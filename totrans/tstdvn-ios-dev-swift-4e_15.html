<html><head></head><body>
		<div><h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor526"/>Chapter 11</em>: Easy Navigation with Coordinators</h1>
			<p>An iOS app is usually a collection of single screens somehow connected to each other. Inexperienced developers often present a view controller from another view controller, because this is easy to implement and it is often shown that way in tutorials and demo code. But, for apps that need to be maintained over a long period of time, we need a pattern that is easier to understand and easier to change.</p>
			<p>The <strong class="bold">coordinator pattern</strong> is very <a id="_idIndexMarker452"/>easy to implement and still manages to decouple the navigation between views of the app from the presentation of the information. In the coordinator pattern, a structure called a coordinator is responsible for navigating between views. View controllers tell the coordinator that the user interacted with the app and the coordinator decides which view controller should become responsible for the screen next.</p>
			<p>As a bonus, the coordinator pattern makes testing navigation code simpler and more robust, and as a result, this pattern is a good fit for <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>).</p>
			<p>The app we are building in this book is a small app with only three screens. The navigation between those three screens can be bundled into one coordinator. In more complicated apps, you would usually use more than one coordinator. To learn more about the coordinator pattern, there are plenty of blog posts on the internet about that topic. You don't need to know anything about that pattern to follow the code in this chapter.</p>
			<p>In this chapter, you will learn how to test and implement the navigation between the different views of an app using the coordinator pattern.</p>
			<p>The chapter is structured as follows:</p>
			<ul>
				<li>Testing the app's setup</li>
				<li>Navigating to the details</li>
				<li>Navigating to a modal view</li>
				<li>Adding missing parts </li>
			</ul>
			<p>Let's start by refactoring the app's setup with the coordinator pattern.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor527"/>Technical requirement</h1>
			<p>The source code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11</a>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor528"/>Testing the app's setup</h1>
			<p>When our app starts, a coordinator should be instantiated and started. This should result in the <a id="_idIndexMarker453"/>presentation of the initial view of our app. Follow these steps to refactor the setup from using a storyboard to using a coordinator: </p>
			<ol>
				<li>Before we can refactor the setup of the app, we need a test that tells us when we break something. Select the <code>AppSetupTests</code>.</li>
				<li>Replace the content of the new class with the following:<pre>// AppSetupTests.swif<a id="_idTextAnchor531"/><a id="_idTextAnchor532"/>t
import XCTest
@testable import ToDo
class AppSetupTests: XCTestCase {
  func test_application_shouldSetupRoot() {
    let application = UIApplication.shared
    let scene = application.connectedScenes.first
    as? UIWindowScene
    let root =
      scene?.windows.first?.rootViewController
    XCTAssert(root is ToDoItemsListViewController)
  }
}</pre></li>
			</ol>
			<p>In this test, we get the <code>rootViewController</code> property of the first window of our app and we check whether it is of the <code>ToDoItemsListViewController</code> type.</p>
			<ol>
				<li value="3">Run the tests <a id="_idIndexMarker454"/>to confirm that all tests pass right now. This test passes because the storyboard is set up in a way that the app starts with an instance of the <code>ToDoItemsListViewController</code> class.</li>
				<li>Go to <code>Main.storyboard</code> and uncheck the checkbox for <code>ToDoItemsListViewController</code> scene in the attribute inspector.</li>
			</ol>
			<div><div><img src="img/Figure_11.01_B18127.jpg" alt="Figure 11.1 – Removing the initial view controller setting from the storyboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Removing the initial view controller setting from the storyboard</p>
			<ol>
				<li value="5">Switch to the <code>ToDoItemsListViewController</code>. With this change, we can instantiate this view controller in the code using this ID.</li>
				<li>Run the tests to confirm that now the last test we added fails. Oh, there is another test that fails. In <code>ToDoItemsListViewControllerTests</code>, all tests fail, because the setup in <code>setUpWithError</code> throws an error. Let's fix this error <a id="_idIndexMarker455"/>before we move on with the setup of our app. <code>ToDoItemsListViewController</code> isn't the initial view controller of the storyboard anymore. This means we need to load it using its ID. Replace <code>setUpWithError()</code> with the following implementation:<pre>// ToDoItemsListViewControllerTests.swift
override func setUpWithError() throws {
  let storyboard = UIStoryboard(name: "Main", bundle:
    nil)
  sut = try XCTUnwrap(
    storyboa<a id="_idTextAnchor535"/><a id="_idTextAnchor536"/>rd.instantiateViewController(
      withIdentifier: "ToDoItemsListViewController")
    as? ToDoItemsListViewController
  )
  toDoItemStoreMock = ToDoItemStoreProtocolMock()
  sut.toDoItemStore = toDoItemStoreMock
  sut.loadViewIfNeeded()
}</pre></li>
				<li>Run all tests again. Now, only our app setup test fails. Good. Let's move on to the implementation.</li>
				<li>Select the <code>AppCoordinator.swift</code>. Replace the content of the new file with the following code:<pre>// AppCoordinator.swi<a id="_idTextAnchor539"/><a id="_idTextAnchor540"/>ft
import UIKit
 
protocol Coordinator {
  func start()
}</pre></li>
			</ol>
			<p>This code defines the <code>Coordinator</code> protocol. This is how I implement the coordinator pattern. In blogs and books of other developers, you might find other implementations. Don't worry, they only differ in their details. When you have worked <a id="_idIndexMarker456"/>a bit with the coordinator pattern, you might develop your own implementation.</p>
			<p>This implementation of the protocol tells us that a coordinator has a <code>start</code> method.</p>
			<ol>
				<li value="9">Add the following implementation of our <code>AppCoordinator</code> in the same file:<pre>// AppCoordinator.sw<a id="_idTextAnchor541"/><a id="_idTextAnchor542"/>ift
class AppCoordinator: Coordinator {
  private let window: UIWindow?
  private let viewController: UIViewController
  init(window: UIWindow?) {
    self.window = window
    let storyboard = UIStoryboard(name: "Main",
      bundle: nil)
    viewController =
      storyboard.instantiateViewController(
      withIdentifier: "ToDoItemsListViewController")
  }
  func start() {
    window?.rootViewController = viewController
  }
}</pre></li>
			</ol>
			<p>In the initializer of <code>AppCoordinator</code>, we store the window that was passed in as a <a id="_idIndexMarker457"/>parameter, and we set up the view of the initial view controller. In the <code>start</code> method, we set the <code>rootViewController</code> property of the window.</p>
			<ol>
				<li value="10">Go to <code>SceneDelegate</code> and add the following property:<pre>// SceneDelegate.s<a id="_idTextAnchor543"/><a id="_idTextAnchor544"/>wift
var appCoordinator: AppCoordinator?</pre></li>
				<li>Next, replace the <code>scene(_:willConnectTo:options:)</code> method with this code:<pre>// SceneDelegate.s<a id="_idTextAnchor545"/><a id="_idTextAnchor546"/>wift
func scene(_ scene: UIScene,
  willConnectTo session: UISceneSession,
  options connectionOptions:
  UIScene.ConnectionOptions)<a id="_idTextAnchor547"/><a id="_idTextAnchor548"/> {
  guard let scene = (scene as? UIWindowScene) else {
    return
  }
  window = UIWindow(windowScene: scene)
  let coordinator = AppCoordinator(
    window: window)
  coordinator.start()
  appCoordinator = coordinator
  window?.makeKeyAndVisible()
}</pre></li>
			</ol>
			<p>In this code, we first set up an instance of the <code>UIWindow</code> class. Next, we instantiate the <code>AppCoordinator</code> instance and call its <code>start</code> method. Finally, we call <code>makeKeyAndVisible</code> on the window to tell <code>UIKit</code> that this window should be presented on the screen.</p>
			<ol>
				<li value="12">Run all <a id="_idIndexMarker458"/>tests to confirm that our refactoring was successful.</li>
			</ol>
			<p>Now, the app works as it did before. When the app starts, an instance of <code>ToDoItemsListViewController</code> is created and shown. But, this is not as it should work in the final app. The list of to-do items needs to be presented on a <code>UINavigationController</code> instance to be able to navigate to the details of a to-do item later.</p>
			<p>Follow these steps to make this change:</p>
			<ol>
				<li value="1">Replace the <code>test_application_shouldSetupRoot()</code> test method with the following implementation:<pre>// AppSetupTests.<a id="_idTextAnchor549"/><a id="_idTextAnchor550"/>swift
func test_application_shouldSetupRoot() throws {
  let application = UIApplication.shared
  let scene = application.connectedScenes.first
  as? UIWindowScene
  let root = scene?.windows.first?.rootViewController
  let nav = try XCTUnwrap(root as?
    UINavigationController)
  XCTAssert(nav.topViewController
    is ToDoItemsListViewController)
}</pre></li>
				<li>Run the <a id="_idIndexMarker459"/>tests to see this test now failing in the line before the <code>XCTAssert</code> call.</li>
				<li>To make this test pass again, we first need a property for the navigation controller in the <code>AppCoordinator</code> class:<pre>// AppCoordinator<a id="_idTextAnchor551"/><a id="_idTextAnchor552"/>.swift
private let navigationController:
  UINavigationController</pre></li>
				<li>Next, we set up the navigation controller in the <code>init</code> method:<pre>// AppCoordinator<a id="_idTextAnchor553"/><a id="_idTextAnchor554"/>.swift
init(window: UI<a id="_idTextAnchor555"/><a id="_idTextAnchor556"/>Window?,
  navigationController: UINavigationController =
  UINavigationController()) {
  self.window = window
  self.navigationController = navigationController
  let storyboard = UIStoryboard(name: "Main", bundle:
    nil)
  viewController =
    storyboard.instantiateViewController(
    withIdentifier: "ToDoItemsListViewController")
}</pre></li>
			</ol>
			<p>We have added the navigation controller as a parameter with a default value to the <code>init</code> call. This will come in handy later when we add tests for the navigation to the details of a to-do item.</p>
			<ol>
				<li value="5">Now, we can <a id="_idIndexMarker460"/>change the <code>start</code> method to add the instance of <code>ToDoItemsListViewController</code> to the navigation stack of the navigation controller:<pre>// AppCoordinato<a id="_idTextAnchor557"/><a id="_idTextAnchor558"/>r.swift
func st<a id="_idTextAnchor559"/><a id="_idTextAnchor560"/>art() {
  navigationController.pushViewController
   (viewController,
    animated: false)
  window?.rootViewController = navigationController
}</pre></li>
			</ol>
			<p>Run the tests to confirm that all tests are now passing again.</p>
			<p>We are not done yet with setting up the list view controller. Remember, the list view controller communicates interactions by the user to a delegate object conforming<a id="_idTextAnchor561"/><a id="_idTextAnchor562"/> to the <code>ToDoItemsListViewControllerProtocol</code> protocol we defined in <a href="B18127_07_ePub.xhtml#_idTextAnchor177"><em class="italic">Chapter 7</em></a>, <em class="italic">Building a Table View Controller for the To-Do Items</em>. Follow these steps to implement this part of the setup:</p>
			<ol>
				<li value="1">Select the <code>AppCoordinatorTests</code>. Remove the two template test methods and add the <code>@testable import ToDo</code> import statement.</li>
				<li>Now, we will <a id="_idIndexMarker461"/>make the <code>AppCoordinator</code> class conform to the <code>ToDoItemsListViewControllerProtocol</code> protocol. Add the following code to <code>AppCoordinator.swift</code>: <pre>// AppCoordinato<a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>r.swift 
extension AppCoordinator:  
  ToDoItemsListViewControllerProtocol { 
 
  func selectToDoItem(_ viewController:
    UIViewController, 
    item: ToDoItem) { 
  } 
}  </pre></li>
			</ol>
			<p>This implementation does nothing yet. We will implement this method in the next section.</p>
			<ol>
				<li value="3">To write a test for assigning the delegate property of the list view controller, we need to access the list view controller in the <code>test</code> method. The view controller property of the <code>AppCoordinator</code> class is private. This means we cannot access it in the test. We could change the access level of the view controller property.</li>
			</ol>
			<p>But for educational reasons, we will do something else. We will pass a navigation controller mock into the <code>init</code> method of the <code>AppCoordinator</code> class and get the initial view controller from that.</p>
			<ol>
				<li value="4">Add a <a id="_idIndexMarker462"/>new Swift class to the <code>NavigationControllerMock</code>. Replace the contents of that new file with the following code: <pre>// NavigationControllerMo<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ck.swift 
import UIKit 
  
class NavigationControllerMock: UINavigationController { 
  var lastPushedViewController: UIViewController? 
  
  override func pushViewController( 
    _ viewController: UIViewController, 
    animated: Bool) {   
      lastPushedViewController = viewController 
      super.pushViewController(viewController, 
        animated: animated) 
    } 
} </pre></li>
			</ol>
			<p>This subclass of the <code>UINavigationController</code> class stores the last pushed view controller for later inspection, and then calls the implementation of the <code>super</code> class.</p>
			<ol>
				<li value="5">Now, we can use this class in the <code>AppCoordinator</code> tests. Add the following properties to <code>AppCoordinatorTests</code>: <pre>// AppCoordinatorTes<a id="_idTextAnchor571"/><a id="_idTextAnchor572"/>ts.swift 
var sut: AppCoordinator! 
var navigationControllerMock: 
NavigationControllerMock! 
var window: UIWindow!</pre></li>
				<li>Replace <a id="_idIndexMarker463"/>the <code>setUpWithError</code> method with the following code: <pre>// AppCoordinatorTe<a id="_idTextAnchor573"/><a id="_idTextAnchor574"/>sts.swift 
override func setUpWithError()<a id="_idTextAnchor575"/><a id="_idTextAnchor576"/> throws { 
  window = UIWindow(frame: CGRect(x: 0, 
    y: 0, 
    width: 200, 
    height: 200)) 
  navigationControllerMock =
    NavigationControllerMock() 
  sut = AppCoordinator( 
    window: window, 
    navigationController: navigationControllerMock) 
} </pre></li>
			</ol>
			<p>In this code, we create a dummy window and an instance of <code>NavigationControllerMock</code>, and use both to initialize an instance of <code>AppCoordinator</code>.</p>
			<ol>
				<li value="7">What we set up for the tests, we have to clean up when the tests are finished. Replace the <code>tearDownWithError</code> method with the following code: <pre>// AppCoordinatorTe<a id="_idTextAnchor577"/><a id="_idTextAnchor578"/>sts.swift 
override func tearDownWithError() throws { 
  sut = nil 
  navigationControllerMock = nil 
  window = nil 
}</pre></li>
				<li>With this preparation, we can add a test to confirm that the <code>start</code> method assigns <a id="_idIndexMarker464"/>the instance of <code>AppCoordinator</code> to the delegate of the list view controller:<pre>// AppCoordinator<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/>Tests.swift
func test_start_shouldSetDelegate() throws {
  sut.start()
  let listViewController = try XCTUnwrap(
    navigationControllerMock.lastPushedViewController
    as? ToDoItemsListViewController)
  XCTAssertIdentical(
    listViewController.delegate as? AppCoordinator,
    sut)
}</pre></li>
			</ol>
			<p>In this test, we call the <code>start</code> method of the <code>AppCoordinator</code> instance and then assert that <code>sut</code> is assigned to the delegate property of the list view controller. We use here the <code>XCTAssertIdentical(_:_:)</code> assert function. As <code>AppCoordinator</code> is a class, we can check in the test whether the delegate is identical to <code>sut</code>. This assert function compares the pointer address of the two items, and the test passe<a id="_idTextAnchor581"/><a id="_idTextAnchor582"/>s when both references are the same. This does not work with value types because they are copied when assigned (or rather when changed).</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="9">To make this test pass, add the following code to the end of the <code>start</code> method in <code>AppCoordinator</code>:<pre>// AppCoordi<a id="_idTextAnchor583"/><a id="_idTextAnchor584"/>nator.swift
if let listViewController =
  viewController as? ToDoItemsListViewController {
  listViewController.delegate = self
}</pre></li>
			</ol>
			<p>Run the tests to confirm that this addition makes the test pass.</p>
			<p><code>ToDoItemsListViewController</code> shows the to-do items it gets from an instance of <code>ToDoItemStore</code>. We need to provide the list view controller with an item store when it is set up. Follow these steps to add the item store to the list view controller:</p>
			<ol>
				<li value="1">Add the <a id="_idIndexMarker465"/>following test to <code>AppCoordinatorTests</code>:<pre>// AppCoordinato<a id="_idTextAnchor585"/><a id="_idTextAnchor586"/>rTests.swift
func test_start_shouldAssignItemStore() throws {
  sut.start()
  let listViewController = try XCTUnwrap(
    navigationControllerMock.lastPushedViewController
    as? ToDoItemsListViewController)
  XCTAssertNotNil(listViewController.toDoItemStore)
}</pre></li>
			</ol>
			<p>In this test, we assert that the <code>toDoItemStore</code> property of the list view controller is not nil. Run the tests to confirm that this test fails.</p>
			<ol>
				<li value="2">Let's make this test pass. Add the following property to <code>AppCoordinator</code>:<pre>// AppCoord<a id="_idTextAnchor587"/><a id="_idTextAnchor588"/>inator.swift
let toDoItemStore: ToDoItemStore</pre></li>
				<li>Assign this property in the <code>init</code> method with a new instance:<pre>// AppCoord<a id="_idTextAnchor589"/><a id="_idTextAnchor590"/>inator.swift
toDoItemStore = ToDoItemStore()</pre></li>
				<li>Now, assign <a id="_idIndexMarker466"/>this property to the property of the list view controller within the <code>if let</code> statement of the <code>start</code> method:<pre>// AppCoordinator.swift
func start() {
  navigationController.pushViewController
    (viewController,
     animated: false)
  window?.rootViewController = navigationController
  if let listViewController =
      viewController as? ToDoItemsListViewController {
    listViewController.delegate = self
    listViewController.toDoItemStore = toDoItemStore
  }
}</pre></li>
			</ol>
			<p>Run the tests to confirm that all tests now pass.</p>
			<p>The setup of the coordinator and the initial view controller is now complete. We can move on to implementing the interaction of the list view controller with the app coordinator.</p>
			<p>When the <a id="_idIndexMarker467"/>user taps a table view cell with a to-do item, the app should navigate to the details of that item. In the following section, we will implement this feature.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor591"/>Navigating to the details</h1>
			<p>We will <a id="_idIndexMarker468"/>implement the navigation within the app using <a id="_idIndexMarker469"/>the <code>AppCoordinator</code> class. Follow these steps to implement navigation to the details of to-do items:</p>
			<ol>
				<li value="1">Add the following test method to <code>AppCoordinatorTests</code>:<pre>// AppCoordi<a id="_idTextAnchor592"/><a id="_idTextAnchor593"/>natorTests.swift
func test_selectToDoItem_pushesDetails() throws {
  let dummyViewController = UIViewController()
  let item = ToDoItem(title: "dummy title")
  sut.selectToDoItem(dummyViewController, item: item)
  let detail = try XCTUnwrap(
    navigationControllerMock.lastPushedViewController
    as? ToDoItemDetailsViewController)
  XCTAssertEqual(detail.toDoItem, item)
}</pre></li>
			</ol>
			<p>In this test, we execute the <code>delegate</code> method and assert that an instance of <code>ToDoItemDetailsViewController</code> is pushed to the navigation stack, and that its <code>toDoItem</code> is the item we used in the <code>delegate</code> method call.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="2">Replace <a id="_idIndexMarker470"/>the implementation of <code>selectToDoItem(_:item:)</code> with <a id="_idIndexMarker471"/>this implementation: <pre>// AppCoordinator.swift 
func selectToDoItem(_ viewController:
  UIViewController, 
  it<a id="_idTextAnchor594"/><a id="_idTextAnchor595"/>em: ToDoItem) { 
 
  let storyboard = UIStoryboard(name: "Main", bundle:
    nil) 
  guard let next =
    storyboard.instantiateViewController( 
    withIdentifier: "ToDoItemDetailsViewController") 
      as? ToDoItemDetailsViewController else { 
            return 
          } 
 
  next.loadViewIfNeeded() 
  next.toDoItem = item 
 
  navigationController.pushViewController(next, 
    animated: true) 
} </pre></li>
			</ol>
			<p>In this code, we instantiate an instance of <code>ToDoItemDetailsViewController</code> from the storyboard and set it up with the to-do item passed into the method. Then we push the new view controller onto the navigation stack. </p>
			<p>Run the tests to confirm that all tests now pass again.</p>
			<ol>
				<li value="3">The details <a id="_idIndexMarker472"/>view controller needs a reference <a id="_idIndexMarker473"/>to <code>toDoItemStore</code> because the user can change the status of the item to <code>done</code> in the details view. Add the following test to <code>AppCoordinatorTests</code>:<pre>// AppCo<a id="_idTextAnchor596"/><a id="_idTextAnchor597"/>ordinatorTests.swift
func test_selectToDoItem_shouldSetItemStore() throws {
  let dummyViewController = UIViewController()
  let item = ToDoItem(title: "dummy title")
  sut.selectToDoItem(dummyViewController, item: item)
  let detail = try XCTUnwrap(
    navigationControllerMock.lastPushedViewController
    as? ToDoItemDetailsViewController)
  XCTAssertIdentical(
    detail.toDoItemStore as? ToDoItemStore,
    sut.toDoItemStore)
}</pre></li>
			</ol>
			<p>This test looks like the previous one. We only changed the assert function call to check whether the <code>toDoItemStore</code> property is identical to the <code>sut</code> property.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="4">To make this test pass, assign the <code>toDoItemStore</code> property below the line we assigned the <code>toDoItem</code> property:<pre>// AppCoordinator.swift
next.loadViewIfNeeded()
next.toDoItem = item
next.toDoItemStore = toDoItemStore</pre></li>
			</ol>
			<p>Run the tests to confirm that all tests pass.</p>
			<p>When the <a id="_idIndexMarker474"/>user selects a cell with a to-do item, our app now <a id="_idIndexMarker475"/>shows the details of that item on the screen. There is one feature missing. The app needs to allow the input of new to-do items. We will implement the presentation of the input view from the list view in the next section.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor598"/>Navigating to a modal view</h1>
			<p>Normally, testing the presentation of a modal view controller is quite complicated. If you search <a id="_idIndexMarker476"/>how to do that on the internet, you will find that the common solutions work by swizzling the <code>present(_:animated:completion:)</code> method defined in the <code>UIViewController</code> class. Swizzling is quite complicated, and I will not show in this book how this is done.</p>
			<p>But, because we are using the coordinator pattern for the navigation in our app, we can test the presentation without the need to swizzle any method. Still, you should look up how to swizzle methods because sometimes you don't have the option to use the coordinator pattern; for example, when there is already all the navigation code implemented and you are not allowed to change it.</p>
			<p>Follow these steps to implement the presentation of the input view when the user chooses to add a new to-do item:</p>
			<ol>
				<li value="1">The app needs a button in the user interface that the user can tap to add a to-do item. When the user taps that button, the list view controller should tell its delegate about it. Add the following method definition to <code>ToDoItemsListViewControllerProtocol</code>:<pre>// ToDoItemsL<a id="_idTextAnchor599"/><a id="_idTextAnchor600"/>istViewController.swift
func addToDoItem(
  _ viewController: UIViewController)</pre></li>
				<li>To make <a id="_idIndexMarker477"/>the compiler happy, add the following empty method implementation to <code>AppCoordinator</code>:<a id="_idTextAnchor601"/><a id="_idTextAnchor602"/><pre>// AppCoordinator.swift
func addToDoItem(_ viewController: UIViewController) {
}</pre></li>
				<li>We have another class that conforms to the <code>ToDoItemsListViewControllerProtocol</code> protocol. Add the following code to the end of the <code>ToDoItemsListViewControllerProtocolMock</code> class:<pre>// ToDoItemsListViewCont<a id="_idTextAnchor603"/><a id="_idTextAnchor604"/>roll<a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>erProtocolMock.swift
var addTo<a id="_idTextAnchor607"/><a id="_idTextAnchor608"/>DoItemCallCount = 0
func addToDoItem(_ viewController: UIViewController) {
  addToDoItemCallCount += 1
}</pre></li>
			</ol>
			<p>The mock object counts the number of calls of the <code>addToDoItem(_:)</code> method.</p>
			<ol>
				<li value="4">Next, we need a view controller mock that catches the last presented view controller. Select the <code>ViewControllerMock.swift</code>. Replace its content with the following code:<pre>// <a id="_idTextAnchor611"/><a id="_idTextAnchor612"/>ViewController<a id="_idTextAnchor613"/><a id="_idTextAnchor614"/>Mock.swift
import UIKit
class ViewControllerMock: UIViewController {
  var lastPresented: UIViewController?
  override func present(
    _ viewControllerToPresent: UIViewController,
    animated flag: Bool,
    completion: (() -&gt; Void)? = nil) {
    lastPresented = viewControllerToPresent
    super.present(viewControllerToPresent,
      animated: flag,
      completion: completion)
  }
}</pre></li>
			</ol>
			<p>This mock stores the presented view controller in a property for later inspection.</p>
			<ol>
				<li value="5">Now, we can <a id="_idIndexMarker478"/>write the test. Import <code>SwiftUI</code> to <code>AppCoordinatorTests.swift</code> and add the following test method to <code>AppCoordinatorTests</code>:<pre>// <a id="_idTextAnchor615"/><a id="_idTextAnchor616"/>AppCoordinatorTests.swift
func test_addToDoItem_shouldPresentInputView() throws
 {
  let viewControllerMock = ViewControllerMock()
  sut.addToDoItem(viewControllerMock)
  let lastPresented = try XCTUnwrap(
    viewControllerMock.lastPresented
    as? UIHostingController&lt;ToDoItemInputView&gt;)
  XCTAssertIdentical(
    lastPresented.rootView.delegate as?
    AppCoordinator,
    sut)
}</pre></li>
			</ol>
			<p>This test calls <code>addToDoItem(_:)</code> and asserts that the <code>sut</code> variable is assigned as the delegate of the presented instance of <code>ToDoItemInputView</code>.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="6">To make <a id="_idIndexMarker479"/>this test pass, import <code>SwiftUI</code> into <code>AppCoordinator.swift</code> and replace the implementation of <code>addToDoItem(_:)</code> with the following code:<pre>// AppCoordinator.swift
func addToDoItem(_ viewContr<a id="_idTextAnchor617"/><a id="_idTextAnchor618"/>oller: UIViewController) {
  let data = ToDoItemData()
  let next = UIHostingController(
    rootView: ToDoItemInputView(data: data,
      apiClient: APIClient(),
      delegate: self))
  viewController.present(next, animated: true)
}</pre></li>
			</ol>
			<p>Xcode shows an error; we will fix this error in the next step. This code instantiates an instance of <code>UIHostingController</code> with a root view of <code>ToDoItemInputView</code>. This is how we can present a <code>SwiftUI</code> view from a <code>UIKit</code> environment.</p>
			<ol>
				<li value="7">To make this code compile, add the following extension to <code>AppCoordinator.swif<a id="_idTextAnchor619"/><a id="_idTextAnchor620"/>t</code>:<pre>// AppCoordinator.swift
extension AppCoordinator: ToDoItemInputViewDelegate {
  func addToDoItem(with: ToDoItemData,
    coordinate: Coordinate?) {
  }
}</pre></li>
			</ol>
			<p>Run the <a id="_idIndexMarker480"/>tests to confirm that all tests now pass.</p>
			<p>One part of this feature is finished. Next, we need to implement the other part in the <code>ToDoItemsListViewController</code> class.</p>
			<ol>
				<li value="8">Add the following test method to <code>ToDoItemsListViewControllerTests</code>:<pre>// ToDoItemsLi<a id="_idTextAnchor621"/><a id="_idTextAnchor622"/>stViewControllerTests.swift
func test_navigationBarButton_shouldCallDelegate()
 throws {
  let delegateMock =
  ToDoItemsListViewControllerProtocolMock()
  sut.delegate = delegateMock
  let addButton =
    sut.navigationItem.rightBarButtonItem
  let target = try XCTUnwrap(addButton?.target)
  let action = try XCTUnwrap(addButton?.action)
  _ = target.perform(action, with: addButton)
  <a id="_idTextAnchor623"/><a id="_idTextAnchor624"/>XCTAssertEqual(delegateMock.addToDoItemCallCount, 1)
}</pre></li>
			</ol>
			<p>In this test, we get the right bar button item of the <code>sut</code> variable and call its action on its target. This should result in a call to the <code>addToDoItem(_:)</code> method of the delegate.</p>
			<p>Run the tests and confirm that this new test fails.</p>
			<ol>
				<li value="9">Add the <a id="_idIndexMarker481"/>following code to the end of <code>viewDidLoad()</code> of <code>ToDoItemsListViewController</code>:<pre>// ToDoI<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/>temsListViewController.swift
let addItem = UIBarButtonItem(barButtonSystemItem:
  .add,
  target: self,
  action: #selector(add(_:)))
navigationItem.rightBarButtonItem = addItem</pre></li>
			</ol>
			<p>With this code, we add a bar button to the navigation item of the <code>ToDoItemsListViewController</code> instance. This results in a bar button that is added to the navigation bar of the navigation controller that hosts <code>ToDoItemsListViewController</code>.</p>
			<ol>
				<li value="10">Now, add the following method to <code>ToDoItemsListViewController</code>:<pre>// ToDoI<a id="_idTextAnchor627"/><a id="_idTextAnchor628"/>temsListViewController.swift
@objc func add(_ sender: UIBarButtonItem) {
}</pre></li>
			</ol>
			<p>For now, we let the implementation of this method empty because we want to see the test fail in the assert function call. Run the tests and confirm that the test we added last now fails in the assert call.</p>
			<ol>
				<li value="11">To make <a id="_idIndexMarker482"/>the test pass, add the missing code in <code>add(_:)</code>:<pre>// ToDo<a id="_idTextAnchor629"/><a id="_idTextAnchor630"/>ItemsListViewController.swift
@objc func add(_ sender: UIBarButtonItem) {
  delegate?.addToDoItem(self)
} </pre></li>
			</ol>
			<p>Run the tests to confirm that all tests now pass.</p>
			<p>We already know that <code>ToDoItemInputView</code> calls its delegate when the user selects the <code>add(_:)</code> method of <code>ToDoItemStore</code>. Take the following steps to implement this feature.</p>
			<ol>
				<li value="12">Add the following test to <code>AppCoordinatorTests</code>:<a id="_idTextAnchor631"/><a id="_idTextAnchor632"/><pre>// AppCoordinatorTests.swift
func test_addToDoItemWith_shouldCallToDoItemStore()
 throws {
  let toDoItemData = ToDoItemData()
  toDoItemData.title = "dummy title"
  let receivedItems =
  try wait(for: sut.toDoItemStore.itemPublisher,
    afterChange: {
    sut.addToDoItem(with: toDoItemData, coordinate:
      nil)
  })
  XCTAssertEqual(receivedItems.first?.title, 
    toDoItemData.title)
}</pre></li>
			</ol>
			<p>This test asserts that, after calling <code>addToDoItem(with:coordinate:)</code>, now <code>itemPublisher</code> of the <code>toDoItemStore</code> property publishes the change to the stored items.</p>
			<ol>
				<li value="13">As we <a id="_idIndexMarker483"/>are adding a to-do item to the item store, we need to replace <code>doToItemStore</code> in <code>AppCoordinator</code> with a test store. Otherwise, the test could fail because of items added to the store in other tests or while we test the app on the simulator. </li>
				<li>Replace the <code>init</code> method of the <code>AppCoordinator</code> class with the following implement<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/>ation:<pre>// AppCoordinator.swift
init(window: UIWindow?,
 navigationController: UINavigationController =
     UINavigationController(),
     toDoItemStore: ToDoItemStore = ToDoItemStore()) {
  self.window = window
  self.navigationController = navigationController
  self.toDoItemStore = toDoItemStore
  let storyboard = UIStoryboard(name: "Main", bundle:
    nil)
  viewController = 
    storyboard.instantiateViewController(
    withIdentifier: "ToDoItemsListViewController")
}</pre></li>
			</ol>
			<p>Here, we have added the <code>toDoItemStore</code> parameter to the method and we use that parameter to set the <code>toDoItemStore</code> property used in the <code>AppCoordinator</code> class.</p>
			<ol>
				<li value="15">So, we can <a id="_idIndexMarker484"/>use a test store when setting up <code>sut</code> in <code>setUpWithErro<a id="_idTextAnchor635"/><a id="_idTextAnchor636"/>r</code>:<pre>// AppCoordinatorTests.swift
override func setUpWithError() throws {
  window = UIWindow(frame: CGRect(x: 0,
    y: 0,
    width: 200,
    height: 200))
  navigationControllerMock =
    NavigationControllerMock()
  sut = AppCoordinator(
    window: window,
    navigationController: navigationControllerMock,
    toDoItemStore: ToDoItemStore(fileName:
      "dummy_store"))
}</pre></li>
				<li>To delete the item store when the test is finished, add the following code to the end of <code>tearDownWithError</code> of <code>AppCoordinatorTest<a id="_idTextAnchor637"/><a id="_idTextAnchor638"/>s</code>:<pre>// AppCoordinatorTests.swift
let url = FileManager.default
  .documentsURL(name: "dummy_store")
try? FileManager.default.removeItem(at: url)</pre></li>
			</ol>
			<p>This code should look familiar, as we already used it in <code>ToDoItemStoreTests</code>.</p>
			<p>Run the tests to confirm that the new test fails.</p>
			<ol>
				<li value="17">Make the <a id="_idIndexMarker485"/>test pass with the following implementation of <code>addToDoItem(with:coord<a id="_idTextAnchor639"/><a id="_idTextAnchor640"/>inate:)</code>:<pre>// AppCoordinator.swift
func addToDoItem(with item: ToDoItemData,
  coordinate: Coordinate?) {
  let location = Location(name: item.locationName,
    coordinate: coordinate)
  let toDoItem = ToDoItem(
    title: item.title,
    itemDescription: item.itemDescription,
    timestamp: item.date.timeIntervalSince1970,
    location: location)
  toDoItemStore.add(toDoItem)
}</pre></li>
			</ol>
			<p>Note that we added an internal parameter name of <code>item</code> for the first parameter of that method.</p>
			<p>In this code, we create an instance of <code>ToDoItem</code> from the <code>ToDoItemData</code> structure. Then, we call the <code>add(_:)</code> method of <code>toDoItemStore</code>.</p>
			<p>Run the <a id="_idIndexMarker486"/>tests to confirm that this change makes all tests pass again.</p>
			<p>For now, we are done with the implementation. Let's make the app work in the simulator and see whether we missed something.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor641"/>Adding missing parts</h1>
			<p>First, let's run <a id="_idIndexMarker487"/>the app for the first time to see where we are.</p>
			<p>The app starts with a blank screen with just one plus (<strong class="bold">+</strong>) button in the upper-right corner.</p>
			<div><div><img src="img/Figure_11.02_B18127.jpg" alt="Figure 11.2 – The initial view of our app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – The initial view of our app</p>
			<p>So, there is <a id="_idIndexMarker488"/>work to do here. But, let's move on and tap the plus (<strong class="bold">+</strong>) button. We are presented with the input view. We can add data for the item and tap the <strong class="bold">Save</strong> button.</p>
			<div><div><img src="img/Figure_11.03_B18127.jpg" alt="Figure 11.3 – The input view of our app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – The input view of our app</p>
			<p>But, when <a id="_idIndexMarker489"/>we tap the <strong class="bold">Save</strong> button, nothing happens. Dismiss the view by swiping down, and see whether the item was added. Something changed. There is a blank table view cell visible in the middle of the screen.</p>
			<div><div><img src="img/Figure_11.04_B18127.jpg" alt="Figure 11.4 – A blank table view cell. Where is the to-do item?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – A blank table view cell. Where is the to-do item?</p>
			<p>When you <a id="_idIndexMarker490"/>tap the blank table view cell, the detail view is pushed onto the screen.</p>
			<div><div><img src="img/Figure_11.05_B18127.jpg" alt="Figure 11.5 – The details of the to-do item. But, where is the due date?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – The details of the to-do item. But, where is the due date?</p>
			<p>Okay, we have <a id="_idIndexMarker491"/>some work to do. Let's go back to Xcode and fix some problems.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor642"/>Making the cells visible</h2>
			<p>The table view <a id="_idIndexMarker492"/>doesn't show the information of the to-do items. The reason is, we didn't add constraints to the views when we added the labels. This was on purpose because I believe you should not write unit tests to test the position and size of interface elements. UI tests of snapshot tests are a better tool for these kinds of tests.</p>
			<p>Follow these steps to fix the layout of the cells and the table view:</p>
			<ol>
				<li value="1">Open <code>Main.storyboard</code> in <code>0</code> and click <strong class="bold">Add 4 Constraints</strong>.</li>
			</ol>
			<div><div><img src="img/Figure_11.06_B18127.jpg" alt="Figure 11.6 – The constraints for the table view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – The constraints for the table view</p>
			<ol>
				<li value="2">Next, go to <code>ToDoItemCell</code>, and <a id="_idIndexMarker494"/>replace the <code>init</code> method with the following i<a id="_idTextAnchor643"/><a id="_idTextAnchor644"/>mplementation:<pre>// ToDoItemCell.swift
override init(style: UITableViewCell.CellStyle,
  reuseIdentifier: String?) {
  titleLabel = UILabel()
  dateLabel = UILabel()
  dateLabel.textAlignment = .right
  locationLabel = UILabel()
  let titleLocation = UIStackView(
    arrangedSubviews: [titleLabel, locationLabel])
  titleLocation.axis = .vertical
  let stackView = UIStackView(
    arrangedSubviews: [titleLocation, dateLabel])
  stackView
    .translatesAutoresizingMaskIntoConstraints = false
  super.init(style: style,
    reuseIdentifier: reuseIdentifier)
  contentView.addSubview(stackView)
  NSLayoutConstraint.activate([
   stackView.topAnchor.constraint(
      equalTo: contentView.topAnchor, constant: 5),
   stackView.leadingAnchor.constraint(
    equalTo: contentView.leadingAnchor, constant: 16),
   stackView.bottomAnchor.constraint(
    equalTo: contentView.bottomAnchor, constant: -5),
   stackView.trailingAnchor.constraint(
    equalTo: contentView.trailingAnchor, constant: -
    16),
  ])
}</pre></li>
			</ol>
			<p>We use <code>UIStackView</code> instances to lay out the elements. Run the tests to confirm that we didn't break anything. Then, run the app again on the simulator.</p>
			<p>It looks better, but the <a id="_idIndexMarker495"/>due date is still missing in the table view cell. The reason is that we didn't set up the <code>dateFormatter</code> instance currently. We found a bug. Whenever we find a bug, we should try to write a test that fails because of that bug. Then, we should make the test pass by fixing the bug.</p>
			<ol>
				<li value="3">Add the following test method to <code>ToDoItemsListViewControllerTests</code>:<pre>// T<a id="_idTextAnchor645"/><a id="_idTextAnchor646"/>oDoItemsListViewControllerTests.swift
func test_dateFormatter_shouldNotBeNone() {
  XCTAssertNotEqual(sut.dateFormatter.dateStyle,
    .none)
}</pre></li>
			</ol>
			<p>Note that the <code>XCTAssertNotEqual</code> assert function does the opposite of the <code>XCTAssertEqual</code> function. It passes when the two values are not equal.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="4">To make this test pass and the bug disappear, add these lines to <code>viewDidLoad</code> below the <code>super.viewDidLoad()</code> line:<pre>// ToDoItemsListView<a id="_idTextAnchor647"/><a id="_idTextAnchor648"/>Controller.swift
super.viewDidLoad()
dateFormatter.dateStyle = .short</pre></li>
				<li>Run the tests <a id="_idIndexMarker496"/>to confirm that this makes the test green. Then, run the app on the simulator. Woohoo! We fixed our first bug with the help of TDD. This is a milestone. We are now sure that this bug won't come back as long as this test is run regularly.</li>
			</ol>
			<p>Next, we need to fix the bug that the input view is not dismissed when the user taps the <strong class="bold">Save</strong> button.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor649"/>Dismissing the input view</h2>
			<p>Again, we <a id="_idIndexMarker497"/>have a bug. Let's see whether we can write a test for that bug. Follow these steps to fix the bug:</p>
			<ol>
				<li value="1">The navigation controller mock should register if <code>dismiss(animated:completion:)</code> got called. This way, we can make sure that it is called when a new item is added. Add the following code to <code>NavigationController<a id="_idTextAnchor650"/><a id="_idTextAnchor651"/>Mock</code>:<pre>// NavigationControllerMock.swift
var dismissCallCount = 0
override func dismiss(animated flag: Bool,
  completion: (() -&gt; Void)? = nil) {
  dismissCallCount += 1
  super.dismiss(animated: flag,
     completion: completion)
}</pre></li>
			</ol>
			<p>This code counts the times <code>dismiss(animated:completion:)</code> got called.</p>
			<ol>
				<li value="2">Add the <a id="_idIndexMarker498"/>following test method to <code>AppCoordi<a id="_idTextAnchor652"/><a id="_idTextAnchor653"/>natorTests</code>:<pre>// AppCoordinatorTests.swift
func test_addToDoItemWith_shouldDismissInput() {
  let toDoItemData = ToDoItemData()
  toDoItemData.title = "dummy title"
  sut.addToDoItem(with: toDoItemData,
    coordinate: nil)
  XCTAssertEqual(
    navigationControllerMock.dismissCallCount, 1)
}</pre></li>
			</ol>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="3">Add the following code to the end of <code>addToDoItem(with:co<a id="_idTextAnchor654"/><a id="_idTextAnchor655"/>ordinate:)</code>:<pre>// AppCoordinatorTests.swift
navigationController.dismiss(animated: true)</pre></li>
			</ol>
			<p>Run the tests to confirm that this code makes all tests pass again. Then, run the app and add a new to-do item. </p>
			<p>We fixed <a id="_idIndexMarker499"/>another bug using TDD.</p>
			<p>Next, let's fix the bug in the details that the due date isn't shown.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor656"/>Making the due date visible in the details</h2>
			<p>The reason <a id="_idIndexMarker500"/>that the date is not shown in the details is the same as for the table view cell. The date formatter isn't set up correctly. You already know how to write a test for this. Write the test and make sure that the test fails.</p>
			<p>To make the test pass and, therefore, fix the bug, you can use this definition of the <code>dateFormatter</code> proper<a id="_idTextAnchor657"/><a id="_idTextAnchor658"/>ty:</p>
			<pre>// ToDoItemDetailsViewController.swift
let dateFormatter: DateFormatter = {
  let formatter = DateFormatter()
  formatter.dateStyle = .short
  return formatter
}()</pre>
			<p>This should make your test pass.</p>
			<p>Run the app again, and play around with it. You might realize some more bugs. Here is what I found:</p>
			<ul>
				<li>When the user taps the <strong class="bold">Done</strong> button in the details, the app should pop back to the list of to-do items.</li>
				<li>The section headers are missing in the table view. The done items are correctly moved to the second section, but it's not visible in the user interface that there are several sections.</li>
				<li>When the user marks the first item done, the order in the table view changes. If the user then selects the first item in the table view, the details for the other item are shown.</li>
				<li>The cell stays selected even after the user came back from the details.</li>
				<li>The debug console shows a warning that the table view was told to lay out the cells when it is not visible.</li>
			</ul>
			<p>We sure <a id="_idIndexMarker501"/>found some more bugs.</p>
			<p>In the following sections, we will fix only the third and the fifth bug in this list. The other bugs are left as an exercise for you. If you get stuck, have a look at the code for this chapter on GitHub.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor659"/>Fixing the wrong item being selected</h2>
			<p>Again, let's try <a id="_idIndexMarker502"/>to write a test for this bug before we try to fix it. Follow these steps to fix that bug:</p>
			<ol>
				<li value="1">The problem is that we set up the sections when we create the snapshot for the diffable data source, but we ignore the section when the user selects a table view row. We can change the <code>test_didSelectCellAt_shouldCallDelegate</code> method to check for this error. Replace the implementation of that test method with the following c<a id="_idTextAnchor660"/><a id="_idTextAnchor661"/>ode:<pre>// ToDoItemsListViewControllerTests.swift
func test_didSelectCellAt_shouldCallDelegate() throws
 {
  let delegateMock =
    ToDoItemsListViewControllerProtocolMock()
  sut.delegate = delegateMock
  var doneItem = ToDoItem(title: "done item")
  doneItem.done = true
  let toDoItem = ToDoItem(title: "to-do item")
  toDoItemStoreMock.itemPublisher
    .send([doneItem, toDoItem])
  let tableView = try XCTUnwrap(sut.tableView)
  let indexPath = IndexPath(row: 0, section: 0)
  tableView.delegate?.tableView?(
    tableView,
    didSelectRowAt: indexPath)
  XCTAssertEqual(
   delegateMock.selectToDoItemReceivedArguments?.item,
    toDoItem)
}</pre></li>
			</ol>
			<p>We change <a id="_idIndexMarker503"/>the test to use two items, one done item and one item that is not done yet.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="2">To make the test pass and thus fix the bug, replace the implementation of <code>tableView(_:didSelectRowAt:)</code> with the follo<a id="_idTextAnchor662"/><a id="_idTextAnchor663"/>wing code:<pre>// ToDoItemsListViewController.swift
func tableView(_ tableView: UITableView,
  didSelectRowAt indexPath: IndexPath) {
  let item: ToDoItem
  switch indexPath.section {
    case 0:
      let filteredItems = items.filter({ false ==
        $0.done })
      item = filteredItems[indexPath.row]
    default:
      let filteredItems = items.filter({ true ==
        $0.done })
      item = filteredItems[indexPath.row]
  }
  delegate?.selectToDoItem(self, item: item)
}</pre></li>
			</ol>
			<p>In this <a id="_idIndexMarker504"/>implementation, we respect the two sections and choose the item to be shown accordingly.</p>
			<p>Run all tests to confirm that all tests now pass.</p>
			<p>And, with this last bug fixed, we are done with the first simple version of our little app that we created using TDD.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor664"/>Fixing the layout of the table view</h2>
			<p>The problem here is that we use the <code>Combine</code> framework to update the table view. When the <a id="_idIndexMarker505"/>user taps the <code>doToItemStore</code> updates its items and tells the table view about it. This results in an update of the table view when it is not visible on the screen. This is easy to fix and we don't even need a test for this. Add the following code to <code>ToDoItemsListViewCont<a id="_idTextAnchor665"/><a id="_idTextAnchor666"/>roller</code>:</p>
			<pre>// ToDoItemsListViewController.swift
override func viewDidAppear(_ animat<a id="_idTextAnchor667"/><a id="_idTextAnchor668"/>ed: Bool) {
  super.viewDidAppear(animated)
  token = toDoItemStore?.itemPublisher
    .sink(receiveValue: { [weak self] items in
      self?.items = items
      self?.update(with: items)
    })
}
override func viewWillDisappear(_ animated: Bool) {
  super.viewWillDisappear(animated)
  token?.cancel()
}</pre>
			<p>When the <a id="_idIndexMarker506"/>view with the table view disappears, we unsubscribe from <code>itemsPublisher</code>. When the view appears on the screen, we subscribe again. Run the app again in the simulator and have a look at the console to see whether the message is gone.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor669"/>Summary</h1>
			<p>In this final chapter, we have implemented the navigation between the different views of our app. We have learned how to test pushing view controllers onto a navigation stack and how we can test whether a view got presented modally.</p>
			<p>With navigation implemented, we started the app on the simulator and found and fixed bugs. We figured out that TDD even helps when fixing bugs. By writing first a failing test for that bug and then making the test pass, we ensured that this bug won't hurt us in the future of our app.</p>
			<p>With the skills you gained in this chapter, you will be able to implement and test the navigation of an app using the coordinator pattern. And, you are now able to write tests for bugs and fix the bug by making the test pass.</p>
			<p>Congratulations, you reached the end of this book! My hope is that this book is the beginning of your journey to becoming a test-driven developer. You learned how to test <code>Combine</code> code and write tests for view controllers and views, table views, and even SwiftUI code. I believe this is a good foundation for your next steps. Try to add tests to your existing projects and talk to your colleagues about the advantages and disadvantages of unit tests and TDD. Find your own testing style.</p>
			<p>Most importantly, have fun!</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor670"/>Exercises</h1>
			<ol>
				<li value="1">Fix the bugs you found while testing the app on the simulator.</li>
				<li>Add the feature that the user can check to-do items in the list of all to-do items.</li>
				<li>Write a review for this book on Amazon.</li>
			</ol>
		</div>
	</body></html>