<html><head></head><body>
		<div id="_idContainer083">
			<h1 id="_idParaDest-150"><em class="italic"><a id="_idTextAnchor526"/>Chapter 11</em>: Easy Navigation with Coordinators</h1>
			<p>An iOS app is usually a collection of single screens somehow connected to each other. Inexperienced developers often present a view controller from another view controller, because this is easy to implement and it is often shown that way in tutorials and demo code. But, for apps that need to be maintained over a long period of time, we need a pattern that is easier to understand and easier to change.</p>
			<p>The <strong class="bold">coordinator pattern</strong> is very <a id="_idIndexMarker452"/>easy to implement and still manages to decouple the navigation between views of the app from the presentation of the information. In the coordinator pattern, a structure called a coordinator is responsible for navigating between views. View controllers tell the coordinator that the user interacted with the app and the coordinator decides which view controller should become responsible for the screen next.</p>
			<p>As a bonus, the coordinator pattern makes testing navigation code simpler and more robust, and as a result, this pattern is a good fit for <strong class="bold">test-driven development</strong> (<strong class="bold">TDD</strong>).</p>
			<p>The app we are building in this book is a small app with only three screens. The navigation between those three screens can be bundled into one coordinator. In more complicated apps, you would usually use more than one coordinator. To learn more about the coordinator pattern, there are plenty of blog posts on the internet about that topic. You don't need to know anything about that pattern to follow the code in this chapter.</p>
			<p>In this chapter, you will learn how to test and implement the navigation between the different views of an app using the coordinator pattern.</p>
			<p>The chapter is structured as follows:</p>
			<ul>
				<li>Testing the app's setup</li>
				<li>Navigating to the details</li>
				<li>Navigating to a modal view</li>
				<li>Adding missing parts </li>
			</ul>
			<p>Let's start by refactoring the app's setup with the coordinator pattern.</p>
			<h1 id="_idParaDest-151"><a id="_idTextAnchor527"/>Technical requirement</h1>
			<p>The source code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11">https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter11</a>.</p>
			<h1 id="_idParaDest-152"><a id="_idTextAnchor528"/>Testing the app's setup</h1>
			<p>When our app starts, a coordinator should be instantiated and started. This should result in the <a id="_idIndexMarker453"/>presentation of the initial view of our app. Follow these steps to refactor the setup from using a storyboard to using a coordinator: </p>
			<ol>
				<li>Before we can refactor the setup of the app, we need a test that tells us when we break something. Select the <strong class="bold">ToDoTests</strong> group in the project navigator and add a new <strong class="bold">Unit Test Case Class</strong> instance with the nam<a id="_idTextAnchor529"/><a id="_idTextAnchor530"/>e <strong class="source-inline">AppSetupTests</strong>.</li>
				<li>Replace the content of the new class with the following:<p class="source-code">// AppSetupTests.swif<a id="_idTextAnchor531"/><a id="_idTextAnchor532"/>t</p><p class="source-code">import XCTest</p><p class="source-code">@testable import ToDo</p><p class="source-code">class AppSetupTests: XCTestCase {</p><p class="source-code">  func test_application_shouldSetupRoot() {</p><p class="source-code">    let application = UIApplication.shared</p><p class="source-code">    let scene = application.connectedScenes.first</p><p class="source-code">    as? UIWindowScene</p><p class="source-code">    let root =</p><p class="source-code">      scene?.windows.first?.rootViewController</p><p class="source-code">    XCTAssert(root is ToDoItemsListViewController)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we get the <strong class="source-inline">rootViewController</strong> property of the first window of our app and we check whether it is of the <strong class="source-inline">ToDoItemsListViewController</strong> type.</p>
			<ol>
				<li value="3">Run the tests <a id="_idIndexMarker454"/>to confirm that all tests pass right now. This test passes because the storyboard is set up in a way that the app starts with an instance of the <strong class="source-inline">ToDoItemsListViewController</strong> class.</li>
				<li>Go to <strong class="source-inline">Main.storyboard</strong> and uncheck the checkbox for <strong class="bold">Is Initial View Controller</strong> for the <strong class="source-inline">ToDoItemsListViewController</strong> scene in the attribute inspector.</li>
			</ol>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_11.01_B18127.jpg" alt="Figure 11.1 – Removing the initial view controller setting from the storyboard&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.1 – Removing the initial view controller setting from the storyboard</p>
			<ol>
				<li value="5">Switch to the <strong class="bold">Identity</strong> inspector and set <strong class="bold">Storyboard ID</strong> t<a id="_idTextAnchor533"/><a id="_idTextAnchor534"/>o <strong class="source-inline">ToDoItemsListViewController</strong>. With this change, we can instantiate this view controller in the code using this ID.</li>
				<li>Run the tests to confirm that now the last test we added fails. Oh, there is another test that fails. In <strong class="source-inline">ToDoItemsListViewControllerTests</strong>, all tests fail, because the setup in <strong class="source-inline">setUpWithError</strong> throws an error. Let's fix this error <a id="_idIndexMarker455"/>before we move on with the setup of our app. <strong class="source-inline">ToDoItemsListViewController</strong> isn't the initial view controller of the storyboard anymore. This means we need to load it using its ID. Replace <strong class="source-inline">setUpWithError()</strong> with the following implementation:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle:</p><p class="source-code">    nil)</p><p class="source-code">  sut = try XCTUnwrap(</p><p class="source-code">    storyboa<a id="_idTextAnchor535"/><a id="_idTextAnchor536"/>rd.instantiateViewController(</p><p class="source-code">      withIdentifier: "ToDoItemsListViewController")</p><p class="source-code">    as? ToDoItemsListViewController</p><p class="source-code">  )</p><p class="source-code">  toDoItemStoreMock = ToDoItemStoreProtocolMock()</p><p class="source-code">  sut.toDoItemStore = toDoItemStoreMock</p><p class="source-code">  sut.loadViewIfNeeded()</p><p class="source-code">}</p></li>
				<li>Run all tests again. Now, only our app setup test fails. Good. Let's move on to the implementation.</li>
				<li>Select the <strong class="bold">ToDo</strong> group in the project navigator and add a new Swift file with the na<a id="_idTextAnchor537"/><a id="_idTextAnchor538"/>me <strong class="source-inline">AppCoordinator.swift</strong>. Replace the content of the new file with the following code:<p class="source-code">// AppCoordinator.swi<a id="_idTextAnchor539"/><a id="_idTextAnchor540"/>ft</p><p class="source-code">import UIKit</p><p class="source-code"> </p><p class="source-code">protocol Coordinator {</p><p class="source-code">  func start()</p><p class="source-code">}</p></li>
			</ol>
			<p>This code defines the <strong class="source-inline">Coordinator</strong> protocol. This is how I implement the coordinator pattern. In blogs and books of other developers, you might find other implementations. Don't worry, they only differ in their details. When you have worked <a id="_idIndexMarker456"/>a bit with the coordinator pattern, you might develop your own implementation.</p>
			<p>This implementation of the protocol tells us that a coordinator has a <strong class="source-inline">start</strong> method.</p>
			<ol>
				<li value="9">Add the following implementation of our <strong class="source-inline">AppCoordinator</strong> in the same file:<p class="source-code">// AppCoordinator.sw<a id="_idTextAnchor541"/><a id="_idTextAnchor542"/>ift</p><p class="source-code">class AppCoordinator: Coordinator {</p><p class="source-code">  private let window: UIWindow?</p><p class="source-code">  private let viewController: UIViewController</p><p class="source-code">  init(window: UIWindow?) {</p><p class="source-code">    self.window = window</p><p class="source-code">    let storyboard = UIStoryboard(name: "Main",</p><p class="source-code">      bundle: nil)</p><p class="source-code">    viewController =</p><p class="source-code">      storyboard.instantiateViewController(</p><p class="source-code">      withIdentifier: "ToDoItemsListViewController")</p><p class="source-code">  }</p><p class="source-code">  func start() {</p><p class="source-code">    window?.rootViewController = viewController</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>In the initializer of <strong class="source-inline">AppCoordinator</strong>, we store the window that was passed in as a <a id="_idIndexMarker457"/>parameter, and we set up the view of the initial view controller. In the <strong class="source-inline">start</strong> method, we set the <strong class="source-inline">rootViewController</strong> property of the window.</p>
			<ol>
				<li value="10">Go to <strong class="source-inline">SceneDelegate</strong> and add the following property:<p class="source-code">// SceneDelegate.s<a id="_idTextAnchor543"/><a id="_idTextAnchor544"/>wift</p><p class="source-code">var appCoordinator: AppCoordinator?</p></li>
				<li>Next, replace the <strong class="source-inline">scene(_:willConnectTo:options:)</strong> method with this code:<p class="source-code">// SceneDelegate.s<a id="_idTextAnchor545"/><a id="_idTextAnchor546"/>wift</p><p class="source-code">func scene(_ scene: UIScene,</p><p class="source-code">  willConnectTo session: UISceneSession,</p><p class="source-code">  options connectionOptions:</p><p class="source-code">  UIScene.ConnectionOptions)<a id="_idTextAnchor547"/><a id="_idTextAnchor548"/> {</p><p class="source-code">  guard let scene = (scene as? UIWindowScene) else {</p><p class="source-code">    return</p><p class="source-code">  }</p><p class="source-code">  window = UIWindow(windowScene: scene)</p><p class="source-code">  let coordinator = AppCoordinator(</p><p class="source-code">    window: window)</p><p class="source-code">  coordinator.start()</p><p class="source-code">  appCoordinator = coordinator</p><p class="source-code">  window?.makeKeyAndVisible()</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we first set up an instance of the <strong class="source-inline">UIWindow</strong> class. Next, we instantiate the <strong class="source-inline">AppCoordinator</strong> instance and call its <strong class="source-inline">start</strong> method. Finally, we call <strong class="source-inline">makeKeyAndVisible</strong> on the window to tell <strong class="source-inline">UIKit</strong> that this window should be presented on the screen.</p>
			<ol>
				<li value="12">Run all <a id="_idIndexMarker458"/>tests to confirm that our refactoring was successful.</li>
			</ol>
			<p>Now, the app works as it did before. When the app starts, an instance of <strong class="source-inline">ToDoItemsListViewController</strong> is created and shown. But, this is not as it should work in the final app. The list of to-do items needs to be presented on a <strong class="source-inline">UINavigationController</strong> instance to be able to navigate to the details of a to-do item later.</p>
			<p>Follow these steps to make this change:</p>
			<ol>
				<li value="1">Replace the <strong class="source-inline">test_application_shouldSetupRoot()</strong> test method with the following implementation:<p class="source-code">// AppSetupTests.<a id="_idTextAnchor549"/><a id="_idTextAnchor550"/>swift</p><p class="source-code">func test_application_shouldSetupRoot() throws {</p><p class="source-code">  let application = UIApplication.shared</p><p class="source-code">  let scene = application.connectedScenes.first</p><p class="source-code">  as? UIWindowScene</p><p class="source-code">  let root = scene?.windows.first?.rootViewController</p><p class="source-code">  let nav = try XCTUnwrap(root as?</p><p class="source-code">    UINavigationController)</p><p class="source-code">  XCTAssert(nav.topViewController</p><p class="source-code">    is ToDoItemsListViewController)</p><p class="source-code">}</p></li>
				<li>Run the <a id="_idIndexMarker459"/>tests to see this test now failing in the line before the <strong class="source-inline">XCTAssert</strong> call.</li>
				<li>To make this test pass again, we first need a property for the navigation controller in the <strong class="source-inline">AppCoordinator</strong> class:<p class="source-code">// AppCoordinator<a id="_idTextAnchor551"/><a id="_idTextAnchor552"/>.swift</p><p class="source-code">private let navigationController:</p><p class="source-code">  UINavigationController</p></li>
				<li>Next, we set up the navigation controller in the <strong class="source-inline">init</strong> method:<p class="source-code">// AppCoordinator<a id="_idTextAnchor553"/><a id="_idTextAnchor554"/>.swift</p><p class="source-code">init(window: UI<a id="_idTextAnchor555"/><a id="_idTextAnchor556"/>Window?,</p><p class="source-code">  navigationController: UINavigationController =</p><p class="source-code">  UINavigationController()) {</p><p class="source-code">  self.window = window</p><p class="source-code">  self.navigationController = navigationController</p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle:</p><p class="source-code">    nil)</p><p class="source-code">  viewController =</p><p class="source-code">    storyboard.instantiateViewController(</p><p class="source-code">    withIdentifier: "ToDoItemsListViewController")</p><p class="source-code">}</p></li>
			</ol>
			<p>We have added the navigation controller as a parameter with a default value to the <strong class="source-inline">init</strong> call. This will come in handy later when we add tests for the navigation to the details of a to-do item.</p>
			<ol>
				<li value="5">Now, we can <a id="_idIndexMarker460"/>change the <strong class="source-inline">start</strong> method to add the instance of <strong class="source-inline">ToDoItemsListViewController</strong> to the navigation stack of the navigation controller:<p class="source-code">// AppCoordinato<a id="_idTextAnchor557"/><a id="_idTextAnchor558"/>r.swift</p><p class="source-code">func st<a id="_idTextAnchor559"/><a id="_idTextAnchor560"/>art() {</p><p class="source-code">  navigationController.pushViewController</p><p class="source-code">   (viewController,</p><p class="source-code">    animated: false)</p><p class="source-code">  window?.rootViewController = navigationController</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that all tests are now passing again.</p>
			<p>We are not done yet with setting up the list view controller. Remember, the list view controller communicates interactions by the user to a delegate object conforming<a id="_idTextAnchor561"/><a id="_idTextAnchor562"/> to the <strong class="source-inline">ToDoItemsListViewControllerProtocol</strong> protocol we defined in <a href="B18127_07_ePub.xhtml#_idTextAnchor177"><em class="italic">Chapter 7</em></a>, <em class="italic">Building a Table View Controller for the To-Do Items</em>. Follow these steps to implement this part of the setup:</p>
			<ol>
				<li value="1">Select the <strong class="bold">ToDoTests</strong> group in the project navigator and add a <strong class="bold">Unit Test Case Class</strong> with t<a id="_idTextAnchor563"/><a id="_idTextAnchor564"/>he name <strong class="source-inline">AppCoordinatorTests</strong>. Remove the two template test methods and add the <strong class="source-inline">@testable import ToDo</strong> import statement.</li>
				<li>Now, we will <a id="_idIndexMarker461"/>make the <strong class="source-inline">AppCoordinator</strong> class conform to the <strong class="source-inline">ToDoItemsListViewControllerProtocol</strong> protocol. Add the following code to <strong class="source-inline">AppCoordinator.swift</strong>: <p class="source-code">// AppCoordinato<a id="_idTextAnchor565"/><a id="_idTextAnchor566"/>r.swift </p><p class="source-code">extension AppCoordinator:  </p><p class="source-code">  ToDoItemsListViewControllerProtocol { </p><p class="source-code"> </p><p class="source-code">  func selectToDoItem(_ viewController:</p><p class="source-code">    UIViewController, </p><p class="source-code">    item: ToDoItem) { </p><p class="source-code">  } </p><p class="source-code">}  </p></li>
			</ol>
			<p>This implementation does nothing yet. We will implement this method in the next section.</p>
			<ol>
				<li value="3">To write a test for assigning the delegate property of the list view controller, we need to access the list view controller in the <strong class="source-inline">test</strong> method. The view controller property of the <strong class="source-inline">AppCoordinator</strong> class is private. This means we cannot access it in the test. We could change the access level of the view controller property.</li>
			</ol>
			<p>But for educational reasons, we will do something else. We will pass a navigation controller mock into the <strong class="source-inline">init</strong> method of the <strong class="source-inline">AppCoordinator</strong> class and get the initial view controller from that.</p>
			<ol>
				<li value="4">Add a <a id="_idIndexMarker462"/>new Swift class to the <strong class="bold">Doubles</strong> group in the <strong class="bold">ToDoTests</strong> group an<a id="_idTextAnchor567"/><a id="_idTextAnchor568"/>d call it <strong class="source-inline">NavigationControllerMock</strong>. Replace the contents of that new file with the following code: <p class="source-code">// NavigationControllerMo<a id="_idTextAnchor569"/><a id="_idTextAnchor570"/>ck.swift </p><p class="source-code">import UIKit </p><p class="source-code">  </p><p class="source-code">class NavigationControllerMock: UINavigationController { </p><p class="source-code">  var lastPushedViewController: UIViewController? </p><p class="source-code">  </p><p class="source-code">  override func pushViewController( </p><p class="source-code">    _ viewController: UIViewController, </p><p class="source-code">    animated: Bool) {   </p><p class="source-code">      lastPushedViewController = viewController </p><p class="source-code">      super.pushViewController(viewController, </p><p class="source-code">        animated: animated) </p><p class="source-code">    } </p><p class="source-code">} </p></li>
			</ol>
			<p>This subclass of the <strong class="source-inline">UINavigationController</strong> class stores the last pushed view controller for later inspection, and then calls the implementation of the <strong class="source-inline">super</strong> class.</p>
			<ol>
				<li value="5">Now, we can use this class in the <strong class="source-inline">AppCoordinator</strong> tests. Add the following properties to <strong class="source-inline">AppCoordinatorTests</strong>: <p class="source-code">// AppCoordinatorTes<a id="_idTextAnchor571"/><a id="_idTextAnchor572"/>ts.swift </p><p class="source-code">var sut: AppCoordinator! </p><p class="source-code">var navigationControllerMock: </p><p class="source-code">NavigationControllerMock! </p><p class="source-code">var window: UIWindow!</p></li>
				<li>Replace <a id="_idIndexMarker463"/>the <strong class="source-inline">setUpWithError</strong> method with the following code: <p class="source-code">// AppCoordinatorTe<a id="_idTextAnchor573"/><a id="_idTextAnchor574"/>sts.swift </p><p class="source-code">override func setUpWithError()<a id="_idTextAnchor575"/><a id="_idTextAnchor576"/> throws { </p><p class="source-code">  window = UIWindow(frame: CGRect(x: 0, </p><p class="source-code">    y: 0, </p><p class="source-code">    width: 200, </p><p class="source-code">    height: 200)) </p><p class="source-code">  navigationControllerMock =</p><p class="source-code">    NavigationControllerMock() </p><p class="source-code">  sut = AppCoordinator( </p><p class="source-code">    window: window, </p><p class="source-code">    navigationController: navigationControllerMock) </p><p class="source-code">} </p></li>
			</ol>
			<p>In this code, we create a dummy window and an instance of <strong class="source-inline">NavigationControllerMock</strong>, and use both to initialize an instance of <strong class="source-inline">AppCoordinator</strong>.</p>
			<ol>
				<li value="7">What we set up for the tests, we have to clean up when the tests are finished. Replace the <strong class="source-inline">tearDownWithError</strong> method with the following code: <p class="source-code">// AppCoordinatorTe<a id="_idTextAnchor577"/><a id="_idTextAnchor578"/>sts.swift </p><p class="source-code">override func tearDownWithError() throws { </p><p class="source-code">  sut = nil </p><p class="source-code">  navigationControllerMock = nil </p><p class="source-code">  window = nil </p><p class="source-code">}</p></li>
				<li>With this preparation, we can add a test to confirm that the <strong class="source-inline">start</strong> method assigns <a id="_idIndexMarker464"/>the instance of <strong class="source-inline">AppCoordinator</strong> to the delegate of the list view controller:<p class="source-code">// AppCoordinator<a id="_idTextAnchor579"/><a id="_idTextAnchor580"/>Tests.swift</p><p class="source-code">func test_start_shouldSetDelegate() throws {</p><p class="source-code">  sut.start()</p><p class="source-code">  let listViewController = try XCTUnwrap(</p><p class="source-code">    navigationControllerMock.lastPushedViewController</p><p class="source-code">    as? ToDoItemsListViewController)</p><p class="source-code">  XCTAssertIdentical(</p><p class="source-code">    listViewController.delegate as? AppCoordinator,</p><p class="source-code">    sut)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we call the <strong class="source-inline">start</strong> method of the <strong class="source-inline">AppCoordinator</strong> instance and then assert that <strong class="source-inline">sut</strong> is assigned to the delegate property of the list view controller. We use here the <strong class="source-inline">XCTAssertIdentical(_:_:)</strong> assert function. As <strong class="source-inline">AppCoordinator</strong> is a class, we can check in the test whether the delegate is identical to <strong class="source-inline">sut</strong>. This assert function compares the pointer address of the two items, and the test passe<a id="_idTextAnchor581"/><a id="_idTextAnchor582"/>s when both references are the same. This does not work with value types because they are copied when assigned (or rather when changed).</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="9">To make this test pass, add the following code to the end of the <strong class="source-inline">start</strong> method in <strong class="source-inline">AppCoordinator</strong>:<p class="source-code">// AppCoordi<a id="_idTextAnchor583"/><a id="_idTextAnchor584"/>nator.swift</p><p class="source-code">if let listViewController =</p><p class="source-code">  viewController as? ToDoItemsListViewController {</p><p class="source-code">  listViewController.delegate = self</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that this addition makes the test pass.</p>
			<p><strong class="source-inline">ToDoItemsListViewController</strong> shows the to-do items it gets from an instance of <strong class="source-inline">ToDoItemStore</strong>. We need to provide the list view controller with an item store when it is set up. Follow these steps to add the item store to the list view controller:</p>
			<ol>
				<li value="1">Add the <a id="_idIndexMarker465"/>following test to <strong class="source-inline">AppCoordinatorTests</strong>:<p class="source-code">// AppCoordinato<a id="_idTextAnchor585"/><a id="_idTextAnchor586"/>rTests.swift</p><p class="source-code">func test_start_shouldAssignItemStore() throws {</p><p class="source-code">  sut.start()</p><p class="source-code">  let listViewController = try XCTUnwrap(</p><p class="source-code">    navigationControllerMock.lastPushedViewController</p><p class="source-code">    as? ToDoItemsListViewController)</p><p class="source-code">  XCTAssertNotNil(listViewController.toDoItemStore)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we assert that the <strong class="source-inline">toDoItemStore</strong> property of the list view controller is not nil. Run the tests to confirm that this test fails.</p>
			<ol>
				<li value="2">Let's make this test pass. Add the following property to <strong class="source-inline">AppCoordinator</strong>:<p class="source-code">// AppCoord<a id="_idTextAnchor587"/><a id="_idTextAnchor588"/>inator.swift</p><p class="source-code">let toDoItemStore: ToDoItemStore</p></li>
				<li>Assign this property in the <strong class="source-inline">init</strong> method with a new instance:<p class="source-code">// AppCoord<a id="_idTextAnchor589"/><a id="_idTextAnchor590"/>inator.swift</p><p class="source-code">toDoItemStore = ToDoItemStore()</p></li>
				<li>Now, assign <a id="_idIndexMarker466"/>this property to the property of the list view controller within the <strong class="source-inline">if let</strong> statement of the <strong class="source-inline">start</strong> method:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">func start() {</p><p class="source-code">  navigationController.pushViewController</p><p class="source-code">    (viewController,</p><p class="source-code">     animated: false)</p><p class="source-code">  window?.rootViewController = navigationController</p><p class="source-code">  if let listViewController =</p><p class="source-code">      viewController as? ToDoItemsListViewController {</p><p class="source-code">    listViewController.delegate = self</p><p class="source-code">    listViewController.toDoItemStore = toDoItemStore</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to confirm that all tests now pass.</p>
			<p>The setup of the coordinator and the initial view controller is now complete. We can move on to implementing the interaction of the list view controller with the app coordinator.</p>
			<p>When the <a id="_idIndexMarker467"/>user taps a table view cell with a to-do item, the app should navigate to the details of that item. In the following section, we will implement this feature.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor591"/>Navigating to the details</h1>
			<p>We will <a id="_idIndexMarker468"/>implement the navigation within the app using <a id="_idIndexMarker469"/>the <strong class="source-inline">AppCoordinator</strong> class. Follow these steps to implement navigation to the details of to-do items:</p>
			<ol>
				<li value="1">Add the following test method to <strong class="source-inline">AppCoordinatorTests</strong>:<p class="source-code">// AppCoordi<a id="_idTextAnchor592"/><a id="_idTextAnchor593"/>natorTests.swift</p><p class="source-code">func test_selectToDoItem_pushesDetails() throws {</p><p class="source-code">  let dummyViewController = UIViewController()</p><p class="source-code">  let item = ToDoItem(title: "dummy title")</p><p class="source-code">  sut.selectToDoItem(dummyViewController, item: item)</p><p class="source-code">  let detail = try XCTUnwrap(</p><p class="source-code">    navigationControllerMock.lastPushedViewController</p><p class="source-code">    as? ToDoItemDetailsViewController)</p><p class="source-code">  XCTAssertEqual(detail.toDoItem, item)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we execute the <strong class="source-inline">delegate</strong> method and assert that an instance of <strong class="source-inline">ToDoItemDetailsViewController</strong> is pushed to the navigation stack, and that its <strong class="source-inline">toDoItem</strong> is the item we used in the <strong class="source-inline">delegate</strong> method call.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="2">Replace <a id="_idIndexMarker470"/>the implementation of <strong class="source-inline">selectToDoItem(_:item:)</strong> with <a id="_idIndexMarker471"/>this implementation: <p class="source-code">// AppCoordinator.swift </p><p class="source-code">func selectToDoItem(_ viewController:</p><p class="source-code">  UIViewController, </p><p class="source-code">  it<a id="_idTextAnchor594"/><a id="_idTextAnchor595"/>em: ToDoItem) { </p><p class="source-code"> </p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle:</p><p class="source-code">    nil) </p><p class="source-code">  guard let next =</p><p class="source-code">    storyboard.instantiateViewController( </p><p class="source-code">    withIdentifier: "ToDoItemDetailsViewController") </p><p class="source-code">      as? ToDoItemDetailsViewController else { </p><p class="source-code">            return </p><p class="source-code">          } </p><p class="source-code"> </p><p class="source-code">  next.loadViewIfNeeded() </p><p class="source-code">  next.toDoItem = item </p><p class="source-code"> </p><p class="source-code">  navigationController.pushViewController(next, </p><p class="source-code">    animated: true) </p><p class="source-code">} </p></li>
			</ol>
			<p>In this code, we instantiate an instance of <strong class="source-inline">ToDoItemDetailsViewController</strong> from the storyboard and set it up with the to-do item passed into the method. Then we push the new view controller onto the navigation stack. </p>
			<p>Run the tests to confirm that all tests now pass again.</p>
			<ol>
				<li value="3">The details <a id="_idIndexMarker472"/>view controller needs a reference <a id="_idIndexMarker473"/>to <strong class="source-inline">toDoItemStore</strong> because the user can change the status of the item to <strong class="source-inline">done</strong> in the details view. Add the following test to <strong class="source-inline">AppCoordinatorTests</strong>:<p class="source-code">// AppCo<a id="_idTextAnchor596"/><a id="_idTextAnchor597"/>ordinatorTests.swift</p><p class="source-code">func test_selectToDoItem_shouldSetItemStore() throws {</p><p class="source-code">  let dummyViewController = UIViewController()</p><p class="source-code">  let item = ToDoItem(title: "dummy title")</p><p class="source-code">  sut.selectToDoItem(dummyViewController, item: item)</p><p class="source-code">  let detail = try XCTUnwrap(</p><p class="source-code">    navigationControllerMock.lastPushedViewController</p><p class="source-code">    as? ToDoItemDetailsViewController)</p><p class="source-code">  XCTAssertIdentical(</p><p class="source-code">    detail.toDoItemStore as? ToDoItemStore,</p><p class="source-code">    sut.toDoItemStore)</p><p class="source-code">}</p></li>
			</ol>
			<p>This test looks like the previous one. We only changed the assert function call to check whether the <strong class="source-inline">toDoItemStore</strong> property is identical to the <strong class="source-inline">sut</strong> property.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="4">To make this test pass, assign the <strong class="source-inline">toDoItemStore</strong> property below the line we assigned the <strong class="source-inline">toDoItem</strong> property:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">next.loadViewIfNeeded()</p><p class="source-code">next.toDoItem = item</p><p class="source-code">next.toDoItemStore = toDoItemStore</p></li>
			</ol>
			<p>Run the tests to confirm that all tests pass.</p>
			<p>When the <a id="_idIndexMarker474"/>user selects a cell with a to-do item, our app now <a id="_idIndexMarker475"/>shows the details of that item on the screen. There is one feature missing. The app needs to allow the input of new to-do items. We will implement the presentation of the input view from the list view in the next section.</p>
			<h1 id="_idParaDest-154"><a id="_idTextAnchor598"/>Navigating to a modal view</h1>
			<p>Normally, testing the presentation of a modal view controller is quite complicated. If you search <a id="_idIndexMarker476"/>how to do that on the internet, you will find that the common solutions work by swizzling the <strong class="source-inline">present(_:animated:completion:)</strong> method defined in the <strong class="source-inline">UIViewController</strong> class. Swizzling is quite complicated, and I will not show in this book how this is done.</p>
			<p>But, because we are using the coordinator pattern for the navigation in our app, we can test the presentation without the need to swizzle any method. Still, you should look up how to swizzle methods because sometimes you don't have the option to use the coordinator pattern; for example, when there is already all the navigation code implemented and you are not allowed to change it.</p>
			<p>Follow these steps to implement the presentation of the input view when the user chooses to add a new to-do item:</p>
			<ol>
				<li value="1">The app needs a button in the user interface that the user can tap to add a to-do item. When the user taps that button, the list view controller should tell its delegate about it. Add the following method definition to <strong class="source-inline">ToDoItemsListViewControllerProtocol</strong>:<p class="source-code">// ToDoItemsL<a id="_idTextAnchor599"/><a id="_idTextAnchor600"/>istViewController.swift</p><p class="source-code">func addToDoItem(</p><p class="source-code">  _ viewController: UIViewController)</p></li>
				<li>To make <a id="_idIndexMarker477"/>the compiler happy, add the following empty method implementation to <strong class="source-inline">AppCoordinator</strong>:<a id="_idTextAnchor601"/><a id="_idTextAnchor602"/><p class="source-code">// AppCoordinator.swift</p><p class="source-code">func addToDoItem(_ viewController: UIViewController) {</p><p class="source-code">}</p></li>
				<li>We have another class that conforms to the <strong class="source-inline">ToDoItemsListViewControllerProtocol</strong> protocol. Add the following code to the end of the <strong class="source-inline">ToDoItemsListViewControllerProtocolMock</strong> class:<p class="source-code">// ToDoItemsListViewCont<a id="_idTextAnchor603"/><a id="_idTextAnchor604"/>roll<a id="_idTextAnchor605"/><a id="_idTextAnchor606"/>erProtocolMock.swift</p><p class="source-code">var addTo<a id="_idTextAnchor607"/><a id="_idTextAnchor608"/>DoItemCallCount = 0</p><p class="source-code">func addToDoItem(_ viewController: UIViewController) {</p><p class="source-code">  addToDoItemCallCount += 1</p><p class="source-code">}</p></li>
			</ol>
			<p>The mock object counts the number of calls of the <strong class="source-inline">addToDoItem(_:)</strong> method.</p>
			<ol>
				<li value="4">Next, we need a view controller mock that catches the last presented view controller. Select the <strong class="bold">Doubles</strong> group within the <strong class="bold">ToDoTests</strong> group in the project navigator and add a new <a id="_idTextAnchor609"/><a id="_idTextAnchor610"/>Swift file with the name <strong class="source-inline">ViewControllerMock.swift</strong>. Replace its content with the following code:<p class="source-code">// <a id="_idTextAnchor611"/><a id="_idTextAnchor612"/>ViewController<a id="_idTextAnchor613"/><a id="_idTextAnchor614"/>Mock.swift</p><p class="source-code">import UIKit</p><p class="source-code">class ViewControllerMock: UIViewController {</p><p class="source-code">  var lastPresented: UIViewController?</p><p class="source-code">  override func present(</p><p class="source-code">    _ viewControllerToPresent: UIViewController,</p><p class="source-code">    animated flag: Bool,</p><p class="source-code">    completion: (() -&gt; Void)? = nil) {</p><p class="source-code">    lastPresented = viewControllerToPresent</p><p class="source-code">    super.present(viewControllerToPresent,</p><p class="source-code">      animated: flag,</p><p class="source-code">      completion: completion)</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This mock stores the presented view controller in a property for later inspection.</p>
			<ol>
				<li value="5">Now, we can <a id="_idIndexMarker478"/>write the test. Import <strong class="source-inline">SwiftUI</strong> to <strong class="source-inline">AppCoordinatorTests.swift</strong> and add the following test method to <strong class="source-inline">AppCoordinatorTests</strong>:<p class="source-code">// <a id="_idTextAnchor615"/><a id="_idTextAnchor616"/>AppCoordinatorTests.swift</p><p class="source-code">func test_addToDoItem_shouldPresentInputView() throws</p><p class="source-code"> {</p><p class="source-code">  let viewControllerMock = ViewControllerMock()</p><p class="source-code">  sut.addToDoItem(viewControllerMock)</p><p class="source-code">  let lastPresented = try XCTUnwrap(</p><p class="source-code">    viewControllerMock.lastPresented</p><p class="source-code">    as? UIHostingController&lt;ToDoItemInputView&gt;)</p><p class="source-code">  XCTAssertIdentical(</p><p class="source-code">    lastPresented.rootView.delegate as?</p><p class="source-code">    AppCoordinator,</p><p class="source-code">    sut)</p><p class="source-code">}</p></li>
			</ol>
			<p>This test calls <strong class="source-inline">addToDoItem(_:)</strong> and asserts that the <strong class="source-inline">sut</strong> variable is assigned as the delegate of the presented instance of <strong class="source-inline">ToDoItemInputView</strong>.</p>
			<p>Run the tests to confirm that this new test fails.</p>
			<ol>
				<li value="6">To make <a id="_idIndexMarker479"/>this test pass, import <strong class="source-inline">SwiftUI</strong> into <strong class="source-inline">AppCoordinator.swift</strong> and replace the implementation of <strong class="source-inline">addToDoItem(_:)</strong> with the following code:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">func addToDoItem(_ viewContr<a id="_idTextAnchor617"/><a id="_idTextAnchor618"/>oller: UIViewController) {</p><p class="source-code">  let data = ToDoItemData()</p><p class="source-code">  let next = UIHostingController(</p><p class="source-code">    rootView: ToDoItemInputView(data: data,</p><p class="source-code">      apiClient: APIClient(),</p><p class="source-code">      delegate: self))</p><p class="source-code">  viewController.present(next, animated: true)</p><p class="source-code">}</p></li>
			</ol>
			<p>Xcode shows an error; we will fix this error in the next step. This code instantiates an instance of <strong class="source-inline">UIHostingController</strong> with a root view of <strong class="source-inline">ToDoItemInputView</strong>. This is how we can present a <strong class="source-inline">SwiftUI</strong> view from a <strong class="source-inline">UIKit</strong> environment.</p>
			<ol>
				<li value="7">To make this code compile, add the following extension to <strong class="source-inline">AppCoordinator.swif<a id="_idTextAnchor619"/><a id="_idTextAnchor620"/>t</strong>:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">extension AppCoordinator: ToDoItemInputViewDelegate {</p><p class="source-code">  func addToDoItem(with: ToDoItemData,</p><p class="source-code">    coordinate: Coordinate?) {</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the <a id="_idIndexMarker480"/>tests to confirm that all tests now pass.</p>
			<p>One part of this feature is finished. Next, we need to implement the other part in the <strong class="source-inline">ToDoItemsListViewController</strong> class.</p>
			<ol>
				<li value="8">Add the following test method to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// ToDoItemsLi<a id="_idTextAnchor621"/><a id="_idTextAnchor622"/>stViewControllerTests.swift</p><p class="source-code">func test_navigationBarButton_shouldCallDelegate()</p><p class="source-code"> throws {</p><p class="source-code">  let delegateMock =</p><p class="source-code">  ToDoItemsListViewControllerProtocolMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">  let addButton =</p><p class="source-code">    sut.navigationItem.rightBarButtonItem</p><p class="source-code">  let target = try XCTUnwrap(addButton?.target)</p><p class="source-code">  let action = try XCTUnwrap(addButton?.action)</p><p class="source-code">  _ = target.perform(action, with: addButton)</p><p class="source-code">  <a id="_idTextAnchor623"/><a id="_idTextAnchor624"/>XCTAssertEqual(delegateMock.addToDoItemCallCount, 1)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this test, we get the right bar button item of the <strong class="source-inline">sut</strong> variable and call its action on its target. This should result in a call to the <strong class="source-inline">addToDoItem(_:)</strong> method of the delegate.</p>
			<p>Run the tests and confirm that this new test fails.</p>
			<ol>
				<li value="9">Add the <a id="_idIndexMarker481"/>following code to the end of <strong class="source-inline">viewDidLoad()</strong> of <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoI<a id="_idTextAnchor625"/><a id="_idTextAnchor626"/>temsListViewController.swift</p><p class="source-code">let addItem = UIBarButtonItem(barButtonSystemItem:</p><p class="source-code">  .add,</p><p class="source-code">  target: self,</p><p class="source-code">  action: #selector(add(_:)))</p><p class="source-code">navigationItem.rightBarButtonItem = addItem</p></li>
			</ol>
			<p>With this code, we add a bar button to the navigation item of the <strong class="source-inline">ToDoItemsListViewController</strong> instance. This results in a bar button that is added to the navigation bar of the navigation controller that hosts <strong class="source-inline">ToDoItemsListViewController</strong>.</p>
			<ol>
				<li value="10">Now, add the following method to <strong class="source-inline">ToDoItemsListViewController</strong>:<p class="source-code">// ToDoI<a id="_idTextAnchor627"/><a id="_idTextAnchor628"/>temsListViewController.swift</p><p class="source-code">@objc func add(_ sender: UIBarButtonItem) {</p><p class="source-code">}</p></li>
			</ol>
			<p>For now, we let the implementation of this method empty because we want to see the test fail in the assert function call. Run the tests and confirm that the test we added last now fails in the assert call.</p>
			<ol>
				<li value="11">To make <a id="_idIndexMarker482"/>the test pass, add the missing code in <strong class="source-inline">add(_:)</strong>:<p class="source-code">// ToDo<a id="_idTextAnchor629"/><a id="_idTextAnchor630"/>ItemsListViewController.swift</p><p class="source-code">@objc func add(_ sender: UIBarButtonItem) {</p><p class="source-code">  delegate?.addToDoItem(self)</p><p class="source-code">} </p></li>
			</ol>
			<p>Run the tests to confirm that all tests now pass.</p>
			<p>We already know that <strong class="source-inline">ToDoItemInputView</strong> calls its delegate when the user selects the <strong class="bold">Save</strong> button in the user interface. But, we still have to implement that the delegate calls the <strong class="source-inline">add(_:)</strong> method of <strong class="source-inline">ToDoItemStore</strong>. Take the following steps to implement this feature.</p>
			<ol>
				<li value="12">Add the following test to <strong class="source-inline">AppCoordinatorTests</strong>:<a id="_idTextAnchor631"/><a id="_idTextAnchor632"/><p class="source-code">// AppCoordinatorTests.swift</p><p class="source-code">func test_addToDoItemWith_shouldCallToDoItemStore()</p><p class="source-code"> throws {</p><p class="source-code">  let toDoItemData = ToDoItemData()</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  let receivedItems =</p><p class="source-code">  try wait(for: sut.toDoItemStore.itemPublisher,</p><p class="source-code">    afterChange: {</p><p class="source-code">    sut.addToDoItem(with: toDoItemData, coordinate:</p><p class="source-code">      nil)</p><p class="source-code">  })</p><p class="source-code">  XCTAssertEqual(receivedItems.first?.title, </p><p class="source-code">    toDoItemData.title)</p><p class="source-code">}</p></li>
			</ol>
			<p>This test asserts that, after calling <strong class="source-inline">addToDoItem(with:coordinate:)</strong>, now <strong class="source-inline">itemPublisher</strong> of the <strong class="source-inline">toDoItemStore</strong> property publishes the change to the stored items.</p>
			<ol>
				<li value="13">As we <a id="_idIndexMarker483"/>are adding a to-do item to the item store, we need to replace <strong class="source-inline">doToItemStore</strong> in <strong class="source-inline">AppCoordinator</strong> with a test store. Otherwise, the test could fail because of items added to the store in other tests or while we test the app on the simulator. </li>
				<li>Replace the <strong class="source-inline">init</strong> method of the <strong class="source-inline">AppCoordinator</strong> class with the following implement<a id="_idTextAnchor633"/><a id="_idTextAnchor634"/>ation:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">init(window: UIWindow?,</p><p class="source-code"> navigationController: UINavigationController =</p><p class="source-code">     UINavigationController(),</p><p class="source-code">     toDoItemStore: ToDoItemStore = ToDoItemStore()) {</p><p class="source-code">  self.window = window</p><p class="source-code">  self.navigationController = navigationController</p><p class="source-code">  self.toDoItemStore = toDoItemStore</p><p class="source-code">  let storyboard = UIStoryboard(name: "Main", bundle:</p><p class="source-code">    nil)</p><p class="source-code">  viewController = </p><p class="source-code">    storyboard.instantiateViewController(</p><p class="source-code">    withIdentifier: "ToDoItemsListViewController")</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have added the <strong class="source-inline">toDoItemStore</strong> parameter to the method and we use that parameter to set the <strong class="source-inline">toDoItemStore</strong> property used in the <strong class="source-inline">AppCoordinator</strong> class.</p>
			<ol>
				<li value="15">So, we can <a id="_idIndexMarker484"/>use a test store when setting up <strong class="source-inline">sut</strong> in <strong class="source-inline">setUpWithErro<a id="_idTextAnchor635"/><a id="_idTextAnchor636"/>r</strong>:<p class="source-code">// AppCoordinatorTests.swift</p><p class="source-code">override func setUpWithError() throws {</p><p class="source-code">  window = UIWindow(frame: CGRect(x: 0,</p><p class="source-code">    y: 0,</p><p class="source-code">    width: 200,</p><p class="source-code">    height: 200))</p><p class="source-code">  navigationControllerMock =</p><p class="source-code">    NavigationControllerMock()</p><p class="source-code">  sut = AppCoordinator(</p><p class="source-code">    window: window,</p><p class="source-code">    navigationController: navigationControllerMock,</p><p class="source-code">    toDoItemStore: ToDoItemStore(fileName:</p><p class="source-code">      "dummy_store"))</p><p class="source-code">}</p></li>
				<li>To delete the item store when the test is finished, add the following code to the end of <strong class="source-inline">tearDownWithError</strong> of <strong class="source-inline">AppCoordinatorTest<a id="_idTextAnchor637"/><a id="_idTextAnchor638"/>s</strong>:<p class="source-code">// AppCoordinatorTests.swift</p><p class="source-code">let url = FileManager.default</p><p class="source-code">  .documentsURL(name: "dummy_store")</p><p class="source-code">try? FileManager.default.removeItem(at: url)</p></li>
			</ol>
			<p>This code should look familiar, as we already used it in <strong class="source-inline">ToDoItemStoreTests</strong>.</p>
			<p>Run the tests to confirm that the new test fails.</p>
			<ol>
				<li value="17">Make the <a id="_idIndexMarker485"/>test pass with the following implementation of <strong class="source-inline">addToDoItem(with:coord<a id="_idTextAnchor639"/><a id="_idTextAnchor640"/>inate:)</strong>:<p class="source-code">// AppCoordinator.swift</p><p class="source-code">func addToDoItem(with item: ToDoItemData,</p><p class="source-code">  coordinate: Coordinate?) {</p><p class="source-code">  let location = Location(name: item.locationName,</p><p class="source-code">    coordinate: coordinate)</p><p class="source-code">  let toDoItem = ToDoItem(</p><p class="source-code">    title: item.title,</p><p class="source-code">    itemDescription: item.itemDescription,</p><p class="source-code">    timestamp: item.date.timeIntervalSince1970,</p><p class="source-code">    location: location)</p><p class="source-code">  toDoItemStore.add(toDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>Note that we added an internal parameter name of <strong class="source-inline">item</strong> for the first parameter of that method.</p>
			<p>In this code, we create an instance of <strong class="source-inline">ToDoItem</strong> from the <strong class="source-inline">ToDoItemData</strong> structure. Then, we call the <strong class="source-inline">add(_:)</strong> method of <strong class="source-inline">toDoItemStore</strong>.</p>
			<p>Run the <a id="_idIndexMarker486"/>tests to confirm that this change makes all tests pass again.</p>
			<p>For now, we are done with the implementation. Let's make the app work in the simulator and see whether we missed something.</p>
			<h1 id="_idParaDest-155"><a id="_idTextAnchor641"/>Adding missing parts</h1>
			<p>First, let's run <a id="_idIndexMarker487"/>the app for the first time to see where we are.</p>
			<p>The app starts with a blank screen with just one plus (<strong class="bold">+</strong>) button in the upper-right corner.</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_11.02_B18127.jpg" alt="Figure 11.2 – The initial view of our app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.2 – The initial view of our app</p>
			<p>So, there is <a id="_idIndexMarker488"/>work to do here. But, let's move on and tap the plus (<strong class="bold">+</strong>) button. We are presented with the input view. We can add data for the item and tap the <strong class="bold">Save</strong> button.</p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_11.03_B18127.jpg" alt="Figure 11.3 – The input view of our app&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.3 – The input view of our app</p>
			<p>But, when <a id="_idIndexMarker489"/>we tap the <strong class="bold">Save</strong> button, nothing happens. Dismiss the view by swiping down, and see whether the item was added. Something changed. There is a blank table view cell visible in the middle of the screen.</p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_11.04_B18127.jpg" alt="Figure 11.4 – A blank table view cell. Where is the to-do item?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.4 – A blank table view cell. Where is the to-do item?</p>
			<p>When you <a id="_idIndexMarker490"/>tap the blank table view cell, the detail view is pushed onto the screen.</p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_11.05_B18127.jpg" alt="Figure 11.5 – The details of the to-do item. But, where is the due date?&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.5 – The details of the to-do item. But, where is the due date?</p>
			<p>Okay, we have <a id="_idIndexMarker491"/>some work to do. Let's go back to Xcode and fix some problems.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor642"/>Making the cells visible</h2>
			<p>The table view <a id="_idIndexMarker492"/>doesn't show the information of the to-do items. The reason is, we didn't add constraints to the views when we added the labels. This was on purpose because I believe you should not write unit tests to test the position and size of interface elements. UI tests of snapshot tests are a better tool for these kinds of tests.</p>
			<p>Follow these steps to fix the layout of the cells and the table view:</p>
			<ol>
				<li value="1">Open <strong class="source-inline">Main.storyboard</strong> in <strong class="bold">Interface Builder </strong>and select the table view in <strong class="bold">To Do Items List View Controller Scene</strong>. Then, select the <strong class="bold">Add New Constraints</strong> button <a id="_idIndexMarker493"/>in the lower-right corner of <strong class="bold">Interface Builder</strong>. Set the top, leading, trailing, and bottom constraints to <strong class="source-inline">0</strong> and click <strong class="bold">Add 4 Constraints</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_11.06_B18127.jpg" alt="Figure 11.6 – The constraints for the table view&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.6 – The constraints for the table view</p>
			<ol>
				<li value="2">Next, go to <strong class="source-inline">ToDoItemCell</strong>, and <a id="_idIndexMarker494"/>replace the <strong class="source-inline">init</strong> method with the following i<a id="_idTextAnchor643"/><a id="_idTextAnchor644"/>mplementation:<p class="source-code">// ToDoItemCell.swift</p><p class="source-code">override init(style: UITableViewCell.CellStyle,</p><p class="source-code">  reuseIdentifier: String?) {</p><p class="source-code">  titleLabel = UILabel()</p><p class="source-code">  dateLabel = UILabel()</p><p class="source-code">  dateLabel.textAlignment = .right</p><p class="source-code">  locationLabel = UILabel()</p><p class="source-code">  let titleLocation = UIStackView(</p><p class="source-code">    arrangedSubviews: [titleLabel, locationLabel])</p><p class="source-code">  titleLocation.axis = .vertical</p><p class="source-code">  let stackView = UIStackView(</p><p class="source-code">    arrangedSubviews: [titleLocation, dateLabel])</p><p class="source-code">  stackView</p><p class="source-code">    .translatesAutoresizingMaskIntoConstraints = false</p><p class="source-code">  super.init(style: style,</p><p class="source-code">    reuseIdentifier: reuseIdentifier)</p><p class="source-code">  contentView.addSubview(stackView)</p><p class="source-code">  NSLayoutConstraint.activate([</p><p class="source-code">   stackView.topAnchor.constraint(</p><p class="source-code">      equalTo: contentView.topAnchor, constant: 5),</p><p class="source-code">   stackView.leadingAnchor.constraint(</p><p class="source-code">    equalTo: contentView.leadingAnchor, constant: 16),</p><p class="source-code">   stackView.bottomAnchor.constraint(</p><p class="source-code">    equalTo: contentView.bottomAnchor, constant: -5),</p><p class="source-code">   stackView.trailingAnchor.constraint(</p><p class="source-code">    equalTo: contentView.trailingAnchor, constant: -</p><p class="source-code">    16),</p><p class="source-code">  ])</p><p class="source-code">}</p></li>
			</ol>
			<p>We use <strong class="source-inline">UIStackView</strong> instances to lay out the elements. Run the tests to confirm that we didn't break anything. Then, run the app again on the simulator.</p>
			<p>It looks better, but the <a id="_idIndexMarker495"/>due date is still missing in the table view cell. The reason is that we didn't set up the <strong class="source-inline">dateFormatter</strong> instance currently. We found a bug. Whenever we find a bug, we should try to write a test that fails because of that bug. Then, we should make the test pass by fixing the bug.</p>
			<ol>
				<li value="3">Add the following test method to <strong class="source-inline">ToDoItemsListViewControllerTests</strong>:<p class="source-code">// T<a id="_idTextAnchor645"/><a id="_idTextAnchor646"/>oDoItemsListViewControllerTests.swift</p><p class="source-code">func test_dateFormatter_shouldNotBeNone() {</p><p class="source-code">  XCTAssertNotEqual(sut.dateFormatter.dateStyle,</p><p class="source-code">    .none)</p><p class="source-code">}</p></li>
			</ol>
			<p>Note that the <strong class="source-inline">XCTAssertNotEqual</strong> assert function does the opposite of the <strong class="source-inline">XCTAssertEqual</strong> function. It passes when the two values are not equal.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="4">To make this test pass and the bug disappear, add these lines to <strong class="source-inline">viewDidLoad</strong> below the <strong class="source-inline">super.viewDidLoad()</strong> line:<p class="source-code">// ToDoItemsListView<a id="_idTextAnchor647"/><a id="_idTextAnchor648"/>Controller.swift</p><p class="source-code">super.viewDidLoad()</p><p class="source-code">dateFormatter.dateStyle = .short</p></li>
				<li>Run the tests <a id="_idIndexMarker496"/>to confirm that this makes the test green. Then, run the app on the simulator. Woohoo! We fixed our first bug with the help of TDD. This is a milestone. We are now sure that this bug won't come back as long as this test is run regularly.</li>
			</ol>
			<p>Next, we need to fix the bug that the input view is not dismissed when the user taps the <strong class="bold">Save</strong> button.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor649"/>Dismissing the input view</h2>
			<p>Again, we <a id="_idIndexMarker497"/>have a bug. Let's see whether we can write a test for that bug. Follow these steps to fix the bug:</p>
			<ol>
				<li value="1">The navigation controller mock should register if <strong class="source-inline">dismiss(animated:completion:)</strong> got called. This way, we can make sure that it is called when a new item is added. Add the following code to <strong class="source-inline">NavigationController<a id="_idTextAnchor650"/><a id="_idTextAnchor651"/>Mock</strong>:<p class="source-code">// NavigationControllerMock.swift</p><p class="source-code">var dismissCallCount = 0</p><p class="source-code">override func dismiss(animated flag: Bool,</p><p class="source-code">  completion: (() -&gt; Void)? = nil) {</p><p class="source-code">  dismissCallCount += 1</p><p class="source-code">  super.dismiss(animated: flag,</p><p class="source-code">     completion: completion)</p><p class="source-code">}</p></li>
			</ol>
			<p>This code counts the times <strong class="source-inline">dismiss(animated:completion:)</strong> got called.</p>
			<ol>
				<li value="2">Add the <a id="_idIndexMarker498"/>following test method to <strong class="source-inline">AppCoordi<a id="_idTextAnchor652"/><a id="_idTextAnchor653"/>natorTests</strong>:<p class="source-code">// AppCoordinatorTests.swift</p><p class="source-code">func test_addToDoItemWith_shouldDismissInput() {</p><p class="source-code">  let toDoItemData = ToDoItemData()</p><p class="source-code">  toDoItemData.title = "dummy title"</p><p class="source-code">  sut.addToDoItem(with: toDoItemData,</p><p class="source-code">    coordinate: nil)</p><p class="source-code">  XCTAssertEqual(</p><p class="source-code">    navigationControllerMock.dismissCallCount, 1)</p><p class="source-code">}</p></li>
			</ol>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="3">Add the following code to the end of <strong class="source-inline">addToDoItem(with:co<a id="_idTextAnchor654"/><a id="_idTextAnchor655"/>ordinate:)</strong>:<p class="source-code">// AppCoordinatorTests.swift</p><p class="source-code">navigationController.dismiss(animated: true)</p></li>
			</ol>
			<p>Run the tests to confirm that this code makes all tests pass again. Then, run the app and add a new to-do item. </p>
			<p>We fixed <a id="_idIndexMarker499"/>another bug using TDD.</p>
			<p>Next, let's fix the bug in the details that the due date isn't shown.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor656"/>Making the due date visible in the details</h2>
			<p>The reason <a id="_idIndexMarker500"/>that the date is not shown in the details is the same as for the table view cell. The date formatter isn't set up correctly. You already know how to write a test for this. Write the test and make sure that the test fails.</p>
			<p>To make the test pass and, therefore, fix the bug, you can use this definition of the <strong class="source-inline">dateFormatter</strong> proper<a id="_idTextAnchor657"/><a id="_idTextAnchor658"/>ty:</p>
			<p class="source-code">// ToDoItemDetailsViewController.swift</p>
			<p class="source-code">let dateFormatter: DateFormatter = {</p>
			<p class="source-code">  let formatter = DateFormatter()</p>
			<p class="source-code">  formatter.dateStyle = .short</p>
			<p class="source-code">  return formatter</p>
			<p class="source-code">}()</p>
			<p>This should make your test pass.</p>
			<p>Run the app again, and play around with it. You might realize some more bugs. Here is what I found:</p>
			<ul>
				<li>When the user taps the <strong class="bold">Done</strong> button in the details, the app should pop back to the list of to-do items.</li>
				<li>The section headers are missing in the table view. The done items are correctly moved to the second section, but it's not visible in the user interface that there are several sections.</li>
				<li>When the user marks the first item done, the order in the table view changes. If the user then selects the first item in the table view, the details for the other item are shown.</li>
				<li>The cell stays selected even after the user came back from the details.</li>
				<li>The debug console shows a warning that the table view was told to lay out the cells when it is not visible.</li>
			</ul>
			<p>We sure <a id="_idIndexMarker501"/>found some more bugs.</p>
			<p>In the following sections, we will fix only the third and the fifth bug in this list. The other bugs are left as an exercise for you. If you get stuck, have a look at the code for this chapter on GitHub.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor659"/>Fixing the wrong item being selected</h2>
			<p>Again, let's try <a id="_idIndexMarker502"/>to write a test for this bug before we try to fix it. Follow these steps to fix that bug:</p>
			<ol>
				<li value="1">The problem is that we set up the sections when we create the snapshot for the diffable data source, but we ignore the section when the user selects a table view row. We can change the <strong class="source-inline">test_didSelectCellAt_shouldCallDelegate</strong> method to check for this error. Replace the implementation of that test method with the following c<a id="_idTextAnchor660"/><a id="_idTextAnchor661"/>ode:<p class="source-code">// ToDoItemsListViewControllerTests.swift</p><p class="source-code">func test_didSelectCellAt_shouldCallDelegate() throws</p><p class="source-code"> {</p><p class="source-code">  let delegateMock =</p><p class="source-code">    ToDoItemsListViewControllerProtocolMock()</p><p class="source-code">  sut.delegate = delegateMock</p><p class="source-code">  var doneItem = ToDoItem(title: "done item")</p><p class="source-code">  doneItem.done = true</p><p class="source-code">  let toDoItem = ToDoItem(title: "to-do item")</p><p class="source-code">  toDoItemStoreMock.itemPublisher</p><p class="source-code">    .send([doneItem, toDoItem])</p><p class="source-code">  let tableView = try XCTUnwrap(sut.tableView)</p><p class="source-code">  let indexPath = IndexPath(row: 0, section: 0)</p><p class="source-code">  tableView.delegate?.tableView?(</p><p class="source-code">    tableView,</p><p class="source-code">    didSelectRowAt: indexPath)</p><p class="source-code">  XCTAssertEqual(</p><p class="source-code">   delegateMock.selectToDoItemReceivedArguments?.item,</p><p class="source-code">    toDoItem)</p><p class="source-code">}</p></li>
			</ol>
			<p>We change <a id="_idIndexMarker503"/>the test to use two items, one done item and one item that is not done yet.</p>
			<p>Run the tests to see this test failing.</p>
			<ol>
				<li value="2">To make the test pass and thus fix the bug, replace the implementation of <strong class="source-inline">tableView(_:didSelectRowAt:)</strong> with the follo<a id="_idTextAnchor662"/><a id="_idTextAnchor663"/>wing code:<p class="source-code">// ToDoItemsListViewController.swift</p><p class="source-code">func tableView(_ tableView: UITableView,</p><p class="source-code">  didSelectRowAt indexPath: IndexPath) {</p><p class="source-code">  let item: ToDoItem</p><p class="source-code">  switch indexPath.section {</p><p class="source-code">    case 0:</p><p class="source-code">      let filteredItems = items.filter({ false ==</p><p class="source-code">        $0.done })</p><p class="source-code">      item = filteredItems[indexPath.row]</p><p class="source-code">    default:</p><p class="source-code">      let filteredItems = items.filter({ true ==</p><p class="source-code">        $0.done })</p><p class="source-code">      item = filteredItems[indexPath.row]</p><p class="source-code">  }</p><p class="source-code">  delegate?.selectToDoItem(self, item: item)</p><p class="source-code">}</p></li>
			</ol>
			<p>In this <a id="_idIndexMarker504"/>implementation, we respect the two sections and choose the item to be shown accordingly.</p>
			<p>Run all tests to confirm that all tests now pass.</p>
			<p>And, with this last bug fixed, we are done with the first simple version of our little app that we created using TDD.</p>
			<h2 id="_idParaDest-160"><a id="_idTextAnchor664"/>Fixing the layout of the table view</h2>
			<p>The problem here is that we use the <strong class="source-inline">Combine</strong> framework to update the table view. When the <a id="_idIndexMarker505"/>user taps the <strong class="bold">Done</strong> button in the details, <strong class="source-inline">doToItemStore</strong> updates its items and tells the table view about it. This results in an update of the table view when it is not visible on the screen. This is easy to fix and we don't even need a test for this. Add the following code to <strong class="source-inline">ToDoItemsListViewCont<a id="_idTextAnchor665"/><a id="_idTextAnchor666"/>roller</strong>:</p>
			<p class="source-code">// ToDoItemsListViewController.swift</p>
			<p class="source-code">override func viewDidAppear(_ animat<a id="_idTextAnchor667"/><a id="_idTextAnchor668"/>ed: Bool) {</p>
			<p class="source-code">  super.viewDidAppear(animated)</p>
			<p class="source-code">  token = toDoItemStore?.itemPublisher</p>
			<p class="source-code">    .sink(receiveValue: { [weak self] items in</p>
			<p class="source-code">      self?.items = items</p>
			<p class="source-code">      self?.update(with: items)</p>
			<p class="source-code">    })</p>
			<p class="source-code">}</p>
			<p class="source-code">override func viewWillDisappear(_ animated: Bool) {</p>
			<p class="source-code">  super.viewWillDisappear(animated)</p>
			<p class="source-code">  token?.cancel()</p>
			<p class="source-code">}</p>
			<p>When the <a id="_idIndexMarker506"/>view with the table view disappears, we unsubscribe from <strong class="source-inline">itemsPublisher</strong>. When the view appears on the screen, we subscribe again. Run the app again in the simulator and have a look at the console to see whether the message is gone.</p>
			<h1 id="_idParaDest-161"><a id="_idTextAnchor669"/>Summary</h1>
			<p>In this final chapter, we have implemented the navigation between the different views of our app. We have learned how to test pushing view controllers onto a navigation stack and how we can test whether a view got presented modally.</p>
			<p>With navigation implemented, we started the app on the simulator and found and fixed bugs. We figured out that TDD even helps when fixing bugs. By writing first a failing test for that bug and then making the test pass, we ensured that this bug won't hurt us in the future of our app.</p>
			<p>With the skills you gained in this chapter, you will be able to implement and test the navigation of an app using the coordinator pattern. And, you are now able to write tests for bugs and fix the bug by making the test pass.</p>
			<p>Congratulations, you reached the end of this book! My hope is that this book is the beginning of your journey to becoming a test-driven developer. You learned how to test <strong class="source-inline">Combine</strong> code and write tests for view controllers and views, table views, and even SwiftUI code. I believe this is a good foundation for your next steps. Try to add tests to your existing projects and talk to your colleagues about the advantages and disadvantages of unit tests and TDD. Find your own testing style.</p>
			<p>Most importantly, have fun!</p>
			<h1 id="_idParaDest-162"><a id="_idTextAnchor670"/>Exercises</h1>
			<ol>
				<li value="1">Fix the bugs you found while testing the app on the simulator.</li>
				<li>Add the feature that the user can check to-do items in the list of all to-do items.</li>
				<li>Write a review for this book on Amazon.</li>
			</ol>
		</div>
	</body></html>