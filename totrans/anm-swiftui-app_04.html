<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-57"><a id="_idTextAnchor060"/>4</h1>
<h1 id="_idParaDest-58"><a id="_idTextAnchor061"/>Building a Record Player</h1>
<p>In this project, we will create a record player that will move an arm over the record, make the record spin, and play music when a button is pressed.</p>
<p>Sure, record players are a <a id="_idIndexMarker238"/>bit outdated now, but this project is a good way to learn new techniques about rotation – specifically, how to rotate objects around an anchor point. And you can always modify the design to look like a turntable, as many DJs still use vinyl, especially due to the vinyl resurgence in the last few years.</p>
<p>You might be thinking, <em class="italic">didn’t we rotate circles in the first project?</em> Well, this project is different. In the last project, the rotation animation we applied was on SwiftUI-created shapes, (specifically, circles), but in this project, we will be applying a rotation animation onto a photo image, then controlling it with a button, and mixing in some sounds to add to the user experience.</p>
<p>Before we start, let’s list our objectives for this project:</p>
<ul>
<li>Adding images to the Assets catalog</li>
<li>Creating the record player elements</li>
<li>Combining all the elements into one view</li>
<li>Testing the project</li>
</ul>
<h1 id="_idParaDest-59"><a id="_idTextAnchor062"/>Technical requirements</h1>
<p>You can find the finished project in the <code>Chapter 4</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-60"><a id="_idTextAnchor063"/>Adding images to the Assets catalog</h1>
<p>Okay, let’s get started <a id="_idIndexMarker239"/>on the first objective: adding some images to<a id="_idIndexMarker240"/> the project. First, we need to create a new project in Xcode. I called mine <code>Record Player</code> (you can copy this name or choose something else if you like). Then, we need to fill out the other fields exactly as we did in the last chapter. Once this is done, we are ready to start.</p>
<p>When it comes to the images themselves, we need three: the record, the record player arm that will move over the record, and a wood grain image that we can use as the record player box. All of these images can be found on GitHub by clicking the link provided in the <em class="italic">Technical </em><em class="italic">requirements</em> section.</p>
<p>There are three main methods to add images to the project.</p>
<p>The first method is using Xcode’s special file folder <a id="_idIndexMarker241"/>called the <code>Assets.xcassets</code> file in Xcode and you will be taken to the Assets catalog. The catalog is split into two sections: the section on the left is where your files are listed, and the section on the right is where you can actually see your files when you click on them in the left pane. To bring your images into the catalog, simply drag them into the left column: </p>
<div><div><img alt="Figure 4.1: Adding files to the Assets catalog " src="img/B18674_04_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1: Adding files to the Assets catalog</p>
<p>These<a id="_idIndexMarker242"/> images will be accessible by referencing their<a id="_idIndexMarker243"/> name in the code we write (we will see how to do this shortly).</p>
<p>The second method to add image files to the project is just by dragging and dropping them into the Project navigator. However, this method includes the extra step of choosing how and where you want to copy the files into the project via the following pop-up window:</p>
<div><div><img alt="Figure 4.2: Adding files into the Project navigator " src="img/B18674_04_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2: Adding files into the Project navigator</p>
<p>Here, you want to make sure that you tick the checkbox that says <strong class="bold">Copy items if needed</strong>. That’s important because Xcode will copy your files into the project, so if they are no longer available on your computer, it won’t matter, as they are part of your project now. </p>
<p>You also want to make sure that you check the boxes for the specific target you want to copy those resources to. For example, if you want to build the app on your Mac, then you want to check the <strong class="bold">Record Player (macOS)</strong> option in the <strong class="bold">Add to targets</strong> box. If you’re just building it for the iPhone, then check the <strong class="bold">Record Player (iOS)</strong> option. You can also check both if you prefer.</p>
<p>The<a id="_idIndexMarker244"/> final method is opening the <strong class="bold">File</strong> menu and selecting<a id="_idIndexMarker245"/> the <strong class="bold">Add Files </strong><strong class="bold">to…</strong> option:</p>
<div><div><img alt="Figure 4.3: Adding files to the project via the File menu " src="img/B18674_04_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3: Adding files to the project via the File menu</p>
<p>Now that we have added all the images, the next objective is to create the record player.</p>
<h1 id="_idParaDest-61"><a id="_idTextAnchor064"/>Creating the record player elements</h1>
<p>To create <a id="_idIndexMarker246"/>our record player, we will create three separate files, each in charge of performing specific tasks: </p>
<ul>
<li>The first file will hold the record player box</li>
<li>The second file will hold the spinning record, the record player arm, and the button to control it</li>
<li>The third file will hold the sound file that will play when the record player animation <a id="_idIndexMarker247"/>starts</li>
</ul>
<p>Let’s get started with the first file.</p>
<h2 id="_idParaDest-62"><a id="_idTextAnchor065"/>Creating the record player box</h2>
<p>To create the file to hold the<a id="_idIndexMarker248"/> record player box, in Xcode, open the <strong class="bold">File</strong> menu, select <strong class="bold">New</strong>, then select <strong class="bold">File</strong>. You will notice that this brings up several template options:</p>
<div><div><img alt="Figure 4.4: Creating a new SwiftUI file " src="img/B18674_04_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4: Creating a new SwiftUI file</p>
<p>Looking at the top of the window, the row of tabs lets you select which platform you want to write code for. We’re only interested in iOS apps, so select the <strong class="bold">iOS</strong> tab. Then, under the <strong class="bold">User Interface</strong> heading, select <strong class="bold">SwiftUI View</strong>.</p>
<p>Click <code>RecordPlayerBox</code>. Make sure your targets are selected in the checkboxes so that the file and everything it contains will work correctly when you run the project. Once your targets have been set, click <strong class="bold">Create</strong>. </p>
<p>Now, we have our <a id="_idIndexMarker249"/>new file to write our code, and you’ll notice it’s the same as the <code>ContentView</code> file, except it’s called <code>RecordPlayerBox</code>. Working in the <code>body</code> property, we will start with a <code>ZStack</code>; this will be our main stack to hold all of our views. Within the <code>ZStack</code>, we can build a rectangle using one of the images in the Assets catalog. Enter the following code, and then let’s look at what it does:</p>
<pre class="source-code">
ZStack {
            Rectangle()
                .frame(width: 345, height: 345)
                .cornerRadius(10)
            Image("woodGrain")
                .resizable().frame(width: 325, height: 325)
                .shadow(color: .white, radius: 3, x: 0, y: 0)
        }</pre>
<p>First, we added a <code>Rectangle</code> view, and then, using the <code>frame</code> modifier, it gets a dimension of <code>345</code> points for the width and height, making a square.</p>
<p>Then, using the <code>cornerRadius</code> modifier, we rounded the corners of the rectangle by <code>10</code> points.</p>
<p>The next line of code is the <code>Image</code> initializer, which is a view that displays an image. We want to use the wood grain image that’s in the Assets catalog, so we accessed it by typing the image’s name within quotes to create a string inside the <code>Image</code> initializer. In our case, we typed <code>"woodGrain"</code>.</p>
<p>Now we have our image, but we have to resize it. In order to do that, we need to use the <code>resizable</code> modifier, which is used to prepare an image or other view to be resized so it fits within its parent view. When it’s applied to an <code>Image</code> view, the <code>resizable</code> modifier will determine how the image should be scaled to fit within the space available.</p>
<p>Then, the <code>frame</code> modifier resizes the wood image to a width and height of <code>325</code> points. This will make it a little smaller than the <code>Rectangle</code> dimensions; however, making it smaller will allow some of the rectangle edges to show through, creating a border. The reason why the border is black is that the default color for creating a rectangle shape is black, as it is with all shapes. We can change it to any color we want by using a <code>color</code> modifier, but I think I’ll leave it black here.</p>
<p>The final line of <a id="_idIndexMarker250"/>code creates a shadow by using the <code>shadow</code> modifier. Again, all the modifiers we are adding are for the wood grain image, so each modifier placed on the wood grain has its own specific task of modifying the wood grain image in some way. Since this modifier is placed on the wood grain image and is using a white color, a white shadow will be radiating around the image. Setting the radius to a value of <code>3</code> means the shadow will extend out from the image by 3 points. We can also choose to put a value in for the <code>x</code> and <code>y</code> parameters, which will move the shadow on those axes either left, right, up, or down. </p>
<p>How much the shadow is moved depends on the size of the value you put in. For example, if you put a value of <code>10</code> in for the <code>x</code> parameter, the shadow will extend out from the right edge 10 points; if you put a value of <code>10</code> in for the <code>y</code> parameter, the shadow will extend out 10 points from the bottom edge of the box. I put in a value of <code>0</code> because I want the shadow directly over the wood grain image; it won’t be shifted left or right or up and down. </p>
<p>Play with these numbers and with the color of the shadow so you can see how much the values that we’ve used affect the shadow location and intensity. Don’t expect to see much of a difference with this <code>shadow</code> modifier yet though, because its color is white, and we’re working over a white background. When we add a gradient to the whole background later, the shadow will become more prominent. </p>
<p class="callout-heading">Note</p>
<p class="callout">You can easily see which modifiers you have on any given view by the way Xcode indents them. For example, look at the <code>Rectangle</code> view again. Its two modifiers, <code>frame</code> and <code>cornerRadius</code>, are indented to the right, which means they are acting on the rectangle only. The same goes for <code>Image("Woodgrain")</code>; its two modifiers are indented to the right as well.</p>
<p class="callout">Here’s a quick shortcut if your code starts to get messy and the indenting is not lined up: press <em class="italic">Command</em> + <em class="italic">A</em> to select everything in the file, and then press <em class="italic">Control</em> + <em class="italic">I</em>. Xcode then properly indents the whole file, every bit of code, in one go.</p>
<p>Now, look at <strong class="bold">Preview</strong> to see <a id="_idIndexMarker251"/>how your record player box looks. The following is what I have according to the code we have written:</p>
<div><div><img alt="Figure 4.5: The finished box " src="img/B18674_04_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5: The finished box</p>
<p>Before we continue, I want to show you how you can alter the previews to display your creations in a size that fits the view or views on the screen. Notice in <em class="italic">Figure 4</em><em class="italic">.5</em> that our box is much smaller than the iPhone <strong class="bold">Preview</strong> screen; sometimes, you might want to preview what you make in a screen size that fits the size of the view you just made – in our example, we made a box view. Here is how to shrink the <strong class="bold">Preview</strong> screen down to fit the box view.</p>
<p>At the bottom of every SwiftUI file is a struct that will have the same name as the struct we just used to write our code. This is a special struct that is used for development purposes, and it creates the <strong class="bold">Preview</strong> window that we need so we can see our work in real time. </p>
<p>Inside the<a id="_idIndexMarker252"/> preview struct, add this modifier right at the end of the <code>RecordPlayerBox()</code> code:</p>
<pre class="source-code">
.previewLayout(.sizeThatFits).padding()</pre>
<p>Using the <code>sizeThatFits</code> value will bring the <strong class="bold">Preview</strong> window size down to about the same size as our finished box. I don’t want it exactly the same size, so I added a bit of padding around it. Here is the result:</p>
<div><div><img alt="Figure 4.6: The finished box fitting to the Preview screen " src="img/B18674_04_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6: The finished box fitting to the Preview screen</p>
<p>By using<a id="_idIndexMarker253"/> the <code>previewLayout</code> modifier, you can customize the <strong class="bold">Preview</strong> window to suit your needs.</p>
<p>And that’s our finished box. Simple, right? Now, with the record player box done, we can move on to our next objective: creating the spinning record.</p>
<h2 id="_idParaDest-63"><a id="_idTextAnchor066"/>Creating the spinning record</h2>
<p>As mentioned earlier, our <a id="_idIndexMarker254"/>second file is going to contain the record code. However, for simplicity’s sake, we’re actually going to make the record player arm and button in this file too. We could split those tasks up into separate files as we did with the box, so each part has its own file, but I think that for this small project, this one file will do the job for us. </p>
<p>Since we are creating three different views in this one file, let’s give it a name that reflects each view the file will have, so <code>RecordButtonArmView</code>. Now, do you remember how to make a new SwiftUI file? If not, jump back to the <em class="italic">Creating the record player box</em> section for a refresher. There’s also a shortcut to creating a new file: simply press <em class="italic">Command</em> + <em class="italic">N</em> and choose the file template you want to use; we want the <strong class="bold">SwiftUI View</strong> template from the options.</p>
<p>With the file made, let’s <a id="_idIndexMarker255"/>work on making that spinning record. As we have done before, we will need properties to make everything work, so working at the top of the file, within the struct, add the following variables:</p>
<pre class="source-code">
    @State private var rotateRecord = false
    @State private var moveArm = false
    @State private var duration = 0.0
    
    var animateForever: Animation {
        Animation.linear(duration: duration)
            .repeatForever(autoreverses: false)
    }</pre>
<p>One of these variables is a little different, so let me explain what we’re doing.</p>
<p>The first three variables are <code>State</code> variables. The <code>rotateRecord</code> variable is going to keep track of the spinning record and will initiate the spinning animation when its value changes to <code>true</code>. The next <code>State</code> variable, <code>moveArm</code>, will keep track of the record player arm, and the third <code>State</code> variable, <code>duration</code>, is used to set the duration of the spinning record.</p>
<p>The final variable is a computed property. A computed property<a id="_idIndexMarker256"/> is a property that does not store a value but is, instead, computed every time it is accessed, meaning the code in its body will run every time the variable is used. The property we made is of the <code>Animation</code> type, which means we can use this in the <code>animation</code> modifiers.</p>
<p>By using <code>Animation.linear</code>, we initialize this variable with a linear timing curve for the animation. Remember we talked about timing curves in <a href="B18674_02.xhtml#_idTextAnchor034"><em class="italic">Chapter 2</em></a> – a linear curve is a curve with no easing in or easing out; it’s simply a steady, non-fluctuating animation from the beginning to the middle, and to the end.</p>
<p>Then, by keeping the <code>duration</code> parameter as <code>0</code>, this means the animation will have no duration and cannot start yet. This will change in order to start the animation later. </p>
<p>Then, we’re using the <code>repeatForever</code> option because we want the spinning record to keep going until we stop it. And finally, the <code>autoReverses</code> parameter is set to <code>false</code>, as we don’t want the record to spin backward. </p>
<p>Using a <a id="_idIndexMarker257"/>computed property in this way simplifies things, as now we only need to pass that property into the <code>animation</code> modifier, and four values will have been set with one computed property: <code>Animation.linear</code> curve, <code>duration</code>, <code>repeatForever</code>, and <code>autoReverses</code>. A computed property is also helpful if you are calling the animation modifier in several different places because rather than changing all the separate places to alter the animation, you could simply change the variable in one place. For example, if you want the auto-reverse feature in all of your other animations, all you have to do is change <code>autoreverses</code> in one place to <code>true</code>.</p>
<p>We now have all the variables we need to set up this file. Next, we will actually add the record. Let’s first put everything in a main <code>ZStack</code>, which will hold all the views:</p>
<pre class="source-code">
ZStack {
Image("record").resizable()
               .frame(width: 280, height: 280)
               .rotationEffect(Angle(degrees: rotateRecord ?                  360.0 : 0.0))
               .animation(animateForever.delay(1.5), value:                  rotateRecord)
 }</pre>
<p>The first line of code accesses the <code>"record"</code> image in the Assets catalog to create the record on the screen by using the <code>Image</code> initializer (just as we did with the <code>"</code><code>woodGrain"</code> image).</p>
<p>Next, by using the <code>resizable</code> modifier again to initiate the resizing, we can change the size of the record image by using the <code>frame</code> modifier. Passing in a value of <code>280</code> points for the width and height makes the image just right for the screen.</p>
<p>In the next line of code, we added the <code>rotationEffect</code> modifier to the record. This modifier will rotate (or spin) the image to any angle we want. For the <code>degrees</code> parameter, we’re using the ternary operator and rotating the record <code>360</code> degrees, which is one full rotation. So, the record will spin one complete revolution, but it will only do so when the <code>rotateRecord</code> variable becomes <code>true</code>. </p>
<p>Next, we added the animation to the record, by using the <code>animation</code> modifier and passing in the <code>animateForever</code> computed property for its first parameter. Remember, this property is doing a few things for us already: it’s setting a timing curve to linear, making the animation repeat forever, and stopping the animation from playing in reverse.</p>
<p>Notice the <a id="_idIndexMarker258"/>use of the <code>delay</code> modifier. This will add a 1.5-second delay to the start of the spinning record. This delay is added because old record players didn’t start spinning until the arm swung over the record first. This will add a little realism to the animation.</p>
<p>Finally, the animation’s <code>value</code> parameter gets passed in the <code>rotateRecord</code> variable, which supplies the animation to the record.</p>
<p>Before we move onto the record player arm, let’s make <strong class="bold">Preview</strong> smaller so it reflects the size of the record, just like we did with the box:</p>
<pre class="source-code">
struct RecordButtonArmView_Previews: PreviewProvider {
    static var previews: some View {
        RecordButtonArmView()
            <strong class="bold">.previewLayout(.sizeThatFits).padding()</strong>
    }
}</pre>
<p>Now, the record is complete and ready to spin some tunes. Here’s what it looks like:</p>
<div><div><img alt="Figure 4.7: Record disk " src="img/B18674_04_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7: Record disk</p>
<p>Nothing will <a id="_idIndexMarker259"/>happen yet because we have to add the other views and functionality, but we’re making good progress. Next up, let’s work on the record player arm.</p>
<h2 id="_idParaDest-64"><a id="_idTextAnchor067"/>Creating the record player arm</h2>
<p>With the spinning record<a id="_idIndexMarker260"/> completed, the next objective is the record player’s arm. Still working in the <code>RecordButtonArmView</code> file, here is the code I want you to add, just underneath the call to the <code>animation</code> modifier for the record:</p>
<pre class="source-code">
//Arm
            Image("playerArm").resizable()
                .aspectRatio(contentMode: .fit)
                .frame(width: 150, height: 150)
                .shadow(color: .gray, radius: 2, x: 0, y: 0)
                .rotationEffect(Angle.degrees(-35), anchor:                   .topTrailing)
                .rotationEffect(Angle.degrees(moveArm ? 8 : 0),                   anchor: .topTrailing)
                .animation(Animation.linear(duration: 2),value:                   moveArm)
                .offset(x: 75, y: -30)</pre>
<p>Similar to the <a id="_idIndexMarker261"/>record image, we use the <code>Image</code> initializer to display the <code>"playerArm"</code> image that we imported earlier into the Assets catalog. It gets resizable behaviors using the <code>resizable</code> modifier, and the aspect ratio is set to <code>fit</code>, which will fit the image proportionally on the screen. Next, the image’s width and height are set to <code>150</code> points, using the <code>frame</code> modifier, as we have seen before.</p>
<p>Continuing, the next line of code sets a shadow with a gray color and casts it around the arm with a <code>2</code>-point radius. If you like, you can change the radius to whatever size you prefer, and experiment to see what works for you.</p>
<p>Then, the arm gets rotated by -35 degrees; this value lines it up perpendicular with the record on the left. Also, we set the anchor point here to <code>topTrailing</code>, so when the arm swings over the record, the <code>topTrailing</code> (or top-right) anchor point will not move but will serve as a pivot point for the whole arm to move.</p>
<p>The next line of code calls the <code>rotationEffect</code> modifier again – this time, passing in the <code>moveArm</code> variable. Once this becomes <code>true</code>, the arm will move <code>8</code> points to the left, and when it’s <code>false</code>, it goes back to its original spot, using a value of <code>0</code>. </p>
<p>As we have seen, to have an animation, we need the <code>animation</code> modifier, which is the next line of code. This has a linear timing curve and sets the animation to 2 seconds to complete, meaning it should take the arm 2 seconds to move over the record.</p>
<p>Finally, we need to position the arm just right in relation to the spinning record, so using the <code>offset</code> modifier here, we can place it exactly where we want on the record player box. For our purposes, a record player’s arm is usually placed to the right of the record, with an inch or two of spacing between the arm and the record.</p>
<p>Here’s what<a id="_idIndexMarker262"/> the project should look like so far with the arm in place:</p>
<div><div><img alt="Figure 4.8: Record player arm " src="img/B18674_04_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8: Record player arm</p>
<p>We’re actually almost done with the project, but two more key components are needed. </p>
<p>The first of these is a button that will start and stop the animation. This will be a dynamic button, meaning that the title of the button will change depending on what it’s doing. If the record player is not playing a record, we will keep the button color black, display the word <strong class="bold">Play</strong>, and show the triangular <em class="italic">play</em> symbol. If the record player is playing the record, then the button will be red, display the word <strong class="bold">Stop</strong>, and show the square <em class="italic">stop</em> symbol instead. </p>
<p>The second <a id="_idIndexMarker263"/>component is to add sound to the project. This involves importing an audio/video framework specifically made for sound and video files.</p>
<p>Let’s tackle the button component first.</p>
<h2 id="_idParaDest-65"><a id="_idTextAnchor068"/>Adding a custom dynamic button</h2>
<p>A button<a id="_idIndexMarker264"/> is a control that performs an action when triggered. It can be configured to display a text label, an image, or both. When the user taps it, an action is sent to its target, which can trigger a method to be executed. So, let’s add one now. </p>
<p>Still working in <a id="_idIndexMarker265"/>the <code>RecordButtonArmView</code> file, as before, I will add the button code, and then explain how it works:</p>
<pre class="source-code">
                 //Button
                Button(action: {
                    rotateRecord.toggle()
                    if rotateRecord {
                        duration = 0.8
                        moveArm = true
                    } else {
                        duration = 0.0
                        moveArm = false
\                    }
                }) {
                    HStack() {
                        if !rotateRecord {
                            Text("Play").bold().                              foregroundColor(Color.black)
                            Image(systemName: "play.circle.                              fill").foregroundColor(Color.                              black)
                        } else {
                            Text("Stop").bold().                              foregroundColor(Color.black)
                            Image(systemName: "stop.fill").                              foregroundColor(Color.red)
                        }
                    }
                    .padding(.horizontal, 10)
                    .padding(.vertical, 5)
                    .background(Capsule().strokeBorder(Color.                      black, lineWidth: 2.00))
                }.offset(x: -105, y: 135)</pre>
<p>The <code>Button</code> control has an <code>action</code> parameter, and this is where we put the code that we want<a id="_idIndexMarker266"/> to be executed when the button is pressed. Inside this <code>action</code> closure, we toggled the <code>rotateRecord</code> variable before doing anything else. The reason for this is that we want the button to change the state of the variable because that’s the one that controls the spinning record. So, by toggling it, we’re changing the state right away.</p>
<p>Next, we checked to see what the state of <code>rotateRecord</code> is when using an <code>if else</code> statement. If it’s <code>true</code>, we set the duration variable to <code>0.8</code> seconds, as that’s how long we want it to take for the record to spin one revolution (this is a good speed for producing a spinning record effect). Next, we want to set the <code>moveArm</code> variable to <code>true</code> when the button is pressed, because setting that to <code>true</code> gets the arm to move over the record by <code>8</code> degrees. </p>
<p>All of that happens if <code>rotateRecord</code> is true, but if it’s <code>false</code>, the code falls into the <code>else</code> block. In the <code>else</code> block, the <code>duration</code> is set to <code>0</code>, which effectively stops the record from spinning, and <code>moveArm</code> is set to <code>false</code>, which will allow the arm to animate back to its original starting position: off the record, and to the right side. </p>
<p>Then, we move into the labeling part of the button. Within this initializer, I declared an <code>HStack</code>, and inside there, another <code>if else</code> statement. I’m using the not operator (<code>!</code>) in front of the <code>rotateRecord</code> variable too, which will read like this: if the <code>rotateRecord</code> variable is not <code>true</code> (this is another way of saying the variable is <code>false</code>), then the record is not playing, so set the text for the button to the word <code>"Play"</code>, make it bold and black, and provide a system image for it (a triangular <em class="italic">play</em> button). But if the code falls into the <code>else</code> block here, it means the record is spinning; in this case, we want to make the text bold, change the foreground color to red, and provide a system image of a <em class="italic">stop</em> button. </p>
<p>To finish off the button, we added a little bit of padding on its horizontal and vertical sides, gave it a capsule shape, and used the <code>strokeBorder</code> modifier to put a <code>2</code>-point black line<a id="_idIndexMarker267"/> around the button.</p>
<p class="callout-heading">Note</p>
<p class="callout">You might be wondering, why use the not operator (<code>!</code>) when you can say <code>if false</code> instead? You can use the <code>if false</code> statement instead of <code>if !true</code>, but the <code>!</code> operator can help to make your code more readable. For example, consider the following code:</p>
<p class="callout"><code>if !</code><code>fingerprintAccepted {</code></p>
<p class="callout"><code>    //</code><code>access granted</code></p>
<p class="callout"><code>} </code><code>else {</code></p>
<p class="callout"><code>    //</code><code>access denied</code></p>
<p class="callout"><code>}</code></p>
<p class="callout">The <code>!</code> operator negates the Boolean value, making the code more readable because it emphasizes the opposite of what is expected. In the example, if <code>fingerprintAccepted</code> is <code>false</code>, access will be granted. If <code>fingerprintAccepted</code> is <code>true</code>, access will be denied. The <code>!</code> operator makes it clear that the code is checking for the opposite of <code>fingerprintAccepted</code>.</p>
<p>With that <a id="_idIndexMarker268"/>code placed into your project, the current interface should look like this:</p>
<div><div><img alt="Figure 4.9: Adding the button control " src="img/B18674_04_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9: Adding the button control</p>
<p>Now, there’s a <strong class="bold">Play</strong> button to control the record. Next up, we want our record player animation to actually play sound, so let’s do that.</p>
<h2 id="_idParaDest-66"><a id="_idTextAnchor069"/>Creating a sound file to play audio</h2>
<p>Now, we are <a id="_idIndexMarker269"/>going to add sound to the project so that it plays when the record spins. To do this, navigate back to the GitHub folder for this project and drag the <code>.m4a</code> file called <code>music</code> into the Project navigator. Make sure to check the <strong class="bold">Copy files to project</strong> box if that box is unchecked.</p>
<p>With our <code>.m4a</code> audio file, we need to create a separate Swift file for this sound. Press <em class="italic">Command</em> + <em class="italic">N</em> to create a new file, but instead of creating a SwiftUI View file, we will create a simple Swift file instead. Then, name it <code>PlaySound</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">The main difference between a SwiftUI View file and Swift file is the purpose of the code contained in the file. A SwiftUI View file contains the code needed to define a view and its layout, while Swift file can contain a wide range of code that is not specifically related to defining views.</p>
<p>In this file, the first thing we need to do is import the <code>AVFoundation</code> framework:</p>
<pre class="source-code">
import AVFoundation</pre>
<p>The <code>AVFoundation</code> framework <a id="_idIndexMarker270"/>includes classes and methods that allow developers to manipulate and work with audio and video in their apps.</p>
<p>Next, let’s instantiate (create) an audio player:</p>
<pre class="source-code">
var audioPlayer: AVAudioPlayer?</pre>
<p>Notice that this variable is an optional type, denoted by a question mark at the end. I made it optional because if for any reason the music file cannot be found within the project, it will stop the app from crashing. Instead, the app will still work but simply won’t play the music.</p>
<p>Now, let’s now create a function called <code>playSound</code> that will search through the project for the audio file, and load it if it finds it:</p>
<pre class="source-code">
func playSound(sound: String, type: String) {
    if let path = Bundle.main.path(forResource: sound, ofType: type) {
        do {
            audioPlayer = try AVAudioPlayer(contentsOf:               URL(fileURLWithPath: path))
            audioPlayer?.play()
        } catch {
            print("Could not find and play the sound file")
        }
    }
}</pre>
<p>Here’s how the function works. It has two parameters, both of which are strings: one is called <code>sound</code> and the other is called <code>type</code>. </p>
<p>The first <a id="_idIndexMarker271"/>thing we do is to create a <code>path</code> constant using what is <a id="_idIndexMarker272"/>called <code>if let</code> statement. Optional binding is a feature that lets us check the value of an optional, and if there is a value in it (meaning it’s not nil), then bind that optional to a variable or constant.</p>
<p>This constant called <code>path</code> will be assigned a path from the app’s bundle. The bundle is where the app and its resources are stored, and we need to get the path to the sound file that we added to the project, which is in the app’s bundle. We can access the main bundle of the app by using the <code>Bundle.main</code> property. This property returns a <code>Bundle</code> object that represents the main bundle of the app, and we can use this object to access any of the resources in the app, such as images, sounds, or other files.</p>
<p>So, the <code>if let</code> statement reads as follows: the code searches the main bundle for a file with the given sound’s name and type extension. If found, the file path is stored in the <code>path</code> constant and runs the code in the <code>do</code> block. Otherwise, if for whatever reason the path to the file can’t be found, then the file we are looking for is missing or corrupt, and the flow of the program will proceed into the <code>catch</code> block and execute the code there.</p>
<p>Okay, let’s assume the file path has found our sound file, then the code moves into the <code>do</code> block, in which the code will try to create an audio player using that <code>path</code> constant. If that is successful, then it will try to play that file. But again, if for any reason the file can’t be played, the code will then fall into the <code>catch</code> block and print an error message to the console (<code>"Could not find and play the sound file"</code>). That error message won’t be shown to the user, it’s only for our debugging purposes, but the user’s app won’t crash with this code in place; the sound just won’t play. </p>
<p class="callout-heading">Note</p>
<p class="callout">Here, it would be helpful to show the user an alert if we fall into the <code>catch</code> block; however, we won’t do that just yet. If you would like to do this, we will cover this in <a href="B18674_12.xhtml#_idTextAnchor172"><em class="italic">Chapter 12</em></a>, where we create a word game. </p>
<p>Okay, we have <a id="_idIndexMarker273"/>everything in place to test the app, but before we can do that, we need to combine our three files – the <code>RecordPlayerBox</code>, <code>RecordButtonArmView</code>, and <code>PlaySound</code> files – into one unified view.</p>
<h1 id="_idParaDest-67"><a id="_idTextAnchor070"/>Combining all the elements into one view</h1>
<p>To put all of our <a id="_idIndexMarker274"/>finished views together into one unified grouping to make the finished project, let’s go back into the <code>ContentView</code> file and add the following code:</p>
<pre class="source-code">
struct ContentView : View {
    var body: some View {
        ZStack {
            //MARK: - ADD THE GRADIENT BACKGROUND
            RadialGradient(gradient: Gradient(colors: [.white,              .black]), center: .center, startRadius: 20,              endRadius: 600)
                .scaleEffect(1.2)
                //.ignoresSafeArea()
            //MARK: - ADD THE RECORD PLAYER BOX
            RecordPlayerBox()
            
            //MARK: - ADD THE RECORD, THE BUTTON, AND THE ARM
                RecordButtonArmView()
        }
    }
}</pre>
<p>Again, we’re using <code>ZStack</code> as the main view because we want to layer our other views on top of each other.</p>
<p>First, let’s look at the <code>RadialGradient</code> view. This is a struct that takes an array of colors that are placed one by one between the open and closed brackets. Within those brackets, you can put as many colors as you want, separating each color by a comma (I’m using two colors: white and black). </p>
<p>The <code>RadialGradient</code> view <a id="_idIndexMarker275"/>works by using the first color in the array to color the center of the background, and subsequent colors will surround that center. Using <code>startRadius</code> and <code>endRadius</code> values of <code>20</code> and <code>600</code>, respectively, will make the radial gradient expand to cover the entire screen; however, it doesn’t include the safe areas of the iPhone (again, those are that little area by the notch at the top and a small area at the bottom of the phone). We can handle the safe areas in two ways: we can use the <code>ignoreSafeArea</code> modifier as we’ve done before, or we can use the <code>scaleEffect</code> modifier as we are doing here. By passing in <code>1.2</code> as a value for the <code>scaleEffect</code> modifier, the gradient scales up 1.2 times the size of the iPhone screen, covering all the edges. This is effectively doing the same thing as the <code>ignoreSafeArea</code> modifier would do. </p>
<p>The next line of code makes a call to the <code>RecordPlayerBox</code> view and places it over the gradient (remember that we are working in <code>ZStack</code>, so views get stacked up onto one another). The final line of code makes a call to <code>RecordButtonArmView</code>, placing it over the box, to complete the interface.</p>
<p>This is how our project will look (if you didn’t make any modifications along the way, that is):</p>
<div><div><img alt="Figure 4.10: The finished interface " src="img/B18674_04_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10: The finished interface</p>
<p>The final <a id="_idIndexMarker276"/>piece of the puzzle is to use the sound file that we created. This is easy to do, so as a challenge, try and think of where you would place the audio code to get the app to play music.</p>
<p>Did you figure it out? If you thought of putting code into the body of the button, then you are correct! The button is the view that controls the action: it gets the arm to swing over the record, and the record to spin, as well. So, inside the <code>RecordButtonArmView</code> file, and then inside the button’s <code>if</code> statement, add the following code:</p>
<pre class="console">
playSound(sound: "music", type: "m4a")</pre>
<p>This line of code calls the function that we made in the <code>PlaySound</code> file, passing in the name of our music file, which is simply called <code>music</code>, and the file extension for the <code>type</code> parameter, which is <code>m4a</code>. When the button is pressed, it means the user wants to spin the record and play the music, and this code will grab the music file and play it.</p>
<p>When the button is pressed again, that means the user wants to stop the music, so we need to add the following code to the <code>else</code> block to do just that:</p>
<pre class="console">
audioPlayer?.stop()</pre>
<p>This line of <a id="_idIndexMarker277"/>code calls the audio player that we created and uses the <code>stop</code> function to stop the music. Notice the use of the question mark before calling the <code>stop</code> function. That’s because the <code>audioPlayer</code> variable was created as an optional. When we create optional variables, we need to use the question mark or exclamation mark when using them too.</p>
<h1 id="_idParaDest-68"><a id="_idTextAnchor071"/>Testing the project</h1>
<p>And with that, the project is<a id="_idIndexMarker278"/> done. Let’s come back to <code>ContentView</code> and test everything out. If you hit the <strong class="bold">Play</strong> button in the <strong class="bold">Preview</strong> window or run it in the simulator, you should see that the record won’t start spinning until the player’s arm is directly over the record. As the record starts spinning, you should hear a golden oldy from the big band era of the 40s, complete with the scratchy intro sound that old records were notoriously famous for. You will also notice that the text on the button changes from <strong class="bold">Play</strong> to <strong class="bold">Stop</strong>, and the color of the button changes from black to red, as shown in this figure:</p>
<div><div><img alt="Figure 4.11: The spinning record " src="img/B18674_04_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11: The spinning record</p>
<p>When you<a id="_idIndexMarker279"/> press <strong class="bold">Stop</strong>, the arm goes back to its original place, the record stops, and the <strong class="bold">Play</strong> button will reappear again.</p>
<p>After all of that, that completes our second project!</p>
<h1 id="_idParaDest-69"><a id="_idTextAnchor072"/>Summary</h1>
<p>To recap what we covered in this project, we added images to the Assets catalog and accessed them in our code. Then, we created three separate files to hold the elements that we need – one to hold the record player box; one to hold the spinning record, the arm moved with an anchor point, and a dynamic button; and one in which we wrote code to access a sound file. Once we created these elements, we merged them into one view, to create a record and animated record player.</p>
<p>In the next chapter, we’re going to continue working with Swift animations by exploring colors. We will create a simple project that displays various images and then, using <code>hueRotation</code>, change the color of the images to display a kaleidoscope effect. We will also look at how to pass data bidirectionally to another view, which gives up more flexibility than using the <code>@State</code> property wrapper.</p>
</div>
<div><div></div>
</div>
</body></html>