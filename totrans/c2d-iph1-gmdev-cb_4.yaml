- en: Chapter 4. Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Box2D setup and debug drawing
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating collision response routines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using different shapes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging and collision filtering
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating physical properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying impulses
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying forces
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous body destruction
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using joints
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vehicle
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character movement
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating bullets
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating and rendering a rope
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a top-down isometric game engine
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For years, physics engines have been used in video games to add a sense of
    realism to the action onscreen. In many games, physics plays a crucial role within
    the gameplay. Cocos2d comes bundled with two popular 2D physics engines: **Box2D**
    and **Chipmunk**. In this chapter, we will explain the most common uses of physics
    in games using Box2D as our engine of choice. Most of the recipes here can be
    easily modified to use Chipmunk or any other similar physics engine.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: Box2D setup and debug drawing
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first physics recipe, we will explore the basics of creating a Box2D
    project and setting up a Box2D world. The example creates a scene that allows
    the user to create realistic 2D blocks.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Box2D setup and debug drawing](img/4002_04_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a Box2D project using the built-in
    Box2D project template:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New Project**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **User Templates** click on **Cocos2d**.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right click on **Cocos2d Box2d Application**.![How to do it...](img/4002_04_02.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Choose**, name your project, and hit **Save**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Box2D sample project is a simple way to understand what a physics system
    looks like.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization:'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon initialization of the `b2World` object, we set a few things including
    gravity, object **sleeping**, and continuous physics. Sleeping allows bodies that
    are at rest to take up less system resources. Gravity is typically set to a negative
    number in the Y direction but can be reset at any time using the following method
    on `b2World`:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In addition to storing a pointer to the main b2World instance, we also usually
    store a pointer to an instance of `GLESDebugDraw`.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Debug drawing:'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug drawing is handled by the `GLESDebugDraw` class as defined in `GLES-Render.h`.
    Debug drawing encompasses drawing five different elements onscreen. These include
    **shapes, joint** connections, **AABB**s (axis-aligned bounding boxes), **broad-phase**
    pairs, and a **center of mass** bit.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visual to physical drawing ratio:'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the constant `PTM_RATIO` at 32, to allow consistent conversion between
    the physical world and the visual world. **PTM** stands for **pixel to meter**.
    Box2D measures bodies in meters and is built and optimized to work with bodies
    between the sizes of 0.1 to 10.0 meters. Setting this ratio to 32 is a common
    convention for optimal shapes to appear between 3.2 to 320 pixels on screen. Optimization
    aside, there is no upper or lower limit to Box2D body size.
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将常量`PTM_RATIO`定义为32，以便在物理世界和视觉世界之间进行一致的转换。**PTM**代表**像素到米**。Box2D以米为单位测量身体，并构建和优化以与0.1到10.0米大小的身体一起工作。将此比例设置为32是屏幕上形状出现3.2到320像素之间的常见约定。除了优化之外，Box2D身体大小没有上限或下限。
- en: 'Level boundaries:'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡边界：
- en: 'In this and many future examples, we add a level boundary roughly encompassing
    the entire screen. This is handled with the creation of a `b2Body` object with
    four **fixtures**. Each fixture has a `b2Polygon` shape that defines a single
    **edge**. Creating an edge typically involves the following:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个和许多未来的示例中，我们添加了一个大致覆盖整个屏幕的水平边界。这是通过创建一个具有四个**固定体**的`b2Body`对象来处理的。每个固定体都有一个定义单个**边缘**的`b2Polygon`形状。创建边缘通常涉及以下步骤：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Because these edges have no corresponding visual components (they are invisible),
    we do not need to set the `bodyDef.userData` pointer.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于这些边缘没有相应的视觉组件（它们是不可见的），我们不需要设置`bodyDef.userData`指针。
- en: 'Creating the blocks:'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建方块：
- en: Blocks are created much in the same way that the level boundaries are created.
    Instead of calling `SetAsEdge`, we call `SetAsBox` to create a box-shaped polygon.
    We then set the `density` and `friction` attributes of the **fixture**. We also
    set `bodyDef.userData` to point to the `CCSprite` we created. This links the visual
    and the physical, and allows our `step:` method to reposition sprites as necessary.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 块的创建方式与创建关卡边界的方式大致相同。我们不是调用`SetAsEdge`，而是调用`SetAsBox`来创建一个矩形多边形。然后我们设置**固定体**的`density`和`friction`属性。我们还设置`bodyDef.userData`以指向我们创建的`CCSprite`。这连接了视觉和物理，并允许我们的`step:`方法根据需要重新定位精灵。
- en: 'Scheduling the world step:'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排世界步长：
- en: 'Finally, we schedule our `step` method. In this method, we run one discrete
    `b2World` step using the following code:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，我们安排我们的`step`方法。在这个方法中，我们使用以下代码运行一个离散的`b2World`步长：
- en: '[PRE3]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The Box2D `world Step` method moves the physics engine forward one step. The
    Box2D constraint solver runs in two phases: the velocity phase and position phase.
    These determine how fast the bodies move and where they are in the game world.
    Setting these variables higher results in a more accurate simulation at the cost
    of speed. Setting `velocityIterations` to 8 and `positionIterations` to 3 is the
    suggested baseline in the Box2D manual. Using the dt variable syncs the logical
    timing of the application with the physical timing. If a game step takes an inordinate
    amount of time, the physics system will move forward quickly to compensate. This
    is referred to as a **variable time step**. An alternative to this would be a
    **fixed time step** set to 1/60th of a second. In addition to the physical step,
    we also reposition and re-orientate all `CCSprites` according to their respective
    `b2Body` positions and rotations:'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Box2D的`world Step`方法将物理引擎向前推进一步。Box2D约束求解器在两个阶段运行：速度阶段和位置阶段。这些确定物体的移动速度以及它们在游戏世界中的位置。将这些变量设置得更高会导致更精确的模拟，但会牺牲速度。Box2D手册中建议将`velocityIterations`设置为8，将`positionIterations`设置为3。使用dt变量同步应用程序的逻辑时间与物理时间。如果游戏步长花费了过多的时间，物理系统将快速前进以补偿。这被称为**可变时间步长**。另一种选择是将时间步长设置为1/60秒的**固定时间步长**。除了物理步长之外，我们还将所有`CCSprites`根据它们各自的`b2Body`位置和旋转进行重新定位和重新定向：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Taken together, these pieces of code sync the physical world with the visual.
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将这些代码片段放在一起，可以将物理世界与视觉世界同步。
- en: Creating collision response routines
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建碰撞响应例程
- en: To make efficient and organized use of Box2D, we must create a few wrapper classes
    to encapsulate specific functionality. In this recipe, we will use these classes
    to add collision response routines to our simple falling block demo from the previous
    recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了高效且有序地使用Box2D，我们必须创建几个包装类来封装特定的功能。在这个菜谱中，我们将使用这些类将碰撞响应例程添加到之前菜谱中的简单下落方块演示中。
- en: '![Creating collision response routines](img/4002_04_03.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![创建碰撞响应例程](img/4002_04_03.jpg)'
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。另外，请注意，为了简洁，一些代码已被省略。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: How it works...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe lays the groundwork for the rest of this chapter. Here, we see the
    same block creation recipe from before except now a message is printed on the
    screen when either blocks collide with each other or they collide with a **sensor.**
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱为本章的其余部分奠定了基础。在这里，我们看到与之前相同的块创建菜谱，但现在当块相互碰撞或与 **传感器** 碰撞时，会在屏幕上打印一条消息。
- en: '`GameObject:`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObject:`'
- en: The `GameObject` class encapsulates Box2D data structures to help ease the process
    of Box2D object creation. It also includes a pointer back to its parent `GameArea`
    object as well as some other information we will use later. `GameObject` is intended
    to be an abstract base class that should be extended for specific uses.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameObject` 类封装了 Box2D 数据结构，以帮助简化 Box2D 对象创建的过程。它还包括一个指向其父 `GameArea` 对象的指针以及我们稍后会用到的其他信息。`GameObject`
    被设计为一个抽象基类，应该为特定用途进行扩展。'
- en: 'Sensors:'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传感器：
- en: A **fixture** attached to a `b2Body` can be set to 'sensor mode'. This allows
    collision response routines to run without the body actually existing in the world
    physically. No physical collision response will occur. We've encapsulated this
    functionality in the `GameSensor` class. An object of this class can be differentiated
    from other objects by checking its type property.
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 附着到 `b2Body` 上的 **固定体** 可以设置为 '传感器模式'。这允许碰撞响应例程在没有身体在物理世界中实际存在的情况下运行。不会发生物理碰撞响应。我们已经在
    `GameSensor` 类中封装了这个功能。可以通过检查其类型属性来区分此类对象的其他对象。
- en: '`GameMisc:`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameMisc:`'
- en: The `GameMisc` class exists as an example of a typical extension of `GameObject`.
    The only added functionality in `GameMisc` is the life variable that we will use
    in later recipes.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameMisc` 类作为一个典型的 `GameObject` 扩展的例子存在。在 `GameMisc` 中添加的唯一功能是我们将在后面的菜谱中使用的生命变量。'
- en: '`GameArea2D:`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameArea2D:`'
- en: The `GameArea2D` class is where the action happens. Here, we encapsulate most
    of the functionality outlined in the previous recipe. In addition to that, we
    have an instance of `DebugDrawNode` and an instance of `CCNode` entitled `gameNode`.
    These allow us to draw our debug information and our game information separately
    from the main scene. This feature will come in handy as recipes become more complex.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameArea2D` 类是动作发生的地方。在这里，我们封装了之前菜谱中概述的大多数功能。除此之外，我们还有一个 `DebugDrawNode` 实例和一个名为
    `gameNode` 的 `CCNode` 实例。这允许我们将调试信息和游戏信息分别从主场景中绘制出来。随着菜谱变得更加复杂，这个特性将非常有用。'
- en: 'Contact listeners:'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接触监听器：
- en: 'The class `b2ContactListener` is commonly overridden to allow for custom collision
    response handling. We extend `b2ContentListener` to create the `basicContentListener`
    class. There are four methods that can be extended to detect collision at a number
    of different intervals:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类 `b2ContactListener` 通常被重写以允许自定义碰撞响应处理。我们扩展 `b2ContactListener` 来创建 `basicContentListener`
    类。有四种方法可以扩展以在多个不同的间隔检测碰撞：
- en: '[PRE6]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The methods `BeginContact` and `EndContact` are fairly self-explanatory. The
    former is called when two fixtures begin to touch, the latter when they cease
    to touch. The `PreSolve` and `PostSolve` methods are called before and after the
    contact solver routine runs. We will use this functionality in a later recipe.
    For this recipe, we are only concerned with `BeginContact`. In this method, we
    retrieve two `GameObject` instances from `body->GetUserData()` and we pass them
    to the following method in the corresponding `GameArea` instance:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`BeginContact` 和 `EndContact` 方法相当直观。前者在两个固定体开始接触时被调用，后者在它们停止接触时被调用。`PreSolve`
    和 `PostSolve` 方法在接触求解器例程运行前后被调用。我们将在后面的菜谱中使用这个功能。对于这个菜谱，我们只关心 `BeginContact`。在这个方法中，我们从
    `body->GetUserData()` 中检索两个 `GameObject` 实例，并将它们传递给相应 `GameArea` 实例中的下一个方法：'
- en: '[PRE7]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: That method checks object types and finally displays different messages onscreen.
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 那个方法检查对象类型，并最终在屏幕上显示不同的消息。
- en: There's More...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this example, blocks are colliding with a static sensor. The sensor does
    not move because its body `type` attribute is set to `b2_staticBody`. Static bodies
    never move and they do not collide with each other. Each block has its `type`
    attribute set to `b2_dynamicBody`. Dynamic bodies move freely and collide with
    all other bodies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，方块正在与一个静态传感器发生碰撞。传感器不会移动，因为它的身体`type`属性被设置为`b2_staticBody`。静态物体永远不会移动，并且它们不会相互碰撞。每个方块都有其`type`属性设置为`b2_dynamicBody`。动态物体可以自由移动，并且与所有其他物体发生碰撞。
- en: Using different shapes
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用不同的形状
- en: The primary attribute a Box2D body has is its shape. Box2D uses two classes,
    `b2PolygonShape` and `b2CircleShape`, to represent any possible shape. In this
    recipe, we will create a number of different shapes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D身体的主要属性是其形状。Box2D使用两个类，`b2PolygonShape`和`b2CircleShape`，来表示任何可能的形状。在这个菜谱中，我们将创建许多不同的形状。
- en: '![Using different shapes](img/4002_04_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![使用不同的形状](img/4002_04_04.jpg)'
- en: Getting ready
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection02*以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we randomly create objects with five different shapes: square,
    circle, rectangle, an oddly shaped convex polygon, and a simple concave polygon.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们随机创建具有五种不同形状的物体：正方形、圆形、矩形、一个奇特的凸多边形和一个简单的凹多边形。
- en: 'Rectangles:'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 矩形：
- en: Rectangles are created using the `b2PolygonShape` method `SetAsBox` just like
    in the first two recipes. In this example, we have a simple textured square as
    well as a rectangular column image.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 矩形是通过与前面两个菜谱中相同的`b2PolygonShape`方法`SetAsBox`创建的。在这个例子中，我们有一个简单的纹理正方形以及一个矩形柱图像。
- en: 'Circles:'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 圆形：
- en: Circles are a special case in Box2D and they've been given a special class in
    `b2CircleShape`. After initialization, we simply set the `m_radius` variable of
    the circle shape. In this example, we also give the circle shaped objects a high
    `restitution` value to make them bounce. We will cover this in more depth in another
    recipe.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Box2D中，圆形是一个特殊情况，并且它们在`b2CircleShape`类中有一个特殊的类。初始化后，我们只需设置圆形形状的`m_radius`变量。在这个例子中，我们还给圆形形状的对象赋予了一个高的`restitution`值，使它们能够弹跳。我们将在另一个菜谱中更深入地介绍这一点。
- en: 'Convex polygons:'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凸形多边形：
- en: Individual polygons must be **convex**. This means that every angle inside the
    polygon is less than 180 degrees. For this example, we've created an oddly shaped
    convex polygon with 8 vertices. We are using `TexturedPolygon` to accurately draw
    this polygon. For more information about the `TexturedPolygon` class, please refer
    to Chapter 1, Graphics.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单个多边形必须是**凸形**。这意味着多边形内部的所有角度都小于180度。在这个例子中，我们创建了一个具有8个顶点的奇特形状的凸多边形。我们使用`TexturedPolygon`来准确绘制这个多边形。有关`TexturedPolygon`类的更多信息，请参阅第1章，图形。
- en: 'Concave polygons:'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 凹形多边形：
- en: '**Concave** polygons can be represented by creating multiple convex polygons
    and linking them to one body using multiple fixtures. In this example, we link
    two simple convex polygons together by creating two fixtures on the same body.
    We reverse our width and height values to create a simple L-shaped object. With
    this technique, you can create arbitrarily complex shapes.'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**凹形**多边形可以通过创建多个凸多边形并将它们通过多个固定件链接到单个物体上来表示。在这个例子中，我们通过在同一个物体上创建两个固定件将两个简单的凸多边形链接在一起。我们反转宽度和高度值以创建一个简单的L形物体。使用这种技术，你可以创建任意复杂的形状。'
- en: Extensibility of `GameObject:`
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObject`的扩展性：'
- en: The `GameObject` class is primarily designed for single fixture bodies. It contains
    one `CCSprite` object, one `b2FixtureDef`, and so on. However, as you can see
    in the concave polygon example, you can create multiple `CCSprite` objects and
    link them to the main `GameObject` sprite. You can also reuse the Box2D object
    pointers within the `GameObject` instance to easily create multiple fixtures and
    shapes.
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameObject`类主要是为单个固定件身体设计的。它包含一个`CCSprite`对象，一个`b2FixtureDef`等。然而，正如你在凹形多边形示例中看到的，你可以创建多个`CCSprite`对象并将它们链接到主要的`GameObject`精灵上。你还可以在`GameObject`实例内重用Box2D对象指针，以便轻松创建多个固定件和形状。'
- en: Dragging and collision filtering
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拖动和碰撞过滤
- en: In a previous recipe, we handled user input to allow the user to drag an object.
    In this example, we see a bowl filled with pieces of fruit that can be dragged
    across the screen. A piece of fruit does not collide with another piece of fruit.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的菜谱中，我们处理了用户输入，允许用户拖动一个物体。在这个例子中，我们看到一个装满水果的碗，这些水果可以在屏幕上拖动。一块水果不会与其他水果发生碰撞。
- en: '![Dragging and collision filtering](img/4002_04_05.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![拖动和碰撞过滤](img/4002_04_05.jpg)'
- en: Getting ready
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE9]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this example, we create a realistic ''grabbing'' effect. We achieve this
    by repositioning the nearest Box2D body with the `SetTransform` method:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个逼真的“抓取”效果。我们通过使用 `SetTransform` 方法重新定位最近的 Box2D 物体来实现这一点：
- en: '[PRE10]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We then store the previous distance the object was moved, to determine a final
    velocity and then to allow the object to be ''thrown'' when the user lets go.
    We apply this velocity using the `SetLinearVelocity` method:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后存储物体之前移动的距离，以确定最终速度，并允许用户松手时物体被“抛出”。我们使用 `SetLinearVelocity` 方法应用这个速度：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To suspend fruit in the air while the user has a finger on the screen, we set
    the object's velocity to `b2Vec2_zero` while it is grabbed.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在屏幕上有手指时，为了使水果悬浮在空中，我们将物体速度设置为 `b2Vec2_zero`，此时它被抓住。
- en: 'Collision filtering:'
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞过滤：
- en: 'In this example, we don''t allow a fruit to collide with other fruits so that
    they can sit nicely in the bowl. We achieve this by setting the `filter` property
    on the fruit''s fixture. Specifically, we set the `categoryBits` and `maskBits`:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们不允许水果与其他水果碰撞，以便它们可以整齐地放在碗中。我们通过设置水果的固定件上的 `filter` 属性来实现这一点。具体来说，我们设置了
    `categoryBits` 和 `maskBits`：
- en: '[PRE12]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `categoryBits` variable indicates what kind of object this is. The `maskBits`
    variable indicates what kind of objects this should collide with. Both of these
    properties use **bits** and **Boolean logic** to specify how the object should
    interact. For example, | means "or". So, we are saying that the `CB_FRUIT` category
    can collide with `CB_GROUND` or `CB_BOWL` categories. Alternatively, filters can
    be set using **filter groups**. Also note that, if you do not specify the fixture''s
    `filter` variable on object then it will not collide with an object that has a
    set filter. For more information about filtering, please refer to the Box2D manual
    at: [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`categoryBits` 变量表示这是什么类型的物体。`maskBits` 变量表示它应该与哪些类型的物体碰撞。这两个属性都使用 **位** 和
    **布尔逻辑** 来指定物体应该如何交互。例如，| 表示“或”。因此，我们说 `CB_FRUIT` 类别可以与 `CB_GROUND` 或 `CB_BOWL`
    类别碰撞。或者，可以使用 **过滤器组** 来设置过滤器。此外，请注意，如果您没有指定对象的固定件的 `filter` 变量，则它将不会与设置了过滤器的对象碰撞。有关过滤器的更多信息，请参阅
    Box2D 手册：[http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)。'
- en: Manipulating physical properties
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操纵物理特性
- en: Box2D allows the user to set physical properties on bodies to create a wide
    array of effects. In this example, we see a block of ice pushing a box down a
    slope. We also see a number of bouncing balls.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 允许用户在物体上设置物理特性以创建各种效果。在这个例子中，我们看到一块冰块将箱子推下斜坡。我们还看到了一些弹跳球。
- en: '![Manipulating physical properties](img/4002_04_06.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![操纵物理特性](img/4002_04_06.jpg)'
- en: Getting ready
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: How it works...
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this example, we see multiple objects each with different physical properties.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们看到多个具有不同物理特性的物体。
- en: 'Density:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 密度：
- en: Body **density** determines how much force is required to move an object around.
    Two objects with different sizes and the same density will have different masses.
    The larger object will naturally take a larger force to move.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 物体的**密度**决定了移动物体所需的力的大小。两个大小不同但密度相同的物体将具有不同的质量。较大的物体自然需要更大的力来移动。
- en: 'Friction:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摩擦：
- en: '**Friction** determines how difficult an object is to move against another
    object. Physics nerds may point out the difference between static and kinetic
    friction. Box2D amalgamates them into one variable while assuming a constant static
    to kinetic ratio. In our example, the block of ice has absolutely no friction.
    This means that it will slide around on any surface. This allows the block to
    slowly push the crate down the ramp until it finally falls on the bouncing balls.'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**摩擦**决定了物体相对于另一个物体移动的难易程度。物理爱好者可能会指出静摩擦和动摩擦之间的区别。Box2D 将它们合并为一个变量，同时假设静摩擦和动摩擦的比例是恒定的。在我们的例子中，冰块完全没有摩擦。这意味着它可以在任何表面上滑动。这允许冰块慢慢地将箱子推下斜坡，直到它最终落在弹跳球上。'
- en: 'Restitution:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性系数：
- en: The term **restitution** is interchangeable with elasticity. This measures the
    'bounciness' of an object. An object with a restitution of `1.0f` will theoretically
    bounce forever. In our example, we see four balls each with a different restitution.
    This causes them to bounce at different rates. To see these differences in action,
    quickly grab the block of ice before it pushes the crate over the edge of the
    ledge.
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 术语**恢复系数**与弹性可以互换。这衡量了物体的“弹性”。具有恢复系数为 `1.0f` 的物体理论上会永远弹跳。在我们的例子中，我们看到四个具有不同恢复系数的球。这导致它们以不同的速率弹跳。为了看到这些差异的实际效果，请迅速抓住冰块，在它推动箱子越过边缘之前。
- en: Applying impulses
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 施加冲量
- en: In Box2D, bodies can be moved around using **impulses** and **forces**. In this
    recipe, we will use impulses to accurately shoot a basketball into a basketball
    net.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Box2D 中，可以使用**冲量**和**力**来移动物体。在这个菜谱中，我们将使用冲量来准确地将篮球射入篮球网。
- en: '![Applying impulses](img/4002_04_07.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![施加冲量](img/4002_04_07.jpg)'
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this scene, we see a basketball player shooting the ball into a basket. When
    he comes in contact with the ball he shoots it into the net.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们看到一名篮球运动员将篮球射入篮筐。当他接触到篮球时，他将篮球射入篮筐。
- en: 'Impulses:'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 冲量：
- en: 'When the basketball touches the basketball player, we reset the ball''s velocity
    and then we apply a precise impulse to accurately shoot the ball into the net:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当篮球触碰到篮球运动员时，我们重置篮球的速度，然后施加一个精确的冲量以准确地将篮球射入篮筐：
- en: '[PRE15]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Applying an impulse, immediately changes the **momentum** of the body. Instead
    of applying a force over time, an impulse applies instantaneous force to immediately
    redirect an object. Impulses also wake up a sleeping body if necessary.
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用冲量，立即改变物体的**动量**。而不是在一段时间内施加力，冲量施加瞬时力以立即改变物体的方向。如果需要，冲量还会唤醒一个休眠的物体。
- en: '`GameObject` typeTag:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObject` 类型标签：'
- en: Instances of the `GameObject` class have heretofore been identified with the
    `type` property as specified by the extending class. For more granular object
    identification, you can use the `typeTag` enumeration. This allows us to tag objects
    to perform a number of tasks. In this example, we use `typeTag` during collision
    response to properly animate the basketball player as well as the basketball net.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameObject` 类的实例迄今为止已被扩展类指定的 `type` 属性所识别。为了进行更细粒度的对象识别，你可以使用 `typeTag` 枚举。这允许我们标记对象以执行多项任务。在这个例子中，我们使用
    `typeTag` 在碰撞响应期间正确地动画化篮球运动员以及篮球网。'
- en: Applying forces
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 施加力
- en: Unlike impulses, forces must be applied over time to significantly move a body
    in the physical world. In this recipe, we see a simulation of our solar system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 与冲量不同，力必须在一段时间内施加才能在物理世界中显著移动一个物体。在这个菜谱中，我们看到我们太阳系的模拟。
- en: '![Applying forces](img/4002_04_08.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![施加力](img/4002_04_08.jpg)'
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Execute the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE16]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this scene, we see eight planets orbiting the sun. They orbit at roughly
    the same speed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，我们看到八个行星围绕太阳运行。它们的运行速度大致相同。
- en: 'Forces:'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 力：
- en: 'Each planet is having a constant force applied to it in the direction of the
    sun:'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个行星都受到一个指向太阳方向的恒定力的作用：
- en: '[PRE17]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This, combined with its initial momentum applied by an impulse, creates an orbit
    around the sun. The forces applied take into account planet size and distance
    from the sun in a way similar to how real gravity works.
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这，加上由冲量施加的初始动量，形成了一个围绕太阳的轨道。施加的力考虑了行星的大小和距离太阳的距离，其方式与真实重力相似。
- en: 'Torque:'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扭矩：
- en: When applying a force or an impulse, you must specify the point on the object
    where the force or impulse is applied. If this is not the exact center of mass,
    then a **torque** will also be applied to the object. This will change the angular
    velocity of the body and will make it spin.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当施加力或冲量时，你必须指定力或冲量作用在物体上的点。如果这不是物体的质心，那么物体还会受到**扭矩**的作用。这将改变物体的角速度并使其旋转。
- en: 'Gravity:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重力：
- en: As you can see in this example, setting gravity to `b2Vec2(0.0f, 0.0f)` creates
    a top-down physical simulation.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如你在本例中看到的，将重力设置为 `b2Vec2(0.0f, 0.0f)` 会创建一个从上到下的物理模拟。
- en: See also...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见...
- en: Setting gravity to `b2Vec2(0.0f, 0.0f)` creates a top-down simulation. We will
    use this technique in later recipes, including *Creating a top-down isometric
    game engine* found later in this chapter.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 将重力设置为 `b2Vec2(0.0f, 0.0f)` 创建一个上下模拟。我们将在后面的菜谱中使用这项技术，包括本章后面找到的 *创建上下等距游戏引擎*。
- en: Asynchronous body destruction
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步刚体销毁
- en: So far, we have learned how to create bodies, how to reposition them, and how
    to apply forces and impulses to move them around onscreen. In this example, we
    will see how to destroy a body during the physics simulation. This is naturally
    a very tricky process that can create bugs and cause game crashes if you're not
    careful.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经学习了如何创建刚体，如何重新定位它们，以及如何施加力和冲量来在屏幕上移动它们。在这个例子中，我们将看到如何在物理模拟期间销毁一个刚体。这是一个非常棘手的过程，如果不小心，可能会导致错误和游戏崩溃。
- en: '![Asynchronous body destruction](img/4002_04_09.jpg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![异步刚体销毁](img/4002_04_09.jpg)'
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。同时请注意，为了简洁，以下代码中省略了一些内容。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have the ability to throw grenades that explode after five
    seconds. The explosion launches any other objects in the immediate area.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们有能力投掷在五秒后爆炸的手榴弹。爆炸会发射出附近区域的其他任何物体。
- en: Destroying a `b2Body:`
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁 `b2Body`：
- en: 'Box2D does not allow bodies to be destroyed during a `world->Step(dt, velocityIterations,
    positionIterations)` call. Because of this, collision response routines and timed
    callbacks cannot synchronously initiate body destruction. To solve this problem,
    we have created a simple asynchronous system that can queue up bodies for destruction
    and creation. This system uses the following methods:'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Box2D 不允许在 `world->Step(dt, velocityIterations, positionIterations)` 调用期间销毁刚体。因此，碰撞响应例程和定时回调不能同步启动刚体的销毁。为了解决这个问题，我们创建了一个简单的异步系统，可以排队等待销毁和创建刚体。此系统使用以下方法：
- en: '[PRE19]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Bodies are created and destroyed after each physics step has completed.
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个物理步骤完成后都会创建和销毁刚体。
- en: '`GameObjectCallback` and `QueuedAction:`'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObjectCallback` 和 `QueuedAction`：'
- en: The `GameObjectCallback` and `QueuedAction` helper classes allow us to queue
    up method callbacks and `CCAction` instances to use after object creation/deletion.
    This can help maintain a logical order of operations when the game is running.
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`GameObjectCallback` 和 `QueuedAction` 辅助类允许我们在对象创建/删除后排队方法回调和 `CCAction` 实例以供使用。这有助于在游戏运行时保持操作逻辑的顺序。'
- en: '`GameObject` life:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameObject` 生命：'
- en: In the class `GameMisc`, we added a `life` value. In this recipe, we get to
    put it to use. Each grenade's `life` ticks away until it explodes. The explosion
    created is also a `GameMisc` object with a set amount of `life` corresponding
    to its animation duration. Life can also be used for actors and breakable objects.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 `GameMisc` 类中，我们添加了一个 `life` 值。在这个菜谱中，我们将使用它。每个手榴弹的 `life` 会逐渐减少直到爆炸。创建的爆炸也是一个
    `GameMisc` 对象，具有与其动画持续时间相对应的固定 `life`。生命值也可以用于演员和可破坏物体。
- en: Using joints
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用关节
- en: The last major feature of Box2D we have yet to investigate is **joints**. Joints
    allow us to link objects to create simple machines like pulleys, levers, and simple
    motors. In this recipe, we will learn how to create a simple seesaw using a joint.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们尚未调查 Box2D 的最后一个主要功能是 **关节**。关节允许我们将对象连接起来，创建像滑轮、杠杆和简单电机这样的简单机械。在这个菜谱中，我们将学习如何使用关节创建一个简单的跷跷板。
- en: '![Using joints](img/4002_04_10.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用关节](img/4002_04_10.jpg)'
- en: Getting ready
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。同时请注意，为了简洁，以下代码中省略了一些内容。
- en: How to do it...
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE20]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: How it works...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By dropping the heavy weight object on one side, we can launch the lighter boxes
    up into the air from the other side. This is achieved using a simple joint.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将重物放在一边，我们可以将轻质箱子从另一边抛向空中。这是通过一个简单的关节实现的。
- en: 'Joint types:'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关节类型：
- en: All joints link two Box2D bodies. Each joint is represented by a class that
    derives from `b2Joint`. These include `b2PulleyJoint, b2WeldJoint, b2RopeJoint,`
    and more. A comprehensive overview of all Box2D joint types is beyond the scope
    of this book. Please refer to the Box2D testbed for example code for each joint
    as well as the Box2D manual page at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有关节连接两个Box2D物体。每个关节都由一个从`b2Joint`派生的类表示。这些包括`b2PulleyJoint, b2WeldJoint, b2RopeJoint`等。Box2D所有关节类型的全面概述超出了本书的范围。请参阅Box2D测试床中的每个关节的示例代码以及Box2D手册页面[http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)。
- en: 'Revolute joints:'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转关节：
- en: 'In this example, we are using a `b2RevoluteJoint` to force two bodies to share
    a common anchor point:'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用`b2RevoluteJoint`来迫使两个物体共享一个共同的锚点：
- en: '[PRE21]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: By pinning the dynamic `plank` body to the static `triangle` body, in this example,
    we have constrained the movement of the `plank` on the X and Y axes. Now that
    it can't move, it can only rotate. This creates a realistic seesaw effect.
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过将动态的`plank`物体固定到静态的`triangle`物体上，在这个例子中，我们已经限制了`plank`在X轴和Y轴上的运动。现在它不能移动，它只能旋转。这产生了真实的跷跷板效果。
- en: Creating a vehicle
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建车辆
- en: Combining two or more joints can create some interesting effects. In this example,
    we will create a car that can be driven around a level.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 结合两个或多个关节可以产生一些有趣的效果。在这个例子中，我们将创建一个可以在关卡中驾驶的汽车。
- en: '![Creating a vehicle](img/4002_04_11.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![创建车辆](img/4002_04_11.jpg)'
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目*RecipeCollection02*以获取此菜谱的完整工作代码。此外，请注意，为了简洁，以下代码中省略了一些内容。
- en: How to do it...
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Execute the following code:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: By pressing on either side of the screen, we can see the car drive forward or
    backward until it inevitably meets a brick wall at either end of the level.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过按屏幕的任意一侧，我们可以看到汽车向前或向后行驶，直到不可避免地撞到关卡两端的一堵砖墙。
- en: 'The car:'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 汽车：
- en: To create a simple car in Box2D, all you have to do is attach two circles to
    a polygon using revolute joints. Each circle, or 'wheel', has high density and
    friction to help it pull the car along the road. It also has a low restitution
    to limit bouncing. When placed on an uneven surface the car will then roll forward
    or backward. Also, for the sake of simplicity the actual chasis of the car is
    a convex polygon.
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在Box2D中创建一个简单的汽车，你所要做的就是使用旋转关节将两个圆圈连接到一个多边形上。每个圆圈，或称为“车轮”，具有高密度和摩擦力，有助于它在道路上拉动汽车。它还具有低恢复力，以限制弹跳。当放置在不平的表面上时，汽车将向前或向后滚动。此外，为了简化，汽车的底盘实际上是一个凸多边形。
- en: 'Driving the car:'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 驾驶汽车：
- en: 'To drive the car around, we apply torque to the front wheel while applying
    some counter-torque to the car itself:'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要驾驶汽车，我们在前轮上施加扭矩，同时在汽车本身上施加一些反扭矩：
- en: '[PRE23]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The counter-torque acts in the same way that a spoiler does to keep the car
    balanced.
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 反扭矩的作用方式与尾翼保持汽车平衡的方式相同。
- en: 'Creating the curved road:'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建弯曲的道路：
- en: The road in this recipe is a good example of a curved surface in Box2D. We created
    this using many small **edge** fixtures to construct a hi-poly curve.
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个菜谱中的道路是Box2D中曲面形状的一个很好的例子。我们使用许多小的**边缘**固定件来构建一个高多边形曲线。
- en: 'The camera:'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像头：
- en: 'In this recipe, we finally put `gameNode` to use. By repositioning this node,
    we effectively reposition the camera separately from the **HUD**:'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们最终使用了`gameNode`。通过重新定位此节点，我们有效地将摄像头与**HUD**分开单独定位：
- en: '[PRE24]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We'll discuss camera usage in depth in another recipe.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将在另一个菜谱中深入讨论摄像头的使用。
- en: There's More...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The vehicle in this example is far from perfect. Try using **revolute joints**
    to extend the wheels out from under the car and to add some shock absorption.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，车辆远非完美。尝试使用**旋转关节**将车轮从车底伸出，并添加一些减震。
- en: '`b2_maxPolygonVertices:`'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`b2_maxPolygonVertices：`'
- en: 'Because our car has more than eight vertices, we must override the b2_maxPolygonVertices
    definition. This is located in the file b2Settings.h. The new definition looks
    like this:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的汽车有超过八个顶点，我们必须覆盖`b2_maxPolygonVertices`的定义。这位于文件`b2Settings.h`中。新的定义看起来像这样：
- en: '[PRE25]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This allows us to define polygons with up to 16 vertices.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许我们定义具有多达16个顶点的多边形。
- en: Character movement
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 角色移动
- en: Moving a character around a level can be trickier than you might expect. In
    this recipe, we will lay out the basics of 2D side scrolling character movement.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个关卡中移动一个角色可能比你想象的要复杂。在本菜谱中，我们将介绍2D侧滚动角色移动的基础。
- en: '![Character movement](img/4002_04_12.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![角色移动](img/4002_04_12.jpg)'
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。此外，请注意，以下代码中省略了一些内容以简化。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE26]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we can make the 'gunman' run and jump around the level. The
    animation routine used here is based on the one used in a previous recipe.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们可以让“枪手”在关卡中奔跑和跳跃。这里使用的动画程序是基于之前菜谱中使用的。
- en: 'Moving left and right:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向左和向右移动：
- en: 'Using the directional pad, we can move the gunman to the left or right. This
    involves applying a force to the body on the X-axis:'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用方向垫，我们可以将枪手移动到左边或右边。这涉及到在X轴上对物体施加力：
- en: '[PRE27]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The gunman's animation speed is then based on his X movement speed.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 随后，枪手的动画速度基于他的X轴移动速度。
- en: 'Damping:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻尼：
- en: 'To slow the gunman down both in the air and on the ground, we set a **linear
    damping** value on the body:'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了在空中和地面上减慢枪手的速度，我们在身体上设置一个 **线性阻尼** 值：
- en: '[PRE28]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This gradually decreases the gunman's speed in all directions. This has the
    dual effect of creating air resistance and also slowing him down when he's not
    actively running.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这会逐渐减少枪手在所有方向上的速度。这有两个作用：一方面产生空气阻力，另一方面在他没有积极奔跑时减慢他的速度。
- en: 'Jumping:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跳跃：
- en: 'To create a comfortable Mario-esque jump, we need to apply a handful of techniques
    and store a few variables. Jumping should only happen when the gunman is standing
    on an object. The user should be able to hold down the jump button for a higher
    jump, that is, until a certain point. To achieve all this we use the following
    variables:'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要创建一个舒适的马里奥式跳跃，我们需要应用一些技巧并存储几个变量。跳跃只应该在枪手站在一个物体上时发生。用户应该能够按住跳跃按钮进行更高跳跃，即直到某个点。为了实现所有这些，我们使用以下变量：
- en: '[PRE29]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The variable `lastYVelocity` is used to determine whether or not the gunman
    recently hit the ground or if he just ran off the ground (as opposed to jumping
    off the ground). Subtle changes in Y velocity can tell us these things. The variable
    `jumpCounter` is used to limit jumping height. The counter is constantly being
    decremented. The time it resets to when you initially jump is the maximum amount
    of time the gunman is thrust upward. This time can be modified to allow certain
    actors to jump higher or lower. Jumping is first an initial impulse then a constant
    upward thrusting force. When the user lets go of the jump button, we reset `jumpCounter`
    and the gunman begins to fall.
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 变量 `lastYVelocity` 用于确定枪手是否最近触地，或者他只是从地面上跑开（而不是从地面上跳开）。Y速度的微妙变化可以告诉我们这些信息。变量
    `jumpCounter` 用于限制跳跃高度。计数器会不断递减。重置到最初跳跃时的时间是枪手向上推力的最大时间。这个时间可以修改，以允许某些角色跳得更高或更低。跳跃首先是一个初始冲量，然后是一个持续的向上推力。当用户松开跳跃按钮时，我们重置
    `jumpCounter`，枪手开始下落。
- en: Simulating bullets
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟子弹
- en: Bullets and other fast moving objects are a fundamental part of many video games.
    In this recipe, we will see how to properly implement bullet physics.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 子弹和其他快速移动的物体是许多电子游戏的基本组成部分。在本菜谱中，我们将看到如何正确实现子弹物理。
- en: '![Simulating bullets](img/4002_04_13.jpg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![模拟子弹](img/4002_04_13.jpg)'
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅项目 *RecipeCollection02* 以获取此菜谱的完整工作代码。此外，请注意，以下代码中省略了一些内容以简化。
- en: How to do it...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Execute the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE30]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Pressing the **B** button animates a muzzle flash, fires a bullet object, and
    ejects a used bullet casing. The muzzle flash is merely an animation but the bullets
    and bullet casings are physical objects.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 **B** 按钮会触发枪口闪光，发射子弹对象，并弹出已使用的弹壳。枪口闪光只是一个动画，但子弹和弹壳是物理对象。
- en: 'Setting the bullet flag:'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置子弹标志：
- en: 'In the recipe, we set the bullet body''s flag to identify it as a fast moving
    projectile:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在菜谱中，我们将子弹身体的标志设置为识别它为一个快速移动的投射物：
- en: '[PRE31]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Setting this flag allows the bullet to properly collide with other dynamic bodies.
    When two dynamic bodies collide, Box2D only performs collision detection for each
    discrete physics step. This means that during each cycle all dynamic physical
    bodies have discrete positions. Because of this, when a body moves fast enough,
    there is a chance that it could move through a body that it is supposed to collide
    with. Specifying this fast moving body as a bullet allows Box2D to perform continuous
    collision detection to allow this object to collide with other dynamic objects
    at any speed.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 设置此标志允许子弹正确地与其他动态物体发生碰撞。当两个动态物体发生碰撞时，Box2D 仅在每个离散物理步骤中执行碰撞检测。这意味着在每个循环中，所有动态物理物体都有离散的位置。正因为如此，当一个物体移动得足够快时，它有可能穿过它应该与之碰撞的物体。将这个快速移动的物体指定为子弹，允许
    Box2D 执行连续碰撞检测，使该物体能够以任何速度与其他动态物体发生碰撞。
- en: 'Animating a bullet impact:'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画子弹撞击：
- en: In our example, we used some trigonometry to determine where the bullet landed
    on the periphery of the 2D box object. For more complex shapes, you can retrieve
    the contact normals from the Box2D solver. This will help identify exactly where
    two bodies have collided. For more information about **contact normals**, please
    consult the Box2D documentation.
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了一些三角学来确定子弹落在二维盒形物体的外围。对于更复杂的形状，你可以从 Box2D 求解器中检索接触法线。这将有助于确定两个物体确切碰撞的位置。有关
    **接触法线** 的更多信息，请参阅 Box2D 文档。
- en: Simulating and rendering a rope
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟和渲染线索
- en: A recent addition to the Box2D library is the `b2RopeJoint.` In this recipe,
    we will see how to implement this physically and visually.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 库最近新增了 `b2RopeJoint` 功能。在本教程中，我们将了解如何实现这一功能在物理和视觉上的应用。
- en: '![Simulating and rendering a rope](img/4002_04_14.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![模拟和渲染线索](img/4002_04_14.jpg)'
- en: Getting ready
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取本教程的完整工作代码。同时请注意，为了简洁，以下代码中省略了一些内容。
- en: How to do it...
  id: totrans-274
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE32]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: How it works...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: Pressing **B** fires a rope into the level directly above the gap in the middle.
    This allows the gunman to swing across the gap.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 按下 **B** 键将线索射入中间缺口上方的关卡。这允许枪手跨越缺口。
- en: 'Using a rope joint:'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线索关节：
- en: 'The rope joint is initialized in a way similar to that of other joints. It
    connects two bodies at two specific local points:'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 线索关节的初始化方式与其他关节类似。它连接两个物体在两个特定的局部点：
- en: '[PRE33]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We then set the maximum rope length and create the joint:'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后我们设置最大线索长度并创建关节：
- en: '[PRE34]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This allows the user to swing on a circular arc around the anchor point.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这允许用户在锚点周围的圆形弧线上摆动。
- en: Using `VRope:`
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `VRope`：
- en: 'The `VRope` class allows us to visualize the rope. An instance of `VRope` stores
    the two connected bodies and the connecting joint to then create a realistic depiction
    of a rope in each frame:'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`VRope` 类允许我们可视化线索。`VRope` 的一个实例存储了两个连接的物体和连接关节，然后在每一帧中创建线索的真实描绘：'
- en: '[PRE35]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: From the original Pitfall arcade game to the newer Worms games, ropes have been
    used in games for years. They connect the player to the world in a way that is
    more dynamic than just running and jumping around.
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从原始的 Pitfall 街机游戏到较新的 Worms 游戏，线索在游戏中已经使用了多年。它们以比仅仅跑步和跳跃更动态的方式将玩家与世界连接起来。
- en: Creating a top-down isometric game engine
  id: totrans-289
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建俯视等距游戏引擎
- en: By making some modifications to Box2D we can turn a 2D world into a 2.5D world.
    We will see this 2.5D **sandbox** in action in this recipe.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对 Box2D 进行一些修改，我们可以将二维世界转变为2.5D世界。在本教程中，我们将看到2.5D **沙盒** 的实际应用。
- en: '![Creating a top-down isometric game engine](img/4002_04_15.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![创建俯视等距游戏引擎](img/4002_04_15.jpg)'
- en: Getting ready
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that a large amount of code from this recipe has been omitted
    for brevity.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 请参考项目 *RecipeCollection02* 以获取本教程的完整工作代码。同时请注意，为了简洁，本教程中省略了大量代码。
- en: How to do it...
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Execute the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下代码：
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In this recipe, we control the gunman as he runs around in a pseudo-3D world.
    Pressing **B** makes him fire colorful bouncing balls into the air. Pressing **A**
    makes him jump. Much like in a previous recipe, the user can pinch to zoom in
    or out.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在本教程中，我们控制枪手在一个伪3D世界中奔跑。按下 **B** 键使他向空中发射彩色弹球。按下 **A** 键使他跳跃。与之前的教程类似，用户可以捏合来缩放。
- en: 'Box2D modifications:'
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Box2D修改：
- en: 'To create a somewhat realistic 3D effect, we need to store some more data inside
    the `b2Body` class. By searching for the string "Isometric Additions" in the RecipeCollection02
    project, you will find four sets of additions to the `b2Body` class. These changes
    add the following variables:'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了创建一个相对逼真的3D效果，我们需要在`b2Body`类内部存储更多的数据。通过在RecipeCollection02项目中搜索字符串"Isometric
    Additions"，你将找到四组对`b2Body`类的扩展。这些更改添加了以下变量：
- en: '[PRE37]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The position, size, and velocity variables allow us to perform some basic physical
    calculations on the Z plane. The `m_handleZMiss` variable tells us whether or
    not to send a message to a callback method when an object passes over or under
    another object on the Z plane.
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 位置、大小和速度变量使我们能够在Z平面上进行一些基本的物理计算。`m_handleZMiss`变量告诉我们，当一个对象在Z平面上经过另一个对象上方或下方时，是否向回调方法发送消息。
- en: 'The `GameIsoObject` class:'
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameIsoObject`类：'
- en: This new class adds some new variables that we can use in our engine. Particularly,
    `yModifier` and `zModifier` are simple values to help with sprite positioning
    and depth testing, respectively. The variables `actualImageSize` and `inGameSize`
    help to determine baseline image scaling.
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个新类添加了一些我们可以用在我们的引擎中的新变量。特别是，`yModifier`和`zModifier`是简单的值，分别用于帮助精灵定位和深度测试。变量`actualImageSize`和`inGameSize`有助于确定基线图像缩放。
- en: 'The `isometricContactListener` class:'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isometricContactListener`类：'
- en: 'Here, we use our contact listener to check collision in the third or ''Z''
    dimension. If two collide on the X and Y but miss on the Z, then we disable physical
    collision response:'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我们使用我们的接触监听器来检查第三维或'Z'维的碰撞。如果两个物体在X和Y轴上相撞，但在Z轴上错过，那么我们禁用物理碰撞响应：
- en: '[PRE38]'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We also call the following function on the corresponding gameArea instance:'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还在相应的gameArea实例上调用以下函数：
- en: '[PRE39]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is useful, for instance, when you want to determine if someone jumped over
    a fence or if a ball went over a wall in a sports video game.
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这很有用，例如，当你想确定某人是否跳过了栅栏，或者在一个体育视频游戏中球是否越过了墙壁。
- en: 'Physics on the Z plane:'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z平面的物理：
- en: This recipe overrides the normal `step` routine for its own custom routine.
    Here, we handle Z physics. This involves assuming an arbitrary, static ground
    at Z=0\. Bodies are subjected to a `GRAVITY` constant that decreases Z velocity
    relative to the amount of time passing with each step. This ensures that physics
    on the Z-axis stays in sync with Box2D physics.
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个配方覆盖了正常的`step`例程以使用自己的自定义例程。在这里，我们处理Z物理。这涉及到假设一个任意、静态的地面在Z=0。物体受到一个`GRAVITY`常数的作用，该常数随着每一步时间的流逝而减少Z速度。这确保了Z轴上的物理与Box2D物理保持同步。
- en: 'Bouncing and rolling:'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹跳和滚动：
- en: 'Each `GameIsoObject` has a `bounceCoefficient` and a `rollCoefficient`. These
    `Vector3D` instances determine the restitution and friction of bodies on all three
    planes:'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个`GameIsoObject`都有一个`bounceCoefficient`和`rollCoefficient`。这些`Vector3D`实例决定了所有三个平面上物体的恢复力和摩擦力：
- en: '[PRE40]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This, combined with Box2D damping, restitution, and friction variables allows
    for a lot of customization.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与Box2D阻尼、恢复力和摩擦变量相结合，允许进行大量的自定义。
- en: '`PERSPECTIVE_RATIO` and depth testing:'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PERSPECTIVE_RATIO`和深度测试：'
- en: This isometric setup assumes a perspective ratio of `0.5f`. This means that,
    for every `1.0f` of distance on the Y we only see 0.5f of distance on the screen.
    In simpler terms, you could consider this the equivalent of having the camera
    looking down at the ground at a 45-degree angle. This acts as a mathematical reference
    for our forced perspective. So, when converting from the physical to the visual
    (or vice versa) we use `PTM_RATIO` on the X and Y axes and `PERSPECTIVE_RATIO`
    on only the Y-axis. In our step routine, we also apply depth testing. For this,
    we simply use Y body positions to determine object depth. All sprites are continually
    reordered.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个等距设置假设一个透视比为`0.5f`。这意味着，对于Y轴上的每`1.0f`距离，我们在屏幕上只能看到`0.5f`的距离。用更简单的话说，你可以认为这相当于摄像机以45度角向下看地面。这作为我们强制透视的数学参考。因此，当我们从物理转换到视觉（或反之亦然）时，我们在X和Y轴上使用`PTM_RATIO`，在Y轴上只使用`PERSPECTIVE_RATIO`。在我们的步进例程中，我们还应用了深度测试。为此，我们只需使用Y轴上的物体位置来确定物体深度。所有精灵都会持续重新排序。
- en: 'Shadows and image scaling on the Z-axis:'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Z轴上的阴影和图像缩放：
- en: To further sell the visual trick of isometric perspective, we add shadow under
    every object using the spriteShadow variable. This shadow stays at height Z=0
    at all times. We have it increase in size when an object goes further up into
    the air. Also, objects at higher altitudes are scaled up slightly. This is why
    we need a baseline scale for our GameIsoObject sprites. When these two effects
    are combined, they give a stronger impression of 3D space. Also, as you can see
    with trees and walls, shadows can be finely drawn (trees) or procedurally generated
    (walls).
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了进一步增强等距视角的视觉效果，我们使用spriteShadow变量在每一个物体下添加阴影。这个阴影始终保持在高度Z=0的位置。当物体向上移动时，它会增加大小。此外，高海拔的物体也会稍微放大。这就是为什么我们需要为我们的GameIsoObject精灵设置一个基线缩放。当这两个效果结合在一起时，它们会给人更强的3D空间印象。此外，正如您从树木和墙壁中看到的，阴影可以精细绘制（树木）或程序生成（墙壁）。
- en: 'Camera limiting and zooming:'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 相机限制和缩放：
- en: 'In the following method, we limit camera movement past the edges of the `gameArea`:'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以下方法中，我们限制相机在`gameArea`边缘之外的移动：
- en: '[PRE41]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This method is then combined with pinch zooming to allow the user to zoom in
    and out to further survey the gameplay area. If you are planning to make use of
    this in-game zoom feature I highly recommend using mipmapping to smooth out shrunken
    textures.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后将此方法与捏合缩放结合，使用户能够放大和缩小以进一步查看游戏区域。如果您计划使用此游戏中的缩放功能，我强烈建议使用米派映射来平滑缩小的纹理。
- en: There's More...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The physics simulation on the Z plane previously provided is very simple. For
    example, this example does not allow for variable height terrain or proper physical
    collision response on the Z-axis. Unfortunately, a more complex simulation would
    be outside the scope of this book.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提供的Z平面的物理模拟非常简单。例如，此示例不允许地形高度变化或Z轴上的正确物理碰撞响应。不幸的是，更复杂的模拟超出了本书的范围。
- en: 'Side-scrolling with depth:'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有深度的侧滚动：
- en: This technique can be easily modified to create a side-scrolling isometric scene
    as opposed to a top-down isometric scene. Examples of this include Streets of
    Rage and NBA Jam for the Sega Genesis console. The gameplay angle would be foreshortened
    to `0.25f` or lower. Also, the custom-made Z-axis should represent depth as opposed
    to height since most physical interactions occur on the width
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种技术可以很容易地修改，以创建侧滚动等距场景，而不是俯视等距场景。这方面的例子包括世嘉Genesis游戏机的《街头霸王》和《NBA Jam》。游戏角度将被缩短到`0.25f`或更低。此外，自定义的Z轴应表示深度而不是高度，因为大多数物理交互都发生在宽度方向上。
