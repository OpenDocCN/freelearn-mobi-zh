- en: Chapter 4. Physics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: Box2D setup and debug drawing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating collision response routines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using different shapes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dragging and collision filtering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating physical properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying impulses
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying forces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Asynchronous body destruction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using joints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a vehicle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character movement
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating bullets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simulating and rendering a rope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a top-down isometric game engine
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For years, physics engines have been used in video games to add a sense of
    realism to the action onscreen. In many games, physics plays a crucial role within
    the gameplay. Cocos2d comes bundled with two popular 2D physics engines: **Box2D**
    and **Chipmunk**. In this chapter, we will explain the most common uses of physics
    in games using Box2D as our engine of choice. Most of the recipes here can be
    easily modified to use Chipmunk or any other similar physics engine.'
  prefs: []
  type: TYPE_NORMAL
- en: Box2D setup and debug drawing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our first physics recipe, we will explore the basics of creating a Box2D
    project and setting up a Box2D world. The example creates a scene that allows
    the user to create realistic 2D blocks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Box2D setup and debug drawing](img/4002_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a Box2D project using the built-in
    Box2D project template:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to **File** | **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Under **User Templates** click on **Cocos2d**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right click on **Cocos2d Box2d Application**.![How to do it...](img/4002_04_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Choose**, name your project, and hit **Save**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Box2D sample project is a simple way to understand what a physics system
    looks like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Upon initialization of the `b2World` object, we set a few things including
    gravity, object **sleeping**, and continuous physics. Sleeping allows bodies that
    are at rest to take up less system resources. Gravity is typically set to a negative
    number in the Y direction but can be reset at any time using the following method
    on `b2World`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to storing a pointer to the main b2World instance, we also usually
    store a pointer to an instance of `GLESDebugDraw`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Debug drawing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debug drawing is handled by the `GLESDebugDraw` class as defined in `GLES-Render.h`.
    Debug drawing encompasses drawing five different elements onscreen. These include
    **shapes, joint** connections, **AABB**s (axis-aligned bounding boxes), **broad-phase**
    pairs, and a **center of mass** bit.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Visual to physical drawing ratio:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We define the constant `PTM_RATIO` at 32, to allow consistent conversion between
    the physical world and the visual world. **PTM** stands for **pixel to meter**.
    Box2D measures bodies in meters and is built and optimized to work with bodies
    between the sizes of 0.1 to 10.0 meters. Setting this ratio to 32 is a common
    convention for optimal shapes to appear between 3.2 to 320 pixels on screen. Optimization
    aside, there is no upper or lower limit to Box2D body size.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Level boundaries:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this and many future examples, we add a level boundary roughly encompassing
    the entire screen. This is handled with the creation of a `b2Body` object with
    four **fixtures**. Each fixture has a `b2Polygon` shape that defines a single
    **edge**. Creating an edge typically involves the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Because these edges have no corresponding visual components (they are invisible),
    we do not need to set the `bodyDef.userData` pointer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating the blocks:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blocks are created much in the same way that the level boundaries are created.
    Instead of calling `SetAsEdge`, we call `SetAsBox` to create a box-shaped polygon.
    We then set the `density` and `friction` attributes of the **fixture**. We also
    set `bodyDef.userData` to point to the `CCSprite` we created. This links the visual
    and the physical, and allows our `step:` method to reposition sprites as necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Scheduling the world step:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, we schedule our `step` method. In this method, we run one discrete
    `b2World` step using the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The Box2D `world Step` method moves the physics engine forward one step. The
    Box2D constraint solver runs in two phases: the velocity phase and position phase.
    These determine how fast the bodies move and where they are in the game world.
    Setting these variables higher results in a more accurate simulation at the cost
    of speed. Setting `velocityIterations` to 8 and `positionIterations` to 3 is the
    suggested baseline in the Box2D manual. Using the dt variable syncs the logical
    timing of the application with the physical timing. If a game step takes an inordinate
    amount of time, the physics system will move forward quickly to compensate. This
    is referred to as a **variable time step**. An alternative to this would be a
    **fixed time step** set to 1/60th of a second. In addition to the physical step,
    we also reposition and re-orientate all `CCSprites` according to their respective
    `b2Body` positions and rotations:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Taken together, these pieces of code sync the physical world with the visual.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating collision response routines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To make efficient and organized use of Box2D, we must create a few wrapper classes
    to encapsulate specific functionality. In this recipe, we will use these classes
    to add collision response routines to our simple falling block demo from the previous
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating collision response routines](img/4002_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also, note that some code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe lays the groundwork for the rest of this chapter. Here, we see the
    same block creation recipe from before except now a message is printed on the
    screen when either blocks collide with each other or they collide with a **sensor.**
  prefs: []
  type: TYPE_NORMAL
- en: '`GameObject:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameObject` class encapsulates Box2D data structures to help ease the process
    of Box2D object creation. It also includes a pointer back to its parent `GameArea`
    object as well as some other information we will use later. `GameObject` is intended
    to be an abstract base class that should be extended for specific uses.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Sensors:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **fixture** attached to a `b2Body` can be set to 'sensor mode'. This allows
    collision response routines to run without the body actually existing in the world
    physically. No physical collision response will occur. We've encapsulated this
    functionality in the `GameSensor` class. An object of this class can be differentiated
    from other objects by checking its type property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameMisc:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameMisc` class exists as an example of a typical extension of `GameObject`.
    The only added functionality in `GameMisc` is the life variable that we will use
    in later recipes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameArea2D:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameArea2D` class is where the action happens. Here, we encapsulate most
    of the functionality outlined in the previous recipe. In addition to that, we
    have an instance of `DebugDrawNode` and an instance of `CCNode` entitled `gameNode`.
    These allow us to draw our debug information and our game information separately
    from the main scene. This feature will come in handy as recipes become more complex.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Contact listeners:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class `b2ContactListener` is commonly overridden to allow for custom collision
    response handling. We extend `b2ContentListener` to create the `basicContentListener`
    class. There are four methods that can be extended to detect collision at a number
    of different intervals:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The methods `BeginContact` and `EndContact` are fairly self-explanatory. The
    former is called when two fixtures begin to touch, the latter when they cease
    to touch. The `PreSolve` and `PostSolve` methods are called before and after the
    contact solver routine runs. We will use this functionality in a later recipe.
    For this recipe, we are only concerned with `BeginContact`. In this method, we
    retrieve two `GameObject` instances from `body->GetUserData()` and we pass them
    to the following method in the corresponding `GameArea` instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That method checks object types and finally displays different messages onscreen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, blocks are colliding with a static sensor. The sensor does
    not move because its body `type` attribute is set to `b2_staticBody`. Static bodies
    never move and they do not collide with each other. Each block has its `type`
    attribute set to `b2_dynamicBody`. Dynamic bodies move freely and collide with
    all other bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Using different shapes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The primary attribute a Box2D body has is its shape. Box2D uses two classes,
    `b2PolygonShape` and `b2CircleShape`, to represent any possible shape. In this
    recipe, we will create a number of different shapes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using different shapes](img/4002_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we randomly create objects with five different shapes: square,
    circle, rectangle, an oddly shaped convex polygon, and a simple concave polygon.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Rectangles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rectangles are created using the `b2PolygonShape` method `SetAsBox` just like
    in the first two recipes. In this example, we have a simple textured square as
    well as a rectangular column image.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Circles:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Circles are a special case in Box2D and they've been given a special class in
    `b2CircleShape`. After initialization, we simply set the `m_radius` variable of
    the circle shape. In this example, we also give the circle shaped objects a high
    `restitution` value to make them bounce. We will cover this in more depth in another
    recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Convex polygons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Individual polygons must be **convex**. This means that every angle inside the
    polygon is less than 180 degrees. For this example, we've created an oddly shaped
    convex polygon with 8 vertices. We are using `TexturedPolygon` to accurately draw
    this polygon. For more information about the `TexturedPolygon` class, please refer
    to Chapter 1, Graphics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Concave polygons:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Concave** polygons can be represented by creating multiple convex polygons
    and linking them to one body using multiple fixtures. In this example, we link
    two simple convex polygons together by creating two fixtures on the same body.
    We reverse our width and height values to create a simple L-shaped object. With
    this technique, you can create arbitrarily complex shapes.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Extensibility of `GameObject:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameObject` class is primarily designed for single fixture bodies. It contains
    one `CCSprite` object, one `b2FixtureDef`, and so on. However, as you can see
    in the concave polygon example, you can create multiple `CCSprite` objects and
    link them to the main `GameObject` sprite. You can also reuse the Box2D object
    pointers within the `GameObject` instance to easily create multiple fixtures and
    shapes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Dragging and collision filtering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In a previous recipe, we handled user input to allow the user to drag an object.
    In this example, we see a bowl filled with pieces of fruit that can be dragged
    across the screen. A piece of fruit does not collide with another piece of fruit.
  prefs: []
  type: TYPE_NORMAL
- en: '![Dragging and collision filtering](img/4002_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this example, we create a realistic ''grabbing'' effect. We achieve this
    by repositioning the nearest Box2D body with the `SetTransform` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We then store the previous distance the object was moved, to determine a final
    velocity and then to allow the object to be ''thrown'' when the user lets go.
    We apply this velocity using the `SetLinearVelocity` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: To suspend fruit in the air while the user has a finger on the screen, we set
    the object's velocity to `b2Vec2_zero` while it is grabbed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Collision filtering:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we don''t allow a fruit to collide with other fruits so that
    they can sit nicely in the bowl. We achieve this by setting the `filter` property
    on the fruit''s fixture. Specifically, we set the `categoryBits` and `maskBits`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `categoryBits` variable indicates what kind of object this is. The `maskBits`
    variable indicates what kind of objects this should collide with. Both of these
    properties use **bits** and **Boolean logic** to specify how the object should
    interact. For example, | means "or". So, we are saying that the `CB_FRUIT` category
    can collide with `CB_GROUND` or `CB_BOWL` categories. Alternatively, filters can
    be set using **filter groups**. Also note that, if you do not specify the fixture''s
    `filter` variable on object then it will not collide with an object that has a
    set filter. For more information about filtering, please refer to the Box2D manual
    at: [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Manipulating physical properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Box2D allows the user to set physical properties on bodies to create a wide
    array of effects. In this example, we see a block of ice pushing a box down a
    slope. We also see a number of bouncing balls.
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating physical properties](img/4002_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we see multiple objects each with different physical properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Density:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Body **density** determines how much force is required to move an object around.
    Two objects with different sizes and the same density will have different masses.
    The larger object will naturally take a larger force to move.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Friction:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Friction** determines how difficult an object is to move against another
    object. Physics nerds may point out the difference between static and kinetic
    friction. Box2D amalgamates them into one variable while assuming a constant static
    to kinetic ratio. In our example, the block of ice has absolutely no friction.
    This means that it will slide around on any surface. This allows the block to
    slowly push the crate down the ramp until it finally falls on the bouncing balls.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restitution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The term **restitution** is interchangeable with elasticity. This measures the
    'bounciness' of an object. An object with a restitution of `1.0f` will theoretically
    bounce forever. In our example, we see four balls each with a different restitution.
    This causes them to bounce at different rates. To see these differences in action,
    quickly grab the block of ice before it pushes the crate over the edge of the
    ledge.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Applying impulses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Box2D, bodies can be moved around using **impulses** and **forces**. In this
    recipe, we will use impulses to accurately shoot a basketball into a basketball
    net.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying impulses](img/4002_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scene, we see a basketball player shooting the ball into a basket. When
    he comes in contact with the ball he shoots it into the net.
  prefs: []
  type: TYPE_NORMAL
- en: 'Impulses:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the basketball touches the basketball player, we reset the ball''s velocity
    and then we apply a precise impulse to accurately shoot the ball into the net:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Applying an impulse, immediately changes the **momentum** of the body. Instead
    of applying a force over time, an impulse applies instantaneous force to immediately
    redirect an object. Impulses also wake up a sleeping body if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameObject` typeTag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instances of the `GameObject` class have heretofore been identified with the
    `type` property as specified by the extending class. For more granular object
    identification, you can use the `typeTag` enumeration. This allows us to tag objects
    to perform a number of tasks. In this example, we use `typeTag` during collision
    response to properly animate the basketball player as well as the basketball net.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Applying forces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unlike impulses, forces must be applied over time to significantly move a body
    in the physical world. In this recipe, we see a simulation of our solar system.
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying forces](img/4002_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this scene, we see eight planets orbiting the sun. They orbit at roughly
    the same speed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forces:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each planet is having a constant force applied to it in the direction of the
    sun:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This, combined with its initial momentum applied by an impulse, creates an orbit
    around the sun. The forces applied take into account planet size and distance
    from the sun in a way similar to how real gravity works.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Torque:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When applying a force or an impulse, you must specify the point on the object
    where the force or impulse is applied. If this is not the exact center of mass,
    then a **torque** will also be applied to the object. This will change the angular
    velocity of the body and will make it spin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Gravity:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As you can see in this example, setting gravity to `b2Vec2(0.0f, 0.0f)` creates
    a top-down physical simulation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: See also...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Setting gravity to `b2Vec2(0.0f, 0.0f)` creates a top-down simulation. We will
    use this technique in later recipes, including *Creating a top-down isometric
    game engine* found later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous body destruction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have learned how to create bodies, how to reposition them, and how
    to apply forces and impulses to move them around onscreen. In this example, we
    will see how to destroy a body during the physics simulation. This is naturally
    a very tricky process that can create bugs and cause game crashes if you're not
    careful.
  prefs: []
  type: TYPE_NORMAL
- en: '![Asynchronous body destruction](img/4002_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have the ability to throw grenades that explode after five
    seconds. The explosion launches any other objects in the immediate area.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying a `b2Body:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Box2D does not allow bodies to be destroyed during a `world->Step(dt, velocityIterations,
    positionIterations)` call. Because of this, collision response routines and timed
    callbacks cannot synchronously initiate body destruction. To solve this problem,
    we have created a simple asynchronous system that can queue up bodies for destruction
    and creation. This system uses the following methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Bodies are created and destroyed after each physics step has completed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameObjectCallback` and `QueuedAction:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `GameObjectCallback` and `QueuedAction` helper classes allow us to queue
    up method callbacks and `CCAction` instances to use after object creation/deletion.
    This can help maintain a logical order of operations when the game is running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`GameObject` life:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the class `GameMisc`, we added a `life` value. In this recipe, we get to
    put it to use. Each grenade's `life` ticks away until it explodes. The explosion
    created is also a `GameMisc` object with a set amount of `life` corresponding
    to its animation duration. Life can also be used for actors and breakable objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using joints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last major feature of Box2D we have yet to investigate is **joints**. Joints
    allow us to link objects to create simple machines like pulleys, levers, and simple
    motors. In this recipe, we will learn how to create a simple seesaw using a joint.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using joints](img/4002_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By dropping the heavy weight object on one side, we can launch the lighter boxes
    up into the air from the other side. This is achieved using a simple joint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Joint types:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All joints link two Box2D bodies. Each joint is represented by a class that
    derives from `b2Joint`. These include `b2PulleyJoint, b2WeldJoint, b2RopeJoint,`
    and more. A comprehensive overview of all Box2D joint types is beyond the scope
    of this book. Please refer to the Box2D testbed for example code for each joint
    as well as the Box2D manual page at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Revolute joints:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this example, we are using a `b2RevoluteJoint` to force two bodies to share
    a common anchor point:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: By pinning the dynamic `plank` body to the static `triangle` body, in this example,
    we have constrained the movement of the `plank` on the X and Y axes. Now that
    it can't move, it can only rotate. This creates a realistic seesaw effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a vehicle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Combining two or more joints can create some interesting effects. In this example,
    we will create a car that can be driven around a level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a vehicle](img/4002_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By pressing on either side of the screen, we can see the car drive forward or
    backward until it inevitably meets a brick wall at either end of the level.
  prefs: []
  type: TYPE_NORMAL
- en: 'The car:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To create a simple car in Box2D, all you have to do is attach two circles to
    a polygon using revolute joints. Each circle, or 'wheel', has high density and
    friction to help it pull the car along the road. It also has a low restitution
    to limit bouncing. When placed on an uneven surface the car will then roll forward
    or backward. Also, for the sake of simplicity the actual chasis of the car is
    a convex polygon.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Driving the car:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To drive the car around, we apply torque to the front wheel while applying
    some counter-torque to the car itself:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The counter-torque acts in the same way that a spoiler does to keep the car
    balanced.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Creating the curved road:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The road in this recipe is a good example of a curved surface in Box2D. We created
    this using many small **edge** fixtures to construct a hi-poly curve.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The camera:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this recipe, we finally put `gameNode` to use. By repositioning this node,
    we effectively reposition the camera separately from the **HUD**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We'll discuss camera usage in depth in another recipe.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The vehicle in this example is far from perfect. Try using **revolute joints**
    to extend the wheels out from under the car and to add some shock absorption.
  prefs: []
  type: TYPE_NORMAL
- en: '`b2_maxPolygonVertices:`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because our car has more than eight vertices, we must override the b2_maxPolygonVertices
    definition. This is located in the file b2Settings.h. The new definition looks
    like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to define polygons with up to 16 vertices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character movement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Moving a character around a level can be trickier than you might expect. In
    this recipe, we will lay out the basics of 2D side scrolling character movement.
  prefs: []
  type: TYPE_NORMAL
- en: '![Character movement](img/4002_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we can make the 'gunman' run and jump around the level. The
    animation routine used here is based on the one used in a previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving left and right:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Using the directional pad, we can move the gunman to the left or right. This
    involves applying a force to the body on the X-axis:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The gunman's animation speed is then based on his X movement speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Damping:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To slow the gunman down both in the air and on the ground, we set a **linear
    damping** value on the body:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gradually decreases the gunman's speed in all directions. This has the
    dual effect of creating air resistance and also slowing him down when he's not
    actively running.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Jumping:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a comfortable Mario-esque jump, we need to apply a handful of techniques
    and store a few variables. Jumping should only happen when the gunman is standing
    on an object. The user should be able to hold down the jump button for a higher
    jump, that is, until a certain point. To achieve all this we use the following
    variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The variable `lastYVelocity` is used to determine whether or not the gunman
    recently hit the ground or if he just ran off the ground (as opposed to jumping
    off the ground). Subtle changes in Y velocity can tell us these things. The variable
    `jumpCounter` is used to limit jumping height. The counter is constantly being
    decremented. The time it resets to when you initially jump is the maximum amount
    of time the gunman is thrust upward. This time can be modified to allow certain
    actors to jump higher or lower. Jumping is first an initial impulse then a constant
    upward thrusting force. When the user lets go of the jump button, we reset `jumpCounter`
    and the gunman begins to fall.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simulating bullets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bullets and other fast moving objects are a fundamental part of many video games.
    In this recipe, we will see how to properly implement bullet physics.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simulating bullets](img/4002_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pressing the **B** button animates a muzzle flash, fires a bullet object, and
    ejects a used bullet casing. The muzzle flash is merely an animation but the bullets
    and bullet casings are physical objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Setting the bullet flag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the recipe, we set the bullet body''s flag to identify it as a fast moving
    projectile:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting this flag allows the bullet to properly collide with other dynamic bodies.
    When two dynamic bodies collide, Box2D only performs collision detection for each
    discrete physics step. This means that during each cycle all dynamic physical
    bodies have discrete positions. Because of this, when a body moves fast enough,
    there is a chance that it could move through a body that it is supposed to collide
    with. Specifying this fast moving body as a bullet allows Box2D to perform continuous
    collision detection to allow this object to collide with other dynamic objects
    at any speed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Animating a bullet impact:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our example, we used some trigonometry to determine where the bullet landed
    on the periphery of the 2D box object. For more complex shapes, you can retrieve
    the contact normals from the Box2D solver. This will help identify exactly where
    two bodies have collided. For more information about **contact normals**, please
    consult the Box2D documentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Simulating and rendering a rope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A recent addition to the Box2D library is the `b2RopeJoint.` In this recipe,
    we will see how to implement this physically and visually.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simulating and rendering a rope](img/4002_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that some of the following code has been omitted for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pressing **B** fires a rope into the level directly above the gap in the middle.
    This allows the gunman to swing across the gap.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a rope joint:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The rope joint is initialized in a way similar to that of other joints. It
    connects two bodies at two specific local points:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then set the maximum rope length and create the joint:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows the user to swing on a circular arc around the anchor point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `VRope:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `VRope` class allows us to visualize the rope. An instance of `VRope` stores
    the two connected bodies and the connecting joint to then create a realistic depiction
    of a rope in each frame:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the original Pitfall arcade game to the newer Worms games, ropes have been
    used in games for years. They connect the player to the world in a way that is
    more dynamic than just running and jumping around.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a top-down isometric game engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: By making some modifications to Box2D we can turn a 2D world into a 2.5D world.
    We will see this 2.5D **sandbox** in action in this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a top-down isometric game engine](img/4002_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe. Also note that a large amount of code from this recipe has been omitted
    for brevity.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we control the gunman as he runs around in a pseudo-3D world.
    Pressing **B** makes him fire colorful bouncing balls into the air. Pressing **A**
    makes him jump. Much like in a previous recipe, the user can pinch to zoom in
    or out.
  prefs: []
  type: TYPE_NORMAL
- en: 'Box2D modifications:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a somewhat realistic 3D effect, we need to store some more data inside
    the `b2Body` class. By searching for the string "Isometric Additions" in the RecipeCollection02
    project, you will find four sets of additions to the `b2Body` class. These changes
    add the following variables:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The position, size, and velocity variables allow us to perform some basic physical
    calculations on the Z plane. The `m_handleZMiss` variable tells us whether or
    not to send a message to a callback method when an object passes over or under
    another object on the Z plane.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `GameIsoObject` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This new class adds some new variables that we can use in our engine. Particularly,
    `yModifier` and `zModifier` are simple values to help with sprite positioning
    and depth testing, respectively. The variables `actualImageSize` and `inGameSize`
    help to determine baseline image scaling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `isometricContactListener` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here, we use our contact listener to check collision in the third or ''Z''
    dimension. If two collide on the X and Y but miss on the Z, then we disable physical
    collision response:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also call the following function on the corresponding gameArea instance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is useful, for instance, when you want to determine if someone jumped over
    a fence or if a ball went over a wall in a sports video game.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Physics on the Z plane:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This recipe overrides the normal `step` routine for its own custom routine.
    Here, we handle Z physics. This involves assuming an arbitrary, static ground
    at Z=0\. Bodies are subjected to a `GRAVITY` constant that decreases Z velocity
    relative to the amount of time passing with each step. This ensures that physics
    on the Z-axis stays in sync with Box2D physics.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Bouncing and rolling:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each `GameIsoObject` has a `bounceCoefficient` and a `rollCoefficient`. These
    `Vector3D` instances determine the restitution and friction of bodies on all three
    planes:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This, combined with Box2D damping, restitution, and friction variables allows
    for a lot of customization.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`PERSPECTIVE_RATIO` and depth testing:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This isometric setup assumes a perspective ratio of `0.5f`. This means that,
    for every `1.0f` of distance on the Y we only see 0.5f of distance on the screen.
    In simpler terms, you could consider this the equivalent of having the camera
    looking down at the ground at a 45-degree angle. This acts as a mathematical reference
    for our forced perspective. So, when converting from the physical to the visual
    (or vice versa) we use `PTM_RATIO` on the X and Y axes and `PERSPECTIVE_RATIO`
    on only the Y-axis. In our step routine, we also apply depth testing. For this,
    we simply use Y body positions to determine object depth. All sprites are continually
    reordered.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Shadows and image scaling on the Z-axis:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To further sell the visual trick of isometric perspective, we add shadow under
    every object using the spriteShadow variable. This shadow stays at height Z=0
    at all times. We have it increase in size when an object goes further up into
    the air. Also, objects at higher altitudes are scaled up slightly. This is why
    we need a baseline scale for our GameIsoObject sprites. When these two effects
    are combined, they give a stronger impression of 3D space. Also, as you can see
    with trees and walls, shadows can be finely drawn (trees) or procedurally generated
    (walls).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Camera limiting and zooming:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the following method, we limit camera movement past the edges of the `gameArea`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method is then combined with pinch zooming to allow the user to zoom in
    and out to further survey the gameplay area. If you are planning to make use of
    this in-game zoom feature I highly recommend using mipmapping to smooth out shrunken
    textures.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The physics simulation on the Z plane previously provided is very simple. For
    example, this example does not allow for variable height terrain or proper physical
    collision response on the Z-axis. Unfortunately, a more complex simulation would
    be outside the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Side-scrolling with depth:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This technique can be easily modified to create a side-scrolling isometric scene
    as opposed to a top-down isometric scene. Examples of this include Streets of
    Rage and NBA Jam for the Sega Genesis console. The gameplay angle would be foreshortened
    to `0.25f` or lower. Also, the custom-made Z-axis should represent depth as opposed
    to height since most physical interactions occur on the width
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
