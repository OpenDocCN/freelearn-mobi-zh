<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Operation Storyboard"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Operation Storyboard</h1></div></div></div><div class="blockquote"><blockquote class="blockquote"><p>We've taken our game Egg Drop and explored ways to create game physics to react with collision detection and tracking other useful data such as lives and a points system. We also worked with customizing physical bodies and creating names for our display objects that apply to the game score count.</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>Next, we'll be adding a menu system that incorporates an introduction to the game and also applying a pause menu during gameplay and saving high scores when the game is over.</p></blockquote></div><div class="blockquote"><blockquote class="blockquote"><p>We're on our way to completing an application that has the necessary elements that will be ready for the App Store or Google Play Store.</p></blockquote></div><p>In this chapter, we will learn the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Saving high scores</li><li class="listitem" style="list-style-type: disc">Adding a pause menu</li><li class="listitem" style="list-style-type: disc">Changing scenes with Storyboard API</li><li class="listitem" style="list-style-type: disc">Adding a loading screen</li><li class="listitem" style="list-style-type: disc">Adding a main menu and options menu</li></ul></div><p>So let's keep on going!</p><div class="section" title="Continuation of Egg Drop"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec01"/>Continuation of Egg Drop</h1></div></div></div><p>We have finished the main game portion of Egg Drop as the base of our application. Now it's time for us to include how to pause action mid-game and also how to save high scores. We're also going to add some new scenes that will help us introduce and transition to the game in an easy and quick fashion.<a id="id544" class="indexterm"/>
</p><p>In the Chapter 8 <code class="literal">Resources</code> folder, grab all the image and file assets inside and copy them to your current <code class="literal">Egg Drop</code> project folder. You can download the project files accompanying this book from the Packt website. We'll be using these files to add the final touches to our game.</p></div></div>
<div class="section" title="Data saving"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec02"/>Data saving</h1></div></div></div><p>Saving file information is used in many aspects of game development. We use it to save high scores, game settings such as sound on/off, locking/unlocking levels, and so on. They're not necessary to have, but good to have if you'd like to have those features included in your applications.<a id="id545" class="indexterm"/>
</p><p>In Corona SDK, applications are sandboxed, meaning that your files (application images, data, and preferences) are stored in a location that no other application can access. Your files will reside in an app-specific directory for documents, resources, or temporary files. This restriction is related to the files on your device, not when you are coding on your Mac or PC.</p><div class="section" title="BeebeGames Class for saving and loading values"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec01"/>BeebeGames Class for saving and loading values</h2></div></div></div><p>We'll be using BeebeGames Class, created by Jonathan Beebe. It provides many easy and useful functions to use for games. Some of the notable functions included incorporate a simple way of saving and loading data that we'll be able add into our game. More information on BeebeGames Class can be found at:<a class="ulink" href="http://developer.anscamobile.com/code/beebegames-class"> http://developer.anscamobile.com/code/beebegames-class</a>. You can download the file from the link and take a look at other methods relating to animation, transitions, timers, and so on, incase you would like to use them for future use. For now, we'll be focusing on the methods for easy saving and loading values for our game.<a id="id546" class="indexterm"/>
</p><p>Example of saving and loading values:</p><div class="informalexample"><pre class="programlisting"><span class="strong"><strong>-- Public Method: saveValue() --&gt; save single-line file (replace contents)
</strong></span>
function saveValue( strFilename, strValue )
-- will save specified value to specified file
local theFile = strFilename
local theValue = strValue
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
-- "w+": update mode, all previous data is erased
local file = io.open( path, "w+" )
if file then
-- write game score to the text file
file:write( theValue )
io.close( file )
end
end
<span class="strong"><strong>-- Public Method: loadValue() --&gt; load single-line file and store it into variable</strong></span>
function loadValue( strFilename )
-- will load specified file, or create new file if it doesn't exist
local theFile = strFilename
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
-- "r": read mode
local file = io.open( path, "r" )
if file then
-- read all contents of file into a string
-- "*a": reads the whole file, starting at the current position
local contents = file:read( "*a" )
io.close( file )
return contents
else
-- create file b/c it doesn't exist yet
-- "w": write mode
file = io.open( path, "w" )
file:write( "0" )
io.close( file )
return "0"
end
end
</pre></div></div><div class="section" title="Getting paths to files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec02"/>Getting paths to files</h2></div></div></div><p>The paths to these files are unique to your application. To create file paths, you use the <code class="literal">system.pathForFile</code> function. The following generates an absolute path to the icon file for your application using the application's resource directory as the base directory for <code class="literal">Icon.png:</code>
<a id="id548" class="indexterm"/>
</p><div class="informalexample"><pre class="programlisting">local path = system.pathForFile( "Icon.png", system.ResourceDirectory )
</pre></div><p>In general, your files must reside in one of three possible base directories:<a id="id549" class="indexterm"/>
</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">system.DocumentsDirectory</code> should be used for files that need to persist between application sessions.</li><li class="listitem" style="list-style-type: disc"><code class="literal">system.TemporaryDirectory</code> is a temporary directory. Files written to this directory are not guaranteed to exist in subsequent application sessions. They may or may not exist.</li><li class="listitem" style="list-style-type: disc"><code class="literal">system.ResourceDirectory</code> is the directory where all application assets exist. Note that you should never create, modify, or add files to this directory.<div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="note19"/>Note</h3><p>More information on files can be found at:<a class="ulink" href="http://developer.anscamobile.com/content/files"> http://developer.anscamobile.com/content/files</a>.</p></div></li></ul></div></div><div class="section" title="Reading files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec03"/>Reading files</h2></div></div></div><p>To read files, the <code class="literal">io</code> library is used. This library allows you to open files given an absolute path.<a id="id550" class="indexterm"/>
</p></div><div class="section" title="Writing files"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec04"/>Writing files</h2></div></div></div><p>To write files, you follow many of the same steps as reading a file. Instead of using a read method, you write data (strings or numbers) to a file.</p></div></div>
<div class="section" title="Time for action&#x2014;saving and loading the high score"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec03"/>Time for action—saving and loading the high score</h1></div></div></div><p>When the<span class="strong"><strong> Game Over</strong></span> screen displays, we're going to save and load the values of our final score and highest score.<a id="id551" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Open up your <code class="literal">main.lua</code> file that we created for Egg Drop. We'll continue using the same file and add in more code with the new alterations to the game.</li><li class="listitem">Add in two new variables, <code class="literal">local highScoreText</code> and <code class="literal">local highScore</code> where all the other initialised variables are located near the top of the code.<div class="informalexample"><pre class="programlisting">local highScoreText
local highScore
</pre></div></li><li class="listitem">Introduce the <code class="literal">saveValue()</code> function after the pre-loaded sound files.<div class="informalexample"><pre class="programlisting">local saveValue = function( strFilename, strValue )
-- will save specified value to specified file
local theFile = strFilename
local theValue = strValue
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
local file = io.open( path, "w+" )
if file then
-- write game score to the text file
file:write( theValue )
io.close( file )
end
end
</pre></div></li><li class="listitem">Add in the <code class="literal">loadValue()</code> function.<a id="id552" class="indexterm"/><div class="informalexample"><pre class="programlisting">local loadValue = function( strFilename )
-- will load specified file, or create new file if it doesn't exist
local theFile = strFilename
local path = system.pathForFile( theFile, system.DocumentsDirectory )
-- io.open opens a file at path. returns nil if no file found
local file = io.open( path, "r" )
if file then
-- read all contents of file into a string
local contents = file:read( "*a" )
io.close( file )
return contents
else
-- create file b/c it doesn't exist yet
file = io.open( path, "w" )
file:write( "0" )
io.close( file )
return "0"
end
end
</pre></div></li><li class="listitem">At the end of the <code class="literal">callGameOver()</code> function, create an <code class="literal">if</code> statement to compare the <code class="literal">gameScore</code> and <code class="literal">highScore</code>. Save the highest score using the <code class="literal">saveValue()</code> function.<a id="id553" class="indexterm"/><div class="informalexample"><pre class="programlisting">if gameScore &gt; highScore then
highScore = gameScore
local highScoreFilename = "highScore.data"
saveValue( highScoreFilename, tostring(highScore) )
end
</pre></div></li><li class="listitem">Next, add in the <code class="literal">highScoreText</code> display text in the same <code class="literal">callGameOver()</code> function to show the high score at the end of the game.<a id="id554" class="indexterm"/><div class="informalexample"><pre class="programlisting">highScoreText = display.newText( "Best Game Score: " .. tostring( highScore ), 0, 0, "Arial", 30 )
highScoreText:setTextColor( 255, 255, 255, 255 )
highScoreText.xScale = 0.5; highScoreText.yScale = 0.5
highScoreText.x = 240
highScoreText.y = 120
gameGroup:insert( highScoreText )
</pre></div></li><li class="listitem">At the end of the <code class="literal">gameStart()</code> function, have the high score loaded using the <code class="literal">loadValue()</code> function.<div class="informalexample"><pre class="programlisting">local highScoreFilename = "highScore.data"
local loadedHighScore = loadValue( highScoreFilename )
highScore = tonumber(loadedHighScore)
</pre><div class="mediaobject"><img src="graphics/1888_08_01.jpg" alt="Time for action—saving and loading the high score"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec05"/>What just happened?</h2></div></div></div><p>After initializing the <code class="literal">saveValue()</code> and <code class="literal">loadValue()</code> functions in the game level, we created an <code class="literal">if</code> statement to compare the <code class="literal">gameScore</code>, which is the current score during gameplay and the <code class="literal">highScore</code>, which is the highest score accrued so far. When the outcome of <code class="literal">gameScore</code> is higher, then it replaces the <code class="literal">highScore</code> data saved.</p><p>In order to save the value, a data file needs to be created. We created a variable called <code class="literal">local highScoreFilename = "highscore.data"</code>. We called the <code class="literal">saveValue()</code> function using <code class="literal">highScoreFilename</code> as a parameter. <code class="literal">tostring(highScore)</code> will be converted to a string.<a id="id555" class="indexterm"/>
</p><p>When the<span class="strong"><strong> Game Over</strong></span> screen is visible, <code class="literal">highScoreText</code> displays the value saved from <code class="literal">highScore</code> above the <code class="literal">gameScore</code> that is achieved. Adding a high score gives the player an incentive to top the highest score and to add the replay value to the game.</p><p>In the <code class="literal">gameStart()</code> function, it's important to have the value of <code class="literal">highScore.data</code> loaded at the start of gameplay. By using the same data file we created to save <code class="literal">highScore</code>, we can also use it to load the value throughout the game. To load the value, <code class="literal">local highScore</code> calls <code class="literal">loadValue(highScoreFileName)</code>. This takes the information from <code class="literal">highScore.data</code>. To obtain the value, <code class="literal">tonumber(loadedHighScore)</code> converts it to an integer from a string and can be used to display the value of <code class="literal">highScore</code>.</p></div></div>
<div class="section" title="Pausing the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec04"/>Pausing the game</h1></div></div></div><p>Have you ever found yourself in the middle of playing a game and all of sudden you have to take a bathroom break or your hand cramps up? Obviously, any of those situations require you to avert your attention from your game progress and you need to stop the current action temporarily to attend to those needs. This is when a pause button comes in handy so you can stop the action in that moment in time and continue where you left off when you're ready to play again.<a id="id556" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;pausing the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec05"/>Time for action—pausing the game</h1></div></div></div><p>It's more than just making a button, it's also pausing all the action onscreen, including physics and timers.</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Add in the variables <code class="literal">local pauseBtn</code> and <code class="literal">local pauseBG</code> where all the other variables are initialized near the beginning of the code. Preload the <code class="literal">btnSound</code> audio after <code class="literal">gameOverSound</code> near the top of the script.<div class="informalexample"><pre class="programlisting">-- Place near other game variables
local pauseBtn
local pauseBG
-- Place after gameOverSound
local btnSound = audio.loadSound( "btnSound.wav" )
</pre></div></li><li class="listitem">Within the <code class="literal">hud()</code> function and after the <code class="literal">scoreText</code> chunk, create another function that will run the event for the pause button. Call the function <code class="literal">onPauseTouch(event)</code>. Pause the physics in the game by setting <code class="literal">gameIsActive</code> to <code class="literal">false</code> and have the pause elements appear on screen.<div class="informalexample"><pre class="programlisting">local onPauseTouch = function( event )
if event.phase == "release" and pauseBtn.isActive then
audio.play( btnSound )
-- Pause the game
if gameIsActive then
gameIsActive = false
physics.pause()
local function pauseGame()
timer.pause( startDrop )
print("timer has been paused")
end
timer.performWithDelay(1, pauseGame)
-- SHADE
if not shade then
shade = display.newRect( 0, 0, 570, 380 )
shade:setFillColor( 0, 0, 0, 255 )
shade.x = 240; shade.y = 160
gameGroup:insert( shade )
end
shade.alpha = 0.5
-- SHOW MENU BUTTON
if pauseBG then
pauseBG.isVisible = true
pauseBG.isActive = true
pauseBG:toFront()
end
pauseBtn:toFront()
</pre></div></li><li class="listitem">When the game is unpaused, have the physics become active again and remove all pause display objects.<a id="id557" class="indexterm"/><div class="informalexample"><pre class="programlisting">else
if shade then
display.remove( shade )
shade = nil
end
if pauseBG then
pauseBG.isVisible = false
pauseBG.isActive = false
end
gameIsActive = true
physics.start()
local function resumeGame()
timer.resume( startDrop )
print("timer has been resumed")
end
timer.performWithDelay(1, resumeGame)
end
end
end
</pre></div></li><li class="listitem">Add the <code class="literal">pauseBtn</code> UI button and <code class="literal">pauseBG</code> display object after the <code class="literal">onPauseTouch()</code> function.<div class="informalexample"><pre class="programlisting">pauseBtn = ui.newButton{
defaultSrc = "pausebtn.png",
defaultX = 44,
defaultY = 44,
overSrc = "pausebtn-over.png",
overX = 44,
overY = 44,
onEvent = onPauseTouch,
id = "PauseButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
pauseBtn.x = 38; pauseBtn.y = 288
pauseBtn.isVisible = false
pauseBtn.isActive = false
gameGroup:insert( pauseBtn )
pauseBG = display.newImageRect( "pauseoverlay.png", 480, 320 )
pauseBG.x = 240; pauseBG.y = 160
pauseBG.isVisible = false
pauseBG.isActive = false
gameGroup:insert( pauseBG )
</pre></div></li><li class="listitem">In order for <code class="literal">pauseBtn</code> to display during gameplay, make it visible and active in the <code class="literal">gameActivate()</code> function.<a id="id558" class="indexterm"/><div class="informalexample"><pre class="programlisting">pauseBtn.isVisible = true
pauseBtn.isActive = true
</pre></div></li><li class="listitem">When the game is over, disable <code class="literal">pauseBtn</code> in the <code class="literal">callGameOver()</code> function. Place the code right after the <code class="literal">physics.pause()</code> line.<div class="informalexample"><pre class="programlisting">pauseBtn.isVisible = false
pauseBtn.isActive = false
</pre><div class="mediaobject"><img src="graphics/1888_08_02.jpg" alt="Time for action—pausing the game"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec06"/>What just happened?</h2></div></div></div><p>We created the <code class="literal">onPauseTouch(event)</code> function to control all pause events that occur within gameplay. To pause all the motion in game, we changed the boolean of <code class="literal">gameIsActive</code> to <code class="literal">false</code> and <code class="literal">physics.pause()</code> to stop all the eggs that are falling from moving. Next, the timer is paused for <code class="literal">startDrop</code> so any eggs falling from the sky won't accumulate over time as long as the pause function is still active.<a id="id559" class="indexterm"/>
</p><p>A slightly transparent overlay called <code class="literal">shade</code> is called to appear when the pause button is pressed. This will avert the attention of the user from the game scene and allow the user to differentiate when the gameplay is not active.</p><p>The<span class="strong"><strong> Game Paused</strong></span> banner also displays on top of the screen by making it visible and active. <code class="literal">pauseBG</code> is pushed ahead of the display hierarchy by <code class="literal">pauseBG:toFront()</code>.</p><p>To unpause, we reversed the process of how the pause display items appear. When <code class="literal">pauseBtn</code> is pressed for the second time, <code class="literal">shade</code> is taken away by <code class="literal">display.remove(shade); shade = nil. pauseBG.isVisible</code> and <code class="literal">pauseBG.isActive</code> are both set to <code class="literal">false</code>.</p><p>Remember when we set <code class="literal">gameIsActive</code> to <code class="literal">false?</code> Well, it's time to set it back to <code class="literal">true</code>. This also means resuming physics with <code class="literal">physics.start()</code>. The timer is resumed by local function <code class="literal">resumeGame()</code> and calls <code class="literal">timer.resume(startDrop)</code> within the function.</p><p>The <code class="literal">pauseBtn</code> and <code class="literal">pauseBG</code> display objects are inserted at the end of the <code class="literal">if</code> statement block. <code class="literal">pauseBtn</code> is then shown as visible and active once the game is playable. It is invisible and inactive when the<span class="strong"><strong> Game Over</strong></span> screen appears. This is because there are no other touch events that interfere when the game is over.<a id="id560" class="indexterm"/>
</p></div></div>
<div class="section" title="Storyboard API"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec06"/>Storyboard API</h1></div></div></div><p>The Storyboard API provides an easy solution for developers to control scenes with or without transitions. This is a great scene-management library for displaying menu systems and even managing multiple levels in a game. Storyboard also comes with a variety of transition effects. A listing of them can be found on the <code class="literal">storyboard.gotoScene()</code> API reference page at:<a class="ulink" href="http://developer.anscamobile.com/reference/index/storyboardgotoscene"> http://developer.anscamobile.com/reference/index/storyboardgotoscene</a>.<a id="id561" class="indexterm"/>
</p><p>More information on the Storyboard API can be found on the<span class="emphasis"><em> Anscamobile</em></span> website at:<a class="ulink" href="http://developer.anscamobile.com/content/storyboard"> http://developer.anscamobile.com/content/storyboard</a>.</p><p>Our scene management will look similar to the scene template displayed at:<a class="ulink" href="http://developer.anscamobile.com/reference/index/scene-template"> http://developer.anscamobile.com/reference/index/scene-template</a>.</p><p>You can also download the<span class="emphasis"><em> Storyboard Sample Code</em></span> from<a class="ulink" href="http://https://github.com/ansca/Storyboard-Sample"> https://github.com/ansca/Storyboard-Sample</a> and run the project file in the Corona simulator to get familiar with how it works.</p><div class="section" title="Game development with Storyboard API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec07"/>Game development with Storyboard API</h2></div></div></div><p>You may wonder how we're going to apply Storyboard with Egg Drop. It's really simple actually. We'll have to alter some lines in our game code to make it compatible with Storyboard and create some new scenes for the menu system that is applied before gameplay.<a id="id562" class="indexterm"/>
</p></div></div>
<div class="section" title="Time for action&#x2014;altering the game file"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec07"/>Time for action—altering the game file</h1></div></div></div><p>We're going to rename our current <code class="literal">main.lua</code> file to <code class="literal">maingame.lua</code> and put some additional lines into our game code.<a id="id563" class="indexterm"/>
</p><div class="note" title="Note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title"><a id="tip08"/>Tip</h3><p>Be sure to change the filename within your Egg Drop project folder.</p></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Remove the following lines near the top of the code. We'll hide the status bar in another scene that we'll create later on in this chapter. The <code class="literal">gameGroup</code> display group will be altered to fit within the Storyboard parameters.<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>display.setStatusBar( display.HiddenStatusBar )
local gameGroup = display.newGroup()</strong></span>
</pre></div></li><li class="listitem">At the very top of the code, implement Storyboard by adding <code class="literal">local storyboard = require( "storyboard" )</code> and <code class="literal">local scene = storyboard.newScene()</code> so we can call scene events.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
</pre></div></li><li class="listitem">After <code class="literal">local loadValue = function( strFilename )</code>, add in the <code class="literal">createScene()</code> event. We will also add back in our <code class="literal">gameGroup</code> display group, but under the scene's view property. Also, add <code class="literal">in storyboard.removeScene( "loadgame" )</code>. The<code class="literal">"loadgame"</code> scene will be introduced later on in this chapter.<a id="id564" class="indexterm"/><div class="informalexample"><pre class="programlisting">-- Called when the scene's view does not exist:
function scene:createScene( event )
local gameGroup = self.view
-- completely remove loadgame's view
storyboard.removeScene( "loadgame" )
print( "\nmaingame: createScene event")
end
</pre></div></li><li class="listitem">After the <code class="literal">createScene()</code> event, create the <code class="literal">enterScene()</code> event and add it before the <code class="literal">gameActivate()</code> function. <code class="literal">enterScene()</code> will transition all our gameplay functions onscreen. Include <code class="literal">gameGroup</code> in the scene's view property as well.<div class="informalexample"><pre class="programlisting">-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local gameGroup = self.view
</pre></div></li><li class="listitem">After the <code class="literal">gameStart()</code> function, remove the <code class="literal">return gameGroup</code> line.<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>return gameGroup -- Code will not run if this line is not removed</strong></span>
</pre></div></li><li class="listitem">Next, close <code class="literal">function scene: enterScene( event )</code> with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">print( "maingame: enterScene event" )
end
</pre></div></li><li class="listitem">Create the <code class="literal">exitScene()</code> and <code class="literal">destroyScene()</code> events.<div class="informalexample"><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene( event )
print( "maingame: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying maingame's view))" )
end
</pre></div></li><li class="listitem">Lastly, create event listeners for all the scene events and add <code class="literal">return scene</code> at the end of the code.<a id="id565" class="indexterm"/><div class="informalexample"><pre class="programlisting">-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
-- automatically unloaded in low memory situations, or explicitly via a call to
-- storyboard.purgeScene() or storyboard.removeScene().
scene:addEventListener( "destroyScene", scene )
return scene
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec08"/>What just happened?</h2></div></div></div><p>Using Storyboard API will help us transition scenes a lot easily and quickly. Every time you want to load a new scene into view, <code class="literal">require("storyboard")</code> needs to be added. <code class="literal">local scene = storyboard.newScene()</code> will allow us to call the scene events: <code class="literal">createScene(), enterScene(), exitScene()</code>, and <code class="literal">destroyScene()</code>.</p><p>At the very end of the game code, we added event listeners to all the scene events and <code class="literal">return scene</code>.</p><p>The format for how each scene is managed with Storyboard will look similar to the preceding code. Most of the game code will be dispatched during a scene is displayed by the <code class="literal">createScene()</code> and <code class="literal">enterScene()</code> events. When you want to clean or unload listeners, audio, assets, and so on, the <code class="literal">exitScene()</code> and <code class="literal">destroyScene()</code> events are used.<a id="id566" class="indexterm"/>
</p></div></div>
<div class="section" title="Organizing the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec08"/>Organizing the game</h1></div></div></div><p>We've been used to having the <code class="literal">main.lua</code> as our main source file to show every detail of our game code. It's time to organize it efficiently with the help of Storyboard API.<a id="id567" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;adding the new main.lua file"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec09"/>Time for action—adding the new main.lua file</h1></div></div></div><p>While using Storyboard, our <code class="literal">main.lua</code> file is still vital since it is the first thing that Corona SDK looks at to launch an application in the simulator. We're going add some lines of code that will change scenes for our game.<a id="id568" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a brand new file called <code class="literal">main.lua</code> and let's add back in our status bar.<div class="informalexample"><pre class="programlisting">display.setStatusBar( display.HiddenStatusBar )
</pre></div></li><li class="listitem">Import Storyboard and load the first scene called <code class="literal">loadmainmenu</code>. We will create this scene in the next couple of sections.<div class="informalexample"><pre class="programlisting">-- require controller module
local storyboard = require ( "storyboard" )
-- load first screen
storyboard.gotoScene( "loadmainmenu" )
</pre></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec09"/>What just happened?</h2></div></div></div><p>In order to incorporate Storyboard throughout the application, we called the <code class="literal">local storyboard = require ( "storyboard" )</code> module. The scene will be changed with <code class="literal">storyboard.gotoScene( "loadmainmenu" )</code>, which is a loading screen directing the user to the main menu screen.</p></div></div>
<div class="section" title="New game transitions"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec10"/>New game transitions</h1></div></div></div><p>Now that we have introduced Storyboard API, we can apply some long-awaited transitions that will be helpful to our game. One way to approach this is by transitioning out of the game once it is over.</p></div>
<div class="section" title="Time for action&#x2014;changing screens after the game is over"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec11"/>Time for action—changing screens after the game is over</h1></div></div></div><p>Now that we have renamed our game file, let's add in a scene transition so that our game is not stuck on the<span class="strong"><strong> Game Over</strong></span> screen once gameplay is over.<a id="id569" class="indexterm"/>
</p><p>In our <code class="literal">maingame.lua</code> file, add in a new variable called <code class="literal">local menuBtn</code> where all the other variables are initialized in the beginning of the code. Inside the <code class="literal">callGameOver()</code> function, add the following lines after the <code class="literal">highScoreText</code> code:</p><div class="informalexample"><pre class="programlisting">local onMenuTouch = function( event )
if event.phase == "release" then
audio.play( btnSound )
storyboard.gotoScene( "mainmenu", "fade", 500 )
end
end
menuBtn = ui.newButton{
defaultSrc = "menubtn.png",
defaultX = 60,
defaultY = 60,
overSrc = "menubtn-over.png",
overX = 60,
overY = 60,
onEvent = onMenuTouch,
id = "MenuButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
menuBtn.x = 100; menuBtn.y = 260
gameGroup:insert( menuBtn )
</pre><div class="mediaobject"><img src="graphics/1888_08_03.jpg" alt="Time for action—changing screens after the game is over"/></div></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec10"/>What just happened?</h2></div></div></div><p>In order to transition out of the<span class="strong"><strong> Game Over</strong></span> screen, a menu button was created to change scenes. Inside the <code class="literal">onMenuTouch()</code> function, upon<code class="literal">"release"</code> of the button, we called <code class="literal">storyboard.gotoScene( "mainmenu", "fade", 500 )</code>. This will allow the application to transition to the main menu, which we will create later on in this chapter.<a id="id570" class="indexterm"/>
</p></div><div class="section" title="Have a go hero—restarting the game"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec11"/>Have a go hero—restarting the game</h2></div></div></div><p>Now that you're well aware of how Storyboard API works with changing scenes and using UI buttons to transition between them, how about creating a button that restarts the game after the<span class="strong"><strong> Game Over</strong></span> screen appears. So far, the application allows the user to go back to the menu screen once the game has reached an end.<a id="id571" class="indexterm"/>
</p><p>Within the <code class="literal">callGameOver()</code> function, a new local function needs to be created that will run an event using the UI button system to change scenes with Storyboard. Hint: You can't call the same scene over if you're currently in it.</p></div></div>
<div class="section" title="Creating a loading screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec12"/>Creating a loading screen</h1></div></div></div><p>Loading screens provide feedback that the program is in the process of loading. This is helpful by informing the user that the next screen is underway so they don't assume the application crashed, especially if the next screen is loading a large amount of data.<a id="id572" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;adding the loading screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec13"/>Time for action—adding the loading screen</h1></div></div></div><p>We'll be placing loading screens when the application launches and before the game level starts. This tells the user that more content or information is on its way.<a id="id573" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new file called <code class="literal">loadmainmenu.lua</code> in your project folder.</li><li class="listitem">Import Storyboard and add in the <code class="literal">storyboard.newScene()</code> function.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
</pre></div></li><li class="listitem">Create two local variables called <code class="literal">myTimer</code> and <code class="literal">loadingImage</code>. Add in the <code class="literal">createScene()</code> event and a <code class="literal">screenGroup</code> display group.<div class="informalexample"><pre class="programlisting">local myTimer
local loadingImage
-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
print( "\nloadmainmenu: createScene event" )
end
</pre></div></li><li class="listitem">Create the <code class="literal">enterScene()</code> event and add in a <code class="literal">screenGroup</code> display group.<div class="informalexample"><pre class="programlisting">-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local screenGroup = self.view
print( "loadmainmenu: enterScene event" )
</pre></div></li><li class="listitem">Introduce the <code class="literal">loadingImage</code> display object.<div class="informalexample"><pre class="programlisting">loadingImage = display.newImageRect( "loading.png", 480, 320 )
loadingImage.x = 240; loadingImage.y = 160
screenGroup:insert( loadingImage )
</pre></div></li><li class="listitem">Create another local function called <code class="literal">goToMenu()</code> and call <code class="literal">storyboard.gotoScene( "mainmenu", "zoomOutInFadeRotate", 500 )</code> to change the scene to<code class="literal">"mainmenu"</code>.<div class="informalexample"><pre class="programlisting">local goToMenu = function()
storyboard.gotoScene( "mainmenu", "zoomOutInFadeRotate", 500 )
end
</pre></div></li><li class="listitem">Use the timer function and have it call <code class="literal">goToMenu()</code> in 1000 milliseconds once. Define it with the timerID, <code class="literal">myTimer</code>. Close the <code class="literal">enterScene()</code> event with <code class="literal">end.</code><a id="id574" class="indexterm"/><div class="informalexample"><pre class="programlisting">myTimer = timer.performWithDelay( 1000, goToMenu, 1 )
end
</pre></div></li><li class="listitem">Call the <code class="literal">exitScene()</code> and the <code class="literal">destroyScene()</code> events. In the <code class="literal">exitScene()</code> event, cancel <code class="literal">myTimer</code>.<div class="informalexample"><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene()
if myTimer then timer.cancel( myTimer ); end
print( "loadmainmenu: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying loadmainmenu's view))" )
end
</pre></div></li><li class="listitem">Add event listeners for all the scene events and <code class="literal">return scene</code>. Save and close the file.<div class="informalexample"><pre class="programlisting">-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre></div></li><li class="listitem">Create a new file called <code class="literal">loadgame.lua</code> in your project folder. We'll be making another loading screen that occurs right before the game scene, <code class="literal">maingame.lua</code>. Use <code class="literal">storyboard.gotoScene( "maingame", "flipFadeOutIn", 500 )</code> to transition scenes. Save and close your file.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local myTimer
local loadingImage
-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
-- completely remove mainmenu
storyboard.removeScene( "mainmenu" )
print( "\nloadgame: createScene event" )
end
-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local screenGroup = self.view
print( "loadgame: enterScene event" )
loadingImage = display.newImageRect( "loading.png", 480, 320 )
loadingImage.x = 240; loadingImage.y = 160
screenGroup:insert( loadingImage )
local changeScene = function()
storyboard.gotoScene( "maingame", "flipFadeOutIn", 500 )
end
myTimer = timer.performWithDelay( 1000, changeScene, 1 )
end
-- Called when scene is about to move offscreen:
function scene:exitScene()
if myTimer then timer.cancel( myTimer ); end
print( "loadgame: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying loadgame's view))" )
end
-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre><div class="mediaobject"><img src="graphics/1888_08_04.jpg" alt="Time for action—adding the loading screen"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec12"/>What just happened?</h2></div></div></div><p>In the <code class="literal">loadmainmenu.lua</code> file, once <code class="literal">loadingImage</code> is added to the screen, we created the <code class="literal">goToMenu()</code> function to change scenes to<code class="literal">"mainmenu"</code> and use the transition<code class="literal">" zoomOutInFadeRotate"</code> that zooms out and rotates the loading screen image as it fades to the background. <code class="literal">myTimer = timer.performWithDelay( 1000, goToMenu, 1 )</code> performs the function in 1000 milliseconds (one second) and runs it once. This is long enough to view the image and have it fade out.<a id="id577" class="indexterm"/>
</p><p>All display objects enter the scene by <code class="literal">function scene:enterScene( event ). loadingImage</code> is placed in <code class="literal">screenGroup</code>. To make sure we have no timers running after the scene change, <code class="literal">myTimer</code> stops running with the use of <code class="literal">timer.cancel(myTimer)</code> under <code class="literal">function scene:exitScene()</code>.</p><p>The code for <code class="literal">loadgame.lua</code> is similar to <code class="literal">loadmainmenu.lua</code>. For this file, Storyboard transitions scenes to <code class="literal">maingame.lua</code>, the gameplay file.</p></div></div>
<div class="section" title="Creating a main menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec14"/>Creating a main menu</h1></div></div></div><p>A main menu or title screen is one of the first impressions a player sees before playing the game. It usually shows small snippets of images or scenery that correlate with the actual game and also displays the title of the application.<a id="id578" class="indexterm"/>
</p><p>There are buttons such as<span class="strong"><strong> Start</strong></span> or<span class="strong"><strong> Play</strong></span> that urge the player to go into the game if they choose to and some secondary buttons such as<span class="strong"><strong> Options</strong></span> to view settings and other information that may be included in relation to the app.<a id="id579" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;adding a main menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec15"/>Time for action—adding a main menu</h1></div></div></div><p>We're going to create the frontend of our game by introducing the game title,<span class="strong"><strong> Play</strong></span> button, and<span class="strong"><strong> Options</strong></span> button that will transition throughout different scenes in the application with ease.<a id="id580" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new file called <code class="literal">mainmenu.lua</code> and import Storyboard and UI modules, the <code class="literal">storyboard.newScene()</code> function, and the variables for timer and audio.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local ui = require("ui")
local btnAnim
local btnSound = audio.loadSound( "btnSound.wav" )
</pre></div></li><li class="listitem">Create the <code class="literal">createScene()</code> event. Add in the line, <code class="literal">storyboard.removeScene( "maingame" )</code> and <code class="literal">storyboard.removeScene( "options" )</code>, which will remove the<code class="literal">"maingame" and "options"</code> scene. Removing<code class="literal">"maingame"</code> will occur after the player has transitioned from the main game screen and is sent to the main menu screen. Removing<code class="literal">"options"</code> will occur after the player has transitioned from the options screen and is sent to the main menu screen.<div class="informalexample"><pre class="programlisting">-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
-- completely remove maingame and options
storyboard.removeScene( "maingame" )
storyboard.removeScene( "options" )
print( "\nmainmenu: createScene event" )
end
</pre></div></li><li class="listitem">Add in the <code class="literal">enterScene()</code> event and the <code class="literal">backgroundImage</code> display object.<div class="informalexample"><pre class="programlisting">-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local screenGroup = self.view
print( "mainmenu: enterScene event" )
local backgroundImage = display.newImageRect( "mainMenuBG.png", 480, 320 )
backgroundImage.x = 240; backgroundImage.y = 160
screenGroup:insert( backgroundImage )
</pre></div></li><li class="listitem">Introduce the <code class="literal">playBtn</code> display object and create a function called <code class="literal">onPlayTouch(event)</code> that uses <code class="literal">storyboard.gotoScene()</code> to change the scene to<code class="literal">"loadgame"</code>. Use the<code class="literal">"fade"</code> effect to change scenes.<a id="id581" class="indexterm"/><div class="informalexample"><pre class="programlisting">local playBtn
local onPlayTouch = function( event )
if event.phase == "release" then
audio.play( btnSound )
storyboard.gotoScene( "loadgame", "fade", 300 )
end
end
playBtn = ui.newButton{
defaultSrc = "playbtn.png",
defaultX = 100,
defaultY = 100,
overSrc = "playbtn-over.png",
overX = 100,
overY = 100,
onEvent = onPlayTouch,
id = "PlayButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
playBtn.x = 240; playBtn.y = 440
screenGroup:insert( playBtn )
</pre></div></li><li class="listitem">Transition the <code class="literal">playBtn</code> display object to <code class="literal">y = 260</code> in 500 milliseconds using the <code class="literal">easing.inOutExpo</code> transition. Have it initialized through <code class="literal">btnAnim</code>.<div class="informalexample"><pre class="programlisting">btnAnim = transition.to( playBtn, { time=500, y=260, transition=easing.inOutExpo } )
</pre></div></li><li class="listitem">Introduce the <code class="literal">optBtn</code> display object and create a function called <code class="literal">onOptionsTouch(event)</code>. Use <code class="literal">storyboard.gotoScene()</code> to transition the scene to<code class="literal">"options"</code> using the<code class="literal">"crossFade"</code> effect.<a id="id582" class="indexterm"/><div class="informalexample"><pre class="programlisting">local optBtn
local onOptionsTouch = function( event )
if event.phase == "release" then
audio.play( btnSound )
storyboard.gotoScene( "options", "crossFade", 300 )
end
end
optBtn = ui.newButton{
defaultSrc = "optbtn.png",
defaultX = 60,
defaultY = 60,
overSrc = "optbtn-over.png",
overX = 60,
overY = 60,
onEvent = onOptionsTouch,
id = "OptionsButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
optBtn.x = 430; optBtn.y = 440
screenGroup:insert( optBtn )
</pre></div></li><li class="listitem">Transition the <code class="literal">optBtn</code> display object to <code class="literal">y = 280</code> in 500 milliseconds using the <code class="literal">easing.inOutExpo</code> transition. Have it initialized through <code class="literal">btnAnim</code>. Close the <code class="literal">scene:enterScene( event )</code> function with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">btnAnim = transition.to( optBtn, { time=500, y=280, transition=easing.inOutExpo } )
end
</pre></div></li><li class="listitem">Create the <code class="literal">exitScene()</code> event and cancel the <code class="literal">btnAnim</code> transition. Also, create the <code class="literal">destroyScene()</code> event.<div class="informalexample"><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene()
if btnAnim then transition.cancel( btnAnim ); end
print( "mainmenu: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying mainmenu's view))" )
end
</pre></div></li><li class="listitem">Add the event listeners for all the scene events and <code class="literal">return scene</code>. Save and close your file.<a id="id583" class="indexterm"/><div class="informalexample"><pre class="programlisting">-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre><div class="mediaobject"><img src="graphics/1888_08_05.jpg" alt="Time for action—adding a main menu"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec13"/>What just happened?</h2></div></div></div><p>On the main menu screen, we added an image that displays the game title, a<span class="strong"><strong> Play</strong></span> button, and an<span class="strong"><strong> Options</strong></span> button. The<span class="strong"><strong> Options</strong></span> button is still not functional at this time. The <code class="literal">onPlayTouch()</code> function transitions the scene to<code class="literal">"loadgame"</code>. This will change scenes to <code class="literal">loadgame.lua</code>. The<span class="strong"><strong> Play</strong></span> button is placed at x = 240; y = 440, (middle and offscreen). When the scene loads, <code class="literal">playBtn</code> transitions to y = 260 so it pops up from the bottom of the screen in 500 milliseconds.<a id="id584" class="indexterm"/>
</p><p>The<span class="strong"><strong> Options</strong></span> button does a similar thing. <code class="literal">optBtn</code> is placed towards the right side of the stage and pops up at y = 280 in 500 milliseconds.</p><p>The <code class="literal">btnAnim</code> transition is cancelled by <code class="literal">transition.cancel( btnAnim )</code> through the <code class="literal">scene:exitScene()</code> function. Cleaning timers, transitions, and event listeners is important to do every time you change scenes so potential memory leaks do not occur while in the application.</p></div></div>
<div class="section" title="Creating an options menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec16"/>Creating an options menu</h1></div></div></div><p>An options menu allows users to change various settings in the game or include other information that can't be displayed in the main menu. Games can vary from having many options to only having a few. Sometimes an options menu can be called a settings menu, which offers the same type of customization to the player's experience.<a id="id585" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;adding an options menu"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec17"/>Time for action—adding an options menu</h1></div></div></div><p>We'll be adding an options menu that can be accessed through the main menu. We're going to add a new UI button called<span class="strong"><strong> Credits</strong></span>, which will direct the user to the credits screen once it is pressed.<a id="id586" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new file called <code class="literal">options.lua</code> and import Storyboard and UI modules, the <code class="literal">storyboard.newScene()</code> function, and the variables for timer and audio.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local ui = require("ui")
local btnAnim
local btnSound = audio.loadSound( "btnSound.wav" )
</pre></div></li><li class="listitem">Create the <code class="literal">createScene()</code> event. Add in, <code class="literal">storyboard.removeScene ( "mainmenu" )</code>, which will remove the<code class="literal">"mainmenu"</code> scene. This will occur after the player has transitioned from the main menu screen and is sent to the options screen. Next, add in <code class="literal">storyboard.removeScene( "creditsScreen" )</code>. This will remove the<code class="literal">"creditsScreen"</code> after the player has transitioned from the credits screen back to the options screen.<div class="informalexample"><pre class="programlisting">-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
-- completely remove mainmenu and creditsScreen
storyboard.removeScene( "mainmenu" )
storyboard.removeScene( "creditsScreen" )
print( "\noptions: createScene event" )
end
</pre></div></li><li class="listitem">Add in the <code class="literal">enterScene()</code> event and the <code class="literal">backgroundImage</code> display object.<div class="informalexample"><pre class="programlisting">-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local screenGroup = self.view
print( "options: enterScene event" )
local backgroundImage = display.newImageRect( "optionsBG.png", 480, 320 )
backgroundImage.x = 240; backgroundImage.y = 160
screenGroup:insert( backgroundImage )
</pre></div></li><li class="listitem">Create a button for the credits screen. Transition the <code class="literal">creditsBtn</code> display object to y = 260 in 500 milliseconds using the <code class="literal">easing.inOutExpo</code> transition. Have it initialized through <code class="literal">btnAnim</code>.<a id="id587" class="indexterm"/><div class="informalexample"><pre class="programlisting">local creditsBtn
local onCreditsTouch = function( event )
if event.phase == "release" then
audio.play( btnSound )
storyboard.gotoScene( "creditsScreen", "crossFade", 300 )
end
end
creditsBtn = ui.newButton{
defaultSrc = "creditsbtn.png",
defaultX = 100,
defaultY = 100,
overSrc = "creditsbtn-over.png",
overX = 100,
overY = 100,
onEvent = onCreditsTouch,
id = "CreditsButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
creditsBtn.x = 240; creditsBtn.y = 440
screenGroup:insert( creditsBtn )
btnAnim = transition.to( creditsBtn, { time=500, y=260, transition=easing.inOutExpo } )
</pre></div></li><li class="listitem">Create the<span class="strong"><strong> Close</strong></span> button that loads the main menu. Close the <code class="literal">scene:enterScene ( event )</code> with <code class="literal">end</code>.<div class="informalexample"><pre class="programlisting">local closeBtn
local onCloseTouch = function( event )
if event.phase == "release" then
audio.play( tapSound )
storyboard.gotoScene( "mainmenu", "zoomInOutFadeRotate", 500 )
end
end
closeBtn = ui.newButton{
defaultSrc = "closebtn.png",
defaultX = 60,
defaultY = 60,
overSrc = "closebtn-over.png",
overX = 60,
overY = 60,
onEvent = onCloseTouch,
id = "CloseButton",
text = "",
font = "Helvetica",
textColor = { 255, 255, 255, 255 },
size = 16,
emboss = false
}
closeBtn.x = 50; closeBtn.y = 280
screenGroup:insert( closeBtn )
end
</pre></div></li><li class="listitem">Create the <code class="literal">exitScene()</code> event and cancel the <code class="literal">btnAnim</code> transition. Also, create the <code class="literal">destroyScene()</code> event. Add the event listeners to all the scene events and <code class="literal">return scene</code>. Save and close your file.<div class="informalexample"><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene()
if btnAnim then transition.cancel( btnAnim ); end
print( "options: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying options's view))" )
end
-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
options menuoptions menuaddingscene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre><div class="mediaobject"><img src="graphics/1888_08_06.jpg" alt="Time for action—adding an options menu"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec14"/>What just happened?</h2></div></div></div><p>In this scene, <code class="literal">creditsBtn</code> will operate in a similar fashion like how our main menu was created. The<span class="strong"><strong> Credits</strong></span> button is still not functional at this time. In the <code class="literal">onCreditsTouch()</code> function, the scene is transitioned to<code class="literal">"creditsScreen"</code> and uses<code class="literal">"crossFade"</code> as the effect. From the offscreen position, <code class="literal">creditsBtn</code> transitions to y=260 in 500 milliseconds when the scene is loaded.<a id="id590" class="indexterm"/>
</p><p>A<span class="strong"><strong> Close</strong></span> button is created for this scene so the user will have a way to go back to the previous screen. With the <code class="literal">onCloseTouch()</code> function, Storyboard changes the scene to<code class="literal">"mainmenu"</code> upon<code class="literal">"release"</code> of <code class="literal">closeBtn</code>. The main menu screen will display upon pressing the<span class="strong"><strong> Close</strong></span> button. The <code class="literal">btnAnim</code> transition is cancelled through the <code class="literal">scene:exitScene()</code> function.</p></div></div>
<div class="section" title="Creating a credits screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec18"/>Creating a credits screen</h1></div></div></div><p>A credits screen usually shows and lists all the people involved in the production of the game. It can include other information in the form of thanking certain individuals and programs used to create the final project.<a id="id591" class="indexterm"/>
</p></div>
<div class="section" title="Time for action&#x2014;adding a credits screen"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec19"/>Time for action—adding a credits screen</h1></div></div></div><p>The credits screen we'll be creating will be based on a touch event that transitions to the previous screen from which it was introduced.<a id="id592" class="indexterm"/>
</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Create a new file call <code class="literal">creditsScreen.lua</code> and import Storyboard, the <code class="literal">storyboard.newScene()</code> function, and the <code class="literal">backgroundImage</code> variable.<div class="informalexample"><pre class="programlisting">local storyboard = require( "storyboard" )
local scene = storyboard.newScene()
local backgroundImage
</pre></div></li><li class="listitem">Create the <code class="literal">createScene()</code> event. Add in the line, <code class="literal">storyboard.removeScene ( "options" )</code>, which will remove the<code class="literal">"options"</code> scene. This will occur after the player has transitioned from the options screen and is sent to the credits screen.<div class="informalexample"><pre class="programlisting">-- Called when the scene's view does not exist:
function scene:createScene( event )
local screenGroup = self.view
-- completely remove options
storyboard.removeScene( "options" )
print( "\ncreditsScreen: createScene event" )
end
</pre></div></li><li class="listitem">Add in the <code class="literal">enterScene()</code> event and <code class="literal">backgroundImage</code> display object.<div class="informalexample"><pre class="programlisting">-- Called immediately after scene has moved onscreen:
function scene:enterScene( event )
local screenGroup = self.view
print( "creditsScreen: enterScene event" )
backgroundImage = display.newImageRect( "creditsScreen.png", 480, 320 )
backgroundImage.x = 240; backgroundImage.y = 160
screenGroup:insert( backgroundImage )
</pre></div></li><li class="listitem">Create a local function called <code class="literal">changeToOptions()</code> with an event parameter. Have the function change the scene with Storyboard back to the options screen using a touch event on <code class="literal">backgroundImage</code>. Close the <code class="literal">scene:enterScene( event )</code> function with <code class="literal">end</code>.<a id="id593" class="indexterm"/><div class="informalexample"><pre class="programlisting">local changeToOptions = function( event )
if event.phase == "began" then
storyboard.gotoScene( "options", "crossFade", 300 )
end
end
backgroundImage:addEventListener( "touch", changeToOptions)
end
</pre></div></li><li class="listitem">Create the <code class="literal">exitScene()</code> and <code class="literal">destroyScene()</code> events. Add the event listeners to all the scene events and <code class="literal">return scene</code>. Save and close your file.<div class="informalexample"><pre class="programlisting">-- Called when scene is about to move offscreen:
function scene:exitScene()
print( "creditsScreen: exitScene event" )
end
-- Called prior to the removal of scene's "view" (display group)
function scene:destroyScene( event )
print( "((destroying creditsScreen's view))" )
end
-- "createScene" event is dispatched if scene's view does not exist
scene:addEventListener( "createScene", scene )
-- "enterScene" event is dispatched whenever scene transition has finished
scene:addEventListener( "enterScene", scene )
-- "exitScene" event is dispatched before next scene's transition begins
scene:addEventListener( "exitScene", scene )
-- "destroyScene" event is dispatched before view is unloaded, which can be
scene:addEventListener( "destroyScene", scene )
return scene
</pre><div class="mediaobject"><img src="graphics/1888_08_07.jpg" alt="Time for action—adding a credits screen"/></div></div></li></ol></div><div class="section" title="What just happened?"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec15"/>What just happened?</h2></div></div></div><p>The credits screen works with an event listener. The <code class="literal">changeToOptions(event)</code> function will tell Storyboard to change the scene to<code class="literal">"options"</code> using <code class="literal">storyboard.gotoScene ( "options", "crossFade", 500 )</code>. At the end of the function, <code class="literal">backgroundImage</code> will activate the event listener when the screen is touched. <code class="literal">backgroundImage</code> is inserted into the <code class="literal">screenGroup</code> under the <code class="literal">scene:enterScene( event )</code> function. Egg Drop is now fully operable using Storyboard. Run the game in the simulator. You'll be able to transition to all the scenes we have created in this chapter as well as play the game.<a id="id595" class="indexterm"/>
</p></div><div class="section" title="Have a go hero—adding more levels"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec16"/>Have a go hero—adding more levels</h2></div></div></div><p>Now that Egg Drop is completed and has a working menu system, challenge yourself by creating more levels. Minor alterations will have to be added to incorporate some placement for additional levels. Remember to apply Storyboard when changing scenes.<a id="id596" class="indexterm"/>
</p><p>Try creating the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Level select screen</li><li class="listitem" style="list-style-type: disc">Level number buttons to add additional levels</li></ul></div><p>When creating new levels, refer to the format as shown in <code class="literal">maingame.lua</code>. New levels can be altered by changing the interval of how fast the egg falls from the sky or maybe adding other game assets that fall but have to be avoided so there is no penalty during gameplay. There are so many possibilities on adding your own spin with this game framework. Give it a try!</p></div><div class="section" title="Pop quiz—game transitions and scenes"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec17"/>Pop quiz—game transitions and scenes</h2></div></div></div><div class="orderedlist"><ol class="orderedlist"><li class="listitem">Which function do you call to change scenes with Storyboard?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">storyboard()</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">storyboard.gotoScene()</code></li><li class="listitem" style="list-style-type: none">c. <code class="literal">storyboard(changeScene)</code></li><li class="listitem" style="list-style-type: none">d. None of the above</li></ul></div></li><li class="listitem">Which function converts any argument into a number?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">tonumber()</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">print()</code></li><li class="listitem" style="list-style-type: none">c. <code class="literal">tostring()</code></li><li class="listitem" style="list-style-type: none">d. nil</li></ul></div></li><li class="listitem">How do you pause a timer?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">timer.cancel()</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">physics.pause()</code></li><li class="listitem" style="list-style-type: none">c. <code class="literal">timer.pause( timerID )</code></li><li class="listitem" style="list-style-type: none">d. None of the above</li></ul></div></li><li class="listitem">How do you resume a timer?<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: none">a. <code class="literal">resume()</code></li><li class="listitem" style="list-style-type: none">b. <code class="literal">timer.resume( timerID )</code></li><li class="listitem" style="list-style-type: none">c. <code class="literal">timer.performWithDelay()</code></li><li class="listitem" style="list-style-type: none">d. None of the above</li></ul></div></li></ol></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec20"/>Summary</h1></div></div></div><p>Congratulations! We have a game that is complete enough to go into the App Store or Google Play Store. Of course not using this exact game, but we have learned enough material to create one. It's a great accomplishment to have completed game framework, especially in the short amount of time it took to create something so simple.</p><p>Here are some skills you learned:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Saving high scores using <code class="literal">saveValue()</code> and <code class="literal">loadValue()</code></li><li class="listitem" style="list-style-type: disc">Understanding how to pause physics/timers</li><li class="listitem" style="list-style-type: disc">Displaying the pause menu</li><li class="listitem" style="list-style-type: disc">Changing scenes with the Storyboard API</li><li class="listitem" style="list-style-type: disc">Creating transitions between scenes using loading screens</li><li class="listitem" style="list-style-type: disc">Using a main menu to introduce the game title and submenus</li></ul></div><p>This chapter was an important milestone to achieve. Everything that we have gone over in the previous chapters was applied to this sample game. The great thing about it is that it took only less than a day's worth of development to code. The art assets on the other hand are a different story.</p><p>We still have quite a few more things to learn of what Corona SDK is capable of. In the next chapter, we'll go over more in detail on how to optimize our game assets for high-resolution devices. We're also going to go over how to post messages on Facebook and Twitter and sync our applications with Openfeint!</p></div></body></html>