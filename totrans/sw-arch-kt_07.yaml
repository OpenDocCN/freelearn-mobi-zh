- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Modular and Layered Architectures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The previous chapters have repeatedly mentioned the importance of appropriate
    modularization of the system and addressing concerns separately. In this chapter,
    we delve into four prominent architectural patterns that offer their approaches
    to separate concerns in layers, modularize code, and set up clean boundaries among
    modules.
  prefs: []
  type: TYPE_NORMAL
- en: All these patterns will be illustrated with the same real-life example to highlight
    the similarities and differences of these patterns.
  prefs: []
  type: TYPE_NORMAL
- en: By understanding these patterns with code examples in Kotlin, engineers can
    make informed choices to create loosely coupling and highly cohesive modules that
    are testable, flexible, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following architectural patterns will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hexagonal architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional core, imperative** **shell** (**FCIS**)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Connect pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end, these patterns will be briefly compared with one another. We will
    also explore the possibility of taking elements from each pattern to create a
    hybrid pattern to meet the requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7%0D)'
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Clean Architecture** is an architectural pattern that advocates organizing
    a software system into distinct layers, each with its own responsibilities and
    dependencies.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The term Clean Architecture was introduced by Robert Martin (known as *Uncle
    Bob*) in his book titled *Clean Architecture: A Craftsman’s Guide to Software
    Structure and Design*, published in 2017\. The foundation of this approach is
    built upon a few earlier architectural patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The hexagonal architecture** (also known as **ports and adapters**) by Alistair
    Cockburn'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Onion Architecture** by Jeffrey Palermo'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screaming Architecture** by Robert Martin'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data, context, and interaction** (**DCI**) by James Coplien and Trygve Reenskaug'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boundary-control-entity** (**BCE**) by Ivar Jacobson'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean Architecture dissects a software system by numerous layers, where each
    layer is wrapped one on top of the other, like an onion. The **Dependency Rule**
    of Clean Architecture states that the outer layers always depend on the inner
    layers.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Clean Architecture](img/B21737_07_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – Clean Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Due to the Dependency Rule, any change in the outer layer does not affect the
    inner layer. On the contrary, any change in the inner layer may affect the outer
    layer.
  prefs: []
  type: TYPE_NORMAL
- en: Let us go through the layer from the innermost to the outermost, demonstrated
    by the real-life example we use throughout previous chapters—households in a village
    exchanging services with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Entities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Entities layer** is the innermost layer, which depends on no other layer.
    This layer is designed to encapsulate business rules shared among applications.
  prefs: []
  type: TYPE_NORMAL
- en: It contains mostly data structures and functions only. It rarely depends on
    external libraries. The only libraries it depends on are most likely those that
    provide specialized data structures. This layer is also the least likely to change.
  prefs: []
  type: TYPE_NORMAL
- en: In our real-life example, there are a few candidates suitable to be hosted in
    the Entities layer. `Household`, `Contract`, `Service`, and subclasses of `Service`
    as Kotlin data classes belong to the Entities layer. Certain rules and policies
    can also reside in the Entities layer. Here are a few example rules.
  prefs: []
  type: TYPE_NORMAL
- en: Rule 1 – Household name must not be null and must have at least one member
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This rule is enforced by the Kotlin non-null field syntax in data classes and
    the validation within the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Rule 2 – Contract must be in one of the specified states
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This rule is enforced by the Kotlin enumeration feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Rule 3 – a Contract consists of two Household objects and a state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This rule is enforced by Kotlin data classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These classes are Pure Kotlin and can be shared among the four services we defined
    earlier in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212), namely *Household
    Service*, *Contract Service*, and *Notification Service*. Arguably, Household
    Service does not need a `Contract` class, and this may be a trade-off for most
    services to share entity classes but not all.
  prefs: []
  type: TYPE_NORMAL
- en: Use Cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Use Cases layer** is one layer above the Entities layer. It is designed
    to encapsulate business rules within an application.
  prefs: []
  type: TYPE_NORMAL
- en: It contains use cases that make use of the data structures and functions in
    the Entities layer. Any change in this layer should not affect the Entities layer.
    This layer should also remain neutral to choices of frameworks and technologies,
    such as databases and messaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our real-life example, we have a use case of a household drafting a contract
    with another household, using the Negotiation Service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `draftContract` function validates that the two households are not the same.
    If everything looks good, it creates a contract with both households and their
    services to be provided. In addition, it set the contract state to `DRAFTED`.
    This `draftContract` function in the Use Cases layer makes use of the `Household`,
    `Party`, `ContractState`, and `Contract` classes from the Entities layer.
  prefs: []
  type: TYPE_NORMAL
- en: There could be a bit of fluidity between the Entities layer and the Use Cases
    layer. If one feature in Entities is considered only relevant to one application,
    it can be moved to the Use Cases layer. Similarly, if there are duplicated logics
    in the Use Cases layer in different applications, they can be extracted into the
    Entities layer.
  prefs: []
  type: TYPE_NORMAL
- en: Interface Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Entities and Use Cases layers are considered internal models, where data
    structures are not exposed outside of the application. The **Interface Adapters
    layer** serves as the translation between the internal and the external models.
    Typical examples of external models are relational database tables, message payloads,
    HTTP request and response payloads, file formats, and visual representation in
    the **graphical user** **interface** (**GUI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'We already have a few examples of where the code should stay in the Interface
    Adapters layer:'
  prefs: []
  type: TYPE_NORMAL
- en: The peer-to-peer architectures covered in [*Chapter 4*](B21737_04.xhtml#_idTextAnchor102)
    have illustrated the example code of conversion between a `Contract` object and
    a binary payload used for **User Datagram Protocol** (**UDP**) transmission.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the same chapter, there is a similar example, but the conversion is between
    a `Contract` object and a **JavaScript Object Notation** (**JSON**) payload that
    is defined by **OpenAPI** specifications, under the client-server architecture.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The three frontend architectural styles covered in [*Chapter 5*](B21737_05.xhtml#_idTextAnchor125),
    MVC, MVP, and MVVM, would have the corresponding code in this layer, as they transform
    internal models to the view that is rendered as GUI.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the application uses query languages, such as SQL, for relational databases,
    they should also stay in the Interface Adapters layer.
  prefs: []
  type: TYPE_NORMAL
- en: These external models and their corresponding conversion should not leak into
    other layers. The layer should not contain business logic either. The concern
    of internal models is separated from layers outside of the Interface Adapters
    layer, and the concern of external models is separated from layers inside of the
    Interface Adapters layer.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks and Drivers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Frameworks and Drivers layer is one layer outside of the Interface Adapters
    layer. This is where external frameworks are added to make it an application.
    Typical examples are HTTP endpoint routing configurations, database connection
    details, Kubernetes configurations, and dependency management. Quite often, this
    layer contains configuration files more than source code.
  prefs: []
  type: TYPE_NORMAL
- en: This layer should never contain business use cases. It does not know any internal
    models and therefore no conversion from external models. This layer focuses on
    supporting configurations that turn code into an application executable in a runtime.
    It should address only non-functional requirements, such as startup time, or redundancy.
  prefs: []
  type: TYPE_NORMAL
- en: An example use case with Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let us take a use case as an example of how different layers are used. A household
    is presented with a form to submit a draft contract, which is a web page in the
    Frameworks and Drivers layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The household then submits the form as JSON values and enters the controller
    in the Interface Adapters layer. The controller converts the form into a few internal
    objects, such as the objects of both `Household` and the services provided as
    strings. These internal objects are then passed to a `draftContract` function
    in the Use Cases layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The function creates a `Contract` object, which comes from the Entities layer.
    The function passes a `Contract` object to the presenter in the Interface Adapters
    layer. The presenter converts the `Contract` object into a JSON value to be rendered
    by the web page in the Frameworks and Drivers layer. The whole journey is illustrated
    in *Figure 7**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Example use case of Clean Architecture](img/B21737_07_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – Example use case of Clean Architecture
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of Clean Architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The centerpiece of Clean Architecture is the Dependency Rule, not the four defined
    layers. With justifications, there could be variation in the layers, but the Dependency
    Rule should still apply.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, concerns are separated in each layer in Clean Architecture. Each layer
    is dedicated to address specific concerns that no other layers do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Entities layer**: Functional requirements shared among applications'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Use Cases layer**: Functional requirements within an application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface Adapters layer**: Conversion between internal and external models'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Frameworks and Drivers layer**: Non-functional requirements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With a clear separation of concerns, we now have the Entities layer and the
    Use Cases layer independent of the choices of frameworks and technologies. They
    have no knowledge about the external world. They are testable without **user interfaces**
    (**UIs**), databases, messaging, files, or any external representation. It is
    computationally cheap to execute a test in these two layers, and therefore we
    can afford to run a comprehensive test suite without significant penalty on build
    times.
  prefs: []
  type: TYPE_NORMAL
- en: As the technology and framework choices only exist in the Interface Adapters
    layer and the Framework and Drivers layer, engineers can make changes to the framework
    in these layers, knowing that the functional logic in the Entities and Use Cases
    layers is intact. In addition, there could be test cases in these layers to ensure
    the correctness of internal-external model conversion, and the correctness of
    configuration of the framework in these layers.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, it enables a smooth transition of technology change. A new technology
    can be introduced and coexist with the old one. Engineers can commit incrementally
    to the changes required for the new technology. There can be toggles to switch
    between the new and old technology for testing purposes. Once the team is happy
    with the change, they can switch to the new technology and clean up the code afterward.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture is one of the architectural patterns that Clean Architecture
    is built upon. We are going to explore the hexagonal architecture in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Hexagonal architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **hexagonal architecture**, also known as the **ports and adapters architecture**,
    aims to address the problem of coupling between the core business logic and external
    dependencies, such as databases, UIs, and external systems.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture was introduced by Alistair Cockburn in his paper,
    *Hexagonal Architecture*, published in 2005.
  prefs: []
  type: TYPE_NORMAL
- en: The two fundamental concepts of this architectural style are **ports** and **adapters**.
    Ports define the interactions between the internal and the external worlds, and
    adapters provide the implementation details of these interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of hexagonal architecture is visualized in *Figure 7**.3* as a hexagon.
    It is worth noting that this architecture allows as many sides as possible, not
    limited to only six as the name *hexagon* suggests.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3 – An example of the hexagonal architecture](img/B21737_07_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – An example of the hexagonal architecture
  prefs: []
  type: TYPE_NORMAL
- en: We will cover each element of the hexagonal architecture in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The core of the hexagonal architecture encapsulates the business logic of the
    application in a pure way, without involving any technology and framework. The
    core is often called “the Domain.” The only exception may be a library that provides
    the data structure needed to support the business logic. The core does not depend
    on any adapter implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The core contains data structures and functions that represent pure business
    logic. Taking the same real-life example we have for households exchanging service,
    we should have these elements in the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HouseHold`, `Party`, and `Contract` data classes; the `ContractState` enum
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draftContract` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ports
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Ports** are the interfaces describing what the application can do. There
    are two types of ports in the hexagonal architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Primary port**: Known as the driving port, this determines inputs required
    by the core to perform an operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secondary port**: Known as the driven port, this determines what outputs
    are produced by the core for the external world’s consumption'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The port interfaces should be defined by the needs of the core and not the external
    world. If we are writing a new application from scratch, we should start from
    the core and define port interfaces for what the core needs, even without any
    code in adapters.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the code we have in the core, we need to define port interfaces
    for the external world to use the core and consume the result produced by the
    core.
  prefs: []
  type: TYPE_NORMAL
- en: In the real-life example where a household intends to draft a contract, the
    core validates the request and produces a drafted contract. The core needs a repository
    to store the drafted contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need a primary port to allow a contract to be drafted. The `ContractService`
    interface is exposed for external usage, but the implementation of the interface
    stays in the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a secondary port to allow a draft contract to be persisted. The
    `ContractRepository` interface is implemented by adapters to provide the technical
    details of how a `Contract` object is saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the primary port interface, `ContractService`, validates
    the draft contract and creates a `Contract` object with a `DRAFTED` state. Then,
    the `Contract` object is passed to `ContractRepository` to be saved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ContractServiceImpl` class is a part of the core logic and stays in the
    core. It is able to implement business behaviors without specifying how `Contract`
    is saved. In other words, the core focuses on business rules and is free of the
    concerns of the choice of technology and frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adapters are responsible for translating external models to the internal models,
    which are defined in the core.
  prefs: []
  type: TYPE_NORMAL
- en: Adapters use the primary port as an entrance to the core and run business operations.
    An adapter is tied to at least one framework, and it has an external representation
    of the entities involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real-life example, the adapter can be a `POST` endpoint to create a
    draft contract. The payload is a JSON value, represented by the `DraftContractRequest`
    class, which can be converted into a `Contract` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Contract Service has locally cached `Household` objects, which can be looked
    up by household name from the `HouseholdRepository` repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The function returns a `Household` object if the household of the given name
    is found. Otherwise, it returns a `null` value. The REST controller class, `ContractController`,
    is defined to accept HTTP requests to draft a contract. This controller uses Spring
    Boot as the framework to register URI mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The controller is injected with the `ContractService` primary port to enter
    the core and draft a contract. It is also injected with the `HouseholdRepository`
    secondary port to look up `Household` objects for validation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The controller defines a mapping of `POST /contracts/draft` that accepts JSON
    value as input and as output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The controller converts the `DraftContractRequest` request payload and validates
    that household names in the payload exist. If any household does not exist, a
    `404 (Not Found)` HTTP status is returned to the requester.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The controller invokes the `draftContract` function in the `ContractNegotiationService`
    primary port, which validates the request and persists the draft contract in the
    repository.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the operation has finished, and the controller returns a `201 (Created)`
    HTTP status back to the requester with the details of the draft contract. The
    response payload is represented by the `ContractDto` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There is a `toDto` function for the conversion from the internal model to the
    external model of the contract:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The data was transformed and passed through the layers of the hexagonal architecture
    in this example, as demonstrated in *Figure 7**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Example use case of the hexagonal architecture](img/B21737_07_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Example use case of the hexagonal architecture
  prefs: []
  type: TYPE_NORMAL
- en: The request payload as JSON value is validated in the `ContractController` adapter
    with the help of a `HouseholdRepository` secondary port. Then, the payload is
    converted to the `Household` objects defined in the core. The core runs through
    the business process and uses a `ContractRepository` secondary port to persist
    a valid draft `Contract` object. Then, the result is populated to the `ContractController`
    adapter. Finally, the adapter converts the `Contract` object to a response payload.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of hexagonal architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Separating source code in the layers of the hexagonal architecture certainly
    makes the code base more complicated. It does bring a few benefits by separating
    the source code between the core and the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: The core encapsulates pure business rules and the adapter contains all technology
    details. This separation makes it extremely easy to test the concerns of correctness
    and technology integration independently.
  prefs: []
  type: TYPE_NORMAL
- en: The core contains a comprehensive test suite that ensures the business rules
    are enforced as intended, without involving any technology.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the adapter contains test cases that verify the configuration
    of the chosen technology and frameworks work as intended, without mixing business
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: An adapter is designed to be pulled and replaced by another adapter at any time.
    An adapter is specifically implemented for a chosen technology or framework, but
    the port has no knowledge about it. For example, if the request and response use
    messaging technology, such as queuing, then we can replace `ContractController`
    with a different adapter, such as `DraftContractRequestConsumer`.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of the secondary port as an adapter can also be replaced
    if needed. For example, we could have an implementation of a memory cache or relational
    database of `HouseholdRepository`. They can coexist and we can use configuration
    to decide which one is used at runtime. Each adapter can be tested in isolation.
  prefs: []
  type: TYPE_NORMAL
- en: This separation of concerns results in enabling engineers to conform to the
    **single responsibility principle** (**SRP**), in which the core has only one
    reason to change, and each adapter has only one reason to change.
  prefs: []
  type: TYPE_NORMAL
- en: Coming next, we are going to cover an architecture pattern that aims to solve
    this similar challenge, but in the functional style.
  prefs: []
  type: TYPE_NORMAL
- en: Functional core, imperative shell
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**FCIS** emerged as an architectural pattern over time in the functional programming
    community. It is a design principle that advocates separating the immutable core
    business logic from the mutable aspects, such as persistent storage or external
    system integration. It aligns and encourages functional programming principles
    with the use of stateless functions and immutable data structures.'
  prefs: []
  type: TYPE_NORMAL
- en: Stateless functions are sometimes called pure functions. They can be executed
    without causing side effects, in other words, for a given input, the function
    always produces the same output. Immutable data structures never change their
    content.
  prefs: []
  type: TYPE_NORMAL
- en: The FCIS principle has been influenced by various software development paradigms
    and architectural patterns. It shares similarities with the hexagonal architecture,
    which also promotes separating the core logic from the infrastructure concerns.
  prefs: []
  type: TYPE_NORMAL
- en: There are two major components in FCIS. The functional core contains stateless
    functions and immutable data structures that represent business logic and entities,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: The imperative shell, on the other hand, is the layer outside of the functional
    core that interacts with the external world, such as database operations, messaging,
    or UIs. This layer is responsible for executing the imperative and mutable operations
    required by the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The FCIS architecture can be demonstrated in *Figure 7**.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – FCIS](img/B21737_07_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – FCIS
  prefs: []
  type: TYPE_NORMAL
- en: We are going to cover these two components of this architectural style here.
  prefs: []
  type: TYPE_NORMAL
- en: Functional core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The functional core focuses on the core business logic, which consists of stateless
    functions and immutable data structures only.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the same real-life example we have for households exchanging service,
    we should have these elements in the core:'
  prefs: []
  type: TYPE_NORMAL
- en: '`HouseHold`, `Party`, and `Contract` data classes and the `ContractState` enum
    class'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`draftContract` function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All data classes are immutable, and all functions are stateless in our example.
    They are tested in isolation by simply verifying the output of the function given
    the input.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `draftContract` function would need a tweak from the implementation
    shown in the example from the Clean Architecture section, because we need to build
    up higher-order functions with potential errors found along the way.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with this approach, we need to define what errors we may encounter.
    We will start with defining the types of errors first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need a wrapper data class for the error itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to be able to communicate that functions can return an expected result,
    but there is also a chance an error occurred. This new implementation of `draftContract`
    uses the `Either` class from **Arrow** library to express this outcome:'
  prefs: []
  type: TYPE_NORMAL
- en: Arrow
  prefs: []
  type: TYPE_NORMAL
- en: '`Option` and result types for error handling using `Either`. It also provides
    various functional programming patterns, such as functors, monads, and applicatives.
    Arrow aims to improve code readability, maintainability, and robustness by enabling
    developers to express computations in a functional style, making it easier to
    manage complex data flows and side effects in Kotlin applications.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draftContract` function returns an `Either` object in which the left type
    parameter is always the potential error, and the right type parameter is always
    the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The same validation ensures the contract does not have the same `Household`
    on both sides. However, instead of throwing an exception, the function returns
    the left side value, which is represented by the `Error` class just defined earlier
    on.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: If everything is fine, the function returns the right side value, which is the
    `Contract` object itself.
  prefs: []
  type: TYPE_NORMAL
- en: Imperative shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The imperative shell handles the necessary interactions with the outside world,
    providing the necessary integration points and adaptors.
  prefs: []
  type: TYPE_NORMAL
- en: In the real-life example, this includes the persistence of the `Contract` object
    and the REST endpoint controller that accepts HTTP `POST` requests to draft a
    contract.
  prefs: []
  type: TYPE_NORMAL
- en: 'Apart from the REST controller, there are two more imperative operations involved.
    The first one looks up a `Household` object by the name, and the second one persists
    a `Contract` object. We define them using `typealias` in this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to these two functions defined, we also need a function to ensure
    the household mentioned in the request exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `ensureHouseholdExist` function makes use of `HouseholdLookup` to check
    if the two households mentioned in the `DraftContractRequest` request exist. If
    not, the left side of `Either` will be returned to report the household not found
    error. If both households exist, the household records are returned for further
    processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this function defined, we can now inject them into the imperative controller
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `draft` function now takes full advantage of the `Either` class by collapsing
    the right type parameter with the `flatMap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `flatMap` functions chain the results of `Either` to return either the first
    error on the left or the final expected result on the right. The preceding code
    firstly checks and ensures that both households mentioned in the request exist.
    The next chained call gets the household records from the `ensureHouseholdExist`
    function and it passes all parameters to the `draftContract` function to validate
    business rules and return a `Contract` object of the `DRAFTED` state.
  prefs: []
  type: TYPE_NORMAL
- en: The next chained call receives the `Contract` object of the `DRAFTED` state
    and calls the `ContractPersist` function to persist this contract.
  prefs: []
  type: TYPE_NORMAL
- en: After the `Contract` record is persisted, it is transformed into a **data transfer
    object** (**DTO**) that will be exposed and returned to the HTTP client that initiated
    the request.
  prefs: []
  type: TYPE_NORMAL
- en: At the last part of the chained call, the `fold` function is invoked to differentiate
    the response back to the HTTP client. The success result as a `Contract` object,
    the right side, is converted to the `ContractDto` response payload by the `toDto`
    function. A `201 (Created)` HTTP status is returned together with the response
    payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the possible errors are collapsed onto the left side, and they are mapped
    to the HTTP status code, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Benefits of functional core, imperative shell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: FCIS separates the code into two parts.
  prefs: []
  type: TYPE_NORMAL
- en: The functional core is a purely functional area that only contains stateless
    functions and immutable data structures, which can be easily tested and reasoned
    about. There is no state management and no side effects. Each test is about verifying
    the output of the function given the input values.
  prefs: []
  type: TYPE_NORMAL
- en: The functional core is also free of technology choice. It makes the functional
    core focus on only business concerns. There is no need to change the code if we
    decide to use other technologies to receive requests and produce responses. This
    makes the core logic reliable, adaptable, and maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The only exception, as we shown in the example, is the use of the `Either` class
    brought from the Arrow library, to express that an operation can fail and return
    a different object.
  prefs: []
  type: TYPE_NORMAL
- en: This encourages engineers to organize the code to conform to the SRP in which
    each function has only one reason to change. We still need to organize our functions
    with the best practices to conform to SRP though. For example, each function needs
    to be small, reusable, stateless, and with one purpose only.
  prefs: []
  type: TYPE_NORMAL
- en: Separating the functional core from the imperative shell allows for easier evolution
    of the core logic without being tightly coupled to the external systems or implementation
    details. It also allows for greater flexibility and maintainability, leading to
    more robust and flexible software architectures.
  prefs: []
  type: TYPE_NORMAL
- en: The next architectural pattern we are going to cover focuses on adapting to
    a remote API call.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Connect pattern was first introduced by David Denton in his technical article,
    *Smash your Adapter Monolith with the Connect pattern*, on the internet in 2011.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern, however, has a different focus from the three architectural patterns
    previously discussed. It is specifically targeted at remote system integration.
    It aims to provide a testable and extensible approach to encapsulate remote API
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The concept of the Connect pattern is illustrated in *Figure 7**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – The Connect pattern](img/B21737_07_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – The Connect pattern
  prefs: []
  type: TYPE_NORMAL
- en: An integration operation is abstracted as an Action. It understands how to generate
    a request and how to transform a response into an internal object. However, it
    does not know the connection details to the external system.
  prefs: []
  type: TYPE_NORMAL
- en: An adapter, on the other hand, is crafted to adapt to a specific system. It
    can establish a connection with an external system while delegating the actual
    request-response exchange to an Action.
  prefs: []
  type: TYPE_NORMAL
- en: Action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **Action** is responsible for transforming requests from internal to external
    format and transforming responses from external to internal format. Using the
    same real-life example of the villagers exchanging services, there are some supporting
    functions that we need from the Household Service, and one of them is as simple
    as getting a household by the given household name.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Action related to communicating with the Household Service is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: There are only two simple functions. The `toRequest` function generates a request
    in an external format to communicate with Household Service. The `fromResponse`
    function transforms a response from Household Service to an internal object. The
    type variable, `R`, is specific to the given Action and can vary.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Action to get a household name by the given household name is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `GetHousehold` class encapsulates the details needed to generate the HTTP
    request to Household Service. The response from Household Service is transformed
    to an internal data class, `Household`, using `Household` data class is defined
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: So far, there are no connection details to Household Service, but this will
    be covered by the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The adapter class provides a way to abstract away the connectivity details
    and mechanism to an external system. The `Household` API is defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HouseholdApi` interface acts as a wrapper and handle for the invocation
    of the specific action. The companion object is defined as a placeholder for extension
    functions, which will be covered later. An HTTP implementation that communicates
    with a local Household Service is implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This `Household` API implementation is an anonymous inner class that sets the
    host of Household Service to localhost and sets the authorization bearer token.
    It assumes that all `HouseholdAction` would use the same connectivity settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moreover, an extension function is defined to make the usage code tidier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The code usage example is going to be covered in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the Action and the adapter set up, the usage of the Household Service
    to get a household by the given name only requires three lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The variable app is `HttpHandler`, which defines URI routings. Only a `GET`
    endpoint is defined in this example, together with a canned response back to the
    HTTP client.
  prefs: []
  type: TYPE_NORMAL
- en: In the `main` function, an HTTP client implementation is created to be fed to
    create an HTTP implementation of `HouseholdApi`. Then, the extension function
    is used to get a household with the name *Whittington*. Internally, a `GetHousehold`
    Action is created and passed into `HouseholdApi` and kicks off the API communication.
    However, from a usage point of view, an object of the internal `Household` data
    class is returned.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the strengths of the Connect pattern is better testability. Each Action
    and API with the Household Service can be tested individually. This is the test
    case of getting a household from the Household API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: When there are more Actions, there will be more test cases, but each test case
    is isolated. In other words, the Actions and test cases scale without creating
    an interface with many functions.
  prefs: []
  type: TYPE_NORMAL
- en: Benefits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The major benefits of the Connect pattern are extensibility and testability.
    Given it is common to use multiple APIs of an external system, engineers often
    end up with one interface for the external system with many functions. With the
    Connect pattern, each API call is represented by an Action and thus breaks down
    the big interface into smaller pieces.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern naturally conforms to the SRP as an Action represents only one
    API call. Moreover, each Action has its own dedicated test case, which is a lot
    simpler than testing an interface with many functions.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter has abstracted away the concern of connectivity details to a remote
    system, so Action classes can focus on the message formats and interactions.
  prefs: []
  type: TYPE_NORMAL
- en: The use of Kotlin extension functions makes the code usage fluent, tidy, and
    small. A lot of details are hidden and encapsulated within the Action and adapter
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: Although the example uses HTTP and Kotlin, the Connect pattern itself is not
    restricted to them.
  prefs: []
  type: TYPE_NORMAL
- en: This pattern is particularly useful in the usage of communicating with a monolithic
    application that exposes a lot of functions in one interface.
  prefs: []
  type: TYPE_NORMAL
- en: Coming next, we are going to briefly compare these architectural styles.
  prefs: []
  type: TYPE_NORMAL
- en: Comparisons of architectural styles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first three architectural styles we discussed in this chapter have a great
    deal of similarities. They all aim to solve the same issues; the variations are
    in the approaches.
  prefs: []
  type: TYPE_NORMAL
- en: Meanwhile, the Connect pattern focuses on the testability and extensibility
    of remote system interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency on frameworks and technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Traditional architectures often tightly couple the business logic with specific
    frameworks, libraries, or technologies. This makes it difficult to switch or upgrade
    these components without making widespread changes throughout the code base.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture proposes the Entities layer for enterprise business rules
    and the Use Cases layer for application-specific business rules. Both are neutral
    to choices of frameworks and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture proposes the core as the centerpiece for business
    logic, also free of the choices of frameworks and technologies.
  prefs: []
  type: TYPE_NORMAL
- en: FCIS proposes the functional core for business logic, but with the use of stateless
    functions and immutable data structures.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern uses Action for the integration point of a single action
    and an adapter for the transport details of the interaction with the remote system.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In traditional architectures, testing the core business logic can be challenging
    due to dependencies on external systems, databases, or UI frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: Testing a function coupled with a choice of technology typically requires a
    lot of setting up and tearing down of resources, and worse if there are asynchronous
    processes behind the scenes. This means it requires more effort from engineers
    to make the tests work, fewer tests can be written for the same amount of time,
    the test suite takes longer to run, and there could be flaky tests that fail occasionally
    due to some asynchronous processes involved. Any parallel executed tests can make
    the test suite even more flaky.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture offers dedicated layers for business logic only (the Entities
    and Use Cases layers), which can be tested in isolation without involving any
    choice of technology. The Interface Adapters layer focuses on internal and external
    model translation, which can be also tested independently. The configurations
    of the Frameworks & Driver layers can be tested without involving business rules.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture advocates the core as a technology-neutral area where
    unit tests can be easily written without the need for complex setups or mocking
    extensive external components. Each adapter can be tested individually and without
    involving any business logic.
  prefs: []
  type: TYPE_NORMAL
- en: FCIS suggests putting only business logic as stateless functions and immutable
    data structures in the functional core. This reduces testing of the functional
    core using a simple verification of the output result given by input. The imperative
    shell can also be tested easily by swapping the lower-order functions in the functional
    core, as a result, the immutable and the mutable parts of the systems can be tested
    separately.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern breaks down the large remote interface of a monolithic application
    into one Action per API call. This reduces a lot of overhead, excessive mocking,
    test double, or stubbing of the interface. The ability to test an API call in
    isolation improves testability and enables easy extension of the usage of a remote
    API.
  prefs: []
  type: TYPE_NORMAL
- en: Maintainability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Over time, applications tend to evolve and change, often requiring modifications
    to the core business logic or the choice of frameworks. In traditional architectures,
    making changes can be risky as these modifications may have unintended consequences
    throughout the system. Updating business logic may have intertwined with a deprecated
    library and eventually, both need to be changed.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture, the hexagonal architecture, and FCIS provide a clear separation
    between the core business logic and the surrounding infrastructure, making it
    easier to modify or extend the application without affecting the core business
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern is very lightweight and there is no overlapping among Actions.
    The connectivity and message interaction concerns are separated into adapter and
    Action classes, the maintenance of these classes is simple, and code changes are
    small.
  prefs: []
  type: TYPE_NORMAL
- en: Flexibility and adaptability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Applications often need to integrate with various external resources, such as
    files, databases, third-party services, or UIs. In traditional architectures,
    these integrations are deeply embedded within the application code, making it
    challenging to switch or modify these integrations.
  prefs: []
  type: TYPE_NORMAL
- en: Clean Architecture promotes the Interface Adapters and Frameworks and Drivers
    layers to contain external dependencies. This allows more flexibility and adaptability,
    as the business rules remain decoupled from specific technologies or protocols.
  prefs: []
  type: TYPE_NORMAL
- en: The hexagonal architecture promotes the use of ports and adapters, which act
    as interfaces and adapters between the core logic and the external systems. A
    different choice of framework results in a separate implementation of adapters
    but the port interfaces remain the same. Changing technology or a protocol is
    easy by swapping an implementation of the same interface.
  prefs: []
  type: TYPE_NORMAL
- en: FCIS uses the imperative shell layer to handle all the interactions with the
    external world. Any change in technology or protocol requires a change only in
    the imperative shell layer. With the high-level reuse of small functions, only
    a minor change is required to adapt to a new technology.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern allows engineers to implement a new adapter if it needs
    to integrate with a new remote system. If it needs to adapt to a new communication
    protocol, it is required to implement a new adapter and new Action, but there
    is no need to update the current code.
  prefs: []
  type: TYPE_NORMAL
- en: When to use which architectural style
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Clean Architecture, the hexagonal architecture, and FCIS share a great deal
    of similarities that engineers may find hard to choose for their applications.
    The layers of these three architectural styles can be approximately mapped as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Clean Architecture** | **Hexagonal Architecture** | **FCIS** |'
  prefs: []
  type: TYPE_TB
- en: '| **Entities** | Shared / Common libs | Shared / Common libs |'
  prefs: []
  type: TYPE_TB
- en: '| **Use Case** | Core / Domain / Port | Core |'
  prefs: []
  type: TYPE_TB
- en: '| **Interface Adapters** | Adapters | Shell |'
  prefs: []
  type: TYPE_TB
- en: '| **Frameworks** **and Drivers** | Adapters | Shell |'
  prefs: []
  type: TYPE_TB
- en: Table 7.1 – Approximate mapping among the three architectural styles
  prefs: []
  type: TYPE_NORMAL
- en: 'If we accept the opinion that the three styles can be loosely mapped, then
    the choice would become convention among engineers. The following are some opinions
    for reference but they are not strict rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Engineers with more functional programming experience would prefer FCIS.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clean Architecture provides better support to monolithic applications or systems
    with a big source repository. Having said that, Clean Architecture can absolutely
    support smaller repositories or microservices.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The hexagonal architecture fits microservice applications in terms of scope
    and scale.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are also a lot of rooms to create a hybrid style. For instance, an application
    using the hexagonal architecture can borrow the concepts of FCIS, so all ports
    and adapters are basically functions using the Kotlin operator overload features:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '`ContractPersist` is a type alias we used in FCIS, and we can define a class
    that implements the type alias interface and provides the `invoke` function with
    operator override. So, in practice, callers can skip the `invoke` keyword and
    treat it as a function, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: So, this concept can be extended to port interfaces, where they are only type
    aliases or interfaces with one function only.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern is an integration pattern that solves a different problem
    than the other three styles covered in this chapter. The Connect pattern can be
    used when there is a need to perform the same action in a business sense using
    external systems, but we want to decouple the technical integration details from
    the business logic.
  prefs: []
  type: TYPE_NORMAL
- en: In relation to the anemic domain model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **anemic domain model** (**ADM**) is a controversial architectural style
    that some people classify as an anti-pattern, while others find it useful in certain
    circumstances. In the ADM, the core or Use Cases layer has mainly data structures
    and little to zero business behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: The in-depth discussion on ADM is beyond the scope of this chapter, however,
    if a team has chosen to use ADM, then it is not advisable to combine it with Clean
    Architecture, the hexagonal architecture, or FCIS.
  prefs: []
  type: TYPE_NORMAL
- en: The main reason is that these architectures are designed to have business behaviors
    kept in the core or Use Cases layer; in other words, they are designed to work
    with the **rich domain model** (**RDM**) only. The application does not get any
    benefit from adopting the layers from Clean Architecture, the hexagonal architecture,
    or FCIS covered in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of ADM
  prefs: []
  type: TYPE_NORMAL
- en: Although ADM may be seen as an anti-pattern to some people, the lack of business
    behaviors may mean the application’s goals are data processing and infrastructure
    plumbing only. For example, an ADM application may be responsible for ingesting
    a large file, splitting the data in the file into chunks, and processing each
    chunk in parallel. The application focuses on data manipulation and scalability,
    meanwhile, the processed data is read by other downstream applications that contain
    actual business behaviors related to the data. Another example could be an application
    that consumes the headers of external messages and forwards these messages to
    their corresponding internal topics for further processing.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing source code as layers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two popular choices for organizing source code as layers. In Kotlin,
    the first approach is to put files into their belonging packages as layers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the real-life example we used, we could have the following packages in each
    architectural style:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Clean Architecture**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Hexagonal architecture**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**FCIS**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Enforcing the layered architecture, where only the outer layer can use the inner
    layer and not the other way round, can easily be done using test cases and includes
    passing them as a part of a successful build.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an example of a test case that enforces the FCIS layer dependency,
    using **ArchUnit** as the test driver:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The second approach is the use of a source code module within a build framework,
    such as **Gradle** or **Maven**. We create multi-module projects for an application,
    and the outer modules declare dependencies on inner modules.
  prefs: []
  type: TYPE_NORMAL
- en: For example, the imperative shell of the Negotiation Service can have explicit
    dependencies declared in the Gradle Kotlin script of the imperative shell module.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that this approach is more heavy-weighted than the package
    approach as it creates actual artifacts of inner layers.
  prefs: []
  type: TYPE_NORMAL
- en: The Connect pattern, however, is a modular but not layered architecture, so
    there is no need to enforce layer dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we discussed three architectural styles that aim to solve
    the same issues in traditional architectures where business logic and technology
    choices are tightly coupled. These three architectures were covered in depth:
    Clean Architecture, hexagonal architecture, and FCIS. We also discussed the Connect
    pattern, which focuses on breaking down large remote interfaces for integrating
    with remote systems.'
  prefs: []
  type: TYPE_NORMAL
- en: We illustrated each architectural style using our real-life example and how
    each style is implemented in code.
  prefs: []
  type: TYPE_NORMAL
- en: We also compared the four architecture styles in terms of how they tackle the
    issues in traditional architecture. We briefly covered how code can be organized
    in a repository under layered architectures.
  prefs: []
  type: TYPE_NORMAL
- en: We mentioned that the core in the hexagonal architecture is sometimes named
    the *domain*. However, the term “domain” itself is worth a lengthy discussion.
    In the next chapter, we are going to cover the concepts surrounding the domain,
    with one common theme – **domain-driven** **development** (**DDD**).
  prefs: []
  type: TYPE_NORMAL
