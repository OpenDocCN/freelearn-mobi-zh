- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Modular and Layered Architectures
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模块化和分层架构
- en: The previous chapters have repeatedly mentioned the importance of appropriate
    modularization of the system and addressing concerns separately. In this chapter,
    we delve into four prominent architectural patterns that offer their approaches
    to separate concerns in layers, modularize code, and set up clean boundaries among
    modules.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 前几章反复提到了适当模块化系统以及单独处理关注点的重要性。在本章中，我们将深入研究四种突出的架构模式，这些模式提供了在层次中分离关注点、模块化代码以及在模块之间设置清洁边界的途径。
- en: All these patterns will be illustrated with the same real-life example to highlight
    the similarities and differences of these patterns.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些模式都将使用相同的真实生活示例来突出这些模式的相似性和差异性。
- en: By understanding these patterns with code examples in Kotlin, engineers can
    make informed choices to create loosely coupling and highly cohesive modules that
    are testable, flexible, and maintainable.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在Kotlin中使用代码示例理解这些模式，工程师可以做出明智的选择，创建松散耦合且高度内聚的模块，这些模块是可测试的、灵活的且可维护的。
- en: 'The following architectural patterns will be covered:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 以下将介绍以下架构模式：
- en: Clean Architecture
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构
- en: The hexagonal architecture
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构
- en: '**Functional core, imperative** **shell** (**FCIS**)'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能核心，命令** **壳** （**FCIS**）'
- en: The Connect pattern
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接模式
- en: At the end, these patterns will be briefly compared with one another. We will
    also explore the possibility of taking elements from each pattern to create a
    hybrid pattern to meet the requirements.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将简要比较这些模式。我们还将探讨从每个模式中提取元素以创建混合模式以满足需求的可能性。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7%0D)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章使用的代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-7%0D)
- en: Clean Architecture
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 清洁架构
- en: '**Clean Architecture** is an architectural pattern that advocates organizing
    a software system into distinct layers, each with its own responsibilities and
    dependencies.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**清洁架构**是一种架构模式，主张将软件系统组织成具有各自责任和依赖的独立层。'
- en: 'The term Clean Architecture was introduced by Robert Martin (known as *Uncle
    Bob*) in his book titled *Clean Architecture: A Craftsman’s Guide to Software
    Structure and Design*, published in 2017\. The foundation of this approach is
    built upon a few earlier architectural patterns:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '术语“清洁架构”由罗伯特·马丁（也称为“Uncle Bob”）在他的2017年出版的书籍《Clean Architecture: A Craftsman’s
    Guide to Software Structure and Design》中引入。这种方法的基础建立在几个较早的架构模式之上：'
- en: '**The hexagonal architecture** (also known as **ports and adapters**) by Alistair
    Cockburn'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**六边形架构** （也称为**端口和适配器**）由Alistair Cockburn提出'
- en: '**Onion Architecture** by Jeffrey Palermo'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**洋葱架构**由Jeffrey Palermo提出'
- en: '**Screaming Architecture** by Robert Martin'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**罗伯特·马丁的尖叫架构**'
- en: '**Data, context, and interaction** (**DCI**) by James Coplien and Trygve Reenskaug'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据、上下文和交互** （**DCI**）由James Coplien和Trygve Reenskaug提出'
- en: '**Boundary-control-entity** (**BCE**) by Ivar Jacobson'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**边界控制实体** （**BCE**）由Ivar Jacobson提出'
- en: Clean Architecture dissects a software system by numerous layers, where each
    layer is wrapped one on top of the other, like an onion. The **Dependency Rule**
    of Clean Architecture states that the outer layers always depend on the inner
    layers.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构通过多个层次剖析软件系统，其中每个层次都像洋葱一样一层层包裹，**依赖规则**指出清洁架构的外层始终依赖于内层。
- en: '![Figure 7.1 – Clean Architecture](img/B21737_07_1.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 清洁架构](img/B21737_07_1.jpg)'
- en: Figure 7.1 – Clean Architecture
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 清洁架构
- en: Due to the Dependency Rule, any change in the outer layer does not affect the
    inner layer. On the contrary, any change in the inner layer may affect the outer
    layer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于依赖规则，外层任何变化都不会影响内层。相反，内层任何变化都可能影响外层。
- en: Let us go through the layer from the innermost to the outermost, demonstrated
    by the real-life example we use throughout previous chapters—households in a village
    exchanging services with each other.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照从内层到外层的顺序，通过我们在前几章中使用的真实生活示例——村庄家庭之间互相提供服务——来演示这些层次。
- en: Entities
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实体
- en: The **Entities layer** is the innermost layer, which depends on no other layer.
    This layer is designed to encapsulate business rules shared among applications.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**实体层**是内层最深的层，不依赖于其他任何层。这一层的设计是为了封装应用程序之间共享的业务规则。'
- en: It contains mostly data structures and functions only. It rarely depends on
    external libraries. The only libraries it depends on are most likely those that
    provide specialized data structures. This layer is also the least likely to change.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它主要包含数据结构和函数。它很少依赖于外部库。它所依赖的库很可能是那些提供专用数据结构的库。这一层也最不可能发生变化。
- en: In our real-life example, there are a few candidates suitable to be hosted in
    the Entities layer. `Household`, `Contract`, `Service`, and subclasses of `Service`
    as Kotlin data classes belong to the Entities layer. Certain rules and policies
    can also reside in the Entities layer. Here are a few example rules.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际例子中，有几个候选者适合托管在实体层中。`Household`、`Contract`、`Service` 以及 `Service` 的子类作为
    Kotlin 数据类属于实体层。某些规则和政策也可以存在于实体层中。以下是一些示例规则。
- en: Rule 1 – Household name must not be null and must have at least one member
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则 1 – 家庭名称不能为空且必须至少有一个成员
- en: 'This rule is enforced by the Kotlin non-null field syntax in data classes and
    the validation within the `init` function:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则通过数据类中的 Kotlin 非空字段语法和在 `init` 函数中的验证强制执行：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Rule 2 – Contract must be in one of the specified states
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则 2 – 合同必须在指定的状态之一
- en: 'This rule is enforced by the Kotlin enumeration feature:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则通过 Kotlin 枚举功能强制执行：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Rule 3 – a Contract consists of two Household objects and a state
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 规则 3 – 合同由两个家庭对象和一个状态组成
- en: 'This rule is enforced by Kotlin data classes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此规则通过 Kotlin 数据类强制执行：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: These classes are Pure Kotlin and can be shared among the four services we defined
    earlier in [*Chapter 6*](B21737_06.xhtml#_idTextAnchor212), namely *Household
    Service*, *Contract Service*, and *Notification Service*. Arguably, Household
    Service does not need a `Contract` class, and this may be a trade-off for most
    services to share entity classes but not all.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类是纯 Kotlin 编写的，可以在我们之前在[*第 6 章*](B21737_06.xhtml#_idTextAnchor212)中定义的四个服务之间共享，即
    *家庭服务*、*合同服务*和*通知服务*。可以说，家庭服务不需要 `Contract` 类，这可能是在大多数服务共享实体类但不是所有服务之间的一种权衡。
- en: Use Cases
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用例
- en: The **Use Cases layer** is one layer above the Entities layer. It is designed
    to encapsulate business rules within an application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**用例层**位于实体层之上。它旨在封装应用内的业务规则。'
- en: It contains use cases that make use of the data structures and functions in
    the Entities layer. Any change in this layer should not affect the Entities layer.
    This layer should also remain neutral to choices of frameworks and technologies,
    such as databases and messaging.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含使用实体层数据结构和函数的用例。此层的任何更改都不应影响实体层。此层还应保持对框架和技术选择的中立性，例如数据库和消息传递。
- en: 'In our real-life example, we have a use case of a household drafting a contract
    with another household, using the Negotiation Service:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际例子中，我们有一个用例，即一个家庭使用协商服务与另一个家庭草拟合同：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `draftContract` function validates that the two households are not the same.
    If everything looks good, it creates a contract with both households and their
    services to be provided. In addition, it set the contract state to `DRAFTED`.
    This `draftContract` function in the Use Cases layer makes use of the `Household`,
    `Party`, `ContractState`, and `Contract` classes from the Entities layer.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`draftContract` 函数验证两个家庭不是同一个。如果一切看起来都很好，它将创建一个包含两个家庭及其提供的服务合同的合同。此外，它将合同状态设置为
    `DRAFTED`。此用例层的 `draftContract` 函数使用了实体层中的 `Household`、`Party`、`ContractState`
    和 `Contract` 类。'
- en: There could be a bit of fluidity between the Entities layer and the Use Cases
    layer. If one feature in Entities is considered only relevant to one application,
    it can be moved to the Use Cases layer. Similarly, if there are duplicated logics
    in the Use Cases layer in different applications, they can be extracted into the
    Entities layer.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 实体层和用例层之间可能存在一定的灵活性。如果实体层中的一个特性被认为仅与一个应用相关，则它可以移动到用例层。同样，如果不同应用中的用例层存在重复的逻辑，则可以将这些逻辑提取到实体层。
- en: Interface Adapters
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口适配器
- en: The Entities and Use Cases layers are considered internal models, where data
    structures are not exposed outside of the application. The **Interface Adapters
    layer** serves as the translation between the internal and the external models.
    Typical examples of external models are relational database tables, message payloads,
    HTTP request and response payloads, file formats, and visual representation in
    the **graphical user** **interface** (**GUI**).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 实体和用例层被视为内部模型，其中数据结构不会暴露在应用程序之外。**接口适配器层**充当内部模型和外部模型之间的翻译。外部模型的典型例子包括关系数据库表、消息负载、HTTP
    请求和响应负载、文件格式以及**图形用户界面**（**GUI**）中的视觉表示。
- en: 'We already have a few examples of where the code should stay in the Interface
    Adapters layer:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经有一些例子说明代码应该保留在接口适配器层：
- en: The peer-to-peer architectures covered in [*Chapter 4*](B21737_04.xhtml#_idTextAnchor102)
    have illustrated the example code of conversion between a `Contract` object and
    a binary payload used for **User Datagram Protocol** (**UDP**) transmission.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第 4 章*](B21737_04.xhtml#_idTextAnchor102)中介绍的点对点架构展示了在`Contract`对象和用于**用户数据报协议**（**UDP**）传输的二进制负载之间的转换示例代码。
- en: In the same chapter, there is a similar example, but the conversion is between
    a `Contract` object and a **JavaScript Object Notation** (**JSON**) payload that
    is defined by **OpenAPI** specifications, under the client-server architecture.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在同一章节中，有一个类似的例子，但转换是在一个`Contract`对象和由**OpenAPI**规范定义的**JavaScript 对象表示法**（**JSON**）负载之间进行的，在客户端-服务器架构下。
- en: The three frontend architectural styles covered in [*Chapter 5*](B21737_05.xhtml#_idTextAnchor125),
    MVC, MVP, and MVVM, would have the corresponding code in this layer, as they transform
    internal models to the view that is rendered as GUI.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[*第 5 章*](B21737_05.xhtml#_idTextAnchor125)中介绍的三个前端架构风格，MVC、MVP 和 MVVM，在这个层中会有相应的代码，因为它们将内部模型转换为作为
    GUI 渲染的视图。
- en: If the application uses query languages, such as SQL, for relational databases,
    they should also stay in the Interface Adapters layer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果应用程序使用查询语言，如 SQL，用于关系数据库，它们也应该保留在接口适配器层。
- en: These external models and their corresponding conversion should not leak into
    other layers. The layer should not contain business logic either. The concern
    of internal models is separated from layers outside of the Interface Adapters
    layer, and the concern of external models is separated from layers inside of the
    Interface Adapters layer.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这些外部模型及其相应的转换不应泄漏到其他层。该层也不应包含业务逻辑。内部模型关注的问题与接口适配器层之外的其他层分离，外部模型关注的问题与接口适配器层之内的其他层分离。
- en: Frameworks and Drivers
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架和驱动器
- en: The Frameworks and Drivers layer is one layer outside of the Interface Adapters
    layer. This is where external frameworks are added to make it an application.
    Typical examples are HTTP endpoint routing configurations, database connection
    details, Kubernetes configurations, and dependency management. Quite often, this
    layer contains configuration files more than source code.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架和驱动器层**位于接口适配器层之外的一层。这是添加外部框架以使其成为应用程序的地方。典型例子包括 HTTP 端点路由配置、数据库连接细节、Kubernetes
    配置和依赖关系管理。这个层通常包含比源代码更多的配置文件。'
- en: This layer should never contain business use cases. It does not know any internal
    models and therefore no conversion from external models. This layer focuses on
    supporting configurations that turn code into an application executable in a runtime.
    It should address only non-functional requirements, such as startup time, or redundancy.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这个层永远不应该包含业务用例。它不知道任何内部模型，因此没有从外部模型转换。这个层专注于支持将代码转换为在运行时可以执行的应用程序的可执行配置。它应该只解决非功能性需求，例如启动时间或冗余。
- en: An example use case with Clean Architecture
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个使用 Clean 架构的示例用例
- en: Let us take a use case as an example of how different layers are used. A household
    is presented with a form to submit a draft contract, which is a web page in the
    Frameworks and Drivers layer.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以一个用例为例，说明如何使用不同的层。一个家庭被要求提交一个草案合同表单，这是一个位于框架和驱动器层的网页。
- en: 'The household then submits the form as JSON values and enters the controller
    in the Interface Adapters layer. The controller converts the form into a few internal
    objects, such as the objects of both `Household` and the services provided as
    strings. These internal objects are then passed to a `draftContract` function
    in the Use Cases layer:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，家庭将表单作为JSON值提交，并在接口适配器层中进入控制器。控制器将表单转换为几个内部对象，例如`Household`对象和作为字符串提供的服务。然后，这些内部对象被传递到用例层的`draftContract`函数：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The function creates a `Contract` object, which comes from the Entities layer.
    The function passes a `Contract` object to the presenter in the Interface Adapters
    layer. The presenter converts the `Contract` object into a JSON value to be rendered
    by the web page in the Frameworks and Drivers layer. The whole journey is illustrated
    in *Figure 7**.2*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数创建一个来自实体层的`Contract`对象。函数将`Contract`对象传递给接口适配器层中的展示者。展示者将`Contract`对象转换为JSON值，以便在框架和驱动层中的网页上渲染。整个过程在*图7.2*中展示。2*：
- en: '![Figure 7.2 – Example use case of Clean Architecture](img/B21737_07_2.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 清洁架构的示例用例](img/B21737_07_2.jpg)'
- en: Figure 7.2 – Example use case of Clean Architecture
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 清洁架构的示例用例
- en: Benefits of Clean Architecture
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清洁架构的好处
- en: The centerpiece of Clean Architecture is the Dependency Rule, not the four defined
    layers. With justifications, there could be variation in the layers, but the Dependency
    Rule should still apply.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构的核心是依赖规则，而不是四个定义的层。有合理的理由，层的结构可能会有所不同，但依赖规则仍然适用。
- en: 'Overall, concerns are separated in each layer in Clean Architecture. Each layer
    is dedicated to address specific concerns that no other layers do:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，在清洁架构中，每个层都关注于分离关注点。每个层都致力于解决特定的问题，而其他层不处理：
- en: '**Entities layer**: Functional requirements shared among applications'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**实体层**：应用程序之间共享的功能需求'
- en: '**Use Cases layer**: Functional requirements within an application'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**用例层**：应用程序内的功能需求'
- en: '**Interface Adapters layer**: Conversion between internal and external models'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**接口适配器层**：内部和外部模型之间的转换'
- en: '**Frameworks and Drivers layer**: Non-functional requirements'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和驱动层**：非功能需求'
- en: With a clear separation of concerns, we now have the Entities layer and the
    Use Cases layer independent of the choices of frameworks and technologies. They
    have no knowledge about the external world. They are testable without **user interfaces**
    (**UIs**), databases, messaging, files, or any external representation. It is
    computationally cheap to execute a test in these two layers, and therefore we
    can afford to run a comprehensive test suite without significant penalty on build
    times.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过清晰的关注点分离，我们现在有了实体层和用例层，它们独立于框架和技术的选择。它们对外部世界一无所知。它们可以在没有**用户界面**（**UIs**）、数据库、消息传递、文件或任何外部表示的情况下进行测试。在这两层执行测试的计算成本很低，因此我们可以承担运行一个全面的测试套件，而不会对构建时间产生重大影响。
- en: As the technology and framework choices only exist in the Interface Adapters
    layer and the Framework and Drivers layer, engineers can make changes to the framework
    in these layers, knowing that the functional logic in the Entities and Use Cases
    layers is intact. In addition, there could be test cases in these layers to ensure
    the correctness of internal-external model conversion, and the correctness of
    configuration of the framework in these layers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于技术和框架选择仅存在于接口适配器层和框架和驱动层，工程师可以在这些层中对框架进行更改，同时知道实体层和用例层中的功能逻辑保持完整。此外，这些层中可能有测试用例，以确保内部-外部模型转换的正确性，以及这些层中框架配置的正确性。
- en: Moreover, it enables a smooth transition of technology change. A new technology
    can be introduced and coexist with the old one. Engineers can commit incrementally
    to the changes required for the new technology. There can be toggles to switch
    between the new and old technology for testing purposes. Once the team is happy
    with the change, they can switch to the new technology and clean up the code afterward.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还使得技术变更的过渡变得顺畅。可以引入新技术，并与旧技术共存。工程师可以逐步对新技术所需的变更进行提交。可以设置开关，用于在测试目的之间切换新旧技术。一旦团队对变更感到满意，他们就可以切换到新技术，并在之后清理代码。
- en: The hexagonal architecture is one of the architectural patterns that Clean Architecture
    is built upon. We are going to explore the hexagonal architecture in the next
    section.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构是Clean Architecture构建在之上的几种架构模式之一。我们将在下一节中探讨六边形架构。
- en: Hexagonal architecture
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六边形架构
- en: The **hexagonal architecture**, also known as the **ports and adapters architecture**,
    aims to address the problem of coupling between the core business logic and external
    dependencies, such as databases, UIs, and external systems.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '**六边形架构**，也称为**端口和适配器架构**，旨在解决核心业务逻辑与外部依赖（如数据库、UI和外部系统）之间的耦合问题。'
- en: The hexagonal architecture was introduced by Alistair Cockburn in his paper,
    *Hexagonal Architecture*, published in 2005.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构是由Alistair Cockburn在他的论文《六边形架构》中引入的，该论文于2005年发表。
- en: The two fundamental concepts of this architectural style are **ports** and **adapters**.
    Ports define the interactions between the internal and the external worlds, and
    adapters provide the implementation details of these interactions.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构风格的两个基本概念是**端口**和**适配器**。端口定义了内部世界和外部世界之间的交互，适配器提供了这些交互的实现细节。
- en: The concept of hexagonal architecture is visualized in *Figure 7**.3* as a hexagon.
    It is worth noting that this architecture allows as many sides as possible, not
    limited to only six as the name *hexagon* suggests.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构的概念在*图7.3*中被可视化为一个六边形。值得注意的是，这种架构允许尽可能多的边，不仅限于名称*六边形*所暗示的六个边。
- en: '![Figure 7.3 – An example of the hexagonal architecture](img/B21737_07_3.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3 – 六边形架构的示例](img/B21737_07_3.jpg)'
- en: Figure 7.3 – An example of the hexagonal architecture
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 六边形架构的一个示例
- en: We will cover each element of the hexagonal architecture in the following sections.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的章节中介绍六边形架构的每个元素。
- en: The core
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心组件
- en: The core of the hexagonal architecture encapsulates the business logic of the
    application in a pure way, without involving any technology and framework. The
    core is often called “the Domain.” The only exception may be a library that provides
    the data structure needed to support the business logic. The core does not depend
    on any adapter implementation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构的核心以纯方式封装了应用程序的业务逻辑，不涉及任何技术和框架。核心通常被称为“领域”。唯一的例外可能是一个提供支持业务逻辑所需数据结构的库。核心不依赖于任何适配器实现。
- en: 'The core contains data structures and functions that represent pure business
    logic. Taking the same real-life example we have for households exchanging service,
    we should have these elements in the core:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 核心包含表示纯业务逻辑的数据结构和函数。以我们之前提到的家庭交换服务的现实生活例子为例，我们应该在核心中包含以下元素：
- en: '`HouseHold`, `Party`, and `Contract` data classes; the `ContractState` enum
    class'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HouseHold`、`Party`和`Contract`数据类；`ContractState`枚举类'
- en: '`draftContract` function'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draftContract`函数'
- en: Ports
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 端口
- en: '**Ports** are the interfaces describing what the application can do. There
    are two types of ports in the hexagonal architecture:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**端口**是描述应用程序能做什么的接口。在六边形架构中，有两种类型的端口：'
- en: '**Primary port**: Known as the driving port, this determines inputs required
    by the core to perform an operation'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要端口**：也称为驱动端口，它决定了核心执行操作所需的输入。'
- en: '**Secondary port**: Known as the driven port, this determines what outputs
    are produced by the core for the external world’s consumption'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**次要端口**：也称为驱动端口，它决定了核心为外部世界消费产生的输出。'
- en: The port interfaces should be defined by the needs of the core and not the external
    world. If we are writing a new application from scratch, we should start from
    the core and define port interfaces for what the core needs, even without any
    code in adapters.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 端口接口应由核心需求定义，而不是外部世界。如果我们从头开始编写一个新应用程序，我们应该从核心开始，定义核心需要的端口接口，即使适配器中没有任何代码。
- en: In addition to the code we have in the core, we need to define port interfaces
    for the external world to use the core and consume the result produced by the
    core.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在核心中的代码外，我们还需要为外部世界定义端口接口，以便使用核心并消费核心产生的结果。
- en: In the real-life example where a household intends to draft a contract, the
    core validates the request and produces a drafted contract. The core needs a repository
    to store the drafted contract.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，如果一个家庭打算起草一份合同，核心会验证请求并生成一份草拟的合同。核心需要一个存储库来存储草拟的合同。
- en: 'We need a primary port to allow a contract to be drafted. The `ContractService`
    interface is exposed for external usage, but the implementation of the interface
    stays in the core:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个主端口以允许草拟合同。`ContractService`接口对外公开，但其实现保持在核心中：
- en: '[PRE5]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need a secondary port to allow a draft contract to be persisted. The
    `ContractRepository` interface is implemented by adapters to provide the technical
    details of how a `Contract` object is saved:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要一个次要端口以允许草拟合同被持久化。`ContractRepository`接口由适配器实现，以提供如何保存`Contract`对象的详细技术信息：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The implementation of the primary port interface, `ContractService`, validates
    the draft contract and creates a `Contract` object with a `DRAFTED` state. Then,
    the `Contract` object is passed to `ContractRepository` to be saved:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 主端口接口`ContractService`的实现验证草拟合同，并创建一个具有`DRAFTED`状态的`Contract`对象。然后，将`Contract`对象传递给`ContractRepository`进行保存：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ContractServiceImpl` class is a part of the core logic and stays in the
    core. It is able to implement business behaviors without specifying how `Contract`
    is saved. In other words, the core focuses on business rules and is free of the
    concerns of the choice of technology and frameworks.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContractServiceImpl`类是核心逻辑的一部分，并保持在核心中。它能够实现业务行为，而无需指定如何保存`Contract`。换句话说，核心专注于业务规则，不受技术选择和框架的约束。'
- en: Adapters
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: Adapters are responsible for translating external models to the internal models,
    which are defined in the core.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器负责将外部模型转换为在核心中定义的内部模型。
- en: Adapters use the primary port as an entrance to the core and run business operations.
    An adapter is tied to at least one framework, and it has an external representation
    of the entities involved.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器使用主端口作为进入核心的入口并运行业务操作。一个适配器至少绑定到一个框架，并且它具有涉及实体的外部表示。
- en: 'In the real-life example, the adapter can be a `POST` endpoint to create a
    draft contract. The payload is a JSON value, represented by the `DraftContractRequest`
    class, which can be converted into a `Contract` object:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际示例中，适配器可以是创建草拟合同的`POST`端点。负载是一个由`DraftContractRequest`类表示的JSON值，它可以被转换成一个`Contract`对象：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Contract Service has locally cached `Household` objects, which can be looked
    up by household name from the `HouseholdRepository` repository:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 合同服务在本地缓存了`Household`对象，可以通过`HouseholdRepository`存储库从家庭名称进行查找：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function returns a `Household` object if the household of the given name
    is found. Otherwise, it returns a `null` value. The REST controller class, `ContractController`,
    is defined to accept HTTP requests to draft a contract. This controller uses Spring
    Boot as the framework to register URI mapping:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找到给定名称的家庭，则函数返回一个`Household`对象。否则，它返回一个`null`值。定义了REST控制器类`ContractController`以接受草拟合同的HTTP请求。此控制器使用Spring
    Boot作为框架来注册URI映射：
- en: '[PRE10]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The controller is injected with the `ContractService` primary port to enter
    the core and draft a contract. It is also injected with the `HouseholdRepository`
    secondary port to look up `Household` objects for validation.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器注入了`ContractService`主端口以进入核心并草拟合同。它还注入了`HouseholdRepository`次要端口以查找用于验证的`Household`对象。
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The controller defines a mapping of `POST /contracts/draft` that accepts JSON
    value as input and as output.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器定义了一个映射`POST /contracts/draft`，它接受JSON值作为输入和输出。
- en: '[PRE12]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The controller converts the `DraftContractRequest` request payload and validates
    that household names in the payload exist. If any household does not exist, a
    `404 (Not Found)` HTTP status is returned to the requester.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器将`DraftContractRequest`请求负载转换为JSON，并验证负载中的家庭名称是否存在。如果任何家庭不存在，则向请求者返回一个`404
    (Not Found)` HTTP 状态码。
- en: '[PRE13]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The controller invokes the `draftContract` function in the `ContractNegotiationService`
    primary port, which validates the request and persists the draft contract in the
    repository.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器调用`ContractNegotiationService`主端口中的`draftContract`函数，该函数验证请求并在存储库中持久化草拟合同。
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, the operation has finished, and the controller returns a `201 (Created)`
    HTTP status back to the requester with the details of the draft contract. The
    response payload is represented by the `ContractDto` class:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，操作已完成，控制器向请求者返回一个`201 (Created)` HTTP 状态码，并附带草拟合同的详细信息。响应负载由`ContractDto`类表示：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'There is a `toDto` function for the conversion from the internal model to the
    external model of the contract:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于合同从内部模型到外部模型的转换，存在一个`toDto`函数：
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The data was transformed and passed through the layers of the hexagonal architecture
    in this example, as demonstrated in *Figure 7**.4*:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，数据被转换并通过六角架构的层级传递，如*图7.4*所示：
- en: '![Figure 7.4 – Example use case of the hexagonal architecture](img/B21737_07_4.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4 – 六角架构的示例用例](img/B21737_07_4.jpg)'
- en: Figure 7.4 – Example use case of the hexagonal architecture
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 六角架构的示例用例
- en: The request payload as JSON value is validated in the `ContractController` adapter
    with the help of a `HouseholdRepository` secondary port. Then, the payload is
    converted to the `Household` objects defined in the core. The core runs through
    the business process and uses a `ContractRepository` secondary port to persist
    a valid draft `Contract` object. Then, the result is populated to the `ContractController`
    adapter. Finally, the adapter converts the `Contract` object to a response payload.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请求负载作为JSON值在`ContractController`适配器中通过`HouseholdRepository`二级端口进行验证。然后，负载被转换为核心中定义的`Household`对象。核心运行业务流程，并使用`ContractRepository`二级端口持久化一个有效的草稿`Contract`对象。然后，结果被填充到`ContractController`适配器中。最后，适配器将`Contract`对象转换为响应负载。
- en: Benefits of hexagonal architecture
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 六角架构的好处
- en: Separating source code in the layers of the hexagonal architecture certainly
    makes the code base more complicated. It does bring a few benefits by separating
    the source code between the core and the adapter.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在六角架构的层级中分离源代码确实会使代码库更加复杂。通过在核心和适配器之间分离源代码，它确实带来了一些好处。
- en: The core encapsulates pure business rules and the adapter contains all technology
    details. This separation makes it extremely easy to test the concerns of correctness
    and technology integration independently.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 核心封装了纯业务规则，而适配器包含所有技术细节。这种分离使得独立测试正确性和技术集成问题变得极其容易。
- en: The core contains a comprehensive test suite that ensures the business rules
    are enforced as intended, without involving any technology.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 核心部分包含一个全面的测试套件，确保业务规则按照预期执行，而不涉及任何技术。
- en: On the other hand, the adapter contains test cases that verify the configuration
    of the chosen technology and frameworks work as intended, without mixing business
    rules.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，适配器包含测试用例，以验证所选技术和框架的配置是否按预期工作，而不混合业务规则。
- en: An adapter is designed to be pulled and replaced by another adapter at any time.
    An adapter is specifically implemented for a chosen technology or framework, but
    the port has no knowledge about it. For example, if the request and response use
    messaging technology, such as queuing, then we can replace `ContractController`
    with a different adapter, such as `DraftContractRequestConsumer`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器被设计成可以在任何时候被拉出并替换为另一个适配器。适配器专门为选定的技术或框架实现，但端口对此一无所知。例如，如果请求和响应使用消息传递技术，如队列，那么我们可以用不同的适配器替换`ContractController`，例如`DraftContractRequestConsumer`。
- en: The implementation of the secondary port as an adapter can also be replaced
    if needed. For example, we could have an implementation of a memory cache or relational
    database of `HouseholdRepository`. They can coexist and we can use configuration
    to decide which one is used at runtime. Each adapter can be tested in isolation.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，也可以替换作为适配器的二级端口实现。例如，我们可以有一个`HouseholdRepository`的内存缓存或关系型数据库实现。它们可以共存，并且我们可以使用配置来决定在运行时使用哪一个。每个适配器都可以单独进行测试。
- en: This separation of concerns results in enabling engineers to conform to the
    **single responsibility principle** (**SRP**), in which the core has only one
    reason to change, and each adapter has only one reason to change.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关注点的分离使得工程师能够遵循**单一职责原则**（**SRP**），其中核心只有一个改变的理由，每个适配器也只有一个改变的理由。
- en: Coming next, we are going to cover an architecture pattern that aims to solve
    this similar challenge, but in the functional style.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍一种旨在解决类似挑战的架构模式，但以功能风格实现。
- en: Functional core, imperative shell
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能核心，命令式外壳
- en: '**FCIS** emerged as an architectural pattern over time in the functional programming
    community. It is a design principle that advocates separating the immutable core
    business logic from the mutable aspects, such as persistent storage or external
    system integration. It aligns and encourages functional programming principles
    with the use of stateless functions and immutable data structures.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**FCIS** 逐渐在函数式编程社区中成为了一种架构模式。它是一种设计原则，主张将不可变的核心业务逻辑与可变方面（如持久化存储或外部系统集成）分离。它将函数式编程原则与无状态函数和不可变数据结构的使用相结合。'
- en: Stateless functions are sometimes called pure functions. They can be executed
    without causing side effects, in other words, for a given input, the function
    always produces the same output. Immutable data structures never change their
    content.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无状态函数有时被称为纯函数。它们可以在不引起副作用的情况下执行，换句话说，对于给定的输入，函数总是产生相同的输出。不可变数据结构永远不会改变其内容。
- en: The FCIS principle has been influenced by various software development paradigms
    and architectural patterns. It shares similarities with the hexagonal architecture,
    which also promotes separating the core logic from the infrastructure concerns.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS 原则受到了各种软件开发范式和架构模式的影响。它与六边形架构相似，也促进了将核心逻辑与基础设施关注点分离。
- en: There are two major components in FCIS. The functional core contains stateless
    functions and immutable data structures that represent business logic and entities,
    respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS 有两个主要组成部分。功能核心包含代表业务逻辑和实体的无状态函数和不可变数据结构。
- en: The imperative shell, on the other hand, is the layer outside of the functional
    core that interacts with the external world, such as database operations, messaging,
    or UIs. This layer is responsible for executing the imperative and mutable operations
    required by the system.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，命令式外壳是功能核心之外与外部世界交互的层，例如数据库操作、消息传递或用户界面。这一层负责执行系统所需的命令式和可变操作。
- en: 'The FCIS architecture can be demonstrated in *Figure 7**.5*:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS 架构可以在 *图 7.5* 中展示：
- en: '![Figure 7.5 – FCIS](img/B21737_07_5.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.5 – FCIS](img/B21737_07_5.jpg)'
- en: Figure 7.5 – FCIS
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.5 – FCIS
- en: We are going to cover these two components of this architectural style here.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍这种架构风格的这两个组成部分。
- en: Functional core
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数核心
- en: The functional core focuses on the core business logic, which consists of stateless
    functions and immutable data structures only.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 函数核心专注于核心业务逻辑，仅包含无状态函数和不可变数据结构。
- en: 'Using the same real-life example we have for households exchanging service,
    we should have these elements in the core:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们为家庭交换服务提供的相同真实生活示例，核心中应该有这些元素：
- en: '`HouseHold`, `Party`, and `Contract` data classes and the `ContractState` enum
    class'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HouseHold`、`Party` 和 `Contract` 数据类以及 `ContractState` 枚举类'
- en: '`draftContract` function'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draftContract` 函数'
- en: All data classes are immutable, and all functions are stateless in our example.
    They are tested in isolation by simply verifying the output of the function given
    the input.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，所有数据类都是不可变的，所有函数都是无状态的。它们通过简单地验证给定输入的函数输出进行隔离测试。
- en: However, the `draftContract` function would need a tweak from the implementation
    shown in the example from the Clean Architecture section, because we need to build
    up higher-order functions with potential errors found along the way.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`draftContract` 函数需要从“清洁架构”部分示例中的实现进行微调，因为我们需要构建带有潜在错误的更高阶函数。
- en: 'To start with this approach, we need to define what errors we may encounter.
    We will start with defining the types of errors first:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始这种方法，我们需要定义我们可能遇到的错误。我们首先定义错误的类型：
- en: '[PRE17]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We also need a wrapper data class for the error itself:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要为错误本身提供一个包装数据类：
- en: '[PRE18]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to be able to communicate that functions can return an expected result,
    but there is also a chance an error occurred. This new implementation of `draftContract`
    uses the `Either` class from **Arrow** library to express this outcome:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要能够传达函数可以返回预期的结果，但同时也存在发生错误的可能性。这种新的 `draftContract` 实现使用了 **Arrow** 库中的
    `Either` 类来表示这种结果：
- en: Arrow
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow
- en: '`Option` and result types for error handling using `Either`. It also provides
    various functional programming patterns, such as functors, monads, and applicatives.
    Arrow aims to improve code readability, maintainability, and robustness by enabling
    developers to express computations in a functional style, making it easier to
    manage complex data flows and side effects in Kotlin applications.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `Either` 进行错误处理的 `Option` 和结果类型。它还提供了各种函数式编程模式，如函子、单子和应用。Arrow 通过允许开发者以函数式风格表达计算，旨在提高代码的可读性、可维护性和健壮性，使
    Kotlin 应用中的复杂数据流和副作用管理变得更加容易。
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `draftContract` function returns an `Either` object in which the left type
    parameter is always the potential error, and the right type parameter is always
    the expected result:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`draftContract` 函数返回一个 `Either` 对象，其中左侧类型参数始终是潜在的错误，右侧类型参数始终是预期结果：'
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The same validation ensures the contract does not have the same `Household`
    on both sides. However, instead of throwing an exception, the function returns
    the left side value, which is represented by the `Error` class just defined earlier
    on.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的验证确保合同在两侧没有相同的 `Household`。然而，而不是抛出异常，该函数返回左侧值，这由之前定义的 `Error` 类表示。
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If everything is fine, the function returns the right side value, which is the
    `Contract` object itself.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，函数返回右侧值，即 `Contract` 对象本身。
- en: Imperative shell
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令式壳
- en: The imperative shell handles the necessary interactions with the outside world,
    providing the necessary integration points and adaptors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 命令式壳处理与外部世界的必要交互，提供必要的集成点和适配器。
- en: In the real-life example, this includes the persistence of the `Contract` object
    and the REST endpoint controller that accepts HTTP `POST` requests to draft a
    contract.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际示例中，这包括 `Contract` 对象的持久化和接受 HTTP `POST` 请求以起草合同的 REST 端点控制器。
- en: 'Apart from the REST controller, there are two more imperative operations involved.
    The first one looks up a `Household` object by the name, and the second one persists
    a `Contract` object. We define them using `typealias` in this example:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 REST 控制器之外，还有两个涉及命令式操作。第一个是通过名称查找 `Household` 对象，第二个是持久化 `Contract` 对象。我们在这个示例中使用
    `typealias` 定义它们：
- en: '[PRE22]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In addition to these two functions defined, we also need a function to ensure
    the household mentioned in the request exists:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这两个定义的函数之外，我们还需要一个函数来确保请求中提到的家庭存在：
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `ensureHouseholdExist` function makes use of `HouseholdLookup` to check
    if the two households mentioned in the `DraftContractRequest` request exist. If
    not, the left side of `Either` will be returned to report the household not found
    error. If both households exist, the household records are returned for further
    processing.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`ensureHouseholdExist` 函数使用 `HouseholdLookup` 检查 `DraftContractRequest` 请求中提到的两个家庭是否存在。如果不存在，`Either`
    的左侧将返回以报告家庭未找到错误。如果两个家庭都存在，将返回家庭记录以进行进一步处理。'
- en: 'With this function defined, we can now inject them into the imperative controller
    implementation:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了这个函数后，我们现在可以将它们注入到命令式控制器实现中：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `draft` function now takes full advantage of the `Either` class by collapsing
    the right type parameter with the `flatMap` function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`draft` 函数现在充分利用了 `Either` 类，通过 `flatMap` 函数将右侧类型参数折叠：'
- en: '[PRE25]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `flatMap` functions chain the results of `Either` to return either the first
    error on the left or the final expected result on the right. The preceding code
    firstly checks and ensures that both households mentioned in the request exist.
    The next chained call gets the household records from the `ensureHouseholdExist`
    function and it passes all parameters to the `draftContract` function to validate
    business rules and return a `Contract` object of the `DRAFTED` state.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 函数将 `Either` 的结果链式连接，返回左侧的第一个错误或右侧的最终预期结果。前面的代码首先检查并确保请求中提到的两个家庭都存在。接下来的链式调用从
    `ensureHouseholdExist` 函数获取家庭记录，并将所有参数传递给 `draftContract` 函数以验证业务规则并返回一个 `DRAFTED`
    状态的 `Contract` 对象。'
- en: The next chained call receives the `Contract` object of the `DRAFTED` state
    and calls the `ContractPersist` function to persist this contract.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个链式调用接收 `DRAFTED` 状态的 `Contract` 对象，并调用 `ContractPersist` 函数以持久化此合同。
- en: After the `Contract` record is persisted, it is transformed into a **data transfer
    object** (**DTO**) that will be exposed and returned to the HTTP client that initiated
    the request.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Contract` 记录持久化后，它被转换为一个 **数据传输对象**（**DTO**），该对象将被公开并返回给发起请求的 HTTP 客户端。
- en: At the last part of the chained call, the `fold` function is invoked to differentiate
    the response back to the HTTP client. The success result as a `Contract` object,
    the right side, is converted to the `ContractDto` response payload by the `toDto`
    function. A `201 (Created)` HTTP status is returned together with the response
    payload.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在链式调用的最后部分，调用`fold`函数来将响应区分回HTTP客户端。成功的结果作为一个`Contract`对象，右侧，通过`toDto`函数被转换为`ContractDto`响应负载。返回一个包含响应负载的`201
    (Created)` HTTP状态码。
- en: 'All the possible errors are collapsed onto the left side, and they are mapped
    to the HTTP status code, as shown here:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 所有可能的错误都被折叠到左侧，并且它们被映射到HTTP状态码，如下所示：
- en: '[PRE26]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Benefits of functional core, imperative shell
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数式核心和命令式壳层的优势
- en: FCIS separates the code into two parts.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS将代码分为两部分。
- en: The functional core is a purely functional area that only contains stateless
    functions and immutable data structures, which can be easily tested and reasoned
    about. There is no state management and no side effects. Each test is about verifying
    the output of the function given the input values.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式核心是一个纯函数式区域，只包含无状态函数和不可变数据结构，这些可以很容易地进行测试和推理。没有状态管理和副作用。每个测试都是关于验证给定输入值的功能输出。
- en: The functional core is also free of technology choice. It makes the functional
    core focus on only business concerns. There is no need to change the code if we
    decide to use other technologies to receive requests and produce responses. This
    makes the core logic reliable, adaptable, and maintainable.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式核心也是技术选择自由的。它使函数式核心只关注业务问题。如果我们决定使用其他技术来接收请求和生成响应，则无需更改代码。这使得核心逻辑可靠、可适应和可维护。
- en: The only exception, as we shown in the example, is the use of the `Either` class
    brought from the Arrow library, to express that an operation can fail and return
    a different object.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的例外，正如我们在示例中所展示的，是使用从Arrow库中引入的`Either`类，以表达一个操作可能失败并返回不同对象的情况。
- en: This encourages engineers to organize the code to conform to the SRP in which
    each function has only one reason to change. We still need to organize our functions
    with the best practices to conform to SRP though. For example, each function needs
    to be small, reusable, stateless, and with one purpose only.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这鼓励工程师组织代码以符合SRP，其中每个函数只有一个改变的理由。尽管如此，我们仍然需要按照最佳实践组织我们的函数以符合SRP。例如，每个函数需要小、可重用、无状态，并且只有一个目的。
- en: Separating the functional core from the imperative shell allows for easier evolution
    of the core logic without being tightly coupled to the external systems or implementation
    details. It also allows for greater flexibility and maintainability, leading to
    more robust and flexible software architectures.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数式核心与命令式壳层分离，可以更容易地进化核心逻辑，而无需与外部系统或实现细节紧密耦合。这也允许有更大的灵活性和可维护性，从而产生更健壮和灵活的软件架构。
- en: The next architectural pattern we are going to cover focuses on adapting to
    a remote API call.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的下一个架构模式侧重于适应远程API调用。
- en: The Connect pattern
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接模式
- en: The Connect pattern was first introduced by David Denton in his technical article,
    *Smash your Adapter Monolith with the Connect pattern*, on the internet in 2011.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式最初由David Denton在他的技术文章《Smash your Adapter Monolith with the Connect pattern》中提出，该文章于2011年发布在互联网上。
- en: This pattern, however, has a different focus from the three architectural patterns
    previously discussed. It is specifically targeted at remote system integration.
    It aims to provide a testable and extensible approach to encapsulate remote API
    interactions.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个模式与之前讨论的三个架构模式有不同的重点。它专门针对远程系统集成。它的目标是提供一个可测试和可扩展的方法来封装远程API交互。
- en: 'The concept of the Connect pattern is illustrated in *Figure 7**.6*:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式的概念在*图7.6*中得到了说明：
- en: '![Figure 7.6 – The Connect pattern](img/B21737_07_6.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6 – 连接模式](img/B21737_07_6.jpg)'
- en: Figure 7.6 – The Connect pattern
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 连接模式
- en: An integration operation is abstracted as an Action. It understands how to generate
    a request and how to transform a response into an internal object. However, it
    does not know the connection details to the external system.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 集成操作被抽象为Action。它理解如何生成请求以及如何将响应转换为一个内部对象。然而，它不知道与外部系统的连接细节。
- en: An adapter, on the other hand, is crafted to adapt to a specific system. It
    can establish a connection with an external system while delegating the actual
    request-response exchange to an Action.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，适配器是为了适应特定的系统而精心制作的。它可以在将实际请求-响应交换委托给操作的同时，与外部系统建立连接。
- en: Action
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作
- en: An **Action** is responsible for transforming requests from internal to external
    format and transforming responses from external to internal format. Using the
    same real-life example of the villagers exchanging services, there are some supporting
    functions that we need from the Household Service, and one of them is as simple
    as getting a household by the given household name.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作**负责将请求从内部格式转换为外部格式，并将响应从外部格式转换为内部格式。使用相同的现实生活例子，即村民交换服务，我们需要从家庭服务中获取一些支持函数，其中之一就是通过给定的家庭名称获取家庭，这个操作非常简单。'
- en: 'The Action related to communicating with the Household Service is defined here:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 与家庭服务通信相关的操作定义如下：
- en: '[PRE27]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There are only two simple functions. The `toRequest` function generates a request
    in an external format to communicate with Household Service. The `fromResponse`
    function transforms a response from Household Service to an internal object. The
    type variable, `R`, is specific to the given Action and can vary.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个简单的函数。`toRequest`函数生成一个外部格式请求，用于与家庭服务通信。`fromResponse`函数将家庭服务响应转换为内部对象。类型变量`R`对于给定的操作是特定的，并且可能不同。
- en: 'The Action to get a household name by the given household name is defined here:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过给定的家庭名称获得家庭名称的操作定义如下：
- en: '[PRE28]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `GetHousehold` class encapsulates the details needed to generate the HTTP
    request to Household Service. The response from Household Service is transformed
    to an internal data class, `Household`, using `Household` data class is defined
    here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetHousehold`类封装了生成发送到家庭服务的HTTP请求所需的详细信息。家庭服务响应通过使用`Household`数据类转换为内部数据类，`Household`数据类在此定义：'
- en: '[PRE29]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: So far, there are no connection details to Household Service, but this will
    be covered by the adapter.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，还没有与家庭服务的连接细节，但适配器将涵盖这一点。
- en: Adapter
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器
- en: 'The adapter class provides a way to abstract away the connectivity details
    and mechanism to an external system. The `Household` API is defined here:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器类提供了一种将连接细节和机制抽象到外部系统的方式。`Household` API在此定义：
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `HouseholdApi` interface acts as a wrapper and handle for the invocation
    of the specific action. The companion object is defined as a placeholder for extension
    functions, which will be covered later. An HTTP implementation that communicates
    with a local Household Service is implemented as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`HouseholdApi`接口充当特定操作的包装和处理程序。伴随对象被定义为扩展函数的占位符，稍后将会介绍。与本地家庭服务通信的HTTP实现如下：'
- en: '[PRE31]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This `Household` API implementation is an anonymous inner class that sets the
    host of Household Service to localhost and sets the authorization bearer token.
    It assumes that all `HouseholdAction` would use the same connectivity settings.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`Household` API实现是一个匿名内部类，将家庭服务的宿主设置为localhost，并设置授权令牌。它假定所有`HouseholdAction`都会使用相同的连接设置。
- en: 'Moreover, an extension function is defined to make the usage code tidier:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，定义了一个扩展函数来使使用代码更整洁：
- en: '[PRE32]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The code usage example is going to be covered in the following section.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 代码使用示例将在下一节中介绍。
- en: Usage
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用
- en: 'With the Action and the adapter set up, the usage of the Household Service
    to get a household by the given name only requires three lines of code:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好操作和适配器后，使用家庭服务通过给定的名称获取家庭只需要三行代码：
- en: '[PRE33]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The variable app is `HttpHandler`, which defines URI routings. Only a `GET`
    endpoint is defined in this example, together with a canned response back to the
    HTTP client.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 变量app是`HttpHandler`，它定义了URI路由。在这个例子中，只定义了一个`GET`端点，以及一个返回给HTTP客户端的预定义响应。
- en: In the `main` function, an HTTP client implementation is created to be fed to
    create an HTTP implementation of `HouseholdApi`. Then, the extension function
    is used to get a household with the name *Whittington*. Internally, a `GetHousehold`
    Action is created and passed into `HouseholdApi` and kicks off the API communication.
    However, from a usage point of view, an object of the internal `Household` data
    class is returned.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`main`函数中，创建了一个HTTP客户端实现，用于创建`HouseholdApi`的HTTP实现。然后，使用扩展函数获取名为*Whittington*的家庭。内部，创建了一个`GetHousehold`操作并将其传递给`HouseholdApi`，启动API通信。然而，从使用角度来看，返回的是内部`Household`数据类的对象。
- en: Test cases
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试用例
- en: 'One of the strengths of the Connect pattern is better testability. Each Action
    and API with the Household Service can be tested individually. This is the test
    case of getting a household from the Household API:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 模式的一个优势是更好的可测试性。每个 Action 和与 Household Service 一起的 API 都可以单独测试。这是从 Household
    API 获取家庭的测试用例：
- en: '[PRE34]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: When there are more Actions, there will be more test cases, but each test case
    is isolated. In other words, the Actions and test cases scale without creating
    an interface with many functions.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 当有更多 Action 时，会有更多的测试用例，但每个测试用例都是隔离的。换句话说，Action 和测试用例的扩展不会创建具有许多功能的接口。
- en: Benefits
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优势
- en: The major benefits of the Connect pattern are extensibility and testability.
    Given it is common to use multiple APIs of an external system, engineers often
    end up with one interface for the external system with many functions. With the
    Connect pattern, each API call is represented by an Action and thus breaks down
    the big interface into smaller pieces.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 模式的重大优势在于可扩展性和可测试性。考虑到通常需要使用外部系统的多个 API，工程师们往往最终会得到一个具有许多功能的单一外部系统接口。使用
    Connect 模式，每个 API 调用都由一个 Action 表示，从而将大接口分解成更小的部分。
- en: This pattern naturally conforms to the SRP as an Action represents only one
    API call. Moreover, each Action has its own dedicated test case, which is a lot
    simpler than testing an interface with many functions.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式自然符合 SRP（单一职责原则），因为 Action 只代表一个 API 调用。此外，每个 Action 都有自己的专用测试用例，这比测试具有许多功能的接口要简单得多。
- en: The adapter has abstracted away the concern of connectivity details to a remote
    system, so Action classes can focus on the message formats and interactions.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器将连接到远程系统的细节关注点抽象化，因此 Action 类可以专注于消息格式和交互。
- en: The use of Kotlin extension functions makes the code usage fluent, tidy, and
    small. A lot of details are hidden and encapsulated within the Action and adapter
    classes.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 扩展函数的使用使代码使用更加流畅、整洁和简洁。许多细节都被隐藏并封装在 Action 和适配器类中。
- en: Although the example uses HTTP and Kotlin, the Connect pattern itself is not
    restricted to them.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管示例使用了 HTTP 和 Kotlin，但 Connect 模式本身并不局限于它们。
- en: This pattern is particularly useful in the usage of communicating with a monolithic
    application that exposes a lot of functions in one interface.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式在用于与暴露单个接口中许多功能的单体应用程序通信时特别有用。
- en: Coming next, we are going to briefly compare these architectural styles.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要比较这些架构风格。
- en: Comparisons of architectural styles
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构风格比较
- en: The first three architectural styles we discussed in this chapter have a great
    deal of similarities. They all aim to solve the same issues; the variations are
    in the approaches.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中讨论的前三种架构风格有许多相似之处。它们都旨在解决相同的问题；差异在于方法。
- en: Meanwhile, the Connect pattern focuses on the testability and extensibility
    of remote system interactions.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，Connect 模式专注于远程系统交互的可测试性和可扩展性。
- en: Dependency on frameworks and technologies
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖框架和技术
- en: Traditional architectures often tightly couple the business logic with specific
    frameworks, libraries, or technologies. This makes it difficult to switch or upgrade
    these components without making widespread changes throughout the code base.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 传统架构通常将业务逻辑与特定的框架、库或技术紧密耦合。这使得在没有对代码库进行广泛更改的情况下切换或升级这些组件变得困难。
- en: Clean Architecture proposes the Entities layer for enterprise business rules
    and the Use Cases layer for application-specific business rules. Both are neutral
    to choices of frameworks and technologies.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构提出实体层用于企业业务规则，用例层用于特定于应用的业务规则。两者都对框架和技术选择保持中立。
- en: The hexagonal architecture proposes the core as the centerpiece for business
    logic, also free of the choices of frameworks and technologies.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 六角架构提出将核心作为业务逻辑的中心，同时不受框架和技术选择的限制。
- en: FCIS proposes the functional core for business logic, but with the use of stateless
    functions and immutable data structures.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS（功能核心信息系统）提出业务逻辑的功能核心，但使用无状态函数和不可变数据结构。
- en: The Connect pattern uses Action for the integration point of a single action
    and an adapter for the transport details of the interaction with the remote system.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: Connect 模式使用 Action 作为单个操作和与远程系统交互的传输细节的集成点，并使用适配器。
- en: Testability
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可测试性
- en: In traditional architectures, testing the core business logic can be challenging
    due to dependencies on external systems, databases, or UI frameworks.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统架构中，由于依赖于外部系统、数据库或UI框架，测试核心业务逻辑可能具有挑战性。
- en: Testing a function coupled with a choice of technology typically requires a
    lot of setting up and tearing down of resources, and worse if there are asynchronous
    processes behind the scenes. This means it requires more effort from engineers
    to make the tests work, fewer tests can be written for the same amount of time,
    the test suite takes longer to run, and there could be flaky tests that fail occasionally
    due to some asynchronous processes involved. Any parallel executed tests can make
    the test suite even more flaky.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 测试一个与技术选择耦合的函数通常需要大量的设置和拆除资源，如果背后有异步过程，则更糟。这意味着需要工程师付出更多努力才能使测试工作，相同时间内可以编写的测试较少，测试套件运行时间更长，并且可能存在偶尔失败的不可靠测试，这是由于涉及的一些异步过程。任何并行执行的测试都可能使测试套件更加不可靠。
- en: Clean Architecture offers dedicated layers for business logic only (the Entities
    and Use Cases layers), which can be tested in isolation without involving any
    choice of technology. The Interface Adapters layer focuses on internal and external
    model translation, which can be also tested independently. The configurations
    of the Frameworks & Driver layers can be tested without involving business rules.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构为仅业务逻辑提供专用层（实体和用例层），可以在不涉及任何技术选择的情况下单独测试。接口适配器层专注于内部和外部模型转换，也可以独立测试。框架和驱动器层的配置可以在不涉及业务规则的情况下进行测试。
- en: The hexagonal architecture advocates the core as a technology-neutral area where
    unit tests can be easily written without the need for complex setups or mocking
    extensive external components. Each adapter can be tested individually and without
    involving any business logic.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构倡导核心作为一个技术中立区域，在这里可以轻松编写单元测试，无需复杂的设置或模拟大量的外部组件。每个适配器都可以单独测试，而不涉及任何业务逻辑。
- en: FCIS suggests putting only business logic as stateless functions and immutable
    data structures in the functional core. This reduces testing of the functional
    core using a simple verification of the output result given by input. The imperative
    shell can also be tested easily by swapping the lower-order functions in the functional
    core, as a result, the immutable and the mutable parts of the systems can be tested
    separately.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS建议将业务逻辑仅作为无状态函数和不可变数据结构放在功能核心中。这通过简单验证由输入给出的输出结果来减少对功能核心的测试。通过在功能核心中交换低阶函数，命令式外壳也可以轻松测试，因此，系统的不可变和可变部分可以单独测试。
- en: The Connect pattern breaks down the large remote interface of a monolithic application
    into one Action per API call. This reduces a lot of overhead, excessive mocking,
    test double, or stubbing of the interface. The ability to test an API call in
    isolation improves testability and enables easy extension of the usage of a remote
    API.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式将单体应用程序的大远程接口分解为每个API调用一个操作。这减少了大量的开销、过度的模拟、测试双倍或接口的存根。在隔离状态下测试API调用的能力提高了可测试性，并使得远程API的使用扩展变得容易。
- en: Maintainability
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性
- en: Over time, applications tend to evolve and change, often requiring modifications
    to the core business logic or the choice of frameworks. In traditional architectures,
    making changes can be risky as these modifications may have unintended consequences
    throughout the system. Updating business logic may have intertwined with a deprecated
    library and eventually, both need to be changed.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，应用程序往往会发展和变化，通常需要修改核心业务逻辑或框架的选择。在传统架构中，进行更改可能存在风险，因为这些修改可能在整个系统中产生意外的后果。更新业务逻辑可能与已弃用的库交织在一起，最终两者都需要进行更改。
- en: Clean Architecture, the hexagonal architecture, and FCIS provide a clear separation
    between the core business logic and the surrounding infrastructure, making it
    easier to modify or extend the application without affecting the core business
    rules.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构、六边形架构和FCIS在核心业务逻辑和周围基础设施之间提供了清晰的分离，这使得在不影响核心业务规则的情况下修改或扩展应用程序变得更容易。
- en: The Connect pattern is very lightweight and there is no overlapping among Actions.
    The connectivity and message interaction concerns are separated into adapter and
    Action classes, the maintenance of these classes is simple, and code changes are
    small.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式非常轻量级，动作之间没有重叠。连接性和消息交互关注点被分离到适配器和动作类中，这些类的维护简单，代码更改小。
- en: Flexibility and adaptability
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 灵活性和适应性
- en: Applications often need to integrate with various external resources, such as
    files, databases, third-party services, or UIs. In traditional architectures,
    these integrations are deeply embedded within the application code, making it
    challenging to switch or modify these integrations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序通常需要与各种外部资源集成，例如文件、数据库、第三方服务或用户界面。在传统的架构中，这些集成深深嵌入到应用程序代码中，使得切换或修改这些集成变得具有挑战性。
- en: Clean Architecture promotes the Interface Adapters and Frameworks and Drivers
    layers to contain external dependencies. This allows more flexibility and adaptability,
    as the business rules remain decoupled from specific technologies or protocols.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构促进接口适配器和框架以及驱动程序层的包含外部依赖。这允许更多的灵活性和适应性，因为业务规则与特定的技术或协议解耦。
- en: The hexagonal architecture promotes the use of ports and adapters, which act
    as interfaces and adapters between the core logic and the external systems. A
    different choice of framework results in a separate implementation of adapters
    but the port interfaces remain the same. Changing technology or a protocol is
    easy by swapping an implementation of the same interface.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 六边形架构促进使用端口和适配器，这些作为核心逻辑和外部系统之间的接口和适配器。不同的框架选择会导致适配器的单独实现，但端口接口保持不变。通过交换相同接口的实现，改变技术或协议变得容易。
- en: FCIS uses the imperative shell layer to handle all the interactions with the
    external world. Any change in technology or protocol requires a change only in
    the imperative shell layer. With the high-level reuse of small functions, only
    a minor change is required to adapt to a new technology.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: FCIS使用命令式外壳层来处理与外部世界的所有交互。任何技术或协议的变化只需要在命令式外壳层进行更改。通过高级的小函数重用，只需进行微小的更改即可适应新技术。
- en: The Connect pattern allows engineers to implement a new adapter if it needs
    to integrate with a new remote system. If it needs to adapt to a new communication
    protocol, it is required to implement a new adapter and new Action, but there
    is no need to update the current code.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 连接模式允许工程师在需要与新的远程系统集成时实现新的适配器。如果需要适应新的通信协议，则需要实现新的适配器和新的动作，但无需更新当前代码。
- en: When to use which architectural style
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用哪种架构风格
- en: 'Clean Architecture, the hexagonal architecture, and FCIS share a great deal
    of similarities that engineers may find hard to choose for their applications.
    The layers of these three architectural styles can be approximately mapped as
    follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 清洁架构、六边形架构和FCIS在许多方面有相似之处，工程师可能难以为他们的应用程序选择。这些三种架构风格的层可以大致映射如下：
- en: '| **Clean Architecture** | **Hexagonal Architecture** | **FCIS** |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| **清洁架构** | **六边形架构** | **FCIS** |'
- en: '| **Entities** | Shared / Common libs | Shared / Common libs |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| **实体** | 共享/通用库 | 共享/通用库 |'
- en: '| **Use Case** | Core / Domain / Port | Core |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| **用例** | 核心/领域/端口 | 核心 |'
- en: '| **Interface Adapters** | Adapters | Shell |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| **接口适配器** | 适配器 | 外壳 |'
- en: '| **Frameworks** **and Drivers** | Adapters | Shell |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| **框架和驱动程序** | 适配器 | 外壳 |'
- en: Table 7.1 – Approximate mapping among the three architectural styles
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 表7.1 – 三种架构风格之间的近似映射
- en: 'If we accept the opinion that the three styles can be loosely mapped, then
    the choice would become convention among engineers. The following are some opinions
    for reference but they are not strict rules:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们接受这种观点，即三种风格可以松散地映射，那么选择将变成工程师之间的惯例。以下是一些供参考的意见，但它们并非严格规则：
- en: Engineers with more functional programming experience would prefer FCIS.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拥有更多函数式编程经验的工程师会更倾向于FCIS。
- en: Clean Architecture provides better support to monolithic applications or systems
    with a big source repository. Having said that, Clean Architecture can absolutely
    support smaller repositories or microservices.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 清洁架构为单体应用程序或拥有大型源代码库的系统提供了更好的支持。话虽如此，清洁架构绝对可以支持较小的代码库或微服务。
- en: The hexagonal architecture fits microservice applications in terms of scope
    and scale.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六边形架构在范围和规模方面适合微服务应用程序。
- en: 'There are also a lot of rooms to create a hybrid style. For instance, an application
    using the hexagonal architecture can borrow the concepts of FCIS, so all ports
    and adapters are basically functions using the Kotlin operator overload features:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建混合风格方面有很多空间。例如，一个使用六边形架构的应用程序可以借鉴FCIS的概念，因此所有端口和适配器基本上是使用Kotlin操作符重载功能实现的函数：
- en: '[PRE35]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '`ContractPersist` is a type alias we used in FCIS, and we can define a class
    that implements the type alias interface and provides the `invoke` function with
    operator override. So, in practice, callers can skip the `invoke` keyword and
    treat it as a function, like the following:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContractPersist`是我们用于FCIS的类型别名，我们可以定义一个实现类型别名接口并提供具有操作符重载的`invoke`函数的类。因此，在实践中，调用者可以跳过`invoke`关键字，将其视为一个函数，如下所示：'
- en: '[PRE36]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: So, this concept can be extended to port interfaces, where they are only type
    aliases or interfaces with one function only.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个概念可以扩展到端口接口，其中它们只是具有一个函数的唯一类型别名或接口。
- en: The Connect pattern is an integration pattern that solves a different problem
    than the other three styles covered in this chapter. The Connect pattern can be
    used when there is a need to perform the same action in a business sense using
    external systems, but we want to decouple the technical integration details from
    the business logic.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: Connect模式是一种集成模式，它解决的问题不同于本章中涵盖的其他三种风格。当需要在外部系统中执行具有业务意义的相同操作，但希望将技术集成细节与业务逻辑解耦时，可以使用Connect模式。
- en: In relation to the anemic domain model
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与贫血领域模型相关
- en: The **anemic domain model** (**ADM**) is a controversial architectural style
    that some people classify as an anti-pattern, while others find it useful in certain
    circumstances. In the ADM, the core or Use Cases layer has mainly data structures
    and little to zero business behaviors.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**贫血领域模型**（ADM）是一种有争议的架构风格，一些人将其归类为反模式，而另一些人发现在某些情况下它是有用的。在ADM中，核心或用例层主要包含数据结构，几乎没有或没有业务行为。'
- en: The in-depth discussion on ADM is beyond the scope of this chapter, however,
    if a team has chosen to use ADM, then it is not advisable to combine it with Clean
    Architecture, the hexagonal architecture, or FCIS.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 本章对ADM的深入讨论超出了范围，然而，如果一个团队选择使用ADM，那么不建议将其与Clean Architecture、六边形架构或FCIS结合使用。
- en: The main reason is that these architectures are designed to have business behaviors
    kept in the core or Use Cases layer; in other words, they are designed to work
    with the **rich domain model** (**RDM**) only. The application does not get any
    benefit from adopting the layers from Clean Architecture, the hexagonal architecture,
    or FCIS covered in this chapter.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 主要原因是这些架构旨在将业务行为保留在核心或用例层；换句话说，它们旨在仅与**丰富领域模型**（RDM）一起工作。应用程序采用本章中涵盖的Clean Architecture、六边形架构或FCIS的层不会获得任何好处。
- en: Usage of ADM
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: ADM的使用
- en: Although ADM may be seen as an anti-pattern to some people, the lack of business
    behaviors may mean the application’s goals are data processing and infrastructure
    plumbing only. For example, an ADM application may be responsible for ingesting
    a large file, splitting the data in the file into chunks, and processing each
    chunk in parallel. The application focuses on data manipulation and scalability,
    meanwhile, the processed data is read by other downstream applications that contain
    actual business behaviors related to the data. Another example could be an application
    that consumes the headers of external messages and forwards these messages to
    their corresponding internal topics for further processing.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然AD（贫血领域模型）可能被一些人视为反模式，但缺乏业务行为可能意味着应用程序的目标仅仅是数据处理和基础设施管道。例如，一个AD应用程序可能负责接收一个大文件，将文件中的数据分割成块，并并行处理每个块。该应用程序专注于数据操作和可扩展性，同时，处理后的数据被包含实际与数据相关的业务行为的下游应用程序读取。另一个例子可能是一个消费外部消息头并将其转发到相应内部主题以进行进一步处理的应用程序。
- en: Organizing source code as layers
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 按层组织源代码
- en: There are two popular choices for organizing source code as layers. In Kotlin,
    the first approach is to put files into their belonging packages as layers.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 按层组织源代码有两种流行的选择。在Kotlin中，第一种方法是将文件放入它们所属的包中作为层。
- en: 'In the real-life example we used, we could have the following packages in each
    architectural style:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们使用的实际生活示例中，我们可以在每个架构风格中拥有以下包：
- en: '**Clean Architecture**:'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Clean Architecture**：'
- en: '[PRE37]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '**Hexagonal architecture**:'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**六边形架构**：'
- en: '[PRE38]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '**FCIS**:'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**FCIS**：'
- en: '[PRE39]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Enforcing the layered architecture, where only the outer layer can use the inner
    layer and not the other way round, can easily be done using test cases and includes
    passing them as a part of a successful build.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 强制执行分层架构，其中只有外层可以使用内层，反之则不行，可以通过使用测试用例并作为成功构建的一部分来轻松实现。
- en: 'This is an example of a test case that enforces the FCIS layer dependency,
    using **ArchUnit** as the test driver:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个强制执行 FCIS 层依赖的测试用例示例，使用 **ArchUnit** 作为测试驱动程序：
- en: '[PRE40]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The second approach is the use of a source code module within a build framework,
    such as **Gradle** or **Maven**. We create multi-module projects for an application,
    and the outer modules declare dependencies on inner modules.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法是使用构建框架内的源代码模块，例如 **Gradle** 或 **Maven**。我们为应用程序创建多模块项目，并且外层模块声明对内层模块的依赖。
- en: For example, the imperative shell of the Negotiation Service can have explicit
    dependencies declared in the Gradle Kotlin script of the imperative shell module.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，协商服务的命令行外壳可以在命令行模块的 Gradle Kotlin 脚本中声明显式依赖。
- en: '[PRE41]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: It is important to note that this approach is more heavy-weighted than the package
    approach as it creates actual artifacts of inner layers.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这种方法比包方法更重量级，因为它创建了内层的实际工件。
- en: The Connect pattern, however, is a modular but not layered architecture, so
    there is no need to enforce layer dependencies.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Connect 模式是一个模块化但非分层架构，因此没有必要强制执行层依赖。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we discussed three architectural styles that aim to solve
    the same issues in traditional architectures where business logic and technology
    choices are tightly coupled. These three architectures were covered in depth:
    Clean Architecture, hexagonal architecture, and FCIS. We also discussed the Connect
    pattern, which focuses on breaking down large remote interfaces for integrating
    with remote systems.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了三种旨在解决传统架构中相同问题的架构风格，其中业务逻辑和技术选择紧密耦合。这三个架构被深入探讨：清洁架构、六边形架构和 FCIS。我们还讨论了
    Connect 模式，该模式侧重于分解大型远程接口以与远程系统集成。
- en: We illustrated each architectural style using our real-life example and how
    each style is implemented in code.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用我们的真实生活示例说明了每种架构风格，以及每种风格如何在代码中实现。
- en: We also compared the four architecture styles in terms of how they tackle the
    issues in traditional architecture. We briefly covered how code can be organized
    in a repository under layered architectures.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还比较了四种架构风格在解决传统架构问题方面的方法。我们简要介绍了在分层架构下如何在存储库中组织代码。
- en: We mentioned that the core in the hexagonal architecture is sometimes named
    the *domain*. However, the term “domain” itself is worth a lengthy discussion.
    In the next chapter, we are going to cover the concepts surrounding the domain,
    with one common theme – **domain-driven** **development** (**DDD**).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到，在六边形架构中，核心有时被称为 *领域*。然而，"领域" 这个术语本身值得深入讨论。在下一章中，我们将探讨与领域相关的概念，其中一个共同的主题是
    **领域驱动** **开发**（**DDD**）。
