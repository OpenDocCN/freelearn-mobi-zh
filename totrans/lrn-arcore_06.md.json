["```kt\nFrame frame = mSession.update();\n```", "```kt\nmPointCloud.update(frame.getPointCloud());\nmPointCloud.draw(frame.getPointCloudPose(), viewmtx, projmtx);\n```", "```kt\nif (messageSnackbar != null) {\n  for (Plane plane : session.getAllTrackables(Plane.class)) {\n    if (plane.getType() == com.google.ar.core.Plane.Type.HORIZONTAL_UPWARD_FACING\n        && plane.getTrackingState() == TrackingState.TRACKING) {\n      hideLoadingMessage();\n      break;\n    }\n  }\n}\n```", "```kt\nplaneRenderer.drawPlanes(\n    session.getAllTrackables(Plane.class), camera.getDisplayOrientedPose(), projmtx);\n```", "```kt\nMotionEvent tap = queuedSingleTaps.poll();\nif (tap != null && camera.getTrackingState() == TrackingState.TRACKING) {\n  for (HitResult hit : frame.hitTest(tap)) {\n    // Check if any plane was hit, and if it was hit inside the plane \n       polygon\n    Trackable trackable = hit.getTrackable();\n    // Creates an anchor if a plane or an oriented point was hit.\n    if ((trackable instanceof Plane && ((Plane) trackable).isPoseInPolygon(hit.getHitPose()))\n || (trackable instanceof Point\n && ((Point) trackable).getOrientationMode()\n == OrientationMode.ESTIMATED_SURFACE_NORMAL)) {\n      // Hits are sorted by depth. Consider only closest hit on a plane \n         or oriented point.\n      // Cap the number of objects created. This avoids overloading \n         both the\n      // rendering system and ARCore.\n      if (anchors.size() >= 20) {\n        anchors.get(0).detach();\n        anchors.remove(0);\n      }\n      // Adding an Anchor tells ARCore that it should track this          \n        position in\n      // space. This anchor is created on the Plane to place the 3D \n         model\n      // in the correct position relative both to the world and to the \n         plane.\n      anchors.add(hit.createAnchor());\n      break;\n    }\n  }\n}\n```", "```kt\n// Visualize anchors created by touch.\nfloat scaleFactor = 1.0f;\nfor (Anchor anchor : anchors) {\n  if (anchor.getTrackingState() != TrackingState.TRACKING) {\n    continue;\n  }\n  // Get the current pose of an Anchor in world space. The Anchor pose is updated\n  // during calls to session.update() as ARCore refines its estimate of the world.\n  anchor.getPose().toMatrix(anchorMatrix, 0);\n\n  // Update and draw the model and its shadow.\n  virtualObject.updateModelMatrix(anchorMatrix, scaleFactor);\n  virtualObjectShadow.updateModelMatrix(anchorMatrix, scaleFactor);\n  virtualObject.draw(viewmtx, projmtx, lightIntensity);\n  virtualObjectShadow.draw(viewmtx, projmtx, lightIntensity);\n```", "```kt\nfloat scaleFactor = 2.0f;\n```", "```kt\n// Set up tap listener.\ngestureDetector =\n    new GestureDetector(\n        this,\n        new GestureDetector.SimpleOnGestureListener() {\n          @Override\n          public boolean onSingleTapUp(MotionEvent e) {\n            onSingleTap(e);\n            return true;\n          }\n\n          @Override\n          public boolean onDown(MotionEvent e) {\n            return true;\n          }\n        });\n\nsurfaceView.setOnTouchListener(\n    new View.OnTouchListener() {\n      @Override\n      public boolean onTouch(View v, MotionEvent event) {\n        return gestureDetector.onTouchEvent(event);\n      }\n    });\n```", "```kt\n@Override\npublic boolean onDown(MotionEvent e) { return true;} //after this section@Overridepublic void onLongPress(MotionEvent e) {\n onLongPressDown(e);\n}\n\n```", "```kt\nprivate void onSingleTap(MotionEvent e) {\n    // Queue tap if there is space. Tap is lost if queue is full. mQueuedSingleTaps.offer(e);\n} //after this block of codeprivate void onLongPressDown(MotionEvent e) {\n    mTouches.clear();\n}\n```", "```kt\nGLES20.glUniform4f(colorUniform, 31.0f / 255.0f, 188.0f / 255.0f, 210.0f / 255.0f, 1.0f);\n```", "```kt\nGLES20.glUniform4f(colorUniform, 255.0f / 255.0f, 255.0f / 255.0f, 255.0f / 255.0f, 1.0f); \n```", "```kt\nGLES20.glUniform1f(pointSizeUniform, 25.0f);\n```", "```kt\nuniform mat4 u_ModelViewProjection;\nuniform vec4 u_Color;\nuniform float u_PointSize;\n\nattribute vec4 a_Position;\n\nvarying vec4 v_Color;\n\nvoid main() {\n   v_Color = u_Color;\n   gl_Position = u_ModelViewProjection * vec4(a_Position.xyz, 1.0);\n   gl_PointSize = u_PointSize;\n}\n```", "```kt\npositionAttribute = GLES20.glGetAttribLocation(programName, \"a_Position\");\ncolorUniform = GLES20.glGetUniformLocation(programName, \"u_Color\");\nmodelViewProjectionUniform = GLES20.glGetUniformLocation(programName, \"u_ModelViewProjection\");\npointSizeUniform = GLES20.glGetUniformLocation(programName, \"u_PointSize\");\n```", "```kt\nfurthestPoint = GLES20.glGetUniformLocation(programName, \"u_FurthestPoint\");\n```", "```kt\nprivate int numPoints = 0; //after this line\nprivate int furthestPoint;\nprivate float furthestPointLength;\n```", "```kt\nnumPoints = lastPointCloud.getPoints().remaining() / FLOATS_PER_POINT;  //after me\n\nfurthestPointLength = 1;\nif(numPoints > 0) {\n    for(int i=0; i<numPoints*FLOATS_PER_POINT;i= i+FLOATS_PER_POINT) {\n        float x = lastPointCloud.getPoints().get(i);\n        float y = lastPointCloud.getPoints().get(i+1);\n        float z = lastPointCloud.getPoints().get(i+2);\n        double len = Math.sqrt(x*x+y*y+z*z);\n        furthestPointLength = Math.max(furthestPointLength, (float)len);\n    } \n }\n}\n```", "```kt\nGLES20.glUniform1f(mPointSizeUniform, 25.0f); //after me\n\nGLES20.glUniform1f(furthestPoint, furthestPointLength);\n```", "```kt\nuniform mat4 u_ModelViewProjection;\nuniform vec4 u_Color;\nuniform float u_PointSize;\nuniform float u_FurthestPoint;\n\nattribute vec4 a_Position;\n\nvarying vec4 v_Color;\n\nvoid main() {\n   float t = length(a_Position)/u_FurthestPoint;\n   v_Color = vec4(t, 1.0-t,t,1.0);\n   gl_Position = u_ModelViewProjection * vec4(a_Position.xyz, 1.0);\n   gl_PointSize = u_PointSize;\n}\n```"]