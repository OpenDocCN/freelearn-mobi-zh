<html><head></head><body>
<div id="_idContainer174">
<h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor172"/><span class="koboSpan" id="kobo.1.1">12</span></h1>
<h1 id="_idParaDest-165"><a id="_idTextAnchor173"/><span class="koboSpan" id="kobo.2.1">Creating a Word Game (Part 1)</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In this project, we will start creating a “complete the word” game, which we will then finish in the next chapter. </span><span class="koboSpan" id="kobo.3.2">The word game will require the user to find words using the letters within a given word. </span><span class="koboSpan" id="kobo.3.3">To add a little twist to the game, we’ll offer it in three different languages – English, Spanish, </span><span class="No-Break"><span class="koboSpan" id="kobo.4.1">and Italian.</span></span></p>
<p><span class="koboSpan" id="kobo.5.1">Some new things that you will learn are how to add and customize a </span><strong class="source-inline"><span class="koboSpan" id="kobo.6.1">PickerView</span></strong><span class="koboSpan" id="kobo.7.1">, implement user feedback in a few different ways (including with pop-up alerts, haptics, and sound), and add various animations to the user interface, including </span><span class="No-Break"><span class="koboSpan" id="kobo.8.1">spring animations.</span></span></p>
<p><span class="koboSpan" id="kobo.9.1">So, in this chapter, we will cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">following topics:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Setting up the project and creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.12.1">data model</span></span></li>
<li><span class="koboSpan" id="kobo.13.1">Building out the UI by adding a text field </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">and list</span></span></li>
<li><span class="koboSpan" id="kobo.15.1">Displaying a character count next to each word in </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">the list</span></span></li>
<li><span class="koboSpan" id="kobo.17.1">Checking the entered words </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">for duplicates</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Adding a random word with a </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">button press</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Checking whether the user’s entered word </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">is possible</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Checking whether the user’s entered word is a </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">real word</span></span></li>
<li><span class="koboSpan" id="kobo.25.1">Checking whether the user’s entered work </span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">is valid</span></span></li>
<li><span class="koboSpan" id="kobo.27.1">Creating </span><strong class="source-inline"><span class="koboSpan" id="kobo.28.1">HeaderView</span></strong><span class="koboSpan" id="kobo.29.1"> with an </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.30.1">info</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.31.1"> button</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.32.1">Creating </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.33.1">PickerView</span></strong></span></li>
</ul>
<h1 id="_idParaDest-166"><a id="_idTextAnchor174"/><span class="koboSpan" id="kobo.34.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.35.1">You can download the resources and finished project from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.36.1">Chapter 12</span></strong></span><strong class="source-inline"><span class="koboSpan" id="kobo.37.1"> and 13</span></strong><span class="koboSpan" id="kobo.38.1"> folder on </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">GitHub: </span></span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="No-Break"><span class="koboSpan" id="kobo.40.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.41.1">.</span></span></p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor175"/><span class="koboSpan" id="kobo.42.1">Setting up the project and creating a data model</span></h1>
<p><span class="koboSpan" id="kobo.43.1">First, create</span><a id="_idIndexMarker656"/><span class="koboSpan" id="kobo.44.1"> a new Xcode project and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">Find Words</span></strong><span class="koboSpan" id="kobo.46.1">. </span><span class="koboSpan" id="kobo.46.2">Then, in the</span><a id="_idIndexMarker657"/><span class="koboSpan" id="kobo.47.1"> GitHub repository, go to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.48.1">Chapter 12</span></strong></span><strong class="source-inline"> </strong><span class="koboSpan" id="kobo.49.1">and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.50.1">Chapter 13</span></strong></span><span class="koboSpan" id="kobo.51.1"> folders; this folder will include three subfolders called </span><strong class="source-inline"><span class="koboSpan" id="kobo.52.1">Language Data</span></strong><span class="koboSpan" id="kobo.53.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">Images</span></strong><span class="koboSpan" id="kobo.55.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">Sound</span></strong><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.58.1">Images</span></strong><span class="koboSpan" id="kobo.59.1"> folder to the Assets catalog, and the other folders to the </span><span class="No-Break"><span class="koboSpan" id="kobo.60.1">Project navigator.</span></span></p>
<p><span class="koboSpan" id="kobo.61.1">Next, we will create a data model file to hold the data for the </span><a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications"><span class="koboSpan" id="kobo.62.1">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</span></a><span class="koboSpan" id="kobo.63.1"> app – to do this, press </span><em class="italic"><span class="koboSpan" id="kobo.64.1">Command + N</span></em><span class="koboSpan" id="kobo.65.1">, choose the </span><strong class="bold"><span class="koboSpan" id="kobo.66.1">SwiftUI</span></strong><span class="koboSpan" id="kobo.67.1"> file type, and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.68.1">DataModel</span></strong><span class="koboSpan" id="kobo.69.1">. </span><span class="koboSpan" id="kobo.69.2">In this file, import SwiftUI by adding the following code at the top of </span><span class="No-Break"><span class="koboSpan" id="kobo.70.1">the file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.71.1">
import SwiftUI</span></pre>
<p><span class="koboSpan" id="kobo.72.1">As we have done before, we add a class to hold all of the properties and methods. </span><span class="koboSpan" id="kobo.72.2">We’ll call the class </span><strong class="source-inline"><span class="koboSpan" id="kobo.73.1">DataModel</span></strong><span class="koboSpan" id="kobo.74.1">, and it needs to conform to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.75.1">ObservableObject</span></strong><span class="koboSpan" id="kobo.76.1"> protocol in order for us to access this data later on. </span><span class="koboSpan" id="kobo.76.2">Then, we’ll add the properties </span><span class="No-Break"><span class="koboSpan" id="kobo.77.1">we need:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.78.1">
class DataModel: ObservableObject {
    @Published var allWordsInFile = [String]()
    @Published var baseWord = ""
    @Published var userEnteredWord = ""
    @Published var userEnteredWordsArray = [String]()
    @Published var letterCount = ""
    @Published var showSettings: Bool = false
    
    //error properties
    @Published var errorMessageIsShown = false
    @Published var errorTitle = ""
    @Published var errorDescription = ""
    
    //properties to stpre in user defaults
    @AppStorage ("selectedSegment") var selectedSegment:
      Int = 0
    @AppStorage ("englishIsOn") var englishIsOn: Bool = 
      false
    @AppStorage ("spanishIsOn") var spanishIsOn: Bool = 
      false
    @AppStorage ("italianIsOn") var italianIsOn: Bool = 
      false
   
    //splash view property
    @Published var change = false  
}</span></pre>
<p><span class="koboSpan" id="kobo.79.1">Let’s break</span><a id="_idIndexMarker658"/><span class="koboSpan" id="kobo.80.1"> down </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">the</span></span><span class="No-Break"><a id="_idIndexMarker659"/></span><span class="No-Break"><span class="koboSpan" id="kobo.82.1"> code:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.83.1">First, we have an array called </span><strong class="source-inline"><span class="koboSpan" id="kobo.84.1">allWordsInFile</span></strong><span class="koboSpan" id="kobo.85.1">, which will hold all of the words needed to play the game. </span><span class="koboSpan" id="kobo.85.2">We will use three separate files, one for English, one for Spanish, and one for Italian. </span><span class="koboSpan" id="kobo.85.3">This array will be loaded with whichever language is selected to play the </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">game with.</span></span></li>
<li><span class="koboSpan" id="kobo.87.1">Next is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.88.1">baseWord</span></strong><span class="koboSpan" id="kobo.89.1"> property, which will contain the word the user is working with and trying to find new </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">words from.</span></span></li>
<li><span class="koboSpan" id="kobo.91.1">Then, we have another property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">userEnteredWord</span></strong><span class="koboSpan" id="kobo.93.1"> that will hold the user’s word when they type it into the </span><span class="No-Break"><span class="koboSpan" id="kobo.94.1">text field.</span></span></li>
<li><span class="koboSpan" id="kobo.95.1">Next is another array called </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.97.1">, which will hold all of the user’s guessed words so that we can keep track of what they have completed </span><span class="No-Break"><span class="koboSpan" id="kobo.98.1">so far.</span></span></li>
<li><span class="koboSpan" id="kobo.99.1">Next is a property called </span><strong class="source-inline"><span class="koboSpan" id="kobo.100.1">letterCount</span></strong><span class="koboSpan" id="kobo.101.1">, which will be used to keep track of the number of letters per word being used so that we can tally an average number of letters per word. </span><span class="koboSpan" id="kobo.101.2">For example, if the user is only choosing three-letter words, we will display that word letter average on </span><span class="No-Break"><span class="koboSpan" id="kobo.102.1">the screen.</span></span></li>
<li><span class="koboSpan" id="kobo.103.1">Next is the Boolean that will open </span><strong class="source-inline"><span class="koboSpan" id="kobo.104.1">SettingsView</span></strong><span class="koboSpan" id="kobo.105.1">, allowing the user to change the </span><span class="No-Break"><span class="koboSpan" id="kobo.106.1">game’s language.</span></span></li>
<li><span class="koboSpan" id="kobo.107.1">Next are three error properties we will use to show an alert when the user misspells words or enters duplicate words, which are words that are already in </span><span class="No-Break"><span class="koboSpan" id="kobo.108.1">the list.</span></span></li>
<li><span class="koboSpan" id="kobo.109.1">Next are what are called </span><strong class="source-inline"><span class="koboSpan" id="kobo.110.1">AppStorage</span></strong><span class="koboSpan" id="kobo.111.1"> properties. </span><span class="koboSpan" id="kobo.111.2">These are used to save the user’s language settings in memory, so when they close the app and then come back later, their settings are preserved. </span><span class="koboSpan" id="kobo.111.3">When we prefix a property with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">AppStorage</span></strong><span class="koboSpan" id="kobo.113.1"> wrapper, a place in memory on the phone will preserve the </span><span class="No-Break"><span class="koboSpan" id="kobo.114.1">user settings.</span></span></li>
<li><span class="koboSpan" id="kobo.115.1">Next, a </span><a id="_idIndexMarker660"/><span class="koboSpan" id="kobo.116.1">property to display a splash screen. </span><span class="koboSpan" id="kobo.116.2">A splash screen</span><a id="_idIndexMarker661"/><span class="koboSpan" id="kobo.117.1"> is an opening scene that the user will see briefly as the app loads in </span><span class="No-Break"><span class="koboSpan" id="kobo.118.1">the background.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.119.1">Let’s continue and add all the methods we need for the project now into </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">DataModel</span></strong><span class="koboSpan" id="kobo.121.1">, right under the properties we just added: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
 //FUNCTIONS
     //starts the game off with a random word by looking in 
       the app's bundle for the language file
    func getRandomWord() {
        guard let wordsURL = Bundle.main.url(forResource: 
        setWordLengthAndLanguage(), withExtension: "txt"),
        let wordsConverted = try? </span><span class="koboSpan" id="kobo.122.2">String(contentsOf:
          wordsURL) else {
        assert(false, "There was a problem loading the data
          file from the bundle.")
            return
        }
        let allWordsInFile = 
          wordsConverted.components(separatedBy: "\n")
        baseWord = allWordsInFile.randomElement() ?? 
</span><span class="koboSpan" id="kobo.122.3">          "SwiftUI"
    }
    //sets the language for the game
    func setWordLengthAndLanguage() -&gt; String {
      return ""
    }
    
    //adds a new word to the game
    func addWordToList() {
        
    }
    
    //check to see if the word is a duplicate
    func isWordDuplicate(word: String) -&gt; Bool {
        return false
    }
    
    //check to see if the word is possible given the base
      word's letters
    func isWordFoundInBaseWord(userGuessWord: String) -&gt;
      Bool {
        return false
    }
    
    //check to see if the word is a real word in dictionary
    func isWordReal(word: String) -&gt; Bool {
        return false
    }
    //error message
    func displayErrorMessage(messageTitle: String,
      description: String) {
        
    }</span></pre>
<p><span class="koboSpan" id="kobo.123.1">Let’s break this </span><a id="_idIndexMarker662"/><span class="koboSpan" id="kobo.124.1">code </span><span class="No-Break"><span class="koboSpan" id="kobo.125.1">down too:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.126.1">We have a method </span><a id="_idIndexMarker663"/><span class="koboSpan" id="kobo.127.1">to grab a random word from the </span><span class="No-Break"><span class="koboSpan" id="kobo.128.1">language files</span></span></li>
<li><span class="koboSpan" id="kobo.129.1">We have a function to set the word length – either 7, 8, or 9 letters – and language – either English, Spanish, </span><span class="No-Break"><span class="koboSpan" id="kobo.130.1">or Italian</span></span></li>
<li><span class="koboSpan" id="kobo.131.1">There’s a function to add the user’s word to a list so that they can see all the words that they have found </span><span class="No-Break"><span class="koboSpan" id="kobo.132.1">so far</span></span></li>
<li><span class="koboSpan" id="kobo.133.1">Then a function to check whether their word is a duplicate; we don’t want duplicates in </span><span class="No-Break"><span class="koboSpan" id="kobo.134.1">the list</span></span></li>
<li><span class="koboSpan" id="kobo.135.1">Then, a function to check to see whether the word is possible given the word they’re </span><span class="No-Break"><span class="koboSpan" id="kobo.136.1">working with</span></span></li>
<li><span class="koboSpan" id="kobo.137.1">We also have a function to check to see whether the word is a real word in the language of choice (we don’t want </span><span class="No-Break"><span class="koboSpan" id="kobo.138.1">made-up words!)</span></span></li>
<li><span class="koboSpan" id="kobo.139.1">And then finally, a function to display an error message to the user if they type in a word that doesn’t exist or cannot </span><span class="No-Break"><span class="koboSpan" id="kobo.140.1">be made</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.141.1">As you see </span><a id="_idIndexMarker664"/><span class="koboSpan" id="kobo.142.1">from the code, I have filled out only one function for now, and the </span><a id="_idIndexMarker665"/><span class="koboSpan" id="kobo.143.1">rest of the functions are just known as </span><strong class="bold"><span class="koboSpan" id="kobo.144.1">function stubs</span></strong><span class="koboSpan" id="kobo.145.1">. </span><span class="koboSpan" id="kobo.145.2">A function stub is a declared function but without anything in its body </span><a id="_idIndexMarker666"/><span class="koboSpan" id="kobo.146.1">other than a </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">return</span></strong><span class="koboSpan" id="kobo.148.1"> statement. </span><span class="koboSpan" id="kobo.148.2">This is helpful because we can still continue writing code in the interface, call these functions stubs, and the code will still build cleanly, even though it won’t do </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">anything yet.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">We will fill out the body of the other functions soon enough, but let’s look at the one function I did add code into – </span><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">getRandomWord()</span></strong><span class="koboSpan" id="kobo.152.1">. </span><span class="koboSpan" id="kobo.152.2">This function starts by trying to access the app bundle, which is where we placed our language files. </span><span class="koboSpan" id="kobo.152.3">When we add files to the project, they are put into the app bundle. </span><span class="koboSpan" id="kobo.152.4">The app bundle is a folder where all the app files are stored and used to make the app work. </span><span class="koboSpan" id="kobo.152.5">We need to access the bundle and find the path to those language files so we can load the words they contain and use them in </span><span class="No-Break"><span class="koboSpan" id="kobo.153.1">the game.</span></span></p>
<p><span class="koboSpan" id="kobo.154.1">To access them, Swift gives us a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">url(forResource)</span></strong><span class="koboSpan" id="kobo.156.1"> for locating the path of a file – we simply type the name of the file into the first parameter and the extension into the second parameter. </span><span class="koboSpan" id="kobo.156.2">For now, we’re just going to load up the seven-letter word file in the English language (but later on, we’ll be accessing words of other sizes and other languages’ files). </span></p>
<p><span class="koboSpan" id="kobo.157.1">For the extension, I put in </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">txt</span></strong><span class="koboSpan" id="kobo.159.1"> for a text file. </span><span class="koboSpan" id="kobo.159.2">If we find that file, then we proceed to the next step where we attempt to convert that file into a string so that we can manipulate it. </span><span class="koboSpan" id="kobo.159.3">If the code is able to complete that task, then it will separate the words in the file using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">components(separatedBy)</span></strong><span class="koboSpan" id="kobo.161.1"> method and pass in the new line character, so each word will be on its own line. </span><span class="koboSpan" id="kobo.161.2">This is helpful so we can access these words later, one </span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">by one.</span></span></p>
<p><span class="koboSpan" id="kobo.163.1">Next, we need to get a random word from the file and store it in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">baseWord</span></strong><span class="koboSpan" id="kobo.165.1"> property. </span><span class="koboSpan" id="kobo.165.2">Notice that we need to use the ternary operator here. </span><span class="koboSpan" id="kobo.165.3">That’s because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.166.1">randomElement</span></strong><span class="koboSpan" id="kobo.167.1"> function is an optional function. </span><span class="koboSpan" id="kobo.167.2">For this reason, it might not have a word to get, so, we offer an alternative word to keep the code from crashing in case there are no words in the file (this would only happen if the file became corrupt, which </span><span class="No-Break"><span class="koboSpan" id="kobo.168.1">is rare).</span></span></p>
<p><span class="koboSpan" id="kobo.169.1">Finally, if we do come across a problem along the way, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.170.1">assert</span></strong><span class="koboSpan" id="kobo.171.1"> function. </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">assert</span></strong><span class="koboSpan" id="kobo.173.1"> takes two arguments: a condition to check, and a message to display if the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.174.1">false</span></strong><span class="koboSpan" id="kobo.175.1">. </span><span class="koboSpan" id="kobo.175.2">If the condition is </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">false</span></strong><span class="koboSpan" id="kobo.177.1">, the message will be displayed and the app will halt in a debugging environment. </span><span class="koboSpan" id="kobo.177.2">In a production environment, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">assert</span></strong><span class="koboSpan" id="kobo.179.1"> statement will </span><span class="No-Break"><span class="koboSpan" id="kobo.180.1">be ignored.</span></span></p>
<p><span class="koboSpan" id="kobo.181.1">We will use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.182.1">getRandomWord()</span></strong><span class="koboSpan" id="kobo.183.1"> function later to get a random word that the user can play with and try to find new </span><span class="No-Break"><span class="koboSpan" id="kobo.184.1">words from.</span></span></p>
<p><span class="koboSpan" id="kobo.185.1">Okay, that’s all the properties and functions in place, with one function complete. </span></p>
<p><span class="koboSpan" id="kobo.186.1">Now let’s go </span><a id="_idIndexMarker667"/><span class="koboSpan" id="kobo.187.1">into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">App.Swift</span></strong><span class="koboSpan" id="kobo.189.1"> file and create an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">DataModel</span></strong><span class="koboSpan" id="kobo.191.1"> class, and </span><a id="_idIndexMarker668"/><span class="koboSpan" id="kobo.192.1">then inject that instance into </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ContentView</span></strong><span class="koboSpan" id="kobo.194.1"> so that the data model is available from anywhere in </span><span class="No-Break"><span class="koboSpan" id="kobo.195.1">the app:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.196.1">
@main
struct FindWordsApp: App {
    @StateObject private var appData = DataModel()
    
    var body: some Scene {
        WindowGroup {
            ContentView(appData: DataModel())
        }
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.197.1">This should be familiar to you – we have created the </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">DataModel</span></strong><span class="koboSpan" id="kobo.199.1"> instance and passed it into the root view, </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">ContentView</span></strong><span class="koboSpan" id="kobo.201.1">. </span><span class="koboSpan" id="kobo.201.2">We will also get an error because we now need to update </span><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">ContentView</span></strong><span class="koboSpan" id="kobo.203.1">, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.204.1">Previews</span></strong><span class="koboSpan" id="kobo.205.1">. </span><span class="koboSpan" id="kobo.205.2">Let’s add the following modifications in </span><strong class="source-inline"><span class="koboSpan" id="kobo.206.1">ContentView</span></strong><span class="koboSpan" id="kobo.207.1"> and finish off implementing the </span><strong class="source-inline"><span class="koboSpan" id="kobo.208.1">Observable</span></strong><span class="koboSpan" id="kobo.209.1"> object protocol by adding a </span><strong class="source-inline"><span class="koboSpan" id="kobo.210.1">DataModel</span></strong><span class="koboSpan" id="kobo.211.1"> instance so that we can pass the data into </span><span class="No-Break"><span class="koboSpan" id="kobo.212.1">the views:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
@ObservedObject var appData: DataModel
Now let's update the Previews at the bottom of the file 
  too:
ContentView(appData: DataModel())</span></pre>
<p><span class="koboSpan" id="kobo.214.1">Then, let’s add a property to display a random word at the top </span><span class="No-Break"><span class="koboSpan" id="kobo.215.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.216.1">ContentView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.217.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.218.1">
@State var wordToPlayFrom = "Click for Word"</span></pre>
<p><span class="koboSpan" id="kobo.219.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.220.1">wordToPlayFrom</span></strong><span class="koboSpan" id="kobo.221.1"> property will be set to a random word, which will be the user’s word to start playing with and finding new words to make with. </span><span class="koboSpan" id="kobo.221.2">It’s being set to a string that will prompt the user to </span><a id="_idIndexMarker669"/><span class="koboSpan" id="kobo.222.1">start the game. </span></p>
<p><span class="koboSpan" id="kobo.223.1">Okay, our</span><a id="_idIndexMarker670"/><span class="koboSpan" id="kobo.224.1"> data model is now set up here in </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">ContentView</span></strong><span class="koboSpan" id="kobo.226.1">; let’s focus on building out the user </span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">interface next.</span></span></p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor176"/><span class="koboSpan" id="kobo.228.1">Building out the UI by adding a text field and list</span></h1>
<p><span class="koboSpan" id="kobo.229.1">To build </span><a id="_idIndexMarker671"/><span class="koboSpan" id="kobo.230.1">out our UI, first, we’ll add a text field </span><a id="_idIndexMarker672"/><span class="koboSpan" id="kobo.231.1">view so the user can enter their answers, and then we’ll add a list view, so all of the user’s words can be listed in </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">a table.</span></span></p>
<p><span class="koboSpan" id="kobo.233.1">To do that, go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.234.1">body</span></strong><span class="koboSpan" id="kobo.235.1"> property of </span><strong class="source-inline"><span class="koboSpan" id="kobo.236.1">ContentView</span></strong><span class="koboSpan" id="kobo.237.1"> and remove the existing boilerplate code for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.238.1">Text</span></strong><span class="koboSpan" id="kobo.239.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">Image</span></strong><span class="koboSpan" id="kobo.241.1"> views, and add the </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.243.1">
//MARK: - TEXTFIELD - LIST TABLE
    VStack(alignment: .center, spacing: 15) {
       //MARK: - TEXT FIELD AND LIST
            TextField("Enter your word", text: 
              $appData.userEnteredWord)
                .textInputAutocapitalization(.never)
             .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal, 55)
                .onSubmit(appData.addWordToList)
         ///List view to display the user input
         List(appData.userEnteredWordsArray, id: \.self) {
           word in
                Text(word)
            .foregroundColor(.black)
            .font(.system(size: 18))
        }
        .frame(width: 285, height: 190, alignment: .center)
        .cornerRadius(10)
        .foregroundColor(Color.blue)
        .font(.system(size: 50))
    }</span></pre>
<p><span class="koboSpan" id="kobo.244.1">Here, we added a text field so we can grab the user’s input, while changing </span><strong class="source-inline"><span class="koboSpan" id="kobo.245.1">.textInputAutocapitalization</span></strong><span class="koboSpan" id="kobo.246.1"> to </span><strong class="source-inline"><span class="koboSpan" id="kobo.247.1">never</span></strong><span class="koboSpan" id="kobo.248.1"> so that auto-capitalize won’t capitalize what the user types into the text field. </span><span class="koboSpan" id="kobo.248.2">The word files we imported into the project are all </span><a id="_idIndexMarker673"/><span class="koboSpan" id="kobo.249.1">written in lowercase, so turning auto-capitalization</span><a id="_idIndexMarker674"/><span class="koboSpan" id="kobo.250.1"> off helps with accessing those words and checking </span><span class="No-Break"><span class="koboSpan" id="kobo.251.1">the letters.</span></span></p>
<p><span class="koboSpan" id="kobo.252.1">Next, the text field gets a little styling and a little padding, before we call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">onSubmit</span></strong><span class="koboSpan" id="kobo.254.1"> modifier and pass the </span><strong class="source-inline"><span class="koboSpan" id="kobo.255.1">addWordToList</span></strong><span class="koboSpan" id="kobo.256.1"> property into it. </span><span class="koboSpan" id="kobo.256.2">What this modifier does is add an action to be performed when the user types in a word and hits </span><em class="italic"><span class="koboSpan" id="kobo.257.1">Enter</span></em><span class="koboSpan" id="kobo.258.1">. </span><span class="koboSpan" id="kobo.258.2">That action being performed is a call to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.259.1">addWordToList</span></strong><span class="koboSpan" id="kobo.260.1"> method that we have in our data model. </span><span class="koboSpan" id="kobo.260.2">That method will process the user’s input and see whether their word is allowed to be used based on certain criteria, such as whether the word is even possible in the chosen language and whether they make it from the letters present in the </span><span class="No-Break"><span class="koboSpan" id="kobo.261.1">base word.</span></span></p>
<p><span class="koboSpan" id="kobo.262.1">Notice that in order to access our data model, we have to use our </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">DataModel</span></strong><span class="koboSpan" id="kobo.264.1"> instance’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.265.1">appData</span></strong><span class="koboSpan" id="kobo.266.1"> that we created at the top of this file; this gives us access to all the methods and properties we created </span><span class="No-Break"><span class="koboSpan" id="kobo.267.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.268.1">DataModel</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.270.1">Continuing with the code, we then move on to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">List</span></strong><span class="koboSpan" id="kobo.272.1"> view, which creates a list to display the user’s words. </span><span class="koboSpan" id="kobo.272.2">This uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">id</span></strong><span class="koboSpan" id="kobo.274.1"> parameter to uniquely identify each word in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.275.1">guessedWords</span></strong><span class="koboSpan" id="kobo.276.1"> array. </span><span class="koboSpan" id="kobo.276.2">When we iterate (loop) through </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.278.1">, we need a way of identifying its content – each element in that array has to be unique to be able to use it and fortunately, every word is indeed unique (no two words are the same). </span><span class="koboSpan" id="kobo.278.2">So, what the </span><strong class="source-inline"><span class="koboSpan" id="kobo.279.1">id</span></strong><span class="koboSpan" id="kobo.280.1"> parameter you see here is saying is that it will </span><a id="_idIndexMarker675"/><span class="koboSpan" id="kobo.281.1">use the word’s own name as its </span><a id="_idIndexMarker676"/><span class="koboSpan" id="kobo.282.1">identifier (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.283.1">self</span></strong><span class="koboSpan" id="kobo.284.1"> part), and we can access the elements in the array. </span></p>
<p><span class="koboSpan" id="kobo.285.1">After that, we did a bit more styling. </span><span class="koboSpan" id="kobo.285.2">We set the text color of the words to </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">black</span></strong><span class="koboSpan" id="kobo.287.1"> and their size to </span><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">18</span></strong><span class="koboSpan" id="kobo.289.1"> points. </span><span class="koboSpan" id="kobo.289.2">Then, we set the frame size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.290.1">List</span></strong><span class="koboSpan" id="kobo.291.1"> view, as well as changing the color to </span><strong class="source-inline"><span class="koboSpan" id="kobo.292.1">blue</span></strong><span class="koboSpan" id="kobo.293.1"> and providing a </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">cornerRadius</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.295.1"> property.</span></span></p>
<p><span class="koboSpan" id="kobo.296.1">Now, if we run the app, we can type words into the text field, but when we press </span><em class="italic"><span class="koboSpan" id="kobo.297.1">Enter</span></em><span class="koboSpan" id="kobo.298.1">, the word isn’t being placed into the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.299.1">List</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.300.1"> view:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer163">
<span class="koboSpan" id="kobo.301.1"><img alt="Figure 12.1: Words typed into the text field " src="image/B18674_12_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.302.1">Figure 12.1: Words typed into the text field</span></p>
<p><span class="koboSpan" id="kobo.303.1">The reason the </span><a id="_idIndexMarker677"/><span class="koboSpan" id="kobo.304.1">words are not going into the list is that we</span><a id="_idIndexMarker678"/><span class="koboSpan" id="kobo.305.1"> just haven’t filled out the empty </span><strong class="source-inline"><span class="koboSpan" id="kobo.306.1">addWordToList</span></strong><span class="koboSpan" id="kobo.307.1"> function in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.308.1">DataModel</span></strong><span class="koboSpan" id="kobo.309.1"> class yet. </span><span class="koboSpan" id="kobo.309.2">Let’s fill out that method now with some code that will allow the user’s typed-in word to be displayed inside </span><span class="No-Break"><span class="koboSpan" id="kobo.310.1">the list:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.311.1">
func addWordToList() {
    let usersWord = userEnteredWord.trimmingCharacters(in:
      .whitespacesAndNewlines).lowercased()
    //guard against one or two letter words - they are too 
      easy
    guard usersWord.count &gt; 1 else {
        return
    }
    userEnteredWordsArray.insert(usersWord, at: 0)
    userEnteredWord = ""
  }</span></pre>
<p><span class="koboSpan" id="kobo.312.1">Here, we</span><a id="_idIndexMarker679"/><span class="koboSpan" id="kobo.313.1"> created a </span><strong class="source-inline"><span class="koboSpan" id="kobo.314.1">userWord</span></strong><span class="koboSpan" id="kobo.315.1"> constant, which</span><a id="_idIndexMarker680"/><span class="koboSpan" id="kobo.316.1"> is going to store the new word that the user adds to the list. </span><span class="koboSpan" id="kobo.316.2">We first check the user’s word for white spaces. </span><span class="koboSpan" id="kobo.316.3">This way, if the user types some extra spaces in the text field by mistake, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">trimmingCharacters</span></strong><span class="koboSpan" id="kobo.318.1"> function will eliminate them. </span><span class="koboSpan" id="kobo.318.2">Next, the word is made lowercase using the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">lowercased</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1"> function.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">Then, we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.322.1">guard</span></strong><span class="koboSpan" id="kobo.323.1"> statement, which is very similar to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.324.1">if</span></strong><span class="koboSpan" id="kobo.325.1"> statement, which checks to see whether the word that the user entered has more than one letter. </span><span class="koboSpan" id="kobo.325.2">If it does, it will proceed to the next line of code. </span><span class="koboSpan" id="kobo.325.3">Otherwise, the method will return right there and not run any more code. </span><span class="koboSpan" id="kobo.325.4">When the code “returns” from a method, that means the code is finished running that method, and even if there’s more code inside that method, it won’t run. </span><span class="koboSpan" id="kobo.325.5">The reason why we’re checking to see whether there need to be at least two letters in the user’s word is because those are too easy. </span><span class="koboSpan" id="kobo.325.6">Even though there aren’t many one-letter words in any given language, why not simply remove </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">them altogether?</span></span></p>
<p><span class="koboSpan" id="kobo.327.1">After the user’s word has been trimmed and made lowercase, it’s then added to </span><strong class="source-inline"><span class="koboSpan" id="kobo.328.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.329.1">, and inserted at index zero using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.330.1">insert(at)</span></strong><span class="koboSpan" id="kobo.331.1"> method. </span><span class="koboSpan" id="kobo.331.2">This index is at the beginning of the array, and the reason why we insert the word at the beginning and don’t append it to the end of the array is that we want each new word to appear at the top of the list so that it’s </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">readily visible.</span></span></p>
<p><span class="koboSpan" id="kobo.333.1">Finally, we set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.334.1">newWord</span></strong><span class="koboSpan" id="kobo.335.1"> property back to an empty string, which effectively clears out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.336.1">Text</span></strong><span class="koboSpan" id="kobo.337.1"> view when the user presses </span><em class="italic"><span class="koboSpan" id="kobo.338.1">Enter</span></em><span class="koboSpan" id="kobo.339.1">, so they can type in another word </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">when ready.</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Now, if we run the project, we can see that when we type words into the text field and press </span><em class="italic"><span class="koboSpan" id="kobo.342.1">Enter</span></em><span class="koboSpan" id="kobo.343.1">, they now appear in </span><span class="No-Break"><span class="koboSpan" id="kobo.344.1">the list:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer164">
<span class="koboSpan" id="kobo.345.1"><img alt="Figure 12.2: Words are now entered into the list " src="image/B18674_12_02.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.346.1">Figure 12.2: Words are now entered into the list</span></p>
<p><span class="koboSpan" id="kobo.347.1">New words will </span><a id="_idIndexMarker681"/><span class="koboSpan" id="kobo.348.1">appear at the top of the list. </span><span class="koboSpan" id="kobo.348.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">List</span></strong><span class="koboSpan" id="kobo.350.1"> view, by </span><a id="_idIndexMarker682"/><span class="koboSpan" id="kobo.351.1">default, is also scrollable, so the user can easily scroll up and down to see previously </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">entered words.</span></span></p>
<p><span class="koboSpan" id="kobo.353.1">Let’s continue with the UI and display the number of characters each </span><span class="No-Break"><span class="koboSpan" id="kobo.354.1">word contains.</span></span></p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor177"/><span class="koboSpan" id="kobo.355.1">Displaying a character count next to each word in the list</span></h1>
<p><span class="koboSpan" id="kobo.356.1">I also </span><a id="_idIndexMarker683"/><span class="koboSpan" id="kobo.357.1">want to add a number next to each word that indicates how many letters are in the word that the user has entered. </span><span class="koboSpan" id="kobo.357.2">Later, we will take this number from each word and add them together to get an average of how the user is doing in terms of the length of words they </span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">are entering.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">We can put this number inside a circle, and luckily this is very easy, as Swift gives us system images of circles with numbers in them that are already created; all we have to do is call them up. </span><span class="koboSpan" id="kobo.359.2">So, back in </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">ContentView</span></strong><span class="koboSpan" id="kobo.361.1">, then inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.362.1">List</span></strong><span class="koboSpan" id="kobo.363.1"> view, let’s put the </span><strong class="source-inline"><span class="koboSpan" id="kobo.364.1">Text</span></strong><span class="koboSpan" id="kobo.365.1"> view inside of an </span><strong class="source-inline"><span class="koboSpan" id="kobo.366.1">HStack</span></strong><span class="koboSpan" id="kobo.367.1"> (so they are side by side), and add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.368.1">Image</span></strong><span class="koboSpan" id="kobo.369.1"> view for the </span><span class="No-Break"><span class="koboSpan" id="kobo.370.1">number circle:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.371.1">
List(guessedWordsArray, id: \.self) { word in
        HStack {
            Image(systemName: 
              "\(word.count).circle")
            Text(word)
        } .foregroundColor(.black)
          .font(.system(size: 18))
    }</span></pre>
<p><span class="koboSpan" id="kobo.372.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.373.1">Image</span></strong><span class="koboSpan" id="kobo.374.1"> view gets a system image of a circle. </span><span class="koboSpan" id="kobo.374.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.375.1">word.count</span></strong><span class="koboSpan" id="kobo.376.1"> code statement gets the number of letters in the user’s word and displays that number inside of a circle. </span><span class="koboSpan" id="kobo.376.2">Now if we run the code, all the words that are typed in will have their letter counts displayed in a circle to the left of the </span><span class="No-Break"><span class="koboSpan" id="kobo.377.1">given </span></span><span class="No-Break"><a id="_idIndexMarker684"/></span><span class="No-Break"><span class="koboSpan" id="kobo.378.1">words:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer165">
<span class="koboSpan" id="kobo.379.1"><img alt="Figure 12.3: The letter count displayed in a circle " src="image/B18674_12_03.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.380.1">Figure 12.3: The letter count displayed in a circle</span></p>
<p><span class="koboSpan" id="kobo.381.1">Let’s move on to now checking the user’s words </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">for duplicates.</span></span></p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor178"/><span class="koboSpan" id="kobo.383.1">Checking the entered words for duplicates</span></h1>
<p><span class="koboSpan" id="kobo.384.1">Now that we’re </span><a id="_idIndexMarker685"/><span class="koboSpan" id="kobo.385.1">displaying the words that the user enters, how about we check them to make sure they are real words in a dictionary and that there are no duplicate words in the list? </span><span class="koboSpan" id="kobo.385.2">We have all the function stubs in place for these checks, so let’s start filling </span><span class="No-Break"><span class="koboSpan" id="kobo.386.1">them out.</span></span></p>
<p><span class="koboSpan" id="kobo.387.1">The first function we’ll fill out is </span><strong class="source-inline"><span class="koboSpan" id="kobo.388.1">isWordDuplicate</span></strong><span class="koboSpan" id="kobo.389.1">, which we’ll modify to look like this: </span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.390.1">
 func isWordDuplicate(word: String) -&gt; Bool {
    return userEnteredWordsArray.filter { $0 == word 
      }.isEmpty
  }</span></pre>
<p><span class="koboSpan" id="kobo.391.1">What this does is to check </span><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.393.1"> to see whether it contains the word the user has typed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.394.1">Text</span></strong><span class="koboSpan" id="kobo.395.1"> field. </span><span class="koboSpan" id="kobo.395.2">Here’s how it works. </span><span class="koboSpan" id="kobo.395.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.396.1">return</span></strong><span class="koboSpan" id="kobo.397.1"> statement in this function uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">filter</span></strong><span class="koboSpan" id="kobo.399.1"> method on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.401.1"> array. </span><span class="koboSpan" id="kobo.401.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.402.1">filter</span></strong><span class="koboSpan" id="kobo.403.1"> method takes a closure as its argument, which is evaluated for each element of the array. </span><span class="koboSpan" id="kobo.403.2">In this case, the closure checks whether the current element of the array (</span><strong class="source-inline"><span class="koboSpan" id="kobo.404.1">$0</span></strong><span class="koboSpan" id="kobo.405.1">) is equal to the word passed as an argument to </span><span class="No-Break"><span class="koboSpan" id="kobo.406.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.407.1">The result of this </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">filter</span></strong><span class="koboSpan" id="kobo.409.1"> operation is a new array that contains all the elements of </span><strong class="source-inline"><span class="koboSpan" id="kobo.410.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.411.1"> that match the given condition. </span><span class="koboSpan" id="kobo.411.2">If this new array is not empty, that means that the word already exists in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">userEnteredWordsArray</span></strong><span class="koboSpan" id="kobo.413.1">, so the function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">false</span></strong><span class="koboSpan" id="kobo.415.1">. </span><span class="koboSpan" id="kobo.415.2">If the new array is empty, that means that the word is not duplicated, so the function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">true</span></strong><span class="koboSpan" id="kobo.417.1">. </span><span class="koboSpan" id="kobo.417.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">isEmpty</span></strong><span class="koboSpan" id="kobo.419.1"> property of the array is used to check whether the array </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">is empty.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">Now, just filling out the function is not enough to have it check for duplicates; we have to call this function inside of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.422.1">addWordToList</span></strong><span class="koboSpan" id="kobo.423.1"> function so that we can use it to check the new </span><a id="_idIndexMarker686"/><span class="koboSpan" id="kobo.424.1">words before they are added to the list. </span><span class="koboSpan" id="kobo.424.2">Let’s do that now – inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">addWordToList</span></strong><span class="koboSpan" id="kobo.426.1"> function, add the following, right after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.427.1">userWord</span></strong><span class="koboSpan" id="kobo.428.1"> instance </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">is created:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
func addWordToList() {
    let usersWord = 
      userEnteredWord.lowercased().trimmingCharacters(in: 
      .whitespacesAndNewlines)
    //is the word a duplicate
   if !isWordDuplicate(word: usersWord) {
    displayErrorMessage(messageTitle: "You already used 
      this word", description: "Keep looking!")
    return
        }
            •••••••••
}</span></pre>
<p><span class="koboSpan" id="kobo.431.1">This code checks the </span><strong class="source-inline"><span class="koboSpan" id="kobo.432.1">isWordDuplicate</span></strong><span class="koboSpan" id="kobo.433.1"> function to see whether it’s returning </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">true</span></strong><span class="koboSpan" id="kobo.435.1"> by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.436.1">!</span></strong><span class="koboSpan" id="kobo.437.1"> operator in front of it. </span><span class="koboSpan" id="kobo.437.2">Remember, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.438.1">isWordDuplicate</span></strong><span class="koboSpan" id="kobo.439.1"> function returns a Boolean value, either </span><strong class="source-inline"><span class="koboSpan" id="kobo.440.1">true</span></strong><span class="koboSpan" id="kobo.441.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.442.1">false</span></strong><span class="koboSpan" id="kobo.443.1">, so if this function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.444.1">false</span></strong><span class="koboSpan" id="kobo.445.1">, then the </span><strong class="source-inline"><span class="koboSpan" id="kobo.446.1">if</span></strong><span class="koboSpan" id="kobo.447.1"> statement runs the code in its body, which is another function called </span><strong class="source-inline"><span class="koboSpan" id="kobo.448.1">displayErrorMessage</span></strong><span class="koboSpan" id="kobo.449.1">. </span><span class="koboSpan" id="kobo.449.2">This will display an error message to the user telling them that their word is a duplicate (we haven’t set up our error messaging system yet, but we will soon!). </span></p>
<p><span class="koboSpan" id="kobo.450.1">Now I’d like you to come back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.451.1">ContentView</span></strong><span class="koboSpan" id="kobo.452.1"> and run the app, enter a word, and see it appear in the list. </span><span class="koboSpan" id="kobo.452.2">Then, try entering that same word again, and you’ll notice you’re not able to. </span><span class="koboSpan" id="kobo.452.3">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.453.1">guard</span></strong><span class="koboSpan" id="kobo.454.1"> statement stops it from happening because it checks and sees that the</span><a id="_idIndexMarker687"/><span class="koboSpan" id="kobo.455.1"> word has already been entered into the list. </span></p>
<p><span class="koboSpan" id="kobo.456.1">Next, we want to add a button that will grab a random word from the word files we imported into the project, which gives the user a word to play with and try to find </span><span class="No-Break"><span class="koboSpan" id="kobo.457.1">words from.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor179"/><span class="koboSpan" id="kobo.458.1">Adding a random word with a button press</span></h1>
<p><span class="koboSpan" id="kobo.459.1">Before we</span><a id="_idIndexMarker688"/><span class="koboSpan" id="kobo.460.1"> continue with the methods and fill them out, we need a button to provide a random word that the user can play off and try to find words from. </span><span class="koboSpan" id="kobo.460.2">After all, it’s not a challenge to just type random words and for them to appear in the </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">list currently.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">We’ll start by supplying a file of thousands of seven-letter words, from which one will be shown on the screen randomly when a button is pressed. </span><span class="koboSpan" id="kobo.462.2">We will also give the user the choice to choose a seven-, eight-, or nine-letter word, and the option to select another language later, but right now, let’s just stick with seven-letter </span><span class="No-Break"><span class="koboSpan" id="kobo.463.1">English words.</span></span></p>
<p><span class="koboSpan" id="kobo.464.1">If you haven’t done so already, go to the GitHub folder, select the </span><strong class="source-inline"><span class="koboSpan" id="kobo.465.1">Language</span></strong><span class="koboSpan" id="kobo.466.1"> files folder, and drop the contents of that folder into the Project navigator. </span><span class="koboSpan" id="kobo.466.2">Once done, select them all, right-click, and choose </span><strong class="bold"><span class="koboSpan" id="kobo.467.1">New Group From Selection</span></strong><span class="koboSpan" id="kobo.468.1">. </span><span class="koboSpan" id="kobo.468.2">Then, name the group </span><strong class="source-inline"><span class="koboSpan" id="kobo.469.1">Languages</span></strong><span class="koboSpan" id="kobo.470.1"> – this helps keep everything organized in the Project navigator. </span></p>
<p><span class="koboSpan" id="kobo.471.1">Now those files are added to the project and we have already built out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.472.1">getRandomWord</span></strong><span class="koboSpan" id="kobo.473.1"> function, which will get us a random word from a specified file, so now we need to call this function so that we can show the word to the user – we can do that with a button. </span><span class="koboSpan" id="kobo.473.2">Add the</span><a id="_idIndexMarker689"/><span class="koboSpan" id="kobo.474.1"> following code directly in </span><strong class="source-inline"><span class="koboSpan" id="kobo.475.1">VStack</span></strong><span class="koboSpan" id="kobo.476.1">, above the </span><strong class="source-inline"><span class="koboSpan" id="kobo.477.1">Text</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.478.1">field code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.479.1">
 //MARK: - BUTTON
        Button(action: {
            appData.getRandomWord()
            wordToPlayFrom = appData.baseWord
        }){
            ZStack {
                Image("background").resizable()
                    .renderingMode(.original)
                    .frame(width: 125, height: 50)
                    .cornerRadius(15)
                Text("New Word")
                    .foregroundColor(.white)
             }
        }.padding(7)
            .shadow(color: .black, radius: 2, x: 1, y: 1)
            .shadow(color: .black, radius: 2, x: -1, y: -1)
        
        Text(wordToPlayFrom)</span></pre>
<p><span class="koboSpan" id="kobo.480.1">This code creates a button. </span><span class="koboSpan" id="kobo.480.2">Inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.481.1">action</span></strong><span class="koboSpan" id="kobo.482.1"> parameter for the button, we use our </span><strong class="source-inline"><span class="koboSpan" id="kobo.483.1">appData</span></strong><span class="koboSpan" id="kobo.484.1"> instance and call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.485.1">getRandomWord</span></strong><span class="koboSpan" id="kobo.486.1"> function. </span><span class="koboSpan" id="kobo.486.2">We also set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.487.1">wordToPlayFrom</span></strong><span class="koboSpan" id="kobo.488.1"> property to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.489.1">baseWord</span></strong><span class="koboSpan" id="kobo.490.1"> value because </span><strong class="source-inline"><span class="koboSpan" id="kobo.491.1">baseWord</span></strong><span class="koboSpan" id="kobo.492.1"> contains the random word that will appear on </span><span class="No-Break"><span class="koboSpan" id="kobo.493.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.494.1">Now every time the button is pressed, a randomized word from our text file is placed into </span><strong class="source-inline"><span class="koboSpan" id="kobo.495.1">baseWord</span></strong><span class="koboSpan" id="kobo.496.1">, which then gets placed into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">wordToPlayFrom</span></strong><span class="koboSpan" id="kobo.498.1"> property to </span><span class="No-Break"><span class="koboSpan" id="kobo.499.1">be displayed.</span></span></p>
<p><span class="koboSpan" id="kobo.500.1">At the end of the button </span><a id="_idIndexMarker690"/><span class="koboSpan" id="kobo.501.1">code, we create a </span><strong class="source-inline"><span class="koboSpan" id="kobo.502.1">Text</span></strong><span class="koboSpan" id="kobo.503.1"> view that displays </span><strong class="source-inline"><span class="koboSpan" id="kobo.504.1">wordToPlayFrom</span></strong><span class="koboSpan" id="kobo.505.1"> on the screen. </span><span class="koboSpan" id="kobo.505.2">The button is then styled with a wood background image, a slight corner radius, a little bit of shadow, and the words </span><span class="No-Break"><strong class="bold"><span class="koboSpan" id="kobo.506.1">New Word</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.507.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.508.1">After adding that code, the button should look </span><span class="No-Break"><span class="koboSpan" id="kobo.509.1">like this:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer166">
<span class="koboSpan" id="kobo.510.1"><img alt="Figure 12.4: A button to create a random word " src="image/B18674_12_04.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.511.1">Figure 12.4: A button to create a random word</span></p>
<p><span class="koboSpan" id="kobo.512.1">Now, press the </span><a id="_idIndexMarker691"/><span class="koboSpan" id="kobo.513.1">button, and you will get a random word that a user can work with. </span><span class="koboSpan" id="kobo.513.2">Also, notice that when you press the button, it actually looks like it’s being pressed down; we get this behavior by default, which really adds to the </span><span class="No-Break"><span class="koboSpan" id="kobo.514.1">user experience.</span></span></p>
<p><span class="koboSpan" id="kobo.515.1">The game is coming along, but we want to continue checking the word the user enters to see whether it can be made from the randomized word. </span><span class="koboSpan" id="kobo.515.2">Let’s do that </span><span class="No-Break"><span class="koboSpan" id="kobo.516.1">up next.</span></span></p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor180"/><span class="koboSpan" id="kobo.517.1">Checking if the user’s entered word is possible</span></h1>
<p><span class="koboSpan" id="kobo.518.1">Looking for</span><a id="_idIndexMarker692"/><span class="koboSpan" id="kobo.519.1"> duplicate words is not enough. </span><span class="koboSpan" id="kobo.519.2">Now that we have generated a random seven-letter word, we want to make sure that the user’s entered word can be made from the letters that are in the random word. </span><span class="koboSpan" id="kobo.519.3">For example, if the random word is </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">bookend</span></strong><span class="koboSpan" id="kobo.521.1"> and the user types in </span><strong class="source-inline"><span class="koboSpan" id="kobo.522.1">books</span></strong><span class="koboSpan" id="kobo.523.1">, that would be invalid because </span><strong class="source-inline"><span class="koboSpan" id="kobo.524.1">s</span></strong><span class="koboSpan" id="kobo.525.1"> is not in the </span><span class="No-Break"><span class="koboSpan" id="kobo.526.1">random word.</span></span></p>
<p><span class="koboSpan" id="kobo.527.1">Let’s go back to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.528.1">DataModel</span></strong><span class="koboSpan" id="kobo.529.1"> class and add code to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.530.1">isWordFoundInBaseWord</span></strong><span class="koboSpan" id="kobo.531.1"> function so that we can check that the word can be made </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">from </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.533.1">baseWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.535.1">
  //check to see if the word is possible given the baseWord 
    letters
   func isWordFoundInBaseWord(userGuessWord: String) -&gt; 
     Bool {
        var comparisonWord = baseWord
        return userGuessWord.allSatisfy { letter in
            guard let position = 
              comparisonWord.firstIndex(of: letter) else {
                return false
            }
            comparisonWord.remove(at: position)
            return true
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.536.1">Here’s how this function works. </span><span class="koboSpan" id="kobo.536.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.537.1">isWordFoundInBaseWord</span></strong><span class="koboSpan" id="kobo.538.1"> function takes a </span><strong class="source-inline"><span class="koboSpan" id="kobo.539.1">String</span></strong><span class="koboSpan" id="kobo.540.1"> parameter, </span><strong class="source-inline"><span class="koboSpan" id="kobo.541.1">userGuessWord</span></strong><span class="koboSpan" id="kobo.542.1">, and returns a </span><strong class="source-inline"><span class="koboSpan" id="kobo.543.1">Bool</span></strong><span class="koboSpan" id="kobo.544.1"> value indicating whether or not </span><strong class="source-inline"><span class="koboSpan" id="kobo.545.1">userGuessWord</span></strong><span class="koboSpan" id="kobo.546.1"> can be made by removing letters from the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.547.1">baseWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.548.1"> string.</span></span></p>
<p><span class="koboSpan" id="kobo.549.1">The function</span><a id="_idIndexMarker693"/><span class="koboSpan" id="kobo.550.1"> starts by creating a </span><strong class="source-inline"><span class="koboSpan" id="kobo.551.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.552.1"> variable equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.553.1">baseWord</span></strong><span class="koboSpan" id="kobo.554.1">. </span><span class="koboSpan" id="kobo.554.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.555.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.556.1"> variable is used to keep track of the remaining letters in </span><strong class="source-inline"><span class="koboSpan" id="kobo.557.1">baseWord</span></strong><span class="koboSpan" id="kobo.558.1"> that haven’t been matched </span><span class="No-Break"><span class="koboSpan" id="kobo.559.1">by </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.560.1">userGuessWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.561.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.562.1">Next, the function uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.563.1">allSatisfy</span></strong><span class="koboSpan" id="kobo.564.1"> method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.565.1">String</span></strong><span class="koboSpan" id="kobo.566.1"> to check that all the letters in </span><strong class="source-inline"><span class="koboSpan" id="kobo.567.1">userGuessWord</span></strong><span class="koboSpan" id="kobo.568.1"> can be found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.569.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.570.1">. </span><span class="koboSpan" id="kobo.570.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.571.1">allSatisfy</span></strong><span class="koboSpan" id="kobo.572.1"> method iterates over each character in the string and returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.573.1">true</span></strong><span class="koboSpan" id="kobo.574.1"> if the closure passed to it returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.575.1">true</span></strong><span class="koboSpan" id="kobo.576.1"> for </span><span class="No-Break"><span class="koboSpan" id="kobo.577.1">all characters.</span></span></p>
<p><span class="koboSpan" id="kobo.578.1">The closure takes a single parameter letter, representing the current letter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.579.1">userGuessWord</span></strong><span class="koboSpan" id="kobo.580.1"> being processed. </span><span class="koboSpan" id="kobo.580.2">It first uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.581.1">firstIndex(of:)</span></strong><span class="koboSpan" id="kobo.582.1"> method to find the index of a letter in </span><strong class="source-inline"><span class="koboSpan" id="kobo.583.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.584.1">. </span><span class="koboSpan" id="kobo.584.2">If a letter is not found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.585.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.586.1">, the closure immediately returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.587.1">false</span></strong><span class="koboSpan" id="kobo.588.1">, which will make the overall </span><strong class="source-inline"><span class="koboSpan" id="kobo.589.1">allSatisfy</span></strong><span class="koboSpan" id="kobo.590.1"> call </span><span class="No-Break"><span class="koboSpan" id="kobo.591.1">return </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.592.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.593.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.594.1">If a letter is found in </span><strong class="source-inline"><span class="koboSpan" id="kobo.595.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.596.1">, the closure removes that letter from </span><strong class="source-inline"><span class="koboSpan" id="kobo.597.1">comparisonWord</span></strong><span class="koboSpan" id="kobo.598.1"> using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.599.1">remove(at:)</span></strong><span class="koboSpan" id="kobo.600.1"> method. </span><span class="koboSpan" id="kobo.600.2">Finally, the closure </span><span class="No-Break"><span class="koboSpan" id="kobo.601.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.602.1">true</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.603.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.604.1">If the </span><strong class="source-inline"><span class="koboSpan" id="kobo.605.1">allSatisfy</span></strong><span class="koboSpan" id="kobo.606.1"> call returns true, the function returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.607.1">true</span></strong><span class="koboSpan" id="kobo.608.1">, indicating that </span><strong class="source-inline"><span class="koboSpan" id="kobo.609.1">userGuessWord</span></strong><span class="koboSpan" id="kobo.610.1"> can be made by removing letters from </span><strong class="source-inline"><span class="koboSpan" id="kobo.611.1">baseWord</span></strong><span class="koboSpan" id="kobo.612.1">. </span><span class="koboSpan" id="kobo.612.2">If </span><strong class="source-inline"><span class="koboSpan" id="kobo.613.1">allSatisfy</span></strong><span class="koboSpan" id="kobo.614.1"> returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.615.1">false</span></strong><span class="koboSpan" id="kobo.616.1">, the function </span><span class="No-Break"><span class="koboSpan" id="kobo.617.1">returns </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.618.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.619.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.620.1">The logic for this can be a little tricky to understand at first, but it basically looks at each letter in the user’s word and compares it to </span><strong class="source-inline"><span class="koboSpan" id="kobo.621.1">baseWord</span></strong><span class="koboSpan" id="kobo.622.1">. </span><span class="koboSpan" id="kobo.622.2">Any letter that’s not in </span><strong class="source-inline"><span class="koboSpan" id="kobo.623.1">baseWord</span></strong><span class="koboSpan" id="kobo.624.1"> will cause the method to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.625.1">false</span></strong><span class="koboSpan" id="kobo.626.1">, meaning the user’s word </span><span class="No-Break"><span class="koboSpan" id="kobo.627.1">is incorrect.</span></span></p>
<p><span class="koboSpan" id="kobo.628.1">Now that we have this method written out, let’s put it to work. </span><span class="koboSpan" id="kobo.628.2">We need to call this method in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.629.1">addWordToList</span></strong><span class="koboSpan" id="kobo.630.1"> function, so place this code after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.631.1">if</span></strong><span class="koboSpan" id="kobo.632.1"> statement’s </span><span class="No-Break"><span class="koboSpan" id="kobo.633.1">closing brace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.634.1">
func addWordToList() {
        let usersWord = 
          userEnteredWord.trimmingCharacters(in: 
          .whitespacesAndNewlines).lowercased()
        //is the word a duplicate
        if !isWordDuplicate(word: usersWord) {
        displayErrorMessage(messageTitle: "You already used
          this word", description: "Keep looking!")
        return
        }
   </span><strong class="bold"><span class="koboSpan" id="kobo.635.1">     //is the word possible given your base word letters </span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.636.1">          to work with?</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.637.1">        guard isWordFoundInBaseWord(userGuessWord:</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.638.1">          usersWord) else {</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.639.1">            displayErrorMessage(messageTitle: "This word is</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.640.1">            not possible", description: "Create only words</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.641.1">            from the letters in the given word")</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.642.1">            return</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.643.1">        }</span></strong><span class="koboSpan" id="kobo.644.1">
            userEnteredWordsArray.insert(usersWord, at: 0)
            userEnteredWord = ""        
        }</span></pre>
<p><span class="koboSpan" id="kobo.645.1">What we’re doing</span><a id="_idIndexMarker694"/><span class="koboSpan" id="kobo.646.1"> here is calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.647.1">isWordFoundInBaseWord</span></strong><span class="koboSpan" id="kobo.648.1"> function, and it will have </span><strong class="source-inline"><span class="koboSpan" id="kobo.649.1">userGuessedWord</span></strong><span class="koboSpan" id="kobo.650.1"> passed into it. </span><span class="koboSpan" id="kobo.650.2">The function checks whether the word is possible to create – if not, we’re going to display an alert message to the user using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.651.1">displayErrorMessage</span></strong><span class="koboSpan" id="kobo.652.1"> method (again, the alert messages will be </span><span class="No-Break"><span class="koboSpan" id="kobo.653.1">created later).</span></span></p>
<p><span class="koboSpan" id="kobo.654.1">Let’s try this out. </span><span class="koboSpan" id="kobo.654.2">Come back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.655.1">ContentView</span></strong><span class="koboSpan" id="kobo.656.1"> and run the program. </span><span class="koboSpan" id="kobo.656.2">You will see that you cannot enter a word unless those letters are also present </span><span class="No-Break"><span class="koboSpan" id="kobo.657.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.658.1">baseWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.659.1">:</span></span></p>
<p class="IMG---Figure"> </p>
<div>
<div class="IMG---Figure" id="_idContainer167">
<span class="koboSpan" id="kobo.660.1"><img alt="Figure 12.5: Checking whether the word is possible using the base word’s letters " src="image/B18674_12_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.661.1">Figure 12.5: Checking whether the word is possible using the base word’s letters</span></p>
<p><span class="koboSpan" id="kobo.662.1">Here, I entered </span><strong class="source-inline"><span class="koboSpan" id="kobo.663.1">set</span></strong><span class="koboSpan" id="kobo.664.1"> into </span><a id="_idIndexMarker695"/><span class="koboSpan" id="kobo.665.1">the list because that can be made from </span><strong class="bold"><span class="koboSpan" id="kobo.666.1">settler</span></strong><span class="koboSpan" id="kobo.667.1">, but I could not enter </span><strong class="source-inline"><span class="koboSpan" id="kobo.668.1">sent</span></strong><span class="koboSpan" id="kobo.669.1"> because there is no </span><strong class="source-inline"><span class="koboSpan" id="kobo.670.1">n</span></strong><span class="koboSpan" id="kobo.671.1"> in </span><strong class="bold"><span class="koboSpan" id="kobo.672.1">settler</span></strong><span class="koboSpan" id="kobo.673.1">. </span><span class="koboSpan" id="kobo.673.2">So, we can see that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.674.1">isWordFoundInBaseWord</span></strong><span class="koboSpan" id="kobo.675.1"> function is </span><span class="No-Break"><span class="koboSpan" id="kobo.676.1">working perfectly.</span></span></p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor181"/><span class="koboSpan" id="kobo.677.1">Checking whether the user’s entered word is a real word</span></h1>
<p><span class="koboSpan" id="kobo.678.1">There is one</span><a id="_idIndexMarker696"/><span class="koboSpan" id="kobo.679.1"> final check we need to do, and that is to see whether the word is an actual word in the dictionary. </span><span class="koboSpan" id="kobo.679.2">This check is important because the user could rearrange letters in </span><strong class="source-inline"><span class="koboSpan" id="kobo.680.1">baseWord</span></strong><span class="koboSpan" id="kobo.681.1">, make up their own word, and enter it into the list. </span><span class="koboSpan" id="kobo.681.2">We want to prevent that and check each of the words against an actual dictionary. </span><span class="koboSpan" id="kobo.681.3">To do that, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.682.1">UITextChecker</span></strong><span class="koboSpan" id="kobo.683.1"> class. </span><span class="koboSpan" id="kobo.683.2">This class has methods and properties we can use to check whether a word is an actual word in the dictionary, and what’s especially nice is it will work with misspellings and authenticity in Spanish and Italian </span><span class="No-Break"><span class="koboSpan" id="kobo.684.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.685.1">So, let’s go into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.686.1">DataModel</span></strong><span class="koboSpan" id="kobo.687.1"> class and add the following code to the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.688.1">isWordInDictionary</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.689.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.690.1">
 func isWordInDictionary(word: String) -&gt; Bool {
    return UITextChecker().rangeOfMisspelledWord(in: word,
      range: NSRange(location: 0, length:
      word.utf16.count), startingAt: 0, wrap: false,
      language: "en").isNotFound
    }</span></pre>
<p><span class="koboSpan" id="kobo.691.1">We’re going to get an error here because I am adding this </span><strong class="source-inline"><span class="koboSpan" id="kobo.692.1">isNotFound</span></strong><span class="koboSpan" id="kobo.693.1"> property. </span><span class="koboSpan" id="kobo.693.2">So, let’s fix that error first, and then we can go over what the code is doing. </span><span class="koboSpan" id="kobo.693.3">Outside the class’s closing brace, add the </span><span class="No-Break"><span class="koboSpan" id="kobo.694.1">following extension:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.695.1">
extension NSRange {
    var isNotFound: Bool {
        return location == NSNotFound
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.696.1">Going back now, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.697.1">isWordInDictionary</span></strong><span class="koboSpan" id="kobo.698.1"> function checks whether a given word exists in the English dictionary. </span><span class="koboSpan" id="kobo.698.2">It does so by creating an instance of </span><strong class="source-inline"><span class="koboSpan" id="kobo.699.1">UITextChecker</span></strong><span class="koboSpan" id="kobo.700.1"> and calling the </span><strong class="source-inline"><span class="koboSpan" id="kobo.701.1">rangeOfMisspelledWord</span></strong><span class="koboSpan" id="kobo.702.1"> method on it. </span><span class="koboSpan" id="kobo.702.2">This method takes </span><span class="No-Break"><span class="koboSpan" id="kobo.703.1">several arguments:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.704.1">word</span></strong><span class="koboSpan" id="kobo.705.1">: The word to check </span><span class="No-Break"><span class="koboSpan" id="kobo.706.1">for spelling</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.707.1">range</span></strong><span class="koboSpan" id="kobo.708.1">: The range of the word to check, specified </span><span class="No-Break"><span class="koboSpan" id="kobo.709.1">as </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.710.1">NSRange</span></strong></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.711.1">startingAt</span></strong><span class="koboSpan" id="kobo.712.1">: The starting position of the word to check within the </span><span class="No-Break"><span class="koboSpan" id="kobo.713.1">specified range</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.714.1">wrap</span></strong><span class="koboSpan" id="kobo.715.1">: A Boolean value indicating whether to wrap around the end of the range to the beginning when checking for </span><span class="No-Break"><span class="koboSpan" id="kobo.716.1">misspelled words</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.717.1">language</span></strong><span class="koboSpan" id="kobo.718.1">: The language to use for spell checking – in this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.719.1">"en"</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.720.1">for English</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.721.1">The method </span><a id="_idIndexMarker697"/><span class="koboSpan" id="kobo.722.1">then returns an </span><strong class="source-inline"><span class="koboSpan" id="kobo.723.1">NSRange</span></strong><span class="koboSpan" id="kobo.724.1"> that indicates the range of the first misspelled word found. </span><span class="koboSpan" id="kobo.724.2">If no misspelled word is found, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.725.1">location</span></strong><span class="koboSpan" id="kobo.726.1"> property of the returned range is set </span><span class="No-Break"><span class="koboSpan" id="kobo.727.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.728.1">NSNotFound</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.729.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.730.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.731.1">isNotFound</span></strong><span class="koboSpan" id="kobo.732.1"> computed property is an extension on </span><strong class="source-inline"><span class="koboSpan" id="kobo.733.1">NSRange</span></strong><span class="koboSpan" id="kobo.734.1"> that returns </span><strong class="source-inline"><span class="koboSpan" id="kobo.735.1">true</span></strong><span class="koboSpan" id="kobo.736.1"> if the </span><strong class="source-inline"><span class="koboSpan" id="kobo.737.1">location</span></strong><span class="koboSpan" id="kobo.738.1"> property is equal to </span><strong class="source-inline"><span class="koboSpan" id="kobo.739.1">NSNotFound</span></strong><span class="koboSpan" id="kobo.740.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.741.1">false</span></strong><span class="koboSpan" id="kobo.742.1"> otherwise. </span><span class="koboSpan" id="kobo.742.2">This makes it more readable and allows us to write </span><strong class="source-inline"><span class="koboSpan" id="kobo.743.1">isNotFound</span></strong><span class="koboSpan" id="kobo.744.1"> instead of comparing the location of </span><strong class="source-inline"><span class="koboSpan" id="kobo.745.1">NSNotFound</span></strong><span class="koboSpan" id="kobo.746.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.747.1">the function.</span></span></p>
<p><span class="koboSpan" id="kobo.748.1">Summing it up, the function creates an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.749.1">UITextChecker</span></strong><span class="koboSpan" id="kobo.750.1"> class. </span><strong class="source-inline"><span class="koboSpan" id="kobo.751.1">UITextChecker</span></strong><span class="koboSpan" id="kobo.752.1"> looks through its dictionary for any misspelling to make sure the word is real – if it is in the dictionary, </span><strong class="source-inline"><span class="koboSpan" id="kobo.753.1">true</span></strong><span class="koboSpan" id="kobo.754.1"> is returned and the word will be entered into the user’s list; otherwise, </span><strong class="source-inline"><span class="koboSpan" id="kobo.755.1">false</span></strong><span class="koboSpan" id="kobo.756.1"> will be returned, and we show a message to the user saying that this is not an actual word in </span><span class="No-Break"><span class="koboSpan" id="kobo.757.1">the dictionary.</span></span></p>
<p><span class="koboSpan" id="kobo.758.1">Now that the function is complete, let’s use it. </span><span class="koboSpan" id="kobo.758.2">Add the following code directly after the closing brace of the previous </span><strong class="source-inline"><span class="koboSpan" id="kobo.759.1">guard</span></strong><span class="koboSpan" id="kobo.760.1"> statement in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.761.1">addWordToList</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.762.1"> function:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.763.1">
 //is the word spelled correctly and a real word in the
   chosen language? </span><span class="koboSpan" id="kobo.763.2">- only real words allowed
    guard isWordInDictionary(word: usersWord) else {
        displayErrorMessage(messageTitle: "This is not a 
          valid word", description: "Use only real words")
        return
    }</span></pre>
<p><span class="koboSpan" id="kobo.764.1">With that code in place, give the app another go and make up your own word using the given letters</span><a id="_idIndexMarker698"/> <span class="No-Break"><span class="koboSpan" id="kobo.765.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.766.1">baseWord</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.767.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer168">
<span class="koboSpan" id="kobo.768.1"><img alt="Figure 12.6: Checking whether the word is in the dictionary " src="image/B18674_12_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.769.1">Figure 12.6: Checking whether the word is in the dictionary</span></p>
<p><span class="koboSpan" id="kobo.770.1">Here, I made up a word using the letters from </span><strong class="source-inline"><span class="koboSpan" id="kobo.771.1">baseWord</span></strong><span class="koboSpan" id="kobo.772.1"> – </span><strong class="source-inline"><span class="koboSpan" id="kobo.773.1">tesh</span></strong><span class="koboSpan" id="kobo.774.1"> – however, I wasn’t allowed to add the word to the list because there is no such word in the English language, so we know the function </span><span class="No-Break"><span class="koboSpan" id="kobo.775.1">is working.</span></span></p>
<p><span class="koboSpan" id="kobo.776.1">And that really completes all of the word-checking functionality for the app; we will add pop-up </span><a id="_idIndexMarker699"/><span class="koboSpan" id="kobo.777.1">alerts for when a user’s word doesn’t pass any of </span><span class="No-Break"><span class="koboSpan" id="kobo.778.1">those checks.</span></span></p>
<p><span class="koboSpan" id="kobo.779.1">Let’s focus on building out the UI some more. </span><span class="koboSpan" id="kobo.779.2">We’re going to add a text string at the top that will be the name of the app, and we can style this in a </span><span class="No-Break"><span class="koboSpan" id="kobo.780.1">separate file.</span></span></p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor182"/><span class="koboSpan" id="kobo.781.1">Creating HeaderView with an info button</span></h1>
<p><span class="koboSpan" id="kobo.782.1">Let’s continue</span><a id="_idIndexMarker700"/><span class="koboSpan" id="kobo.783.1"> building out the UI and add a header title, which will be the name of our app. </span><span class="koboSpan" id="kobo.783.2">We can create this header in a separate file so we can keep our </span><strong class="source-inline"><span class="koboSpan" id="kobo.784.1">ContentView</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.785.1">clutter free.</span></span></p>
<p><span class="koboSpan" id="kobo.786.1">The purpose of </span><strong class="source-inline"><span class="koboSpan" id="kobo.787.1">HeaderView</span></strong><span class="koboSpan" id="kobo.788.1"> is twofold – to set the title of the app, and to add an </span><strong class="source-inline"><span class="koboSpan" id="kobo.789.1">info</span></strong><span class="koboSpan" id="kobo.790.1"> button that opens a user </span><span class="No-Break"><span class="koboSpan" id="kobo.791.1">settings page.</span></span></p>
<p><span class="koboSpan" id="kobo.792.1">Press </span><em class="italic"><span class="koboSpan" id="kobo.793.1">Command + N</span></em><span class="koboSpan" id="kobo.794.1">, choose a </span><strong class="bold"><span class="koboSpan" id="kobo.795.1">SwiftUI View</span></strong><span class="koboSpan" id="kobo.796.1"> file, and call it </span><strong class="source-inline"><span class="koboSpan" id="kobo.797.1">HeaderView</span></strong><span class="koboSpan" id="kobo.798.1">. </span><span class="koboSpan" id="kobo.798.2">Then, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.799.1">Binding</span></strong><span class="koboSpan" id="kobo.800.1"> property in the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.801.1">HeaderView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.802.1"> struct:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.803.1">
@Binding var showSettings: Bool
Now let's update the Previews struct to satisfy Xcode and so we can build cleanly again:
HeaderView(showSettings: .constant(false))
        .previewLayout(.fixed(width: 375, height: 80))</span></pre>
<p><span class="koboSpan" id="kobo.804.1">Next, add the following code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.805.1">body</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.806.1"> property:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.807.1">
   ZStack {
          Image("title").resizable()
              .frame(width: 250, height: 50)
              .shadow(color: .black, radius: 1, x: 1, y: 1)
          
          //info button
          Button(action: {
          }){
              Image(systemName: "info.circle")
                  .font(.system(size: 30, weight: .medium))
                  .padding(.top, 10)
                  .accentColor(Color.black)
          }.offset(x: 160)
      }</span></pre>
<p><span class="koboSpan" id="kobo.808.1">First, we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.809.1">ZStack</span></strong><span class="koboSpan" id="kobo.810.1"> to hold two views, an image displaying the title of the app, and a button that we will set up to take the user to a settings page, where they can choose another language to play the game in. </span><span class="koboSpan" id="kobo.810.2">Also added was the </span><strong class="source-inline"><span class="koboSpan" id="kobo.811.1">shadow</span></strong><span class="koboSpan" id="kobo.812.1"> modifier on the image to help make it stand out a </span><span class="No-Break"><span class="koboSpan" id="kobo.813.1">little more.</span></span></p>
<p><span class="koboSpan" id="kobo.814.1">Inside the button closure, we use the system image of an info circle, then some top padding on it to align the button vertically with the image, and then we colored the button black using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.815.1">accent</span></strong><span class="koboSpan" id="kobo.816.1"> modifier. </span><span class="koboSpan" id="kobo.816.2">After that, we offset the button to the right </span><strong class="source-inline"><span class="koboSpan" id="kobo.817.1">150</span></strong><span class="koboSpan" id="kobo.818.1"> points so that it’s next to the image on the right side of </span><span class="No-Break"><span class="koboSpan" id="kobo.819.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.820.1">When the </span><strong class="source-inline"><span class="koboSpan" id="kobo.821.1">info</span></strong><span class="koboSpan" id="kobo.822.1"> button is pressed, a settings page will open, giving the user three language options for the game. </span><span class="koboSpan" id="kobo.822.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.823.1">showSettings</span></strong><span class="koboSpan" id="kobo.824.1"> property will be used to open up </span><strong class="source-inline"><span class="koboSpan" id="kobo.825.1">SettingsView</span></strong><span class="koboSpan" id="kobo.826.1">, but</span><a id="_idIndexMarker701"/><span class="koboSpan" id="kobo.827.1"> we don’t have </span><strong class="source-inline"><span class="koboSpan" id="kobo.828.1">SettingsView</span></strong><span class="koboSpan" id="kobo.829.1"> yet, so let’s make one. </span><span class="koboSpan" id="kobo.829.2">Press </span><em class="italic"><span class="koboSpan" id="kobo.830.1">Command + N</span></em><span class="koboSpan" id="kobo.831.1">, choose </span><strong class="bold"><span class="koboSpan" id="kobo.832.1">SwiftUI View</span></strong><span class="koboSpan" id="kobo.833.1">, and name it </span><strong class="source-inline"><span class="koboSpan" id="kobo.834.1">SettingsView</span></strong><span class="koboSpan" id="kobo.835.1">. </span><span class="koboSpan" id="kobo.835.2">And just like that, we now have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.836.1">SettingsView</span></strong><span class="koboSpan" id="kobo.837.1">. </span><span class="koboSpan" id="kobo.837.2">Let’s come back into the </span><strong class="bold"><span class="koboSpan" id="kobo.838.1">HeaderView</span></strong><span class="koboSpan" id="kobo.839.1"> and add the code that we need to open up the </span><strong class="source-inline"><span class="koboSpan" id="kobo.840.1">SettingsView</span></strong><span class="koboSpan" id="kobo.841.1">. </span></p>
<p><span class="koboSpan" id="kobo.842.1">Inside the button, we need to toggle the </span><strong class="source-inline"><span class="koboSpan" id="kobo.843.1">showSettings</span></strong><span class="koboSpan" id="kobo.844.1"> state variable, so add the following line of code to the </span><span class="No-Break"><span class="koboSpan" id="kobo.845.1">button body:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.846.1">
showSettings.toggle()</span></pre>
<p><span class="koboSpan" id="kobo.847.1">And finally, in order to open up a sheet over another view, we need to call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.848.1">sheet</span></strong><span class="koboSpan" id="kobo.849.1"> modifier on the button, so add the code to the end of the button’s </span><span class="No-Break"><span class="koboSpan" id="kobo.850.1">closing brace:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.851.1">
 Button(action: {
              self.showSettings.toggle()
          }){
              Image(systemName: "info.circle")
                  .font(.system(size: 30, weight: .medium))
                  .padding(.top, 10)
                  .padding(.horizontal, 10)
                  .accentColor(Color.black)
          }.offset(x: 160)
           .sheet(isPresented: $showSettings) {
              //show the settings view
              SettingsView()
          }</span></pre>
<p><span class="koboSpan" id="kobo.852.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.853.1">sheet</span></strong><span class="koboSpan" id="kobo.854.1"> modifier is used in SwiftUI to open a sheet, which is simply another view that opens by sliding up from the bottom of the screen. </span><span class="koboSpan" id="kobo.854.2">The sheet is triggered by the </span><strong class="source-inline"><span class="koboSpan" id="kobo.855.1">isPresented</span></strong><span class="koboSpan" id="kobo.856.1"> parameter – when the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.857.1">isPresented</span></strong><span class="koboSpan" id="kobo.858.1"> becomes </span><strong class="source-inline"><span class="koboSpan" id="kobo.859.1">true</span></strong><span class="koboSpan" id="kobo.860.1">, the code in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.861.1">sheet</span></strong><span class="koboSpan" id="kobo.862.1"> modifier’s body will run. </span><span class="koboSpan" id="kobo.862.2">In the </span><strong class="source-inline"><span class="koboSpan" id="kobo.863.1">sheet</span></strong><span class="koboSpan" id="kobo.864.1"> modifier’s closure, there is a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.865.1">SettingsView</span></strong><span class="koboSpan" id="kobo.866.1">; this is the view (sheet) that gets presented over </span><strong class="source-inline"><span class="koboSpan" id="kobo.867.1">ContentView</span></strong><span class="koboSpan" id="kobo.868.1">. </span><span class="koboSpan" id="kobo.868.2">To dismiss the sheet, the user slides it back down with </span><span class="No-Break"><span class="koboSpan" id="kobo.869.1">their finger.</span></span></p>
<p><span class="koboSpan" id="kobo.870.1">To see this in action, we need to add two more lines of code inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.871.1">ContentView</span></strong><span class="koboSpan" id="kobo.872.1">. </span><span class="koboSpan" id="kobo.872.2">First, go into that file, and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.873.1">State</span></strong><span class="koboSpan" id="kobo.874.1"> property that can connect to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.875.1">Bindin</span></strong><span class="koboSpan" id="kobo.876.1">g variable of </span><strong class="source-inline"><span class="koboSpan" id="kobo.877.1">HeaderView</span></strong><span class="koboSpan" id="kobo.878.1">. </span><span class="koboSpan" id="kobo.878.2">Add </span><a id="_idIndexMarker702"/><span class="koboSpan" id="kobo.879.1">this </span><strong class="source-inline"><span class="koboSpan" id="kobo.880.1">State</span></strong><span class="koboSpan" id="kobo.881.1"> variable right after the previous property at the top </span><span class="No-Break"><span class="koboSpan" id="kobo.882.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.883.1">ContentView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.884.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.885.1">
@State var showSettings: Bool = false</span></pre>
<p><span class="koboSpan" id="kobo.886.1">I’m calling it </span><strong class="source-inline"><span class="koboSpan" id="kobo.887.1">showSettings</span></strong><span class="koboSpan" id="kobo.888.1">, the same as the variable it’s binding to from </span><strong class="source-inline"><span class="koboSpan" id="kobo.889.1">HeaderView</span></strong><span class="koboSpan" id="kobo.890.1">. </span></p>
<p><span class="koboSpan" id="kobo.891.1">Now, we just need to add a call to </span><strong class="source-inline"><span class="koboSpan" id="kobo.892.1">HeaderView</span></strong><span class="koboSpan" id="kobo.893.1"> to get the </span><strong class="source-inline"><span class="koboSpan" id="kobo.894.1">info</span></strong><span class="koboSpan" id="kobo.895.1"> button working. </span><span class="koboSpan" id="kobo.895.2">Add this line of code inside </span><strong class="source-inline"><span class="koboSpan" id="kobo.896.1">VStack</span></strong><span class="koboSpan" id="kobo.897.1"> at </span><span class="No-Break"><span class="koboSpan" id="kobo.898.1">the top:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.899.1">
HeaderView(showSettings: $showSettings)</span></pre>
<p><span class="koboSpan" id="kobo.900.1">And that’s all we need to get </span><strong class="source-inline"><span class="koboSpan" id="kobo.901.1">SettingsView</span></strong><span class="koboSpan" id="kobo.902.1"> working. </span><span class="koboSpan" id="kobo.902.2">Try it out – press the information button in </span><strong class="source-inline"><span class="koboSpan" id="kobo.903.1">ContentView</span></strong><span class="koboSpan" id="kobo.904.1"> and </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.905.1">SettingsView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.906.1"> opens:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer169">
<span class="koboSpan" id="kobo.907.1"><img alt="Figure 12.7: SettingsView " src="image/B18674_12_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.908.1">Figure 12.7: SettingsView</span></p>
<p><span class="koboSpan" id="kobo.909.1">To dismiss the view, simply slide down on the opened view. </span><span class="koboSpan" id="kobo.909.2">This “sliding to close” behavior is automatically baked into the </span><strong class="source-inline"><span class="koboSpan" id="kobo.910.1">sheet</span></strong><span class="koboSpan" id="kobo.911.1"> modifier, so we don’t have to </span><span class="No-Break"><span class="koboSpan" id="kobo.912.1">implement it.</span></span></p>
<p><span class="koboSpan" id="kobo.913.1">So, we</span><a id="_idIndexMarker703"/><span class="koboSpan" id="kobo.914.1"> have </span><strong class="source-inline"><span class="koboSpan" id="kobo.915.1">SettingView</span></strong><span class="koboSpan" id="kobo.916.1"> working, although it doesn’t do much right now other than open up and show </span><strong class="bold"><span class="koboSpan" id="kobo.917.1">Hello, World!</span></strong><span class="koboSpan" id="kobo.918.1"> (we will build that out soon enough). </span><span class="koboSpan" id="kobo.918.2">Let’s continue with the styling of the interface and add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.919.1">PickerView</span></strong><span class="koboSpan" id="kobo.920.1"> that the user can press on to set the size of the words they want to </span><span class="No-Break"><span class="koboSpan" id="kobo.921.1">play with.</span></span></p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor183"/><span class="koboSpan" id="kobo.922.1">Creating PickerView</span></h1>
<p><span class="koboSpan" id="kobo.923.1">A </span><strong class="source-inline"><span class="koboSpan" id="kobo.924.1">PickerView</span></strong><span class="koboSpan" id="kobo.925.1"> is a view</span><a id="_idIndexMarker704"/><span class="koboSpan" id="kobo.926.1"> that displays various options to the user. </span><span class="koboSpan" id="kobo.926.2">The picker can either be a single button with a drop-down list, a segmented list with multiple buttons, or a wheel that the user can spin to select an option. </span></p>
<p><span class="koboSpan" id="kobo.927.1">There are two main differences between these three pickers in terms of style. </span><span class="koboSpan" id="kobo.927.2">The first is how they appear in your app. </span><span class="koboSpan" id="kobo.927.3">The second is the number of options available to the user – the wheel can hold many, many options for the user, whereas a button picker or a segmented control picker is limited by the amount of space on </span><span class="No-Break"><span class="koboSpan" id="kobo.928.1">the screen.</span></span></p>
<p><span class="koboSpan" id="kobo.929.1">Since we will be offering just three options to the user, a seven-, eight-, or nine-letter word option, we’ll go with the </span><span class="No-Break"><span class="koboSpan" id="kobo.930.1">segmented control.</span></span></p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor184"/><span class="koboSpan" id="kobo.931.1">Adding PickerView</span></h2>
<p><span class="koboSpan" id="kobo.932.1">Let’s start by </span><a id="_idIndexMarker705"/><span class="koboSpan" id="kobo.933.1">adding a new </span><strong class="bold"><span class="koboSpan" id="kobo.934.1">SwiftUI View</span></strong><span class="koboSpan" id="kobo.935.1"> file and calling it </span><strong class="source-inline"><span class="koboSpan" id="kobo.936.1">PickerView</span></strong><span class="koboSpan" id="kobo.937.1">. </span><span class="koboSpan" id="kobo.937.2">Next, let’s add an instance of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.938.1">DataModel</span></strong><span class="koboSpan" id="kobo.939.1"> class at the top of the struct so we have access to the </span><span class="No-Break"><span class="koboSpan" id="kobo.940.1">data properties:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.941.1">
@ObservedObject var appData = DataModel()</span></pre>
<p><span class="koboSpan" id="kobo.942.1">Then add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.943.1">VStack</span></strong><span class="koboSpan" id="kobo.944.1">, and inside that, add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.945.1">topBar</span></strong><span class="koboSpan" id="kobo.946.1"> image that we have in the Assets catalog, which will help to frame </span><span class="No-Break"><span class="koboSpan" id="kobo.947.1">the picker:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.948.1">
VStack(alignment: .center, spacing: 10) {
          //bar
          Image("topBar").resizable()
              .frame(width: 280, height: 8)
              .padding(.bottom, 10)
              .shadow(color: .black, radius: 1, x: 1, y: 1)
}</span></pre>
<p><span class="koboSpan" id="kobo.949.1">In the code, we add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.950.1">topBar</span></strong><span class="koboSpan" id="kobo.951.1"> image and put a little padding and shadow around it to help it stand out against the background (which will be added soon). </span><span class="koboSpan" id="kobo.951.2">Then, we use </span><strong class="source-inline"><span class="koboSpan" id="kobo.952.1">10</span></strong><span class="koboSpan" id="kobo.953.1"> points of center spacing on the </span><strong class="source-inline"><span class="koboSpan" id="kobo.954.1">VStack</span></strong><span class="koboSpan" id="kobo.955.1"> to keep some space between </span><span class="No-Break"><span class="koboSpan" id="kobo.956.1">the views.</span></span></p>
<p><span class="koboSpan" id="kobo.957.1">Now, add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.958.1">Picker</span></strong><span class="koboSpan" id="kobo.959.1"> control underneath the last line of code we </span><span class="No-Break"><span class="koboSpan" id="kobo.960.1">just added:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.961.1">
Picker("", selection: $appData.selectedSegment) {
              Text("7 Letter").tag(1)
              Text("8 Letter").tag(2)
              Text("9 Letter").tag(3)
              
          }</span></pre>
<p><span class="koboSpan" id="kobo.962.1">This code adds the picker and uses the </span><strong class="source-inline"><span class="koboSpan" id="kobo.963.1">selectedSegment</span></strong><span class="koboSpan" id="kobo.964.1"> property in </span><strong class="source-inline"><span class="koboSpan" id="kobo.965.1">DataModel</span></strong><span class="koboSpan" id="kobo.966.1">, which is used to keep track of which segment of the picker has been selected by the user. </span><span class="koboSpan" id="kobo.966.2">The picker </span><a id="_idIndexMarker706"/><span class="koboSpan" id="kobo.967.1">is set to three different titles, and we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.968.1">tag</span></strong><span class="koboSpan" id="kobo.969.1"> modifier to distinguish which title goes where on the picker control. </span><span class="koboSpan" id="kobo.969.2">Now, the user can choose between </span><strong class="source-inline"><span class="koboSpan" id="kobo.970.1">7</span></strong><span class="koboSpan" id="kobo.971.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.972.1">8</span></strong><span class="koboSpan" id="kobo.973.1">, or </span><strong class="source-inline"><span class="koboSpan" id="kobo.974.1">9</span></strong><span class="koboSpan" id="kobo.975.1"> letters for the word they will work with. </span></p>
<p><span class="koboSpan" id="kobo.976.1"> This is the default button look, which offers options to the user </span><span class="No-Break"><span class="koboSpan" id="kobo.977.1">when pressed:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer170">
<span class="koboSpan" id="kobo.978.1"><img alt="Figure 12.8: The button picker " src="image/B18674_12_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.979.1">Figure 12.8: The button picker</span></p>
<p><span class="koboSpan" id="kobo.980.1">Let’s now look </span><a id="_idIndexMarker707"/><span class="koboSpan" id="kobo.981.1">at how we can style the picker to something more suitable for </span><span class="No-Break"><span class="koboSpan" id="kobo.982.1">our game.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor185"/><span class="koboSpan" id="kobo.983.1">Styling PickerView</span></h2>
<p><span class="koboSpan" id="kobo.984.1">As I </span><a id="_idIndexMarker708"/><span class="koboSpan" id="kobo.985.1">mentioned, I feel that segmented control looks better, so let’s change the styling to that picker option instead. </span><span class="koboSpan" id="kobo.985.2">Add the following code after the closing brace </span><span class="No-Break"><span class="koboSpan" id="kobo.986.1">of </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.987.1">PickerView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.988.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.989.1">
      .pickerStyle(SegmentedPickerStyle())
      .background(RoundedRectangle(cornerRadius: 8)
      .stroke(Color.black, lineWidth: 4).shadow(color: 
        Color.black, radius: 8, x: 0, y: 0))
      .cornerRadius(8)
      .padding(.horizontal, 50.0)
      .padding(.bottom, 10)</span></pre>
<p><span class="koboSpan" id="kobo.990.1">We set the picker</span><a id="_idIndexMarker709"/><span class="koboSpan" id="kobo.991.1"> to the segmented style, and added a rounded rectangle with a corner radius of </span><strong class="source-inline"><span class="koboSpan" id="kobo.992.1">8</span></strong><span class="koboSpan" id="kobo.993.1"> points, with a black stroke around the picker control to give it a nice border. </span><span class="koboSpan" id="kobo.993.2">Then, we finished it off with some shadow and padding, and this is what it </span><span class="No-Break"><span class="koboSpan" id="kobo.994.1">looks like:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer171">
<span class="koboSpan" id="kobo.995.1"><img alt="Figure 12.9: The completed PickerView " src="image/B18674_12_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.996.1">Figure 12.9: The completed PickerView</span></p>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.997.1">PickerView</span></strong><span class="koboSpan" id="kobo.998.1"> is done, but to complete the work in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.999.1">PickerView</span></strong><span class="koboSpan" id="kobo.1000.1"> file, let’s add a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1001.1">bottomBar</span></strong><span class="koboSpan" id="kobo.1002.1"> image to the scene. </span><span class="koboSpan" id="kobo.1002.2">After the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1003.1">shadow</span></strong><span class="koboSpan" id="kobo.1004.1"> modifier, add </span><span class="No-Break"><span class="koboSpan" id="kobo.1005.1">the following:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1006.1">
Image("bottomBar").resizable()
        .frame(width: 280, height: 8)
        .padding(.bottom, 10)
        .shadow(color: .black, radius: 1, x: 1, y: 1)</span></pre>
<p><span class="koboSpan" id="kobo.1007.1">This just </span><a id="_idIndexMarker710"/><span class="koboSpan" id="kobo.1008.1">sets </span><strong class="source-inline"><span class="koboSpan" id="kobo.1009.1">bottomBar</span></strong><span class="koboSpan" id="kobo.1010.1"> like </span><strong class="source-inline"><span class="koboSpan" id="kobo.1011.1">topBar</span></strong><span class="koboSpan" id="kobo.1012.1">, and helps frame out </span><strong class="source-inline"><span class="koboSpan" id="kobo.1013.1">PickerView</span></strong><span class="koboSpan" id="kobo.1014.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.1015.1">the UI:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer172">
<span class="koboSpan" id="kobo.1016.1"><img alt="Figure 12.10: The bottom bar image added " src="image/B18674_12_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1017.1">Figure 12.10: The bottom bar image added</span></p>
<p><span class="koboSpan" id="kobo.1018.1">Let’s go back into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1019.1">ContentView</span></strong><span class="koboSpan" id="kobo.1020.1">, where we need to call </span><strong class="source-inline"><span class="koboSpan" id="kobo.1021.1">PickerView</span></strong><span class="koboSpan" id="kobo.1022.1"> to bring it into the scene. </span><span class="koboSpan" id="kobo.1022.2">Add the following just below the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1023.1">HeaderView</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1024.1"> code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1025.1">
          //MARK: - PICKER
        PickerView()</span></pre>
<p><span class="koboSpan" id="kobo.1026.1">And now we</span><a id="_idIndexMarker711"/><span class="koboSpan" id="kobo.1027.1"> have our </span><strong class="source-inline"><span class="koboSpan" id="kobo.1028.1">PickerView</span></strong><span class="koboSpan" id="kobo.1029.1"> that can offer the user some choices. </span><span class="koboSpan" id="kobo.1029.2">It doesn’t do anything yet because we need to fill out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1030.1">setWordLengthAndLanguage</span></strong><span class="koboSpan" id="kobo.1031.1"> method, so let’s do that. </span><span class="koboSpan" id="kobo.1031.2">Back in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1032.1">DataModel</span></strong><span class="koboSpan" id="kobo.1033.1">, add the following code inside the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1034.1">setWordLengthAndLanguage</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1035.1"> method:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
    //sets the word length and language for the game
    func setWordLengthAndLanguage() -&gt; String {
        let language = ["English": "En", "Spanish": "ES",
          "Italian": "It"]
        let wordLength = [1: "7", 2: "8", 3: "9"]
        var dataFile = ""
        var selectedLanguage = ""
        if englishIsOn == true {
            selectedLanguage = "English"
        } else if spanishIsOn == true {
            selectedLanguage = "Spanish"
        } else if italianIsOn == true {
            selectedLanguage = "Italian"
        }
        if let languageCode = language[selectedLanguage],
          let lengthCode = wordLength[selectedSegment] {
        dataFile = 
          "\(lengthCode)LetterWords\(languageCode)"
          letterCount = "🇱🇷 \(lengthCode) letter word – 
            \(selectedLanguage) 🇱🇷"
        }
        return dataFile
    }</span></pre>
<p><span class="koboSpan" id="kobo.1037.1">This is how the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1038.1">setWordLengthAndLanguage</span></strong><span class="koboSpan" id="kobo.1039.1"> function works. </span><span class="koboSpan" id="kobo.1039.2">It starts by defining two dictionaries, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1040.1">language</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.1041.1">and </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1042.1">wordLength</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1043.1">:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.1044.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1045.1">language</span></strong><span class="koboSpan" id="kobo.1046.1"> dictionary maps the names of different languages to their abbreviations. </span><span class="koboSpan" id="kobo.1046.2">In this case, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1047.1">"English"</span></strong><span class="koboSpan" id="kobo.1048.1"> is mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1049.1">"En"</span></strong><span class="koboSpan" id="kobo.1050.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1051.1">"Spanish"</span></strong><span class="koboSpan" id="kobo.1052.1"> is mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1053.1">"ES"</span></strong><span class="koboSpan" id="kobo.1054.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1055.1">"Italian"</span></strong><span class="koboSpan" id="kobo.1056.1"> is mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.1057.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1058.1">"It"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1059.1">.</span></span></li>
<li><span class="koboSpan" id="kobo.1060.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.1061.1">wordLength</span></strong><span class="koboSpan" id="kobo.1062.1"> dictionary maps integer values to their corresponding word lengths. </span><span class="koboSpan" id="kobo.1062.2">For example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1063.1">1</span></strong><span class="koboSpan" id="kobo.1064.1"> is mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1065.1">"7"</span></strong><span class="koboSpan" id="kobo.1066.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1067.1">2</span></strong><span class="koboSpan" id="kobo.1068.1"> is mapped to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1069.1">"8"</span></strong><span class="koboSpan" id="kobo.1070.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1071.1">3</span></strong><span class="koboSpan" id="kobo.1072.1"> is mapped </span><span class="No-Break"><span class="koboSpan" id="kobo.1073.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1074.1">"9"</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1075.1">.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.1076.1">Next, the </span><a id="_idIndexMarker712"/><span class="koboSpan" id="kobo.1077.1">function checks the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1078.1">selectedSegment</span></strong><span class="koboSpan" id="kobo.1079.1"> variable. </span><span class="koboSpan" id="kobo.1079.2">This variable holds an integer that represents the user’s selected word length (seven letters, eight letters, or </span><span class="No-Break"><span class="koboSpan" id="kobo.1080.1">nine letters).</span></span></p>
<p><span class="koboSpan" id="kobo.1081.1">Based on the value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.1082.1">selectedSegment</span></strong><span class="koboSpan" id="kobo.1083.1">, the function retrieves the corresponding word length from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1084.1">wordLength</span></strong><span class="koboSpan" id="kobo.1085.1"> dictionary using the square bracket notation, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1086.1">wordLength[selectedSegment]</span></strong><span class="koboSpan" id="kobo.1087.1">. </span><span class="koboSpan" id="kobo.1087.2">This gives us the word length as a string, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1088.1">7</span></strong><span class="koboSpan" id="kobo.1089.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1090.1">8</span></strong><span class="koboSpan" id="kobo.1091.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1092.1">or </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1093.1">9</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1094.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1095.1">The function then checks the values of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1096.1">englishIsOn</span></strong><span class="koboSpan" id="kobo.1097.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.1098.1">spanishIsOn</span></strong><span class="koboSpan" id="kobo.1099.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.1100.1">italianIsOn</span></strong><span class="koboSpan" id="kobo.1101.1"> variables. </span><span class="koboSpan" id="kobo.1101.2">These variables hold Booleans that indicate whether the user has selected the </span><span class="No-Break"><span class="koboSpan" id="kobo.1102.1">corresponding language.</span></span></p>
<p><span class="koboSpan" id="kobo.1103.1">If one of these language variables is true, then the function uses the corresponding language abbreviation (retrieved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1104.1">language</span></strong><span class="koboSpan" id="kobo.1105.1"> dictionary) and the word length (retrieved from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1106.1">wordLength</span></strong><span class="koboSpan" id="kobo.1107.1"> dictionary) to construct the filename of the data file that contains the words for that language and word length. </span><span class="koboSpan" id="kobo.1107.2">For example, if the user has selected English with seven letters, the filename will </span><span class="No-Break"><span class="koboSpan" id="kobo.1108.1">be </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1109.1">7LetterWordsEn</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1110.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1111.1">The function sets the value of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1112.1">letterCount</span></strong><span class="koboSpan" id="kobo.1113.1"> variable to a string that provides a description of the selected language and word length, such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.1114.1">7 letter word - </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1115.1">American English</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1116.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.1117.1">Finally, the function returns the constructed filename as </span><span class="No-Break"><span class="koboSpan" id="kobo.1118.1">a string.</span></span></p>
<p><span class="koboSpan" id="kobo.1119.1">There’s one</span><a id="_idIndexMarker713"/><span class="koboSpan" id="kobo.1120.1"> other bit of code we need to add to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1121.1">ContentView</span></strong><span class="koboSpan" id="kobo.1122.1"> in order to get the language word count string working for the picker control. </span><span class="koboSpan" id="kobo.1122.2">Add the following code directly after the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1123.1">shadow</span></strong><span class="koboSpan" id="kobo.1124.1"> modifier of </span><span class="No-Break"><span class="koboSpan" id="kobo.1125.1">the button:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1126.1">
//MARK: - WORD TO PLAY FROM
      VStack {
          //word letter count string
          Text("\(appData.letterCount)")
              .font(.system(size: 18, weight: .regular, 
                design: .serif))
              .foregroundColor(Color.white)
              .bold()
              .shadow(color: .black, radius: 1, x: 1, y: 1)
              
      }</span></pre>
<p><span class="koboSpan" id="kobo.1127.1">In this code, we added a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1128.1">VStack</span></strong><span class="koboSpan" id="kobo.1129.1"> and then displayed the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1130.1">letterCount</span></strong><span class="koboSpan" id="kobo.1131.1"> property in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.1132.1">Text</span></strong><span class="koboSpan" id="kobo.1133.1"> view by using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1134.1">appData</span></strong><span class="koboSpan" id="kobo.1135.1"> instance. </span><span class="koboSpan" id="kobo.1135.2">Then, we applied a font size and weight and a white foreground, made it bold, and added a shadow to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1136.1">Text</span></strong><span class="koboSpan" id="kobo.1137.1"> view. </span><span class="koboSpan" id="kobo.1137.2">What I want you to do now is to cut out the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1138.1">Text</span></strong><span class="koboSpan" id="kobo.1139.1"> view that displays the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1140.1">wordToPlayFrom</span></strong><span class="koboSpan" id="kobo.1141.1"> property, and paste it inside the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1142.1">VStack</span></strong><span class="koboSpan" id="kobo.1143.1"> just added, at the very end. </span><span class="koboSpan" id="kobo.1143.2">This keeps both text views </span><span class="No-Break"><span class="koboSpan" id="kobo.1144.1">horizontally organized.</span></span></p>
<p><span class="koboSpan" id="kobo.1145.1">Now, to test the picker out and see it display the letter word string, as well as a word in a different language, we need to come to our data file and set one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1146.1">language</span></strong><span class="koboSpan" id="kobo.1147.1"> variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1148.1">true</span></strong><span class="koboSpan" id="kobo.1149.1">; just for testing purposes, we will later toggle these variables in the settings page. </span><span class="koboSpan" id="kobo.1149.2">So, in </span><strong class="source-inline"><span class="koboSpan" id="kobo.1150.1">DataModel</span></strong><span class="koboSpan" id="kobo.1151.1">, change the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1152.1">spanishIsOn</span></strong><span class="koboSpan" id="kobo.1153.1"> variable to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1154.1">true</span></strong><span class="koboSpan" id="kobo.1155.1">, </span><span class="No-Break"><span class="koboSpan" id="kobo.1156.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.1157.1">
@AppStorage ("spanishIsOn") var spanishIsOn: Bool = true</span></pre>
<p><span class="koboSpan" id="kobo.1158.1">Now, come</span><a id="_idIndexMarker714"/><span class="koboSpan" id="kobo.1159.1"> into </span><strong class="source-inline"><span class="koboSpan" id="kobo.1160.1">ContentView</span></strong><span class="koboSpan" id="kobo.1161.1"> and select the length of the word that you want to use from the picker control. </span><span class="koboSpan" id="kobo.1161.2">Press the button and you will see a Spanish word of the length you chose and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1162.1">letterCount</span></strong><span class="koboSpan" id="kobo.1163.1"> string displaying the chosen language’s flag and picker selection for the </span><span class="No-Break"><span class="koboSpan" id="kobo.1164.1">word size:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer173">
<span class="koboSpan" id="kobo.1165.1"><img alt="Figure 12.11: Choosing the word size and language for the game " src="image/B18674_12_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.1166.1">Figure 12.11: Choosing the word size and language for the game</span></p>
<p><span class="koboSpan" id="kobo.1167.1">You can check</span><a id="_idIndexMarker715"/><span class="koboSpan" id="kobo.1168.1"> it for the other two languages as well by just setting one of those languages to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1169.1">true</span></strong><span class="koboSpan" id="kobo.1170.1"> and keeping the others set to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1171.1">false</span></strong><span class="koboSpan" id="kobo.1172.1">. </span><span class="koboSpan" id="kobo.1172.2">Also, if you don’t set one of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1173.1">AppStorage</span></strong><span class="koboSpan" id="kobo.1174.1"> variables to </span><strong class="source-inline"><span class="koboSpan" id="kobo.1175.1">true</span></strong><span class="koboSpan" id="kobo.1176.1">, then the picker will not pick the length of the word; it will default to an eight-letter word (this behavior will work itself out when we finish adding the rest of the code in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1177.1">next chapter).</span></span></p>
<p><span class="koboSpan" id="kobo.1178.1">After you’re done testing things out, make sure to set the </span><strong class="source-inline"><span class="koboSpan" id="kobo.1179.1">data</span></strong><span class="koboSpan" id="kobo.1180.1"> variable back </span><span class="No-Break"><span class="koboSpan" id="kobo.1181.1">to </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.1182.1">false</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.1183.1">.</span></span></p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor186"/><span class="koboSpan" id="kobo.1184.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.1185.1">So, we’ve come to the end of this chapter, and have done quite a bit of work. </span></p>
<p><span class="koboSpan" id="kobo.1186.1">We started building out our game, allowing the user to enter words to play the game, and adding checks to validate their choices. </span><span class="koboSpan" id="kobo.1186.2">We also added a button that the user can press to bring up a random word from a file of thousands of words, a button that brings up a settings page, a picker control, and a letter </span><span class="No-Break"><span class="koboSpan" id="kobo.1187.1">count string.</span></span></p>
<p><span class="koboSpan" id="kobo.1188.1">Next, we will continue building out the app, specifically building out the user interface, the settings page so it contains those three buttons that the user can select for the languages, and adding error messages when the user’s entered word is not valid. </span><span class="koboSpan" id="kobo.1188.2">So, let’s continue with the second part of this project in the </span><span class="No-Break"><span class="koboSpan" id="kobo.1189.1">next chapter.</span></span></p>
</div>
<div>
<div class="IMG---Figure" id="_idContainer175">
</div>
</div>
</body></html>