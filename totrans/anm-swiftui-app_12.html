<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-164"><a id="_idTextAnchor172"/>12</h1>
<h1 id="_idParaDest-165"><a id="_idTextAnchor173"/>Creating a Word Game (Part 1)</h1>
<p>In this project, we will start creating a “complete the word” game, which we will then finish in the next chapter. The word game will require the user to find words using the letters within a given word. To add a little twist to the game, we’ll offer it in three different languages – English, Spanish, and Italian.</p>
<p>Some new things that you will learn are how to add and customize a <code>PickerView</code>, implement user feedback in a few different ways (including with pop-up alerts, haptics, and sound), and add various animations to the user interface, including spring animations.</p>
<p>So, in this chapter, we will cover the following topics:</p>
<ul>
<li>Setting up the project and creating a data model</li>
<li>Building out the UI by adding a text field and list</li>
<li>Displaying a character count next to each word in the list</li>
<li>Checking the entered words for duplicates</li>
<li>Adding a random word with a button press</li>
<li>Checking whether the user’s entered word is possible</li>
<li>Checking whether the user’s entered word is a real word</li>
<li>Checking whether the user’s entered work is valid</li>
<li>Creating <code>HeaderView</code> with an <code>info</code> button</li>
<li>Creating <code>PickerView</code></li>
</ul>
<h1 id="_idParaDest-166"><a id="_idTextAnchor174"/>Technical requirements</h1>
<p>You can download the resources and finished project from the <code>Chapter 12</code><code> and 13</code> folder on GitHub: <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a>.</p>
<h1 id="_idParaDest-167"><a id="_idTextAnchor175"/>Setting up the project and creating a data model</h1>
<p>First, create<a id="_idIndexMarker656"/> a new Xcode project and call it <code>Find Words</code>. Then, in the<a id="_idIndexMarker657"/> GitHub repository, go to the <code>Chapter 12</code><code> </code>and <code>Chapter 13</code> folders; this folder will include three subfolders called <code>Language Data</code>, <code>Images</code>, and <code>Sound</code>. Add the <code>Images</code> folder to the Assets catalog, and the other folders to the Project navigator.</p>
<p>Next, we will create a data model file to hold the data for the <a href="https://github.com/PacktPublishing/Animating-SwiftUI-Applications">https://github.com/PacktPublishing/Animating-SwiftUI-Applications</a> app – to do this, press <em class="italic">Command + N</em>, choose the <code>DataModel</code>. In this file, import SwiftUI by adding the following code at the top of the file:</p>
<pre class="source-code">
import SwiftUI</pre>
<p>As we have done before, we add a class to hold all of the properties and methods. We’ll call the class <code>DataModel</code>, and it needs to conform to the <code>ObservableObject</code> protocol in order for us to access this data later on. Then, we’ll add the properties we need:</p>
<pre class="source-code">
class DataModel: ObservableObject {
    @Published var allWordsInFile = [String]()
    @Published var baseWord = ""
    @Published var userEnteredWord = ""
    @Published var userEnteredWordsArray = [String]()
    @Published var letterCount = ""
    @Published var showSettings: Bool = false
    
    //error properties
    @Published var errorMessageIsShown = false
    @Published var errorTitle = ""
    @Published var errorDescription = ""
    
    //properties to stpre in user defaults
    @AppStorage ("selectedSegment") var selectedSegment:
      Int = 0
    @AppStorage ("englishIsOn") var englishIsOn: Bool = 
      false
    @AppStorage ("spanishIsOn") var spanishIsOn: Bool = 
      false
    @AppStorage ("italianIsOn") var italianIsOn: Bool = 
      false
   
    //splash view property
    @Published var change = false  
}</pre>
<p>Let’s break<a id="_idIndexMarker658"/> down the<a id="_idIndexMarker659"/> code:</p>
<ul>
<li>First, we have an array called <code>allWordsInFile</code>, which will hold all of the words needed to play the game. We will use three separate files, one for English, one for Spanish, and one for Italian. This array will be loaded with whichever language is selected to play the game with.</li>
<li>Next is a <code>baseWord</code> property, which will contain the word the user is working with and trying to find new words from.</li>
<li>Then, we have another property called <code>userEnteredWord</code> that will hold the user’s word when they type it into the text field.</li>
<li>Next is another array called <code>userEnteredWordsArray</code>, which will hold all of the user’s guessed words so that we can keep track of what they have completed so far.</li>
<li>Next is a property called <code>letterCount</code>, which will be used to keep track of the number of letters per word being used so that we can tally an average number of letters per word. For example, if the user is only choosing three-letter words, we will display that word letter average on the screen.</li>
<li>Next is the Boolean that will open <code>SettingsView</code>, allowing the user to change the game’s language.</li>
<li>Next are three error properties we will use to show an alert when the user misspells words or enters duplicate words, which are words that are already in the list.</li>
<li>Next are what are called <code>AppStorage</code> properties. These are used to save the user’s language settings in memory, so when they close the app and then come back later, their settings are preserved. When we prefix a property with the <code>AppStorage</code> wrapper, a place in memory on the phone will preserve the user settings.</li>
<li>Next, a <a id="_idIndexMarker660"/>property to display a splash screen. A splash screen<a id="_idIndexMarker661"/> is an opening scene that the user will see briefly as the app loads in the background.</li>
</ul>
<p>Let’s continue and add all the methods we need for the project now into <code>DataModel</code>, right under the properties we just added: </p>
<pre class="source-code">
 //FUNCTIONS
     //starts the game off with a random word by looking in 
       the app's bundle for the language file
    func getRandomWord() {
        guard let wordsURL = Bundle.main.url(forResource: 
        setWordLengthAndLanguage(), withExtension: "txt"),
        let wordsConverted = try? String(contentsOf:
          wordsURL) else {
        assert(false, "There was a problem loading the data
          file from the bundle.")
            return
        }
        let allWordsInFile = 
          wordsConverted.components(separatedBy: "\n")
        baseWord = allWordsInFile.randomElement() ?? 
          "SwiftUI"
    }
    //sets the language for the game
    func setWordLengthAndLanguage() -&gt; String {
      return ""
    }
    
    //adds a new word to the game
    func addWordToList() {
        
    }
    
    //check to see if the word is a duplicate
    func isWordDuplicate(word: String) -&gt; Bool {
        return false
    }
    
    //check to see if the word is possible given the base
      word's letters
    func isWordFoundInBaseWord(userGuessWord: String) -&gt;
      Bool {
        return false
    }
    
    //check to see if the word is a real word in dictionary
    func isWordReal(word: String) -&gt; Bool {
        return false
    }
    //error message
    func displayErrorMessage(messageTitle: String,
      description: String) {
        
    }</pre>
<p>Let’s break this <a id="_idIndexMarker662"/>code down too:</p>
<ul>
<li>We have a method <a id="_idIndexMarker663"/>to grab a random word from the language files</li>
<li>We have a function to set the word length – either 7, 8, or 9 letters – and language – either English, Spanish, or Italian</li>
<li>There’s a function to add the user’s word to a list so that they can see all the words that they have found so far</li>
<li>Then a function to check whether their word is a duplicate; we don’t want duplicates in the list</li>
<li>Then, a function to check to see whether the word is possible given the word they’re working with</li>
<li>We also have a function to check to see whether the word is a real word in the language of choice (we don’t want made-up words!)</li>
<li>And then finally, a function to display an error message to the user if they type in a word that doesn’t exist or cannot be made</li>
</ul>
<p>As you see <a id="_idIndexMarker664"/>from the code, I have filled out only one function for now, and the <a id="_idIndexMarker665"/>rest of the functions are just known as <code>return</code> statement. This is helpful because we can still continue writing code in the interface, call these functions stubs, and the code will still build cleanly, even though it won’t do anything yet.</p>
<p>We will fill out the body of the other functions soon enough, but let’s look at the one function I did add code into – <code>getRandomWord()</code>. This function starts by trying to access the app bundle, which is where we placed our language files. When we add files to the project, they are put into the app bundle. The app bundle is a folder where all the app files are stored and used to make the app work. We need to access the bundle and find the path to those language files so we can load the words they contain and use them in the game.</p>
<p>To access them, Swift gives us a method called <code>url(forResource)</code> for locating the path of a file – we simply type the name of the file into the first parameter and the extension into the second parameter. For now, we’re just going to load up the seven-letter word file in the English language (but later on, we’ll be accessing words of other sizes and other languages’ files). </p>
<p>For the extension, I put in <code>txt</code> for a text file. If we find that file, then we proceed to the next step where we attempt to convert that file into a string so that we can manipulate it. If the code is able to complete that task, then it will separate the words in the file using the <code>components(separatedBy)</code> method and pass in the new line character, so each word will be on its own line. This is helpful so we can access these words later, one by one.</p>
<p>Next, we need to get a random word from the file and store it in the <code>baseWord</code> property. Notice that we need to use the ternary operator here. That’s because the <code>randomElement</code> function is an optional function. For this reason, it might not have a word to get, so, we offer an alternative word to keep the code from crashing in case there are no words in the file (this would only happen if the file became corrupt, which is rare).</p>
<p>Finally, if we do come across a problem along the way, we’ll use the <code>assert</code> function. <code>assert</code> takes two arguments: a condition to check, and a message to display if the condition is <code>false</code>. If the condition is <code>false</code>, the message will be displayed and the app will halt in a debugging environment. In a production environment, the <code>assert</code> statement will be ignored.</p>
<p>We will use the <code>getRandomWord()</code> function later to get a random word that the user can play with and try to find new words from.</p>
<p>Okay, that’s all the properties and functions in place, with one function complete. </p>
<p>Now let’s go <a id="_idIndexMarker667"/>into the <code>App.Swift</code> file and create an instance of the <code>DataModel</code> class, and <a id="_idIndexMarker668"/>then inject that instance into <code>ContentView</code> so that the data model is available from anywhere in the app:</p>
<pre class="source-code">
@main
struct FindWordsApp: App {
    @StateObject private var appData = DataModel()
    
    var body: some Scene {
        WindowGroup {
            ContentView(appData: DataModel())
        }
    }
}</pre>
<p>This should be familiar to you – we have created the <code>DataModel</code> instance and passed it into the root view, <code>ContentView</code>. We will also get an error because we now need to update <code>ContentView</code>, and the <code>Previews</code>. Let’s add the following modifications in <code>ContentView</code> and finish off implementing the <code>Observable</code> object protocol by adding a <code>DataModel</code> instance so that we can pass the data into the views:</p>
<pre class="source-code">
@ObservedObject var appData: DataModel
Now let's update the Previews at the bottom of the file 
  too:
ContentView(appData: DataModel())</pre>
<p>Then, let’s add a property to display a random word at the top of <code>ContentView</code>:</p>
<pre class="source-code">
@State var wordToPlayFrom = "Click for Word"</pre>
<p>The <code>wordToPlayFrom</code> property will be set to a random word, which will be the user’s word to start playing with and finding new words to make with. It’s being set to a string that will prompt the user to <a id="_idIndexMarker669"/>start the game. </p>
<p>Okay, our<a id="_idIndexMarker670"/> data model is now set up here in <code>ContentView</code>; let’s focus on building out the user interface next.</p>
<h1 id="_idParaDest-168"><a id="_idTextAnchor176"/>Building out the UI by adding a text field and list</h1>
<p>To build <a id="_idIndexMarker671"/>out our UI, first, we’ll add a text field <a id="_idIndexMarker672"/>view so the user can enter their answers, and then we’ll add a list view, so all of the user’s words can be listed in a table.</p>
<p>To do that, go into the <code>body</code> property of <code>ContentView</code> and remove the existing boilerplate code for the <code>Text</code> and <code>Image</code> views, and add the following code:</p>
<pre class="source-code">
//MARK: - TEXTFIELD - LIST TABLE
    VStack(alignment: .center, spacing: 15) {
       //MARK: - TEXT FIELD AND LIST
            TextField("Enter your word", text: 
              $appData.userEnteredWord)
                .textInputAutocapitalization(.never)
             .textFieldStyle(RoundedBorderTextFieldStyle())
                .padding(.horizontal, 55)
                .onSubmit(appData.addWordToList)
         ///List view to display the user input
         List(appData.userEnteredWordsArray, id: \.self) {
           word in
                Text(word)
            .foregroundColor(.black)
            .font(.system(size: 18))
        }
        .frame(width: 285, height: 190, alignment: .center)
        .cornerRadius(10)
        .foregroundColor(Color.blue)
        .font(.system(size: 50))
    }</pre>
<p>Here, we added a text field so we can grab the user’s input, while changing <code>.textInputAutocapitalization</code> to <code>never</code> so that auto-capitalize won’t capitalize what the user types into the text field. The word files we imported into the project are all <a id="_idIndexMarker673"/>written in lowercase, so turning auto-capitalization<a id="_idIndexMarker674"/> off helps with accessing those words and checking the letters.</p>
<p>Next, the text field gets a little styling and a little padding, before we call the <code>onSubmit</code> modifier and pass the <code>addWordToList</code> property into it. What this modifier does is add an action to be performed when the user types in a word and hits <em class="italic">Enter</em>. That action being performed is a call to the <code>addWordToList</code> method that we have in our data model. That method will process the user’s input and see whether their word is allowed to be used based on certain criteria, such as whether the word is even possible in the chosen language and whether they make it from the letters present in the base word.</p>
<p>Notice that in order to access our data model, we have to use our <code>DataModel</code> instance’s <code>appData</code> that we created at the top of this file; this gives us access to all the methods and properties we created in <code>DataModel</code>.</p>
<p>Continuing with the code, we then move on to the <code>List</code> view, which creates a list to display the user’s words. This uses the <code>id</code> parameter to uniquely identify each word in the <code>guessedWords</code> array. When we iterate (loop) through <code>userEnteredWordsArray</code>, we need a way of identifying its content – each element in that array has to be unique to be able to use it and fortunately, every word is indeed unique (no two words are the same). So, what the <code>id</code> parameter you see here is saying is that it will <a id="_idIndexMarker675"/>use the word’s own name as its <a id="_idIndexMarker676"/>identifier (the <code>self</code> part), and we can access the elements in the array. </p>
<p>After that, we did a bit more styling. We set the text color of the words to <code>black</code> and their size to <code>18</code> points. Then, we set the frame size of the <code>List</code> view, as well as changing the color to <code>blue</code> and providing a <code>cornerRadius</code> property.</p>
<p>Now, if we run the app, we can type words into the text field, but when we press <em class="italic">Enter</em>, the word isn’t being placed into the <code>List</code> view:</p>
<div><div><img alt="Figure 12.1: Words typed into the text field " src="img/B18674_12_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1: Words typed into the text field</p>
<p>The reason the <a id="_idIndexMarker677"/>words are not going into the list is that we<a id="_idIndexMarker678"/> just haven’t filled out the empty <code>addWordToList</code> function in the <code>DataModel</code> class yet. Let’s fill out that method now with some code that will allow the user’s typed-in word to be displayed inside the list:</p>
<pre class="source-code">
func addWordToList() {
    let usersWord = userEnteredWord.trimmingCharacters(in:
      .whitespacesAndNewlines).lowercased()
    //guard against one or two letter words - they are too 
      easy
    guard usersWord.count &gt; 1 else {
        return
    }
    userEnteredWordsArray.insert(usersWord, at: 0)
    userEnteredWord = ""
  }</pre>
<p>Here, we<a id="_idIndexMarker679"/> created a <code>userWord</code> constant, which<a id="_idIndexMarker680"/> is going to store the new word that the user adds to the list. We first check the user’s word for white spaces. This way, if the user types some extra spaces in the text field by mistake, the <code>trimmingCharacters</code> function will eliminate them. Next, the word is made lowercase using the <code>lowercased</code> function.</p>
<p>Then, we use the <code>guard</code> statement, which is very similar to the <code>if</code> statement, which checks to see whether the word that the user entered has more than one letter. If it does, it will proceed to the next line of code. Otherwise, the method will return right there and not run any more code. When the code “returns” from a method, that means the code is finished running that method, and even if there’s more code inside that method, it won’t run. The reason why we’re checking to see whether there need to be at least two letters in the user’s word is because those are too easy. Even though there aren’t many one-letter words in any given language, why not simply remove them altogether?</p>
<p>After the user’s word has been trimmed and made lowercase, it’s then added to <code>userEnteredWordsArray</code>, and inserted at index zero using the <code>insert(at)</code> method. This index is at the beginning of the array, and the reason why we insert the word at the beginning and don’t append it to the end of the array is that we want each new word to appear at the top of the list so that it’s readily visible.</p>
<p>Finally, we set the <code>newWord</code> property back to an empty string, which effectively clears out the <code>Text</code> view when the user presses <em class="italic">Enter</em>, so they can type in another word when ready.</p>
<p>Now, if we run the project, we can see that when we type words into the text field and press <em class="italic">Enter</em>, they now appear in the list:</p>
<div><div><img alt="Figure 12.2: Words are now entered into the list " src="img/B18674_12_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2: Words are now entered into the list</p>
<p>New words will <a id="_idIndexMarker681"/>appear at the top of the list. The <code>List</code> view, by <a id="_idIndexMarker682"/>default, is also scrollable, so the user can easily scroll up and down to see previously entered words.</p>
<p>Let’s continue with the UI and display the number of characters each word contains.</p>
<h1 id="_idParaDest-169"><a id="_idTextAnchor177"/>Displaying a character count next to each word in the list</h1>
<p>I also <a id="_idIndexMarker683"/>want to add a number next to each word that indicates how many letters are in the word that the user has entered. Later, we will take this number from each word and add them together to get an average of how the user is doing in terms of the length of words they are entering.</p>
<p>We can put this number inside a circle, and luckily this is very easy, as Swift gives us system images of circles with numbers in them that are already created; all we have to do is call them up. So, back in <code>ContentView</code>, then inside the <code>List</code> view, let’s put the <code>Text</code> view inside of an <code>HStack</code> (so they are side by side), and add an <code>Image</code> view for the number circle:</p>
<pre class="source-code">
List(guessedWordsArray, id: \.self) { word in
        HStack {
            Image(systemName: 
              "\(word.count).circle")
            Text(word)
        } .foregroundColor(.black)
          .font(.system(size: 18))
    }</pre>
<p>The <code>Image</code> view gets a system image of a circle. The <code>word.count</code> code statement gets the number of letters in the user’s word and displays that number inside of a circle. Now if we run the code, all the words that are typed in will have their letter counts displayed in a circle to the left of the given <a id="_idIndexMarker684"/>words:</p>
<div><div><img alt="Figure 12.3: The letter count displayed in a circle " src="img/B18674_12_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.3: The letter count displayed in a circle</p>
<p>Let’s move on to now checking the user’s words for duplicates.</p>
<h1 id="_idParaDest-170"><a id="_idTextAnchor178"/>Checking the entered words for duplicates</h1>
<p>Now that we’re <a id="_idIndexMarker685"/>displaying the words that the user enters, how about we check them to make sure they are real words in a dictionary and that there are no duplicate words in the list? We have all the function stubs in place for these checks, so let’s start filling them out.</p>
<p>The first function we’ll fill out is <code>isWordDuplicate</code>, which we’ll modify to look like this: </p>
<pre class="source-code">
 func isWordDuplicate(word: String) -&gt; Bool {
    return userEnteredWordsArray.filter { $0 == word 
      }.isEmpty
  }</pre>
<p>What this does is to check <code>userEnteredWordsArray</code> to see whether it contains the word the user has typed into the <code>Text</code> field. Here’s how it works. The <code>return</code> statement in this function uses the <code>filter</code> method on the <code>userEnteredWordsArray</code> array. The <code>filter</code> method takes a closure as its argument, which is evaluated for each element of the array. In this case, the closure checks whether the current element of the array (<code>$0</code>) is equal to the word passed as an argument to the function.</p>
<p>The result of this <code>filter</code> operation is a new array that contains all the elements of <code>userEnteredWordsArray</code> that match the given condition. If this new array is not empty, that means that the word already exists in the <code>userEnteredWordsArray</code>, so the function returns <code>false</code>. If the new array is empty, that means that the word is not duplicated, so the function returns <code>true</code>. The <code>isEmpty</code> property of the array is used to check whether the array is empty.</p>
<p>Now, just filling out the function is not enough to have it check for duplicates; we have to call this function inside of the <code>addWordToList</code> function so that we can use it to check the new <a id="_idIndexMarker686"/>words before they are added to the list. Let’s do that now – inside the <code>addWordToList</code> function, add the following, right after the <code>userWord</code> instance is created:</p>
<pre class="source-code">
func addWordToList() {
    let usersWord = 
      userEnteredWord.lowercased().trimmingCharacters(in: 
      .whitespacesAndNewlines)
    //is the word a duplicate
   if !isWordDuplicate(word: usersWord) {
    displayErrorMessage(messageTitle: "You already used 
      this word", description: "Keep looking!")
    return
        }
            •••••••••
}</pre>
<p>This code checks the <code>isWordDuplicate</code> function to see whether it’s returning <code>true</code> by using the <code>!</code> operator in front of it. Remember, the <code>isWordDuplicate</code> function returns a Boolean value, either <code>true</code> or <code>false</code>, so if this function returns <code>false</code>, then the <code>if</code> statement runs the code in its body, which is another function called <code>displayErrorMessage</code>. This will display an error message to the user telling them that their word is a duplicate (we haven’t set up our error messaging system yet, but we will soon!). </p>
<p>Now I’d like you to come back into <code>ContentView</code> and run the app, enter a word, and see it appear in the list. Then, try entering that same word again, and you’ll notice you’re not able to. The <code>guard</code> statement stops it from happening because it checks and sees that the<a id="_idIndexMarker687"/> word has already been entered into the list. </p>
<p>Next, we want to add a button that will grab a random word from the word files we imported into the project, which gives the user a word to play with and try to find words from.</p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor179"/>Adding a random word with a button press</h1>
<p>Before we<a id="_idIndexMarker688"/> continue with the methods and fill them out, we need a button to provide a random word that the user can play off and try to find words from. After all, it’s not a challenge to just type random words and for them to appear in the list currently.</p>
<p>We’ll start by supplying a file of thousands of seven-letter words, from which one will be shown on the screen randomly when a button is pressed. We will also give the user the choice to choose a seven-, eight-, or nine-letter word, and the option to select another language later, but right now, let’s just stick with seven-letter English words.</p>
<p>If you haven’t done so already, go to the GitHub folder, select the <code>Language</code> files folder, and drop the contents of that folder into the Project navigator. Once done, select them all, right-click, and choose <code>Languages</code> – this helps keep everything organized in the Project navigator. </p>
<p>Now those files are added to the project and we have already built out the <code>getRandomWord</code> function, which will get us a random word from a specified file, so now we need to call this function so that we can show the word to the user – we can do that with a button. Add the<a id="_idIndexMarker689"/> following code directly in <code>VStack</code>, above the <code>Text</code> field code:</p>
<pre class="source-code">
 //MARK: - BUTTON
        Button(action: {
            appData.getRandomWord()
            wordToPlayFrom = appData.baseWord
        }){
            ZStack {
                Image("background").resizable()
                    .renderingMode(.original)
                    .frame(width: 125, height: 50)
                    .cornerRadius(15)
                Text("New Word")
                    .foregroundColor(.white)
             }
        }.padding(7)
            .shadow(color: .black, radius: 2, x: 1, y: 1)
            .shadow(color: .black, radius: 2, x: -1, y: -1)
        
        Text(wordToPlayFrom)</pre>
<p>This code creates a button. Inside the <code>action</code> parameter for the button, we use our <code>appData</code> instance and call the <code>getRandomWord</code> function. We also set the <code>wordToPlayFrom</code> property to the <code>baseWord</code> value because <code>baseWord</code> contains the random word that will appear on the screen.</p>
<p>Now every time the button is pressed, a randomized word from our text file is placed into <code>baseWord</code>, which then gets placed into the <code>wordToPlayFrom</code> property to be displayed.</p>
<p>At the end of the button <a id="_idIndexMarker690"/>code, we create a <code>Text</code> view that displays <code>wordToPlayFrom</code> on the screen. The button is then styled with a wood background image, a slight corner radius, a little bit of shadow, and the words <strong class="bold">New Word</strong>.</p>
<p>After adding that code, the button should look like this:</p>
<div><div><img alt="Figure 12.4: A button to create a random word " src="img/B18674_12_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.4: A button to create a random word</p>
<p>Now, press the <a id="_idIndexMarker691"/>button, and you will get a random word that a user can work with. Also, notice that when you press the button, it actually looks like it’s being pressed down; we get this behavior by default, which really adds to the user experience.</p>
<p>The game is coming along, but we want to continue checking the word the user enters to see whether it can be made from the randomized word. Let’s do that up next.</p>
<h1 id="_idParaDest-172"><a id="_idTextAnchor180"/>Checking if the user’s entered word is possible</h1>
<p>Looking for<a id="_idIndexMarker692"/> duplicate words is not enough. Now that we have generated a random seven-letter word, we want to make sure that the user’s entered word can be made from the letters that are in the random word. For example, if the random word is <code>books</code>, that would be invalid because <code>s</code> is not in the random word.</p>
<p>Let’s go back to the <code>DataModel</code> class and add code to the <code>isWordFoundInBaseWord</code> function so that we can check that the word can be made from <code>baseWord</code>:</p>
<pre class="source-code">
  //check to see if the word is possible given the baseWord 
    letters
   func isWordFoundInBaseWord(userGuessWord: String) -&gt; 
     Bool {
        var comparisonWord = baseWord
        return userGuessWord.allSatisfy { letter in
            guard let position = 
              comparisonWord.firstIndex(of: letter) else {
                return false
            }
            comparisonWord.remove(at: position)
            return true
        }
    }</pre>
<p>Here’s how this function works. The <code>isWordFoundInBaseWord</code> function takes a <code>String</code> parameter, <code>userGuessWord</code>, and returns a <code>Bool</code> value indicating whether or not <code>userGuessWord</code> can be made by removing letters from the <code>baseWord</code> string.</p>
<p>The function<a id="_idIndexMarker693"/> starts by creating a <code>comparisonWord</code> variable equal to <code>baseWord</code>. The <code>comparisonWord</code> variable is used to keep track of the remaining letters in <code>baseWord</code> that haven’t been matched by <code>userGuessWord</code>.</p>
<p>Next, the function uses the <code>allSatisfy</code> method of <code>String</code> to check that all the letters in <code>userGuessWord</code> can be found in <code>comparisonWord</code>. The <code>allSatisfy</code> method iterates over each character in the string and returns <code>true</code> if the closure passed to it returns <code>true</code> for all characters.</p>
<p>The closure takes a single parameter letter, representing the current letter in <code>userGuessWord</code> being processed. It first uses the <code>firstIndex(of:)</code> method to find the index of a letter in <code>comparisonWord</code>. If a letter is not found in <code>comparisonWord</code>, the closure immediately returns <code>false</code>, which will make the overall <code>allSatisfy</code> call return <code>false</code>.</p>
<p>If a letter is found in <code>comparisonWord</code>, the closure removes that letter from <code>comparisonWord</code> using the <code>remove(at:)</code> method. Finally, the closure returns <code>true</code>.</p>
<p>If the <code>allSatisfy</code> call returns true, the function returns <code>true</code>, indicating that <code>userGuessWord</code> can be made by removing letters from <code>baseWord</code>. If <code>allSatisfy</code> returns <code>false</code>, the function returns <code>false</code>.</p>
<p>The logic for this can be a little tricky to understand at first, but it basically looks at each letter in the user’s word and compares it to <code>baseWord</code>. Any letter that’s not in <code>baseWord</code> will cause the method to return <code>false</code>, meaning the user’s word is incorrect.</p>
<p>Now that we have this method written out, let’s put it to work. We need to call this method in the <code>addWordToList</code> function, so place this code after the <code>if</code> statement’s closing brace:</p>
<pre class="source-code">
func addWordToList() {
        let usersWord = 
          userEnteredWord.trimmingCharacters(in: 
          .whitespacesAndNewlines).lowercased()
        //is the word a duplicate
        if !isWordDuplicate(word: usersWord) {
        displayErrorMessage(messageTitle: "You already used
          this word", description: "Keep looking!")
        return
        }
   <strong class="bold">     //is the word possible given your base word letters </strong>
<strong class="bold">          to work with?</strong>
<strong class="bold">        guard isWordFoundInBaseWord(userGuessWord:</strong>
<strong class="bold">          usersWord) else {</strong>
<strong class="bold">            displayErrorMessage(messageTitle: "This word is</strong>
<strong class="bold">            not possible", description: "Create only words</strong>
<strong class="bold">            from the letters in the given word")</strong>
<strong class="bold">            return</strong>
<strong class="bold">        }</strong>
            userEnteredWordsArray.insert(usersWord, at: 0)
            userEnteredWord = ""        
        }</pre>
<p>What we’re doing<a id="_idIndexMarker694"/> here is calling the <code>isWordFoundInBaseWord</code> function, and it will have <code>userGuessedWord</code> passed into it. The function checks whether the word is possible to create – if not, we’re going to display an alert message to the user using the <code>displayErrorMessage</code> method (again, the alert messages will be created later).</p>
<p>Let’s try this out. Come back into <code>ContentView</code> and run the program. You will see that you cannot enter a word unless those letters are also present in <code>baseWord</code>:</p>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 12.5: Checking whether the word is possible using the base word’s letters " src="img/B18674_12_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.5: Checking whether the word is possible using the base word’s letters</p>
<p>Here, I entered <code>set</code> into <a id="_idIndexMarker695"/>the list because that can be made from <code>sent</code> because there is no <code>n</code> in <code>isWordFoundInBaseWord</code> function is working perfectly.</p>
<h1 id="_idParaDest-173"><a id="_idTextAnchor181"/>Checking whether the user’s entered word is a real word</h1>
<p>There is one<a id="_idIndexMarker696"/> final check we need to do, and that is to see whether the word is an actual word in the dictionary. This check is important because the user could rearrange letters in <code>baseWord</code>, make up their own word, and enter it into the list. We want to prevent that and check each of the words against an actual dictionary. To do that, we can use the <code>UITextChecker</code> class. This class has methods and properties we can use to check whether a word is an actual word in the dictionary, and what’s especially nice is it will work with misspellings and authenticity in Spanish and Italian as well.</p>
<p>So, let’s go into the <code>DataModel</code> class and add the following code to the <code>isWordInDictionary</code> function:</p>
<pre class="source-code">
 func isWordInDictionary(word: String) -&gt; Bool {
    return UITextChecker().rangeOfMisspelledWord(in: word,
      range: NSRange(location: 0, length:
      word.utf16.count), startingAt: 0, wrap: false,
      language: "en").isNotFound
    }</pre>
<p>We’re going to get an error here because I am adding this <code>isNotFound</code> property. So, let’s fix that error first, and then we can go over what the code is doing. Outside the class’s closing brace, add the following extension:</p>
<pre class="source-code">
extension NSRange {
    var isNotFound: Bool {
        return location == NSNotFound
    }
}</pre>
<p>Going back now, the <code>isWordInDictionary</code> function checks whether a given word exists in the English dictionary. It does so by creating an instance of <code>UITextChecker</code> and calling the <code>rangeOfMisspelledWord</code> method on it. This method takes several arguments:</p>
<ul>
<li><code>word</code>: The word to check for spelling</li>
<li><code>range</code>: The range of the word to check, specified as <code>NSRange</code></li>
<li><code>startingAt</code>: The starting position of the word to check within the specified range</li>
<li><code>wrap</code>: A Boolean value indicating whether to wrap around the end of the range to the beginning when checking for misspelled words</li>
<li><code>language</code>: The language to use for spell checking – in this case, <code>"en"</code> for English</li>
</ul>
<p>The method <a id="_idIndexMarker697"/>then returns an <code>NSRange</code> that indicates the range of the first misspelled word found. If no misspelled word is found, the <code>location</code> property of the returned range is set to <code>NSNotFound</code>.</p>
<p>The <code>isNotFound</code> computed property is an extension on <code>NSRange</code> that returns <code>true</code> if the <code>location</code> property is equal to <code>NSNotFound</code>, and <code>false</code> otherwise. This makes it more readable and allows us to write <code>isNotFound</code> instead of comparing the location of <code>NSNotFound</code> in the function.</p>
<p>Summing it up, the function creates an instance of the <code>UITextChecker</code> class. <code>UITextChecker</code> looks through its dictionary for any misspelling to make sure the word is real – if it is in the dictionary, <code>true</code> is returned and the word will be entered into the user’s list; otherwise, <code>false</code> will be returned, and we show a message to the user saying that this is not an actual word in the dictionary.</p>
<p>Now that the function is complete, let’s use it. Add the following code directly after the closing brace of the previous <code>guard</code> statement in the <code>addWordToList</code> function:</p>
<pre class="source-code">
 //is the word spelled correctly and a real word in the
   chosen language? - only real words allowed
    guard isWordInDictionary(word: usersWord) else {
        displayErrorMessage(messageTitle: "This is not a 
          valid word", description: "Use only real words")
        return
    }</pre>
<p>With that code in place, give the app another go and make up your own word using the given letters<a id="_idIndexMarker698"/> in <code>baseWord</code>:</p>
<div><div><img alt="Figure 12.6: Checking whether the word is in the dictionary " src="img/B18674_12_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.6: Checking whether the word is in the dictionary</p>
<p>Here, I made up a word using the letters from <code>baseWord</code> – <code>tesh</code> – however, I wasn’t allowed to add the word to the list because there is no such word in the English language, so we know the function is working.</p>
<p>And that really completes all of the word-checking functionality for the app; we will add pop-up <a id="_idIndexMarker699"/>alerts for when a user’s word doesn’t pass any of those checks.</p>
<p>Let’s focus on building out the UI some more. We’re going to add a text string at the top that will be the name of the app, and we can style this in a separate file.</p>
<h1 id="_idParaDest-174"><a id="_idTextAnchor182"/>Creating HeaderView with an info button</h1>
<p>Let’s continue<a id="_idIndexMarker700"/> building out the UI and add a header title, which will be the name of our app. We can create this header in a separate file so we can keep our <code>ContentView</code> clutter free.</p>
<p>The purpose of <code>HeaderView</code> is twofold – to set the title of the app, and to add an <code>info</code> button that opens a user settings page.</p>
<p>Press <em class="italic">Command + N</em>, choose a <code>HeaderView</code>. Then, add a <code>Binding</code> property in the <code>HeaderView</code> struct:</p>
<pre class="source-code">
@Binding var showSettings: Bool
Now let's update the Previews struct to satisfy Xcode and so we can build cleanly again:
HeaderView(showSettings: .constant(false))
        .previewLayout(.fixed(width: 375, height: 80))</pre>
<p>Next, add the following code inside the <code>body</code> property:</p>
<pre class="source-code">
   ZStack {
          Image("title").resizable()
              .frame(width: 250, height: 50)
              .shadow(color: .black, radius: 1, x: 1, y: 1)
          
          //info button
          Button(action: {
          }){
              Image(systemName: "info.circle")
                  .font(.system(size: 30, weight: .medium))
                  .padding(.top, 10)
                  .accentColor(Color.black)
          }.offset(x: 160)
      }</pre>
<p>First, we added a <code>ZStack</code> to hold two views, an image displaying the title of the app, and a button that we will set up to take the user to a settings page, where they can choose another language to play the game in. Also added was the <code>shadow</code> modifier on the image to help make it stand out a little more.</p>
<p>Inside the button closure, we use the system image of an info circle, then some top padding on it to align the button vertically with the image, and then we colored the button black using the <code>accent</code> modifier. After that, we offset the button to the right <code>150</code> points so that it’s next to the image on the right side of the screen.</p>
<p>When the <code>info</code> button is pressed, a settings page will open, giving the user three language options for the game. The <code>showSettings</code> property will be used to open up <code>SettingsView</code>, but<a id="_idIndexMarker701"/> we don’t have <code>SettingsView</code> yet, so let’s make one. Press <em class="italic">Command + N</em>, choose <code>SettingsView</code>. And just like that, we now have our <code>SettingsView</code>. Let’s come back into the <code>SettingsView</code>. </p>
<p>Inside the button, we need to toggle the <code>showSettings</code> state variable, so add the following line of code to the button body:</p>
<pre class="source-code">
showSettings.toggle()</pre>
<p>And finally, in order to open up a sheet over another view, we need to call the <code>sheet</code> modifier on the button, so add the code to the end of the button’s closing brace:</p>
<pre class="source-code">
 Button(action: {
              self.showSettings.toggle()
          }){
              Image(systemName: "info.circle")
                  .font(.system(size: 30, weight: .medium))
                  .padding(.top, 10)
                  .padding(.horizontal, 10)
                  .accentColor(Color.black)
          }.offset(x: 160)
           .sheet(isPresented: $showSettings) {
              //show the settings view
              SettingsView()
          }</pre>
<p>The <code>sheet</code> modifier is used in SwiftUI to open a sheet, which is simply another view that opens by sliding up from the bottom of the screen. The sheet is triggered by the <code>isPresented</code> parameter – when the value of <code>isPresented</code> becomes <code>true</code>, the code in the <code>sheet</code> modifier’s body will run. In the <code>sheet</code> modifier’s closure, there is a call to <code>SettingsView</code>; this is the view (sheet) that gets presented over <code>ContentView</code>. To dismiss the sheet, the user slides it back down with their finger.</p>
<p>To see this in action, we need to add two more lines of code inside <code>ContentView</code>. First, go into that file, and add a <code>State</code> property that can connect to the <code>Bindin</code>g variable of <code>HeaderView</code>. Add <a id="_idIndexMarker702"/>this <code>State</code> variable right after the previous property at the top in <code>ContentView</code>:</p>
<pre class="source-code">
@State var showSettings: Bool = false</pre>
<p>I’m calling it <code>showSettings</code>, the same as the variable it’s binding to from <code>HeaderView</code>. </p>
<p>Now, we just need to add a call to <code>HeaderView</code> to get the <code>info</code> button working. Add this line of code inside <code>VStack</code> at the top:</p>
<pre class="source-code">
HeaderView(showSettings: $showSettings)</pre>
<p>And that’s all we need to get <code>SettingsView</code> working. Try it out – press the information button in <code>ContentView</code> and <code>SettingsView</code> opens:</p>
<div><div><img alt="Figure 12.7: SettingsView " src="img/B18674_12_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.7: SettingsView</p>
<p>To dismiss the view, simply slide down on the opened view. This “sliding to close” behavior is automatically baked into the <code>sheet</code> modifier, so we don’t have to implement it.</p>
<p>So, we<a id="_idIndexMarker703"/> have <code>SettingView</code> working, although it doesn’t do much right now other than open up and show <code>PickerView</code> that the user can press on to set the size of the words they want to play with.</p>
<h1 id="_idParaDest-175"><a id="_idTextAnchor183"/>Creating PickerView</h1>
<p>A <code>PickerView</code> is a view<a id="_idIndexMarker704"/> that displays various options to the user. The picker can either be a single button with a drop-down list, a segmented list with multiple buttons, or a wheel that the user can spin to select an option. </p>
<p>There are two main differences between these three pickers in terms of style. The first is how they appear in your app. The second is the number of options available to the user – the wheel can hold many, many options for the user, whereas a button picker or a segmented control picker is limited by the amount of space on the screen.</p>
<p>Since we will be offering just three options to the user, a seven-, eight-, or nine-letter word option, we’ll go with the segmented control.</p>
<h2 id="_idParaDest-176"><a id="_idTextAnchor184"/>Adding PickerView</h2>
<p>Let’s start by <a id="_idIndexMarker705"/>adding a new <code>PickerView</code>. Next, let’s add an instance of the <code>DataModel</code> class at the top of the struct so we have access to the data properties:</p>
<pre class="source-code">
@ObservedObject var appData = DataModel()</pre>
<p>Then add a <code>VStack</code>, and inside that, add a <code>topBar</code> image that we have in the Assets catalog, which will help to frame the picker:</p>
<pre class="source-code">
VStack(alignment: .center, spacing: 10) {
          //bar
          Image("topBar").resizable()
              .frame(width: 280, height: 8)
              .padding(.bottom, 10)
              .shadow(color: .black, radius: 1, x: 1, y: 1)
}</pre>
<p>In the code, we add the <code>topBar</code> image and put a little padding and shadow around it to help it stand out against the background (which will be added soon). Then, we use <code>10</code> points of center spacing on the <code>VStack</code> to keep some space between the views.</p>
<p>Now, add the <code>Picker</code> control underneath the last line of code we just added:</p>
<pre class="source-code">
Picker("", selection: $appData.selectedSegment) {
              Text("7 Letter").tag(1)
              Text("8 Letter").tag(2)
              Text("9 Letter").tag(3)
              
          }</pre>
<p>This code adds the picker and uses the <code>selectedSegment</code> property in <code>DataModel</code>, which is used to keep track of which segment of the picker has been selected by the user. The picker <a id="_idIndexMarker706"/>is set to three different titles, and we use the <code>tag</code> modifier to distinguish which title goes where on the picker control. Now, the user can choose between <code>7</code>, <code>8</code>, or <code>9</code> letters for the word they will work with. </p>
<p> This is the default button look, which offers options to the user when pressed:</p>
<div><div><img alt="Figure 12.8: The button picker " src="img/B18674_12_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.8: The button picker</p>
<p>Let’s now look <a id="_idIndexMarker707"/>at how we can style the picker to something more suitable for our game.</p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor185"/>Styling PickerView</h2>
<p>As I <a id="_idIndexMarker708"/>mentioned, I feel that segmented control looks better, so let’s change the styling to that picker option instead. Add the following code after the closing brace of <code>PickerView</code>:</p>
<pre class="source-code">
      .pickerStyle(SegmentedPickerStyle())
      .background(RoundedRectangle(cornerRadius: 8)
      .stroke(Color.black, lineWidth: 4).shadow(color: 
        Color.black, radius: 8, x: 0, y: 0))
      .cornerRadius(8)
      .padding(.horizontal, 50.0)
      .padding(.bottom, 10)</pre>
<p>We set the picker<a id="_idIndexMarker709"/> to the segmented style, and added a rounded rectangle with a corner radius of <code>8</code> points, with a black stroke around the picker control to give it a nice border. Then, we finished it off with some shadow and padding, and this is what it looks like:</p>
<div><div><img alt="Figure 12.9: The completed PickerView " src="img/B18674_12_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.9: The completed PickerView</p>
<p><code>PickerView</code> is done, but to complete the work in the <code>PickerView</code> file, let’s add a <code>bottomBar</code> image to the scene. After the <code>shadow</code> modifier, add the following:</p>
<pre class="source-code">
Image("bottomBar").resizable()
        .frame(width: 280, height: 8)
        .padding(.bottom, 10)
        .shadow(color: .black, radius: 1, x: 1, y: 1)</pre>
<p>This just <a id="_idIndexMarker710"/>sets <code>bottomBar</code> like <code>topBar</code>, and helps frame out <code>PickerView</code> in the UI:</p>
<div><div><img alt="Figure 12.10: The bottom bar image added " src="img/B18674_12_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.10: The bottom bar image added</p>
<p>Let’s go back into <code>ContentView</code>, where we need to call <code>PickerView</code> to bring it into the scene. Add the following just below the <code>HeaderView</code> code:</p>
<pre class="source-code">
          //MARK: - PICKER
        PickerView()</pre>
<p>And now we<a id="_idIndexMarker711"/> have our <code>PickerView</code> that can offer the user some choices. It doesn’t do anything yet because we need to fill out the <code>setWordLengthAndLanguage</code> method, so let’s do that. Back in <code>DataModel</code>, add the following code inside the <code>setWordLengthAndLanguage</code> method:</p>
<pre class="source-code">
    //sets the word length and language for the game
    func setWordLengthAndLanguage() -&gt; String {
        let language = ["English": "En", "Spanish": "ES",
          "Italian": "It"]
        let wordLength = [1: "7", 2: "8", 3: "9"]
        var dataFile = ""
        var selectedLanguage = ""
        if englishIsOn == true {
            selectedLanguage = "English"
        } else if spanishIsOn == true {
            selectedLanguage = "Spanish"
        } else if italianIsOn == true {
            selectedLanguage = "Italian"
        }
        if let languageCode = language[selectedLanguage],
          let lengthCode = wordLength[selectedSegment] {
        dataFile = 
          "\(lengthCode)LetterWords\(languageCode)"
          letterCount = "🇱🇷 \(lengthCode) letter word – 
            \(selectedLanguage) 🇱🇷"
        }
        return dataFile
    }</pre>
<p>This is how the <code>setWordLengthAndLanguage</code> function works. It starts by defining two dictionaries, <code>language</code> and <code>wordLength</code>:</p>
<ul>
<li>The <code>language</code> dictionary maps the names of different languages to their abbreviations. In this case, <code>"English"</code> is mapped to <code>"En"</code>, <code>"Spanish"</code> is mapped to <code>"ES"</code>, and <code>"Italian"</code> is mapped to <code>"It"</code>.</li>
<li>The <code>wordLength</code> dictionary maps integer values to their corresponding word lengths. For example, <code>1</code> is mapped to <code>"7"</code>, <code>2</code> is mapped to <code>"8"</code>, and <code>3</code> is mapped to <code>"9"</code>.</li>
</ul>
<p>Next, the <a id="_idIndexMarker712"/>function checks the value of the <code>selectedSegment</code> variable. This variable holds an integer that represents the user’s selected word length (seven letters, eight letters, or nine letters).</p>
<p>Based on the value of <code>selectedSegment</code>, the function retrieves the corresponding word length from the <code>wordLength</code> dictionary using the square bracket notation, <code>wordLength[selectedSegment]</code>. This gives us the word length as a string, such as <code>7</code>, <code>8</code>, or <code>9</code>.</p>
<p>The function then checks the values of the <code>englishIsOn</code>, <code>spanishIsOn</code>, and <code>italianIsOn</code> variables. These variables hold Booleans that indicate whether the user has selected the corresponding language.</p>
<p>If one of these language variables is true, then the function uses the corresponding language abbreviation (retrieved from the <code>language</code> dictionary) and the word length (retrieved from the <code>wordLength</code> dictionary) to construct the filename of the data file that contains the words for that language and word length. For example, if the user has selected English with seven letters, the filename will be <code>7LetterWordsEn</code>.</p>
<p>The function sets the value of the <code>letterCount</code> variable to a string that provides a description of the selected language and word length, such as <code>7 letter word - </code><code>American English</code>.</p>
<p>Finally, the function returns the constructed filename as a string.</p>
<p>There’s one<a id="_idIndexMarker713"/> other bit of code we need to add to <code>ContentView</code> in order to get the language word count string working for the picker control. Add the following code directly after the <code>shadow</code> modifier of the button:</p>
<pre class="source-code">
//MARK: - WORD TO PLAY FROM
      VStack {
          //word letter count string
          Text("\(appData.letterCount)")
              .font(.system(size: 18, weight: .regular, 
                design: .serif))
              .foregroundColor(Color.white)
              .bold()
              .shadow(color: .black, radius: 1, x: 1, y: 1)
              
      }</pre>
<p>In this code, we added a <code>VStack</code> and then displayed the <code>letterCount</code> property in a <code>Text</code> view by using the <code>appData</code> instance. Then, we applied a font size and weight and a white foreground, made it bold, and added a shadow to the <code>Text</code> view. What I want you to do now is to cut out the <code>Text</code> view that displays the <code>wordToPlayFrom</code> property, and paste it inside the <code>VStack</code> just added, at the very end. This keeps both text views horizontally organized.</p>
<p>Now, to test the picker out and see it display the letter word string, as well as a word in a different language, we need to come to our data file and set one of the <code>language</code> variables to <code>true</code>; just for testing purposes, we will later toggle these variables in the settings page. So, in <code>DataModel</code>, change the <code>spanishIsOn</code> variable to <code>true</code>, like this:</p>
<pre class="source-code">
@AppStorage ("spanishIsOn") var spanishIsOn: Bool = true</pre>
<p>Now, come<a id="_idIndexMarker714"/> into <code>ContentView</code> and select the length of the word that you want to use from the picker control. Press the button and you will see a Spanish word of the length you chose and the <code>letterCount</code> string displaying the chosen language’s flag and picker selection for the word size:</p>
<div><div><img alt="Figure 12.11: Choosing the word size and language for the game " src="img/B18674_12_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.11: Choosing the word size and language for the game</p>
<p>You can check<a id="_idIndexMarker715"/> it for the other two languages as well by just setting one of those languages to <code>true</code> and keeping the others set to <code>false</code>. Also, if you don’t set one of the <code>AppStorage</code> variables to <code>true</code>, then the picker will not pick the length of the word; it will default to an eight-letter word (this behavior will work itself out when we finish adding the rest of the code in the next chapter).</p>
<p>After you’re done testing things out, make sure to set the <code>data</code> variable back to <code>false</code>.</p>
<h1 id="_idParaDest-178"><a id="_idTextAnchor186"/>Summary</h1>
<p>So, we’ve come to the end of this chapter, and have done quite a bit of work. </p>
<p>We started building out our game, allowing the user to enter words to play the game, and adding checks to validate their choices. We also added a button that the user can press to bring up a random word from a file of thousands of words, a button that brings up a settings page, a picker control, and a letter count string.</p>
<p>Next, we will continue building out the app, specifically building out the user interface, the settings page so it contains those three buttons that the user can select for the languages, and adding error messages when the user’s entered word is not valid. So, let’s continue with the second part of this project in the next chapter.</p>
</div>
<div><div></div>
</div>
</body></html>