- en: Chapter 6. Working with Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 与着色器一起工作
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Implementing the wobble and ripple effect
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现摇摆和波纹效果
- en: Procedural texture shading with object coordinates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于对象坐标的程序纹理着色
- en: Creating the circular pattern and making them revolve
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建圆形图案并使其旋转
- en: Generating the brick pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成砖块图案
- en: Generating the polka dot pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成圆点图案
- en: Discarding fragments
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛弃片段
- en: Procedural texture shading with texture coordinates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于纹理坐标的程序纹理着色
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will give you an in-depth understanding of the shaders programming
    technique. It discusses various techniques that can be implemented by using the
    vertex and fragment shaders, revealing their capabilities. We will begin this
    chapter by understanding the role of shaders in the OpenGL ES 3.0 programmable
    pipeline. You will also learn how the vertex shader and fragment shaders process
    information on GPU Multicores.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将为你深入理解着色器编程技术。它讨论了可以使用顶点和片段着色器实现的各种技术，揭示了它们的特性。我们将从理解着色器在OpenGL ES 3.0可编程管道中的作用开始本章。你还将了解顶点着色器和片段着色器如何在GPU多核上处理信息。
- en: You will learn how to deform the geometry shape by using the vertex shader;
    this will produce a wobble effect on 3D mesh models. With a little modification,
    we will use the same deforming concept to implement the pond water ripple effect.
    Further, we will understand the difference between the procedural and image texturing.
    With the help of model coordinates, we will implement our first simple procedural
    texturing recipe.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将学习如何通过使用顶点着色器来变形几何形状；这将产生在3D网格模型上的摇摆效果。稍作修改后，我们将使用相同的变形概念来实现池塘水波纹效果。此外，我们将了解程序纹理和图像纹理之间的区别。借助模型坐标，我们将实现我们的第一个简单的程序纹理配方。
- en: Drawing a circle-shaped geometry by using vertices may be too expensive to render
    because it requires too many vertices to form smoother edges; the circle shader
    recipe demonstrates an efficient way of rendering a circle that uses procedural
    texturing. The brick shader recipe demonstrates how to render a pattern of bricks
    on the surface of an object. Using the knowledge from the circle pattern, we will
    program how to render polka dots on 3D mesh objects. We will extend the same recipe
    to show an interesting feature of the GL shading language that allows us to produce
    holes in the 3D geometries by using discarded fragments. Finally, you will learn
    how to use texture coordinates to program procedural textures. With this knowledge,
    we will create a grid or cage like geometry on a 3D cube mesh object.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用顶点绘制圆形几何体可能渲染成本过高，因为它需要太多的顶点来形成更平滑的边缘；圆形着色器配方演示了一种使用程序纹理高效渲染圆形的方法。砖块着色器配方演示了如何在物体表面渲染砖块图案。利用圆形图案的知识，我们将编写如何在3D网格对象上渲染圆点的程序。我们将扩展相同的配方来展示GL着色语言的一个有趣特性，该特性允许我们通过丢弃片段在3D几何体中产生孔洞。最后，你将学习如何使用纹理坐标来编程程序纹理。有了这些知识，我们将在3D立方网格对象上创建一个网格或笼状几何体。
- en: 'Shader role and responsibilities: The following figure illustrates the role
    of vertex and fragment shaders on two overlapped models to produce the final image
    on the screen; the expected output is marked as label 1\. The graphics engine
    is provided with a rectangle-shaped model (four vertices) and a triangle-shaped
    model (three vertices). These models are first sent to the vertex shader. The
    vertex and fragment shader program has syntax, such as C programming language;
    the program''s entry point always starts from the `main()` function.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器角色和责任：以下图展示了顶点和片段着色器在两个重叠模型中的作用，以在屏幕上产生最终图像；预期的输出标记为标签1。图形引擎提供了一个矩形形状的模型（四个顶点）和一个三角形形状的模型（三个顶点）。这些模型首先被发送到顶点着色器。顶点和片段着色器程序具有类似于C编程语言的语法；程序的主入口点始终从`main()`函数开始。
- en: The vertex shader is compiled and executed at runtime; it's invoked once for
    every vertex in the geometry, as shown in the following figure with labels **2**
    and **3**. Shader programs are executed on the multiprocessors GPUs, which allows
    manipulation of several vertices at the same time. The vertex shader is always
    executed first before the fragment shader.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器在运行时编译和执行；它为几何中的每个顶点调用一次，如下图中标记为**2**和**3**所示。着色器程序在多处理器GPU上执行，这允许同时操纵多个顶点。顶点着色器总是在片段着色器之前执行。
- en: 'There are mainly two goals of a vertex shader:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器主要有两个目标：
- en: Calculating the transformation of the vertex coordinates
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算顶点坐标的变换
- en: Calculating any per-vertex calculations required by the fragment shader![Introduction](img/5527OT_06_01.jpg)
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算片段着色器所需的任何顶点计算![介绍](img/5527OT_06_01.jpg)
- en: A fragment shader is always executed after the vertex shader. Unlike vertex
    shaders, the fragment shader also contains a `main()` function as its entry point.
    The fragment shader is also compiled and executed at runtime for every single
    fragment; label **4** and label **5** shows the execution of the fragment shader
    on each fragment.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器总是在顶点着色器之后执行。与顶点着色器不同，片段着色器也包含一个`main()`函数作为其入口点。片段着色器也会为每个单独的片段在运行时进行编译和执行；标签**4**和标签**5**显示了片段着色器在每个片段上的执行。
- en: The image with label **6** shows the generated fragments after the rasterization
    process; the pixel is shown in the red box. Each fragment may or may not correspond
    to a single pixel in the primitive. A pixel in the framebuffer can be composed
    of one or more than one fragment, as shown in the following figure; using the
    fragment shader, these generated fragments can be controlled programmatically
    to assign color, texture, and other attribute information; each fragment has position,
    depth, and color associated with it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 标签为**6**的图像展示了光栅化过程后的生成片段；像素显示在红色框中。每个片段可能对应也可能不对应原始图元中的单个像素。帧缓冲区中的像素可以由一个或多个片段组成，如下图所示；使用片段着色器，这些生成的片段可以通过程序控制来分配颜色、纹理和其他属性信息；每个片段都与位置、深度和颜色相关联。
- en: The main goal of the fragment shader is to compute the color information for
    each fragment or discard the fragment according to the programing decision.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 片段着色器的主要目标是计算每个片段的颜色信息或根据编程决策丢弃片段。
- en: 'A fragment has the ability to perform the following tasks:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 片段具有执行以下任务的能力：
- en: Color interpolation or computation of every fragment
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色插值或每个片段的计算
- en: Texture coordinates computation
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算纹理坐标
- en: Texture assignment to every pixel
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将纹理分配给每个像素
- en: Normal interpolation for each pixel
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个像素的法线插值
- en: Calculation of light information for every pixel
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 计算每个像素的光信息
- en: Animation effects computation
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画效果的计算
- en: 'The shaders concurrent execution model: The modern graphics engine architecture
    is capable of rendering high performance state-of-the-art graphics. Thanks to
    modern graphic processors that allow fast and parallel processing of large datasets
    at an incredible speed, this capability requires computation of a large dataset
    in a fraction of micro seconds. **Graphics** **Processor Units** (**GPUs**) are
    special dedicated processors made to fulfill these requirements; these processors
    are multicore where parallel processing can be achieved.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器的并发执行模型：现代图形引擎架构能够渲染高性能的先进图形。得益于现代图形处理器，它能够以惊人的速度快速并行处理大量数据集，这种能力需要计算大量数据集，只需微秒级的几分之一。**图形处理器单元**（**GPUs**）是专门为满足这些要求而设计的特殊专用处理器；这些处理器是多核的，可以实现并行处理。
- en: One of the major requirements of modern graphics is that it needs efficient
    floating-point calculations and fast polygon transformation operations. The GPU
    is optimized exclusively for these types of requirements; they provide a bunch
    of capabilities. Among these, it includes the fast trigonometric function, which
    is considered to be expensive on the CPU architecture. The number of processor
    cores in GPU can go from a few hundreds to thousands in number.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现代图形的一个主要要求是它需要高效的浮点计算和快速的多边形变换操作。GPU专门优化以满足这些类型的要求；它们提供了一组功能。其中，包括快速三角函数，这在CPU架构上被认为是昂贵的。GPU中的处理器核心数量可以从几百到几千不等。
- en: 'The following figure shows the concurrent execution on the GPUs for the vertex
    and fragment shader:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了GPU上顶点着色器和片段着色器的并发执行：
- en: '![Introduction](img/5527OT_06_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![介绍](img/5527OT_06_03.jpg)'
- en: Each core of the GPU is capable of running an instance of the vertex or fragment
    shader; each core processes the vertices first and then the fragments, as shown
    in the preceding figure.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: GPU的每个核心都能够运行顶点或片段着色器的一个实例；每个核心首先处理顶点，然后处理片段，如图所示。
- en: Implementing the wobble and ripple effect
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现波动和涟漪效果
- en: This is a first simple yet effective vertex shader technique that produces a
    wobbling effect on the object's geometry. This shader produces animation effects
    on the geometric shape like a sine wave; this effect is implemented within the
    vertex shader. This recipe also demonstrates another animation technique that
    produces a water pond ripple effect.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单而有效的顶点着色器技术，可以在对象的几何形状上产生摆动效果。这个着色器在几何形状上产生类似正弦波的动画效果；此效果在顶点着色器中实现。这个配方还演示了另一种动画技术，可以产生水塘波纹效果。
- en: Getting ready
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will reuse the existing Phong shading recipe from the previous
    chapter. Rename the shader files with a name of your choice; for this recipe,
    we will rename these to `WobbleVertex.glsl` and `WobbleFragment.glsl`. The wobble
    and ripple shader are both vertex shader-based recipes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将重用前一章中现有的 Phong 着色器配方。将着色器文件重命名为你选择的名称；对于这个配方，我们将重命名为 `WobbleVertex.glsl`
    和 `WobbleFragment.glsl`。摆动和波纹着色器都是基于顶点着色器的配方。
- en: How to do it...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'This section will provide the changes required to implement the vertex shader
    in order to produce the wobble effect. Modify the `WobbleVertex.glsl` as per the
    following code; there is no change required for the fragment shader:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将提供实现顶点着色器以产生摆动效果所需的更改。根据以下代码修改 `WobbleVertex.glsl`；不需要对片段着色器进行更改：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How it works...
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: A sine wave has a mathematical property of producing a smooth repetitive oscillation.
    The following figure shows the sine wave; the amplitude of sine wave defines the
    height or depth of the wave trough or crest, respectively. The wobble vertex shader
    displaces the Y component of each object vertex V (V[x], V[y], and V[z]) to produce
    the wobbling effect; the displacement is done using the sine function whose value
    always range between -1.0 and 1.0.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 正弦波具有产生平滑重复振荡的数学特性。以下图显示了正弦波；正弦波的振幅定义了波谷或波峰的高度或深度。摆动顶点着色器将每个对象顶点 V (V[x], V[y],
    和 V[z]) 的 Y 分量移动以产生摆动效果；位移是通过始终介于 -1.0 和 1.0 之间的正弦函数完成的。
- en: '![How it works...](img/5527OT_06_04.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_06_04.jpg)'
- en: 'The uniform `Time` attribute variable is used for clock ticks. When these clock
    ticks are fed to the GLSL `sin()` function, it generates values ranging from -1.0
    to 1.0\. Each vertex''s Y component (V[y]) is added to this sine value (*VertexCoord.y
    += sin(Time)*) to produce a hopping effect animation. Try this equation, it will
    make the object hop:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 统一 `Time` 属性变量用于时钟滴答。当这些时钟滴答被输入到 GLSL `sin()` 函数时，它生成介于 -1.0 到 1.0 之间的值。每个顶点的
    Y 分量 (V[y]) 被添加到这个正弦值 (*VertexCoord.y += sin(Time)*) 以产生跳跃效果动画。尝试这个方程，它会使物体跳跃：
- en: '![How it works...](img/5527OT_06_29.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_06_29.jpg)'
- en: 'Further, in order to produce the wobble animation, take the X (V[x]) or Z (V[z])
    component of each vertex into consideration to produce a wave like oscillation
    animation using (*VertexCoord.y += sin(VertexCoord.x + Time)*). Multiplying the
    Y (V[y]) component of the resultant with `AMPLITUDE` will affect the height of
    the wobbling wave animation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，为了产生摆动动画，考虑每个顶点的 X (V[x]) 或 Z (V[z]) 分量，使用 (*VertexCoord.y += sin(VertexCoord.x
    + Time)*) 产生类似波浪的振荡动画。将结果的 Y (V[y]) 分量乘以 `AMPLITUDE` 将影响摆动波动画的高度：
- en: '![How it works...](img/5527OT_06_26.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_06_26.jpg)'
- en: With the new Y (V[y]) component of each vertex, the clip coordinates of the
    vertex are calculated by multiplying it with the `ModelViewProjection` matrix.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每个顶点的新的 Y (V[y]) 组件，通过乘以 `ModelViewProjection` 矩阵来计算顶点的裁剪坐标。
- en: '![How it works...](img/5527OT_06_05.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_06_05.jpg)'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The wobble shader recipe also exhibits a pond water ripple animation, as shown
    in the preceding image in this section. Mathematically, the sine wave as a function
    of time is defined as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 摆动着色器配方还展示了池塘水波动画，如本节前面的图像所示。从数学上讲，正弦波作为时间的函数定义为以下：
- en: '![There''s more...](img/5527OT_06_27.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_06_27.jpg)'
- en: 'Where *t* is the time, *A* is the amplitude of the wave, and *f* is the frequency.
    Using this formula, the ripple effect can be programmed as follows. The change
    in phase (*φ*) is assumed to be *t* here:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *t* 是时间，*A* 是波的振幅，*f* 是频率。使用这个公式，可以编程波纹效果如下。相位变化 (*φ*) 假设为 *t*：
- en: '![There''s more...](img/5527OT_06_28.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_06_28.jpg)'
- en: 'Modify the existing vertex shader according to the instructions given in the
    following code snippet, highlighted in bold:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 根据以下代码片段中给出的说明修改现有的顶点着色器，粗体部分如下：
- en: '[PRE1]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The distance variable is used to calculate distances of each variable from its
    origin; this distance is calculated using the OpenGL ES shading language `length()`
    API. Finally, the clipped coordinates are calculated by taking product between
    the `VertexCoord` and `ModelViewProjection` matrix.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 距离变量用于计算每个变量与其原点的距离；此距离使用OpenGL ES着色语言`length()` API计算。最后，通过将`VertexCoord`和`ModelViewProjection`矩阵相乘来计算裁剪坐标。
- en: '![There''s more...](img/5527OT_06_06.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_06_06.jpg)'
- en: See also
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Phong shading – the per-fragment shading technique* recipe in
    [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第5章中关于*Phong着色 - 每个片段着色技术*的配方，*光与材料*章节
- en: Procedural texture shading with object coordinates
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用对象坐标进行过程纹理着色
- en: 'In this recipe, you will learn how to produce a texture pattern on the surface
    of the 3D geometry with the help of procedural textures. Basically, texturing
    on a 2D/3D mesh object can be divided into two categories:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，你将学习如何借助过程纹理在3D几何体的表面上生成纹理图案。基本上，在2D/3D网格对象上的纹理可以分成两类：
- en: '**Procedural texturing**: A procedure texture is an image or a texture produced
    mathematically using an algorithm; such algorithms use various attributes of a
    2D/3D object to create an image; this type of texturing is highly controllable.
    Procedural texturing is used to create patterns, such as clouds, marble, wood,
    blending, noise, musgrave, voronoi, and so on.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过程纹理**：过程纹理是使用算法数学上生成的一个图像或纹理；此类算法使用2D/3D对象的各个属性来创建图像；这种纹理类型高度可控。过程纹理用于创建图案，如云彩、大理石、木材、混合、噪声、musgrave、voronoi等。'
- en: '**Image texturing**: In this type of texture, a static image is wrapped on
    the object; this image could be distorted on affine scaling transformation because
    this is a raster type of image. You will learn more about image texturing in the
    next chapter called textures.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像纹理**：在这种类型的纹理中，一个静态图像被包裹在物体上；由于这是一个光栅图像，因此该图像在仿射缩放变换中可能会发生扭曲。你将在下一章中学习更多关于图像纹理的内容，该章节名为纹理。'
- en: In this chapter, we will produce a number of procedural textures, with the help
    of object and texture coordinates. The current recipe makes use of object coordinates
    to demonstrate how it can be used to control fragment colors on a 3D model.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用对象和纹理坐标生成多个过程纹理。当前的配方利用对象坐标来演示如何用它来控制3D模型上的片段颜色。
- en: 'An object coordinate is a coordinate system in which the original shape of
    the object is defined. For example, the square in the following image is a 2 x
    2 unit along the *x-z* plane; the origin is located in the middle of the square.
    The *x* axis and *z* axis divides the square into four quadrants around the origin.
    This recipe uses this logic to logically divide the mesh''s 3D space into four
    quadrants, with each quadrant colored with a different color:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对象坐标是一个坐标系，其中定义了物体的原始形状。例如，以下图像中的正方形沿*x-z*平面有2 x 2个单位；原点位于正方形的中间。*x*轴和*z*轴将正方形分为围绕原点的四个象限。本配方使用此逻辑将网格的3D空间逻辑上分为四个象限，每个象限以不同的颜色着色：
- en: '![Procedural texture shading with object coordinates](img/5527OT_06_07.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![使用对象坐标进行过程纹理着色](img/5527OT_06_07.jpg)'
- en: How to do it...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps to implement this simple recipe:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现此简单配方：
- en: 'Create the `SimpleVertexShader.glsl` and add it to the following code snippet:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`SimpleVertexShader.glsl`并将其添加到以下代码片段中：
- en: '[PRE2]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Modify the `SimpleFragmentShader.glsl` as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下修改`SimpleFragmentShader.glsl`：
- en: '[PRE3]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![How to do it...](img/5527OT_06_08.jpg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_06_08.jpg)'
- en: The preceding figure shows the result of our simple procedural shader The models
    are divided into four quadrants along the *x-z* plane , with each quadrant shown
    in a different color. Use the single tap on the screen in order to switch between
    these models.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了我们的简单过程着色器的结果。模型沿*x-z*平面分为四个象限，每个象限以不同的颜色显示。通过在屏幕上轻触一次来在这些模型之间切换。
- en: How it works...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The shader job starts from the vertex shader where object coordinates are received
    by the vertex program as a vertex attribute in the `VertexPosition` variable;
    this variable contains the vertex position in the local 3D space in which the
    object was defined. This value is stored in the `ObjectCoord` and passed on to
    the fragment shader. In the fragment shader, the object coordinate value is checked
    with the origin in order to test the quadrant to which it belongs to in the *x-z*
    plane. Depending on the quadrant outcome, a color is assigned to the fragment.
    The following image shows the division of 3D space into four quadrants using object
    coordinates:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器作业从顶点着色器开始，其中对象坐标作为 `VertexPosition` 变量中的顶点属性由顶点程序接收；该变量包含在定义对象时在局部3D空间中的顶点位置。此值存储在
    `ObjectCoord` 中并传递到片段着色器。在片段着色器中，对象坐标值与原点进行比较，以测试它在 *x-z* 平面上的哪个象限。根据象限的结果，为片段分配颜色。以下图像显示了使用对象坐标将3D空间分为四个象限：
- en: '![How it works...](img/5527OT_06_09.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_06_09.jpg)'
- en: There's more...
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The shader program does not provide any print statements that can be used for
    debugging purposes; one of the easiest solutions to debug coordinate values in
    the shader is to assign colors to fragments. If you are interested to deal with
    a coordinate range of a model in the 3D space, you can assign various colors using
    conditional statements. For example, if the previous fragment shader is replaced
    with the following code, it will render strips with various colors depending on
    the coordinate range:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器程序不提供任何可用于调试目的的打印语句；在着色器中调试坐标值的最简单解决方案之一是将颜色分配给片段。如果你对处理3D空间中模型的坐标范围感兴趣，你可以使用条件语句分配各种颜色。例如，如果将之前的片段着色器替换为以下代码，它将根据坐标范围渲染不同颜色的条带：
- en: '[PRE4]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '![There''s more...](img/5527OT_06_10.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_06_10.jpg)'
- en: 'Each unique color specifies a range of object coordinates along *x* or *z*
    axes. The following image shows that each color represents a band of 0.1 logical
    units from 0.5 to 1.0 units along the *x-z* plane:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每种独特的颜色指定了沿 *x* 或 *z* 轴的对象坐标范围。以下图像显示了每种颜色代表沿 *x-z* 平面从 0.5 到 1.0 单位的 0.1 逻辑单位带：
- en: '![There''s more...](img/5527OT_06_11.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_06_11.jpg)'
- en: See also
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第7章](ch07.html "第7章。纹理和映射技术")中的*使用UV映射应用纹理*配方，*纹理和映射技术*。
- en: Creating the circular pattern and making them revolve
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建圆形图案并使其旋转
- en: This procedural texture recipe will make use of fragment coordinates to demonstrate
    a circular pattern using `gl_FragCoord`. The `gl_FragCoord` is a keyword available
    in the fragment shader that is responsible to store the window position of the
    current fragment in *x* and *y* coordinates; the *z* coordinate stores the depth
    of the fragment in the range `[0, 1]`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序纹理配方将使用片段坐标来演示使用 `gl_FragCoord` 的圆形图案。`gl_FragCoord` 是在片段着色器中可用的一个关键字，它负责存储当前片段在
    *x* 和 *y* 坐标中的窗口位置；*z* 坐标存储片段在 `[0, 1]` 范围内的深度。
- en: 'These coordinates are always relative to the OpenGL ES surface window; the
    `gl_FragCoords` is a result of a fixed functionality in which primitive are interpolated
    after the vertex processing stage to generate fragments. By default, the `gl_FragCoord`
    assumes the lower-left corner of the OpenGL ES rendering surface window as the
    origin. The following image shows the origin in the OpenGL ES surface window with
    different dimensions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些坐标始终相对于OpenGL ES表面窗口；`gl_FragCoords` 是一个固定功能的结果，其中在顶点处理阶段之后对原语进行插值以生成片段。默认情况下，`gl_FragCoord`
    假设OpenGL ES渲染表面窗口的左下角为原点。以下图像显示了不同尺寸的OpenGL ES表面窗口中的原点：
- en: '![Creating the circular pattern and making them revolve](img/5527OT_06_12.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![创建圆形图案并使其旋转](img/5527OT_06_12.jpg)'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The light shading technique for this recipe will remain similar to the previous
    recipe; for more information, refer to the *Phong shading – the per-fragment shading
    technique* recipe in [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Light and Materials*. Create the `CircleVertexShader.glsl` vertex shader and
    reuse the code from previous recipe; for the `CircleFragmentShader.glsl` fragment
    shader, make the following changes:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的光照着色技术将与之前的菜谱相似；更多信息，请参阅[第5章](ch05.html "第5章。光和材料")中的*Phong着色 - 每个片段着色技术*菜谱，*光和材料*。创建`CircleVertexShader.glsl`顶点着色器并重用之前菜谱中的代码；对于`CircleFragmentShader.glsl`片段着色器，进行以下更改：
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following image shows the output of this recipe:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像显示了此菜谱的输出：
- en: '![How to do it...](img/5527OT_06_13.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_06_13.jpg)'
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'For each fragment''s window position received from `gl_Fragcoord`, it''s manipulated
    by shifting the bottom-left coordinate to the center of the imaginary square region;
    this square region is used to inscribe a circle in it. The following code is responsible
    for displacing each coordinate relative to the center of the logical square, as
    shown in the following image:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于从`gl_Fragcoord`接收到的每个片段的窗口位置，它通过将左下角坐标移动到想象中的正方形区域中心来处理；这个正方形区域用于在其中绘制一个圆。以下代码负责相对于逻辑正方形中心的每个坐标进行位移，如图所示：
- en: '[PRE6]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '![How it works...](img/5527OT_06_14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_06_14.jpg)'
- en: As the `position` is relative to the center of the imaginary square, we can
    calculate the distance of each coordinate from the center using the standard length
    formula in vector graphics. This length is used to render the fragment with the
    color of the circle, which is specified using the `DotColor`; if the length is
    smaller than the `DotSize`, then the body color is rendered using the `ModelColor`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`位置`是相对于想象中的正方形中心的，我们可以使用矢量图形中的标准长度公式来计算每个坐标与中心的距离。这个长度用于渲染具有圆圈颜色的片段，圆圈的颜色是通过`DotColor`指定的；如果长度小于`DotSize`，则使用`ModelColor`渲染身体颜色。
- en: 'Mathematically, a circle is the locus of a point, which is always equidistant
    from a given point; as the origin is moved to the center, we can inscribe a circle
    within the square, as shown in the following figure. The coordinates falling under
    the circle can be rendered with `DotColor` to produce a circle pattern on the
    model. In order to check whether the length is greater or lesser than `DotSize`,
    we have used the `step()` GLSL API:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，圆是一个点的轨迹，该点始终与给定点等距；当原点移动到中心时，我们可以在正方形内绘制一个圆，如图所示。落在圆下的坐标可以使用`DotColor`渲染，以在模型上产生圆圈图案。为了检查长度是否大于或小于`DotSize`，我们使用了`step()`
    GLSL API：
- en: '[PRE7]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '![How it works...](img/5527OT_06_15.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_06_15.jpg)'
- en: '**Syntax**:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| Variable | Description |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `edge` | This specifies the location of the edge of the step function |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `edge` | 这指定了步骤函数边缘的位置 |'
- en: '| `x` | This specifies the value to be used to generate the step function |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 这指定了用于生成步骤函数的值 |'
- en: '| `Return value` | This step function returns 0.0 if x is smaller than edge;
    otherwise, it returns 1.0 |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `返回值` | 此步骤函数如果x小于边缘则返回0.0；否则返回1.0 |'
- en: There's more...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'The current implementation of the circle pattern is very static; it does not
    show any movement on the patterns of the circle. In this section, we will apply
    a general form of the 2D rotation matrix to perform a single rotation in the Euclidean
    space; the general form of the rotation matrix is:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当前实现的圆圈图案非常静态；它不会在圆的图案上显示任何运动。在本节中，我们将应用二维旋转矩阵的一般形式来在欧几里得空间中执行单次旋转；旋转矩阵的一般形式是：
- en: '![There''s more...](img/5527OT_06_30.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![更多...](img/5527OT_06_30.jpg)'
- en: 'Modify the existing fragment shader recipe to see the circular patterns rotation
    in action; the highlighted code is responsible for calculating the rotation matrix
    according to the 2D equation:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 修改现有的片段着色器菜谱以查看圆形图案的旋转效果；高亮代码负责根据二维方程计算旋转矩阵：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Generating* *the polka dot pattern*'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成* *圆点图案*'
- en: Generating the brick pattern
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成砖块图案
- en: The brick shader generates a pattern the bricks on the given surface of the
    3D mesh object; this is another very good example of procedural texturing. The
    brick pattern is made up of two components (a brick and the mortar); these are
    represented using two different colors, as shown in the following figure. These
    colors are defined using `BrickColor` and `MortarColor` as the global variables
    in the vertex shader.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 砖块着色器生成给定 3D 网格对象表面的砖块图案；这是过程纹理的另一个非常好的例子。砖块图案由两个组件（砖块和砂浆）组成；这些使用两种不同的颜色表示，如图所示。这些颜色使用
    `BrickColor` 和 `MortarColor` 作为全局变量在顶点着色器中定义。
- en: 'The rectangular size of the brick consists of brick and mortal materials; the
    total dimension of the rectangular region is 0.40 x 0.10 square units, out of
    which 90 percent of the horizontal dimension (0.40) is reserved for the dimension
    of the bricks along the *x* axis; the remaining 10 percent is used for the mortar
    along the same axis. Similarly, the brick vertical dimension is 85 percent along
    the *y* axis and the remaining 15 percent is used by the mortar''s vertical dimension:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 砖块的矩形尺寸由砖块和砂浆材料组成；矩形区域的总体尺寸为 0.40 x 0.10 平方单位，其中 90% 的水平尺寸（0.40）保留用于沿 *x* 轴的砖块尺寸；剩余的
    10% 用于沿同一轴的砂浆。同样，砖块的垂直尺寸沿 *y* 轴为 85%，剩余的 15% 由砂浆的垂直尺寸使用：
- en: '![Generating the brick pattern](img/5527OT_06_17.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![生成砖块图案](img/5527OT_06_17.jpg)'
- en: How to do it...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to implement the brick shader:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现砖块着色器：
- en: Create `BrickVertex.glsl` and reuse the code of the vertex shader from the previous
    recipe.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BrickVertex.glsl` 并重用前一个配方中的顶点着色器代码。
- en: 'Create `BrickFragment.glsl` and modify the following code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BrickFragment.glsl` 并修改以下代码：
- en: '[PRE10]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Use the main program and specify the color for `BrickColor` and `MortarColor`
    uniform variables:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用主程序并指定 `BrickColor` 和 `MortarColor` 常量变量的颜色：
- en: '[PRE11]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similarly, specify the total rectangular size and brick percentage:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，指定总矩形尺寸和砖块百分比：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '![How to do it...](img/5527OT_06_18.jpg)'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_06_18.jpg)'
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Each incoming object coordinate `ObjectCoord` in the fragment shader is divided
    by the `BrickSize`; the outcome position contains rows and columns of the brick
    to which `ObjectCoord` belongs. For each alternative row, the position of the
    brick is advanced by 0.5 units in the horizontal direction using the following
    code snippet in the program:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在片段着色器中，每个传入的对象坐标 `ObjectCoord` 都被除以 `BrickSize`；结果位置包含砖块所属的行和列。对于每个交替的行，使用程序中的以下代码片段在水平方向上将砖块的位置向前推进
    0.5 个单位：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `fract` GLSL API calculates the fractional part of the position and stores
    it in the `position` variable; as it''s a fractional value, it must be in a range
    between 0.0 and 1.0; we must use this new value to compare it with `BrickPercent`
    using the GLSL step function. The step function takes two arguments, a threshold
    and a parameter against which the threshold needs to be compared; if the parameter
    value is less than the threshold value, the function return `0`; otherwise, it
    will return `1`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '`fract` GLSL API 计算位置的小数部分并将其存储在 `position` 变量中；由于它是一个小数值，它必须在 0.0 和 1.0 之间；我们必须使用这个新值来使用
    GLSL step 函数与 `BrickPercent` 进行比较。步进函数接受两个参数，一个阈值和一个需要与阈值进行比较的参数；如果参数值小于阈值值，则函数返回
    `0`；否则，它将返回 `1`：'
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The mix function mixes two colors using a weight parameter; this weight parameter
    in the current recipe is provided as a product between `useBrick.x` and `useBrick.y`.
    The resultant color is multiplied with `PhongShading()`, which produces the final
    light shading on the brick shader.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 混合函数使用权重参数混合两种颜色；在这个配方中，权重参数是 `useBrick.x` 和 `useBrick.y` 的乘积。结果颜色与 `PhongShading()`
    相乘，产生砖块着色器上的最终光照着色。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The mix function that is used in the brick shader is responsible for performing
    linear interpolation between two given values based on the weight value.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在砖块着色器中使用的混合函数负责根据权重值在两个给定值之间执行线性插值。
- en: '**Syntax**:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '| Variable | Description |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `x` | This specifies the start of the range in which to interpolate |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `x` | 这指定了插值范围的起点 |'
- en: '| `y` | This specifies the end of the range in which to interpolate |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `y` | 这指定了插值范围的终点 |'
- en: '| `a` | This specifies the value to use to interpolate between x and y |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| `a` | 这指定了用于在 x 和 y 之间进行插值的值 |'
- en: Mathematically, the *mix(x, y, and a)* function calculates the linear interpolation
    between *x* and *y,* using `a` as weight. The resultant value is computed as *x
    * (1 − a) + y * a*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，*mix(x, y, and a)* 函数计算 *x* 和 *y* 之间的线性插值，使用 `a` 作为权重。计算出的值如下：*x * (1
    − a) + y * a*。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Gouraud shading – the per-fragment shading technique* recipe in
    [Chapter 5](ch05.html "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 5 章 *Gouraud 着色 – 每片段着色技术* 配方，*光与材料*。
- en: Generating the polka dot pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成波点图案
- en: 'This recipe is another procedural texture, which is an extension of our circle
    pattern shader. In that recipe, we looked at the logic behind producing a 2D circle
    pattern on a planar surface; this planar surface was created using fragment coordinates.
    In this recipe, we will create a polka dot pattern on the surface of the 3D mesh
    object; the main difference here is that instead of producing a logical circle
    in the square, we will use an inscribed logical sphere within the logical cube
    of dimensions **Side** x **Side** x **Side** units:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方是另一种程序纹理，它是我们圆形图案着色器的扩展。在那个配方中，我们研究了在平面表面上产生二维圆形图案的逻辑；这个平面表面是通过片段坐标创建的。在这个配方中，我们将在三维网格对象表面上创建波点图案；这里的主要区别在于，我们不会在方形中产生逻辑圆形，而是在逻辑立方体的
    **Side** x **Side** x **Side** 单位内使用内嵌的逻辑球体：
- en: '![Generating the polka dot pattern](img/5527OT_06_19.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![生成波点图案](img/5527OT_06_19.jpg)'
- en: Getting ready
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we have reused the lighting technique using the *Implementing
    two-side shading* recipe in [Chapter 5](ch05.html "Chapter 5. Light and Materials"),
    *Light and Materials*. The generic vertex attributes for vertex positions, normals,
    and texture coordinates are laid out with 0, 1, and 2 indexes, respectively.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们重用了第 5 章 *实现双面着色* 配方中的照明技术，*光与材料*。顶点位置、法线和纹理坐标的通用顶点属性分别用 0、1 和 2 个索引排列。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to implement the polka dot recipe:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以实现波点图案的配方：
- en: Create `PolkaDotsVertex.glsl` and reuse the code of the vertex shader from the
    previous recipe.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PolkaDotsVertex.glsl` 并重用前一个配方中的顶点着色器代码。
- en: 'Create `PolkaDotsFragment.glsl`; edit the following fragment shader file:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PolkaDotsFragment.glsl`；编辑以下片段着色器文件：
- en: '[PRE16]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following image shows the output of the polka shader on various 3D mesh
    models; among these, the hollow cylinder shows the two-sided shading technique,
    where the inside and outside faces are rendered with different color polka dots
    from inside and outside:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图像显示了波点着色器在各个 3D 网格模型上的输出；在这些模型中，空心圆柱展示了双面着色技术，其中内部和外部面以从内部和外部不同颜色的波点渲染：
- en: '![How to do it...](img/5527OT_06_20.jpg)'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/5527OT_06_20.jpg)'
- en: How it works...
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The polka dot shader uses object coordinates to produce polka dot on the surface
    of the mesh model; these object coordinates are shared by the vertex shader in
    the form of the `ObjectCoord` input vertex attribute variable. A modulus operation
    is performed on `ObjectCoord` using the `Cube` variable, which is a `vec3` of
    `Side`. This results in a logical cube, which is further subtracted by the half
    cube dimension in order to bring the origin at the center of the logical cube:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 波点着色器使用对象坐标在网格模型表面产生波点；这些对象坐标以 `ObjectCoord` 输入顶点属性变量的形式由顶点着色器共享。使用 `Cube` 变量对
    `ObjectCoord` 执行模运算，`Cube` 是一个 `vec3` 的 `Side`。这产生了一个逻辑立方体，然后从这个逻辑立方体的半立方维度中减去，以便将原点置于逻辑立方体的中心：
- en: '[PRE17]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Calculating the distance of the translated `ObjectCoord` with respect to this
    center will provide the length of the position vector from the translated origin:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平移后的 `ObjectCoord` 与此中心的距离将提供从平移原点到位置向量的长度：
- en: '[PRE18]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Finally, the length is compared with the `DotSize` using the GLSL step function
    in order to check whether it''s inside the imaginary sphere of the `DotSize` radius
    or not:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，使用 GLSL step 函数将长度与 `DotSize` 进行比较，以检查它是否在 `DotSize` 半径的虚球体内部：
- en: '[PRE19]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Depending on the outcome of the `insideSphere`, the color value is assigned
    to the body and polka dots; the colors used for the front face are different from
    the color used for back faces in order to exhibit the two-side shading.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `insideSphere` 的结果，颜色值被分配给主体和波点；用于前表面的颜色与用于背面颜色的颜色不同，以便展示双面着色。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Implementing two-side shading* recipe in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 5 章 *实现双面着色* 的配方，*光与材料*
- en: '*Procedural texture shading with object coordinates*'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用对象坐标进行过程纹理着色*'
- en: '*Creating the circular pattern and making them revolve*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建圆形图案并使它们旋转*'
- en: Discarding fragments
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 丢弃片段
- en: The OpenGL ES shading language provides an important feature of discarding fragments
    using the `discard` keyword; this keyword is used only in the fragment shader
    to prevent updating the framebuffer. In other words, using this keyword throws
    away the current fragment and stops execution of the fragment shader. This feature
    of the OpenGL ES shading language is a simple yet effective feature, which opens
    up possibilities of producing cross-sectional views of 3D geometries, holes, or
    perforated surfaces.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 着色语言提供了一个重要的功能，即使用 `discard` 关键字丢弃片段；这个关键字仅在片段着色器中使用，以防止更新帧缓冲区。换句话说，使用这个关键字会丢弃当前片段并停止片段着色器的执行。OpenGL
    ES 着色语言的这个特性是一个简单而有效的特性，它为产生 3D 几何体的横截面视图、孔或穿孔表面提供了可能性。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe reuses the last recipe; this requires a few changes in the fragment
    shader to demonstrate discarded fragment capabilities.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方重用了上一个配方；这需要在片段着色器中做一些更改以展示丢弃片段的功能。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Rename the polka shader vertex and the fragment shader file as `DiscardFragVertex.glsl`
    and `DiscardFragFragment.glsl`. Open the fragment shader file and add the highlighted
    code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 将圆点着色器的顶点着色器文件和片段着色器文件重命名为 `DiscardFragVertex.glsl` 和 `DiscardFragFragment.glsl`。打开片段着色器文件并添加以下高亮代码：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![How to do it...](img/5527OT_06_21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/5527OT_06_21.jpg)'
- en: How it works...
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The preceding output shows the application of the discard keyword in the polka
    fragment shader program. In this recipe, fragments are judged on the basis of
    the `insideCircle` variable. This variable checks whether the fragment is falling
    inside the circle or outside the circle. If it's falling inside the circle, then
    the fragment is thrown away; this results in a perforated look, as shown in the
    previous image.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的输出显示了在圆点片段着色器程序中应用 `discard` 关键字。在这个配方中，片段基于 `insideCircle` 变量进行判断。这个变量检查片段是否落在圆内或圆外。如果落在圆内，则丢弃该片段；这会导致如前图所示的多孔外观。
- en: In the vice versa condition, fragments residing outside of the circle are discarded,
    as shown in previous images. In general, it's not advisable to use the `discard`
    keyword extensively because it increases the overhead on the graphics pipeline
    to perform additional operations. According to Imagination Technologies, for PowerVR
    architecture, it advises limited use of the `discard` keyword in programming practices.
    Although this is very much dependent on the application itself, it's advisable
    to profile your application to see whether the `discard` produces a significant
    loss in its performance.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在相反的情况下，位于圆外的片段会被丢弃，如前图所示。一般来说，不建议广泛使用 `discard` 关键字，因为它会增加图形管道执行额外操作的开销。根据
    Imagination Technologies 的建议，对于 PowerVR 架构，建议在编程实践中限制使用 `discard` 关键字。尽管这很大程度上取决于应用程序本身，但建议对应用程序进行性能分析，以查看
    `discard` 是否会导致其性能显著下降。
- en: See also
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Generating the polka dot pattern*'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*生成圆点图案*'
- en: '*Procedural texture shading with texture coordinates*'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用纹理坐标进行过程纹理着色*'
- en: Procedural texture shading with texture coordinates
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用纹理坐标进行过程纹理着色
- en: 'Texture coordinates control the wrapping of texture on the surface of a model;
    these are 2D coordinates used to map texture on the 3D surface of the geometry.
    Texture coordinates are mapped to a different coordinate system called **UV**
    Mapping. Letters **U** and **V** denote the axis of the texture along the *x*
    and *y* axis, respectively:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标控制纹理在模型表面的包裹方式；这些是用于将纹理映射到几何体 3D 表面的 2D 坐标。纹理坐标映射到称为 **UV 映射** 的不同坐标系中。字母
    **U** 和 **V** 分别表示沿 *x* 轴和 *y* 轴的纹理轴：
- en: '![Procedural texture shading with texture coordinates](img/5527OT_06_22.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理坐标进行过程纹理着色](img/5527OT_06_22.jpg)'
- en: The preceding extreme left image shows an icon that needs to be mapped to a
    blue-colored square of some arbitrary dimension. An image (irrespective of its
    dimensions) is always treated in the UV mapping between a range of 0 to 1 along
    the U and V axis, respectively. Therefore, the bottom-left image is always **(0,
    0)** and the top-left image is **(1, 1)**; there is no need to assign these values
    in the OpenGL ES program. By default, it's understood by the graphics pipeline.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的最左边的图像显示了一个需要映射到某个任意尺寸蓝色方块的图标。一个图像（无论其尺寸如何）总是在U和V轴上的0到1的范围之间进行UV映射。因此，左下角的图像始终是**(0,
    0**)，左上角的图像是**(1, 1**)；在OpenGL ES程序中不需要分配这些值。默认情况下，图形管线会理解这一点。
- en: 'What needs to be mentioned is the texture coordinates of the 2D/3D model; for
    example; in the previous image, the blue color square is assigned with four UV
    coordinates, which shows how the image is going to be completely mapped to the
    surface of the square:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 需要提到的是2D/3D模型的纹理坐标；例如，在前面的图像中，蓝色方块被分配了四个UV坐标，这显示了图像将如何完全映射到方块的表面：
- en: '![Procedural texture shading with texture coordinates](img/5527OT_06_23.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![使用纹理坐标的程序化纹理着色](img/5527OT_06_23.jpg)'
- en: In the preceding image, the blue-colored square is assigned with new texture
    coordinates with bottom-left and top-right at (0, 0) and (0.5, 1), respectively;
    the resultant mapped image is shown in the right-hand side corner, where we can
    clearly see that new texture coordinates are pasted on half of the image along
    the *U* axis.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，蓝色方块被分配了新的纹理坐标，底部左角和右上角分别为**(0, 0**)和**(0.5, 1**)；映射后的图像显示在右下角，我们可以清楚地看到新的纹理坐标沿*U*轴粘贴在图像的一半上。
- en: Texture coordinates are compulsory for image-based texturing; however, they
    are not must for procedural texturing. Texture coordinates in procedural texturing
    have their own importance and their applications are endless. This recipe will
    demonstrate one of the applications of texture coordinates, where a grid like
    procedural texture is produced on the surface of a 3D cube mesh model. For more
    information on UV Mapping and its related application, refer to the next chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理坐标对于基于图像的纹理是强制性的；然而，对于程序化纹理来说并非必须。程序化纹理中的纹理坐标有其自身的重要性，其应用是无限的。本食谱将演示纹理坐标的一个应用，即在3D立方网格模型表面产生类似网格的程序化纹理。有关UV贴图及其相关应用的信息，请参阅下一章。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, the mesh model must contain texture coordinates information.
    For more information on how to create Wavefront object models with texture coordinates,
    refer to [Chapter 8](ch08.html "Chapter 8. Font Rendering"), *Working with Meshes*.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，网格模型必须包含纹理坐标信息。有关如何创建带有纹理坐标的Wavefront对象模型的信息，请参阅[第8章](ch08.html "第8章。与网格一起工作")，*与网格一起工作*。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'In order to implement this recipe, perform the following steps:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这个食谱，执行以下步骤：
- en: 'Create the `GridVertex.glsl` vertex shader program and add the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `GridVertex.glsl` 顶点着色器程序并添加以下代码：
- en: '[PRE21]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'For the programming grid shader, we need to make changes in the fragment shader.
    Create a new fragment shader file called `GridFragment.glsl` and use the following
    code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于编程网格着色器，我们需要在片段着色器中进行修改。创建一个新的片段着色器文件，命名为 `GridFragment.glsl`，并使用以下代码：
- en: '[PRE22]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![How to do it...](img/5527OT_06_24.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_06_24.jpg)'
- en: How it works...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The vertex shader receives texture coordinates from the OpenGL ES program in
    the `TexCoord` vertex attribute; this attribute is defined with index **2** as
    the layout location. Texture coordinates are passed on to the fragment shader
    as an out variable using `TextureCoord`. In this recipe, we have used a cube made
    of six square faces; each of these faces has texture coordinates defined in the
    UV mapping. Each of these UV mapping coordinates is multiplied by a multiplier
    factor variable called `texCoordMultiplyFactor`, which produces surface mapping
    coordinates called **ST** coordinates. Note that ST coordinates are logical coordinates,
    which are used to create surface mapping calculations; in many places, both are
    used interchangeably:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点着色器从OpenGL ES程序中的`TexCoord`顶点属性接收纹理坐标；该属性使用索引**2**定义为布局位置。纹理坐标通过`TextureCoord`作为输出变量传递给片段着色器。在这个配方中，我们使用了一个由六个正方形面组成的立方体；这些面的纹理坐标在UV映射中定义。这些UV映射坐标乘以一个名为`texCoordMultiplyFactor`的乘数因子变量，产生称为**ST**坐标的表面映射坐标。请注意，ST坐标是逻辑坐标，用于创建表面映射计算；在许多地方，它们可以互换使用：
- en: '[PRE23]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![How it works...](img/5527OT_06_25.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_06_25.jpg)'
- en: 'The practical significance of `texCoordMultiplyFactor` is to define the number
    of strips along horizontal and vertical dimensions. The width of the strip is
    controlled by the `stripWidth` variable. As coordinates are converted to ST mapping,
    we can now assume that there are 10 strips along the horizontal and vertical axis
    and each strip is **1** unit wide. The stripWidth is compared against ST coordinate
    fractional values using the GLSL `frac()` API; this API returns the fractional
    value of the decimal number. If the fractional values are greater than the `stripWidth`,
    then they are discarded; otherwise, depending on the front and back facing of
    the fragment, they are assigned with colors:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`texCoordMultiplyFactor`的实际意义是定义水平和垂直方向上的条带数量。条带的宽度由`stripWidth`变量控制。当坐标转换为ST映射时，现在可以假设水平和垂直轴上有10条条带，每条条带宽**1**个单位。使用GLSL的`frac()`
    API将`stripWidth`与ST坐标的分数值进行比较；此API返回十进制数的分数值。如果分数值大于`stripWidth`，则将其丢弃；否则，根据片段的前后面对齐，它们被分配颜色：'
- en: '[PRE24]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Refer to the *Implementing two-side shading* recipe in [Chapter 5](ch05.html
    "Chapter 5. Light and Materials"), *Light and Materials*
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第5章中关于*实现双面着色*的配方，*光和材料*
- en: '*Discarding fragments*'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*丢弃片段*'
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第7章中关于*使用UV映射应用纹理*的配方，*纹理和映射技术*
