- en: '*Chapter 7*: Building a Table View Controller for the To-Do Items'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：为待办事项构建表格视图控制器'
- en: If you have talked to other iOS developers about unit testing and the test-driven
    development of iOS apps, you might have heard the opinion that the user interface
    of iOS apps is not testable and also shouldn't be tested. Many developers state
    that it is enough to check whether the user interface is correct by running the
    app during development and testing it manually.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾与其他 iOS 开发者讨论过单元测试以及 iOS 应用程序的测试驱动开发，你可能已经听到过这样的观点：iOS 应用的用户界面不可测试，也不应该进行测试。许多开发者表示，在开发过程中运行应用程序并手动测试就足以检查用户界面是否正确。
- en: That might be true for the initial implementation of the user interface. During
    the development process, you run the app often on the iOS simulator or on your
    test devices and most bugs and errors in the user interface are quite obvious.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能适用于用户界面的初始实现。在开发过程中，你经常在 iOS 模拟器或测试设备上运行应用程序，用户界面中的大多数错误和错误都非常明显。
- en: However, the main benefit of a user interface that is backed by unit tests is
    the ability to fearlessly refactor code that is no longer perfect. As a developer,
    you gain experience every day, and each year, Apple releases new APIs that make
    our code easier to understand and sometimes easier to write. Long-living apps
    need to be refactored all the time to keep them manageable.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，具有单元测试支持的用户界面的主要好处是能够无畏地重构不再完美的代码。作为一名开发者，你每天都在积累经验，每年，Apple 都会发布新的 API，使我们的代码更容易理解，有时也更容易编写。长期存在的应用程序需要不断重构，以保持其可管理性。
- en: This is the main argument for writing tests for user interfaces in iOS development.
    When you are confident that the user interface is backed by good tests, you can
    execute extreme refactoring without breaking tested features.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在 iOS 开发中为用户界面编写测试的主要论据。当你确信用户界面背后有良好的测试支持时，你可以执行极端的重构而不会破坏已测试的功能。
- en: 'In this chapter, we are going to build a table view controller that shows the
    information of the to-do items. This view controller is the main part of the app,
    so it is a good idea to start with it. The chapter is structured as follows:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个表格视图控制器，用于显示待办事项的信息。这个视图控制器是应用程序的主要部分，因此从它开始是一个好主意。本章的结构如下：
- en: Adding the table view for the to-do items
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加待办事项的表格视图
- en: Testing the data source of a table view
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试表格视图的数据源
- en: Refactoring to a diffable data source
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构为可差异数据源
- en: Presenting two sections
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示两个部分
- en: Implementing the delegate of a table view
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现表格视图的代理
- en: After you have worked through this chapter, you will be able to write unit tests
    for table view controllers and table view cells.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成本章内容后，你将能够为表格视图控制器和表格视图单元格编写单元测试。
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The source code for this chapter is available here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码在此处可用：[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07)。
- en: Adding the table view for the to-do items
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加待办事项的表格视图
- en: 'As always, we start with a test. But before we can write the test, we need
    a new test class. Follow these steps to add a test class for the view controller
    that shows the to-do items:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从测试开始。但在我们可以编写测试之前，我们需要一个新的测试类。按照以下步骤为显示待办事项的视图控制器添加一个测试类：
- en: Select the `ToDoItemsListViewControllerTests`.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ToDoItemsListViewControllerTests`。
- en: In the created file, add `@testable import ToDo` and remove the two template
    test methods.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建的文件中，添加 `@testable import ToDo` 并删除两个模板测试方法。
- en: 'Add a property for the system under test (`sut`):'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为待测试的系统（`sut`）添加一个属性：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Xcode complains that it **Cannot find type 'ToDoItemsListViewController' in
    scope**. This is expected as we haven't added this class yet.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 抱怨它 **在作用域中找不到类型 'ToDoItemsListViewController'**。这是预期的，因为我们还没有添加这个类。
- en: 'Select the `ToDoItemsListViewController` in the **Class** field and make it
    a **Subclass of**: **UIViewController**. Make sure that **Also create XIB file**
    is not checked.'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **类** 字段中选择 `ToDoItemsListViewController` 并将其设置为 **子类**：**UIViewController**。确保
    **也创建 XIB 文件** 复选框未被勾选。
- en: '![Figure 7.1 – Options for ToDoItemsListViewController'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.1 – ToDoItemsListViewController 的选项'
- en: '](img/Figure_7.01_B18127.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.01_B18127.jpg]'
- en: Figure 7.1 – Options for ToDoItemsListViewController
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.1 – ToDoItemsListViewController 的选项
- en: Remove all the template code within the `ToDoItemsListViewController` class.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: We are going to switch between `ToDoItemsListViewController` and its test class
    several times. So, it might be a good idea to open both files side by side. In
    Xcode, you can do that by clicking the `ToDoItemsListViewControllerTests.swift`
    file in the Project navigator and then holding down the *Option* key and clicking
    the `ToDoItemsListViewController.swift` file. Xcode then opens the second file
    in the Assistant editor.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Test code and production code side by side in Xcode'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B18127.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Test code and production code side by side in Xcode
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can test anything in the view controller, we need to set up the system
    under test. Replace the `setUpWithError()` method with the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As the view controller will be set up in the `Main` storyboard, we need to load
    it from the storyboard in the setup code. Note that the call to `loadViewIfNeeded()`
    is the actual loading of the view. If we don't call that method, the view does
    not get loaded and all outlets are `nil`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a good citizen, we also need to clean up after each test. Replace the
    `tearDownWithError()` method with the following:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Loading from a storyboard can go wrong. Let's add a test to make sure this works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `ToDoItemsListViewControllerTests`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This test asserts that the system under test is not nil after being loaded from
    the storyboard.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to make sure that setting up the system under tests works. This
    test fails in `setupWithError`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: The setup method can't instantiate an instance of `ToDoItemsListViewController`
    from the storyboard because the initial view controller in the storyboard is of
    the `ViewController` type. Let's fix that.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: Open `ToDoItemsListViewController`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Changing the initial view controller in the Main storyboard'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B18127.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Changing the initial view controller in the Main storyboard
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests again to confirm that all the tests now pass.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to write the first test in this new test class. In the
    following steps, we add a test that asserts that the view controller has a `tableView`
    property for the to-do items. Let''s go:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `isDescendant(of:)` method is defined on `UIView` and it returns `true`
    if the view on which it is called is in the hierarchy of the view that is passed
    in as a parameter. This means that this test asserts that `tableView` is added
    to `sut.view` or one of its subviews.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Xcode complains that a `tableView` property to `ToDoItemsListViewController`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Open **Main.storyboard** in the interface builder and open the library by clicking
    the plus button in the toolbar and dragging a table view onto the view of the
    view controller.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Adding a table view to the view controller'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B18127.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Adding a table view to the view controller
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 将表视图添加到视图控制器
- en: Open the Assistant editor using the `ToDoItemsListViewController` class.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`ToDoItemsListViewController`类打开助手编辑器。
- en: '![Figure 7.5 – Dragging a connection from the storyboard into the class'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.5 – Dragging a connection from the storyboard into the class'
- en: '](img/Figure_7.05_B18127.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.05_B18127.jpg]'
- en: Figure 7.5 – Dragging a connection from the storyboard into the class
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 从故事板拖动连接到类
- en: Set the name of this property to `tableView` and click **Connect**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此属性的名称设置为`tableView`并点击**连接**。
- en: Run all the tests. All the tests pass. We have added a table view to the view
    of the view controller.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试。所有测试都通过。我们已经将表视图添加到视图控制器的视图中。
- en: A table view is managed by a data source and a delegate. In the next section,
    we will implement parts of the data source of the table view.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 表视图由数据源和代理管理。在下一节中，我们将实现表视图数据源的部分。
- en: Testing the data source of a table view
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试表视图的数据源
- en: In this section, we will implement parts of the data source for the table view
    using test-driven development. We will use the traditional approach by using the
    view controller as the data source. In the next section, we will switch to a diffable
    data source. Our challenge in this section is to write the tests so that they
    are independent of the actual implementation of the data source.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用测试驱动开发来实现表视图数据源的部分。我们将使用传统的通过使用视图控制器作为数据源的方法。在下一节中，我们将切换到可变数据源。本节中的挑战是编写测试，使它们独立于数据源的实际实现。
- en: But first, we need to talk about test doubles.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要谈谈测试替身。
- en: Adding a test double
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加测试替身
- en: 'In the film industry, doubles are used in scenes that are too dangerous for
    the actor. The double must look and act like the actor. In software testing, we
    have something similar: test doubles. Test doubles look and act like a piece of
    code, but can be controlled completely from within the test. For example, to test
    the data source of our table view, we need to connect the view controller with
    a store of to-do items. We could use the store we already implemented. But this
    would make the tests for the table view depend on the implementation of `ToDoItemStore`.
    It would be better to have a test double for `ToDoItemStore` we could use in the
    tests for `ToDoItemsListViewController`.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在电影行业中，替身在演员无法参与的危险场景中使用。替身必须看起来和表现得像演员。在软件测试中，我们也有类似的东西：测试替身。测试替身看起来和表现得像一段代码，但可以在测试中完全控制。例如，为了测试我们的表视图的数据源，我们需要将视图控制器与待办项存储连接起来。我们可以使用我们已实现的存储。但这样会使表视图的测试依赖于`ToDoItemStore`的实现。最好有一个可以用于`ToDoItemsListViewController`测试的`ToDoItemStore`测试替身。
- en: 'Follow these steps to add a test double for `ToDoItemStore`:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤为`ToDoItemStore`添加测试替身：
- en: 'The first step in implementing a test double for `ToDoItemStore` is to create
    a protocol that defines the interface our view controller expects. Add the following
    protocol to `ToDoItemStore.swift`:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现`ToDoItemStore`测试替身的第一步是创建一个定义我们的视图控制器期望的接口的协议。将以下协议添加到`ToDoItemStore.swift`中：
- en: '[PRE5]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The protocol defines the elements the view controller needs. It needs to subscribe
    to changes of the items and it also needs a way to check a to-do item.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 协议定义了视图控制器需要的元素。它需要订阅项目的变化，并且还需要一种检查待办项的方式。
- en: 'Now that we have the protocol, we can add the conformance to the protocol to
    `ToDoItemStore`:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了协议，我们可以将协议的符合性添加到`ToDoItemStore`中：
- en: '[PRE6]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we need a test double conforming to that protocol. Select the `ToDoItemStoreProtocolMock`.
    Replace the contents of that file with this code:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个符合该协议的测试替身。选择`ToDoItemStoreProtocolMock`。用以下代码替换该文件的内容：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With this implementation of the test double, we can control how the store used
    in the view controller behaves. We will see next how we can use this test double
    in a test.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个测试替身的实现，我们可以控制在视图控制器中使用的存储的行为。我们将在下一个测试中看到如何使用这个测试替身。
- en: Using test doubles to implement a number of rows
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试替身实现行数
- en: 'A table view data source needs to provide two kinds of information: first,
    the number of rows in a given section and second, the cell for a given item. Sure,
    there are other methods defined in the `UITableViewDataSource` protocol, but those
    are optional.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 表视图数据源需要提供两种类型的信息：首先，给定部分中的行数；其次，给定项的单元格。当然，`UITableViewDataSource`协议中定义了其他方法，但这些是可选的。
- en: 'Let''s start with the number of rows in a given section. In the default case,
    the number of sections in a table view is one. This means we are interested in
    the number of rows in the first and only section. Follow these steps to implement
    the correct number of rows for the table view:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从给定部分的行数开始。在默认情况下，表格视图中的部分数是1。这意味着我们感兴趣的是第一和唯一部分的行数。按照以下步骤实现表格视图的正确行数：
- en: 'Add the following property to `ToDoItemsListViewControllerTests`:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下属性添加到`ToDoItemsListViewControllerTests`：
- en: '[PRE8]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, set it up in `setUpWithError()` and make the system under test use it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`setUpWithError()`中设置它，并使系统测试使用它：
- en: '[PRE9]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This code does not compile because `toDoItemStore` is missing in `ToDoItemsListViewController`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码无法编译，因为`toDoItemStore`在`ToDoItemsListViewController`中缺失。
- en: 'Open `ToDoItemsListViewController` in the editor and add the missing property:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中打开`ToDoItemsListViewController`并添加缺少的属性：
- en: '[PRE10]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add the following test to `ToDoItemsListViewControllerTests`:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下测试添加到`ToDoItemsListViewControllerTests`：
- en: '[PRE11]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this test, we send a `ToDoItem` instance using its `itemPublisher`. We expect
    that the table view should then have one row in section zero.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用其`itemPublisher`发送一个`ToDoItem`实例。我们期望表格视图在零区应有行。
- en: Run all the tests to confirm that this new test fails.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认这个新测试失败。
- en: 'At the moment, the table view has no data source set. The `dataSource` property
    is nil. To make this test pass, we first need to assign `ToDoItemsListViewController`
    to the `dataSource` property of the table view. Add the following method to `ToDoItemsListViewController`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，表格视图没有设置数据源。`dataSource`属性为nil。为了使此测试通过，我们首先需要将`ToDoItemsListViewController`分配给表格视图的`dataSource`属性。将以下方法添加到`ToDoItemsListViewController`：
- en: '[PRE12]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Xcode complains that it `ToDoItemsListViewController` does not yet conform to
    the `UITableViewDataSource` protocol.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 抱怨`ToDoItemsListViewController`尚未符合`UITableViewDataSource`协议。
- en: 'Add the following extension to `ToDoItemsListViewController.swift`:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下扩展添加到`ToDoItemsListViewController.swift`：
- en: '[PRE13]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is the minimal code to make `ToDoItemsListViewController` conform to the
    `UITableViewDataSource` protocol and make the test pass.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使`ToDoItemsListViewController`符合`UITableViewDataSource`协议并使测试通过的最小代码。
- en: You might be wondering why we return a hardcoded fixed value from `tableView(_:numberOfRowsInSection:)`.
    This is clearly wrong and won't result in a working app. Patience. At the moment,
    our task is to make the test pass and this is what we have accomplished. Our feeling
    that this implementation is wrong just means we need another test to make sure
    the implementation is correct.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们从`tableView(_:numberOfRowsInSection:)`返回一个硬编码的固定值。这显然是错误的，并且不会导致应用程序正常工作。耐心点。目前，我们的任务是使测试通过，这是我们完成的事情。我们觉得这种实现是错误的只是意味着我们需要另一个测试来确保实现是正确的。
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到`ToDoItemsListViewControllerTests`：
- en: '[PRE14]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To make this test pass without breaking any previous tests, we need to process
    the items that are sent by the item publisher in the view controller.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在不破坏任何先前测试的情况下使此测试通过，我们需要在视图控制器中处理由项目发布者发送的项目。
- en: 'First, import Combine and add two properties, `items` and `token`, to `ToDoItemsListViewController`:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，导入Combine并添加两个属性，`items`和`token`，到`ToDoItemsListViewController`：
- en: '[PRE15]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `items` property will hold the items sent by the item publisher and the
    `token` property will hold a reference to the subscriber subscribed to that publisher.
    Without a reference to the subscriber, `Combine` would destroy the subscriber
    before we can use it.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`items`属性将保留由项目发布者发送的项目，而`token`属性将保留订阅该发布者的订阅者的引用。如果没有订阅者的引用，`Combine`会在我们使用它之前将其销毁。'
- en: 'Next, change `viewDidLoad()` in `ToDoItemsListViewController` so that it looks
    like this:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更改`ToDoItemsListViewController`中的`viewDidLoad()`，使其看起来像这样：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With this code, we subscribe to changes sent by the item publisher of `toDoItemStore`.
    We store the sent items in the `items` property we just added.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们订阅了由`toDoItemStore`的项目发布者发送的变化。我们将发送的项目存储在刚刚添加的`items`属性中。
- en: 'Finally, we can return the number of items in `tableView(_:numberOfRowsInSection:)`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在`tableView(_:numberOfRowsInSection:)`中返回项目数量：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the tests. All the tests pass.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。所有测试都通过。
- en: Next, we are going to use our test double to implement the to-do item cell for
    the table view.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用我们的测试替身来实现表格视图的待办事项单元格。
- en: Using test doubles to implement setting up the to-do item cell
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用测试替身来实现设置待办事项单元格
- en: 'As always, when implementing a new microfeature, we need a test. Follow these
    steps to add the failing test and the implementation that makes the test pass:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 像往常一样，在实现一个新的微功能时，我们需要一个测试。按照以下步骤添加失败的测试和使测试通过的实现：
- en: 'Add the following test method to `ToDoItemsListViewControllerTests.swift`:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试方法添加到 `ToDoItemsListViewControllerTests.swift`：
- en: '[PRE18]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is not the complete test, but we need to pause here because the `ToDoItemCell`
    type is not yet defined.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完整的测试，但我们需要在这里暂停，因为 `ToDoItemCell` 类型尚未定义。
- en: Select the `ToDoItemCell` and make it a `UITableViewCell`. Remove the template
    code within the class.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ToDoItemCell` 并将其设置为 `UITableViewCell`。移除类中的模板代码。
- en: 'Go back to `ToDoItemsListViewControllerTests` and add the test assertion, as
    shown in the following code block:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `ToDoItemsListViewControllerTests` 并添加测试断言，如下所示：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this test, we publish a list with one to-do item using our test double. Then
    we execute the `tableView(_:cellForRowAt:)` method defined in the data source
    of the table view. The returned table view cell should have a label showing the
    title of the to-do item sent by the publisher. This test does not compile at the
    moment because the cell doesn't have a property with the name `titleLabel`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用测试替身发布一个包含一个待办事项的列表。然后我们执行表格视图数据源中定义的 `tableView(_:cellForRowAt:)`
    方法。返回的表格视图单元格应该显示由发布者发送的待办事项的标题。这个测试目前无法编译，因为单元格没有名为 `titleLabel` 的属性。
- en: 'Add the property to `ToDoItemCell`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将属性添加到 `ToDoItemCell`：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Now the tests compile. Run the tests to confirm that the new test fails.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试可以编译了。运行测试以确认新的测试失败。
- en: If you are an experienced iOS developer, you might have realized that this code
    is not enough. The label is initialized, but it is not added to the cell. We will
    fix that later in this section.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一个经验丰富的 iOS 开发者，你可能已经意识到这段代码还不够。标签已初始化，但尚未添加到单元格中。我们将在本节稍后修复这个问题。
- en: "The test we have just added fails because the data source of the table view\
    \ does not return a cell of the `ToDoItemCell` type. Go to `ToDoItemsListViewController`\
    \ \Land replace the `tableView(_:cellForRowAt:)` method with the following code:"
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们刚刚添加的测试失败，因为表格视图的数据源没有返回 `ToDoItemCell` 类型的单元格。转到 `ToDoItemsListViewController`
    并将 `tableView(_:cellForRowAt:)` 方法替换为以下代码：
- en: '[PRE21]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Even though this code makes all the tests pass (run the tests to confirm), these
    few lines of code have several issues. One issue is that the text in `titleLabel`
    is hardcoded to the string expected by the test. It might seem stupid to write
    code like this, but this is kind of essential to TDD. Code that uses hardcoded
    values to make the tests pass tells us that we need more tests.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这段代码使所有测试通过（运行测试以确认），但这几行代码有几个问题。一个问题是在 `titleLabel` 中的文本是硬编码为测试期望的字符串。写这样的代码可能看起来很愚蠢，但这对
    TDD 来说是基本必要的。使用硬编码值使测试通过的代码告诉我们需要更多的测试。
- en: 'Add the following test to `ToDoItemsListViewController`:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到 `ToDoItemsListViewController`：
- en: '[PRE22]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: You should try to find a better name for this test. I use this name here to
    keep the method name kind of short. Long method names do not look good in printed
    books.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该尝试为这个测试找一个更好的名字。我在这里使用这个名字是为了让方法名尽可能短。长方法名在打印的书籍中看起来不好。
- en: In this test, we send two to-do items to the system under test and check the
    text in the second cell. Run the tests. This new test fails because the text in
    `titleLabel` is hardcoded.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们向系统测试发送两个待办事项，并检查第二个单元格中的文本。运行测试。这个新的测试失败，因为 `titleLabel` 中的文本是硬编码的。
- en: 'Change the implementation of `tableView(_:cellForRowAt:)` such that it looks
    like this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `tableView(_:cellForRowAt:)` 的实现，使其看起来像这样：
- en: '[PRE23]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, we get the item for that row from the `items` property and assign
    its title to the text of the `titleLabel` property. Run the tests to confirm that
    all the tests pass.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们从 `items` 属性中获取该行的项，并将其标题分配给 `titleLabel` 属性的文本。运行测试以确认所有测试通过。
- en: The implementation code still has an issue. The cells in a table view should
    be reused to improve the rendering performance of the table view. Let's refactor
    the code without breaking the tests.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实现代码仍然存在问题。表格视图中的单元格应该被重用，以提高表格视图的渲染性能。让我们重构代码，同时不破坏测试。
- en: 'To opt in to the cell reuse capability of `UITableView`, add the following
    lines of code to `viewDidLoad()` in `ToDoItemsListViewController`:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要启用 `UITableView` 的单元格重用功能，请将以下代码行添加到 `ToDoItemsListViewController` 的 `viewDidLoad()`
    中：
- en: '[PRE24]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With this call, we register `ToDoItemCell` for the reuse queue of the table
    view.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个调用，我们将 `ToDoItemCell` 注册到表格视图的重用队列中。
- en: 'Now we can ask the table view to dequeue such a cell in `tableView(_:cellForRowAt:)`:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以要求表格视图在`tableView(_:cellForRowAt:)`中出队这样的单元格：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the tests to confirm that we didn't break anything.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认我们没有破坏任何东西。
- en: The implementation of `ToDoItemCell` is not enough to make the cell show the
    title in the user interface. We have initialized the label, but we haven't added
    it to any view yet. This is what we will do next.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDoItemCell`的实现不足以使单元格在用户界面中显示标题。我们已经初始化了标签，但还没有将其添加到任何视图中。这就是我们接下来要做的。'
- en: 'We could write tests that check whether the label is added to the table view
    cell in the tests for the view controller. But if we think about it, they belong
    to dedicated tests for the cell itself. Follow these steps to add the test and
    the implementation that make the test pass:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写测试来检查标签是否在视图控制器的测试中添加到表格视图单元格。但如果我们仔细想想，它们应该属于针对单元格本身的专用测试。按照以下步骤添加测试和实现，以使测试通过：
- en: Select the `ToDoItemCellTests` in the **Text** field next to **Class** and create
    the file. Remove the two template tests in the created file.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**旁边的**文本**字段中选择`ToDoItemCellTests`并创建文件。删除创建的文件中的两个模板测试。
- en: 'Below the existing import statement, add the testable import of the `ToDo`
    module:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的导入语句下方，添加对`ToDo`模块的可测试导入：
- en: '[PRE26]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Before we can test anything relating to the table view cell, we need to set
    it up. Replace the implementation of the `ToDoItemCellTests` class with the following
    code:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以测试与表格视图单元格相关的任何内容之前，我们需要设置它。将`ToDoItemCellTests`类的实现替换为以下代码：
- en: '[PRE27]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we are ready to add the first test to this new test class. Add the following
    test method:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们准备好向这个新的测试类添加第一个测试。添加以下测试方法：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `isDescendant(of:)` method is defined on `UIView`. We have already seen
    this call earlier in this chapter when we wrote a test that asserted that the
    table view was added to the view of the view controller.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`isDescendant(of:)`方法是在`UIView`上定义的。我们已经在本章前面编写测试时看到了这个调用，当时我们断言表格视图被添加到视图控制器的视图中。'
- en: Run the tests to confirm that this new test fails.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新的测试失败。
- en: 'To make this test pass, change the code in `ToDoItemCell` such that it looks
    like this:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，请修改`ToDoItemCell`中的代码，使其看起来像这样：
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the tests to confirm that this code makes the test pass.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这段代码使测试通过。
- en: 'Now that the test passes, we move to the refactoring stage of the TDD workflow.
    Depending on your style of development, you may already be satisfied with this
    implementation. I like to structure the initialization of user interface elements
    differently. I would refactor that code to this:'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试通过后，我们进入TDD工作流程的重构阶段。根据你的开发风格，你可能已经对这个实现感到满意。我喜欢以不同的方式结构用户界面元素的初始化。我会将那段代码重构为以下形式：
- en: '[PRE30]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The difference is that I prefer to initialize the elements within the `init`
    method. Run the test to confirm that all the tests still pass.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 差别在于我更喜欢在`init`方法中初始化元素。运行测试以确认所有测试仍然通过。
- en: Note that we have intentionally not implemented any positioning of the label.
    In my opinion, this is something we shouldn't test with a unit test. The positioning
    and the size of user interface elements depend on the size of the screen and the
    version of iOS. We could write tests for these values, but most probably, those
    would often break even though the app still works for the user. With our tests,
    we want to catch the real bugs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有意没有实现任何标签的位置。在我看来，这不是我们应该用单元测试来测试的事情。用户界面元素的位置和大小取决于屏幕大小和iOS版本。我们可以为这些值编写测试，但很可能会经常破坏，尽管应用对用户来说仍然可以工作。我们想要通过测试来捕捉真正的错误。
- en: 'OK, this test was easy. Let''s now add the two other required labels – `dateLabel`
    and `locationLabel`:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，这个测试很简单。现在让我们添加另外两个必需的标签 - `dateLabel`和`locationLabel`：
- en: 'Add this test method to `ToDoItemCellTests`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此测试方法添加到`ToDoItemCellTests`中：
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the tests to confirm that this new test fails. The test fails because the
    `dateLabel` property is missing.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新的测试失败。测试失败是因为缺少`dateLabel`属性。
- en: 'Go to `ToDoItemCell` and add this property:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemCell`并添加此属性：
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '"Wait a minute, Dominik," I hear you say, "why didn''t you add the label to
    the content view?" Good question! In TDD, you should only add code that makes
    the test pass. The test failed because the label was not defined. So, our task
    in this step is to add this `dateLabel` property. At the moment, we don''t know
    whether this is enough to make the test pass. We have the feeling that this is
    not enough based on our previous experience with `titleLabel`, but it''s better
    to confirm our feeling.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: “等一下，多米尼克，”我听到你说，“你为什么没有将标签添加到内容视图中？”这是个好问题！在TDD（测试驱动开发）中，你应该只添加使测试通过的代码。测试失败是因为标签未定义。因此，在这一步中，我们的任务是添加这个`dateLabel`属性。目前，我们不知道这是否足以使测试通过。根据我们之前对`titleLabel`的经验，我们感觉这还不够，但最好还是确认我们的感觉。
- en: Run the tests to confirm that the test is still failing. It still fails, but
    this time in the line of the assert function call.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认测试仍然失败。它仍然失败，但这次是在断言函数调用的行。
- en: 'To make it pass, add the following line below the existing `addSubview` call:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，在现有的`addSubview`调用下面添加以下行：
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Run the tests again. Now, all the tests pass again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。现在，所有测试都通过了。
- en: 'When the `location` property of the to-do item is set, the cell should show
    the name of the `location` property. Add the following test to `ToDoItemCellTests`:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当设置待办事项的`location`属性时，单元格应显示`location`属性的名称。将以下测试添加到`ToDoItemCellTests`中：
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Run the tests to see this test failing.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看这个测试失败。
- en: 'Add the property for the `location` label to `ToDoItemCell`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`location`标签的属性添加到`ToDoItemCell`中：
- en: '[PRE35]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Run the tests to see the last test still failing, but now in the line with the
    assert function call.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看最后一个测试仍然失败，但现在是在断言函数调用的行中。
- en: 'Add the line that adds `locationLabel` as a subview to `contentView` of the
    cell:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码，将`locationLabel`作为子视图添加到单元格的`contentView`中：
- en: '[PRE36]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Run all the tests to make sure they all pass now.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确保现在它们都通过。
- en: 'The next step is to fill the labels in the data source of the table view. Open
    `ToDoItemsListViewControllerTests` and follow these steps to add this feature
    to our app:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是填充表格视图的数据源中的标签。打开`ToDoItemsListViewControllerTests`并按照以下步骤将此功能添加到我们的应用中：
- en: 'Add the following test to `ToDoItemsListViewControllerTests`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到`ToDoItemsListViewControllerTests`中：
- en: '[PRE37]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we now use `toDoItemStoreMock` to send a to-do item with a timestamp.
    In the `assert` function, we use a `dateFormatter` property that is not defined
    yet. Let's add this property to make the test compile.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们现在使用`toDoItemStoreMock`发送一个带有时间戳的待办事项。在`assert`函数中，我们使用一个尚未定义的`dateFormatter`属性。让我们添加这个属性以使测试编译。
- en: 'Go to `ToDoItemsListViewController` and add the following property:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemsListViewController`并添加以下属性：
- en: '[PRE38]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now the test compiles. Run the tests to confirm that this new test fails.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试可以编译。运行测试以确认这个新测试失败。
- en: 'To make the test pass, we need to set the date label in `tableView(_:cellForRowAt:)`.
    Add the following code right below `cell.textLabel.text = item.title`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使测试通过，我们需要在`tableView(_:cellForRowAt:)`中设置日期标签。在`cell.textLabel.text = item.title`下面添加以下代码：
- en: '[PRE39]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: We use the timestamp of the item to generate a date from it and ask the date
    formatter for a string representation of that date.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用项目的时间戳从中生成一个日期，并请求日期格式化器提供该日期的字符串表示形式。
- en: Run all the tests to confirm that all the tests pass.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认所有测试都通过。
- en: The next step is to refactor the implementation. We could move the generation
    of the date string to the model object, but then the model object would need to
    know how the data is presented to the user. This is not a good idea. It would
    be better to move that code to a view model. That is a class connected to the
    view controller that converts the model data such that it can be presented in
    the user interface.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是对实现进行重构。我们可以将日期字符串的生成移动到模型对象中，但这样模型对象就需要知道数据是如何呈现给用户的。这不是一个好主意。最好是将那段代码移动到视图模型中。这是一个与视图控制器连接的类，它将模型数据转换为可以在用户界面中呈现的形式。
- en: We will leave it as it is because for our small app, it's OK to have this code
    in the view controller.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将保持原样，因为对于我们的小型应用来说，在视图控制器中保留此代码是可以的。
- en: You will implement the setting of the `location` label in the exercises later
    in this chapter.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在本章后面的练习中实现设置`location`标签。
- en: We have now implemented the presentation and the setup of the to-do item table
    view cells. With the tests in place, we can now look at the implementation and
    see whether we can improve it to better fit modern concepts in iOS development.
    The implementation we have built here is based on how table views have been implemented
    for many years. Over the last few years, better ways have emerged to set up a
    table view.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经实现了待办事项表视图单元格的表示和设置。有了测试，我们现在可以查看实现，看看我们是否可以改进它以更好地适应现代iOS开发的概念。我们在这里构建的实现是基于多年来表格视图的实现方式。在过去的几年里，出现了更好的设置表格视图的方法。
- en: In the following section, we will refactor our implementation to use a diffable
    data source.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，我们将重构我们的实现以使用可差异化的数据源。
- en: Refactoring to a diffable data source
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构为可差异化的数据源
- en: In iOS 13, Apple introduced the `UITableViewDiffableDataSource` class. This
    class manages the update of a table view when the data changes and it can be used
    as the data source of any table view. It should be used, when possible, because
    implementing updates of a table view is a bit complicated and can lead to strange
    bugs and even crashes. In addition, the code needed to set up such a data source
    is often easier to read and reason about than the traditional implementation we
    used in the previous section.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在iOS 13中，Apple引入了`UITableViewDiffableDataSource`类。此类管理数据变化时表格视图的更新，并且可以用作任何表格视图的数据源。在可能的情况下应使用它，因为实现表格视图的更新有点复杂，可能会导致奇怪的错误甚至崩溃。此外，设置此类数据源所需的代码通常比我们在上一节中使用的传统实现更容易阅读和推理。
- en: 'Follow these steps to transform our implementation to one that uses a diffable
    data source:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将我们的实现转换为使用可差异化的数据源：
- en: 'A diffable data source manages the data in the table view using a section and
    an item that both need to conform to the `Hashable` protocol. We already have
    an item we can use in the diffable data source, the `ToDoItem` structure. However,
    this structure does not yet conform to `Hashable`. To make it conform to that
    protocol, add the following code to `ToDoItem.swift` outside of the current `ToDoItem`
    implementation:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可差异化的数据源使用符合`Hashable`协议的分区和项来管理表格视图中的数据。我们已经有了一个可以在可差异化的数据源中使用的项，即`ToDoItem`结构。然而，此结构尚未符合`Hashable`协议。为了使其符合该协议，请将以下代码添加到`ToDoItem.swift`中的当前`ToDoItem`实现之外：
- en: '[PRE40]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With this code, we tell the hasher provided by Swift to use the ID of the to-do
    item to generate the hash value. The ID of the to-do item is unique and therefore
    a good basis for a hash value.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们告诉Swift提供的哈希器使用待办事项的ID来生成哈希值。待办事项的ID是唯一的，因此是哈希值的好基础。
- en: 'Next, we need a section type that also conforms to `Hashable`. Add the following
    `enum` type to `ToDoItemsListViewController.swift`:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个同时符合`Hashable`协议的分区类型。将以下`enum`类型添加到`ToDoItemsListViewController.swift`中：
- en: '[PRE41]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is enough for now. We only need one section at the moment because later
    we will add another section to distinguish between to-do and done items.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这样就足够了。目前我们只需要一个分区，因为稍后我们将添加另一个分区来区分待办事项和已完成事项。
- en: 'Next, we need a property for the data source. Add the following property to
    `ToDoItemsListViewController`:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个数据源属性。将以下属性添加到`ToDoItemsListViewController`中：
- en: '[PRE42]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'In the `viewDidLoad()` method, replace the `tableView.dataSource = self` code
    with the following:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`viewDidLoad()`方法中，将`tableView.dataSource = self`代码替换为以下代码：
- en: '[PRE43]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: With this code, we initialize a diffable data source for the table view. The
    second parameter of this initializer is a `cell` provider. This piece of code
    gets called when the table view needs to show a `cell` provider for a given index
    path. As you can see, the code within this closure looks similar to the code we
    had in `tableView(_:cellForRowAt:)` previously.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们为表格视图初始化一个可差异化的数据源。此初始化器的第二个参数是一个`cell`提供者。当表格视图需要为给定的索引路径显示`cell`提供者时，会调用此段代码。如您所见，此闭包内的代码与我们之前在`tableView(_:cellForRowAt:)`中使用的代码类似。
- en: Now delete the extension that implemented the conformance to `UITableViewDataSource`
    within `ToDoItemsListViewController.swift`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在删除`ToDoItemsListViewController.swift`中实现`UITableViewDataSource`协议的扩展。
- en: '`UITableViewDiffableDataSource` manages table view updates via `NSDiffableDataSourceSnapshot`.
    To update the table view with new data, we need to create a snapshot and set it
    up with the new data. Add the following method to `ToDoItemsListViewController`:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UITableViewDiffableDataSource`通过`NSDiffableDataSourceSnapshot`管理表格视图的更新。要使用新数据更新表格视图，我们需要创建一个快照并将其与新数据设置起来。将以下方法添加到`ToDoItemsListViewController`中：'
- en: '[PRE44]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In this method, we create a snapshot and add one section and the items passed
    into that method.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们创建一个快照并添加一个部分以及传递给该方法的项。
- en: 'The view controller receives updates from the publisher of `toDoItemStore`.
    Change the subscription code in `viewDidLoad` such that it looks like this:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图控制器从`toDoItemStore`的发布者接收更新。在`viewDidLoad`中更改订阅代码，使其看起来像这样：
- en: '[PRE45]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: In addition to assigning the received items to the `items` property of the view
    controller, we call here the new update method that applies a new snapshot to
    the data source.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将接收到的项分配给视图控制器的`items`属性外，我们在这里调用新的更新方法，该方法将新的快照应用到数据源。
- en: Run the tests. All the tests pass. We have now successfully refactored our table
    view code to use a diffable data source.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试。所有测试都通过了。我们现在已成功重构我们的表格视图代码以使用可比较的数据源。
- en: Our list of to-do items should show two sections, one for the to-do items and
    one for the already done items. In the next section, we will change the snapshot
    creation to achieve this.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务项列表应显示两个部分，一个用于任务项，一个用于已完成项。在下一节中，我们将更改快照创建以实现这一点。
- en: Presenting two sections
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 展示两个部分
- en: 'As we have already refactored to a diffable data source, supporting two sections
    in the table view is quite easy. Follow these steps to implement two sections:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经重构为可比较的数据源，支持表格视图中的两个部分相当容易。按照以下步骤实现两个部分：
- en: 'As always, we need to start with a failing test. Add the following test to
    `ToDoItemsListViewControllerTests`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 和往常一样，我们需要从一个失败的测试开始。将以下测试添加到`ToDoItemsListViewControllerTests`中：
- en: '[PRE46]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In this test, we set a to-do item and a done item to the table view using `toDoItemStoreMock`.
    The name of the test method should also include what the preconditions of the
    tests are. We use a shorter name in the book because otherwise, the code is harder
    to read. You should try to use a better name.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用`toDoItemStoreMock`将任务项和已完成项设置到表格视图中。测试方法的名称也应包括测试的先决条件。在书中我们使用较短的名称，因为否则代码更难阅读。你应该尝试使用更好的名称。
- en: Run the tests to confirm that this new test fails.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认此新测试失败。
- en: 'To support two sections, `enum Section` needs two cases. Change the code of
    `enum Section` such that it looks like this:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了支持两个部分，`enum Section`需要两个情况。更改`enum Section`的代码，使其看起来像这样：
- en: '[PRE47]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Finally, we need to change the `update` method such that it looks like this:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要更改`update`方法，使其看起来像这样：
- en: '[PRE48]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this code, we add the two sections to the snapshot and use the `done` property
    of the to-do item to fill the two sections.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将两个部分添加到快照中，并使用任务项的`done`属性来填充两个部分。
- en: Run the tests to confirm that this code makes the new test pass.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认此代码使新的测试通过。
- en: The data source of the table view is now finished. The next step in implementing
    the list view of the to-do items is to add code that reacts to the user selecting
    the to-do item in the list.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图的数据源现在已经完成。实现待办事项列表视图的下一步是添加代码，以响应用户在列表中选择任务项。
- en: Implementing the delegate of a table view
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现表格视图的委托
- en: When the user selects a to-do item in the list of items, the details of the
    to-do item should be shown in a dedicated view. We will implement the actual navigation
    between the different views of the app in [*Chapter 11*](B18127_11_ePub.xhtml#_idTextAnchor526),
    *Easy Navigation with Coordinators*. In this section, we will implement the required
    code in `ToDoItemsListViewController`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在项目列表中选择一个任务项时，应在专用视图中显示任务项的详细信息。我们将在[*第11章*](B18127_11_ePub.xhtml#_idTextAnchor526)中实现不同视图之间的实际导航，*使用协调器轻松导航*。在本节中，我们将实现`ToDoItemsListViewController`中所需的代码。
- en: 'Follow these steps to prepare `ToDoItemsListViewController` for navigation
    to the detail view:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤准备`ToDoItemsListViewController`以导航到详细视图：
- en: 'Let''s assume we already have a delegate that will provide a method the view
    controller can call. Add the following test method to `ToDoItemsListViewControllerTests`:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们已经有了一个委托，它将提供一个视图控制器可以调用的方法。将以下测试方法添加到`ToDoItemsListViewControllerTests`中：
- en: '[PRE49]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Xcode tells us that it cannot find the `ToDoItemsListViewControllerProtocolMock`
    type. This type is meant to be a mock object for the real delegate we will add
    in [*Chapter 11*](B18127_11_ePub.xhtml#_idTextAnchor526), *Easy Navigation with
    Coordinators*. The view controller should tell the delegate that a to-do item
    was selected by the user. Let's add a mock object with a method for that task.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode告诉我们它找不到`ToDoItemsListViewControllerProtocolMock`类型。这个类型是为了模拟我们将在[*第11章*](B18127_11_ePub.xhtml#_idTextAnchor526)，“使用协调器轻松导航”中添加的实际代理。视图控制器应该通知代理用户已选择待办事项。让我们添加一个用于该任务的模拟对象。
- en: 'Select the `ToDoItemsListViewControllerProtocolMock` in the **Save As** field
    and then click **Create**. Replace the contents of the created file with the following:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**保存为**字段中选择`ToDoItemsListViewControllerProtocolMock`，然后点击**创建**。将创建的文件内容替换为以下内容：
- en: '[PRE50]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Again, Xcode tells us that a type is missing. This time, Xcode doesn't know
    anything about `ToDoItemsListViewControllerProtocol`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Xcode告诉我们缺少一个类型。这次，Xcode对`ToDoItemsListViewControllerProtocol`一无所知。
- en: 'Go to `ToDoItemsListViewController.swift` and add the following protocol below
    the import statements:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemsListViewController.swift`并在导入语句下方添加以下协议：
- en: '[PRE51]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can finish the implementation of the protocol mock:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成协议模拟的实现：
- en: '[PRE52]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This protocol mock stores the received argument to the call of the delegate
    method, `selectToDoItem(_:item:)`.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 这个协议模拟将接收到的参数存储在调用代理方法`selectToDoItem(_:item:)`时。
- en: 'Now that we have this protocol mock, we can use it in our test:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了这个协议模拟，我们可以在测试中使用它：
- en: '[PRE53]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: We have to stop here because `sut` doesn't yet have a `delegate` property.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在这里停止，因为`sut`还没有`delegate`属性。
- en: 'Add that property to `ToDoItemsListViewController`:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将该属性添加到`ToDoItemsListViewController`：
- en: '[PRE54]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Now we can finish the test method:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成测试方法：
- en: '[PRE55]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: After we have set the delegate of the system under test, we send one to-do item
    using `itemPublisher` of `toDoItemStoreMock`. Next, we call `tableView(_:didSelectRowAt:)`
    of the `tableViews` delegate. Finally, we assert that the protocol method, `selectToDoItem(_:item:)`,
    got called with the selected to-do item.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们设置了系统测试的代理之后，我们使用`toDoItemStoreMock`的`itemPublisher`发送一个待办事项。接下来，我们调用`tableView(_:didSelectRowAt:)`的`tableViews`代理。最后，我们断言协议方法`selectToDoItem(_:item:)`确实被调用，并带有所选的待办事项。
- en: Run the tests to confirm that this new test fails.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'To make the test pass, add the follow extension to `ToDoItemsListViewController.swift`
    outside of the class definition of `ToDoItemsListViewController`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使测试通过，请将以下扩展添加到`ToDoItemsListViewController.swift`中，位于`ToDoItemsListViewController`类定义之外：
- en: '[PRE56]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In this implementation, we get the to-do item of the selected cell and call
    the delegate method with it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中，我们获取所选单元格的待办事项，并使用它调用代理方法。
- en: 'To make `ToDoItemsListViewController` the delegate of the table view, add the
    following line to the end of `viewDidLoad()`:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`ToDoItemsListViewController`成为表格视图的代理，请在`viewDidLoad()`的末尾添加以下行：
- en: '[PRE57]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Now, run the tests to confirm that all the tests pass.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行测试以确认所有测试都通过。
- en: For now, we are finished with implementing the list view of the to-do items.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经完成了待办事项列表视图的实现。
- en: Summary
  id: totrans-260
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned how to test table views and table view cells.
    We experienced the value of useful unit tests when refactoring a large part of
    the code. By switching from the traditional table view data source to the diffable
    data source, we improved the code and the behavior of the app while still keeping
    the existing tested functionality.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何测试表格视图和表格视图单元格。我们在重构代码的大部分内容时体验到了有用单元测试的价值。通过从传统的表格视图数据源切换到可变数据源，我们改进了代码和应用程序的行为，同时保持了现有的测试功能。
- en: In the next chapter, we will use the knowledge we gained to create a detailed
    view and its view controller.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用我们获得的知识来创建详细视图及其视图控制器。
- en: Exercises
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Implement the setting of the location label using test-driven development.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用测试驱动开发实现位置标签的设置。
- en: Try to figure out in the documentation of Xcode how to add section headers when
    using a diffable data source. We will implement the section headers in [*Chapter
    11*](B18127_11_ePub.xhtml#_idTextAnchor526), *Easy Navigation with Coordinators*.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在Xcode的文档中找出如何在使用可变数据源时添加分区标题。我们将在[*第11章*](B18127_11_ePub.xhtml#_idTextAnchor526)，“使用协调器轻松导航”中实现分区标题。
