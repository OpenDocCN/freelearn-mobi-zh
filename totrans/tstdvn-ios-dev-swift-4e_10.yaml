- en: '*Chapter 7*: Building a Table View Controller for the To-Do Items'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have talked to other iOS developers about unit testing and the test-driven
    development of iOS apps, you might have heard the opinion that the user interface
    of iOS apps is not testable and also shouldn't be tested. Many developers state
    that it is enough to check whether the user interface is correct by running the
    app during development and testing it manually.
  prefs: []
  type: TYPE_NORMAL
- en: That might be true for the initial implementation of the user interface. During
    the development process, you run the app often on the iOS simulator or on your
    test devices and most bugs and errors in the user interface are quite obvious.
  prefs: []
  type: TYPE_NORMAL
- en: However, the main benefit of a user interface that is backed by unit tests is
    the ability to fearlessly refactor code that is no longer perfect. As a developer,
    you gain experience every day, and each year, Apple releases new APIs that make
    our code easier to understand and sometimes easier to write. Long-living apps
    need to be refactored all the time to keep them manageable.
  prefs: []
  type: TYPE_NORMAL
- en: This is the main argument for writing tests for user interfaces in iOS development.
    When you are confident that the user interface is backed by good tests, you can
    execute extreme refactoring without breaking tested features.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to build a table view controller that shows the
    information of the to-do items. This view controller is the main part of the app,
    so it is a good idea to start with it. The chapter is structured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the table view for the to-do items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the data source of a table view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring to a diffable data source
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting two sections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the delegate of a table view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After you have worked through this chapter, you will be able to write unit tests
    for table view controllers and table view cells.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The source code for this chapter is available here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter07).
  prefs: []
  type: TYPE_NORMAL
- en: Adding the table view for the to-do items
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, we start with a test. But before we can write the test, we need
    a new test class. Follow these steps to add a test class for the view controller
    that shows the to-do items:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ToDoItemsListViewControllerTests`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the created file, add `@testable import ToDo` and remove the two template
    test methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a property for the system under test (`sut`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode complains that it **Cannot find type 'ToDoItemsListViewController' in
    scope**. This is expected as we haven't added this class yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `ToDoItemsListViewController` in the **Class** field and make it
    a **Subclass of**: **UIViewController**. Make sure that **Also create XIB file**
    is not checked.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.1 – Options for ToDoItemsListViewController'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.01_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.1 – Options for ToDoItemsListViewController
  prefs: []
  type: TYPE_NORMAL
- en: Remove all the template code within the `ToDoItemsListViewController` class.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to switch between `ToDoItemsListViewController` and its test class
    several times. So, it might be a good idea to open both files side by side. In
    Xcode, you can do that by clicking the `ToDoItemsListViewControllerTests.swift`
    file in the Project navigator and then holding down the *Option* key and clicking
    the `ToDoItemsListViewController.swift` file. Xcode then opens the second file
    in the Assistant editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.2 – Test code and production code side by side in Xcode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.02_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.2 – Test code and production code side by side in Xcode
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can test anything in the view controller, we need to set up the system
    under test. Replace the `setUpWithError()` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the view controller will be set up in the `Main` storyboard, we need to load
    it from the storyboard in the setup code. Note that the call to `loadViewIfNeeded()`
    is the actual loading of the view. If we don't call that method, the view does
    not get loaded and all outlets are `nil`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To be a good citizen, we also need to clean up after each test. Replace the
    `tearDownWithError()` method with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Loading from a storyboard can go wrong. Let's add a test to make sure this works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This test asserts that the system under test is not nil after being loaded from
    the storyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to make sure that setting up the system under tests works. This
    test fails in `setupWithError`.
  prefs: []
  type: TYPE_NORMAL
- en: The setup method can't instantiate an instance of `ToDoItemsListViewController`
    from the storyboard because the initial view controller in the storyboard is of
    the `ViewController` type. Let's fix that.
  prefs: []
  type: TYPE_NORMAL
- en: Open `ToDoItemsListViewController`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.3 – Changing the initial view controller in the Main storyboard'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.03_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.3 – Changing the initial view controller in the Main storyboard
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests again to confirm that all the tests now pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to write the first test in this new test class. In the
    following steps, we add a test that asserts that the view controller has a `tableView`
    property for the to-do items. Let''s go:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `isDescendant(of:)` method is defined on `UIView` and it returns `true`
    if the view on which it is called is in the hierarchy of the view that is passed
    in as a parameter. This means that this test asserts that `tableView` is added
    to `sut.view` or one of its subviews.
  prefs: []
  type: TYPE_NORMAL
- en: Xcode complains that a `tableView` property to `ToDoItemsListViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: Open **Main.storyboard** in the interface builder and open the library by clicking
    the plus button in the toolbar and dragging a table view onto the view of the
    view controller.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Adding a table view to the view controller'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.04_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.4 – Adding a table view to the view controller
  prefs: []
  type: TYPE_NORMAL
- en: Open the Assistant editor using the `ToDoItemsListViewController` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Dragging a connection from the storyboard into the class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_7.05_B18127.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 7.5 – Dragging a connection from the storyboard into the class
  prefs: []
  type: TYPE_NORMAL
- en: Set the name of this property to `tableView` and click **Connect**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run all the tests. All the tests pass. We have added a table view to the view
    of the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: A table view is managed by a data source and a delegate. In the next section,
    we will implement parts of the data source of the table view.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the data source of a table view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will implement parts of the data source for the table view
    using test-driven development. We will use the traditional approach by using the
    view controller as the data source. In the next section, we will switch to a diffable
    data source. Our challenge in this section is to write the tests so that they
    are independent of the actual implementation of the data source.
  prefs: []
  type: TYPE_NORMAL
- en: But first, we need to talk about test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a test double
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the film industry, doubles are used in scenes that are too dangerous for
    the actor. The double must look and act like the actor. In software testing, we
    have something similar: test doubles. Test doubles look and act like a piece of
    code, but can be controlled completely from within the test. For example, to test
    the data source of our table view, we need to connect the view controller with
    a store of to-do items. We could use the store we already implemented. But this
    would make the tests for the table view depend on the implementation of `ToDoItemStore`.
    It would be better to have a test double for `ToDoItemStore` we could use in the
    tests for `ToDoItemsListViewController`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to add a test double for `ToDoItemStore`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step in implementing a test double for `ToDoItemStore` is to create
    a protocol that defines the interface our view controller expects. Add the following
    protocol to `ToDoItemStore.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The protocol defines the elements the view controller needs. It needs to subscribe
    to changes of the items and it also needs a way to check a to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have the protocol, we can add the conformance to the protocol to
    `ToDoItemStore`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need a test double conforming to that protocol. Select the `ToDoItemStoreProtocolMock`.
    Replace the contents of that file with this code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this implementation of the test double, we can control how the store used
    in the view controller behaves. We will see next how we can use this test double
    in a test.
  prefs: []
  type: TYPE_NORMAL
- en: Using test doubles to implement a number of rows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A table view data source needs to provide two kinds of information: first,
    the number of rows in a given section and second, the cell for a given item. Sure,
    there are other methods defined in the `UITableViewDataSource` protocol, but those
    are optional.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the number of rows in a given section. In the default case,
    the number of sections in a table view is one. This means we are interested in
    the number of rows in the first and only section. Follow these steps to implement
    the correct number of rows for the table view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following property to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, set it up in `setUpWithError()` and make the system under test use it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This code does not compile because `toDoItemStore` is missing in `ToDoItemsListViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open `ToDoItemsListViewController` in the editor and add the missing property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following test to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we send a `ToDoItem` instance using its `itemPublisher`. We expect
    that the table view should then have one row in section zero.
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, the table view has no data source set. The `dataSource` property
    is nil. To make this test pass, we first need to assign `ToDoItemsListViewController`
    to the `dataSource` property of the table view. Add the following method to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode complains that it `ToDoItemsListViewController` does not yet conform to
    the `UITableViewDataSource` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following extension to `ToDoItemsListViewController.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is the minimal code to make `ToDoItemsListViewController` conform to the
    `UITableViewDataSource` protocol and make the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why we return a hardcoded fixed value from `tableView(_:numberOfRowsInSection:)`.
    This is clearly wrong and won't result in a working app. Patience. At the moment,
    our task is to make the test pass and this is what we have accomplished. Our feeling
    that this implementation is wrong just means we need another test to make sure
    the implementation is correct.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To make this test pass without breaking any previous tests, we need to process
    the items that are sent by the item publisher in the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, import Combine and add two properties, `items` and `token`, to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `items` property will hold the items sent by the item publisher and the
    `token` property will hold a reference to the subscriber subscribed to that publisher.
    Without a reference to the subscriber, `Combine` would destroy the subscriber
    before we can use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, change `viewDidLoad()` in `ToDoItemsListViewController` so that it looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, we subscribe to changes sent by the item publisher of `toDoItemStore`.
    We store the sent items in the `items` property we just added.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can return the number of items in `tableView(_:numberOfRowsInSection:)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests. All the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to use our test double to implement the to-do item cell for
    the table view.
  prefs: []
  type: TYPE_NORMAL
- en: Using test doubles to implement setting up the to-do item cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, when implementing a new microfeature, we need a test. Follow these
    steps to add the failing test and the implementation that makes the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test method to `ToDoItemsListViewControllerTests.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is not the complete test, but we need to pause here because the `ToDoItemCell`
    type is not yet defined.
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ToDoItemCell` and make it a `UITableViewCell`. Remove the template
    code within the class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go back to `ToDoItemsListViewControllerTests` and add the test assertion, as
    shown in the following code block:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we publish a list with one to-do item using our test double. Then
    we execute the `tableView(_:cellForRowAt:)` method defined in the data source
    of the table view. The returned table view cell should have a label showing the
    title of the to-do item sent by the publisher. This test does not compile at the
    moment because the cell doesn't have a property with the name `titleLabel`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the property to `ToDoItemCell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the tests compile. Run the tests to confirm that the new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: If you are an experienced iOS developer, you might have realized that this code
    is not enough. The label is initialized, but it is not added to the cell. We will
    fix that later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: "The test we have just added fails because the data source of the table view\
    \ does not return a cell of the `ToDoItemCell` type. Go to `ToDoItemsListViewController`\
    \ \Land replace the `tableView(_:cellForRowAt:)` method with the following code:"
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Even though this code makes all the tests pass (run the tests to confirm), these
    few lines of code have several issues. One issue is that the text in `titleLabel`
    is hardcoded to the string expected by the test. It might seem stupid to write
    code like this, but this is kind of essential to TDD. Code that uses hardcoded
    values to make the tests pass tells us that we need more tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You should try to find a better name for this test. I use this name here to
    keep the method name kind of short. Long method names do not look good in printed
    books.
  prefs: []
  type: TYPE_NORMAL
- en: In this test, we send two to-do items to the system under test and check the
    text in the second cell. Run the tests. This new test fails because the text in
    `titleLabel` is hardcoded.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the implementation of `tableView(_:cellForRowAt:)` such that it looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we get the item for that row from the `items` property and assign
    its title to the text of the `titleLabel` property. Run the tests to confirm that
    all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation code still has an issue. The cells in a table view should
    be reused to improve the rendering performance of the table view. Let's refactor
    the code without breaking the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To opt in to the cell reuse capability of `UITableView`, add the following
    lines of code to `viewDidLoad()` in `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this call, we register `ToDoItemCell` for the reuse queue of the table
    view.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can ask the table view to dequeue such a cell in `tableView(_:cellForRowAt:)`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that we didn't break anything.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation of `ToDoItemCell` is not enough to make the cell show the
    title in the user interface. We have initialized the label, but we haven't added
    it to any view yet. This is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could write tests that check whether the label is added to the table view
    cell in the tests for the view controller. But if we think about it, they belong
    to dedicated tests for the cell itself. Follow these steps to add the test and
    the implementation that make the test pass:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `ToDoItemCellTests` in the **Text** field next to **Class** and create
    the file. Remove the two template tests in the created file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Below the existing import statement, add the testable import of the `ToDo`
    module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Before we can test anything relating to the table view cell, we need to set
    it up. Replace the implementation of the `ToDoItemCellTests` class with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are ready to add the first test to this new test class. Add the following
    test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `isDescendant(of:)` method is defined on `UIView`. We have already seen
    this call earlier in this chapter when we wrote a test that asserted that the
    table view was added to the view of the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this test pass, change the code in `ToDoItemCell` such that it looks
    like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this code makes the test pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the test passes, we move to the refactoring stage of the TDD workflow.
    Depending on your style of development, you may already be satisfied with this
    implementation. I like to structure the initialization of user interface elements
    differently. I would refactor that code to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The difference is that I prefer to initialize the elements within the `init`
    method. Run the test to confirm that all the tests still pass.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have intentionally not implemented any positioning of the label.
    In my opinion, this is something we shouldn't test with a unit test. The positioning
    and the size of user interface elements depend on the size of the screen and the
    version of iOS. We could write tests for these values, but most probably, those
    would often break even though the app still works for the user. With our tests,
    we want to catch the real bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, this test was easy. Let''s now add the two other required labels – `dateLabel`
    and `locationLabel`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add this test method to `ToDoItemCellTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to confirm that this new test fails. The test fails because the
    `dateLabel` property is missing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemCell` and add this property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '"Wait a minute, Dominik," I hear you say, "why didn''t you add the label to
    the content view?" Good question! In TDD, you should only add code that makes
    the test pass. The test failed because the label was not defined. So, our task
    in this step is to add this `dateLabel` property. At the moment, we don''t know
    whether this is enough to make the test pass. We have the feeling that this is
    not enough based on our previous experience with `titleLabel`, but it''s better
    to confirm our feeling.'
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that the test is still failing. It still fails, but
    this time in the line of the assert function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make it pass, add the following line below the existing `addSubview` call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests again. Now, all the tests pass again.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `location` property of the to-do item is set, the cell should show
    the name of the `location` property. Add the following test to `ToDoItemCellTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to see this test failing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the property for the `location` label to `ToDoItemCell`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the tests to see the last test still failing, but now in the line with the
    assert function call.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the line that adds `locationLabel` as a subview to `contentView` of the
    cell:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run all the tests to make sure they all pass now.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to fill the labels in the data source of the table view. Open
    `ToDoItemsListViewControllerTests` and follow these steps to add this feature
    to our app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we now use `toDoItemStoreMock` to send a to-do item with a timestamp.
    In the `assert` function, we use a `dateFormatter` property that is not defined
    yet. Let's add this property to make the test compile.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemsListViewController` and add the following property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now the test compiles. Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, we need to set the date label in `tableView(_:cellForRowAt:)`.
    Add the following code right below `cell.textLabel.text = item.title`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We use the timestamp of the item to generate a date from it and ask the date
    formatter for a string representation of that date.
  prefs: []
  type: TYPE_NORMAL
- en: Run all the tests to confirm that all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to refactor the implementation. We could move the generation
    of the date string to the model object, but then the model object would need to
    know how the data is presented to the user. This is not a good idea. It would
    be better to move that code to a view model. That is a class connected to the
    view controller that converts the model data such that it can be presented in
    the user interface.
  prefs: []
  type: TYPE_NORMAL
- en: We will leave it as it is because for our small app, it's OK to have this code
    in the view controller.
  prefs: []
  type: TYPE_NORMAL
- en: You will implement the setting of the `location` label in the exercises later
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We have now implemented the presentation and the setup of the to-do item table
    view cells. With the tests in place, we can now look at the implementation and
    see whether we can improve it to better fit modern concepts in iOS development.
    The implementation we have built here is based on how table views have been implemented
    for many years. Over the last few years, better ways have emerged to set up a
    table view.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section, we will refactor our implementation to use a diffable
    data source.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring to a diffable data source
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In iOS 13, Apple introduced the `UITableViewDiffableDataSource` class. This
    class manages the update of a table view when the data changes and it can be used
    as the data source of any table view. It should be used, when possible, because
    implementing updates of a table view is a bit complicated and can lead to strange
    bugs and even crashes. In addition, the code needed to set up such a data source
    is often easier to read and reason about than the traditional implementation we
    used in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to transform our implementation to one that uses a diffable
    data source:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A diffable data source manages the data in the table view using a section and
    an item that both need to conform to the `Hashable` protocol. We already have
    an item we can use in the diffable data source, the `ToDoItem` structure. However,
    this structure does not yet conform to `Hashable`. To make it conform to that
    protocol, add the following code to `ToDoItem.swift` outside of the current `ToDoItem`
    implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, we tell the hasher provided by Swift to use the ID of the to-do
    item to generate the hash value. The ID of the to-do item is unique and therefore
    a good basis for a hash value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a section type that also conforms to `Hashable`. Add the following
    `enum` type to `ToDoItemsListViewController.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is enough for now. We only need one section at the moment because later
    we will add another section to distinguish between to-do and done items.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need a property for the data source. Add the following property to
    `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `viewDidLoad()` method, replace the `tableView.dataSource = self` code
    with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With this code, we initialize a diffable data source for the table view. The
    second parameter of this initializer is a `cell` provider. This piece of code
    gets called when the table view needs to show a `cell` provider for a given index
    path. As you can see, the code within this closure looks similar to the code we
    had in `tableView(_:cellForRowAt:)` previously.
  prefs: []
  type: TYPE_NORMAL
- en: Now delete the extension that implemented the conformance to `UITableViewDataSource`
    within `ToDoItemsListViewController.swift`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UITableViewDiffableDataSource` manages table view updates via `NSDiffableDataSourceSnapshot`.
    To update the table view with new data, we need to create a snapshot and set it
    up with the new data. Add the following method to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this method, we create a snapshot and add one section and the items passed
    into that method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The view controller receives updates from the publisher of `toDoItemStore`.
    Change the subscription code in `viewDidLoad` such that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In addition to assigning the received items to the `items` property of the view
    controller, we call here the new update method that applies a new snapshot to
    the data source.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests. All the tests pass. We have now successfully refactored our table
    view code to use a diffable data source.
  prefs: []
  type: TYPE_NORMAL
- en: Our list of to-do items should show two sections, one for the to-do items and
    one for the already done items. In the next section, we will change the snapshot
    creation to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting two sections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we have already refactored to a diffable data source, supporting two sections
    in the table view is quite easy. Follow these steps to implement two sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we need to start with a failing test. Add the following test to
    `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this test, we set a to-do item and a done item to the table view using `toDoItemStoreMock`.
    The name of the test method should also include what the preconditions of the
    tests are. We use a shorter name in the book because otherwise, the code is harder
    to read. You should try to use a better name.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To support two sections, `enum Section` needs two cases. Change the code of
    `enum Section` such that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to change the `update` method such that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we add the two sections to the snapshot and use the `done` property
    of the to-do item to fill the two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this code makes the new test pass.
  prefs: []
  type: TYPE_NORMAL
- en: The data source of the table view is now finished. The next step in implementing
    the list view of the to-do items is to add code that reacts to the user selecting
    the to-do item in the list.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the delegate of a table view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When the user selects a to-do item in the list of items, the details of the
    to-do item should be shown in a dedicated view. We will implement the actual navigation
    between the different views of the app in [*Chapter 11*](B18127_11_ePub.xhtml#_idTextAnchor526),
    *Easy Navigation with Coordinators*. In this section, we will implement the required
    code in `ToDoItemsListViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to prepare `ToDoItemsListViewController` for navigation
    to the detail view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s assume we already have a delegate that will provide a method the view
    controller can call. Add the following test method to `ToDoItemsListViewControllerTests`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Xcode tells us that it cannot find the `ToDoItemsListViewControllerProtocolMock`
    type. This type is meant to be a mock object for the real delegate we will add
    in [*Chapter 11*](B18127_11_ePub.xhtml#_idTextAnchor526), *Easy Navigation with
    Coordinators*. The view controller should tell the delegate that a to-do item
    was selected by the user. Let's add a mock object with a method for that task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the `ToDoItemsListViewControllerProtocolMock` in the **Save As** field
    and then click **Create**. Replace the contents of the created file with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Again, Xcode tells us that a type is missing. This time, Xcode doesn't know
    anything about `ToDoItemsListViewControllerProtocol`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go to `ToDoItemsListViewController.swift` and add the following protocol below
    the import statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can finish the implementation of the protocol mock:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This protocol mock stores the received argument to the call of the delegate
    method, `selectToDoItem(_:item:)`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this protocol mock, we can use it in our test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to stop here because `sut` doesn't yet have a `delegate` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add that property to `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can finish the test method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we have set the delegate of the system under test, we send one to-do item
    using `itemPublisher` of `toDoItemStoreMock`. Next, we call `tableView(_:didSelectRowAt:)`
    of the `tableViews` delegate. Finally, we assert that the protocol method, `selectToDoItem(_:item:)`,
    got called with the selected to-do item.
  prefs: []
  type: TYPE_NORMAL
- en: Run the tests to confirm that this new test fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the test pass, add the follow extension to `ToDoItemsListViewController.swift`
    outside of the class definition of `ToDoItemsListViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this implementation, we get the to-do item of the selected cell and call
    the delegate method with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make `ToDoItemsListViewController` the delegate of the table view, add the
    following line to the end of `viewDidLoad()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the tests to confirm that all the tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: For now, we are finished with implementing the list view of the to-do items.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to test table views and table view cells.
    We experienced the value of useful unit tests when refactoring a large part of
    the code. By switching from the traditional table view data source to the diffable
    data source, we improved the code and the behavior of the app while still keeping
    the existing tested functionality.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will use the knowledge we gained to create a detailed
    view and its view controller.
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implement the setting of the location label using test-driven development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try to figure out in the documentation of Xcode how to add section headers when
    using a diffable data source. We will implement the section headers in [*Chapter
    11*](B18127_11_ePub.xhtml#_idTextAnchor526), *Easy Navigation with Coordinators*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
