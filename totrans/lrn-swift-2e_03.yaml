- en: Chapter 3. One Piece at a Time – Types, Scopes, and Projects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 一点一滴 – 类型、范围和项目
- en: 'In [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables, Collections,
    and Flow Control"), *Building Blocks – Variables, Collections, and Flow Control*,
    we developed a very simple program that helped organize a party. Even though we
    separated parts of the code in a logical way, everything was written in a single
    file and our functions were all lumped together. As projects grow in complexity,
    this way of organizing code is not sustainable. In the same way we use functions
    to separate out logical components in our code at scale, we also need to be able
    to separate out the logical components of our functions and data. To do this,
    we can define code in different files and we can also create our own types that
    contain custom data and functionality. These types are commonly referred to as
    **objects**, as a part of the programming technique called **object-oriented programming**.
    In this chapter we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. 基础知识 – 变量、集合和流程控制")中，我们开发了一个非常简单的程序，帮助组织派对。尽管我们以逻辑方式分离了代码的部分，但所有内容都写在单个文件中，我们的函数都聚集在一起。随着项目的复杂性增加，这种组织代码的方式是不可持续的。同样，我们使用函数在代码中分离逻辑组件，我们也需要能够分离函数和数据逻辑组件。为此，我们可以在不同的文件中定义代码，我们还可以创建包含自定义数据和功能的自己的类型。这些类型通常被称为**对象**，作为编程技术**面向对象编程**的一部分。在本章中，我们将涵盖以下内容：
- en: Structs
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结构体
- en: Classes and inheritance
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类和继承
- en: Enumerations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 枚举
- en: Projects
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目
- en: Extensions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展
- en: Scope
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Access control
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问控制
- en: Structs
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: The most basic way that we can group together data and functionality into a
    logical unit or object is to define something called a **structure**. Essentially,
    a structure is a named collection of data and functions. Actually, we have already
    seen several different structures because all of the types such as string, array,
    and dictionary that we have seen so far are structures. Now we will learn how
    to create our own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将数据和功能组合成一个逻辑单元或对象的最基本方法就是定义一个名为**结构**的东西。本质上，结构是一组命名的数据和函数。实际上，我们已经看到了几个不同的结构，因为我们之前看到的字符串、数组和字典等所有类型都是结构。现在我们将学习如何创建自己的结构。
- en: Types versus instances
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型与实例
- en: 'Let''s jump straight into defining our first structure to represent a contact:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们直接定义第一个结构来表示联系人：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Here we have created a structure by using the `struct` keyword followed by a
    name and curly brackets (`{}`) with code inside them. Just like with a function,
    everything about a structure is defined inside its curly brackets. However, code
    in a structure is not run directly, it is all part of defining what the structure
    is. Think of a structure as a specification for future behavior instead of code
    to be run, in the same way that blueprints are the specification for building
    a house.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们通过使用`struct`关键字、一个名称以及包含其中的代码的大括号（`{}`）创建了一个结构。就像函数一样，结构中的所有内容都是在它的大括号内定义的。然而，结构中的代码并不是直接运行的，它全部是定义结构本身的一部分。将结构视为未来行为的规范，而不是要运行的代码，就像蓝图是建造房子的规范一样。
- en: Here, we have defined two variables for the first and last name. This code does
    not create any actual variables nor does it remember any data. As with a function,
    this code is not truly used until another piece of code uses it. Just like with
    a string, we have to define a new variable or constant of this type. However,
    in the past we have always used literals like `Sarah` or `10`. With our own structures,
    we will have to *initialize* our own *instances*, which is just like building
    a house based on the specifications.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们为第一个和最后一个名字定义了两个变量。这段代码并没有创建任何实际的变量，也没有记住任何数据。就像函数一样，这段代码只有在其他代码使用它时才会真正被使用。就像字符串一样，我们必须定义这个类型的新变量或常量。然而，在过去，我们总是使用像`Sarah`或`10`这样的字面量。有了我们自己的结构，我们将不得不*初始化*自己的*实例*，这就像根据规范建造房子一样。
- en: An instance is a specific incarnation of a type. This could be when we create
    a `String` variable and assign it the value `Sarah`. We have created an instance
    of a `String` variable that has the value `Sarah`. The string itself is not a
    piece of data; it simply defines the nature of instances of String that actually
    contain data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 实例是类型的特定实现。这可能是在我们创建一个`String`变量并将其赋值为`Sarah`时。我们已经创建了一个具有值`Sarah`的`String`变量的实例。字符串本身不是数据的一部分；它仅仅定义了包含数据的String实例的性质。
- en: 'Initializing is the formal name for creating a new instance. We initialize
    a new `Contact` like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化是创建新实例的正式名称。我们这样初始化一个新的`Contact`：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You may have noticed that this looks a lot like calling a function and that
    is because it is very similar. Every type must have at least one special function
    called an **initializer**. As the name implies, this is a function that initializes
    a new instance of the type. All initializers are named after their type and they
    may or may not have parameters, just like a function. In our case, we have not
    provided any parameters so the first and last names will be left with the default
    values that we provided in our specification: `First` and `Last`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到这看起来很像调用一个函数，这是因为它确实非常相似。每个类型都必须至少有一个特殊函数，称为**初始化器**。正如其名所示，这是一个初始化类型新实例的函数。所有初始化器都是以它们的类型命名的，它们可以有也可以没有参数，就像函数一样。在我们的例子中，我们没有提供任何参数，所以第一个和最后一个名字将保留我们在规范中提供的默认值：`First`和`Last`。
- en: You can see this in a playground by clicking on the plus sign next to **Contact**
    to the right of that line. This inserts a result pane after the line where it
    displays the value of `firstName` and `lastName`. We have just initialized our
    first custom type!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在游乐场中通过点击该行右侧的**Contact**旁边的加号来看到这一点。这将在该行之后插入一个结果面板，显示`firstName`和`lastName`的值。我们刚刚初始化了我们的第一个自定义类型！
- en: 'If we define a second contact structure that does not provide default values,
    it changes how we call the initializer. Since there are no default values, we
    must provide the values when initializing it:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们定义一个不提供默认值的第二个接触结构，它会改变我们调用初始化器的方式。因为没有默认值，所以在初始化它时必须提供值：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Again, this looks just like calling a function that happens to be named after
    the type that we defined. Now, `someone2` is an instance of `Contact2` with `firstName`
    equal to `Sarah` and `lastName` equal to `Smith`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这看起来就像调用一个函数，而这个函数恰好是以我们定义的类型命名的。现在，`someone2`是`Contact2`的一个实例，`firstName`等于`Sarah`，`lastName`等于`Smith`。
- en: Properties
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: 'The two variables, `firstName` and `lastName`, are called **member variables**
    and, if we change them to be constants, they are then called **member constants**.
    This is because they are pieces of information associated with a specific instance
    of the type. You can access member constants and variables on any instance of
    a structure:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个变量，`firstName`和`lastName`，被称为**成员变量**，如果我们将它们改为常量，那么它们就被称为**成员常量**。这是因为它们是与类型的特定实例相关联的信息片段。你可以在任何结构实例上访问成员常量和变量：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is in contrast to a **static constant**. We could add a static constant
    to our type by adding the following line to its definition:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这与**静态常量**形成对比。我们可以在类型的定义中添加以下行来向我们的类型添加一个静态常量：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Note the `static` keyword before the constant declaration. A static constant
    is accessed directly from the type and is independent of any instance:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在常量声明之前的`static`关键字。静态常量可以直接从类型中访问，并且与任何实例无关：
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that we will be adding code to existing code every so often like this.
    If you are following along in a playground, you should have added the `static
    let` line to the existing `Contact` structure.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有时会像这样向现有代码中添加代码。如果你在游乐场中跟随，你应该已经向现有的`Contact`结构添加了`static let`行。
- en: 'Member and static constants and variables all fall under the category of **properties**.
    A property is simply a piece of information associated with an instance or a type.
    This helps reinforce the idea that every type is an object. A ball, for example,
    is an object that has many properties including its radius, color, and elasticity.
    We can represent a ball in code in an object-oriented way by creating a ball structure
    that has each of those properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 成员和静态常量和变量都属于**属性**这一类别。属性只是与实例或类型相关联的信息片段。这有助于加强每个类型都是对象的观念。例如，一个球是一个具有许多属性的对象，包括其半径、颜色和弹性。我们可以通过创建一个具有所有这些属性的球结构，以面向对象的方式在代码中表示一个球：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that this `Ball` type does not define default values for its properties.
    If default values are not provided in the declaration, they are required when
    initializing an instance of the type. This means that an empty initializer is
    not available for that type. If you try to use one, you will get an error:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个`Ball`类型没有为其属性定义默认值。如果在声明中没有提供默认值，则在初始化该类型的实例时需要提供。这意味着该类型没有空初始化器可用。如果你尝试使用它，你会得到一个错误：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just like with normal variables and constants, all properties must have a value
    once initialized.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 就像普通变量和常量一样，所有属性一旦初始化就必须有一个值。
- en: Member and static methods
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 成员和静态方法
- en: 'Just as you can define constants and variables within a structure, you can
    also define **member** and static functions. These functions are referred to as
    **methods** to distinguish them from global functions that are not associated
    with any type. You declare member methods in a similar way to functions but you
    do so inside the type declaration, as shown:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 就像你可以在结构体内部定义常量和变量一样，你也可以定义 **成员** 和静态函数。这些函数被称为 **方法**，以区分它们与任何类型都不相关的全局函数。你以与函数类似的方式声明成员方法，但你在类型声明内部这样做，如下所示：
- en: '[PRE8]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Member methods always act on a specific instance of the type they are defined
    in. To access that instance within the method, you use the `self` keyword. `Self`
    acts in a similar way to any other variable in that you can access properties
    and methods on it. The preceding code prints out the `firstName` and `lastName`
    properties. You call this method in the same way we called methods on any other
    type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 成员方法始终作用于它们定义的类型的具体实例。要在方法内部访问该实例，你使用 `self` 关键字。`Self` 在行为上与任何其他变量类似，你可以访问其上的属性和方法。前面的代码打印了
    `firstName` 和 `lastName` 属性。你以与调用任何其他类型上的方法相同的方式调用此方法：
- en: '[PRE9]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Within a normal structure method, `self` is constant, which means you can''t
    modify any of its properties. If you tried, you would get an error like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个普通的结构体方法中，`self` 是常量，这意味着你不能修改其任何属性。如果你尝试这样做，你会得到一个像这样的错误：
- en: '[PRE10]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In order for a method to modify `self`, it must be declared as a **mutating
    method** using the `mutating` keyword:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让一个方法能够修改 `self`，它必须被声明为 **可变方法**，使用 `mutating` 关键字：
- en: '[PRE11]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We can define static properties that apply to the type itself but we can also
    define **static methods** that operate on the type by using the `static` keyword.
    We can add a static method to our `Contact` structure that prints the available
    phone prefixes, as shown here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以定义适用于类型的静态属性，但我们也可以使用 `static` 关键字定义在类型上操作 **静态方法**。我们可以在我们的 `Contact` 结构体中添加一个打印可用电话前缀的静态方法，如下所示：
- en: '[PRE12]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In a static method, `self` refers to the type instead of an instance of the
    type. In the preceding code, we have used the `UnitedStatesPhonePrefix` static
    property through `self` instead of writing out the type name.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态方法中，`self` 指的是类型而不是类型的实例。在前面的代码中，我们通过 `self` 使用了 `UnitedStatesPhonePrefix`
    静态属性，而不是写出类型名称。
- en: 'In both static and instance methods, Swift allows you to access properties
    without using `self,` for brevity. `self` is simply implied:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在静态和实例方法中，Swift 允许你为了简洁而无需使用 `self` 就可以访问属性。`self` 简单地隐含：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'However, if you create a variable in the method with the same name, you will
    have to use `self` to distinguish which one you want:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你在方法中创建了一个同名变量，你必须使用 `self` 来区分你想要的是哪一个：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: I recommend avoiding this feature of Swift. I want to make you aware of it so
    you are not confused when looking at other people's code but I feel that always
    using `self` greatly increases the readability of your code. `self` makes it instantly
    clear that the variable is attached to the instance instead of only defined in
    the function. You could also create bugs if you add code that creates a variable
    that hides a member variable. For example, you would create a bug if you introduced
    the `firstName` variable to the `printFullName` method in the preceding code without
    realizing you were using `firstName` to access the member variable later in the
    code. Instead of accessing the member variable, the later code would start to
    only access the local variable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议避免 Swift 的这个特性。我想让你知道这一点，这样你在查看别人的代码时不会感到困惑，但我感觉总是使用 `self` 可以大大提高你代码的可读性。`self`
    使得变量与实例相关联而不是仅在函数中定义变得一目了然。如果你添加了创建变量来隐藏成员变量的代码，你也可能会创建错误。例如，如果你在前面代码中的 `printFullName`
    方法中引入了 `firstName` 变量，而没有意识到你后来在代码中使用 `firstName` 来访问成员变量，那么你将创建一个错误。而不是访问成员变量，后面的代码将开始只访问局部变量。
- en: Computed properties
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'So far, it seems that properties are used to store information and methods
    are used to perform calculations. While this is generally true, Swift has a feature
    called **computed properties**. These are properties that are calculated every
    time they are accessed. To do this, you define a property and then provide a method
    called a **getter** that returns the calculated value, as shown:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，似乎属性被用来存储信息，而方法被用来执行计算。虽然这通常是正确的，但Swift有一个名为**计算属性**的功能。这些属性在每次访问时都会被计算。为此，你定义一个属性，然后提供一个名为**getter**的方法，该方法返回计算值，如下所示：
- en: '[PRE15]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a great way to avoid storing data that could potentially conflict with
    other data. If, instead, `diameter` were just another property, it would be possible
    for it to be different to the `radius`. Every time you changed the radius you
    would have to remember to change the diameter. Using a computed property eliminates
    this concern.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种避免存储可能与其他数据冲突的数据的绝佳方法。如果 `diameter` 只是另一个属性，那么它可能与 `radius` 不同。每次你更改半径时，你都必须记得更改直径。使用计算属性消除了这种担忧。
- en: 'You can even provide a second function called a **setter** that allows you
    to assign a value to this property like normal properties:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你甚至可以提供一个名为**setter**的第二个函数，允许你像普通属性一样为这个属性赋值：
- en: '[PRE16]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'If you provide a setter then you must also explicitly provide a getter. If
    you don''t, Swift allows you to leave out the `get` syntax:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你提供了一个setter，那么你也必须显式地提供一个getter。如果不这样做，Swift 允许你省略 `get` 语法：
- en: '[PRE17]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This provides a nice concise way of defining read-only computed properties.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这提供了一种简洁定义只读计算属性的好方法。
- en: Reacting to property changes
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对属性更改做出反应
- en: 'It is pretty common to need to perform an action whenever a property is changed.
    One way to achieve this is to define a computed property with a setter that performs
    the necessary action. However, Swift provides a better way of doing this. You
    can define a `willSet` function or a `didSet` function on any stored property.
    `WillSet` is called just *before* the property is changed and it is provided with
    a variable `newValue`. `didSet` is called just *after* the property is changed
    and it is provided with a variable `oldValue`, as you can see here:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在属性更改时执行操作是很常见的。实现这一目标的一种方法是通过定义一个具有执行必要操作的setter的计算属性。然而，Swift 提供了一种更好的方法。你可以在任何存储属性上定义一个
    `willSet` 函数或 `didSet` 函数。`WillSet` 在属性更改之前被调用，并提供了变量 `newValue`。`didSet` 在属性更改之后被调用，并提供了变量
    `oldValue`，如下所示：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Be careful to avoid creating an infinite loop when using `didSet` and `willSet`
    with multiple properties. For example, if you tried to use this technique to keep
    `diameter` and `radius` synchronized instead of using a computed property, it
    would look like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `didSet` 和 `willSet` 与多个属性时，请注意避免创建无限循环。例如，如果你尝试使用这种技术来保持 `diameter` 和 `radius`
    的同步，而不是使用计算属性，它看起来会是这样：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this scenario, if you set the `radius`, it triggers a change on the `diameter`
    which triggers another change on the `radius` and that then continues on forever.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个场景中，如果你设置了 `radius`，它将触发 `diameter` 的更改，这又触发 `radius` 的另一个更改，然后无限循环继续下去。
- en: Subscripts
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 下标
- en: 'You may also have realized that there is another way that we have interacted
    with a structure in the past. We have used square brackets (`[]`) with both arrays
    and dictionaries to access elements. These are called **subscripts** and we can
    use them on our custom types as well. The syntax for them is similar to the computed
    properties that we saw before except that you define it more like a method with
    parameters and a return type, as you can see here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能也已经意识到，我们过去与结构体交互的另一种方式。我们使用方括号 (`[]`) 既可以访问数组也可以访问字典中的元素。这些被称为**下标**，我们也可以在我们的自定义类型上使用它们。它们的语法与我们之前看到的计算属性类似，只是你定义它更像是带有参数和返回类型的方法，如下所示：
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You declare the arguments you want to use as the parameters to the subscript
    method in the square brackets. The return type for the subscript function is the
    type that will be returned when used to access a value. It is also the type for
    any value you assign to the subscript:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你在方括号中声明你想要用作下标方法参数的参数。下标函数的返回类型是当用于访问值时将返回的类型。它也是任何分配给下标的值的类型：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: You may have noticed a question mark (`?`) in the return type. This is called
    an **optional** and we will discuss this more in the next chapter. For now, you
    only need to know that this is the type that is returned when accessing a dictionary
    by key because a value does not exist for every possible key.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了返回类型中的问号（`?`）。这被称为**可选类型**，我们将在下一章中进一步讨论。现在，你只需要知道，这是在通过键访问字典时返回的类型，因为并非每个可能的键都有一个值。
- en: 'Just like with computed properties, you can define a subscript as read-only
    without using the `get` syntax:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 就像计算属性一样，你可以定义一个只读的下标，而不使用`get`语法：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`subscript` can have as many arguments as you want if you add additional parameters
    to the `subscript` declaration. You would then separate each parameter with a
    comma in the square brackets when using the subscript, as shown:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在`subscript`声明中添加了额外的参数，`subscript`可以接受任意数量的参数。使用下标时，你将使用逗号在方括号中分隔每个参数，如下所示：
- en: '[PRE23]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Subscripts are a good way to shorten your code but you should always be careful
    to avoid sacrificing clarity for brevity. Writing clear code is a balance between
    being too wordy and not wordy enough. If your code is too short, it will be hard
    to understand because meanings will become ambiguous. It is much better to have
    a method called `movieForInvitee:` rather than using a subscript. However, if
    all of your code is too long, there will be too much noise around and you will
    lose clarity in that way. Use subscripts sparingly and only when they would appear
    intuitive to another programmer based on the type of structure you are creating.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下标是一个缩短代码的好方法，但你应该始终小心，避免为了简洁而牺牲清晰度。编写清晰的代码是在过于冗长和不够简洁之间取得平衡。如果你的代码太短，将很难理解，因为含义会变得模糊。有一个名为`movieForInvitee:`的方法比使用下标要好得多。然而，如果你的所有代码都太长，周围会有太多的噪音，这样你会在某种程度上失去清晰度。谨慎使用下标，并且只有在它们基于你创建的结构类型对其他程序员来说直观时才使用。
- en: Custom initialization
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义初始化
- en: 'If you are not satisfied with the default initializers provided to you, you
    can define your own. This is done using the `init` keyword, as shown:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对你提供的默认初始化器不满意，你可以定义自己的。这是通过使用`init`关键字来完成的，如下所示：
- en: '[PRE24]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Just like with a method, an initializer can take any number of parameters including
    none at all. However, initializers have other restrictions. One rule is that every
    member variable and constant must have a value by the end of the initializer.
    If we were to omit a value for `lastName` in our initializer, we would get an
    error like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 就像方法一样，初始化器可以接受任意数量的参数，包括没有任何参数。然而，初始化器还有一些其他限制。一条规则是，每个成员变量和常量都必须在初始化器的末尾有一个值。如果我们从初始化器中省略了`lastName`的值，我们会得到如下错误：
- en: '[PRE25]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Note that this code did not provide default values for `firstName` and `lastName`.
    If we add that back, we no longer get an error because a value is then provided:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这段代码没有为`firstName`和`lastName`提供默认值。如果我们将其添加回来，我们就不再得到错误，因为此时提供了一个值：
- en: '[PRE26]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Once you provide your own initializer, Swift no longer provides any default
    initializers. In the preceding example, `Contact` can no longer be initialized
    with the `firstName` and `lastName` parameters. If we want both, we have to add
    our own version of that initializer, as shown:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你提供了自己的初始化器，Swift就不再提供任何默认的初始化器。在先前的例子中，`Contact`就不能再通过`firstName`和`lastName`参数进行初始化了。如果我们想要两者都有，我们必须添加自己的初始化器版本，如下所示：
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another option for setting up the initial values in an initializer is to call
    a different initializer:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化器中设置初始值的另一个选项是调用不同的初始化器：
- en: '[PRE28]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This is a great tool for reducing duplicate code in multiple initializers.
    However, when using this, there is an extra rule that you must follow. You cannot
    access `self` before calling the other initializer:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种在多个初始化器中减少重复代码的绝佳工具。然而，在使用这个工具时，你必须遵循一个额外的规则。你不能在调用其他初始化器之前访问`self`：
- en: '[PRE29]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This is a great example of why the requirement exists. If we were to call `print`
    before calling the other initializer, `firstName` and `lastName` would not have
    a value. What would be printed in that case? Instead, you can only access `self`
    after calling the other initializer, like this:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的例子，说明了为什么存在这样的要求。如果我们调用`print`在调用其他初始化器之前，`firstName`和`lastName`将没有值。在这种情况下会打印什么？相反，你只能在调用其他初始化器之后访问`self`，如下所示：
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This guarantees that all the properties have a valid value before any method
    is called.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这保证了在调用任何方法之前，所有属性都有一个有效的值。
- en: You may have noticed that initializers follow a different pattern for parameter
    naming. By default, initializers require a label for all parameters. However,
    remember that this is only the default behavior. You can change the behavior by
    either providing an internal and external name or by using an underscore (`_`)
    as the external name.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到初始化器在参数命名上遵循不同的模式。默认情况下，初始化器要求所有参数都有一个标签。然而，请记住，这只是一个默认行为。你可以通过提供内部和外部名称或使用下划线(`_`)作为外部名称来更改行为。
- en: Structures are an incredibly powerful tool in programming. They are an important
    way that we, as programmers, can abstract away more complicated concepts. As we
    discussed in [Chapter 2](ch02.html "Chapter 2. Building Blocks – Variables, Collections,
    and Flow Control"), *Building Blocks – Variables, Collections, and Flow Control*,
    this is the way we get better at using computers. Other people can provide these
    abstractions to us for concepts that we don't understand yet or in circumstances
    where it isn't worth our time to start from scratch. We can also use these abstractions
    for ourselves so that we can better understand the high-level logic going on in
    our app. This will greatly increase the reliability of our code. Structures make
    our code more understandable both for other people and for ourselves in the future.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是编程中一种非常强大的工具。它是我们作为程序员可以用来抽象更复杂概念的重要方式。正如我们在[第2章](ch02.html "第2章. 构成要素 –
    变量、集合和流程控制")中讨论的，*构成要素 – 变量、集合和流程控制*，这是我们提高使用计算机能力的方式。其他人可以为我们提供这些抽象，以理解我们尚未理解的概念，或者在不需要从头开始的情况下节省我们的时间。我们也可以为自己使用这些抽象，以便更好地理解应用中正在进行的整体逻辑。这将大大提高我们代码的可靠性。结构体使我们的代码对他人和我们自己来说都更容易理解。
- en: However, structures are limited in one important way, they don't provide a good
    way to express parent-child relationships between types. For example, a dog and
    a cat are both animals and share a lot of properties and actions. It would be
    great if we only had to implement the common attributes once. We could then split
    those types into different species. For this, Swift has a different system of
    types called **classes**.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，结构体在一点上受到限制，它们不提供一种很好的方式来表达类型之间的父子关系。例如，狗和猫都是动物，并且有很多共同的属性和行为。如果我们只需要实现一次这些共同属性将会很棒。然后我们可以将这些类型分成不同的物种。为此，Swift有一个不同的类型系统，称为**类**。
- en: Classes
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: A class can do everything that a structure can do except that a class can use
    something called **inheritance**. A class can inherit the functionality from another
    class and then extend or customize its behavior. Let's jump right into some code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以做到结构体所能做到的一切，除了类可以使用一种称为**继承**的东西。类可以从另一个类继承功能，然后扩展或定制其行为。让我们直接进入一些代码。
- en: Inheriting from another class
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从另一个类继承
- en: 'Firstly, let''s define a class called `Building` that we can inherit from later:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们定义一个可以稍后继承的名为`Building`的类：
- en: '[PRE31]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Predictably, a class is defined using the `class` keyword instead of `struct`.
    Otherwise, a class looks extremely similar to a structure. However, we can also
    see one difference. With a structure, the initializer we created before would
    not be necessary because it would have been created for us. With classes, initializers
    are not automatically created unless all of the properties have default values.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 预计之下，类是通过使用`class`关键字而不是`struct`来定义的。否则，类看起来与结构体极为相似。然而，我们也可以看到一点不同。在使用结构体时，我们之前创建的初始化器就不再必要了，因为它已经被自动创建。而在类中，除非所有属性都有默认值，否则初始化器不会自动创建。
- en: 'Now let''s look at how to inherit from this building class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何从这个构建类中继承：
- en: '[PRE32]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we have created a new class called `House` that inherits from our `Building`
    class. This is denoted by the colon (`:`) followed by `Building` in the class
    declaration. Formally, we would say that `House` is a **subclass** of `Building`
    and `Building` is a **superclass** of `House`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的名为`House`的类，它继承自我们的`Building`类。这通过类声明中的冒号(`:`)后跟`Building`来表示。正式来说，我们会说`House`是`Building`的**子类**，而`Building`是`House`的**超类**。
- en: 'If we initialize a variable of the type `House`, we can then access both the
    properties of `House` and those of `Building`, as shown:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们初始化一个`House`类型的变量，我们就可以访问`House`和`Building`的属性，如下所示：
- en: '[PRE33]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This is the beginning of what makes classes powerful. If we need to define ten
    different types of buildings, we don't have to add a separate `squareFootage`
    property to each one. This is true for properties as well as methods.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是使类强大的起点之一。如果我们需要定义十种不同的建筑类型，我们不必为每一种都添加一个单独的`squareFootage`属性。这同样适用于属性和方法。
- en: 'Beyond a simple *superclass* and *subclass* relationship, we can define an
    entire hierarchy of classes with subclasses of subclasses of subclasses, and so
    on. It is often helpful to think of a class hierarchy as an upside down tree:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的**超类**和**子类**关系之外，我们还可以定义一个完整的类层次结构，包括子类的子类、子类的子类的子类，依此类推。通常，将类层次结构想象成一个倒置的树是有帮助的：
- en: '![Inheriting from another class](img/B05103_03_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![从另一个类继承](img/B05103_03_01.jpg)'
- en: The trunk of the tree is the topmost superclass and each subclass is a separate
    branch off of that. The topmost superclass is commonly referred to as the base
    class as it forms the foundation for all the other classes.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 树的主干是最顶层的超类，每个子类都是从这个主干上分离出来的一个分支。最顶层的超类通常被称为基类，因为它为所有其他类提供了基础。
- en: Initialization
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化
- en: 'Because of the hierarchical nature of classes, the rules for their initializers
    are more complex. The following additional rules are applied:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类的层次性，它们的初始化器规则更为复杂。以下是一些附加规则：
- en: All initializers in a subclass must call the initializer of its superclass
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类中的所有初始化器都必须调用其超类的初始化器
- en: All properties of a subclass must be initialized before calling the superclass
    initializer
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子类的所有属性必须在调用超类初始化器之前初始化
- en: The second rule enables us to use `self` before calling the initializer. However,
    you cannot use `self` for any reason other than to initialize its properties.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 第二条规则使我们能够在调用初始化器之前使用`self`。然而，你不能出于任何其他原因使用`self`，除了初始化其属性。
- en: You may have noticed the use of the keyword `super` in our `house` initializer.
    `super` is used to reference the current instance as if it were its superclass.
    This is how we call the superclass initializer. We will see more uses of `super`
    when we explore inheritance further later in the chapter.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了我们在`house`初始化器中使用了关键字`super`。`super`用于引用当前实例，就像它是其超类一样。这就是我们调用超类初始化器的方式。当我们进一步探索继承时，我们将看到`super`的更多用法。
- en: 'Inheritance also creates four types of initializers shown here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 继承也创建了以下四种类型的初始化器，如下所示：
- en: Overriding initializer
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖初始化器
- en: Required initializer
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必需初始化器
- en: Designated initializer
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定初始化器
- en: Convenience initializer
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 便利初始化器
- en: Overriding initializer
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 覆盖初始化器
- en: 'An **overriding initializer** is used to replace the initializer in a superclass:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**覆盖初始化器**用于替换超类中的初始化器：'
- en: '[PRE34]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: An initializer that takes only `squareFootage` as a parameter already exists
    in `Building`. This initializer replaces that initializer so if you try to initialize
    `House` using only `squareFootage`, this initializer will be called. It will then
    call the `Building` version of the initializer because we asked it to with the
    `super.init` call.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Building`中已经存在一个只接受`squareFootage`作为参数的初始化器。这个初始化器将替换那个初始化器，所以如果你尝试仅使用`squareFootage`来初始化`House`，这个初始化器将被调用。然后，它将调用`Building`版本的初始化器，因为我们通过`super.init`调用来请求它。
- en: This ability is especially important if you want to initialize subclasses using
    their superclass initializer. By default, if you don't specify a new initializer
    in a subclass, it inherits all of the initializers from its superclass. However,
    as soon as you declare an initializer in a subclass, it hides all of the superclass
    initializers. By using an overriding initializer, you can expose the superclass
    version of the initializer again.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用超类初始化器来初始化子类，这种能力尤为重要。默认情况下，如果你在子类中没有指定新的初始化器，它将继承其超类中的所有初始化器。然而，一旦你在子类中声明了一个初始化器，它就会隐藏所有超类的初始化器。通过使用覆盖初始化器，你可以再次暴露超类版本的初始化器。
- en: Required initializer
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 必需初始化器
- en: 'A **required initializer** is a type of initializer for superclasses. If you
    mark an initializer as required, it forces all of the subclasses to also define
    that initializer. For example, we could make the `Building` initializer required,
    as shown:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**必需初始化器**是超类的一种初始化器。如果你将一个初始化器标记为必需，它将强制所有子类也定义该初始化器。例如，我们可以使`Building`初始化器成为必需的，如下所示：'
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Then, if we implemented our own initializer in `House`, we would get an error
    like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们自己在`House`中实现了自己的初始化器，我们就会得到如下错误：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'This time, when declaring this initializer, we repeat the `required` keyword
    instead of using `override`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，在声明这个初始化器时，我们重复使用`required`关键字而不是使用`override`：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This is an important tool when your superclass has multiple initializers that
    do different things. For example, you could have one initializer that creates
    an instance of your class from a data file and another one that sets its properties
    from code. Essentially, you have two paths for initialization and you can use
    the required initializers to make sure that all subclasses take both paths into
    account. A subclass should still be able to be initialized from both a file and
    in code. Marking both of the superclass initializers as required makes sure that
    this is the case.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的超类有多个执行不同操作的初始化器时，这是一个重要的工具。例如，你可以有一个初始化器从数据文件创建你的类的实例，另一个初始化器从代码设置其属性。本质上，你有两条初始化路径，你可以使用必需的初始化器确保所有子类都考虑了这两条路径。子类仍然应该能够从文件和代码中初始化。将超类的两个初始化器都标记为必需确保了这一点。
- en: Designated and convenience initializers
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指定和便利初始化器
- en: To discuss **designated initializers,** we first have to talk about **convenience
    initializers**. The normal initializer that we started with is really called a
    designated initializer. This means that they are core ways to initialize the class.
    You can also create convenience initializers which, as the name suggests, are
    there for convenience and are not a core way to initialize the class.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论**指定初始化器**，我们首先必须谈谈**便利初始化器**。我们最初开始使用的正常初始化器实际上被称为指定初始化器。这意味着它们是初始化类的核心方式。你还可以创建便利初始化器，正如其名所示，它们是为了便利而存在的，并不是初始化类的核心方式。
- en: 'All convenience initializers must call a designated initializer and they do
    not have the ability to manually initialize properties like a designated initializer
    does. For example, we can define a convenience initializer on our `Building` class
    that takes another building and makes a copy:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有便利初始化器都必须调用一个指定初始化器，并且它们没有像指定初始化器那样手动初始化属性的能力。例如，我们可以在我们的`Building`类上定义一个便利初始化器，它接受另一个建筑并创建一个副本：
- en: '[PRE38]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, as a convenience, you can create a new building using the properties from
    an existing building. The other rule about convenience initializers is that they
    cannot be used by a subclass. If you try to do that, you will get an error like
    this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，作为一个便利，你可以使用现有建筑的属性创建一个新的建筑。关于便利初始化器的另一条规则是，它们不能被子类使用。如果你尝试这样做，你会得到一个像这样的错误：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This is one of the main reasons that convenience initializers exist. Ideally,
    every class should only have one designated initializer. The fewer designated
    initializers you have, the easier it is to maintain your class hierarchy. This
    is because you will often add additional properties and other things that need
    to be initialized. Every time you add something like that, you will have to make
    sure that every designated initializer sets things up properly and consistently.
    Using a convenience initializer instead of a designated initializer ensures that
    everything is consistent because it must call a designated initializer that, in
    turn, is required to set everything up properly. Basically, you want to funnel
    all of your initialization through as few designated initializers as possible.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是便利初始化器存在的主要原因之一。理想情况下，每个类应该只有一个指定初始化器。你拥有的指定初始化器越少，维护你的类层次结构就越容易。这是因为你经常会添加额外的属性和其他需要初始化的东西。每次你添加这样的东西时，你都必须确保每个指定初始化器都正确且一致地设置好。使用便利初始化器而不是指定初始化器可以确保一切的一致性，因为它们必须调用一个指定初始化器，而该初始化器反过来又必须正确设置一切。基本上，你希望尽可能通过最少的指定初始化器进行所有初始化。
- en: Generally, your designated initializer is the one with the most arguments, possibly
    with all of the possible arguments. In that way, you can call that from all of
    your other initializers and mark them as convenience initializers.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的指定初始化器是具有最多参数的，可能包含所有可能的参数。这样，你就可以从所有其他初始化器中调用它，并将它们标记为便利初始化器。
- en: Overriding methods and computed properties
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重写方法和计算属性
- en: Just as with initializers, subclasses can **override** methods and computed
    properties. However, you have to be more careful with these. The compiler has
    fewer protections.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 就像初始化器一样，子类可以**重写**方法和计算属性。然而，对这些操作需要更加小心。编译器提供的保护较少。
- en: Methods
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法
- en: 'Even though it is possible, there is no requirement that an **overriding method**
    calls its superclass implementation. For example, let''s add clean methods to
    our `Building` and `House` classes:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然可能，但覆盖方法调用其超类实现并不是强制性的。例如，让我们给我们的`Building`和`House`类添加清理方法：
- en: '[PRE40]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In our `Building` superclass, the only thing that we have to clean is the floors.
    However, in our `House` subclass, we also have to make the beds and clean the
    bathrooms. As it has been implemented above, when we call `clean` on `House`,
    it will not clean the floors because we overrode that behavior with the `clean`
    method on `House`. In this case, we also need to have our `Building` superclass
    do any necessary cleaning, so we must call the superclass version, as shown:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Building`超类中，我们唯一需要清理的是地板。然而，在我们的`House`子类中，我们还需要整理床铺和清洁浴室。如上所示实现，当我们调用`House`上的`clean`时，它不会清理地板，因为我们已经在`House`的`clean`方法中覆盖了这种行为。在这种情况下，我们还需要让`Building`超类执行任何必要的清理，因此我们必须调用超类版本，如下所示：
- en: '[PRE41]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Now, before doing any cleaning based on the house definition, it will first
    clean based on the building definition. You can control the order in which things
    happen by changing the place in which you call the super version.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在基于房屋定义进行任何清理之前，它将首先基于建筑定义进行清理。你可以通过改变调用超类版本的位置来控制事情发生的顺序。
- en: This is a great example of the need to override methods. We can provide common
    functionality in a superclass that can be extended in each of its subclasses instead
    of rewriting the same functionality in multiple classes.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个需要覆盖方法的绝佳例子。我们可以在超类中提供通用功能，这些功能可以在每个子类中扩展，而不是在多个类中重写相同的功能。
- en: Computed properties
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 计算属性
- en: 'It is also useful to override computed properties using the `override` keyword
    again:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 再次使用`override`关键字覆盖计算属性也是有用的：
- en: '[PRE42]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In our `Building` superclass, we have provided an estimate for energy costs
    based on $100 per 1000 square feet. That estimate still applies to the house but
    there are additional costs related to someone else living in the building. We
    must therefore override the `estimatedEnergyCost` computed property to return
    the `Building` calculation plus $100.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`Building`超类中，我们已经提供了一个基于每1000平方英尺100美元的能源成本估算。这个估算仍然适用于房屋，但与有人住在建筑中相关的额外成本。因此，我们必须重写`estimatedEnergyCost`计算属性，以返回`Building`的计算结果加上100美元。
- en: Again, using the super version of an overriding computed property is not required.
    A subclass could have a completely different implementation disregarding what
    is implemented in its superclass, or it could make use of its superclass implementation.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，使用覆盖的计算属性的父类版本不是必需的。子类可以完全不同的实现，不考虑其超类中实现的内容，或者它可以利用其超类的实现。
- en: Casting
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型转换
- en: 'We have already talked about how classes are great for sharing functionality
    between a hierarchy of types. Another thing that makes classes powerful is that
    they allow code to interact with multiple types in a more general way. Any subclass
    can be used in code that treats it as if it were its superclass. For example,
    we might want to write a function that calculates the total square footage of
    an array of buildings. For this function, we don''t care what specific type of
    building it is, we just need to have access to the `squareFootage` property that
    is defined in the superclass. We can define our function to take an array of buildings
    and the actual array can contain `House` instances:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了类如何在类型层次结构之间共享功能。使类强大的另一个原因是它们允许代码以更通用的方式与多个类型交互。任何子类都可以在将其视为其超类的代码中使用。例如，我们可能想编写一个函数来计算建筑数组总面积。对于这个函数，我们不在乎它是哪种具体的建筑类型，我们只需要访问在超类中定义的`squareFootage`属性。我们可以定义我们的函数接受一个建筑数组，而实际的数组可以包含`House`实例：
- en: '[PRE43]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Even though this function thinks we are dealing with classes of the type `Building`,
    the program will execute the `House` implementation of `squareFootage`. If we
    had also created an office subclass of `Building`, instances of that would also
    be included in the array as well with its own implementation.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个函数认为我们正在处理`Building`类型的类，但程序将执行`House`的`squareFootage`实现。如果我们还创建了一个`Building`的办公室子类，那么该子类的实例也将包含在数组中，并具有自己的实现。
- en: 'We can also assign an instance of a subclass to a variable that is defined
    to be one of its superclasses:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将子类的实例分配给定义为其超类之一的变量：
- en: '[PRE44]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: This provides us with an even more powerful abstraction tool than the one we
    had when using structures. For example, let's consider a hypothetical class hierarchy
    of images. We might have a base class called `Image` with subclasses for the different
    types of encodings like `JPGImage` and `PNGImage`. It is great to have the subclasses
    so that we can cleanly support multiple types of images but, once the image is
    loaded, we no longer need to be concerned with the type of encoding the image
    is saved in. Every other class that wants to manipulate or display the image can
    do so with a well-defined image superclass; the encoding of the image has been
    abstracted away from the rest of the code. Not only does this create easier to
    understand code but it also makes maintenance much easier. If we need to add another
    image encoding like **GIF**, we can create another subclass and all the existing
    manipulation and display code can get GIF support with no changes to that code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了一种比使用结构时更强大的抽象工具。例如，让我们考虑一个假设的图像类层次结构。我们可能有一个名为`Image`的基类，以及用于不同编码类型的子类，如`JPGImage`和`PNGImage`。有子类是很好的，因为我们能够干净地支持多种类型的图像，但一旦图像被加载，我们就不再需要关心图像保存的编码类型。任何其他想要操作或显示图像的类都可以使用一个定义良好的图像超类来这样做；图像的编码已被从其余代码中抽象出来。这不仅创造了更容易理解的代码，而且也使得维护变得更加容易。如果我们需要添加另一个图像编码，如**GIF**，我们可以创建另一个子类，所有现有的操作和显示代码都可以通过不修改该代码来获得GIF支持。
- en: There are actually two different types of casting. So far, we have only seen
    the type of casting called **upcasting**. Predictably, the other type of casting
    is called **downcasting**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上存在两种不同的转型类型。到目前为止，我们只看到了称为**向上转型**的转型类型。可以预见，另一种转型类型被称为**向下转型**。
- en: Upcasting
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向上转型
- en: 'What we have seen so far is called upcasting because we are going up the class
    tree that we visualized earlier by treating a subclass as its superclass. Previously,
    we upcasted by assigning a subclass instance to a variable that was defined as
    its superclass. We could do the same thing using the `as` operator instead, like
    this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所看到的方法被称为向上转型，因为我们通过将子类视为其超类来向上遍历我们之前可视化的类树。之前，我们通过将子类实例赋值给定义为其超类的变量来进行向上转型。我们也可以使用`as`运算符来做同样的事情，如下所示：
- en: '[PRE45]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: It is really personal preference as to which you should use.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 关于应该使用哪种方法，这实际上是一种个人偏好。
- en: Downcasting
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向下转型
- en: Downcasting means that we treat a superclass as one of its subclasses.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 向下转型意味着我们将超类视为其子类之一。
- en: While upcasting can be done implicitly by using it in a function declared to
    use its superclass or by assigning it to a variable with its superclass type,
    downcasting must be done explicitly. This is because upcasting cannot fail based
    on the nature of its inheritance, but downcasting can. You can always treat a
    subclass as its superclass but you cannot guarantee that a superclass is, in fact,
    one of its specific subclasses. You can only downcast an instance that is, in
    fact, an instance of that class or one of its subclasses.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用其超类声明的函数或将其赋值给具有其超类类型的变量时，向上转型可以隐式进行，但向下转型必须显式进行。这是因为向上转型不会因为其继承性质而失败，但向下转型可能会失败。你可以始终将子类视为其超类，但你不能保证超类实际上是其特定的子类之一。你只能向下转型那些实际上是该类或其子类实例的实例。
- en: 'We can force downcast by using the `as!` Operator, like this:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`as!`运算符来强制向下转型，如下所示：
- en: '[PRE46]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The `as!` operator has an exclamation point added to it because it is an operation
    that can fail. The exclamation point serves as a warning and ensures that you
    realize that it can fail. If the forced downcasting fails, for example, if `someBuilding`
    were not actually `House`, the program would crash as so:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '`as!`运算符中添加了感叹号，因为它是一种可能会失败的操作。感叹号充当警告，确保你意识到它可能会失败。例如，如果`someBuilding`实际上不是`House`，则强制向下转型失败时，程序会崩溃，如下所示：'
- en: '[PRE47]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'A safer way to perform downcasting is using the `as?` operator in a special
    `if` statement called an optional binding. We will discuss this in detail in the
    next chapter, which concerns optionals but, for now, you can just remember the
    syntax:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊`if`语句中的`as?`运算符进行向下转型是一种更安全的方法，这种`if`语句被称为可选绑定。我们将在下一章详细讨论这个问题，但到目前为止，你只需记住语法：
- en: '[PRE48]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This code prints out `numberOfBathrooms` in the building only if it is of the
    type `House`. The `House` constant is used as a temporary view of `someBuilding`
    with its type explicitly set to `House`. With this temporary view, you can access
    `someBuilding` as if it were `House` instead of just `Building`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仅在建筑物的类型为`House`时打印出`numberOfBathrooms`。`House`常量被用作`someBuilding`的临时视图，其类型明确设置为`House`。有了这个临时视图，你可以像访问`House`一样访问`someBuilding`，而不是仅仅访问`Building`。
- en: Enumerations
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'So far, we have covered two of the three types of classification in Swift:
    structure and class. The third classification is called **enumeration**. Enumerations
    are used to define a group of related values for an instance. For example, if
    we want values to represent one of the three primary colors, an enumeration is
    a great tool.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经涵盖了Swift中三种分类中的两种：结构和类。第三种分类被称为**枚举**。枚举用于为实例定义一组相关值。例如，如果我们想要值表示三种原色之一，枚举是一个很好的工具。
- en: Basic declaration
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本声明
- en: 'An enumeration is made up of **cases** much like a switch and uses the keyword
    `enum` instead of `struct` or `class`. An enumeration for primary colors should
    look like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举由**案例**组成，就像`switch`一样，它使用`enum`关键字而不是`struct`或`class`。一个用于原色的枚举应该看起来像这样：
- en: '[PRE49]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'You can then define a variable with this type and assign it one of the cases:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以定义一个具有这种类型的变量，并给它分配一个案例：
- en: '[PRE50]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Note that, to use one of the values, we must use the name of the type followed
    by a dot (`.`) and then the specific case. If the type of the variable can be
    inferred, you can even leave out the enumeration name and just start with a dot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，要使用其中一个值，我们必须使用类型的名称后跟一个点（`.`），然后是具体的案例。如果变量的类型可以被推断出来，甚至可以省略枚举名称，只需从点开始：
- en: '[PRE51]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: During the assignment to `.Red`, the compiler already knows that the `color`
    variable is of the type `PrimaryColor` so it doesn't need us to specify that again.
    This is a great way of making your code more concise but make sure you don't sacrifice
    legibility. If you leave out the type name, it should still be obvious from the
    context of the code.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在将`.Red`赋值的过程中，编译器已经知道`color`变量是`PrimaryColor`类型，因此不需要我们再次指定。这是一种使代码更简洁的好方法，但请确保你不会牺牲可读性。如果你省略了类型名称，代码的上下文应该仍然很明显。
- en: Testing enumeration values
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试枚举值
- en: 'Enumeration instances can be tested for a specific value as with any other
    type, using the equality operator (`==`):'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举实例可以像任何其他类型一样测试特定的值，使用相等运算符（`==`）：
- en: '[PRE52]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that, in the second `if` statement, where `color` is checked for if it
    is blue, the code takes advantage of type inference and doesn't bother specifying
    `PrimaryColor`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在第二个`if`语句中，当检查`color`是否为蓝色时，代码利用了类型推断，并没有麻烦地指定`PrimaryColor`。
- en: 'This method of comparison is familiar and useful for one or two possible values.
    However, there is a better way to test an enumeration for different values. Instead
    of using an `if` statement, you can use a switch. This is a logical solution considering
    that enumerations are made up of cases and switches test for cases:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这种比较方法对于一两个可能的值来说是熟悉且有用的。然而，对于不同值的枚举测试，有更好的方法。你不需要使用`if`语句，而是可以使用`switch`。考虑到枚举是由案例组成的，而`switch`测试的是案例，这是一个逻辑上的解决方案：
- en: '[PRE53]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This is great for all the same reasons that switches themselves are great. In
    fact, switches work even better with enumerations because the possible values
    for an enumeration are always finite, unlike other basic types. You may remember
    that switches require that you have a case for every possible value. This means
    that, if you don't have a test case for every case of the enumeration, the compiler
    will produce an error. This is usually great protection and that is why I recommend
    using switches rather than simple `if` statements in most circumstances. If you
    ever add additional cases to an enumeration, it is great to get an error everywhere
    in your code that doesn't consider that new case so that you make sure you address
    it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于所有与`switch`本身相同的原因都是很好的。事实上，`switch`与枚举配合得更好，因为枚举的可能值总是有限的，而其他基本类型则不是。你可能记得，`switch`要求你必须为每个可能的值有一个案例。这意味着，如果你没有为枚举的每个案例提供测试案例，编译器将产生错误。这通常是一种很好的保护措施，这就是为什么我建议在大多数情况下使用`switch`而不是简单的`if`语句。如果你在枚举中添加了额外的案例，那么在代码中任何没有考虑这个新案例的地方都会产生错误，这样你可以确保你已经处理了它。
- en: Raw values
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原始值
- en: 'Enumerations are great because they provide the ability to store information
    that is not based on the basic types provided by Swift such as strings, integers,
    and doubles. There are many abstract concepts like our color example, that are
    not at all related to a basic type. However, you often want each enumeration case
    to have a **raw value** that is another type. For example, if we wanted to represent
    all of the coins in United States currency along with their monetary value, we
    could make our enumeration have an integer raw value type, like this:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举类型非常出色，因为它们能够存储基于 Swift 基本类型（如字符串、整数和双精度浮点数）之外的信息。有许多像我们的颜色示例这样的抽象概念，它们与基本类型根本无关。然而，你通常希望每个枚举情况都有一个**原始值**，它属于另一种类型。例如，如果我们想表示美国货币中的所有硬币及其货币价值，我们可以使我们的枚举具有一个整型原始值类型，如下所示：
- en: '[PRE54]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The raw value type is specified in the same way that inheritance is specified
    with classes and then each case is individually assigned a specific value of that
    type.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值类型是以与类中指定继承相同的方式指定的，然后每个情况都单独分配了该类型的特定值。
- en: 'You can access the raw value of a case at any time by using the `rawValue`
    property:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过使用`rawValue`属性在任何时候访问情况的原始值：
- en: '[PRE55]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Keep in mind that an enumeration can only have raw value types that can be defined
    with literals like `10`, or `String`. You cannot define an enumeration with your
    own custom type as its raw value.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，枚举只能具有可以用文字如`10`或`String`定义的原始值类型。你不能定义一个具有自定义类型的枚举，该类型作为其原始值。
- en: Associated values
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关联值
- en: Raw values are great for when every case in your enumeration has the same type
    of value associated with it and its value never changes. However, there are also
    scenarios where each case has different values associated with it and those values
    are different for each instance of the enumeration. You may even want a case that
    has multiple values associated with it. To do this, we use a feature of enumerations
    called **associated values**.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 原始值非常适合当你枚举中的每个情况都与相同类型的值相关联，并且其值永远不会改变时。然而，也存在每种情况都有不同值与之相关联，并且这些值对于枚举的每个实例都不同的情况。你可能甚至想要一个具有多个相关值的案例。为此，我们使用枚举的一个功能，称为**关联值**。
- en: 'You can specify zero or several types to be associated separately with each
    case with associated values. Then, when creating an instance of the enumeration,
    you can give it any value you want, as shown:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以指定零个或多个类型，这些类型可以与每个情况单独关联关联值。然后，在创建枚举实例时，你可以给出任何你想要的值，如下所示：
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Here, we have defined an enumeration to store a height measurement using various
    measurement systems. There is a case for the imperial system that uses feet and
    inches and a case for the metric system that is in just meters. Both of these
    cases have labels for their associated values which are similar to a tuple. The
    last case is there to illustrate that you don't have to provide a label if you
    don't want to. It simply takes a string.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个枚举来存储使用各种测量系统的高度测量值。有一个英制系统的情况，它使用英尺和英寸，还有一个公制系统的情况，它只有米。这两个情况都有其关联值的标签，类似于元组。最后一个情况是为了说明，如果你不想提供标签，你不必提供。它只需一个字符串。
- en: 'Comparing and accessing values of enumerations with associated values is a
    little bit more complex than for regular enumerations. We can no longer use the
    equality operator (`==`). Instead, we must always use a case. Within a case, there
    are multiple ways that you can handle the associated values. The easiest thing
    to do is to access the specific associated value. To do that, you can assign it
    to a temporary variable:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 与具有关联值的枚举进行比较和访问值比常规枚举要复杂一些。我们不能再使用等号运算符（`==`）。相反，我们必须始终使用一个情况。在情况内部，有几种处理关联值的方法。最简单的方法是访问特定的关联值。为此，你可以将其分配给一个临时变量：
- en: '[PRE57]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: In the imperial case, the preceding code assigned `feet` to a temporary constant
    and `inches` to a temporary variable. The names match the labels used for the
    associated values but that is not necessary. The metric case shows that, if you
    want all of the temporary values to be constant, you can declare `let` before
    the enumeration case. No matter how many associated values there are, `let` only
    has to be written once instead of once for every value. The other case is the
    same as the metric case except that it creates a temporary variable instead of
    a constant.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在英制情况下，前面的代码将`feet`赋值给一个临时常量，将`inches`赋值给一个临时变量。这些名称与关联值使用的标签相匹配，但这不是必需的。公制情况表明，如果你想让所有临时值都是常量，你可以在枚举情况之前声明`let`。无论有多少关联值，`let`只需要写一次，而不是每个值都写一次。另一种情况与公制情况相同，只是它创建了一个临时变量而不是一个常量。
- en: 'If you wanted to create separate cases for conditions on the associated values,
    you could use the `where` syntax that we saw in the previous chapter:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要为关联值的条件创建单独的情况，你可以使用我们在上一章中看到的`where`语法：
- en: '[PRE58]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Note that we had to add a default case because our restrictions on the other
    cases were no longer exhaustive.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不得不添加一个默认情况，因为我们对其他情况的限制不再详尽无遗。
- en: 'Lastly, if you don''t actually care about the associated value, you can use
    an underscore (`_`) to ignore it, as shown:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果你实际上不关心关联值，你可以使用下划线（`_`）来忽略它，如下所示：
- en: '[PRE59]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This shows you that, with enumerations, switches have even more power than we
    saw previously.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明，与枚举一起，开关甚至比我们之前看到的更有力量。
- en: Now that you understand how to use associated values, you might have noticed
    that they can change the conceptual nature of enumerations. Without associated
    values, an enumeration represents a list of abstract and constant possible values.
    An enumeration with associated values is different because two instances with
    the same case are not necessarily equal; each case could have different associated
    values. This means that the conceptual nature of enumerations is really a list
    of ways to look at a certain type of information. This is not a concrete rule
    but it is common and it gives you a better idea of the different types of information
    that can best be represented by enumerations. It will also help you make your
    own enumerations more understandable. Each case could theoretically represent
    a completely unrelated concept from the rest of the cases using associated values
    but that should be a sign that an enumeration may not be the best tool for that
    particular job.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用关联值，你可能已经注意到它们可以改变枚举的概念性质。没有关联值时，枚举代表了一组抽象和恒定的可能值。具有关联值的枚举则不同，因为具有相同情况的两个实例不一定相等；每个情况可能有不同的关联值。这意味着枚举的概念性质实际上是一系列查看特定类型信息的方式。这不是一个具体的规则，但它很常见，并且能更好地帮助你理解枚举可以最好地表示的不同类型的信息。这也有助于使你自己的枚举更易于理解。每个情况理论上都可以通过关联值代表与其它情况完全无关的概念，但那应该是一个信号，表明枚举可能不是完成那个特定工作的最佳工具。
- en: Methods and properties
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 方法与属性
- en: 'Enumerations are actually very similar to structures. As with structures, enumerations
    can have methods and properties. To improve the `Height` enumeration, we could
    add methods to access the height in any measurement system we wanted. As an example,
    let''s implement a `meters` method, as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举实际上与结构非常相似。与结构一样，枚举可以有方法和属性。为了改进`Height`枚举，我们可以添加方法来访问我们想要的任何测量系统中的高度。作为一个例子，让我们实现一个`meters`方法，如下所示：
- en: '[PRE60]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In this method, we have switched on `self` which tells us which unit of measurement
    this instance was created with. If it is in meters we can just return that but,
    if it is in feet and inches, we must do the conversion. As an exercise, I recommend
    you try to implement a `feetAndInches` method that returns a tuple with the two
    values. The biggest challenge is in handling the mathematical operations using
    the correct types. You cannot perform operations with mismatching types mathematically.
    If you need to convert from one number type to another, you can do so by initializing
    a copy as shown in the code above: `Double(feet)`. Unlike the casting that we
    discussed earlier, this process simply creates a new copy of the `feet` variable
    that is now `Double` instead of `Int`. This is only possible because the `Double`
    type happens to define an initializer that takes `Int`. Most number types can
    be initialized with any of the other ones.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们开启了`self`，它告诉我们这个实例是用哪个单位创建的。如果它在米，我们就可以直接返回，但如果它在英尺和英寸，我们必须进行转换。作为一个练习，我建议你尝试实现一个`feetAndInches`方法，它返回一个包含两个值的元组。最大的挑战在于使用正确的类型处理数学运算。你不能用不匹配的类型进行数学运算。如果你需要将一个数字类型转换为另一个类型，你可以通过初始化一个副本来实现，就像上面的代码所示：`Double(feet)`。与之前讨论的类型转换不同，这个过程只是创建了一个新的`feet`变量副本，现在它是`Double`而不是`Int`。这之所以可能，是因为`Double`类型恰好定义了一个可以接受`Int`的初始化器。大多数数字类型都可以用其他任何类型进行初始化。
- en: You now have a great overview of all of the different ways in which we can organize
    Swift code in a single file to make the code more understandable and maintainable.
    It is now time to discuss how we can separate our code into multiple files to
    improve it even more.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你对我们可以如何在一个文件中组织Swift代码以使代码更易于理解和维护的所有不同方式有了很好的了解。现在是时候讨论我们如何将代码分离到多个文件中，以进一步提高代码质量。
- en: Projects
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目
- en: If we want to move away from developing with a single file, we need to move
    away from playgrounds and create our first project. In order to simplify the project,
    we are going to create a **command-line tool**. This is a program without a graphical
    interface. As an exercise, we will redevelop our example program from [Chapter
    2](ch02.html "Chapter 2. Building Blocks – Variables, Collections, and Flow Control"),
    *Building Blocks – Variables, Collections, and Flow Control* which managed invitees
    to a party. We will develop an app with a graphical interface in [Chapter 11](ch11.html
    "Chapter 11. A Whole New World – Developing an App"), *A Whole New World – Developing
    an App*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要摆脱使用单个文件进行开发，我们就需要远离游乐场，创建我们的第一个项目。为了简化项目，我们将创建一个**命令行工具**。这是一个没有图形界面的程序。作为一个练习，我们将重新开发来自[第2章](ch02.html
    "第2章. 基础知识 – 变量、集合和流程控制")，“基础知识 – 变量、集合和流程控制”，负责管理派对邀请人的示例程序。我们将在[第11章](ch11.html
    "第11章. 一个全新的世界 – 开发应用程序")，“一个全新的世界 – 开发应用程序”中开发一个具有图形界面的应用程序。
- en: Setting up a command-line Xcode project
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置命令行Xcode项目
- en: 'To create a new command-line tool project, open Xcode and from the menu bar
    on the top, select **File** | **New** | **Project…**. A window will appear allowing
    you to select a template for the project. You should choose **Command Line Tool**
    from the **OS X** | **Application** menu:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的命令行工具项目，打开Xcode，从顶部菜单栏中选择**文件** | **新建** | **项目…**。一个窗口将出现，允许你选择项目的模板。你应该从**OS
    X** | **应用程序**菜单中选择**命令行工具**：
- en: '![Setting up a command-line Xcode project](img/B05103_03_02.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![设置命令行Xcode项目](img/B05103_03_02.jpg)'
- en: From there, click **Next** and then give the project a name like `Learning Swift
    Command Line`. Any **Organization Name** and **Identifier** are fine. Finally,
    make sure that **Swift** is selected from the **Language** dropdown and click
    **Next** again. Now, save the project somewhere that you can find later and click
    **Create**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，点击**下一步**，然后给项目起一个像`Learning Swift Command Line`这样的名字。任何**组织名称**和**标识符**都可以。最后，确保从**语言**下拉菜单中选择**Swift**，然后再次点击**下一步**。现在，将项目保存在你可以找到的地方，然后点击**创建**。
- en: 'Xcode will then present you with the project development window. Select the
    `main.swift` file on the left and you should see the `Hello, World!` code that
    Xcode has generated for you:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode将然后向你展示项目开发窗口。在左侧选择`main.swift`文件，你应该能看到Xcode为你生成的`Hello, World!`代码：
- en: '![Setting up a command-line Xcode project](img/B05103_03_03.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_IMG
  zh: '![设置命令行Xcode项目](img/B05103_03_03.jpg)'
- en: This should feel pretty similar to a playground except that we can no longer
    see the output of the code on the right. In a regular project like this, the code
    is not run automatically for you. The code will still be analyzed for errors as
    you write it, but you must run it yourself whenever you want to test it. To run
    the code, you can click the run button on the toolbar, which looks like a play
    button.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该感觉和游乐场很相似，只是我们不能再看到右侧代码的输出。在一个像这样的常规项目中，代码不会自动为你运行。当你编写代码时，代码仍然会被分析错误，但每次你想测试它时，你必须自己运行它。要运行代码，你可以点击工具栏上的运行按钮，它看起来像一个播放按钮。
- en: The program will then build and run. Once it does, Xcode shows the console on
    the bottom where you will see the text `Hello, World!` which is the result of
    running this program. This is the same console as we saw in playgrounds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 程序将构建并运行。一旦运行，Xcode将在底部显示控制台，你将看到文本`Hello, World!`，这是运行此程序的结果。这与我们在游乐场中看到的是同一个控制台。
- en: Unlike a playground, we have the Project Navigator along the left. This is where
    we organize all of the source files that go into making the application work.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与游乐场不同，我们在左侧有项目导航器。这是我们组织所有用于使应用程序工作的源文件的地方。
- en: Creating and using an external file
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用外部文件
- en: 'Now that we have successfully created our command-line project, let''s create
    our first new file. It is common to create a separate file for each type that
    you create. Let''s start by creating a file for an `invitee` class. We want to
    add the file to the same file group as the `main.swift` file, so click on that
    group. You can then click on the plus sign (**+**) in the lower left of the window
    and select **New File**. From that window, select **OS X** | **Source** | **Swift
    File** and click **Next**:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了我们命令行项目，让我们创建我们的第一个新文件。为每个你创建的类型创建一个单独的文件是很常见的。让我们首先创建一个用于`invitee`类的文件。我们希望将文件添加到与`main.swift`文件相同的文件组中，所以点击那个组。然后，你可以点击窗口左下角的加号（**+**）并选择**New
    File**。从那个窗口，选择**OS X** | **Source** | **Swift File**并点击**Next**：
- en: '![Creating and using an external file](img/B05103_03_04.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![创建和使用外部文件](img/B05103_03_04.jpg)'
- en: 'The new file will be placed in whatever folder was selected before entering
    the dialog. You can always drag a file around to organize it however you want.
    A great place for this file is next to `main.swift`. Name your new file `Invitee.swift`
    and click **Create**. Let''s add a simple `Invitee` structure to this file. We
    want `Invitee` to have a name and to be able to ask them to the party with or
    without a show:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 新文件将被放置在进入对话框之前选择的任何文件夹中。你可以随时拖动文件以按你想要的方式组织它。这个文件的好位置是`main.swift`旁边。将你的新文件命名为`Invitee.swift`并点击**Create**。让我们向这个文件添加一个简单的`Invitee`结构。我们希望`Invitee`有一个名字，并且能够邀请他们参加聚会，无论是否有表演：
- en: '[PRE61]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This is a very simple type and does not require inheritance, so there is no
    reason to use a class. Note that inheritance is not the only reason to use a class,
    as we will see in later chapters but, for now, a structure will work great for
    us. This code provides simple, well-named methods to print out the two types of
    invites.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常简单的类型，不需要继承，所以没有理由使用类。请注意，继承并不是使用类的唯一原因，正如我们将在后面的章节中看到的那样，但就目前而言，结构对我们来说将工作得很好。此代码提供了简单、命名良好的方法来打印出两种邀请类型。
- en: 'We are already making use of a structure that we have not created yet called
    `ShowGenre`. We would expect it to have a `name` and `example` property. Let''s
    implement that structure now. Create another file called `ShowGenre.swift` and
    add the following code to it:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用了我们尚未创建的结构，称为`ShowGenre`。我们预计它将有一个`name`和`example`属性。现在让我们实现这个结构。创建一个名为`ShowGenre.swift`的新文件，并将以下代码添加到其中：
- en: '[PRE62]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This is an even simpler structure. This is just a small improvement over using
    a tuple because it is given a name instead of just properties and it also gives
    us finer control over what is constant or not. It may seem like a waste to have
    an entire file for just this but this is great for maintainability in the future.
    It is easier to find the structure because it is in a well-named file and we may
    want to add more code to it later.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更简单的结构。这只是在使用元组的基础上进行的小改进，因为它提供了一个名称而不是仅仅属性，并且它还让我们能够更精细地控制什么是常量或不是。可能看起来为这个而创建整个文件是浪费的，但这对未来的可维护性来说是非常好的。因为它在一个命名良好的文件中，所以更容易找到这个结构，我们可能以后还想向它添加更多代码。
- en: An important principle in code design is called **separation of concerns**.
    The idea is that every file and every type should have a clear and well-defined
    concern. You should avoid having two files or types responsible for the same thing
    and you want it to be clear why each file and type exists.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 代码设计中的一个重要原则被称为**关注点分离**。其理念是每个文件和每个类型都应该有一个清晰且定义良好的关注点。你应该避免有两个文件或类型负责同一件事，并且希望它清楚地表明每个文件和类型存在的原因。
- en: Interfacing with code from other files
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他文件中的代码交互
- en: 'Now that we have our basic data structures, we can use a smarter container
    for our list of invitees. This list contains the logic for assigning a random
    invitee a genre. Let''s start by defining the structure with some properties:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了基本的数据结构，我们可以为我们的受邀者列表使用一个更智能的容器。这个列表包含了为随机受邀者分配流派逻辑。让我们先定义一些属性来构建这个结构：
- en: '[PRE63]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Instead of storing a single list of both invited and pending invitees, we can
    store them in two separate arrays. This makes selecting a pending invitee much
    easier. This code also provides a custom initializer, so that all we need to provide
    from other classes is an invitee list without worrying whether or not it is a
    list of pending invitees. We could have just used the default initializer but
    the parameter would then have been named `pendingInvitees`. We also seed the random
    number generator for later use.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以不用存储一个包含受邀者和待邀请受邀者的单一列表，而是可以将它们存储在两个单独的数组中。这使得选择待邀请受邀者变得容易得多。此代码还提供了一个自定义初始化器，因此我们只需要从其他类提供受邀者列表，无需担心它是否是待邀请受邀者的列表。我们本可以使用默认初始化器，但参数将被命名为`pendingInvitees`。我们还为随机数生成器设置了种子，以供以后使用。
- en: Note that we did not need to provide a value for `invited` in our initializer
    because we gave it the default value of an empty array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要在初始化器中为`invited`提供一个值，因为我们已经给它赋予了默认值一个空数组。
- en: Note also that we are using our `Invitee` structure freely in this code. Swift
    automatically finds code from other files in the same project and allows you to
    use it. Interfacing with code from other files is as simple as that.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这个代码中自由地使用了`Invitee`结构。Swift会自动从同一项目中的其他文件中查找代码，并允许你使用它。与其他文件中的代码交互就像那样简单。
- en: 'Now, let''s add a helper function to move an invitee from the `pendingInvitee`
    list to the `invited` list:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个辅助函数，将受邀者从`pendingInvitee`列表移动到`invited`列表：
- en: '[PRE64]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'This makes our other methods cleaner and easier to understand. The first thing
    we want to allow is the inviting of a random invitee and then asking them to bring
    a show from a specific `genre`:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们的其他方法更简洁、更容易理解。我们首先想要允许的是随机邀请一个受邀者，然后要求他们从一个特定的`genre`中带来一场表演：
- en: '[PRE65]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: The picking of a random invitee is much cleaner than in our previous implementation.
    We can create a random number between `0` and the number of pending invitees instead
    of having to keep trying a random invitee until we find one that hasn't been invited
    yet. However, before we can pick that random number, we have to make sure that
    the number of pending invitees is greater than zero. If there were no remaining
    invitees we would have to divide the random number by `0` in `Int(rand()) % self.pendingInvitees.count`.
    This would cause a crash. It has the extra benefit of allowing us to handle the
    scenarios where there are more genres than invitees.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择受邀者的过程比我们之前的实现更简洁。我们可以创建一个介于`0`和待邀请受邀者数量之间的随机数，而不是不得不不断尝试随机受邀者，直到找到一个尚未被邀请的。然而，在我们能够选择那个随机数之前，我们必须确保待邀请受邀者的数量大于零。如果没有任何剩余的受邀者，我们将在`Int(rand())
    % self.pendingInvitees.count`中将随机数除以`0`，这会导致崩溃。它还有一个额外的好处，即允许我们处理流派数量多于受邀者数量的场景。
- en: 'Lastly, we want to be able to invite everyone else to just bring themselves:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够邀请其他人只带来他们自己：
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we have simply repeatedly invited and removed the first pending invitee
    from the `pendingInvitees` array until there are none left.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是反复邀请并从`pendingInvitees`数组中移除第一个待邀请受邀者，直到没有剩余的为止。
- en: 'We now have all of our custom types and we can return to the `main.swift` file
    to finish the logic of the program. To switch back, you can just click on the
    file again in Project Navigator (the list of files on the left). Here, all we
    want to do is to create our invitee list and a list of genres with example shows.
    Then, we can loop through our genres and ask our invitee list to do the inviting:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有了所有的自定义类型，可以回到`main.swift`文件来完成程序的逻辑。要切换回来，你只需在项目导航器（左侧的文件列表）中再次点击文件即可。在这里，我们只想创建我们的受邀者名单和包含示例节目的流派列表。然后，我们可以遍历我们的流派，并要求我们的受邀者名单进行邀请：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: That is our complete program. You can now run the program by clicking the **Run**
    button and examine the output. You have just completed your first real Swift project!
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的完整程序。你现在可以通过点击**运行**按钮来运行程序并检查输出。你刚刚完成了你的第一个真正的Swift项目！
- en: File organization and navigation
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件组织和导航
- en: As your project gets larger, it can be cumbersome to have just one single list
    of files. It helps to organize your files into folders to help differentiate which
    role they are playing in your app. In Project Navigator, folders are called groups.
    You can create a new group by selecting the group you would like to add the new
    group to, and going to **File** | **New** | **Group**. It isn't terribly important
    exactly how you group your files; the important thing is that you should be able
    to come up with a relatively simple system that makes sense. If you are having
    trouble doing that, you should consider how you could improve the way you are
    breaking up your code. If you are having trouble categorizing your files, then
    your code is probably not being broken up in a maintainable way.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 随着你的项目变大，仅仅有一个单一的文件列表可能会变得很繁琐。将你的文件组织到文件夹中可以帮助你区分它们在你的应用中扮演的角色。在项目导航器中，文件夹被称为组。你可以通过选择你想要添加新组的组，然后转到**文件**
    | **新建** | **组**来创建一个新的组。确切地如何分组你的文件并不十分重要；重要的是你应该能够想出一个相对简单且合理的系统。如果你在做这件事时遇到困难，你应该考虑如何改进你拆分代码的方式。如果你在分类文件时遇到困难，那么你的代码可能并不是以可维护的方式拆分的。
- en: I would recommend using lots of files and groups to better separate your code.
    However, the drawback of that is that Project Navigator can fill up pretty quickly
    and become hard to navigate around. A great trick in Xcode to navigate to files
    more quickly is to use the keyboard shortcut *Command* + *Shift* + *O*. This displays
    the Open Quickly search. Here, you can start to type the name of the file you
    want to open and Xcode shows you all of the matching files. Use the arrow keys
    to navigate up and down and press *Enter* to open the file you want.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议使用大量的文件和组来更好地分离你的代码。然而，这样做的一个缺点是项目导航器可能会很快填满，变得难以导航。在Xcode中快速导航到文件的一个很好的技巧是使用键盘快捷键*Command*
    + *Shift* + *O*。这会显示快速打开搜索。在这里，你可以开始输入你想要打开的文件名，Xcode会显示所有匹配的文件。使用箭头键上下导航，并按*Enter*键打开文件。
- en: Extensions
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展
- en: Up until this point, we had to define our entire custom type in a single file.
    However, it is sometimes useful to separate out part of our custom types into
    different files, or even just in the same file. To achieve this, Swift provides
    a feature called extensions. Extensions allow us to add additional functionality
    to existing types from anywhere.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们必须在单个文件中定义我们的整个自定义类型。然而，有时将我们的自定义类型的一部分分离到不同的文件中，或者甚至在同一文件中，有时是有用的。为了实现这一点，Swift提供了一个名为扩展的功能。扩展允许我们从任何地方向现有类型添加额外的功能。
- en: 'This functionality is limited to additional functions and additional computed
    properties:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 此功能仅限于额外的函数和额外的计算属性：
- en: '[PRE68]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Note that, to define an extension, we use the `extension` keyword, followed
    by the type that we would like to extend. Extensions can also be used on an existing
    class, struct, or enumeration, even those defined within Swift like String. Let''s
    add an extension to String that allows us to repeat a string any number of times:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了定义一个扩展，我们使用`extension`关键字，后跟我们要扩展的类型。扩展也可以用于现有的类、结构体或枚举，即使是Swift中定义的，如String。让我们给String添加一个扩展，允许我们重复字符串任意次数：
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: This is just one simple idea, but it is often incredibly useful to extend the
    built-in types.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的想法，但扩展内置类型通常非常有用。
- en: Now that we have a good overview of what tools we have at our disposal for organizing
    our code, it is time to discuss an important concept in programming called **scope**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对可用于组织代码的工具有了良好的概述，是时候讨论编程中的一个重要概念，即**作用域**了。
- en: Scope
  id: totrans-275
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作用域
- en: Scope is all about which code has access to which other pieces of code. Swift
    makes it relatively easy to understand because all scope is defined by curly brackets
    (`{}`). Essentially, code in curly brackets can only access other code in the
    same curly brackets.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: How scope is defined
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To illustrate scope, let''s look at some simple code:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: As you can see, `outer` can be accessed from both in and out of the `if` statement.
    However, since `inner` was defined in the curly brackets of the `if` statement,
    it cannot be accessed from outside of them. This is true of structs, classes,
    loops, functions, and any other structure that involves curly brackets. Everything
    that is not in curly brackets is considered to be at **global scope,** meaning
    that anything can access it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: Nested types
  id: totrans-281
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, it is useful to control scope yourself. To do this, you can define
    types within other types:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'In this scenario, `InnerStruct` is only directly visible from within `OuterClass`.
    This, however, provides a special scenario that is not there for other control
    structures like `if` statements and loops. If code at the global scope wanted
    to access `InnerStruct`, it could only do so through `OuterClass` which it does
    have direct access to, as shown:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: This can be useful to better segment your code but it is also great for hiding
    code that is not useful to any code outside other code. As you program in bigger
    projects, you will start to rely on Xcode's autocomplete feature more and more.
    In big code bases, autocomplete offers a lot of options, and nesting types into
    other types is a great way to reduce unnecessary clutter in the autocomplete list.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: Access control
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Swift provides another set of tools that helps to control what code other code
    has access to called **access controls**. All code is actually given three levels
    of access control:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '**Private**: Only accessible from within the same file'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Only accessible from within the same module or app'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Public**: Accessible by any code that imports the module'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before we can really discuss this further, you should understand completely
    what a module is. It is beyond the scope of this book to talk about implementing
    a module but a module is a collection of code that can be used in other modules
    and apps. So far, we have used the `Foundation` module provided by Apple. A module
    is anything that you use when using the `import` keyword.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: All code, by default, is defined to be at the internal level. That means that
    any given piece of code in your program can access any piece of code defined in
    any other file that is also included in your program as long as it follows the
    scoping rules we have already discussed.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'As described previously, code declared as private is only accessible from the
    same file. This is an even better way to protect outside code from seeing code
    you don''t want it to see. You can declare any variable or type as private by
    writing the `private` keyword before it, like this:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that access control is independent of the curly bracket scope. It is built
    on top of it. All of the existing scope rules apply, with access controls acting
    as an additional filter.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，访问控制独立于花括号作用域。它是建立在作用域之上的。所有现有的作用域规则都适用，访问控制作为额外的过滤器。
- en: This is a fantastic way of improving the idea of abstractions. The simpler the
    outside view of your code, the easier it is to understand and use your abstraction.
    You should look at every file and every type as a small abstraction. In any abstraction,
    you want the outside world to have as little knowledge of the inner workings of
    it as possible. You should always keep in mind how you want your abstraction to
    be used and hide any code that does not serve that purpose. This is because code
    becomes harder and harder to understand and maintain as the walls between different
    parts of the code break down. You will end up with code that resembles a bowl
    of pasta. In the same way that it can be difficult to find where one noodle starts
    and ends, code with lots of interdependencies and minimal barriers between code
    components is very hard to make sense of. An abstraction that provides too much
    knowledge or access about its internal workings is often called a **leaky abstraction**.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种改进抽象概念的绝佳方式。你的代码外部视图越简单，理解和使用你的抽象就越容易。你应该把每个文件和每个类型都看作是一个小的抽象。在任何抽象中，你希望外部世界尽可能少地了解其内部工作原理。你应该始终牢记你希望你的抽象如何被使用，并隐藏任何不服务于该目的的代码。这是因为随着代码不同部分之间的墙壁倒塌，代码变得越来越难以理解和维护。你最终会得到一团像意大利面一样的代码。就像很难找到一根面条的起点和终点一样，具有许多相互依赖和代码组件之间最小障碍的代码很难理解。提供过多关于其内部工作原理的知识或访问权限的抽象通常被称为**泄漏抽象**。
- en: Public code is defined in the same way, except that you would use the `public`
    keyword instead of `private`. However, since we will not study designing your
    own modules, this is not useful to us. It is good to know it exists for future
    learning but the default **internal** access level is enough for our apps.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 公共代码的定义方式相同，只是你会使用`public`关键字而不是`private`。然而，由于我们不会研究设计自己的模块，这对我们来说并不有用。了解它的存在对未来的学习是有益的，但默认的**内部**访问级别对我们应用来说已经足够了。
- en: Summary
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a very dense chapter. We have covered a lot of ground. We have delved
    deep into defining our own custom types using structures, classes, and enumerations.
    Structures are great for simple types, while classes are great for types that
    require a hierarchy of related types. Enumerations provide a way to group related
    things together and express more abstract concepts through associated values.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一章非常密集的内容。我们覆盖了大量的内容。我们深入探讨了使用结构、类和枚举定义我们自己的自定义类型。结构非常适合简单类型，而类非常适合需要相关类型层次的结构类型。枚举提供了一种将相关事物分组在一起的方法，并通过关联值表达更抽象的概念。
- en: We have also created our first project, which made use of multiple source files
    improving the maintainability of our code bases, especially at scale. Extensions
    can be used across and within those files to add additional functionality to existing
    types, including those not defined by us.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也创建了我们的第一个项目，该项目利用多个源文件提高了我们代码库的可维护性，尤其是在规模较大的情况下。扩展可以在这些文件之间以及文件内部使用，以向现有类型添加额外功能，包括那些不是由我们定义的类型。
- en: Finally, we developed a good understanding of what scope is and how we can control
    it to our advantage, especially with the help of access controls to give us an
    even more fine grained filter on what code can interact with other code.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们很好地理解了作用域是什么以及我们如何控制它以获得优势，尤其是在访问控制的有力帮助下，这为我们提供了对代码可以与其他代码交互的更精细的过滤器。
- en: Now that you have made it this far, you are well on your way to becoming a quality
    Swift programmer. I definitely recommend that you take a breather and experiment
    with everything that you have learned so far. We have only a few more concepts
    left to learn until we have all the tools necessary for creating a great app.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经走得很远了，你正朝着成为一名优秀的Swift程序员迈进。我强烈建议你稍作休息，并尝试到目前为止所学到的所有内容。我们只剩下几个概念需要学习，直到我们拥有创建优秀应用所需的所有工具。
- en: Once you are ready to move on, we can talk about **optionals**, which I have
    already hinted at. Optionals are somewhat complex but are an integral part of
    using the Swift language effectively. In the next chapter, we will dive deep into
    what they are and then how to take advantage of them in the most effective ways
    possible.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好继续前进，我们就可以讨论**可选参数**了，我已经暗示过了。可选参数有些复杂，但它们是有效使用Swift语言的一个不可或缺的部分。在下一章中，我们将深入探讨它们是什么，以及如何以最有效的方式利用它们。
