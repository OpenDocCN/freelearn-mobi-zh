- en: Chapter 2. Database Design Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you will learn about SQLite's database concepts. Just as with
    most databases, SQLite too can add data using the SQL command called `INSERT`.
    It can also modify data using the `UPDATE` command and remove data using the `DELETE`
    command. It can also retrieve data using the `SELECT` command.
  prefs: []
  type: TYPE_NORMAL
- en: These four commands form the base line for any SQL database RDMS in the market.
    This set of commands manipulate the data, and this type of searching is called
    a **query**.
  prefs: []
  type: TYPE_NORMAL
- en: Database essentials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This persistent and structured way of storing data is simply called a database,
    and the data itself is stored using tables. Each table consists of columns and
    rows, with a look and feel similar to **Microsoft Excel**.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is based on the C language and a related API (RDBMS) in the market. The
    C language, for example, is easy to understand and is based on the fundamentals
    of database design with RDBMS. However, learning the actual API will benefit your
    skills and understanding.
  prefs: []
  type: TYPE_NORMAL
- en: In order to understand the API, you will have to learn the components that make
    up the database to improve your knowledge. Understanding data structures, SQL
    transactions, concurrency, and data-locking mechanisms, and creating good optimized
    queries will help you design great database systems.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, you need to put this understanding into some software code for the app
    you write and see how it is integrated and executed. The API language extension
    will be discussed further in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The design objective of SQLite was to keep the role of administration and operation
    easy to use and simple to manage. SQLite is **ACID** (**atomicity**, **consistency**,
    **isolation**, and **durability**) compliant, and is fully transactional using
    **T-SQL**.
  prefs: []
  type: TYPE_NORMAL
- en: As a part of the design, the SQLite database has a variety of datatypes like
    most databases. One of the types is the `INTEGER` type that has 64 bit numeric
    values. This database uses 64 bit numeric values and the data is stored in 1,
    2, 3, 4, 5, 6, or 8 bytes. The `TEXT` type encoding uses UTF-8 for storing it
    in the database. The `BLOB` datatype can be stored directly, with a default size
    of 1,000,000,000 bytes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SQLite also uses the `REAL` type, which is a 64 bit floating point value, and
    there is the standard `NULL` value as well. The `REAL` type will be applied to
    the `FLOAT`, `DOUBLE`, and `REAL` datatypes. The `TEXT` type applies to the `NCHAR`,
    `NVARCHAR`, `TEXT`, and `VARCHAR` datatypes. The `NUMERIC` type applies to `DATE`,
    `DATETIME`, and `BOOLEAN`. SQLite also uses **CRUD** (**Create, Read**, **Update**,
    and **Delete**), and this database is *not* case sensitive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The statements are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CREATE` statement is used to create new tables in the SQLite database.
    The basic syntax and a simple example of `CREATE TABLE` is shown here. The `CREATE
    TABLE` statement has a database name that is fixed. It is followed by a table
    name, which has a start and close bracket. Within this statement, there is a list
    of column(s) to be created, starting with their names and datatypes, as shown
    in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CREATE table database-name. table-name( column1 datatype, column2 datatype,
    column3, datatype, PRIMARY KEY column1);`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `INSERT` statement will have a table name followed by a set of columns
    on the first half. The second half will have the variables, where the data coming
    from that will be inserted into the table. It is important to ensure that the
    programmer uses the same datatype as the column created; otherwise, there will
    be an error or a warning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`INSERT into table-name(column1,column2,column3) VALUES(variable1,variable2,variable3);`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `UPDATE` statement is used to update records or rows within a table. The
    `UPDATE` statement will have a table name, followed by a set of columns to update
    on the left-hand side, and some data variables on the right-hand side, as shown
    in the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UPDATE table-name SET column1=variable1, column2=variable2, column3=variable3)
    [where variable4 = 10];`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `SELECT` statement is used to select information, records, or rows within
    a table. This is shown in *Figure 7*. The `SELECT` statement will have a set of
    columns on the first half, followed by a table name and a condition, as shown
    here:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SELECT column1, column2, column3 FROM table-name WHERE column1 > 10;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `DELETE` statement is used to delete records or rows within a table. This
    is shown here. The `DELETE` statement will have a set of columns on the first
    half, followed by a table and any condition:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE from table-name where column1 >10;`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The extension and core APIs are the sections that form the API made with the
    C language. The core database carries out functions such as processing SQL syntax
    and connecting to the database. Other tasks, such as error trapping and string
    formatting, are also dealt with the core API. As mentioned earlier, the extension
    API allows programmers to add or extend the current API with a new functionality
    that will add the functionality that does not exist presently or as a current
    definition with the SQLite program.
  prefs: []
  type: TYPE_NORMAL
- en: Although data structures are outlined, as mentioned previously, using the tokenizer
    or parser, their importance is reduced, since coders are interested in other parts,
    such as the connectivity syntax, parameters, or current functions, and not the
    internals of the products. In order to write some good code, programmers must
    be clued up on SQLite locks, transactions, and the API itself.
  prefs: []
  type: TYPE_NORMAL
- en: Although not a part of the API itself, the **pager** and **B tree** parts of
    the SQLite system contribute heavily as a part of locking and transactions mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are eight methods and two objects that make up the C/C++ interface part
    of the SQLite database system. The two objects are: `sqlite3`, which is the actual
    database connection object, and `sqlite3_stmt`, which is the `prepare` statement
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The eight methods comprise the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlite3_exec()`: This is a wrapper function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_close()`: This is a destructor for `sqlite3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_finalize()`:This is a destructor for `sqlite3_stmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_column()`: This holds the column values for `sqlite3_stmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_step()`:This allows you to step to the next result row and is an advancement
    of `sqlite3_stmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_bind()`: This is how SQL is broken down into parameters from the stored
    application data'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_prepare()`:This is a part of the constructor for `sqlite3_stmt`, where
    byte code is produced from SQL that has been compiled, so it can carry out the
    SQL statements (`SELECT`, `UPDATE`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_open()`: This is the constructor of `sqlite3`, which allows a connection
    to an existing or a new SQLite database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Initially, SQLite was easy to learn and had only five C/C++ interfaces, but
    now, it has grown in size, functionality, and interfaces to over 200 APIs. It
    can be daunting to use 200 APIs, but SQLite has been designed in such a way that
    you only use the API, but now, it has grown in size and function.
  prefs: []
  type: TYPE_NORMAL
- en: 'These six core interfaces, once mastered, will give programmers a great understanding
    of SQLite. They are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SQLite3_open()`: This function makes a connection to the SQLite database and,
    once successful, a database connection object will be returned. None of the other
    interfaces will be available until the `SQLite3_open()` interface has been set
    up. They require a starting point, or a reference to a database, and a database
    connection object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite3_prepare()`: This function will convert and set up SQL statements into
    a formatted object, and the output will be a pointer that will be stored in reference
    to that object. In order to progress, this interface requires a database connection
    object produced by the `SQLite3_open()` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite3_column()`: This interface does not interrogate the SQL, it just produces
    a prepared statement. This interface is now not the preferred choice for new applications,
    but the alternative `SQLite3_prepare_V2()` interface must be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite3_step()`: This interface will look at the prepared statement as set
    up by the `SQLite3_prepare()` function and will return a single column from the
    current record set. This is not purely a function, but a placeholder for the type
    of functions that return values with different datatypes. These form a part of
    the results set. There are other functions that are a part of the `sqlite3_column()`
    setup, and they are, `sqlite3_column_blob()`, `sqlite3_column_bytes()`, `sqlite3_column_bytes16()`,
    `sqlite3_column_count()`, `sqlite3_column_double()`, `sqlite3_column_int()`, `sqlite3_column_int64()`,
    `sqlite3_column_text()`, `sqlite3_column_type()`, and `sqlite3_column_value()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite3_finalize()`: This function is the interface that destroys the prepared
    statement to stop any memory leaks in the system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SQLite3_close()`: This interface will shut any database connection and prepared
    statements before closing or ceasing operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are other routines, such as `sqlite3_bind()` and `sqlite3_reset()`, that
    enable prior statements to be used again and again. Usually, statements are created,
    prepared, and destroyed once, but the aforementioned routines can be used at multiple
    instances.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite has the `sqlite3_config()` interface that is first selected before any
    connections to the database are initiated. This interface will have the ability
    to set global changes for the database. It can also allocate memory, set up allocators
    for real-time embedded systems, and page caching for a predefined application
    usage. It can also make adjustments for different treading models.
  prefs: []
  type: TYPE_NORMAL
- en: This database system is flexible, and using `sqlite3_create_collation()`, `sqlite3_create_function()`,
    `sqlite3_create_module()`, and `sqlite3_vfs_register()` functions will allow the
    SQLite system to have a new proprietary functionality on the RDBMS. For example,
    the `sql_create_function()` function will create additional functionality for
    aggregate or scalar purposes. These are `sqlite3_agreegate_context()`, `sqlite3_result()`,
    `sqlite3_user_data()`, and `sqlite3_value()`.
  prefs: []
  type: TYPE_NORMAL
- en: These are the standard built-in functionalities of the SQLite system that prove
    how flexible the system can be to programmers. It is this flexibility, together
    with the technology that has helped it grow and cultivate to a place where it
    has become the best SQL database for mobiles today.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, there are many other interfaces and functions that are too many
    to include in this book. They can be found under the C/C++ interface specification
    of this product.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite, by default, will do most of the tasks required by programmers, users,
    or DBAs. Programmers are always looking to go beyond the normal bounds of the
    relational database system, or take advantage of these extensions to fulfill their
    solution requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Reasons for using SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many features that make SQLite a great database for mobile technologies.
    For example, there is no administration or configuration involved, the transactions
    are atomic, the database is self-contained in a single cross-platform file, and
    it holds advanced features, such as table expressions and partial indexes. The
    reasons for using SQLite are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: It has a small, versatile, and easy-to-use API. It is very standard-compliant
    and is written using the ANSI-C compliant. There are no external dependencies
    on any external programs or services, and the code is well commented. The source
    code is in the public domain and has a standalone **CLI** (**command-line interface**)
    at its disposal. It is cross-platform compliant, works with Mac, Linux, BSD, Android,
    Solaris, VxWorks, and Windows (WinCE, Win32, WinRT).
  prefs: []
  type: TYPE_NORMAL
- en: Its code footprint is very small, less than 500 kB when configured. The amount
    of application range that uses this database is huge. Almost all the products
    can have or have the need for a database that SQLite can handle.
  prefs: []
  type: TYPE_NORMAL
- en: It may not have all the bells and whistles of an enterprise system, but it is
    very flexible and easily available. SQLite is used by a variety of companies such
    as Adobe, Dropbox, Skype, and many more users.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite is tested independently with its own test facilities and criteria. There
    are tests for memory usage, crash and power loss, fuzz tests boundary value and
    disable optimization tests, regression tests, and behavior checks among others.
    The test harnesses are also independently developed and verified.
  prefs: []
  type: TYPE_NORMAL
- en: The testing process for SQLite is well tested and matured, and the TCL tests
    are built using the TCL Scripting language. The test harnesses are made using
    the C code that creates the TCL interface. There are over 800 files of test scripts
    that hold over 10 gigabytes of data and over 30,000 test cases.
  prefs: []
  type: TYPE_NORMAL
- en: There are also SQL logic tests that run SQL statements against other database
    engines, such as SQL Server, PostgreSQL, Oracle, and SQLite itself. These form
    a part of the SLT (SQL Logic Test) that runs over 7 million queries and 1 gigabyte
    of test data as a part of the testing load.
  prefs: []
  type: TYPE_NORMAL
- en: Also, there are many types of stress and performance testing, including anomaly
    tests, which include the behavior of SQLite on a variety of checks and see how
    it performs when errors occur. All the tests are run on all the platforms that
    SQLite works with. There is a subset of testing scripts that are used as a quick
    test; however, over 200,000 test cases—enough to capture any errors, or misfit
    code—can still be executed quickly.
  prefs: []
  type: TYPE_NORMAL
- en: There are also tests for checking the memory usage that look at memory allocation
    and the use of the `malloc()` function. All the SQL databases use the `malloc()`
    function to allocate and release memory. Since SQLite is heavily used in embedded
    systems, it is required to handle errors in a graceful manner.
  prefs: []
  type: TYPE_NORMAL
- en: I/O testing is carried out to ensure that I/O errors are handled and dealt with
    properly. These issues maybe with regard to network errors, configuration, disk
    issues, or permissions. Errors are created to see their effects and to see how
    the software handles them.
  prefs: []
  type: TYPE_NORMAL
- en: A **virtual file system** (**VFS**) is also used to simulate the database crashing
    as part of the testing procedures. There are also simulations using power failures,
    so any measurement can be recorded. The crash test processes are completed separately.
  prefs: []
  type: TYPE_NORMAL
- en: There are also fuzz tests that take care to see that SQLite works with odd and
    different inputs and all the results are checked. Processes are spawned and the
    VFS is used to simulate crashes. In addition to the standard fuzz test, there
    are fuzz tests for SQL that look at the syntax and inputting to the database to
    check the responses and results. These form a part of the TCL testing, and there
    are over 100,000 fuzz tests. All the results are recorded and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: All branch tests for this database are 100% tested and measured. There are also
    measurements and tests to ensure that any automatic resource leaks are detected,
    noted, and dealt with. Usually, resource leaks occur when, in certain circumstances,
    resources are allocated by the `malloc()` function; but they are not released
    when other processes may require the same resource or some form of shared resource.
    When the resource is not freed or released as instructed, then it leads to resource
    leakage.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite also has dynamic analysis that checks the internal and external SQLite
    code while the code is being executed or is in use online. This type of analysis
    is used to ensure that SQLite has the best availability and quality for users.
  prefs: []
  type: TYPE_NORMAL
- en: '**Valgrind** is the simulator of the Linux binary and x86 environments. As
    a simulator, it is much slower, but it is effective. **Memsys2** has a memory
    allocation system that is pluggable; it uses the `malloc()` and `free()` functions.
    If SQLite is compiled with the `SQLite_MEMDEBUG` compile-time option, then, as
    a part of the debugging memory allocator, a larger wrapper is used around the
    `malloc()`, `realloc()`, and `free()` functions. If Memsys2 is used, it looks
    for memory allocation errors at runtime.'
  prefs: []
  type: TYPE_NORMAL
- en: There are the `mutex` subsystems in SQLite that use the `sqlite3_mutex_held()`
    and `sqlite3_mutex_ notheld()` function. This is a pluggable subsystem, and these
    two interfaces detect whether a `mutex` subsystem has a particular thread. SQLite
    uses the `assert()` set of functions to ensure that multithreaded applications
    work correctly within the database system.
  prefs: []
  type: TYPE_NORMAL
- en: SQLite uses a rollback journal to ensure that all the changes on the database
    are recorded before actually making changes to the database. SQLite has to work
    with different conditions so that it does not conflict or cause undetermined or
    odd behavior that must be managed. Since the code is developed in C, it may work
    with many implementations and libraries during development, but in the production
    area, it must confirm and may not work sometimes.
  prefs: []
  type: TYPE_NORMAL
- en: So, checks such as a shifting using a negative number may be tried, or trying
    the `memcpy()` function to copy buffers that are overlapping and checking that
    unsigned or signed variables apply to `char` datatypes. To cope with, and cater
    for these issues, the compiler (**GCC**) may use the `-fraction` to within the
    test suites.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the code is released, it goes through a ping and checks that unsigned
    or signed, or analyzed and compile time errors will be checked before going forward.
    Both the connections—**Connection 1** and **Connection 2**—are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reasons for using SQLite](img/B04725_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: SQLite object model with C API'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 9* outlines the views that a programmer will look at—B-tree and pager,
    rather than components such as tokenizers or parser. *Figure 9* outlines the relationship
    between the components. To know SQLite properly, programmers must understand the
    locks, API, and transactions of SQLite.'
  prefs: []
  type: TYPE_NORMAL
- en: As *Figure 9* illustrates, pager and B-tree access is forbidden, but important
    within locks and transactions. The connection to the database and SQL statements
    is most important when the API has many data structures. For example, a connection
    to any SQLite database is held as one transaction and also as one connection to
    the RDMS. A SQL statement is internally represented in the form of a **virtual
    database of engine** (**VDBE**) byte code.
  prefs: []
  type: TYPE_NORMAL
- en: With the B-tree and pager components of SQLite, it will support many database
    objects within each connection, as shown in *Figure 9*. Every database object
    has a B-tree object, which has a relationship with a pager object. The SQL code
    (SQL statements) within each connection are shown in *Figure 9*. Every database
    object has a B-tree object, which has a relationship.
  prefs: []
  type: TYPE_NORMAL
- en: When B-tree requires information, it prompts the pager component to get the
    data from the database. The pager component will move the data into its memory
    buffer, and the B-tree component will then associate it via its cursor to retrieve
    and view the data.
  prefs: []
  type: TYPE_NORMAL
- en: Executing SQL statements and commands is a part of the main piece of the API
    that has two methods, which are either prepared or wrapped queries. If the page
    is modified by the cursor, the original page/data must be kept just in case of
    a database rollback. The pager is very important and has to deal with write and
    read events to and from the RDBMS.
  prefs: []
  type: TYPE_NORMAL
- en: A transaction is set up once an operation is in place. For example, a database
    connection setup will effectively be considered as one transaction. Also remember
    that a connection cannot have more than one transaction open or available at any
    given time.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, SQL statements from a standard connection will work on the same transaction.
    If the conditions of your program require more than one statement in different
    transactions, you have to engage in using multiple connections, as illustrated
    in *Figure 9*.
  prefs: []
  type: TYPE_NORMAL
- en: It is very important to know how to set up a database connection from the application
    to the SQLite database. If there is no connection, then any of the commands used
    to retrieve, update, or insert data are useless. The connection statement will
    define the data process and its name and will set up a transaction to allow the
    data to pass to the database and back. Once a connection is made, the rest of
    the process sets up the database interactivity. It is not a difficult task to
    complete, but setting up a database is important to learn, because it is the starting
    point of all database activities and applications.
  prefs: []
  type: TYPE_NORMAL
- en: Database connections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `sqlite3_open()` C API function is used to open a connection to the database
    and is held in a single operating system file. This function actually opens the
    file, and thus, a secure connection is made that is not shared. If the memory
    option is used, then the database will be created in **random access memory**
    (**RAM**), once the connection is established. The database will then be removed
    and deleted from RAM when the connection closed.
  prefs: []
  type: TYPE_NORMAL
- en: 'SQLite will attempt to open an existing database, and if an entered database
    name does not exist, then it will assume that the programmer wants to create one.
    SQLite is clever if you want to create a database and then close it without any
    operation, such as creating a table: it will not actually spend resources creating
    the database, only an empty file will exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding statement will create the required default file with a table and
    will then drop/delete it, leaving a clean database without any tables. This is
    possibly the neatest way to show an empty database.
  prefs: []
  type: TYPE_NORMAL
- en: When opening the SQLite database, the programmer or database administrator can
    specify the size of the page in different ranges from 512 to 32,768 bytes. By
    default, SQLite will use a 1,024 byte page size. For a better performance, the
    developer may consider a page size of his SQLite database equal to the operating
    system's page size, which will make operations much more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on the type of application you are going to design; paying attention
    to the detail on the type of columns, sizes, and types, which will gear a table
    and database design to be more efficient and perform well. If the application
    you are dealing with has large binary data for example, the database page size
    will increase to match the loading or selecting of data. The `page_size` parameter
    is used as a part of the database page sizing for each database.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are the eight methods and two objects that form the SQLite interface.
    These are the basic list of functions that each user/reader must be aware of when
    using SQLite in code. These statements don''t change, nor does their functionality.
    These are the key statements to ensure that users are aware of the name, format,
    and where these functions are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`sqlite3`: Database connection object, made by `sqlite3_open()`, killed by
    `sqlite3_close`()'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_stmt`: Preparation statement object, made by `sqlite3_prepare()`,
    killed by `sqlite3_finalize()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_open()`: Opens the database (new or existing) and uses constructor
    `sqlite3`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_prepare()`: Compiles some SQL text into byte code to perform updating
    or querying tasks and is the constructor of `sqlite3_stmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_bind()`: Application data is stored into the parameters of the original
    SQL'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_step()`: The further advancement of `sqlite3_stmt` onto the next row
    or completion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_column()`: The current row result outlining column values for `sqlite3_stmt`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_finalize()`: `sqlite3_stmt` destructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_close()`: `sqlite3` destructor'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sqlite3_exec()`: A wrapper function that works for one or many SQL statements
    using `sqlite3_prepare()`, `sqlite3_step()`, `sqlite3_finalize()`, and `sqlite3_column()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `sqlite3_prepare_v2()` function is the one used to prepare and execute
    SQL statements. The prepare function is the method that SQLite uses as a part
    of the following three-stage process:'
  prefs: []
  type: TYPE_NORMAL
- en: First is the preparation stage, next the execution stage, and then the finalization
    stage. On the preparation side (first step), the components, as explained in [Chapter
    1](ch01.html "Chapter 1. Introduction to SQL and SQLite"), *Introduction to SQL
    and SQLite*, outline the parser, tokenizer, and code maker to investigate the
    SQL and make a statement using the `sqlite3_prepare_v2()` function working with
    the compiler. Then, a handle is created with byte code from the `sqlite3_stmt`
    function that collates and uses relevant resources for the statement to execute.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Secondly, VDBE within SQLite will take the byte code and execute it using the
    C API. The `SQLite3_step()` will work with (VDBE) to go through the byte code
    looking at locking resources as required. Different statements will work differently
    in VDBE, but for the `SELECT` statements as an example, using `sqlite3_step()`
    as part of a result set, `SQLITE_ROW()` will be set and the process will go through
    the whole dataset until `SQLITE_DONE` is reached. Other statements in the set
    including `UPDATE`, `INSERT`, and `DELETE` will be directly executed within VDBE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third step is the final one where the resources to VDBE are closed; the
    `sqlite3_finalize()`function does this. Once the `sqlite3_finalize()` function
    is executed and resources are free, the program comes to an end via the VDBE and
    the statement handle is closed as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parameterized SQL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using SQL within C code and the API will involve parameterized SQL—the way
    to include data placeholders in an SQL statement. These are the two types of parameterized
    binding: named and positional. See *Figure 10* for more details on how these types
    of parameterized binding are used. The first statement is positional where its
    position is located or marked by a question mark, and these positions are based
    on the number of columns.'
  prefs: []
  type: TYPE_NORMAL
- en: The real variable names setup in the programmable language, such as C or Java,
    as shown in the second insert statement in *Figure 10*, outlines the named parameters
    that use a colon as a prefix to indicate it on an SQL statement. By default, `NULL`
    is used as a default value if there is no value for it to be bound to.
  prefs: []
  type: TYPE_NORMAL
- en: Once a statement is bound, you can call on it again more than once without wasting
    the performance or time to recompile it again.
  prefs: []
  type: TYPE_NORMAL
- en: The whole idea of using parameterized SQL is to reuse the same code with different
    parameters without recompiling. It saves on resources and time, and improves efficiency.
    This allows the existing code to be reused several times if the design allows
    it, to save on more code and improve efficiency. If you use quotes or characters
    for plurals as an example, SQLite, by default, will escape the characters and
    insert the right data and convert it properly.
  prefs: []
  type: TYPE_NORMAL
- en: 'It also stops SQL injections, SQL penetrations, and easy syntax issues or errors.
    The SQL injection to a company is a security vulnerability, which allows a hacker
    to trick the system into adding or modifying data where access is not granted.
    On a browser where the address of a website is seen, the data input is sometimes
    added without any encryption, or no data checking is carried out at the backend
    or frontend to allow penetration. SQL injections, as illustrated and explained
    in *Figure 12*, show that an open piece of code that relies on an input using
    a `%s` string, can be regarded as opened, and can impact the data in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parameterized SQL](img/4725_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 10: Using parameterized SQL'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows how a statement can be compiled using one set of
    parameters; using the `function _reset()` method will allow the same compiled
    SQL code to be used again with different parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling errors is mandatory when writing systems, especially if it is for mobile
    devices; so, attention to detail and catching issues with code is vital. The `SQLITE_BUSY`
    and `SQLITE_ERROR` functions are used by programmers to notify and trap errors,
    and store them for a later analysis.
  prefs: []
  type: TYPE_NORMAL
- en: For example, `SQL_ERROR` is activated when resources such as locks cannot be
    granted or are not available, whereas the `SQL_BUSY` covers issues with transactions
    and related matters. Another function called `sqlite3_errcode()` will handle any
    general SQLite error. These methods and functions are the standard way of handling
    errors with SQLite.
  prefs: []
  type: TYPE_NORMAL
- en: Queries within the db.exec statement
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `sqlite3_get_table()` function is used to execute SQL statements that actually
    return data, such as the `SELECT` statement, but the `sqlite3_exec()` function
    is a one-way traffic execution and does not return any data, for example, the
    `INSERT` statement. See the following code for more information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: SQL injection attacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another issue with SQLite and SQL statements generally is **SQL injection attacks**.
    These can deface websites, result in data corruption, and also affect the reputation
    of your website and its customers. If the input to SQL parameters is direct, then
    a weakness could be penetrable. SQL data input must be checked and filtered to
    allow no one to change the current statement with data elements or even replace
    SQL statements to perform corrupt acts. This can be done using this statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code shows that an injection can take place where `%s` is the
    input string, and it can be changed to be something else, thus changing the outcome
    result. To protect SQL, constrain the input, use parameters with stored procedures,
    and use parameters with dynamic SQL to reduce the threats.
  prefs: []
  type: TYPE_NORMAL
- en: To prevent your website from being used for `XSS` or `XSRF` attacks, disallow
    the HTML tags in text input provided by users by using functions to find and strip
    tags.
  prefs: []
  type: TYPE_NORMAL
- en: Creating user-defined functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The benefit of using SQLite over other small databases is its flexibility to
    engage with the extension API side by creating your own user-defined function.
    If you are familiar with creating your own function in a language such as Java
    or C, for example, then extending the natural SQLite database will not be difficult.
    The following code outlines how this can be done using the C API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Transactions and locks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Transactions and lock states form a part of the makeup of the API and its functions.
  prefs: []
  type: TYPE_NORMAL
- en: Although difficult to control in their entirety, locks and transactions are
    interlinked with queries within SQLite and most database systems. The key to better
    transactions involves the programmer writing good SQL code, ensuring that it will
    perform well, and catering for possible errors and issues during the journey so
    that the application does not crash or leave the user in the lurch. Another issue
    with locks will relate to which resources you need. Sometimes, it could be a badly
    written code that does not use `autocommit` or is holding an exclusive lock to
    a table and another part of your process, and you can't update it, as an example.
    So, it is very important for the programmer to gauge, learn the API, and understand
    how locking and transaction strategies will work to produce a smooth and good
    app.
  prefs: []
  type: TYPE_NORMAL
- en: By default, `autocommit` is used in SQLite where transactions cycles start and
    end, which are controlled by programmers and statements used for the app. Each
    SQL command will run in its own transaction since `autocommit` is used. However,
    within a transaction, especially using a begin command, the programmer has to
    manually call a rollback, or a commit to update the database. Sometimes, a locking
    strategy such as this may cause SQL violations or errors, which has to be handled
    by the error handling code within the app.
  prefs: []
  type: TYPE_NORMAL
- en: In terms of passwords, as a programmer or designer, do not store password, such
    as database passwords, in any clear text or script that may be accessed by any
    user. For example, in a directory to a web server, a source file can be compromised.
  prefs: []
  type: TYPE_NORMAL
- en: Application authentication should be done on two levels with heavy type password
    formats so that access is not compromised, especially with technology, such as
    spyware that looks into compromising your system. The data can be encrypted when
    database authorization provisions do not offer sufficient protection, which is
    initially required.
  prefs: []
  type: TYPE_NORMAL
- en: Transactions – reading/writing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a `SELECT` statement is used within SQLite, it moves from a default status
    of `UNLOCKED` to `SHARED`, and once the statement is committed, it reverts to
    `UNLOCKED`. There are several states for transaction lock states and locking works
    when there is `autocommit` on or transactional control with `autocommit` off within
    a begin/end statement arrangement. When there is some contention, the transactional
    locking states may alter from `UNLOCKED` to `SHARED`, `RESERVED`, or `EXCLUSIVE`.
  prefs: []
  type: TYPE_NORMAL
- en: If an update is to take place, the programmer may code it so that an `EXCLUSIVE`
    lock is used. This stops updates from other processes, just until the job has
    been done and the lock is released. In this case, the programmer must also code
    and put up a message or write to the log file; if this happens, auditors or database
    administrators will have an audit trail of events during the lifetime of an application.
    It is a very good practice to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Designing for SQLite
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generally, programmers will think that because database systems are huge or
    work best in enterprise, it will be the same for SQLite and the mobile environment.
    Remember when the app is released; ensure that SQLite is built in with some basic
    data for the user to start. Ensure that the data can be dynamically populated
    easily. This will form a part of a great data access strategy and format, which
    should be replicated across all of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned previously, security to your data is mandatory, and requirements
    around privacy and access, including a form of encryption, must be considered
    to protect information.
  prefs: []
  type: TYPE_NORMAL
- en: Another important factor in designing a good database for SQLite is the performance
    and the ability of the software to work efficiently and quickly among the operating
    system on a small device and app that has more demands on it today.
  prefs: []
  type: TYPE_NORMAL
- en: Testing both, manual and automatic, using products such as **Appium** for mobiles,
    is a must, because it can find out relevant bugs, issues, and problems, that manual
    testing may not have uncovered. The usage of SQLite in your application can be
    as complicated or as simple as you require, and the freedom and accessibility
    of code and experts are plentiful, to ensure that your app delivers what it sets
    out to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to design a database system for an application
    using SQLite. You learned the details of how to approach the design and outline
    certain concepts. The next chapter will show you how to administer an SQLite database
    and make use of this functionality.
  prefs: []
  type: TYPE_NORMAL
