- en: Introduction to Android System Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android系统编程简介
- en: 'This book is about Android system programming. In this chapter, we will start
    with a discussion on system programming and the scope of Android system programming
    (to give a high-level view of this book). After that, we will look at the Android
    system architecture. From the architecture, we can see the layers that we will
    focus on in this book. We will also talk about the virtual hardware platforms
    and third-party open source projects that we will use in this book. In summary,
    we will cover the following topics in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是关于Android系统编程的。在本章中，我们将从对系统编程和Android系统编程范围的讨论开始（以给出本书的高级概述）。之后，我们将查看Android系统架构。从架构中，我们可以看到本书将关注的层次。我们还将讨论本书中将使用的虚拟硬件平台和第三方开源项目。总之，本章将涵盖以下主题：
- en: Introduction to Android system programming
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android系统编程简介
- en: Overview of the Android system architecture
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android系统架构概述
- en: Introduction to the third-party projects used in this book
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本书所使用的第三方项目简介
- en: Introduction to virtual hardware platforms
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虚拟硬件平台简介
- en: What is system programming?
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是系统编程？
- en: 'When we talk about what system programming is, we can start with the definition
    of system programming in Wikipedia:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论什么是系统编程时，我们可以从维基百科中系统编程的定义开始：
- en: '"System programming (or systems programming) is the activity of programming
    system software. The primary distinguishing characteristic of systems programming
    when compared to application programming is that application programming aims
    to produce software which provides services to the user (e.g. word processor),
    whereas systems programming aims to produce software and software platforms which
    provide services to other software, are performance constrained, or both (e.g.
    operating systems, computational science applications, game engines and AAA video
    games, industrial automation, and software as a service applications). "'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '"系统编程（或系统软件编程）是指编写系统软件的活动。与应用编程相比，系统编程的主要区别特征在于，应用编程旨在产生为用户提供服务的软件（例如文字处理器），而系统编程旨在产生为其他软件提供服务的软件和软件平台，这些软件和平台受性能限制，或者两者兼而有之（例如操作系统、计算科学应用、游戏引擎和AAA级视频游戏、工业自动化以及软件即服务应用）。"'
- en: From the preceding definition, we can see that when we talk about system programming
    we actually deal with the building blocks of the computer system itself. We may
    depict the system architecture and how it looks like inside the system. As an
    example, we can refer to system programming books for Windows or Linux. The book
    *Linux System Programming* published by O'Reilly Media, Inc. includes topics about
    f*ile I/O*, *process management*, *memory management*, *interrupt handling*, and
    so on. There is another book called *Windows System Programming* published by
    Addison-Wesley Professional that includes very similar topics to its Linux counterpart.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的定义中，我们可以看出，当我们谈论系统编程时，我们实际上是在处理计算机系统本身的构建块。我们可以描述系统架构及其在系统内部的外观。例如，我们可以参考关于Windows或Linux的系统编程书籍。由O'Reilly
    Media, Inc.出版的《Linux系统编程》一书包括关于文件I/O、进程管理、内存管理、中断处理等内容。还有一本名为《Windows系统编程》的书，由Addison-Wesley
    Professional出版，其内容与Linux版本非常相似。
- en: You may expect similar content in this book for Android, but you will find that
    the topics in this book are quite different from the classic system programming
    book. First of all, it doesn't really make sense to have a system programming
    book for Android talk about file I/O, process management, or memory management,
    because the *Linux System Programming* book can cover almost the same topics for
    Android (Android uses Linux kernels and device driver models).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能期望在这本书中看到类似的内容，但您会发现本书中的主题与经典的系统编程书籍相当不同。首先，为Android编写系统编程书籍讨论文件I/O、进程管理或内存管理并没有太多意义，因为《Linux系统编程》一书几乎可以涵盖Android的相同主题（Android使用Linux内核和设备驱动模型）。
- en: When you want to explore kernel space system programming, you can read books
    such as *Linux Device Drivers* by O'Reilly or *Essential Linux Device Drivers*
    from Prentice Hall. When you want to explore user space system programming, you
    can read the book that I mentioned before, *Linux System Programming* by O'Reilly.
    Then you may wonder, Do we need an *Android System Programming* book in this case?
    To answer this question, it depends on how we look at system programming for Android.
    Or in other words, it depends on which angle we look at *Android System Programming*
    from. We can tell people different things about the same world from different
    perspectives. In that sense, we may need more than one book to talk about Android
    system programming.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想探索内核空间系统编程时，你可以阅读O'Reilly的《Linux设备驱动程序》或Prentice Hall的《Essential Linux Device
    Drivers》等书籍。当你想探索用户空间系统编程时，你可以阅读我之前提到的书籍，O'Reilly的《Linux系统编程》。然后你可能想知道，在这种情况下，我们需要一本《Android系统编程》的书吗？为了回答这个问题，这取决于我们如何看待Android的系统编程。或者换句话说，这取决于我们从哪个角度看待*Android系统编程*。我们可以从不同的视角对同一个世界讲述不同的事情。从这个意义上讲，我们可能需要不止一本书来讨论Android系统编程。
- en: To talk about Android system programming, we can talk about it theoretically
    or practically. In this book, we will do it practically with a few actual projects
    and hands-on examples. Our focus will be how to customize the Android system and
    how to port it to a new platform.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要谈论Android系统编程，我们可以从理论上或实践上进行讨论。在这本书中，我们将通过几个实际项目和动手实例来实践。我们的重点是定制Android系统以及如何将其移植到新的平台。
- en: What is the scope of this book?
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 这本书的范围是什么？
- en: 'As we know, there are two kinds of programming for Android: application programming
    and system programming.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Android有两种编程类型：应用编程和系统编程。
- en: Usually, it is hard to draw a line between system programming and application
    programming, especially for C language-based operating systems, such as Linux
    and all kinds of Unix system. With the Android framework, the application layer
    is separated nicely from the rest of the system. You may know that Android application
    programming uses the Java language and Android system programming using Java,
    C/C++, or assembly languages. To make it simple, we can treat everything other
    than application programming in the Android world as the scope of system programming.
    In this sense, the Android framework is also in the scope of system programming.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，很难在系统编程和应用编程之间划清界限，尤其是在基于C语言的操作系统，如Linux和各种Unix系统。在Android框架中，应用层与系统其他部分被很好地分离。你可能知道，Android应用编程使用Java语言，而Android系统编程则使用Java、C/C++或汇编语言。为了简化，我们可以将Android世界中除了应用编程之外的所有内容视为系统编程的范畴。从这个意义上讲，Android框架也属于系统编程的范畴。
- en: From the perspective of the audiences of this book, they may want to learn more
    about the layers they may touch on in their project work. The Android framework
    is a layer that will be changed by Google only in most cases. From this point
    of view, we won't spend too much time talking about the framework itself. Instead,
    we will focus on how to port the system including the Android framework from the
    standard platforms in **Android Open Source Project** (**AOSP**) to other platforms.
    We will focus on the layers that need to be changed during the porting process
    in this book.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从本书读者的角度来看，他们可能想了解他们在项目工作中可能触及的层次。Android框架是Google在大多数情况下唯一会更改的层次。从这个角度来看，我们不会花太多时间讨论框架本身。相反，我们将专注于如何将包括Android框架在内的系统从**Android开源项目**（**AOSP**）的标准平台移植到其他平台。在这本书中，我们将重点关注移植过程中需要更改的层次。
- en: After we have done the porting work, a new Android system will be available.
    One thing that we need to do for the new system is deliver the changes for the
    new system to the end users from time to time. It could be a major system update
    or bug fixing. This is supported by **over-the-air** (**OTA**) updates in Android.
    This is also one of the topics in this book.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成移植工作后，将有一个新的Android系统可用。对于这个新系统，我们需要做的一件事是，不时地将新系统的更改传递给最终用户。这可能是一次重大的系统更新或错误修复。这由Android中的**空中**（**OTA**）更新支持。这也是本书的一个主题。
- en: Traditionally, all Unix programming was system-level programming. Unix or Linux
    programming is built around three cornerstones, which are system calls, the C
    library, and the C compiler. This is true for Android system programming as well.
    On top of the system calls and C library, Android has an additional layer of abstraction
    for the Android application level. This is the Android framework and Java virtual
    machine.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，所有Unix编程都是系统级编程。Unix或Linux编程是围绕三个基石构建的，即系统调用、C库和C编译器。Android系统编程也是如此。在系统调用和C库之上，Android为Android应用级别提供了一个额外的抽象层。这就是Android框架和Java虚拟机。
- en: In that sense, most Android applications are built using Android SDK and Java
    language. You may be wondering whether it is possible to do Android application
    development using C/C++ or even do system level programming using Java. Yes, all
    these are possible. Besides Android SDK, we can also develop native applications
    using Android NDK. There are also a lot of Android framework components developed
    using the Java language. We can even develop Android applications using C# with
    Visual Studio (Xamarin). However, we won't go to that kind of complexity in this
    book. We will focus on the layers below the application framework. Again, the
    focus will be on customizing and extending the existing system or porting the
    entire system to a new hardware platform.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个意义上讲，大多数Android应用程序都是使用Android SDK和Java语言构建的。你可能想知道是否可以使用C/C++或甚至使用Java进行系统级编程。是的，所有这些都是可能的。除了Android
    SDK之外，我们还可以使用Android NDK开发本地应用程序。还有许多使用Java语言开发的Android框架组件。我们甚至可以使用Visual Studio（Xamarin）用C#开发Android应用程序。然而，本书不会涉及这种复杂性。我们将专注于应用框架之下的层次。再次强调，重点是定制和扩展现有系统，或者将整个系统移植到新的硬件平台。
- en: The reason why we will focus on the porting of Android systems and the customization
    of Android systems is because these are what most people working on the Android
    system level will do. After Google releases a new version of Android, silicon
    vendors need to port the new version to their reference platform. When OEM/ODM
    companies get the reference platform, they have to customize the reference platform
    to their products. The customization includes the build of the initial system
    itself and the deployment of the updates to the deployed system. In the first
    part of this book, we will discuss the porting of Android systems. In the second
    part of this book, we will discuss how to update the existing system.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重点关注Android系统的移植和定制，因为这些是大多数从事Android系统级工作的人会做的事情。在谷歌发布Android新版本后，芯片供应商需要将其移植到他们的参考平台上。当OEM/ODM公司获得参考平台时，他们必须将其定制为自己的产品。定制包括构建初始系统本身以及部署到部署系统的更新。本书的第一部分将讨论Android系统的移植。本书的第二部分将讨论如何更新现有系统。
- en: If we consider the architecture of Android in the right-hand side of the following
    figure, we can see that most porting work will focus on the **Kernel** and **Hardware
    Abstraction Layer** (**HAL**) in the Android system architecture. This is true
    for other Android derivatives as well. The knowledge and concepts in this book
    can apply to Android wearables and Brillo as well. The left-hand side of the following
    figure, it shows the architecture diagram of **Brillo**. **Brillo** is the IoT
    operating system from Google for IoT devices. It is a simpler and smaller version
    of Android for IoT devices. However, the porting layer is still the same as Android.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们考虑以下图中右侧的Android架构，我们可以看到大部分移植工作将集中在Android系统架构中的**内核**和**硬件抽象层（HAL**）上。这对其他Android衍生版本也是如此。本书中的知识和概念也适用于Android可穿戴设备和Brillo。以下图的左侧显示了**Brillo**的架构图。**Brillo**是谷歌为物联网设备提供的物联网操作系统。它是Android物联网设备的简化版和较小版本。然而，移植层与Android相同。
- en: '![](img/6099_01_01.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6099_01_01.png)'
- en: Comparison of Android and Brillo system architecture
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Android与Brillo系统架构比较
- en: The Brillo/Weave architecture diagram on the left-hand side is created by referring
    to the presentation by Bruce Beare, from OpenIoT Summit. Thanks, Bruce Beare for
    the great presentation and video on YouTube, which gives a very comprehensive
    introduction to the Brillo/Weave architecture.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的Brillo/Weave架构图是根据OpenIoT Summit上布鲁斯·比尔的演示制作的。感谢布鲁斯·比尔提供的精彩演示和YouTube上的视频，它对Brillo/Weave架构进行了非常全面的介绍。
- en: Overview of the Android system
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android系统概述
- en: As we can see from the architecture diagram, the architecture layers of Android
    include **Application Framework**, **Android System Services**, **HAL**, and **Kernel**.
    Binder IPC is used as a mechanism for inter-process communication. We will cover
    each of them in this section. Since recovery is also part of the system programming
    scope, we will also give an overview of recovery in this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从架构图中可以看到，Android的架构层包括**应用程序框架**、**Android系统服务**、**HAL**和**内核**。Binder IPC用作进程间通信的机制。我们将在本节中介绍它们。由于恢复也是系统编程范围的一部分，我们还将在本节中概述恢复。
- en: 'You can find more information about key porting layers and system architecture
    internals at the following Google website:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在以下谷歌网站上找到有关关键移植层和系统架构内部信息的更多信息：
- en: '[http://source.android.com/devices/index.html](http://source.android.com/devices/index.html)'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://source.android.com/devices/index.html](http://source.android.com/devices/index.html)'
- en: Kernel
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内核
- en: As we know, Android uses the Linux kernel. Linux was developed by Linus Torvalds
    in 1991\. The current Linux kernel is maintained by the Linux Kernel Organization
    Inc. The latest mainline kernel releases can be found at [https://www.kernel.org](https://www.kernel.org).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Android使用Linux内核。Linux是由Linus Torvalds在1991年开发的。当前的Linux内核由Linux Kernel
    Organization Inc.维护。最新的主线内核发布可以在[https://www.kernel.org](https://www.kernel.org)找到。
- en: 'Android uses a slightly customized Linux kernel. The following is a concise
    list of the changes to the Linux kernel:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Android使用略微定制的Linux内核。以下是Linux内核更改的简要列表：
- en: '**ashmem (Android Shared Memory)**: A file-based shared memory system to user
    space'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ashmem（Android共享内存）**：一个基于文件的共享内存系统，用于用户空间'
- en: '**Binder**: An **interprocess communication** (**IPC**) and **remote procedure
    call** (**RPC**) system'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Binder**：一个**进程间通信**（IPC）和**远程过程调用**（RPC）系统'
- en: '**logger**: A high-speed in-kernel logging mechanism optimized for writes'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**logger**：一个针对写入进行优化的高速内核日志机制'
- en: '**paranoid networking**: A mechanism to restrict network I/O to certain processes'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**paranoid networking**：一种限制网络I/O到某些进程的机制'
- en: '**pmem (physical memory)**: A driver for mapping large chunks of physical memory
    into user space'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pmem（物理内存）**：一个将大块物理内存映射到用户空间的驱动程序'
- en: '**Viking Killer**: A replacement OOM killer that implements Android''s "kill
    least recently used process" logic under low-memory conditions'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Viking Killer**：一个替换的OOM杀手，在低内存条件下实现了Android的“杀死最近最少使用进程”逻辑'
- en: '**wakelocks**: Android''s unique power management solution, in which the default
    state of the device is sleep and explicit action is required (via a wakelock)
    to prevent that'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**wakelocks**：Android独特的电源管理解决方案，其中设备的默认状态是睡眠，需要显式操作（通过wakelock）来防止设备进入睡眠状态'
- en: Most of the changes were implemented as device drivers with little or no changes
    necessary to the core kernel code. The only significant subsystem-spanning change
    is wakelocks.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数更改都作为设备驱动程序实现，对核心内核代码的更改很少或没有。唯一显著的跨子系统更改是wakelocks。
- en: There are many Android patches accepted by the mainline Linux kernel today.
    The mainline kernel can even boot up Android directly. There is a blog from Linaro
    about how to boot Nexus 7 running a mainline kernel. If you want to try it, you
    can find the instructions at [https://wiki.linaro.org/LMG/Kernel/FormFactorEnablement](https://wiki.linaro.org/LMG/Kernel/FormFactorEnablement).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，许多Android补丁被主线Linux内核接受。主线内核甚至可以直接启动Android。关于如何在运行主线内核的Nexus 7上启动的Linaro博客，你可以找到说明在[https://wiki.linaro.org/LMG/Kernel/FormFactorEnablement](https://wiki.linaro.org/LMG/Kernel/FormFactorEnablement)。
- en: If a Linux device driver is available for a hardware device, it usually can
    work on Android as well. The development of device drivers is the same as the
    development of a typical Linux device driver. If you want to find out the merges
    on the mainline kernel related to Android, you can check the kernel release notes
    at [https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果某个硬件设备的Linux设备驱动程序可用，它通常也可以在Android上工作。设备驱动程序的开发与典型Linux设备驱动程序的开发相同。如果你想了解与Android相关的主线内核合并，你可以查看内核发布说明[https://kernelnewbies.org/LinuxVersions](https://kernelnewbies.org/LinuxVersions)。
- en: The Android kernel source code is usually provided by SoC vendors, such as Qualcomm
    or MTK. The kernel source code for Google devices can be found at [https://android.googlesource.com/kernel/](https://android.googlesource.com/kernel/).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Android内核源代码通常由SoC供应商提供，例如高通或MTK。Google设备的内核源代码可以在[https://android.googlesource.com/kernel/](https://android.googlesource.com/kernel/)找到。
- en: Google devices use SoC from various vendors so that you can find kernel source
    code from different vendors here. For example, the kernel source of QualComm SoC
    is under `kernel/msm` and the kernel source of Mediatek is under `kernel/mediatek`.
    The general Android kernel source code is in the folder `kernel/common`, which
    looks much like the Vanilla kernel.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Google设备使用来自不同供应商的SoC，因此您可以在不同供应商这里找到内核源代码。例如，QualComm SoC的内核源代码位于`kernel/msm`，MediaTek的内核源代码位于`kernel/mediatek`。一般的Android内核源代码在`kernel/common`文件夹中，看起来与Vanilla内核非常相似。
- en: The default build of AOSP is for various devices from Google, such as Nexus
    or Pixel. It started to include some reference boards from silicon vendors as
    well recently, such as `hikey-linaro`, and so on. If you need a vendor-specific
    Android kernel for your reference platform, you should get the kernel source code
    from your platform vendors.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: AOSP的默认构建版本适用于谷歌的各种设备，例如Nexus或Pixel。最近它也开始包含一些来自硅供应商的参考板，例如`hikey-linaro`等。如果您需要针对您的参考平台的特定供应商的Android内核，您应该从您的平台供应商那里获取内核源代码。
- en: There are also open source communities maintaining Android kernels. For example,
    the kernel for the ARM architecture can be found at Linaro for many reference
    boards. For Intel x86 architecture, you can find various versions of kernels in
    the Android-x86 project. As you can see from the following Linaro Linux Kernel
    status website, the `linaro-android` tree is a forward port of the out-of-tree
    AOSP patches. It provides a preview of what Google's next AOSP `kernel/common.git`
    tree "might" look like.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，还有开源社区在维护Android内核。例如，ARM架构的内核可以在Linaro的许多参考板上找到。对于Intel x86架构，您可以在Android-x86项目中找到各种内核版本。正如您可以从以下Linaro
    Linux内核状态网站上看到的那样，`linaro-android`树是树外AOSP补丁的前向移植。它提供了Google下一个AOSP `kernel/common.git`树“可能”看起来是什么样的预览。
- en: The Linaro Android kernel tree can be found at [https://android.git.linaro.org/gitweb/kernel/linaro-android.git](https://android.git.linaro.org/gitweb/kernel/linaro-android.git).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: Linaro的Android内核树可以在[https://android.git.linaro.org/gitweb/kernel/linaro-android.git](https://android.git.linaro.org/gitweb/kernel/linaro-android.git)找到。
- en: The status of this kernel tree can be seen at [https://wiki.linaro.org/LMG/Kernel/Upstreaming](https://wiki.linaro.org/LMG/Kernel/Upstreaming).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 该内核树的状态可以在[https://wiki.linaro.org/LMG/Kernel/Upstreaming](https://wiki.linaro.org/LMG/Kernel/Upstreaming)查看。
- en: HAL
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HAL
- en: HAL defines a standard interface for hardware vendors to implement and allows
    Android to be agnostic about lower-level driver implementations. HAL allows you
    to implement functionality without affecting or modifying the higher level system.
    HAL implementations are packaged into module (`.so`) files and loaded by the Android
    system at the appropriate time. This is one of the focuses for porting Android
    systems to a new platform. We will discover more about HAL in [Chapter 3](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml),
    *Discovering Kernel, HAL, and Virtual Hardware*. Throughout this book, I will
    give a very detailed analysis of the HAL layer for various hardware interfaces.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: HAL为硬件供应商定义了一个标准接口，允许Android对底层驱动实现保持无知。HAL允许您在不影响或修改高级系统的情况下实现功能。HAL实现被打包成模块（`.so`）文件，并在适当的时候由Android系统加载。这是将Android系统移植到新平台的一个重点。我们将在[第3章](e0f861c2-5832-402f-89d3-cfc75785e759.xhtml)“发现内核、HAL和虚拟硬件”中了解更多关于HAL的内容。在这本书中，我将详细分析各种硬件接口的HAL层。
- en: Android system services
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android系统服务
- en: Functionality exposed by application framework APIs communicates with system
    services to access the underlying hardware. There are two groups of services that
    application developers may interact mostly with. They are **system** (services
    such as window manager and notification manager) and **media** (services involved
    in playing and recording media). These are the services that provide application
    interfaces as part of the Android framework.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 应用框架API公开的功能与系统服务通信，以访问底层硬件。应用开发者可能主要交互的两个服务组是**系统**（如窗口管理器和通知管理器）和**媒体**（涉及播放和录制媒体的服务）。这些服务是作为Android框架的一部分提供应用程序接口的。
- en: Besides these services, there are also native services supporting these system
    services, such as SurfaceFlinger, netd, logcatd, rild, and so on. Many of them
    are very similar to Linux daemons that you may find in a Linux distribution. In
    a complicated hardware module, such as graphic, both system services and native
    services need to access HAL in order to provide the framework API to the application
    layer. We will talk about system services when we debug the init process in [Chapter
    6](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml), *Enabling Wi-Fi on the Android
    Emulator* to Chapter 9, *Booting Up x86vbox Using PXE/NFS*.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些服务之外，还有支持这些系统服务的本地服务，例如SurfaceFlinger、netd、logcatd、rild等等。许多服务与您可能在Linux发行版中找到的Linux守护进程非常相似。在复杂的硬件模块中，例如图形，系统服务和本地服务都需要访问HAL，以便向应用层提供框架API。我们将在[第6章](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml)，*在Android模拟器上启用Wi-Fi*到[第9章](7ff9a111-96cb-44ed-b92d-435e73821306.xhtml)，*使用PXE/NFS启动x86vbox*时讨论系统服务。
- en: Binder IPC
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Binder IPC
- en: The Binder IPC mechanism allows the application framework to cross process boundaries
    and call into the Android system services code. This enables high-level framework
    APIs to interact with Android system services. An Android application usually
    runs in its own process space. It doesn't have the ability to access system resources
    or the underlying hardware directly. It has to talk to system services through
    Binder IPC to access the system resource. Since applications and system services
    run in different processes, the Binder IPC provides a mechanism for this purpose.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Binder IPC机制允许应用框架跨越进程边界并调用Android系统服务代码。这使得高级框架API能够与Android系统服务交互。Android应用程序通常在其自己的进程空间中运行。它没有直接访问系统资源或底层硬件的能力。它必须通过Binder
    IPC与系统服务通信来访问系统资源。由于应用程序和系统服务运行在不同的进程中，Binder IPC为此提供了机制。
- en: The Binder IPC proxies are the channel by which the application framework can
    access system services in different process spaces. It does not mean it is a layer
    between the application framework and system services. Binder IPC is the inter-process
    communication mechanism that can be used by any process that wants to talk to
    another process. For example, system services can use Binder IPC to talk to each
    other as well.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Binder IPC代理是应用框架访问不同进程空间中系统服务的渠道。这并不意味着它是应用框架和系统服务之间的一个层。Binder IPC是任何想要与其他进程通信的进程都可以使用的进程间通信机制。例如，系统服务可以使用Binder
    IPC相互通信。
- en: Application framework
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用框架
- en: The application framework provides APIs to the applications. It is used most
    often by application developers. After an interface is invoked by the applications,
    application frameworks talk to the system services through the Binder IPC mechanism.
    An Android application framework is not just a set of libraries for the application
    developers to use. It provides much more than that.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 应用框架为应用程序提供API。它通常被应用程序开发者使用。当应用程序调用一个接口后，应用框架通过Binder IPC机制与系统服务进行通信。Android应用框架不仅仅是一组供应用开发者使用的库。它提供了比这更多的功能。
- en: The break-through technology that the Android application framework brought
    to the developer community is a very nice separation between application layers
    and system layers. As we know Android application development uses the Java language
    and Android applications run in an environment similar to the Java virtual machine.
    In this kind of setup, the application layer is separated from the system layer
    very clearly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用框架带给开发社区的突破性技术是应用层和系统层之间一个非常清晰的分离。正如我们所知，Android应用开发使用Java语言，Android应用程序在类似于Java虚拟机的环境中运行。在这种设置中，应用层与系统层被非常清晰地分离。
- en: The Android application framework also provides a unique programming model together
    with a tight integration with the **integrated development environment** (**IDE**)
    from Google. With this programming model and related tools, Android developers
    can work on application development with great efficiency and productivity. All
    these are key reasons why Android has gained so much traction in the mobile device
    world.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用框架还与Google的**集成开发环境**（**IDE**）紧密集成，并提供了一种独特的编程模型。使用这种编程模型和相关工具，Android开发者可以以极高的效率和生产力进行应用开发。所有这些都是Android在移动设备世界中取得巨大成功的关键原因。
- en: I have given an overall introduction to all the layers in the previous Android
    system architecture diagram. As I mentioned about the scope of Android system
    programming before, we can consider all programming in Android systems as within
    the scope of system programming other than application programming. With this
    concept in mind, we actually missed one piece in the previous architecture diagram,
    which is recovery.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经在之前的Android系统架构图中对所有的层进行了整体介绍。正如我之前提到的关于Android系统编程的范围，我们可以将Android系统中的所有编程视为系统编程的范围，而不是应用编程。带着这个概念，我们实际上在之前的架构图中遗漏了一部分，那就是恢复。
- en: Recovery
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 恢复
- en: In this chapter, we want to have a brief look at recovery as well, since we
    have three chapters about it in the second part of this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们还想简要地看看恢复，因为在这本书的第二部分中，我们有三章是关于它的。
- en: Recovery is a tool that can be used to upgrade or reinstall Android systems.
    It is part of the AOSP source code. The source code for recovery can be found
    at `$AOSP/bootable/recovery`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复是一个可以用来升级或重新安装Android系统的工具。它是AOSP源代码的一部分。恢复的源代码可以在`$AOSP/bootable/recovery`找到。
- en: 'The unique point about recovery compared to the other parts of Android is that
    it is a self-contained system by itself. We can look at recovery using the following
    diagram, and compare it to the Android and Brillo architectures that we talked
    about before:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 与Android的其他部分相比，恢复的独特之处在于它本身是一个自包含的系统。我们可以通过以下图示来查看恢复，并将其与我们之前讨论过的Android和Brillo架构进行比较：
- en: '![](img/image_01_002.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_01_002.png)'
- en: Recovery is a separate system from Android that shares the same kernel with
    the Android system that it supports. We can treat it as a mini operating system
    or an embedded application that we can find in many embedded devices. It is a
    dedicated application running on top of the same Linux kernel as Android and it
    performs a single task, which is to update the current Android system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复是一个与Android系统分开的系统，它与它所支持的Android系统共享相同的内核。我们可以将其视为一个迷你操作系统或一个可以在许多嵌入式设备中找到的嵌入式应用程序。它是在与Android相同的Linux内核上运行的专用应用程序，它执行单个任务，即更新当前的Android系统。
- en: 'When the system boots to recovery mode, it boots from a dedicated partition
    in the flash. This partition includes the recovery image that includes a Linux
    kernel and a special ramdisk image. If we look at Nexus 5 partitions, we will
    see the following list:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动到恢复模式时，它从闪存中的专用分区启动。这个分区包括包含Linux内核和特殊ramdisk图像的恢复镜像。如果我们查看Nexus 5分区，我们会看到以下列表：
- en: '[PRE0]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The list includes 29 partitions and recovery partition is one of them. The recovery
    ramdisk of recovery, it has a similar directory structure to the normal ramdisk.
    In the init script of recovery ramdisk, init starts the recovery program and it
    is the main process of the recovery mode. The recovery itself is the same as other
    native daemons in the Android system. The programming for recovery is part of
    the scope of Android system programming. The programming language and debug method
    for recovery is also the same as native Android applications. We will discuss
    this in more depth in the second part of this book.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中包括29个分区，恢复分区是其中之一。恢复ramdisk与正常的ramdisk具有类似的目录结构。在恢复ramdisk的init脚本中，init启动恢复程序，它是恢复模式的主要进程。恢复本身与Android系统中的其他本地守护进程相同。恢复的编程是Android系统编程范围的一部分。恢复的编程语言和调试方法也与原生Android应用程序相同。我们将在本书的第二部分更深入地讨论这个问题。
- en: The third-party open source projects derived from AOSP
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从AOSP派生出的第三方开源项目
- en: As we know, AOSP source code is the major source that we can start to work with
    in system-level programming. Various silicon vendors usually work with Google
    to enable their reference platforms. This is a huge effort and they won't publish
    everything to the world except for their customers. This brings a limitation to
    the open source world. Since the AOSP source code is mainly for Google devices,
    such as emulator, Nexus, or Pixel series, there is no problem for developers who
    use Nexus devices as hardware reference platforms. How about other devices? Manufacturers
    may release the kernel source code for their devices, but nothing else. In the
    open source world, several third-party organizations provide solutions for this
    situation. We will have a brief look at the ones that we used in this book in
    the following sections.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，AOSP 源代码是我们可以从系统级编程开始工作的主要源代码。各种芯片供应商通常与谷歌合作，以启用他们的参考平台。这是一项巨大的努力，他们不会将所有内容都公布于众，除非是他们的客户。这给开源世界带来了限制。由于
    AOSP 源代码主要是为谷歌设备，如模拟器、Nexus 或 Pixel 系列，因此使用 Nexus 设备作为硬件参考平台的开发者没有问题。其他设备呢？制造商可能会发布他们设备的内核源代码，但仅此而已。在开源世界中，几个第三方组织为这种情况提供了解决方案。在接下来的几节中，我们将简要介绍我们在本书中使用的一些解决方案。
- en: LineageOS (CyanogenMod)
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LineageOS (CyanogenMod)
- en: LineageOS is a community providing aftermarket firmware distribution for many
    popular Android devices. It is the successor to the highly popular CyanogenMod.
    If you cannot build the ROM for your devices from AOSP source code, you may look
    at LineageOS source code. Because there are many devices supported by LineageOS,
    many major third-party ROM images are built on top of its predecessor CyanogenMod.
    From the famous MIUI in China to the latest OnePlus device, they all use CyanogenMod
    source code as the base start from. The major contributions of LineageOS/CyanogenMod
    to the open source world are the adaptation of the Linux kernel and HAL to various
    Android devices.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: LineageOS 是一个社区，为许多流行的 Android 设备提供售后固件分发。它是高度受欢迎的 CyanogenMod 的继任者。如果您无法从 AOSP
    源代码为您的设备构建 ROM，您可以考虑 LineageOS 源代码。由于 LineageOS 支持许多设备，许多主要的第三方 ROM 映像都是基于其前身
    CyanogenMod 构建的。从中国的著名 MIUI 到最新的 OnePlus 设备，它们都使用 CyanogenMod 源代码作为基础开始。LineageOS/CyanogenMod
    对开源世界的重大贡献是将 Linux 内核和 HAL 适配到各种 Android 设备。
- en: The source code of LineageOS is maintained in GitHub and you can find it at
    [https://github.com/LineageOS](https://github.com/LineageOS).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: LineageOS 的源代码维护在 GitHub 上，您可以在 [https://github.com/LineageOS](https://github.com/LineageOS)
    找到它。
- en: 'To build LineageOS source code for your device, the overall build process is
    similar to the AOSP build. The key difference is the large number of devices supported
    by LineageOS. For each device, there is a web page to give information about how
    to build for a device. We use Nexus 5 as an example. You can go to the following
    page for detailed information:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要为您的设备构建 LineageOS 源代码，整体构建过程与 AOSP 构建类似。关键区别是 LineageOS 支持的设备数量众多。对于每个设备，都有一个网页提供有关如何为该设备构建的信息。我们以
    Nexus 5 为例。您可以通过以下页面获取详细信息：
- en: '[https://wiki.lineageos.org/devices/hammerhead](https://wiki.lineageos.org/devices/hammerhead)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://wiki.lineageos.org/devices/hammerhead](https://wiki.lineageos.org/devices/hammerhead)'
- en: In the information page, you can find information about how to download the
    ROM image, how to install the image, and how to build the image. There is a build
    guide for devices and we can find the build guide for Nexus 5 at [https://wiki.lineageos.org/devices/hammerhead/build](https://wiki.lineageos.org/devices/hammerhead/build).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在信息页面上，您可以找到有关如何下载 ROM 映像、如何安装映像以及如何构建映像的信息。有一个针对设备的构建指南，我们可以在 [https://wiki.lineageos.org/devices/hammerhead/build](https://wiki.lineageos.org/devices/hammerhead/build)
    找到 Nexus 5 的构建指南。
- en: To build LineageOS for Nexus 5, the two key elements are **Kernel** and **Device.**
    The Kernel includes the Linux kernel and Nexus 5-specific device drivers, while
    the Device includes the major part of the device-specific HAL code. The naming
    convention for both the Kernel and Device folder is `android_kernel/device_{manufacturer}_{code
    name}`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Nexus 5 构建 LineageOS，两个关键元素是 **内核** 和 **设备**。内核包括 Linux 内核和 Nexus 5 特定的设备驱动程序，而设备包括设备特定
    HAL 代码的大部分。内核和设备文件夹的命名规范是 `android_kernel/device_{制造商}_{代号}`。
- en: The code name for Nexus 5 is **hammerhead** and the manufacturer is **lge,**
    which is LG.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 5 的代号为 **hammerhead**，制造商为 **lge**，即 LG。
- en: 'We can find the following two Git repositories for Kernel and Device:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以找到以下两个用于内核和设备的 Git 仓库：
- en: '[https://github.com/LineageOS/android_kernel_lge_hammerhead](https://github.com/LineageOS/android_kernel_lge_hammerhead)'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/LineageOS/android_kernel_lge_hammerhead](https://github.com/LineageOS/android_kernel_lge_hammerhead)'
- en: '[https://github.com/LineageOS/android_device_lge_hammerhead](https://github.com/LineageOS/android_device_lge_hammerhead)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/LineageOS/android_device_lge_hammerhead](https://github.com/LineageOS/android_device_lge_hammerhead)'
- en: Other than the Kernel and Device, other important information is the LineageOS
    version. You may find it on the same device information page. For Nexus 5, the
    versions that can be used are 11, 12, 12.1, 13, and 14.1\. You may be wondering
    how to match LineageOS versions to AOSP versions.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了内核和设备之外，其他重要信息是 LineageOS 版本。你可以在同一设备信息页面上找到它。对于 Nexus 5，可用的版本有 11、12、12.1、13
    和 14.1。你可能想知道如何将 LineageOS 版本与 AOSP 版本匹配。
- en: 'The information can be found at the following two pages at Wikipedia about
    CyanogenMod and LineageOS:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 CyanogenMod 和 LineageOS 的信息可以在以下两个维基百科页面上找到：
- en: '[https://en.wikipedia.org/wiki/CyanogenMod#Version_history](https://en.wikipedia.org/wiki/CyanogenMod#Version_history)'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/CyanogenMod#Version_history](https://en.wikipedia.org/wiki/CyanogenMod#Version_history)'
- en: '[https://en.wikipedia.org/wiki/LineageOS#Version_history](https://en.wikipedia.org/wiki/LineageOS#Version_history)'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://en.wikipedia.org/wiki/LineageOS#Version_history](https://en.wikipedia.org/wiki/LineageOS#Version_history)'
- en: The LineageOS/CyanogenMod and AOSP versions supported for Nexus 5 are CM11 (Android
    4.4), CM 12 (Android 5.0), CM 12.1 (Android 5.1), CM 13 (Android 6.0), and CM
    14.1 (Android 7.1.1).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Nexus 5 支持的 LineageOS/CyanogenMod 和 AOSP 版本是 CM11 (Android 4.4)、CM 12 (Android
    5.0)、CM 12.1 (Android 5.1)、CM 13 (Android 6.0) 和 CM 14.1 (Android 7.1.1)。
- en: 'You will not be able to access the links related to CyanogenMod while you read
    this book, since the infrastructure behind CyanogenMod has been shut down recently.
    You can read the following post to find out more:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读这本书的过程中，你将无法访问与 CyanogenMod 相关的链接，因为最近 CyanogenMod 背后的基础设施已经关闭。你可以阅读以下帖子以获取更多信息：
- en: '[https://plus.google.com/+CyanogenMod/posts/RYBfQ9rTjEH](https://plus.google.com/+CyanogenMod/posts/RYBfQ9rTjEH)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://plus.google.com/+CyanogenMod/posts/RYBfQ9rTjEH](https://plus.google.com/+CyanogenMod/posts/RYBfQ9rTjEH)'
- en: Nevertheless, the idea from the preceding configuration is that the key pieces
    of code to differentiate one device from another are the Kernel and Device. It
    is possible to share the rest of the code across devices. This is one of the goals
    for the projects in this book. We try to keep the changes for different hardware
    platforms within the Kernel and the Device, while keeping the rest of the AOSP
    source code untouched. This is not 100% possible, but we can try to do it as much
    as possible. The benefit is that we can keep our code separated from AOSP code
    and it is much easier to update to a new AOSP version.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，前述配置中的想法是，区分不同设备的关键代码是内核和设备。有可能在设备之间共享其余的代码。这是本书中项目的一个目标。我们试图将不同硬件平台的更改限制在内核和设备中，同时保持其余的
    AOSP 源代码不变。这并非 100% 可能，但我们尽可能尝试这样做。好处是我们可以将我们的代码与 AOSP 代码分开，并且更新到新 AOSP 版本要容易得多。
- en: Android-x86
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android-x86
- en: While LineageOS/CyanogenMod provides excellent support for a large number of
    Android devices, many of these devices are ARM-based devices from various silicon
    vendors, such as Qualcomm, Samsung, MTK, and so on. Similarly, there is an open
    source community for Intel-based Android devices as well. This is another famous
    open source project, Android-x86\. Even though the number of Intel x86-based Android
    devices on the market cannot compare to the number of ARM-based devices, there
    is another market using the Intel x86 Android build extensively. This is the Android
    emulator market. For commercial Android emulator products, you can find AMI DuOS,
    Genymotion, Andy, and so on.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 LineageOS/CyanogenMod 为大量 Android 设备提供了出色的支持，但这些设备中的许多都是来自各种硅供应商的 ARM 架构设备，例如高通、三星、MTK
    等。同样，也有针对基于 Intel 的 Android 设备的开源社区。这是另一个著名的开源项目，Android-x86。尽管市场上基于 Intel x86
    的 Android 设备数量无法与 ARM 架构设备相比，但还有另一个市场广泛使用 Intel x86 Android 构建，那就是 Android 模拟器市场。对于商业
    Android 模拟器产品，你可以找到 AMI DuOS、Genymotion、Andy 等等。
- en: The project Android-x86 uses a very different approach to support various Intel
    x86-based devices compared to LineageOS/CyanogenMod. Its goal is to provide **Board
    Support Package** (**BSP**) for any Intel x86 devices. It is similar to how you
    install Microsoft Windows or Linux on your PC. You have only one copy of the release
    and you can install it on any Intel PCs. There is no special build of Windows
    or Linux for each different PC or laptop.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与LineageOS/CyanogenMod相比，Android-x86项目在支持各种基于Intel x86的设备时采用了非常不同的方法。其目标是为任何Intel
    x86设备提供**板级支持包**（**BSP**）。这类似于您在PC上安装Microsoft Windows或Linux的方式。您只有一份发布版本，可以在任何Intel
    PC上安装。没有为每个不同的PC或笔记本电脑专门构建的Windows或Linux版本。
- en: To achieve this goal on Android, Android-x86 customized the Android boot up
    process significantly. There are two stages of boot up process in Android-x86\.
    The first stage is booting up a minimal Linux environment using a special ramdisk--`initrd.img`.
    After the system can boot up to this Linux environment, it starts the second stage
    through the `chroot` or `switch_root` command. In this stage, it will boot up
    the actual Android system.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Android上实现这一目标，Android-x86对Android启动过程进行了显著定制。在Android-x86中，启动过程分为两个阶段。第一阶段是使用特殊的ramdisk--`initrd.img`启动一个最小的Linux环境。当系统可以启动到这个Linux环境时，它将通过`chroot`或`switch_root`命令启动第二阶段。在这个阶段，它将启动实际的Android系统。
- en: This is a very smart way to resolve the new challenge using existing technology.
    Essentially, we try to resolve the problem in two steps. In the first stage of
    the boot up process, since both Windows and Linux can boot on Intel x86 PCs without
    a dedicated build, you should be able to boot Linux on an Intel device without
    too much effort. This is exactly what the first stage of Android-x86 boot up does.
    After the minimal Linux system can run properly, this means the minimum set of
    hardware devices is initialized and you are able to debug or boot the rest of
    the system using this minimal Linux environment. In the second stage, a common
    Android image for Intel x86 can be started with limited hardware initialization.
    This approach can be used in the debugging of hardware devices as well. We will
    show how we can do the same thing on the Android emulator in this book.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种非常聪明的利用现有技术解决新挑战的方法。本质上，我们试图分两步解决问题。在启动过程的第一个阶段，由于Windows和Linux都可以在没有专用构建的情况下在Intel
    x86 PC上启动，您应该能够不太费力地在Intel设备上启动Linux。这正是Android-x86启动的第一个阶段所做的事情。当最小的Linux系统可以正常运行时，这意味着最小的一组硬件设备已经初始化，您可以使用这个最小的Linux环境来调试或启动系统的其余部分。在第二阶段，可以启动一个适用于Intel
    x86的通用Android镜像，并且只需要有限的硬件初始化。这种方法也可以用于硬件设备的调试。本书将展示我们如何在Android模拟器上做同样的事情。
- en: The official website of the Android-x86 project is [http://www.android-x86.org/](http://www.android-x86.org/).
    You can find the information about the Android-x86 project there. To build Android-x86,
    it is a little tricky to get the source code. The original source code was hosted
    at `http://git.android-x86.org` and it was maintained by volunteers from **Taiwan
    Linux User Group** (**TLUG**). It was valid for several years. However, it ceased
    to work from April 2015.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Android-x86项目的官方网站是[http://www.android-x86.org/](http://www.android-x86.org/)。您可以在那里找到关于Android-x86项目的相关信息。要构建Android-x86，获取源代码稍微有些棘手。原始源代码托管在`http://git.android-x86.org`，由**台湾Linux用户组**（**TLUG**）的志愿者维护。它有效了几年。然而，从2015年4月起，它就不再工作了。
- en: You can always find the latest status from the Google discussion group at [https://groups.google.com/forum/#!forum/android-x86](https://groups.google.com/forum/#!forum/android-x86).
    There is an official announcement about the issue of `git.android-x86.org` at
    the discussion group from the maintainer Chih-Wei Huang. Later, the hosting was
    moved to SourceForge for a short period. However, issues retrieving source code
    from SourceForge have been reported again since July 2016\. Currently, the source
    code is hosted at OSDN and you can search the announcement from Chih-Wei Huang
    on September 8, 2016 at the Android-x86 discussion group. Since most open source
    projects are maintained by volunteers, they may be up and down from time to time.
    It is always good to keep your own mirror of the projects that you work on. We
    will discuss this issue in this book as well so that you can have full control
    of your own work.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Google讨论组[https://groups.google.com/forum/#!forum/android-x86](https://groups.google.com/forum/#!forum/android-x86)中找到最新的状态。讨论组中有一个关于`git.android-x86.org`问题的官方公告，由维护者Chih-Wei
    Huang发布。后来，托管被短暂地移至SourceForge。然而，自2016年7月以来，又报告了从SourceForge检索源代码的问题。目前，源代码托管在OSDN上，你可以在Android-x86讨论组中搜索Chih-Wei
    Huang于2016年9月8日发布的公告。由于大多数开源项目都是由志愿者维护的，它们可能会不时地上线或下线。始终保留你正在工作的项目自己的镜像是个好主意。我们将在本书中讨论这个问题，以便你可以完全控制自己的工作。
- en: We know that many open source projects are related to each other and this is
    true for both Android-x86 and LineageOS/CyanogenMod as well. Starting from January
    2016, Jaap Jan Meijer did the initial porting of CyanogenMod to Android-x86 and
    this makes CyanogenMod available on most Intel devices. If you are interested
    in this topic, you can search for `CM porting plan` in the Android-x86 discussion
    group.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道许多开源项目之间相互关联，Android-x86和LineageOS/CyanogenMod也是如此。从2016年1月开始，Jaap Jan Meijer对CyanogenMod进行了初始移植到Android-x86，这使得CyanogenMod可以在大多数英特尔设备上使用。如果你对这个话题感兴趣，你可以在Android-x86讨论组中搜索`CM移植计划`。
- en: CWM/CMR/TWRP
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CWM/CMR/TWRP
- en: As a part of system-level programming, we introduced recovery in the previous
    section. The original recovery from AOSP only supports very limited functionalities
    so there are many third-party recovery projects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 作为系统级编程的一部分，我们在上一节中介绍了恢复功能。AOSP的原始恢复功能仅支持非常有限的功能，因此有许多第三方恢复项目。
- en: '**ClockworkMod recovery** (**CWM**) is one of the famous open source recovery
    projects, written by Koushik Dutta. Even though many people still use ClockworkMod
    recovery now, this project ceased development some time ago.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**ClockworkMod恢复**（**CWM**）是著名的开源恢复项目之一，由Koushik Dutta编写。尽管现在许多人仍然使用ClockworkMod恢复，但该项目已经停止开发一段时间了。'
- en: Another recovery project is **CyanogenMod recovery** (**CMR**). CMR is maintained
    by the CyanogenMod team and it is quite similar to ClockworkMod recovery.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个恢复项目是**CyanogenMod恢复**（**CMR**）。CMR由CyanogenMod团队维护，它与ClockworkMod恢复非常相似。
- en: '**TWRP** or **TeamWin Recovery Project** is another very widely used custom
    recovery. It is fully touch-driven and has one of the most complete feature sets
    available. TWRP is the default recovery of OmniROM and its source code is hosted
    in GitHub as part of OmniROM at [https://github.com/omnirom/android_bootable_recovery/](https://github.com/omnirom/android_bootable_recovery/).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**TWRP**或**TeamWin恢复项目**是另一个非常广泛使用的自定义恢复。它是完全触摸驱动的，并拥有最完整的特性集之一。TWRP是OmniROM的默认恢复，其源代码托管在GitHub上，作为OmniROM的一部分，网址为[https://github.com/omnirom/android_bootable_recovery/](https://github.com/omnirom/android_bootable_recovery/)。'
- en: Strategy of integration
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成策略
- en: In the preceding sections, we talked about Android architecture, AOSP, and third-party
    open source projects for Android. The software industry has been there for decades.
    There are so many existing source codes that can be reused and the need to create
    something from scratch is very rare. The porting and customization for a new platform
    is basically art of integration.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们讨论了Android架构、AOSP以及Android的第三方开源项目。软件行业已经存在了几十年。有如此多的现有源代码可以重用，从头开始创建的需求非常罕见。为新平台进行移植和定制基本上是集成艺术。
- en: In this book, we will use the AOSP source code as the foundation and try to
    build everything on top of it. However, we may not be able to rely on AOSP source
    code only. In fact, we want to demonstrate how to support a platform that is not
    supported by AOSP. How are we going to do this? Do we create something from scratch?
    The answer is no. We will demonstrate how we can integrate all existing projects
    together to create a new platform. That's the reason why we discuss third-party
    open source projects.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用AOSP源代码作为基础，并尝试在其上构建一切。然而，我们可能不能仅依赖于AOSP源代码。实际上，我们想展示如何支持AOSP不支持的平台。我们将如何做到这一点？我们是从头开始创建吗？答案是：不是。我们将演示如何将所有现有项目整合在一起以创建一个新平台。这就是我们讨论第三方开源项目的原因。
- en: In our case, VirtualBox is not supported by AOSP and we are going to enable
    it using AOSP and Android-x86\. We need to use projects from both AOSP and Android-x86
    to build a system for VirtualBox. However, our goal is to create a new build system
    for VirtualBox with minimal changes to the AOSP source code tree. This is also
    the goal of many other projects based on AOSP.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，VirtualBox不受AOSP支持，我们将使用AOSP和Android-x86来启用它。我们需要使用来自AOSP和Android-x86的项目来为VirtualBox构建一个系统。然而，我们的目标是创建一个对AOSP源代码树改动最小的VirtualBox新构建系统。这也是许多基于AOSP的其他项目的目标。
- en: 'Based on the previous understanding, we have four categories of projects in
    our integration process:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的理解，在我们的集成过程中，我们有四个类别的项目：
- en: '**The original unmodified AOSP projects**: In these kinds of projects, we will
    use AOSP projects without any changes.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未经修改的原始AOSP项目**：在这些类型的项目中，我们将使用未经修改的AOSP项目。'
- en: '**The third-party projects**: In this category, the projects are added by the
    third-party projects and are not part of AOSP, so there are no changes involved
    as well.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第三方项目**：在这个类别中，项目是由第三方项目添加的，并且不是AOSP的一部分，因此也没有涉及任何更改。'
- en: '**Projects modified by both AOSP and one of the third-party projects**: This
    is complicated. We need to review the third-party changes and decide whether we
    want to include them in our system or not.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由AOSP和第三方项目共同修改的项目**：这很复杂。我们需要审查第三方更改并决定我们是否希望将它们包含在我们的系统中。'
- en: '**Projects modified by multiple open source projects and AOSP**: This is the
    most complicated case that we should avoid to integrate or change.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由多个开源项目和AOSP修改的项目**：这是我们应尽量避免集成或更改的最复杂情况。'
- en: It is very easy to understand that we should try to reuse projects in category
    1 and 2 as much as possible. The challenges and major work will be in category
    3, while we should try to avoid category 4 whenever possible.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易理解，我们应该尽可能多地重用类别1和2中的项目。挑战和主要工作将在类别3中，而我们应该尽可能避免类别4。
- en: Virtual hardware reference platforms
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 虚拟硬件参考平台
- en: The new Android releases usually come with two reference platforms. Developers
    can test the new Android releases on Android emulator first. This can be very
    useful in the preview stages. After the official release, the Google hardware
    platforms, such as Nexus or Pixel, usually become the devices for developers.
    The emulator and Nexus/Pixel builds are the earliest builds available in AOSP.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 新的Android发布通常包含两个参考平台。开发者可以先在Android模拟器上测试新的Android发布。这在预览阶段可能非常有用。在官方发布后，Google硬件平台，如Nexus或Pixel，通常成为开发者的设备。模拟器和Nexus/Pixel构建是AOSP中最早可用的构建。
- en: In this book, we will use Android emulator as the virtual hardware reference
    platform for our topics. Since the Android emulator build is already available
    in AOSP, you may wonder what we can do with it. Actually, we can customize an
    existing platform by adding new features to it. This is what OEM/ODM companies
    usually do using a reference platform from a silicon vendor. With Android emulator,
    we will demonstrate how to create a new device so that we can customize it. If
    you know any commercial emulator products, such as Genymotion and AMI DuOS, then
    you may know what features these products added to the emulator. We will extend
    Android emulator in a very similar way.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将使用Android模拟器作为我们主题的虚拟硬件参考平台。由于Android模拟器的构建已经在AOSP中可用，你可能会想知道我们能用它做什么。实际上，我们可以通过添加新功能来定制现有的平台。这就是OEM/ODM公司通常使用来自硅供应商的参考平台所做的事情。使用Android模拟器，我们将演示如何创建一个新设备，以便我们可以对其进行定制。如果你了解任何商业模拟器产品，例如Genymotion和AMI
    DuOS，那么你可能知道这些产品为模拟器添加了哪些功能。我们将以非常相似的方式扩展Android模拟器。
- en: After we explore the topics about the customization of a new device, we will
    explore more advanced topics about porting. The major work with porting is the
    changes to the kernel and HAL. To discuss advanced topics about porting and debugging,
    we will also use VirtualBox as another virtual hardware reference platform. Even
    though VirtualBox has been used by many commercial emulator products, such as
    Genymotion, AMI DuOS, Leapdroid, and so on, it is not supported by AOSP directly.
    Most Android emulators for the PC are based on VirtualBox and they are designed
    for gamers to run Android games. In this book, we will learn how to create a similar
    build using various open source resources.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们探讨了关于新设备定制的主题之后，我们将探讨更多关于移植的高级主题。移植的主要工作是内核和HAL的更改。为了讨论关于移植和调试的高级主题，我们还将使用VirtualBox作为另一个虚拟硬件参考平台。尽管VirtualBox被许多商业模拟器产品（如Genymotion、AMI
    DuOS、Leapdroid等）使用，但它并未直接得到AOSP的支持。大多数PC上的Android模拟器都是基于VirtualBox的，它们是为游戏玩家运行Android游戏而设计的。在这本书中，我们将学习如何使用各种开源资源创建类似的构建。
- en: Introduction to the x86-based Android emulator
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: x86架构的Android模拟器简介
- en: Android emulator has been changed dramatically as well in Android 4, 5, 6, and
    7\. Before Android 5, Android emulator was built on a virtual hardware reference
    board called goldfish.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: Android模拟器在Android 4、5、6和7版本中也发生了巨大变化。在Android 5之前，Android模拟器是基于名为goldfish的虚拟硬件参考板构建的。
- en: The hardware specification of the goldfish virtual hardware platform can be
    found in the AOSP source tree at `$AOSP/platform/external/qemu/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT`.
    In this book, we will refer to the AOSP root directory as `$AOSP`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 金鱼虚拟硬件平台的硬件规范可以在AOSP源代码树中的`$AOSP/platform/external/qemu/docs/GOLDFISH-VIRTUAL-HARDWARE.TXT`找到。在这本书中，我们将把AOSP根目录称为`$AOSP`。
- en: The goldfish virtual hardware platform was built on QEMU 1.x to emulate ARM
    devices on the x86 environment. The x86 host environments could be a Windows,
    Linux, or macOS X computer. Since the target device architecture is emulated using
    QEMU, the performance is poor. The emulator is very slow and difficult to use
    for application developers. However, QEMU is actively developed on the x86 architecture
    and widely used together with various virtualization technologies, such as VT-x,
    AMD-V, and so on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 金鱼虚拟硬件平台是基于QEMU 1.x构建的，用于在x86环境中模拟ARM设备。x86主机环境可以是Windows、Linux或macOS X计算机。由于目标设备架构是通过QEMU模拟的，性能较差。模拟器运行非常缓慢，对于应用程序开发者来说难以使用。然而，QEMU在x86架构上得到了积极开发，并且与各种虚拟化技术（如VT-x、AMD-V等）广泛使用。
- en: Since Android 4.x, Intel developed an x86-based Android emulator using KVM on
    Linux and Intel HAXM for Windows and macOS X. With the introduction of virtualization
    technology to the emulator, the Intel x86-based emulator is much faster than the
    emulated one for the ARM or MIPS architecture. For the sake of Android application
    developers, Google officially integrated the Intel x86-based Android emulator
    to Android SDK. The Intel x86-based Android emulator has become the recommended
    choice for developers to test their Android applications.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 4.x以来，英特尔在Linux上使用KVM和Windows及macOS X上的Intel HAXM开发了一个基于x86的Android模拟器。随着虚拟化技术被引入模拟器，基于英特尔x86的模拟器比模拟ARM或MIPS架构的模拟器要快得多。为了方便Android应用程序开发者，谷歌官方将基于英特尔x86的Android模拟器集成到Android
    SDK中。基于英特尔x86的Android模拟器已成为开发者测试其Android应用程序的首选选择。
- en: Introduction to ranchu
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ranchu简介
- en: With the introduction of Android 5 (Lollipop), the 64-bit hardware architecture
    is available for both ARM and Intel platforms. However, 64-bit hardware devices
    for Android were still under development at that time. The only choice for developers
    was to get a hardware reference platform from silicon vendors.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 随着Android 5（Lollipop）的引入，64位硬件架构对ARM和英特尔平台都可用。然而，当时Android的64位硬件设备仍在开发中。开发者唯一的选择是从硅供应商那里获取硬件参考平台。
- en: To help developers test their applications on 64-bit architecture, the engineers
    at Linaro did an excellent job enabling a virtual hardware platform on QEMU to
    test ARMv8-A 64-bit architecture. They gave this virtual hardware platform a code
    name, **ranchu**. You may refer to the blog at Linaro by Alex Bennée at [https://www.linaro.org/blog/core-dump/running-64bit-android-l-qemu/](https://www.linaro.org/blog/core-dump/running-64bit-android-l-qemu/).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助开发者测试其应用程序在64位架构上的运行，Linaro的工程师在QEMU上实现了一个虚拟硬件平台，以测试ARMv8-A 64位架构。他们给这个虚拟硬件平台取了一个代号，**ranchu**。您可以参考Linaro的博客，由Alex
    Bennée撰写，[https://www.linaro.org/blog/core-dump/running-64bit-android-l-qemu/](https://www.linaro.org/blog/core-dump/running-64bit-android-l-qemu/)。
- en: This change was adopted by Google later and was used as the hardware reference
    platform for the next generation of Android emulators. If you install the Android
    SDK images, you can see two kernel images starting from Android 5\. The kernel
    image `kernel-qemu` is the image to be used with the goldfish virtual hardware
    platform and the image `kernel-ranchu` is the image to be used with the ranchu
    virtual hardware platform.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变后来被谷歌采纳，并作为下一代Android模拟器的硬件参考平台。如果你安装了Android SDK镜像，你可以从Android 5开始看到两个内核镜像。内核镜像`kernel-qemu`是与goldfish虚拟硬件平台一起使用的镜像，而镜像`kernel-ranchu`是与ranchu虚拟硬件平台一起使用的镜像。
- en: To respond to this change, both Intel and MIPS worked on their architectures
    to support their 64-bit hardware emulation in ranchu. You can refer to the group
    discussions at [https://groups.google.com/forum/#!topic/android-emulator-dev/dltBnUW_HzU](https://groups.google.com/forum/#!topic/android-emulator-dev/dltBnUW_HzU).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应对这一变化，英特尔和MIPS都对其架构进行了工作，以支持ranchu中的64位硬件模拟。你可以参考在[https://groups.google.com/forum/#!topic/android-emulator-dev/dltBnUW_HzU](https://groups.google.com/forum/#!topic/android-emulator-dev/dltBnUW_HzU)的群组讨论。
- en: The ranchu hardware platform is based on a newer QEMU version and the architecture
    is changed to have less dependency on Google modification and goldfish-specific
    devices. For example, it uses virtio-block devices to emulate the NAND and SD
    card. This has the potential of providing much better performance and also makes
    it possible to utilize the features provided by the latest QEMU code base. The
    ranchu kernel is built on a new version in the `android-goldfish-3.10` branch,
    while the latest goldfish kernel is in the `android-goldfish-3.4` branch. You
    can notice this difference by running your Android virtual device using different
    kernels from Android SDK.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: ranchu硬件平台基于更新的QEMU版本，其架构的改变减少了对于谷歌修改和goldfish特定设备的依赖。例如，它使用virtio-block设备来模拟NAND和SD卡。这有可能提供更好的性能，同时也使得利用最新QEMU代码库提供的功能成为可能。ranchu内核是基于`android-goldfish-3.10`分支的新版本构建的，而最新的goldfish内核在`android-goldfish-3.4`分支。你可以通过在Android虚拟设备上使用来自Android
    SDK的不同内核来注意到这种差异。
- en: VirtualBox-based Android emulators
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于VirtualBox的Android模拟器
- en: With the ever evolving nature of virtualization technology, there are many commercial
    Android emulator products developed on the market as well. You may have heard
    of some of them such as Genymotion, AMIDuOS, Andy, BlueStacks, and so on. Many
    of them are built using VirtualBox from Oracle, such as Genymotion, AMIDuOS, and
    Andy. The reason that VirtualBox is used instead of other solutions such as VMware
    is because VirtualBox is an open source solution.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 随着虚拟化技术的不断演变，市场上也出现了许多基于商业的Android模拟器产品。你可能听说过其中的一些，例如Genymotion、AMIDuOS、Andy、BlueStacks等等。其中许多都是使用Oracle的VirtualBox构建的，例如Genymotion、AMIDuOS和Andy。使用VirtualBox而不是其他解决方案（如VMware）的原因是VirtualBox是一个开源解决方案。
- en: To achieve the best performance and user experience, both host and target need
    to be customized in the commercial emulator products. Besides Android emulator,
    we will also use VirtualBox as the virtual hardware platform to demonstrate how
    to port Android to a new platform. The reason that we need another virtual hardware
    platform in this book is because Android emulator is already supported in AOSP.
    We will use Android emulator as a platform to teach how to extend and customize
    an existing platform. While VirtualBox is not supported in AOSP, it can be used
    as a target platform to teach how to port Android to a new platform. Even though
    Android has been ported to VirtualBox by Genymotion, AMI, and others, none of
    them are open source products.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现最佳的性能和用户体验，商业模拟器产品中的主机和目标都需要进行定制。除了Android模拟器，我们还将使用VirtualBox作为虚拟硬件平台来演示如何将Android移植到新平台。在这本书中我们需要另一个虚拟硬件平台的原因是Android模拟器已经在AOSP中得到支持。我们将使用Android模拟器作为一个平台来教授如何扩展和定制现有平台。而VirtualBox在AOSP中不受支持，但它可以用作目标平台来教授如何将Android移植到新平台。尽管Android已经被Genymotion、AMI和其他人移植到VirtualBox，但它们都不是开源产品。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed what Android system programming is and the scope
    involved in system-level programming in this book. After that, we took an overview
    of the Android system architecture and talked about the layers that we will focus
    on in this book. We also discussed the virtual hardware platforms that we use
    in this book. In this book, we use the code from various third-party projects,
    so we also took a brief overview of each of them in this chapter. In the next
    chapter, we will start to learn about the development environment setup for Android
    system programming. This includes both development tools and the source code repository
    setup.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了Android系统编程是什么以及本书中涉及的系统级编程范围。之后，我们对Android系统架构进行了概述，并讨论了本书中我们将关注的层次。我们还讨论了本书中使用的虚拟硬件平台。在本书中，我们使用了来自各种第三方项目的代码，因此在本章中也简要概述了每个项目。在下一章中，我们将开始学习Android系统编程的开发环境设置。这包括开发工具和源代码仓库的设置。
