- en: Chapter 2. User Interface – Views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving user input with buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and editing text
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the keyboard
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying progress
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying content larger than the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through the content divided into pages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying alerts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling views
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An application's **User Interface** (**UI**) is essential for providing the
    user with an easy way of communicating with a device, be it a computer, a mobile
    phone, or a tablet. On a mobile device, the user interface is not only essential
    but the only way to interact with the user. Developers have to cope with various
    limitations and restrictions when developing applications for mobile devices.
    The processing power of mobile devices does not match that of desktop CPUs, and
    the screens are smaller, making the process of choosing what sort of information
    will be displayed each time somewhat more difficult.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the key components of an iOS application''s
    UI. We will see how to use and customize these components to create rich application
    user interfaces and discuss the similarities and differences they have with their
    desktop equivalents. The following is a list of these components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**UIView**: This is a customizable container that is the base object of most
    iOS user interface controls'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIButton**: This is the equivalent of a Button in the .NET world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UILabel**: This is the equivalent of a Label in the .NET world'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIImageView**: This is a view that allows us to display and create basic
    animations with images'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UITextView**: This is a view that allows us to display editable text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UITextField**: This is similar to .NET''s TextBox control'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIProgressView**: This displays the known length progress'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIScrollView**: This provides the ability to display scrollable content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIPageControl**: This provides navigation functionality to the content that
    is divided into different pages or screens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**UIAlertView**: This is the default iOS control for displaying a message box
    to the user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also talk about how to programmatically create instances of these components
    and how to style and use them efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Adding and customizing views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to add and customize `UIView` with Xcode's
    Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding views with Interface Builder is a simple task. Let's start by creating
    a new`iPhone Single View Application` project in Xamarin Studio. Name the project
    `FirstViewApp` and open the `FirstViewAppViewController.xib` file with Interface
    Builder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: To add a view to the project, drag-and-drop a `UIView` object from the **Library**
    pad onto the main view. Make sure that it fits the entire window area. To make
    `UIView` accessible, create an outlet for it and name it `subView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The concept of outlets and how to use them is discussed in detail in [Chapter
    1](ch01.html "Chapter 1. Development Tools"), *Development Tools*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Select the view that we have just added and go to the **Inspector** pad. Select
    the **Attributes** tab, and select **Dark Gray Color** in the **Background** drop-down
    list. Now, select the **Size** tab and reduce the view's height by 60 points.
    Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the simulator. The result should look like the one
    shown in the following screenshot:![How to do it...](img/8924OT_02_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The dark gray portion of the simulator's screen is the view that we have just
    added.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have successfully created an app that contains one view. Of course, this
    app does not provide any functionality. It is only meant to show how to add a
    view and display it.
  prefs: []
  type: TYPE_NORMAL
- en: Views are the essential components of an iOS app interface. Every visual user
    interface object inherits from the `UIView` class. The concept is somewhat different
    from a form in .NET. A view manages content drawing, accepts other views as subviews,
    provides autosizing features, can accept touch events for itself and its subviews,
    and many of its properties can even be animated. Even `UIWindow` inherits from
    `UIView`. It is this class or its inheritors that iOS developers will use most
    frequently.
  prefs: []
  type: TYPE_NORMAL
- en: When a view that is added with Interface Builder is first instantiated at runtime,
    it sets its `Frame` property with values that are set through the **Inspector**
    pad's **Size** tab. The `Frame` property is of the `RectangleF` type, and it defines
    the location of the view in its superview's coordinate system (in our case, the
    main window) and its size in points.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Objective-C, the `frame` property of UIView is of the `CGRect` type. This
    type has not been bound in Xamarin.iOS, and the more familiar `System.Drawing.RectangleF`
    was used instead.
  prefs: []
  type: TYPE_NORMAL
- en: A superview is a view's parent view, while subviews are its child views. Views
    that have the same superview are described as siblings.
  prefs: []
  type: TYPE_NORMAL
- en: The default coordinate system in iOS originates from the top-left corner and
    extends towards the bottom and the right. The coordinate origin is always the
    same and cannot be changed programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The coordinate system of iOS is displayed in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/Image1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When the `Frame` property is set, it adjusts the `Bounds` property. The `Bounds`
    property defines the location of the view in its own coordinate system and its
    size in points. It is also of the `RectangleF` type. The default location for
    the `Bounds` property is (0,0), and its size is always the same as the view's
    `Frame` value. Both these properties' sizes are connected to each other, so when
    you change the size of `Frame`, the size of `Bounds` changes accordingly and vice
    versa. You can change the `Bounds` property to display different parts of the
    view.
  prefs: []
  type: TYPE_NORMAL
- en: A view's frame can exceed the screen in both location and position. That is,
    a view's frame with values *(x = -50, y = -50, width = 1500, height = 1500)* is
    perfectly acceptable, although it will not be completely visible on the screen
    of an iPhone.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another thing to note is that the `UIView` class inherits from the `UIResponder`
    class. The `UIResponder` class is responsible for responding to and handling events.
    When a view is added to a superview, it becomes part of its responder chain. The
    `UIView` class exposes the properties and methods of `UIResponder`, and the ones
    we are interested in describing for now are the following two:'
  prefs: []
  type: TYPE_NORMAL
- en: '**IsFirstResponder property**: This returns a Boolean value indicating whether
    the view is the first responder. Basically, it indicates if the view has focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ResignFirstResponder():** This causes the view to lose focus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding views programmatically
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we would like to add a view on our main view programmatically, we would
    use the following `UIView.AddSubview(UIView)` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `AddSubview` method adds its parameter, which is of the `UIView` type, to
    the list of the caller's subviews and sets its `Superview` parameter to the caller.
    A view will not be displayed unless it is added to a parent view with the `AddSubview`
    method. Also, if a view already has a superview and it is added to another view
    with its `AddSubview` method, its `Superview` is changed to that of the new caller.
    What this means is that a view can have only one superview at a time.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When adding a view as a subview with Interface Builder, it is not required to
    use the `AddSubview` method to display the subview. However, it is required to
    call the `AddSubview` method when adding views programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: For removing a view from its superview programmatically, call its `RemoveFromSuperview`
    method. Calling this method on a view that has no superview does nothing. Care
    must be taken when we want to reuse the view we want to remove. We must keep a
    reference to it, or it might be released.
  prefs: []
  type: TYPE_NORMAL
- en: View content layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Another important property of `UIView` is `ContentMode`. `ContentMode` accepts
    values of the `UIViewContentMode` enumeration type. This property sets how the
    `UIView` will display its content, usually an image. The default value of this
    property is `UIViewContentMode.ScaleToFill`. This scales the content to fit the
    exact view's size, stretching it if necessary. The available values of `UIViewContentMode`
    are explained in detail in the *Displaying Images* recipe later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a custom view* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating the UI* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Accessing the UI with Outlets* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving user input with buttons
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use buttons to receive and respond to user
    input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We used buttons in [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development*
    *Tools*, to discuss how to use Interface Builder to add controls to the user interface.
    In this recipe, we will describe the `UIButton` class in more detail. Open the
    `FirstViewApp` project, which we created in the previous recipe, in Xamarin Studio.
    Increase the height of the view, which we added, to cover the whole device screen
    in Interface Builder and save the document.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will programmatically add a button in our interface. This button will change
    our view''s background color when tapped. Open the `FirstViewAppViewController.cs`
    file and enter the following code in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method, add the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. When the button is tapped, the result
    should be similar to the following screenshot:![How to do it...](img/8924OT_02_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have added a button to the user interface. This button changes
    the background color of its superview. Furthermore, we have accomplished this
    without using Interface Builder at all.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now what the code does. We create the following field that will
    hold the button object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `CreateButton` method, we create the button and set some properties.
    The method is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we assign the view''s frame to a new variable named `viewFrame`. Then,
    we create a new `RectangleF` object named `buttonFrame`. This object will be assigned
    to the button''s `Frame` property. Now that we have a frame for our button, we
    can initialize it as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The button is initialized with the `UIButton.FromType(UIButtonType)` static
    method. This method takes one parameter of the `UIButtonType` type and returns
    predefined types of buttons that are included in iOS SDK. The `UIButtonType.System`
    button enumeration value used here is the default type of button without any borders
    or background. After the `buttonChangeColor` object is initialized, we set its
    frame to the `RectangleF` value we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have provided an initialization code for the button, we will set
    its titles (that''s right, more than one) as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the `UIButton.SetTitle(string, UIControlState)` method twice. This
    method is responsible for setting the button''s title for each given button state.
    The string parameter is the actual title that will be shown. The second parameter
    is an enumeration of the `UIControlState` type. This parameter indicates the different
    control states that apply to controls. These control states are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: This is the default idle state of an enabled control.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highlighted**: This is the state of the control when a touch-up event occurs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Disabled**: This is the state when the control is disabled and does not accept
    any events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selected**: This is the state when the control is selected. In most cases,
    this state does not apply. However, it is useful when a selection state is required,
    like in a `UISegmentedControl` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application**: This is the additional control state value for an application''s
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Reserved**: This is for internal framework use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, with the `UIButton.SetTitle(string, UIControlState)` method, we have set
    the title that will be displayed when the button is in its default state and the
    title that will be displayed while the button is being tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'After this, we set the button''s handler for the `TouchUpInside` event and
    add it as a subview to `subView` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside the `buttonChangeColor_TouchUpInside` event, we change the background
    color of the view according to the Boolean field that we have declared, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This is done by setting the view's `BackgroundColor` property to the appropriate
    `UIColor` class instance we want, as shown in the preceding highlighted code.
    The `UIColor` object is a class with many different static methods and properties
    that allow us to create different colored objects.
  prefs: []
  type: TYPE_NORMAL
- en: When you compile and run the app on the simulator, notice the view's color change
    when you tap the button. Also notice how the button's title changes while the
    mouse cursor (or a finger on the device) is "touching" the button.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used the `UIButton.FromType(UIButtonType)` static method
    to initialize the button. A brief description of each of the enumeration flags
    of `UIButtonType` are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**System**: This is the default type of button.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Custom**: This is a borderless transparent button. Use this flag when creating
    custom buttons with images as backgrounds. The button''s title is not transparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**RoundedRect**: This is the default type of button with rounded corners. As
    of iOS 7, this type of `UIButton` is deprecated. Use `UIButtonType.System` instead.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**DetailDisclosure**: This is a round blue button that reveals additional information
    related to an item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InfoLight**: This is a light-colored button with the letter (**i**) that
    represents information display.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**InfoDark**: This is the same as InfoLight; it is shown with a dark color.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ContactAdd**: This is a round blue button with a white plus sign (**+**).
    Usually, this button is displayed to present contact information to add to an
    item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the appearance of buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For creating custom buttons with the `UIButtonType.Custom` type, use the `UIButton`
    class' `SetBackgroundImage` and `SetImage` methods. They both accept one `UIImage`
    and one `UIControlState` parameter so that different images for different control
    states can be set. When setting images for buttons, be sure to set the `UIButton.ContentMode`
    property accordingly, irrespective of whether creating a custom button or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'The functionality provided by the `SetImage` and `SetBackgroundImage` methods
    can also be accomplished in the corresponding **Image** and **Background** fields
    in the **Attributes** tab of the **Inspector** pad in Interface Builder. Select
    the state for which to set the desired image(s) from the drop-down list box and
    set the path to the image file, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Changing the appearance of buttons](img/8924OT_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding and customizing views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a custom view* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Styling views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating the UI* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIImageView` class to display
    images on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will see how to bundle and display images in a project. An
    image file will be needed for display. The image file used here is named `Toroni.jpg`.
    Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `ImageViewerApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps for this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ImageViewerAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIImageView` object on its view. Connect the `UIImageView` object with
    an outlet named `imageDisplay`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, in the `ImageViewerAppViewController` class, enter
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right-click on the project in the **Solution** pad and navigate to **Add** |
    **Add Files…**. Select the image file you want to display and click on **Open**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the image file you have just added and navigate to **Build Action**
    | **BundleResource**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, compile and run the app on the simulator. The image you added to the
    project should be displayed on the screen, like in the following screenshot:![How
    to do it...](img/8924OT_02_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `UIImageView` class is basically a view customized for displaying images.
    When you add an image in a project, its **Build Action** must be set to **BundleResource**
    in the **Solution** pad; otherwise, the image will not be copied into the app
    bundle. Fortunately, Xamarin Studio is smart enough to handle this setting automatically
    for images.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ContentMode` property is very important when displaying images. It sets
    the way the `UIView` (`UIImageView` in this case) object will display the image.
    We have set it to `UIViewContentMode.ScaleAspectFit` so that it will be resized
    to fit the area of `UIImageView`, keeping the aspect ratio intact at the same
    time. If the `ContentMode` property was left at its default `ScaleToFill` value,
    the output would be something like the one shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/8924OT_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To set the image that `UIImageView` should display, we set its `Image` property
    with a `UIImage` object, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContentMode` property accepts an enumeration type named `UIViewContentMode`.
    The values provided are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ScaleToFill`: This is the default value of the base `UIView` object. It scales
    the content to fit the size of the view, changing the aspect ratio as necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleAspectFit`: This scales the content to fit the size of the view, maintaining
    its aspect ratio. The remaining area of the view''s content becomes transparent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ScaleAspectFill`: This scales the content to fill the size of the view, maintaining
    its aspect ratio. Some part of the content may be left out.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Redraw`: When a view''s bounds are changed, its content is not redrawn. This
    value causes the content to be redrawn. Drawing content is an expensive operation
    in terms of CPU cycles, so think twice before using this value with large content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Center`: This places the content at the center of the view, keeping its aspect
    ratio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Top`, `Bottom`, `Left`, `Right`, `TopLeft`, `TopRight`, `BottomLeft`, and
    `BottomRight`: These align the content in the view with the corresponding value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIImage` class is the object that represents image information. The file
    formats it supports are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| File Format | File extension |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Portable Network Graphics (PNG) | `.png` |'
  prefs: []
  type: TYPE_TB
- en: '| Joint Photographic Experts Group (JPEG) | `.jpg`, `.jpeg` |'
  prefs: []
  type: TYPE_TB
- en: '| Tagged Image File Format (TIFF) | `.tiff`, `.tif` |'
  prefs: []
  type: TYPE_TB
- en: '| Graphic Interchange Format | `.gif` |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Bitmap Format | `.bmp` |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Icon Format | `.ico` |'
  prefs: []
  type: TYPE_TB
- en: '| Windows Cursor | `.cur` |'
  prefs: []
  type: TYPE_TB
- en: '| XWindow bitmap | `.xbm` |'
  prefs: []
  type: TYPE_TB
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Animated GIF image files are not supported by the `UIImageView` class. When
    an animated GIF is set to the `Image` property of `UIImageView`, only its first
    frame will be displayed as a static image.
  prefs: []
  type: TYPE_NORMAL
- en: Using images for different screen sizes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating images for backgrounds provides developers with the ability to produce
    rich and elegant user interfaces for their apps. The preferred image file format
    for creating backgrounds for views is PNG. However, since iPhone 4 was released,
    the screen resolution was increased. To support both screen resolutions in an
    app, the iOS SDK provides an easy solution. Just save the image in the higher
    resolution and add a `@2x` suffix to the file name just before the extension.
    For example, the name of a higher resolution version of a file named `Default.png`
    would be `Default@2x.png`. Also, no extra code is required to use both files.
    Just use the `UIImage.FromBundle(string)` static method, passing the file name
    without an extension. The following line of code would load the appropriate file,
    depending on the screen resolution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: iOS takes care of loading the appropriate file, depending on the device the
    app is running on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The preceding case only applies to PNG image files.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding and customizing views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Selecting images and videos* recipe in [Chapter 7](ch07.html "Chapter 7. Multimedia
    Resources"), *Multimedia Resources*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying and editing text
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display simple text blocks with editing
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the usage of `UITextView` and how to display
    editable text with it. Create a new iPhone **Single View Application** project
    in Xamarin Studio and name it `TextViewApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open `TextViewAppViewController.xib` in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIButton` near the top of its view and a `UITextView` below it. Connect
    both objects to their outlets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, enter the following `ViewDidLoad` method in the `TextViewAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following nested class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap somewhere in the text view and
    the keyboard will appear. Type some text and then tap on the **Finished** button
    to hide the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UITextView` class provides an object that displays editable blocks of
    text. To respond to the events of our text view, we have implemented a class (shown
    in the following code) that inherits from `UITextViewDelegate`, which will act
    as the text view''s delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We declared a constructor that accepts a `TextViewAppViewController` object
    so that we can have the instance of our controller available to access our controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we override three methods of the `UITextViewDelegate` class, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: These methods are the handlers that will get called whenever a corresponding
    event is triggered. When tapping on the text view, the `EditingStarted` method
    gets called. We enable the **Finished** button in it. When we type some text in
    the text view, the `Changed` method gets called, and we can see the output of
    the `Console.WriteLine` method in Xamarin Studio's **Application Output** pad.
    Finally, when we tap on the **Finished** button, the keyboard hides, and the `EditingEnded`
    method gets called. This method allows us to disable the button.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `ViewDidLoad` method, we assign a handler to the `TouchUpInside` event
    of the button, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the text view''s `ResignFirstResponder()` method in it so that when
    the button is tapped, the text view will lose focus, causing the keyboard to hide.
    Then, we assign a new instance of the delegate we created to the text view''s
    `Delegate` property, passing the instance of the `TextViewAppViewController` object,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates in Objective-C are somewhat different than those in C#. Although in
    both worlds, their most common usage is to provide access to some form of event
    notification mechanism, in Objective-C, this mechanism is a bit more complex.
    A C# delegate is much like a function pointer in C or C++ programming languages.
    It is an object that holds a reference to a method of a specific signature. On
    the other hand, an Objective-C delegate is a certain type of object that conforms
    to a specific `protocol`. It is basically an object that wraps one or more methods
    (and/or other members) that act as event handlers.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An Objective-C protocol is similar to an interface in C#.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of delegate objects might seem confusing at first, but it is not
    difficult to comprehend. Regarding the event notification mechanism, Xamarin.iOS
    simplifies things for .NET developers by providing events for most objects, including
    `UITextView` described here.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Using the keyboard* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the keyboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss some important aspects of the device's virtual
    keyboard usage.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous recipe, we discussed how to edit text. In this recipe, we will
    discuss some of the things we can or even must do to use the keyboard effectively.
    Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `KeyboardApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `KeyboardAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UITextField` object in the bottom-half portion of the view and connect
    it to an outlet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, enter the following code in the `KeyboardAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap on the text field and watch it
    moving upwards to avoid being hidden from the keyboard. Tap the **Done** button
    on the keyboard and watch the text field returning to its original position when
    the keyboard hides.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are various types of keyboards in iOS. Since not all keys can be displayed
    at once due to the restricted screen size, it is a good practice to set the appropriate
    type of keyboard according to the text input we need the user to provide. In this
    project, we have set the keyboard to the **Email Address** type. We have also
    customized the type of **Return key** by setting it to **Done** in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When the keyboard is displayed, it is the developer''s responsibility to make
    sure it does not obstruct the essential UI elements. In this case, since we provide
    the user with the ability to enter some text input, we have to make sure that
    the text field is shown, so the user will be able to see what is being typed.
    For this, we add two observers in the default notification center using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The notification center is iOS' mechanism for providing system-wide notifications.
    Normally, it can be accessed through the `NSNotificationCenter.DefaultCenter`
    static property. However, Xamarin.iOS provides some APIs that simplify things
    for us. In the example project for this recipe, you will find the usage of both
    APIs. In this recipe, we are using Xamarin's APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'By calling `UIKeyboard.Notifications.ObserveWillShow` and passing a handler
    to it, we subscribe to the notification center so that we get notified whenever
    the keyboard is about to be displayed. This handler is of the `EventHandler<UIKeyboardEventArgs>`
    type, and the `UIKeyboardEventArgs` parameter provides us with, among others,
    the frame of the keyboard after it has been shown (as shown in the following code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we store the text field''s frame in a variable using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We reduce the frame''s `Y` position using the following code value so that
    the text field will move upwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When the new frame is set to `emailField` (as shown in the following code),
    it will move to the new position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The second handler is needed for moving the text field back to its original
    position after the keyboard is closed. It is almost the same as the first handler,
    except for two differences. The `UIKeyboard.Notifications.ObserveDidHide` method
    is used. This method will trigger our handler after the keyboard is hidden. In
    this handler, we just make sure that we readjust the text field's position back
    to where it was.
  prefs: []
  type: TYPE_NORMAL
- en: 'The last few lines of code in the `ViewDidLoad` method set the `ShouldReturn`
    property of the `UITextField` class. This property accepts a delegate of the `UITextFieldCondition`
    type, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The handler we have added is called whenever the user taps the return key on
    the virtual keyboard. Here, we call the `ResignFirstResponder` method of `UITextField`,
    which will hide our keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The two fields of the `NSObject` type in the class, which are assigned to the
    return values of the `UIKeyboard.Notifications` methods we used, hold information
    about the observers we added. For removing the two observers we have added here,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Care must be taken when developing an app that uses the keyboard and supports
    multiple interface orientations. If, for example, the keyboard appears in portrait
    orientation and the user changes to landscape orientation, both the keyboard's
    bounds and the text field's frame will be different and must be adjusted accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying and editing text* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Adjusting the UI orientation* recipe in [Chapter 9](ch09.html "Chapter 9. Interacting
    with Device Hardware"), *Interacting with Device Hardware*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying progress
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will discuss how to display the progress of known length.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will talk about the `UIProgressView` control. This control
    provides a similar functionality to the ProgressBar control in .NET. Create a
    new iPhone **Single View Application** project in Xamarin Studio and name it `ProgressApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The following are the steps for using the `UIProgressView` class. Note that
    in this recipe, we will add all the controls programmatically without the use
    of Interface Builder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following `using` directives in the `ProgressAppViewController` class
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following fields in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Enter the following code in the `ViewDidLoad` override:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following method in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Tap on the button and watch the progress
    bar fill.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The current value of `UIProgressView` is represented by its `Progress` property.
    Its acceptable value range is always from `0` to `1`. So, when we initialize it,
    we set it to `0` to make sure that the bar is not filled at all. This can be done
    using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Since `UIProgressView` has a specific range, we need to assign the value we
    want it to be incremented by, depending on the number of items we need to process
    (in this case, 10) using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'In the button''s `TouchUpInside` handler, we disable the button and start our
    progress through `Task` from `System.Threading.Tasks`, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `StartProgress()` method, we start a loop that will process the work,
    which needs to be done. Since the work executes on a separate thread, when we
    want to make changes to the controls, it must be done on the main UI thread by
    calling the `InvokeOnMainThread` method, which accepts a parameter of the `NSAction`
    type. An `NSAction` type parameter can accept anonymous methods as well, as seen
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The progress view supports two styles. `UIProgressViewStyle.Default` (the one
    that was used in this recipe) and `UIProgressViewStyle.Bar`. There is absolutely
    no functionality difference between the two styles, except for appearance. To
    change the style of the progress view, set its `Style` property to one of the
    previously mentioned values.
  prefs: []
  type: TYPE_NORMAL
- en: UIProgressView height
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Setting the height of the progress view has no effect, as it is constant for
    the control. For creating a variable-height progress bar, the `UIProgressView`
    class must be subclassed.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Receiving user input with buttons* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying content larger than the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to display content that extends beyond the
    screen's bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will discuss the `UIScrollView` control. Create a new iPhone
    **Single View Application** project and name it `ScrollApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to create the project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ScrollAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UIScrollView` object on its view and connect it to an outlet. Save the
    document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, add the following code in the `ScrollAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, add an image to the project and set its **Build Action** to **BundleResource**.
    An image larger than the screen size of 640 x 1136 pixels of iPhone 5S is preferable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the simulator. Tap and drag the image to display
    different portions. By pressing *Alt* + left-mouse click, you can simulate the
    pinch zooming function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIScrollView` is capable of managing content that expands beyond the screen
    size. The size of the content that the scroll view will display must be set in
    its `ContentSize` property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ContentOffset` property shown in the following code defines the position
    of the content inside the scroll view''s bounds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'What this means is that the image''s (x=200, y=50) point will be displayed
    at the origin (x=0, y=0) of `UIScrollView`. To provide a zooming functionality
    for the content, we first set the `MinimumZoomScale` and `MaximumZoomScale` properties,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code set the minimum and maximum zoom scale for the content. A
    value of `2` means that the content will be displayed double in size, while a
    value of `0.5` means that the content will be displayed at half its size.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the actual zooming operation, we need to set the `ViewForZoomingInScrollView`
    property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ViewForZoomingInScrollView` property accepts a `delegate` variable of
    the `UIScrollViewGetZoomView` type and returns `UIView`. Here, the image view
    that we created is returned, but another image view of a higher resolution can
    be used instead to provide better image quality when zooming. After the `delegate`
    variable is assigned, the initial zoom scale is set using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the scroll view''s indicator style is set, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Indicators are the two lines that appear when scrolling or zooming: one vertical
    line on the right side and one horizontal line on the bottom side of the scroll
    view. These lines inform the user of the position of the content.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To provide a more pleasing scrolling and zooming effect to the user, the `UIScrollView`
    exposes the `Bounce` property. By default, it is set to `true`, but we have the
    option to disable it by setting it to `false`. Bouncing the content gives immediate
    feedback to the user that the bounds of the content have been reached, in either
    a horizontal or vertical direction. Furthermore, the `AlwaysBounceHorizontal`
    and `AlwaysBounceVertical` properties can be set individually. Setting one or
    both of these properties will make the scroll view bounce the content in the respective
    direction always, even if the content is equal to or smaller than the scroll view's
    bounds. Hence, no actual scrolling is needed.
  prefs: []
  type: TYPE_NORMAL
- en: UIScrollView events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UIScrollView` class exposes some of the following very useful events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Scrolled`: This occurs while the content is being scrolled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecelerationStarted`: This occurs when the user has started scrolling the
    content'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DecelerationEnded`: This occurs when the user has finished scrolling, and
    the content has stopped moving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If a handler has been assigned to the `Scrolled` event, it will be triggered
    whenever the `ContentOffset` property is set.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying and editing text* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Navigating through the content divided into pages* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigating through the content divided into pages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to use the `UIPageControl` class to provide
    page navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIPageControl` provides a simple visual representation of multiple pages
    or screens in an iOS app, which is indicated by dots. The following screenshot
    shows an example of the page control indicating that content is divided into three
    pages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting ready](img/8924OT_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The dot that corresponds to the current page is highlighted. It is usually combined
    with `UIScrollView`. Create a new iPhone **Single View Application** project in
    Xamarin Studio and name it `PageNavApp`. Add three image files in the project
    and set their **Build Action** to **BundleResource**.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to create this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `PageNavAppViewController.xib` file in Interface Builder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add `UIPageControl` to the bottom of the view and `UIScrollView` above it. Resize
    the scroll view to take up all the remaining space of the view and save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, enter the following code in the `PageNavAppViewController`
    class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following methods in the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. Scroll sideways on the scroll view
    to change the page. Likewise, tap or scroll on the page control to change the
    page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing that we need to do is set the `UIScrollView.PagingEnabled`
    property to true, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'This property instructs the scroll view to stop scrolling at multiples of the
    scroll view''s bounds, hence providing paging functionality. After this, the image
    views that will be displayed on different pages are prepared. Here, we take care
    of adjusting each image view''s frame so that they will be positioned next to
    each other, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We have attached handlers for two events. The first one is the `UIScrollView.DecelerationEnded`
    event, which will adjust the page control''s current page when the user scrolls
    the scroll view. The current page is determined by the scroll view''s `ContentOffset`
    property, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'The second event to which we attach a handler is the `UIPageControl.ValueChanged`
    event. In this handler, we make sure that the content is scrolled when the user
    taps or drags on the page control. The scrolling action is performed when the
    `ContentOffset` property is set to the desired image view''s `Frame.X` property
    using the `UIScrollView.SetContentOffset(PointF, bool)` method, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter of the `SetContentOffset` method instructs the scroll view
    to animate while scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, different `UIImageView` objects have been used. Any kind of
    `UIView` object can be used according to the type of content we want to display.
  prefs: []
  type: TYPE_NORMAL
- en: Proper usage of UIPageControl
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Users expect that scrolling to other pages will occur when tapping or dragging
    on the page control. It is not a good practice to use it for displaying page indexing
    only.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying images* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying content larger than the screen* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying alerts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `UIAlertView` class provides us with the ability to display alert messages
    to the user. In this recipe, we will discuss how to use this class and respond
    to user input.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, create an iPhone **Single View Application** project in Xamarin
    Studio and name it `AlertViewApp`. Open the `AlertViewAppViewController.xib` file
    in Xcode and add a button on its view. Don't forget to connect it to an outlet.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to implement the `UIAlertView` in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xamarin Studio, open the `AlertViewAppViewController.cs` file and add the
    following method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `ViewDidLoad` method, add the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app in the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap the button on the view. The alert should be displayed, as shown in the following
    screenshot:![How to do it…](img/8924OT_02_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tap either **OK** or **Cancel**. The **Show alert** button's title will change
    according to the alert button that was tapped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIAlertView` is a modal control. This means that once it is presented,
    the user is required to take an action for it to disappear. After creating the
    instance, we assign the title and the message that will be displayed through the
    `Title` and `Message` properties, respectively, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the buttons we want to display through the `AddButton` method,
    which accepts a `string` parameter for the button''s title, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We can practically add as many buttons as we want; however, it would be good
    to avoid adding more than three or four buttons. If there is a need for more options,
    it would be best to show a new view to the user with these options, instead of
    using an alert view.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the buttons, we need an event handler (as shown in the following
    code) that will inform us of the user''s action on the alert view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For this functionality, we use the `Dismissed` event that is triggered whenever
    the alert view is hidden. This occurs when any of its buttons are tapped. In the
    event handler, we can determine which button was tapped through the passed `ButtonIndex`
    property of `UIButtonEventArgs`. It is pretty clear which index corresponds to
    which button. The first button we added will have an index of `0`, the second
    button will have an index of `1`, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, to display the alert view, we call its `Show` method using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`UIAlertView` also supports text input. We can implement it by setting its
    `AlertViewStyle` property before displaying it. The `AlertViewStyle` property
    accepts the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UIAlertViewStyle.Default`: This alert view will not contain text input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIAlertViewStyle.SecureTextInput`: This alert view will contain a text field
    for password input, which obscures the typed text'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIAlertViewStyle.PlainTextInput`: In this, only one simple text field will
    be included'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UIAlertViewStyle.LoginAndPasswordInput`: Using this property, two text fields
    will be displayed, one plain and one secure, for entering the login credentials'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To access any of the mentioned text fields, we call the `GetTextField` method,
    passing the appropriate index, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also modify the text fields themselves. For example, if we
    want to disable obscuring the characters of the password text field, we can add
    the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Receiving user input with buttons* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Displaying and editing text* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a custom view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to override the `UIView` class and/or classes
    that derive from it to create custom views.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have discussed many of the available views to create iOS apps. There
    will be many cases, however, we will need to implement our own custom views. In
    this recipe, we will see how to create a custom view and use it.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Creating custom views is very useful when we want to capture touches or implement
    other custom behavior such as drawing.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `CustomViewApp`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are the steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new C# class file in the project and name it `MyView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Implement it with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `CustomViewAppViewController.xib` file in Interface Builder and add
    a `UIView` object on the main view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Class** field in the **Identity Inspector** to `MyView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the document.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compile and run the app on the simulator. Tap and drag the view and watch the
    touch coordinates being displayed in the label at the bottom of the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to note when creating custom views is to derive them from the
    `UIView` class and decorate them with the `RegisterAttribute`, as shown in the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The `RegisterAttribute` basically exposes our class to the Objective-C world.
    Note that the name we pass as its parameter must be the same name we enter in
    the **Class** field in the **Identity Inspector**. It is important to create the
    following constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'This constructor overrides the base class'' `UIView(IntPtr)`. This constructor
    is always being called when a view is initialized through the native code. If
    we do not override it, an exception will occur upon the initialization of the
    object. The other constructor that is used in this example is just provided as
    guidance on what might be used if the view was initialized programmatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Both these constructors call the `Initialize()` method that performs the initialization
    we need, such as creating the label that will be used and setting the background
    colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `TouchesMoved` method is overridden. This is the method that is executed
    when the user drags a finger on the view. Inside the method, we retrieve the `UITouch`
    object from the method''s NSSet parameter, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An `NSSet` object is a collection of data that are not in particular order.
    It is similar to an array. Its `AnyObject` parameter returns an object from the
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `UITouch` object contains information about user touches. We retrieve the
    touch''s current location from the `UITouch` object, using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: The `UITouch` object's `LocationInView` method accepts a parameter of the `UIView`
    type, which declares in which view's coordinate system will the location be calculated.
    In this case, we are interested in the coordinates of `MyView`.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we would like to initialize the custom view we created programmatically,
    we would enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Adding and customizing views* recipe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Loading a view with a view controller* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling views
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS provides a set of APIs through the **UIAppearance** protocol that allows
    us to adjust the appearance of the views once, without having to explicitly modify
    the styling properties on every instance of each view. This is particularly useful
    if, say, we want a specific view to have the same appearance throughout the app.
  prefs: []
  type: TYPE_NORMAL
- en: Apart from setting the styling properties of a view globally, we can also define
    the appearance of this view to be different under certain circumstances. Read
    on to find out how to accomplish this.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will work on the existing `CustomViewApp` project we created in the preceding
    recipe. Open the project in Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The downloadable code contains a separate project for this recipe. It is named
    `CustomViewApp2`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to complete this recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `CustomViewAppViewController.xib` file in Xcode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Resize the `MyView` object, which we created earlier, to make some room at the
    top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `UILabel` above the `MyView` object. Make sure that the label is added
    on the main view and not on `MyView`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Connect both objects to their respective outlets.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Back in Xamarin Studio, add the following code in the `ViewDidLoad` method
    of `CustomViewAppViewController`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Compile and run the app on the simulator. The output should be similar to the
    one shown in the following screenshot:![How to do it…](img/8924OT_02_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `UIAppearance` class is basically a proxy to the specific properties of
    each control. In Xamarin.iOS, we can access each control''s proxy through its
    static `Appearance` property. The changes we make to this object''s properties
    will reflect on the instances of the object throughout the app. In this case,
    we set the `BackgroundColor` attribute of all `UILabel` instances to blue using
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, we can provide different behavior for specific instances of `UILabel`.
    For example, we want the labels that are contained in `MyView` objects to have
    a green background. We accomplish this by calling the static `AppearanceWhenContainedIn`
    method, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We pass the types of objects for which we want to set the specific style. In
    this case, passing `typeof(MyView)` instructs the appearance proxy to make sure
    that we are referring to objects that are only contained in `MyView` objects.
    We then set the value we want to the object that was returned from this method,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Through the `AppearanceWhenContainedIn` method, we can target a more specific
    set of styling. For example, consider the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This would return a styling object that acts as a proxy for all instances of
    `UILabel`, which are part of `MyView`, only when `MyView` is included in `AnotherView`
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations of UIAppearance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `UIAppearance` protocol has some limitations, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Only specific properties can be set. For example, we cannot set the `Frame`
    of a view globally. Each set of properties that can be changed for a control can
    be accessed through its appearance proxy. If a control property is not in the
    appearance proxy, we cannot modify it for all instances of that particular control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For modifying the appearance of a custom view (in this case, `MyView`), using
    the following line of code will yield an unwanted result:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That is, all instances of `UIView` will have a yellow background. This is because
    C# cannot override the static methods in derived classes. To overcome this issue,
    we use the `GetAppearance<T>` static method on the derived class instead, as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating a custom view recipe*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Creating a custom view controller* recipe in [Chapter 3](ch03.html "Chapter 3. User
    Interface – View Controllers"), *User Interface – View Controllers*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
