- en: Chapter 2. User Interface – Views
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 用户界面 – 视图
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Adding and customizing views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和自定义视图
- en: Receiving user input with buttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按钮接收用户输入
- en: Displaying images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图像
- en: Displaying and editing text
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和编辑文本
- en: Using the keyboard
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘
- en: Displaying progress
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示进度
- en: Displaying content larger than the screen
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示比屏幕更大的内容
- en: Navigating through the content divided into pages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分页内容中导航
- en: Displaying alerts
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示警报
- en: Creating a custom view
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义视图
- en: Styling views
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图样式
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An application's **User Interface** (**UI**) is essential for providing the
    user with an easy way of communicating with a device, be it a computer, a mobile
    phone, or a tablet. On a mobile device, the user interface is not only essential
    but the only way to interact with the user. Developers have to cope with various
    limitations and restrictions when developing applications for mobile devices.
    The processing power of mobile devices does not match that of desktop CPUs, and
    the screens are smaller, making the process of choosing what sort of information
    will be displayed each time somewhat more difficult.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的**用户界面**（**UI**）对于提供用户与设备（无论是计算机、移动电话还是平板电脑）的便捷通信方式至关重要。在移动设备上，用户界面不仅至关重要，而且是与用户交互的唯一方式。开发者在为移动设备开发应用程序时必须应对各种限制和约束。移动设备的处理能力不匹配桌面CPU，屏幕也较小，这使得每次选择要显示的信息类型变得更加困难。
- en: 'In this chapter, we will discuss the key components of an iOS application''s
    UI. We will see how to use and customize these components to create rich application
    user interfaces and discuss the similarities and differences they have with their
    desktop equivalents. The following is a list of these components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论iOS应用程序UI的关键组件。我们将了解如何使用和自定义这些组件来创建丰富的应用程序用户界面，并讨论它们与桌面等价物的相似之处和不同之处。以下是一个组件列表：
- en: '**UIView**: This is a customizable container that is the base object of most
    iOS user interface controls'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIView**：这是一个可定制的容器，是大多数iOS用户界面控件的基础对象'
- en: '**UIButton**: This is the equivalent of a Button in the .NET world'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIButton**：这是.NET世界中的按钮等价物'
- en: '**UILabel**: This is the equivalent of a Label in the .NET world'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UILabel**：这是.NET世界中的标签等价物'
- en: '**UIImageView**: This is a view that allows us to display and create basic
    animations with images'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIImageView**：这是一个允许我们显示和创建基本图像动画的视图'
- en: '**UITextView**: This is a view that allows us to display editable text'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UITextView**：这是一个允许我们显示可编辑文本的视图'
- en: '**UITextField**: This is similar to .NET''s TextBox control'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UITextField**：这与.NET的TextBox控件类似'
- en: '**UIProgressView**: This displays the known length progress'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIProgressView**：这显示已知的长度进度'
- en: '**UIScrollView**: This provides the ability to display scrollable content'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIScrollView**：这提供了显示可滚动内容的能力'
- en: '**UIPageControl**: This provides navigation functionality to the content that
    is divided into different pages or screens'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIPageControl**：这为分为不同页面或屏幕的内容提供导航功能'
- en: '**UIAlertView**: This is the default iOS control for displaying a message box
    to the user'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UIAlertView**：这是iOS中用于向用户显示消息框的默认控件'
- en: We will also talk about how to programmatically create instances of these components
    and how to style and use them efficiently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何以编程方式创建这些组件的实例，以及如何高效地样式化和使用它们。
- en: Adding and customizing views
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和自定义视图
- en: In this recipe, we will discuss how to add and customize `UIView` with Xcode's
    Interface Builder.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何使用Xcode的Interface Builder添加和自定义`UIView`。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Adding views with Interface Builder is a simple task. Let's start by creating
    a new`iPhone Single View Application` project in Xamarin Studio. Name the project
    `FirstViewApp` and open the `FirstViewAppViewController.xib` file with Interface
    Builder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Interface Builder添加视图是一个简单的任务。让我们首先在Xamarin Studio中创建一个新的`iPhone Single View
    Application`项目。将项目命名为`FirstViewApp`，并使用Interface Builder打开`FirstViewAppViewController.xib`文件。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: To add a view to the project, drag-and-drop a `UIView` object from the **Library**
    pad onto the main view. Make sure that it fits the entire window area. To make
    `UIView` accessible, create an outlet for it and name it `subView`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将视图添加到项目中，从**库**垫拖动一个`UIView`对象到主视图。确保它适合整个窗口区域。为了使`UIView`可访问，为其创建一个出口并将其命名为`subView`。
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of outlets and how to use them is discussed in detail in [Chapter
    1](ch01.html "Chapter 1. Development Tools"), *Development Tools*.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于出口的概念及其使用方法将在[第1章](ch01.html "第1章。开发工具")*开发工具*中详细讨论。
- en: Select the view that we have just added and go to the **Inspector** pad. Select
    the **Attributes** tab, and select **Dark Gray Color** in the **Background** drop-down
    list. Now, select the **Size** tab and reduce the view's height by 60 points.
    Save the document.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚刚添加的视图并转到**检查器**面板。选择**属性**选项卡，并在**背景**下拉列表中选择**深灰色**。现在，选择**大小**选项卡并将视图的高度减少60点。保存文档。
- en: Compile and run the app on the simulator. The result should look like the one
    shown in the following screenshot:![How to do it...](img/8924OT_02_01.jpg)
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应该看起来像以下截图所示：![如何操作...](img/8924OT_02_01.jpg)
- en: The dark gray portion of the simulator's screen is the view that we have just
    added.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 模拟器屏幕上的深灰色部分是我们刚刚添加的视图。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have successfully created an app that contains one view. Of course, this
    app does not provide any functionality. It is only meant to show how to add a
    view and display it.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个包含一个视图的应用程序。当然，这个应用程序不提供任何功能。它只是用来展示如何添加视图并显示它。
- en: Views are the essential components of an iOS app interface. Every visual user
    interface object inherits from the `UIView` class. The concept is somewhat different
    from a form in .NET. A view manages content drawing, accepts other views as subviews,
    provides autosizing features, can accept touch events for itself and its subviews,
    and many of its properties can even be animated. Even `UIWindow` inherits from
    `UIView`. It is this class or its inheritors that iOS developers will use most
    frequently.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是iOS应用程序界面的基本组件。每个视觉用户界面对象都继承自`UIView`类。这个概念与.NET中的表单有些不同。视图管理内容绘制，接受其他视图作为子视图，提供自动调整大小功能，可以接受自身及其子视图的触摸事件，并且许多属性甚至可以动画化。甚至`UIWindow`也继承自`UIView`。iOS开发者将最频繁地使用这个类或其继承者。
- en: When a view that is added with Interface Builder is first instantiated at runtime,
    it sets its `Frame` property with values that are set through the **Inspector**
    pad's **Size** tab. The `Frame` property is of the `RectangleF` type, and it defines
    the location of the view in its superview's coordinate system (in our case, the
    main window) and its size in points.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Interface Builder添加的视图在运行时首次实例化时，它使用通过**检查器**面板的**大小**选项卡设置的值来设置其`Frame`属性。`Frame`属性是`RectangleF`类型，它定义了视图在其父视图坐标系中的位置（在我们的例子中，是主窗口）以及其大小（以点为单位）。
- en: Note
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Objective-C, the `frame` property of UIView is of the `CGRect` type. This
    type has not been bound in Xamarin.iOS, and the more familiar `System.Drawing.RectangleF`
    was used instead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，UIView的`frame`属性是`CGRect`类型。此类型在Xamarin.iOS中未绑定，因此使用了更熟悉的`System.Drawing.RectangleF`。
- en: A superview is a view's parent view, while subviews are its child views. Views
    that have the same superview are described as siblings.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 父视图是一个视图的父视图，而子视图是其子视图。具有相同父视图的视图被称为兄弟视图。
- en: The default coordinate system in iOS originates from the top-left corner and
    extends towards the bottom and the right. The coordinate origin is always the
    same and cannot be changed programmatically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: iOS中的默认坐标系起源于左上角并向底部和右侧延伸。坐标原点始终相同，且不能通过编程方式更改。
- en: 'The coordinate system of iOS is displayed in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的坐标系在以下图中显示：
- en: '![How it works...](img/Image1.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/Image1.jpg)'
- en: When the `Frame` property is set, it adjusts the `Bounds` property. The `Bounds`
    property defines the location of the view in its own coordinate system and its
    size in points. It is also of the `RectangleF` type. The default location for
    the `Bounds` property is (0,0), and its size is always the same as the view's
    `Frame` value. Both these properties' sizes are connected to each other, so when
    you change the size of `Frame`, the size of `Bounds` changes accordingly and vice
    versa. You can change the `Bounds` property to display different parts of the
    view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`Frame`属性时，它会调整`Bounds`属性。`Bounds`属性定义了视图在其自身坐标系中的位置以及其大小（以点为单位）。它也是`RectangleF`类型。`Bounds`属性的默认位置是(0,0)，其大小始终与视图的`Frame`值相同。这两个属性的尺寸是相互关联的，因此当你更改`Frame`的大小，`Bounds`的大小也会相应地改变，反之亦然。你可以更改`Bounds`属性以显示视图的不同部分。
- en: A view's frame can exceed the screen in both location and position. That is,
    a view's frame with values *(x = -50, y = -50, width = 1500, height = 1500)* is
    perfectly acceptable, although it will not be completely visible on the screen
    of an iPhone.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个视图的框架可以在位置和位置上超出屏幕。也就是说，具有值 *(x = -50, y = -50, width = 1500, height = 1500)*
    的视图框架是完全可接受的，尽管它将不会在 iPhone 的屏幕上完全可见。
- en: There's more...
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Another thing to note is that the `UIView` class inherits from the `UIResponder`
    class. The `UIResponder` class is responsible for responding to and handling events.
    When a view is added to a superview, it becomes part of its responder chain. The
    `UIView` class exposes the properties and methods of `UIResponder`, and the ones
    we are interested in describing for now are the following two:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，`UIView` 类继承自 `UIResponder` 类。`UIResponder` 类负责响应用和处理事件。当视图被添加到父视图中时，它成为其响应链的一部分。`UIView`
    类公开了 `UIResponder` 的属性和方法，我们现在感兴趣描述的是以下两个：
- en: '**IsFirstResponder property**: This returns a Boolean value indicating whether
    the view is the first responder. Basically, it indicates if the view has focus.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IsFirstResponder 属性**：这个属性返回一个布尔值，表示视图是否是第一个响应者。基本上，它表示视图是否具有焦点。'
- en: '**ResignFirstResponder():** This causes the view to lose focus.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ResignFirstResponder()**：这将使视图失去焦点。'
- en: Adding views programmatically
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式添加视图
- en: 'If we would like to add a view on our main view programmatically, we would
    use the following `UIView.AddSubview(UIView)` method:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以编程方式将视图添加到主视图中，我们将使用以下 `UIView.AddSubview(UIView)` 方法：
- en: '[PRE0]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AddSubview` method adds its parameter, which is of the `UIView` type, to
    the list of the caller's subviews and sets its `Superview` parameter to the caller.
    A view will not be displayed unless it is added to a parent view with the `AddSubview`
    method. Also, if a view already has a superview and it is added to another view
    with its `AddSubview` method, its `Superview` is changed to that of the new caller.
    What this means is that a view can have only one superview at a time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSubview` 方法将其参数（`UIView` 类型）添加到调用者的子视图列表中，并将其 `Superview` 参数设置为调用者。除非使用
    `AddSubview` 方法将其添加到父视图中，否则视图将不会显示。此外，如果视图已经有一个父视图，并且使用其 `AddSubview` 方法添加到另一个视图中，其
    `Superview` 将更改为新的调用者。这意味着视图一次只能有一个父视图。'
- en: Note
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When adding a view as a subview with Interface Builder, it is not required to
    use the `AddSubview` method to display the subview. However, it is required to
    call the `AddSubview` method when adding views programmatically.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Interface Builder 将视图作为子视图添加时，不需要使用 `AddSubview` 方法来显示子视图。然而，当以编程方式添加视图时，必须调用
    `AddSubview` 方法。
- en: For removing a view from its superview programmatically, call its `RemoveFromSuperview`
    method. Calling this method on a view that has no superview does nothing. Care
    must be taken when we want to reuse the view we want to remove. We must keep a
    reference to it, or it might be released.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以编程方式从父视图中删除视图，请调用其 `RemoveFromSuperview` 方法。如果对没有父视图的视图调用此方法，则不会执行任何操作。当我们想要重用要删除的视图时，必须注意。我们必须保留对其的引用，否则它可能会被释放。
- en: View content layout
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图内容布局
- en: Another important property of `UIView` is `ContentMode`. `ContentMode` accepts
    values of the `UIViewContentMode` enumeration type. This property sets how the
    `UIView` will display its content, usually an image. The default value of this
    property is `UIViewContentMode.ScaleToFill`. This scales the content to fit the
    exact view's size, stretching it if necessary. The available values of `UIViewContentMode`
    are explained in detail in the *Displaying Images* recipe later in this chapter.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView` 的另一个重要属性是 `ContentMode`。`ContentMode` 接受 `UIViewContentMode` 枚举类型的值。此属性设置
    `UIView` 将如何显示其内容，通常是图像。此属性的默认值是 `UIViewContentMode.ScaleToFill`。这会将内容缩放到适合视图的确切大小，如果需要则拉伸。`UIViewContentMode`
    的可用值将在本章后面的 *显示图像* 菜谱中详细解释。'
- en: See also
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom view* recipe
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义视图* 菜谱'
- en: The *Creating the UI* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具")中的 *创建 UI* 菜谱，*开发工具*'
- en: The *Accessing the UI with Outlets* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具")中的 *使用连接访问 UI* 菜谱，*开发工具*'
- en: Receiving user input with buttons
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮接收用户输入
- en: In this recipe, we will learn how to use buttons to receive and respond to user
    input.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用按钮来接收和响应用户输入。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We used buttons in [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development*
    *Tools*, to discuss how to use Interface Builder to add controls to the user interface.
    In this recipe, we will describe the `UIButton` class in more detail. Open the
    `FirstViewApp` project, which we created in the previous recipe, in Xamarin Studio.
    Increase the height of the view, which we added, to cover the whole device screen
    in Interface Builder and save the document.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第1章](ch01.html "第1章。开发工具")，*开发工具*中使用了按钮，讨论了如何使用Interface Builder将控件添加到用户界面。在本食谱中，我们将更详细地描述`UIButton`类。在Xamarin
    Studio中打开我们在上一个食谱中创建的`FirstViewApp`项目。增加我们添加的视图的高度，使其在Interface Builder中覆盖整个设备屏幕，并保存文档。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'We will programmatically add a button in our interface. This button will change
    our view''s background color when tapped. Open the `FirstViewAppViewController.cs`
    file and enter the following code in the class:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在我们的界面中以编程方式添加一个按钮。此按钮在被点击时会改变我们视图的背景颜色。打开`FirstViewAppViewController.cs`文件，并在类中输入以下代码：
- en: '[PRE1]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `ViewDidLoad` method, add the following line:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中，添加以下行：
- en: '[PRE2]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Compile and run the app on the simulator. When the button is tapped, the result
    should be similar to the following screenshot:![How to do it...](img/8924OT_02_03.jpg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。当按钮被点击时，结果应类似于以下截图：![如何操作...](img/8924OT_02_03.jpg)
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we have added a button to the user interface. This button changes
    the background color of its superview. Furthermore, we have accomplished this
    without using Interface Builder at all.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们向用户界面添加了一个按钮。此按钮会改变其父视图的背景颜色。此外，我们没有使用Interface Builder就完成了这个任务。
- en: 'Let''s see now what the code does. We create the following field that will
    hold the button object:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看代码是如何工作的。我们创建以下字段来保存按钮对象：
- en: '[PRE3]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `CreateButton` method, we create the button and set some properties.
    The method is shown in the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CreateButton`方法中，我们创建按钮并设置一些属性。该方法如下所示：
- en: '[PRE4]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, we assign the view''s frame to a new variable named `viewFrame`. Then,
    we create a new `RectangleF` object named `buttonFrame`. This object will be assigned
    to the button''s `Frame` property. Now that we have a frame for our button, we
    can initialize it as shown in the following code snippet:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将视图的框架分配给一个名为`viewFrame`的新变量。然后，我们创建一个名为`buttonFrame`的新`RectangleF`对象。此对象将被分配给按钮的`Frame`属性。现在我们为我们的按钮有了框架，我们可以按照以下代码片段初始化它：
- en: '[PRE5]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The button is initialized with the `UIButton.FromType(UIButtonType)` static
    method. This method takes one parameter of the `UIButtonType` type and returns
    predefined types of buttons that are included in iOS SDK. The `UIButtonType.System`
    button enumeration value used here is the default type of button without any borders
    or background. After the `buttonChangeColor` object is initialized, we set its
    frame to the `RectangleF` value we created earlier.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是通过`UIButton.FromType(UIButtonType)`静态方法初始化的。此方法接受一个`UIButtonType`类型的参数，并返回iOS
    SDK中包含的预定义按钮类型。这里使用的`UIButtonType.System`按钮枚举值是默认类型，没有边框或背景。在`buttonChangeColor`对象初始化后，我们将其框架设置为之前创建的`RectangleF`值。
- en: 'Now that we have provided an initialization code for the button, we will set
    its titles (that''s right, more than one) as shown in the following code:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为按钮提供了初始化代码，我们将设置其标题（没错，不止一个），如下所示：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We call the `UIButton.SetTitle(string, UIControlState)` method twice. This
    method is responsible for setting the button''s title for each given button state.
    The string parameter is the actual title that will be shown. The second parameter
    is an enumeration of the `UIControlState` type. This parameter indicates the different
    control states that apply to controls. These control states are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们调用了两次`UIButton.SetTitle(string, UIControlState)`方法。此方法负责为每个给定的按钮状态设置按钮的标题。字符串参数是实际显示的标题。第二个参数是`UIControlState`类型的枚举。此参数表示应用于控件的不同控件状态。这些控件状态如下：
- en: '**Normal**: This is the default idle state of an enabled control.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**：这是启用控件默认的空闲状态。'
- en: '**Highlighted**: This is the state of the control when a touch-up event occurs.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高亮**：这是控件在触摸抬起事件发生时的状态。'
- en: '**Disabled**: This is the state when the control is disabled and does not accept
    any events.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**禁用**：这是控件被禁用且不接受任何事件的状态。'
- en: '**Selected**: This is the state when the control is selected. In most cases,
    this state does not apply. However, it is useful when a selection state is required,
    like in a `UISegmentedControl` object.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选中**：这是控件被选中的状态。在大多数情况下，此状态不适用。然而，当需要选择状态时，它很有用，例如在`UISegmentedControl`对象中。'
- en: '**Application**: This is the additional control state value for an application''s
    use.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用**：这是为应用程序使用提供的附加控件状态值。'
- en: '**Reserved**: This is for internal framework use.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保留**：这是供内部框架使用的。'
- en: So, with the `UIButton.SetTitle(string, UIControlState)` method, we have set
    the title that will be displayed when the button is in its default state and the
    title that will be displayed while the button is being tapped.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，使用`UIButton.SetTitle(string, UIControlState)`方法，我们设置了按钮在其默认状态下将显示的标题，以及按钮在被点击时将显示的标题。
- en: 'After this, we set the button''s handler for the `TouchUpInside` event and
    add it as a subview to `subView` using the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码设置按钮的`TouchUpInside`事件处理程序，并将其作为子视图添加到`subView`中：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `buttonChangeColor_TouchUpInside` event, we change the background
    color of the view according to the Boolean field that we have declared, as shown
    in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在`buttonChangeColor_TouchUpInside`事件内部，我们根据我们声明的布尔字段更改视图的背景颜色，如下面的代码所示：
- en: '[PRE8]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is done by setting the view's `BackgroundColor` property to the appropriate
    `UIColor` class instance we want, as shown in the preceding highlighted code.
    The `UIColor` object is a class with many different static methods and properties
    that allow us to create different colored objects.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这通过将视图的`BackgroundColor`属性设置为所需的`UIColor`类实例来完成，如前面突出显示的代码所示。`UIColor`对象是一个具有许多不同静态方法和属性的类，允许我们创建不同颜色的对象。
- en: When you compile and run the app on the simulator, notice the view's color change
    when you tap the button. Also notice how the button's title changes while the
    mouse cursor (or a finger on the device) is "touching" the button.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上编译并运行应用程序时，请注意当你点击按钮时视图的颜色变化。同时请注意，当鼠标光标（或设备上的手指）"触摸"按钮时，按钮的标题如何变化。
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In this recipe, we used the `UIButton.FromType(UIButtonType)` static method
    to initialize the button. A brief description of each of the enumeration flags
    of `UIButtonType` are as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们使用了`UIButton.FromType(UIButtonType)`静态方法来初始化按钮。以下是`UIButtonType`枚举标志的简要描述：
- en: '**System**: This is the default type of button.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统**：这是按钮的默认类型。'
- en: '**Custom**: This is a borderless transparent button. Use this flag when creating
    custom buttons with images as backgrounds. The button''s title is not transparent.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：这是一个无边框的透明按钮。在创建具有图像背景的自定义按钮时使用此标志。按钮的标题不是透明的。'
- en: '**RoundedRect**: This is the default type of button with rounded corners. As
    of iOS 7, this type of `UIButton` is deprecated. Use `UIButtonType.System` instead.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**圆角矩形**：这是具有圆角的默认按钮类型。截至iOS 7，此类型的`UIButton`已被弃用。请使用`UIButtonType.System`代替。'
- en: '**DetailDisclosure**: This is a round blue button that reveals additional information
    related to an item.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**详细披露**：这是一个揭示与项目相关额外信息的圆形蓝色按钮。'
- en: '**InfoLight**: This is a light-colored button with the letter (**i**) that
    represents information display.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息浅色**：这是一个带有代表信息显示的字母（**i**）的浅色按钮。'
- en: '**InfoDark**: This is the same as InfoLight; it is shown with a dark color.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息深色**：这与InfoLight相同；它以深色显示。'
- en: '**ContactAdd**: This is a round blue button with a white plus sign (**+**).
    Usually, this button is displayed to present contact information to add to an
    item.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系人添加**：这是一个带有白色加号（**+**）的圆形蓝色按钮。通常，此按钮用于显示要添加到项目中的联系人信息。'
- en: Changing the appearance of buttons
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 改变按钮的外观
- en: For creating custom buttons with the `UIButtonType.Custom` type, use the `UIButton`
    class' `SetBackgroundImage` and `SetImage` methods. They both accept one `UIImage`
    and one `UIControlState` parameter so that different images for different control
    states can be set. When setting images for buttons, be sure to set the `UIButton.ContentMode`
    property accordingly, irrespective of whether creating a custom button or not.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用`UIButtonType.Custom`类型创建自定义按钮，请使用`UIButton`类的`SetBackgroundImage`和`SetImage`方法。它们都接受一个`UIImage`和一个`UIControlState`参数，以便可以设置不同控件状态的不同图像。在设置按钮的图像时，务必相应地设置`UIButton.ContentMode`属性，无论是否创建自定义按钮。
- en: 'The functionality provided by the `SetImage` and `SetBackgroundImage` methods
    can also be accomplished in the corresponding **Image** and **Background** fields
    in the **Attributes** tab of the **Inspector** pad in Interface Builder. Select
    the state for which to set the desired image(s) from the drop-down list box and
    set the path to the image file, as shown in the following screenshot:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetImage`和`SetBackgroundImage`方法提供的功能也可以在Interface Builder中**检查器垫**的**属性**选项卡中的相应**图像**和**背景**字段中完成。从下拉列表框中选择要设置所需图像的状态，并设置图像文件的路径，如下面的截图所示：'
- en: '![Changing the appearance of buttons](img/8924OT_02_04.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![更改按钮外观](img/8924OT_02_04.jpg)'
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding and customizing views* recipe
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**添加和自定义视图**配方'
- en: The *Displaying images* recipe
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示图像**配方'
- en: The *Creating a custom view* recipe
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建自定义视图**配方'
- en: The *Styling views* recipe
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**样式化视图**配方'
- en: The *Creating the UI* recipe in [Chapter 1](ch01.html "Chapter 1. Development
    Tools"), *Development Tools*
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**第1章**中**开发工具**的**创建UI**配方'
- en: Displaying images
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图像
- en: In this recipe, we will learn how to use the `UIImageView` class to display
    images on screen.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用`UIImageView`类在屏幕上显示图像。
- en: Getting ready
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will see how to bundle and display images in a project. An
    image file will be needed for display. The image file used here is named `Toroni.jpg`.
    Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `ImageViewerApp`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将了解如何在项目中捆绑和显示图像。需要显示一个图像文件。这里使用的图像文件命名为`Toroni.jpg`。在Xamarin Studio中创建一个新的iPhone**单视图应用程序**项目，并将其命名为`ImageViewerApp`。
- en: How to do it...
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps for this recipe:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个配方的步骤：
- en: Open the `ImageViewerAppViewController.xib` file in Interface Builder.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`ImageViewerAppViewController.xib`文件。
- en: Add a `UIImageView` object on its view. Connect the `UIImageView` object with
    an outlet named `imageDisplay`.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图中添加一个`UIImageView`对象。将`UIImageView`对象与名为`imageDisplay`的输出连接起来。
- en: Save the document.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in Xamarin Studio, in the `ImageViewerAppViewController` class, enter
    the following code:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中，进入`ImageViewerAppViewController`类，输入以下代码：
- en: '[PRE9]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right-click on the project in the **Solution** pad and navigate to **Add** |
    **Add Files…**. Select the image file you want to display and click on **Open**.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**解决方案垫**中的项目，导航到**添加** | **添加文件…**。选择要显示的图像文件，然后点击**打开**。
- en: Right-click on the image file you have just added and navigate to **Build Action**
    | **BundleResource**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击你刚刚添加的图片文件，导航到**构建操作** | **捆绑资源**。
- en: Finally, compile and run the app on the simulator. The image you added to the
    project should be displayed on the screen, like in the following screenshot:![How
    to do it...](img/8924OT_02_05.jpg)
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在模拟器上编译并运行应用程序。你添加到项目中的图片应该显示在屏幕上，如下面的截图所示：![如何操作...](img/8924OT_02_05.jpg)
- en: How it works...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The `UIImageView` class is basically a view customized for displaying images.
    When you add an image in a project, its **Build Action** must be set to **BundleResource**
    in the **Solution** pad; otherwise, the image will not be copied into the app
    bundle. Fortunately, Xamarin Studio is smart enough to handle this setting automatically
    for images.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`类基本上是一个为显示图像而定制的视图。当你在一个项目中添加图片时，其**构建操作**必须在**解决方案垫**中设置为**捆绑资源**；否则，图片将不会被复制到应用程序捆绑包中。幸运的是，Xamarin
    Studio足够智能，可以自动处理图像的此设置。'
- en: 'The `ContentMode` property is very important when displaying images. It sets
    the way the `UIView` (`UIImageView` in this case) object will display the image.
    We have set it to `UIViewContentMode.ScaleAspectFit` so that it will be resized
    to fit the area of `UIImageView`, keeping the aspect ratio intact at the same
    time. If the `ContentMode` property was left at its default `ScaleToFill` value,
    the output would be something like the one shown in the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示图像时，`ContentMode`属性非常重要。它设置了`UIView`（在本例中为`UIImageView`）对象将如何显示图像。我们将其设置为`UIViewContentMode.ScaleAspectFit`，以便它将调整大小以适应`UIImageView`的区域，同时保持宽高比不变。如果`ContentMode`属性保留为默认的`ScaleToFill`值，输出将类似于以下截图所示：
- en: '![How it works...](img/8924OT_02_06.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/8924OT_02_06.jpg)'
- en: 'To set the image that `UIImageView` should display, we set its `Image` property
    with a `UIImage` object, as shown in the following code:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`UIImageView`应显示的图片，我们使用`UIImage`对象设置其`Image`属性，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ContentMode` property accepts an enumeration type named `UIViewContentMode`.
    The values provided are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentMode` 属性接受一个名为 `UIViewContentMode` 的枚举类型。提供的值如下：'
- en: '`ScaleToFill`: This is the default value of the base `UIView` object. It scales
    the content to fit the size of the view, changing the aspect ratio as necessary.'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleToFill`: 这是基本 `UIView` 对象的默认值。它将内容缩放以适应视图的大小，必要时更改宽高比。'
- en: '`ScaleAspectFit`: This scales the content to fit the size of the view, maintaining
    its aspect ratio. The remaining area of the view''s content becomes transparent.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleAspectFit`: 这将内容缩放以适应视图的大小，同时保持其宽高比。视图内容的剩余区域变为透明。'
- en: '`ScaleAspectFill`: This scales the content to fill the size of the view, maintaining
    its aspect ratio. Some part of the content may be left out.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScaleAspectFill`: 这会将内容缩放以填充视图的大小，同时保持其宽高比。部分内容可能会被裁剪掉。'
- en: '`Redraw`: When a view''s bounds are changed, its content is not redrawn. This
    value causes the content to be redrawn. Drawing content is an expensive operation
    in terms of CPU cycles, so think twice before using this value with large content.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Redraw`: 当视图的边界发生变化时，其内容不会被重新绘制。此值会导致内容被重新绘制。在 CPU 周期内，绘制内容是一项昂贵的操作，因此在使用此值与大量内容一起使用之前请三思。'
- en: '`Center`: This places the content at the center of the view, keeping its aspect
    ratio.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Center`: 这将内容放置在视图的中心，同时保持其宽高比。'
- en: '`Top`, `Bottom`, `Left`, `Right`, `TopLeft`, `TopRight`, `BottomLeft`, and
    `BottomRight`: These align the content in the view with the corresponding value.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Top`, `Bottom`, `Left`, `Right`, `TopLeft`, `TopRight`, `BottomLeft`, 和 `BottomRight`:
    这些将内容在视图中对齐到相应的值。'
- en: There's more...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `UIImage` class is the object that represents image information. The file
    formats it supports are listed in the following table:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImage` 类是表示图像信息的对象。它支持的文件格式如下表所示：'
- en: '| File Format | File extension |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| 文件格式 | 文件扩展名 |'
- en: '| --- | --- |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Portable Network Graphics (PNG) | `.png` |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 可移植网络图形 (PNG) | `.png` |'
- en: '| Joint Photographic Experts Group (JPEG) | `.jpg`, `.jpeg` |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 联合图像专家小组 (JPEG) | `.jpg`, `.jpeg` |'
- en: '| Tagged Image File Format (TIFF) | `.tiff`, `.tif` |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| 标记图像文件格式 (TIFF) | `.tiff`, `.tif` |'
- en: '| Graphic Interchange Format | `.gif` |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| 图形交换格式 | `.gif` |'
- en: '| Windows Bitmap Format | `.bmp` |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| Windows 位图格式 | `.bmp` |'
- en: '| Windows Icon Format | `.ico` |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| Windows 图标格式 | `.ico` |'
- en: '| Windows Cursor | `.cur` |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| Windows 光标 | `.cur` |'
- en: '| XWindow bitmap | `.xbm` |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| XWindow位图 | `.xbm` |'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Animated GIF image files are not supported by the `UIImageView` class. When
    an animated GIF is set to the `Image` property of `UIImageView`, only its first
    frame will be displayed as a static image.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 类不支持动画 GIF 图像文件。当动画 GIF 被设置为 `UIImageView` 的 `Image` 属性时，只有其第一帧将以静态图像的形式显示。'
- en: Using images for different screen sizes
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同屏幕尺寸的图像
- en: 'Creating images for backgrounds provides developers with the ability to produce
    rich and elegant user interfaces for their apps. The preferred image file format
    for creating backgrounds for views is PNG. However, since iPhone 4 was released,
    the screen resolution was increased. To support both screen resolutions in an
    app, the iOS SDK provides an easy solution. Just save the image in the higher
    resolution and add a `@2x` suffix to the file name just before the extension.
    For example, the name of a higher resolution version of a file named `Default.png`
    would be `Default@2x.png`. Also, no extra code is required to use both files.
    Just use the `UIImage.FromBundle(string)` static method, passing the file name
    without an extension. The following line of code would load the appropriate file,
    depending on the screen resolution:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 为背景创建图像为开发者提供了为他们的应用程序创建丰富和优雅的用户界面的能力。为视图创建背景的首选图像文件格式是 PNG。然而，自从 iPhone 4 发布以来，屏幕分辨率已经提高。为了在应用程序中支持两种屏幕分辨率，iOS
    SDK 提供了一个简单的解决方案。只需将图像保存为高分辨率，并在扩展名之前添加一个 `@2x` 后缀。例如，名为 `Default.png` 的文件的高分辨率版本名称将是
    `Default@2x.png`。此外，无需额外的代码即可使用这两个文件。只需使用 `UIImage.FromBundle(string)` 静态方法，传递不带扩展名的文件名。以下行代码将根据屏幕分辨率加载适当的文件：
- en: '[PRE11]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: iOS takes care of loading the appropriate file, depending on the device the
    app is running on.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 会根据应用程序运行的设备加载适当的文件。
- en: Note
  id: totrans-168
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding case only applies to PNG image files.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的情况仅适用于 PNG 图像文件。
- en: See also
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding and customizing views* recipe
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图* 烹饪法'
- en: The *Selecting images and videos* recipe in [Chapter 7](ch07.html "Chapter 7. Multimedia
    Resources"), *Multimedia Resources*
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 7 章](ch07.html "第 7 章。多媒体资源") 的 *选择图像和视频* 烹饪法中，*多媒体资源*
- en: Displaying and editing text
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和编辑文本
- en: In this recipe, we will learn how to display simple text blocks with editing
    functionality.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用编辑功能显示简单的文本块。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will discuss the usage of `UITextView` and how to display
    editable text with it. Create a new iPhone **Single View Application** project
    in Xamarin Studio and name it `TextViewApp`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论`UITextView`的使用以及如何使用它显示可编辑文本。在Xamarin Studio中创建一个新的iPhone**单视图应用程序**项目，并将其命名为`TextViewApp`。
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open `TextViewAppViewController.xib` in Interface Builder.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`TextViewAppViewController.xib`。
- en: Add a `UIButton` near the top of its view and a `UITextView` below it. Connect
    both objects to their outlets.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的顶部附近添加一个`UIButton`，在其下方添加一个`UITextView`。将两个对象连接到它们的出口。
- en: Save the document.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in Xamarin Studio, enter the following `ViewDidLoad` method in the `TextViewAppViewController`
    class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到Xamarin Studio，在`TextViewAppViewController`类中输入以下`ViewDidLoad`方法：
- en: '[PRE12]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following nested class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下嵌套类：
- en: '[PRE13]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run the app on the simulator. Tap somewhere in the text view and
    the keyboard will appear. Type some text and then tap on the **Finished** button
    to hide the keyboard.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在文本视图中点击某个位置，键盘将出现。输入一些文本，然后点击**完成**按钮以隐藏键盘。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UITextView` class provides an object that displays editable blocks of
    text. To respond to the events of our text view, we have implemented a class (shown
    in the following code) that inherits from `UITextViewDelegate`, which will act
    as the text view''s delegate:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITextView`类提供了一个显示可编辑文本块的对象。为了响应文本视图的事件，我们实现了一个从`UITextViewDelegate`继承的类（如下面的代码所示），它将作为文本视图的代理：'
- en: '[PRE14]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We declared a constructor that accepts a `TextViewAppViewController` object
    so that we can have the instance of our controller available to access our controls.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个接受`TextViewAppViewController`对象的构造函数，这样我们就可以访问我们的控件并获取我们控制器的实例。
- en: 'Then, we override three methods of the `UITextViewDelegate` class, as shown
    in the following code:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重写了`UITextViewDelegate`类的三个方法，如下面的代码所示：
- en: '[PRE15]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: These methods are the handlers that will get called whenever a corresponding
    event is triggered. When tapping on the text view, the `EditingStarted` method
    gets called. We enable the **Finished** button in it. When we type some text in
    the text view, the `Changed` method gets called, and we can see the output of
    the `Console.WriteLine` method in Xamarin Studio's **Application Output** pad.
    Finally, when we tap on the **Finished** button, the keyboard hides, and the `EditingEnded`
    method gets called. This method allows us to disable the button.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是在相应事件被触发时会被调用的处理程序。当点击文本视图时，会调用`EditingStarted`方法。我们在其中启用**完成**按钮。当我们向文本视图中输入一些文本时，会调用`Changed`方法，我们可以在Xamarin
    Studio的**应用程序输出**面板中看到`Console.WriteLine`方法的输出。最后，当我们点击**完成**按钮时，键盘隐藏，并调用`EditingEnded`方法。此方法允许我们禁用按钮。
- en: 'In the `ViewDidLoad` method, we assign a handler to the `TouchUpInside` event
    of the button, as shown in the following code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中，我们为按钮的`TouchUpInside`事件分配了一个处理程序，如下面的代码所示：
- en: '[PRE16]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We call the text view''s `ResignFirstResponder()` method in it so that when
    the button is tapped, the text view will lose focus, causing the keyboard to hide.
    Then, we assign a new instance of the delegate we created to the text view''s
    `Delegate` property, passing the instance of the `TextViewAppViewController` object,
    as shown in the following code:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在文本视图的`ResignFirstResponder()`方法中调用它，这样当按钮被点击时，文本视图将失去焦点，导致键盘隐藏。然后，我们将我们创建的代理的新实例分配给文本视图的`Delegate`属性，传递`TextViewAppViewController`对象的实例，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Delegates in Objective-C are somewhat different than those in C#. Although in
    both worlds, their most common usage is to provide access to some form of event
    notification mechanism, in Objective-C, this mechanism is a bit more complex.
    A C# delegate is much like a function pointer in C or C++ programming languages.
    It is an object that holds a reference to a method of a specific signature. On
    the other hand, an Objective-C delegate is a certain type of object that conforms
    to a specific `protocol`. It is basically an object that wraps one or more methods
    (and/or other members) that act as event handlers.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C中的委托与C#中的委托有所不同。尽管在两个世界中，它们最常用的用途都是提供对某种形式的事件通知机制的访问，但在Objective-C中，这种机制要复杂一些。C#委托类似于C或C++编程语言中的函数指针。它是一个包含对特定签名的特定方法引用的对象。另一方面，Objective-C委托是一种符合特定`协议`的特定类型的对象。它基本上是一个封装了一个或多个方法（以及/或其它成员）的对象，这些方法充当事件处理器。
- en: Note
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An Objective-C protocol is similar to an interface in C#.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C协议类似于C#中的接口。
- en: The concept of delegate objects might seem confusing at first, but it is not
    difficult to comprehend. Regarding the event notification mechanism, Xamarin.iOS
    simplifies things for .NET developers by providing events for most objects, including
    `UITextView` described here.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 委托对象的概念一开始可能看起来有些复杂，但实际上并不难理解。关于事件通知机制，Xamarin.iOS通过为大多数对象提供事件（包括这里描述的`UITextView`）来简化.NET开发者的工作。
- en: See also
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Using the keyboard* recipe
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用键盘*菜谱'
- en: Using the keyboard
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘
- en: In this recipe, we will discuss some important aspects of the device's virtual
    keyboard usage.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论设备虚拟键盘使用的一些重要方面。
- en: Getting ready
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous recipe, we discussed how to edit text. In this recipe, we will
    discuss some of the things we can or even must do to use the keyboard effectively.
    Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `KeyboardApp`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们讨论了如何编辑文本。在这个菜谱中，我们将讨论一些我们可以做，甚至必须做的事情来有效地使用键盘。在Xamarin Studio中创建一个新的iPhone**单视图应用程序**项目，并将其命名为`KeyboardApp`。
- en: How to do it...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Perform the following steps:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `KeyboardAppViewController.xib` file in Interface Builder.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`KeyboardAppViewController.xib`文件。
- en: Add a `UITextField` object in the bottom-half portion of the view and connect
    it to an outlet.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的下半部分添加一个`UITextField`对象，并将其连接到一个出口。
- en: Save the document.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in Xamarin Studio, enter the following code in the `KeyboardAppViewController`
    class:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中，在`KeyboardAppViewController`类中输入以下代码：
- en: '[PRE18]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Compile and run the app on the simulator. Tap on the text field and watch it
    moving upwards to avoid being hidden from the keyboard. Tap the **Done** button
    on the keyboard and watch the text field returning to its original position when
    the keyboard hides.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击文本框，观察它向上移动以避免被键盘隐藏。点击键盘上的**完成**按钮，观察文本框在键盘隐藏时返回到其原始位置。
- en: How it works...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'There are various types of keyboards in iOS. Since not all keys can be displayed
    at once due to the restricted screen size, it is a good practice to set the appropriate
    type of keyboard according to the text input we need the user to provide. In this
    project, we have set the keyboard to the **Email Address** type. We have also
    customized the type of **Return key** by setting it to **Done** in the following
    code:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: iOS中有各种类型的键盘。由于屏幕尺寸有限，无法一次性显示所有按键，因此根据我们需要用户提供的文本输入设置适当的键盘类型是一种良好的做法。在这个项目中，我们将键盘设置为**电子邮件地址**类型。我们还在以下代码中自定义了**返回键**的类型，将其设置为**完成**：
- en: '[PRE19]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When the keyboard is displayed, it is the developer''s responsibility to make
    sure it does not obstruct the essential UI elements. In this case, since we provide
    the user with the ability to enter some text input, we have to make sure that
    the text field is shown, so the user will be able to see what is being typed.
    For this, we add two observers in the default notification center using the following
    code:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 当键盘显示时，确保它不会遮挡必要的UI元素是开发者的责任。在这种情况下，由于我们提供了用户输入文本的能力，我们必须确保文本框是可见的，这样用户才能看到正在输入的内容。为此，我们使用以下代码在默认的通知中心添加了两个观察者：
- en: '[PRE20]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The notification center is iOS' mechanism for providing system-wide notifications.
    Normally, it can be accessed through the `NSNotificationCenter.DefaultCenter`
    static property. However, Xamarin.iOS provides some APIs that simplify things
    for us. In the example project for this recipe, you will find the usage of both
    APIs. In this recipe, we are using Xamarin's APIs.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 通知中心是iOS提供系统级通知的机制。通常，可以通过`NSNotificationCenter.DefaultCenter`静态属性访问它。然而，Xamarin.iOS提供了一些API，这些API简化了我们的操作。在这个菜谱的示例项目中，你可以找到这两个API的使用示例。在这个菜谱中，我们使用的是Xamarin的API。
- en: 'By calling `UIKeyboard.Notifications.ObserveWillShow` and passing a handler
    to it, we subscribe to the notification center so that we get notified whenever
    the keyboard is about to be displayed. This handler is of the `EventHandler<UIKeyboardEventArgs>`
    type, and the `UIKeyboardEventArgs` parameter provides us with, among others,
    the frame of the keyboard after it has been shown (as shown in the following code):'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`UIKeyboard.Notifications.ObserveWillShow`并将其传递一个处理程序，我们订阅了通知中心，以便在键盘即将显示时得到通知。此处理程序是`EventHandler<UIKeyboardEventArgs>`类型，`UIKeyboardEventArgs`参数为我们提供了，包括键盘显示后的框架（如下面的代码所示）：
- en: '[PRE21]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, we store the text field''s frame in a variable using the following code:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用以下代码将文本字段的框架存储在一个变量中：
- en: '[PRE22]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We reduce the frame''s `Y` position using the following code value so that
    the text field will move upwards:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码值来减少框架的`Y`位置，以便文本字段向上移动：
- en: '[PRE23]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When the new frame is set to `emailField` (as shown in the following code),
    it will move to the new position:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 当新框架设置为`emailField`（如下面的代码所示）时，它将移动到新位置：
- en: '[PRE24]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The second handler is needed for moving the text field back to its original
    position after the keyboard is closed. It is almost the same as the first handler,
    except for two differences. The `UIKeyboard.Notifications.ObserveDidHide` method
    is used. This method will trigger our handler after the keyboard is hidden. In
    this handler, we just make sure that we readjust the text field's position back
    to where it was.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个处理程序是在键盘关闭后需要将文本字段移回原始位置的。它与第一个处理程序几乎相同，除了两个不同之处。使用`UIKeyboard.Notifications.ObserveDidHide`方法。此方法将在键盘隐藏后触发我们的处理程序。在这个处理程序中，我们只是确保我们将文本字段的定位调整回原来的位置。
- en: 'The last few lines of code in the `ViewDidLoad` method set the `ShouldReturn`
    property of the `UITextField` class. This property accepts a delegate of the `UITextFieldCondition`
    type, as shown in the following code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法的最后几行代码中设置了`UITextField`类的`ShouldReturn`属性。此属性接受一个`UITextFieldCondition`类型的委托，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The handler we have added is called whenever the user taps the return key on
    the virtual keyboard. Here, we call the `ResignFirstResponder` method of `UITextField`,
    which will hide our keyboard.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在虚拟键盘上点击回车键时，我们添加的处理程序会被调用。在这里，我们调用`UITextField`的`ResignFirstResponder`方法，这将隐藏我们的键盘。
- en: There's more...
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The two fields of the `NSObject` type in the class, which are assigned to the
    return values of the `UIKeyboard.Notifications` methods we used, hold information
    about the observers we added. For removing the two observers we have added here,
    add the following code:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 类中`NSObject`类型的两个字段，它们被分配给了我们使用的`UIKeyboard.Notifications`方法的返回值，包含有关我们添加的观察者的信息。为了移除我们在这里添加的两个观察者，请添加以下代码：
- en: '[PRE26]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Note
  id: totrans-238
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Care must be taken when developing an app that uses the keyboard and supports
    multiple interface orientations. If, for example, the keyboard appears in portrait
    orientation and the user changes to landscape orientation, both the keyboard's
    bounds and the text field's frame will be different and must be adjusted accordingly.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发使用键盘并支持多个界面方向的应用程序时，必须小心。例如，如果键盘以纵向模式出现，而用户切换到横向模式，则键盘的边界和文本字段的框架都将不同，必须相应地进行调整。
- en: See also
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying and editing text* recipe
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本* 菜谱'
- en: The *Adjusting the UI orientation* recipe in [Chapter 9](ch09.html "Chapter 9. Interacting
    with Device Hardware"), *Interacting with Device Hardware*
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第9章](ch09.html "第9章。与设备硬件交互")的*调整UI方向*菜谱中，*与设备硬件交互*
- en: Displaying progress
  id: totrans-243
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示进度
- en: In this recipe, we will discuss how to display the progress of known length.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何显示已知长度的进度。
- en: Getting ready
  id: totrans-245
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will talk about the `UIProgressView` control. This control
    provides a similar functionality to the ProgressBar control in .NET. Create a
    new iPhone **Single View Application** project in Xamarin Studio and name it `ProgressApp`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论`UIProgressView`控件。此控件提供与.NET中ProgressBar控件类似的功能。在Xamarin Studio中创建一个新的iPhone**单视图应用程序**项目，并将其命名为`ProgressApp`。
- en: How to do it...
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The following are the steps for using the `UIProgressView` class. Note that
    in this recipe, we will add all the controls programmatically without the use
    of Interface Builder.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是如何使用`UIProgressView`类的步骤。请注意，在这个菜谱中，我们将使用编程方式添加所有控件，而不使用Interface Builder。
- en: 'Add the following `using` directives in the `ProgressAppViewController` class
    file:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ProgressAppViewController`类文件中添加以下`using`指令：
- en: '[PRE27]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Add the following fields in the class:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下字段：
- en: '[PRE28]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Enter the following code in the `ViewDidLoad` override:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`重写中输入以下代码：
- en: '[PRE29]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following method in the class:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE30]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile and run the app on the simulator. Tap on the button and watch the progress
    bar fill.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击按钮并观察进度条填充。
- en: How it works...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The current value of `UIProgressView` is represented by its `Progress` property.
    Its acceptable value range is always from `0` to `1`. So, when we initialize it,
    we set it to `0` to make sure that the bar is not filled at all. This can be done
    using the following code:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIProgressView`的当前值由其`Progress`属性表示。其可接受值范围始终从`0`到`1`。因此，当我们初始化它时，我们将其设置为`0`以确保条形不会填充任何内容。这可以通过以下代码完成：'
- en: '[PRE31]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Since `UIProgressView` has a specific range, we need to assign the value we
    want it to be incremented by, depending on the number of items we need to process
    (in this case, 10) using the following code:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`UIProgressView`有一个特定的范围，我们需要根据我们需要处理的项数（在这种情况下，10）来分配我们希望它增加的值，使用以下代码：
- en: '[PRE32]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the button''s `TouchUpInside` handler, we disable the button and start our
    progress through `Task` from `System.Threading.Tasks`, as shown in the following
    code:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮的`TouchUpInside`处理程序中，我们禁用按钮并从`System.Threading.Tasks`中的`Task`开始我们的进度，如下所示：
- en: '[PRE33]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the `StartProgress()` method, we start a loop that will process the work,
    which needs to be done. Since the work executes on a separate thread, when we
    want to make changes to the controls, it must be done on the main UI thread by
    calling the `InvokeOnMainThread` method, which accepts a parameter of the `NSAction`
    type. An `NSAction` type parameter can accept anonymous methods as well, as seen
    in the following code:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StartProgress()`方法中，我们启动一个循环来处理需要完成的工作。由于工作在单独的线程上执行，当我们想要更改控件时，必须在主UI线程上通过调用`InvokeOnMainThread`方法来完成，该方法接受一个`NSAction`类型的参数。`NSAction`类型参数还可以接受匿名方法，如以下代码所示：
- en: '[PRE34]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There's more...
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The progress view supports two styles. `UIProgressViewStyle.Default` (the one
    that was used in this recipe) and `UIProgressViewStyle.Bar`. There is absolutely
    no functionality difference between the two styles, except for appearance. To
    change the style of the progress view, set its `Style` property to one of the
    previously mentioned values.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 进度视图支持两种样式。`UIProgressViewStyle.Default`（在这个菜谱中使用的那种）和`UIProgressViewStyle.Bar`。这两种样式之间没有任何功能差异，除了外观。要更改进度视图的样式，将其`Style`属性设置为之前提到的值之一。
- en: UIProgressView height
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIProgressView的高度
- en: Setting the height of the progress view has no effect, as it is constant for
    the control. For creating a variable-height progress bar, the `UIProgressView`
    class must be subclassed.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 设置进度视图的高度没有效果，因为对于控件来说它是恒定的。要创建可变高度的进度条，必须对`UIProgressView`类进行子类化。
- en: See also
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Receiving user input with buttons* recipe
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用按钮接收用户输入*的菜谱'
- en: Displaying content larger than the screen
  id: totrans-273
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示比屏幕更大的内容
- en: In this recipe, we will learn how to display content that extends beyond the
    screen's bounds.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何显示超出屏幕边界的内联内容。
- en: Getting ready
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will discuss the `UIScrollView` control. Create a new iPhone
    **Single View Application** project and name it `ScrollApp`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论`UIScrollView`控件。创建一个新的iPhone**单视图应用程序**项目，并将其命名为`ScrollApp`。
- en: How to do it...
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The following are the steps to create the project:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目的以下步骤：
- en: Open the `ScrollAppViewController.xib` file in Interface Builder.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`ScrollAppViewController.xib`文件。
- en: Add a `UIScrollView` object on its view and connect it to an outlet. Save the
    document.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图中添加一个`UIScrollView`对象并将其连接到一个出口。保存文档。
- en: 'Back in Xamarin Studio, add the following code in the `ScrollAppViewController`
    class:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Xamarin Studio，在`ScrollAppViewController`类中添加以下代码：
- en: '[PRE35]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Finally, add an image to the project and set its **Build Action** to **BundleResource**.
    An image larger than the screen size of 640 x 1136 pixels of iPhone 5S is preferable.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将图像添加到项目中，并将其**构建操作**设置为**BundleResource**。iPhone 5S屏幕大小为640 x 1136像素的图像更大为佳。
- en: Compile and run the app on the simulator. Tap and drag the image to display
    different portions. By pressing *Alt* + left-mouse click, you can simulate the
    pinch zooming function.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击并拖动图像以显示不同的部分。通过按下*Alt* + 左键单击，可以模拟捏合缩放功能。
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIScrollView` is capable of managing content that expands beyond the screen
    size. The size of the content that the scroll view will display must be set in
    its `ContentSize` property, as shown in the following code:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIScrollView`能够管理超出屏幕大小的内容。滚动视图将显示的内容大小必须在它的`ContentSize`属性中设置，如下面的代码所示：'
- en: '[PRE36]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The `ContentOffset` property shown in the following code defines the position
    of the content inside the scroll view''s bounds:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码中显示的`ContentOffset`属性定义了内容在滚动视图边界内的位置：
- en: '[PRE37]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'What this means is that the image''s (x=200, y=50) point will be displayed
    at the origin (x=0, y=0) of `UIScrollView`. To provide a zooming functionality
    for the content, we first set the `MinimumZoomScale` and `MaximumZoomScale` properties,
    as shown in the following code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着图像的（x=200，y=50）点将在`UIScrollView`的原点（x=0，y=0）处显示。为了提供内容的缩放功能，我们首先设置`MinimumZoomScale`和`MaximumZoomScale`属性，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The preceding code set the minimum and maximum zoom scale for the content. A
    value of `2` means that the content will be displayed double in size, while a
    value of `0.5` means that the content will be displayed at half its size.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码设置了内容的最小和最大缩放比例。值为`2`表示内容将以两倍大小显示，而值为`0.5`表示内容将以一半大小显示。
- en: 'For the actual zooming operation, we need to set the `ViewForZoomingInScrollView`
    property, as shown in the following code:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的缩放操作，我们需要设置`ViewForZoomingInScrollView`属性，如下面的代码所示：
- en: '[PRE39]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `ViewForZoomingInScrollView` property accepts a `delegate` variable of
    the `UIScrollViewGetZoomView` type and returns `UIView`. Here, the image view
    that we created is returned, but another image view of a higher resolution can
    be used instead to provide better image quality when zooming. After the `delegate`
    variable is assigned, the initial zoom scale is set using the following code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewForZoomingInScrollView`属性接受一个`UIScrollViewGetZoomView`类型的`delegate`变量，并返回`UIView`。在这里，返回的是我们创建的图像视图，但也可以使用更高分辨率的另一个图像视图来提供在缩放时更好的图像质量。在将`delegate`变量分配后，使用以下代码设置初始缩放比例：'
- en: '[PRE40]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Finally, the scroll view''s indicator style is set, as shown in the following
    code:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置滚动视图的指示器样式，如下面的代码所示：
- en: '[PRE41]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Indicators are the two lines that appear when scrolling or zooming: one vertical
    line on the right side and one horizontal line on the bottom side of the scroll
    view. These lines inform the user of the position of the content.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 指示器是在滚动或缩放时出现的两条线：滚动视图右侧的一条垂直线和底部的一条水平线。这些线告知用户内容的位置。
- en: There's more...
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To provide a more pleasing scrolling and zooming effect to the user, the `UIScrollView`
    exposes the `Bounce` property. By default, it is set to `true`, but we have the
    option to disable it by setting it to `false`. Bouncing the content gives immediate
    feedback to the user that the bounds of the content have been reached, in either
    a horizontal or vertical direction. Furthermore, the `AlwaysBounceHorizontal`
    and `AlwaysBounceVertical` properties can be set individually. Setting one or
    both of these properties will make the scroll view bounce the content in the respective
    direction always, even if the content is equal to or smaller than the scroll view's
    bounds. Hence, no actual scrolling is needed.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为用户提供更令人愉悦的滚动和缩放效果，`UIScrollView`公开了`Bounce`属性。默认情况下，它设置为`true`，但我们可以选择将其设置为`false`来禁用它。内容在水平和垂直方向上达到边界时，弹跳会给用户立即反馈。此外，可以单独设置`AlwaysBounceHorizontal`和`AlwaysBounceVertical`属性。设置其中一个或两个这些属性将使滚动视图在相应的方向上始终弹跳内容，即使内容大小等于或小于滚动视图的边界。因此，实际上不需要滚动。
- en: UIScrollView events
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UIScrollView`事件'
- en: 'The `UIScrollView` class exposes some of the following very useful events:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIScrollView`类公开了一些以下非常有用的事件：'
- en: '`Scrolled`: This occurs while the content is being scrolled'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scrolled`：当内容正在滚动时发生'
- en: '`DecelerationStarted`: This occurs when the user has started scrolling the
    content'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecelerationStarted`：当用户开始滚动内容时发生'
- en: '`DecelerationEnded`: This occurs when the user has finished scrolling, and
    the content has stopped moving'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecelerationEnded`：当用户完成滚动，内容停止移动时发生'
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a handler has been assigned to the `Scrolled` event, it will be triggered
    whenever the `ContentOffset` property is set.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已将处理程序分配给 `Scrolled` 事件，则每当设置 `ContentOffset` 属性时，它都会被触发。
- en: See also
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying images* recipe
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像* 菜谱'
- en: The *Displaying and editing text* recipe
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本* 菜谱'
- en: The *Navigating through the content divided into pages* recipe
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在分页的内容之间导航* 菜谱'
- en: Navigating through the content divided into pages
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分页的内容之间导航
- en: In this recipe, we will learn how to use the `UIPageControl` class to provide
    page navigation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用 `UIPageControl` 类来提供页面导航。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The `UIPageControl` provides a simple visual representation of multiple pages
    or screens in an iOS app, which is indicated by dots. The following screenshot
    shows an example of the page control indicating that content is divided into three
    pages:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPageControl` 提供了 iOS 应用程序中多个页面或屏幕的简单视觉表示，这由点表示。以下截图显示了页面控制器的示例，表明内容被分为三个页面：'
- en: '![Getting ready](img/8924OT_02_09.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/8924OT_02_09.jpg)'
- en: The dot that corresponds to the current page is highlighted. It is usually combined
    with `UIScrollView`. Create a new iPhone **Single View Application** project in
    Xamarin Studio and name it `PageNavApp`. Add three image files in the project
    and set their **Build Action** to **BundleResource**.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 对应当前页面的点被突出显示。它通常与 `UIScrollView` 结合使用。在 Xamarin Studio 中创建一个新的 iPhone **Single
    View Application** 项目，并将其命名为 `PageNavApp`。在项目中添加三个图像文件，并将它们的 **Build Action**
    设置为 **BundleResource**。
- en: How to do it...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to create this project:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 以下创建此项目的步骤：
- en: Open the `PageNavAppViewController.xib` file in Interface Builder.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `PageNavAppViewController.xib` 文件。
- en: Add `UIPageControl` to the bottom of the view and `UIScrollView` above it. Resize
    the scroll view to take up all the remaining space of the view and save the document.
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UIPageControl` 添加到视图的底部，并将 `UIScrollView` 添加到其上方。调整滚动视图的大小，使其占据视图剩余的所有空间，并保存文档。
- en: 'Back in Xamarin Studio, enter the following code in the `PageNavAppViewController`
    class:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 Xamarin Studio，在 `PageNavAppViewController` 类中输入以下代码：
- en: '[PRE42]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following methods in the class:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE43]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compile and run the app on the simulator. Scroll sideways on the scroll view
    to change the page. Likewise, tap or scroll on the page control to change the
    page.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在滚动视图中水平滚动以更改页面。同样，在页面控制器上点击或滚动以更改页面。
- en: How it works...
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing that we need to do is set the `UIScrollView.PagingEnabled`
    property to true, as shown in the following code:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将 `UIScrollView.PagingEnabled` 属性设置为 true，如下面的代码所示：
- en: '[PRE44]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'This property instructs the scroll view to stop scrolling at multiples of the
    scroll view''s bounds, hence providing paging functionality. After this, the image
    views that will be displayed on different pages are prepared. Here, we take care
    of adjusting each image view''s frame so that they will be positioned next to
    each other, using the following code:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指示滚动视图在滚动视图边界的倍数处停止滚动，从而提供分页功能。之后，准备将在不同页面上显示的图像视图。在这里，我们注意调整每个图像视图的框架，以便它们彼此相邻，如下面的代码所示：
- en: '[PRE45]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'We have attached handlers for two events. The first one is the `UIScrollView.DecelerationEnded`
    event, which will adjust the page control''s current page when the user scrolls
    the scroll view. The current page is determined by the scroll view''s `ContentOffset`
    property, as shown in the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个事件附加了处理程序。第一个是 `UIScrollView.DecelerationEnded` 事件，当用户滚动滚动视图时，它将调整页面控制器的当前页面。当前页面由滚动视图的
    `ContentOffset` 属性确定，如下面的代码所示：
- en: '[PRE46]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The second event to which we attach a handler is the `UIPageControl.ValueChanged`
    event. In this handler, we make sure that the content is scrolled when the user
    taps or drags on the page control. The scrolling action is performed when the
    `ContentOffset` property is set to the desired image view''s `Frame.X` property
    using the `UIScrollView.SetContentOffset(PointF, bool)` method, as shown in the
    following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加处理器的第二个事件是 `UIPageControl.ValueChanged` 事件。在这个处理程序中，我们确保当用户在页面控件上点击或拖动时内容会滚动。滚动操作是通过使用
    `UIScrollView.SetContentOffset(PointF, bool)` 方法将 `ContentOffset` 属性设置为所需图像视图的
    `Frame.X` 属性来执行的，如下面的代码所示：
- en: '[PRE47]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: The second parameter of the `SetContentOffset` method instructs the scroll view
    to animate while scrolling.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetContentOffset` 方法的第二个参数指示滚动视图在滚动时进行动画。'
- en: There's more...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this recipe, different `UIImageView` objects have been used. Any kind of
    `UIView` object can be used according to the type of content we want to display.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，使用了不同的 `UIImageView` 对象。可以根据我们想要显示的内容类型使用任何类型的 `UIView` 对象。
- en: Proper usage of UIPageControl
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确使用 UIPageControl
- en: Users expect that scrolling to other pages will occur when tapping or dragging
    on the page control. It is not a good practice to use it for displaying page indexing
    only.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望在点击或拖动页面控件时滚动到其他页面。仅用于显示页面索引并不是一个好的做法。
- en: See also
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying images* recipe
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像* 示例'
- en: The *Displaying content larger than the screen* recipe
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示比屏幕大的内容* 示例'
- en: Displaying alerts
  id: totrans-345
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示警告
- en: The `UIAlertView` class provides us with the ability to display alert messages
    to the user. In this recipe, we will discuss how to use this class and respond
    to user input.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAlertView` 类为我们提供了向用户显示警告消息的能力。在这个示例中，我们将讨论如何使用这个类并响应用户输入。'
- en: Getting ready
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, create an iPhone **Single View Application** project in Xamarin
    Studio and name it `AlertViewApp`. Open the `AlertViewAppViewController.xib` file
    in Xcode and add a button on its view. Don't forget to connect it to an outlet.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个示例，在 Xamarin Studio 中创建一个名为 `AlertViewApp` 的 iPhone **单视图应用程序** 项目。在 Xcode
    中打开 `AlertViewAppViewController.xib` 文件，并在其视图中添加一个按钮。别忘了将其连接到一个出口。
- en: How to do it…
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to implement the `UIAlertView` in the app:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在应用程序中实现 `UIAlertView`：
- en: 'In Xamarin Studio, open the `AlertViewAppViewController.cs` file and add the
    following method:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中，打开 `AlertViewAppViewController.cs` 文件并添加以下方法：
- en: '[PRE48]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the `ViewDidLoad` method, add the following line of code:'
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中，添加以下行代码：
- en: '[PRE49]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Compile and run the app in the simulator.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器中编译并运行应用程序。
- en: Tap the button on the view. The alert should be displayed, as shown in the following
    screenshot:![How to do it…](img/8924OT_02_07.jpg)
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中点击按钮。应该会显示警告，如下面的截图所示：![如何操作…](img/8924OT_02_07.jpg)
- en: Tap either **OK** or **Cancel**. The **Show alert** button's title will change
    according to the alert button that was tapped.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**确定**或**取消**。**显示警告**按钮的标题将根据点击的警告按钮而改变。
- en: How it works...
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIAlertView` is a modal control. This means that once it is presented,
    the user is required to take an action for it to disappear. After creating the
    instance, we assign the title and the message that will be displayed through the
    `Title` and `Message` properties, respectively, as shown in the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAlertView` 是一个模态控件。这意味着一旦它被显示，用户必须采取某种行动才能使其消失。在创建实例后，我们通过 `Title` 和 `Message`
    属性分别设置要显示的标题和消息，如下面的代码所示：'
- en: '[PRE50]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We then add the buttons we want to display through the `AddButton` method,
    which accepts a `string` parameter for the button''s title, as shown in the following
    code:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过 `AddButton` 方法添加我们想要显示的按钮，该方法接受一个用于按钮标题的 `string` 参数，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We can practically add as many buttons as we want; however, it would be good
    to avoid adding more than three or four buttons. If there is a need for more options,
    it would be best to show a new view to the user with these options, instead of
    using an alert view.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实际上可以添加尽可能多的按钮；然而，最好避免添加超过三个或四个按钮。如果需要更多选项，最好向用户显示一个包含这些选项的新视图，而不是使用警告视图。
- en: 'After adding the buttons, we need an event handler (as shown in the following
    code) that will inform us of the user''s action on the alert view:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 添加按钮后，我们需要一个事件处理器（如下面的代码所示），它会通知我们用户在警告视图上的操作：
- en: '[PRE52]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: For this functionality, we use the `Dismissed` event that is triggered whenever
    the alert view is hidden. This occurs when any of its buttons are tapped. In the
    event handler, we can determine which button was tapped through the passed `ButtonIndex`
    property of `UIButtonEventArgs`. It is pretty clear which index corresponds to
    which button. The first button we added will have an index of `0`, the second
    button will have an index of `1`, and so on.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此功能，我们使用 `Dismissed` 事件，该事件在警报视图被隐藏时触发。这发生在任何按钮被点击时。在事件处理程序中，我们可以通过 `UIButtonEventArgs`
    传递的 `ButtonIndex` 属性确定哪个按钮被点击。哪个索引对应哪个按钮是很清晰的。我们添加的第一个按钮将具有索引 `0`，第二个按钮将具有索引 `1`，依此类推。
- en: 'Finally, to display the alert view, we call its `Show` method using the following
    code:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了显示警报视图，我们使用以下代码调用其 `Show` 方法：
- en: '[PRE53]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: There's more...
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: '`UIAlertView` also supports text input. We can implement it by setting its
    `AlertViewStyle` property before displaying it. The `AlertViewStyle` property
    accepts the following values:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAlertView` 也支持文本输入。我们可以在显示之前通过设置其 `AlertViewStyle` 属性来实现。`AlertViewStyle`
    属性接受以下值：'
- en: '`UIAlertViewStyle.Default`: This alert view will not contain text input'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIAlertViewStyle.Default`: 此警报视图将不包含文本输入'
- en: '`UIAlertViewStyle.SecureTextInput`: This alert view will contain a text field
    for password input, which obscures the typed text'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIAlertViewStyle.SecureTextInput`: 此警报视图将包含一个用于密码输入的文本字段，它会隐藏输入的文本'
- en: '`UIAlertViewStyle.PlainTextInput`: In this, only one simple text field will
    be included'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIAlertViewStyle.PlainTextInput`: 在此，仅包含一个简单的文本字段'
- en: '`UIAlertViewStyle.LoginAndPasswordInput`: Using this property, two text fields
    will be displayed, one plain and one secure, for entering the login credentials'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIAlertViewStyle.LoginAndPasswordInput`: 使用此属性，将显示两个文本字段，一个普通和一个安全，用于输入登录凭据'
- en: 'To access any of the mentioned text fields, we call the `GetTextField` method,
    passing the appropriate index, as shown in the following code:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问任何提到的文本字段，我们调用 `GetTextField` 方法，传递适当的索引，如下面的代码所示：
- en: '[PRE54]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Of course, we can also modify the text fields themselves. For example, if we
    want to disable obscuring the characters of the password text field, we can add
    the following line of code:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们也可以修改文本字段本身。例如，如果我们想禁用隐藏密码文本字段的字符，我们可以添加以下代码行：
- en: '[PRE55]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Receiving user input with buttons* recipe
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用按钮接收用户输入* 菜单'
- en: The *Displaying and editing text* recipe
  id: totrans-381
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本* 菜单'
- en: Creating a custom view
  id: totrans-382
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义视图
- en: In this recipe, we will learn how to override the `UIView` class and/or classes
    that derive from it to create custom views.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何覆盖 `UIView` 类及其派生类以创建自定义视图。
- en: Getting ready
  id: totrans-384
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: So far, we have discussed many of the available views to create iOS apps. There
    will be many cases, however, we will need to implement our own custom views. In
    this recipe, we will see how to create a custom view and use it.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了许多可用于创建 iOS 应用程序的视图。然而，在许多情况下，我们将需要实现自己的自定义视图。在本菜谱中，我们将了解如何创建自定义视图并使用它。
- en: Note
  id: totrans-386
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating custom views is very useful when we want to capture touches or implement
    other custom behavior such as drawing.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义视图非常有用，当我们想要捕获触摸或实现其他自定义行为，如绘图时。
- en: Create a new iPhone **Single View Application** project in Xamarin Studio and
    name it `CustomViewApp`.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 iPhone **Single View Application** 项目，并将其命名为 `CustomViewApp`。
- en: How to do it...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The following are the steps to complete this recipe:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱的以下步骤：
- en: Add a new C# class file in the project and name it `MyView`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的 C# 类文件，并将其命名为 `MyView`。
- en: 'Implement it with the following code:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现：
- en: '[PRE56]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: Open the `CustomViewAppViewController.xib` file in Interface Builder and add
    a `UIView` object on the main view.
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `CustomViewAppViewController.xib` 文件，并在主视图中添加一个 `UIView`
    对象。
- en: Set its **Class** field in the **Identity Inspector** to `MyView`.
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Identity Inspector** 中的 **Class** 字段设置为 `MyView`。
- en: Save the document.
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Compile and run the app on the simulator. Tap and drag the view and watch the
    touch coordinates being displayed in the label at the bottom of the screen.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击并拖动视图，观察触摸坐标在屏幕底部的标签中显示。
- en: How it works...
  id: totrans-398
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The first thing to note when creating custom views is to derive them from the
    `UIView` class and decorate them with the `RegisterAttribute`, as shown in the
    following code:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义视图时要注意的第一件事是从 `UIView` 类派生它们，并使用 `RegisterAttribute` 装饰它们，如下面的代码所示：
- en: '[PRE57]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `RegisterAttribute` basically exposes our class to the Objective-C world.
    Note that the name we pass as its parameter must be the same name we enter in
    the **Class** field in the **Identity Inspector**. It is important to create the
    following constructor:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterAttribute` 基本上使我们的类暴露给 Objective-C 世界。请注意，我们传递给它的参数名称必须与我们在 **Identity
    Inspector** 的 **Class** 字段中输入的名称相同。创建以下构造函数很重要：'
- en: '[PRE58]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'This constructor overrides the base class'' `UIView(IntPtr)`. This constructor
    is always being called when a view is initialized through the native code. If
    we do not override it, an exception will occur upon the initialization of the
    object. The other constructor that is used in this example is just provided as
    guidance on what might be used if the view was initialized programmatically:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 此构造函数覆盖了基类的 `UIView(IntPtr)`。当通过原生代码初始化视图时，始终调用此构造函数。如果我们不覆盖它，初始化对象时将发生异常。此示例中使用的另一个构造函数仅作为指导，说明如果视图是通过编程初始化的，可能会使用什么：
- en: '[PRE59]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Both these constructors call the `Initialize()` method that performs the initialization
    we need, such as creating the label that will be used and setting the background
    colors.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个构造函数都调用了 `Initialize()` 方法，该方法执行所需的初始化，例如创建将要使用的标签并设置背景颜色。
- en: 'Then, the `TouchesMoved` method is overridden. This is the method that is executed
    when the user drags a finger on the view. Inside the method, we retrieve the `UITouch`
    object from the method''s NSSet parameter, using the following code:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重写了 `TouchesMoved` 方法。这是当用户在视图中拖动手指时执行的方法。在方法内部，我们使用以下代码从方法参数的 NSSet 中检索
    `UITouch` 对象：
- en: '[PRE60]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note
  id: totrans-408
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An `NSSet` object is a collection of data that are not in particular order.
    It is similar to an array. Its `AnyObject` parameter returns an object from the
    collection.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSSet` 对象是一组没有特定顺序的数据集合。它类似于数组。它的 `AnyObject` 参数从集合中返回一个对象。'
- en: 'The `UITouch` object contains information about user touches. We retrieve the
    touch''s current location from the `UITouch` object, using the following code:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITouch` 对象包含有关用户触摸的信息。我们使用以下代码从 `UITouch` 对象中检索触摸的当前位置：'
- en: '[PRE61]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `UITouch` object's `LocationInView` method accepts a parameter of the `UIView`
    type, which declares in which view's coordinate system will the location be calculated.
    In this case, we are interested in the coordinates of `MyView`.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITouch` 对象的 `LocationInView` 方法接受一个 `UIView` 类型的参数，它声明了位置将在哪个视图的坐标系中计算。在这种情况下，我们感兴趣的是
    `MyView` 的坐标。'
- en: There's more...
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we would like to initialize the custom view we created programmatically,
    we would enter the following code:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想通过编程初始化我们创建的自定义视图，我们将输入以下代码：
- en: '[PRE62]'
  id: totrans-415
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: See also
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Adding and customizing views* recipe
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图* 菜谱'
- en: The *Loading a view with a view controller* recipe in [Chapter 3](ch03.html
    "Chapter 3. User Interface – View Controllers"), *User Interface – View Controllers*
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 3 章](ch03.html "第 3 章。用户界面 – 视图控制器") 的 *加载视图与视图控制器* 菜谱中，*用户界面 – 视图控制器*
- en: Styling views
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图样式化
- en: iOS provides a set of APIs through the **UIAppearance** protocol that allows
    us to adjust the appearance of the views once, without having to explicitly modify
    the styling properties on every instance of each view. This is particularly useful
    if, say, we want a specific view to have the same appearance throughout the app.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 通过 **UIAppearance** 协议提供了一套 API，允许我们一次性调整视图的外观，而无需显式修改每个视图实例的样式属性。如果我们想使特定视图在整个应用程序中具有相同的外观，这尤其有用。
- en: Apart from setting the styling properties of a view globally, we can also define
    the appearance of this view to be different under certain circumstances. Read
    on to find out how to accomplish this.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 除了全局设置视图的样式属性外，我们还可以定义在某些情况下此视图的外观不同。继续阅读以了解如何实现这一点。
- en: Getting ready
  id: totrans-422
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will work on the existing `CustomViewApp` project we created in the preceding
    recipe. Open the project in Xamarin Studio.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在前一个菜谱中创建的现有 `CustomViewApp` 项目上进行工作。在 Xamarin Studio 中打开该项目。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The downloadable code contains a separate project for this recipe. It is named
    `CustomViewApp2`.
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 可下载的代码包含一个用于此菜谱的单独项目。它被命名为 `CustomViewApp2`。
- en: How to do it…
  id: totrans-426
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此菜谱：
- en: Open the `CustomViewAppViewController.xib` file in Xcode.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xcode 中打开 `CustomViewAppViewController.xib` 文件。
- en: Resize the `MyView` object, which we created earlier, to make some room at the
    top.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整我们之前创建的 `MyView` 对象的大小，以便在顶部留出一些空间。
- en: Add a `UILabel` above the `MyView` object. Make sure that the label is added
    on the main view and not on `MyView`.
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MyView` 对象上方添加一个 `UILabel`。确保标签是在主视图中添加的，而不是在 `MyView` 中。
- en: Connect both objects to their respective outlets.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个对象连接到它们各自的出口。
- en: 'Back in Xamarin Studio, add the following code in the `ViewDidLoad` method
    of `CustomViewAppViewController`:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中，将以下代码添加到 `CustomViewAppViewController` 的 `ViewDidLoad` 方法中：
- en: '[PRE63]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Compile and run the app on the simulator. The output should be similar to the
    one shown in the following screenshot:![How to do it…](img/8924OT_02_08.jpg)
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。输出应类似于以下截图所示：![如何操作…](img/8924OT_02_08.jpg)
- en: How it works…
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `UIAppearance` class is basically a proxy to the specific properties of
    each control. In Xamarin.iOS, we can access each control''s proxy through its
    static `Appearance` property. The changes we make to this object''s properties
    will reflect on the instances of the object throughout the app. In this case,
    we set the `BackgroundColor` attribute of all `UILabel` instances to blue using
    the following code:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAppearance` 类基本上是每个控件特定属性的代理。在 Xamarin.iOS 中，我们可以通过每个控件的静态 `Appearance`
    属性来访问每个控件的代理。我们对这个对象属性所做的更改将反映在整个应用程序的对象实例上。在这种情况下，我们使用以下代码将所有 `UILabel` 实例的 `BackgroundColor`
    属性设置为蓝色：'
- en: '[PRE64]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'However, we can provide different behavior for specific instances of `UILabel`.
    For example, we want the labels that are contained in `MyView` objects to have
    a green background. We accomplish this by calling the static `AppearanceWhenContainedIn`
    method, as shown in the following code:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以为 `UILabel` 的特定实例提供不同的行为。例如，我们希望包含在 `MyView` 对象中的标签具有绿色背景。我们通过调用静态 `AppearanceWhenContainedIn`
    方法来实现这一点，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We pass the types of objects for which we want to set the specific style. In
    this case, passing `typeof(MyView)` instructs the appearance proxy to make sure
    that we are referring to objects that are only contained in `MyView` objects.
    We then set the value we want to the object that was returned from this method,
    as shown in the following code:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递我们想要设置特定样式的对象类型。在这种情况下，传递 `typeof(MyView)` 指示外观代理确保我们引用的是仅包含在 `MyView` 对象中的对象。然后我们将我们想要的值设置为我们从这个方法返回的对象，如下面的代码所示：
- en: '[PRE66]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: There's more…
  id: totrans-442
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Through the `AppearanceWhenContainedIn` method, we can target a more specific
    set of styling. For example, consider the following line of code:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `AppearanceWhenContainedIn` 方法，我们可以针对更具体的样式集。例如，考虑以下代码行：
- en: '[PRE67]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This would return a styling object that acts as a proxy for all instances of
    `UILabel`, which are part of `MyView`, only when `MyView` is included in `AnotherView`
    objects.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回一个样式对象，该对象充当 `UILabel` 所有实例的代理，这些实例是 `MyView` 的一部分，仅当 `MyView` 包含在 `AnotherView`
    对象中时。
- en: Limitations of UIAppearance
  id: totrans-446
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UIAppearance 的局限性
- en: 'The `UIAppearance` protocol has some limitations, which are as follows:'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIAppearance` 协议有一些局限性，如下所示：'
- en: Only specific properties can be set. For example, we cannot set the `Frame`
    of a view globally. Each set of properties that can be changed for a control can
    be accessed through its appearance proxy. If a control property is not in the
    appearance proxy, we cannot modify it for all instances of that particular control.
  id: totrans-448
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只能设置特定的属性。例如，我们无法全局设置视图的 `Frame`。对于每个控件可以更改的属性集，都可以通过其外观代理访问。如果控件属性不在外观代理中，我们无法为该特定控件的所有实例修改它。
- en: 'For modifying the appearance of a custom view (in this case, `MyView`), using
    the following line of code will yield an unwanted result:'
  id: totrans-449
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于修改自定义视图（在这种情况下，`MyView`）的外观，使用以下代码行将产生一个不希望的结果：
- en: '[PRE68]'
  id: totrans-450
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'That is, all instances of `UIView` will have a yellow background. This is because
    C# cannot override the static methods in derived classes. To overcome this issue,
    we use the `GetAppearance<T>` static method on the derived class instead, as shown
    in the following code:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 即，所有 `UIView` 实例都将具有黄色背景。这是因为 C# 无法覆盖派生类中的静态方法。为了克服这个问题，我们使用派生类上的 `GetAppearance<T>`
    静态方法，如下面的代码所示：
- en: '[PRE69]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: See also
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating a custom view recipe*
  id: totrans-454
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义视图菜谱*'
- en: The *Creating a custom view controller* recipe in [Chapter 3](ch03.html "Chapter 3. User
    Interface – View Controllers"), *User Interface – View Controllers*
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。用户界面 – 视图控制器")中的 *创建自定义视图控制器* 菜谱，*用户界面 – 视图控制器*'
