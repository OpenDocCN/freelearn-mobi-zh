<html><head></head><body><p>&#13;
&#13;
                            &#13;
                    Swift Building Blocks&#13;
                &#13;
            &#13;
            &#13;
                &#13;
<p>Since Apple announced the Swift programming language at WWDC 2014, it has gone on to become one of the fastest-growing programming languages. TIOBE is a company that measures software quality and publishes a ranking index of programming language usage. At the time of writing, Swift ranks as the 11<sup>th</sup> most popular language on this index. This is two places higher than when the first edition of this book was written (visit <a href="http://www.tiobe.com/tiobe_index">http://www.tiobe.com/tiobe_index</a>).</p>&#13;
<p>Swift is a modern, general-purpose programming language that focuses on type safety and expressive and concise syntax. Positioned as a modern replacement for Objective-C, it has taken over from that older language as the future of development on Apple's platforms.</p>&#13;
<p>Occupying this niche alone would ensure Swift's place as a useful and important programming language. However, Apple's decision to open-source Swift has allowed its influence to extend beyond Apple's ecosystem, giving it the potential to be used across all platforms and for any scenario.</p>&#13;
<p>Since open-sourcing Swift, Apple has provided support for running your Swift code on Linux. In the later chapters, we will investigate using a Swift server to execute your code. In addition, the Swift Playgrounds iPad app turns your tablet into a lightweight <strong>Integrated Development Environment</strong> (<strong>IDE</strong>). Despite these alternative ways to use and write Swift code, the simplest is still on a Mac and with Apple's Xcode IDE. At the beginning of this book, we will walk through setting that up and will then assume that the reader uses this development environment unless otherwise stated. Xcode also provides a perfect way to explore the structure and syntax of the Swift standard library, foundation, and any other framework available for iOS or Mac development in the form of its Playgrounds feature.</p>&#13;
<p>A <strong>Swift Playground</strong> is a simplified environment for executing Swift code. For our purposes, playgrounds provide an ideal way to create, run, and understand the recipes contained in this book. As such, it will also be assumed that the reader is using an Xcode Playground to implement the recipes contained in this book, unless otherwise stated.</p>&#13;
<p>Swift 5.3 is an important release, adding many language features that are crucial for Apple's SwiftUI framework, which we will cover in <a href="30f08984-5b97-43e0-ad44-ca47f16ca183.xhtml">Chapter 10</a>, <em>SwiftUI and Combine Framework</em>. Swift 5.3 will also be more compatible with future versions of Swift, which means that code written now with Swift 5.3 can run alongside code written with Swift 6 and beyond. This book will assume that the reader is using Swift 5.3; all code will work with this version.</p>&#13;
<p>In this chapter, we will look at the building blocks of the Swift language, examining the syntax and functionality of the basic Swift components that everything else is based on.</p>&#13;
<p>In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Creating your first Swift program</li>&#13;
<li>Using Strings, Ints, Floats, and Bools</li>&#13;
<li>Unwrapping optionals, and force unwrapping</li>&#13;
<li>Reusing code in functions</li>&#13;
<li>Encapsulating functionality in object classes</li>&#13;
<li>Bundling values into structs</li>&#13;
<li>Enumerating values with enums</li>&#13;
<li>Passing around functionality with closures</li>&#13;
<li>Using protocols to define interfaces</li>&#13;
</ul>&#13;
<h1 id="uuid-d2bb6159-4a71-4474-a464-d8a3d3e954ef">Technical requirements</h1>&#13;
<p>All the code for this chapter can be found in the book's GitHub repository at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01" target="_blank">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter01</a></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3rp0DnJ" target="_blank">https://bit.ly/3rp0DnJ</a></p>&#13;
<h1 id="uuid-65fd765b-5f95-44ab-be45-80e8b53a76db">Creating your first Swift program</h1>&#13;
<p>In the first recipe, we will set up our development environment and use Swift Playgrounds to create our first piece of Swift code.</p>&#13;
<h2 id="uuid-367206ba-f089-4a03-860e-4ff7eaee5b0b">Getting ready</h2>&#13;
<p>First, we must download and install Apple's IDE, Xcode, from the Mac App Store:</p>&#13;
<ol>&#13;
<li>Open up the Mac App Store, either from the Dock or via Spotlight:</li>&#13;
</ol>&#13;
<div><img src="img/4d80b47c-9db3-480b-98f5-014ec97e3d5d.png" style="" width="275" height="376"/><img src="img/0597e1d6-d989-4eb4-a1ec-02aa79c0b850.png" style="" width="1337" height="844"/></p>&#13;
<p>Figure 1.1 – App Store</p>&#13;
<ol start="2">&#13;
<li>Search for <kbd>xcode</kbd>:</li>&#13;
</ol>&#13;
<div><img src="img/5c8c9824-ff65-4884-a7dd-e5a764ee7932.png" style="" width="483" height="596"/></div>&#13;
<p>Figure 1.2 – Searching for xcode</p>&#13;
<ol start="3">&#13;
<li>Click on GET, followed by Install:</li>&#13;
</ol>&#13;
<div><img src="img/df8c3b4e-8945-42c1-be4a-4df05e1a7676.png" width="854" height="665"/></div>&#13;
<p>Figure 1.3 – Xcode in the App Store</p>&#13;
<p>Xcode is a large download (nearly 8 GB), so this may take a while, depending on your internet connection.</p>&#13;
<ol start="4">&#13;
<li>Once downloaded, open Xcode from the App Store or the Dock:</li>&#13;
</ol>&#13;
<div><img src="img/668cbb84-bcd0-4ce7-83d7-c4052866c727.png" width="848" height="653"/></div>&#13;
<p>Figure 1.4 – Opening Xcode</p>&#13;
<h2 id="uuid-39082643-309a-4e1c-ae9a-45b46f71e2e8">How to do it...</h2>&#13;
<p>With Xcode downloaded, let's create our first Swift playground:</p>&#13;
<ol>&#13;
<li>Launch Xcode from the icon in your Dock.</li>&#13;
<li>Choose Get started with a playground from the welcome screen:</li>&#13;
</ol>&#13;
<div><img src="img/013a1e9b-cc2a-4754-86ee-2311d18f97b1.png" style="" width="757" height="453"/></div>&#13;
<p>Figure 1.5 – Xcode, new project</p>&#13;
<ol start="3">&#13;
<li>Select Blank from the iOS tab of the template and then press Next:</li>&#13;
</ol>&#13;
<div><img src="img/073f1ea6-8648-44d9-beeb-b67572a73feb.png" style="" width="1525" height="654"/></div>&#13;
<p>Figure 1.6 – Xcode, selecting the project type</p>&#13;
<ol start="4">&#13;
<li>Choose a name and location for your playground and then press Create:</li>&#13;
</ol>&#13;
<div><img src="img/4df9f9f8-162a-4bec-89ff-2098939bc3ac.png" style="" width="1837" height="642"/></div>&#13;
<p>Figure 1.7 – Xcode, saving the project</p>&#13;
<p>Xcode playgrounds can be based on one of the three different Apple platforms: <strong>iOS</strong>, <strong>tvOS</strong>, and <strong>macOS</strong>. Playgrounds provide full access to the frameworks available to either iOS, tvOS, or macOS, depending on which you choose. An iOS playground will be assumed for the entirety of this book, chiefly because this is the platform of choice of the author. Where code does have UI components, the iOS platform will be used, unless stated otherwise.</p>&#13;
<p style="padding-left: 60px">You are now presented with a view that looks like this:</p>&#13;
<div><img src="img/0578c3d9-1e83-42d8-b3b5-35c4c58fa758.png" style="" width="1209" height="349"/></div>&#13;
<p>Figure 1.8 – Playground – code template</p>&#13;
<ol start="5">&#13;
<li>Let's replace the word <kbd>playground</kbd> with <kbd>Swift!</kbd>. Click on the play icon in the bottom left-hand corner of the window to execute the code in the playground:</li>&#13;
</ol>&#13;
<div><img src="img/53d0ad8a-3abc-4685-9324-0facbb297948.png" style="" width="353" height="137"/></div>&#13;
<p>Figure 1.9 – Playground run/code execution</p>&#13;
<p style="padding-left: 60px">Congratulations! You have just run your first piece of Swift code.</p>&#13;
<p style="padding-left: 60px">On the right-hand side of the window, you will see the output of each line of code in the playground. We can see that our line of code has the output <kbd>Hello Swift!</kbd></p>&#13;
<div><img src="img/d7d4f51f-2ede-40d2-9d9c-61b76bf34bf4.png" style="" width="1334" height="361"/></div>&#13;
<p>Figure 1.10 – The "Hello, Swift!" playground</p>&#13;
<h2 id="uuid-f6f8c3ba-ac5e-4993-bf1d-e2bc4341bf34">There's more...</h2>&#13;
<p>If you put your cursor over the output on the right-hand side, you will see two buttons, one that looks like an eye and another that is a rounded square:</p>&#13;
<div><img src="img/4194d53e-3526-4d9f-a460-a4bc94ef9ed0.png" style="" width="265" height="61"/></div>&#13;
<p>Figure 1.11 – Playground, output</p>&#13;
<p>Click on the eye button to get a <strong>Quick Look</strong> box of the output. This isn't particularly useful for a text string, but can be useful for more visual output, such as colors and views:</p>&#13;
<div><img src="img/c1ee1904-18b8-4bb4-b298-44dcf5fdcfba.png" style="" width="638" height="269"/></div>&#13;
<p>Figure 1.12 – Playground output quick look</p>&#13;
<p>Click on the square button, and a box will be added inline, under your code, showing the output of the code. This can be really useful if you want to see how the output changes as you change the code:</p>&#13;
<div><img src="img/b63b493b-e71b-4d61-a75b-b42710ea2c61.png" style="" width="488" height="255"/></div>&#13;
<p>Figure 1.13 – Playground, inline output</p>&#13;
<h2 id="uuid-3e807004-efac-4c4a-9b61-101344249ab7">See also</h2>&#13;
<p>We will learn more about playgrounds and how we can take them further in <a href="f87c71fa-d2b0-44c4-9d33-65f438d69a15.xhtml">Chapter 7</a>, <em>Swift Playgrounds</em>.</p>&#13;
<h1 id="uuid-540fd123-d6e5-4087-80c6-0a65869cb93b">Using Strings, Ints, Floats, and Bools</h1>&#13;
<p>Many of the core operations in any programming language involve manipulating text, numbers, and determining true and false statements. Let's learn how to accomplish these operations in Swift by taking a look at its basic types and learning how to assign constants and variables. In doing so, we will touch on Swift's static typing and mutability system.</p>&#13;
<h2 id="uuid-833983c6-5a3a-4f28-9cdd-cc3bfd6ac570">Getting ready</h2>&#13;
<p>Open a new Swift Playground in Xcode. The previous recipe explains how to do this.</p>&#13;
<h2 id="uuid-d674366d-4559-4e3d-b579-58b7ecf251b0">How to do it...</h2>&#13;
<p>Let's run some Swift code that explores the basic types, and then we can walk through it step by step:</p>&#13;
<ol>&#13;
<li>Type the following into the new playground file:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let phrase: String = "The quick brown fox jumps over the lazy dog" <br/>let numberOfFoxes: Int = 1 <br/>let numberOfAnimals: Int = 2 <br/> <br/>let averageCharactersPerWord: Float = (3+5+5+3+5+4+3+4+3) / 9 <br/>print(averageCharactersPerWord) // 3.8888888 <br/> <br/>/* <br/>phrase = "The quick brown ? jumps over the lazy ?" // Doesn't compile <br/>*/ <br/> <br/>var anotherPhrase = phrase <br/>anotherPhrase = "The quick brown <img src="img/fddc0bb4-6ec1-423b-a734-f9f476ff547b.png" style="width:1.50em;height:1.25em;" width="845" height="762"/> jumps over the lazy <img src="img/4ccaf213-b044-4094-8b38-ce83df01c485.png" style="width:1.25em;height:1.08em;" width="854" height="855"/>" <br/>print(phrase) // "The quick brown fox jumps over the lazy dog"<br/>print(anotherPhrase) // "The quick brown <img src="img/ff776fff-afba-470d-9917-e5f95d2a943a.png" style="width:1.50em;height:1.25em;" width="845" height="762"/> jumps over the lazy <img src="img/35b57def-0f9d-4a0c-ae32-f4f39e09ed2e.png" style="width:1.25em;height:1.08em;" width="854" height="855"/>"<br/> <br/>var phraseInfo = "The phrase" + " has: " <br/>print(phraseInfo) // "The phrase has: " <br/> <br/>phraseInfo = phraseInfo + "\(numberOfFoxes) fox and \<br/>  (numberOfAnimals) animals" <br/>print(phraseInfo) // "The phrase has: 1 fox and 2 animals" <br/> <br/>print("Number of characters in phrase: \(phrase.count)")<br/><br/>let multilineExplanation = """<br/>Why is the following phrase often used?<br/>"The quick brown fox jumps over the lazy dog"<br/>This phrase contains every letter in the alphabet.<br/>""" <br/> <br/>let phrasesAreEqual = phrase == anotherPhrase <br/>print(phrasesAreEqual) // false <br/> <br/>let phraseHas43Characters = phrase.count == 40 + 3 <br/>print(phraseHas43Characters) // true <br/> </pre>&#13;
<ol start="2">&#13;
<li>Press the play button at the bottom of the window to run the playground and verify that Xcode doesn't show any errors. Your playground should look like the following screenshot, with an output for each line in the timeline on the right-hand side and printed values in the console at the bottom:</li>&#13;
</ol>&#13;
<div><img src="img/a28e0de3-63b5-4543-886d-07cfa874b168.png" style="" width="1838" height="1682"/></div>&#13;
<p>Figure 1.14 – Playground console output</p>&#13;
<h2 id="uuid-24348449-ee3c-4e4c-b6ec-3dc8cc063739">How it works...</h2>&#13;
<p>Let's step through the preceding code line by line to understand it.</p>&#13;
<p>In this line of code, we are assigning some text to a constant value:</p>&#13;
<pre> let phrase: String = "The quick brown fox jumps over the lazy dog"</pre>&#13;
<p>We define a new constant value by using the <kbd>let</kbd> keyword, and we give that constant a name, <kbd>phrase</kbd>. The colon <kbd>:</kbd> shows that we want to define what type of information we want to store in the constant, and that type is defined after the colon. In this case, we want to assign a string (<kbd>String</kbd> is how most programming languages refer to text). The <kbd>=</kbd> sign indicates that we are assigning a value to the constant we have defined, and <kbd>"The quick brown fox jumps over the lazy dog"</kbd> is a <kbd>String</kbd> literal, which means that it's an easy way to construct a string. Any text contained within <kbd>""</kbd> marks is treated as a <kbd>String</kbd> literal by Swift.</p>&#13;
<p>We are assigning the <kbd>String</kbd> literal on the right-hand side of the <kbd>=</kbd> sign to the constant on the left-hand side of the <kbd>=</kbd> sign.</p>&#13;
<p>Next, we are assigning two more constants, but this time they are of the <kbd>Int</kbd> type, or integers:</p>&#13;
<pre>let numberOfFoxes: Int = 1 <br/>let numberOfAnimals: Int = 2 </pre>&#13;
<p>Rather than assigning a value directly, we can assign the outcome from a mathematical expression to the constant. This constant is a <kbd>Float</kbd>, or floating-point number:</p>&#13;
<pre>let averageCharactersPerWord: Float = (3+5+5+3+5+4+3+4+3) / 9 </pre>&#13;
<p>In other words, it can store fractions rather than integers. Notice that in the timeline on the right of this line, the value is displayed as <kbd>3.88889</kbd>.</p>&#13;
<p>The <kbd>print</kbd> function allows us to see the output from any expression printed to the console or displayed in the playground:</p>&#13;
<pre>print(averageCharactersPerWord)</pre>&#13;
<p>We will cover functions in a later recipe, but for now, all you need to know is that in order to use a function, you type its name (in this case <kbd>print</kbd>) and then enclose any required input to the function within brackets, <kbd>()</kbd>.</p>&#13;
<p>When our code calls this function, the timeline to the right of the code displays the output of the statement as <kbd>3.88888</kbd>, which differs from the line above it. The actual value of the mathematical expression we performed is <kbd>3.88888888...</kbd> with an infinite number of 8s. However, the <kbd>print</kbd> function has rounded this up to just five decimal places and rounded it in a different way than the timeline for the line above. This potential difference between the true value of a floating-point number and how it's represented by the Swift language is important to remember when dealing with floats.</p>&#13;
<p>Next, you'll see some lines colored gray:</p>&#13;
<pre>/* <br/>phrase = "The quick brown ? jumps over the lazy ?" // Doesn't compile <br/>*/</pre>&#13;
<p>The playground doesn't produce an output for these lines because they are comments. The <kbd>/*</kbd> syntax before the line of code and the <kbd>*/</kbd> syntax after the line of code denote that this is a comment block, and therefore Swift should ignore anything typed in this block.</p>&#13;
<p>Remove <kbd>/*</kbd> and <kbd>*/</kbd> and you'll see that <kbd>// Doesn't compile</kbd> is still colored gray. This is because <kbd>//</kbd> also denotes a comment. Anything after this, on the same line, is also ignored.</p>&#13;
<p>If you now try and run this code, Xcode will tell you that there is a problem with this line, so let's look at the line to determine the issue.</p>&#13;
<p>On the left-hand side of the <kbd>=</kbd> sign, we have <kbd>phrase</kbd>, which we declared earlier, and now we are trying to assign a new value to it. We can't do this because we defined <kbd>phrase</kbd> as a constant using the <kbd>let</kbd> keyword. We should only use <kbd>let</kbd> for things we know will not change. This ability to define something as unchanging, or <strong>immutable</strong>, is an important concept in Swift, and we will revisit it in later chapters.</p>&#13;
<p>If we want to define something that can change, we declare it as a variable using the <kbd>var</kbd> keyword:</p>&#13;
<pre>var anotherPhrase = phrase </pre>&#13;
<p>Since <kbd>anotherPhrase</kbd> is a variable, we can assign a new value to it:</p>&#13;
<pre>anotherPhrase = "The quick brown <img src="img/044c8451-5b2e-4dcf-a452-3ad7c840d8f3.png" style="width:1.33em;height:1.08em;" width="845" height="762"/> jumps over the lazy <img src="img/c2d4cdf4-4bc5-4254-ac49-a2f805a5ad79.png" style="width:1.25em;height:1.25em;" width="854" height="855"/>"</pre>&#13;
<p>Strings in Swift are fully <em>Unicode-compliant</em>, so we can have some fun and use emojis instead of words. Now, let's print out the values of our strings to see what values they hold:</p>&#13;
<pre>print(phrase) // "The quick brown fox jumps over the lazy dog" <br/>print(anotherPhrase) // "The quick brown <img src="img/0cc059c4-b7b7-4f46-ab6a-62a47b16f520.png" style="width:1.50em;height:1.25em;" width="845" height="762"/> jumps over the lazy <img src="img/22004f2c-e6c5-4a66-97ab-f9671fd44561.png" style="width:1.33em;height:1.25em;" width="854" height="855"/>"</pre>&#13;
<p>In the preceding lines, we have done the following:</p>&#13;
<ul>&#13;
<li>Defined a string called <kbd>phrase</kbd></li>&#13;
<li>Defined a string called <kbd>anotherPhrase</kbd> as having the same value as <kbd>phrase</kbd></li>&#13;
<li>Changed the value of <kbd>anotherPhrase</kbd></li>&#13;
<li>Printed the value of <kbd>phrase</kbd> and <kbd>anotherPhrase</kbd></li>&#13;
</ul>&#13;
<p>When we do this, we see that only <kbd>anotherPhrase</kbd> prints the new value that was assigned, even though the values of <kbd>phrase</kbd> and <kbd>anotherPhrase</kbd> were initially the same. Although <kbd>phrase</kbd> and <kbd>anotherPhrase</kbd> had the same value, they do not have an intrinsic connection; so, when <kbd>anotherPhrase</kbd> is assigned a new value, this does not affect <kbd>phrase</kbd>.</p>&#13;
<p>Strings can be easily combined using the <kbd>+</kbd> operator:</p>&#13;
<pre>var phraseInfo = "The phrase" + " has: " <br/>print(phraseInfo) // "The phrase has: "</pre>&#13;
<p>This gives the result you would expect; the strings are concatenated. </p>&#13;
<p>You will often want to create strings by including values derived from other expressions. We can do this with <kbd>String</kbd> interpolation:</p>&#13;
<pre>phraseInfo = phraseInfo + "\(numberOfFoxes) fox and \(numberOfAnimals)<br/>  animals" <br/>print(phraseInfo) // "The phrase has: 1 fox and 2 animals" </pre>&#13;
<p>The values inserted after <kbd>\(</kbd> and before <kbd>)</kbd> can be anything that can be represented as a string, including other strings, ints, floats, or expressions.</p>&#13;
<p>&#13;
<p>We can also use expressions with string interpolation, such as displaying the number of characters in a string:</p>&#13;
</p>&#13;
<pre>print("Number of characters in phrase: \(phrase.count)") </pre>&#13;
<p>Strings in Swift are collections, which are containers of elements; in this case, a string is a collection of characters. We will cover collections in more depth in the next chapter, but for now, it's enough to know that your collections can tell you how many elements they contain through their count property. We use this to output the number of characters in the phrase.</p>&#13;
<p>Multiline string literals can be defined using <kbd>"""</kbd> at the beginning and end of the string:</p>&#13;
<pre class="p1">let multilineExplanation = """<br/>Why is the following phrase often used?<br/>"The quick brown fox jumps over the lazy dog"<br/>This phrase contains every letter in the alphabet.<br/>"""</pre>&#13;
<p>&#13;
<p>The contents of the Multiline string must be on a separate line from the start and end signifiers. Within a Multiline string literal, you can use single quote characters <kbd>"</kbd> without needing to use an additional escape character, as you would with a single-line string literal.</p>&#13;
</p>&#13;
<p>Boolean, or <kbd>Bool</kbd>, values represent either true or false. In the next line, we evaluate the value of a Boolean expression and assign the result to the <kbd>phrasesAreEqual</kbd> constant:</p>&#13;
<pre>let phrasesAreEqual: Bool = phrase == anotherPhrase <br/>print(phrasesAreEqual) // false </pre>&#13;
<p>Here, the equality operator, <kbd>==</kbd>, compares the values on its left and right and evaluates to <kbd>true</kbd> if the two values are equal, and <kbd>false</kbd> otherwise.</p>&#13;
<p>As we discussed earlier, although we assigned <kbd>anotherPhrase</kbd> the value of <kbd>phrase</kbd> initially, we then assigned a new, different value to <kbd>anotherPhrase</kbd>; therefore, <kbd>phrase</kbd> and <kbd>anotherPhrase</kbd> are not equal and the expression assigns the value of <kbd>false</kbd>.</p>&#13;
<p>Each side of the <kbd>==</kbd> operator can be any expression that evaluates to match the type of the other side, as we do with the following code:</p>&#13;
<pre>let phraseHas43Characters: Bool = phrase.characters.count == 40 + 3  <br/>print(phraseHas43Characters) // true </pre>&#13;
<p>In this case, the character count of <kbd>phrase</kbd> equals 43. Since <kbd>40 + 3</kbd> also equals 43, the constant is assigned the value of <kbd>true</kbd>.</p>&#13;
<h2 id="uuid-226dd811-4abc-49f8-93fc-8e38dfecf179">There's more...</h2>&#13;
<p>During this recipe, we defined a number of constants and variables, and when we did this, we also explicitly defined their type. For example, consider the following line of Swift code:</p>&#13;
<pre>let clearlyAString: String = "This is a string literal" </pre>&#13;
<p>Swift is a statically typed language. This means any constant or variable that we define has to have a specific type, and once defined it cannot be changed to a different type. However, in the preceding line of code, the <kbd>clearlyAString</kbd> constant is clearly a string! The right-hand side of the expression is a string literal, and therefore we know that the left-hand side will be a string. More importantly, the Swift compiler also knows this (a compiler is the program that turns Swift code into machine code).</p>&#13;
<p>Swift is all about being concise, so since the type can be inferred by the compiler, we do not need to explicitly state it. Instead of the preceding code, we can use the following code and it will still run, even though we didn't specify the type:</p>&#13;
<pre>let clearlyAString = "This is a string literal" </pre>&#13;
<p>In fact, all the type declarations that we have made so far can be removed! So, go back through the code we have already written and remove all type declarations (<kbd>:String</kbd>, <kbd>:Int</kbd>, <kbd>:Float</kbd>, and <kbd>:Bool</kbd>), as they can all be inferred. Run the playground to confirm that this is still valid Swift code.</p>&#13;
<h2 id="uuid-3129eeb3-4fe6-44c1-a9fb-98e544a0bd1b">See also</h2>&#13;
<p>Further information regarding these base types in Swift can be found in Apple's documentation of the Swift language:</p>&#13;
<ul>&#13;
<li><strong>Ints, Floats, and Bools</strong>: <a href="http://swiftbook.link/docs/the-basics">http://swiftbook.link/docs/the-basics</a></li>&#13;
</ul>&#13;
<ul>&#13;
<li><strong>Strings and Characters</strong>: <a href="http://swiftbook.link/docs/strings">http://swiftbook.link/docs/strings</a></li>&#13;
</ul>&#13;
<h1 id="uuid-e8750fca-7a84-4e92-9b7a-2ea11d094b8f">Unwrapping optionals, and force unwrapping</h1>&#13;
<p>In the real world, we don't always know the answer to a question, and problems can occur if we assume that we will always know the answer. The same is true in programming languages, especially when dealing with external systems that we may not control. In many languages, there is no way to call out that we might not know a value at any given time. This can lead to either fragile code or lots of checks to ensure a value exists before it can be used.</p>&#13;
<p>The term <kbd>nil</kbd> or <kbd>null</kbd> is used by programming languages to denote the absence of a value. Note that this is not the same as the number 0 or the empty (zero length) string <kbd>""</kbd>. Swift uses <kbd>nil</kbd> to indicate the absence of a value. Therefore, assigning <kbd>nil</kbd> to a value will remove any value that is currently assigned.</p>&#13;
<p>With a focus on Swift being type-safe and making it easier to write safe code, this ambiguity had to be addressed, and the Swift language does this with something called optionals. In this recipe, we will look at what optionals are in Swift, and how to handle and use them safely.</p>&#13;
<h2 id="uuid-2e3bbaaa-6587-493a-aa97-f28266afd4dc">Getting started</h2>&#13;
<p>Enter the following into a new playground:</p>&#13;
<pre>var dayOfTheWeek: String = "Monday" <br/>dayOfTheWeek = "Tuesday" <br/>dayOfTheWeek = "Wednesday" <br/>dayOfTheWeek = nil </pre>&#13;
<p>When you try to run the code, you will see that the compiler has raised an error and will not let you assign <kbd>nil</kbd> to the <kbd>dayOfTheWeek</kbd> variable. Quite right too! The day of the week might change, but there will never not be a current day of the week.</p>&#13;
<p>As we declared the type to be <kbd>String</kbd>, that is what the compiler expects, and <kbd>nil</kbd> is not a string, so it can't be assigned to this variable.</p>&#13;
<p>The same is true even if you remove the type declaration and have the compiler infer it, as we did in the preceding recipe. This is because the type is inferred at the point the variable is declared, and since it is being assigned a string value, the type of <kbd>String</kbd> is inferred. All other uses of this variable are checked against this inferred type of <kbd>String</kbd>.</p>&#13;
<p>Delete the last line, as the compiler issue will prevent us from running further code in the playground.</p>&#13;
<h2 id="uuid-e1e8ebd9-b19d-4e1d-bed4-f41bd6aa3198" class="p1">How to do it...</h2>&#13;
<p>We will look at a different scenario where it is appropriate to have an optional variable. Nick and Finn are playing a game. In each round, Finn will hold his hand behind his back and choose a number of fingers to hold up, Nick will guess how many fingers it is, and Finn will then show him how many fingers he had chosen to hold up.</p>&#13;
<p>To help keep track of the game, Nick stores how many fingers Finn has held up in a variable. When Finn shows his hand, Nick can enter a value for the number of fingers, but when Finn's hands are behind his back, Nick doesn't know how many fingers Finn is holding up, and so can't store a value.</p>&#13;
<p>Let's enter the following code:</p>&#13;
<pre>// Start of the game<br/>var numberOfFingersHeldUpByFinn: Int?<br/>// Finn's hand behind his back<br/>numberOfFingersHeldUpByFinn = nil<br/>// Finn shows his hand<br/>numberOfFingersHeldUpByFinn = 3<br/>// Finn puts hand back behind his back<br/>numberOfFingersHeldUpByFinn = nil<br/>// Finn shows his hand<br/>numberOfFingersHeldUpByFinn = 1<br/>print(numberOfFingersHeldUpByFinn)<br/>// End of the game<br/>let lastNumberOfFingersHeldUpByFinn: Int = numberOfFingersHeldUpByFinn!</pre>&#13;
<p>Unlike the days of the week example, this code compiles without issues, despite the fact that we assign <kbd>nil</kbd> to the variable. Let's look into why we were able to do that.</p>&#13;
<h2 id="uuid-53fc48c4-bc18-4791-b7da-e43edeb6abc2">How it works...</h2>&#13;
<p>We know that there will be times during the game when we don't know how many fingers are being held up, so the variable is optional; it may be an <kbd>Int</kbd>, or it may be <kbd>nil</kbd>. You will remember from earlier that <kbd>nil</kbd> does not mean <kbd>0</kbd>. It is entirely possible that Finn may be holding up zero fingers (that is, a clenched fist) and this is a valid answer. In this scenario, <kbd>nil</kbd> represents a lack of knowledge regarding the number of fingers. To declare this variable as optional, we define the expected type, but with an additional <kbd>?</kbd>:</p>&#13;
<pre>var numberOfFingersHeldUpByFinn: Int? </pre>&#13;
<p>In Swift, this is referred to as an optionally wrapped <kbd>Int</kbd>. We have wrapped the <kbd>Int</kbd> type in the concept of being optional. I am emphasizing this term <strong>wrapping</strong> because we will need to <strong>unwrap</strong> this optional type later on. At the start of the game, we don't know how many fingers are being held up, so we assign <kbd>nil</kbd> to this variable, which is allowable for optional variables:</p>&#13;
<pre>numberOfFingersHeldUpByFinn = nil </pre>&#13;
<p>Once Finn's hand is shown and we know how many fingers he has held up, we can assign that <kbd>Int</kbd> value to the variable:</p>&#13;
<pre>numberOfFingersHeldUpByFinn = 3 </pre>&#13;
<p>Since the variable type is an optional <kbd>Int</kbd>, the valid values are either <kbd>Int</kbd> or <kbd>nil</kbd>; if we try something of another type, we will get a compiler error:</p>&#13;
<pre>numberOfFingersHeldUpByFinn = "three" // Doesn't compile because "three" isn't an Int or nil</pre>&#13;
<p>As we discussed earlier, Swift has a static type system, so the type of variable can't be changed once it is declared. Therefore, although we have assigned a value of the <kbd>Int</kbd> type to the variable, this hasn't changed the variable type to the non-optional <kbd>Int</kbd>; its type remains <kbd>Int?</kbd>. Since the type is still optional, we can assign it a <kbd>nil</kbd> value when Finn puts his hands behind his back again:</p>&#13;
<pre>numberOfFingersHeldUpByFinn = nil  </pre>&#13;
<p>When we print an optional variable, the output tells us that it is optional, for example, <kbd>Optional(1)</kbd>:</p>&#13;
<pre>numberOfFingersHeldUpByFinn = 1 <br/>print(numberOfFingersHeldUpByFinn)  </pre>&#13;
<p>You will notice that the compiler highlights an issue that says Expression implicitly coerced from 'Int?' to 'Any' on the print line. We see this because we are passing an option value to the print comment, which is expecting a non-optional value. To solve this issue, we can provide a value to use if our optional value happens to be <kbd>nil</kbd>, and there is a really concise way to do this. The <kbd>??</kbd> operator can be applied after an optional value, and the value to the right of the operator will be used if the optional value is <kbd>nil</kbd>. This is called the <strong>nil coalescing operator</strong>:</p>&#13;
<pre class="p1">print(numberOfFingersHeldUpByFinn ?? "Unknown")</pre>&#13;
<p>At the end of the game, we want to store the number of fingers that Finn held up during the last round of the game. Since we know that we will play at least one round of the game, we know that there must be a value for the last number of fingers that were held up. Therefore, we declare the <kbd>lastNumberOfFingersHeldUpByFinn</kbd> variable as a non-optional <kbd>Int</kbd>:</p>&#13;
<pre>let lastNumberOfFingersHeldUpByFinn: Int = numberOfFingersHeldUpByFinn! </pre>&#13;
<p>However, our <kbd>numberOfFingersHeldUpByFinn</kbd> variable is an optional <kbd>Int</kbd>, and assigning a optional value to a non-optional variable causes a problem for the compiler since it can't be sure that it will be assigning a non-nil value. To get around this issue, we need to declare that this variable is now non-optional, even though we declared it as optional. We do this by adding <kbd>!</kbd> to the value.</p>&#13;
<p>If you remove <kbd>!</kbd> from the preceding statement, the compiler will complain:</p>&#13;
<pre>let lastNumberOfFingersHeldUpByFinn: Int = numberOfFingersHeldUpByFinn <br/>  // Does not compile </pre>&#13;
<p>In Swift terminology, by adding <kbd>!</kbd>, we are unwrapping the optional variable. Once it is unwrapped, and therefore non-optional, we can assign it to the <kbd>lastNumberOfFingersHeldUpByFinn</kbd> variable, which is also non-optional.</p>&#13;
<p>Beware! Use of this forced unwrapping can be risky. When you forcibly unwrap an optional, you are declaring that you are sure that there will be a value in that variable at that point in the execution of the code. However, if the variable is <kbd>nil</kbd>, you will get an error while your code is running and the execution will terminate. If this code is running in an app, then the app will crash. We will see safer ways to unwrap an optional value in the later chapters.</p>&#13;
<p>Let's see what happens when we forcibly unwrap a variable that is set to <kbd>nil</kbd>. Imagine that we ended the game before playing the first round:</p>&#13;
<pre>// Start of the game <br/>var numberOfFingersHeldUpByFinn: Int? <br/>// Hand behind his back <br/>numberOfFingersHeldUpByFinn = nil <br/>print(numberOfFingersHeldUpByFinn) // nil <br/>// End of the game <br/>let lastNumberOfFingersHeldUpByFinn: Int = numberOfFingersHeldUpByFinn! </pre>&#13;
<p>This code will compile and run, but will crash at runtime because at the point that <kbd>numberOfFingersHeldUpByFinn</kbd> is assigned to <kbd>lastNumberOfFingersHeldUpByFinn</kbd>, the value of <kbd>numberOfFingersHeldUpByFinn</kbd> is <kbd>nil</kbd>.</p>&#13;
<h2 id="uuid-3114df36-e4ed-4407-81c9-c3cb26695cbf">There's more...</h2>&#13;
<p>So far, we have seen non-optional variables, where a value of the correct type must be provided, and optional variables, where the value can either be the underlying type or <kbd>nil</kbd>. In a perfect world, this would be all we need. However, we may need to declare a variable that should be treated as non-optional, even if we don't know the value at the time it is declared. For these situations, we can declare a variable as an <strong>implicitly unwrapped optional</strong> (<strong>IUO</strong>) in Swift.</p>&#13;
<p>Run the following code in the playground:</p>&#13;
<pre>var legalName: String!  <br/>// At birth <br/>legalName = nil <br/>// At birth registration <br/>legalName = "Alissa Jones" <br/>// At enrolling in school <br/>print(legalName) <br/>// At enrolling in college <br/>print(legalName) <br/>// Registering Marriage <br/>legalName = "Alissa Moon" <br/>// When meeting new people <br/>print(legalName) </pre>&#13;
<p>In the preceding example, we have declared a person's legal name, which is used at many points during their life, such as when registering for educational institutions. It can be changed, either by legal request or through marriage, and yet you would never expect someone's legal name to not exist. However, that is exactly what happens when someone is born! When a person is born, they don't have a legal name until their birth is registered. So, if we were trying to model this in code, a person's legal name could be represented as an <strong>IUO</strong>.</p>&#13;
<p>In code, we declare a variable to be an IUO by placing a <kbd>!</kbd> sign after the type:</p>&#13;
<pre>let legalName: String!  </pre>&#13;
<p>IUOs present the same risk as forced unwrapping. You are promising that the variable has a value, even though it is possible that it could be <kbd>nil</kbd>. Although it's possible for the variable to be <kbd>nil</kbd>, when something tries to access it, a value will be there. If the variable is accessed, but doesn't contain a value, the execution will terminate and your app will crash.</p>&#13;
<p>There is some subtlety to how IUOs behave when they are assigned to other variables and the type is inferred. It's easiest to illustrate this with code, so enter the following into a playground:</p>&#13;
<pre>var input: Int! = 5 // Int! <br/>print(input) // 5 <br/>var output1 = input // Int? <br/>print(output1 as Any) // Optional(5) <br/>var output2 = input + 1 // Int <br/>print(output2) // 5</pre>&#13;
<p>When an IUO is assigned to a new variable, the compiler can't be sure that there is a non-nil value assigned. So, if an IUO is assigned to a new variable, as is the case with <kbd>output1</kbd> here, the compiler plays it safe and infers that the type of this new variable is an optional. If, however, the value of the IUO has been unwrapped, then the compiler knows that it has a non-nil value, and will infer a non-optional type. When assigning <kbd>output2</kbd>, the value of the input is unwrapped in order to add <kbd>1</kbd> to it. Therefore, the type of <kbd>output2</kbd> is inferred to be the non-optional <kbd>Int</kbd>.</p>&#13;
<h2 id="uuid-9512c54c-83d3-415a-9302-56a977775a0a">See also</h2>&#13;
<p>Further information regarding optionals can be found at <a href="http://swiftbook.link/docs/the-basics">http://swiftbook.link/docs/the-basics</a>.</p>&#13;
<h1 id="uuid-7bd6dd08-9169-4ba3-bf1b-83a71269057d">Reusing code in functions</h1>&#13;
<p><strong>Functions</strong> are a building block of almost all programming languages, allowing functionality to be defined and reused. Swift's syntax provides an expressive way to define your functions, creating concise and readable code. In this recipe, we will run through the different types of functions we can create, and understand how to define and use them.</p>&#13;
<h2 id="uuid-620b367e-aea6-4db5-aed3-706db09a493a">How to do it...</h2>&#13;
<p>Let's look at how functions are defined in Swift:</p>&#13;
<pre>func nameOfFunction(parameterLabel1 parameter1: ParameterType1, parameterLabel2 parameter2: ParameterType2,...) -&gt; OutputType { <br/>     <br/>   // Function's implementation <br/>   // If the function has an output type,  <br/>   // the function must return a valid value <br/>   return output <br/>}</pre>&#13;
<p>Let's look at this in more detail to see how a function is defined:</p>&#13;
<ul>&#13;
<li><kbd>func</kbd>: This indicates that you are declaring a function.</li>&#13;
<li><kbd>nameOfFunction</kbd>: This will be the name of your function and, by convention, is written in camel case (this means that each word, apart from the first, is capitalized and all spaces are removed). This should describe what the function does, and should provide some context to the value returned by the function, if one is returned. This will be how you will invoke the method from elsewhere in your code, so bear that in mind when naming it.</li>&#13;
<li><kbd>parameterLabel1 parameter1: ParameterType1</kbd>: This is the first input, or parameter, into the function. You can specify as many parameters as you like, separated by commas. Each parameter has a parameter name (<kbd>parameter1</kbd>) and type (<kbd>ParameterType1</kbd>). The parameter name is how the value of the parameter will be made available to your function's implementation. You can optionally provide a parameter label in front of the parameter name (<kbd>parameterLabel1</kbd> ) that will be used to label the parameter when your function is used (at the call site).</li>&#13;
<li><kbd>-&gt; OutputType</kbd>: This indicates that the function returns a value and indicates the type of that value. If no value is returned, this can be omitted.</li>&#13;
<li><kbd>{ }</kbd>: The curly brackets indicate the start and end of the function's implementation; anything within them will be executed when the function is called.</li>&#13;
</ul>&#13;
<ul>&#13;
<li><kbd>return output</kbd>: If the function returns a value, you type <kbd>return</kbd> and then the value to return. This ends the execution of the function; any code written after the return statement is not executed.</li>&#13;
</ul>&#13;
<p>Now, let's put this into action.</p>&#13;
<p>Imagine that we are building a contacts app to hold the details of your family and friends, and we want to create a string of a contact's full name. Let's explore some of the ways in which functions can be used:</p>&#13;
<pre>// Input parameters and output <br/>func fullName(givenName: String, <br/>              middleName: String, <br/>              familyName: String) -&gt; String {<br/><br/>    return "\(givenName) \(middleName) \(familyName)" <br/>} </pre>&#13;
<p>The preceding function takes three string parameters and outputs a string that puts all these together with spaces in between. The only thing this function does is take inputs and produce an output without causing any side effects; this type of function is often called a <strong>pure function</strong>. To call this function, we enter the name of the function followed by the input parameters within <kbd>()</kbd> brackets, where each parameter value is preceded by its label:</p>&#13;
<pre>let myFullName = fullName(givenName: "Keith", <br/>                          middleName: "David", <br/>                          familyName: "Moon") <br/><br/>print(myFullName) // Keith David Moon </pre>&#13;
<p>Functions with multiple parameters can get quite long, so to help with readability, the parameters can be placed on separate lines, as in the preceding example. This is true for both the definition of a function and when it is called. The convention is to align the start of the parameter name with the first parameter.</p>&#13;
<p>Since the function returns a value, we can assign the output of this function to a constant or a variable, just like any other expression.</p>&#13;
<p>The next function takes the same input parameters, but its purpose is not to return a value. Instead, it prints out the parameters as one string separated by spaces:</p>&#13;
<pre>// Input parameters, with a side effect and no output <br/>func printFullName(givenName: String, <br/>                   middleName: String, <br/>                   familyName: String) { <br/><br/>    print("\(givenName) \(middleName) \(familyName)") <br/>} </pre>&#13;
<p>We can call this function in the same way as the preceding function, although it can't be assigned to anything since it doesn't have a return value:</p>&#13;
<pre>printFullName(givenName: "Keith", middleName: "David", familyName: <br/>  "Moon") </pre>&#13;
<p>The following function takes no parameters as everything it needs to perform its task is contained within it, although it does output a string. This function calls the <kbd>fullName</kbd> function we defined earlier, taking advantage of its ability to produce a full name when given the component names. Reusing functionality is the most useful feature that functions provide:</p>&#13;
<pre>// No inputs, with an output <br/>func authorsFullName() -&gt; String { <br/><br/>    return fullName(givenName: "Keith", <br/>                    middleName: "David",<br/>                    familyName: "Moon") <br/>}</pre>&#13;
<p class="p1">Since <kbd>authorsFullName</kbd> takes no parameters, we can execute it by entering the function name followed by empty brackets, <kbd>()</kbd>, and since it returns a value, we can assign the outcome of <kbd>authorsFullName</kbd> to a variable:</p>&#13;
<pre>let authorOfThisBook = authorsFullName()</pre>&#13;
<p class="p1">Our final example takes no parameters and returns no value:</p>&#13;
<pre>// No inputs, no output <br/>func printAuthorsFullName() { <br/><br/>    let author = authorsFullName() <br/>    print(author) <br/>}</pre>&#13;
<p class="p1">You can call this function in the same way as the previous functions with no parameters, and there is no return value to assign:</p>&#13;
<pre>printAuthorsFullName()</pre>&#13;
<p>As you can see from the preceding example, having input parameters and providing an output value are not required when defining a function.</p>&#13;
<h2 id="uuid-e0bb6f36-75eb-4ec0-8c4a-c352625ef722">There's more...</h2>&#13;
<p>Now, let's look at a couple of ways of making your use of functions more expressive and concise.</p>&#13;
<h3 id="uuid-24596c35-5281-4ab0-b9dd-e046b1c4fcaf">Default parameter values</h3>&#13;
<p>One convenience in Swift is the ability to specify default values for parameters. These allow you to omit the parameter when calling, as the default value will be provided instead. Let's use the same example as earlier in this recipe, where we are creating a contact app to hold information about our family and friends. Many of your family members are likely to have the same family name as you, so we can set the family name as the default value for that parameter. Therefore, the family name only needs to be provided if it is different from the default.</p>&#13;
<p>Enter the following code into a playground:</p>&#13;
<pre>func fullName(givenName: String, <br/>              middleName: String, <br/>              familyName: String = "Moon") -&gt; String { <br/><br/>    return "\(givenName) \(middleName) \(familyName)" <br/>}</pre>&#13;
<p class="p1">Defining a default value looks similar to assigning a value to the <kbd>familyName: String = "Moon"</kbd> parameter. When calling the function, the parameter with the default value does not have to be given:</p>&#13;
<pre>let keith = fullName(givenName: "Keith", middleName: "David") <br/>let alissa = fullName(givenName: "Alissa", middleName: "May") <br/>let laura = fullName(givenName: "Laura", <br/>                     middleName: "May", <br/>                     familyName: "Jones") <br/>print(keith) // Keith David Moon <br/>print(alissa) // Alissa May Moon <br/>print(laura)  // Laura May Jones </pre>&#13;
<h3 id="uuid-36ce340c-77b8-4ce8-9c3b-f833d7a74b7a">Parameter overloading</h3>&#13;
<p>Swift supports parameter overloading, which allows for functions to have the same name and only be differentiated by the parameters that they take.</p>&#13;
<p>Let's learn more about parameter overloading by entering the following code into a playground:</p>&#13;
<pre>func combine(_ givenName: String, _ familyName: String) -&gt; String {<br/>    return "\(givenName) \(familyName)" <br/>} <br/> <br/>func combine(_ integer1: Int, _ integer2: Int) -&gt; Int { <br/>    return integer1+integer2 <br/>} <br/> <br/>let combinedString = combine("Finnley", "Moon") <br/>let combinedInt = combine(5, 10) <br/>print(combinedString) // Finnley Moon <br/>print(combinedInt) // 15 </pre>&#13;
<p>Both the preceding functions have the name <kbd>combine</kbd>, but one takes two strings as parameters, and the other takes two Ints. Therefore, when we call the function, Swift knows which implementation we intended by the values we pass as parameters.</p>&#13;
<p>We've introduced something new in the preceding function declarations, anonymous parameter labels: <kbd>_ givenName: String</kbd>.</p>&#13;
<p>When we declare the parameters, we use an underscore, <kbd>_</kbd>, for the parameter label. This indicates that we don't want a parameter name shown when calling the function. This should only be used if the purpose of the parameters is clear without the labels.</p>&#13;
<h2 id="uuid-3bee37ac-f898-486f-9b34-314e6d34c958">See also</h2>&#13;
<p>Further information about functions can be found at <a href="http://swiftbook.link/docs/functions">http://swiftbook.link/docs/functions</a>.</p>&#13;
<h1 id="uuid-624e48e4-049b-4526-ad86-39d516a1c8f1">Encapsulating functionality in object classes</h1>&#13;
<p><strong>Object-oriented programming</strong> is a common and powerful programming paradigm. At its core is the <em>object class</em>. Objects allow us to encapsulate data and functionality, which can then be stored and passed around.</p>&#13;
<p>In this recipe, we will build some class objects, break down their components, and understand how they are defined and used.</p>&#13;
<h2 id="uuid-54456a11-19f2-4cfb-a332-bed094696f6d">How to do it...</h2>&#13;
<p>Let's write some code to create and use class objects, and then we will walk through what the code is doing:</p>&#13;
<ol>&#13;
<li class="mce-root">First, create a <kbd>Person</kbd> class object:</li>&#13;
</ol>&#13;
<pre style="color: black;padding-left: 60px">class Person { <br/>    <br/>}</pre>&#13;
<ol start="2">&#13;
<li>Within the curly brackets, <kbd>{</kbd> and <kbd>}</kbd>, add three constants representing the person's name, and one variable representing their country of residence:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let givenName: String <br/>let middleName: String <br/>let familyName: String <br/>var countryOfResidence: String = "UK"</pre>&#13;
<ol start="3">&#13;
<li>Below the properties, but still within the curly brackets, add an initialization method for our <kbd>Person</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">init(givenName: String, middleName: String, familyName: String) { <br/>    self.givenName = givenName<br/>    self.middleName = middleName<br/>    self.familyName = familyName<br/>}</pre>&#13;
<ol start="4">&#13;
<li>Next, add a variable as a property of the class, with a computed value:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var displayString: String { <br/>    return "\(self.fullName()) - Location: \<br/>      (self.countryOfResidence)"<br/>} </pre>&#13;
<ol start="5">&#13;
<li>Add a function within the <kbd>Person</kbd> object that returns the person's full name:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fullName() -&gt; String { <br/>    return "\(givenName) \(middleName) \(familyName)" <br/>} </pre>&#13;
<ol start="6">&#13;
<li>Next, create a <kbd>Friend</kbd> object that extends the functionality of the <kbd>Person</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">final class Friend: Person { <br/>    <br/>} </pre>&#13;
<ol start="7">&#13;
<li>Within the <kbd>Friend</kbd> class object, add a variable property to hold details of where the user met the friend, and override the display string property to customize its behavior for <kbd>Friend</kbd> objects:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var whereWeMet: String? <br/>     <br/>override var displayString: String { <br/>    let meetingPlace = whereWeMet ?? "Don't know where we met"<br/>    return "\(super.displayString) - \(meetingPlace)" <br/>} </pre>&#13;
<ol start="8">&#13;
<li>In addition to the <kbd>Friend</kbd> object, create a <kbd>Family</kbd> object that extends the functionality of the <kbd>Person</kbd> object:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">final class Family: Person { <br/>     <br/>}</pre>&#13;
<ol start="9">&#13;
<li>Add a relationship property to our <kbd>Family</kbd> object and create an initializer method to populate it in addition to the other properties from <kbd>Person</kbd>:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">final class Family: Person { <br/><br/>    let relationship: String <br/>     <br/>    init(givenName: String, <br/>         middleName: String, <br/>         familyName: String = "Moon",<br/>         relationship: String) { <br/><br/>        self.relationship = relationship <br/>        super.init(givenName: givenName, <br/>                   middleName: middleName, <br/>                   familyName: familyName) <br/>    } <br/>} </pre>&#13;
<ol start="10">&#13;
<li>Give the <kbd>Family</kbd> object a custom <kbd>displayString</kbd> method that includes the value of the <kbd>relationship</kbd> property by adding this code within the <kbd>Family</kbd> object definition (within the curly brackets):</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">override var displayString: String { <br/><br/>    return "\(super.displayString) - \(relationship)" <br/>} </pre>&#13;
<ol start="11">&#13;
<li>Lastly, create instances of our new objects and print the display string to see how its value differs:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let steve = Person(givenName: "Steven", <br/>                    middleName: "Paul", <br/>                    familyName: "Jobs") <br/><br/>let richard = Friend(givenName: "Richard", <br/>                     middleName: "Adrian", <br/>                     familyName: "Das") <br/>richard.whereWeMet = "Worked together at Travel Supermarket" <br/><br/>let finnley = Family(givenName: "Finnley", <br/>                     middleName: "David", <br/>                     relationship: "Son") <br/><br/>let dave = Family(givenName: "Dave", <br/>                  middleName: "deRidder", <br/>                  familyName: "Jones", <br/>                  relationship: "Father-In-Law") <br/>dave.countryOfResidence = "US" <br/> <br/>print(steve.displayString) <br/>// Steven Paul Jobs <br/><br/>print(richard.displayString) <br/>// Richard Adrian Das - Worked together at Travel Supermarket <br/><br/>print(finnley.displayString) <br/>// Finnley David Moon - Son <br/><br/>print(dave.displayString) <br/>// Dave deRidder Jones - Father-In-Law</pre>&#13;
<h2 id="uuid-e039a31a-a80e-49e0-8909-1f59ce4bd0bc">How it works...</h2>&#13;
<p>Classes are defined with the <kbd>class</kbd> keyword. Class names start with a capital letter by convention, and the implementation of the class is contained, or "scoped", within curly brackets:</p>&#13;
<pre>class Person {<br/>     //...<br/>}</pre>&#13;
<p>An object can have property values, which are contained within the object. These properties can have initial values, as <kbd>countryOfResidence</kbd> does in the following code, although bear in mind that constants (defined with <kbd>let</kbd>) cannot be changed once the initial value has been set:</p>&#13;
<pre>class Person {<br/>    let givenName: String<br/>    let middleName: String<br/>    let familyName: String<br/>    var countryOfResidence: String = "UK"<br/>    //...<br/>}</pre>&#13;
<p>If your class were to just have the preceding property definitions, the compiler would raise a warning, as <kbd>givenName</kbd>, <kbd>middleName</kbd>, and <kbd>familyName</kbd> are defined as non-optional strings, but we have not provided any way to populate those values.</p>&#13;
<p>The compiler needs to know how the object will be initialized so that we can be sure that all the non-optional properties will indeed have values:</p>&#13;
<pre>class Person { <br/>    let givenName: String <br/>    let middleName: String <br/>    let familyName: String <br/>    var countryOfResidence: String = "UK" <br/>     <br/>    init(givenName: String, middleName: String, familyName: String) { <br/>        self.givenName = givenName <br/>        self.middleName = middleName <br/>        self.familyName = familyName <br/>    } <br/>    //... <br/>} </pre>&#13;
<p><kbd>init</kbd> is a special method (functions defined within objects are called methods) that's called when the object is initialized. In the <kbd>Person</kbd> object of the preceding code, <kbd>givenName</kbd>, <kbd>middleName</kbd>, and <kbd>familyName</kbd> must be passed in when the object is initialized, and we assign those provided values to the object's properties. The <kbd>self.</kbd> prefix is used to differentiate between the property and the value passed in, as they have the same name.</p>&#13;
<p>We do not need to pass in a value for <kbd>countryOfResidence</kbd> as this has an initial value. This isn't ideal, though, as when we create a <kbd>Person</kbd> object, it will always have the <kbd>countryOfResidence</kbd> variable set to <kbd>"UK"</kbd>, and we will then have to change that value, if different, after initialization. Another way to do this would be to use a default parameter value, as seen in the previous recipe. Amend the <kbd>Person</kbd> object initialization to the following:</p>&#13;
<pre>class Person { <br/>    let givenName: String <br/>    let middleName: String <br/>    let familyName: String <br/>    var countryOfResidence: String <br/>     <br/>    init(givenName: String, <br/>         middleName: String, <br/>         familyName: String, <br/>         countryOfResidence: String = "UK") { <br/><br/>        self.givenName = givenName <br/>        self.middleName = middleName <br/>        self.familyName = familyName <br/>        self.countryOfResidence = countryOfResidence <br/>    } <br/>    //... <br/>} <br/> </pre>&#13;
<p>Now, you can provide a country of residence in the initialization or omit it to use the default value.</p>&#13;
<p>Next, let's look at the <kbd>displayString</kbd> property of our <kbd>Person</kbd> class:</p>&#13;
<pre>class Person { <br/>    //... <br/>    var displayString: String { <br/>        return "\(self.fullName()) - Location: \<br/>          (self.countryOfResidence)" <br/>    } <br/>    //... <br/>} </pre>&#13;
<p>This property declaration is different from the others. Rather than having a value assigned to it, it is followed by an expression contained within curly braces. This is a computed property; its value is not static but is determined by the given expression every time the property is accessed. Any valid expressions can be used to compute the property, but must return a value that matches the declared type of the property. The compiler will enforce this, and you can't omit the variable type for computed properties.</p>&#13;
<p>In constructing the return value above, we use <kbd>self.fullName()</kbd> and <kbd>self.countryOfResidence</kbd>. As we did in the preceding <kbd>init</kbd> method, we use <kbd>self.</kbd> to show that we are accessing the method and property of the current instance of the <kbd>Person</kbd> object. However, since <kbd>displayString</kbd> is already a property on the current instance, the Swift compiler is aware of this context and so those self references can be removed:</p>&#13;
<pre>var displayString: String { <br/>    return "\(fullName()) - Location: \(countryOfResidence)" <br/>} </pre>&#13;
<p>Objects can do work based on the information they contain, and this work can be defined in methods. Methods are just functions that are contained within classes and have access to all the object's properties. The <kbd>Person</kbd> object's <kbd>fullName</kbd> method is an example of this:</p>&#13;
<pre>  <br/>class Person { <br/>    //... <br/>    func fullName() -&gt; String { <br/>        return "\(givenName) \(middleName) \(familyName))" <br/>    } <br/>    //... <br/>}</pre>&#13;
<p>All the abilities of a function are available, which we explored in the last recipe, including optional inputs and outputs, default parameter values, and parameter overloading.</p>&#13;
<p>Having defined a <kbd>Person</kbd> object, we want to extend the concept of <kbd>Person</kbd> to define a friend. A friend is also a person, so it stands to reason that anything a <kbd>Person</kbd> object can do, a <kbd>Friend</kbd> object can also do. We model this inherited behavior by defining <kbd>Friend</kbd> as a subclass of <kbd>Person</kbd>. We define the class that our <kbd>Friend</kbd> class inherits from (called the "superclass"), after the class name, separated by <kbd>:</kbd>:</p>&#13;
<pre>  <br/>final class Friend: Person { <br/>    var whereWeMet: String? <br/>    //... <br/>} </pre>&#13;
<p>By inheriting from <kbd>Person</kbd>, our <kbd>Friend</kbd> object inherits all the properties and methods from its superclass. We can then add any extra functionality we require. In this case, we add a property for details of where we met this friend.</p>&#13;
<p>The <kbd>final</kbd> prefix tells the compiler that we don't intend for this class to be subclassed; it is the final class in the inheritance hierarchy. This allows the compiler to make some optimizations as it knows it won't be extended.</p>&#13;
<p>In addition to implementing new functionalities, we can override functionalities from the superclass using the <kbd>override</kbd> keyword:</p>&#13;
<pre>final class Friend: Person { <br/>    //... <br/>    override var displayString: String { <br/><br/>        let meetingPlace = whereWeMet ?? "Don't know where we met"<br/>        return "\(super.displayString) - \(meetingPlace)" <br/>    } <br/>} </pre>&#13;
<p class="mce-root">In the preceding code, we override the <kbd>displayString</kbd> computed property from <kbd>Person</kbd> as we want to add the "where we met" information. Within the computed property, we can access the superclass's implementation by calling <kbd>super.</kbd>, and then referencing the property or method.</p>&#13;
<p>Next, let's look at how we can customize how our subclasses are initialized:</p>&#13;
<pre>final class Family: Person {<br/><br/>    let relationship: String<br/><br/>    init(givenName: String, <br/>         middleName: String, <br/>         familyName: String = "Moon", <br/>         relationship: String) {<br/><br/>        self.relationship = relationship<br/>        super.init(givenName: givenName, <br/>                   middleName: middleName, <br/>                   familyName: familyName)<br/>    }<br/>    //...<br/>}</pre>&#13;
<p>Our <kbd>Family</kbd> class also inherits from <kbd>Person</kbd>, but we want to add a <kbd>relationship</kbd> property, which should form part of the initialization, so we can declare a new <kbd>init</kbd> that also takes a relationship string value. That passed-in value is then assigned to the <kbd>relationship</kbd> property because the superclass's initializer is called.</p>&#13;
<p>Subclasses must have all their non-optional properties assigned a value before the superclass's <kbd>init</kbd> method is called. If we had forgotten to assign a value to <kbd>relationship</kbd>, or we had assigned it after calling <kbd>super.init</kbd>, then our code would not compile.</p>&#13;
<p>With all our class objects defined, we can create instances of these objects and call methods and access properties of these objects:</p>&#13;
<pre>let steve = Person(givenName: "Steven", <br/>                   middleName: "Paul", <br/>                   familyName: "Jobs") <br/><br/>let richard = Friend(givenName: "Richard", <br/>                     middleName: "Adrian", <br/>                     familyName: "Das") <br/>richard.whereWeMet = "Worked together at Travel Supermarket" <br/><br/>let finnley = Family(givenName: "Finnley", <br/>                     middleName: "David", <br/>                     relationship: "Son") <br/><br/>let dave = Family(givenName: "Dave", <br/>                  middleName: "deRidder", <br/>                  familyName: "Jones", <br/>                  relationship: "Father-In-Law") <br/>dave.countryOfResidence = "US" <br/> <br/>print(steve.displayString) <br/>// Steven Paul Jobs <br/><br/>print(richard.displayString) <br/>// Richard Adrian Das - Worked together at Travel Supermarket <br/><br/>print(finnley.displayString) <br/>// Finnley David Moon - Son <br/><br/>print(dave.displayString) <br/>// Dave deRidder Jones - Father-In-Law</pre>&#13;
<p>To create an instance of an object, we use the name of the object like a function, passing in any required parameters. This returns an object instance that we can then assign to a constant or variable.</p>&#13;
<p>When creating an instance, we are actually calling the object's <kbd>init</kbd> method, and you can do this explicitly, as follows:</p>&#13;
<pre>let steve = Person.init(givenName: "Steven", <br/>                        middleName: "Paul", <br/>                        familyName: "Jobs") </pre>&#13;
<p>However, to be concise, this is usually omitted.</p>&#13;
<h2 id="uuid-ec0d352d-6c92-4715-b03c-545b41671aa0">There's more...</h2>&#13;
<p>Class objects are <strong>reference types</strong>, which is a term that refers to the way they are stored and referenced internally. To see how these reference type semantics work, let's look at how an object behaves when it is modified:</p>&#13;
<pre>class MovieReview { <br/>    let movieTitle: String <br/>    var starRating: Int // Rating out of 5 <br/>    init(movieTitle: String, starRating: Int) { <br/>        self.movieTitle = movieTitle <br/>        self.starRating = starRating <br/>    } <br/>} <br/> <br/>// Write a review <br/>let shawshankReviewOnYourWebsite = MovieReview(movieTitle: "Shawshank <br/>  Redemption", starRating: 3)     <br/>                                               <br/> <br/>// Post it to social media <br/>let referenceToReviewOnTwitter = shawshankReviewOnYourWebsite <br/>let referenceToReviewOnFacebook = shawshankReviewOnYourWebsite <br/> <br/>print(referenceToReviewOnTwitter.starRating) // 3 <br/>print(referenceToReviewOnFacebook.starRating) // 3 <br/> <br/>// Reconsider the review  <br/>shawshankReviewOnYourWebsite.starRating = 5 <br/> <br/>// The change is visible from anywhere with a reference to the object  <br/>print(referenceToReviewOnTwitter.starRating) // 5 <br/>print(referenceToReviewOnFacebook.starRating) // 5</pre>&#13;
<p>We defined a <kbd>MovieReview</kbd> class object, created an instance of that <kbd>MovieReview</kbd> object, and then assigned that review to two separate constants. As a class object is a reference type, it is a reference to the object that is stored in the constant, rather than a new copy of the object. Therefore, when we reconsider our review to give <em>The Shawshank Redemption</em> five stars (and rightly so!), we are changing the underlying object. All references that access that underlying object will receive the updated value when the <kbd>starRating</kbd> property is accessed.</p>&#13;
<h2 id="uuid-6ba3683e-1b92-48ef-8fe4-5be06b70a757">See also</h2>&#13;
<ul>&#13;
<li>Further information about classes can be found at <a href="http://swiftbook.link/docs/classes-and-structures">http://swiftbook.link/docs/classes-and-structures</a>.</li>&#13;
<li>In <a href="f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml">Chapter 9</a>, <em>Performance and Responsiveness in Swift</em>, we will examine reference semantics in more detail, and see how this affects performance.</li>&#13;
</ul>&#13;
<h1 id="uuid-49e03049-de3f-424b-9167-60c567d9124e">Bundling values into structs</h1>&#13;
<p>Class objects are great for encapsulating data and functionality within a unifying concept, such as a person, as they allow individual instances to be referenced. However, not everything is an object. We may need to represent data that is logically grouped together, but there isn't much more than that. It's <strong>not</strong> more than the sum of its parts; it is the sum of its parts.</p>&#13;
<p>For this, there are <strong>structs</strong>. Short for structures, structs can be found in many programming languages. Structs are <strong>value types</strong>, as opposed to classes, which are reference types, and, as such, behave differently when passed around. In this recipe, we will learn how structs work in Swift, and when and how to use them.</p>&#13;
<h2 id="uuid-8b7ee9eb-6df3-45bc-82e1-d4afe8a4a803">Getting ready</h2>&#13;
<p>This recipe will build on top of the previous recipe, so open the playground you have used for the previous recipe. Don't worry if you didn't work through the previous recipe, as this one will contain all the code you need.</p>&#13;
<h2 id="uuid-eac92cba-47eb-4579-959c-d8a0f97b701a">How to do it...</h2>&#13;
<p>We have already defined a <kbd>Person</kbd> object as having three separate string properties relating to the person's name. However, these three separate strings don't exist in isolation from each other, as together they define a person's name. Currently, if you wanted to retrieve a person's name, you have to access three separate properties and combine them. Let's tidy this up by defining a person's name as its own struct:</p>&#13;
<ol>&#13;
<li>Create a struct called <kbd>PersonName</kbd>:</li>&#13;
</ol>&#13;
<pre style="color: black;padding-left: 60px">struct PersonName { <br/>    <br/>} </pre>&#13;
<ol start="2">&#13;
<li>Add three properties to <kbd>PersonName</kbd>, for <kbd>givenName</kbd>, <kbd>middleName</kbd> and <kbd>familyName</kbd>. Make the first two constants, and the last one a variable, as a family name can change:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct PersonName { <br/>    let givenName: String <br/>    let middleName: String <br/>    var familyName: String <br/>} </pre>&#13;
<ol start="3">&#13;
<li>Add a method to combine the three properties into a <kbd>fullName</kbd> string:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">func fullName() -&gt; String { <br/>    return "\(givenName) \(middleName) \(familyName)" <br/>}</pre>&#13;
<ol start="4">&#13;
<li>Provide a method to change the family name property and prefix this method with the <kbd>mutating</kbd> keyword:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">mutating func change(familyName: String) { <br/>    self.familyName = familyName <br/>}</pre>&#13;
<ol start="5">&#13;
<li>Create a person name, passing in the property values:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">var alissasName = PersonName(givenName: "Alissa", <br/>                             middleName: "May", <br/>                             familyName: "Jones")</pre>&#13;
<h2 id="uuid-4a0d4578-5d9e-4598-852c-958ba5caf15d">How it works...</h2>&#13;
<p>Defining a struct is very similar to defining an object class, and that is intentional. Much of the functionality available to a class is also available to a struct. Therefore, you will notice that aside from using the <kbd>struct</kbd> keyword instead of <kbd>class</kbd>, the definition of a class and a struct are almost identical.</p>&#13;
<p>Within the <kbd>PersonName</kbd> struct, we have properties for the three components of the name and the <kbd>fullName</kbd> method we saw earlier to combine the three name components into a full name string.</p>&#13;
<p>The method we created to change the family name property has a new keyword that we haven't seen before, <kbd>mutating</kbd>:</p>&#13;
<pre>mutating func change(familyName: String) { <br/>    self.familyName = familyName <br/>} </pre>&#13;
<p>This keyword must be added to any method in a struct that changes a property of the struct. This keyword is to inform anyone using the method that it will change, or "mutate", the struct. Unlike class objects, when you mutate a struct, you create a copy of the struct with the changed properties. This behavior is known as <strong>value-type semantics</strong>.</p>&#13;
<p>To see this in action, let's first create a struct and then check that it behaves as we expect when we assign it to different values:</p>&#13;
<pre>let alissasBirthName = PersonName(givenName: "Alissa", <br/>                                  middleName: "May", <br/>                                  familyName: "Jones") <br/>print(alissasBirthName.fullName()) // Alissa May Jones <br/>var alissasCurrentName = alissasBirthName <br/>print(alissasCurrentName.fullName()) // Alissa May Jones </pre>&#13;
<p>So far, so good. We have created a <kbd>PersonName</kbd> struct, assigned it to a constant called <kbd>alissasBirthName</kbd>, and then assigned that constant to a variable called <kbd>alissasCurrentName</kbd>.</p>&#13;
<p>Now let's see what happens when we mutate <kbd>alissasCurrentName</kbd>:</p>&#13;
<pre>alissasCurrentName.change(familyName: "Moon") <br/>print(alissasBirthName.fullName()) // Alissa May Jones <br/>print(alissasCurrentName.fullName()) // Alissa May Moon </pre>&#13;
<p>When we call the mutating method on the <kbd>alissasCurrentName</kbd> variable, only that variable is changed. This change is not reflected in <kbd>alissasBirthName</kbd>, even though these structs were once the same. This behavior would be different if <kbd>PersonName</kbd> was an object class, and we explored that behavior in the previous recipe.</p>&#13;
<h2 id="uuid-787bf337-30f4-4a03-aa39-c31a223e8c3b">There's more...</h2>&#13;
<p>We can use how this value-type behavior interacts with constants and variables to restrict unintended changes.</p>&#13;
<p>To see this in action, first, let's amend our <kbd>Person</kbd> class to our new <kbd>PersonName</kbd> struct:</p>&#13;
<pre>class Person { <br/>     <br/>    let birthName: PersonName <br/>    var currentName: PersonName <br/>    var countryOfResidence: String <br/>     <br/>    init(name: PersonName, countryOfResidence: String = "UK") { <br/>        birthName = name <br/>        currentName = name <br/>        self.countryOfResidence = countryOfResidence <br/>    } <br/>     <br/>    var displayString: String { <br/>        return "\(currentName.fullName()) - Location: \<br/>          (countryOfResidence)" <br/>    } <br/>} </pre>&#13;
<p>We've added the <kbd>birthName</kbd> and <kbd>currentName</kbd> properties of our new <kbd>PersonName</kbd> struct type, and we initiate them with the same value when the <kbd>Person</kbd> object is created. Since a person's birth name won't change, we define it as a constant, but their current name can change, so it's defined as a variable.</p>&#13;
<p>Now, let's create a new <kbd>Person</kbd> object:</p>&#13;
<pre>var name = PersonName(givenName: "Alissa", middleName: "May", familyName: "Jones") <br/>let alissa = Person(name: name) <br/>print(alissa.currentName.fullName()) // Alissa May Jones </pre>&#13;
<p>Since our <kbd>PersonName</kbd> struct has value semantics, we can use this to enforce the behavior that we expect our model to have. We would expect to not be able to change a person's birth name, and if you try, you will find that the compiler won't let you.</p>&#13;
<p>As we discussed earlier, changing the family name mutates the struct, and so a new copy is made. However, we defined <kbd>birthName</kbd> as a constant, which can't be changed, so the only way we would be able to change the family name would be to change our definition of <kbd>birthName</kbd> from <kbd>let</kbd> to <kbd>var</kbd>:</p>&#13;
<pre>alissa.birthName.change(familyName: "Moon") // Does not compile. <br/>  // Compiler tells you to change let to var </pre>&#13;
<p>When we change <kbd>currentName</kbd> to have a new family name, which we can do since we defined it as a <kbd>var</kbd>, it changes the <kbd>currentName</kbd> property, but not the <kbd>birthName</kbd> property, even though these were assigned with the same value:</p>&#13;
<pre>print(alissa.birthName.fullName()) // Alissa May Jones <br/>print(alissa.currentName.fullName()) // Alissa May Jones <br/>alissa.currentName.change(familyName: "Moon") <br/>print(alissa.birthName.fullName()) // Alissa May Jones <br/>print(alissa.currentName.fullName()) // Alissa May Moon </pre>&#13;
<p>We have used a combination of objects and structs to create a model that enforces our expected behavior. This technique can help to reduce potential bugs in our code.</p>&#13;
<h2 id="uuid-2221176d-5256-42f3-9dd4-818280daea60">See also</h2>&#13;
<ul>&#13;
<li>Further information about structs can be found at <a href="http://swiftbook.link/docs/classes-and-structures">http://swiftbook.link/docs/classes-and-structures</a>.</li>&#13;
</ul>&#13;
<ul>&#13;
<li>In <a href="f9e2c873-c2b2-4d40-9b02-5d884006d1a5.xhtml">Chapter 9</a>, <em>Performance and Responsiveness in Swift</em>, we will examine value semantics in more detail, and see how it affects performance.</li>&#13;
</ul>&#13;
<h1 id="uuid-8339b1d9-d05c-45df-b7d8-710cc49cadb5">Enumerating values with enums</h1>&#13;
<p><strong>Enumerations</strong> are a programming construct that lets you define a value type with a finite set of options. Most programming languages have enumerations (usually abbreviated to <strong>enums</strong>), although the Swift language takes the concept further than most.</p>&#13;
<p>An example of an enum from the iOS/macOS SDK is <kbd>ComparisonResult</kbd>, which you would use when sorting items. When comparing for the purposes of sorting, there are only three possible results from a comparison:</p>&#13;
<ul>&#13;
<li><kbd>ascending</kbd>: The items are ordered in ascending order.</li>&#13;
<li><kbd>descending</kbd>: The items are ordered in descending order.</li>&#13;
<li><kbd>same</kbd>: The items are the same.</li>&#13;
</ul>&#13;
<p>There are a finite number of possible options for a comparison result; therefore, it's a perfect candidate for being represented by an enum:</p>&#13;
<pre>enum ComparisonResult : Int { <br/>    case orderedAscending <br/>    case orderedSame <br/>    case orderedDescending <br/>} </pre>&#13;
<p>Swift takes the enum concept and elevates it to a first-class type. As we will see, this makes enums a very powerful tool for modeling your information.</p>&#13;
<p>This recipe will examine how and when to use enums in Swift.</p>&#13;
<h2 id="uuid-a150dd60-b162-447b-9e29-35d15f9e2067">Getting ready</h2>&#13;
<p>This recipe will build on top of the earlier recipes, so open the playground you have used for the previous recipes. Don't worry if you haven't tried out the previous recipes, as this one will contain all the code you need.</p>&#13;
<h2 id="uuid-158d527c-e305-4766-8e97-af6167ba4181">How to do it...</h2>&#13;
<p>In the <em>Encapsulating functionality in object classes</em> recipe, we created a <kbd>Person</kbd> object to represent people in our model and, in the <em>Bundling values into structs</em> recipe, we made a <kbd>PersonName</kbd> struct to hold information about a person's name. Now, let's turn our attention to a person's title (for example, Mr, Mrs), which precedes someone's full name. There are a small and finite number of common titles that a person may have; therefore an enum is a great way to model this information.</p>&#13;
<ol>&#13;
<li>Create an enum to represent a person's title:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">enum Title { <br/>    case mr <br/>    case mrs <br/>    case mister <br/>    case miss <br/>    case dr <br/>    case prof <br/>    case other <br/>} </pre>&#13;
<p style="padding-left: 60px">We define our enumeration with the <kbd>enum</kbd> keyword and provide a name for the enum. As with classes and structs, the convention is that this starts with a capital letter, and the implementation is defined within curly brackets. We define each enum option with the <kbd>case</kbd> keyword, and, by convention, these start with a lowercase character.</p>&#13;
<ol start="2">&#13;
<li>Assign the <kbd>mr</kbd> case of our <kbd>Title</kbd> enum to a value:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let title1 = Title.mr</pre>&#13;
<p style="padding-left: 60px">Enums can be assigned by specifying the enum type, then a dot, and then the case. However, if the compiler can infer the enum type, we can omit the type and just provide the case, preceded by a dot.</p>&#13;
<ol start="3">&#13;
<li>Define a constant value, of the <kbd>Title</kbd> type, and then assign a case to it with the type inferred:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">let title2: Title <br/>title2 = .mr</pre>&#13;
<h2 id="uuid-d100fd74-e9c9-4561-9c7c-4047d066146e">How it works...</h2>&#13;
<p>In many programming languages, including C and Objective-C, enums are defined as a type definition on top of an integer, with each case being given a defined integer value. In Swift, enums do not need to represent integers under the hood. In fact, they do not need to be backed by any type and can exist as their own abstract concepts. Consider the following example:</p>&#13;
<pre>enum CompassPoint { <br/>    case North, South, East, West <br/>} </pre>&#13;
<p>It doesn't make sense to map the compass points as integers, and in Swift we don't have to. </p>&#13;
<p>Note that we can define multiple cases on the same line by separating them with commas.</p>&#13;
<p>For <kbd>Title</kbd> also, an integer-based enum doesn't seem appropriate; however, a string-based one may be. So, let's declare our enum to be string-based:</p>&#13;
<pre>enum Title: String { <br/>    case mr = "Mr" <br/>    case mrs = "Mrs" <br/>    case mister = "Master" <br/>    case miss = "Miss" <br/>    case dr = "Dr" <br/>    case prof = "Prof" <br/>    case other // Inferred as "other" <br/>} </pre>&#13;
<p>The enum's raw underlying type is declared after its name and a <kbd>:</kbd> separator. The raw types that can be used to back the enum are limited to types that can be represented as a literal. This includes the following Swift base types:</p>&#13;
<ul>&#13;
<li><kbd>String</kbd></li>&#13;
<li><kbd>Int</kbd></li>&#13;
<li><kbd>Float</kbd></li>&#13;
<li><kbd>Bool</kbd></li>&#13;
</ul>&#13;
<p>These types can be used to back an enum because they conform to a protocol, called <kbd>RawRepresentable</kbd>. We will cover protocols later in the chapter.</p>&#13;
<p>Cases can be assigned a value of the raw type; however, certain types can be inferred, and so do not need to be explicitly declared. For int-backed enums, the inferred values are sequentially assigned starting at <kbd>0</kbd>:</p>&#13;
<pre>enum Rating: Int { <br/>    case worst   // Infered as 0 <br/>    case bad     // Infered as 1 <br/>    case average // Infered as 2 <br/>    case good    // Infered as 3 <br/>    case best    // Infered as 4 <br/>} </pre>&#13;
<p>For string-based enums, the inferred value is the name of the case, so the <kbd>other</kbd> case in our <kbd>Title</kbd> enum is inferred to be <kbd>other</kbd>.</p>&#13;
<p>We can get the underlying value of the enum in its raw type by accessing its <kbd>rawValue</kbd> property:</p>&#13;
<pre>let title1 = Title.mr <br/>print(title1.rawValue) // "Mr" </pre>&#13;
<h2 id="uuid-d2041c05-cc02-44d6-bb74-19e5d625a43d">There's more...</h2>&#13;
<p>As mentioned in the introduction to this recipe, Swift treats enums as a first-class type, and therefore they can have functionality that is not available to enums in most programming languages. This includes having computed variables and methods.</p>&#13;
<h3 id="uuid-e441e594-e6af-43bc-a1b0-f35146c0561f">Methods and computed variables</h3>&#13;
<p>Let's imagine that it is important for us to know whether a person's title relates to a professional qualification that the person holds. Let's add a method to our enum to provide that information:</p>&#13;
<pre style="padding-left: 30px">enum Title: String { <br/>    case mr = "Mr" <br/>    case mrs = "Mrs" <br/>    case mister = "Master" <br/>    case miss = "Miss" <br/>    case dr = "Dr" <br/>    case prof = "Prof" <br/>    case other // Inferred as "other" <br/><br/>    func isProfessional() -&gt; Bool { <br/>        return self == Title.dr || self == Title.prof <br/>    }<br/>}</pre>&#13;
<p>For the list of titles that we have defined, <kbd>Dr</kbd> and <kbd>Prof</kbd> relate to professional qualifications, so we have our method return <kbd>true</kbd> if <kbd>self</kbd> (the instance of the enum type this method is called on) is equal to the <kbd>dr</kbd> case, or equal to the <kbd>prof</kbd> case.</p>&#13;
<p>In defining this method, we used <kbd>||</kbd>, which is the OR logical operator. Using this operator returns a <kbd>true</kbd> Bool value if the expression on the left-hand side evaluates to <kbd>true</kbd> OR the expression on the right-hand side evaluates to <kbd>true</kbd>. Another useful common operator to know is the AND operator, <kbd>&amp;&amp;</kbd>, but this is not appropriate for this method. </p>&#13;
<p>This functionality feels more appropriate as a computed property since whether it <kbd>isProfessional</kbd> or not is intrinsic to the enum itself, and we don't need to do much work to determine the answer. So, let's change this into a property:</p>&#13;
<pre>enum Title: String { <br/>    case mr = "Mr" <br/>    case mrs = "Mrs" <br/>    case mister = "Master" <br/>    case miss = "Miss" <br/>    case dr = "Dr" <br/>    case prof = "Prof" <br/>    case other // Inferred as "other" <br/>     <br/>    var isProfessional: Bool { <br/>        return self == Title.dr || self == Title.prof <br/>    } <br/>} </pre>&#13;
<p class="mce-root">Now, we can determine whether a title is a professional title by accessing the computed property on it:</p>&#13;
<pre class="mce-root">let loganTitle = Title.mr<br/>let xavierTitle = Title.prof<br/>print(loganTitle.isProfessional) // false<br/>print(xavierTitle.isProfessional) // true</pre>&#13;
<p class="p1">We can't store any additional information on an enum, over and above the enum value itself, but being able to define methods and computed properties that provide extra information about the enum is a really powerful option.</p>&#13;
<h3 id="uuid-b684e1f0-a1d1-4b15-bda8-2449a85c92df">Associated values</h3>&#13;
<p>Our string-based enum seems perfect for our title information, except that we have a case called <kbd>other</kbd>. If the person has a title that we hadn't considered when defining the enum, we can choose <kbd>other</kbd>, but that doesn't capture what the other title is. In our model, we would need to define another property to hold the value given for <kbd>other</kbd>, but that splits our definition of title over two separate properties, which could cause an unintended combination of values.</p>&#13;
<p>Swift enums have a solution for this situation, <strong>associated values</strong>. We can choose to associate a value with each enum case, allowing us to bind a non-optional string to our <kbd>other</kbd> case.</p>&#13;
<p>Let's rewrite our <kbd>Title</kbd> enum to use an associated value:</p>&#13;
<pre>enum Title { <br/>    case mr <br/>    case mrs <br/>    case mister <br/>    case miss <br/>    case dr <br/>    case prof <br/>    case other(String) <br/>} </pre>&#13;
<p>We have defined the <kbd>other</kbd> case to have an associated value by putting the value's type in brackets after the case declaration. We do not need to add associated values for every case. Each case declaration can have associated values of different types or none at all.</p>&#13;
<p>Enums containing associated values cannot have a raw type as they are now too complex to be represented by one of these base types, so our <kbd>Title</kbd> enum is no longer string-based.</p>&#13;
<p>Now let's look at how we assign an enum case with an associated type:</p>&#13;
<pre>let mister: Title = .mr<br/>let dame: Title = .other("Dame")</pre>&#13;
<p>The associated value is declared in brackets after the case, and the compiler enforces that the type matches the type declared in our enum definition. As we declared the <kbd>other</kbd> case to have a non-optional string, we are ensuring that a title of <kbd>other</kbd> cannot be chosen without providing details of what the other title is, and we don't need another property to fully represent <kbd>Title</kbd> in our model.</p>&#13;
<h2 id="uuid-0d0d5576-2c9d-44fb-9f77-4164fc38ac23">See also</h2>&#13;
<p>Further information about enums can be found at <a href="http://swiftbook.link/docs/enums">http://swiftbook.link/docs/enums</a>.</p>&#13;
<h1 id="uuid-fa01a8ca-109c-493d-ae84-44a486029fcf">Passing around functionality with closures</h1>&#13;
<p><strong>Closures</strong> are also referred to as <strong>anonymous functions</strong>, and this is the best way to explain them. Closures are functions without a name and, like other functions, they can take a set of input parameters and can return an output. Closures behave like other primary types. They can be assigned, stored, passed around, and used as input and output to functions and other closures. </p>&#13;
<p>In this recipe, we will explore how and when to use closures in our code.</p>&#13;
<h2 id="uuid-a471216c-2158-4c5e-a9f3-bd0a775e51ac">Getting ready</h2>&#13;
<p>We will continue to build on our contacts app example from earlier in this chapter, so you should use the same playground as in the previous recipes.</p>&#13;
<p>If, however, you are implementing this in a new playground, first add the relevant code from the previous recipes:</p>&#13;
<pre>struct PersonName { <br/>    let givenName: String <br/>    let middleName: String <br/>    var familyName: String <br/>     <br/>    func fullName() -&gt; String { <br/>        return "\(givenName) \(middleName) \(familyName)" <br/>    } <br/>     <br/>    mutating func change(familyName: String) { <br/>        self.familyName = familyName <br/>    } <br/>} <br/><br/>class Person { <br/>     <br/>    let birthName: PersonName <br/>    var currentName: PersonName <br/>    var countryOfResidence: String <br/>     <br/>    init(name: PersonName, countryOfResidence: String = "UK") { <br/>        birthName = name <br/>        currentName = name <br/>        self.countryOfResidence = countryOfResidence <br/>    } <br/>     <br/>    var displayString: String { <br/>        return "\(currentName.fullName()) - Location: \<br/>          (countryOfResidence)" <br/>    } <br/>} </pre>&#13;
<p>For explanations of how this code works, please refer to the previous recipes in this chapter.</p>&#13;
<h2 id="uuid-4b2fd0d8-9f75-43de-af58-59b24c6e45f9">How to do it...</h2>&#13;
<p>Now, let's define a number of types of closures, which we will then work through step by step:</p>&#13;
<ol>&#13;
<li>Define a closure to print this author's details that takes no input and returns no output:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// No input, no output <br/>let printAuthorsDetails: () -&gt; Void = { <br/>    let name = PersonName(givenName: "Keith", <br/>                          middleName: "David", <br/>                          familyName: "Moon") <br/>    let author = Person(name: name) <br/>    print(author.displayString) <br/>} <br/>printAuthorsDetails() // "Keith David Moon - Location: UK" </pre>&#13;
<ol start="2">&#13;
<li>Define a closure that creates a <kbd>Person</kbd> object. The closure takes no input, but returns a <kbd>Person</kbd> object as the output:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// No input, Person output <br/>let createAuthor: () -&gt; Person = { <br/>    let name = PersonName(givenName: "Keith", <br/>                          middleName: "David", <br/>                          familyName: "Moon") <br/>    let author = Person(name: name) <br/>    return author <br/>} <br/>let author = createAuthor() <br/>print(author.displayString) // "Keith David Moon - Location: UK" </pre>&#13;
<ol start="3">&#13;
<li>Define a closure that prints a person's details, taking the three components of their name as <kbd>String</kbd> inputs, but returning no output:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// String inputs, no output <br/>let printPersonsDetails: (String, String, String) -&gt; Void = { given, <br/>  middle, family in <br/>    let name = PersonName(givenName: given, <br/>                          middleName: middle, <br/>                          familyName: family) <br/>    let author = Person(name: name) <br/>    print(author.displayString) <br/>} <br/>printPersonsDetails("Kathleen", "Mary", "Moon") <br/>// "Kathleen Mary Moon - Location: UK" </pre>&#13;
<ol start="4">&#13;
<li>Lastly, define a closure to create a person, taking the three name components as string inputs and returning a <kbd>Person</kbd> object as the output:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">// String inputs, Person output <br/>let createPerson: (String, String, String) -&gt; Person = { given, <br/>  middle, family in <br/>    let name = PersonName(givenName: given, <br/>                          middleName: middle, <br/>                          familyName: family) <br/>    let person = Person(name: name) <br/>    return person <br/>} <br/>let felix = createPerson("Felix", "Robert", "Moon") <br/>print(felix.displayString) // "Felix Robert Moon - Location: UK"</pre>&#13;
<h2 id="uuid-4f179d4a-5929-4b6a-8e3d-71100ab97d16">How it works...</h2>&#13;
<p>Let's take a look at the different types of closures we just implemented:</p>&#13;
<pre>// No input, no output <br/>let printAuthorsDetails: () -&gt; Void = { <br/>    let name = PersonName(givenName: "Keith", middleName: "David", <br/>      familyName: "Moon") <br/>    let author = Person(name: name) <br/>    print(author.displayString) <br/>} </pre>&#13;
<p>As a first-class type in Swift, closures can be assigned to constants or variables, and constants and variables need a type. To define a closure's type, we need to specify the input parameter types and the output type, and for the closure in the preceding code, the type is <kbd>() -&gt; Void</kbd>. The <kbd>Void</kbd> type is another way of saying "nothing", so this closure takes no inputs and returns nothing, and the closure's functionality is defined within the curly brackets, as with other functions.</p>&#13;
<p>Now that we have this closure defined and assigned to the <kbd>printAuthorsDetails</kbd> constant, we can execute it like other functions, but with the variable name, instead of the function's name. With this closure, that will cause this author's details to be printed:</p>&#13;
<pre>printAuthorsDetails() // "Keith David Moon - Location: UK" </pre>&#13;
<p>The next closure type takes no input parameters, but returns a <kbd>Person</kbd> object, as you can see with the <kbd>() -&gt; Person</kbd> type definition:</p>&#13;
<pre>// No input, Person output <br/>let createAuthor: () -&gt; Person = { <br/>    let name = PersonName(givenName: "Keith", middleName: "David", <br/>      familyName: "Moon") <br/>    let author = Person(name: name) <br/>    return author <br/>} <br/>let author: Person = createAuthor() <br/>print(author.displayString) // "Keith David Moon - Location: UK" </pre>&#13;
<p>Since it has an output, the execution of the closure returns a value that can be assigned to a variable or constant. In the preceding code, we execute the <kbd>createAuthor</kbd> closure and assign the output to the <kbd>author</kbd> constant. Since we defined the closure type as <kbd>() -&gt; Person</kbd>, the compiler knows that the output type is a <kbd>Person</kbd>, and so the type of constant can be inferred. Since we don't need to declare it explicitly, let's remove the type declaration:</p>&#13;
<pre>let author = createAuthor() <br/>print(author.displayString) // "Keith David Moon - Location: UK"</pre>&#13;
<p>Next, let's take a look at a closure that takes input parameters:</p>&#13;
<pre>// String inputs, no output <br/>let printPersonsDetails: (String, String, String) -&gt; Void = { given, <br/>  middle, family in <br/>    let name = PersonName(givenName: given, middleName: middle, <br/>      familyName: family) <br/>    let author = Person(name: name) <br/>    print(author.displayString) <br/>} <br/>printPersonsDetails("Kathleen", "Mary", "Moon") // "Kathleen Mary Moon <br/>  - Location: UK" </pre>&#13;
<p>You will remember, from the recipe on functions, that we can define parameter labels, which determine how the parameters are referenced when the function is used, and parameter names, which define how the parameter is referenced from within the function. In closures, these are defined a bit differently:</p>&#13;
<ul>&#13;
<li>Parameter labels cannot be defined for closures, so, when calling a closure, the order and parameter type have to be used to determine what values should be provided as parameters:</li>&#13;
</ul>&#13;
<pre style="padding-left: 60px">(String, String, String) -&gt; Void </pre>&#13;
<ul>&#13;
<li>Parameter names are defined inside the curly brackets, followed by the <kbd>in</kbd> keyword:</li>&#13;
</ul>&#13;
<pre style="padding-left: 60px">given, middle, family in </pre>&#13;
<p>Putting it all together, we can define and execute a closure with inputs and an output, as follows:</p>&#13;
<pre>// String inputs, Person output <br/>let createPerson: (String, String, String) -&gt; Person = { given, middle, <br/>  family in <br/>    let name = PersonName(givenName: given, <br/>                          middleName: middle, <br/>                          familyName: family) <br/>    let person = Person(name: name) <br/>    return person <br/>} <br/>let felix = createPerson("Felix", "Robert", "Moon") <br/>print(felix.displayString) // "Felix Robert Moon - Location: UK"</pre>&#13;
<h2 id="uuid-7e5b2ec2-156c-4c50-9411-ecf898f9db3a">There's more...</h2>&#13;
<p>We've seen how we can store closures, but we can also use them as method parameters. This pattern can be really useful when we want to be notified when a long-running task is completed.</p>&#13;
<p>Let's imagine that we want to save the details of our <kbd>Person</kbd> object to a remote database, maybe for backup or use on other devices. We may want to be notified when this process has completed, so we execute some additional code, perhaps printing a completion message, or update some UI. While the actual saving implementation is outside the scope of this recipe, we can amend our <kbd>Person</kbd> class to allow this save functionality to be called, passing a closure to execute on completion.</p>&#13;
<p>Add a method to save to a remote database, taking in a completion "handler", and store it for subsequent execution:</p>&#13;
<pre>class Person { <br/>    //.... <br/>    var saveHandler: ((Bool) -&gt; Void)? <br/>     <br/>    func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>        saveHandler = handler <br/>        // Send person information to remove database <br/>        // Once remote save is complete, it calls saveComplete(Bool) <br/>        // We'll fake it for the moment, and assume the save is <br/>          // complete.<br/>        saveComplete(success: true)<br/>    } <br/>     <br/>    func saveComplete(success: Bool) { <br/>        saveHandler?(success) <br/>    } <br/>} </pre>&#13;
<p>We define an optional variable to hold on to the save handler during the long-running save operation. Our closure will take a <kbd>Bool</kbd> to indicate whether the save was a success:</p>&#13;
<pre>var saveHandler: ((Bool) -&gt; Void)? </pre>&#13;
<p>Let's now define a method to save our <kbd>Person</kbd> object, which takes a closure as a parameter:</p>&#13;
<pre>func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>    saveHandler = handler <br/>    // Send person information to remove database <br/>    // Once remote save is complete, it calls saveComplete(Bool)<br/>    // We'll fake it for the moment, and assume the save is complete.<br/>    saveComplete(success: true) <br/>}</pre>&#13;
<p>Our function stores the given closure in the variable and then starts the process to save to the remote database (the actual implementation of this is outside the scope of this recipe). This save process will call the <kbd>saveComplete</kbd> method when completed.</p>&#13;
<p>We added a modifier, <kbd>@escaping</kbd>, just before the closure type definition. This tells the compiler that, rather than using the closure within this method, we intend to store the closure and use it later. The closure will be <em>escaping</em> the scope of this method. This modifier is needed to prevent the compiler from doing certain optimizations that would be possible if the closure was <em>nonescaping</em>. It also helps users of this method understand whether the closure they provide will be executed immediately, or at a later time.</p>&#13;
<p>With the save operation complete, we can execute the <kbd>saveHandler</kbd> variable, passing in the <kbd>success</kbd> Boolean:</p>&#13;
<pre>func saveComplete(success: Bool) { <br/>    saveHandler?(success) <br/>} </pre>&#13;
<p>Since we stored the closure as an optional, we need to unwrap it by adding a <kbd>?</kbd> after the variable name. If <kbd>saveHandler</kbd> has a value, the closure will be executed; if it is <kbd>nil</kbd>, the expression is ignored.</p>&#13;
<p>Now that we have a function that takes a closure, let's see how we call it:</p>&#13;
<pre>let fox = createPerson("Fox", "Richard", "Moon") <br/>fox.saveToRemoteDatabase(handler: { success in <br/>    print("Saved finished. Successful: \(success)") <br/>}) </pre>&#13;
<p>Swift provides a more concise way to provide closures to functions. When a closure is the last (or only) parameter, Swift allows it to be provided as a <strong>trailing closure</strong>. This means the parameter name can be dropped and the closure can be specified after the parameter brackets. So, we can rewrite the preceding with the following, neater, syntax:</p>&#13;
<pre>let fox = createPerson("Fox", "Richard", "Moon") <br/>fox.saveToRemoteDatabase() { success in <br/>    print("Saved finished. Successful: \(success)") <br/>} </pre>&#13;
<h2 id="uuid-fadb09ed-c430-4af3-9c19-6b579105bafa">See also</h2>&#13;
<p>Further information about closures can be found at <a href="http://swiftbook.link/docs/closures">http://swiftbook.link/docs/closures</a>.</p>&#13;
<h1 id="uuid-9f2f6df0-bed1-4a09-943d-a02778b06d8f">Using protocols to define interfaces</h1>&#13;
<p><strong>Protocols</strong> are a way to describe the interface that a type provides. They can be thought of as a contract, defining how you can interact with instances of that type. Protocols are a great way to abstract the "what" something does from "how" it does it. As we will see in subsequent chapters, Swift adds functionalities to protocols, that make them even more useful and powerful than in many other programming languages.</p>&#13;
<h2 id="uuid-445b1db4-0adc-43e5-87a8-c3d5facfc5ce">Getting ready</h2>&#13;
<p>We will continue to build on examples from the previous recipes, but don't worry if you haven't followed these recipes yet as all the code you need is listed in the upcoming sections.</p>&#13;
<h2 id="uuid-803ee236-76c2-4778-86a1-ab58bc346be1">How to do it...</h2>&#13;
<p>In the last recipe, we added a method to our <kbd>Person</kbd> class that (given the full implementation) would save it to a remote database. This is a very useful functionality, and as we add more features to our app, there will likely be more types that we also want to save to a remote database:</p>&#13;
<ol>&#13;
<li>Create a protocol to define how we will interface with anything that can be saved in this way:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">protocol Saveable {<br/>      var saveNeeded: Bool { get set }<br/>      func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void)<br/>}</pre>&#13;
<ol start="2">&#13;
<li>Update our <kbd>Person</kbd> class so that it conforms to the <kbd>Saveable</kbd> protocol:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">class Person: Saveable { <br/>    //.... <br/>    var saveHandler: ((Bool) -&gt; Void)? <br/>    var saveNeeded: Bool = true  <br/>     <br/>    func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>         saveHandler = handler <br/>         // Send person information to remove database    <br/>         // Once remote save is complete, it calls <br/>           // saveComplete(Bool) <br/>         // We'll fake it for the moment, and assume the save is <br/>           // complete.<br/>         saveComplete(success: true)<br/>    } <br/>     <br/>    func saveComplete(success: Bool) { <br/>        saveHandler?(success) <br/>    } <br/>} </pre>&#13;
<h2 id="uuid-78448084-fd00-496c-92b5-25c60b7ea310">How it works...</h2>&#13;
<p>Protocols are defined with the <kbd>protocol</kbd> keyword, and the implementation is contained within curly brackets. As we have seen with other type definitions, it is conventional to begin a protocol name with a capital letter. It is also convention to name a protocol as either something that the type <strong>is</strong> or something that it <strong>does.</strong> In this protocol, we are declaring that any type of implementation is <strong>saveable.</strong></p>&#13;
<p>Types conforming to this protocol have two parts of the interface to implement. Let's look at the first:</p>&#13;
<pre>var saveNeeded: Bool { get set }</pre>&#13;
<p>The <kbd>Saveable</kbd> protocol declares that anything implementing it needs to have a variable called <kbd>saveNeeded</kbd>, which is a <kbd>Bool</kbd>. This property will indicate that the information held in the remote database is out of date and a save is needed. In addition to the usual property declaration, a protocol requires us to define whether the property can be accessed (<kbd>get</kbd>) and changed (<kbd>set</kbd>), which is added in curly brackets after the type declaration. Removing the set keywords makes it a read-only variable.</p>&#13;
<p>Defining a protocol property as read-only doesn't prevent an implementing type from allowing the property to be set, just that the setting of that property isn't defined in the interface.</p>&#13;
<p>&#13;
<p>The second part of our protocol definition is to describe the method we can call to save the information to the remote database:</p>&#13;
<pre>func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void)</pre>&#13;
<p>This <kbd>func</kbd> declaration is exactly the same as other function declarations we have seen. However, the implementation of this function, which would have been contained in curly brackets, is omitted. Any type conforming to this protocol must provide this function and its implementation.</p>&#13;
</p>&#13;
<p>Now that we have defined our protocol, we need to implement the <kbd>Saveable</kbd> protocol on our <kbd>Person</kbd> class that we have been using throughout this chapter:</p>&#13;
<pre>class Person: Saveable { <br/>    //.... <br/>    var saveHandler: ((Bool) -&gt; Void)? <br/>     <br/>    func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>        saveHandler = handler <br/>        // Send person information to remove database <br/>        // Once remote save is complete, it calls saveComplete(Bool) <br/>        // We'll fake it for the moment, and assume the save is <br/>          // complete.<br/>        saveComplete(success: true)<br/>    } <br/>     <br/>    func saveComplete(success: Bool) { <br/>        saveHandler?(success) <br/>    } <br/>} </pre>&#13;
<p>Conforming to a protocol looks similar to how a class inherits from another class, as we saw earlier in this chapter. The protocol name is added after the type name, separated by <kbd>:</kbd>. By adding this conformance, the compiler will complain that our <kbd>Person</kbd> object doesn't implement part of the protocol, as we haven't declared a <kbd>saveNeeded</kbd> property. So let's add that:</p>&#13;
<pre>class Person: Saveable { <br/>    //.... <br/>    var saveHandler: ((Bool) -&gt; Void)? <br/>    var saveNeeded: Bool = true  <br/>     <br/>    func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>         saveHandler = handler <br/>         // Send person information to remove database    <br/>         // Once remote save is complete, it calls saveComplete(Bool) <br/>         // We'll fake it for the moment, and assume the save is <br/>           // complete.<br/>         saveComplete(success: true)<br/>    } <br/>     <br/>    func saveComplete(success: Bool) { <br/>        saveHandler?(success) <br/>    } <br/>} </pre>&#13;
<p>We'll add a default value of <kbd>true</kbd> since when an instance of this object is created, it won't be in the remote database, and so it will need to be saved.</p>&#13;
<h2 id="uuid-f7f2f69e-5ba1-49f0-b0c4-6a225fa0ac19">There's more...</h2>&#13;
<p><strong>Protocol conformance</strong> can be applied to classes, structs, enums, and even other protocols. The benefit of a protocol is that it allows an instance to be stored and passed without needing to know how it's implemented under the hood. This provides many benefits, including testing using mock objects and changing implementations without changing how and where the implementations are used.</p>&#13;
<p>Let's add a feature to our app that lets us set a reminder for a contact's birthday, which we will also want to save to our remote database.</p>&#13;
<p>We can use protocol conformance to give our reminder the same, consistent, save functionality interface, even though a reminder may have a very different implementation for saving.</p>&#13;
<p>Let's create our <kbd>Reminder</kbd> object and have it conform to the <kbd>Saveable</kbd> protocol:</p>&#13;
<pre>class Reminder: Saveable { <br/>     <br/>    var dateOfReminder: String // There is a better way to store dates, <br/>      // but this suffice currently.  <br/>    var reminderDetail: String // eg. Ali's birthday <br/>     <br/>    init(date: String, detail: String) { <br/>        dateOfReminder = date <br/>        reminderDetail = detail <br/>    } <br/>    var saveHandler: ((Bool) -&gt; Void)? <br/>    var saveNeeded: Bool = true <br/>     <br/>    func saveToRemoteDatabase(handler: @escaping (Bool) -&gt; Void) { <br/>        saveHandler = handler <br/>        // Send reminder information to remove database <br/>        // Once remote save is complete, it calls <br/>          // saveComplete(success: Bool) <br/>        // We'll fake it for the moment, and assume the save is <br/>          // complete.<br/>        saveComplete(success: true)<br/>    } <br/>     <br/>    func saveComplete(success: Bool) { <br/>        saveHandler?(success) <br/>    } <br/>} </pre>&#13;
<p>Our <kbd>Reminder</kbd> object conforms to <kbd>Saveable</kbd> and implements all the requirements.</p>&#13;
<p>We now have two objects that represent very different things and have different functionalities, but they both implement <kbd>Saveable</kbd>, and therefore we can treat them in a common way.</p>&#13;
<p>To see this in action, let's create an object that will manage the saving of information in our app:</p>&#13;
<pre>class SaveManager { <br/>    func save(_ thingToSave: Saveable) { <br/>        thingToSave.saveToRemoteDatabase { success in <br/>            print("Saved! Success: \(success)") <br/>        } <br/>    } <br/>} <br/>let nick = createPerson("Nick", "Edward", "Moon") // This closure was <br/>  // covered in the previous recipe<br/>let birthdayReminder = Reminder(date: "12/06/2008", detail: "Nick's <br/>  Birthday")<br/>let saveManager = SaveManager()<br/>saveManager.save(nick) <br/>saveManager.save(birthdayReminder) </pre>&#13;
<p>In the preceding example, <kbd>SaveManager</kbd> doesn't know the underlying type that it is being passed, but it doesn't need to. It receives instances that conform to the <kbd>Saveable</kbd> protocol and therefore can use that interface to save each instance.</p>&#13;
<h2 id="uuid-102299f1-7d44-42a7-b672-b886dcbdd52f">See also</h2>&#13;
<p>Further information about protocols can be found at <a href="http://swiftbook.link/docs/protocols">http://swiftbook.link/docs/protocols</a>.</p>&#13;
&#13;
&#13;
            &#13;
&#13;
            &#13;
        &#13;
    </div></body></html>