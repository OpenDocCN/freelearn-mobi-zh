<html><head></head><body>
        

            
                <h1 class="header-title">Adding an Explosion and Creating a UI</h1>
            

            
                
<p>Congratulations on having made it so far! By now, you must be equipped with almost all of the basics needed for you to get started on your journey of game development. This chapter will serve as a finishing touch for our game, and we will complete our explosion part by adding an explosion to our game scene. Once we are done with that, we will create a simple UI for our game that will include displaying our score and distance on the screen. So, buckle up! You are about to finish the game we started. We will be learning the following in this chapter:</p>
<ul>
<li>Adding an explosion to our game</li>
<li>Creating a tutorial with instructions for the player</li>
<li>Displaying the score on the screen with our UI</li>
</ul>
<p>However, before we move on to our UI, let's first finish up with our explosion effect.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Adding an explosion to our game</h1>
            

            
                
<p>In <a href="f605aac3-7f23-4895-b920-90515cff2b48.xhtml"><em>Chapter 7</em></a>, <em>Adding Boundaries and Using Sprites to Create Explosions</em>, we have already created our <kbd>ExplosionEffect.java</kbd> class file. Now, we are left with just one task: to spawn our explosion on the screen. Now, just for reference, we will take a look at the image we will use for our explosion file:</p>
<div><img class="image-border" height="430" src="img/B05066_08_01.png" width="430"/></div>
<div><kbd>Explosion.png</kbd> file sprite sheet</div>
<p>Note that the last frame of our explosion has almost no image in it. This is because we are not going to destroy this object; we are simply going to spawn it and let it play its animation for now.</p>
<p>Let's proceed and get our explosion running on our game screen. Again, here we will break down our process into simple steps.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating variables</h1>
            

            
                
<p>As you should be aware by now, we will work on our <kbd>GameView.java</kbd> file to display our explosion. So, open up your <kbd>GameView.java</kbd> file. We will start by creating a few variables, as follows:</p>
<pre>
private ExplosionEffect explosionEffect;<br/>private long startReset;<br/>private boolean reset;<br/>private boolean started;
</pre>
<p>We created the <kbd>explosionEffect</kbd> variable to get a reference to our <kbd>ExplosionEffect</kbd> class and the other variables we have created in order to make our player reset after it collides. So, basically, what we will do is that once the player collides with a rock, an explosion animation will play and the player will get reset to the initial state.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Some optimizations and improvements</h1>
            

            
                
<p>We will do some optimizations to our game by shifting our <kbd>mainThread</kbd> after our surface has been created. So, we will remove <kbd>mainThread = new MainGameThread(getHolder(), this);</kbd> from our constructor and write it just above the place where we start running it in our <kbd>surfaceCreated()</kbd> method, as follows:</p>
<pre>
@Override<br/>public void surfaceCreated(SurfaceHolder holder){<br/><br/>    bgImg = new BackgroundImage(BitmapFactory.decodeResource<br/>    (getResources(), R.drawable.background_image));<br/>    playerCharacter = new PlayerCharacter(BitmapFactory.decodeResource<br/>    (getResources(),R.drawable.player_run),200,246,3);<br/>    rocks = new ArrayList&lt;Rock&gt;();<br/>    upperBoundary = new ArrayList&lt;UpperBoundary&gt;();<br/>    lowerBoundary = new ArrayList&lt;LowerBoundary&gt;();<br/><br/>    mainThread = new MainGameThread(getHolder(), this);<br/>    //we can safely start the game loop<br/>    mainThread.setRunning(true);<br/>    mainThread.start();<br/><br/>}
</pre>
<p>Looks neat! Now, we will also need to make a few improvements to our touch events because we will be resetting our game to its initial state if our player collides with a rock. So, we need to make sure that we can play only if our game is in a play mode or if a new game has been created or reset. So, we will modify our <kbd>onTouchEvent()</kbd> to look somewhat like this:</p>
<pre>
@Override<br/>public boolean onTouchEvent(MotionEvent event)<br/>{<br/><strong>    if(event.getAction() == MotionEvent.ACTION_DOWN) {</strong><br/><strong>        if(!playerCharacter.getPlaying() &amp;&amp; newGameCreated &amp;&amp; reset){</strong><br/><strong>            playerCharacter.setPlaying(true);</strong><br/><strong>            playerCharacter.setUp(true);</strong><br/><strong>        }</strong><br/><strong>        if(playerCharacter.getPlaying()){</strong><br/><strong>            if(!started)started = true;</strong><br/><strong>            reset = false;</strong><br/><strong>            playerCharacter.setUp(true);</strong><br/><strong>        }<br/></strong>        return true;<br/>    }<br/>}
</pre>
<p>Here, we are simply setting up a few parameters for getting more control over our player movement. As you can see from our first <kbd>if</kbd> block, if <kbd>getPlaying()</kbd>, <kbd>newGameCreated</kbd> , and <kbd>reset</kbd> return a <kbd>false</kbd> value, then we will <kbd>setPlaying</kbd> to <kbd>true</kbd> and <kbd>setUp</kbd> to <kbd>true</kbd>.</p>
<p>Also, if our <kbd>getPlaying()</kbd> is already <kbd>true</kbd>, then we will check whether the game has started; if not, we will set our <kbd>started</kbd> variable to <kbd>true</kbd>, <kbd>reset</kbd> to <kbd>false</kbd>, and <kbd>setUp()</kbd> to true.</p>
<p>Now, we are set with our new game, playing, and reset logic for playing the game. We handle our reset variables here, but we also have to handle them in the <kbd>newGame()</kbd> function that we created earlier. However, before we do that, let's reference our explosion effect and tell it exactly where and when to spawn.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Spawning our explosion</h1>
            

            
                
<p>We need our explosion to spawn after our player has collided with our rocks. Once our player collides with a rock, the game is over. So, all of that is handled in our <kbd>update()</kbd> function wherein we have already created an else block for our <kbd>newGame()</kbd> function to be called. Let's utilize that and write our logic to spawn an explosion. Our objective here is as follows:</p>
<ul>
<li>Spawn the explosion effect</li>
<li>Start a counter to wait for a certain time after a collision</li>
<li>Reset the game after a certain time</li>
</ul>
<p>Note here that the dimensions of our image are 500 x 500, so we will be splitting our image into equal parts for each of our frames, thereby giving us 25 parts, which are 100 x 100 in dimension. We will pass each into our constructor as width, height, and number of frames. If the dimensions of the image that you are using for your game are different, then you need to calculate your dimensions and then use the values as per your image size.</p>
<p>We will go to our <kbd>else</kbd> block of the <kbd>update()</kbd> function and modify our previously written code to look like this:</p>
<pre>
else {<br/>    playerCharacter.resetDYC();<br/>    if(!reset) {<br/>        newGameCreated = false;<br/>        startReset = System.nanoTime();<br/>        reset = true;<br/>        explosionEffect = new ExplosionEffect(BitmapFactory<br/>        .decodeResource(getResources(),R.drawable.explosion)<br/>        playerCharacter.getXC(),playerCharacter.getYC()<br/>        -30,<strong>100,100,25</strong>);<br/>    }<br/><br/>    //Code block after this part remains the same<br/>}
</pre>
<p>So, here we are resetting our player's <kbd>y</kbd> acceleration and spawning our explosion. Then, after waiting for a certain period of time, we call in the function to reset our game.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Drawing the explosion on the screen</h1>
            

            
                
<p>We still have to draw our explosion effect on the screen, and yes, you are right! We will do so in our <kbd>draw()</kbd> method. We also have to make sure that we draw our explosion only once, that is, at the start of the game, and so we will use our started variable to keep track of it:</p>
<pre>
if(started) {<br/>    explosionEffect.draw(canvas);<br/>}
</pre>
<p>We're all set with our draw logic as well. We're done with the entire logic for our explosion effect, and now your entire code for the <kbd>GameView.java</kbd> file should look somewhat like the following; all the changes done in this chapter are marked in bold:</p>
<pre>
//Package name and import statements remain same as previous chapter<br/>public class GameView extends SurfaceView implements SurfaceHolder.Callback<br/>{<br/>    //Same variables as defined earlier<br/><strong><br/>    private ExplosionEffect explosionEffect;</strong><br/><strong>    private long startReset;</strong><br/><strong>    private boolean reset;</strong><br/><strong>    private  boolean started;</strong><br/><br/>    private Random rnd = new Random();<br/>    //GameView constructor, SurfaceChanged and surfaceDestroyed methods <br/>    remain same<br/>    @Override<br/>    public void surfaceCreated(SurfaceHolder holder){<br/>        //bgImg, playerCharacter, rocks, upperBoundary and <br/>        lowerBoundary code same as before<br/><strong><br/>        mainThread = new MainGameThread(getHolder(), this);<br/></strong>        //main thread code after this as earlier<br/><br/>    }<br/>    @Override<br/>    public boolean onTouchEvent(MotionEvent event)<br/>    {<br/>        if(event.getAction() == MotionEvent.ACTION_DOWN) {<br/><strong>            if(!playerCharacter.getPlaying() <br/>            &amp;&amp; newGameCreated &amp;&amp; reset){</strong><br/><strong>                playerCharacter.setPlaying(true);</strong><br/><strong>                playerCharacter.setUp(true);</strong><br/><strong>            }</strong><br/><strong>            if(playerCharacter.getPlaying()){</strong><br/><strong>                if(!started)started = true;</strong><br/><strong>                reset = false;</strong><br/><strong>                playerCharacter.setUp(true);</strong><br/><strong>            }<br/></strong>            return true;<br/>        }<br/>        //MotionEvent.ACTION_UP code same as earlier<br/><br/>        return super.onTouchEvent(event);<br/>    }<br/><br/>    public void update()<br/>    {<br/>        if(playerCharacter.getPlaying()) {<br/>            //Same code as earlier<br/>        } else {<br/><strong>            playerCharacter.resetDYC();</strong><br/><strong>            if(!reset) {</strong><br/><strong>                newGameCreated = false;</strong><br/><strong>                startReset = System.nanoTime();</strong><br/><strong>                reset = true;</strong><br/><strong>                explosionEffect = new ExplosionEffect(BitmapFactory<br/>                .decodeResource(getResources(),R.drawable.explosion),<br/>                playerCharacter.getXC(),playerCharacter.getYC()<br/>                -30,100,100,25);</strong><br/><strong>            }</strong><br/><br/><strong>            explosionEffect.update();</strong><br/><strong>            long resetElapsed = (System.nanoTime()-startReset)/1000000;</strong><br/><br/><strong>            if(resetElapsed &gt; 2500 &amp;&amp; !newGameCreated) {</strong><br/><strong>                newGame();</strong><br/><strong>            }</strong><br/><br/><strong>            if(!newGameCreated) {</strong><br/><strong>                newGame();</strong><br/><strong>            }</strong><br/>        }<br/>    }<br/><br/>    //collision code remains same. no change<br/><br/>    @Override<br/>    public void draw(Canvas canvas)<br/>    {<br/>            //Same as till lower boundary and upper boundary code block<br/><strong>            if(started) {</strong><br/><strong>                explosionEffect.draw(canvas);</strong><br/><strong>            }</strong><br/><br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/><br/>    //No change in updateUpperBound, updateLowerBound and update method<br/>}
</pre>
<p>So, now you can test your explosion in the game by playing it on your device!:</p>
<div><img class="image-border" height="395" src="img/B05066_08_02.png" width="702"/></div>
<p>Our explosion effect in action</p>
<p>Kaboom! We're now done with our sprite explosion effect! Now, we will move on to the final part of this game-- the UI.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating the UI for our game</h1>
            

            
                
<p>If you are not familiar with the term the UI, you must be wondering what the heck is it? UI is an abbreviation for User Interface. To put simply, a UI can consist of all the information you need to display on your game screen or your onscreen controls. Common elements of a UI include the following:</p>
<ul>
<li>Text displayed on the screen</li>
<li>Buttons</li>
<li>Joystick pad</li>
<li>Tutorial instructions</li>
</ul>
<p>In this part of our chapter, we will learn how to display text on the screen. We will also instruct the player how to play the game. We will display the following on our screen:</p>
<ul>
<li>Distance ran</li>
<li>Best score</li>
<li>Instructions on how to play</li>
</ul>
<p>So, here we have to display the best score. However, we haven't created our best score variable yet. For this part, we will work entirely in our <kbd>GameView.java</kbd> file. So, let's define our best score variable in this class:</p>
<pre>
private int bestScore;
</pre>
<p>We're now ready to show our UI data on the screen. Our UI will be entirely based on the <kbd>draw()</kbd> function, and so we will define a method called as <kbd>drawText()</kbd>, which should be called from our <kbd>draw()</kbd> method in the class. So, before we actually call our <kbd>drawText()</kbd> method, let's write some code for it.</p>
<p>Before that, let's calculate our best score first. Now, obviously, our best score will be calculated after our first game is over, so we will put that logic into our <kbd>newGame()</kbd> function. The logic for this is fairly simple. If our current score is greater than the <kbd>bestScore</kbd> that is initialized to <kbd>0</kbd>, then our <kbd>bestScore</kbd> equals our current score that we get through <kbd>playerCharacter.getScore();</kbd> and that would be in our <kbd>newGame()</kbd> function:</p>
<pre>
if(playerCharacter.getScore() &gt; bestScore) {<br/>    bestScore = playerCharacter.getScore();<br/>}
</pre>
<p>Alright, that's sorted, and now we have our <kbd>bestScore</kbd> variable ready to hold our best score; our <kbd>newGame()</kbd> function would look like this:</p>
<pre>
public void newGame () {<br/>    //clear code and minBoundaryHeight, maxBoundaryHeight code same as <br/>    before<br/><strong>    if(playerCharacter.getScore() &gt; bestScore) { <br/>        bestScore = playerCharacter.getScore(); <br/>    }</strong> <br/>    //Rest of the code block after this is the same as previous<br/>}
</pre>
<p>We can now write our <kbd>drawText()</kbd> method. To do so, we will use the help of the <kbd>Paint</kbd> class in Android. The <kbd>Paint</kbd> class holds the information about style; color, and how to draw geometries, texts, and bitmaps. Using this class, we can define the color, size, and typeface of our text. Then using our canvas as a reference, we can draw text on our canvas. So let's display our current distance and best score on the screen:</p>
<pre>
public void drawText(Canvas canvas) {<br/>    Paint p = new Paint();<br/>    p.setColor(Color.BLACK);<br/>    p.setTextSize(30);<br/>    p.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD));<br/>    canvas.drawText("DISTANCE: "+<br/>    (playerCharacter.getScore()*3),10,HEIGHT-10,p);<br/>    canvas.drawText("BEST: "+ bestScore,WIDTH - 215,HEIGHT-10,p);<br/>}
</pre>
<p>Okay, that looks awesome, but hey, we're still left with one part: the tutorial. As soon as the game starts, we need to instruct the player how to play the game. So, we will add an <kbd>if</kbd> statement to control the visibility of our tutorial message. We will guide our player to <kbd>Tap To Start</kbd>, <kbd>Keep Pressed To Go Up</kbd>, and <kbd>Release To Go Down</kbd>:</p>
<pre>
if(!playerCharacter.getPlaying() &amp;&amp; newGameCreated &amp;&amp; reset) {<br/><br/>    Paint p1 = new Paint();<br/>    p1.setTextSize(40);<br/>    p1.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD));<br/>    canvas.drawText("TAP TO START",WIDTH/2-50,HEIGHT/2,p1);<br/><br/>    p1.setTextSize(20);<br/>    canvas.drawText("KEEP PRESSED TO GO UP",WIDTH/2 - <br/>    50,HEIGHT/2+20,p1);<br/>    canvas.drawText("RELEASE TO GO DOWN",WIDTH/2 - 50,HEIGHT/2+40,p1);<br/>}
</pre>
<p>Alright, we are done with our <kbd>drawText()</kbd> method, and in its entirety it would look like this:</p>
<pre>
public void drawText(Canvas canvas) {<br/>    Paint p = new Paint();<br/>    p.setColor(Color.BLACK);<br/>    p.setTextSize(30);<br/>    p.setTypeface(Typeface.create(Typeface.DEFAULT, Typeface.BOLD));<br/>    canvas.drawText("DISTANCE: "+<br/>    (playerCharacter.getScore()*3),10,HEIGHT-10,p);<br/>    canvas.drawText("BEST: "+ bestScore,WIDTH - 215,HEIGHT-10,p);<br/><br/>if(!playerCharacter.getPlaying() &amp;&amp; newGameCreated &amp;&amp; reset) {<br/><br/>        Paint p1 = new Paint();<br/>        p1.setTextSize(40);<br/>        p1.setTypeface(Typeface.create(Typeface.DEFAULT, <br/>        Typeface.BOLD));<br/>        canvas.drawText("TAP TO START",WIDTH/2-50,HEIGHT/2,p1);<br/><br/>        p1.setTextSize(20);<br/>        canvas.drawText("KEEP PRESSED TO GO UP",WIDTH/2 - <br/>        50,HEIGHT/2+20,p1);<br/>        canvas.drawText("RELEASE TO GO DOWN",WIDTH/2 - <br/>        50,HEIGHT/2+40,p1);<br/>    }<br/>}
</pre>
<p>Now, there's one last thing remaining to do. We need to call our <kbd>drawText()</kbd> method. Any guesses where we will do this? We will do so in our <kbd>draw()</kbd> method of our class; let's do it:</p>
<pre>
@Override<br/>public void draw(Canvas canvas)<br/>{<br/>    final float scaleFactorX = getWidth()/WIDTH;<br/>    final float scaleFactorY = getHeight()/HEIGHT;<br/>    if(canvas!=null) {<br/>        //No changes in code till if(started) statement<br/><br/>        if(started) {<br/>            explosionEffect.draw(canvas);<br/>        }<br/><strong><br/>        drawText(canvas);</strong><br/><br/>        canvas.restoreToCount(savedState);<br/>    }<br/>}
</pre>
<p>You are all set with your code for displaying the text components on our screen and now have a working game with a UI to display your tutorial message, distance covered, and best score on the screen.</p>
<p>Let's review our code changes that we did in this part of our chapter; code changes are marked in bold:</p>
<pre>
//package name and import statements remain the same as before<br/>public class GameView extends SurfaceView implements SurfaceHolder.Callback<br/>{<br/>    //no change in variable names<br/>    //GameView constructor. No change needed, write as is<br/>    //surfaceChanged method constant as before<br/>    //surfaceDestroyed method same as before<br/>    //surfaceCreated method same as before<br/><br/>    //onTouchEvent same as before<br/>    //collision method written as is<br/><br/>    @Override<br/>    public void draw(Canvas canvas)<br/>    {<br/>        final float scaleFactorX = getWidth()/WIDTH;<br/>        final float scaleFactorY = getHeight()/HEIGHT;<br/>        if(canvas!=null) {<br/>            final int savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/>            bgImg.draw(canvas);<br/>            playerCharacter.draw(canvas);<br/><br/>            for(Rock r : rocks) {<br/>                r.draw(canvas);<br/>            }<br/><br/>            for(UpperBoundary ub : upperBoundary){<br/>                ub.draw(canvas);<br/>            }<br/><br/>            for(LowerBoundary lb: lowerBoundary) {<br/>                lb.draw(canvas);<br/>            }<br/><br/>            if(started) {<br/>                explosionEffect.draw(canvas);<br/>            }<br/><strong><br/>            drawText(canvas);</strong><br/><br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/>    //updateUpperBound code remains same<br/>    //updateLowerBound code remains same<br/><br/>    public void newGame () {<br/>        lowerBoundary.clear();<br/>        upperBoundary.clear();<br/>        rocks.clear();<br/><br/>        minBoundaryHeight = 5;<br/>        maxBoundaryHeight = 30;<br/><strong><br/>        if(playerCharacter.getScore() &gt; bestScore) {</strong> <strong> <br/>             bestScore = playerCharacter.getScore();</strong> <strong> <br/>        }<br/></strong><br/>        playerCharacter.resetScore();<br/>        playerCharacter.resetDYC();<br/>        playerCharacter.setYC(HEIGHT/2);<br/><br/><br/>        for(int i=0; i*20&lt;WIDTH+40;i++) {<br/>            if(i==0) {<br/>                upperBoundary.add(new UpperBoundary<br/>                (BitmapFactory.decodeResource(getResources(),<br/>                R.drawable.ground),i*20,0,10));<br/>            } else {<br/>                upperBoundary.add(new UpperBoundary<br/>                (BitmapFactory.decodeResource(getResources(),<br/>                R.drawable.ground),i*20,0,<br/>                upperBoundary.get(i-1).getHeight()+1));<br/>            }<br/>        }<br/><br/>        for(int i = 0; i*20&lt;WIDTH+40;i++) {<br/>            if(i==0) {<br/>                lowerBoundary.add(new LowerBoundary<br/>                (BitmapFactory.decodeResource(getResources(),<br/>                R.drawable.ground),i*20, HEIGHT-minBoundaryHeight));<br/>            } else {<br/>                lowerBoundary.add(new LowerBoundary<br/>                (BitmapFactory.decodeResource<br/>                (getResources(),R.drawable.ground),<br/>                i*20, lowerBoundary.get(i-1).getYC()-1));<br/>            }<br/>        }<br/>        newGameCreated = true;<br/>    }<br/><br/><strong>public void drawText(Canvas canvas) {</strong><br/><strong>        Paint p = new Paint();</strong><br/><strong>        p.setColor(Color.BLACK);</strong><br/><strong>        p.setTextSize(30);</strong><br/><strong>        p.setTypeface(Typeface.create(Typeface.DEFAULT, <br/>        Typeface.BOLD));</strong><br/><strong>        canvas.drawText("DISTANCE: "+<br/>        (playerCharacter.getScore()*3),10,HEIGHT-10,p);</strong><br/><strong>        canvas.drawText("BEST: "+ bestScore,WIDTH - 215,HEIGHT-10,p);</strong><br/><br/><strong>        if(!playerCharacter.getPlaying() &amp;&amp; newGameCreated &amp;&amp; reset) {</strong><br/><br/><strong>            Paint p1 = new Paint();</strong><br/><strong>            p1.setTextSize(40);</strong><br/><strong>            p1.setTypeface(Typeface.create(Typeface.DEFAULT, <br/></strong><strong>            Typeface.BOLD));</strong><br/><strong>            canvas.drawText("TAP TO START",WIDTH/2-50,HEIGHT/2,p1);</strong><br/><br/><strong>            p1.setTextSize(20);</strong><br/><strong>            canvas.drawText("KEEP PRESSED TO GO UP",WIDTH/2 - <br/>            50,HEIGHT/2+20,p1);</strong><br/><strong>            canvas.drawText("RELEASE TO GO DOWN",WIDTH/2 - <br/>            50,HEIGHT/2+40,p1);</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><br/>}
</pre>
<p>If you have completed all these steps, then you can go ahead and test your game on your device or emulator now. You will get an output like this:</p>
<div><img class="image-border" height="292" src="img/B05066_08_03.png" width="519"/></div>
<p>Tutorial displaying our message</p>
<p>We can also see our score in the game while playing:</p>
<div><img class="image-border" height="288" src="img/B05066_08_04.png" width="512"/></div>
<p>Distance covered and best score updating as we play</p>
<p>So, here we wrap up our 2D game. Now, based on your understanding of the previous chapters, you can add in elements to this game such as coins, more obstacles, and anything that you can imagine. It is recommended by now that you customize this game as much as possible according to your understanding, or alternatively, you can also start creating a new game altogether.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>We created our explosion and displayed our tutorial message, distance covered, and best score on the screen.</p>
<p>We learned how to create texts on the screen that helped us to display our score, and finally implemented our explosion logic to make the explosion appear on the screen after colliding with rocks. This is it for our 3D game. After this, you can build your game, test it on your device, or even tweak it further to add in more obstacles or make it as interesting as you want. You are only restricted by your imagination.</p>
<p>With this, we wrap up our 2D game, and we will take a look at how to make a shift into the 3D world in our next chapter. </p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>