- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with .NET MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the release of .NET 5, Microsoft has been trying to unify different .NET
    implementations into one .NET release. .NET Multi-platform App UI (or .NET MAUI)
    is the effort to provide a unified cross-platform UI framework. We will learn
    how to use .NET MAUI to develop cross-platform applications in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what we will cover in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Overview of cross-platform technologies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comparison of cross-platform technologies (.NET, Java, and JavaScript)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET landscape and the history of Xamarin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI Blazor apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What’s new in .NET 8 for .NET MAUI?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Development environment setup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you’re new to .NET development, this chapter will help you to understand
    the .NET landscape. For Xamarin developers, many topics in this book may sound
    familiar; this chapter will give you an overview of what we will discuss in this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of cross-platform and full stack technologies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Multi-platform App UI, or .NET MAUI, is a cross-platform development framework
    from Microsoft for building apps that targets both mobile and desktop form factors
    on Android, iOS, macOS, Windows, and Tizen. It is one of a number of cross-platform
    frameworks available on the market.
  prefs: []
  type: TYPE_NORMAL
- en: Before discussing cross-platform technologies, let’s review the scope of application
    development first. This review will help us to understand the various cross-platform
    frameworks better.
  prefs: []
  type: TYPE_NORMAL
- en: Generally, software development can be divided into two categories – **systems
    programming** and **application programming**. Application programming aims to
    produce software that provides services to the user directly, whereas systems
    programming aims to produce software and software platforms that provide services
    to other software. In the .NET domain, the development of the .NET platform itself
    belongs to systems programming, whereas application development on top of the
    .NET platform belongs to application programming.
  prefs: []
  type: TYPE_NORMAL
- en: Compared to systems programming, most software development demands are from
    application programming.
  prefs: []
  type: TYPE_NORMAL
- en: Many business solutions fall under the category of application development.
    To understand why we choose a specific technology stack for a solution, it is
    essential to have an overview of all the technologies used in the entire solution.
    Once we have a clear understanding of the role cross-platform technologies play
    within the entire solution, we can better comprehend the technology we wish to
    select.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the development effort for business solutions consists of frontend and
    backend components. Frontend developers are responsible for the visible and interactive
    part of an application that users directly see, touch, and interact with. Typically,
    the frontend team focuses on developing web and native applications. On the other
    hand, backend development deals with server-side processing, data management,
    and the implementation of business logic within an application.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend and backend development involve different programming languages and
    frameworks. Sometimes, the same team may work on both frontend and backend development
    due to various reasons. In this case, we need a team who can work on full stack
    development.
  prefs: []
  type: TYPE_NORMAL
- en: To classify application development by programming languages and frameworks,
    we have the below three categories.
  prefs: []
  type: TYPE_NORMAL
- en: Native application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By native application development, we usually refer to application development
    for a particular operating system. For desktop applications, it could involve
    Windows applications, macOS applications, or Linux applications. For mobile applications,
    it could involve Android or iOS.
  prefs: []
  type: TYPE_NORMAL
- en: When we develop a native application, we may need to support multiple platforms
    (Windows, Linux, Android, macOS/iOS, etc.). To support multiple platforms, we
    need to use different programming languages, tools, and libraries to develop each
    of them individually.
  prefs: []
  type: TYPE_NORMAL
- en: Web application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web application development has gone through several generations of evolution
    over the past few decades, from the Netscape browser with static web pages to
    today’s **single-page application (SPA)** using JavaScript frameworks (such as
    React and Angular). In web application development, JavaScript and various JavaScript-based
    frameworks dominate the market. In the .NET ecosystem, Blazor is trying to catch
    up in this area. We’ll learn more about Blazor in Chapter 8, *Introducing Blazor
    Hybrid App Development.*
  prefs: []
  type: TYPE_NORMAL
- en: Backend services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both native applications and web applications typically require backend services
    to access business logic or a database. For backend development, there are various
    languages and frameworks available, including Java/Spring, .NET, Node.js, Ruby
    on Rails, and Python/Django. In many cases, native applications and web applications
    can share the same backend service. Java/Spring, ASP.NET, and Node.js are among
    the most popular choices for backend service developments.
  prefs: []
  type: TYPE_NORMAL
- en: The selection of the technical stack for each category can significantly impact
    the complexity of a solution. In the next section, we will review and analyze
    solution complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Managing development complexity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Building a complete solution usually requires a web app, a native app, and a
    backend service. Since web, native, and backend development use different programming
    languages and frameworks, we have to set up multiple teams to implement one solution.
    To manage the complexity of the development process, we need to manage the profile
    of the development team. The team profile can be managed according to two extreme
    cases/approaches. The simplest one is to set up one team that works on all stacks.
    The more complex one is to have separate teams for each stack. To successfully
    develop for all stacks using one team, the team must be a cross-platform full
    stack development team. Is it possible to have a cross-platform full stack team?
    Let’s review various scenarios for this in the next two sections.
  prefs: []
  type: TYPE_NORMAL
- en: Full stack development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Many people doubt whether it is good, or even possible, to set up a full stack
    team, but in fact, the earliest web development frameworks were full stack frameworks.
    If you had a chance to use Java/Thymeleaf or ASP.NET MVC, you will know that they
    are full stack frameworks. These frameworks use server-side rendering, so the
    implementation of the UI and business logic are all on the server side.
  prefs: []
  type: TYPE_NORMAL
- en: The separation of frontend and backend came with the emergence of SPAs. To move
    the UI to the client side, SPA frameworks, such as React, Angular, and Vue.js,
    are used to implement the client-side logic. Backend services are implemented
    using frameworks such as Java/Spring and ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: SPA frameworks use **client-side rendering** (**CSR**), while Java/Thymeleaf
    and ASP.NET MVC use **server-side rendering** (**SSR**). Both CSR and SSR have
    their pros and cons. In modern application development, both CSR and SSR are used
    by frameworks, as in Next.js and Nuxt.js. In .NET 8, Microsoft introduced server-side
    Blazor component rendering, or Blazor United. With this feature, the boundary
    between frontend and backend in ASP.NET has blurred again.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, we should choose technology stacks based on business requirements,
    so there is not a single, catch-all answer as to whether we should go with full
    stack development or not.
  prefs: []
  type: TYPE_NORMAL
- en: For end users, SPAs are very similar to native applications, and some SPA frameworks
    have even evolved into cross-platform frameworks, such as React Native. With React
    and React Native, it is possible to have one team working on both frontend development
    and native application development. Furthermore, if a JavaScript-based backend
    framework is chosen, it is possible to set up one cross-platform full stack team
    to implement the entire solution.
  prefs: []
  type: TYPE_NORMAL
- en: To understand cross-platform frameworks better, let us analyze the cross-platform
    frameworks currently available on the market in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cross-platform frameworks are alternative solutions to native application development.
    Native application development refers to using the programming language and **software
    development kit** (**SDK**) provided by the operating system. In native application
    development, we use native development tools, such as Swift/UIKit for iOS, Java/Kotlin
    for Android, and C#/WinUI for Windows. Ideally, we should use the tools provided
    by the operating system vendor to develop applications for a given operating system.
    With native application development, we don’t have performance or compatibility
    issues in our apps. With cross-platform development frameworks, there will always
    be certain corner cases that cannot be resolved using cross-platform APIs alone.
    Regardless of whether you are a .NET MAUI, React Native, or Flutter developer,
    it is necessary to acquire a certain level of native programming knowledge to
    address these specific cases. For instance, I am currently waiting for the ZXing.Net.Maui
    project to be ready to support QR code functionality in my application.
  prefs: []
  type: TYPE_NORMAL
- en: However, we usually need to develop our application for multiple operating systems.
    Native application development incurs much higher costs than cross-platform frameworks.
    We must strike a balance between budget, time, and quality in a project. Again,
    we need to choose a solution based on the business requirements. This might mean
    we need to choose a cross-platform framework.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular cross-platform frameworks on the market include Flutter, React
    Native, .NET MAUI/Xamarin, Ionic, and Apache Cordova.
  prefs: []
  type: TYPE_NORMAL
- en: Gaining an understanding of various cross-platform technologies can greatly
    benefit .NET MAUI developers in making informed decisions when selecting their
    technology stack. It’s important to note that, currently, there isn’t a single
    cross-platform technology that can fulfill all requirements. As a result, we still
    come across new projects utilizing Ionic in business solutions.
  prefs: []
  type: TYPE_NORMAL
- en: In these frameworks, besides Flutter and .NET MAUI, React Native, Ionic, and
    Apache Cordova are JavaScript-based frameworks that originated from web development.
  prefs: []
  type: TYPE_NORMAL
- en: Apache Cordova
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Apache Cordova is a hybrid framework that can be used to build mobile apps using
    web technologies such as HTML, CSS, and JavaScript. Cordova runs inside WebView,
    which provides a runtime environment to access device features. Cordova uses the
    same technologies as web apps, so Cordova can reuse the source code of web apps.
    Using a hybrid framework, the frontend team can work on both web and mobile applications.
  prefs: []
  type: TYPE_NORMAL
- en: The problem with hybrid frameworks is that the user interface for mobile is
    more similar to that of web apps than that of native apps, since the UI is created
    using web technology. Another concern is that the performance of hybrid apps is
    dependent on WebView’s performance on the specific platform. Users may have different
    experiences on iOS and Android platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Cordova is a hybrid framework that uses JavaScript, HTML, and CSS, but it doesn’t
    provide a way to use modern JavaScript frameworks, such as React, Vue.js, and
    Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Ionic
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ionic is a framework that was initially built on top of Apache Cordova. Another
    low-level framework called Capacitor can also be used in the more recent versions.
    Ionic can integrate with popular JavaScript frameworks such as React, Vue.js,
    and Angular, which means productivity can be improved significantly. Ionic also
    includes UI controls to support interactions, gestures, and animations.
  prefs: []
  type: TYPE_NORMAL
- en: Since Ionic is built using hybrid frameworks such as Cordova and Capacitor,
    the performance is similar to that of the underlying frameworks. However, Ionic
    includes optimizations for animations and transitions to deliver native-like performance
    for built-in libraries.
  prefs: []
  type: TYPE_NORMAL
- en: React Native
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: React Native is another framework that originated from a web development framework.
    Since React Native uses React and JavaScript to develop mobile apps, React developers
    can pick up React Native with very little effort. A cross-platform team can work
    on both web and mobile apps using React and React Native.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike hybrid frameworks, React Native uses a bridge to translate JavaScript
    UIs into native ones. React Native apps have the same look and feel as native
    apps. Since React Native uses native components for rendering UIs on iOS and Android
    instead of WebView, it can achieve better performance than hybrid apps. A downside
    of React Native using native components is that we cannot share UI design and
    UI code between React and React Native. The paradigm is, “Learn once, write anywhere,”
    instead of, “Write once, run anywhere.”
  prefs: []
  type: TYPE_NORMAL
- en: Since React Native uses a bridge in its architecture, it may have slower performance
    than Flutter or .NET MAUI. In newer React Native releases, this may be improved
    by the new architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Flutter is an open-source UI toolkit developed by Google using the programming
    language Dart. Using Dart, Flutter supports **just-in-time** (**JIT**) and **ahead-of-time**
    (**AOT**) compilation and also has powerful performance optimization tools. Flutter
    apps can achieve near-native app performance.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter employs a distinct rendering technology in comparison to hybrid apps
    and React Native. It uses an internal graphics engine called Skia (or Impeller,
    in the preview) to convert a hierarchy of widgets into the actual pixels on the
    screen. Flutter apps have the same look and feel on different devices without
    specific customization.
  prefs: []
  type: TYPE_NORMAL
- en: To simulate the look and feel of different platforms, Flutter has two different
    UI libraries for iOS and Android. Cupertino widgets are used for iOS and Material
    widgets for Android.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: .NET MAUI is a successor of Xamarin.Forms, which is a part of the larger Xamarin
    platform. Xamarin itself provides native UI controls as part of the .NET runtime
    environment on iOS, macOS, and Android. You can develop native applications using
    C# and Xamarin. On Windows, since .NET is the original framework, .NET is supported
    by default.
  prefs: []
  type: TYPE_NORMAL
- en: From .NET 6 or above, you have a full .NET runtime available on these four platforms.
    .NET MAUI is only one of the .NET cross-platform frameworks that uses Xamarin.
    There are other .NET cross-platform frameworks that use Xamarin, and some of them
    can support more operating systems than .NET MAUI, such as Uno Platform, Avalonia
    UI, and Blazor Hybrid.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter, React Native, and Cordova/Ionic represent three different types of
    cross-platform framework implementations. In the .NET world, we can find .NET
    cross-platform implementations that can match all these three categories.
  prefs: []
  type: TYPE_NORMAL
- en: Cordova, or Ionic, is a hybrid framework that uses web technology JavaScript,
    HTML, and CSS to develop mobile applications that run inside WebView. In .NET,
    Blazor is a web technology that uses C#, HTML, and CSS to develop web applications.
    The hybrid solution in .NET is Blazor Hybrid. BlazorWebView is used to host Blazor
    Hybrid applications on different platforms. Currently, BlazorWebView is available
    for .NET MAUI, WFP, and Windows Forms. We can use BlazorWebView to develop hybrid
    applications on these three frameworks. It is like Cordova and Ionic in that the
    look and feel of Blazor Hybrid applications is the same as that of web applications.
    It is possible to reuse code between Blazor Hybrid and Blazor applications.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter uses a rendering technology based on Skia’s 2D engine or Impeller. In
    .NET, Avalonia UI uses a similar approach that builds UI controls using Skia’s
    2D engine.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI uses native components as UI controls, such as React Native, so the
    .NET MAUI UI looks the same as native applications.
  prefs: []
  type: TYPE_NORMAL
- en: For a summary and comparison of the different frameworks, see *Table 1.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cross-Platform Frameworks****(Languages)** | **UI Feature** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI(XAML/C#) | React Native(HTML/CSS/JavaScript) | Native UI |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Hybrid(HTML/CSS/C#) | Ionic/Cordova(HTML/CSS/JavaScript) | Web UI
    |'
  prefs: []
  type: TYPE_TB
- en: '| Avalonia UI(XAML/C#) | Flutter(Dart) | Custom UI using 2D engine (Skia) |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.1: Comparison of cross-platform frameworks'
  prefs: []
  type: TYPE_NORMAL
- en: Besides Flutter, we can see that cross-platform frameworks use either JavaScript
    or .NET. It is possible to set up a cross-platform full stack team to work on
    the entire solution using either JavaScript or .NET technologies. Let’s review
    the complexity level of cross-platform full stack solutions in the next section
    by comparing different combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Analysis of cross-platform full stack solutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have analyzed cross-platform and full stack frameworks, we can see
    that we are able to use just one programming language, either JavaScript or C#,
    to build the entire technical stack for a solution.
  prefs: []
  type: TYPE_NORMAL
- en: '*Table 1.2* is a summary of cross-platform full stack frameworks that use JavaScript
    or .NET.'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Layers** | **Frameworks** |'
  prefs: []
  type: TYPE_TB
- en: '| JavaScript | C#/.NET |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/1.png) Web Application | React, Angular or Vue.js, etc. | Blazor
    |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/2.png) Mobile Application | Cordova or Ionic | Blazor Hybrid |'
  prefs: []
  type: TYPE_TB
- en: '| React Native | .NET MAUI |'
  prefs: []
  type: TYPE_TB
- en: '| ![](img/3.png) Backend Services | Node.js/Nest.js/Koa/Express.js | ASP.NET
    Core |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.2: Comparison of JavaScript and .NET cross-platform full stack technical
    stacks'
  prefs: []
  type: TYPE_NORMAL
- en: To build a solution using JavaScript, we can develop a web client using JavaScript
    frameworks, such as React, Angular, and Vue.js. If cost and time to market are
    major considerations, we will want to reuse code between web and mobile as much
    as possible. In that case, we can choose hybrid frameworks, such as Ionic and
    Cordova. If performance and user experience are more important to the business,
    React Native can be a good choice for mobile development. For backend services,
    there are plenty of JavaScript-based backend frameworks, such as Nest.js, Koa,
    and Express.js. We can choose pure JavaScript frameworks for all layers in the
    solution.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET, we have very similar choices to those we have in JavaScript. If choosing
    a pure .NET technical stack for a solution, Blazor can be used for web client
    development. We also have the option to choose between hybrid and native frameworks.
    If considering cost and time to market, we can choose Blazor Hybrid so that web
    and mobile development can be treated as one development task. To have a native
    user experience and better performance, we can choose .NET MAUI for mobile development.
    In backend development, ASP.NET Core already has a large market share and is a
    popular framework.
  prefs: []
  type: TYPE_NORMAL
- en: Using frameworks with one programming language is the most economical choice,
    as we saw in *Table 1.1* and *Table 1.2*. However, in real projects, we may have
    to consider many factors. Our actual solution can be a combination of different
    languages and frameworks. Let’s review the complexity level of different combinations
    in *Table 1.3*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Cost Time to Market** | **![](img/11.png)** | **Performance User Experience**
    | **Complexity Level** | **Technical Stacks in a Solution** |'
  prefs: []
  type: TYPE_TB
- en: '| **Mobile** | **Web** | **Backend** |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | Blazor Hybrid | Blazor | ASP.NET |'
  prefs: []
  type: TYPE_TB
- en: '| Ionic/Cordova | JavaScript | Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | .NET MAUI | Blazor | ASP.NET |'
  prefs: []
  type: TYPE_TB
- en: '| React Native | ReactJS | Node.js |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | React Native | ReactJS | Java/ASP.NET/… |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | Flutter | JavaScript | Java/ASP.NET/… |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | Android/iOS/macOS/Windows/… | JavaScript | Java/ASP.NET/… |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.3: Complexity levels for cross-platform full stack solutions'
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 1.3*, I have summarized the different levels of complexity for different
    technology choices in each layer of a solution.
  prefs: []
  type: TYPE_NORMAL
- en: The complexity of your solution is determined by how many programming languages
    and frameworks are involved. The more languages and frameworks are involved, the
    greater the time to market and cost.
  prefs: []
  type: TYPE_NORMAL
- en: We have more choices with cross-platform and backend frameworks than we do with
    the frontend. In terms of programming languages, we can choose either JavaScript
    or C# to develop web clients. For this reason, the most economical choice to make
    for a backend framework is to select either a JavaScript- or C#-based backend
    framework. This is what we can see at complexity levels 1 and 2 in *Table 1.3*.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose a hybrid framework, such as Ionic or Blazor Hybrid, to develop
    mobile apps, we can use one language and framework to cover all frontend and mobile
    development. In this case, if we also choose a backend framework in the same language,
    the time required and cost for this profile is minimal compared to all other profiles.
    As we can see in *Table 1.3*, we have JavaScript and .NET options at complexity
    level 1.
  prefs: []
  type: TYPE_NORMAL
- en: The most economical option may not be the best one for the product owner, since
    the product owner may have concerns about the user experience and performance
    of the solution. In terms of frontend and backend frameworks, .NET and JavaScript
    frameworks are mature and proven solutions. The real concern when thinking about
    solution performance, however, should be to do with hybrid frameworks. We can
    choose either .NET MAUI or React Native for mobile development. When using React
    Native, the most economical option is to use React as the frontend framework.
    In this way, we can still use one language and similar frameworks to cover both
    mobile and web development. There are many commercial solutions that go with this
    option. Since we won’t be able to share UI code between .NET MAUI and Blazor or
    React and React Native, this category is a complexity level 2 option.
  prefs: []
  type: TYPE_NORMAL
- en: In backend development, there are too many options available in terms of languages
    and frameworks, and many of them are proven solutions. There is a very long list
    of languages that can be used in backend development, such as Java, C#, JavaScript,
    Python, Ruby, Go, and Rust. For whatever reason, we may not be able to choose
    the same backend programming language as the one we use for mobile and web development.
    This means a complexity level 3 solution. In this situation, the project team
    can reduce the complexity by choosing React and React Native together with a backend
    framework. In a real project, .NET MAUI and Blazor usually go with a .NET backend.
    We don’t see many cases of .NET MAUI or Blazor being used with a non-.NET backend
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: Flutter and React Native are the two most popular cross-platform frameworks
    in the market. .NET MAUI still needs more time to catch up with the market. If
    using Flutter, we go to complexity level 4\. In this case, we have to involve
    three programming languages in the solution profile.
  prefs: []
  type: TYPE_NORMAL
- en: In some large projects, the user experience is a more important consideration
    than other factors. In such cases, we go with native application development.
    The number of languages and frameworks involved increases significantly, since
    every operating system added to the list adds one more programming language to
    the profile. This is the most complex case, at complexity level 5.
  prefs: []
  type: TYPE_NORMAL
- en: Comparison of .NET and JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is no single best choice of cross-platform tool or framework. The final
    choice is usually decided according to the specific business requirements. However,
    from the above table, we can see that the .NET ecosystem provides a full spectrum
    of tools for your requirements. The development team of a large system usually
    requires people with experience in different programming languages and frameworks.
    With .NET, the complexity of programming languages and frameworks can be dramatically
    simplified.
  prefs: []
  type: TYPE_NORMAL
- en: We had an overview of tools and frameworks used in web app, native app, and
    backend service development. If we look at a higher level, that is, the .NET ecosystem
    level, the ecosystem of JavaScript almost matches what we have in a .NET solution.
    JavaScript and .NET solutions can provide tools or frameworks at nearly all layers.
    It would be interesting to do a comparison of JavaScript and .NET at a higher
    level.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript is a language created for web browsers, but its capability is extended
    due to the demands of web development. The limitation of JavaScript is that it
    is a scripting language, so it lacks the language features that can be found in
    C#. However, this limitation doesn’t limit its usage and popularity. *Table 1.4*
    is a comparison of two technologies:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Area of Comparison** | **.NET** | **JavaScript** |'
  prefs: []
  type: TYPE_TB
- en: '| Programming languages | C#, F#, VB, C++ | JavaScript, TypeScript, CoffeeScript,
    etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Runtime | CLR | V8/ SpiderMonkey/ JavaScriptCore |'
  prefs: []
  type: TYPE_TB
- en: '| Supported IDE | Microsoft Visual Studio, Rider, MonoDevelop, Visual Studio
    Code | Visual Studio Code, Webstorm, Atom |'
  prefs: []
  type: TYPE_TB
- en: '| Web | ASP.NET MVC/Blazor | React, Angular, Vue.js, etc. |'
  prefs: []
  type: TYPE_TB
- en: '| Native apps | WinForms, WinUI, WPF, UWP | - |'
  prefs: []
  type: TYPE_TB
- en: '| Desktop apps | .NET MAUI/Avalonia/Uno Platform/Xamarin | Electron, NW.js
    |'
  prefs: []
  type: TYPE_TB
- en: '| Mobile apps | React Native, Cordova, or Ionic |'
  prefs: []
  type: TYPE_TB
- en: '| Backend | ASP.NET Core | Node.js |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.4: Comparison of .NET and JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: From *Table 1.4*, we can see that .NET has a good infrastructure for supporting
    multiple languages. With the **Common Type System** (**CTS**) and **Common Language
    Runtime** (**CLR**) as the core of .NET implementation, it supports multiple languages
    naturally, with the capability to share the **Base Class Library** (**BCL**) in
    all supported languages. JavaScript has its limitations as a scripting language,
    so languages such as TypeScript and CoffeeScript were invented to enhance it.
    TypeScript was developed by Microsoft to bring modern, object-oriented language
    features to JavaScript. TypeScript is compiled into JavaScript for execution,
    so it can work well with existing JavaScript libraries.
  prefs: []
  type: TYPE_NORMAL
- en: The cross-platform frameworks of .NET and JavaScript can cover not only mobile
    development but also desktop development. In a .NET environment, .NET MAUI, Uno
    Platform, and Avalonia can support both desktop and mobile cross-platform development.
    In the JavaScript ecosystem, React Native, Ionic, and Cordova are used for mobile
    development, and Electron or NW.js are used for desktop development.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET is a built-in component of Windows operating systems, it is used
    to develop native applications such as WinForms, UWP, and WPF. The Windows operating
    system itself is one of the major targets for support in cross-platform programming
    frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: This comparison has helped us to choose between and evaluate technical stacks
    for cross-platform full stack development. As a .NET MAUI developer, this analysis
    can help you understand where .NET MAUI is located in the .NET ecosystem. To find
    out more about the .NET ecosystem, let’s have a quick overview of the history
    of the .NET landscape in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the .NET landscape
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we dive into the details of .NET MAUI, let’s have an overview of the
    .NET landscape. This is a section for those who are new to .NET. If you are a
    .NET developer, you can skip this section.
  prefs: []
  type: TYPE_NORMAL
- en: Since Microsoft introduced the .NET platform, it has evolved from a proprietary
    software framework for Windows to a cross-platform and open-source platform.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to look at the .NET technology stack. Basically, it contains
    the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: Common infrastructure (compiler and tools suite)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base Class Library (BCL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Runtime (WinRT or Mono)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET Framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The history of .NET started with .NET Framework. It is a proprietary software
    framework developed by Microsoft that runs primarily on Microsoft Windows. .NET
    Framework started as a future-oriented application framework to standardize the
    software stack in the Windows ecosystem. It is built around the **Common Language
    Infrastructure** (**CLI**) and C#. Even though the primary programming language
    is C#, it is designed to be a language-agnostic framework. Supported languages
    can share the same CTS and CLR. Most Windows desktop applications are developed
    using .NET Framework and it is shipped as a part of the Windows operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Mono
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first attempt to make .NET an open-source framework was made by a company
    called Ximian. When the CLI and C# were ratified by ECMA in 2001 and ISO in 2003,
    it opened the door for independent implementations.
  prefs: []
  type: TYPE_NORMAL
- en: In 2001, the open-source project Mono was launched and aimed to implement .NET
    Framework on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET Framework was a proprietary technology at the time, .NET Framework
    and Mono had their own compiler, BCL, and runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Over time, Microsoft moved toward open-source; .NET source code is available
    to the open-source community. The Mono project adopted some source code and tools
    from the .NET code base.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, the Mono project went through many changes as well. At one
    time, Mono was owned by Xamarin. Xamarin developed the Xamarin platform, based
    on Mono, to support the .NET platform on Android, iOS, UWP, and macOS. In 2016,
    Microsoft acquired Xamarin and Xamarin became a cross-platform solution in the
    .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Core
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before the acquisition of Xamarin, Microsoft had already started work to make
    .NET a cross-platform framework. The first attempt was the release of .NET Core
    1.0 in 2016\. .NET Core is a free and open-source framework available for Windows,
    Linux, and macOS. It can be used to create modern web apps, microservices, libraries,
    and console applications. Since .NET Core applications can run on Linux, we can
    build microservices using containers and cloud infrastructure.
  prefs: []
  type: TYPE_NORMAL
- en: After .NET Core 3.x was released, Microsoft worked to integrate and unify .NET
    technology on various platforms. This unified version was to supersede both .NET
    Core and .NET Framework. To avoid confusion with .NET Framework 4.x, this unified
    framework was named .NET 5\. Since .NET 5, a common BCL can be used on all platforms.
    In .NET 5, there are still two runtimes, which are the **Windows runtime** (**WinRT**),
    which is used for Windows, and the Mono runtime, which is used for mobile and
    macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 5, .NET releases support two types of release, which are **Long Term
    Support** (**LTS**) and **Standard Term Support** (**STS**). In this book, we
    use will .NET 8 releases, which are LTS releases.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard and Portable Class Libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before .NET 5, with .NET Framework, Mono, and .NET Core, we had different subsets
    of BCLs on different platforms. In order to share code between different runtimes
    or platforms, a technique called **Portable Class Libraries** (**PCLs**) was used.
    When you create a PCL, you have to choose a combination of platforms that you
    want to support. The level of compatibility is decided by the developer. If you
    want to reuse a PCL, you must carefully study the list of platforms that are supported.
  prefs: []
  type: TYPE_NORMAL
- en: Even though the PCL provides a way to share code, it cannot resolve compatibility
    issues well. To overcome compatibility issues, Microsoft introduced .NET Standard.
  prefs: []
  type: TYPE_NORMAL
- en: .NET Standard is not a separate .NET release but a specification of a set of
    .NET APIs that must be supported on most .NET implementations (.NET Framework,
    Mono, .NET Core, .NET 5 and 6, etc.).
  prefs: []
  type: TYPE_NORMAL
- en: Since .NET 5, a unified BCL is available, but .NET Standard will still be part
    of this unified BCL. If your applications only need to support .NET 5 or later,
    you don’t really need to care too much about .NET Standard. However, if you want
    to be compatible with old .NET releases, .NET Standard is still the best choice
    for you. We will use .NET Standard 2.0 in this book to build our data model since
    this is a version that can support most existing .NET implementations and all
    future .NET releases.
  prefs: []
  type: TYPE_NORMAL
- en: There will be no new versions of .NET Standard from Microsoft, but .NET 5, .NET
    6, and all future versions will continue to support .NET Standard 2.1 and earlier.
    *Table 1.5* shows the platforms and versions that .NET Standard 2.0 can support.
    This also happens to be a compatibility list for our data model in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '| **.NET Implementation** | **Version support** |'
  prefs: []
  type: TYPE_TB
- en: '| .NET and .NET Core | 2.0, 2.1, 2.2, 3.0, 3.1, 5.0, 6.0 |'
  prefs: []
  type: TYPE_TB
- en: '| .NET Framework 1 | 4.6.1.2, 4.6.2, 4.7.1, 4.7.2, 4.8 |'
  prefs: []
  type: TYPE_TB
- en: '| Mono | 5.4, 6.4 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.iOS | 10.14, 12.16 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Mac | 3.8, 5.16 |'
  prefs: []
  type: TYPE_TB
- en: '| Xamarin.Android | 8.0, 10.0 |'
  prefs: []
  type: TYPE_TB
- en: '| Universal Windows Platform | 10.0.16299, TBD |'
  prefs: []
  type: TYPE_TB
- en: '| Unity | 2018.1 |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.5: .NET Standard 2.0-compatible implementations'
  prefs: []
  type: TYPE_NORMAL
- en: Using Xamarin for cross-platform development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we mentioned in the previous section, Xamarin was part of the Mono project
    and was an effort to support .NET on Android, iOS, and macOS. Xamarin exports
    the underlying operating system features to the .NET runtime. Xamarin.Forms is
    the cross-platform UI framework of Xamarin. .NET MAUI is an evolution of Xamarin.Forms.
    Before we discuss .NET MAUI and Xamarin.Forms, let us review the following diagram
    of Xamarin implementations on various platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.1: Xamarin implementations'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.1* shows the overall architecture of Xamarin. Xamarin allows developers
    to create native UIs on each platform and write business logic in C# that can
    be shared across platforms.'
  prefs: []
  type: TYPE_NORMAL
- en: The transition from Xamarin to .NET MAUI, or more specifically from Xamarin.Forms
    to .NET MAUI, is not a revolution. .NET MAUI essentially represents a new version
    of Xamarin.Forms rather than other components of Xamarin. Xamarin.Android has
    now become .NET Android, with the primary difference being the name change. The
    overall architecture, however, has not undergone significant modifications.
  prefs: []
  type: TYPE_NORMAL
- en: On supported platforms, Xamarin contains bindings for nearly the entire underlying
    platform SDK. Xamarin also provides facilities for directly invoking Objective-C,
    Java, C, and C++ libraries, giving you the power to use a wide array of third-party
    code. You can use existing Android, iOS, or macOS libraries written in Objective-C,
    Swift, Java, and C/C++.
  prefs: []
  type: TYPE_NORMAL
- en: The Mono runtime is used as the .NET runtime on these platforms. It has two
    modes of operation – JIT and AOT. JIT, or Just-in-Time, compilation generates
    code dynamically as it is executed. In AOT, or Ahead-of-Time, compilation mode,
    Mono precompiles everything so it can be used on operating systems where dynamic
    code generation is not possible.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 1.1*, JIT can be used on Android and macOS, while AOT
    is used for iOS, where dynamic code generation is not allowed.
  prefs: []
  type: TYPE_NORMAL
- en: There are two ways to develop native applications using Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: We can develop native applications just like Android, iOS, and macOS developers
    using native APIs on each platform. The difference is that you use .NET libraries
    and C# instead of the platform-specific language and libraries directly. The advantage
    of this approach is that we can use one language and share a lot of components
    through the .NET BCL, even while working on different platforms. We can also leverage
    the power of underlying platforms, just as native application developers can.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to reuse the code at the user interface layer, Xamarin.Forms can
    be used instead of the native UI.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Forms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin.Android, Xamarin.iOS, and Xamarin.Mac provide a .NET environment that
    exposes almost all the original SDK capabilities on their respective platforms.
    For example, as a developer, you nearly have the same capabilities with Xamarin.Android
    as you would with the original Android SDK. To improve code sharing, the open-source
    UI framework Xamarin.Forms was created. Xamarin.Forms includes a collection of
    cross-platform UI components. The user interface design can be implemented using
    XAML markup language, which is similar to Windows user interface design in WinUI
    or WPF.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin.Essentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since Xamarin exposes the capability of the underlying platform SDK, you can
    access device features using .NET APIs. However, the implementation is platform-specific.
    For example, when you use the location service on Android or iOS, the .NET API
    to use can be different. To further improve code sharing across platforms, Xamarin.Essentials
    can be used to access native device features. Xamarin.Essentials provides a unified
    .NET interface for native device features. If you use Xamarin.Essentials instead
    of native APIs, your code can be reused across platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of functionality provided by Xamarin.Essentials include:'
  prefs: []
  type: TYPE_NORMAL
- en: Device info
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: File system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accelerometer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Phone dialer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Text-to-speech
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Screen lock
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Xamarin.Forms together with Xamarin.Essentials, most implementations,
    including of the business logic, user interface design, and some device-specific
    features, can be shared across platforms. In Chapter 7, *Using Platform-Specific
    Features,* we will learn how Xamarin.Essentials has been ported and thus made
    available for .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Comparing user interface design on different platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most modern application development on various platforms uses the **Model View
    Controller (MVC)** design pattern. To separate the business logic and user interface
    design, there are different approaches used on Android, iOS/macOS, and Windows.
    On all these platforms, even though the programming languages used are different,
    they use XML or HTML to design user interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: On iOS/macOS, developers can use Interface Builder in Xcode to generate *.storyboard*
    or *.xib* files. Both are XML-based script files used to keep user interface information,
    and this script is interpreted at runtime together with Swift or Objective-C code
    to create the user interface. In 2019, Apple announced a new framework, SwiftUI.
    Using SwiftUI, developers can build user interfaces using the Swift language in
    a declarative way directly.
  prefs: []
  type: TYPE_NORMAL
- en: On the Android platform, developers can use Layout Editor in Android Studio
    to create user interfaces graphically and store the result in layout files. The
    layout files are in XML format and can be loaded at runtime to create the user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: On the Windows platform, XAML is used in user interface design. XAML, or Extensible
    Application Markup Language, is an XML-based language used for user interface
    design on the Windows platform. For WPF or UWP applications, XAML Designer can
    be used for user interface design. In .NET MAUI, a XAML-based UI is the default
    application UI. Another pattern, MVU, can also be used. In the MVU pattern, the
    user interface is implemented in C# directly without XAML. The coding style of
    MVU is similar to SwiftUI.
  prefs: []
  type: TYPE_NORMAL
- en: Even though SwiftUI on Apple platforms or MVU in .NET MAUI can be used, the
    classic user interface implementation uses XML or HTML. Let us do a comparison
    in *Table 1.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Platform** | **IDE** | **Editor** | **Language** | **File extension** |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | Visual Studio | XAML Designer | XAML/C# | .xaml |'
  prefs: []
  type: TYPE_TB
- en: '| Android | Android Studio | Layout Editor | XML/Java/Kotlin | .layout |'
  prefs: []
  type: TYPE_TB
- en: '| iOS/macOS | Xcode | Interface Builder | XML/Swift/Objective C | .storyboard
    or .xib |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI/Xamarin.Forms | Visual Studio | N.A. | XAML/C# | .xaml |'
  prefs: []
  type: TYPE_TB
- en: '| .NET MAUI Blazor | Razor/C# | .razor |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.6: Comparison of user interface design options'
  prefs: []
  type: TYPE_NORMAL
- en: In *Table 1.6*, we can see a comparison of user interface design options on
    different platforms.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI and Xamarin.Forms use a dialect of XAML to design user interfaces
    on all supported platforms. For .NET MAUI, we have another choice for user interface
    design, which is Blazor. Blazor UIs are written in Razor syntax, which is a combination
    of HTML, CSS, and C#. We will discuss Blazor later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: In Xamarin.Forms, we create user interfaces in XAML and code-behind in C#. The
    underlying implementation is still native controls on each platform, so the look
    and feel of Xamarin.Forms applications is the same as for native ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of features provided by Xamarin.Forms include:'
  prefs: []
  type: TYPE_NORMAL
- en: XAML user interface language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Databinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Gestures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Styling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although Xamarin.Forms enables the sharing of nearly all UI code, it’s still
    necessary to manage most resources used by the application in individual platform
    projects. These resources can include images, fonts, strings, and more. In a Xamarin.Forms
    project structure, there is a common .NET Standard project, accompanied by various
    platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: The majority of development work should take place within the common .NET Standard
    project. While resources such as font icons can be shared across the common project
    as embedded resources, the management of most other resources remains confined
    to separate platform-specific projects.
  prefs: []
  type: TYPE_NORMAL
- en: Moving to .NET MAUI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the .NET unification, Xamarin has become a part of the .NET platform, and
    Xamarin.Forms is integrating with .NET in the form of .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI is a first-class .NET citizen with the namespace `Microsoft.Maui`.
  prefs: []
  type: TYPE_NORMAL
- en: Making the move to .NET MAUI is also an opportunity for Microsoft to redesign
    and rebuild Xamarin.Forms from the ground up and tackle some of the issues that
    have been lingering at a lower level. Compared to Xamarin.Forms, .NET MAUI uses
    a single project structure, supports hot reloads better and supports the MVU and
    Blazor development patterns.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to note that MVU is not currently available as a stable method
    for building apps with .NET MAUI; it has only been announced.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 1.2* shows an architecture diagram of .NET MAUI; you can find it in
    the Microsoft documentation. From *Figure 1.2*, we can see that there is a common
    BCL for all supported operating systems. Under the BCL, there are two runtimes,
    WinRT and the Mono runtime, according to the platform. For each platform, there
    is a dedicated .NET implementation to provide full support for native application
    development.'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.2: .NET MAUI architecture'
  prefs: []
  type: TYPE_NORMAL
- en: Compared to Xamarin.Forms, we can see in *Table 1.7* that there are many improvements
    in .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI uses a single project structure to simplify project management. We
    can manage resources, dependency injection, and configuration in one location
    instead of managing them separately per platform. We will learn more about the
    single project structure in *Chapter 2*, *Building Our First .NET MAUI App.*
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI is fully integrated as part of .NET, so we can create and build projects
    using the .NET SDK command line. In this case, we have more choice in terms of
    development environment.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Features** | **.NET MAUI** | **Xamarin.Forms** |'
  prefs: []
  type: TYPE_TB
- en: '| Project structure | Single project | Multiple projects |'
  prefs: []
  type: TYPE_TB
- en: '| Resource management | One location for all platforms | Managed per platform
    |'
  prefs: []
  type: TYPE_TB
- en: '| Fully integrated with .NET | Namespace in `Microsoft.Maui` and other IDEs
    can be chosen besides Visual StudioCommand-line support. We can create, build,
    and run in console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| Namespace in `Xamarin.Forms` and Visual Studio as IDE |'
  prefs: []
  type: TYPE_TB
- en: '| Design improvement | Configuration through .NET Generic HostDependency injection
    support | Configuration scattered in different locations |'
  prefs: []
  type: TYPE_TB
- en: '| Model View Update (MVU) pattern | A modern way of UI implementation | No
    |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Hybrid | Support through `BlazorWebView` | No |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.7: .NET MAUI improvements'
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI Blazor apps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Table 1.6*, where we compared user interface design options on different
    platforms, we mentioned that there is another way to design cross-platform user
    interfaces in .NET MAUI, which is Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor, released in ASP.NET Core 3.0, is a framework for building interactive
    client-side web UIs with .NET. With .NET MAUI and Blazor, we can build cross-platform
    apps in the form of Blazor Hybrid apps. In this way, the boundary between native
    application and web application becomes blurred. .NET MAUI Blazor Hybrid apps
    enable Blazor components to be integrated with native platform features and UI
    controls. Blazor components have full access to the native capabilities of the
    device.
  prefs: []
  type: TYPE_NORMAL
- en: '*![](img/B21554_01_03.png)*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 1.3: .NET MAUI Blazor Hybrid'
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 1.3*, the way to use the Blazor web framework in .NET
    MAUI is through a `BlazorWebView` component. We can use .NET MAUI Blazor to mix
    native and web UIs in a single view. In .NET MAUI Blazor apps, applications can
    leverage the Blazor component model (Razor components), which uses HTML, CSS,
    and C# in Razor syntax. The Blazor part of an app can reuse components, layouts,
    and styles that are used in an existing regular web app. `BlazorWebView` components
    can be composed alongside native elements; additionally, these components leverage
    platform features and share state with their native counterparts.
  prefs: []
  type: TYPE_NORMAL
- en: Developing native apps using .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With .NET MAUI, Xamarin.Android, Xamarin.iOS, and Xamarin.Mac have been updated
    to .NET for Android, and .NET for iOS and .NET for Mac. We can develop native
    applications using .NET as we can see in *Figure 1.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.4: Native app development using .NET'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we have a complete .NET implementation on Android, iOS, and macOS, we
    can develop native applications on these platforms using .NET tools. This is the
    same as for Xamarin-native projects. The open-source project `keepass2android`
    is a good example of developing native Android apps using `Xamarin.Android`: [https://play.google.com/store/search?q=keepass2android](https://play.google.com/store/search?q=keepass2android).'
  prefs: []
  type: TYPE_NORMAL
- en: With the latest .NET releases, there are multiple ways to develop cross-platform
    applications, such as .NET MAUI apps, native apps, and Blazor Hybrid apps, Avalonia,
    and Uno. We can see that there is a variety of possibilities in the .NET ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: What’s new in .NET 8 for .NET MAUI?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET 8 introduced many new changes, and here we will review the aspects related
    to .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: Native AOT support for iOS-like platforms
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET 8 introduces native AOT support for iOS-like platforms, allowing the building
    and running of .NET iOS and .NET MAUI applications on various platforms. Preliminary
    testing shows a 40% disk size decrease for .NET iOS apps and a 25% increase for
    .NET MAUI iOS apps using native AOT. However, as this is only the first step in
    support, performance conclusions should not be drawn yet. Native AOT support is
    an opt-in feature for app deployment, while Mono remains the default runtime for
    development and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI extension of Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although still in its preview stage, Visual Studio Code now offers a .NET MAUI
    extension, making it available for use in .NET MAUI development. The .NET MAUI
    extension is a new Visual Studio Code extension that lets you develop and debug
    your app on devices, emulators, and simulators from VS Code. It is built on top
    of the C# and C# Dev Kit extensions, which supercharge your .NET development with
    powerful IntelliSense, an intuitive Solution Explorer, package management, and
    more.
  prefs: []
  type: TYPE_NORMAL
- en: Development environment setup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will introduce the development environment setup in Visual
    Studio and Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Using Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both Windows and macOS can be used for.NET MAUI development, but you won’t be
    able to build all the targets with only one of them. You will need both Windows
    and Mac computers to build all the targets. In this book, the Windows environment
    is used to build and test Android and Windows targets, while iOS and macOS targets
    are built on a Mac computer.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET MAUI apps can target the following platforms:'
  prefs: []
  type: TYPE_NORMAL
- en: Android 5.0 (API 21) or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS 11 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 10.15 or higher, using Mac Catalyst
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Windows 11 and Windows 10 version 1809 or higher, using Windows UI Library (WinUI)
    3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET MAUI Blazor apps use the platform-specific WebView control, so they have
    the following additional requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: Android 7.0 (API 24) or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: iOS 14 or higher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: macOS 11 or higher, using Mac Catalyst
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET MAUI build targets of Android, iOS, macOS, and Windows can be built using
    Visual Studio on a Windows computer. In this environment, a networked Mac is required
    to build iOS and macOS targets. Xcode must be installed on the paired Mac to debug
    and test an iOS MAUI app in a Windows environment.
  prefs: []
  type: TYPE_NORMAL
- en: .NET MAUI targets of Android, iOS, and macOS can be built and tested on macOS.
    Please refer to *Table 1.8* to find out about the build configurations on Windows
    and macOS.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Target platform** | **Windows** | **macOS** |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Android | Yes | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| iOS | Yes (pair to Mac) | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | Build only (pair to Mac) | Yes |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.8: Development environment of .NET MAUI'
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET MAUI on Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '.NET MAUI can be installed as part of Visual Studio 2022\. Visual Studio Community
    Edition is free, and we can download it from the Microsoft website at: [https://visualstudio.microsoft.com/vs/community/](https://visualstudio.microsoft.com/vs/community/).'
  prefs: []
  type: TYPE_NORMAL
- en: After launching the Visual Studio Installer, we see what is shown in *Figure
    1.5*. Please select **.NET Multi-platform App UI development** and **.NET desktop
    development** in the list of options. We also need to select **ASP.NET and web
    development** for the .NET MAUI Blazor app, which will be covered in part 2 of
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application, email  Description automatically generated](img/B21554_01_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.5: Visual Studio 2022 installation'
  prefs: []
  type: TYPE_NORMAL
- en: After the installation is completed, we can check the installation from the
    command line using the `dotnet` command as follows.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.6: Checking the dotnet workload list'
  prefs: []
  type: TYPE_NORMAL
- en: We are now ready to create, build, and run a .NET MAUI app on Windows.
  prefs: []
  type: TYPE_NORMAL
- en: Installing .NET MAUI on macOS
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Despite Microsoft’s announcement of Visual Studio for Mac’s retirement in August
    2023, developers can still utilize it for .NET MAUI development on Mac. Visual
    Studio for Mac 17.6 will continue to be supported for another 12 months, until
    August 31st, 2024\. Please refer to the following announcement: [https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/](https://devblogs.microsoft.com/visualstudio/visual-studio-for-mac-retirement-announcement/).'
  prefs: []
  type: TYPE_NORMAL
- en: The installation of Visual Studio Community Edition is similar to what we have
    done on Windows. The installation package can be downloaded from the same link.
  prefs: []
  type: TYPE_NORMAL
- en: After launching the Visual Studio Installer, we see what is shown in *Figure
    1.7*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Graphical user interface, application  Description automatically generated](img/B21554_01_07.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.7: Visual Studio for Mac 2022 Installer'
  prefs: []
  type: TYPE_NORMAL
- en: Please select **.NET** and **.NET MAUI** from the list of options in *Figure
    1.7*.
  prefs: []
  type: TYPE_NORMAL
- en: After the installation is complete, we can check the installation from the command
    line using the `dotnet` command as well.
  prefs: []
  type: TYPE_NORMAL
- en: We are ready to create, build, and run a .NET MAUI app on macOS.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code with the .NET MAUI extension
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also set up a development environment using Visual Studio Code. It’s
    straightforward to get started with the .NET MAUI extension by installing it in
    Visual Studio Code. You can search for the .NET MAUI extension and install it,
    as shown in *Figure 1.8*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_08.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.8: Visual Studio Code with .NET MAUI extension'
  prefs: []
  type: TYPE_NORMAL
- en: When you install the **.NET MAUI extension**, the C# Dev Kit and C# extension
    will be installed automatically. Once the .NET MAUI extension is installed, you
    can load the project and explore the project in the solution explorer just as
    you can in Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21554_01_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.9: Solution explorer in Visual Studio Code'
  prefs: []
  type: TYPE_NORMAL
- en: Since Visual Studio Code can support Windows, macOS, and Linux, we can develop
    .NET MAUI apps on these three platforms. Please refer to the following table to
    find out about the supported target platforms.
  prefs: []
  type: TYPE_NORMAL
- en: '| **Operating System** | **Supported Target Platform** |'
  prefs: []
  type: TYPE_TB
- en: '| Windows | Windows, Android |'
  prefs: []
  type: TYPE_TB
- en: '| macOS | Android, iOS, macOS |'
  prefs: []
  type: TYPE_TB
- en: '| Linux | Android |'
  prefs: []
  type: TYPE_TB
- en: 'Table 1.9: Supported target platforms'
  prefs: []
  type: TYPE_NORMAL
- en: With Visual Studio Code, it is possible to develop .NET MAUI apps on Linux,
    but it can support Android as a target only.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored topics related to .NET MAUI and Xamarin, discussing
    various cross-platform technologies in comparison to .NET MAUI. This analysis
    provided insight into the advantages and disadvantages of different frameworks.
    Additionally, we compared the JavaScript and C# ecosystems, as most cross-platform
    frameworks utilize these languages. By introducing the .NET landscape and the
    available cross-platform frameworks, you now have a comprehensive understanding
    of the essentials before delving into the world of .NET MAUI.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore how to build a .NET MAUI application from
    scratch.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Avalonia UI and MAUI – Something for everyone: [https://avaloniaui.net/](https://avaloniaui.net/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET MAUI** – You can find more information about .NET MAUI in the Microsoft
    official documentation: [https://docs.microsoft.com/en-us/dotnet/maui/](https://docs.microsoft.com/en-us/dotnet/maui/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**KeePass** – The official website for KeePass can be found at: [https://keepass.info/](https://keepass.info/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more on Discord
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/cross-platform-app](https://packt.link/cross-platform-app)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code166522361691420406.png)'
  prefs: []
  type: TYPE_IMG
