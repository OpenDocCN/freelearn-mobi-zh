- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Improving Game Feel
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a basic game, but it’s just that... basic. In this chapter, you
    will learn some of the secrets of game developers to take the basic prototype
    of their game and turn it into something with a lot of polish that feels satisfying
    to play, which is known as improving the game feel of the project.
  prefs: []
  type: TYPE_NORMAL
- en: Also known as *juiciness*, or making our games juicy, in some corners of the
    game industry, **game feel** is a kind of catch-all term for all the things that
    we do in a game to make it pleasing for its users to interact with. This is something
    that is done with most mobile games that are out there today, and lacking this
    kind of interactivity will make others believe our project is lacking in polish.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn some of the different ways that you can integrate
    several of these features into your projects. We will start off by learning how
    to make use of animations. We will then see how we can use Unity’s material system
    in order to add visual appeal to our objects. We will then improve the overall
    visual quality of our game through the use of postprocessing effects. Lastly,
    we will use one of the most powerful tools in a game developer’s toybox, the particle
    system, to improve feedback when the player moves in the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers a number of topics. It goes through a simple step-by-step
    process from beginning to end. Here is an outline of the tasks we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Animation using LeanTween
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding tweens to the pause menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with materials
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using postprocessing effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding particle effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This book utilizes Unity 2022.1.0b16 and Unity Hub 3.3.1, but the steps should
    work with minimal changes in future versions of the editor. If you would like
    to download the exact version used in this book, and there is a new version out,
    you can visit Unity’s download archive at [https://unity3d.com/get-unity/download/archive](https://unity3d.com/get-unity/download/archive).
    You can also find the system requirements for Unity at [https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html](https://docs.unity3d.com/2022.1/Documentation/Manual/system-requirements.html)
    in the **Unity Editor system requirements** section. To deploy your project, you
    will need an Android or iOS device.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code files present in this chapter on GitHub at [https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12](https://github.com/PacktPublishing/Unity-2022-Mobile-Game-Development-3rd-Edition/tree/main/Chapter12).
  prefs: []
  type: TYPE_NORMAL
- en: Animation using LeanTween
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Currently, our game’s menus are completely static. This is functional but does
    not make players excited about playing our game. To make the game seem more alive,
    we should animate our menus. Being able to use Unity’s built-in animation system
    is great, and it can be quite useful if you want to modify many different properties
    at once. If you don’t need precise control, say, if you’re only modifying a single
    property or you want to animate something purely via code, you can also make use
    of a tweening library.
  prefs: []
  type: TYPE_NORMAL
- en: Tweening, short for “in-betweening,” is a common technique used in animation
    and game development to create smooth transitions between two states or values
    over a specified duration. It involves interpolating or transitioning a property
    or set of properties from one value to another gradually.
  prefs: []
  type: TYPE_NORMAL
- en: If it is given a start and an end, the library will take care of all the work
    in the middle to get that property to that endpoint within the time and speed
    you specify. By using tweens, developers can easily add fluid and visually appealing
    animations to their applications without having to manually handle the interpolation
    calculations and animation loops. Tweening libraries provide convenient APIs and
    functionalities to create and control tweens in a straightforward and efficient
    manner.
  prefs: []
  type: TYPE_NORMAL
- en: One of my favorite tweening libraries is Dented Pixel’s *LeanTween*, which is
    open source, usable for free in commercial and non-commercial projects, optimized
    for mobile devices, and used in many games, including Pokémon Go. In the following
    sections, we will first install and set up LeanTween and then see how we can use
    it to animate our title screen UI menus.
  prefs: []
  type: TYPE_NORMAL
- en: LeanTween setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LeanTween allows us to spin, shake, punch, move, fade, and tweak objects in
    many different ways with only one line of code per task. It also gives us the
    ability to fire custom events during the start, middle, and end of the animations,
    allowing us to effectively do whatever we want to create an animation in a way
    that is incredibly powerful once you get familiar with it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we know we want to add tweens to our project, let’s start off by actually
    adding the LeanTween engine to our project. Implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open up the `LeanTween` and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From there, you’ll be brought to a list of items, with the first one being
    **LeanTween**; select it and you will be brought to LeanTween’s product page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.1: Asset Store search](img/B18868_12_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.1: Asset Store search'
  prefs: []
  type: TYPE_NORMAL
- en: Once on the project page, click on button that either says **Add to My Assets**
    or **Open In Unity** depending on if you have the package or not. At this point
    you may need to log into your Unity account. Once added, from the **Package Manager**,
    go ahead and from the asset page click on the **Import** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.2: Package Manager](img/B18868_12_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.2: Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The packages in the Package Manager here will likely look different than yours
    as they are ones that I have personally purchased from the Asset Store.
  prefs: []
  type: TYPE_NORMAL
- en: You should see an `Framework` folder here; however, the others may be useful
    to you, so feel free to use them yourself.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you’ve finished selecting what you want, click on the **Import** button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.3: Import Unity Package dialog](img/B18868_12_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.3: Import Unity Package dialog'
  prefs: []
  type: TYPE_NORMAL
- en: 'We don’t need the Package Manager anymore, so go ahead and close it. You’ll
    notice that now we have the files we have selected inside our `Assets/LeanTween/Framework`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.4: LeanTween imported](img/B18868_12_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.4: LeanTween imported'
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have set up LeanTween.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: There are other tweening libraries that you may want to consider, such as iTween
    and DOTween. For some more information and a comparison of them, check out [http://dotween.demigiant.com/#enginesComparison](http://dotween.demigiant.com/#enginesComparison).
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a tweening system in place, let’s see how we can actually use
    it!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple tween
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Made popular in animation before transitioning to game development, the process
    of tweening (or *inbetweening*) is where, given a starting and ending value, the
    computer will generate the intermediate frames between the two states, giving
    the appearance of the beginning value evolving smoothly into the second value.
    A tween is the information that we have to provide in order to start the tweening
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have LeanTween included in our project, we can use it inside our
    code. To do that, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the Unity Editor, open the **MainMenu** level by going to the **Project**
    window and double-clicking on the **MainMenu** scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, move to the `Scripts` folder and open `MainMenuBehaviour` by double-clicking
    on it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will add the following new function, which we will use to have the object
    move from the left side of the screen to the center:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Before we move anything using LeanTween, we will first set the position of our
    object (the `obj` parameter) off screen by setting the `x` position. It’s important
    to note that when dealing with UI elements in Unity, by default, we are dealing
    with screen space, which, as you can recall from [*Chapter 3*](B18868_03.xhtml#_idTextAnchor125),
    *Mobile Input/Touch Controls*, means that we are moving in terms of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: From here, we’ll see that we are calling the `moveX` function from LeanTween.
    The version we are using takes in three parameters, the first being the `RectTransform`
    object we wish to move and the second being the `x` position to move it to. Based
    on how we set up the anchors and pivots, a position of 0 on the *x* axis is actually
    centered, so we pass in `0`. Lastly, we have the amount of time (in seconds) in
    which we want the transition to happen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have this function, let’s actually call it. Change the `Start`
    function of the `MainMenuBehaviour` script so that it now looks as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first thing we do is bring the Facebook login menu to the screen by calling
    the `SlideMenuIn` function, which in turn will tween the menu to the center of
    the screen. LeanTween, by default, makes use of the game’s `Time.timeScale` property
    to scale movement. When we leave the game from the pause menu and go back to the
    main menu, the game will still be paused. This ensures that the game will be unpaused
    by the time we want to slide this menu in. When we start building the pause menu,
    we’ll see how we can make our tweens work even when the game is paused.
  prefs: []
  type: TYPE_NORMAL
- en: If you play the game now, you’ll notice that the Facebook login screen will
    now move from off screen back into the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Right now, the object moves in a fairly static manner. One of the ways we can
    add life to this tween is by giving it some additional features, such as `easeType`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following highlighted code to the `SlideMenuIn` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'What is happening here is that the `LeanTween.moveX` function returns an object
    of the `LTDescr` type, which is actually a reference to the tween that was created.
    To that tween, we can add additional parameters by calling additional functions
    onto the tween. In fact, an alternate way to write this is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, most of the examples in LeanTween’s documentation use the former method,
    chaining a number of different events to happen at once.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To see what some of the other commonly used methods are besides `easeType` in
    LeanTween, check out [https://tedliou.com/archives/leantween-ui-animation/](https://tedliou.com/archives/leantween-ui-animation/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add the ability for the current menu to slide off screen when
    we select a button to go to another menu:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this is similar to the previously written function, except now we
    are also using another function called `setOnComplete`, which can take in either
    a function or an expression lambda, which works basically as a function without
    a name and is often used in `obj`, I used a lambda. What this will do is after
    the object is off screen, it will automatically turn off; but we have the potential
    to do anything. This can be incredibly powerful, as we can do anything that we’d
    normally be able to do via code.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on lambda expressions, check out [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/statements-expressions-operators/lambda-expressions).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we will need to update the `ShowMainMenu` function to actually display
    the menus:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the script and dive back into the game:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.5: Menus sliding in and out](img/B18868_12_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.5: Menus sliding in and out'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the menus will now fly in and out when on the main menu.
  prefs: []
  type: TYPE_NORMAL
- en: With the preceding example, you should be able to see just how easy it is to
    add motion to our projects and how it can improve the overall quality of the game,
    making it more enjoyable to interact with.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tweens to the pause menu
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have finished the main menu, let’s continue adding tweens to the
    pause menu:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and open up our `PauseScreenBehaviour` script to have the following
    implementation of `SetPauseMenu`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that because `PauseMenuBehaviour` inherits from `MainMenuBehaviour`, it
    can also call the `SlideMenuIn` and `SlideMenuOut` functions, respectively, as
    long as they are marked as `protected` or `public`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, if we run the game, nothing will appear to happen when we hit the pause
    menu. This is because—as I mentioned previously—tweens are scaled by `Time.timeScale`,
    which we just changed. To fix this, we can make use of another LeanTween function,
    called `setIgnoreTimeScale`, which we will set to `true` in both functions we
    wrote previously in the `MainMenuBehaviour` script. Go back to the `MainMenuBehaviour`
    script and add the following highlighted code to the `SlideMenuIn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the highlighted code to the `SlideMenuOut` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save both scripts and dive into the Editor to try it out:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.6: Screen flying in](img/B18868_12_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.6: Screen flying in'
  prefs: []
  type: TYPE_NORMAL
- en: Perfect! We now have the screen flying in just like we wanted it to.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous two sections, we learned how to create tweening events and how
    to apply them to different scenarios. In the next section, we will see another
    way that we can improve the visuals of our project through the use of materials.
  prefs: []
  type: TYPE_NORMAL
- en: Working with materials
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Previously, we have always used the default material for everything in our project.
    This has worked out well for us, but it may be a good idea for us to talk a little
    bit about creating custom ones to improve the visuals of our player. Materials
    are instructions on how to draw 3D objects within Unity. They consist of a shader
    and properties that the shader uses. A **shader** is a script that instructs the
    material on how to draw things on the object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Shaders are a huge subject that entire books have been written on, so we can’t
    dive too much into them here, but we can talk about working with one that is included
    in Unity, the **Standard Shader**. Implement the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the `Materials`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.7: Adding Materials](img/B18868_12_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.7: Adding Materials'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `Materials` folder we just created, and then once inside, create
    a new material by right-clicking within the folder and then selecting **Create**
    | **Material**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8: Creating a material](img/B18868_12_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.8: Creating a material'
  prefs: []
  type: TYPE_NORMAL
- en: Name this new material `Ball`. In the `0.9` and the `0.8`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go to the **Scene** view and drag and drop the **Ball** material onto our
    player object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.9: Setting material properties](img/B18868_12_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.9: Setting material properties'
  prefs: []
  type: TYPE_NORMAL
- en: The albedo property acts as a diffuse map setting the base color of an object,
    though you can also apply a texture to use an image file to change how it looks.
    The **Metallic** parameter of a material determines how *metal-like* the surface
    is. The more metallic a surface is, the more it reflects its environment. The
    **Smoothness** property determines how smooth the surface is; a higher smoothness
    will have light bounce off it uniformly, making the reflections clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on the standard shader and its parameters, check out [https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html](https://docs.unity3d.com/Manual/StandardShaderMaterialParameters.html).
  prefs: []
  type: TYPE_NORMAL
- en: Using materials is only one of the ways that we can improve the visual quality
    of our project. In fact, one of the most drastic ways that we can modify our project’s
    visuals is through the use of postprocessing effects, which we will be looking
    at next.
  prefs: []
  type: TYPE_NORMAL
- en: Using postprocessing effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the ways that we can improve the visual quality of our game with little
    effort is by using postprocessing effects (previously called **Image Effects**).
    Postprocessing is the process of applying filters and other effects to what the
    camera will draw (the image buffer) before it is displayed on screen.
  prefs: []
  type: TYPE_NORMAL
- en: Unity includes a number of effects in its freely available postprocessing stack.
    Unity’s postprocessing stack is a set of visual effects that can be applied to
    the rendered images in a game or application to enhance the overall visual quality.
    These effects can include things like color grading, depth of field, motion blur,
    ambient occlusion, and more. By using the postprocessing stack, developers can
    easily add these effects to their games without having to create them from scratch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The term “stack” is used to emphasize that these effects are designed to be
    used together, in a layered manner, to achieve a desired visual style or aesthetic.
    By providing a pre-built collection of effects as a stack, Unity simplifies the
    process of implementing advanced visual effects for developers, allowing them
    to focus more on the creative aspects of their projects. So, let’s go ahead and
    add it using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the Package Manager again by going to **Window** | **Package Manager**.
    From there, go to the **Packages** dropdown from the top left and set it to **Unity
    Registry**. Afterward, scroll down until you see the **Post Processing** option
    and select it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.10: Post Processing](img/B18868_12_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.10: Post Processing'
  prefs: []
  type: TYPE_NORMAL
- en: Once selected, click on the **Install** button and wait for it to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the `Post Process`. Then, move your mouse over the **Post-process
    Layer** selection and click to add the script to your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Post-process Layer** component handles the blending of postprocessing
    volumes and what the postprocessing should be based on.
  prefs: []
  type: TYPE_NORMAL
- en: Under the **Post-process Layer** component, change **Layer** to **Everything**.
    This will make it so everything in our scene will be used in terms of blending
    between volumes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will next need to add the **Post-process Volume** component to our **Main
    Camera** game object. Do this by clicking on the **Add Component** button and
    then selecting the **Post-process** **Volume** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.11: Adding the volume](img/B18868_12_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.11: Adding the volume'
  prefs: []
  type: TYPE_NORMAL
- en: Note that this component requires a profile. We can go ahead and add that next.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a new postprocessing profile by right-clicking on the `Assets`
    folder, selecting `MobilePostProcessing`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Image 12.12: Adding a postprocessing profile](img/B18868_12_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Image 12.12: Adding a postprocessing profile'
  prefs: []
  type: TYPE_NORMAL
- en: Go back to the **Main Camera** object and attach this object to the **Profile**
    property of the **Post-process Volume** component. Afterward, go to the **Post-process
    Volume** component and then check the **Is Global** property box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will make it so the volume we have created will always be visible on our
    player’s screen no matter where their camera is positioned in the world.
  prefs: []
  type: TYPE_NORMAL
- en: Because `Post-processing Profile` is a separate file, we can make changes to
    it while playing the game without worrying about losing our changes. With that
    in mind, start the game and pause it once gameplay has started.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, there’s a large number of possible effects that can be added to modify
    how the game looks.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that for each element that we add to the profile you add, the frame rate
    of the devices we are trying to run our game on will be decreased. Keep testing
    your device with these options and note how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, under the `0.45`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.13: Adding Vignette](img/B18868_12_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.13: Adding Vignette'
  prefs: []
  type: TYPE_NORMAL
- en: Note how there now seems to be a blackened edge or border around the game.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If the UI menu disappears, switching from the **Scene** view back to the **Game**
    view seems to fix this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, enable `0.35` to make it even darker by clicking on the top right of
    the section to expand it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.14: Enabling Smoothness](img/B18868_12_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.14: Enabling Smoothness'
  prefs: []
  type: TYPE_NORMAL
- en: Vignetting is the term used for the darkening and/or desaturating toward the
    edges of an image compared to the center. I like to use this when I want to have
    players focus on the center of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Click on the **Add effect...** button again and this time, select **Unity**
    | **Grain**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Check and set `0.15` and you’ll note that the screen has become fuzzier. While
    it’s not a great idea if it is set too large, note that decreasing `0.3` and unchecking
    **Colored** will help with the appearance of things:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.15: Grain](img/B18868_12_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.15: Grain'
  prefs: []
  type: TYPE_NORMAL
- en: If you’ve been to a movie theater that still uses film, you may have noticed
    how there were little specks in the filmstock that were visible over the course
    of the film. The **Grain** effect in Unity simulates this film grain, causing
    the effect to become more pronounced the more the movie is played. This is often
    used in horror games to obscure the player’s vision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another property to add is `10`. From there, set `0.6` to help brighten things
    up:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.16: Bloom](img/B18868_12_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.16: Bloom'
  prefs: []
  type: TYPE_NORMAL
- en: The **Bloom** effect attempts to mimic the imaging artifacts of real-world cameras,
    where things in areas with light will glow along the edges, thus overwhelming
    the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, stop the game, then go back to the **Post-process Layer** component
    and, under **Anti-aliasing**, change **Mode** to **Fast Approximate Anti-aliasing
    (FXAA)** and then check **Fast** **Mode**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.17: Anti-aliasing](img/B18868_12_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.17: Anti-aliasing'
  prefs: []
  type: TYPE_NORMAL
- en: Aliasing is an effect where lines appear jagged on the screen. This happens
    if the screen on the device we are trying to play our game on doesn’t have a high
    enough resolution to display properly.
  prefs: []
  type: TYPE_NORMAL
- en: Anti-aliasing attempts to reduce that effect by combining colors near these
    lines to remove its prominence, at the cost of it appearing blurrier.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: For more information on postprocessing in Unity, check out [https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html](https://docs.unity3d.com/Packages/com.unity.postprocessing@3.2/manual/index.html).
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of other properties to look into and adapt to get your project
    looking just the way you want. Explore them and find what works well for the vision
    you are looking to achieve!
  prefs: []
  type: TYPE_NORMAL
- en: The game itself currently works, but it could use some more polish. One of the
    things we can do to increase the polish of the game is to make use of particle
    systems, which is what we can look at next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding particle effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Typically used for effects that are natural or organic, such as fire, smoke,
    and sparks, particle systems create objects that are designed to be as low cost
    as possible, called particles. Due to this, we can spawn many of the particles
    at once with a minimal performance cost. One of the easiest types of particle
    systems to create is a trail to follow our player, so let’s add one of those now
    using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Player** in the **Hierarchy** window, and then right-click and select
    **Effects** | **Particle System**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This will make this system a child of the player, which will be good for what
    we are going to do.
  prefs: []
  type: TYPE_NORMAL
- en: In the `0` and **Simulation Space** to **World**. Then, change **Start Color**
    to a color that stands out, such as purple.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open up the `0` (it will automatically change to `0.0001`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a step in the right direction. The purple particles are now following
    the player, as shown in the screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.18: Particle trail](img/B18868_12_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.18: Particle trail'
  prefs: []
  type: TYPE_NORMAL
- en: However, there are still a number of things we can do to improve this. Instead
    of just a single color, we can change it so that it randomly alternates between
    two colors.
  prefs: []
  type: TYPE_NORMAL
- en: To do that, go to the right side of **Start Color**, and you’ll see a little
    downward-facing arrow. Click on that and then select **Random Between Two Colors**.
    Then, change the color to one of two purple colors for some randomness.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, next to `0.5` and `1.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, set the `0` to `0.2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, open up the `100`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.19: Particle settings](img/B18868_12_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.19: Particle settings'
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the game and play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.20: Final particle trail](img/B18868_12_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 12.20: Final particle trail'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you’re interested in exploring more details on things that can be done to
    polish projects, you can check out another of my Unity books, *Unity 5.x Game
    Development Blueprints*, also available from Packt, which also dives into game
    polish.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the particle system looks great on both our PC and mobile devices.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there are many other areas that can be improved through the use of
    particle systems. Perhaps whenever the player hits a wall, we can display some
    sparks; when we swipe, we could play another effect; when the player pauses the
    game, we could have something falling on the screen. The possibilities are endless!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have now improved our game by a huge amount by only doing a few simple things.
    We first animated our menus with a few lines of code using tweens from LeanTween
    and saw how a few lines of code can improve the visual quality of our UI in a
    number of ways. We next saw how to create materials to improve the visual quality
    of our ball and then used some postprocessing effects to polish the contents of
    our screen. Finally, we discussed how to use particle effects to create a nice
    trail following our player.
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts, you now have the skills to dramatically improve the feel
    of your game projects so that players actually enjoy interacting with your game.
  prefs: []
  type: TYPE_NORMAL
- en: By this point, our game is finally ready for the big leagues. In the next chapter,
    we will explore how to build our games in order to get our game onto the Apple
    App Store and Google Play.
  prefs: []
  type: TYPE_NORMAL
