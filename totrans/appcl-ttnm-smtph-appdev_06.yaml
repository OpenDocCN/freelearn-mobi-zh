- en: Chapter 6. Getting to Grips with Events and Properties
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 掌握事件和属性
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Reading and writing app properties
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读取和写入应用程序属性
- en: Firing and capturing events
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发和捕获事件
- en: Passing event data between your app and a WebView using custom events
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义事件在应用程序和WebView之间传递事件数据
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter describes the processes of two fundamentally important, yet deceptively
    simple, parts of the Titanium framework. In this chapter, we'll explain how to
    go about creating and reading app properties so that you can store data that is
    accessible from any part of your application. This is similar to how session data
    or cookies would work if you were building a web-based app.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章描述了Titanium框架两个基本重要但看似简单的部分的流程。在本章中，我们将解释如何创建和读取应用程序属性，以便你可以存储可以从应用程序任何部分访问的数据。这类似于如果你正在构建基于Web的应用程序，会话数据或cookie的工作方式。
- en: We'll also go into further detail on events, including a selection of those
    fired by the various components in Titanium, and custom events that you can define
    yourself.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将进一步详细介绍事件，包括由Titanium的各种组件触发的事件的选择，以及你可以自己定义的自定义事件。
- en: Application properties are used for storing data in key/value pairs. These properties
    can persist between your app's windows, and even beyond single application sessions,
    much like a website cookie. You can use any combination of upper case or lower
    case letters and numbers in a property name, but you should mix them with care
    as JavaScript is case-sensitive. In this regard, `Myname, myname`, and `MYNAME`
    would be three very different properties!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序属性用于以键/值对的形式存储数据。这些属性可以在你的应用程序窗口之间持久化，甚至可以跨越单个应用程序会话，就像网站cookie一样。你可以在属性名称中使用任意组合的大写字母、小写字母和数字，但你应该谨慎地混合它们，因为JavaScript是区分大小写的。在这方面，`Myname,
    myname` 和 `MYNAME` 将是三个非常不同的属性！
- en: When should you use app properties?
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 你应该在何时使用应用程序属性？
- en: 'Application properties should be used when one or more of the following points
    are true:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 应当在以下任一点成立时使用应用程序属性：
- en: The data consists of simple key/value pairs
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据由简单的键/值对组成
- en: The data is related to the application rather than the user
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据与应用程序相关，而不是与用户相关
- en: The data does not require other data in order to be meaningful or useful
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据不需要其他数据才能有意义或有用
- en: There only needs to be one version of the data stored at any one time
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何给定时间只需要存储数据的一个版本
- en: For example, storing a string/string key pair of `data_url` and "[http://mywebsite.com/data.xml](http://mywebsite.com/data.xml)"
    would be a valid way to use app properties. This URL could be re-used throughout
    all of your application screens/windows and is related to your application, rather
    than your data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，将字符串/字符串键对`data_url`和`[http://mywebsite.com/data.xml](http://mywebsite.com/data.xml)`存储为应用程序属性是使用应用程序属性的有效方式。这个URL可以在你应用程序的所有屏幕/窗口中重用，并且与你的应用程序相关，而不是与你的数据相关。
- en: If your data is complex and needs to be joined, ordered, or queried when retrieving
    it, then you are better off using a local database built with SQLite. If your
    data is a file or large blob object, (for example, an image) then this is better
    stored on the filesystem, in the manner described in our previous recipe.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据复杂且在检索时需要连接、排序或查询，那么使用用SQLite构建的本地数据库会更好。如果你的数据是文件或大型blob对象（例如，图像），那么按照我们之前食谱中描述的方式存储在文件系统中会更好。
- en: What object types can be stored as app properties?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可以将哪些对象类型存储为应用程序属性？
- en: 'There are currently five distinct types of objects that can be stored in the
    app properties module. These include:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 目前可以在应用程序属性模块中存储五种不同的对象类型。这些包括：
- en: Booleans
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔值
- en: Doubles (float values)
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双精度（浮点值）
- en: Integers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 整数
- en: Strings
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串
- en: Lists (arrays)
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列表（数组）
- en: In the following recipe, we will create a number of app properties and then
    read them back, printing them out to the console as we do so.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的食谱中，我们将创建一些应用程序属性，然后读取它们，在读取过程中将它们打印到控制台。
- en: Note
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this entire chapter can be found in the `/Chapter 6/EventsAndProperties`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节的完整源代码可以在`/Chapter 6/EventsAndProperties`中找到。
- en: Reading and writing app properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 读取和写入应用程序属性
- en: Whether reading or writing values, all app properties are accessed from the
    `Titanium.App.Properties` namespace. In this recipe, we are going to create a
    number of properties, all with different types, on the first tab window of our
    app. We will then read them and output their values to the console from a button
    in the second tab window. We'll also show you how to check the existence of a
    property using the `hasProperty` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 无论是读取还是写入值，所有应用属性都是从`Titanium.App.Properties`命名空间访问的。在这个食谱中，我们将在应用的第一标签窗口上创建多个属性，所有属性类型都不同。然后我们将从第二个标签窗口上的按钮读取它们并将它们的值输出到控制台。我们还将向您展示如何使用`hasProperty`方法检查属性的存在。
- en: Note
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    1` folder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/第 6 章/食谱 1`文件夹中找到。
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `EventsAndProperties`
    as the name of the app, and fill in the rest of the details with your own information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 准备此食谱，请打开 Titanium Studio 并登录，如果您尚未登录的话。如果您需要注册新账户，您可以直接在应用程序内免费注册。登录后，点击**新建项目**，创建新项目的详细信息窗口将出现。将应用名称输入为`EventsAndProperties`，并使用您自己的信息填写其余的详细信息。
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is, *com.packtpub.eventsandproperties)*. This identifier cannot
    be easily changed after the project is created and you will need to match it *exactly*
    when creating provisioning profiles for distributing your apps later on.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意应用标识符，它以反向域名表示法（即，*com.packtpub.eventsandproperties*）正常书写。在项目创建后，此标识符不容易更改，您在创建用于分发应用的配置文件时需要**精确匹配**它。
- en: How to do it…
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Open up the `app.js` file in your editor and leave the existing code, except
    for the declaration of the two labels and the lines where those labels are added
    to your tab Windows. After the declaration of the `win1` object, type in the following
    code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`app.js`文件，保留现有的代码，除了两个标签和标签窗口中添加这些标签的行。在`win1`对象的声明之后，输入以下代码：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, while still in your `app.js` file, add the following code. It should be
    placed after the declaration of the `win2` object.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，仍然在您的`app.js`文件中，添加以下代码。它应该放在`win2`对象声明之后。
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, launch the emulator from Titanium Studio and you should see the standard
    2-tab navigation view, with a button in each view. Clicking on the **Set** button
    on the first tab will set your app properties. After you have done so, you can
    use the buttons on the second tab view to read back individual properties and
    check the existence of a property. The results will appear in your Titanium Studio
    console, similar to the following screenshot:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，从 Titanium Studio 中启动模拟器，您应该会看到标准的双标签导航视图，每个视图中都有一个按钮。点击第一个标签上的**设置**按钮将设置您的应用属性。完成设置后，您可以使用第二个标签视图上的按钮读取单个属性并检查属性的存在。结果将显示在您的
    Titanium Studio 控制台中，类似于以下截图：
- en: '![How to do it…](img/3968EXP_06_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/3968EXP_06_01.jpg)'
- en: How it works…
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: In this recipe, we are setting a number of app properties, using our **Set Properties!**
    button. Each property consists of a key/value pair, and therefore requires a property
    name (also called the 'key') and a property value. To set a property, we use the
    `set` method, which looks similar to `Titanium.App.Properties.set<type>(key,value)`.
    We are then retrieving our app properties by using the `get` method, which looks
    similar to `Titanium.App.Properties.get<type>(key,value)`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们通过使用我们的**设置属性！**按钮设置了一系列应用属性。每个属性由一个键/值对组成，因此需要一个属性名（也称为“键”）和一个属性值。要设置属性，我们使用`set`方法，其形式类似于`Titanium.App.Properties.set<type>(key,value)`。然后我们通过使用`get`方法检索我们的应用属性，其形式类似于`Titanium.App.Properties.get<type>(key,value)`。
- en: Application properties are loaded into memory as the app launches, and exist
    in the global scope of the app until either it is closed, or the property is removed
    from memory using the `Titanium.App.Properties.remove()` method. While there is
    a memory overhead in using properties in this manner, it means you can efficiently
    and quickly access them from any part of your application as they are effectively
    global in scope.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序属性在应用程序启动时加载到内存中，并在应用程序的全局范围内存在，直到它被关闭，或者使用`Titanium.App.Properties.remove()`方法从内存中删除属性。虽然以这种方式使用属性会有内存开销，但这意味着您可以从应用程序的任何部分有效地快速访问它们，因为它们在作用域上是全局的。
- en: You can also access the entire list of properties stored at any given time using
    the `Titanium.App.Properties.listProperties` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用`Titanium.App.Properties.listProperties`方法访问任何给定时间存储的整个属性列表。
- en: Firing and capturing events
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发和捕获事件
- en: Much of Titanium is built around the concept of event-driven programming. If
    you have ever written code in Visual Basic, C#, Java or any number of event-driven,
    object-orientated languages, this concept will already be familiar to you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分Titanium都是围绕事件驱动编程的概念构建的。如果您曾经用Visual Basic、C#、Java或任何数量的事件驱动、面向对象的语言编写过代码，这个概念对您来说已经很熟悉了。
- en: Each time a user interacts with a part of your application's interface, or types
    something in a `TextField`, an event occurs. The event is simply the action the
    user took (for example, a tap, a scroll, or a key press on the virtual keyboard)
    and where it took place (for example, on a button, or in this `TextField)`. Additionally,
    some events can indirectly cause other events to fire. For example, when the user
    selects a menu item that opens a window, it causes another event—the opening of
    the window.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 每当用户与您应用程序界面的某个部分进行交互，或在`TextField`中输入内容时，都会发生一个事件。事件只是用户执行的动作（例如，点击、滚动或虚拟键盘上的按键）以及它发生的位置（例如，在按钮上，或在这个`TextField`中）。此外，某些事件可以间接触发其他事件。例如，当用户选择一个打开窗口的菜单项时，它会导致另一个事件——窗口的打开。
- en: There are basically two fundamental types of events in Titanium; those you define
    yourself (a custom event), and those already defined by the Titanium API (a button
    click event is a good example).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在Titanium中基本上有两种基本类型的事件；那些您自己定义的（自定义事件），以及那些由Titanium API预先定义的（按钮点击事件是一个很好的例子）。
- en: In the following recipes, we will explore a number of Titanium-defined events
    before showing you how to create custom events that can pass data between your
    app and a Webview.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的菜谱中，我们将在向您展示如何创建可以在您的应用程序和Webview之间传递数据的自定义事件之前，探索许多由Titanium定义的事件。
- en: As mentioned in the previous recipe, the user can also indirectly cause events
    to occur. Buttons, for example, have an event called 'click', which occurs when
    the user clicks on the button on the screen. The code that handles the response
    to an event is called an event handler.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个菜谱中提到的，用户也可以间接地导致事件发生。例如，按钮有一个名为'click'的事件，当用户在屏幕上点击按钮时发生。处理事件响应的代码称为事件处理器。
- en: There are many events that can occur to each object in your Titanium application.
    The good news is that you don't need to learn about all of them, and those that
    are already defined are listed in the Titanium API. You simply need to know how
    they work and how the event data is accessed so you can find out if the object
    is able to respond to that event.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您的Titanium应用程序中的每个对象都可能发生许多事件。好消息是您不需要了解所有这些事件，并且那些已经定义的事件列在Titanium API中。您只需要了解它们是如何工作的以及如何访问事件数据，这样您就可以找出对象是否能够响应该事件。
- en: In this recipe, we will explore the events that occur from a number of common
    components, using the `OptionDialog` as an example, and explain how to access
    the properties of those events. We'll also explain how to create a function that
    passes the resulting event back to our executing code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨从多个常见组件中发生的事件，以`OptionDialog`为例，并解释如何访问这些事件的属性。我们还将解释如何创建一个函数，该函数将返回的事件传递回我们的执行代码。
- en: Note
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    2` folder.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 6/Recipe 2`文件夹中找到。
- en: How to do it…
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Open up the `app.js` file in your editor, and below your declaration of the
    `win1` object, type in the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的编辑器中打开`app.js`文件，并在您的`win1`对象声明下方输入以下代码：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, after you have created the previous code, we are going to create an `OptionDialog`
    with an event listener that uses an external function as its event handler. We'll
    do this in the event handler function for the `buttonLaunchDialog:`
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你创建了前面的代码之后，我们将创建一个使用外部函数作为其事件处理程序的事件监听器的`OptionDialog`。我们将在`buttonLaunchDialog`的事件处理程序函数中这样做：
- en: '[PRE3]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'All that is left to do now is create the final event handler function for our
    `OptionDialog`. Add the following function to your code before the `buttonLaunchDialog''s`
    event listener:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的就是为我们的`OptionDialog`创建最终的事件处理函数。在`buttonLaunchDialog`的事件监听器之前添加以下函数到你的代码中：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Try launching your code now in either the iPhone or Android emulator. As seen
    in the following example screenshots, you should be able to click on the button
    and execute the launch of the `OptionDialog` through the button's event handler,
    which in turn can then show an alert executed via the `optionDialogEventHandler:`
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试在iPhone或Android模拟器中启动你的代码。如以下示例截图所示，你应该能够点击按钮并通过按钮的事件处理程序启动`OptionDialog`的执行，该处理程序反过来可以通过`optionDialogEventHandler:`执行一个警告。
- en: '![How to do it…](img/3968EXP_06_02.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点…](img/3968EXP_06_02.jpg)'
- en: How it works…
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'First, it''s important to reiterate the difference between the event handler
    and the event listener. The code that listens for a particular event, such as
    ''click'', and then attaches a particular function in response is called the event
    listener. The code that handles the response to an event is called an event handler.
    In this recipe, we have shown that event listeners can be launched directly via
    user interaction, such as a button click, and that event handlers can be executed
    in one of the following two ways:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，重要的是要重申事件处理程序和事件监听器之间的区别。监听特定事件（如'click'）并相应地附加特定函数的代码称为事件监听器。处理事件响应的代码称为事件处理程序。在本食谱中，我们展示了事件监听器可以直接通过用户交互（如按钮点击）启动，并且事件处理程序可以通过以下两种方式之一执行：
- en: Our first method is inline, that is, the event handler function is declared
    directly within the event listener, such as `buttonLaunchDialog.addEventListener('click',
    function(e){} )`;. This is great for quick execution of code that is perhaps used
    once for a simple task, but does not have a great deal of code reuse.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的第一种方法是内联的，也就是说，事件处理函数直接在事件监听器中声明，例如`buttonLaunchDialog.addEventListener('click',
    function(e){} )`;。这对于快速执行可能只用于简单任务的代码来说很棒，但代码复用性不高。
- en: 'The second method, and a much more preferable way of using an event handler,
    is to write it as a separate, self-contained function, such as:'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种方法，以及使用事件处理程序的一个更受欢迎的方式，是将它编写为一个独立的、自包含的函数，例如：
- en: '[PRE5]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This method allows you to get much greater code reuse, and is generally considered
    a much neater way of organizing your source code.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种方法允许你获得更高的代码复用性，并且通常被认为是一种更整洁的源代码组织方式。
- en: Passing event data between your app and a Webview using custom events
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件在您的应用和Webview之间传递事件数据
- en: While we can use the events built into the Titanium API to suit 90 percent of
    our general purposes, what happens when we want to launch an event that's not
    covered by one of the standard Titanium components? Luckily for us, Titanium already
    has this covered with the `fireEvent` method in our `Titanium.App` namespace!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以使用钛金API内置的事件来满足我们90%的一般需求，但当我们想要启动一个标准钛金组件未涵盖的事件时会发生什么？幸运的是，钛金已经通过我们`Titanium.App`命名空间中的`fireEvent`方法为我们解决了这个问题！
- en: FireEvent allows you to execute an arbitrary event with an event listener name
    that you determine, and then listen for that event in your code. In this recipe,
    we are going to get a little bit tricky and write some code that copies an input
    field's data and displays it on a label back in our app. We will do this by firing
    off a custom event from within a Webview, which we'll then listen for and respond
    to back in our Titanium window.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`FireEvent`允许你执行一个任意事件，该事件具有你确定的监听器名称，然后在你的代码中监听该事件。在本食谱中，我们将稍微复杂一些，编写一些代码，将输入字段的
    数据复制并显示在我们的应用中的标签上。我们将通过从Webview中触发一个自定义事件来完成此操作，然后我们将在钛金窗口中监听并响应该事件。'
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    3` folder.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 6/Recipe 3`文件夹中找到。
- en: How to do it…
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open up the `app.js` file in your editor, and below your declaration of the
    `win2` object, type in the following code to create the Webview:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`app.js`文件，并在`win2`对象的声明下方输入以下代码以创建Webview：
- en: '[PRE6]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, create a new HTML file and call it `webevent.html`, with the following
    code. When you have finished, save the HTML file to your project `Resources` folder.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个新的 HTML 文件，并将其命名为 `webevent.html`，以下代码。完成之后，将 HTML 文件保存到你的项目 `Resources`
    文件夹中。
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All that is left to do now is create the event handler back in our `app.js`
    file which will copy the input field data from our HTML file as you type in it,
    and then add our `webview` to the Window. Write the following code below your
    initial `webview` object declaration in the `app.js` file:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是在我们 `app.js` 文件中创建事件处理程序，它将在你输入时从我们的 HTML 文件中复制输入字段数据，然后将我们的 `webview`
    添加到窗口中。在 `app.js` 文件中你的初始 `webview` 对象声明下方写下以下代码：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Run your app in the emulator now and you should be able type in the input field
    that is within our Webview to see the results mirrored on the label that we positioned
    above it! You should be able to see a screen just like the one pictured here:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在模拟器中运行你的应用，你应该能够输入位于我们 Webview 内的输入字段，并看到结果在位于其上方的标签上镜像！你应该能看到一个与这里图片中一样的屏幕：
- en: '![How to do it…](img/3968EXP_06_03.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作…](img/3968EXP_06_03.jpg)'
- en: How it works…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Basically, our event fired from the `Titanium.App.fireEvent` method creates
    a cross-context application event that any JavaScript file can listen to. However,
    there are two caveats to this. First, the event can only be handled if the same
    event name is used in both your `fireEvent` call and your listener. As with app
    properties, this event name is case-sensitive so make sure it is spelled exactly
    the same way throughout all parts of your application code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们从 `Titanium.App.fireEvent` 方法触发的事件创建了一个跨上下文的应用程序事件，任何 JavaScript 文件都可以监听。然而，这里有两个注意事项。首先，只有当你的
    `fireEvent` 调用和监听器中使用相同的事件名称时，事件才能被处理。与应用程序属性一样，这个事件名称也是大小写敏感的，所以请确保在应用程序代码的所有部分中拼写完全相同。
- en: Second, you must pass an object back even if it is empty, and that object must
    be in a JSON serialized format. This standardization ensures that your data payload
    is always transportable between contexts.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，即使对象为空，你也必须返回一个对象，并且该对象必须以 JSON 序列化格式存在。这种标准化确保了你的数据负载始终可以在不同上下文之间传输。
- en: There's more…
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'It''s also possible to remove an event listener from your code should you no
    longer need it. You can do this by calling `Titanium.App.removeEventListener`
    and passing it the name of your event. Note that it is still case-sensitive, so
    your event name must match exactly! An example for our application of removing
    the `webviewEvent` would be:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不再需要，也可以从你的代码中移除事件监听器。你可以通过调用 `Titanium.App.removeEventListener` 并传递事件名称来实现。请注意，它仍然是大小写敏感的，所以你的事件名称必须完全匹配！对于我们应用中移除
    `webviewEvent` 的一个示例将是：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
