- en: Chapter 6. Getting to Grips with Events and Properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing app properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Firing and capturing events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing event data between your app and a WebView using custom events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter describes the processes of two fundamentally important, yet deceptively
    simple, parts of the Titanium framework. In this chapter, we'll explain how to
    go about creating and reading app properties so that you can store data that is
    accessible from any part of your application. This is similar to how session data
    or cookies would work if you were building a web-based app.
  prefs: []
  type: TYPE_NORMAL
- en: We'll also go into further detail on events, including a selection of those
    fired by the various components in Titanium, and custom events that you can define
    yourself.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties are used for storing data in key/value pairs. These properties
    can persist between your app's windows, and even beyond single application sessions,
    much like a website cookie. You can use any combination of upper case or lower
    case letters and numbers in a property name, but you should mix them with care
    as JavaScript is case-sensitive. In this regard, `Myname, myname`, and `MYNAME`
    would be three very different properties!
  prefs: []
  type: TYPE_NORMAL
- en: When should you use app properties?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Application properties should be used when one or more of the following points
    are true:'
  prefs: []
  type: TYPE_NORMAL
- en: The data consists of simple key/value pairs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data is related to the application rather than the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The data does not require other data in order to be meaningful or useful
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There only needs to be one version of the data stored at any one time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, storing a string/string key pair of `data_url` and "[http://mywebsite.com/data.xml](http://mywebsite.com/data.xml)"
    would be a valid way to use app properties. This URL could be re-used throughout
    all of your application screens/windows and is related to your application, rather
    than your data.
  prefs: []
  type: TYPE_NORMAL
- en: If your data is complex and needs to be joined, ordered, or queried when retrieving
    it, then you are better off using a local database built with SQLite. If your
    data is a file or large blob object, (for example, an image) then this is better
    stored on the filesystem, in the manner described in our previous recipe.
  prefs: []
  type: TYPE_NORMAL
- en: What object types can be stored as app properties?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are currently five distinct types of objects that can be stored in the
    app properties module. These include:'
  prefs: []
  type: TYPE_NORMAL
- en: Booleans
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Doubles (float values)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Strings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lists (arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the following recipe, we will create a number of app properties and then
    read them back, printing them out to the console as we do so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this entire chapter can be found in the `/Chapter 6/EventsAndProperties`.
  prefs: []
  type: TYPE_NORMAL
- en: Reading and writing app properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether reading or writing values, all app properties are accessed from the
    `Titanium.App.Properties` namespace. In this recipe, we are going to create a
    number of properties, all with different types, on the first tab window of our
    app. We will then read them and output their values to the console from a button
    in the second tab window. We'll also show you how to check the existence of a
    property using the `hasProperty` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    1` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter in `EventsAndProperties`
    as the name of the app, and fill in the rest of the details with your own information.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is, *com.packtpub.eventsandproperties)*. This identifier cannot
    be easily changed after the project is created and you will need to match it *exactly*
    when creating provisioning profiles for distributing your apps later on.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `app.js` file in your editor and leave the existing code, except
    for the declaration of the two labels and the lines where those labels are added
    to your tab Windows. After the declaration of the `win1` object, type in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, while still in your `app.js` file, add the following code. It should be
    placed after the declaration of the `win2` object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, launch the emulator from Titanium Studio and you should see the standard
    2-tab navigation view, with a button in each view. Clicking on the **Set** button
    on the first tab will set your app properties. After you have done so, you can
    use the buttons on the second tab view to read back individual properties and
    check the existence of a property. The results will appear in your Titanium Studio
    console, similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we are setting a number of app properties, using our **Set Properties!**
    button. Each property consists of a key/value pair, and therefore requires a property
    name (also called the 'key') and a property value. To set a property, we use the
    `set` method, which looks similar to `Titanium.App.Properties.set<type>(key,value)`.
    We are then retrieving our app properties by using the `get` method, which looks
    similar to `Titanium.App.Properties.get<type>(key,value)`.
  prefs: []
  type: TYPE_NORMAL
- en: Application properties are loaded into memory as the app launches, and exist
    in the global scope of the app until either it is closed, or the property is removed
    from memory using the `Titanium.App.Properties.remove()` method. While there is
    a memory overhead in using properties in this manner, it means you can efficiently
    and quickly access them from any part of your application as they are effectively
    global in scope.
  prefs: []
  type: TYPE_NORMAL
- en: You can also access the entire list of properties stored at any given time using
    the `Titanium.App.Properties.listProperties` method.
  prefs: []
  type: TYPE_NORMAL
- en: Firing and capturing events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of Titanium is built around the concept of event-driven programming. If
    you have ever written code in Visual Basic, C#, Java or any number of event-driven,
    object-orientated languages, this concept will already be familiar to you.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a user interacts with a part of your application's interface, or types
    something in a `TextField`, an event occurs. The event is simply the action the
    user took (for example, a tap, a scroll, or a key press on the virtual keyboard)
    and where it took place (for example, on a button, or in this `TextField)`. Additionally,
    some events can indirectly cause other events to fire. For example, when the user
    selects a menu item that opens a window, it causes another event—the opening of
    the window.
  prefs: []
  type: TYPE_NORMAL
- en: There are basically two fundamental types of events in Titanium; those you define
    yourself (a custom event), and those already defined by the Titanium API (a button
    click event is a good example).
  prefs: []
  type: TYPE_NORMAL
- en: In the following recipes, we will explore a number of Titanium-defined events
    before showing you how to create custom events that can pass data between your
    app and a Webview.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned in the previous recipe, the user can also indirectly cause events
    to occur. Buttons, for example, have an event called 'click', which occurs when
    the user clicks on the button on the screen. The code that handles the response
    to an event is called an event handler.
  prefs: []
  type: TYPE_NORMAL
- en: There are many events that can occur to each object in your Titanium application.
    The good news is that you don't need to learn about all of them, and those that
    are already defined are listed in the Titanium API. You simply need to know how
    they work and how the event data is accessed so you can find out if the object
    is able to respond to that event.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will explore the events that occur from a number of common
    components, using the `OptionDialog` as an example, and explain how to access
    the properties of those events. We'll also explain how to create a function that
    passes the resulting event back to our executing code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    2` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `app.js` file in your editor, and below your declaration of the
    `win1` object, type in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, after you have created the previous code, we are going to create an `OptionDialog`
    with an event listener that uses an external function as its event handler. We'll
    do this in the event handler function for the `buttonLaunchDialog:`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do now is create the final event handler function for our
    `OptionDialog`. Add the following function to your code before the `buttonLaunchDialog''s`
    event listener:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Try launching your code now in either the iPhone or Android emulator. As seen
    in the following example screenshots, you should be able to click on the button
    and execute the launch of the `OptionDialog` through the button's event handler,
    which in turn can then show an alert executed via the `optionDialogEventHandler:`
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, it''s important to reiterate the difference between the event handler
    and the event listener. The code that listens for a particular event, such as
    ''click'', and then attaches a particular function in response is called the event
    listener. The code that handles the response to an event is called an event handler.
    In this recipe, we have shown that event listeners can be launched directly via
    user interaction, such as a button click, and that event handlers can be executed
    in one of the following two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Our first method is inline, that is, the event handler function is declared
    directly within the event listener, such as `buttonLaunchDialog.addEventListener('click',
    function(e){} )`;. This is great for quick execution of code that is perhaps used
    once for a simple task, but does not have a great deal of code reuse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second method, and a much more preferable way of using an event handler,
    is to write it as a separate, self-contained function, such as:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method allows you to get much greater code reuse, and is generally considered
    a much neater way of organizing your source code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing event data between your app and a Webview using custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we can use the events built into the Titanium API to suit 90 percent of
    our general purposes, what happens when we want to launch an event that's not
    covered by one of the standard Titanium components? Luckily for us, Titanium already
    has this covered with the `fireEvent` method in our `Titanium.App` namespace!
  prefs: []
  type: TYPE_NORMAL
- en: FireEvent allows you to execute an arbitrary event with an event listener name
    that you determine, and then listen for that event in your code. In this recipe,
    we are going to get a little bit tricky and write some code that copies an input
    field's data and displays it on a label back in our app. We will do this by firing
    off a custom event from within a Webview, which we'll then listen for and respond
    to back in our Titanium window.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Complete source code for this recipe can be found in the `/Chapter 6/Recipe
    3` folder.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open up the `app.js` file in your editor, and below your declaration of the
    `win2` object, type in the following code to create the Webview:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now, create a new HTML file and call it `webevent.html`, with the following
    code. When you have finished, save the HTML file to your project `Resources` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'All that is left to do now is create the event handler back in our `app.js`
    file which will copy the input field data from our HTML file as you type in it,
    and then add our `webview` to the Window. Write the following code below your
    initial `webview` object declaration in the `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Run your app in the emulator now and you should be able type in the input field
    that is within our Webview to see the results mirrored on the label that we positioned
    above it! You should be able to see a screen just like the one pictured here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it…](img/3968EXP_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Basically, our event fired from the `Titanium.App.fireEvent` method creates
    a cross-context application event that any JavaScript file can listen to. However,
    there are two caveats to this. First, the event can only be handled if the same
    event name is used in both your `fireEvent` call and your listener. As with app
    properties, this event name is case-sensitive so make sure it is spelled exactly
    the same way throughout all parts of your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Second, you must pass an object back even if it is empty, and that object must
    be in a JSON serialized format. This standardization ensures that your data payload
    is always transportable between contexts.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s also possible to remove an event listener from your code should you no
    longer need it. You can do this by calling `Titanium.App.removeEventListener`
    and passing it the name of your event. Note that it is still case-sensitive, so
    your event name must match exactly! An example for our application of removing
    the `webviewEvent` would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
