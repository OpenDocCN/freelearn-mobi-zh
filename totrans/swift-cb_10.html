<html><head></head><body><div id="sbo-rt-content"><section>&#13;
&#13;
                            <header class="header-title chapter-title">&#13;
                    SwiftUI and Combine Framework&#13;
                </header>&#13;
            &#13;
            <article>&#13;
                &#13;
<p>At the Apple <strong>Worldwide Developer Conference</strong> (<strong>WWDC</strong>) in 2019, Apple took a lot of us by surprise with the announcement of SwiftUI, a brand new <strong>user interface</strong> (<strong>UI</strong>) framework written from the ground up, entirely in Swift.</p>&#13;
<p>Making use of the declarative programming paradigm, SwiftUI not only offers a powerful way to programmatically create and design your UI but a functional and logical approach too.</p>&#13;
<p>Alongside many other announcements at WWDC 19, Apple also announced its very own entry into the reactive programming stream with a new framework called <strong>Combine</strong>. Combine replaces the traditional delegate pattern most of us will be accustomed to in iOS and macOS development.</p>&#13;
<p>With SwiftUI's change to the dynamics of how UI patterns are written programmatically, Combine is a welcome addition alongside the SwiftUI framework. In this chapter, we'll take a tour of the inner workings of SwiftUI and how to build our very own app—alongside this, we'll integrate the power of Combine to give us a truly unique and reactive workflow.</p>&#13;
<p class="mce-root">In this chapter, we will cover the following recipes:</p>&#13;
<ul>&#13;
<li>Declarative syntax</li>&#13;
<li>Function builders, property wrappers, and o<span>paque return types</span></li>&#13;
<li>Building simple views in SwiftUI</li>&#13;
<li>Combine and data flow in SwiftUI</li>&#13;
</ul>&#13;
<h1 id="uuid-0d23d028-ae83-4f3e-a46a-d3c2e496c20d">Technical requirements</h1>&#13;
<p>You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10">https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter10</a><a href="https://github.com/PacktPublishing/Swift-5.3-Cookbook-Second-Edition/tree/master/Chapter10" target="_blank"/></p>&#13;
<p>Check out the following video to see the Code in Action: <a href="https://bit.ly/3qE2mpv" target="_blank">https://bit.ly/3qE2mpv</a></p>&#13;
<h1 id="uuid-72dc5b1d-2be1-49c2-b7e6-daeeccd827cb">Declarative syntax</h1>&#13;
<p>With the introduction of SwiftUI comes a new coding paradigm called declarative syntax. Well, I say "new"—it's actually been around for a while; it's just something we've never really used in iOS or macOS development. In this section, we'll take a look at what exactly declarative syntax is and how it compares to the style of syntax we might be used to seeing already.</p>&#13;
<h2 id="uuid-9cd61b9d-3943-40b9-b8a5-be164f94fee5">Getting ready</h2>&#13;
<p>For this section, you'll need the latest version of Xcode available from the Mac App Store.</p>&#13;
<h2 id="uuid-a7720046-c2a9-489a-a5d1-2dc18f5d536f">How to do it...</h2>&#13;
<ol>&#13;
<li>Open Xcode and select <span class="packt_screen"><strong>File</strong></span> | <span class="packt_screen"><strong>New</strong></span> | <strong><span class="packt_screen">Playground</span></strong>, then select <em><strong><span class="packt_screen">Blank</span></strong></em> in order to open a new Playground canvas to work from.</li>&#13;
<li>Once open, add in the following syntax:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import PlaygroundSupport<br/><strong>import SwiftUI</strong></pre>&#13;
<p style="padding-left: 60px">The first <kbd>import</kbd> statement we've seen before and should be familiar with already. The next is our one for SwiftUI—pretty self-explanatory as to why we need this.</p>&#13;
<ol start="3">&#13;
<li>Now, let's create a view in SwiftUI by adding in the following highlighted code:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">import PlaygroundSupport<strong><br/></strong>import SwiftUI<strong><br/><br/>struct MyView: View {</strong><br/><strong>    var body: some View {</strong><br/><strong>        VStack {</strong><br/><strong>            Text("Swift Cookbook")</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/><strong>}</strong><br/><br/></pre>&#13;
<p style="padding-left: 60px">All SwiftUI views are built in a struct that conforms to the <kbd>View</kbd> type—this then houses another struct, which looks a bit like a computed property called <kbd>body</kbd>, which in turn conforms to <kbd>some View</kbd>. Inside this property—or "function builder", as it's known (which we'll touch on later in this chapter)—we have certain elements that start to make up our UI.</p>&#13;
<p style="padding-left: 60px">There is a <kbd>VStack</kbd> or <strong>vertical stack</strong>, which will wrap all enclosing views "vertically" within itself. A VStack is, again, a <kbd>View.</kbd></p>&#13;
<p style="padding-left: 60px">Inside here, we have a <kbd>Text()</kbd> view where we set our text to be displayed.</p>&#13;
<ol start="4">&#13;
<li>If we add the following to our Playground, we'll be able to see our SwiftUI in action:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">PlaygroundPage.current.setLiveView(MyView())</pre>&#13;
<p>However, where does the declarative syntax come into all this? Well, it already has done; you've written it, right there in your struct. Let's dig a little deeper into how declarative syntax works.</p>&#13;
<h2 id="uuid-d276a4b4-87b5-4c60-8d13-3178e312f72f" class="mce-root">How it works...</h2>&#13;
<p><span>In SwiftUI everything is made from Views, from the main container that is presented to the app's window, to text, a button, or even a toggle.</span></p>&#13;
<p><span>Thinking back to how UIKit works, this theory isn't too dissimilar—most objects are a subclass of </span><kbd>UIView()</kbd><span>.</span></p>&#13;
<p><span>The only fundamental difference is that with SwiftUI, the layout and construction of all this is much more visible; this is the declarative syntax coming into play. The best way to think about declarative syntax is in a functional and logical way.</span></p>&#13;
<p>I want to vertically align items on my view:</p>&#13;
<pre><strong>VStack {}</strong></pre>&#13;
<p>I then want to add a <kbd>Text</kbd> box:</p>&#13;
<pre><strong>Text("Swift Cookbook")</strong></pre>&#13;
<pre><strong> </strong></pre>&#13;
<p>Then, let's add a button:</p>&#13;
<pre>Button(action: {<br/>    <strong>print("Set Action Here...")</strong><br/>}, label: {<br/>    <strong>Text("I'm going to perform an action")</strong><br/>})</pre>&#13;
<p>Even the construction of the button is declarative itself: <em><strong>set an action</strong></em>; <em><strong>set a label</strong></em>.<em> </em>Everything is just... functional.</p>&#13;
<p>Another way to think of this would be similar to how we would work through a food recipe:</p>&#13;
<ol>&#13;
<li>Chop onions.</li>&#13;
<li>Fry onions.</li>&#13;
<li>Add seasoning.</li>&#13;
<li>And so on...</li>&#13;
</ol>&#13;
<p>With our more traditional style of programming (or <strong>imperative</strong> programming, as it's known), you might perform things a little differently and a little less logically: </p>&#13;
<ol>&#13;
<li>Get seasoning </li>&#13;
<li>Get onion </li>&#13;
<li>Peel onion</li>&#13;
<li>Chop onion</li>&#13;
<li>Heat pan</li>&#13;
<li>And so on...</li>&#13;
</ol>&#13;
<p>While with declarative syntax all the preceding steps still need to exist to make it work, the framework that it is written on does a lot of the work for you—we just simply "tell it" what to do.</p>&#13;
<h2 id="uuid-bd0cbe1e-e327-49e2-bca9-c05a1860e593" class="mce-root">There's more...</h2>&#13;
<p>Declarative syntax has been around for a while now; you may have used it before without even realizing it. Let's take a look at the following <strong>Structured Query Language</strong> (<strong>SQL</strong>) syntax:</p>&#13;
<pre>SELECT column1, column2, ...<br/>FROM table_name<br/>WHERE condition;</pre>&#13;
<p>Notice anything familiar? That's right: declarative syntax right there... give me <kbd>column1</kbd> and <kbd>column2</kbd> from a <em><strong>particular table</strong></em> where this <kbd>condition</kbd> is met.</p>&#13;
<p>Most recently, the declarative syntax has been making its way into even more UI frameworks such as Google's Flutter and, most recently, into Android's new Jetpack Compose, both of which use a declarative syntax style to allow developers and designers to build a UI.</p>&#13;
<p>We've mentioned a few times already that declarative syntax gives us a much more functional and logical approach to programming. They are paradigms that sit beneath the declarative paradigm as a whole. SQL, for example, sits within <strong>DSL</strong> (<strong>Domain-Specific Language</strong>), along with HTML and other markup languages.</p>&#13;
<h2 id="uuid-31c1d4ee-eac7-452d-bd49-6ce260b86cfa" class="mce-root">See also</h2>&#13;
<ul>&#13;
<li>Android Jetpack Compose: <a href="https://developer.android.com/jetpack/compose">https://developer.android.com/jetpack/compose</a></li>&#13;
<li>Google's Flutter: <a href="https://flutter.dev/">https://flutter.dev/</a></li>&#13;
</ul>&#13;
<h1 id="uuid-e84f3e97-326f-4c30-9df7-d852fb8be5fc"><span>Function builders, property wrappers, and o</span><span>paque return types</span></h1>&#13;
<p>SwiftUI certainly brings a lot to the table, especially as it's been built from the ground up using Swift at its core. This itself has a plethora of benefits, which include making use of some of the features we are about to cover in this section.</p>&#13;
<h2 id="uuid-15ba41a3-7150-4c47-b44d-3e31a3951aac">Getting ready</h2>&#13;
<p><span>For this section, you'll need the latest version of Xcode available from the Mac App Store.</span></p>&#13;
<h2 id="uuid-432ca2c6-3aad-4dab-b96c-19b435ce4415" class="mce-root">How to do it...</h2>&#13;
<ol>&#13;
<li>Continuing with our existing Playground project, let's take another look at how things "stack up". We'll start by taking another look at our VStack:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px"><strong>VStack {</strong><br/>    Text("Swift Cookbook")<br/>    Button(action: {<br/>        print("Set Action Here...")<br/>    }, label: {<br/>        Text("I'm going to perform an action")<br/>    })<br/><strong>}</strong></pre>&#13;
<p style="padding-left: 60px">Here is a block of code, which in SwiftUI terms is a View to be displayed. The view is a vertical stack—think <kbd>UITableView</kbd>, but at the same time don't think <kbd>UITableView</kbd>, as it's bad practice to try to compare SwiftUI to UIKit.</p>&#13;
<p style="padding-left: 60px">All the code sitting within our VStack will be displayed vertically and then presented back to the main View, but where is the logic that adds our <kbd>Text()</kbd> and  <kbd>Button()</kbd> views to the <kbd>VStack</kbd>? There's no <kbd>item</kbd> or <kbd>row</kbd> for index (see, it's bad to compare this to <kbd>UITableView</kbd>); there's no <kbd>.add()</kbd> or <kbd>.append()</kbd> function that you would see when building an array. Everything just sits inside what are called <strong>function builders</strong>.</p>&#13;
<ol start="2">&#13;
<li>Let's add another in for good measure:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">VStack {<br/>    Text("Swift Cookbook")<br/>    Button(action: {<br/>        print("Set Action Here...")<br/>    }, label: {<br/>        Text("I'm going to perform an action")<br/>    })<br/><strong>    HStack {</strong><br/><strong>        Text("By Keith &amp; Chris")</strong><br/><strong>        Image(systemName: "book")</strong><br/><strong>    }</strong><br/>}</pre>&#13;
<p style="padding-left: 60px">In the preceding code, we've added an <kbd>HStack</kbd>, which (yep, you guessed it) gives us a horizontal stack of Views—another function builder like before, this time housing a <kbd>Text()</kbd> and an <kbd>Image()</kbd> view. </p>&#13;
<p style="padding-left: 60px">Notice how we've added our <kbd>HStack</kbd> function builder inside our existing VStack? This is like we said before: our Stacks are just Views, so our top-level VStack just treats it like that and our <kbd>HStack</kbd> does all the work of arranging its <kbd>Text()</kbd><span> and </span><kbd>Image()</kbd> views.</p>&#13;
<p style="padding-left: 60px">But what is being returned here? When building Views in functions programmatically, you might expect to see the <kbd>return</kbd> keyword, with the return type specific to the object type being returned.</p>&#13;
<ol start="3">&#13;
<li>However, with Swift 5.1, we can harness the power of <strong>opaque return types</strong>. Let's look back at the body of our SwiftUI view:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct MyView: View {<br/>    var body: <strong>some View</strong> {<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">Notice the <kbd>some View</kbd> <span>return type. T</span>his is an opaque return type and allows SwiftUI to return any type that conforms to the View protocol, such as <kbd>Text</kbd>, <kbd>Button</kbd>, <kbd>Image</kbd>, and so on. Without this, SwiftUI would not be as versatile in terms of allowing us to build up a view, and our view builder would simply not exist.</p>&#13;
<p style="padding-left: 60px">But the beauty of <strong>o</strong><strong>paque return types</strong> is that they are not SwiftUI-specific; they are just a natural evolution of the Swift language, again demonstrating how much SwiftUI has been built from the core Swift programming language.</p>&#13;
<p style="padding-left: 60px">Another thing we see here is the omission of the <kbd>return</kbd> keyword. Again, a new feature introduced in Swift 5.1: our SwiftUI code can now interpret a final return type to be passed back up the View hierarchy. But what about our <kbd>HStack</kbd> or <kbd>VStack</kbd>? Well, as these are <strong>function builders</strong>, they are not being returned back as such; it is more that they are being added to the Stack, which then, in turn, is passed back up.</p>&#13;
<p style="padding-left: 60px">However, there is always the possibility that you may need an <kbd>HStack</kbd> sitting alongside a <kbd>VStack</kbd><strong>, </strong>like so:</p>&#13;
<pre style="padding-left: 60px">VStack { }<br/>HStack {<br/>    Text("I'm sitting underneath a HStack")<br/>}</pre>&#13;
<p style="padding-left: 60px">At this point, the compiler will need a little help. Unfortunately, we can't just add in a <kbd>return</kbd> keyword as we want both to be returned, so we could add these into another Stack—but as we don't really need one that would be unnecessary, so we simply wrap these in a <kbd>Group()</kbd> view instead:</p>&#13;
<pre style="padding-left: 60px"><strong>Group {</strong><br/>    VStack { }<br/>    HStack {<br/>        Text("I'm sitting underneath a HStack")<br/>    }<br/><strong>}</strong></pre>&#13;
<p style="padding-left: 60px">A <kbd>Group</kbd> view itself is another view that can then be passed back up as <kbd>some View</kbd> to our body—nice!</p>&#13;
<ol start="4">&#13;
<li>We're certainly getting all the ingredients together in order to make a start with SwiftUI, but before we get stuck in, let's take a look at another feature introduced in SwiftUI, again from our ever-evolving Swift programming language.</li>&#13;
</ol>&#13;
<p><strong>Property wrappers</strong> in SwiftUI are one of the features that really help make it shine, and are used for a wide variety of things. The main purpose that each one holds is to reduce the amount of maintenance required for your specific view. Let's take a look at some of the more common ones you might use:</p>&#13;
<pre>@State</pre>&#13;
<p><kbd>@State</kbd> allows SwiftUI to modify specific properties of specific views without the need to call a specific function to do so. For example, make the following highlighted changes to your code:</p>&#13;
<pre>struct MyView: View {<br/>    <br/>    <strong>@State var count: Int = 0</strong><br/>    <br/>    var body: some View {<br/>        <br/>        Group {<br/>            VStack {<br/>                Text("Swift Cookbook")<br/>                Button(action: {<br/>                    <strong>count += 1</strong><br/>                }, label: {<br/><strong>                    if actionPerformed &gt; 0 {</strong><br/><strong>                        Text("Performed \(count) times")</strong><br/><strong>                    } else {</strong><br/><strong>                        Text("I'm going to perform an action")</strong><br/><strong>                    }</strong><br/>                })<br/>                HStack {<br/>                    Text("By Keith &amp; Chris")<br/>                    Image(systemName: "book")<br/>                }<br/>            }<br/>            HStack {<br/>                Text("I'm sitting underneath a HStack")<br/>            }<br/>        }<br/>    }<br/>}</pre>&#13;
<p>We've added a variable called <kbd>count</kbd> and have given this the <kbd>@State</kbd> property wrapper, and we now update our button click to increase the integer by <kbd>1</kbd>. Next, we add some logic based on the value of <kbd>count</kbd><strong>.</strong></p>&#13;
<p>By changing the value of <kbd>count</kbd> we have now bound our property that is being used within SwiftUI to the value and any changes that are made, thus invalidating the SwiftUI layout and rebuilding our view using the new value.</p>&#13;
<p>Go ahead—run this in the Playground and try it out for yourself. </p>&#13;
<p><kbd>@Binding</kbd> is another well-used property wrapper specifically used in conjunction with passing values to state properties that may live in another view. Let's take a look at how we might do this, starting by separating out some code and creating another SwiftUI view. We can do this just underneath our current <kbd>MyView</kbd>:</p>&#13;
<pre>struct ResultView: View {<br/>    <br/>    <strong>@Binding var count: Int</strong><br/>    <br/>    var body: some View {<br/>        Text("Performed \(count) times")<br/>    }<br/>}</pre>&#13;
<p>Here, we're simply just creating a SwiftUI view that returns a <kbd>Text</kbd> view, but this is a great way to see how easy it is to separate out specific view logic that you might want to work on separately (or make reusable).</p>&#13;
<p>Notice here we were also using our <kbd>count</kbd> variable, although this time with the <kbd>@Binding</kbd> wrapper. This is because we won't be controlling the value of <kbd>count</kbd> from within this view; this will be done externally back in <kbd>MyView</kbd>:</p>&#13;
<pre>struct MyView: View {<br/>    <br/><strong>    @State var count: Int = 0</strong><br/>    <br/>    var body: some View {<br/>        <br/>        Group {<br/>            VStack {<br/>                Text("Swift Cookbook")<br/>                <br/><strong>                ResultView(count: $count)</strong><br/>                <br/>                Button(action: {<br/><strong>                    count += 1</strong><br/>                }, label: {<br/>                    Text("Perform Action")<br/>                })<br/>                <br/>                HStack {<br/>                    Text("By Keith &amp; Chris")<br/>                    Image(systemName: "book")<br/>                }<br/>            }<br/>            HStack {<br/>                Text("I'm sitting underneath a HStack")<br/>            }<br/>        }<br/>    }<br/>}</pre>&#13;
<p>In the preceding highlighted code, notice we still have our <kbd>@State</kbd> variable, and our <kbd>Button</kbd> action is still updating this value on each press. We've also added in our new <kbd>ResultView</kbd>, passing in our <kbd>@State</kbd> variable and "binding" this to our variable in <kbd>ResultView</kbd><span>, thus forcing a change to that view every time <kbd>count</kbd> is updated. Go ahead and try it for yourself.</span></p>&#13;
<h2 id="uuid-043b519d-7772-49ed-9ce9-70854f2a9adf" class="mce-root">There's more...</h2>&#13;
<p class="mce-root">We've covered some of the property wrappers that you are more than likely to be exposed to with SwiftUI from the outset, but there are plenty more where they came from, some of which we'll cover later on in this chapter, specifically when it comes to working with the Combine framework. However, here is a run-through of some of the others and what they have to offer:</p>&#13;
<pre><strong>@EnvironmentObject</strong></pre>&#13;
<p>Think <span>of this as a</span> global object—sometimes you might want to keep track of certain things throughout your app that you might not necessarily need or feel the need to pass through to every view. However, it's important to know that <kbd>EnvironmentObject</kbd> isn't a single source of truth; it's data—it's merely referencing it from the source, and should the source change, <kbd>EnvironmentObject</kbd> will trigger a state change (which is what we want).</p>&#13;
<p>An example of how we could use this is to create a class we want to observe, conforming to <kbd>ObservableObject</kbd>:</p>&#13;
<pre>class BookStatus: <strong>ObservableObject</strong> {<br/>    @Published var released = true<br/>    @Published var title = ""<br/>    @Published var authors = [""]<br/>}</pre>&#13;
<p>Then, reference it from anywhere in our SwiftUI project, like this:</p>&#13;
<pre><strong>@EnvironmentObject</strong> var bookStatus: BookStatus</pre>&#13;
<p class="mce-root">Another great and certainly convenient property wrapper is <kbd>@AppStorage</kbd>, used as a way to access data stored within <kbd>UserDefaults</kbd>. As of iOS 14, we can incorporate this straight into our SwiftUI views, without the need for additional logic or functions. Let's take a look at how we would do this:</p>&#13;
<pre>@AppStorage("book.title") var title: String = "Book Title"</pre>&#13;
<p>Notice here that we have a default value should there be no data already persisted. If we want to write to this, we simply assign the property a value:</p>&#13;
<pre>title = "Swift Cookbook"</pre>&#13;
<p>Go ahead and try this in your Playground. If you get stuck, have a look at the GitHub resource to see how I did it.</p>&#13;
<p>Due to the architecture of SwiftUI, there is—and will be—an ever-growing list of available property wrappers. We'll cover some more later on in this chapter, but here are some others to be aware of:</p>&#13;
<ul>&#13;
<li><kbd>@GestureState</kbd>—Tracks the current gesture that is being performed</li>&#13;
<li><kbd>@FetchRequest</kbd>—Performs a fetch for Core Data entities</li>&#13;
</ul>&#13;
<h2 id="uuid-118d22d2-de39-4a62-9caa-e3e5471103b8" class="mce-root">See also</h2>&#13;
<ul>&#13;
<li>States: <a href="https://developer.apple.com/documentation/swiftui/state">https://developer.apple.com/documentation/swiftui/state</a></li>&#13;
<li>Bindings: <a href="https://developer.apple.com/documentation/swiftui/binding">https://developer.apple.com/documentation/swiftui/binding</a></li>&#13;
</ul>&#13;
<h1 id="uuid-6c21ec79-9130-487f-b97e-c4c209eccb87">Building simple views in SwiftUI</h1>&#13;
<p>We've covered some of the fundamentals of how SwiftUI is built up from the Swift programming language, but it's time now to get into how we build an actual app in SwiftUI.</p>&#13;
<p>In this section, we'll take everything we've learned so far and apply it in order for us to build a list app similar to the one we created previously.</p>&#13;
<h2 id="uuid-f7c2b4b6-fdd5-4749-9df2-6959b352a0ba">Getting ready</h2>&#13;
<p>For this section, you'll need the latest version of Xcode from the Mac App Store.</p>&#13;
<h2 id="uuid-76903004-c927-4b22-9571-84dcde21d0f4" class="mce-root">How to do it...</h2>&#13;
<ol>&#13;
<li>Let's get going. First, we'll create a brand new project—in Xcode, click on <span class="packt_screen">File</span> | <span class="packt_screen"><strong>New</strong></span> | <strong><span class="packt_screen">Project</span></strong>. Then, select <span class="packt_screen">Single View App</span> and make sure you've selected <kbd>SwiftUI</kbd> for the <span class="packt_screen">Interface</span> style, just like I've done here:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/579ddfcc-c33e-4c4e-bf52-9f3cd99f47ca.png" style="" width="528" height="414"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref">Figure 10.1 – Creating a new project</div>&#13;
<ol start="2">&#13;
<li>Click <span class="packt_screen">Next</span> and select a location on your disk. Once that is done, the familiar site of Xcode should appear; however, you may notice something new. On the right-hand side, you'll see the <span class="packt_screen">Live Window</span> screen. Go ahead and click <span class="packt_screen">Resume</span>—you should see the following:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/ca17d0c7-67b2-47a7-8b3a-1ee0bf71ca2c.png" style="" width="1489" height="1107"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span>Figure 10.2 – Xcode and Live Window screen</span></div>&#13;
<p style="padding-left: 60px">Here, we've got a generated preview of our boilerplate SwiftUI code. Notice our <kbd>ContentView()</kbd> struct, just as we expect with its <strong>body</strong>. Now, look at the struct below it:</p>&#13;
<pre style="padding-left: 60px">struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView()<br/>    }<br/>}</pre>&#13;
<p>This is our <kbd>PreviewProvider</kbd> struct, allowing us to test out our SwiftUI views at design time, without the need to keep rerunning the simulator and rebuilding our application—neat!</p>&#13;
<p>Now, for our initial list, we're going to need some mock data:</p>&#13;
<ol>&#13;
<li>Create the following struct (this can be in a new file if you want):</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct Task: <strong>Identifiable</strong> {<br/>    var description: String<br/>    var category: String<br/>    <strong>var id = UUID()</strong><br/>}</pre>&#13;
<p style="padding-left: 60px">Comparing this to our <kbd>Task</kbd> model in <a href="9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml">Chapter 8</a>, <em>Server-Side Swift</em>, it's pretty much identical in terms of properties and the data we want it to hold. The only difference we've had to make is for our model to conform to <kbd>Identifiable</kbd> and be given a unique ID—this is required by SwiftUI for anything that we are going to iterate around.</p>&#13;
<ol start="2">&#13;
<li>Next, let's create a little helper function for some mock data:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">struct MockHelper {<br/>    static func getTasks() -&gt; [Task] {<br/>        var tasks = [Task]()<br/>        tasks.append(Task(description: "Get Eggs", category: <br/>          "Shopping"))<br/>        tasks.append(Task(description: "Get Milk", category: <br/>          "Shopping"))<br/>        tasks.append(Task(description: "Go for a run", category: <br/>          "Health"))<br/>        return tasks<br/>    }<br/>}</pre>&#13;
<p style="padding-left: 60px">This mock data will come in handy in SwiftUI in more than one way, but we'll get to that shortly. Let's hook this up to our app.</p>&#13;
<ol start="3">&#13;
<li>Back over to our <kbd>ContentView</kbd>, replace the <kbd>Hello World</kbd> text view with the following:</li>&#13;
</ol>&#13;
<pre style="padding-left: 60px">List(MockHelper.getTasks()) { task in<br/>    Text(task.description)<br/>}</pre>&#13;
<p style="padding-left: 60px">Notice something about our <kbd>List()</kbd> view? That's right: another function builder accepts an argument of an array of items, where the items conform to <kbd>Identifiable</kbd>. A variable is given back to us in the closure, representing each one of these items so that we can then use them inside our list builder as we see fit.</p>&#13;
<ol start="4">&#13;
<li>Here, we are just adding the description to a text view for now. If not already showing in the live preview, click <span class="packt_screen">R<strong>esume</strong></span> (sometimes this is needed in Xcode), and you should now see the following:</li>&#13;
</ol>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/f8374630-e7d3-4000-8379-d49bbd66d0bd.png" style="" width="429" height="901"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span> Figure 10.3 – Preview screen</span></div>&#13;
<p>Now, run this in the simulator, and you should see the exact same thing—great job!</p>&#13;
<p>Time for a little refactoring now, so make the following highlighted changes to the <kbd>ContentView</kbd>:</p>&#13;
<pre><strong>var tasks = [Task]()</strong><br/>    <br/>var body: some View {<br/>    List(<strong>tasks</strong>) { task in<br/>        Text(task.description)<br/>    }<br/>}</pre>&#13;
<p class="mce-root">Here, we're removing our call to our mock data helper as, for production code, we shouldn't be calling this in here. With this change, let's head on over to <kbd>PreviewProvider</kbd> and make the following highlighted changes there:</p>&#13;
<pre>struct ContentView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        ContentView(<strong>tasks: MockHelper.getTasks()</strong>)<br/>    }<br/>}</pre>&#13;
<p>As our <kbd>ContentView</kbd> struct now has a non-optional <kbd>tasks</kbd> variable, it requires us to pass some data in; here, we'll pass in our <kbd>MockHelper</kbd> function.</p>&#13;
<p>If not already showing, go ahead and resume the live preview. All being well, everything should be working as expected. However, let's see what happens when we try to run this in the simulator—that's right: no data.</p>&#13;
<p>If you take a closer look at the change we just made, you'll see why we're now only injecting our mock data into our <kbd>ContentView</kbd> via the Preview Provider so that when our actual app runs, our <kbd>tasks</kbd> array is empty.</p>&#13;
<p>But this is right; as we'll be hooking our app up to the <strong>REpresentational State Transfer application</strong> <strong>programming interface</strong> (<strong>REST API</strong>) we created in <a href="9ce1feb3-8fca-4656-91dc-796ba77c3d07.xhtml">Chapter 8</a>, <em>Server-Side Swift</em>, by injecting the mock data via the Preview Provider, we can continue to build our UI long before we build in any networking functionality, so let's continue.</p>&#13;
<p>Remember from the previous section how we refactored out our <kbd>Result</kbd> view? We're going to do the same again here for each row in our <kbd>List</kbd> view.</p>&#13;
<p>Create a new SwiftUI file and call it <kbd>ListRowView</kbd>, then update the boilerplate code to look like the following:</p>&#13;
<pre><strong>var description: String = ""</strong><br/><strong>var category: String = ""</strong><br/>    <br/>var body: some View {<br/><strong>    VStack {</strong><br/><strong>        Text(description)</strong><br/><strong>        Text(category)</strong><br/><strong>    }</strong><br/>}</pre>&#13;
<p>From here, head back over to <kbd>ContentView.swift</kbd> and make the following highlighted changes:</p>&#13;
<pre>var body: some View {<br/>    List(tasks) { task in<br/><strong>        ListRowView(description: task.description,</strong><br/><strong>                    category: task.category)</strong><br/><strong>    }</strong><br/>}</pre>&#13;
<p>Just like before, we're replacing our text view with the view we just created. Click <span class="packt_screen">Resume</span> to view the live preview and see for yourself.</p>&#13;
<p>Now we know that's working, we want to work on the style of our <kbd>ListRowView</kbd> a little, so let's head back on over there now and start by updating the Preview Provider so that we can work from there:</p>&#13;
<pre>struct ListRowView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/><strong>        ListRowView(description: "Description Field",</strong><br/><strong>                    category: "Category Field")</strong><br/>    }<br/>}</pre>&#13;
<p>As you can see from the preceding highlighted code, we've added some mock data for use in our <span class="packt_screen">Live Preview</span>. If this is not already showing, click <span class="packt_screen">Resume</span> and you should see the following:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/174b3e71-a967-4b6b-b60e-a12b0c1424ba.png" style="" width="435" height="900"/></div>&#13;
<div class="CDPAlignCenter CDPAlign packt_figref"><span> Figure 10.4 – Live Preview screen with some mock data</span></div>&#13;
<p>It works but doesn't look much like a <kbd>List</kbd> row, but that's fine—we just need to tell the Preview Provider what we intend to use it for:</p>&#13;
<pre><strong>List {</strong><br/>    ListRowView(description: "Description Field",<br/>                category: "Category Field")<br/><strong>}</strong></pre>&#13;
<p>It really is that simple. We just wrap it around a <kbd>List</kbd> view and SwiftUI does the rest, and we can now get to work on decorating our row.</p>&#13;
<p>Back in the body of our <kbd>ListRowView</kbd>, make the following highlighted changes:</p>&#13;
<pre>var body: some View {<br/>    VStack<strong>(alignment: .leading)</strong> {<br/>        Text(description)<br/><strong>            .font(.title)</strong><br/><strong>            .padding(EdgeInsets(top: 0,</strong><br/><strong>                                leading: 0,</strong><br/><strong>                                bottom: 2,</strong><br/><strong>                                trailing: 0))</strong><br/><strong>            .foregroundColor(.blue)</strong><br/>        Text(category)<br/><strong>            .font(.title3)</strong><br/><strong>            .foregroundColor(.blue)</strong><br/>    }<br/>}</pre>&#13;
<p>Here, we've added modifiers to our views. Modifiers allow us to decorate and style our views just like we would with properties in UIKit, and each modifier is tied specifically to its type of view.</p>&#13;
<p>SwiftUI has gone a little further with some of the modifiers available, giving us a wide variety of options. Let's take the <kbd>.font</kbd> modifier, for example:</p>&#13;
<pre>.font(.largeTitle) // A font with the large title text style.<br/>.font(.title) // A font with the title text style.<br/>.font(.title2) // Create a font for second level hierarchical headings.<br/>.font(.title3) // Create a font for third level hierarchical headings.<br/>.font(.headline) // A font with the headline text style.<br/>.font(.subheadline) // A font with the subheadline text style.<br/>.font(.footnote) // A font with the footnote text style.<br/>.font(.caption) // A font with the caption text style.<br/>.font(.caption2) // Create a font with the alternate caption text <br/>                   // style.</pre>&#13;
<p>The preceding fonts are all available to use straight out of the box; however, if you still want to specify your own font, you can do so by using the following:</p>&#13;
<pre>public static func system(_ style: Font.TextStyle, design: Font.Design <br/>  = .default) -&gt; Font</pre>&#13;
<p>Let's finish off the base of our app by adding in an image based on the category type:</p>&#13;
<pre><strong>HStack {</strong><br/>    VStack(alignment: .leading) {<br/>        Text(description)<br/>            .font(.title)<br/>            <br/>            .padding(EdgeInsets(top: 0,<br/>                                leading: 0,<br/>                                bottom: 2,<br/>                                trailing: 0))<br/>            .foregroundColor(.blue)<br/>        Text(category)<br/>            .font(.title3)<br/>            .foregroundColor(.blue)<br/>    }<br/><strong>    Spacer()</strong><br/><strong>    Image(systemName: "book")</strong><br/><strong>        .foregroundColor(.blue)</strong><br/><strong>        .padding()</strong><br/><strong>}</strong></pre>&#13;
<p>Notice in the preceding code how we've now introduced an <kbd>HStack</kbd> and wrapped this around our current <kbd>VStack</kbd>, which allows us to now add views outside of our original <kbd>VStack</kbd> and align them horizontally, just like we've done with the <kbd>Image</kbd> view.</p>&#13;
<p>The use of the <kbd>Spacer()</kbd> view in SwiftUI has pushed out our two horizontal views (our <kbd>VStack</kbd> on the left and <kbd>Image</kbd> on the right) so that they act as leading and trailing views to the parent view (the body, in this case).</p>&#13;
<h2 id="uuid-b53ef840-485e-4e01-9dc5-545d96570013" class="mce-root">How it works...</h2>&#13;
<p>The base of our app is now ready to hook up to an external data source, but first, let's go over how modifiers work and how we can create our very own. Either add the following code to your <kbd>ListRowView.swift</kbd> file or create a new file (it's up to you):</p>&#13;
<pre>struct CategoryText: ViewModifier {<br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .font(.title3)<br/>            .foregroundColor(.blue)<br/>    }<br/>}</pre>&#13;
<p>Here, we've created a struct called <kbd>CategoryText</kbd> that conforms to the <kbd>ViewModifier</kbd> protocol. In here, there is a function called <kbd>Body</kbd> for which we are setting the modifiers of <kbd>.font</kbd> and <kbd>.foregroundColor</kbd>. These modifiers are available on anything that inherits from <kbd>View</kbd>.</p>&#13;
<p>Feel free to have a play around with some of the modifiers available. You could add the following and really give the <kbd>Category</kbd> label a little punch:</p>&#13;
<pre>struct CategoryText: ViewModifier {<br/>    func body(content: Content) -&gt; some View {<br/>        content<br/>            .font(.footnote)<br/>            .foregroundColor(.blue)<br/><strong>            .padding(4)</strong><br/><strong>            .overlay(</strong><br/><strong>                RoundedRectangle(cornerRadius: 8)</strong><br/><strong>                    .stroke(Color.blue, lineWidth: 2)</strong><br/><strong>                    </strong><br/><strong>            )</strong><br/><strong>            .shadow(color: .grey, radius: 2, x: -1, y: -1)</strong><br/>    }<br/>}</pre>&#13;
<p class="mce-root">Let's now add this to our <kbd>Text</kbd> view:</p>&#13;
<pre>Text(category)<br/>    .modifier(CategoryText())</pre>&#13;
<p>We're using the <kbd>.modifier</kbd> (modifier) in order to call our custom struct; this is good from a readability point of view as it allows you to quickly identify anything that could potentially be custom as opposed to anything that is a system API. However, if you are like me and want it to look just right, simply create an extension of <kbd>View</kbd>:</p>&#13;
<pre>extension View {<br/>    func styleCategory() -&gt; some View {<br/>        self.modifier(CategoryText())<br/>    }<br/>}</pre>&#13;
<p class="mce-root">Then, use it like this:</p>&#13;
<pre>Text(category)<br/>    .styleCategory()</pre>&#13;
<p>You might have noticed we glossed over assigning a specific image to a category. This was with good reason, as I wanted to expand further on the use of SF Symbols within SwiftUI.</p>&#13;
<p>Also available for use with UIKit, SF Symbols works exceptionally well in SwiftUI, especially when used with modifiers like the ones we've just been playing with.</p>&#13;
<p>SF Symbols are exactly what they say they are—symbols (not images), they are fonts and can be treated just like fonts too:</p>&#13;
<pre>Image(systemName: "book")<br/><strong>    .font(.system(size: 32, weight: .regular))</strong><br/>    .foregroundColor(.blue)<br/>    .padding()</pre>&#13;
<p>No need for stretching images or <strong>2x</strong> or <strong>3x</strong> images' assets. SF Symbols will handle this just like having your own vector right in the app, with the added benefit that it's all included in the Swift API without extra assets bulking up your app.</p>&#13;
<p>As the name of the symbol is just written in plain text, let's write a little function that works out what we need to display:</p>&#13;
<pre>struct Helper {<br/>    static func getCategoryIcon(category: String) -&gt; String {<br/>        <br/>        switch category.lowercased() {<br/>        case "shopping":<br/>            return "bag"<br/>        case "health":<br/>            return "heart"<br/>        default:<br/>            return "info.circle"<br/>        }<br/>        <br/>    }<br/>}</pre>&#13;
<p>In an ideal world, our categories would be enums with <kbd>String</kbd> values that we could cast to, but for this demo, a basic string match will suffice. Now, replace the static text in the <kbd>Image</kbd> constructor to call this new static function:</p>&#13;
<pre>Image(systemName: <strong>Helper.getCategoryIcon(category: category)</strong>)</pre>&#13;
<p>The only drawback is the following: is the image you want to use included in the library?</p>&#13;
<p>With iOS 14, Apple introduced a much wider range of SF Symbols. There's even a Mac app you can download that catalogs all these for you in a nice <strong>graphical UI</strong> (<strong>GUI</strong>).</p>&#13;
<h2 id="uuid-8c8df709-31bb-45d1-8522-3162220d7d8f" class="mce-root">There's more...</h2>&#13;
<p>We've touched on the Preview Provider a couple of times so far, but this handy little feature of SwiftUI does have a couple more tricks up its sleeve.</p>&#13;
<p>By default, the device it will preview on will be that of the one currently selected in Xcode, but if you want to change this, simply add in the following:</p>&#13;
<pre>struct ListRowView_Previews: PreviewProvider {<br/>    static var previews: some View {<br/>        List {<br/>            ListRowView(description: "Description Field",<br/>                        category: "Category Field")<br/>        }<br/><strong>        .previewDevice(PreviewDevice(rawValue: "iPhone 12 Pro Max"))</strong><br/><strong>        .previewDisplayName("iPhone 12 Pro Max")</strong><br/>    }<br/>}</pre>&#13;
<p><kbd>.previewDevice</kbd>—This specifies the device you want to use—the raw value string matched that of an internal enum for that specific device (<em>basically the string name as you would see in the simulator list</em>).</p>&#13;
<p><kbd>.previewDisplayName</kbd>—This is a custom name given for that device, as shown in the <span class="packt_screen">Live Preview</span> window.</p>&#13;
<p>The display name can come in handy for other reasons too, specifically if we have more than one preview running:</p>&#13;
<pre>struct <strong>ListRowView_Previews_MockData2</strong>: PreviewProvider {<br/>    static var previews: some View {<br/>        List {<br/>            ListRowView(description: "Very Long Description Field, Very <br/>              Long Description Field", category: "Very Long Category <br/>                Field, Very Long Category Field")<br/>        }<br/>        .previewDevice(PreviewDevice(rawValue: "iPhone 12 Pro"))<br/><strong>        .previewDisplayName("iPhone 12 Pro - Data #2")</strong><br/>    }<br/>}</pre>&#13;
<p>As highlighted, we've created an additional preview to run in our <span class="packt_screen">Live Preview</span> window, which in turn passes in different data and tests on a different device.</p>&#13;
<p>With this, we could create mock data for every condition or style we wanted and have them previewing on all manner of device types, allowing us to test right there without the need to launch each version on a simulator.</p>&#13;
<p>SwiftUI is no doubt powerful and, especially with the latest release of iOS 14 at WWDC 2020, things have improved vastly, but we must not forget that at less than 2 years old it's still well within its infancy, and there will be more than one occasion when you'll need to revert back to UIKit for some form of component. </p>&#13;
<p>Luckily for us, Apple has us ready to go with <kbd>UIViewRepresentable</kbd>, a protocol that we can use to harness UIKit components and return them as SwiftUI views.</p>&#13;
<p>A good example would be <kbd>UITextView()</kbd>, currently not available in SwiftUI or any direct equivalent (<em>although with iOS 14, TextEditor for SwiftUI now does a lot of what we want, but is still not a direct replacement as such</em>).</p>&#13;
<p>Create a new Swift file and call it <kbd>TextView</kbd>, then start by pasting the following methods in one by one:</p>&#13;
<pre>struct TextView: UIViewRepresentable {<br/> <br/>    @Binding var text: String<br/> <br/>    func makeUIView(context: Context) -&gt; UITextView {<br/>        <br/>        let textView = UITextView()<br/>        return textView<br/>    }<br/>    <br/>}</pre>&#13;
<p>Our <kbd>UIViewRepresentable</kbd> protocol requires us to conform to certain functions such as <kbd>makeUIView()</kbd>, which is, in turn, responsible for instantiating the UIKit component we want to wrap.</p>&#13;
<p>Next, add the following:</p>&#13;
<pre>struct TextView: UIViewRepresentable {<br/> <br/>    // ...<br/> <br/><strong>    func updateUIView(_ uiView: UITextView, context: Context) {</strong><br/><strong>        uiView.text = text</strong><br/><strong>    }</strong><br/><br/><strong>    func makeCoordinator() -&gt; Coordinator {</strong><br/><strong>        Coordinator($text)</strong><br/><strong>    }</strong><br/>     <br/>    // ...<br/>    <br/>}</pre>&#13;
<p>With <kbd>updateUIView()</kbd>, we set the instance of our <kbd>UITextView</kbd> with whatever we want. Here, we are setting the <kbd>text</kbd> value from our variable.</p>&#13;
<p>Next, we'll add the <kbd>makeCoordinator()</kbd> function, which returns an instance of <kbd>Coordinator</kbd>, padding in our <kbd>@Binding</kbd> text field. The best way to think about the <kbd>Coordinator</kbd> is as a way of handling the delegate methods we might use for our UIKit component. Add in the following, and this should make more sense:</p>&#13;
<pre>struct TextView: UIViewRepresentable {<br/> <br/>    // ...<br/><br/><strong>    class Coordinator: NSObject, UITextViewDelegate {</strong><br/><strong>        var text: Binding&lt;String&gt;</strong><br/><strong>     </strong><br/><strong>        init(_ text: Binding&lt;String&gt;) {</strong><br/><strong>            self.text = text</strong><br/><strong>        }</strong><br/><strong>     </strong><br/><strong>        func textViewDidChange(_ textView: UITextView) {</strong><br/><strong>            self.text.wrappedValue = textView.text</strong><br/><strong>        }</strong><br/><strong>    }</strong><br/>    <br/>}</pre>&#13;
<p>See how our <kbd>Coordinator</kbd> conforms to <kbd>UITextViewDelegate</kbd>, and we have <kbd>textViewDidChange()</kbd> in there. As our text variable being passed in is a <kbd>Binding</kbd> string, changes made will reflect in the delegate method being called, just as they would in UIKit:</p>&#13;
<pre>@State var textViewString = ""<br/>TextView(text: $textViewString)</pre>&#13;
<p>In order to call this, we would simply add this as we would any other SwiftUI view.</p>&#13;
<h2 id="uuid-8baa13a2-2b5d-46e3-95fa-fc1259016b22" class="mce-root">See also</h2>&#13;
<p>SF Symbols Mac app: <a href="https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/">https://developer.apple.com/design/human-interface-guidelines/sf-symbols/overview/</a></p>&#13;
<p><kbd>UIViewRepresentable</kbd>: <a href="https://developer.apple.com/documentation/swiftui/uiviewrepresentable">https://developer.apple.com/documentation/swiftui/uiviewrepresentable</a></p>&#13;
<h1 id="uuid-22b777e2-9bc8-4473-b551-e5f798330ead"><span>Combine and data flow in SwiftUI</span></h1>&#13;
<p>For many years, the reactive programming stream has played a big part in development architecture in terms of iOS and macOS. You may have heard of RxSwift and RxCocoa, a massive community committed to the reactive stream that allows for asynchronous events to be processed.</p>&#13;
<p>If you are not familiar with the terminology of Rx or reactive programming, you may have seen the use of <strong>Publishers</strong>, <strong>Subscribers</strong>, and <strong>Operators</strong> in your code base. If you have, then you've most likely been subject to reactive programming at some point.</p>&#13;
<p>In this section, we are going to take a look at Apple's offering for reactive programming, called <strong>Combine</strong>. Introduced alongside SwiftUI at WWDC 2019, Combine is the perfect accompaniment for the new layout and structure of SwiftUI (although not bound solely to SwiftUI). We'll take a look at how we can create a seamless flow of data from our REST API, right up to our UI layer.</p>&#13;
<h2 id="uuid-185f419f-ad63-4524-aeb5-aeb0bebde8df">Getting ready</h2>&#13;
<p><span>For this section, you'll need the latest version of Xcode from the Mac App Store and the project from the previous section.</span></p>&#13;
<h2 id="uuid-3f71c736-7e5b-400e-9d77-8b466a799fec" class="mce-root">How to do it...</h2>&#13;
<p>First, we'll start by updating our <kbd>Task</kbd> model to a class, by making the following highlighted changes:</p>&#13;
<pre><strong>class</strong> Task: Identifiable {<br/>    <br/>    var id = UUID()<br/>    <br/>    <strong>let response: TaskResponse</strong><br/><strong>    </strong><br/><strong>    init(taskResponse: TaskResponse) {</strong><br/><strong>        self.response = taskResponse</strong><br/><strong>    }</strong><br/><strong>    </strong><br/><strong>    var category: String {</strong><br/><strong>        return response.category ?? ""</strong><br/><strong>    }</strong><br/><strong>    </strong><br/><strong>    var description: String {</strong><br/><strong>        return response.description ?? ""</strong><br/><strong>    }</strong><br/>    <br/>}</pre>&#13;
<p>Here, we've converted our model to a class (more on that later), and have added a custom initializer and a couple of computed properties too.</p>&#13;
<p>We've also added a variable of type <kbd>TaskResponse</kbd>, so let's go ahead and create that now in a new file:</p>&#13;
<pre>struct TaskResponse: Codable {<br/>    let category: String?<br/>    let description: String?<br/>}</pre>&#13;
<p>Here, we have a basic codable response from the REST API we created earlier.</p>&#13;
<p>Now, for a bit of boilerplate networking code; create a new file called <kbd>NetworkManager.swift</kbd> and add the following code into it:</p>&#13;
<pre>class NetworkManager {<br/>    <br/>    static func loadData(url: URL, completion: @escaping <br/>      ([TaskResponse]?) -&gt; ()) {<br/>        <br/>        URLSession.shared.dataTask(with: url) { data, response, error <br/>          in<br/>            <br/>            guard let data = data, error == nil else {<br/>                completion(nil)<br/>                return<br/>            }<br/>            <br/>            if let response = try? JSONDecoder().decode(<br/>              [TaskResponse].self, from: data) {<br/>                DispatchQueue.main.async {<br/>                    completion(response)<br/>                }<br/>            }<br/>        }.resume()<br/>        <br/>    }<br/>    <br/>}</pre>&#13;
<p>Here, we have a basic implementation of <kbd>URLSession</kbd>, which is being passed a <strong>Uniform Resource Locator</strong> (<strong>URL</strong>), parsing the <strong>JavaScript Object Notation</strong> (<strong>JSON</strong>) response into a <kbd>Codable</kbd> object (our <kbd>TaskResponse</kbd> model). The function we've created has a completion handler that returns an array of our <kbd>TaskResponse</kbd> model, should the response and decoding be successful. </p>&#13;
<p>Next, create a file called <kbd>TaskViewModel</kbd> and add in the following code:</p>&#13;
<pre>class TaskViewModel: <strong>ObservableObject</strong> {<br/>    <br/>    init() {<br/>        getTasks()<br/>    }<br/>    <strong>@Published var tasks = [Task]()</strong><br/>    <br/>    private func getTasks() {<br/>        <br/>        guard let url = URL(string: "<strong>http://0.0.0.0:8080/tasks</strong>") else {<br/>            return<br/>        }<br/>        <br/>        NetworkManager.loadData(url: url) { taskResponse in<br/>            <br/>            if let taskResponse = taskResponse {<br/>                self.tasks = taskResponse.map(Task.init)<br/>            }<br/>            <br/>        }<br/>        <br/>    }<br/>    <br/>}</pre>&#13;
<p class="mce-root">In the preceding code, I've highlighted some areas of interest. First is how we've conformed our class to <kbd>ObservableObject</kbd>—this is required as our <kbd>tasks</kbd> variable has the <kbd>@Published</kbd> wrapper and will be looking for changes as and when they occur.</p>&#13;
<p>Next is the local URL we're passing into our <kbd>NetworkingManager</kbd>—this is our local instance of the REST API we created earlier.</p>&#13;
<p>Now, head on back over to our <kbd>ContentView.swift</kbd> file and make the following highlighted changes:</p>&#13;
<pre>struct ContentView: View {<br/>    <br/>    <strong>@ObservedObject var model = TaskViewModel()</strong><br/>    <br/>    var body: some View {<br/>        List(<strong>model.tasks</strong>) { task in<br/>            ListRowView(description: task.description,<br/>                        category: task.category)<br/>        }<br/>        <br/>    }<br/>}</pre>&#13;
<p>We've now renamed our <kbd>tasks</kbd> variable to <kbd>model</kbd>, and this in turn has now created a new instance of <kbd>TaskViewModel()</kbd>.</p>&#13;
<p>As we've updated a few things here, the structure of how we inject our mock data will need adjusting too, so make the following highlighted changes to our <kbd>MockHelper</kbd> function:</p>&#13;
<pre>var task = [Task]()<br/>task.append(<strong>Task(taskResponse: TaskResponse(category: "Get Eggs", <br/>  description: "Shopping"))</strong>)<br/>task.append(<strong>Task(taskResponse: TaskResponse(category: "Get Milk", <br/>  description: "Shopping"))</strong>)<br/>task.append(<strong>Task(taskResponse: TaskResponse(category: "Go for a run", <br/>  description: "Health"))</strong>)<br/><br/><strong>let taskViewModel = TaskViewModel()</strong><br/><strong>taskViewModel.tasks = task</strong><br/><br/>return taskViewModel</pre>&#13;
<p>As our <kbd>ContentView</kbd> now accepts an array of <kbd>TaskResponse</kbd>, we've just made the adjustment accordingly.</p>&#13;
<p>Now for the magic—from our previous project, launch our local instance of our Task API and add a couple of things into the database:</p>&#13;
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"description":"Remember the Eggs","category":"Shopping"}' http://0.0.0.0:8080/tasks</strong><br/><br/></pre>&#13;
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"description":"Bread","category":"Shopping"}' http://0.0.0.0:8080/tasks</strong></pre>&#13;
<pre><strong>curl -H "Content-Type: application/json" -X POST -d '{"description":"Ring Mandy","category":"Home"}' http://0.0.0.0:8080/tasks</strong></pre>&#13;
<p>With this done, it's time to see the magic happen. Launch the app, and if all's going well, you should see something like this:</p>&#13;
<div class="CDPAlignCenter CDPAlign"><img src="Images/c69127f9-fd03-4bfb-8a1c-249b6823c02b.png" style="" width="1125" height="2146"/></div>&#13;
<div class="packt_figref CDPAlignCenter CDPAlign"><span> Figure 10.5 – Launching the app</span></div>&#13;
<p>Here is a simple yet exceptionally effective demonstration of how Combine can and should be used within SwiftUI. Let's take a look now at how all this actually works.</p>&#13;
<h2 id="uuid-eadbaf8d-e0d2-40d1-849c-7a97454e91c2" class="mce-root">How it works...</h2>&#13;
<p>Let's start at the <kbd>ContentView</kbd> and work our way back:</p>&#13;
<pre><strong>@ObservedObject</strong> var model = <strong>TaskViewModel()</strong></pre>&#13;
<p>Two things to note here—our model is that of an <kbd>@ObservedObject</kbd>, meaning any changes made to this model will result in an update being fired and thus forcing a refresh of our UI (just like we saw with <kbd>@State</kbd> earlier).</p>&#13;
<p>Next, we're instantiating our <kbd>TaskViewModel()</kbd> when the <kbd>ContentView</kbd> is rendered. Let's dive into our <kbd>TaskViewModel</kbd> and see why:</p>&#13;
<pre>class TaskViewModel: <strong>ObservableObject</strong> {<br/>    <br/>    <strong>init() {</strong><br/><strong>        getTasks()</strong><br/><strong>    }</strong><br/><strong>    @Published var tasks = [Task]()</strong><br/>    <br/>    // ...<br/>    <br/>}</pre>&#13;
<p class="mce-root">We already touched earlier on our class conforming to <kbd>ObservableObject</kbd>. This is what allows us to use <kbd>@ObservedObject</kbd> when declaring this back over in our <kbd>ContentView</kbd> (we're creating a <strong>data flow </strong>connection, so to speak).</p>&#13;
<p>Notice here that we've also added a call to our <kbd>getTasks()</kbd><strong> </strong>function so that when we initialize the class (back over in <kbd>ContentView</kbd>), we'll kick off a networking request to get a list of tasks.</p>&#13;
<p>If we now have a quick look inside our <kbd>getTasks()</kbd> function, you'll see that once we get a successful response, we assign this to our <kbd>@Published tasks</kbd> variable:</p>&#13;
<pre>NetworkManager.loadData(url: url) { articles in<br/>    <br/>    if let articles = articles {<br/>        <strong>self.tasks = articles.map(Task.init)</strong><br/>    }<br/>    <br/>}</pre>&#13;
<p>And as soon as the variable is updated, our <kbd>Observable</kbd> object class lets anything listening know about a change (our <kbd>@ObservedObject</kbd><span> </span>in our <kbd>ContentView</kbd>, for example).</p>&#13;
<p>If you think back to how the <kbd>UITableView</kbd> works, if there are any updates or changes to the data source, we then have to call <kbd>UITableView.reloadData()</kbd><strong> </strong>manually, and within our UI layer. </p>&#13;
<p>With this approach, everything has been handled the way it should be and is in the right place, passing data changes from the source of truth up to the UI layer.</p>&#13;
<h2 id="uuid-a75fceb2-7cb4-4629-80ab-95bfaaf5c9df" class="mce-root">See also</h2>&#13;
<ul>&#13;
<li>Swift Combine: <a href="https://developer.apple.com/documentation/combine">https://developer.apple.com/documentation/combine</a></li>&#13;
</ul>&#13;
&#13;
&#13;
            </article>&#13;
&#13;
            &#13;
        </section>&#13;
    </div></body></html>