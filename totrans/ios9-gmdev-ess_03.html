<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Structuring and Planning a Game Using iOS 9 Storyboards and Segues</h1></div></div></div><p class="calibre8">Video game development has had an interesting history. It started as an offshoot of both electrical engineering and computer science. Games were a great challenge for engineers to make the most out of the limited hardware and, of course, make something fun. Today, video games and video game development are still built on those foundations of technology, math, and engineering but, for decades, have also been major players in the world of entertainment, storytelling, and media.</p><p class="calibre8">Be it if you are a major studio, a small team, or creating games all by yourself, planning and structuring your game projects can give you the foundation needed to save time in the development process, divide the work out to others if on a team, and of course, bring your game to life as close as possible to how you imagined it.</p><p class="calibre8">Starting with iOS 5, Apple took a page from the entertainment industry in how to structure and plan a project, big or small; by using the concept of storyboards. Storyboards are a graphic representation of the various steps and structures of a project; be it an animation, a movie, or in our case, iOS games. Storyboards will graphically show the flow of a production or app. In animation, for example, storyboards are used to flesh out major frames or story points of the production. Once it's agreed on as to what the series of events in a scene will be, animators will animate around those key points. Depending on whether the production is prelay or ADR, voice acting could also be placed into the storyboard process, which gives the animators even more specific content to work with.</p><p class="calibre8">In the case of the actual game application, storyboards can represent major parts of your game, such as the Intro scene, Opening Menu screen, Pause Screen, Game Over Screen, or the generic look <a id="id86" class="calibre1"/>of a main game level. Apple named these structures in Xcode <strong class="calibre9">storyboards</strong>, and the paths between them are known as <a id="id87" class="calibre1"/><strong class="calibre9">segues</strong>. Throughout this chapter, we shall be looking into how to make use of these features while making a game app.</p><div><img src="img/00002.jpeg" alt="Structuring and Planning a Game Using iOS 9 Storyboards and Segues" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">The preceding is an example of a simple iOS Storyboard.</p></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec22" class="calibre1"/>Model-View-Controller</h1></div></div></div><p class="calibre8">Before we get into <a id="id88" class="calibre1"/>storyboards in iOS 9, it's best that we first discuss the basic flow of an iOS app and the concept of <strong class="calibre9">Model-View-Controller</strong> (<strong class="calibre9">MVC</strong>). Model-View-Controller is an architectural paradigm used in software engineering, programming, and even now in web design. We can think of the model portion of MVC as the logic or <em class="calibre10">brains</em> of an application's behavior. This logic is usually independent of the user interface and determines what to do with the app's data.</p><p class="calibre8">We've actually already gone over the model portion of MVC! The Swift programming language discussed in the previous chapter is that model; this is the case with its Objective-C predecessor and any other programming language used in iOS or any other game development. Your game's code controls what to do with the player, level, and enemy/goal data.</p><p class="calibre8">The view portion of MVC is the visual representation of the model. This of course would include the numerous visual aspects of our games, from our player's animation frames, various in-game stats on the HUD, particle effects, and more.</p><p class="calibre8">The controller portion of MVC can be thought of as the <em class="calibre10">glue</em> that holds the model and view together. It is also the point at which the user of your game interacts with. Be it actions, such as a button press, a basic touch, a swipe, or other gestures, recognized by your iOS device, the <a id="id89" class="calibre1"/>controller takes that user input, manipulates your model and then the model updates your view accordingly.</p><div><img src="img/00003.jpeg" alt="Model-View-Controller" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">This diagram is taken from Apple's own Adventure Game Example.</p><p class="calibre8">When we work with iOS apps, the first recommended entry point for code and storyboard info is the Root View Controller. As we'll come to find out, MVC is intrinsically built into iOS app development and the Xcode IDE. Storyboards are a collection of different types of view controllers with varying tasks that are linked by segues.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>An iOS app's lifecycle</h1></div></div></div><p class="calibre8">Before <a id="id90" class="calibre1"/>we move on to working with storyboards, segues, and the foundation of our game apps, it's best we go over the overall lifecycle of an iOS app as it's important to know the entry points of our code and various objects/structures of our apps.</p><p class="calibre8">Insert app lifecycle imagery here before we move on to working with storyboards, segues, and the foundation of our game apps. It's best we go over the overall lifecycle of an iOS app as it's important to know the entry points of our code and various objects/structures of our apps.</p><div><img src="img/00004.jpeg" alt="An iOS app's lifecycle" class="calibre11"/><div><p class="calibre15">Source: <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html">https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html</a>
</p></div></div><p class="calibre12"> </p><p class="calibre8">Anyone who has <a id="id91" class="calibre1"/>worked with C/C++, Java, or other languages will be familiar with the <code class="email">main()</code> function. The <code class="email">main()</code> function is used to designate your program's main entry point. The preceding example is how Apple designates the typical main function for apps. Essentially what this is doing is calling the first class in the typical lifecycle of iOS apps, the <code class="email">AppDelegate</code> class.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec27" class="calibre1"/>The main() function</h2></div></div></div><p class="calibre8">Here's the <a id="id92" class="calibre1"/>code with the <code class="email">main()</code> function:</p><div><pre class="programlisting">#import &lt;UIKit/UIKit.h&gt;
#import "AppDelegate.h"
 
int main(int argc, char * argv[])
{
    @autoreleasepool {
        return UIApplicationMain(argc, argv, nil, NSStringFromClass([AppDelegate class]));
    }
}
//Objective-C example of the Main() function</pre></div><p class="calibre8">Note how the <code class="email">main()</code> function is written in Objective-C. Swift again makes declaring the entry of your application easier.</p><div><pre class="programlisting">@UIApplicationMain
class firstClassCalled
{ 
  //class code
}</pre></div><p class="calibre8">While building an <a id="id93" class="calibre1"/>iOS app with Swift, the <code class="email">main.m</code> file seen in prior Objective-C projects is no longer needed. Instead, we use an Attribute call, <code class="email">@UIApplicationMain</code>, just before the declaration of the class that is first called.</p><div><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre8">
<strong class="calibre9">Swift attributes</strong>
</p><p class="calibre8">Attributes, beginning with the <em class="calibre10">at</em> character, <code class="email">@</code>, are used to add additional information to a declaration or a type. In Swift, they have the following syntax:</p><div><pre class="programlisting">@attribute name
@attribute name(attribute arguments)</pre></div><p class="calibre8">As in other programming languages, attributes, depending on their functionality, can be used to describe objects, functions, and even entire classes.</p><p class="calibre8">For example, the <code class="email">@objc</code> attribute is used to declare code that is readable in Objective-C.</p><p class="calibre8">As we'll see while using and linking various objects in the storyboards with our code, the attributes <code class="email">@IBOutlet</code> and <code class="email">@IBAction</code> are used to describe objects and functions representing objects we create in Xcode's Interface Builder.</p><p class="calibre8">We will discuss more on Attributes in <a class="calibre1" title="Chapter 7. Publishing Our iOS Game" href="part0055_split_000.html#1KEEU2-d06b23b4a4554b3182353558917969c2">Chapter 7</a>, <em class="calibre10">Publishing Our iOS 9.0 Game</em>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec28" class="calibre1"/>The UIApplication class/object</h2></div></div></div><p class="calibre8">
<code class="email">UIApplication</code> is the<a id="id94" class="calibre1"/> object responsible for controlling an app's event-loop as well as handling other upper-level app processes. Game app or not, this is present in all iOS apps and is what is first called at the main entry point and works together with the <code class="email">AppDelegate</code> class. Though it is possible to subclass <code class="email">UIApplication</code>, it's usually not recommended. Customizations to what your game does during various app states are what we use the <code class="email">AppDelegate</code> class and <code class="email">ViewControllers</code> for, even if storyboards are<a id="id95" class="calibre1"/> not utilized (that is if you choose to mostly hardcode your game).</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec29" class="calibre1"/>The AppDelegate class</h2></div></div></div><p class="calibre8">We can<a id="id96" class="calibre1"/> think of the <code class="email">AppDelegate</code> class as your app's main hub. It's the top level of general customization for your game. While making an app in Swift (game or not), it's the class that is given the <code class="email">@UIApplicationMain</code> attribute because it's the general first entry of your game's model/code. </p><p class="calibre8">Here's the code that Apple provides with almost every iOS app preset in Xcode:</p><div><pre class="programlisting">import UIKit

@UIApplicationMain
class AppDelegate: UIResponder, UIApplicationDelegate {

    var window: UIWindow?

    func application(application: UIApplication, didFinishLaunchingWithOptions launchOptions: [NSObject: AnyObject]?) -&gt; Bool {
        // Override point for customization after application launch.
        return true
    }
    func applicationWillResignActive(application: UIApplication) {
        // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state.
        // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.
    }

    func applicationDidEnterBackground(application: UIApplication) {
        // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later.
        // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.
    }

    func applicationWillEnterForeground(application: UIApplication) {
        // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
    }

    func applicationDidBecomeActive(application: UIApplication) {
        // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
    }

    func applicationWillTerminate(application: UIApplication) {
        // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.
    }
}</pre></div><p class="calibre8">This is the direct <a id="id97" class="calibre1"/>code and comments (as of Xcode 6.4) that Apple provides for us when using the iOS 9 game preset. Before we dive into structuring our games with storyboards and the two main frameworks (SpriteKit and SceneKit), it's best to understand what happens in this class. Events that happen to your game app relating to the device, particularly those that are outside of the player's control, such as incoming phone calls, notifications, and the device shutting down due to low battery power, as well as those controlled by the player (that is pausing the game), are handled by this class. As we see, Apple already provides great instructions for what each function of this class does, so be sure to review them. We will come back to these as we create our games and handle those specific situations. Note that the <code class="email">AppDelegate</code> class has an optional variable (meaning it can be nil) named window and is of the type, <code class="email">UIWindow</code>. A <code class="email">UIWindow</code> object is a child of <code class="email">UIView</code> and can allocate various displays/objects that can be put into the view of the user. Technically, we can use objects of <code class="email">UIWindow</code> and <code class="email">UIView</code> in code directly to create the visuals of our game, but Apple provides more robust objects that handle both the user's interaction with the screen and view. These objects are what make up iOS storyboards; the ably named, <code class="email">ViewControllers</code>.</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec30" class="calibre1"/>View controllers</h2></div></div></div><p class="calibre8">View controllers<a id="id98" class="calibre1"/> are probably one of the most vital structures of iOS development and are what storyboards are visually representing when designing them in Xcode's Interface Builder. In terms of their typical entry point order, it's <code class="email">MAIN</code> --&gt; <code class="email">AppDelegate</code> --&gt; <code class="email">RootViewController</code> --&gt; [calls to any additional <code class="email">ViewControllers</code> instance].</p><p class="calibre8">When we create a new app project in Xcode, Apple will make a default Root View Controller <a id="id99" class="calibre1"/>named <code class="email">ViewController</code> for us. Here's it's code:</p><div><pre class="programlisting">import UIKit
class ViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
        // Do any additional setup after loading the view, typically from a nib.
    }
    override func didReceiveMemoryWarning() {
        super.didReceiveMemoryWarning()
        // Dispose of any resources that can be recreated.
    }
}</pre></div><p class="calibre8">This is the starter code given to us in Xcode with the default <code class="email">ViewController.swift</code> class. As we see, it's a subclass of <code class="email">UIViewController</code> and thus inherits all of its parent class's functions. One of them shown here is the function <code class="email">viewDidLoad()</code>. In Swift, when we wish to override a function of a parent class, we use the keyword <code class="email">override</code> before the function declaration. We also see that <code class="email">super.viewDidLoad()</code> is called as well. What this does is call the parent's own version of this function before we add our own code/customizations and is recommended when using any of the functions of <code class="email">UIViewController</code>. The <code class="email">UIViewController</code> functions handle various view states; <code class="email">viewDidLoad()</code> handles when the view is first loaded and is called once for the life of the <code class="email">UIViewController</code> object during an app's lifecycle. If we want to call some code every time a view is seen, we can use the<code class="email"> viewDidAppear()</code> function of <code class="email">UIViewController</code> instead.</p><p class="calibre8">Here's a visual representation of these view states.</p><div><img src="img/00005.jpeg" alt="View controllers" class="calibre11"/></div><p class="calibre12"> </p><p class="calibre8">Here storyboards <a id="id100" class="calibre1"/>and segues, as we'll see, essentially give us a visual and customizable representation of these very states and the transitions between them without using too much code.</p><p class="calibre8">To dive even deeper into the <code class="email">UIViewController</code> methods, check out Apple's documentation on the subject:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/">https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIViewController_Class/</a>
</p><div><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre8">For anyone familiar with the game development engine Unity (which has scripts written in either C#, JavaScript, or the Python derivative), one way we can imagine the <code class="email">UIViewController</code> functions <code class="email">viewDidLoad()</code> and <code class="email">viewDidAppear()</code> is that they are somewhat similar to the Unity functions <code class="email">Awake()</code> and <code class="email">OnEnabled()</code>, respectively. One function is called when the scene is first loaded and the other just before the first frame that the object is visible/enabled. The <code class="email">UIViewController</code> functions however are on a more upper-level basis for the entirety of the app as opposed to a per <code class="email">gameObject</code> basis.</p></div><p class="calibre8">For more information and graphics on the entire iOS app lifecycle, check out the full documentation here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html">https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/TheAppLifeCycle/TheAppLifeCycle.html</a>
</p></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_5"><a id="ch02lvl2sec31" class="calibre1"/>View controller types</h2></div></div></div><p class="calibre8">View controllers <a id="id101" class="calibre1"/>come in a number of types and we can create our own by subclassing them. The two main types are <strong class="calibre9">container</strong> view controller, which hold other view controllers, and content view controllers, which as we can imagine, are what display the content. Content view controllers include the <code class="email">RootViewController</code>, which is the first view controller accessed after the app's entry point and is also the first view controller seen in the default <code class="email">Main.Storyboard</code> file in a preset Xcode project's inspector. There are also other special types of view controllers, like the <code class="email">UITableViewController</code>, used to display data listed in table cell formats and the <code class="email">NavigationController</code>, which controls the navigation logic/imagery of the app when moving between other view controllers.</p><p class="calibre8">For a more in-depth look at the various view controllers available in UIKit, check out the official documentation seen here:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1">https://developer.apple.com/library/ios/featuredarticles/ViewControllerPGforiPhoneOS/index.html#//apple_ref/doc/uid/TP40007457-CH2-SW1</a>
</p><p class="calibre8">It's actually at this point that we can begin to code our game, albeit entirely programming the MVC model. In the beginning of iOS game development, this was essentially how one would go about developing a game for the original iPhone. We'd programmatically work with the <code class="email">UIWindow</code> and <code class="email">ViewController</code> objects and our game's own custom classes to craft the app. As the family of iOS devices grew, an obvious issue began to arise. Though we can, and sometimes might have to. programmatically change code based on the device, dealing with a growing number of screen sizes and device types made it so that our code would always have to be refactored and produced ever increasing ambiguity whenever a new Apple iOS device was announced. Also, let's not forget that game development is as much of a visual designer / animator's work as it is a programmer's. Editing, positioning, refining, and later updating various visual aspects of a game can be very time consuming if done entirely via code. </p><p class="calibre8">Storyboards were made to help alleviate this issue by allowing us to visually design our game in the project itself as oppose to having our own possibly handwritten storyboards that describe just a model-based, code-centric design. With the introduction of Auto Layout in Xcode 5, we can, without using any code, make one project and general view for all varieties of iOS devices. We shall touch on AutoLayout as we now finally move on to working with Storyboards and segues, but for a more in-depth look on Auto Layout, check out the official documentation on Apple's developer portal: <a class="calibre1" href="https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG">https://developer.apple.com/library/ios/documentation/UserExperience/Conceptual/AutolayoutPG</a>.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Storyboards and segues</h1></div></div></div><p class="calibre8">Let's now finally<a id="id102" class="calibre1"/> get to working with these tools and learn the basics of structuring game apps on a broader storyboard level. As of the writing of this book, the latest version of Xcode available is version 7.0. This will be the version we shall work with, but <a id="id103" class="calibre1"/>Xcode is always updating with even a beta version available to separately test the newest features. </p><p class="calibre8">Visit <a class="calibre1" href="https://developer.apple.com/xcode/">https://developer.apple.com/xcode/</a> to download and read up on all that Xcode has to offer for iOS developers.</p><p class="calibre8">To start structuring your app using storyboards, follow these instructions:</p><div><ol class="orderedlist"><li class="listitem" value="1">First, open Xcode in your <code class="email">Applications</code> folder (or in your Dock if you placed it there for easy access).</li><li class="listitem" value="2">Next, click on <strong class="calibre9">Create a new Xcode Project</strong>.<div><img src="img/00006.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">You will now be asked to choose a template preset.</li><li class="listitem" value="4">For the sake of just understanding storyboards and segues, select the Single View Application template. (Don't worry, we will be using the game template in the next chapter).<div><img src="img/00007.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="5">Now we<a id="id104" class="calibre1"/> choose our project's options. Name your project <code class="email">StoryBoardExample</code>.</li><li class="listitem" value="6">In the <strong class="calibre9">Language</strong> dropdown, make sure that it is set to <strong class="calibre9">Swift</strong> and ensure the <strong class="calibre9">Devices</strong> dropdown is set to <strong class="calibre9">Universal</strong>.</li><li class="listitem" value="7">There should be other fields filled in by Xcode, such as your organization name and organization identifier. Those are involved with the information that will be published with your app when it comes to deployment as well as the content of your code's copyright comments. We can for now keep these at their default setting that Xcode has filled in.<div><img src="img/00008.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="8">Click on <strong class="calibre9">Next</strong> and then select a valid location in your files to save this project.</li></ol><div></div><p class="calibre8">Now we have our default app created by the template. We should see on the left-hand side, in the File Navigator Pane, various files and folders created for us. As we can see, the <code class="email">AppDelegate.swift</code> and the <code class="email">ViewController.swift</code> files were automatically created for us and right below that, we'd find the <code class="email">Main.Storyboard</code> file. This is our storyboard and when you click on it, you should see the two panes open at the center of your Xcode window. The left side is the view controller <strong class="calibre9">Scene</strong> dropdown, which shows the hierarchy of the scene controlled by the provided the view controller. The right pane in the center allows us to visually see the view controller and eventually elements that we can place in it. The main visual part of the storyboard can be zoomed in and zoomed out. As we add more scenes to it, this will allow us to see the entirety of our storyboard or the portions we are working on.</p><p class="calibre8">You might have to zoom out slightly to see it (using your mouse or using the pinching gesture on your trackpad with a MacBook), but to the left of the View Controller scene there's a gray arrow. This is the entry point and <a id="id105" class="calibre1"/>the first View Controller scene attached to this arrow is your <code class="email">RootViewController</code>/Initial scene.</p><div><h3 class="title2"><a id="tip05" class="calibre1"/>Tip</h3><p class="calibre8">When adding more scenes to your storyboard, for either debugging purposes or design choice, you can simply change the scene that is first entered by clicking and dragging that arrow to the left of that scene.</p></div><p class="calibre8">Let's start by creating a separate scene for our storyboard:</p><div><ol class="orderedlist"><li class="listitem" value="1">At the bottom of the <strong class="calibre9">Utilities</strong> panel (the far right panel of the Xcode project), there are four icons designating the various snippets and objects we can place in our project's code and the storyboard. Click on the third icon from the left if it's not already selected. This will open the Object Library.<div><img src="img/00009.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">We can see that the very top of the Object Library has a <strong class="calibre9">View Controller</strong> object.<div><img src="img/00010.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">Drag this onto the storyboard's canvas, preferably to the right of the initial scene.<div><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre8">If the <strong class="calibre9">Utilities</strong> panel isn't open, click on the upper right-most icon at the top of your project's toolbar window.</p></div><div><img src="img/00011.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p><div><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre8">The three buttons in your toolbar can be toggled to close the <strong class="calibre9">Navigation</strong> pane, <strong class="calibre9">Debug</strong> pane, and <strong class="calibre9">Utilities</strong> pane, respectively. Closing these when applicable can help expand the general view, known as the canvas of your storyboard scenes.</p></div></li></ol><div></div><p class="calibre8">Now we have<a id="id106" class="calibre1"/> two scenes in our storyboard, but nothing is there to tell us what they are. They are just two blank scenes!</p><p class="calibre8">Let's put a <strong class="calibre9">Label</strong> object in these scenes to represent what they are and at runtime tell us which one we are in.</p><p class="calibre8">To keep this in the mindset of developing a game, let's put a label in the first one called <strong class="calibre9">Intro Scene</strong>, where we'd maybe have an intro animation to our game with a <strong class="calibre9">Start/Options</strong> menu, and in the next one, put the label <code class="email">Game Scene</code> to represent that this is where that actual gameplay would occur.</p><p class="calibre8">Here's how to do that:</p><div><ol class="orderedlist"><li class="listitem" value="1">Go to the bottom of the <strong class="calibre9">Utilities</strong> panel and use the search field to search <code class="email">label</code>. This will isolate the <code class="email">label</code> object, so you don't have to scroll through the entire list.<div><img src="img/00012.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">Drag the <code class="email">label</code> object to the canvas of the first scene. If it doesn't look like it's trying<a id="id107" class="calibre1"/> to snap to the scene's canvas, you might have to select the <strong class="calibre9">View</strong> portion of that view controller scene's hierarchy, using the left pane of the Main/Storyboard's main view. Alternately, you can also double-click the view in the Inspector to get the scene in focus so that you can place the label onto it.<div><img src="img/00013.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">As we drag it, try to center the label as best as possible. The canvas will indicate that we are at the vertical and/or horizontal part of that scene with dotted blue lines. Drop it in the center.<p class="calibre14">The <strong class="calibre9">Utilities</strong> pane should have some fields visible when selecting the label to control various aspects of its text like font size, alignment, and style.</p><div><img src="img/00014.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="4">The label will<a id="id108" class="calibre1"/> just say <code class="email">Label</code> as the default, so let's rename it to <code class="email">Intro Scene</code> for the first scene by either double-clicking the label itself in the canvas, or changing the name in the second field down from <strong class="calibre9">Text</strong> in the <strong class="calibre9">Utilities</strong> panel.</li><li class="listitem" value="5">Let's make this label a bit more prominent, so single-click on the label, click on the [T] icon in the <strong class="calibre9">Font</strong> field, and make the style bold with a size of 28.<p class="calibre14">Note how the label is clipped from the size increase and hardly visible.</p><div><img src="img/00015.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="6">Simply click on the label and expand out any one of the eight scaling icons at the corners of the label object on the canvas.<p class="calibre14">Reposition the label to return it to the center of the scene.</p><div><img src="img/00016.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="7">Create the same label for the second scene we added by simply typing <em class="calibre10">Command</em> + <em class="calibre10">D</em> to duplicate the label (as to not have to repeat all of the steps) and then drag it to the center of the other scene. Zoom out as needed and possibly click back on to the view part of the hierarchy if the focus change prevents the ability to drag the label across.</li></ol><div></div><p class="calibre8">Though <a id="id109" class="calibre1"/>rather rudimentary and with still some more work to do with, this is all it takes to create separate scenes visually. If you have an idea of how you want to structure your game, this is where you can start with the use of storyboards. Of course, there is still more to do here before we make this storyboard have any function.</p><p class="calibre8">We can see that Xcode is giving us the following warning:</p><p class="calibre8">Scene is unreachable due to lack of entry points and does not have an identifier for runtime access via <code class="email">-instantiateViewControllerWithIdentifier</code>.</p><p class="calibre8">This is referring to the Game Scene object that is essentially orphaned due to no connection to the Intro Scene nor the app's entry point.</p><p class="calibre8">This is where segues come into play. Yet, before we work with segues and create a flow to these scenes and more, if we were to run this app, we'd note another issue. We could have sworn that we centered the text, but if simulating or running this in, say, an iPhone 6s, the text is completely off to the upper-right side. This is because the default canvas is a generalized <em class="calibre10">all device</em> template to begin with via Auto Layout.</p><p class="calibre8">Auto Layout has gotten easier with each new build of Xcode, but one could still argue it's still a bit of a hassle at times to fine tune, particularly when creating constraints (set spaces/margining between various storyboard objects). Let's take a quick look at how to work with constraints.</p><p class="calibre8">One quick way<a id="id110" class="calibre1"/> to alleviate the issue we have here is to just work with the <strong class="calibre9">Base Values</strong> panel found at the bottom center of the storyboard canvas by clicking on the <strong class="calibre9">w/Any h/Any</strong> text. Once clicked, a pop-up table of cells will appear. Rolling over with your mouse or trackpad to the various cells will bring up a number of different configurations as oppose to w/Any h/Any. What's great about this is that you can change/add and delete various objects simply based on the device type using these options.</p><div><h3 class="title2"><a id="note18" class="calibre1"/>Note</h3><p class="calibre8">Before storyboards and Auto Layout, this would involve huge amounts of testing and refactoring of code in a view controller or Nib classes to get the layout just the way you'd like visually. Apple would then create the next device with a different screen size to prior devices, it would become an even greater hassle or the developer would risk a broken game on the newest device.</p></div><p class="calibre8">To make the labels be in the center for all iPhones in portrait mode for example:</p><div><ol class="orderedlist"><li class="listitem" value="1">Hover and click on the center left-hand side of the Auto Layout panel where it'll say <strong class="calibre9">Compact Width | Any Height</strong> at the top of that pop-up panel/table.<div><img src="img/00017.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="2">This should now change the display text at the bottom of the canvas to <strong class="calibre9">w/Compact h/Any</strong> and shrink the width of the scene as this layout represents all iPhones in Portrait and of any height (so it could be a bit off in height on an older iPhone 4S as oppose to the iPhone 5 or later).<div><img src="img/00018.jpeg" alt="Storyboards and segues" class="calibre11"/></div><p class="calibre16"> </p></li><li class="listitem" value="3">Note how the labels are off center toward the upper right. This is what would have<a id="id111" class="calibre1"/> been seen in the simulator or on an actual iPhone in the portrait orientation. Drag them back to the center, and they should now look as they are seen in this configuration of the storyboard's canvas. If designing for iPad, then the other configurations would need to be changed for that.<div><h3 class="title2"><a id="note19" class="calibre1"/>Note</h3><p class="calibre8">Pinning with constraints could actually streamline this process. For example, let's say that you want to place a <strong class="calibre9">Pause</strong> button at the upper right corner of your Game Scene and you know that no matter the orientation, it will always be at a certain distance (in percentages or pixels) away from the right and top of a device's screen. We can click on the pin button <img src="img/00019.jpeg" alt="Storyboards and segues" class="calibre18"/> at the bottom of the canvas to create these constraints in the <strong class="calibre9">w/Any h/Any</strong> configuration and skip manually adjusting the icon on every one of the base configurations.</p><p class="calibre8">Xcode already gives us a scene, the <code class="email">LaunchScreen.xib</code> file, which, if you have already ran your code, was actually what was seen first before the first view controller in the storyboard.</p><p class="calibre8">To have just your <code class="email">Main.Storyboard</code> file be at startup you can select the main project file at the top left corner in the <strong class="calibre9">Navigation</strong> pane and in the <strong class="calibre9">Launch Screen</strong> dropdown of the <strong class="calibre9">Apps Icons and Launch Images</strong> section, select <code class="email">Main.Storyboard</code>. Then, you can delete the <code class="email">LaunchScreen.xib</code> file if no longer needed. It can be a good file to see working constraints, and if so be it, it can be your initial splash screen for your game. More on constraints can be found here in the official documentation: <a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html">https://developer.apple.com/library/prerelease/ios/documentation/UserExperience/Conceptual/AutolayoutPG/WorkingwithConstraintsinInterfaceBuidler.html</a>.</p></div></li></ol><div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec32" class="calibre1"/>Segues</h2></div></div></div><p class="calibre8">Games have scenes, and <a id="id112" class="calibre1"/>all scenes have transitions between them. Segues are simply transitions between scenes in a storyboard. Segues come in various types:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre9">Show</strong>: This<a id="id113" class="calibre1"/> pushes the next view controller on top of the current one; it also allows for calling back if using a <code class="email">UINavigationController</code> instance.</li><li class="listitem"><strong class="calibre9">Show Detail</strong>: When<a id="id114" class="calibre1"/> using <code class="email">UISplitViewController</code>, a Container view controller is typically used in iPad apps to browse news/email apps, where the left side of the page is a <code class="email">UITableViewController</code> object and the other side of the same page are the details of that table/list. This calls the details for the <code class="email">DetailView</code> controller portion of the page when triggered by a gesture from the selected item on the <code class="email">UITableViewController</code> side.</li><li class="listitem"><strong class="calibre9">Present modally</strong>: This <a id="id115" class="calibre1"/>presents the next view controller over the current but in such a way that it can be canceled, such as a full-page popup.</li><li class="listitem"><strong class="calibre9">Popover</strong>: This is<a id="id116" class="calibre1"/> like Present modally but with more options in sizing to create a smaller pop-up window that can be closed and disposed of.</li><li class="listitem"><strong class="calibre9">Custom</strong>: This is<a id="id117" class="calibre1"/> a version of a segue that you can completely customize with OOP code.</li></ul></div><p class="calibre8">The typical storyboard structure when building say, an e-mail app, will more than likely need to make use of a navigation controller and <code class="email">UITableView</code> controllers to structure the data and flow of the app. Now, we can very well do the same thing for game apps. Game Over, Menu, Rankings, and Pause screens could make use of these view controllers. For our example, we'll keep it simple and unrestricted to let you, the developer, have a better starting point to branch from.</p><div><h3 class="title2"><a id="note20" class="calibre1"/>Note</h3><p class="calibre8">Our example here is rather simple, but in addition to providing code for this project, an even more detailed storyboard will be available using various view controllers and objects.</p></div><p class="calibre8">Let's take care of that warning and link up these scenes as well as begin to show the overall structure of a typical game using storyboards.</p><div><ol class="orderedlist"><li class="listitem" value="1">First, in the <strong class="calibre9">Intro Scene</strong>, place a button labeled <strong class="calibre9">START</strong> right under the <strong class="calibre9">Intro Scene</strong> label. Placing a button on a storyboard is done exactly the same as with a label. Search for <code class="email">button</code> or scroll down the objects in the <strong class="calibre9">Utilities</strong> panel and then drag and drop the button onto the scene.</li><li class="listitem" value="2">Now create two more buttons on the Game Scene view; one button labeled <strong class="calibre9">Pause</strong> at the top-right corner of the scene and another named <strong class="calibre9">Quit</strong> opposite the Pause button on the upper-left corner.</li><li class="listitem" value="3">Create a new <code class="email">ViewController</code> object on the scene, preferably above or below the Game Scene on the canvas.</li><li class="listitem" value="4">On the new Pause Scene, create a label <code class="email">PAUSED</code> the same way the <code class="email">Game Scene</code> and <code class="email">Intro Scene</code> labels were made.</li><li class="listitem" value="5">Then, add two buttons, <strong class="calibre9">Quit</strong> and <strong class="calibre9">Resume</strong>, and place them right under the <strong class="calibre9">PAUSED</strong> label.</li></ol><div></div><p class="calibre8">Now to create<a id="id118" class="calibre1"/> the segues visually using the storyboard:</p><div><ol class="orderedlist"><li class="listitem" value="1">Control-Click the <strong class="calibre9">START</strong> button object on the Intro Scene and then while still pressing Control-Click, drag the object toward the <strong class="calibre9">Game Scene</strong> on the canvas. You should see a blue line follow your cursor as you drag across. (if you need more space, zoom out a bit and also temporarily close the <strong class="calibre9">Navigation</strong> and <strong class="calibre9">Utilities</strong> panels using the toll bar buttons).</li><li class="listitem" value="2">Drop this point anywhere on the view that isn't another object; you should see the entire view glow blue while doing so.</li><li class="listitem" value="3">A popup asking for the type of Segue will come up. Select <strong class="calibre9">Show</strong>.</li><li class="listitem" value="4">That's it! You've created a segue, and you've also told the storyboard that when the user clicks that button, it'll open the Game Scene—View Controller.</li><li class="listitem" value="5">Before you move on to creating more segues, click on the door-like symbol on the canvas that represents the segue. On the top right in the <strong class="calibre9">Utilities</strong> panel's Assets inspector, you should see an empty <strong class="calibre9">Identifier</strong> field. We can leave the segue empty if we'd like, but naming it could be of use if we wish to call the segue in code with the following line:<div><pre class="programlisting">performSegueWithIdentifier("segueIDNameeWithIdentifi)</pre></div></li><li class="listitem" value="6">Now repeat steps <em class="calibre10">1</em> through <em class="calibre10">3</em> to create the following segues:<div><ol class="orderedlist1"><li class="listitem" value="1">Link Game Scene's <strong class="calibre9">Quit</strong> button back to Intro Scene.</li><li class="listitem" value="2">Link Game Scene's <strong class="calibre9">Pause</strong> button to the PAUSED Scene.</li><li class="listitem" value="3">Link PAUSED Scene's <strong class="calibre9">Resume</strong> button to the Game Scene.</li><li class="listitem" value="4">Link PAUSED Scene's <strong class="calibre9">Quit</strong> button to the Intro Scene.</li></ol><div></div></li></ol><div></div><p class="calibre8">The warning should now be gone as all of the scenes are connected with segues, and after possibly some Auto Layout fixes, running the app now has a game-like scene structure that transition the way we'd normally see in other games. We can go from here and make other scenes, such as a Game Over scene, a Stage Win scene, or others. Even if this might not be the way you'd like your final game's transitions to end up (particularly since the default transition of the Show segue does a quick vertical), this can be a very quick way of prototyping your game right off the bat. Custom segues and segues triggered with code are how we can dive deeper into fine tuning when the default setting might not match with our vision of our games.</p><p class="calibre8">Here's more documentation on<a id="id119" class="calibre1"/> making custom segue classes if you really want to dive deeper into segues:</p><p class="calibre8">
<a class="calibre1" href="https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11">https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIStoryboardSegue_Class/index.html#//apple_ref/doc/uid/TP40010911-CH1-SW11</a>
</p><p class="calibre8">Similarly to how we Control-Dragged the button's linkage to the next view controller scene, we can do the same to our <code class="email">ViewController.swift</code> file.</p><p class="calibre8">Here's a summery on how to do that for the first view controller:</p><div><ol class="orderedlist"><li class="listitem" value="1">Remove the previous segue. One way to do so is to right-click the button and to click on <strong class="calibre9">x</strong> in the <strong class="calibre9">Triggered Segues</strong> section.</li><li class="listitem" value="2">Click on the Intro Scene's view in the hierarchy to get it in focus.</li><li class="listitem" value="3">Control-Drag a blue line from the yellow icon on the top left of the Intro Scene's view controller to the Game Scene's view controller and select the Show type of segue.</li><li class="listitem" value="4">Click on the segue icon in the canvas and now give the identifier of this segue the name <code class="email">startGame</code>.</li><li class="listitem" value="5">Open the Assistant Editor (the two interlocking circles button on the top-right portion of the Xcode toolbar); close some panes to make any needed room.</li><li class="listitem" value="6">Control-Drag the <strong class="calibre9">Start</strong> button into the <code class="email">ViewController</code> class; preferably at the bottom of the code but still within the class's closing brackets.</li><li class="listitem" value="7">This will prompt the outlet/action popup. Select the <strong class="calibre9">Action</strong> option in the <strong class="calibre9">Connection</strong> dropdown and name it <code class="email">startButton</code>.</li><li class="listitem" value="8">This will create the <code class="email">IBAction</code> function: <code class="email">@IBAction func startButton(sender: AnyObject) {}</code>.</li><li class="listitem" value="9">Type the following code between the braces: <code class="email">self.performSegueWithIdentifier("startGame", sender: nil)</code></li><li class="listitem" value="10">This tells the view controller to perform the segue when this button is prompted using code.</li></ol><div></div></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec25" class="calibre1"/>Storyboards versus coding</h1></div></div></div><p class="calibre8">There's no single <a id="id120" class="calibre1"/>correct way to do the design structure of your app as long as the MVC model is followed. Actually, there are programmers out there who are completely fine with just using the initial view controller and never use a single Nib or storyboard file; thus purely building their game controlled by the logic of their code and calls to the various View objects programmatically. In iOS development, there's somewhat of a design split between three main branches, hardcoding, Nibs, and storyboards. The original methodology was coding; Nibs came in later to first allow direct visual editing in Xcode and then that evolved into Storyboards, further built upon with the addition of Auto Layout.</p><p class="calibre8">The reason there's a split between some developers and studios on the visual structure methodology of an iOS app is because one drawback to Nibs and storyboards are their lack of portability. If you wanted to port your game to another platform, such as Android, at descent pace, heavy use of storyboards would make it a rather tough to port the app to the other platform since these design features are specific to the iOS platform. This is when pure code would be more beneficial. Storyboards though give us developers an editable, visual representation of the app/game we wish to make and the ability to do little to no changes as the family of devices change. </p><p class="calibre8">Even other game development engines, such as Unity, Unreal Engine, and more, work on a more sandboxing, visual representation methodology with your code acting as more of a component to the visual as opposed to the full structure of everything that appears before your game characters even get rendered to the screen.</p></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec26" class="calibre1"/>Summary</h1></div></div></div><p class="calibre8">In this chapter, we went over a number of app project structuring and introduction topics. First, we went over the Model-View-Controller paradigm followed by all apps, game or not, and the overall lifecycle of an iOS app that follows this structuring. Next, we reviewed the entry point(s) and pathway of your code in a typical app as well as the upper-level objects used along the way, such as the Application system object, the <code class="email">AppDelegate</code> class, and view controller. Last but not least, we discussed the main topic of the chapter—storyboards, segues, and instructions on how to create a simple game flow structure. From here, we can see how relatively easy and quick it can be to structure various scenes for your game and transition between them with segues. Again, note that although storyboards are recommended, they can simply start as a general guide toward the final product, which gives you, the developer, the ability to visualize your game even if in the end preferring a more code-heavy design choice.</p><p class="calibre8">In the next two chapters, we are going to finally get into really coding and designing actual playable games. We will start off with 2D games, and since iOS 7, Apple has given iOS developers it's own framework to handle 2D sprites and game physics. This framework is amply named Spritekit.</p></div></body></html>