<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Functional Programming and Reactive Programming</h1>
                </header>
            
            <article>
                
<p>So far, we've made good progress over the last eight chapters. You've already learned the concepts of <strong>functional programming</strong> (<strong>FP</strong>) and some awesome Kotlin features such as coroutines and delegates, which are not exactly from FP theories (in fact, delegates are from the OOP paradigm), but all of them enable us to get more benefits out of FP.</p>
<p>This short chapter is dedicated to combining other programming principles/paradigms with FP to get the best output from them. Here's a list of the topics that we will cover in this chapter:</p>
<ul>
<li>Combining FP with OOP</li>
<li>Functional reactive programming</li>
<li>Introduction to RxKotlin</li>
</ul>
<p>So, let's get started.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Combining FP with OOP</h1>
                </header>
            
            <article>
                
<p>FP and OOP are both old age programming paradigms, having their set of benefits and disadvantages. For instance, it is difficult to strictly follow FP without any side effects and all pure functions, especially for beginners in FP and with complex project requirements. However, with OOP systems, it is difficult to avoid side effects; also, OOP systems are often termed as a nightmare for concurrent programs.</p>
<p>FP doesn't acknowledge state, whereas in real life, states cannot be avoided.</p>
<p>All these hassles can be avoided by using/combining OOP with FP. The most general style of mixing OOP and FP that has been professed can be summarized as functional in the small, object-oriented in the large. This is a simple and the most efficient idea of combining OOP with FP. This concept talks about using OOP at a higher level in your code, that is, in the modular architecture, and you can use OOP for classes and interfaces, while using FP at the lower level, that is, while writing methods/functions.</p>
<p>To break this concept, consider a structure where you are writing classes and interfaces as you normally do with OOP, and then while writing functions/methods, you follow the FP style of working with pure functions, monads, and immutability.</p>
<p>As stated earlier in this book, we believe that Kotlin is the best language if you want a mixture of OOP and FP.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional reactive programming</h1>
                </header>
            
            <article>
                
<p>The concept of functional reactive programming emerged by combining FP paradigms with reactive programming.</p>
<p>The definition of <strong>functional reactive programming</strong> says it is a programming paradigm for reactive programming (asynchronous dataflow programming) using the building blocks of FP (for example, <kbd>map</kbd>, <kbd>reduce</kbd>, and <kbd>filter</kbd>).</p>
<p>So, let's begin by defining reactive programming, and then we will discuss combining them with FP.</p>
<p><strong>Reactive programming</strong> is a modern programming paradigm, which talks about propagation of change, that is, instead of representing the world as a series of states, reactive programming models behavior.</p>
<p>Reactive programming is an asynchronous programming paradigm that revolves around data streams and the propagation of change. In simpler words, those programs which propagate all the changes that affected its data/data streams to all the interested parties (such as end users, components and sub-parts, and other programs that are somehow related) are called <strong>reactive programs</strong>.</p>
<p>Reactive programming is best defined with Reactive Manifesto, as described in the following section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Reactive Manifesto</h1>
                </header>
            
            <article>
                
<p>The <strong>Reactive Manifesto</strong> (<a href="http://www.reactivemanifesto.org">http://www.reactivemanifesto.org</a>) is a document, defining the four reactive principles, which are as follows:</p>
<ul>
<li><strong>Responsive</strong>: The system responds in a timely manner. Responsive systems focus on providing rapid and consistent response times, so they deliver a consistent quality of service.</li>
<li><strong>Resilient</strong>: In case the system faces any failure, it stays responsive. Resilience is achieved by replication, containment, isolation, and delegation. Failures are contained within each component, isolating components from each other, so when failure occurs in a component, it will not affect the other components or the system as a whole.</li>
<li><strong>Elastic</strong>: Reactive systems can react to changes and stays responsive under varying workloads. Reactive systems achieve elasticity in a cost-effective way on commodity hardware and software platforms.</li>
<li><strong>Message-driven</strong>: In order to establish the resilient principle, reactive systems need to establish a boundary between components by relying on asynchronous message-passing.</li>
</ul>
<p>By implementing all the preceding four principles, a system becomes reliable and responsive, thus reactive.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Functional reactive frameworks for Kotlin</h1>
                </header>
            
            <article>
                
<p>For writing reactive programs, we need a library. There are several reactive programming libraries for Kotlin out there to help us on these. Here's a list of the available libraries:</p>
<ul>
<li>RxKotlin</li>
<li>Reactor-Kotlin</li>
<li>Redux-Kotlin</li>
<li>RxKotlin/RxJava and other Reactive Java (ReactiveX) frameworks can also be used with Kotlin (as Kotlin is 100% interoperable with Java-bidirectional)</li>
</ul>
<p class="mce-root">In this book, we will focus on RxKotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with RxKotlin</h1>
                </header>
            
            <article>
                
<p><strong>RxKotlin</strong> is a specific implementation of reactive programming for Kotlin, which is influenced by FP. It favors function composition, the avoidance of global state, and side effects. It relies on the observer pattern of producer/consumer, with a lot of operators that allow composing, scheduling, throttling, transforming, error handling, and life cycle management. ReactiveX frameworks are backed by a large community and Netflix.</p>
<p>Reactor-Kotlin is also based on FP; it is widely accepted and is backed by Spring Framework. Both RxKotlin and Reactor-Kotlin share a lot of similarities (probably because of <strong>Reactive Streams</strong> specifications).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Downloading and setting up RxKotlin</h1>
                </header>
            
            <article>
                
<p>You can download and build RxKotlin from GitHub (<a href="https://github.com/ReactiveX/RxKotlin"><span class="URLPACKT">https://github.com/ReactiveX/RxKotlin</span></a>). It does not require any other dependencies. The documentation on the GitHub Wikipedia page is well-structured. Here is how you can check out the project from GitHub and run the build as follows:</p>
<pre>    <strong>$ git clone https://github.com/ReactiveX/RxKotlin.git</strong>
    <strong>$ cd RxKotlin/</strong>
    <strong>$ ./gradlew build</strong>
  </pre>
<p>You can also use Maven and Gradle, as instructed on the page.</p>
<div class="packt_infobox">We are using RxKotlin version 2.2.0 for this book.</div>
<p>Now, let's take a look at what RxKotlin is all about. We will begin with something well-known, and gradually we will get into the secrets of the library.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Comparing the Pull mechanism with the RxJava Push mechanism</h1>
                </header>
            
            <article>
                
<p>RxKotlin revolves around the <kbd>Observable</kbd> type that represents a system of real-life events and data, intended for push mechanisms, thus it is lazy and can be used in both ways—synchronously and asynchronously.</p>
<p>It'll be easier for us to understand if we start with a simple example that works with a list of data:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    var list:List&lt;Any&gt; = listOf(1, "Two", 3, "Four", "Five", 5.5f) // 1 
    var iterator = list.iterator() // 2 
    while (iterator.hasNext()) { // 3 
        println(iterator.next()) // Prints each element 4 
    } 
} </pre>
<p>The output is as follows:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="189" width="386" src="assets/0caf4afc-685f-495d-86b9-f47683dea1ac.jpg"/></div>
<p>Let's go through the program line by line to understand how it works.</p>
<p>At comment <kbd>1</kbd>, we created a <kbd>list</kbd> with seven items (the <kbd>list</kbd> contains data of mixed data types with the help of <kbd>Any</kbd> class). At comment <kbd>2</kbd>, we created <kbd>iterator</kbd> from the <kbd>list</kbd>, so that we can iterate over the data. In comment <kbd>3</kbd>, we created a <kbd>while</kbd> loop to pull data from the <kbd>list</kbd> with the help of an <kbd>iterator</kbd>, and then at comment <kbd>4</kbd>, we printed it.</p>
<p>The thing to notice here is that we're pulling data from the <kbd>list</kbd> while the current thread is blocked till the data is received and ready. For instance, think of getting that data from a network call/database query instead of just a list, and in that case, how long the thread will be blocked. You can obviously create a separate thread for those operations, but that too will increase complexity.</p>
<p>Just give it a thought, which one is a better approach, making the program wait for data or pushing data to the program whenever it's available?</p>
<p>The building blocks of the ReactiveX framework (be it RxKotlin or RxJava) are the observables. The <kbd>Observable</kbd> class is opposite to Iterator. It has an underlying collection or computation that produces values that can be consumed by a consumer. But the difference is that the consumer doesn't pull these values from the producer like in the Iterator pattern; instead the producer pushes the values as notifications to the consumer.</p>
<p>So, let's take the same example again, this time with <kbd>observable</kbd>:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    var list = listOf(1, "Two", 3, "Four", "Five", 5.5f) // 1 
    var observable = list.toObservable(); 
 
    observable.subscribeBy(  // named arguments for lambda Subscribers 
            onNext = { println(it) }, 
            onError =  { it.printStackTrace() }, 
            onComplete = { println("Done!") } 
    ) 
} </pre>
<p>This program's output is the same as the previous one; it prints all the items in the list. The difference is in its approach. So, let's see how it actually works:</p>
<ol>
<li>Created a list (the same as the previous one)</li>
<li>An <kbd>Observable</kbd> instance is created by the <kbd>list</kbd></li>
<li>We subscribe to the observer (we're using named arguments for lambda; we will cover them in detail later)</li>
</ol>
<p>As we subscribe to the <kbd>observable</kbd> variable, each data will be pushed to <kbd>onNext</kbd> as it gets ready; it'll call <kbd>onComplete</kbd> when all the data is pushed, and <kbd>onError</kbd> if any error occurs.</p>
<p>So, you learned how to use the <kbd>Observable</kbd> instances and that they are quite similar to the Iterator instances, something we're quite familiar with. We can use these <kbd>Observable</kbd> instances for building asynchronous streams and pushing data updates to their subscribers (even to multiple subscribers). This was a simple implementation of the reactive programming paradigm. The data is being propagated to all the interested parties—the subscribers.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Observables</h1>
                </header>
            
            <article>
                
<p>As we discussed earlier, in reactive programming, <kbd>Observable</kbd> has an underlying computation that produces values that can be consumed by a consumer (<kbd>Observer</kbd>). The most important thing here is that the consumer (<kbd>Observer</kbd>) doesn't pull values here; rather, <kbd>Observable</kbd> pushes the values to the consumer. So, we can say that an <kbd>Observable</kbd> interface is a push-based, composable Iterator that emits its items through a series of operators to the final <kbd>Observer</kbd>, which finally consumes the items. Let's now break these things down sequentially to understand it better:</p>
<ul>
<li><kbd>Observer</kbd> subscribes to <kbd>Observable</kbd></li>
<li><kbd>Observable</kbd> starts emitting the items that it has in it</li>
<li><kbd>Observer</kbd> reacts to whatever item the <kbd>Observable</kbd> emits</li>
</ul>
<p>So, let's delve into how <kbd>Observable</kbd> works through its events/methods, namely <kbd>onNext</kbd>, <kbd>onComplete</kbd>, and <kbd>onError</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How Observable works</h1>
                </header>
            
            <article>
                
<p>As we stated earlier, an <kbd>Observable</kbd> value has the following three most important events/methods:</p>
<ul>
<li><kbd>onNext</kbd>: The <kbd>Observable</kbd> interface passes all the items one by one to this method</li>
<li><kbd>onComplete</kbd>: When all the items have gone through the <kbd>onNext</kbd> method, the <kbd>Observable</kbd> calls the <kbd>onComplete</kbd> method</li>
<li><kbd>onError</kbd>: When the <kbd>Observable</kbd> faces any error, it calls the <kbd>onError</kbd> method to deal with the error, if defined</li>
</ul>
<p>One thing to note here is that the item in <kbd>Observable</kbd> that we are talking about can be anything; it is defined as <kbd>Observable&lt;T&gt;</kbd>, where <kbd>T</kbd> can be any class. Even an array/list can be assigned as <kbd>Observable</kbd>.</p>
<p>Let's look at the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img height="343" width="521" src="assets/9a1883a3-293a-427e-82f6-3e786e9e9dea.png"/></div>
<p>Here's a code example to understand it better:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
 
    val observer = object :Observer&lt;Any&gt;{//1 
    override fun onComplete() {//2 
        println("All Completed") 
    } 
 
        override fun onNext(item: Any) {//3 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) {//4 
            println("Error Occured $e") 
        } 
 
        override fun onSubscribe(d: Disposable) {//5 
            println("Subscribed to $d") 
        } 
    } 
 
    val observable = listOf(1, "Two", 3, "Four", "Five", 5.5f).toObservable() //6 
 
    observable.subscribe(observer)//7 
 
    val observableOnList = Observable.just(listOf("One", 2, "Three", "Four", 4.5, "Five", 6.0f), 
            listOf("List with 1 Item"), 
            listOf(1,2,3))//8 
 
 
 
    observableOnList.subscribe(observer)//9 
} </pre>
<p>In the preceding example, we declared the observer instance of the <kbd>Any</kbd> datatype at comment <kbd>1</kbd>.</p>
<div class="packt_infobox">Here, we take the benefit of the <kbd>Any</kbd> datatype. In Kotlin, every class is a child class of <kbd>Any</kbd>. Also, in Kotlin, everything is a class and object; there is no separate primitive datatype.</div>
<p>The <kbd>Observer</kbd> interface has four methods declared in it. The <kbd>onComplete()</kbd> method at comment <kbd>2</kbd> gets called when <kbd>Observable</kbd> is finished with all its items without any error. At comment <kbd>3</kbd>, we defined the <kbd>onNext(item: Any)</kbd> function, which will be called by the <kbd>observable</kbd> value  for each item it has to emit. In that method, we printed the data to the console. At comment <kbd>4</kbd>, we defined the <kbd>onError(e: Throwable)</kbd> method, which will be called in case the <kbd>Observable</kbd> interface faces an error. At comment <kbd>5</kbd>, the <kbd>onSubscribe(d: Disposable)</kbd> method will get called whenever the <kbd>Observer</kbd> subscribes to <kbd>Observable</kbd>. At comment <kbd>6</kbd>, we created an <kbd>Observable</kbd> from a list (<kbd>val observable</kbd>) and subscribed to the <kbd>observable</kbd> value with the <kbd>observer</kbd> value at comment <kbd>7</kbd>. At comment <kbd>8</kbd>, we again created <kbd>observable</kbd> (<kbd>val observableOnList</kbd>), which holds lists as items.</p>
<p>The output of the program is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="340" width="403" src="assets/2785f2bc-9a0a-4d42-9f16-d71184dfe82e.jpg"/></div>
<p>So, as you can see in the output, for the first subscription (comment <kbd>7</kbd>), when we subscribe to the <kbd>observable</kbd> value, it calls the <kbd>onSubscribe</kbd> method, then the <kbd>Observable</kbd> property starts emitting items, as <kbd>observer</kbd> starts receiving them on the <kbd>onNext</kbd> method and prints them. When all the items are emitted from the <kbd>Observable</kbd> property, it calls the <kbd>onComplete</kbd> method to denote that all the items have been successfully emitted. It is the same with the second one, except that here, each item is a list.</p>
<p>As we gained some grip on <kbd>Observables</kbd>, you can now learn a few ways to create Observable factory methods for <kbd>Observable</kbd>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Observable.create method</h1>
                </header>
            
            <article>
                
<p>At any time, you can create your own custom implementation of <kbd>Observable</kbd> with the <kbd>Observable.create</kbd> method. This method takes an instance of the <kbd>ObservableEmitter&lt;T&gt;</kbd> interface as a source to observe. Take a look at the following code example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
 
    val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
            println("All Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Next $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured =&gt; ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
    }//Create Observer 
 
    val observable:Observable&lt;String&gt; = Observable.create&lt;String&gt; {//1 
        it.onNext("Emitted 1") 
        it.onNext("Emitted 2") 
        it.onNext("Emitted 3") 
        it.onNext("Emitted 4") 
        it.onComplete() 
    } 
 
    observable.subscribe(observer) 
 
    val observable2:Observable&lt;String&gt; = Observable.create&lt;String&gt; {//2 
        it.onNext("Emitted 1") 
        it.onNext("Emitted 2") 
        it.onError(Exception("My Exception")) 
    } 
 
    observable2.subscribe(observer) 
} </pre>
<p>First, we created an instance of the <kbd>Observer</kbd> interface as the previous example. I will not elaborate the <kbd>observer</kbd> value, as we have already seen an overview in the previous example, and will see this in detail later in this chapter. At comment <kbd>1</kbd>, we created an <kbd>Observable</kbd> value with the <kbd>Observable.create</kbd> method. We have emitted four strings from the <kbd>Observable</kbd> value with the help of <kbd>onNext</kbd> method, then notified it is complete with the <kbd>onComplete</kbd> method. At comment <kbd>2</kbd>, we almost did the same except here, instead of calling <kbd>onComplete</kbd>, we called <kbd>onError</kbd> with a custom <kbd>Exception</kbd> function.</p>
<p>Here is the output of the program:</p>
<div class="CDPAlignCenter CDPAlign"><img height="268" width="369" src="assets/0a3f8053-dcf0-4265-9e46-6457e646e21a.jpg"/></div>
<p>The <kbd>Observable.create</kbd> method is useful, especially when you are working with a custom data structure and want to have a control over which values are getting emitted. You can also emit values to the observer from a different thread.</p>
<div class="packt_infobox">The <strong>Observable contract</strong> (<a href="http://reactivex.io/documentation/contract.html"><span class="URLPACKT">http://reactivex.io/documentati</span><span class="URLPACKT">on/contract.html</span></a>) states that Observables must issue notifications to observers serially (not in parallel). They may issue these notifications from different threads, but there must be a formal happens-before relationship between the notifications.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Observable.from methods</h1>
                </header>
            
            <article>
                
<p>The <kbd>Observable.from</kbd> methods are comparatively simpler than the <kbd>Observable.create</kbd> method. You can create the <kbd>Observable</kbd> instances from nearly every Kotlin structure with the help of from methods.</p>
<div class="packt_infobox">In RxKotlin 1, you will have <kbd>Observale.from</kbd> as a method; however, from RxKotlin 2.0 (as with RxJava2.0), operator overloads have been renamed with a postfix, such as <kbd>fromArray</kbd>, <kbd>fromIterable</kbd>, and <kbd>fromFuture</kbd>.</div>
<p>Let's take a look at the following code:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
 
    val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
            println("Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Received-&gt; $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured =&gt; ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("Subscription") 
        } 
    }//Create Observer 
 
    val list = listOf("Str 1","Str 2","Str 3","Str 4") 
    val observableFromIterable: Observable&lt;String&gt; = Observable.fromIterable(list)//1 
    observableFromIterable.subscribe(observer) 
 
 
    val callable = object : Callable&lt;String&gt; { 
        override fun call(): String { 
            return "I'm From Callable" 
        } 
 
    } 
    val observableFromCallable:Observable&lt;String&gt; = Observable.fromCallable(callable)//2 
    observableFromCallable.subscribe(observer) 
 
    val future:Future&lt;String&gt; = object : Future&lt;String&gt; { 
        val retStr = "I'm from Future" 
 
        override fun get() = retStr 
 
        override fun get(timeout: Long, unit: TimeUnit?)  = retStr 
 
        override fun isDone(): Boolean = true 
 
        override fun isCancelled(): Boolean = false 
 
        override fun cancel(mayInterruptIfRunning: Boolean): Boolean = false 
 
    } 
    val observableFromFuture:Observable&lt;String&gt; = Observable.fromFuture(future)//3 
    observableFromFuture.subscribe(observer) 
} </pre>
<p>At comment <kbd>1</kbd>, we used the <kbd>Observable.fromIterable</kbd> method to create <kbd>Observable</kbd> from an <kbd>Iterable</kbd> instance (here, <kbd>list</kbd>). At comment <kbd>2</kbd>. We called the <kbd>Observable.fromCallable</kbd> method to create <kbd>Observable</kbd> from a <kbd>Callable</kbd> instance, we did the same at comment <kbd>3</kbd>, where we called the <kbd>Observable.fromFuture</kbd> method to derive <kbd>Observable</kbd> from a <kbd>Future</kbd> instance.</p>
<p>Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="221" width="200" src="assets/0acfe4dd-acb4-44c8-b9f7-33e32fc9722e.jpg"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Iterator&lt;T&gt;.toObservable</h1>
                </header>
            
            <article>
                
<p>Thanks to the extension functions of Kotlin, you can turn any <kbd>Iterable</kbd> instance, such as <kbd>list</kbd>, to <kbd>Observable</kbd> without much effort. We have already used this method in <a href="6fd42581-3c3e-4471-b103-22a571a138a4.xhtml">Chapter 1</a>, <em>Kotlin – Data Types, Objects, and Classes</em>, but again take a look at this:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val observer: Observer&lt;String&gt; = object : Observer&lt;String&gt; { 
        override fun onComplete() { 
            println("Completed") 
        } 
 
        override fun onNext(item: String) { 
            println("Received-&gt; $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occured =&gt; ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("Subscription") 
        } 
    }//Create Observer 
    val list:List&lt;String&gt; = listOf("Str 1","Str 2","Str 3","Str 4") 
 
    val observable: Observable&lt;String&gt; = list.toObservable() 
 
    observable.subscribe(observer) 
 
} </pre>
<p>The output is as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="158" width="321" src="assets/0ed751e5-b092-40cf-b3b0-82c6b2c25d1c.jpg"/></div>
<p>So, aren't you curious to look into the <kbd>toObservable</kbd> method? Let's do it. You can find this method inside the <kbd>observable.kt</kbd> file provided with the <kbd>RxKotlin</kbd> package:</p>
<pre>fun &lt;T : Any&gt; Iterator&lt;T&gt;.toObservable(): Observable&lt;T&gt; = toIterable().toObservable() 
fun &lt;T : Any&gt; Iterable&lt;T&gt;.toObservable(): Observable&lt;T&gt; = Observable.fromIterable(this) 
fun &lt;T : Any&gt; Sequence&lt;T&gt;.toObservable(): Observable&lt;T&gt; = asIterable().toObservable() 
 
fun &lt;T : Any&gt; Iterable&lt;Observable&lt;out T&gt;&gt;.merge(): Observable&lt;T&gt; = Observable.merge(this.toObservable()) 
fun &lt;T : Any&gt; Iterable&lt;Observable&lt;out T&gt;&gt;.mergeDelayError(): Observable&lt;T&gt; = Observable.mergeDelayError(this.toObservable()) </pre>
<p>So, it uses the <kbd>Observable.from</kbd> method internally, thanks again to the extension functions of Kotlin.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscriber – the Observer interface</h1>
                </header>
            
            <article>
                
<p>In RxKotlin 1.x, the <kbd>Subscriber</kbd> operator essentially became an <kbd>Observer</kbd> type in RxKotlin 2.x. There is an <kbd>Observer</kbd> type in RxKotlin 1.x, but the <kbd>Subscriber</kbd> value is what you pass to the <kbd>subscribe()</kbd> method, and it implements <kbd>Observer</kbd>. In RxJava 2.x, a <kbd>Subscriber</kbd> operator only exists when talking about <kbd>Flowables</kbd>. </p>
<p>As you can see in the previous examples in this chapter, an <kbd>Observer</kbd> type is an interface with four methods in it, namely <kbd>onNext(item:T)</kbd>, <kbd>onError(error:Throwable)</kbd>, <kbd>onComplete()</kbd>, and <kbd>onSubscribe(d:Disposable)</kbd>. As stated earlier, when we connect <kbd>Observable</kbd> to <kbd>Observer</kbd>, it looks for these four methods in the <kbd>Observer</kbd> type and calls them. Here is a short description of the following four methods:</p>
<ul>
<li><kbd>onNext</kbd>: The <kbd>Observable</kbd> calls this method of <kbd>Observer</kbd> to pass each of the items one by one</li>
<li><kbd>onComplete</kbd>: When the <kbd>Observable</kbd> wants to denote that it's done with passing items to the <kbd>onNext</kbd> method, it calls the <kbd>onComplete</kbd> method of <kbd>Observer</kbd></li>
<li><kbd>onError</kbd>: When <kbd>Observable</kbd> faces any error, it calls the <kbd>onError</kbd> method to deal with the error if defined in the <kbd>Observer </kbd> type, otherwise it throws the exception</li>
<li><kbd>onSubscribe</kbd>: This method is called whenever a new <kbd>Observable</kbd> subscribes to <kbd>Observer</kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Subscribing and disposing</h1>
                </header>
            
            <article>
                
<p>So, we have <kbd>Observable</kbd> (the thing that should be observed upon) and we have the <kbd>Observer</kbd> type (that should be observed), now what? How do we connect them? <kbd>Observable</kbd> and <kbd>Observer</kbd> are like an input device (be it keyboard or mouse) and the computer; we need something to connect them (even wireless input devices have some connectivity channels, be it Bluetooth or Wi-Fi).</p>
<p>The <kbd>subscribe</kbd> operator serves the purpose of the media by connecting an <kbd>Observable</kbd> interface to <kbd>Observer</kbd>. We can pass one to three methods (<kbd>onNext</kbd>, <kbd>onComplete</kbd>, and <kbd>onError</kbd>) to the <kbd>subscribe</kbd> operator, or we can pass an instance of the <kbd>Observer</kbd> interface to the subscribe operator to get the <kbd>Observable</kbd> interface connected with <kbd>Observer</kbd>.</p>
<p>So, let's look at an example now:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
    val observable = Observable.range(1,5)//1 
 
    observable.subscribe({//2 
        //onNext method 
        println("Next-&gt; $it") 
    },{ 
        //onError Method 
        println("Error=&gt; ${it.message}") 
    },{ 
        //onComplete Method 
        println("Done") 
    }) 
 
    val observer: Observer&lt;Int&gt; = object : Observer&lt;Int&gt; {//3 
    override fun onComplete() { 
        println("All Completed") 
    } 
 
        override fun onNext(item: Int) { 
            println("Next-&gt; $item") 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error Occurred=&gt; ${e.message}") 
        } 
 
        override fun onSubscribe(d: Disposable) { 
            println("New Subscription ") 
        } 
    } 
 
    observable.subscribe(observer) 
} </pre>
<p>In this example, we have created an <kbd>Observable</kbd> instance (at comment <kbd>1</kbd>) and used it twice with different overload <kbd>subscribe</kbd> operators. At comment <kbd>2</kbd>, we passed three methods as arguments to the <kbd>subscribe</kbd> method. The first parameter is the <kbd>onNext</kbd> method, the second one is the <kbd>onError</kbd> method, and the last one is <kbd>onComplete</kbd>. At comment <kbd>2</kbd>, we passed an instance of the <kbd>Observer</kbd> interface.</p>
<p>The output can be easily predicted, so we are skipping it.</p>
<p>So, we have got the concepts of subscribing, and can do it now. What about if you want to stop the emissions after some period of subscription? There must be a way, right? So, let's inspect this.</p>
<p>Remember the <kbd>onSubscribe</kbd> method of <kbd>Observer</kbd>? There was a parameter on that method which we haven't discussed yet. While you subscribe, if you pass the methods instead of the <kbd>Observer</kbd> instance, then the <kbd>subscribe</kbd> operator will return an instance of <kbd>Disposable</kbd>, or if you use an instance of <kbd>Observer</kbd>, then you will get the instance of <kbd>Disposable</kbd> in the parameter of the <kbd>onSubscribe</kbd> method.</p>
<p>You can use the instance of the <kbd>Disposable</kbd> interface to stop emissions at any given time. Let's look at an example:</p>
<pre>fun main(args: Array&lt;String&gt;) { 
 
    val observale = Observable.interval(100, TimeUnit.MILLISECONDS)//1 
    val observer = object : Observer&lt;Long&gt; { 
 
        lateinit var disposable: Disposable//2 
 
        override fun onSubscribe(d: Disposable) { 
            disposable = d//3 
        } 
 
        override fun onNext(item: Long) { 
            println("Received $item") 
            if (item &gt;= 10 &amp;&amp; !disposable.isDisposed) {//4 
                disposable.dispose()//5 
                println("Disposed") 
            } 
        } 
 
        override fun onError(e: Throwable) { 
            println("Error ${e.message}") 
        } 
 
        override fun onComplete() { 
            println("Complete") 
        } 
 
    } 
    runBlocking { 
        observale.subscribe(observer) 
        delay(1500)//6 
    } 
} </pre>
<p>Here, we used the <kbd>Observable.interval</kbd> factory method. This method takes two parameters describing the interval period and time unit; it then emits integers sequentially starting from zero. <kbd>Observable</kbd> created with <kbd>interval</kbd> never completes and never stops until you dispose off them, or the program stops execution. I thought it would be the perfect fit in this scenario as we want to stop the <kbd>Observable</kbd> midway here.</p>
<p>So, in this example, at comment <kbd>1</kbd>, we created <kbd>Observable</kbd> with the <kbd>Observable.interval</kbd> factory method that will emit an integer after each <kbd>100</kbd> milliseconds interval.</p>
<p>At comment <kbd>2</kbd>, I have declared <kbd>lateinit var disposable</kbd> of the <kbd>Disposable</kbd> <span>type </span>(<kbd>lateinit</kbd> means the variable will get initialized at a later point in time). At comment <kbd>3</kbd>, inside the <kbd>onSubscribe</kbd> method, we will assign the received parameter value to the <kbd>disposable</kbd> variable.</p>
<p>We intend to stop the execution after the sequence reached <kbd>10</kbd>, that is, after <kbd>10</kbd> is emitted, the emission should be stopped immediately. To achieve this, we placed a check inside the <kbd>onNext</kbd> method, where we are checking the value of the emitted item. We check whether it's equal to or greater than <kbd>10</kbd>, and if the emission is not already stopped (disposed), then we dispose the emission (comment <kbd>5</kbd>).</p>
<p>Here is the output:</p>
<div class="CDPAlignCenter CDPAlign"><img height="287" width="370" src="assets/df453c98-95e6-4a48-954d-6a5d66d66886.jpg"/></div>
<p>From the output, we can see that no integer got emitted after the <kbd>disposable.dispose()</kbd> method was called, though the execution waited for 500 milliseconds more (100*10 = 1000 milliseconds to print the sequence till <kbd>10</kbd>, and we called the delay method with <kbd>1500</kbd>, thus 500 milliseconds after emitting <kbd>10</kbd>).</p>
<p>If you are curious to know the <kbd>Disposable</kbd> interface, then the following is the definition:</p>
<pre>interface Disposable { 
  /** 
 * Dispose the resource, the operation should be idempotent. 
 */ 
  fun dispose() 
  /** 
 * Returns true if this resource has been disposed. 
 * @return true if this resource has been disposed 
 */ 
  val isDisposed:Boolean 
} </pre>
<p>It has one property that denotes that the emission is already notified to stop (disposed) and a method to notify the emission to stop (dispose).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, you learned about combining FP concepts with OOP and reactive programming. We even discussed RxKotlin and covered the setup and basic usage of RxKotlin.</p>
<p>The next chapter is about more advanced FP concepts—monads, functors, and applicatives, and how to implement them with Kotlin. Monads, functors, and applicatives are some of the must-know concepts and are often referred to as the building blocks of FP. So, don't skip the next chapter if you are truly willing to learn about FP. Turn the page now.</p>


            </article>

            
        </section>
    </body></html>