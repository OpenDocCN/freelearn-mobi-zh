<html><head></head><body>
		<div><h1 id="_idParaDest-90"><em class="italic"><a id="_idTextAnchor186"/>Chapter 6</em>: Adding Offline Capabilities with Jetpack Room</h1>
			<p>In this chapter, we're starting our journey of exploring ways to architecture our apps by first making sure that our application can be used without an internet connection.</p>
			<p>In the <em class="italic">Introducing Jetpack Room</em> section, we will briefly note the various caching mechanisms that are on Android. Then, we will introduce the Jetpack Room library and its core elements.</p>
			<p>Next, in the <em class="italic">Enabling offline usage by implementing Room</em> section, we will implement Room in our Restaurants app and allow users to use the application without an internet connection. In the <em class="italic">Applying partial updates to the Room database</em> section, we will learn how to partially update data inside Room so that we can save selections such as whether the restaurants were favorited by the user.</p>
			<p>Finally, in the <em class="italic">Making local data the single source of truth for app content</em> section, we will understand why having a single source of truth for app data is beneficial, and then we will set the Room database as the single source of content for our app.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing Jetpack Room</li>
				<li>Enabling offline usage by implementing Room</li>
				<li>Applying partial updates to the Room database</li>
				<li>Making local data the single source of truth for app content</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor187"/>Technical requirements</h1>
			<p>Usually, building Compose-based Android projects with Jetpack Room will require your day-to-day tools. However, to follow along with the examples smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10, or newer, plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter.</li>
				<li>Minimal knowledge of SQL databases and queries</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application that was developed in the previous chapter. If you haven't followed the implementation described in the previous chapter, access the starter code for this chapter by navigating to the <code>Chapter_05</code> directory of the repository. Then, import the Android project entitled <code>chapter_5_restaurants_app</code>.</p>
			<p>To access the solution code for this chapter, navigate to the <code>Chapter_06</code> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app</a>.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor188"/>Introducing Jetpack Room</h1>
			<p>Modern applications should be available for use in any conditions, including when the user is missing an internet connection. This allows apps to provide a seamless user experience and usability even when the user's device cannot access the network.</p>
			<p>In this section, we will discuss the following:</p>
			<ul>
				<li>Exploring the caching mechanism on Android</li>
				<li>Introducing Jetpack Room as a solution for local caching</li>
			</ul>
			<p>So, let's begin!</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor189"/>Exploring the caching mechanism on Android</h2>
			<p>To cache specific content<a id="_idIndexMarker433"/> or application data, reliable Android apps make<a id="_idIndexMarker434"/> use of the various offline caching mechanisms that are suitable for different use cases:</p>
			<ul>
				<li>Shared preferences are used to store lightweight data (such as user-related selections) as key-value pairs. This option shouldn't be used to store objects that are part of the app's content.</li>
				<li>Device storage (either internal or external) is used for storing heavyweight data (such as files, pictures, and more).</li>
				<li>SQLite database is used for storing app content in a structured manner inside a private database. <strong class="bold">SQLite</strong> is <a id="_idIndexMarker435"/>an open source SQL database that stores data in private text files.</li>
			</ul>
			<p>In this chapter, we will focus on learning how to cache structured content (which is, usually, held by Kotlin <code>data class</code> objects) within a SQLite database. In this way, we allow the user to browse the app's data while remaining offline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Android comes with a built-in SQLite database implementation that allows us to save structured data.</p>
			<p>In our app, we can consider the array of restaurants to be a perfect candidate for app content that can be saved inside a SQLite database. Since the data is structured, with SQLite, we get the advantage of being able to perform different actions such as searching for restaurants within the database, updating particular restaurants, and more.</p>
			<p>By caching app content in this way, we can allow users to browse the app's restaurants while offline. However, for this to work, the users need to have previously opened the app using an active internet connection, thereby allowing the app to cache the contents for future offline use.</p>
			<p>Now, to save the restaurants to the SQLite private database, we need to make use of the SQLite APIs. These <a id="_idIndexMarker436"/>APIs are powerful. However, by using them, you face quite a few disadvantages:</p>
			<ul>
				<li>The APIs are of a low level and are relatively difficult to use.</li>
				<li>The SQLite APIs provide no compile-time verification of SQL queries, which can lead to unwanted runtime errors.</li>
				<li>There is a lot<a id="_idIndexMarker437"/> of boilerplate code involved in creating a database, performing SQL queries, and more.</li>
			</ul>
			<p>To mitigate these issues, Google provides the Jetpack Room library. This library is nothing more than a wrapper library that simplifies the way we access and interact with the SQLite database.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor190"/>Introducing Jetpack Room as a solution for local caching</h2>
			<p><strong class="bold">Room</strong> is a <a id="_idIndexMarker438"/>persistence library that is defined as an abstraction<a id="_idIndexMarker439"/> layer over SQLite and provides simplified database access while taking advantage of the power of the SQLite APIs.</p>
			<p>As opposed to using the raw SQLite APIs, Room abstracts most of the complexity associated with working with SQLite. The library removes most of the unpleasant boilerplate code that is required to set up and interact with SQLite databases on Android while also providing the compile-time checking of SQL queries.</p>
			<p>To make use of the Room library and cache contents using its API, you need to define three primary components:</p>
			<ul>
				<li><code>Restaurant</code> data class as an entity. This means that we will have a table populated with <code>Restaurant</code> objects. In other words, the rows of the table are represented by instances of our restaurants.</li>
				<li>A database class <a id="_idIndexMarker441"/>that will contain and expose the actual database.</li>
				<li><strong class="bold">Data Access Objects</strong> (<strong class="bold">DAOs</strong>) that<a id="_idIndexMarker442"/> represent an interface. This allows us to get, insert, delete, or update the actual content within the database.</li>
			</ul>
			<p>The database class provides us with a reference to the DAO interface associated with the SQLite database:</p>
			<div><div><img src="img/B17788_06_1.jpg" alt="Figure 6.1 – The interaction between the application and the Room database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The interaction between the application and the Room database</p>
			<p>As previously <a id="_idIndexMarker443"/>illustrated, we can use the DAO to retrieve or update the<a id="_idIndexMarker444"/> data from the database in the form of entity objects – in our case, the entity is the restaurant, so we will be applying such operations to restaurant objects.</p>
			<p>Now that we have a basic understanding of how Room works and how we can interact with it, it's time to see it in action for ourselves and implement Room in our Restaurants app.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor191"/>Enabling offline usage by implementing Room</h1>
			<p>We want to <a id="_idIndexMarker445"/>locally cache all the restaurants that we <a id="_idIndexMarker446"/>receive from our Firebase database. Since this content is structured, we want to use Room to help us with this task.</p>
			<p>Essentially, we are trying to save the restaurants when the user is browsing our Restaurants app while online. Then, we will reuse them when the user browses the app while being offline:</p>
			<div><div><img src="img/B17788_06_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Data retrieval for the Restaurants app with two sources of truth</p>
			<p>When online, we<a id="_idIndexMarker447"/> retrieve the restaurants from our web<a id="_idIndexMarker448"/> API. Before displaying them to the user, first, we will cache them to our Room database. If offline, we will retrieve the restaurants from the Room database and then display them to the user.</p>
			<p>Essentially, we are creating two sources of truth for our app:</p>
			<ul>
				<li>The remote API for when the user is online</li>
				<li>The local Room database for when the user is offline</li>
			</ul>
			<p>In the next section, we will discuss why this approach is not ideal. However, until then, we are content with the fact that we will be able to use the app while remaining offline.</p>
			<p>Let's start implementing Room, and then let's cache those restaurants! Perform the following steps:</p>
			<ol>
				<li>Inside the <code>build.gradle</code> file in the app module, add the dependencies for Room inside the <code>dependencies</code> block:<pre>implementation "androidx.room:room-runtime:2.4.2"
kapt "androidx.room:room-co<a id="_idTextAnchor192"/>mpiler:2.4.2"
implementation "androidx.room:room-ktx:2.4.2"</pre></li>
				<li>While you are still inside the <code>build.gradle</code> file, add the <code>kotlin-kapt</code> plugin for Room inside the <code>plugins</code> block:<pre>plugins {
    id 'com.android.application'
    id 'kotli<a id="_idTextAnchor193"/>n-android'
    <strong class="bold">id 'kotlin-kapt'</strong>
}</pre></li>
			</ol>
			<p>The <code>kapt</code> plugin stands<a id="_idIndexMarker449"/> for <strong class="bold">Kotlin Annotation Processing Tool</strong>. This allows Room to generate annotated code at compile time while hiding most of the associated complexity from us.</p>
			<p>After <a id="_idIndexMarker450"/>updating the <code>build.gradle</code> files, make <a id="_idIndexMarker451"/>sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="3">Since we want to store restaurant objects inside our local database, let's instruct Room that the <code>Restaurant</code> data class is an entity that must be saved. Head inside the <code>Restaurant.kt</code> file, and add the <code>@Entity</code> annotation on top of the cl<a id="_idTextAnchor194"/>ass declaration:<pre><strong class="bold">@Entity(tableName = "restaurants")</strong>
data class Restaurant(…)</pre></li>
			</ol>
			<p>Inside the <code>@Entity</code> annotation, we have passed the name of the table via the <code>tableName</code> parameter. We will use this name when making queries.</p>
			<ol>
				<li value="4">Now that Room will create a table with <code>Restaurant</code> objects as rows, it's time to define the columns (or fields) of the entity. While we are still inside the <code>Restaurant.kt</code> class, let's add the <code>@ColumnInfo</code> annotation on top of each field that we're interested in, and that should represent a column:<pre>@Entity(tableName = "restaurants")
data class<a id="_idTextAnchor195"/> Restaurant(
    <strong class="bold">@ColumnInfo(name = "r_id")</strong>
    @SerializedName("r_id")
    <a id="_idTextAnchor196"/>val id: Int,
    <strong class="bold">@ColumnInfo(name = "r_title")</strong>
    @SerializedName("r_title")
    val ti<a id="_idTextAnchor197"/>tle: String,
    <strong class="bold">@ColumnInfo(name = "r_description")</strong>
    @SerializedName("r_description")
    val description: String,
    var isFavorite: Boolean = false
)</pre></li>
			</ol>
			<p>For each <a id="_idIndexMarker452"/>field we're interested in saving, we've <a id="_idIndexMarker453"/>added the <code>@ColumnInfo</code> annotation and passed a <code>String</code> value to the <code>name</code> parameter. These names will correspond to the name of the table's columns. Right now, we are not interested in saving the <code>isFavorite</code> field; we will do that a bit later.</p>
			<ol>
				<li value="5">The entity that represents a table should have a primary key column that ensures uniqueness within the database. For this, we can use the <code>id</code> field that was configured from our Firebase database to be unique. While still inside the <code>Restaurant.kt</code> class, let's add the <code>@PrimaryKey</code> annotation to the <code>id</code> field:<pre>@Entity(tableName = "restaurants")
data cla<a id="_idTextAnchor198"/>ss Restaurant(
    <strong class="bold">@PrimaryKey()</strong>
    @ColumnInfo(name = "r_id")
    @SerializedName("r_id")
    val id: Int,
    …)</pre></li>
			</ol>
			<p>Now we have defined the entity for our database and configured the table's columns.</p>
			<p>It's time to create a DAO that will serve as the entry point to our database, allowing us to perform various actions on it. </p>
			<ol>
				<li value="6">Create a DAO by clicking on the application package, selecting <code>RestaurantsDao</code> as the name, and select <strong class="bold">Interface</strong> as the type. Inside the new file, add the following code:<pre>import and<a id="_idTextAnchor199"/>roidx.room.*
@Dao
interface RestaurantsDao { }</pre></li>
			</ol>
			<p>Since Room <a id="_idIndexMarker454"/>will take care of implementing any <a id="_idIndexMarker455"/>actions that we need to interact with the database, the DAO is an interface, just like Retrofit also had an interface for the HTTP methods. To instruct Room that this is a DAO entity, we've added the <code>@Dao</code> annotation on top of the interface dec<a id="_idTextAnchor200"/>laration.</p>
			<ol>
				<li value="7">Inside the <code>RestaurantsDao</code> interface, add two <code>suspend</code> functions that will help us to both save the restaurants and retrieve them from the database:<pre>@Dao
interface<a id="_idTextAnchor201"/> RestaurantsDao {
<strong class="bold">    @Query("SELECT * FROM restaurants")</strong>
<strong class="bold">    suspend fun getAll(): List&lt;Restaurant&gt;</strong>
<strong class="bold">    @Insert(onConflict = OnConflictStrategy.REPLACE)</strong>
<strong class="bold">    suspend fun addAll(restaurants: List&lt;Restaurant&gt;)</strong>
}</pre></li>
			</ol>
			<p>Now, let's analyze the two methods that we've added:</p>
			<ul>
				<li><code>getAll()</code> is a <a id="_idIndexMarker456"/>query statement that returns the restaurants that were previously cached inside the database. Since we<a id="_idIndexMarker457"/> need to perform a SQL query when calling this method, we've marked it with the <code>@Query</code> annotation and specified that we want all the restaurants (by adding <code>*</code>) from the <code>restaurants</code> table defined in the <code>Restaurant</code> entity data class.</li>
				<li><code>addAll()</code> is an <code>insert</code> statement that caches the received restaurants inside the database. To mark this as a SQL <code>insert</code> statement, we've added the <code>@Insert</code> annotation. However, if the restaurants being inserted are already present in the database, we should replace the old ones with the new ones to refresh our cache. We instructed Room to do so by passing the <code>OnConflictStrategy.REPLACE</code> value into the <code>@Insert</code> annotation.</li>
			</ul>
			<p>Both methods are marked as <code>suspend</code> functions because any interaction with the Room database can take time and is an async job; therefore, it shouldn't block the UI.</p>
			<p>Now, we have defined an entity class and a DAO class, we must define the last component that Room needs in order to function, the database class.</p>
			<ol>
				<li value="8">Create a Room database class by clicking on the application package. Select <code>RestaurantsDb</code> as the name, and select <strong class="bold">File</strong> as the type. Inside the new file, add the following code:<pre>@Database(
    entities = [Restaurant::class], 
    version = 1, 
    exportSchema = false)
abstract class RestaurantsDb : RoomDatabase() { }</pre></li>
			</ol>
			<p>Now, let's analyze the code that we've just added:</p>
			<ul>
				<li><code>RestaurantsDb</code> is an abstract class that inherits from <code>RoomDatabase()</code>. This will allow Room to create the actual implementation of the database behind the scenes and hide all the heavy implementation details from us.</li>
				<li>For the <code>RestaurantsDb</code> class, we've added the <code>@Database</code> annotation so that Room knows that this class represents a database and provides an implementation for it. Inside this annotation, we've passed the following:</li>
				<li>The <code>Restaurant</code> class to the <code>entities</code> parameter. This parameter tells Room<a id="_idIndexMarker458"/> which entities are associated<a id="_idIndexMarker459"/> with this database so that it can create corresponding tables. The parameter expects an array, so you can add as many entity classes as you wish, as long as they are annotated with <code>@Entity</code>.</li>
				<li><code>1</code> as the <code>version</code> number of the database. We should increment this version number whenever the schema of the database changes. The <code>Restaurant</code> class, since it's an entity, we might change the schema of the database, and Room needs to know that for migration purposes.</li>
				<li><code>false</code> to the <code>exportSchema</code> parameter. Room can export the schema of our database externally; however, for simplicity, we chose not to do so.</li>
			</ul>
			<ol>
				<li value="9">Inside the <code>RestaurantsDb</code> class, add an abstract <code>RestaurantsDao</code> variable:<pre>@Database(…)
abstract class Restaurants<a id="_idTextAnchor203"/>Db : RoomDatabase() {
    <strong class="bold">abstract val dao: RestaurantsDao</strong>
}</pre></li>
			</ol>
			<p>We know that the database class should expose a DAO object so that we can interact with the database. By leaving it abstract, we allow Room to provide its implementation behind the scenes.</p>
			<ol>
				<li value="10">Even though we<a id="_idIndexMarker461"/> declared a variable <a id="_idIndexMarker462"/>to hold our DAO object, we still need to find a way to build the database and obtain a reference to the <code>RestaurantsDao</code> instance that Room will create for us. Inside the <code>RestaurantsDb</code> class, add <code>companion object</code> and then add the <code>buildDatabase</code> method:<pre>@Database(…)
abstract class RestaurantsDb : RoomDatabase() {
    abstract val dao: RestaurantsDao
<strong class="bold">    companion object {</strong>
<strong class="bold">        private fun buildDatabase(context: Context): </strong>
<strong class="bold">            RestaurantsDb =</strong>
<strong class="bold">            Room.databaseBuilder(</strong>
<strong class="bold">                context.applicationContext,</strong>
<strong class="bold">                RestaurantsDb::class.java,</strong>
<strong class="bold">                "restaurants_database")</strong>
<strong class="bold">                .fallbackToDestructiveMigration()</strong>
<strong class="bold">                .build()</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>Essentially, this method returns a <code>RestaurantsDb</code> instance. To construct a Room database, we need to call the <code>Room.databaseBuilder</code> constructor, which expects the following parameters:</p>
			<ul>
				<li>A <code>Context</code> object that we provided from the <code>context</code> input argument of our <code>buildDatabase</code> method. </li>
				<li>The class of the<a id="_idIndexMarker463"/> database you're trying to build, that is, the <code>RestaurantsDb</code> class.</li>
				<li>A name for the<a id="_idIndexMarker464"/> database – we named it <code>"restaurants_database"</code>.</li>
			</ul>
			<p>The builder returns a <code>RoomDatabase.Builder</code> object on which we called <code>.fallbackToDestructiveMigration()</code>. This means that, in the case of a schema change (such as performing changes in the entity class and modifying the table columns), the tables would be dropped (or deleted) instead of trying to migrate the contents from the previous schema (which would have been a bit more complex).</p>
			<p>Finally, we called <code>build()</code> on the builder object so that our <code>buildDatabase()</code> method returns a <code>RestaurantsDb</code> instance.</p>
			<p>It's time to finally get a reference to our DAO so that we can start using the database.</p>
			<ol>
				<li value="11">While still inside the <code>companion object</code> of the <code>RestaurantsDb</code> class, add the following code:<pre>companion object {
<strong class="bold">    @Volatile</strong>
<strong class="bold">    private var INSTANCE: RestaurantsDao? = null</strong>
<strong class="bold">    fun getDaoInstance(context: Context): RestaurantsDao   </strong>
<strong class="bold">    {</strong>
<strong class="bold">        synchronized(this) {</strong>
<strong class="bold">            var instance = INSTANCE</strong>
<strong class="bold">            if (instance == null) {</strong>
<strong class="bold">                instance = buildDatabase(context).dao</strong>
<strong class="bold">                INSTANCE = instance</strong>
<strong class="bold">            }</strong>
<strong class="bold">            <a id="_idTextAnchor204"/>return instance</strong>
<strong class="bold">        }</strong>
<strong class="bold">    }</strong>
    private fun buildDatabase(…) = …
}</pre></li>
			</ol>
			<p>Now, let's break down what we've done:</p>
			<ul>
				<li>We added <a id="_idIndexMarker465"/>an <code>INSTANCE</code> variable of <a id="_idIndexMarker466"/> type <code>RestaurantsDao</code>. Since this variable is inside the companion object, <code>INSTANCE</code> is static. Additionally, we marked it with <code>@Volatile</code>. This means that writes to this field are immediately made visible to other threads. Don't worry too much about these multithreading concepts – we will get rid of this boilerplate code soon enough.</li>
				<li>We created a <code>getDaoInstance()</code> method where we added a block of code that calls the <code>buildDatabase()</code> method and gets the DAO object by calling the <code>.dao</code> accessor.</li>
			</ul>
			<p>Since we want only one memory reference to our database (and not create other database<a id="_idIndexMarker467"/> instances in other parts of the app), we made sure that our <code>INSTANCE</code> variable conforms to the singleton pattern. Essentially, the <strong class="bold">singleton pattern</strong> allows<a id="_idIndexMarker468"/> us to hold a static reference to an object so that it lives as long as our application does.</p>
			<p>By following this approach, anytime we need to access the Room database from different parts of the app, we can call the <code>getDaoInstance()</code> method, which returns an instance of <code>RestaurantsDao</code>. Additionally, we can be sure that it's always the same memory reference and that no concurrency issues will occur since we have wrapped the instance creation code inside a <code>synchronized</code> block.</p>
			<ol>
				<li value="12">You might have noticed that to get a reference to our DAO and cache our restaurants in the<a id="_idIndexMarker469"/> database, the <code>RestaurantsDb.getDaoInstance()</code> method expects a <code>Context</code> object. This is needed to create the instance of the database. However, we want to get our DAO in the <code>RestaurantsViewModel</code> class, and we have no context there, so what should we do?</li>
			</ol>
			<p>Let's expose the application context from the application class! Create the application class by clicking on the application package, selecting <code>RestaurantsApplication</code> as the name, and select <strong class="bold">File</strong> as the type. Inside the new file, add the following code:</p>
			<pre>class RestaurantsApplication: Application() {
    init { app = this }
    companion object {
        private lateinit var app: RestaurantsApplication
        fun getAppContext(): Context = 
  <a id="_idTextAnchor206"/>          app.applicationContext
    }
}</pre>
			<p>This class now inherits from <code>android.app.Application</code> and exposes its context through the static <code>getAppContext()</code> method. The only issue is that even though we have an application class, we still haven't configured the project to recognize it.</p>
			<ol>
				<li value="13">In the <code>AndroidManifest.xml</code> file, inside the <code>&lt;application&gt;</code> element, add the <code>android:name</code> identifier that <a id="_idIndexMarker470"/>sets our <code>RestaurantsApplication</code> class as<a id="_idIndexMarker471"/> the application class:<pre>&lt;applicatio<a id="_idTextAnchor207"/>n
    android:allowBackup="true"
    <strong class="bold">android:name=".RestaurantsApplication"</strong>
    android:icon="@mipmap/ic_launcher"
    …
    &lt;activity&gt; … &lt;/activity&gt;
&lt;/application&gt;</pre></li>
			</ol>
			<p>It's time to finally start working on caching those res<a id="_idTextAnchor208"/>taurants in our database.</p>
			<ol>
				<li value="14">Inside the <code>RestaurantsViewModel</code> class, add a <code>restaurantsDao</code> variable. Then, instantiate it via the static <code>RestaurantsDb.getDaoInstance</code> method:<pre>class RestaurantsViewModel(…) : ViewModel() {
    private var restInterface: RestaurantsApiService
    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong>
<strong class="bold">        .getDaoInstance(</strong>
<strong class="bold">            RestaurantsApplication.getAppContext()</strong>
        <strong class="bold">)</strong>
     ....
}</pre></li>
			</ol>
			<p>Make sure that you pass the application context through the newly created <code>getAppContext()</code> method inside the application class.</p>
			<ol>
				<li value="15">Now we're ready to save the <a id="_idIndexMarker472"/>restaurants locally! While you are still in the <code>R<a id="_idTextAnchor209"/>estaurantsViewModel</code> class, inside the <code>getRemoteRestaurants()</code> method, add<a id="_idIndexMarker473"/> these new lines of code:<pre>private suspend fun getRemoteRestaurants(): 
    List&lt;Restaurant&gt; {
    retur<a id="_idTextAnchor210"/>n withContext(Dispatchers.IO) {
        <strong class="bold">val restaurants =</strong> restInterface.getRestaurants()
<strong class="bold">        restaurantsDao.addAll(restaurants)</strong>
<strong class="bold">        return@withContext restaurants</strong>
    }
}</pre></li>
			</ol>
			<p>Essentially, what we are doing is the following: </p>
			<p>I.	Getting the restaurants from the remote API (here, it's the Retrofit <code>restInterface</code> variable).</p>
			<p>II.	Caching those restaurants inside the local database through Room by calling <code>restaurantsDao.addAll()</code>.</p>
			<p>III.	Finally, returning the restaurants to the UI.</p>
			<ol>
				<li value="16">Run the app while you have a working internet connection.</li>
			</ol>
			<p>In terms of the UI, nothing should change – you should still see the restaurants. That said, behind the scenes, the restaurants should now have been cached.</p>
			<ol>
				<li value="17">Run the app again but without internet.</li>
			</ol>
			<p>The chances are that you won't see anything. The restaurants are not there.</p>
			<p>This happens because, while we are offline, we never try to get the previously cached restaurants from the Room database. Moreover, when offline, the <code>restInterface.getRestaurants()</code> suspending function throws an error because the HTTP call that fetches the restaurants has failed<a id="_idTextAnchor211"/> – this exception should arrive inside <code>CoroutineExceptionHandler</code>. The exception is thrown by Retrofit because the associated network request has failed.</p>
			<ol>
				<li value="18">Let's leverage<a id="_idIndexMarker474"/> the fact that, while we're<a id="_idIndexMarker475"/> offline, the <code>restInterface.getRestaurants()</code> function call throws an exception. This is so that we can wrap the whole block of code inside <code>getRemoteRestaurants()</code> inside a <code>try-catch</code> block:<pre>private suspend fun getRemoteRestaurants():
<strong class="bold">        </strong>List&lt;Restaurant&gt; {
    retu<a id="_idTextAnchor212"/>rn withContext(Dispatchers.IO) {
<strong class="bold">        try {</strong>
            val restaurants = restInterface
                .getRestaurants()
            restaurantsDao.addAll(restaurants)
            return@withContext restaurants
<strong class="bold">        } catch (e: Exception) {</strong>
<strong class="bold">            when (e) {</strong>
<strong class="bold">                is UnknownHostException,</strong>
<strong class="bold">                is ConnectException,</strong>
<strong class="bold">                is HttpException -&gt; {</strong>
<strong class="bold">                    return@withContext </strong>
<strong class="bold">                        restaurantsDao.getAll()</strong>
<strong class="bold">                }</strong>
<strong class="bold">                else -&gt; throw e</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
    }
}</pre></li>
			</ol>
			<p>Essentially, what happens now is that if the user is offline, we catch the exception thrown by Retrofit. Alternatively, we return the cached restaurants from the Room database by calling <code>restaurantsDao.getAll()</code>.</p>
			<p>As an extra, we <a id="_idIndexMarker476"/>also check whether the<a id="_idIndexMarker477"/> exception we've caught has been thrown because of the user's poor or inexistent internet connect<a id="_idTextAnchor213"/>ivity. If the <code>Exceptio<a id="_idTextAnchor214"/>n</code> object is of type <code>UnknownHostException</code>, <code>ConnectException</code>, or <code>HttpException</code>, we're loading the restaurants from Room through our DAO; otherwise, we propagate the exception so that it's caught later by <code>CoroutineExceptionHandler</code>.</p>
			<ol>
				<li value="19">Before running the app, let's refactor our <code>getRemoteRestaurants()</code> method a bit. Now, the name of the method implies that it retrieves restaurants from a remote source. However, in reality, it also retrieves restaurants from Room if the user is offline. Room is a local data source, so the name of this method is no longer appropriate.</li>
			</ol>
			<p>Rename the <code>getRemoteRestaurants()</code> method to <code>getAllRestaurants()</code>:</p>
			<pre>private suspend fun <strong class="bold">getAllRestaurants</strong>(): 
    List&lt;Restaurant&gt; {  }</pre>
			<p>Additionally, remember to rename its usage in the <code>getRestaurants()</code> method where the coroutine is launched:</p>
			<pre>private fun getRestaurants() {
    viewModelScope.launch<a id="_idTextAnchor215"/>(errorHandler) {
        val restaurants = <strong class="bold">getAllRestaurants()</strong>
        state.value = restaurants.restoreSelections()
    }
}</pre>
			<ol>
				<li value="20">Run the <a id="_idIndexMarker478"/>app again without an internet <a id="_idIndexMarker479"/>connection.</li>
			</ol>
			<p>Because the restaurants were previously cached and now the user is offline, we are fetching them from Room. You should see the restaurants even without the internet. Success!</p>
			<p>Even though we've come a long way and have managed to make the Restaurants app usable even without internet, there is still something that we've missed. To reproduce it, perform the following steps:</p>
			<ol>
				<li value="1">Try running the application (either online or offline), and then mark a couple of restaurants as favorites.</li>
				<li>Disconnect <a id="_idIndexMarker480"/>your device from the<a id="_idIndexMarker481"/> internet and make sure you are now offline.</li>
				<li>Restart the application while remaining offline.</li>
			</ol>
			<p>You will get to see the restaurants, but your previous selections have been lost. More precisely, even though we have marked some restaurants as favorites, all restaurants now appear as not favorites. It's time to fix this!</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor216"/>Applying partial updates to the Room database</h1>
			<p>Right <a id="_idIndexMarker482"/>now, our application is saving the restaurants<a id="_idIndexMarker483"/> that we receive from the remote web API directly inside the Room database.</p>
			<p>This is not a bad approach; however, whenever we are marking a restaurant as a favorite, we aren't updating the corresponding restaurant inside Room. If we take a look inside the <code>RestaurantsViewModel</code> class and we check its <code>toggleFavorite()</code> method, we can see that we're only updating the <code>isFavorite</code> flag of a restaurant inside the <code>state</code> variable:</p>
			<pre>fun toggleFavorite(id: Int) {
    val restaurants = state.value.toMutableList()
    val itemIndex = restaurants.indexOfFirst { it.id == id }
    val item = restaurants[itemIndex]
    restaurants[itemIndex] = item.copy(isFavorite =  
        !item.isFavorite)
    storeSelection(restaurants[itemIndex])
    state.value = restaurants
}</pre>
			<p>We aren't updating the corresponding restaurant's <code>isFavorite</code> field value inside Room. So, whenever we use the application offline, the restaurants will no longer appear as favorites, even though when we were online, we might have marked some as favorites.</p>
			<p>To fix this, whenever we mark a restaurant as a favorite or not a favorite, we need to apply a partial update on a particular <code>Restaurant</code> object inside our Room database. The partial update <a id="_idIndexMarker484"/>should not replace the entire <code>Restaurant</code> object, but<a id="_idIndexMarker485"/> it should only update its <code>isFavorite</code> field value.</p>
			<p>Let's get started! Perform the following steps:</p>
			<ol>
				<li value="1">Create a partial entity class by clicking on the application package, selecting <code>PartialRestaurant</code> as the name, and select <strong class="bold">File</strong> as the <a id="_idTextAnchor217"/>type. Inside the new file, ad<a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>d the following code:<pre>@Entity
class PartialRestaurant(
    @ColumnInfo(name = "r_id")
    val id: Int,
    @ColumnInfo(name = "is_favorite")
    val isFavorite: Boolean)</pre></li>
			</ol>
			<p>In this <code>@Entity</code> annotated class, we've only added two fields:</p>
			<ul>
				<li>An <code>id</code> field with a <code>@ColumnInfo()</code> annotation that has the same value (<code>"r_id"</code>) passed to the <code>name</code> parameter as the <code>Restaurant</code> object's <code>id</code> field. This allows Room to match the <code>Restaurant</code> object's <code>id</code> field with the one from <code>PartialRestaurant</code>.</li>
				<li>An <code>isFavorite</code> field with a <code>@ColumnInfo()</code> annotation that has the name set to <code>"is_favorited"</code>. So far, Room can't match this field with the one from <code>Restaurant</code>, because inside <code>Restaurant</code>, we haven't annotated the <code>isFavorite</code> field with <code>@ColumnInfo</code> – we'll do that next.</li>
			</ul>
			<ol>
				<li value="2">Now<a id="_idIndexMarker486"/> that our partial entity, called <code>PartialRestaurant</code>, has a <a id="_idIndexMarker487"/>column corresponding to the <code>isFavorite</code> field, it's time to also add a <code>@ColumnInfo()</code> annotation with the same value (<code>"is_favorite"</code>) for the <code>isFavorite</code> field of the <code>Restaurant</code> entity:<pre>@Entity(tableName = "restaurants")
data class Restaurant(
    …
    val descriptio<a id="_idTextAnchor220"/>n: String,
    <strong class="bold">@ColumnInfo(name = "is_favorite")</strong>
    <strong class="bold">val</strong> isFavorite: Boolean = false
)</pre></li>
			</ol>
			<p>As a good practice, we've also made the <code>isFavorite</code> field <code>val</code> instead of <code>var</code> to prevent its value from being changed once the object has been created. Because <code>Restaurant</code> is an object passed to a Compose <code>State</code> object, we want to promote immutability across its fields to ensure recomposition events happen.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">By having a data class field as <code>var</code>, we can easily change its value at runtime and risk having Compose miss a well-needed recomposition. Immutability ensures that whenever an object field's value changes, a new object is created (just as we do with the <code>.copy()</code> function), and Compose is notified so that it can trigger recompo<a id="_idTextAnchor221"/>sition.</p>
			<ol>
				<li value="3">Since the <code>isFavorite</code> field is now <code>val</code>, the <code>restoreSelections()</code> extension function inside <code>RestaurantViewModel</code> has broken. Update its code as follows:<pre>private fun List&lt;Restaurant&gt;.restoreSelections(): … {
    stateHandle.[…]let { selectedIds -&gt;
        val res<a id="_idTextAnchor222"/>taurantsMap = this.associateBy { it.id }
            <strong class="bold">.toMutableM<a id="_idTextAnchor223"/>ap()</strong>
        selectedIds.forEach { id -&gt;
<strong class="bold">            val restaurant = </strong>
<strong class="bold">                restaurantsMap[id] ?: return@forEach</strong>
<strong class="bold">            restaurantsMap[id] =</strong>
<strong class="bold">                restaurant.copy(isFavorite = true)</strong>
        }
        return restaurantsMap.values.toList()
    }
    return this
}</pre></li>
			</ol>
			<p>Essentially, what <a id="_idIndexMarker488"/>we have done is make sure <a id="_idIndexMarker489"/>our <code>restaurantsMap</code> of type <code>Map&lt;Int, Restaurant&gt;</code> is mutable so that we can replace elements inside it. With this approach, we are now replacing the restaurant at entry <code>id</code> by passing a new object reference with the <code>copy</code> function. We are not going to go into much detail since this portion of the code will soon be removed.</p>
			<ol>
				<li value="4">Now that we have a partial entity defined, we need to add another function inside our DAO that will update a <code>Restaurant</code> entity through a <code>PartialRestaurant</code> entity. Inside <code>RestaurantsDao</code>, add the <code>update()</code> function:<pre>@Dao
interface RestaurantsDao {
    …
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun addAll(restaurants: List&lt;Res<a id="_idTextAnchor224"/>taurant&gt;)
<strong class="bold">    @Update(entity = Restaurant::class)</strong>
<strong class="bold">    suspend fun update(partialRestaurant:</strong>
<strong class="bold">        PartialRestaurant)</strong>
}</pre></li>
			</ol>
			<p>Let's <a id="_idIndexMarker490"/>understand, step by step, how <a id="_idIndexMarker491"/>the new <code>update()</code> function works:</p>
			<p>I.	It's a <code>suspend</code> function because, as we know by now, any interaction with the local database is a suspending job that should not run on the main thread.</p>
			<p>II.	It receives a <code>PartialRestaurant</code> entity as an argument and returns nothing. The partial entity's field values correspond to the restaurant that we're trying to update.</p>
			<p>III.	It's annotated with the <code>@Update</code> annotation to which we passed the <code>Restaurant</code> entity. The update process has two steps, as follows:</p>
			<p>i.	First, <code>PartialRestaurant</code> exposes the <code>id</code> field, whose value matches the <code>id</code> field's value of the corresponding <code>Restaurant</code> object.</p>
			<p>ii.	Once the match is complete, the <code>isFavorite</code> field's value is set to the <code>isFavorite</code> field of the matched <code>Restaurant</code> object.</p>
			<p>These matches are possible because the <code>id</code> and <code>isFavorite</code> fields of both entities have the same <code>@ColumnInfo</code> name values.</p>
			<ol>
				<li value="5">Now that our <a id="_idIndexMarker492"/>DAO knows how to partially<a id="_idIndexMarker493"/> update our <code>Restaur<a id="_idTextAnchor225"/>ant</code> entity, it's time to perform the update.</li>
			</ol>
			<p>First, inside <code>RestaurantsViewModel</code>, add a n<a id="_idTextAnchor226"/>ew suspending functi<a id="_idTextAnchor227"/>on, called <code>toggleFavoriteRestaurant()</code>:</p>
			<pre>private suspend fun toggleFavoriteRestaurant(id: Int, oldValue: Boolean) =
    withContext(Dispatchers.IO) {
        restaurantsDao.update(
            PartialRestaurant(
                id = id,
                isFavorite = !oldValue
            )
        )
    }</pre>
			<p>Let's understand, step by step, what this new method does:</p>
			<p>I.	 It receives the <code>id</code> field of the restaurant that we're trying to update, along with the <code>oldValue</code> field which represents the value of the <code>isFavorite</code> field just before the user has toggled the heart icon of the restaurant.</p>
			<p>II.	 To partially update a restaurant, it needs to interact with the Room DAO object. This means that the <code>toggleFavoriteRestaurant</code> method must be a <code>suspend</code> function. As a good practice, we wrapped it inside a <code>withContext</code> block that specifies its work must be done inside the <code>IO</code> dispatcher. While Room ensures that we wrap our suspending work with a special dispatcher, we explicitly specified the <code>Dispatchers.IO</code> dispatcher to better highlight that such heavy work should be done in an appropriate dispatcher.</p>
			<p>III.	 It builds a <code>PartialRestaurant</code> object, which it then passes to the DAO's  <code>update()</code> method that was created earlier. The <code>PartialRestaurant</code> object gets the <code>id</code> field of the restaurant we're updating, along with the negated value of the <code>isFavorite</code> flag. If the user previously didn't have the restaurant marked as favorite, upon clicking the heart icon, we should negate the old (<code>false</code>) value and obtain <code>true</code>, or vice versa.</p>
			<p>Now that we have the method in place to update a restaurant, it's time to call it.</p>
			<ol>
				<li value="6">While you <a id="_idIndexMarker494"/>are still in <code>RestaurantsViewModel</code>, make the <code>toggleFavorite</code> method launch a coroutine at the<a id="_idIndexMarker495"/> end of its body. Then, inside it, call the new <code>toggleFavoriteRestaurant()</code> suspending function:<pre>fun toggleFavorite(id: Int) {
    …
    restaurants[itemIndex] = item.copy(isFavorite =  
       !item.isFavorite)
    storeSelection(restaurants[itemIndex])
    state.value = restaurants
<strong class="bold">    viewModelScope.launch<a id="_idTextAnchor228"/> {</strong>
<strong class="bold">        toggleFavoriteRestaurant(id, item.isFavorite)</strong>
<strong class="bold">    }</strong>
}</pre></li>
			</ol>
			<p>To the <code>toggleFavoriteRestaurant()</code> function, we've passed the following:</p>
			<ul>
				<li>The <code>id</code> parameter, which represents the ID of the restaurant the user is trying to mark as favorite or not favorite</li>
				<li>The old value of the favorite status of the restaurant, as defined by the <code>isFavorite</code> flag of the <code>item</code> field</li>
			</ul>
			<p>Now, whenever the user presses on the heart icon, we not only update the UI but also cache this selection inside the local database through a partial update.</p>
			<ol>
				<li value="7">Build and run <a id="_idIndexMarker496"/>the application because it's time to test what we've just implemented! Unfortunately, the app crashes. Can you think of one reason why this happens? If we look at the stack trace of the error, we will see the following message:<pre>java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number.</pre></li>
			</ol>
			<p>This error<a id="_idIndexMarker497"/> message makes total sense because we've changed the schema of the database, and now Room doesn't know whether to migrate the old entries or delete them. But how did we change the schema?</p>
			<p>Well, we changed the schema when we defined a new column for the Restaurants table by adding the <code>@ColumnInfo()</code> annotation to the <code>isFavorite</code> field.</p>
			<ol>
				<li value="8">To mitigate this issue, we must increase the <code>version</code> number of the database. Inside the <code>RestaurantsDb</code> class, increase the <code>version</code> number from <code>1</code> to <code>2</code>:<pre>@Database(
    entities = [Restaurant::class],
    <strong class="bold">version = 2,</strong>
    exportSchema = false)
abstract class RestaurantsDb : RoomDatabase() { .. }</pre></li>
			</ol>
			<p>Now, Room knows that we've changed the schema of the database. In turn, because we haven't provided a migration strategy, and instead, we've called the <code>fallbackToDestructiveMigration()</code> method in the <code>Room.databaseBuilder</code> constructor when we initially instantiated the database, Room will drop the old contents and tables and provide us with a fresh start.</p>
			<ol>
				<li value="9">Try running the application online, and then mark a couple of restaurants as favorites.</li>
				<li>Disconnect your device from the internet and make sure you are now offline.</li>
				<li>Restart the application while remaining offline.</li>
			</ol>
			<p>Great news! The selections were now kept, and we can see which restaurants were previously marked as favorites! </p>
			<ol>
				<li value="12">To continue<a id="_idIndexMarker498"/> testing, while you are offline, you<a id="_idIndexMarker499"/> can try marking other restaurants as favorites.</li>
			</ol>
			<p>Then, still in offline mode, restart the app and you will notice that these new selections have also been saved.</p>
			<ol>
				<li value="13">Connect your device to the internet and run the application – while you are online.</li>
			</ol>
			<p>Oops! The restaurants that we have previously marked as favorites no longer appear as such, even though we previously cached these selections inside the Room database.</p>
			<p>Essentially, every time we open the application while being connected to the internet, we lose all the previous selections, and no restaurant is marked as favorite anymore.</p>
			<p>There are two issues in our code that are causing this! Can you think of why this is happening?</p>
			<p>In the next section, we will identify and address them. Additionally, we will make sure that Room is the single source of truth for the content of our application.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor229"/>Making local data the single source of truth for app content</h1>
			<p>Whenever we<a id="_idIndexMarker500"/> launch the app with the internet, all the restaurants appear as not favorites, even though we previously marked them as favorites and cached the selections in the Room database.</p>
			<p>To identify the issue, let's navigate back inside <code>RestaurantsViewModel</code> and inspect the <code>getAllRestaurants()</code> method:</p>
			<pre>private suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {
    return withContext(Dispatchers.IO) {
<strong class="bold">        try {</strong>
            val restaurants = restInterface.getRestaurants()
            restaurantsDao.addAll(restaurants)
            return@withContext restaurants
<strong class="bold">        } catch (e: Exception) {</strong>
<strong class="bold">            when (e) {</strong>
<strong class="bold">                is UnknownHostException, […] -&gt; {</strong>
<strong class="bold">                    return@withContext restaurantsDao.getAll()</strong>
<strong class="bold">                }</strong>
<strong class="bold">                else -&gt; throw e</strong>
<strong class="bold">            }</strong>
<strong class="bold">        }</strong>
    }
}</pre>
			<p>Now, when we launch the app while online, we do three things:</p>
			<ul>
				<li>We load the restaurants from the server by calling <code>restInterface.getRestaurants()</code>. For these restaurants, we don't receive the <code>isFavorite</code> flag, so we automatically have it set to <code>false</code>. This happens because our <code>Restaurant</code> class defaults the value of <code>isFavorite</code> to false if no value is passed from the Gson deserialization:<pre>@Entity(tableName = "restaurants")
data class Restaurant(
    …
    @ColumnInfo(name = "is_favorite")
    val isFavorite: Boolean = false)</pre></li>
				<li>Then, we <a id="_idIndexMarker501"/>save those restaurants to Room by calling <code>restaurantsDao.addAll(restaurants)</code>. However, because we've used the <code>REPLACE</code> strategy inside our DAO's <code>addAll()</code> function, and because we received the same restaurants from the server, we override the <code>isFavorite</code> flags of the corresponding restaurants inside the database to <code>false</code>. So, even though our restaurants in Room might have had the <code>isFavorite</code> flag set to <code>true</code>, because we receive restaurants with the same <code>id</code> fields from the server, we end up overriding all those values to <code>false</code>.</li>
				<li>Next, we pass the <code>restaurants</code> list that we've received from the server to the UI. As we already know, these restaurants have the <code>isFavorite</code> field's value of <code>false</code>. So, anytime we start the app while connected to the internet, we will always see no restaurants marked as favorites.</li>
			</ul>
			<p>If we think about it, there are two main issues here:</p>
			<ul>
				<li>Our application has two sources of truth:<ul><li>When online, it displays the restaurants from the remote server.</li><li>When offline, it displays the restaurants from the local database.</li></ul></li>
				<li>Whenever we cache restaurants that already exist inside the local database, we override their <code>isFavorite</code> flag to <code>false</code>.</li>
			</ul>
			<p>If we can fix these two issues by having our UI receive content from a single source of data, we will also be able to remove the need for <code>SavedStateHandle</code> and all the special handling related to process recreation – we will see why in a moment.</p>
			<p>Essentially, in <a id="_idIndexMarker502"/>this section, we will be doing the following:</p>
			<ul>
				<li>Refactoring the Restaurants app to have a single source of truth for data</li>
				<li>Removing the logic of persisting state inside <code>SavedStateHandle</code> in the case of process recreation</li>
			</ul>
			<p>So, let's begin with the first issue at hand!</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor230"/>Refactoring the Restaurants app to have a single source of truth for data</h2>
			<p>The<a id="_idIndexMarker503"/> approach of having multiple sources of data can lead to many inconsistencies and subtle bugs – just like how our app is now inconsistent in terms of what data it displays when the user is either online or offline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The concept of designing systems to rely on only one data source used for storing and updating content is related to a practice that is called <strong class="bold">Single Source of Truth</strong> (<strong class="bold">SSOT</strong>). Having <a id="_idIndexMarker504"/>multiple sources of truth for data that the UI consumes can lead to inconsistencies between what's expected to be shown to the UI and what is actually shown. The SSOT concept helps us to structure the data access so that only one data source is trusted to provide the app with data.</p>
			<p>Let's make sure that our application only has one source of truth, but which one should we choose?</p>
			<p>On the one hand, we cannot control the data that is being sent from our Firebase database, and we also can't update the restaurants stored inside it when the user marks one as a favorite.</p>
			<p>On the other hand, we can do that with Room! In fact, we are already doing that – every time a user marks a restaurant as a favorite or not a favorite, we're applying a partial update to that restaurant inside the local database.</p>
			<p>So, let's make <a id="_idIndexMarker505"/>the local Room database our only source of data:</p>
			<div><div><img src="img/B17788_06_3.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Data retrieval for the Restaurants app with the local database as an SSOT</p>
			<p>When the user is online, we should get the restaurants from the server, cache them into Room, and then obtain the restaurants again from Room to finally send them to the UI.</p>
			<p>Similarly, if the user is offline, we simply obtain the restaurants from Room and display them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Alternatively, instead of always asking your Room database for the most up-to-date content, you could update the DAO interface to provide you with a reactive data stream that we can observe. This way, upon every data update, you would automatically be notified with the most up-to-date content in a reactive manner, without having to manually ask for it. To achieve that, you must use special data holders provided by libraries such as Jetpack LiveData, Kotlin Flow, or RxJava. We will explore Kotlin Flow in <a href="B17788_11_ePub.xhtml#_idTextAnchor317"><em class="italic">Chapter 11</em></a>,<em class="italic"> Creating Infinite Lists with Jetpack Paging and Kotlin Flow</em>.</p>
			<p>The similarity between our two scenarios is that now, regardless of the internet connectivity of the user, our UI always displays the restaurants from inside our Room database. In other words, the local database is ou<a id="_idTextAnchor231"/>r SSOT!</p>
			<p>Let's start<a id="_idIndexMarker506"/> implementing! <a id="_idTextAnchor232"/>Perform the following steps:</p>
			<ol>
				<li value="1">Inside <code>RestaurantsViewModel</code>, refactor the <code>getAllRestaurants()</code> function to always return the restaurants from the Room database:<pre>private suspend fun getAllRestaurants(): 
     List&lt;Restaurant&gt; {
    return withContext(Di<a id="_idTextAnchor233"/>spatchers.IO) {
        try { … } catch (e: Exception) { […] }
        <strong class="bold">return@withContext restaurantsDao.getAll()</strong>
    }
}</pre></li>
			</ol>
			<p>Here, our app tries to display the restaurants from the local database in any condition.</p>
			<ol>
				<li value="2">Now, it's time to refactor the <code>try – catch</code> block inside the <code>getAllRestaurants()</code> method! Essentially, what we want to do is to get the restaurants from the server and then cache them locally.</li>
			</ol>
			<p>Replace the contents within the <code>try { }</code> block with a new  <code>refresh<a id="_idTextAnchor234"/>Cache()</code> method:</p>
			<pre>return withContext(Dispatchers.IO) {
    try {
        <strong class="bold">refreshCache()</strong>
    } catch (e: Exception) { […] }
    return@withContext restaurantsDao.getAll()
}</pre>
			<ol>
				<li value="3">Additionally, we want to define the <code>refreshCache()</code> function to get the restaurants from the remote server and then cache them inside the local database, thereby refreshing their contents:<pre><strong class="bold">private suspend fun refreshCache() {</strong>
<strong class="bold">    val remoteRestaurants = restInterface<a id="_idTextAnchor235"/></strong>
<strong class="bold">        .getRestaurants()</strong>
<strong class="bold">    restaurantsDao.addAll(remoteRestaurants)</strong>
<strong class="bold">}</strong></pre></li>
				<li>We know<a id="_idIndexMarker507"/> that if the refresh of the cache fails, we will still show the local restaurants from Room. But what if the local database is empty?</li>
			</ol>
			<p>Continue refactoring the <code>getAllRestaurants()</code> method by updating its <code>catch</code> block. You can do this by removing the <code>return@withContext restaurantsDao.getAll()</code> call (which is now redundant) from the <code>is UnknownHostException, is ConnectException, is HttpException </code>branch and by replacing it with the following code:</p>
			<pre>try { … } catch (e: Exception) {
    when (e) {
        is UnknownHostException, is ConnectException,
        is HttpException -&gt; {
<strong class="bold">            if (restaurantsDao.getAll().isEmpty())</strong>
<strong class="bold">                throw Exception(</strong>
<strong class="bold">                    "Something went wrong. " +</strong>
<strong class="bold">                            "We have no data.")</strong>
        }
        else -&gt; throw e
    }
}</pre>
			<p>Essentially, if a network exception has been thrown, we can check whether we have any local restaurants saved in the Room database:</p>
			<ul>
				<li>If the<a id="_idIndexMarker508"/> list is empty, we return from the parent method early by throwing a custom exception to inform the user that we have no data to display. </li>
				<li>However, if the local database has elements, we do nothing and let the <code>getAllRestaurants()</code> method return the cached restaurants to the UI.</li>
			</ul>
			<p>Now, inside the <code>toggleFavorite()</code> function of <code>ViewModel</code>, whenever we toggle a restaurant as a favorite or not, we can observe that we're updating the Room database with a partial update. However, we're not fetching the restaurants again from Room and so the UI is never informed of this change:</p>
			<pre>fun toggleFavorite(id: Int) {
    …
    restaurants[itemIndex] = item.copy(isFavorite =
        !item.isFavorite)
    storeSelection(restaurants[itemIndex])
    state.value = restaurants
    viewModel<a id="_idTextAnchor236"/>Scope.launch {
        toggleFavoriteRestaurant(id, item.isFavorite)
    }
}</pre>
			<p>Instead, we're updating the <code>state</code> variable's value – so the UI receives the updated restaurants in-memory. This means that we are not conforming to the SSOT practice in which we opt to always feed the UI with restaurants from the local database. Let's fix this.</p>
			<ol>
				<li value="5">Make the <code>toggleFavoriteRestaurant()</code> function return the restaurants from our<a id="_idIndexMarker509"/> local database. You can do this by calling the <code>restaurantsDao.getAll()</code> function from inside the <code>withContext()</code> block:<pre>private suspend fun toggleFavoriteRestaurant(
    id: Int,
    oldValue: Boolean
) = withContext(Dispatchers.IO) {
        restaurantsDao.update(
           Pa<a id="_idTextAnchor237"/>rtialRestaurant(id = id, isFavorite = 
               !oldValue))
        <strong class="bold">restaurantsDao.getAll()</strong>
    }</pre></li>
				<li>Inside the <code>toggleFavorite()</code> method, store the updated restaurants returned by the <code>toggleFavoriteRestaurant()</code> method inside an <code>updatedRestaurants</code> variable, and then move the <code>state.value = restaurants</code> line from outside the coroutine to inside it while, this time, making it receive the value stored by the <code>updatedRestaurants</code> variable:<pre>fun toggleFavorite(id: Int) {
    val restaurants = state.value.toMutableList()
    […]
    storeSe<a id="_idTextAnchor238"/>lection(restaurants[itemIndex])
    viewModelScope.launch(errorHandler) {
        <strong class="bold">val updatedRestaurants =</strong> 
            toggleFavoriteRestaurant(id, item.isFavorite)
        <strong class="bold">state.value = updatedRestaurants</strong>
    }
}</pre></li>
			</ol>
			<p>Here, we have<a id="_idIndexMarker510"/> not updated the <code>state</code> object value with the <code>restaurants</code> value from the previous state value. Instead, we passed the restaurants from the local database, which were obtained from the <code>toggleFavoriteRestaurant()</code> function.</p>
			<p>Now that we have made our local database the single source of truth for data, we might assume that our issues have been solved. However, remember that we are still overriding the <code>isFavorite</code> field values of the local restaurants whenever we cache restaurants with the same IDs from the server.</p>
			<p>That's why the final problem lies in the <code>refreshCache()</code> method:</p>
			<pre>private suspend fun refreshCache() {
    val remoteRestaurants = restInterface
        .getRestaurants()
    restaurantsDao.addAll(remoteRestaurants)
}</pre>
			<p>We must find a way to preserve the <code>isFavorite</code> field of the restaurants whenever we call <code>restaurantsDao.addAll(remoteRestaurants)</code>.</p>
			<p>We can fix this issue by complicating the logic that is happening inside the <code>refreshCache()</code> function.</p>
			<ol>
				<li value="7">Inside the <code>refreshCache()</code> function, add the following code:<pre>private suspend fun refreshCache()<a id="_idTextAnchor239"/> {
    val remoteRestaurants = restInterface
        .getRestaurants()
    <strong class="bold">val favoriteRestaurants = restaurantsDao<a id="_idTextAnchor240"/></strong>
<strong class="bold">        .getAllFavorited()</strong>
    restaurantsDao.addAll(remoteRestaurants)
<strong class="bold">    restaurantsDao.updateAll(</strong>
<strong class="bold">        favoriteRestaurants.map {</strong>
<strong class="bold">            PartialRestaurant(it.id, true)</strong>
<strong class="bold">        })</strong>
}</pre></li>
			</ol>
			<p>Now, let's break down what we've just done:</p>
			<p>i.	First, just as<a id="_idIndexMarker511"/> before, we got the restaurants from the server (which will all have the <code>isFavorite</code> fields set to <code>false</code> as their default values) by calling <code>restInterface.getRestaurants()</code>.</p>
			<p>ii.	Then, from Room, we obtained all the restaurants that were favorited by calling <code>restaurantsDao.getAllFavorited()</code> – we haven't added this function yet so don't worry if your code doesn't compile yet.</p>
			<p>iii.	Next, just as before, we saved the remote restaurants in Room by calling <code>restaurantsDao.addAll(remoteRestaurants)</code>. With this, we override the <code>isFavorite</code> field (to <code>false</code>) of the existing restaurants that have the same ID as <code>remoteRestaurants</code>.</p>
			<p>iv.	Finally, we partially updated all the restaurants within Room by calling <code>restaurantsDao.updateAll()</code>. To this method (which we have yet to implement), we are passing a list of <code>PartialRestaurant</code> objects.</p>
			<p>These objects resulted from mapping the previously cached <code>favoriteRestaurants</code> objects of type <code>Restaurant</code> to objects of type <code>PartialRestaurant</code>, which have their <code>isFavorite</code> fields set to <code>true</code>. With this approach, we have now restored the <code>isFavorite</code> field's value for those favorited <a id="_idIndexMarker512"/>restaurants that were initially cached.</p>
			<ol>
				<li value="8">Inside <code>RestaurantsDao</code>, we must implement the two methods used earlier:<pre>@Dao
interface RestaurantsDao {
    […]
<strong class="bold">    @Update(entity = Restaurant::class)</strong>
<strong class="bold">    suspend fun updateAll(partialRestaurants: </strong>
<strong class="bold">        List&lt;PartialRestaurant&gt;<a id="_idTextAnchor241"/>)</strong>
<strong class="bold">    @Query("SELECT * FROM restaurants WHERE </strong>
<strong class="bold">        is_favorite = 1")</strong>
<strong class="bold">    suspend fun getAllFavorited(): List&lt;Restaurant&gt;</strong>
}</pre></li>
			</ol>
			<p>We have added the following:</p>
			<ul>
				<li>The <code>updateAll()</code> method: This is a partial update that works in the same way as the <code>update()</code> method. Here, the only difference is that we update the <code>isFavorite</code> field for a list of restaurants instead of only one.</li>
				<li>The <code>getAllFavorited()</code> method: This is a query just like the <code>getAll()</code> method but more specific, as it obtains all the restaurants that have their <code>isFavorite</code> field values equal to <code>1</code> (which stands for <code>true</code>).</li>
			</ul>
			<p>We are finally done! It's time to test out the app!</p>
			<ol>
				<li value="9">Try running the application offline and then mark a couple of restaurants as favorites.</li>
				<li>Connect <a id="_idIndexMarker513"/>your device to the internet and run the application – while you are online.</li>
			</ol>
			<p>You should now be able to see the previous selections – all the restaurants that were originally marked as favorites are now persisted across any scenario.</p>
			<p>However, we have one more thing to address!</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor242"/>Removing the logic of persisting state in the case of process recreation </h2>
			<p>Now our <a id="_idIndexMarker514"/>application has a single source of truth, that is, the local database:</p>
			<ul>
				<li>Whenever we receive restaurants from the server, we cache them to Room and then refresh the UI with the restaurants from Room.</li>
				<li>Whenever we mark a restaurant as a favorite or not, we cache the selection to Room, and similarly, we then refresh the UI with restaurants from Room.</li>
			</ul>
			<p>This means that if a system-initiated process death occurs, we should be able to restore the UI state easily because, now, the restaurants in Room also have the <code>isFavorite</code> field cached.</p>
			<p>In other words, our app no longer needs to rely on <code>SavedStateHandle</code> to restore the restaurants that have been favorited or not; the local source of data for our application will now handle this automatically.</p>
			<p>Let's remove our special handling for a system<a id="_idTextAnchor243"/>-initiated process death:</p>
			<ol>
				<li value="1">Inside <code>RestaurantsViewModel</code>, remove the <code>stateHandle: SavedStateHandle</code> parameter:<pre>class <strong class="bold">Rest<a id="_idTextAnchor244"/>aurantsViewModel()</strong> : ViewModel() { … }</pre></li>
				<li>Inside <code>RestaurantsViewModel</code>, remove the <code>storeSelection()</code> and the <code>restoreSelections()</code> methods.</li>
				<li>Remove the <code>companion object</code> of the <code>RestaurantsViewModel</code> class.</li>
				<li>While you are still inside <code>ViewModel</code>, remove all the logic related to the <code>stateHandle</code> variable from within the <code>toggleFavorite()</code> method. The method should now look like this:<pre>fun toggleFavorite(id: Int) {
    viewModelScope.launch(errorHandler) {
        val updatedRestaurants =
            toggleFavoriteRestaurant(id, item.isFavorite)
        state.value = updatedRestaurants
    }
}</pre></li>
			</ol>
			<p>The issue<a id="_idIndexMarker515"/> is that we no longer have the <code>item</code> variable, so we don't know what to pass to the <code>toggleFavoriteRestaurant()</code> function's <code>oldValue</code> parameter instead of <code>item.isFavorite</code>. We need to fix this.</p>
			<ol>
				<li value="5">Add a new paramet<a id="_idTextAnchor245"/>er to the <code>toggleFavorite()</code> method, called <code>oldValue</code>:<pre>fun toggleFavorite(id: Int, <strong class="bold">oldValue: Boolean</strong>) {
    viewModelScope.launch(errorHandler) {
        val updatedRestaurants =
            toggleFavoriteRestaurant(id, <strong class="bold">oldValue</strong>)
        state.value = updatedRestaurants
    }
}</pre></li>
			</ol>
			<p>This <code>Boolean</code> argument should tell us whether the restaurant was previously marked as favorite or not.</p>
			<ol>
				<li value="6">Following this, refactor the <code>getRestaurants()</code> method to no longer use the <code>restoreSelections()</code> method. The method should now look like this:<pre>private fun getRestaurants() {
    viewModelScope.launch(errorHandler) {
        state.value = getAllRestaurants()
    }
}</pre></li>
				<li>Next, navigate<a id="_idIndexMarker516"/> to the <code>RestaurantsScreen</code> file. Then, inside the <code>RestaurantItem</code> composable, add another <code>oldValue</code> parameter to the <code>onFavoriteClick</code> callback <a id="_idTextAnchor246"/>function:<pre>@Composable
fun RestaurantItem([…],
        onFavoriteClick: (id: Int, <strong class="bold">oldValue: Boolean</strong>)
            -&gt; Unit,
        onItemClick: (id: Int) -&gt; Unit) {
    ...
    Card(…) {
        Row(…) {
            [...]
            RestaurantDetails(...)
            RestaurantIcon(icon, Modifier.weight(0.15f)) 
            {
                onFavoriteClick(item.id, <strong class="bold">item.isFavorite</strong>)
            }
        }
    }
}</pre></li>
			</ol>
			<p>Also, make sure that you pass the <code>item.isFavorite</code> value to the newly added parameter when the <code>onFavoriteClick</code> function is called.</p>
			<ol>
				<li value="8">Inside the <code>RestaurantsScreen()</code> composable, make sure you register and then pass the newly<a id="_idIndexMarker517"/> received <code>oldValue</code> function parameter to the <code>toggleFavorite</code> method of <code>ViewModel</code>:<pre>@Composable
fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {
    val viewModel: RestaurantsViewModel = viewModel()
    LazyColumn(…) {
        items(viewModel.state.value) { restaurant <a id="_idTextAnchor247"/>-&gt;
            RestaurantItem(
                restaurant,
                onFavoriteClick = { id, <strong class="bold">oldValue</strong> -&gt;
                    viewModel
                        .toggleFavorite(id, <strong class="bold">oldValue</strong>)
                },
                onItemClick = { id -&gt; onItemClick(id) })
        }
    }
}</pre></li>
			</ol>
			<p>We're done! Now it's time to simulate the system-initiated process death scenario.</p>
			<ol>
				<li value="9">Build the project and run the application. </li>
				<li>Mark some restaurants as favorites.</li>
				<li>Place the app in the background by pressing the home button on the device/emulator.</li>
				<li>Select the <strong class="bold">Logcat</strong> window and then press the red rectangular button on the left-hand side<a id="_idIndexMarker518"/> to terminate the application:</li>
			</ol>
			<div><div><img src="img/B17788_06_4.jpg" alt="Figure 6.4 – Simulating a system-initiated process death&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Simulating a system-initiated process death</p>
			<ol>
				<li value="13">Relaunch the application from the application drawer.</li>
			</ol>
			<p>Because the app relies on the content saved in the local database, it should now correctly display the UI state with the previously favorited restaurants from before the system-initiated process death.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">In this chapter, we made sure to cache the restaurants in Room so that the first screen of the application could be accessed without the internet. As a homework assignment, you can try to refactor the details screen of the application (where the details of a specific restaurant are displayed) to obtain its own data from Room if the user enters the app without the internet.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor248"/>Summary</h1>
			<p>In this chapter, we gained an understanding of how Room is an essential Jetpack library because it allows us to offer offline capabilities to our applications.</p>
			<p>First, we explored the core elements of Room to see how a private database is set up. Second, we implemented Room inside our Restaurants application and explored how to save and retrieve cached content from the local database.</p>
			<p>Afterward, we discovered what partial updates are and how to implement them to preserve a user's selections within the app.</p>
			<p>Toward the end of the chapter, we understood why having a single source of truth for the application's content is beneficial and how that helps us in edge cases such as a system-initiated process death.</p>
			<p>In the next chapter, we're going to dive deeper into various ways of defining the architecture of our applications by exploring architectural presentation patterns.</p>
		</div>
	</body></html>