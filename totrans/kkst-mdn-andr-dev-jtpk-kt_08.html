<html><head></head><body>
		<div id="_idContainer078">
			<h1 id="_idParaDest-90"><em class="italic"><a id="_idTextAnchor186"/>Chapter 6</em>: Adding Offline Capabilities with Jetpack Room</h1>
			<p>In this chapter, we're starting our journey of exploring ways to architecture our apps by first making sure that our application can be used without an internet connection.</p>
			<p>In the <em class="italic">Introducing Jetpack Room</em> section, we will briefly note the various caching mechanisms that are on Android. Then, we will introduce the Jetpack Room library and its core elements.</p>
			<p>Next, in the <em class="italic">Enabling offline usage by implementing Room</em> section, we will implement Room in our Restaurants app and allow users to use the application without an internet connection. In the <em class="italic">Applying partial updates to the Room database</em> section, we will learn how to partially update data inside Room so that we can save selections such as whether the restaurants were favorited by the user.</p>
			<p>Finally, in the <em class="italic">Making local data the single source of truth for app content</em> section, we will understand why having a single source of truth for app data is beneficial, and then we will set the Room database as the single source of content for our app.</p>
			<p>To summarize, in this chapter, we're going to cover the following main topics:</p>
			<ul>
				<li>Introducing Jetpack Room</li>
				<li>Enabling offline usage by implementing Room</li>
				<li>Applying partial updates to the Room database</li>
				<li>Making local data the single source of truth for app content</li>
			</ul>
			<p>Before jumping in, let's set up the technical requirements for this chapter.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor187"/>Technical requirements</h1>
			<p>Usually, building Compose-based Android projects with Jetpack Room will require your day-to-day tools. However, to follow along with the examples smoothly, make sure you have the following:</p>
			<ul>
				<li>The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer Android Studio version or even Canary builds but note that the IDE interface and other generated code files might differ from the ones used throughout this book.</li>
				<li>The Kotlin 1.6.10, or newer, plugin installed in Android Studio</li>
				<li>The Restaurants app code from the previous chapter.</li>
				<li>Minimal knowledge of SQL databases and queries</li>
			</ul>
			<p>The starting point for this chapter is represented by the Restaurants application that was developed in the previous chapter. If you haven't followed the implementation described in the previous chapter, access the starter code for this chapter by navigating to the <strong class="source-inline">Chapter_05</strong> directory of the repository. Then, import the Android project entitled <strong class="source-inline">chapter_5_restaurants_app</strong>.</p>
			<p>To access the solution code for this chapter, navigate to the <strong class="source-inline">Chapter_06</strong> directory:</p>
			<p><a href="https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app">https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_06/chapter_6_restaurants_app</a>.</p>
			<h1 id="_idParaDest-92"><a id="_idTextAnchor188"/>Introducing Jetpack Room</h1>
			<p>Modern applications should be available for use in any conditions, including when the user is missing an internet connection. This allows apps to provide a seamless user experience and usability even when the user's device cannot access the network.</p>
			<p>In this section, we will discuss the following:</p>
			<ul>
				<li>Exploring the caching mechanism on Android</li>
				<li>Introducing Jetpack Room as a solution for local caching</li>
			</ul>
			<p>So, let's begin!</p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor189"/>Exploring the caching mechanism on Android</h2>
			<p>To cache specific content<a id="_idIndexMarker433"/> or application data, reliable Android apps make<a id="_idIndexMarker434"/> use of the various offline caching mechanisms that are suitable for different use cases:</p>
			<ul>
				<li>Shared preferences are used to store lightweight data (such as user-related selections) as key-value pairs. This option shouldn't be used to store objects that are part of the app's content.</li>
				<li>Device storage (either internal or external) is used for storing heavyweight data (such as files, pictures, and more).</li>
				<li>SQLite database is used for storing app content in a structured manner inside a private database. <strong class="bold">SQLite</strong> is <a id="_idIndexMarker435"/>an open source SQL database that stores data in private text files.</li>
			</ul>
			<p>In this chapter, we will focus on learning how to cache structured content (which is, usually, held by Kotlin <strong class="source-inline">data class</strong> objects) within a SQLite database. In this way, we allow the user to browse the app's data while remaining offline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Android comes with a built-in SQLite database implementation that allows us to save structured data.</p>
			<p>In our app, we can consider the array of restaurants to be a perfect candidate for app content that can be saved inside a SQLite database. Since the data is structured, with SQLite, we get the advantage of being able to perform different actions such as searching for restaurants within the database, updating particular restaurants, and more.</p>
			<p>By caching app content in this way, we can allow users to browse the app's restaurants while offline. However, for this to work, the users need to have previously opened the app using an active internet connection, thereby allowing the app to cache the contents for future offline use.</p>
			<p>Now, to save the restaurants to the SQLite private database, we need to make use of the SQLite APIs. These <a id="_idIndexMarker436"/>APIs are powerful. However, by using them, you face quite a few disadvantages:</p>
			<ul>
				<li>The APIs are of a low level and are relatively difficult to use.</li>
				<li>The SQLite APIs provide no compile-time verification of SQL queries, which can lead to unwanted runtime errors.</li>
				<li>There is a lot<a id="_idIndexMarker437"/> of boilerplate code involved in creating a database, performing SQL queries, and more.</li>
			</ul>
			<p>To mitigate these issues, Google provides the Jetpack Room library. This library is nothing more than a wrapper library that simplifies the way we access and interact with the SQLite database.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor190"/>Introducing Jetpack Room as a solution for local caching</h2>
			<p><strong class="bold">Room</strong> is a <a id="_idIndexMarker438"/>persistence library that is defined as an abstraction<a id="_idIndexMarker439"/> layer over SQLite and provides simplified database access while taking advantage of the power of the SQLite APIs.</p>
			<p>As opposed to using the raw SQLite APIs, Room abstracts most of the complexity associated with working with SQLite. The library removes most of the unpleasant boilerplate code that is required to set up and interact with SQLite databases on Android while also providing the compile-time checking of SQL queries.</p>
			<p>To make use of the Room library and cache contents using its API, you need to define three primary components:</p>
			<ul>
				<li><strong class="bold">Entities</strong> that<a id="_idIndexMarker440"/> define tables within the private database. In our Restaurants app, we will consider the <strong class="source-inline">Restaurant</strong> data class as an entity. This means that we will have a table populated with <strong class="source-inline">Restaurant</strong> objects. In other words, the rows of the table are represented by instances of our restaurants.</li>
				<li>A database class <a id="_idIndexMarker441"/>that will contain and expose the actual database.</li>
				<li><strong class="bold">Data Access Objects</strong> (<strong class="bold">DAOs</strong>) that<a id="_idIndexMarker442"/> represent an interface. This allows us to get, insert, delete, or update the actual content within the database.</li>
			</ul>
			<p>The database class provides us with a reference to the DAO interface associated with the SQLite database:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/B17788_06_1.jpg" alt="Figure 6.1 – The interaction between the application and the Room database&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1 – The interaction between the application and the Room database</p>
			<p>As previously <a id="_idIndexMarker443"/>illustrated, we can use the DAO to retrieve or update the<a id="_idIndexMarker444"/> data from the database in the form of entity objects – in our case, the entity is the restaurant, so we will be applying such operations to restaurant objects.</p>
			<p>Now that we have a basic understanding of how Room works and how we can interact with it, it's time to see it in action for ourselves and implement Room in our Restaurants app.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor191"/>Enabling offline usage by implementing Room</h1>
			<p>We want to <a id="_idIndexMarker445"/>locally cache all the restaurants that we <a id="_idIndexMarker446"/>receive from our Firebase database. Since this content is structured, we want to use Room to help us with this task.</p>
			<p>Essentially, we are trying to save the restaurants when the user is browsing our Restaurants app while online. Then, we will reuse them when the user browses the app while being offline:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/B17788_06_2.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2 – Data retrieval for the Restaurants app with two sources of truth</p>
			<p>When online, we<a id="_idIndexMarker447"/> retrieve the restaurants from our web<a id="_idIndexMarker448"/> API. Before displaying them to the user, first, we will cache them to our Room database. If offline, we will retrieve the restaurants from the Room database and then display them to the user.</p>
			<p>Essentially, we are creating two sources of truth for our app:</p>
			<ul>
				<li>The remote API for when the user is online</li>
				<li>The local Room database for when the user is offline</li>
			</ul>
			<p>In the next section, we will discuss why this approach is not ideal. However, until then, we are content with the fact that we will be able to use the app while remaining offline.</p>
			<p>Let's start implementing Room, and then let's cache those restaurants! Perform the following steps:</p>
			<ol>
				<li>Inside the <strong class="source-inline">build.gradle</strong> file in the app module, add the dependencies for Room inside the <strong class="source-inline">dependencies</strong> block:<p class="source-code">implementation "androidx.room:room-runtime:2.4.2"</p><p class="source-code">kapt "androidx.room:room-co<a id="_idTextAnchor192"/>mpiler:2.4.2"</p><p class="source-code">implementation "androidx.room:room-ktx:2.4.2"</p></li>
				<li>While you are still inside the <strong class="source-inline">build.gradle</strong> file, add the <strong class="source-inline">kotlin-kapt</strong> plugin for Room inside the <strong class="source-inline">plugins</strong> block:<p class="source-code">plugins {</p><p class="source-code">    id 'com.android.application'</p><p class="source-code">    id 'kotli<a id="_idTextAnchor193"/>n-android'</p><p class="source-code">    <strong class="bold">id 'kotlin-kapt'</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">kapt</strong> plugin stands<a id="_idIndexMarker449"/> for <strong class="bold">Kotlin Annotation Processing Tool</strong>. This allows Room to generate annotated code at compile time while hiding most of the associated complexity from us.</p>
			<p>After <a id="_idIndexMarker450"/>updating the <strong class="source-inline">build.gradle</strong> files, make <a id="_idIndexMarker451"/>sure to sync your project with its Gradle files. You can do that by pressing on the <strong class="bold">File</strong> menu option and then by selecting <strong class="bold">Sync Project with Gradle Files</strong>.</p>
			<ol>
				<li value="3">Since we want to store restaurant objects inside our local database, let's instruct Room that the <strong class="source-inline">Restaurant</strong> data class is an entity that must be saved. Head inside the <strong class="source-inline">Restaurant.kt</strong> file, and add the <strong class="source-inline">@Entity</strong> annotation on top of the cl<a id="_idTextAnchor194"/>ass declaration:<p class="source-code"><strong class="bold">@Entity(tableName = "restaurants")</strong></p><p class="source-code">data class Restaurant(…)</p></li>
			</ol>
			<p>Inside the <strong class="source-inline">@Entity</strong> annotation, we have passed the name of the table via the <strong class="source-inline">tableName</strong> parameter. We will use this name when making queries.</p>
			<ol>
				<li value="4">Now that Room will create a table with <strong class="source-inline">Restaurant</strong> objects as rows, it's time to define the columns (or fields) of the entity. While we are still inside the <strong class="source-inline">Restaurant.kt</strong> class, let's add the <strong class="source-inline">@ColumnInfo</strong> annotation on top of each field that we're interested in, and that should represent a column:<p class="source-code">@Entity(tableName = "restaurants")</p><p class="source-code">data class<a id="_idTextAnchor195"/> Restaurant(</p><p class="source-code">    <strong class="bold">@ColumnInfo(name = "r_id")</strong></p><p class="source-code">    @SerializedName("r_id")</p><p class="source-code">    <a id="_idTextAnchor196"/>val id: Int,</p><p class="source-code">    <strong class="bold">@ColumnInfo(name = "r_title")</strong></p><p class="source-code">    @SerializedName("r_title")</p><p class="source-code">    val ti<a id="_idTextAnchor197"/>tle: String,</p><p class="source-code">    <strong class="bold">@ColumnInfo(name = "r_description")</strong></p><p class="source-code">    @SerializedName("r_description")</p><p class="source-code">    val description: String,</p><p class="source-code">    var isFavorite: Boolean = false</p><p class="source-code">)</p></li>
			</ol>
			<p>For each <a id="_idIndexMarker452"/>field we're interested in saving, we've <a id="_idIndexMarker453"/>added the <strong class="source-inline">@ColumnInfo</strong> annotation and passed a <strong class="source-inline">String</strong> value to the <strong class="source-inline">name</strong> parameter. These names will correspond to the name of the table's columns. Right now, we are not interested in saving the <strong class="source-inline">isFavorite</strong> field; we will do that a bit later.</p>
			<ol>
				<li value="5">The entity that represents a table should have a primary key column that ensures uniqueness within the database. For this, we can use the <strong class="source-inline">id</strong> field that was configured from our Firebase database to be unique. While still inside the <strong class="source-inline">Restaurant.kt</strong> class, let's add the <strong class="source-inline">@PrimaryKey</strong> annotation to the <strong class="source-inline">id</strong> field:<p class="source-code">@Entity(tableName = "restaurants")</p><p class="source-code">data cla<a id="_idTextAnchor198"/>ss Restaurant(</p><p class="source-code">    <strong class="bold">@PrimaryKey()</strong></p><p class="source-code">    @ColumnInfo(name = "r_id")</p><p class="source-code">    @SerializedName("r_id")</p><p class="source-code">    val id: Int,</p><p class="source-code">    …)</p></li>
			</ol>
			<p>Now we have defined the entity for our database and configured the table's columns.</p>
			<p>It's time to create a DAO that will serve as the entry point to our database, allowing us to perform various actions on it. </p>
			<ol>
				<li value="6">Create a DAO by clicking on the application package, selecting <strong class="bold">New</strong>, and then selecting <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsDao</strong> as the name, and select <strong class="bold">Interface</strong> as the type. Inside the new file, add the following code:<p class="source-code">import and<a id="_idTextAnchor199"/>roidx.room.*</p><p class="source-code">@Dao</p><p class="source-code">interface RestaurantsDao { }</p></li>
			</ol>
			<p>Since Room <a id="_idIndexMarker454"/>will take care of implementing any <a id="_idIndexMarker455"/>actions that we need to interact with the database, the DAO is an interface, just like Retrofit also had an interface for the HTTP methods. To instruct Room that this is a DAO entity, we've added the <strong class="source-inline">@Dao</strong> annotation on top of the interface dec<a id="_idTextAnchor200"/>laration.</p>
			<ol>
				<li value="7">Inside the <strong class="source-inline">RestaurantsDao</strong> interface, add two <strong class="source-inline">suspend</strong> functions that will help us to both save the restaurants and retrieve them from the database:<p class="source-code">@Dao</p><p class="source-code">interface<a id="_idTextAnchor201"/> RestaurantsDao {</p><p class="source-code"><strong class="bold">    @Query("SELECT * FROM restaurants")</strong></p><p class="source-code"><strong class="bold">    suspend fun getAll(): List&lt;Restaurant&gt;</strong></p><p class="source-code"><strong class="bold">    @Insert(onConflict = OnConflictStrategy.REPLACE)</strong></p><p class="source-code"><strong class="bold">    suspend fun addAll(restaurants: List&lt;Restaurant&gt;)</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Now, let's analyze the two methods that we've added:</p>
			<ul>
				<li><strong class="source-inline">getAll()</strong> is a <a id="_idIndexMarker456"/>query statement that returns the restaurants that were previously cached inside the database. Since we<a id="_idIndexMarker457"/> need to perform a SQL query when calling this method, we've marked it with the <strong class="source-inline">@Query</strong> annotation and specified that we want all the restaurants (by adding <strong class="source-inline">*</strong>) from the <strong class="source-inline">restaurants</strong> table defined in the <strong class="source-inline">Restaurant</strong> entity data class.</li>
				<li><strong class="source-inline">addAll()</strong> is an <strong class="source-inline">insert</strong> statement that caches the received restaurants inside the database. To mark this as a SQL <strong class="source-inline">insert</strong> statement, we've added the <strong class="source-inline">@Insert</strong> annotation. However, if the restaurants being inserted are already present in the database, we should replace the old ones with the new ones to refresh our cache. We instructed Room to do so by passing the <strong class="source-inline">OnConflictStrategy.REPLACE</strong> value into the <strong class="source-inline">@Insert</strong> annotation.</li>
			</ul>
			<p>Both methods are marked as <strong class="source-inline">suspend</strong> functions because any interaction with the Room database can take time and is an async job; therefore, it shouldn't block the UI.</p>
			<p>Now, we have defined an entity class and a DAO class, we must define the last component that Room needs in order to function, the database class.</p>
			<ol>
				<li value="8">Create a Room database class by clicking on the application package. Select <strong class="bold">New</strong>, and then select <strong class="bold">Ko<a id="_idTextAnchor202"/>tlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsDb</strong> as the name, and select <strong class="bold">File</strong> as the type. Inside the new file, add the following code:<p class="source-code">@Database(</p><p class="source-code">    entities = [Restaurant::class], </p><p class="source-code">    version = 1, </p><p class="source-code">    exportSchema = false)</p><p class="source-code">abstract class RestaurantsDb : RoomDatabase() { }</p></li>
			</ol>
			<p>Now, let's analyze the code that we've just added:</p>
			<ul>
				<li><strong class="source-inline">RestaurantsDb</strong> is an abstract class that inherits from <strong class="source-inline">RoomDatabase()</strong>. This will allow Room to create the actual implementation of the database behind the scenes and hide all the heavy implementation details from us.</li>
				<li>For the <strong class="source-inline">RestaurantsDb</strong> class, we've added the <strong class="source-inline">@Database</strong> annotation so that Room knows that this class represents a database and provides an implementation for it. Inside this annotation, we've passed the following:</li>
				<li>The <strong class="source-inline">Restaurant</strong> class to the <strong class="source-inline">entities</strong> parameter. This parameter tells Room<a id="_idIndexMarker458"/> which entities are associated<a id="_idIndexMarker459"/> with this database so that it can create corresponding tables. The parameter expects an array, so you can add as many entity classes as you wish, as long as they are annotated with <strong class="source-inline">@Entity</strong>.</li>
				<li><strong class="source-inline">1</strong> as the <strong class="source-inline">version</strong> number of the database. We should increment this version number whenever the schema of the database changes. The <strong class="bold">schema</strong> is the collection of database objects, such as the tables that <a id="_idIndexMarker460"/>correspond to entities. If we change the <strong class="source-inline">Restaurant</strong> class, since it's an entity, we might change the schema of the database, and Room needs to know that for migration purposes.</li>
				<li><strong class="source-inline">false</strong> to the <strong class="source-inline">exportSchema</strong> parameter. Room can export the schema of our database externally; however, for simplicity, we chose not to do so.</li>
			</ul>
			<ol>
				<li value="9">Inside the <strong class="source-inline">RestaurantsDb</strong> class, add an abstract <strong class="source-inline">RestaurantsDao</strong> variable:<p class="source-code">@Database(…)</p><p class="source-code">abstract class Restaurants<a id="_idTextAnchor203"/>Db : RoomDatabase() {</p><p class="source-code">    <strong class="bold">abstract val dao: RestaurantsDao</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>We know that the database class should expose a DAO object so that we can interact with the database. By leaving it abstract, we allow Room to provide its implementation behind the scenes.</p>
			<ol>
				<li value="10">Even though we<a id="_idIndexMarker461"/> declared a variable <a id="_idIndexMarker462"/>to hold our DAO object, we still need to find a way to build the database and obtain a reference to the <strong class="source-inline">RestaurantsDao</strong> instance that Room will create for us. Inside the <strong class="source-inline">RestaurantsDb</strong> class, add <strong class="source-inline">companion object</strong> and then add the <strong class="source-inline">buildDatabase</strong> method:<p class="source-code">@Database(…)</p><p class="source-code">abstract class RestaurantsDb : RoomDatabase() {</p><p class="source-code">    abstract val dao: RestaurantsDao</p><p class="source-code"><strong class="bold">    companion object {</strong></p><p class="source-code"><strong class="bold">        private fun buildDatabase(context: Context): </strong></p><p class="source-code"><strong class="bold">            RestaurantsDb =</strong></p><p class="source-code"><strong class="bold">            Room.databaseBuilder(</strong></p><p class="source-code"><strong class="bold">                context.applicationContext,</strong></p><p class="source-code"><strong class="bold">                RestaurantsDb::class.java,</strong></p><p class="source-code"><strong class="bold">                "restaurants_database")</strong></p><p class="source-code"><strong class="bold">                .fallbackToDestructiveMigration()</strong></p><p class="source-code"><strong class="bold">                .build()</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Essentially, this method returns a <strong class="source-inline">RestaurantsDb</strong> instance. To construct a Room database, we need to call the <strong class="source-inline">Room.databaseBuilder</strong> constructor, which expects the following parameters:</p>
			<ul>
				<li>A <strong class="source-inline">Context</strong> object that we provided from the <strong class="source-inline">context</strong> input argument of our <strong class="source-inline">buildDatabase</strong> method. </li>
				<li>The class of the<a id="_idIndexMarker463"/> database you're trying to build, that is, the <strong class="source-inline">RestaurantsDb</strong> class.</li>
				<li>A name for the<a id="_idIndexMarker464"/> database – we named it <strong class="source-inline">"restaurants_database"</strong>.</li>
			</ul>
			<p>The builder returns a <strong class="source-inline">RoomDatabase.Builder</strong> object on which we called <strong class="source-inline">.fallbackToDestructiveMigration()</strong>. This means that, in the case of a schema change (such as performing changes in the entity class and modifying the table columns), the tables would be dropped (or deleted) instead of trying to migrate the contents from the previous schema (which would have been a bit more complex).</p>
			<p>Finally, we called <strong class="source-inline">build()</strong> on the builder object so that our <strong class="source-inline">buildDatabase()</strong> method returns a <strong class="source-inline">RestaurantsDb</strong> instance.</p>
			<p>It's time to finally get a reference to our DAO so that we can start using the database.</p>
			<ol>
				<li value="11">While still inside the <strong class="source-inline">companion object</strong> of the <strong class="source-inline">RestaurantsDb</strong> class, add the following code:<p class="source-code">companion object {</p><p class="source-code"><strong class="bold">    @Volatile</strong></p><p class="source-code"><strong class="bold">    private var INSTANCE: RestaurantsDao? = null</strong></p><p class="source-code"><strong class="bold">    fun getDaoInstance(context: Context): RestaurantsDao   </strong></p><p class="source-code"><strong class="bold">    {</strong></p><p class="source-code"><strong class="bold">        synchronized(this) {</strong></p><p class="source-code"><strong class="bold">            var instance = INSTANCE</strong></p><p class="source-code"><strong class="bold">            if (instance == null) {</strong></p><p class="source-code"><strong class="bold">                instance = buildDatabase(context).dao</strong></p><p class="source-code"><strong class="bold">                INSTANCE = instance</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">            <a id="_idTextAnchor204"/>return instance</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">    private fun buildDatabase(…) = …</p><p class="source-code">}</p></li>
			</ol>
			<p>Now, let's break down what we've done:</p>
			<ul>
				<li>We added <a id="_idIndexMarker465"/>an <strong class="source-inline">INSTANCE</strong> variable of <a id="_idIndexMarker466"/> type <strong class="source-inline">RestaurantsDao</strong>. Since this variable is inside the companion object, <strong class="source-inline">INSTANCE</strong> is static. Additionally, we marked it with <strong class="source-inline">@Volatile</strong>. This means that writes to this field are immediately made visible to other threads. Don't worry too much about these multithreading concepts – we will get rid of this boilerplate code soon enough.</li>
				<li>We created a <strong class="source-inline">getDaoInstance()</strong> method where we added a block of code that calls the <strong class="source-inline">buildDatabase()</strong> method and gets the DAO object by calling the <strong class="source-inline">.dao</strong> accessor.</li>
			</ul>
			<p>Since we want only one memory reference to our database (and not create other database<a id="_idIndexMarker467"/> instances in other parts of the app), we made sure that our <strong class="source-inline">INSTANCE</strong> variable conforms to the singleton pattern. Essentially, the <strong class="bold">singleton pattern</strong> allows<a id="_idIndexMarker468"/> us to hold a static reference to an object so that it lives as long as our application does.</p>
			<p>By following this approach, anytime we need to access the Room database from different parts of the app, we can call the <strong class="source-inline">getDaoInstance()</strong> method, which returns an instance of <strong class="source-inline">RestaurantsDao</strong>. Additionally, we can be sure that it's always the same memory reference and that no concurrency issues will occur since we have wrapped the instance creation code inside a <strong class="source-inline">synchronized</strong> block.</p>
			<ol>
				<li value="12">You might have noticed that to get a reference to our DAO and cache our restaurants in the<a id="_idIndexMarker469"/> database, the <strong class="source-inline">RestaurantsDb.getDaoInstance()</strong> method expects a <strong class="source-inline">Context</strong> object. This is needed to create the instance of the database. However, we want to get our DAO in the <strong class="source-inline">RestaurantsViewModel</strong> class, and we have no context there, so what should we do?</li>
			</ol>
			<p>Let's expose the application context from the application class! Create the application class by clicking on the application package, selecting <strong class="bold">New</strong>, and then <a id="_idTextAnchor205"/>selecting <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">RestaurantsApplication</strong> as the name, and select <strong class="bold">File</strong> as the type. Inside the new file, add the following code:</p>
			<p class="source-code">class RestaurantsApplication: Application() {</p>
			<p class="source-code">    init { app = this }</p>
			<p class="source-code">    companion object {</p>
			<p class="source-code">        private lateinit var app: RestaurantsApplication</p>
			<p class="source-code">        fun getAppContext(): Context = </p>
			<p class="source-code">  <a id="_idTextAnchor206"/>          app.applicationContext</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>This class now inherits from <strong class="source-inline">android.app.Application</strong> and exposes its context through the static <strong class="source-inline">getAppContext()</strong> method. The only issue is that even though we have an application class, we still haven't configured the project to recognize it.</p>
			<ol>
				<li value="13">In the <strong class="source-inline">AndroidManifest.xml</strong> file, inside the <strong class="source-inline">&lt;application&gt;</strong> element, add the <strong class="source-inline">android:name</strong> identifier that <a id="_idIndexMarker470"/>sets our <strong class="source-inline">RestaurantsApplication</strong> class as<a id="_idIndexMarker471"/> the application class:<p class="source-code">&lt;applicatio<a id="_idTextAnchor207"/>n</p><p class="source-code">    android:allowBackup="true"</p><p class="source-code">    <strong class="bold">android:name=".RestaurantsApplication"</strong></p><p class="source-code">    android:icon="@mipmap/ic_launcher"</p><p class="source-code">    …</p><p class="source-code">    &lt;activity&gt; … &lt;/activity&gt;</p><p class="source-code">&lt;/application&gt;</p></li>
			</ol>
			<p>It's time to finally start working on caching those res<a id="_idTextAnchor208"/>taurants in our database.</p>
			<ol>
				<li value="14">Inside the <strong class="source-inline">RestaurantsViewModel</strong> class, add a <strong class="source-inline">restaurantsDao</strong> variable. Then, instantiate it via the static <strong class="source-inline">RestaurantsDb.getDaoInstance</strong> method:<p class="source-code">class RestaurantsViewModel(…) : ViewModel() {</p><p class="source-code">    private var restInterface: RestaurantsApiService</p><p class="source-code">    <strong class="bold">private var restaurantsDao = RestaurantsDb</strong></p><p class="source-code"><strong class="bold">        .getDaoInstance(</strong></p><p class="source-code"><strong class="bold">            RestaurantsApplication.getAppContext()</strong></p><p class="source-code">        <strong class="bold">)</strong></p><p class="source-code">     ....</p><p class="source-code">}</p></li>
			</ol>
			<p>Make sure that you pass the application context through the newly created <strong class="source-inline">getAppContext()</strong> method inside the application class.</p>
			<ol>
				<li value="15">Now we're ready to save the <a id="_idIndexMarker472"/>restaurants locally! While you are still in the <strong class="source-inline">R<a id="_idTextAnchor209"/>estaurantsViewModel</strong> class, inside the <strong class="source-inline">getRemoteRestaurants()</strong> method, add<a id="_idIndexMarker473"/> these new lines of code:<p class="source-code">private suspend fun getRemoteRestaurants(): </p><p class="source-code">    List&lt;Restaurant&gt; {</p><p class="source-code">    retur<a id="_idTextAnchor210"/>n withContext(Dispatchers.IO) {</p><p class="source-code">        <strong class="bold">val restaurants =</strong> restInterface.getRestaurants()</p><p class="source-code"><strong class="bold">        restaurantsDao.addAll(restaurants)</strong></p><p class="source-code"><strong class="bold">        return@withContext restaurants</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Essentially, what we are doing is the following: </p>
			<p>I.	Getting the restaurants from the remote API (here, it's the Retrofit <strong class="source-inline">restInterface</strong> variable).</p>
			<p>II.	Caching those restaurants inside the local database through Room by calling <strong class="source-inline">restaurantsDao.addAll()</strong>.</p>
			<p>III.	Finally, returning the restaurants to the UI.</p>
			<ol>
				<li value="16">Run the app while you have a working internet connection.</li>
			</ol>
			<p>In terms of the UI, nothing should change – you should still see the restaurants. That said, behind the scenes, the restaurants should now have been cached.</p>
			<ol>
				<li value="17">Run the app again but without internet.</li>
			</ol>
			<p>The chances are that you won't see anything. The restaurants are not there.</p>
			<p>This happens because, while we are offline, we never try to get the previously cached restaurants from the Room database. Moreover, when offline, the <strong class="source-inline">restInterface.getRestaurants()</strong> suspending function throws an error because the HTTP call that fetches the restaurants has failed<a id="_idTextAnchor211"/> – this exception should arrive inside <strong class="source-inline">CoroutineExceptionHandler</strong>. The exception is thrown by Retrofit because the associated network request has failed.</p>
			<ol>
				<li value="18">Let's leverage<a id="_idIndexMarker474"/> the fact that, while we're<a id="_idIndexMarker475"/> offline, the <strong class="source-inline">restInterface.getRestaurants()</strong> function call throws an exception. This is so that we can wrap the whole block of code inside <strong class="source-inline">getRemoteRestaurants()</strong> inside a <strong class="source-inline">try-catch</strong> block:<p class="source-code">private suspend fun getRemoteRestaurants():</p><p class="source-code"><strong class="bold">        </strong>List&lt;Restaurant&gt; {</p><p class="source-code">    retu<a id="_idTextAnchor212"/>rn withContext(Dispatchers.IO) {</p><p class="source-code"><strong class="bold">        try {</strong></p><p class="source-code">            val restaurants = restInterface</p><p class="source-code">                .getRestaurants()</p><p class="source-code">            restaurantsDao.addAll(restaurants)</p><p class="source-code">            return@withContext restaurants</p><p class="source-code"><strong class="bold">        } catch (e: Exception) {</strong></p><p class="source-code"><strong class="bold">            when (e) {</strong></p><p class="source-code"><strong class="bold">                is UnknownHostException,</strong></p><p class="source-code"><strong class="bold">                is ConnectException,</strong></p><p class="source-code"><strong class="bold">                is HttpException -&gt; {</strong></p><p class="source-code"><strong class="bold">                    return@withContext </strong></p><p class="source-code"><strong class="bold">                        restaurantsDao.getAll()</strong></p><p class="source-code"><strong class="bold">                }</strong></p><p class="source-code"><strong class="bold">                else -&gt; throw e</strong></p><p class="source-code"><strong class="bold">            }</strong></p><p class="source-code"><strong class="bold">        }</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Essentially, what happens now is that if the user is offline, we catch the exception thrown by Retrofit. Alternatively, we return the cached restaurants from the Room database by calling <strong class="source-inline">restaurantsDao.getAll()</strong>.</p>
			<p>As an extra, we <a id="_idIndexMarker476"/>also check whether the<a id="_idIndexMarker477"/> exception we've caught has been thrown because of the user's poor or inexistent internet connect<a id="_idTextAnchor213"/>ivity. If the <strong class="source-inline">Exceptio<a id="_idTextAnchor214"/>n</strong> object is of type <strong class="source-inline">UnknownHostException</strong>, <strong class="source-inline">ConnectException</strong>, or <strong class="source-inline">HttpException</strong>, we're loading the restaurants from Room through our DAO; otherwise, we propagate the exception so that it's caught later by <strong class="source-inline">CoroutineExceptionHandler</strong>.</p>
			<ol>
				<li value="19">Before running the app, let's refactor our <strong class="source-inline">getRemoteRestaurants()</strong> method a bit. Now, the name of the method implies that it retrieves restaurants from a remote source. However, in reality, it also retrieves restaurants from Room if the user is offline. Room is a local data source, so the name of this method is no longer appropriate.</li>
			</ol>
			<p>Rename the <strong class="source-inline">getRemoteRestaurants()</strong> method to <strong class="source-inline">getAllRestaurants()</strong>:</p>
			<p class="source-code">private suspend fun <strong class="bold">getAllRestaurants</strong>(): </p>
			<p class="source-code">    List&lt;Restaurant&gt; {  }</p>
			<p>Additionally, remember to rename its usage in the <strong class="source-inline">getRestaurants()</strong> method where the coroutine is launched:</p>
			<p class="source-code">private fun getRestaurants() {</p>
			<p class="source-code">    viewModelScope.launch<a id="_idTextAnchor215"/>(errorHandler) {</p>
			<p class="source-code">        val restaurants = <strong class="bold">getAllRestaurants()</strong></p>
			<p class="source-code">        state.value = restaurants.restoreSelections()</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<ol>
				<li value="20">Run the <a id="_idIndexMarker478"/>app again without an internet <a id="_idIndexMarker479"/>connection.</li>
			</ol>
			<p>Because the restaurants were previously cached and now the user is offline, we are fetching them from Room. You should see the restaurants even without the internet. Success!</p>
			<p>Even though we've come a long way and have managed to make the Restaurants app usable even without internet, there is still something that we've missed. To reproduce it, perform the following steps:</p>
			<ol>
				<li value="1">Try running the application (either online or offline), and then mark a couple of restaurants as favorites.</li>
				<li>Disconnect <a id="_idIndexMarker480"/>your device from the<a id="_idIndexMarker481"/> internet and make sure you are now offline.</li>
				<li>Restart the application while remaining offline.</li>
			</ol>
			<p>You will get to see the restaurants, but your previous selections have been lost. More precisely, even though we have marked some restaurants as favorites, all restaurants now appear as not favorites. It's time to fix this!</p>
			<h1 id="_idParaDest-96"><a id="_idTextAnchor216"/>Applying partial updates to the Room database</h1>
			<p>Right <a id="_idIndexMarker482"/>now, our application is saving the restaurants<a id="_idIndexMarker483"/> that we receive from the remote web API directly inside the Room database.</p>
			<p>This is not a bad approach; however, whenever we are marking a restaurant as a favorite, we aren't updating the corresponding restaurant inside Room. If we take a look inside the <strong class="source-inline">RestaurantsViewModel</strong> class and we check its <strong class="source-inline">toggleFavorite()</strong> method, we can see that we're only updating the <strong class="source-inline">isFavorite</strong> flag of a restaurant inside the <strong class="source-inline">state</strong> variable:</p>
			<p class="source-code">fun toggleFavorite(id: Int) {</p>
			<p class="source-code">    val restaurants = state.value.toMutableList()</p>
			<p class="source-code">    val itemIndex = restaurants.indexOfFirst { it.id == id }</p>
			<p class="source-code">    val item = restaurants[itemIndex]</p>
			<p class="source-code">    restaurants[itemIndex] = item.copy(isFavorite =  </p>
			<p class="source-code">        !item.isFavorite)</p>
			<p class="source-code">    storeSelection(restaurants[itemIndex])</p>
			<p class="source-code">    state.value = restaurants</p>
			<p class="source-code">}</p>
			<p>We aren't updating the corresponding restaurant's <strong class="source-inline">isFavorite</strong> field value inside Room. So, whenever we use the application offline, the restaurants will no longer appear as favorites, even though when we were online, we might have marked some as favorites.</p>
			<p>To fix this, whenever we mark a restaurant as a favorite or not a favorite, we need to apply a partial update on a particular <strong class="source-inline">Restaurant</strong> object inside our Room database. The partial update <a id="_idIndexMarker484"/>should not replace the entire <strong class="source-inline">Restaurant</strong> object, but<a id="_idIndexMarker485"/> it should only update its <strong class="source-inline">isFavorite</strong> field value.</p>
			<p>Let's get started! Perform the following steps:</p>
			<ol>
				<li value="1">Create a partial entity class by clicking on the application package, selecting <strong class="bold">New</strong>, and then selecting <strong class="bold">Kotlin Class/File</strong>. Enter <strong class="source-inline">PartialRestaurant</strong> as the name, and select <strong class="bold">File</strong> as the <a id="_idTextAnchor217"/>type. Inside the new file, ad<a id="_idTextAnchor218"/><a id="_idTextAnchor219"/>d the following code:<p class="source-code">@Entity</p><p class="source-code">class PartialRestaurant(</p><p class="source-code">    @ColumnInfo(name = "r_id")</p><p class="source-code">    val id: Int,</p><p class="source-code">    @ColumnInfo(name = "is_favorite")</p><p class="source-code">    val isFavorite: Boolean)</p></li>
			</ol>
			<p>In this <strong class="source-inline">@Entity</strong> annotated class, we've only added two fields:</p>
			<ul>
				<li>An <strong class="source-inline">id</strong> field with a <strong class="source-inline">@ColumnInfo()</strong> annotation that has the same value (<strong class="source-inline">"r_id"</strong>) passed to the <strong class="source-inline">name</strong> parameter as the <strong class="source-inline">Restaurant</strong> object's <strong class="source-inline">id</strong> field. This allows Room to match the <strong class="source-inline">Restaurant</strong> object's <strong class="source-inline">id</strong> field with the one from <strong class="source-inline">PartialRestaurant</strong>.</li>
				<li>An <strong class="source-inline">isFavorite</strong> field with a <strong class="source-inline">@ColumnInfo()</strong> annotation that has the name set to <strong class="source-inline">"is_favorited"</strong>. So far, Room can't match this field with the one from <strong class="source-inline">Restaurant</strong>, because inside <strong class="source-inline">Restaurant</strong>, we haven't annotated the <strong class="source-inline">isFavorite</strong> field with <strong class="source-inline">@ColumnInfo</strong> – we'll do that next.</li>
			</ul>
			<ol>
				<li value="2">Now<a id="_idIndexMarker486"/> that our partial entity, called <strong class="source-inline">PartialRestaurant</strong>, has a <a id="_idIndexMarker487"/>column corresponding to the <strong class="source-inline">isFavorite</strong> field, it's time to also add a <strong class="source-inline">@ColumnInfo()</strong> annotation with the same value (<strong class="source-inline">"is_favorite"</strong>) for the <strong class="source-inline">isFavorite</strong> field of the <strong class="source-inline">Restaurant</strong> entity:<p class="source-code">@Entity(tableName = "restaurants")</p><p class="source-code">data class Restaurant(</p><p class="source-code">    …</p><p class="source-code">    val descriptio<a id="_idTextAnchor220"/>n: String,</p><p class="source-code">    <strong class="bold">@ColumnInfo(name = "is_favorite")</strong></p><p class="source-code">    <strong class="bold">val</strong> isFavorite: Boolean = false</p><p class="source-code">)</p></li>
			</ol>
			<p>As a good practice, we've also made the <strong class="source-inline">isFavorite</strong> field <strong class="source-inline">val</strong> instead of <strong class="source-inline">var</strong> to prevent its value from being changed once the object has been created. Because <strong class="source-inline">Restaurant</strong> is an object passed to a Compose <strong class="source-inline">State</strong> object, we want to promote immutability across its fields to ensure recomposition events happen.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">By having a data class field as <strong class="source-inline">var</strong>, we can easily change its value at runtime and risk having Compose miss a well-needed recomposition. Immutability ensures that whenever an object field's value changes, a new object is created (just as we do with the <strong class="source-inline">.copy()</strong> function), and Compose is notified so that it can trigger recompo<a id="_idTextAnchor221"/>sition.</p>
			<ol>
				<li value="3">Since the <strong class="source-inline">isFavorite</strong> field is now <strong class="source-inline">val</strong>, the <strong class="source-inline">restoreSelections()</strong> extension function inside <strong class="source-inline">RestaurantViewModel</strong> has broken. Update its code as follows:<p class="source-code">private fun List&lt;Restaurant&gt;.restoreSelections(): … {</p><p class="source-code">    stateHandle.[…]let { selectedIds -&gt;</p><p class="source-code">        val res<a id="_idTextAnchor222"/>taurantsMap = this.associateBy { it.id }</p><p class="source-code">            <strong class="bold">.toMutableM<a id="_idTextAnchor223"/>ap()</strong></p><p class="source-code">        selectedIds.forEach { id -&gt;</p><p class="source-code"><strong class="bold">            val restaurant = </strong></p><p class="source-code"><strong class="bold">                restaurantsMap[id] ?: return@forEach</strong></p><p class="source-code"><strong class="bold">            restaurantsMap[id] =</strong></p><p class="source-code"><strong class="bold">                restaurant.copy(isFavorite = true)</strong></p><p class="source-code">        }</p><p class="source-code">        return restaurantsMap.values.toList()</p><p class="source-code">    }</p><p class="source-code">    return this</p><p class="source-code">}</p></li>
			</ol>
			<p>Essentially, what <a id="_idIndexMarker488"/>we have done is make sure <a id="_idIndexMarker489"/>our <strong class="source-inline">restaurantsMap</strong> of type <strong class="source-inline">Map&lt;Int, Restaurant&gt;</strong> is mutable so that we can replace elements inside it. With this approach, we are now replacing the restaurant at entry <strong class="source-inline">id</strong> by passing a new object reference with the <strong class="source-inline">copy</strong> function. We are not going to go into much detail since this portion of the code will soon be removed.</p>
			<ol>
				<li value="4">Now that we have a partial entity defined, we need to add another function inside our DAO that will update a <strong class="source-inline">Restaurant</strong> entity through a <strong class="source-inline">PartialRestaurant</strong> entity. Inside <strong class="source-inline">RestaurantsDao</strong>, add the <strong class="source-inline">update()</strong> function:<p class="source-code">@Dao</p><p class="source-code">interface RestaurantsDao {</p><p class="source-code">    …</p><p class="source-code">    @Insert(onConflict = OnConflictStrategy.REPLACE)</p><p class="source-code">    suspend fun addAll(restaurants: List&lt;Res<a id="_idTextAnchor224"/>taurant&gt;)</p><p class="source-code"><strong class="bold">    @Update(entity = Restaurant::class)</strong></p><p class="source-code"><strong class="bold">    suspend fun update(partialRestaurant:</strong></p><p class="source-code"><strong class="bold">        PartialRestaurant)</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Let's <a id="_idIndexMarker490"/>understand, step by step, how <a id="_idIndexMarker491"/>the new <strong class="source-inline">update()</strong> function works:</p>
			<p>I.	It's a <strong class="source-inline">suspend</strong> function because, as we know by now, any interaction with the local database is a suspending job that should not run on the main thread.</p>
			<p>II.	It receives a <strong class="source-inline">PartialRestaurant</strong> entity as an argument and returns nothing. The partial entity's field values correspond to the restaurant that we're trying to update.</p>
			<p>III.	It's annotated with the <strong class="source-inline">@Update</strong> annotation to which we passed the <strong class="source-inline">Restaurant</strong> entity. The update process has two steps, as follows:</p>
			<p>i.	First, <strong class="source-inline">PartialRestaurant</strong> exposes the <strong class="source-inline">id</strong> field, whose value matches the <strong class="source-inline">id</strong> field's value of the corresponding <strong class="source-inline">Restaurant</strong> object.</p>
			<p>ii.	Once the match is complete, the <strong class="source-inline">isFavorite</strong> field's value is set to the <strong class="source-inline">isFavorite</strong> field of the matched <strong class="source-inline">Restaurant</strong> object.</p>
			<p>These matches are possible because the <strong class="source-inline">id</strong> and <strong class="source-inline">isFavorite</strong> fields of both entities have the same <strong class="source-inline">@ColumnInfo</strong> name values.</p>
			<ol>
				<li value="5">Now that our <a id="_idIndexMarker492"/>DAO knows how to partially<a id="_idIndexMarker493"/> update our <strong class="source-inline">Restaur<a id="_idTextAnchor225"/>ant</strong> entity, it's time to perform the update.</li>
			</ol>
			<p>First, inside <strong class="source-inline">RestaurantsViewModel</strong>, add a n<a id="_idTextAnchor226"/>ew suspending functi<a id="_idTextAnchor227"/>on, called <strong class="source-inline">toggleFavoriteRestaurant()</strong>:</p>
			<p class="source-code">private suspend fun toggleFavoriteRestaurant(id: Int, oldValue: Boolean) =</p>
			<p class="source-code">    withContext(Dispatchers.IO) {</p>
			<p class="source-code">        restaurantsDao.update(</p>
			<p class="source-code">            PartialRestaurant(</p>
			<p class="source-code">                id = id,</p>
			<p class="source-code">                isFavorite = !oldValue</p>
			<p class="source-code">            )</p>
			<p class="source-code">        )</p>
			<p class="source-code">    }</p>
			<p>Let's understand, step by step, what this new method does:</p>
			<p>I.	 It receives the <strong class="source-inline">id</strong> field of the restaurant that we're trying to update, along with the <strong class="source-inline">oldValue</strong> field which represents the value of the <strong class="source-inline">isFavorite</strong> field just before the user has toggled the heart icon of the restaurant.</p>
			<p>II.	 To partially update a restaurant, it needs to interact with the Room DAO object. This means that the <strong class="source-inline">toggleFavoriteRestaurant</strong> method must be a <strong class="source-inline">suspend</strong> function. As a good practice, we wrapped it inside a <strong class="source-inline">withContext</strong> block that specifies its work must be done inside the <strong class="source-inline">IO</strong> dispatcher. While Room ensures that we wrap our suspending work with a special dispatcher, we explicitly specified the <strong class="source-inline">Dispatchers.IO</strong> dispatcher to better highlight that such heavy work should be done in an appropriate dispatcher.</p>
			<p>III.	 It builds a <strong class="source-inline">PartialRestaurant</strong> object, which it then passes to the DAO's  <strong class="source-inline">update()</strong> method that was created earlier. The <strong class="source-inline">PartialRestaurant</strong> object gets the <strong class="source-inline">id</strong> field of the restaurant we're updating, along with the negated value of the <strong class="source-inline">isFavorite</strong> flag. If the user previously didn't have the restaurant marked as favorite, upon clicking the heart icon, we should negate the old (<strong class="source-inline">false</strong>) value and obtain <strong class="source-inline">true</strong>, or vice versa.</p>
			<p>Now that we have the method in place to update a restaurant, it's time to call it.</p>
			<ol>
				<li value="6">While you <a id="_idIndexMarker494"/>are still in <strong class="source-inline">RestaurantsViewModel</strong>, make the <strong class="source-inline">toggleFavorite</strong> method launch a coroutine at the<a id="_idIndexMarker495"/> end of its body. Then, inside it, call the new <strong class="source-inline">toggleFavoriteRestaurant()</strong> suspending function:<p class="source-code">fun toggleFavorite(id: Int) {</p><p class="source-code">    …</p><p class="source-code">    restaurants[itemIndex] = item.copy(isFavorite =  </p><p class="source-code">       !item.isFavorite)</p><p class="source-code">    storeSelection(restaurants[itemIndex])</p><p class="source-code">    state.value = restaurants</p><p class="source-code"><strong class="bold">    viewModelScope.launch<a id="_idTextAnchor228"/> {</strong></p><p class="source-code"><strong class="bold">        toggleFavoriteRestaurant(id, item.isFavorite)</strong></p><p class="source-code"><strong class="bold">    }</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>To the <strong class="source-inline">toggleFavoriteRestaurant()</strong> function, we've passed the following:</p>
			<ul>
				<li>The <strong class="source-inline">id</strong> parameter, which represents the ID of the restaurant the user is trying to mark as favorite or not favorite</li>
				<li>The old value of the favorite status of the restaurant, as defined by the <strong class="source-inline">isFavorite</strong> flag of the <strong class="source-inline">item</strong> field</li>
			</ul>
			<p>Now, whenever the user presses on the heart icon, we not only update the UI but also cache this selection inside the local database through a partial update.</p>
			<ol>
				<li value="7">Build and run <a id="_idIndexMarker496"/>the application because it's time to test what we've just implemented! Unfortunately, the app crashes. Can you think of one reason why this happens? If we look at the stack trace of the error, we will see the following message:<p class="source-code">java.lang.IllegalStateException: Room cannot verify the data integrity. Looks like you've changed schema but forgot to update the version number.</p></li>
			</ol>
			<p>This error<a id="_idIndexMarker497"/> message makes total sense because we've changed the schema of the database, and now Room doesn't know whether to migrate the old entries or delete them. But how did we change the schema?</p>
			<p>Well, we changed the schema when we defined a new column for the Restaurants table by adding the <strong class="source-inline">@ColumnInfo()</strong> annotation to the <strong class="source-inline">isFavorite</strong> field.</p>
			<ol>
				<li value="8">To mitigate this issue, we must increase the <strong class="source-inline">version</strong> number of the database. Inside the <strong class="source-inline">RestaurantsDb</strong> class, increase the <strong class="source-inline">version</strong> number from <strong class="source-inline">1</strong> to <strong class="source-inline">2</strong>:<p class="source-code">@Database(</p><p class="source-code">    entities = [Restaurant::class],</p><p class="source-code">    <strong class="bold">version = 2,</strong></p><p class="source-code">    exportSchema = false)</p><p class="source-code">abstract class RestaurantsDb : RoomDatabase() { .. }</p></li>
			</ol>
			<p>Now, Room knows that we've changed the schema of the database. In turn, because we haven't provided a migration strategy, and instead, we've called the <strong class="source-inline">fallbackToDestructiveMigration()</strong> method in the <strong class="source-inline">Room.databaseBuilder</strong> constructor when we initially instantiated the database, Room will drop the old contents and tables and provide us with a fresh start.</p>
			<ol>
				<li value="9">Try running the application online, and then mark a couple of restaurants as favorites.</li>
				<li>Disconnect your device from the internet and make sure you are now offline.</li>
				<li>Restart the application while remaining offline.</li>
			</ol>
			<p>Great news! The selections were now kept, and we can see which restaurants were previously marked as favorites! </p>
			<ol>
				<li value="12">To continue<a id="_idIndexMarker498"/> testing, while you are offline, you<a id="_idIndexMarker499"/> can try marking other restaurants as favorites.</li>
			</ol>
			<p>Then, still in offline mode, restart the app and you will notice that these new selections have also been saved.</p>
			<ol>
				<li value="13">Connect your device to the internet and run the application – while you are online.</li>
			</ol>
			<p>Oops! The restaurants that we have previously marked as favorites no longer appear as such, even though we previously cached these selections inside the Room database.</p>
			<p>Essentially, every time we open the application while being connected to the internet, we lose all the previous selections, and no restaurant is marked as favorite anymore.</p>
			<p>There are two issues in our code that are causing this! Can you think of why this is happening?</p>
			<p>In the next section, we will identify and address them. Additionally, we will make sure that Room is the single source of truth for the content of our application.</p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor229"/>Making local data the single source of truth for app content</h1>
			<p>Whenever we<a id="_idIndexMarker500"/> launch the app with the internet, all the restaurants appear as not favorites, even though we previously marked them as favorites and cached the selections in the Room database.</p>
			<p>To identify the issue, let's navigate back inside <strong class="source-inline">RestaurantsViewModel</strong> and inspect the <strong class="source-inline">getAllRestaurants()</strong> method:</p>
			<p class="source-code">private suspend fun getAllRestaurants(): List&lt;Restaurant&gt; {</p>
			<p class="source-code">    return withContext(Dispatchers.IO) {</p>
			<p class="source-code"><strong class="bold">        try {</strong></p>
			<p class="source-code">            val restaurants = restInterface.getRestaurants()</p>
			<p class="source-code">            restaurantsDao.addAll(restaurants)</p>
			<p class="source-code">            return@withContext restaurants</p>
			<p class="source-code"><strong class="bold">        } catch (e: Exception) {</strong></p>
			<p class="source-code"><strong class="bold">            when (e) {</strong></p>
			<p class="source-code"><strong class="bold">                is UnknownHostException, […] -&gt; {</strong></p>
			<p class="source-code"><strong class="bold">                    return@withContext restaurantsDao.getAll()</strong></p>
			<p class="source-code"><strong class="bold">                }</strong></p>
			<p class="source-code"><strong class="bold">                else -&gt; throw e</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">        }</strong></p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Now, when we launch the app while online, we do three things:</p>
			<ul>
				<li>We load the restaurants from the server by calling <strong class="source-inline">restInterface.getRestaurants()</strong>. For these restaurants, we don't receive the <strong class="source-inline">isFavorite</strong> flag, so we automatically have it set to <strong class="source-inline">false</strong>. This happens because our <strong class="source-inline">Restaurant</strong> class defaults the value of <strong class="source-inline">isFavorite</strong> to false if no value is passed from the Gson deserialization:<p class="source-code">@Entity(tableName = "restaurants")</p><p class="source-code">data class Restaurant(</p><p class="source-code">    …</p><p class="source-code">    @ColumnInfo(name = "is_favorite")</p><p class="source-code">    val isFavorite: Boolean = false)</p></li>
				<li>Then, we <a id="_idIndexMarker501"/>save those restaurants to Room by calling <strong class="source-inline">restaurantsDao.addAll(restaurants)</strong>. However, because we've used the <strong class="source-inline">REPLACE</strong> strategy inside our DAO's <strong class="source-inline">addAll()</strong> function, and because we received the same restaurants from the server, we override the <strong class="source-inline">isFavorite</strong> flags of the corresponding restaurants inside the database to <strong class="source-inline">false</strong>. So, even though our restaurants in Room might have had the <strong class="source-inline">isFavorite</strong> flag set to <strong class="source-inline">true</strong>, because we receive restaurants with the same <strong class="source-inline">id</strong> fields from the server, we end up overriding all those values to <strong class="source-inline">false</strong>.</li>
				<li>Next, we pass the <strong class="source-inline">restaurants</strong> list that we've received from the server to the UI. As we already know, these restaurants have the <strong class="source-inline">isFavorite</strong> field's value of <strong class="source-inline">false</strong>. So, anytime we start the app while connected to the internet, we will always see no restaurants marked as favorites.</li>
			</ul>
			<p>If we think about it, there are two main issues here:</p>
			<ul>
				<li>Our application has two sources of truth:<ul><li>When online, it displays the restaurants from the remote server.</li><li>When offline, it displays the restaurants from the local database.</li></ul></li>
				<li>Whenever we cache restaurants that already exist inside the local database, we override their <strong class="source-inline">isFavorite</strong> flag to <strong class="source-inline">false</strong>.</li>
			</ul>
			<p>If we can fix these two issues by having our UI receive content from a single source of data, we will also be able to remove the need for <strong class="source-inline">SavedStateHandle</strong> and all the special handling related to process recreation – we will see why in a moment.</p>
			<p>Essentially, in <a id="_idIndexMarker502"/>this section, we will be doing the following:</p>
			<ul>
				<li>Refactoring the Restaurants app to have a single source of truth for data</li>
				<li>Removing the logic of persisting state inside <strong class="source-inline">SavedStateHandle</strong> in the case of process recreation</li>
			</ul>
			<p>So, let's begin with the first issue at hand!</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor230"/>Refactoring the Restaurants app to have a single source of truth for data</h2>
			<p>The<a id="_idIndexMarker503"/> approach of having multiple sources of data can lead to many inconsistencies and subtle bugs – just like how our app is now inconsistent in terms of what data it displays when the user is either online or offline.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The concept of designing systems to rely on only one data source used for storing and updating content is related to a practice that is called <strong class="bold">Single Source of Truth</strong> (<strong class="bold">SSOT</strong>). Having <a id="_idIndexMarker504"/>multiple sources of truth for data that the UI consumes can lead to inconsistencies between what's expected to be shown to the UI and what is actually shown. The SSOT concept helps us to structure the data access so that only one data source is trusted to provide the app with data.</p>
			<p>Let's make sure that our application only has one source of truth, but which one should we choose?</p>
			<p>On the one hand, we cannot control the data that is being sent from our Firebase database, and we also can't update the restaurants stored inside it when the user marks one as a favorite.</p>
			<p>On the other hand, we can do that with Room! In fact, we are already doing that – every time a user marks a restaurant as a favorite or not a favorite, we're applying a partial update to that restaurant inside the local database.</p>
			<p>So, let's make <a id="_idIndexMarker505"/>the local Room database our only source of data:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/B17788_06_3.jpg" alt=""/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.3 – Data retrieval for the Restaurants app with the local database as an SSOT</p>
			<p>When the user is online, we should get the restaurants from the server, cache them into Room, and then obtain the restaurants again from Room to finally send them to the UI.</p>
			<p>Similarly, if the user is offline, we simply obtain the restaurants from Room and display them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Alternatively, instead of always asking your Room database for the most up-to-date content, you could update the DAO interface to provide you with a reactive data stream that we can observe. This way, upon every data update, you would automatically be notified with the most up-to-date content in a reactive manner, without having to manually ask for it. To achieve that, you must use special data holders provided by libraries such as Jetpack LiveData, Kotlin Flow, or RxJava. We will explore Kotlin Flow in <a href="B17788_11_ePub.xhtml#_idTextAnchor317"><em class="italic">Chapter 11</em></a>,<em class="italic"> Creating Infinite Lists with Jetpack Paging and Kotlin Flow</em>.</p>
			<p>The similarity between our two scenarios is that now, regardless of the internet connectivity of the user, our UI always displays the restaurants from inside our Room database. In other words, the local database is ou<a id="_idTextAnchor231"/>r SSOT!</p>
			<p>Let's start<a id="_idIndexMarker506"/> implementing! <a id="_idTextAnchor232"/>Perform the following steps:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">RestaurantsViewModel</strong>, refactor the <strong class="source-inline">getAllRestaurants()</strong> function to always return the restaurants from the Room database:<p class="source-code">private suspend fun getAllRestaurants(): </p><p class="source-code">     List&lt;Restaurant&gt; {</p><p class="source-code">    return withContext(Di<a id="_idTextAnchor233"/>spatchers.IO) {</p><p class="source-code">        try { … } catch (e: Exception) { […] }</p><p class="source-code">        <strong class="bold">return@withContext restaurantsDao.getAll()</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, our app tries to display the restaurants from the local database in any condition.</p>
			<ol>
				<li value="2">Now, it's time to refactor the <strong class="source-inline">try – catch</strong> block inside the <strong class="source-inline">getAllRestaurants()</strong> method! Essentially, what we want to do is to get the restaurants from the server and then cache them locally.</li>
			</ol>
			<p>Replace the contents within the <strong class="source-inline">try { }</strong> block with a new  <strong class="source-inline">refresh<a id="_idTextAnchor234"/>Cache()</strong> method:</p>
			<p class="source-code">return withContext(Dispatchers.IO) {</p>
			<p class="source-code">    try {</p>
			<p class="source-code">        <strong class="bold">refreshCache()</strong></p>
			<p class="source-code">    } catch (e: Exception) { […] }</p>
			<p class="source-code">    return@withContext restaurantsDao.getAll()</p>
			<p class="source-code">}</p>
			<ol>
				<li value="3">Additionally, we want to define the <strong class="source-inline">refreshCache()</strong> function to get the restaurants from the remote server and then cache them inside the local database, thereby refreshing their contents:<p class="source-code"><strong class="bold">private suspend fun refreshCache() {</strong></p><p class="source-code"><strong class="bold">    val remoteRestaurants = restInterface<a id="_idTextAnchor235"/></strong></p><p class="source-code"><strong class="bold">        .getRestaurants()</strong></p><p class="source-code"><strong class="bold">    restaurantsDao.addAll(remoteRestaurants)</strong></p><p class="source-code"><strong class="bold">}</strong></p></li>
				<li>We know<a id="_idIndexMarker507"/> that if the refresh of the cache fails, we will still show the local restaurants from Room. But what if the local database is empty?</li>
			</ol>
			<p>Continue refactoring the <strong class="source-inline">getAllRestaurants()</strong> method by updating its <strong class="source-inline">catch</strong> block. You can do this by removing the <strong class="source-inline">return@withContext restaurantsDao.getAll()</strong> call (which is now redundant) from the <strong class="source-inline">is UnknownHostException, is ConnectException, is HttpException </strong>branch and by replacing it with the following code:</p>
			<p class="source-code">try { … } catch (e: Exception) {</p>
			<p class="source-code">    when (e) {</p>
			<p class="source-code">        is UnknownHostException, is ConnectException,</p>
			<p class="source-code">        is HttpException -&gt; {</p>
			<p class="source-code"><strong class="bold">            if (restaurantsDao.getAll().isEmpty())</strong></p>
			<p class="source-code"><strong class="bold">                throw Exception(</strong></p>
			<p class="source-code"><strong class="bold">                    "Something went wrong. " +</strong></p>
			<p class="source-code"><strong class="bold">                            "We have no data.")</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">        else -&gt; throw e</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Essentially, if a network exception has been thrown, we can check whether we have any local restaurants saved in the Room database:</p>
			<ul>
				<li>If the<a id="_idIndexMarker508"/> list is empty, we return from the parent method early by throwing a custom exception to inform the user that we have no data to display. </li>
				<li>However, if the local database has elements, we do nothing and let the <strong class="source-inline">getAllRestaurants()</strong> method return the cached restaurants to the UI.</li>
			</ul>
			<p>Now, inside the <strong class="source-inline">toggleFavorite()</strong> function of <strong class="source-inline">ViewModel</strong>, whenever we toggle a restaurant as a favorite or not, we can observe that we're updating the Room database with a partial update. However, we're not fetching the restaurants again from Room and so the UI is never informed of this change:</p>
			<p class="source-code">fun toggleFavorite(id: Int) {</p>
			<p class="source-code">    …</p>
			<p class="source-code">    restaurants[itemIndex] = item.copy(isFavorite =</p>
			<p class="source-code">        !item.isFavorite)</p>
			<p class="source-code">    storeSelection(restaurants[itemIndex])</p>
			<p class="source-code">    state.value = restaurants</p>
			<p class="source-code">    viewModel<a id="_idTextAnchor236"/>Scope.launch {</p>
			<p class="source-code">        toggleFavoriteRestaurant(id, item.isFavorite)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Instead, we're updating the <strong class="source-inline">state</strong> variable's value – so the UI receives the updated restaurants in-memory. This means that we are not conforming to the SSOT practice in which we opt to always feed the UI with restaurants from the local database. Let's fix this.</p>
			<ol>
				<li value="5">Make the <strong class="source-inline">toggleFavoriteRestaurant()</strong> function return the restaurants from our<a id="_idIndexMarker509"/> local database. You can do this by calling the <strong class="source-inline">restaurantsDao.getAll()</strong> function from inside the <strong class="source-inline">withContext()</strong> block:<p class="source-code">private suspend fun toggleFavoriteRestaurant(</p><p class="source-code">    id: Int,</p><p class="source-code">    oldValue: Boolean</p><p class="source-code">) = withContext(Dispatchers.IO) {</p><p class="source-code">        restaurantsDao.update(</p><p class="source-code">           Pa<a id="_idTextAnchor237"/>rtialRestaurant(id = id, isFavorite = </p><p class="source-code">               !oldValue))</p><p class="source-code">        <strong class="bold">restaurantsDao.getAll()</strong></p><p class="source-code">    }</p></li>
				<li>Inside the <strong class="source-inline">toggleFavorite()</strong> method, store the updated restaurants returned by the <strong class="source-inline">toggleFavoriteRestaurant()</strong> method inside an <strong class="source-inline">updatedRestaurants</strong> variable, and then move the <strong class="source-inline">state.value = restaurants</strong> line from outside the coroutine to inside it while, this time, making it receive the value stored by the <strong class="source-inline">updatedRestaurants</strong> variable:<p class="source-code">fun toggleFavorite(id: Int) {</p><p class="source-code">    val restaurants = state.value.toMutableList()</p><p class="source-code">    […]</p><p class="source-code">    storeSe<a id="_idTextAnchor238"/>lection(restaurants[itemIndex])</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        <strong class="bold">val updatedRestaurants =</strong> </p><p class="source-code">            toggleFavoriteRestaurant(id, item.isFavorite)</p><p class="source-code">        <strong class="bold">state.value = updatedRestaurants</strong></p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we have<a id="_idIndexMarker510"/> not updated the <strong class="source-inline">state</strong> object value with the <strong class="source-inline">restaurants</strong> value from the previous state value. Instead, we passed the restaurants from the local database, which were obtained from the <strong class="source-inline">toggleFavoriteRestaurant()</strong> function.</p>
			<p>Now that we have made our local database the single source of truth for data, we might assume that our issues have been solved. However, remember that we are still overriding the <strong class="source-inline">isFavorite</strong> field values of the local restaurants whenever we cache restaurants with the same IDs from the server.</p>
			<p>That's why the final problem lies in the <strong class="source-inline">refreshCache()</strong> method:</p>
			<p class="source-code">private suspend fun refreshCache() {</p>
			<p class="source-code">    val remoteRestaurants = restInterface</p>
			<p class="source-code">        .getRestaurants()</p>
			<p class="source-code">    restaurantsDao.addAll(remoteRestaurants)</p>
			<p class="source-code">}</p>
			<p>We must find a way to preserve the <strong class="source-inline">isFavorite</strong> field of the restaurants whenever we call <strong class="source-inline">restaurantsDao.addAll(remoteRestaurants)</strong>.</p>
			<p>We can fix this issue by complicating the logic that is happening inside the <strong class="source-inline">refreshCache()</strong> function.</p>
			<ol>
				<li value="7">Inside the <strong class="source-inline">refreshCache()</strong> function, add the following code:<p class="source-code">private suspend fun refreshCache()<a id="_idTextAnchor239"/> {</p><p class="source-code">    val remoteRestaurants = restInterface</p><p class="source-code">        .getRestaurants()</p><p class="source-code">    <strong class="bold">val favoriteRestaurants = restaurantsDao<a id="_idTextAnchor240"/></strong></p><p class="source-code"><strong class="bold">        .getAllFavorited()</strong></p><p class="source-code">    restaurantsDao.addAll(remoteRestaurants)</p><p class="source-code"><strong class="bold">    restaurantsDao.updateAll(</strong></p><p class="source-code"><strong class="bold">        favoriteRestaurants.map {</strong></p><p class="source-code"><strong class="bold">            PartialRestaurant(it.id, true)</strong></p><p class="source-code"><strong class="bold">        })</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>Now, let's break down what we've just done:</p>
			<p>i.	First, just as<a id="_idIndexMarker511"/> before, we got the restaurants from the server (which will all have the <strong class="source-inline">isFavorite</strong> fields set to <strong class="source-inline">false</strong> as their default values) by calling <strong class="source-inline">restInterface.getRestaurants()</strong>.</p>
			<p>ii.	Then, from Room, we obtained all the restaurants that were favorited by calling <strong class="source-inline">restaurantsDao.getAllFavorited()</strong> – we haven't added this function yet so don't worry if your code doesn't compile yet.</p>
			<p>iii.	Next, just as before, we saved the remote restaurants in Room by calling <strong class="source-inline">restaurantsDao.addAll(remoteRestaurants)</strong>. With this, we override the <strong class="source-inline">isFavorite</strong> field (to <strong class="source-inline">false</strong>) of the existing restaurants that have the same ID as <strong class="source-inline">remoteRestaurants</strong>.</p>
			<p>iv.	Finally, we partially updated all the restaurants within Room by calling <strong class="source-inline">restaurantsDao.updateAll()</strong>. To this method (which we have yet to implement), we are passing a list of <strong class="source-inline">PartialRestaurant</strong> objects.</p>
			<p>These objects resulted from mapping the previously cached <strong class="source-inline">favoriteRestaurants</strong> objects of type <strong class="source-inline">Restaurant</strong> to objects of type <strong class="source-inline">PartialRestaurant</strong>, which have their <strong class="source-inline">isFavorite</strong> fields set to <strong class="source-inline">true</strong>. With this approach, we have now restored the <strong class="source-inline">isFavorite</strong> field's value for those favorited <a id="_idIndexMarker512"/>restaurants that were initially cached.</p>
			<ol>
				<li value="8">Inside <strong class="source-inline">RestaurantsDao</strong>, we must implement the two methods used earlier:<p class="source-code">@Dao</p><p class="source-code">interface RestaurantsDao {</p><p class="source-code">    […]</p><p class="source-code"><strong class="bold">    @Update(entity = Restaurant::class)</strong></p><p class="source-code"><strong class="bold">    suspend fun updateAll(partialRestaurants: </strong></p><p class="source-code"><strong class="bold">        List&lt;PartialRestaurant&gt;<a id="_idTextAnchor241"/>)</strong></p><p class="source-code"><strong class="bold">    @Query("SELECT * FROM restaurants WHERE </strong></p><p class="source-code"><strong class="bold">        is_favorite = 1")</strong></p><p class="source-code"><strong class="bold">    suspend fun getAllFavorited(): List&lt;Restaurant&gt;</strong></p><p class="source-code">}</p></li>
			</ol>
			<p>We have added the following:</p>
			<ul>
				<li>The <strong class="source-inline">updateAll()</strong> method: This is a partial update that works in the same way as the <strong class="source-inline">update()</strong> method. Here, the only difference is that we update the <strong class="source-inline">isFavorite</strong> field for a list of restaurants instead of only one.</li>
				<li>The <strong class="source-inline">getAllFavorited()</strong> method: This is a query just like the <strong class="source-inline">getAll()</strong> method but more specific, as it obtains all the restaurants that have their <strong class="source-inline">isFavorite</strong> field values equal to <strong class="source-inline">1</strong> (which stands for <strong class="source-inline">true</strong>).</li>
			</ul>
			<p>We are finally done! It's time to test out the app!</p>
			<ol>
				<li value="9">Try running the application offline and then mark a couple of restaurants as favorites.</li>
				<li>Connect <a id="_idIndexMarker513"/>your device to the internet and run the application – while you are online.</li>
			</ol>
			<p>You should now be able to see the previous selections – all the restaurants that were originally marked as favorites are now persisted across any scenario.</p>
			<p>However, we have one more thing to address!</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor242"/>Removing the logic of persisting state in the case of process recreation </h2>
			<p>Now our <a id="_idIndexMarker514"/>application has a single source of truth, that is, the local database:</p>
			<ul>
				<li>Whenever we receive restaurants from the server, we cache them to Room and then refresh the UI with the restaurants from Room.</li>
				<li>Whenever we mark a restaurant as a favorite or not, we cache the selection to Room, and similarly, we then refresh the UI with restaurants from Room.</li>
			</ul>
			<p>This means that if a system-initiated process death occurs, we should be able to restore the UI state easily because, now, the restaurants in Room also have the <strong class="source-inline">isFavorite</strong> field cached.</p>
			<p>In other words, our app no longer needs to rely on <strong class="source-inline">SavedStateHandle</strong> to restore the restaurants that have been favorited or not; the local source of data for our application will now handle this automatically.</p>
			<p>Let's remove our special handling for a system<a id="_idTextAnchor243"/>-initiated process death:</p>
			<ol>
				<li value="1">Inside <strong class="source-inline">RestaurantsViewModel</strong>, remove the <strong class="source-inline">stateHandle: SavedStateHandle</strong> parameter:<p class="source-code">class <strong class="bold">Rest<a id="_idTextAnchor244"/>aurantsViewModel()</strong> : ViewModel() { … }</p></li>
				<li>Inside <strong class="source-inline">RestaurantsViewModel</strong>, remove the <strong class="source-inline">storeSelection()</strong> and the <strong class="source-inline">restoreSelections()</strong> methods.</li>
				<li>Remove the <strong class="source-inline">companion object</strong> of the <strong class="source-inline">RestaurantsViewModel</strong> class.</li>
				<li>While you are still inside <strong class="source-inline">ViewModel</strong>, remove all the logic related to the <strong class="source-inline">stateHandle</strong> variable from within the <strong class="source-inline">toggleFavorite()</strong> method. The method should now look like this:<p class="source-code">fun toggleFavorite(id: Int) {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val updatedRestaurants =</p><p class="source-code">            toggleFavoriteRestaurant(id, item.isFavorite)</p><p class="source-code">        state.value = updatedRestaurants</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>The issue<a id="_idIndexMarker515"/> is that we no longer have the <strong class="source-inline">item</strong> variable, so we don't know what to pass to the <strong class="source-inline">toggleFavoriteRestaurant()</strong> function's <strong class="source-inline">oldValue</strong> parameter instead of <strong class="source-inline">item.isFavorite</strong>. We need to fix this.</p>
			<ol>
				<li value="5">Add a new paramet<a id="_idTextAnchor245"/>er to the <strong class="source-inline">toggleFavorite()</strong> method, called <strong class="source-inline">oldValue</strong>:<p class="source-code">fun toggleFavorite(id: Int, <strong class="bold">oldValue: Boolean</strong>) {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        val updatedRestaurants =</p><p class="source-code">            toggleFavoriteRestaurant(id, <strong class="bold">oldValue</strong>)</p><p class="source-code">        state.value = updatedRestaurants</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This <strong class="source-inline">Boolean</strong> argument should tell us whether the restaurant was previously marked as favorite or not.</p>
			<ol>
				<li value="6">Following this, refactor the <strong class="source-inline">getRestaurants()</strong> method to no longer use the <strong class="source-inline">restoreSelections()</strong> method. The method should now look like this:<p class="source-code">private fun getRestaurants() {</p><p class="source-code">    viewModelScope.launch(errorHandler) {</p><p class="source-code">        state.value = getAllRestaurants()</p><p class="source-code">    }</p><p class="source-code">}</p></li>
				<li>Next, navigate<a id="_idIndexMarker516"/> to the <strong class="source-inline">RestaurantsScreen</strong> file. Then, inside the <strong class="source-inline">RestaurantItem</strong> composable, add another <strong class="source-inline">oldValue</strong> parameter to the <strong class="source-inline">onFavoriteClick</strong> callback <a id="_idTextAnchor246"/>function:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantItem([…],</p><p class="source-code">        onFavoriteClick: (id: Int, <strong class="bold">oldValue: Boolean</strong>)</p><p class="source-code">            -&gt; Unit,</p><p class="source-code">        onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    ...</p><p class="source-code">    Card(…) {</p><p class="source-code">        Row(…) {</p><p class="source-code">            [...]</p><p class="source-code">            RestaurantDetails(...)</p><p class="source-code">            RestaurantIcon(icon, Modifier.weight(0.15f)) </p><p class="source-code">            {</p><p class="source-code">                onFavoriteClick(item.id, <strong class="bold">item.isFavorite</strong>)</p><p class="source-code">            }</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>Also, make sure that you pass the <strong class="source-inline">item.isFavorite</strong> value to the newly added parameter when the <strong class="source-inline">onFavoriteClick</strong> function is called.</p>
			<ol>
				<li value="8">Inside the <strong class="source-inline">RestaurantsScreen()</strong> composable, make sure you register and then pass the newly<a id="_idIndexMarker517"/> received <strong class="source-inline">oldValue</strong> function parameter to the <strong class="source-inline">toggleFavorite</strong> method of <strong class="source-inline">ViewModel</strong>:<p class="source-code">@Composable</p><p class="source-code">fun RestaurantsScreen(onItemClick: (id: Int) -&gt; Unit) {</p><p class="source-code">    val viewModel: RestaurantsViewModel = viewModel()</p><p class="source-code">    LazyColumn(…) {</p><p class="source-code">        items(viewModel.state.value) { restaurant <a id="_idTextAnchor247"/>-&gt;</p><p class="source-code">            RestaurantItem(</p><p class="source-code">                restaurant,</p><p class="source-code">                onFavoriteClick = { id, <strong class="bold">oldValue</strong> -&gt;</p><p class="source-code">                    viewModel</p><p class="source-code">                        .toggleFavorite(id, <strong class="bold">oldValue</strong>)</p><p class="source-code">                },</p><p class="source-code">                onItemClick = { id -&gt; onItemClick(id) })</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>We're done! Now it's time to simulate the system-initiated process death scenario.</p>
			<ol>
				<li value="9">Build the project and run the application. </li>
				<li>Mark some restaurants as favorites.</li>
				<li>Place the app in the background by pressing the home button on the device/emulator.</li>
				<li>Select the <strong class="bold">Logcat</strong> window and then press the red rectangular button on the left-hand side<a id="_idIndexMarker518"/> to terminate the application:</li>
			</ol>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/B17788_06_4.jpg" alt="Figure 6.4 – Simulating a system-initiated process death&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.4 – Simulating a system-initiated process death</p>
			<ol>
				<li value="13">Relaunch the application from the application drawer.</li>
			</ol>
			<p>Because the app relies on the content saved in the local database, it should now correctly display the UI state with the previously favorited restaurants from before the system-initiated process death.</p>
			<p class="callout-heading">Assignment</p>
			<p class="callout">In this chapter, we made sure to cache the restaurants in Room so that the first screen of the application could be accessed without the internet. As a homework assignment, you can try to refactor the details screen of the application (where the details of a specific restaurant are displayed) to obtain its own data from Room if the user enters the app without the internet.</p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor248"/>Summary</h1>
			<p>In this chapter, we gained an understanding of how Room is an essential Jetpack library because it allows us to offer offline capabilities to our applications.</p>
			<p>First, we explored the core elements of Room to see how a private database is set up. Second, we implemented Room inside our Restaurants application and explored how to save and retrieve cached content from the local database.</p>
			<p>Afterward, we discovered what partial updates are and how to implement them to preserve a user's selections within the app.</p>
			<p>Toward the end of the chapter, we understood why having a single source of truth for the application's content is beneficial and how that helps us in edge cases such as a system-initiated process death.</p>
			<p>In the next chapter, we're going to dive deeper into various ways of defining the architecture of our applications by exploring architectural presentation patterns.</p>
		</div>
	</body></html>