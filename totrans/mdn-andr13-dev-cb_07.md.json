["```kt\n    implementation \"androidx.work:work-runtime-ktx:\n    ```", "```kt\n    version-number\"\n    ```", "```kt\n    private fun createCustomNotificationChannel() {\n    ```", "```kt\n        if (Build.VERSION.SDK_INT >=\n    ```", "```kt\n        Build.VERSION_CODES.O) {\n    ```", "```kt\n            val name = getString(\n    ```", "```kt\n                R.string.notification_channel)\n    ```", "```kt\n            val notificationDescription = getString(\n    ```", "```kt\n                R.string.notification_description)\n    ```", "```kt\n            val importance =\n    ```", "```kt\n                NotificationManager.IMPORTANCE_DEFAULT\n    ```", "```kt\n            val channel = NotificationChannel(CHANNEL_ID,\n    ```", "```kt\n            name, importance).apply {\n    ```", "```kt\n    description = notificationDescription\n    ```", "```kt\n            }\n    ```", "```kt\n            // Register the channel with the system\n    ```", "```kt\n            val notificationManager: NotificationManager =\n    ```", "```kt\n                getSystemService(\n    ```", "```kt\n                    Context.NOTIFICATION_SERVICE) as\n    ```", "```kt\n                        NotificationManager\n    ```", "```kt\n            notificationManager.createNotificationChannel(\n    ```", "```kt\n                channel)\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    val workManagerInstance = WorkManager.getInstance(application.applicationContext)\n    ```", "```kt\n    val ourConstraints = Constraints.Builder()\n    ```", "```kt\n        .setRequiredNetworkType(NetworkType.CONNECTED)\n    ```", "```kt\n        .setRequiresBatteryNotLow(false)\n    ```", "```kt\n        .build()\n    ```", "```kt\n    val data = Data.Builder()\n    ```", "```kt\n    data.putString(ENDPOINT_REQUEST, endPoint)\n    ```", "```kt\n    val job =\n    ```", "```kt\n        PeriodicWorkRequestBuilder<GetDataWorker>(20,\n    ```", "```kt\n            TimeUnit.MINUTES)\n    ```", "```kt\n        .setConstraints(ourConstraints)\n    ```", "```kt\n        .setInputData(data.build())\n    ```", "```kt\n        .build()\n    ```", "```kt\n    workManagerInstance\n    ```", "```kt\n        .enqueue(work)\n    ```", "```kt\n    @HiltWorker\n    ```", "```kt\n    class GetDataWorker @AssistedInject constructor(\n    ```", "```kt\n        @Assisted context: Context,\n    ```", "```kt\n        @Assisted workerParameters: WorkerParameters,\n    ```", "```kt\n        private val viewModel: NotificationViewModel\n    ```", "```kt\n    ) : CoroutineWorker(context, workerParameters) {\n    ```", "```kt\n        override suspend fun doWork(): Result {\n    ```", "```kt\n            val ourEndPoint = inputData.getString(\n    ```", "```kt\n                NotificationConstants.ENDPOINT_REQUEST)\n    ```", "```kt\n            if (endPoint != null) {\n    ```", "```kt\n                getData(endPoint)\n    ```", "```kt\n            }\n    ```", "```kt\n            val dataToOutput = Data.Builder()\n    ```", "```kt\n                .putString(\n    ```", "```kt\n                  NotificationConstants.NOTIFICATION_DATA,\n    ```", "```kt\n                  \"Data\")\n    ```", "```kt\n                .build()\n    ```", "```kt\n            return Result.success(dataToOutput)\n    ```", "```kt\n        }\n    ```", "```kt\n    val notificationIntent = Intent(this, NotifyUser::class.java).apply {\n    ```", "```kt\n    flags = Intent.FLAG_ACTIVITY_NEW_TASK or\n    ```", "```kt\n            Intent.FLAG_ACTIVITY_CLEAR_TASK\n    ```", "```kt\n    }\n    ```", "```kt\n    notificationIntent.putExtra(NOTIFICATION_EXTRA, true)\n    ```", "```kt\n    notificationIntent.putExtra(NOTIFICATION_ID, notificationId)\n    ```", "```kt\n    val notifyPendingIntent = PendingIntent.getActivity(\n    ```", "```kt\n        this, 0, notificationIntent,\n    ```", "```kt\n        PendingIntent.FLAG_UPDATE_CURRENT\n    ```", "```kt\n    )\n    ```", "```kt\n    val builder = NotificationCompat\n    ```", "```kt\n        .Builder(context, Channel_ID_DEFAULT)\n    ```", "```kt\n        .setSmallIcon(notificationImage)\n    ```", "```kt\n        .setContentTitle(notificationTitle)\n    ```", "```kt\n        .setContentText(notificationContent)\n    ```", "```kt\n        .setPriority(NotificationCompat.PRIORITY_HIGH)\n    ```", "```kt\n        .setContentIntent(notifyPendingIntent)\n    ```", "```kt\n        .setAutoCancel(true)\n    ```", "```kt\n    with(NotificationManagerCompat.from(context)) {\n    ```", "```kt\n        notify(notificationId, builder.build())\n    ```", "```kt\n    }\n    ```", "```kt\n    private fun verifyIntent(intent: Intent?) {\n    ```", "```kt\n        intent?.let {\n    ```", "```kt\n        if (it.hasExtra(\n    ```", "```kt\n               NotificationConstants.NOTIFICATION_EXTRA)){\n    ```", "```kt\n               it.getStringExtra(\n    ```", "```kt\n               NotificationConstants.NOTIFICATION_ID)\n    ```", "```kt\n            }\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    override fun onResume() {\n    ```", "```kt\n        super.onResume()\n    ```", "```kt\n        verifyIntent(intent)\n    ```", "```kt\n    }\n    ```", "```kt\n    Result\n    ```", "```kt\n        SUCCESS, FAILURE, RETRY\n    ```", "```kt\n    override suspend fun doWork(): Result {\n    ```", "```kt\n        val file = inputData.getString(\n    ```", "```kt\n            FileParameters.KEY_FILE_NAME) ?: \"\"\n    ```", "```kt\n        if (file.isEmpty()){\n    ```", "```kt\n            Result.failure()\n    ```", "```kt\n        }\n    ```", "```kt\n        val uri = getSavedFileUri(fileName = file,\n    ```", "```kt\n            context = context)\n    ```", "```kt\n        return if (uri != null){\n    ```", "```kt\n            Result.success(workDataOf(\n    ```", "```kt\n                FileParameters.KEY_FILE_URI to\n    ```", "```kt\n                    uri.toString()))\n    ```", "```kt\n        }else{\n    ```", "```kt\n            Result.failure()\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    when (state) {\n    ```", "```kt\n        WorkInfo.State.SUCCEEDED -> {\n    ```", "```kt\n            success(\n    ```", "```kt\n                //do something\n    ```", "```kt\n            )\n    ```", "```kt\n        }\n    ```", "```kt\n        WorkInfo.State.FAILED -> {\n    ```", "```kt\n            failed(\"Downloading failed!\")\n    ```", "```kt\n        }\n    ```", "```kt\n        WorkInfo.State.RUNNING -> {\n    ```", "```kt\n            running()\n    ```", "```kt\n        }\n    ```", "```kt\n        else -> {\n    ```", "```kt\n            failed(\"Something went wrong\")\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    WorkManager.enqueueUniqueWork()\n    ```", "```kt\n    WorkManager.enqueueUniquePeriodicWork()\n    ```", "```kt\n    WorkManager.initialize(\n    ```", "```kt\n        context,\n    ```", "```kt\n        Configuration.Builder()\n    ```", "```kt\n            .setExecutor(Executors.newFixedThreadPool(\n    ```", "```kt\n                CONSTANT_THREAD_POOL_INT))\n    ```", "```kt\n            .build())\n    ```", "```kt\n    class GetFiles(context: Context, params: WorkerParameters) : Worker(context, params) {\n    ```", "```kt\n        override fun doWork(): ListenableWorker.Result {\n    ```", "```kt\n            repeat(20) {\n    ```", "```kt\n                try {\n    ```", "```kt\n                    downloadSynchronously(\"Your Link\")\n    ```", "```kt\n                } catch (e: IOException) {\n    ```", "```kt\n                    return\n    ```", "```kt\n                        ListenableWorker.Result.failure()\n    ```", "```kt\n                }\n    ```", "```kt\n            }\n    ```", "```kt\n            return ListenableWorker.Result.success()\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n        override fun doWork(): ListenableWorker.Result {\n    ```", "```kt\n            repeat(20) {\n    ```", "```kt\n                if (isStopped) {\n    ```", "```kt\n                    break\n    ```", "```kt\n                }\n    ```", "```kt\n                try {\n    ```", "```kt\n                    downloadSynchronously(\"Your Link\")\n    ```", "```kt\n                } catch (e: IOException) {\n    ```", "```kt\n                    return\n    ```", "```kt\n                        ListenableWorker.Result.failure()\n    ```", "```kt\n                }\n    ```", "```kt\n            }\n    ```", "```kt\n            return ListenableWorker.Result.success()\n    ```", "```kt\n        }\n    ```", "```kt\n    WorkManager.getInstance(context)\n    ```", "```kt\n        .beginWith(listOf(job1, job2, job3, job4))\n    ```", "```kt\n        .then(ourCache)\n    ```", "```kt\n        .then(upload)\n    ```", "```kt\n        .enqueue()\n    ```", "```kt\n    val ourCache: OneTimeWorkRequest = OneTimeWorkRequestBuilder<GetDataWorker>()\n    ```", "```kt\n        .setInputMerger(ArrayCreatingInputMerger::class)\n    ```", "```kt\n        .setConstraints(constraints)\n    ```", "```kt\n        .build()\n    ```", "```kt\n    class YourProjectJobService : JobService() {\n    ```", "```kt\n        override fun onStartJob(job: JobParameters):\n    ```", "```kt\n        Boolean {\n    ```", "```kt\n            // perform some job\n    ```", "```kt\n            return false\n    ```", "```kt\n        }\n    ```", "```kt\n        override fun onStopJob(job: JobParameters):\n    ```", "```kt\n        Boolean {\n    ```", "```kt\n            return false\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    class YourWorker(context: Context, params: WorkerParameters) :\n    ```", "```kt\n        ListenableWorker(context, params) {\n    ```", "```kt\n        override fun startWork():\n    ```", "```kt\n        ListenableFuture<ListenableWorker.Result> {\n    ```", "```kt\n            TODO(\"Not yet implemented\")\n    ```", "```kt\n        }\n    ```", "```kt\n        override fun onStopped() {\n    ```", "```kt\n            TODO(\"Not yet implemented\")\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    val job = dispatcher.newJobBuilder()\n    ```", "```kt\n        ...\n    ```", "```kt\n        .build()\n    ```", "```kt\n    <provider\n    ```", "```kt\n        ...\n    ```", "```kt\n        tools:node=\"remove\"/>\n    ```", "```kt\n    class App() : Application(), Configuration.Provider {\n    ```", "```kt\n        override fun getWorkManagerConfiguration() =\n    ```", "```kt\n            Configuration.Builder()\n    ```", "```kt\n                .setMinimumLoggingLevel(\n    ```", "```kt\n                    android.util.Log.DEBUG)\n    ```", "```kt\n                .build()\n    ```", "```kt\n    }\n    ```", "```kt\n    androidTestImplementation(\"androidx.work:work-testing:$work_version\")\n    ```", "```kt\n    @RunWith(AndroidJUnit4::class)\n    ```", "```kt\n    class BasicInstrumentationTest {\n    ```", "```kt\n        @Before\n    ```", "```kt\n        fun setup() {\n    ```", "```kt\n            val context =\n    ```", "```kt\n                InstrumentationRegistry.getTargetContext()\n    ```", "```kt\n            val config = Configuration.Builder()\n    ```", "```kt\n                .setMinimumLoggingLevel(Log.DEBUG)\n    ```", "```kt\n                .setExecutor(SynchronousExecutor())\n    ```", "```kt\n                .build()\n    ```", "```kt\n            // Initialize WorkManager for instrumentation\n    ```", "```kt\n               tests.\n    ```", "```kt\n            WorkManagerTestInitHelper.\n    ```", "```kt\n                initializeTestWorkManager(context, config)\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    class GetDataWorker(context: Context, parameters: WorkerParameters) : Worker(context, parameters) {\n    ```", "```kt\n        override fun doWork(): Result {\n    ```", "```kt\n            return when(endpoint) {\n    ```", "```kt\n                0 -> Result.failure()\n    ```", "```kt\n                else -> Result.success(dataOutput)\n    ```", "```kt\n            }\n    ```", "```kt\n        }\n    ```", "```kt\n    }\n    ```", "```kt\n    @Test\n    ```", "```kt\n    @Throws(Exception::class)\n    ```", "```kt\n    fun testGetDataWorkerHasNoData() {\n    ```", "```kt\n        ...\n    ```", "```kt\n        val workInfo =\n    ```", "```kt\n            workManager.getWorkInfoById(request.id).get()\n    ```", "```kt\n        assertThat(workInfo.state,\n    ```", "```kt\n            `is`(WorkInfo.State.FAILED))\n    ```", "```kt\n    }\n    ```"]