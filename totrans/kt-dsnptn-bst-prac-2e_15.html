<html><head></head><body><div><p>&#13;
			<h1 id="_idParaDest-260"><a id="_idTextAnchor266"/>Assessments</h1>&#13;
			<h1 id="_idParaDest-261"><a id="_idTextAnchor267"/>Chapter 1, Getting Started with Kotlin</h1>&#13;
			<h1 id="_idParaDest-262"><a id="_idTextAnchor268"/>Question 1</h1>&#13;
			<p>What's the difference between <code>var</code> and <code>val</code> in Kotlin? </p>&#13;
			<h1 id="_idParaDest-263"><a id="_idTextAnchor269"/>Answer</h1>&#13;
			<p>The <code>val</code> keyword declares an immutable value that cannot be modified once assigned. The <code>var</code> keyword declares a mutable variable that can be assigned multiple times.</p>&#13;
			<h1 id="_idParaDest-264"><a id="_idTextAnchor270"/>Question 2</h1>&#13;
			<p>How do you extend a class in Kotlin?</p>&#13;
			<h1 id="_idParaDest-265"><a id="_idTextAnchor271"/>Answer</h1>&#13;
			<p>To extend a class, you can specify its name and constructor after a semicolon. If it's a regular class, it must be declared <code>open</code> for your code to be able to extend it.</p>&#13;
			<h1 id="_idParaDest-266"><a id="_idTextAnchor272"/>Question 3</h1>&#13;
			<p>How do you add functionality to a <code>final</code> class?</p>&#13;
			<h1 id="_idParaDest-267"><a id="_idTextAnchor273"/>Answer</h1>&#13;
			<p>To add functionality to a class that we cannot inherit from, we can use an extension function. The extension function will have access only to the class itself and to its public fields and functions.</p>&#13;
			<h1 id="_idParaDest-268"><a id="_idTextAnchor274"/>Chapter 2, Working with Creational Patterns</h1>&#13;
			<h1 id="_idParaDest-269"><a id="_idTextAnchor275"/>Question 1</h1>&#13;
			<p>Name two uses for the <code>object</code> keyword we learned about in this chapter.</p>&#13;
			<h1 id="_idParaDest-270"><a id="_idTextAnchor276"/>Answer</h1>&#13;
			<p>The <code>object</code> keyword is used to declare a singleton if it's used in a global scope or as a collection of static methods if it's used in a conjunction with the <code>companion</code> keyword inside a class.</p>&#13;
			<h1 id="_idParaDest-271"><a id="_idTextAnchor277"/>Question 2</h1>&#13;
			<p>What is the <code>apply()</code> function used for?</p>&#13;
			<h1 id="_idParaDest-272"><a id="_idTextAnchor278"/>Answer</h1>&#13;
			<p>The <code>apply()</code> function is used when we want to change the state of an object and then return it immediately.</p>&#13;
			<h1 id="_idParaDest-273"><a id="_idTextAnchor279"/>Question 3</h1>&#13;
			<p>Provide one example of a static factory method that we discussed in this chapter.</p>&#13;
			<h1 id="_idParaDest-274"><a id="_idTextAnchor280"/>Answer</h1>&#13;
			<p>The JVM <code>valueOf()</code> method on the <code>Long</code> objects is a static factory method.</p>&#13;
			<h1 id="_idParaDest-275"><a id="_idTextAnchor281"/>Chapter 3, Understanding Structural Patterns</h1>&#13;
			<h1 id="_idParaDest-276"><a id="_idTextAnchor282"/>Question 1</h1>&#13;
			<p>What differences are there between the implementations of the Decorator and Proxy design patterns?</p>&#13;
			<h1 id="_idParaDest-277"><a id="_idTextAnchor283"/>Answer</h1>&#13;
			<p>The Decorator and Proxy design patterns could be implemented in the same manner. The only difference is in their intent â€“ the Decorator design pattern adds functionality to an object, while the Proxy design pattern may change an object's functionality.</p>&#13;
			<h1 id="_idParaDest-278"><a id="_idTextAnchor284"/>Question 2</h1>&#13;
			<p>What is the main goal of the Flyweight design pattern?</p>&#13;
			<h1 id="_idParaDest-279"><a id="_idTextAnchor285"/>Answer</h1>&#13;
			<p>The goal of the Flyweight design pattern is to conserve memory by reusing the same immutable state across multiple lightweight objects.</p>&#13;
			<h1 id="_idParaDest-280"><a id="_idTextAnchor286"/>Question 3</h1>&#13;
			<p>What is the difference between the Facade and Adapter design patterns?</p>&#13;
			<h1 id="_idParaDest-281"><a id="_idTextAnchor287"/>Answer</h1>&#13;
			<p>The Facade design pattern creates a new interface to simplify working with complex code, while the Adapter design pattern allows one interface to substitute another interface.</p>&#13;
			<h1 id="_idParaDest-282"><a id="_idTextAnchor288"/>Chapter 4, Getting Familiar with Behavioral Patterns</h1>&#13;
			<h1 id="_idParaDest-283"><a id="_idTextAnchor289"/>Question 1</h1>&#13;
			<p>What's the difference between Mediator and Observer design patterns?</p>&#13;
			<h1 id="_idParaDest-284"><a id="_idTextAnchor290"/>Answer</h1>&#13;
			<p>Both serve a similar purpose. Mediator introduces tight coupling between components that may serve different purposes, while Observer operates on similar components that are loosely coupled. </p>&#13;
			<h1 id="_idParaDest-285"><a id="_idTextAnchor291"/>Question 2</h1>&#13;
			<p>What is a <strong class="bold">Domain-Specific Language</strong> (<strong class="bold">DSL</strong>)?</p>&#13;
			<h1 id="_idParaDest-286"><a id="_idTextAnchor292"/>Answer</h1>&#13;
			<p>A DSL is a language that focuses on solving problems in a specific domain. This is different from a general-purpose language, such as Kotlin, that can be applied to different domains. Kotlin encourages developers to create DSLs for their needs.</p>&#13;
			<h1 id="_idParaDest-287"><a id="_idTextAnchor293"/>Question 3</h1>&#13;
			<p>What are the benefits of using a sealed class or interface?</p>&#13;
			<h1 id="_idParaDest-288"><a id="_idTextAnchor294"/>Answer</h1>&#13;
			<p>Since all types of a sealed class are known at compile time, Kotlin compiler can verify that the <code>when</code> statement covers all cases or, in other words, is exhaustive. </p>&#13;
			<h1 id="_idParaDest-289"><a id="_idTextAnchor295"/>Chapter 5, Introducing Functional Programming</h1>&#13;
			<h1 id="_idParaDest-290"><a id="_idTextAnchor296"/>Question 1</h1>&#13;
			<p>What are higher order functions?</p>&#13;
			<h1 id="_idParaDest-291"><a id="_idTextAnchor297"/>Answer</h1>&#13;
			<p>A higher order function is any function that either receives another function as input or returns a function as output.</p>&#13;
			<h1 id="_idParaDest-292"><a id="_idTextAnchor298"/>Question 2</h1>&#13;
			<p>What is the <code>tailrec</code> keyword in Kotlin? </p>&#13;
			<h1 id="_idParaDest-293"><a id="_idTextAnchor299"/>Answer</h1>&#13;
			<p>The purpose of the <code>tailrec</code> keyword is to allow the Kotlin compiler to optimize tail recursion and avoid stack overflow.</p>&#13;
			<h1 id="_idParaDest-294"><a id="_idTextAnchor300"/>Question 3</h1>&#13;
			<p>What are pure functions? </p>&#13;
			<h1 id="_idParaDest-295"><a id="_idTextAnchor301"/>Answer</h1>&#13;
			<p>Pure functions are functions that don't have any side effects, such as I/O.</p>&#13;
			<h1 id="_idParaDest-296"><a id="_idTextAnchor302"/>Chapter 6, Threads and Coroutines</h1>&#13;
			<h1 id="_idParaDest-297"><a id="_idTextAnchor303"/>Question 1</h1>&#13;
			<p>What are the different ways to start a coroutine in Kotlin?</p>&#13;
			<h1 id="_idParaDest-298"><a id="_idTextAnchor304"/>Answer</h1>&#13;
			<p>A coroutine in Kotlin could be started with either the <code>launch()</code> or <code>async()</code> functions. The difference is that <code>async()</code> also returns a value, while <code>launch()</code> doesn't.</p>&#13;
			<h1 id="_idParaDest-299"><a id="_idTextAnchor305"/>Question 2</h1>&#13;
			<p>With structured concurrency, if one of the coroutines fails, all the siblings will be canceled as well. How can we prevent that behavior?</p>&#13;
			<h1 id="_idParaDest-300"><a id="_idTextAnchor306"/>Answer</h1>&#13;
			<p>We can prevent canceling siblings by using <code>supervisorScope</code> instead of <code>coroutineScope</code>.</p>&#13;
			<h1 id="_idParaDest-301"><a id="_idTextAnchor307"/>Question 3</h1>&#13;
			<p>What is the purpose of the <code>yield()</code> function?</p>&#13;
			<h1 id="_idParaDest-302"><a id="_idTextAnchor308"/>Answer</h1>&#13;
			<p>The <code>yield()</code> function returns a value and suspends the coroutine until it has been resumed.</p>&#13;
			<h1 id="_idParaDest-303"><a id="_idTextAnchor309"/>Chapter 7, Controlling the Data Flow</h1>&#13;
			<h1 id="_idParaDest-304"><a id="_idTextAnchor310"/>Question 1</h1>&#13;
			<p>What is the difference between higher order functions on collections and on concurrent data structures?</p>&#13;
			<h1 id="_idParaDest-305"><a id="_idTextAnchor311"/>Answer</h1>&#13;
			<p>Higher order functions on collections will process the entire collection, creating a copy of it, before proceeding to the next step. Higher order functions on concurrent data structures are reactive, processing one element after the other.</p>&#13;
			<h1 id="_idParaDest-306"><a id="_idTextAnchor312"/>Question 2</h1>&#13;
			<p>What is the difference between cold and hot streams of data?</p>&#13;
			<h1 id="_idParaDest-307"><a id="_idTextAnchor313"/>Answer</h1>&#13;
			<p>A cold stream repeats itself for each new consumer, while the hot stream will only send the available data to the new consumer from the time of subscription. </p>&#13;
			<h1 id="_idParaDest-308"><a id="_idTextAnchor314"/>Question 3</h1>&#13;
			<p>When should a conflated channel/flow be used?</p>&#13;
			<h1 id="_idParaDest-309"><a id="_idTextAnchor315"/>Answer</h1>&#13;
			<p>A conflated flow can be used in situations when the consumer is slower than the producer and some of the messages could be dropped, leaving only the most recent message for consumption.</p>&#13;
			<h1 id="_idParaDest-310"><a id="_idTextAnchor316"/>Chapter 8, Designing for Concurrency</h1>&#13;
			<h1 id="_idParaDest-311"><a id="_idTextAnchor317"/>Question 1</h1>&#13;
			<p>What does it mean when we say that the <code>select</code> expression in Kotlin is biased?</p>&#13;
			<h1 id="_idParaDest-312"><a id="_idTextAnchor318"/>Answer</h1>&#13;
			<p>A biased <code>select</code> expression means that in case of a <em class="italic">draw</em> between two channels, the first channel listed in the <code>select</code> expression will always be picked.</p>&#13;
			<h1 id="_idParaDest-313"><a id="_idTextAnchor319"/>Question 2</h1>&#13;
			<p>When should you use a mutex instead of a channel?</p>&#13;
			<h1 id="_idParaDest-314"><a id="_idTextAnchor320"/>Answer</h1>&#13;
			<p>Mutexes are used to protect a resource shared between multiple coroutines. Channels are used to pass data between coroutines.</p>&#13;
			<h1 id="_idParaDest-315"><a id="_idTextAnchor321"/>Question 3</h1>&#13;
			<p>Which of the concurrent design patterns could help you implement <strong class="bold">MapReduce</strong> or a <strong class="bold">divide and conquer</strong> algorithm efficiently?</p>&#13;
			<h1 id="_idParaDest-316"><a id="_idTextAnchor322"/>Answer</h1>&#13;
			<p>For divide and conquer algorithms, the fan-out design pattern could be used to split the data and a fan-in design pattern could be used to combine the results.</p>&#13;
			<h1 id="_idParaDest-317"><a id="_idTextAnchor323"/>Chapter 9, Idioms and Anti-Patterns</h1>&#13;
			<h1 id="_idParaDest-318"><a id="_idTextAnchor324"/>Question 1</h1>&#13;
			<p>What is the alternative to Java's <code>try</code>-with-resources in Kotlin?</p>&#13;
			<h1 id="_idParaDest-319"><a id="_idTextAnchor325"/>Answer</h1>&#13;
			<p>In Kotlin, the <code>use()</code> function works on the <code>Closeable</code> interface to make sure that resources are released after use.</p>&#13;
			<h1 id="_idParaDest-320"><a id="_idTextAnchor326"/>Question 2</h1>&#13;
			<p>What are the different options for handling nulls in Kotlin?</p>&#13;
			<h1 id="_idParaDest-321"><a id="_idTextAnchor327"/>Answer</h1>&#13;
			<p>There are multiple options to handle nulls: the Elvis operator, smart casts, and the <code>let</code> and <code>run</code> scope functions can help with that.</p>&#13;
			<h1 id="_idParaDest-322"><a id="_idTextAnchor328"/>Question 3</h1>&#13;
			<p>Which problem can be solved by reified generics?</p>&#13;
			<h1 id="_idParaDest-323"><a id="_idTextAnchor329"/>Answer</h1>&#13;
			<p>On JVM, types are erased at runtime. By inlining the generic function body into the call site, it allows preservation of the actual types used by the compiler.</p>&#13;
			<h1 id="_idParaDest-324"><a id="_idTextAnchor330"/>Chapter 10, Concurrent Microservices with Ktor</h1>&#13;
			<h1 id="_idParaDest-325"><a id="_idTextAnchor331"/>Question 1</h1>&#13;
			<p>How are the Ktor applications structured and what are their benefits?</p>&#13;
			<h1 id="_idParaDest-326"><a id="_idTextAnchor332"/>Answer</h1>&#13;
			<p>Ktor applications are divided into modules, each module being an extension function on the <code>Application</code> object. Modularizing our application allows us to test different aspects of it separately. </p>&#13;
			<h1 id="_idParaDest-327"><a id="_idTextAnchor333"/>Question 2</h1>&#13;
			<p>What are plugins in Ktor and what are they used for?</p>&#13;
			<h1 id="_idParaDest-328"><a id="_idTextAnchor334"/>Answer</h1>&#13;
			<p>Plugins are a way Ktor addresses cross-cutting concerns. They are used for serializing and deserializing requests and responses, and setting headers, and even routing itself is a plugin.</p>&#13;
			<h1 id="_idParaDest-329"><a id="_idTextAnchor335"/>Question 3</h1>&#13;
			<p>What is the main problem that the <code>Exposed</code> library solves?</p>&#13;
			<h1 id="_idParaDest-330"><a id="_idTextAnchor336"/>Answer</h1>&#13;
			<p>The <code>Exposed</code> library provides a higher-level API for working with databases. </p>&#13;
			<h1 id="_idParaDest-331"><a id="_idTextAnchor337"/>Chapter 11, Reactive Microservices with Vert.x</h1>&#13;
			<h1 id="_idParaDest-332"><a id="_idTextAnchor338"/>Question 1</h1>&#13;
			<p>What's a verticle in Vert.x?</p>&#13;
			<h1 id="_idParaDest-333"><a id="_idTextAnchor339"/>Answer</h1>&#13;
			<p>A verticle is a lightweight actor that allows us to separate our business logic into small reactive units.</p>&#13;
			<h1 id="_idParaDest-334"><a id="_idTextAnchor340"/>Question 2</h1>&#13;
			<p>What's the goal of the Event Bus in Vert.x?</p>&#13;
			<h1 id="_idParaDest-335"><a id="_idTextAnchor341"/>Answer</h1>&#13;
			<p>The Event Bus allows verticles to communicate with each other indirectly by sending and consuming messages.</p>&#13;
			<h1 id="_idParaDest-336"><a id="_idTextAnchor342"/>Question 3</h1>&#13;
			<p>Why shouldn't we block the event loop?</p>&#13;
			<h1 id="_idParaDest-337"><a id="_idTextAnchor343"/>Answer</h1>&#13;
			<p>The event loop uses a limited number of threads to process many requests concurrently. If even one of the threads is blocked, it reduces the performance of a Vert.x app.</p>&#13;
		</p>&#13;
	</div></body></html>