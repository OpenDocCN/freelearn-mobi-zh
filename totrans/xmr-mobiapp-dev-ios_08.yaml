- en: Chapter 8. Threading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: iOS is what is known as a multithreading system, and understanding how threads
    can be used within an app can be advantageous.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be covering the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A brief introduction to threading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main UI thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Daughter thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The AppDelegate class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Threading Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's discuss an easy way to learn threading.
  prefs: []
  type: TYPE_NORMAL
- en: A single-thread environment can be considered in the same way as going to your
    local college. There are a number of routes you can take, but you end up there
    at some point and the process will take a finite amount of time; you set off,
    you travel, you arrive.
  prefs: []
  type: TYPE_NORMAL
- en: A multithreaded environment needs to be thought of as the college itself with
    each thread being a student. All students start off at 9 a.m. and go until 12
    p.m. What they do in between that time may or may not interfere with each other;
    they will all be doing a task or co-operating on a task to speed up the delivery
    of an answer. Thirty different threads, all working at once and at different speeds,
    but at 12 p.m., they all manage to converge and terminate their activities with
    the jobs done. They repeat the process from 1 p.m. to 4 p.m., and again, there
    is organized chaos between those hours, but at 4 p.m. everything converges. The
    lecturer is the one controlling who does what, and in terms of the threading model,
    is the control thread. *Simple!*
  prefs: []
  type: TYPE_NORMAL
- en: In terms of iOS development, the lecturer would be classed as the UI thread;
    it is the one that can start new threads and, at the end of the day, the one where
    all information needs to be fed back.
  prefs: []
  type: TYPE_NORMAL
- en: The main UI thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name suggests, the UI thread controls the UI. It is usually the hungriest
    in terms of resources and processor time. Not everything runs on the UI thread.
    For example, if the UI calls a method and that method cannot be run on the UI
    thread (such as the SQLite example listed in [Chapter 11](../Text/part0051.html#page
    "Chapter 11. Handling Data"), *Handling Data*), then that is what will happen.
    The code is executed and the flow continues once the method has returned.
  prefs: []
  type: TYPE_NORMAL
- en: The UI thread should not be mistaken as a single task; *it's not*. A single
    task would prohibit any other application running, which we know is not the case
    (for example, you could be playing Angry Worms and still receive a text message).
  prefs: []
  type: TYPE_NORMAL
- en: '`Xamarin.iOS` allows non-UI calls to simply jump back onto the UI thread.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, if a reference to the thread can''t be found (such as being out of scope
    or in a non-UI thread class), use the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Deadlocking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something may have crossed your mind over the description of the multithreaded
    system. What happens if all the students don't come back when they should? What
    happens then? It's a good question as it's something that if you're not careful
    can hit when dealing with a multithreaded environment. It is known as a deadlock
    and, literally, it can lock the app and potentially the device (though this is
    rare). Another problem is threads overwriting the same memory location (think
    of this as two or more people talking to the lecturer at once; only one voice
    will be remembered).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, if the two threads are run within a second of each other, they
    will both have time to grab the first lock before anyone gets to the inner lock.
    Without the `Sleep()` call, one of the threads would most likely have time to
    get and release both locks before the other thread even got started.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Avoiding deadlocks for synchronized accessors
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A simple way to avoid this form of deadlock is for each holding class to have
    its own private deadlock. The problem along with its solution is described well
    on MSDN ([http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx](http://msdn.microsoft.com/en-us/library/orm-9780596516109-03-18.aspx)).
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new thread from the main UI thread
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A new thread coming from an existing thread is known as a daughter thread.
  prefs: []
  type: TYPE_NORMAL
- en: A very simple way to add a daughter thread on an iOS device is like this. I
    have first created a simple UI to show what is happening. The top label is called
    thread 1, the bottom label is called thread 2.
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a new thread from the main UI thread](img/00038.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The code also shows `InvokeOnMainThread` in action—without it the app fails:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And when run, the simulator gives the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting a new thread from the main UI thread](img/00039.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Run this a number of times and you get a number of different results. The threads
    are performing operations on the UI at different times; this shows the problem
    with threading quite well. If the UI was waiting for thread 1 to finish but thread
    2 finishes, then it's not going to know what is going on.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the code can be sanitized by using a lock.
  prefs: []
  type: TYPE_NORMAL
- en: Using locks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Be careful when using locks is probably the first thing that needs to be said.
    A lock is used to synchronize the threads and obtain a far saner output.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time when the app is run, the threads are synchronized and the result is
    always the same. Using this locking system, the app is free to use as many threads
    as it needs to get whatever done off the UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using locks](img/00040.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The AppDelegate class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It may seem odd having the `AppDelegate` class described here, but it fits.
    The `AppDelegate` class is known as a singleton class. It's used once and once
    only with everything coming from it. Consider it as the über thread; without it,
    nothing else happens.
  prefs: []
  type: TYPE_NORMAL
- en: I've given the `AppDelegate` class a more thorough handling in [Chapter 5](../Text/part0031.html#page
    "Chapter 5. UI Controls"), *UI Controls* and, after reading this chapter, you
    should have a clearer idea of its importance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Threading within an iOS application can make up for a more responsive user experience,
    but at the same time, for the developer it can be the reason for many a late nights
    trying to figure out why something is crashing at random times or just seizes
    up for no real reason. Be careful with threads, they can be both a pain and a
    pleasure.
  prefs: []
  type: TYPE_NORMAL
