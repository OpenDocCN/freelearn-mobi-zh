<html><head></head><body>
  <div class="book" title="Chapter&#xA0;10.&#xA0;Animation">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch10"/>Chapter 10. Animation</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">Animation is the illusion of <a class="calibre1" id="id834"/>movement of static (still) images. To do this, typically something has to move roughly every 1/25th of a second. The more the steps used for moving something, the smoother the motion and the easier it is to fool the brain. We've already seen <a class="calibre1" href="../Text/part0035.html#page" title="Chapter 6. Events">Chapter 6</a>, <span class="strong"><em class="calibre15">Events</em></span>, how animation can be achieved using <a class="calibre1" id="id835"/> <code class="email">UIAlertView</code>. Now we need to see how we can do this normally using the <a class="calibre1" id="id836"/> <code class="email">CoreAnimation</code> and <a class="calibre1" id="id837"/> <code class="email">CoreGraphics</code> namespaces. This is not going to be an exhaustive study but it will give you a grounding in the basics.</p>

    <p class="calibre9">In this chapter, we will be covering the following:</p>

    <div class="book">
      <ul class="itemizedlist">
        <li class="listitem">Handling bitmaps (scaling and rotation)</li>

        <li class="listitem">Freeing memory after use</li>
      </ul>
    </div>

    <div class="book" title="Handling bitmaps">
      <div class="book">
        <div class="book">
          <div class="book">
            <h1 class="title"><a class="calibre1" id="ch10lvl1sec41"/>Handling bitmaps</h1>
          </div>
        </div>
      </div>

      <p class="calibre9">A bitmap image can <a class="calibre1" id="id838"/>be created either <a class="calibre1" id="id839"/>inside or outside of an app. External bitmaps are rendered to <code class="email">UIImageView</code> as shown in the following code:</p>

      <div class="informalexample">
        <pre class="programlisting">uiImageView = UIImage.FromFile("path/tofile.ext");</pre>
      </div>

      <p class="calibre9">We can get the image in, so let's do something with it.</p>

      <div class="book" title="Scaling the image">
        <div class="book">
          <div class="book">
            <div class="book">
              <h2 class="title1"><a class="calibre1" id="ch10lvl2sec50"/>Scaling the image</h2>
            </div>
          </div>
        </div>

        <p class="calibre9">Scaling can be <a class="calibre1" id="id840"/>achieved by <a class="calibre1" id="id841"/>setting the scale factor.</p>

        <div class="informalexample">
          <pre class="programlisting">uiImageView = UIImage.FromFile("path/tofile.ext").Scale(new SizeF(float w, float h), float scaleFactor);</pre>
        </div>

        <p class="calibre9">If <code class="email">scaleFactor</code> is <a class="calibre1" id="id842"/>not specified, it is <code class="email">1.0f</code> by default.</p>

        <p class="calibre9">Therefore, you could create a kind of animation as follows:</p>

        <div class="informalexample">
          <pre class="programlisting">float w = 10f, h = 10f;
for (int i = 0; i &lt; 100; ++i) {
  uiImageView = UIImage.FromFile("path/tofile.ext").Scale(new SizeF(w, h));
  w += (float)i + 5f;
  h += (float)i + 5f;
}</pre>
        </div>

        <p class="calibre9">This gives the impression of the <a class="calibre1" id="id843"/>image <a class="calibre1" id="id844"/>growing. It's not very good, but gives you an idea. To get further than this (such as rotation), we need to start looking at <code class="email">CoreGraphics</code> and <code class="email">CoreAnimation</code>.</p>
      </div>

      <div class="book" title="Rotating the image – Part 1">
        <div class="book">
          <div class="book">
            <div class="book">
              <div class="calibre14"/>

              <h2 class="title1"><a class="calibre1" id="ch10lvl2sec51"/>Rotating the image – Part 1</h2>
            </div>
          </div>
        </div>

        <p class="calibre9">I will assume here that there is a <a class="calibre1" id="id845"/>small-enough <code class="email">UIImageView</code> widget set onto a view (say 122 x 122) in the middle of the screen. As before, the image is loaded in, <a class="calibre1" id="id846"/>but this time the <code class="email">CoreGraphics</code> image is required.</p>

        <div class="informalexample">
          <pre class="programlisting">uiImageView.Image = UIImage.FromFile("graphics/image.jpg").Scale(new SizeF(122f, 122f));
uiImageView.Transform = CGAffineTransform.MakeRotation((float)Math.PI / 15f);</pre>
        </div>

        <p class="calibre9">The image is loaded and rotated. The rotation is static (in other words, instant).</p>

        <p class="calibre9">For animation, <a class="calibre1" id="id847"/> <code class="email">CoreAnimation</code> needs to be used. However, before doing a rotation animation, let's start off on something simpler—moving something across the screen and back. To do this, let's look at some code.</p>

        <div class="informalexample">
          <pre class="programlisting">Private PointF startPoint;

public override void ViewDidLoad() {
  base.ViewDidLoad();

  uiImageView.Image = UIImage.FromFile("graphics/image.jpg").Scale(new SizeF(122f, 122f));
  startPoint = uiImageView.Center;

  UIView.BeginAnimations("moveImage");
  UIView.SetAnimationDuration(2);
  UIView.SetAnimationCurve(UIViewAnimationCurve.EaseInOut);
  UIView.SetAnimationRepeatCount(2);
  UIView.SetAnimationRepeatAutoreverses(true);
  UIView.SetAnimationDelegate(this);
  UIView.SetAnimationDidStopSelector(new Selector("moveImageStopped:"));
  uiImageView.Center = new PointF(UIScreen.MainScreen.Bounds.Right – uiImageView.Frame.Width /2, uiImageView.Center.Y);
  UIView.CommitAnimations();
}

[Export("moveImageStopped")]
private void moveImageStopped() {
  uiImageView.Center = startPoint;
}</pre>
        </div>

        <p class="calibre9">There are two important <a class="calibre1" id="id848"/>points to note about this code.</p>

        <div class="book">
          <ul class="itemizedlist">
            <li class="listitem">The code operates on <code class="email">UIView</code> rather than <code class="email">UIImageView</code></li>

            <li class="listitem">The bindings between Xamarin.iOS and the underpinning Objective-C become very visible for <a class="calibre1" id="id849"/>animation and drawing in general (the binding is the selector)</li>
          </ul>
        </div>

        <div class="book" title="Underpinning bindings">
          <div class="book">
            <div class="book">
              <div class="book">
                <h3 class="title2"><a class="calibre1" id="ch10lvl3sec103"/>Underpinning bindings</h3>
              </div>
            </div>
          </div>

          <p class="calibre9">In the preceding example, the <a class="calibre1" id="id850"/>code is creating an interface layer for the underpinning Objective-C. The compiler handles this in a slightly different manner compared to normal code. Adding this sort of <code class="email">Selector</code> code can be used in other ways as well (for example, to access private API code—though this should be avoided as it will debar apps from being accepted into the app store). It should be noted that the bindings to the Objective-C layer may sometimes cause issues with submission to the Apple store.</p>
        </div>
      </div>

      <div class="book" title="Analysis of the code">
        <div class="book">
          <div class="book">
            <div class="book">
              <h2 class="title1"><a class="calibre1" id="ch10lvl2sec52"/>Analysis of the code</h2>
            </div>
          </div>
        </div>

        <p class="calibre9">The analysis of the <a class="calibre1" id="id851"/>preceding code can be summed up as follows:</p>

        <div class="book">
          <ul class="itemizedlist">
            <li class="listitem">startPoint is the position of the image at the start.</li>

            <li class="listitem">To tell the app there is <a class="calibre1" id="id852"/>going to be an animation, <code class="email">BeginAnimations</code> needs to be called.</li>

            <li class="listitem"><code class="email">Duration</code> is the <a class="calibre1" id="id853"/>length of the animation and <code class="email">RepeatCount</code> is the number of times the animation is called.</li>

            <li class="listitem"><code class="email">RepeatAnimationCurve</code> defines <a class="calibre1" id="id854"/>how the animation is to proceed (in this case, to repeat the animation curve, a curve does not have to be an arc on a circle, it can be a straight line).</li>

            <li class="listitem"><code class="email">EaseInOut</code> starts the <a class="calibre1" id="id855"/>animation slowly and builds up and slows down.</li>

            <li class="listitem"><code class="email">EaseIn</code> starts the <a class="calibre1" id="id856"/>animation slowly.</li>

            <li class="listitem"><code class="email">EaseOut</code> slows<a class="calibre1" id="id857"/> it at the end</li>

            <li class="listitem"><code class="email">Linear</code> gives a uniform speed.</li>

            <li class="listitem">The binding resets the image to the center once the animation has ended.</li>

            <li class="listitem"><code class="email">CommitAnimations</code> sets the <a class="calibre1" id="id858"/>animation going. Xamarin.iOS provides a very good example of animation <a class="calibre1" id="id859"/>using blocks that will provide further support on this topic.</li>
          </ul>
        </div>
      </div>
    </div>
  </div>


  <div class="book" title="Freeing memory after use">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch10lvl1sec42"/>Freeing memory after use</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">Typically, once a class has <a class="calibre1" id="id860"/>gone out of scope, the <span class="strong"><strong class="calibre2">garbage collector</strong></span> (<span class="strong"><strong class="calibre2">GC</strong></span>) will free up memory used by the processes within that class. However, as Xamarin.iOS works as a <a class="calibre1" id="id861"/>binding layer to the underpinning Objective-C, there are times when freeing memory becomes important; this mostly happens when dealing with animation and graphics.</p>

    <p class="calibre9">Probably the simplest way to clean up is provided when a new View Controller is created.</p>

    <div class="informalexample">
      <pre class="programlisting">public override void DidReceiveMemoryWarning() {
  // Releases the view if it doesn't have a superview.
  base.DidReceiveMemoryWarning();
  // Release any cached data, images, etc that aren't in use.
}</pre>
    </div>

    <p class="calibre9">For example, to release <code class="email">uiImageView</code> do as follows:</p>

    <div class="informalexample">
      <pre class="programlisting">uiImageView.Release();</pre>
    </div>

    <p class="calibre9">If the code doesn't cause a memory warning, <code class="email">ViewDidDisappear()</code> can also be used to free the memory in the same way.</p>

    <p class="calibre9">Another simple method of freeing memory is to allow the GC to do its job once the code has gone out of scope. Consider the following (simplistic) code:</p>

    <div class="informalexample">
      <pre class="programlisting">private async void doSomething() {
  UIImageView image = new UIImageView(new RectangleF(0, 0, 100,100));
  string filename = await GetFileName();
  image.Image = UIImage.FromFile(filename);
  // do a lot of bits and pieces
  if (condition)
    return;
  else
    callNewMethod();
}</pre>
    </div>

    <p class="calibre9">The code executes and loads <code class="email">UIImageView</code> with the image as directed by the returned string. If <code class="email">condition</code> is met (that is, it's <code class="email">true</code>), the method returns. If <code class="email">condition</code> is not met, the method jumps to <code class="email">callNewMethod</code>. <a class="calibre1" id="id862"/>Neither of these are big issues, except that the GC does not get called until the class itself goes out of scope. So any memory occupied by the <a class="calibre1" id="id863"/> <code class="email">UIImageView</code> control is still used, despite it only being used for three lines in one class. With too many images and too many manipulations, memory soon vanishes.</p>

    <p class="calibre9">If you consider an average animation, there may be 300 images with backgrounds and so the memory is soon drained.</p>

    <p class="calibre9">A simple solution is to only create and use what you need and use code that calls the GC once it has gone out of scope. The <a class="calibre1" id="id864"/>following lines of code demonstrate how to do this:</p>

    <div class="informalexample">
      <pre class="programlisting">private async void doSomething() {
  using (UIImageView image = new UIImageView()) {
    image.Frame = new RectangleF(0, 0, 100, 100);
    string filename = await GetFileName();
    image.Image = UIImage.FromFile(filename);
  };
  // do a lot of bits and pieces
  if (condition)
    return;
  else
    callNewMethod();
}</pre>
    </div>

    <p class="calibre9">While this looks similar, the image being created is used and once completed, the memory being used is freed up again, rather than having to wait until the class goes out of scope.</p>

    <div class="book" title="Rotating the image – Part 2">
      <div class="book">
        <div class="book">
          <div class="book">
            <div class="calibre14"/>

            <h2 class="title1"><a class="calibre1" id="ch10lvl2sec53"/>Rotating the image – Part 2</h2>
          </div>
        </div>
      </div>

      <p class="calibre9">To get an image to <a class="calibre1" id="id865"/>rotate, the <code class="email">CoreGraphics</code> image has to be used followed by conversion to a <a class="calibre1" id="id866"/>bitmap. The following gives you an idea of how to do the rotation. Altering <code class="email">RotateCTM</code> and <code class="email">TranslateCTM</code> from positive to negative (and vice versa) should give different results.</p>

      <div class="informalexample">
        <pre class="programlisting">public static UIImage rotateImage(UIImage uiImage) {
  UIImage result;
  using (CGImage cgImage = uiImage.CGImage) {
    CGImageAlphaInfo alpha = cgImage.AlphaInfo;
    CGColorSpace colour = CGColorSpace.CreateDeviceRGB();
    if (alpha == CGImageAlphaInfo.None)
      alpha = CGImageAlphaInfo.NoneSkipLast;
    int width = cgImage.Width, height = cgImage.Height;
    CGBitmapContext bitmap = new CGBitmapContext(IntPtr.Zero, height,
    width, cgImage.BitsPerComponent, cgImage.BytesPerRow,colour, alpha);
    bitmap.RotateCTM((float)Math.PI / 2); // rotate right.
    bitmap.TranslateCTM(0, -height);
    bitmap.DrawImage(new Rectangle(0, 0, width, height), cgImage);
    result = UIImage.FromImage(bitmap.ToImage());
    bitmap = null; // free memory
  }
  return result;
}</pre>
      </div>
    </div>
  </div>


  <div class="book" title="Summary">
    <div class="book">
      <div class="book">
        <div class="book">
          <h1 class="title"><a class="calibre1" id="ch10lvl1sec43"/>Summary</h1>
        </div>
      </div>
    </div>

    <p class="calibre9">Animation and graphics handling is an extensive topic on iOS. While this chapter has been a whistle-stop over the subject, I would recommend you have a look at <span class="strong"><em class="calibre15">Learning MonoTouch</em></span> by <span class="strong"><em class="calibre15">Michael Bluestein</em></span>, Pearson Education, Inc. His book covers the topic in much greater detail than space allows here.</p>
  </div>
</body></html>