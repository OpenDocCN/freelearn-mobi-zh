<html><head></head><body>
        

                            
                    <h1 class="header-title">Navigating Effectively</h1>
                
            
            
                
<p>Broadly speaking, navigation is how your user gets from one screen to another in your application. More specifically, however, it's what a user needs to do in order to reach a goal within your application. Navigation is an almost completely invisible part of your application's user interface design. It's an area that is often neglected, frequently done badly, and as a result, often leads users to frustration.</p>
<p>The problem is that the navigation design of an application is often a side effect of the user interface design, rather than something that has been planned. Navigation, just like a single screen, can and should be designed to center around the user rather than the designer or developer. Using the techniques you've already learned in this book, you should be able to make almost any navigation flow work easily, because the elements should not be tightly coupled to each other.</p>
<p>In this chapter, we'll look at navigation and navigation patterns within the Material Design language. You'll learn how to do the following:</p>
<ul>
<li style="font-weight: 400">Plan and design the navigation flow of an application</li>
<li style="font-weight: 400">Use the standard navigation menu component</li>
<li style="font-weight: 400">Build tabbed navigation applications</li>
<li style="font-weight: 400">Navigate using fragments instead of Activities</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Planning navigation</h1>
                
            
            
                
<p>Before leaping into your latest app idea, it's a good idea to stop and consider what you are trying to allow the user to do, and figure out how they will actually do it. One of the best ways to do this is with the decision tree or navigation tree. These can be easily drawn on paper, or if you're collaborating with other people, index cards on a magnetic whiteboard (or even a pin-board) are very effective.</p>
<p class="mce-root">The idea is to not just draw out the possible screens in your app, but how the user will get to each one. Navigation diagrams don't just help to define what screens your application actually needs, but will help ensure that the user will never be "lost" in your application. If the navigation lines become too complex, then you need to simplify the navigation (possibly by adding or removing some of the screens). Overly complex navigation is often hidden in the use of an application, but when drawn on a diagram, the complex relationships between screens become obvious, and often, a solution will become apparent.</p>
<p class="mce-root">To start drawing your diagram, create a box or card that represents the user's main entry into the application. Then, branch from each possible action that the user might take from that screen. For each action, draw a simple icon or describe the type of action the user is expected to take. For example, a circle can represent a floating action button, three staggered lines can represent a swipe gesture, and so on. These icons will also help by ensuring that the gestures and actions on a screen remain obvious to the user, and will help you avoid navigation techniques that hide the behaviors from the user. Here's an example navigation diagram for the current state of the travel claims app:</p>
<p class="mce-root"/>
<div><img height="400" width="307" src="img/22634f22-61fc-49bf-beb8-66a457e2f70d.jpg"/></div>
<p>It's immediately apparent from the diagram that everything flows deeply into the application, and that there are currently three distinct action areas: <strong>New Item</strong>, <strong>Delete Item</strong>, and <strong>Add Attachment</strong>. Larger applications should still have these logical groupings of action areas, and should not have navigation lines that have to crossover too much of the diagram. If they do, it's a sign of an overcomplex navigation structure, and moving things around on the diagram will often help you produce a better and more intuitive application.<br/>
<br/>
Now, let's take a look at various Android components built specifically for navigation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Tabbed navigation</h1>
                
            
            
                
<p class="mce-root">When applications are broken down into a small number of logical areas, tabs often become the most obvious and simplest method of navigation. Most application's navigation is deeply hierarchical, and in these cases, tabs are not a good choice for a navigation mechanism. Tab navigation is best used when each tab will be used roughly as much as each of the other tabs (that is, they have roughly equal importance). There are two major types of tabbed layouts in Android: bottom tabs and top tabs (also known as action bar tabs or toolbar tabs).</p>
<p><strong>Top tabs</strong> are the classic method of adding tabs to an Android application, and are perfect when the application areas are not switched between often. This is because they are at the top of the screen and typically far away from where the user's fingers are. Most typically, a user has their fingers near the bottom of the screen, close to the software keyboard and system navigation buttons:</p>
<div><img height="182" width="290" src="img/627f73ff-f318-4271-8dfe-6a4ccfda6b1f.png"/></div>
<p><strong>Bottom tabs</strong>, on the other hand, are a far more subtle and challenging navigation technique to implement effectively. Bottom tabs take up significantly more vertical screen space than their top-bar cousins, and therefore need to <em>work</em> for the extra space they consume. Bottom tabs are good to implement if the user will switch between the spaces frequently and spend roughly the same amount of time in each. As they are at the bottom of the screen, they are typically more accessible to the user and therefore it's easier for them to switch between the screens they offer:</p>
<div><img height="159" width="253" src="img/777376e8-771e-40f0-a50b-17389a348828.png"/></div>
<p><br/>
With either of these tab-based navigation options, it's important to consider that the tabs should always be visible in the application and therefore your application will have several <strong>root</strong> nodes in your navigation tree (one for each tab). You should also avoid navigating the user between tabs too much, as this can be confusing. Instead, each tab should represent a distinct part of the application process, almost like a mini-app.<br/>
<br/>
The tab components provided by Android don't actually perform any of the navigation themselves; instead, it's assumed that you will encapsulate the actual navigation container and logic yourself. It's normal to use the <kbd>ViewPager</kbd> class to manage the switching between different tab screens, and a single <kbd>Fragment</kbd> for each of the tabs. Android Studio also includes some simple templates for both of these navigation patterns. Let's take a look at how you can build a simple Activity with tabs at the top:</p>
<ol>
<li style="font-weight: 400">Open the File menu, and select New | New Project.</li>
<li style="font-weight: 400">Name the new project <kbd>Navigation</kbd>.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Select an appropriate Company Domain to determine the package:</li>
</ol>
<div><img height="145" width="514" src="img/b0f08439-40dd-4f1f-9ca6-4890a06a00f6.png"/></div>
<ol start="4">
<li style="font-weight: 400">Click on the Next button.</li>
<li style="font-weight: 400">Select Phone and Tablet support, and at least API 16 lever support:</li>
</ol>
<div><img src="img/30706e16-71e5-4575-8411-c6d854e4520f.png"/></div>
<ol start="6">
<li style="font-weight: 400">Then, click Next.</li>
</ol>
<ol start="7">
<li style="font-weight: 400">In the Activity Gallery, scroll right to the bottom and select Tabbed Activity:</li>
</ol>
<div><img src="img/548e63f6-ca1b-4645-aaee-79cc397b7f97.png"/></div>
<ol start="8">
<li style="font-weight: 400">Click on the Next button.</li>
<li style="font-weight: 400">Name the new <kbd>Activity</kbd> <kbd>TopTabsActivity</kbd>.</li>
<li style="font-weight: 400">Scroll down to the bottom of the wizard to Navigation Style.</li>
<li style="font-weight: 400">Change the Navigation Style to Action Bar Tabs (with ViewPager):</li>
</ol>
<div><img height="170" width="453" src="img/07860dea-c368-45a2-8a3f-0e1dee581ae4.png"/></div>
<ol start="12">
<li style="font-weight: 400">Click Finish to complete the wizard.</li>
<li style="font-weight: 400">Wait for Android Studio to finish creating your project.</li>
</ol>
<p>If your project has compile errors in the IDE, you might need to add the support library to the new project. Open the build.gradle for app module, and add<br/>
<kbd>implementation 'com.android.support:support-v4:26.0.0'</kbd><br/>
(with the correct version number) to the <kbd>dependencies</kbd>.</p>
<ol start="14">
<li>Once the project has been created, Android Studio will have built a new <kbd>Activity</kbd> with three tabs in its <kbd>AppBarLayout</kbd>. Open the res/layout directory, and open the <kbd>activity_tob_tabs.xml</kbd> layout file to edit the number and appearance of the tabs:</li>
</ol>
<pre style="padding-left: 60px">&lt;android.support.design.widget.TabLayout<br/>    android:id="@+id/tabs"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="wrap_content"&gt;<br/><br/>    &lt;android.support.design.widget.TabItem<br/>        android:id="@+id/tabItem"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="@string/tab_text_1" /&gt;<br/><br/>    &lt;android.support.design.widget.TabItem<br/>        android:id="@+id/tabItem2"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="@string/tab_text_2" /&gt;<br/><br/>    &lt;android.support.design.widget.TabItem<br/>        android:id="@+id/tabItem3"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="@string/tab_text_3" /&gt;<br/>&lt;/android.support.design.widget.TabLayout&gt;</pre>
<p>It's best to avoid having too many tabs in any sort of tabbed layout. If you are using text labels (as the template does), you should try and avoid having more than three tabs. If you require more than three, it's best to use the Material icons and remove the text descriptions.</p>
<ol start="15">
<li style="font-weight: 400">To edit what appears in the tabs, you'll need to open the <kbd>TopTabsActivity</kbd> class.</li>
<li style="font-weight: 400">Find the <kbd>SectionsPagerAdapter</kbd> inner class at the bottom of the file.</li>
</ol>
<ol start="17">
<li style="font-weight: 400">In this class, you can create a <kbd>switch</kbd> statement in the <kbd>getItem</kbd> method to create the <kbd>Fragment</kbd> instances for each tab. For example, the "Flight Search" images used earlier might have a <kbd>getItem</kbd> implementation looking like this:</li>
</ol>
<pre style="padding-left: 60px">public Fragment getItem(final int position) {<br/>  switch (position) {<br/>    case 0:<br/>      return new FlightSearchFragment();<br/>    case 1:<br/>      return new BookingsFragment();<br/>    case 2:<br/>      return new ProfileFragment();<br/>  }<br/><br/>  throw new IndexOutOfBoundsException(<br/>      "no tab for position " + position);<br/>}</pre>
<p>Using a <kbd>switch</kbd> statement or similar structure instead of populating an array ensures that the <kbd>Fragment</kbd> objects are only allocated when they are actually needed. If the user doesn't change tabs, only one will need to be instantiated.</p>
<p>In the <kbd>TopTabsActivity</kbd>, you'll see in the <kbd>onCreate</kbd> method that Android Studio tethers the <kbd>TabLayout</kbd> in the <kbd>AppBarLayout</kbd> with the <kbd>ViewPager</kbd>, using two listener classes from the <kbd>TabLayout</kbd> class:</p>
<pre style="padding-left: 60px">mViewPager.addOnPageChangeListener(<br/>        new TabLayout.TabLayoutOnPageChangeListener(tabLayout));<br/>tabLayout.addOnTabSelectedListener(<br/>        new TabLayout.ViewPagerOnTabSelectedListener(mViewPager));</pre>
<p>These listeners will keep the selected tab in the <kbd>TabLayout</kbd> and the current <kbd>Fragment</kbd> displayed by the <kbd>ViewPager</kbd> in sync. When a tab is selected, the appropriate page will be displayed and when the <kbd>ViewPager</kbd> is swiped, the appropriate tab will be selected.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Bottom tabs navigation</h1>
                
            
            
                
<p>Using the bottom navigation tabs is quite different in code structure to placing tabs in the toolbar of the application. Where the toolbar tabs use <kbd>TabItem</kbd> widgets to render their content, the <kbd>BottomNavigationView</kbd> uses a menu to decide how it should look. A menu, much like a layout file, is a specialized XML resource file in Android. They also compacted to binary XML during compilation of the project and can be inflated at runtime using a <kbd>MenuInflator</kbd> object. Unlike a layout resource, a menu specifies lists of menu items and submenus, and while these have text descriptions and optional icons, they have no other render logic of their own. As a result, they are perfect for representing navigation options to a variety of different widgets.</p>
<p>Bottom tabs are often used to present <em>alternative</em> views--different user interfaces on top of the same data; for example, search flights, upcoming bookings, and past reservations. All of them are flights for the user, but from different perspectives.</p>
<p class="mce-root">Let's build an <kbd>Activity</kbd> to use the <kbd>BottomNavigationView</kbd> to navigate between different areas of an application:</p>
<ol>
<li style="font-weight: 400">Right-click on the main package in the Navigation project and select New | Activity | Bottom Navigation Activity.</li>
<li style="font-weight: 400">Name the new <kbd>Activity</kbd> as <kbd>BottomTabsActivity</kbd>.</li>
<li style="font-weight: 400">Click Finish to create the new structure.</li>
<li style="font-weight: 400">Android Studio will create several new files: the <kbd>Activity</kbd> class, the new layout XML file, several new icon files, and the navigation menu resource.</li>
<li style="font-weight: 400">Open the new <kbd>res/layout/activity_bottom_tabs.xml</kbd> layout resource.</li>
<li style="font-weight: 400">Ensure that the editor is in the Design mode.</li>
<li style="font-weight: 400">In the Component Tree panel, select the message (TextView) item and delete it:</li>
</ol>
<div><img height="104" width="246" src="img/6ed3671c-7b7a-4621-9b06-88ef77273c06.png"/></div>
<ol start="8">
<li>In the Palette panel, open the Containers and drag a <kbd>ViewPager</kbd> into the middle of the design canvas:</li>
</ol>
<div><img height="233" width="249" src="img/6ae6e009-403d-4db7-a605-6d70506b1eff.png"/></div>
<ol start="9">
<li>Using the Attributes panel, add constraints to all sides of the new <kbd>ViewPager</kbd> and make them <kbd>0</kbd>:</li>
</ol>
<div><img src="img/832dfa61-6554-4616-afef-b14318682677.png"/></div>
<ol start="10">
<li style="font-weight: 400">Change the layout_width and layout_height attributes to match_constraint.</li>
<li style="font-weight: 400">Change the ID of the <kbd>ViewPager</kbd> widget to <kbd>container</kbd>.</li>
</ol>
<ol start="12">
<li style="font-weight: 400">Right-click on the res/drawable directory in the project view, and select New | Vector Asset.</li>
<li style="font-weight: 400">Use the Icon selector to find the standard <kbd>search</kbd> icon, and leave the name as is (<kbd>ic_search_black_24dp</kbd>).</li>
<li style="font-weight: 400">Select Next, and then Finish to import the icon into your project.</li>
<li style="font-weight: 400">Import the <kbd>flight takeoff</kbd> and <kbd>bookmark</kbd> icons in the same way.</li>
<li style="font-weight: 400">Open the res/menu/navigation.xml menu resource file. In the Design view, you should be presented with a menu editor, looking like this:</li>
</ol>
<div><img height="169" width="299" src="img/8891eda9-9224-478b-9adf-f113b124421b.png"/></div>
<ol start="17">
<li style="font-weight: 400">Select the Home menu item by clicking on it in the Design canvas.</li>
<li style="font-weight: 400">In the Attributes panel, change the item's ID to <kbd>navigation_search</kbd>.</li>
<li style="font-weight: 400">Use the string resource editor to change the title attribute to a new string resource called <kbd>title_search</kbd>, with the content <kbd>Search</kbd>.</li>
<li style="font-weight: 400">Use the icon resource selector to change the icon to the <kbd>ic_search_black_24dp</kbd> icon you imported.</li>
<li style="font-weight: 400">Select the Dashboard menu item in the Design canvas.</li>
<li style="font-weight: 400">Change the ID attribute in the Attributes panel to <kbd>navigation_upcoming</kbd>.</li>
<li style="font-weight: 400">Use the string resource editor to change the title attribute to a new string resource called <kbd>title_upcoming</kbd>, with the content <kbd>Upcoming Flights</kbd>.</li>
<li style="font-weight: 400">Use the icon resource selector to change the icon to the <kbd>ic_flight_takeoff_black_24dp</kbd> icon you imported.</li>
<li style="font-weight: 400">Select the Notifications menu item in the Design canvas.</li>
<li style="font-weight: 400">Change the ID attribute in the Attributes panel to <kbd>navigation_flown</kbd>.</li>
<li style="font-weight: 400">Use the string resource editor to change the title attribute to a new string resource called <kbd>title_flown</kbd>, with the content <kbd>Past Bookings</kbd>.</li>
</ol>
<ol start="28">
<li style="font-weight: 400">Use the icon resource selector to change the icon to the <kbd>ic_bookmark_black_24dp</kbd> icon you imported.</li>
<li style="font-weight: 400">Now, open the <kbd>BottomTabsActivity</kbd> source file.</li>
<li style="font-weight: 400">Remove the reference to the <kbd>TextView</kbd>, and replace it with a reference to the <kbd>ViewPager</kbd> and <kbd>BottomNavigationView</kbd>:</li>
</ol>
<pre style="padding-left: 60px"><strong>private TextView mTextMessage; // remove this line</strong><br/>private ViewPager container;<br/>private BottomNavigationView navigation;</pre>
<ol start="31">
<li>The <kbd>BottomNavigationView</kbd> (unlike the <kbd>TabLayout</kbd> used for top tabs) includes no listeners to automatically map between the selected tab and a <kbd>ViewPager</kbd>, so you'll need to map the <kbd>MenuItem</kbd> ID values to the index of the pages that should be displayed. Create an <kbd>int</kbd> array with the <kbd>MenuItem</kbd> ID values in the same order as the pages:</li>
</ol>
<pre style="padding-left: 60px">private final int[] pageIds = new int[]{<br/>        R.id.navigation_search,<br/>        R.id.navigation_upcoming,<br/>        R.id.navigation_flown<br/>};</pre>
<ol start="32">
<li>The template created a <kbd>BottomNavigationView.OnNavigationItemSelectedListener</kbd> anonymous inner class to display the name of the selected tab in the <kbd>TextView</kbd>. You instead want the <kbd>ViewPager</kbd> to change to the selected tab <kbd>Fragment</kbd>, and you can do this using the array of ID values you just declared:</li>
</ol>
<pre style="padding-left: 60px">private BottomNavigationView.OnNavigationItemSelectedListener onNavigationItemSelectedListener<br/>        = new BottomNavigationView.OnNavigationItemSelectedListener() {<br/><br/>    public boolean onNavigationItemSelected(final MenuItem item) {<br/>        for (int i = 0; i &lt; pageIds.length; i++) {<br/>            if (pageIds[i] == item.getItemId()) {<br/>                container.setCurrentItem(i);<br/>                return true;<br/>            }<br/>        }<br/><br/>        return false;<br/>    }<br/>};</pre>
<ol start="33">
<li>You'll also need a listener for when the user swipes between the tabs on the <kbd>ViewPager</kbd>, so that the <kbd>BottomNavigationView</kbd> also highlights the correct tab:</li>
</ol>
<pre style="padding-left: 60px">private ViewPager.OnPageChangeListener onPageChangeListener =<br/>        new ViewPager.SimpleOnPageChangeListener() {<br/>            public void onPageSelected(final int position) {<br/>                navigation.setSelectedItemId(pageIds[position]);<br/>            }<br/>        };</pre>
<ol start="34">
<li>In the <kbd>onCreate</kbd> method, remove the assignment to the <kbd>TextView</kbd>, and assign the new <kbd>ViewPager</kbd> field:</li>
</ol>
<pre style="padding-left: 60px"><strong>mTextMessage = findViewById(R.id.message); // remove this line</strong><br/>container = findViewById(R.id.container);</pre>
<ol start="35">
<li>Change the <kbd>BottomNavigationView</kbd> assignment and listeners to assign to the field in your <kbd>Activity</kbd>, and then correctly assign both the listeners:</li>
</ol>
<pre style="padding-left: 60px">navigation = findViewById(R.id.navigation);<br/>navigation.setOnNavigationItemSelectedListener(<br/>    onNavigationItemSelectedListener);<br/>container.addOnPageChangeListener(onPageChangeListener);</pre>
<ol start="36">
<li>You can now assign a <kbd>ViewPagerAdapter</kbd> to the <kbd>ViewPager</kbd> with three tabs (such as the <kbd>SectionsPagerAdapter</kbd> generated in the <kbd>TopTabsActivity</kbd>):</li>
</ol>
<pre style="padding-left: 60px">container.setAdapter(<br/>    new SectionsPagerAdapter(getSupportFragmentManager()));</pre>
<p>If the preceding line complains about <kbd>TopTabsActivity</kbd> not being an enclosing class, then change the <kbd>SectionsPagerAdapter</kbd> to be a static inner class--<kbd>public static class SectionsPagerAdapter extends FragmentPagerAdapter</kbd>.</p>
<p>The listeners in this example can be reused in any number of applications that require bottom-tabbed navigation. The only thing you'll need to change is the list of <kbd>pageIds</kbd> that are displayed to the user. You should avoid having more than three or four tabs in the <kbd>BottomNavigationView</kbd>; it normally implies that another form of navigation is more appropriate to your application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigation menus</h1>
                
            
            
                
<p>Sometimes, you need to provide your user with a broad set of navigation options that won't fit into a set of tabs. This is where a hidden navigation menu, sometimes called a hamburger menu, becomes useful. This menu pattern was once popular to put as a sort of main menu, available on every screen in your application. However, navigation menus hide options, and they often encourage sloppy navigation design, because they provide a space where any navigation items can be <em>dumped</em>. It's better to try and avoid any form of hidden navigation until you're absolutely sure that you need it.</p>
<p>They can be useful when they augment other navigation patterns (such as tabs), and are used to offer seldom used or advanced functionality that the user is unlikely to access every day. For example, on a photo gallery screen, a hidden menu might be used to access the ability to create new labels, access photos that have been deleted, and to access settings and help.</p>
<p>Let's add a navigation menu to the example with the bottom tabs, to allow the user access to some other functionality that they might need:</p>
<ol>
<li style="font-weight: 400">Right-click on the <kbd>res/menu</kbd> directory and select New | Menu resource file.</li>
<li style="font-weight: 400">Name the new file <kbd>nav_menu</kbd>, and click OK to create the new resource file.</li>
<li style="font-weight: 400">Open the Text editor for the new file.</li>
<li style="font-weight: 400">Copy the following menu structure into the new file:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;menu<br/>    &gt;<br/><br/>  &lt;item<br/>    android:id="@+id/loyalty_programs"<br/>    android:title="Frequent Flyer" /&gt;<br/>  &lt;item<br/>    android:id="@+id/deals"<br/>    android:title="Special Deals" /&gt;<br/>  &lt;item<br/>    android:id="@+id/guides"<br/>    android:title="Travel Guide" /&gt;<br/>  &lt;item<br/>    android:id="@+id/settings"<br/>    android:title="Settings"&gt;<br/>    &lt;!-- nesting a menu produces a "group" in the navigation menu --&gt;<br/>    &lt;menu&gt;<br/>      &lt;item android:id="@+id/profile"<br/>            android:title="Profile"/&gt;<br/>      &lt;item android:id="@+id/about"<br/>            android:title="About"/&gt;<br/>    &lt;/menu&gt;<br/>  &lt;/item&gt;<br/>&lt;/menu&gt;</pre>
<ol start="5">
<li style="font-weight: 400">Now, open the <kbd>activity_bottom_tabs.xml</kbd> layout file.</li>
<li style="font-weight: 400">Change to the Text editor.</li>
<li style="font-weight: 400">The root element should currently be a <kbd>ConstraintLayout</kbd>; you'll need to wrap it inside a <kbd>DrawerLayout</kbd> widget that will manage the showing and hiding of the navigation drawer. You'll also need to give the <kbd>ConstraintLayout</kbd> a top-margin the same size as the <kbd>ActionBar</kbd>; otherwise, it will be hidden behind the system <kbd>ActionBar</kbd> (another way around this is to use the <kbd>AppBarLayout</kbd> and <kbd>CoordinatorLayout</kbd> with no system <kbd>ActionBar</kbd>):</li>
</ol>
<pre style="padding-left: 60px"><strong>&lt;android.support.v4.widget.DrawerLayout</strong><br/><strong>    </strong><br/><strong>    </strong><br/><strong>    </strong><br/><strong>    android:id="@+id/drawer_layout"</strong><br/><strong>    android:layout_width="match_parent"</strong><br/><strong>    android:layout_height="match_parent"</strong><br/><strong>    android:fitsSystemWindows="true"</strong><br/><strong>    tools:openDrawer="start"</strong><br/><strong>    tools:context="com.packtpub.navigation.BottomTabActivity"&gt;</strong><br/>    &lt;!-- This ConstraintLayout is your old root layout widget --&gt;<br/>    &lt;android.support.constraint.ConstraintLayout<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent"<br/>        <strong>android:layout_marginTop="?attr/actionBarSize"</strong>&gt;</pre>
<ol start="8">
<li>After the <kbd>ConstraintLayout</kbd> element is closed, you'll need to add the <kbd>NavigationView</kbd>, which will contain the navigation menu you just wrote:</li>
</ol>
<pre style="padding-left: 60px">&lt;/android.support.constraint.ConstraintLayout&gt;<br/><br/>    <strong>&lt;android.support.design.widget.NavigationView</strong><br/><strong>        android:id="@+id/nav_view"</strong><br/><strong>        android:layout_width="wrap_content"</strong><br/><strong>        android:layout_height="match_parent"</strong><br/><strong>        android:layout_gravity="start"</strong><br/><strong>        android:fitsSystemWindows="true"</strong><br/><strong>        app:menu="@menu/nav_menu" /&gt;</strong><br/>&lt;/android.support.v4.widget.DrawerLayout&gt;</pre>
<ol start="9">
<li style="font-weight: 400">Open the <kbd>BottomTabActivity</kbd> source file.</li>
<li style="font-weight: 400">By default, the <kbd>NavigationView</kbd> won't respond to any form of tapping menu items, and won't even close the navigation drawer when you select a menu item. You'll need to add a listener and tell it what to do yourself. At the bottom of the <kbd>onCreate</kbd> method, look up the <kbd>NavigationView</kbd> and add a listener to at least close the navigation drawer:</li>
</ol>
<pre style="padding-left: 60px">final NavigationView navigationView = findViewById(R.id.nav_view);<br/>navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {<br/>  public boolean onNavigationItemSelected(final MenuItem item) {<br/>    <strong>// your normal click handling would go here</strong><br/>    final DrawerLayout drawer = findViewById(R.id.drawer_layout);<br/>    <strong>drawer.closeDrawer(GravityCompat.START);</strong><br/>    return true;<br/>  }<br/>});</pre>
<ol start="11">
<li>Users also expect to be able to close the navigation drawer using the back button. This requires you to override the default back-button behavior:</li>
</ol>
<pre style="padding-left: 60px">public void onBackPressed() {<br/>  final DrawerLayout drawer = findViewById(R.id.drawer_layout);<br/>  if (drawer.isDrawerOpen(GravityCompat.START)) {<br/>    drawer.closeDrawer(GravityCompat.START);<br/>  } else {<br/>    super.onBackPressed();<br/>  }<br/>}</pre>
<p>Overriding the back button behavior like this is something you should be very careful with. The default behavior is strongly consistent across the entire platform and all well-behaved applications. Applications that have inconsistent back-button behavior are obvious to users, and are often very frustrating.</p>
<div><p>The navigation drawer here is a very good example of its use within an application context. The bottom tabs allow the user quick access to the most commonly used areas of the application, while the navigation drawer can be used to access the less frequently used features. Remember that navigation drawers hide features of your application and should only be used for features that are not required for the user, to make effective use of your application. It's sometimes worth forcibly opening the navigation drawer the first time the screen is opened by the user (you can use a <kbd>SharedPreferences</kbd> to remember that they have seen it). You can do this using the <kbd>DrawerLayout.openDrawer</kbd> method in <kbd>Activity.onCreate</kbd>.</p>
<p>Also, remember that while overriding the default back-button behavior is important for the user experience in this specific case, it's normally not a good idea. Inconsistent back-button behavior is something that users pick up on very easily, and it's one of the most common irritations. For some behaviors such as closing the navigation drawer, it's important because it's the most common pattern, but using the ability to ask whether the user is "Sure they want to exit" (and similar additional behaviors) is a waste of the user's time, and should be avoided.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Navigating using Fragments</h1>
                
            
            
                
<p>So far in the book, you've mostly been navigating users from one <kbd>Activity</kbd> to another <kbd>Activity</kbd>, and this is in fact how most applications are built. However, there is another option, which is often much more flexible and allows you to build even more modular applications--navigation using <kbd>Fragment</kbd> instances. So far, we've only really looked at Fragments as little blocks of your application that can be assembled to form parts of a screen, but they can be so much more than that.</p>
<p>The tabbed <kbd>Activity</kbd> classes both provide a sort of navigation using the <kbd>ViewPager</kbd> class and the <kbd>FragmentPagerAdapter</kbd> class. In these cases, each of the pages that the user can swipe to is a complete <kbd>Fragment</kbd>, with its life cycle that is paused and resumed, stopped, and started as the user swipes the <kbd>Fragment</kbd> in or out of view.</p>
<p>If you look into the <kbd>FragmentPagerAdapter</kbd> class, you'll find that it doesn't add and remove the <kbd>Fragment</kbd> view instances directly to the <kbd>ViewPager</kbd> object. Instead, it uses a <kbd>FragmentTransaction</kbd> to add and remove the <kbd>Fragment</kbd> to the <kbd>ViewPager</kbd> using the <kbd>ViewPager</kbd> ID attribute:</p>
<pre style="padding-left: 60px">mCurTransaction = mFragmentManager.beginTransaction();<br/>// …<br/>fragment = getItem(position);<br/>mCurTransaction.add(container.getId(), fragment,<br/>                   makeFragmentName(container.getId(), itemId));</pre>
<p>The <kbd>FragmentTransaction</kbd> class allows you to define any number of actions that will all appear to happen at once. You can add, remove, attach, detach, and replace any number of <kbd>Fragment</kbd> instances on your user interface, and then trigger them all at once. The best part is that you can also add the transaction to the "back stack". This means that the user can undo the transaction by pressing the <em>back</em> button on their device.</p>
<p class="mce-root">So, by creating your main <kbd>Activity</kbd> with a content space (like the <kbd>ViewPager</kbd> in the tabs examples), and populating it with <kbd>Fragment</kbd> objects, you can simulate <kbd>Activity</kbd> to <kbd>Activity</kbd> navigation. This also means that your primary navigation controls, such as tabs or a hidden navigation menu, only need to be defined in your activity layout rather than on the layouts of each screen in the application. This also makes the navigation within your application slightly quicker, because the heavy-weight components of the screen are reused for each navigation.</p>
<p class="mce-root">Let's add some navigation behaviors to the bottom tabs example that we've started, so that the navigation menu options actually do something:</p>
<ol>
<li style="font-weight: 400">First, you'll need a <kbd>Fragment</kbd> class that you can use for the various navigation actions you'll have in the example. Right-click on your default package (that is, <kbd>com.packtpub.navigation</kbd>) and select New| Fragment| Fragment (blank).</li>
<li style="font-weight: 400">Name the new <kbd>Fragment</kbd> class <kbd>PlaceholderFragment</kbd>.</li>
</ol>
<ol start="3">
<li style="font-weight: 400">Deselect the Include fragment factory methods? and Include interface callbacks? checkboxes:</li>
</ol>
<div><img height="246" width="338" src="img/d71c0193-4cda-48e2-b826-842324acec0a.png"/></div>
<ol start="4">
<li style="font-weight: 400">Click on Finish to create the new fragment class and layout file.</li>
<li style="font-weight: 400">Open the <kbd>fragment_placeholder.xml</kbd> layout file in Design mode.</li>
<li style="font-weight: 400">Select the <kbd>FrameLayout</kbd> in the Component Tree panel.</li>
<li style="font-weight: 400">In the Attributes panel, toggle to View all attributes.</li>
<li style="font-weight: 400">Find the <kbd>background</kbd> attribute, and set it to <kbd>#ffffff</kbd> (white) so that the background of this <kbd>Fragment</kbd> is opaque.</li>
<li style="font-weight: 400">Select the <kbd>TextView</kbd> in the Component Tree panel.</li>
<li style="font-weight: 400">In the Attributes panel, change the ID attribute to <kbd>placeholder_text</kbd>.</li>
<li style="font-weight: 400">Change the <kbd>textAppearance</kbd> attribute to <kbd>@style/TextAppearance.AppCompat.Display1</kbd>, which will appear in the drop-down as AppCompat.Display1.</li>
<li style="font-weight: 400">Now, open the new <kbd>PlaceholderFragment</kbd> Java source file.</li>
<li style="font-weight: 400">Declare a <kbd>static</kbd> <kbd>String</kbd> constant to allow the <kbd>PlaceholderFragment</kbd> to hold its placeholder-text argument:</li>
</ol>
<pre style="padding-left: 60px">private static final String ARG_TEXT = "text";</pre>
<ol start="14">
<li>Change the <kbd>onCreateView</kbd> method so that it sets the text of the <kbd>TextView</kbd> to the placeholder-text:</li>
</ol>
<pre style="padding-left: 60px">public View onCreateView(<br/>    final LayoutInflater inflater,<br/>    final ViewGroup container,<br/>    final Bundle savedInstanceState) {<br/><br/>  final View rootView = inflater.inflate(<br/>      R.layout.fragment_placeholder,<br/>      container,<br/>      false<br/>  );<br/><br/>  <strong>final TextView textView =<br/>      rootView.findViewById(R.id.placeholder_text);</strong><br/><strong>  textView.setText(getArguments().getString(ARG_TEXT));&lt;/strong&gt;<br/>  return rootView;<br/>}</strong></pre>
<ol start="15">
<li>Create a convenience factory method to create the <kbd>PlaceholderFragment</kbd> with the placeholder-text specified as a method argument:</li>
</ol>
<pre style="padding-left: 60px">public static PlaceholderFragment newInstance(final String text) {<br/>  final PlaceholderFragment fragment = new PlaceholderFragment();<br/>  final Bundle args = new Bundle();<br/>  args.putString(ARG_TEXT, text);<br/>  fragment.setArguments(args);<br/>  return fragment;<br/>}</pre>
<ol start="16">
<li style="font-weight: 400">Open the <kbd>activity_bottom_tabs.xml</kbd> layout resource in the Text editor.</li>
<li style="font-weight: 400">Find the <kbd>ViewPager</kbd> below the <kbd>BottomNavigationView</kbd> widget.</li>
<li style="font-weight: 400">Change the <kbd>ViewPager</kbd> so that it is wrapped in a full-size <kbd>FrameLayout</kbd> with an ID of <kbd>host</kbd>; this will be used to contain the <kbd>Fragment</kbd> instances used to navigate the user around the app:</li>
</ol>
<pre style="padding-left: 60px">&lt;FrameLayout<br/>    android:id="@+id/host"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="0dp"<br/>    app:layout_constraintBottom_toTopOf="@+id/navigation"<br/>    app:layout_constraintEnd_toEndOf="parent"<br/>    app:layout_constraintStart_toStartOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent"<br/>    tools:layout_editor_absoluteX="8dp"<br/>    tools:layout_editor_absoluteY="8dp"&gt;<br/><br/>    &lt;android.support.v4.view.ViewPager<br/>        android:id="@+id/container"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="match_parent" /&gt;<br/>&lt;/FrameLayout&gt;</pre>
<ol start="19">
<li style="font-weight: 400">Open the <kbd>BottomTabsActivity</kbd> source file.</li>
<li style="font-weight: 400">When the user taps on one of the bottom navigation items, you want to ensure that any navigation they have done is cleared so that the back button doesn't navigate them back into their previous stack, and ensure that there are no residual <kbd>Fragment</kbd> instances on the screen. In the <kbd>OnNavigationItemSelectedListener.onNavigationItemSelected</kbd> method in your anonymous class, you'll want to pop the backstack, before telling the <kbd>ViewPager</kbd> to change tab:</li>
</ol>
<pre style="padding-left: 60px">private BottomNavigationView.OnNavigationItemSelectedListener<br/>    onNavigationItemSelectedListener<br/>    = new BottomNavigationView.OnNavigationItemSelectedListener() {<br/><br/>  @Override<br/>  public boolean onNavigationItemSelected(final MenuItem item) {<br/>    <strong>final FragmentManager fragmentManager =<br/>        getSupportFragmentManager();</strong><br/><strong>    if (fragmentManager.getBackStackEntryCount() &gt; 0) {</strong><br/><strong>      fragmentManager.popBackStack(</strong><br/><strong>            fragmentManager.getBackStackEntryAt(0).getId(),</strong><br/><strong>            FragmentManager.POP_BACK_STACK_INCLUSIVE);</strong><br/><strong>   }</strong><br/>        <br/>      for (int i = 0; i &lt; pageIds.length; i++) {<br/>      // ...</pre>
<ol start="21">
<li>At the bottom of the <kbd>onCreate</kbd> method, you need to add a new listener to the <kbd>NavigationView</kbd> to listen for the taps in the menu. These will trigger the navigation using the <kbd>FragmentManager</kbd>, and will also close the navigation drawer:</li>
</ol>
<pre style="padding-left: 60px">final NavigationView navigationView = findViewById(R.id.nav_view);<br/>navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() {<br/>  @Override<br/>  public boolean onNavigationItemSelected(final MenuItem item) {<br/>    <strong>final String location = item.getTitle().toString();</strong><br/><br/>    <strong>getSupportFragmentManager()</strong><br/><strong>          .beginTransaction()</strong><br/><strong>          .replace(<br/>              R.id.host,<br/>              PlaceholderFragment.newInstance(location)<br/>          )</strong><br/><strong>          .setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN)</strong><br/><strong>          .addToBackStack(location)</strong><br/><strong>          .commit();</strong><br/><br/>    final DrawerLayout drawer = findViewById(R.id.drawer_layout);<br/>    drawer.closeDrawer(GravityCompat.START);<br/>    return true;<br/>  }<br/>});</pre>
<p>As a bonus, the preceding code will also produce a lovely transition navigation between each of the navigation actions. It's also possible that you might want to clear the backstack each time the user takes one of these navigation actions. On top of that, you may also want to select specific tabs in the <kbd>BottomNavigationView</kbd> to indicate which part of the app the user is in, or you may want the <kbd>FrameLayout</kbd> to wrap the entire <kbd>ConstaintLayout</kbd> so that the bottom tabs vanish when the user is navigated using the <kbd>FragmentManager</kbd>.</p>
<p class="mce-root">It's important to note that in this structure, the other layouts and <kbd>Fragment</kbd> instances are still in the layout. They're just hidden by the <kbd>Fragment</kbd> instances being placed over them as the user navigates using the menu. To avoid this, you can wrap the <kbd>ViewPager</kbd> in a dedicated <kbd>Fragment</kbd> class, but it's important to add it to the layout through the <kbd>FragmentManager</kbd> in the <kbd>Activity.onCreate</kbd> method and not by using the <kbd>&lt;fragment&gt;</kbd> tag in the layout XML. The <kbd>FragmentManager</kbd> will only remove a <kbd>Fragment</kbd> from the layout if it was added via a <kbd>FragmentTransaction</kbd> in the first place.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Test your knowledge</h1>
                
            
            
                
<ol>
<li>When using bottom tabs for navigation, which of these is important?
<ul>
<li>They all have single color icons</li>
<li>The tabs are of roughly equal importance</li>
<li>There are always exactly three tabs</li>
</ul>
</li>
</ol>
<ol start="2">
<li>Top tabs are preferred to bottom tabs in which of these situations?
<ul>
<li>When the user won't need to navigate as frequently</li>
<li>When the tabs don't have icons</li>
<li>When there are more than three tabs</li>
</ul>
</li>
<li>Fragments can be used for navigation in which of these cases?
<ul>
<li>Only when a navigation drawer is used as well</li>
<li>Any time the user navigates within the application</li>
<li>When they can be nested in a <kbd>FrameLayout</kbd></li>
</ul>
</li>
<li>When the user selects an item in a navigation drawer, which of these is true?
<ul>
<li>The drawer needs to be closed by the user</li>
<li>The drawer should be closed programmatically</li>
<li>The drawer is closed automatically after a short delay</li>
</ul>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>Navigation is a critical part of a user's experience, and should be carefully thought out and designed. Material design has various different design structures and widgets to help you implement more effective navigation, but it's important to use them carefully and in the right place. As with any screen design, it's important to consider what the user will want to do most often, and to rank each possible action and navigation from the most important to the least on every screen they are available in.</p>
<p class="mce-root">In many applications, dedicated navigation components won't even be needed, and navigation will be achieved purely through goal-oriented actions from an overview screen or dashboard. In all instances, it's a good idea to draw up a navigation map ahead of time (even if it's incomplete or overly simplified). They will often tell you what sort of navigation structure and components your application will require.</p>
<p class="mce-root">Navigation achieved using the <kbd>FragmentManager</kbd> instead of always launching a new <kbd>Activity</kbd> is an extremely powerful pattern. It offers a large number of additional options and significantly more control over the backstack, and even the animations played during each transition. It's also possible to change more than one onscreen <kbd>Fragment</kbd> in a single <kbd>FragmentTransaction</kbd>, which can be used to produce some amazing effects.</p>
<p class="mce-root">In the next chapter, we'll go back to the travel claim example and explore some more of the <kbd>RecyclerView</kbd>. The chapter will take a look at some of the more advanced capabilities of the <kbd>RecyclerView</kbd> and how to integrate it with the <kbd>LiveData</kbd> class and Room using some powerful classes from the support API to achieve some exciting effects.</p>


            

            
        
    </body></html>