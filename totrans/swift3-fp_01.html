<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Getting Started with Functional Programming in Swift</h1></div></div></div><p>In this chapter, we will be introduced to functional programming paradigms, such as immutability, stateless programming, pure, first-class, and higher-order functions. This chapter will give an introduction to the Swift programming language and functional programming paradigms in Swift. The following topics will be covered along with examples:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why functional programming matters?</li><li class="listitem" style="list-style-type: disc">What is functional programming?</li><li class="listitem" style="list-style-type: disc">Swift language basics</li><li class="listitem" style="list-style-type: disc">Immutability</li><li class="listitem" style="list-style-type: disc">First-class, higher-order, and pure functions</li><li class="listitem" style="list-style-type: disc">Optionals and pattern matching</li><li class="listitem" style="list-style-type: disc">Closures</li><li class="listitem" style="list-style-type: disc">Type aliasing</li></ul></div><div><div><div><div><h1 class="title"><a id="ch01lvl1sec7"/>Why functional programming matters?</h1></div></div></div><p>Software solutions are becoming complex and it is necessary to structure them very well for future maintenance and extension. Software engineers try to modularize software to smaller pieces and abstract away complexities in different pieces and layers. Dividing the code into smaller pieces makes it possible to tackle each problem individually. This approach improves collaboration because different engineers can take responsibility for different pieces. Also, they can work on specific parts of software without being concerned about the other parts.</p><p>Dividing software into smaller pieces is not the biggest challenge in most of the projects and programming languages. For instance, in <strong>object-oriented programming</strong> (<strong>OOP</strong>), software is divided into smaller pieces such as packages, classes, interfaces, and methods. Engineers tend to divide the software into these building blocks by domains, logic, and layers. Classes are recipes to create instances and objects. As the name suggests, the most important building blocks in OOP are objects. Engineers deal with objects and the role and responsibility for them should be clear and understandable.</p><p>In OOP, connecting the building blocks to each other is not as easy as dividing them. Connection between different objects may propose strong coupling between them. Coupling is the biggest source of complexity in OOP. A change in a module or class could force change in all coupled modules and classes. Also, a particular module or class might be harder to reuse and test because of coupled modules or classes.</p><p>Software engineers try to loosen coupling by structuring the software well and applying different principles and design patterns. For instance, <strong>single responsibility, open-closed, Liskov substitution, interface segregation and dependency inversion</strong> (<strong>SOLID</strong>) principles when applied together properly tend to make software easy to maintain and extend.</p><p>Even though it is possible to decrease the coupling and simplify software structures, managing the memory, referencing to instances, and testing different objects remains difficult because, in OOP, objects are open to change and mutation.</p><p>In functional programming, pure functions are the most important building blocks. Pure functions do not rely on data outside of themselves and they do not change data that exists outside of them. Pure functions are easy to test because they will always provide the same results.</p><p>Pure functions can be executed on different threads or cores without any mechanisms to handle multithreading and multiprocessing. This is a very important benefit of functional programming over OOP as multicore programming mechanisms are very complex to handle in OOP. Also, programming for multicore computers is becoming more important day by day because hardware engineers have finally hit the speed limit of light. Computer clocks will not be getting faster in the near future so, in order to have more cycles per second, hardware engineers are adding more processors to chips. There seems no end to how many processors we will have in our computers. A higher number of processors to be used for a program means a more complex multithreading and multicore mechanism to handle.</p><p>Functional programming eliminates the need for a complex multicore programming mechanism, and as pure functions are not dependent on any instances or data outside of themselves, it is easy to change them without changing other parts.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec8"/>What is functional programming?</h1></div></div></div><p>We know functional programming matters, but what is it really? There is a lot of hype related to functional programming and there are a lot of definitions about it, but simply it is a style of programming that models computations as the evaluation of expressions. Functional programming is a declarative programming style, as opposed to OOP that is categorized as imperative programming.</p><p>Theoretically, functional programming employs the concepts of category theory, which is a branch of mathematics. It is not necessary to know the category theory to be able to program functionally but studying it will help us grasp some of the more advanced concepts such as <em>functors</em>, <em>applicative functors</em>, and <em>monads</em>. We will get into category theory and its relationship with functional programming later, so for now we are not going to talk math and we will scratch the surface of functional programming pragmatically.</p><p>Let's start with an example to understand the differences between functional programming and OOP styles. The following example gives two different approaches to array element multiplication:</p><pre class="programlisting">let numbers = [9, 29, 19, 79]&#13;
&#13;
// Imperative example&#13;
var tripledNumbers:[Int] = []&#13;
for number in numbers {&#13;
    tripledNumbers.append(number * 3)&#13;
}&#13;
print(tripledNumbers)&#13;
&#13;
// Declarative example&#13;
let tripledIntNumbers = numbers.map({ number in 3 * number })&#13;
print(tripledIntNumbers)&#13;
</pre><p>In the imperative example, we give a command to go through each item in the array, multiply each item by <code class="literal">3</code>, and add it to a new array. In the declarative example, we declare how numbers should be mapped. We will have more examples of declarative programming in upcoming chapters.</p><p>In functional programming, functions are the fundamental building blocks. In OOP, programs are composed of classes and statements, which change the state of classes when executed.</p><p>Functional programming avoids using mutable states. Avoiding mutable states makes it easier to test, read, and understand the code although it is not easy to avoid mutable states in some cases such as file and database operations.</p><p>Functional programming requires functions to be first-class. First-class functions are treated like any other values and can be passed to other functions or returned as a result of a function.</p><p>Functions can be formed as higher-order functions that take other functions as their arguments. Higher-order functions are used to refactor code and reduce the amount of repetition. Higher-order functions can be used to implement <strong>domain-specific languages</strong> (<strong>DSL</strong>).</p><p>Functions are pure so they do not depend on any data outside of themselves and do not change any data outside of themselves. Pure functions provide the same result each time that they are executed. This property of pure functions is called <strong>referential transparency</strong> and makes it possible to conduct <em>equational reasoning</em> on the code.</p><p>In functional programming, expressions can be evaluated lazily. For instance, in the following code example, only the first element in the array is evaluated:</p><pre class="programlisting">let oneToFour = [1, 2, 3, 4]&#13;
let firstNumber = oneToFour.lazy.map({ $0 * 3}).first!&#13;
print(firstNumber) // The result is going to be 3&#13;
</pre><p>The <code class="literal">lazy</code> keyword is used to get a lazy version of the collection in this example so only the first item in the array is multiplied by <code class="literal">3</code> and the rest of the items are not mapped.</p></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec9"/>The Swift programming language</h1></div></div></div><p>Swift is an open source hybrid language developed by Apple that combines OOP and protocol-oriented programming with functional programming paradigms. Swift can be used along with Objective-C to develop macOS, iOS, tvOS, and watchOS applications. Swift can also be used on Ubuntu Linux to develop web applications. This book explains Swift 3.0 Preview 1 and utilizes Xcode 8.0 beta. Source code at GitHub repository will be updated frequently to catch up with Swift changes.</p><div><div><div><div><h2 class="title"><a id="ch01lvl2sec7"/>Swift features</h2></div></div></div><p>Swift has borrowed many concepts from other programming languages such as Scala, Haskell, C#, Rust, and Objective-C and has the following features.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec0"/>Modern syntax</h3></div></div></div><p>Swift has a modern syntax that eliminates the verbosity of programming languages such as Objective-C. For instance, the following code example shows an Objective-C class with a property and method. Objective-C classes are defined in two separate files (interface and implementation). The <code class="literal">VerboseClass.h</code> file defines an interface as a subclass of the <code class="literal">NSObject</code> class. It defines a property, <code class="literal">ourArray</code>, and a method, <code class="literal">aMethod</code>.</p><p>The implementation file imports the header class and provides an implementation for <code class="literal">aMethod</code>:</p><pre class="programlisting">// VerboseClass.h&#13;
@interface VerboseClass: NSObject&#13;
@property (nonatomic, strong) NSArray *ourArray;&#13;
- (void)aMethod:(NSArray *)anArray;&#13;
@end&#13;
&#13;
// VerboseClass.m&#13;
#import "VerboseClass.h"&#13;
&#13;
@implementation VerboseClass&#13;
&#13;
- (void)aMethod:(NSArray *)anArray {&#13;
    self.ourArray = [[NSArray alloc] initWithArray:anArray];&#13;
}&#13;
&#13;
@end&#13;
&#13;
// TestVerboseClass.m&#13;
#import "VerboseClass.h"&#13;
&#13;
@interface TestVerboseClass : NSObject&#13;
&#13;
@end&#13;
&#13;
@implementation TestVerboseClass&#13;
&#13;
- (void)aMethod {&#13;
    VerboseClass *ourOBJCClass = [[VerboseClass alloc] init];&#13;
    [ourOBJCClass aMethod: @[@"One", @"Two", @"Three"]];&#13;
    NSLog(@"%@", ourOBJCClass.ourArray);&#13;
}&#13;
&#13;
@end&#13;
</pre><p>A similar functionality in Swift can be achieved as follows:</p><pre class="programlisting">class ASwiftClass {&#13;
    var ourArray: [String] = []&#13;
&#13;
    func aMethod(anArray: [String]) {&#13;
        self.ourArray = anArray&#13;
    }&#13;
}&#13;
&#13;
let aSwiftClassInstance = ASwiftClass()&#13;
aSwiftClassInstance.aMethod(anArray: ["one", "Two", "Three"])&#13;
print(aSwiftClassInstance.ourArray)&#13;
</pre><p>As seen from this example, Swift eliminates a lot of unnecessary syntax and keeps code very clean and readable.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec1"/>Type safety and type inference</h3></div></div></div><p>Swift is a type safe language unlike languages such as Ruby and JavaScript. As opposed to type variant collections in Objective-C, Swift provides type safe collections.
Swift automatically deducts types by the type inference mechanism, a mechanism that is present in languages such as C# and C++ 11. For instance, <code class="literal">constString</code> in the following example is inferred as <code class="literal">String</code> during the compile time and it is not necessary to annotate the type:</p><pre class="programlisting">let constString = "This is a string constant" &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec2"/>Immutability</h3></div></div></div><p>Swift makes it easy to define immutable values—in other words, constants—and empowers functional programming as immutability is one of the key concepts in functional programming. Once constants are initialized, they cannot be altered. Although it is possible to achieve immutability in languages such as Java, it is not as easy as Swift. To define any immutable type in Swift, the <code class="literal">let</code> keyword can be used no matter if it is a custom type, collection type, or a <code class="literal">Struct</code> type.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec3"/>Stateless programming</h3></div></div></div><p>Swift provides very powerful structures and enumerations that are passed by values and can be stateless; therefore, they are very efficient. Stateless programming simplifies the concurrency and multithreading.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec4"/>First-class functions</h3></div></div></div><p>Functions are first-class types in Swift as they are in languages such as Ruby, JavaScript, and Go so they can be stored, passed, and returned. First-class functions empower functional programming style in Swift.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec5"/>Higher-order functions</h3></div></div></div><p>Higher-order functions can receive other functions as their parameters. Swift provides higher-order functions such as <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code>. Also, in Swift, we can develop our own higher-order functions and DSLs.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec6"/>Pattern matching</h3></div></div></div><p>Pattern matching is the ability to destructure values and match different switch cases based on correct value matches. Pattern matching capabilities are existent in languages such as Scala, Erlang, and Haskell. Swift provides powerful switch-cases and if-cases with <code class="literal">where</code> clauses as well.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec7"/>Generics</h3></div></div></div><p>Swift provides generics that make it possible to write code that is not specific to a type and can be utilized for different types.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec8"/>Closures</h3></div></div></div><p>Closures are blocks of code that can be passed around. Closures capture the constants and variables of the context in which they are defined. Swift provides closures with a simpler syntax compared to Objective-C blocks.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec9"/>Subscripts</h3></div></div></div><p>Swift provides subscripts that are shortcuts to access members of collections, lists, sequences, or custom types. Subscripts can be used to set and get values by an index without needing separate methods for the setting and getting.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec10"/>Optional chaining</h3></div></div></div><p>Swift provides optional types that can have some or none values. Swift also provides optional chaining to use optionals safely and efficiently. Optional chaining empowers us to query and call properties, methods, and subscripts on optional types that may be <code class="literal">nil</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec11"/>Extensions</h3></div></div></div><p>Swift provides extensions that are similar to categories in Objective-C. Extensions add new functionality to an existing class, structure, enumeration, or protocol type even if it is closed source.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec12"/>Objective-C and Swift bridging headers</h3></div></div></div><p>Bridging headers empower us to mix Swift with Objective-C in our projects. This functionality makes it possible to use our previously written Objective-C code in Swift projects and vice versa.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec13"/>Automatic Reference Counting</h3></div></div></div><p>Swift handles memory management through <strong>Automatic Reference Counting</strong> (<strong>ARC</strong>), like Objective-C and unlike languages such as Java and C# that utilize garbage collection. ARC is used to initialize and deinitialize resources, thereby releasing memory allocations of the class instances when they are no longer required. ARC tracks retains and releases in the code instances to manage the memory resources effectively.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec14"/>REPL and Playground</h3></div></div></div><p>Xcode provides the <strong>Read Eval Print Loop</strong> (<strong>REPL</strong>) command-line environment to experiment with the Swift programming language without the need to write a program. Also, Swift provides playgrounds that enable us to test Swift code snippets quickly and see the results in real time via a visual interface. Playgrounds will be used extensively in this book. Also, most of code examples from all the chapters can be experimented on Swift Playgrounds App (<a class="ulink" href="https://developer.apple.com/swift/playgrounds/">https://developer.apple.com/swift/playgrounds/</a>)</p></div></div><div><div><div><div><h2 class="title"><a id="ch01lvl2sec8"/>Language basics</h2></div></div></div><p>This section will provide a brief introduction to the basics of Swift programming language. Topics in the upcoming subsections of this chapter will be explained in detail in the later chapters.</p><div><div><div><div><h3 class="title"><a id="ch01lvl3sec15"/>Type safety and type inference</h3></div></div></div><p>Swift is a type safe language. This means that we cannot change the type of a constant, variable, or expression once we define it. Also, the type safe nature of Swift empowers us to find type mismatches during compile time.</p><p>Swift provides type inference. Swift infers the type of a variable, constant, or expression automatically so we do not need to specify the types while defining them. Let's examine the following expressions:</p><pre class="programlisting">let pi = 3.14159 &#13;
var primeNumber = 691 &#13;
let name = "my name" &#13;
</pre><p>In these expressions, Swift infers <code class="literal">pi</code> as <code class="literal">Double</code>, <code class="literal">primeNumber</code> as <code class="literal">Int</code>, and <code class="literal">name</code> as <code class="literal">String</code>. In case we need special types such as <code class="literal">Int64</code>, we will need to annotate the type.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec16"/>Type annotation</h3></div></div></div><p>In Swift, it is possible to annotate types, in other words, explicitly specify the type of a variable or expression. Let's see the following example:</p><pre class="programlisting">let pi: Double = 3.14159 &#13;
let piAndPhi: (Double, Double) = (3.14159, 1.618) &#13;
func ourFunction(a: Int) { /* ... */ } &#13;
</pre><p>In this example, we define a constant (<code class="literal">pi</code>) annotated as <code class="literal">Double</code>, a tuple named <code class="literal">piAndPhi</code> annotated as <code class="literal">(Double, Double)</code>, and a parameter of <code class="literal">ourFunction</code> as <code class="literal">Int</code>.</p><div><div><h3 class="title"><a id="tip3"/>Tip</h3><p>
<strong>Downloading the example code</strong>
The code bundle for the book is also hosted on GitHub at <a class="ulink" href="https://github.com/PacktPublishing/Swift-3-Functional-Programming">https://github.com/PacktPublishing/Swift-3-Functional-Programming</a>. We also have other code bundles from our rich catalog of books and videos available at <a class="ulink" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a>. Check them out!</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec17"/>Type aliases</h3></div></div></div><p>Type aliases define an alternative name for an existing type. We define type aliases with the <code class="literal">typealias</code> keyword. Type aliases are useful when we want to refer to an existing type by a name that is contextually more appropriate, such as when working with data of a specific size from an external source. For instance, in the following example, we provide an alias for an unsigned 32-bit integer that can be used later in our code:</p><pre class="programlisting">typealias UnsignedInteger = UInt32 &#13;
</pre><p>The <code class="literal">typealias</code> definitions can be used to simplify the closure and function definitions as well.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec18"/>Immutability</h3></div></div></div><p>Swift makes it possible to define variables as mutable and immutable. The <code class="literal">let</code> keyword is used for immutable declarations and the <code class="literal">var</code> keyword is used for mutable declarations. Any variable that is declared with the <code class="literal">let</code> keyword will not be open to change. In the following examples, we define <code class="literal">aMutableString</code> with the <code class="literal">var</code> keyword so that we will be able to alter it later on; in contrast, we will not be able to alter <code class="literal">aConstString</code> that is defined with the <code class="literal">let</code> keyword:</p><pre class="programlisting">var aMutableString = "This is a variable String" &#13;
let aConstString = "This is a constant String" &#13;
</pre><p>In functional programming, it is recommended to define properties as constants or immutables with <code class="literal">let</code> as much as possible. Immutable variables are easier to track and less error-prone. In some cases, such as <em>CoreData</em> programming, <em>SDK</em> requires mutable properties; however, in these cases it is recommended to use mutable variables.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec19"/>Tuples</h3></div></div></div><p>Swift provides tuples so that they can be used to group multiple values into a single compound value. Let's consider the following example:</p><pre class="programlisting">// Tuples &#13;
let http400Error = (400, "Bad Request")&#13;
// http400Error is of type (Int, String), and equals (400, "Bad Request")&#13;
 &#13;
// Decompose a Tuple's content &#13;
let (requestStatusCode, requestStatusMessage) = http400Error &#13;
</pre><p>Tuples can be used as return types in functions to implement multireturn functions as well.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec20"/>Optionals</h3></div></div></div><p>Swift provides optionals so they can be used in situations where a value may be absent. An optional will have some or none values. The <code class="literal">?</code> symbol is used to define a variable as optional. Let's consider the following example:</p><pre class="programlisting">// Optional value either contains a value or contains nil&#13;
var optionalString: String? = "A String literal"&#13;
optionalString = nil&#13;
</pre><p>The <code class="literal">!</code> symbol can be used to forcefully unwrap the value from an optional. For instance, the following example forcefully unwraps the <code class="literal">optionalString</code> variable:</p><pre class="programlisting">optionalString = "An optional String"&#13;
print(optionalString!)&#13;
</pre><p>Force-unwrapping the optionals may cause errors if the optional does not have a value so it is not recommended to use this approach as it is very hard to be sure if we are going to have values in optionals in different circumstances. The better approach would be to use the optional binding technique to find out whether an optional contains a value. Let's consider the following example:</p><pre class="programlisting">let nilName:String? = nil&#13;
if let familyName = nilName {&#13;
    let greetingfamilyName = "Hello, Mr. \(familyName)"&#13;
} else {&#13;
    // Optional does not have a value&#13;
}&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec21"/>Basic operators</h3></div></div></div><p>Swift provides the following basic operations:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">=</code> operator for assignments like so many different programming languages.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">+</code> operator for addition, <code class="literal">-</code> for subtraction, <code class="literal">*</code> for multiplication, <code class="literal">/</code> for division, and <code class="literal">%</code> for remainders. These operators are functions that can be passed to other functions.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">-i</code> operator for unary minus, <code class="literal">+i</code> for unary plus operations.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">+=</code>, <code class="literal">-=</code>, and <code class="literal">*=</code> operators for compound assignments.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">a == b</code> operator for equality, <code class="literal">a != b</code> for inequality, and <code class="literal">a &gt; b</code>, <code class="literal">a &lt; b</code>, and <code class="literal">a &lt;= b</code> for greatness comparison.</li><li class="listitem" style="list-style-type: disc">The ternary conditional operator, <code class="literal">question ? answer1: answer2</code>.</li><li class="listitem" style="list-style-type: disc">Nil coalescing <code class="literal">a ?? b</code> unwraps optional <code class="literal">a</code> if it has a value and returns a default value <code class="literal">b</code> if <code class="literal">a</code> is <code class="literal">nil</code>.</li><li class="listitem" style="list-style-type: disc">Range operators:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Closed range (<code class="literal">a...b</code>) includes the values <code class="literal">a</code> and <code class="literal">b</code></li><li class="listitem" style="list-style-type: disc">Half-open range (<code class="literal">a..&lt;b</code>) includes <code class="literal">a</code> but does not include <code class="literal">b</code></li></ul></div></li><li class="listitem" style="list-style-type: disc">Logical operators:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">!a</code> operator is NOT a</li><li class="listitem" style="list-style-type: disc">The <code class="literal">a &amp;&amp; b</code> operator is logical AND</li><li class="listitem" style="list-style-type: disc">The <code class="literal">a || b</code> operator is logical OR</li></ul></div></li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec22"/>Strings and characters</h3></div></div></div><p>In Swift, <code class="literal">String</code> is an ordered collection of characters. <code class="literal">String</code> is a structure and not a class. Structures are value types in Swift; therefore, any <code class="literal">String</code> is a value type and passed by values, not by references.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec0"/>Immutability</h4></div></div></div><p>Strings can be defined with <code class="literal">let</code> for immutability. Strings defined with <code class="literal">var</code> will be mutable.</p></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec1"/>String literals</h4></div></div></div><p>
<code class="literal">String</code> literals can be used to create an instance of <code class="literal">String</code>. In the following coding example, we define and initialize <code class="literal">aVegetable</code> with the <code class="literal">String</code> literal:</p><pre class="programlisting">let aVegetable = "Arugula" &#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec2"/>Empty Strings</h4></div></div></div><p>Empty <code class="literal">Strings</code> can be initialized as follows:</p><pre class="programlisting">var anEmptyString = ""&#13;
var anotherEmptyString = String()&#13;
</pre><p>These two strings are both empty and equivalent to each other. To find out whether a <code class="literal">String</code> is empty, the <code class="literal">isEmpty</code> property can be used as follows:</p><pre class="programlisting">if anEmptyString.isEmpty {&#13;
    print("String is empty")&#13;
}&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec3"/>Concatenating strings and characters</h4></div></div></div><p>Strings and characters can be concatenated as follows:</p><pre class="programlisting">let string1 = "Hello"&#13;
let string2 = " Mr"&#13;
var welcome = string1 + string2&#13;
&#13;
var instruction = "Follow us please"&#13;
instruction += string2&#13;
&#13;
let exclamationMark: Character = "!"&#13;
welcome.append(exclamationMark)&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec4"/>String interpolation</h4></div></div></div><p>String interpolation is a way to construct a new <code class="literal">String</code> value from a mix of constants, variables, literals, and expressions by including their values inside a <code class="literal">String</code> literal. Let's consider the following example:</p><pre class="programlisting">let multiplier = 3&#13;
let message = "\(multiplier) times 7.5 is \(Double (multiplier) * 7.5)"&#13;
// message is "3 times 7.5 is 22.5"&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec5"/>String comparison</h4></div></div></div><p>Strings can be compared with <code class="literal">==</code> for equality and <code class="literal">!=</code> for inequality.</p><p>The <code class="literal">hasPrefix</code> and <code class="literal">hasSuffix</code> methods can be used for prefix and suffix equality checking.</p></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec23"/>Collections</h3></div></div></div><p>Swift provides typed collections such as arrays, dictionaries, and sets. In Swift, unlike Objective-C, all elements in a collection will have the same type and we will not be able to change the type of a collection after defining it.</p><p>We can define collections as immutables with <code class="literal">let</code> and mutables with <code class="literal">var</code>, as shown in the following example:</p><pre class="programlisting">// Arrays and Dictionaries&#13;
var cheeses = ["Brie", "Tete de Moine", "Cambozola", "Camembert"]&#13;
cheeses[2] = "Roquefort"&#13;
var cheeseWinePairs = [&#13;
    "Brie":"Chardonnay",&#13;
    "Camembert":"Champagne",&#13;
    "Gruyere":"Sauvignon Blanc"&#13;
]&#13;
&#13;
cheeseWinePairs ["Cheddar"] = "Cabarnet Sauvignon"&#13;
// To create an empty array or dictionary&#13;
let emptyArray = [String]()&#13;
let emptyDictionary = Dictionary&lt;String, Float&gt;()&#13;
cheeses = []&#13;
cheeseWinePairs = [:]&#13;
</pre><p>The <code class="literal">for-in</code> loops can be used to iterate over the items in collections.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec24"/>Control flows</h3></div></div></div><p>Swift provides different control flows that are explained in the following subsections.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec6"/>for loops</h4></div></div></div><p>Swift provides <code class="literal">for</code> and <code class="literal">for-in</code> loops. We can use the <code class="literal">for-in</code> loop to iterate over items in a collection, a sequence of numbers such as ranges, or characters in a string expression. The following example presents a <code class="literal">for-in</code> loop to iterate through all items in an <code class="literal">Int</code> array:</p><pre class="programlisting">let scores = [65, 75, 92, 87, 68]&#13;
var teamScore = 0&#13;
&#13;
for score in scores {&#13;
    if score &gt; 70 {&#13;
        teamScore = teamScore + 3&#13;
    } else {&#13;
        teamScore = teamScore + 1&#13;
    }&#13;
}&#13;
</pre><p>The following is to iterate over dictionaries:</p><pre class="programlisting">for (cheese, wine) in cheeseWinePairs {&#13;
    print("\(cheese): \(wine)")&#13;
}&#13;
</pre><p>We can use <code class="literal">for</code> loops with a condition and an incrementer/decrementer. The following example presents a <code class="literal">for</code> loop example:</p><pre class="programlisting">var count = 0&#13;
for var i = 0; i &lt; 3; ++i {&#13;
    count += i&#13;
}&#13;
</pre><p>As C style for loops with incrementers/decrementers are removed from Swift 3.0, it is recommended to use <code class="literal">for-in</code> loops with ranges instead, as follows:</p><pre class="programlisting">var count = 0&#13;
for i in 0...3 {&#13;
    count += i&#13;
}&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec7"/>while loops</h4></div></div></div><p>Swift provides <code class="literal">while</code> and <code class="literal">repeat-while</code> loops. A <code class="literal">while</code> or <code class="literal">repeat-while</code> loop performs a set of expressions until a condition becomes false. Let's consider the following example:</p><pre class="programlisting">var n = 2&#13;
while n &lt; 100 {&#13;
    n = n * 2&#13;
}&#13;
&#13;
var m = 2&#13;
repeat {&#13;
    m = m * 2&#13;
} while m &lt; 100&#13;
</pre><p>The <code class="literal">while</code> loop evaluates its condition at the beginning of each iteration. The <code class="literal">repeat-while</code> loop evaluates its condition at the end of each iteration.</p></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec8"/>stride</h4></div></div></div><p>The <code class="literal">stride</code> functions enable us to iterate through ranges with a step other than one. There are two <code class="literal">stride</code> functions: the <code class="literal">stride to</code> function, which iterates over exclusive ranges, and <code class="literal">stride through</code>, which iterates over inclusive ranges. Let's consider the following example:</p><pre class="programlisting">let fourToTwo = Array(stride(from: 4, to: 1, by: -1)) // [4, 3, 2]&#13;
let fourToOne = Array(stride(from:4, through: 1, by: -1)) // [4, 3, 2, 1]&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec9"/>if</h4></div></div></div><p>Swift provides <code class="literal">if</code> to define conditional statements. It executes a set of statements only if the condition statement is <code class="literal">true</code>. For instance, in the following example, the <code class="literal">print</code> statement will be executed because <code class="literal">anEmptyString</code> is empty:</p><pre class="programlisting">var anEmptyString = ""&#13;
if anEmptyString.isEmpty {&#13;
    print("An empty String")&#13;
} else {&#13;
    // String is not empty.&#13;
}&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec10"/>switch</h4></div></div></div><p>Swift provides the <code class="literal">switch</code> statement to compare a value against different matching patterns. The related statement will be executed once the pattern is matched. Unlike most other C-based programming languages, Swift does not need a <code class="literal">break</code> statement for each <code class="literal">case</code> and supports any value types. Switch statements can be used for range matching and <code class="literal">where</code> clauses in <code class="literal">switch</code> statements can be used to check for additional conditions. The following example presents a simple <code class="literal">switch</code> statement with an additional conditional checking:</p><pre class="programlisting">let aNumber = "Four or Five"&#13;
switch aNumber {&#13;
    case "One":&#13;
        let one = "One"&#13;
    case "Two", "Three":&#13;
        let twoOrThree = "Two or Three"&#13;
    case let x where x.hasSuffix("Five"):&#13;
        let fourOrFive = "it is \(x)"&#13;
    default:&#13;
        let anyOtherNumber = "Any other number"&#13;
}&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec11"/>guard</h4></div></div></div><p>A <code class="literal">guard</code> statement can be used for early exits. We can use a <code class="literal">guard</code> statement to require that a condition must be <code class="literal">true</code> in order for the code after the <code class="literal">guard</code> statement to be executed. The following example presents the <code class="literal">guard</code> statement usage:</p><pre class="programlisting">func greet(person: [String: String]) {&#13;
    guard let name = person["name"] else {&#13;
        return&#13;
    }&#13;
    print("Hello Ms \(name)!")&#13;
}&#13;
</pre><p>In this example, the <code class="literal">greet</code> function requires a value for a person's <code class="literal">name</code>. Therefore, it checks whether it is present with the <code class="literal">guard</code> statement, otherwise it will return and not continue to execute.</p></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec25"/>Functions</h3></div></div></div><p>Functions are self-contained blocks of code that perform a specific task.</p><p>In Swift, function are first-class citizens, meaning that they can be stored, passed, and returned. Functions can be curried and defined as higher-order functions that take other functions as their arguments.
Functions in Swift can have multiple input parameters and multiple returns using tuples. Let's see the following example:</p><pre class="programlisting">func greet(name: String, day: String) -&gt; String {&#13;
    return "Hello \(name), today is \(day)"&#13;
}&#13;
&#13;
greet(name: "Ted", day:"Saturday")&#13;
</pre><p>Functions can have variadic parameters. Let's consider the following example:</p><pre class="programlisting">// Variable number of arguments in functions - Variadic Parameters&#13;
func sumOf(numbers:Int...) -&gt; (Int, Int) {&#13;
    var sum = 0&#13;
    var counter = 0&#13;
    for number in numbers {&#13;
        sum += number&#13;
        counter += 1&#13;
    }&#13;
    return (sum, counter)&#13;
}&#13;
&#13;
sumOf()&#13;
sumOf(numbers: 7, 9, 45)&#13;
</pre><p>Prior to Swift 3.0, functions could have mutable and immutable parameters. Let's consider the following example:</p><pre class="programlisting">func alignRight(var string: String, count: Int, pad: Character) -&gt; String {&#13;
    let amountToPad = count - string.characters.count&#13;
    if amountToPad &lt; 1 {&#13;
        return string&#13;
    }&#13;
    let padString = String(pad)&#13;
    for _ in 1...amountToPad {&#13;
        string = padString + string&#13;
    }&#13;
    return string&#13;
} &#13;
</pre><p>Mutable parameters are not favorable in Swift functional programming and are removed from Swift 3.0.</p><p>Functions can have <code class="literal">inout</code> parameters. Let's consider the following example:</p><pre class="programlisting">func swapTwoInts( a: inout Int, b: inout Int) {&#13;
    let temporaryA = a&#13;
    a = b&#13;
    b = temporaryA&#13;
}&#13;
</pre><p>The <code class="literal">inout</code> parameters are not favorable in functional Swift as they mutate states and make functions impure.</p><p>In Swift, we can define nested functions. The following example presents a function named <code class="literal">add</code> nested inside another function. Nested functions can access the data in scope of their parent function. In this example, the <code class="literal">add</code> function has access to the <code class="literal">y</code> variable:</p><pre class="programlisting">func returnTwenty() -&gt; Int {&#13;
    var y = 10&#13;
    func add() {&#13;
        y += 10&#13;
    }&#13;
    add()&#13;
    return y&#13;
}&#13;
&#13;
returnTwenty()&#13;
</pre><p>In Swift, functions can return other functions. In the following example, the <code class="literal">makeIncrementer</code> function returns a function that receives an <code class="literal">Int</code> value and returns an <code class="literal">Int</code> value (<code class="literal">Int -&gt; Int</code>):</p><pre class="programlisting">// Return another function as its value&#13;
func makeIncrementer() -&gt; (Int -&gt; Int) {&#13;
    func addOne(number: Int) -&gt; Int {&#13;
        return 1 + number&#13;
    }&#13;
    return addOne&#13;
}&#13;
&#13;
var increment = makeIncrementer()&#13;
increment(7)&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec26"/>Closures</h3></div></div></div><p>Closures are self-contained blocks of code that provide a specific functionality and can be stored, passed around, and used in the code. Closures are equivalent of blocks in C and Objective-C. Closures can capture and store references to any constants and variables from the context in which they are defined. Nested functions are special cases of closures.
Closures are reference types that can be stored as variables, constants, and type aliases. They can be passed to and returned from functions.</p><p>The following examples present different declarations of closures in Swift from the website, http://goshdarnclosuresyntax.com:</p><pre class="programlisting">// As a variable:&#13;
var closureName: (parameterTypes) -&gt; (returnType)&#13;
&#13;
//As an optional variable:&#13;
var closureName: ((parameterTypes) -&gt; (returnType))?&#13;
&#13;
//As a type alias:&#13;
typealias closureType = (parameterTypes) -&gt; (returnType)&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec27"/>Map, filter, and reduce</h3></div></div></div><p>Swift provides <code class="literal">map</code>, <code class="literal">filter</code>, and <code class="literal">reduce</code> functions that are higher-order functions.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec12"/>Map</h4></div></div></div><p>The <code class="literal">map</code> function solves the problem of transforming the elements of an array using a function. Let's consider the following example:</p><pre class="programlisting">// Return an `Array` containing the results of calling `transform(x)` on&#13;
  each element `x` of `self`&#13;
// func map&lt;U&gt;(transform: (T) -&gt; U) -&gt; [U]&#13;
let numbers = [10, 30, 91, 50, 100, 39, 74]&#13;
var formattedNumbers: [String] = []&#13;
&#13;
for number in numbers {&#13;
    let formattedNumber = "\(number)$"&#13;
    formattedNumbers.append(formattedNumber)&#13;
}&#13;
&#13;
let mappedNumbers = numbers.map { "\($0)$" }&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec13"/>Filter</h4></div></div></div><p>The <code class="literal">filter</code> function takes a function that, given an element in the array, returns <code class="literal">Bool</code> indicating whether the element should be included in the resulting array. Let's consider the following example:</p><pre class="programlisting">// Return an Array containing the elements x of self for which&#13;
  includeElement(x)` is `true`&#13;
// func filter(includeElement: (T) -&gt; Bool) -&gt; [T]&#13;
let someEvenNumbers = numbers.filter { $0 % 2 == 0 }&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec14"/>Reduce</h4></div></div></div><p>The <code class="literal">reduce</code> function reduces an array to a single value. It takes two parameters: a starting value and a function, which takes a running total and an element of the arrays as parameters and returns a new running total. Let's consider the following example:</p><pre class="programlisting">// Return the result of repeatedly calling `combine` with an accumulated&#13;
  value initialized to `initial` and each element of `self`, in turn,&#13;
  that is return `combine(combine(...combine(combine(initial, self[0]),&#13;
  self[1]),...self[count-2]), self[count-1])`.&#13;
// func reduce&lt;U&gt;(initial: U, combine: (U, T) -&gt; U) -&gt; U&#13;
let total = numbers.reduce(0) { $0 + $1 }&#13;
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec28"/>Enumerations</h3></div></div></div><p>In Swift, an enumeration defines a common type for related values and enables us to work with those values in a type-safe way. Values provided for each enumeration member can be a <code class="literal">String</code>, <code class="literal">Character</code>, <code class="literal">Int</code>, or any floating-point type. Enumerations can store associated values of any given type, and the value types can be different for each member of the enumeration if needed. Enumeration members can come prepopulated with default values (called raw values), which are all of the same type. Let's consider the following example:</p><pre class="programlisting">enum MLSTeam {&#13;
    case montreal&#13;
    case toronto&#13;
    case newYork&#13;
    case columbus&#13;
    case losAngeles&#13;
    case seattle&#13;
}&#13;
&#13;
let theTeam = MLSTeam.montreal&#13;
</pre><p>Enumeration values can be matched with a <code class="literal">switch</code> statement, which can be seen in the following example:</p><pre class="programlisting">switch theTeam {&#13;
    case .montreal:&#13;
        print("Montreal Impact")&#13;
    case .toronto:&#13;
        print("Toronto FC")&#13;
    case .newYork:&#13;
        print("Newyork Redbulls")&#13;
    case .columbus:&#13;
        print("Columbus Crew")&#13;
    case .losAngeles:&#13;
        print("LA Galaxy")&#13;
    case .seattle:&#13;
        print("Seattle Sounders")&#13;
}&#13;
</pre><p>Enumerations in Swift are actually algebraic data types created by combining other types. Let's consider the following example:</p><pre class="programlisting">enum NHLTeam { case canadiens, senators, rangers, penguins, blackHawks,&#13;
  capitals}&#13;
&#13;
enum Team {&#13;
    case hockey(NHLTeam)&#13;
    case soccer(MLSTeam)&#13;
}&#13;
&#13;
struct HockeyAndSoccerTeams {&#13;
    var hockey: NHLTeam&#13;
    var soccer: MLSTeam&#13;
}&#13;
</pre><p>The <code class="literal">MLSTeam</code> and <code class="literal">NHLTeam</code> enumerations each have six potential values. If we combine them, we will have two new types. A <code class="literal">Team</code> enumeration can be either <code class="literal">NHLTeam</code> or <code class="literal">MLSTeam</code> so it has 12 potential values—that is, the sum of the <code class="literal">NHLTeam</code> and <code class="literal">MLSTeam</code> potential values. Therefore, <code class="literal">Team</code>, an enumeration, is a sum type.</p><p>To have a <code class="literal">HockeyAndSoccerTeams</code> structure, we need to choose one value for <code class="literal">NHLTeam</code> and one for <code class="literal">MLSTeam</code> so that it has 36 potential values—that is, the product of the <code class="literal">NHLTeam</code> and <code class="literal">MLSTeam</code> values. Therefore, <code class="literal">HockeyAndSoccerTeams</code> is a product type.</p><p>In Swift, an enumeration's option can have multiple values. If it happens to be the only option, then this enumeration becomes a product type. The following example presents an enumeration as a product type:</p><pre class="programlisting">enum HockeyAndSoccerTeams {&#13;
    case Value(hockey: NHLTeam, soccer: MLSTeam)&#13;
}&#13;
</pre><p>As we can create sum or product types in Swift, we can say that Swift has first-class support for algebraic data types.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec29"/>Generics</h3></div></div></div><p>Generic code enables us to write flexible and reusable functions and types that can work with any type, subject to requirements that we define. For instance, the following function that uses <code class="literal">inout</code> parameters to swap two values can only be used with <code class="literal">Int</code> values:</p><pre class="programlisting">func swapTwoIntegers( a: inout Int, b: inout Int) {&#13;
    let tempA = a&#13;
    a = b&#13;
    b = tempA&#13;
}&#13;
</pre><p>To make this function work with any type, generics can be used, as shown in the following example:</p><pre class="programlisting">func swapTwoValues&lt;T&gt;( a: inout T, b: inout T) {&#13;
    let tempA = a&#13;
    a = b&#13;
    b = tempA&#13;
}&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec30"/>Classes and structures</h3></div></div></div><p>Classes and structures are general-purpose, flexible constructs that become the building blocks of a program's code. They have the following features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Properties can be defined to store values</li><li class="listitem" style="list-style-type: disc">Methods can be defined to provide functionality</li><li class="listitem" style="list-style-type: disc">Subscripts can be defined to provide access to their values using subscript syntax</li><li class="listitem" style="list-style-type: disc">Initializers can be defined to set up their functionality beyond a default implementation</li><li class="listitem" style="list-style-type: disc">They can conform to protocols to provide standard functionality of certain kinds</li></ul></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec15"/>Classes versus structures</h4></div></div></div><p>This section compares classes and structures:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Inheritance enables one class to inherit the characteristics of another</li><li class="listitem" style="list-style-type: disc">Type casting enables us to check and interpret the type of a class instance at runtime</li><li class="listitem" style="list-style-type: disc">Deinitializers enable an instance of a class to free any resources it has assigned</li><li class="listitem" style="list-style-type: disc">Reference counting allows more than one reference to a class instance</li><li class="listitem" style="list-style-type: disc">Structures are value types so they are always copied when they are passed around in code</li><li class="listitem" style="list-style-type: disc">Structures do not use reference counting</li><li class="listitem" style="list-style-type: disc">Classes are reference types</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec16"/>Choosing between classes and structures</h4></div></div></div><p>We consider creating a structure when one or more of the following conditions apply:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The structure's primary purpose is to encapsulate a few relatively simple data values</li><li class="listitem" style="list-style-type: disc">It is reasonable to expect that the encapsulated values will be copied rather than referenced when we assign or pass around an instance of the structure</li><li class="listitem" style="list-style-type: disc">Any properties stored by the structure are themselves value types, which would also be expected to be copied rather than referenced</li><li class="listitem" style="list-style-type: disc">The structure does not need to inherit properties or behavior from another existing type</li></ul></div><p>Example of good candidates for structures include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The size of a geometric shape</li><li class="listitem" style="list-style-type: disc">A point in a 3D coordinate system</li></ul></div></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec17"/>Identity operators</h4></div></div></div><p>As classes are reference types, it is possible for multiple constants and variables to refer to the same single instance of class behind the scenes. To find out if two constants or variables refer to the same instance of a class exactly, Swift provides the following identity operators:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identical to (<code class="literal">===</code>)</li><li class="listitem" style="list-style-type: disc">Not identical to (<code class="literal">!==</code>)</li></ul></div></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec31"/>Properties</h3></div></div></div><p>Properties associate values with a particular class, structure, or enumeration. Swift enables us to set subproperties of a structure property directly without needing to set the entire object property to a new value. All structures have an automatically generated memberwise initializer, which can be used to initialize the member properties of new structure instances. This is not true for class instances.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec18"/>Property observers</h4></div></div></div><p>Property observers are used to respond to change in a property's value. Property observers are called every time a property's value is set, even if the new value is the same as the property's current value. We have the option to define either or both of the following observers on a property:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">willSet</code> observer is called just before the value is stored</li><li class="listitem" style="list-style-type: disc">The <code class="literal">didSet</code> observer is called immediately after the new value is stored</li></ul></div><p>The <code class="literal">willSet</code> and <code class="literal">didSet</code> observers are not called when a property is set in an initializer before delegation takes place.</p></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec32"/>Methods</h3></div></div></div><p>Methods are functions that are associated with a particular type. Instance methods are functions that are called on an instance of a particular type. Type methods are functions that are called on the type itself.</p><p>The following example presents a class containing a type method that is named as <code class="literal">someTypeMethod()</code>:</p><pre class="programlisting">class AClass {&#13;
    class func someTypeMethod() {&#13;
        // type method body&#13;
    }&#13;
}</pre><p>We can call this method as follows:</p><pre class="programlisting">AClass.someTypeMethod()&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec33"/>Subscripts</h3></div></div></div><p>Subscripts are shortcuts to access the member elements of a collection, list, sequence, or any custom type that implements subscripts. Let's consider the following example:</p><pre class="programlisting">struct TimesTable {&#13;
    let multiplier: Int&#13;
    subscript(index: Int) -&gt; Int {&#13;
        return multiplier * index&#13;
    }&#13;
}&#13;
&#13;
let fiveTimesTable = TimesTable(multiplier: 5)&#13;
print("six times five is \(fiveTimesTable[6])")&#13;
// prints "six times five is 30"&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec34"/>Inheritance</h3></div></div></div><p>A class can inherit methods, properties, and other characteristics from another class:</p><pre class="programlisting">class SomeSubClass: SomeSuperClass&#13;
</pre><p>Swift classes do not inherit from a universal base class. Classes that we define without specifying a superclass automatically become base classes for us to build on. To override a characteristic that would otherwise be inherited, we prefix our overriding definition with the <code class="literal">override</code> keyword. An overridden method, property, or subscript can call the superclass version by calling <code class="literal">super</code>. To prevent overrides, the <code class="literal">final</code> keyword can be used.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec35"/>Initialization</h3></div></div></div><p>The process of preparing an instance of a class, structure, or enumeration for use is called initialization. Classes and structures must set all of their stored properties to an appropriate initial value by the time an instance of that class or structure is created. Stored properties cannot be left in an intermediate state. We can modify the value of a constant property at any point during initialization as long as it is set to a definite value by the time initialization finishes. Swift provides a default initializer for any structure or base class that provides default values for all of its properties and does not provide at least one initializer itself. Let's consider the following example:</p><pre class="programlisting">class ShoppingItem {&#13;
    var name: String?&#13;
    var quantity = 1&#13;
    var purchased = false&#13;
}&#13;
&#13;
var item = ShoppingItem()&#13;
</pre><p>The <code class="literal">struct</code> types automatically receive a memberwise initializer if we do not define any of our own custom initializers, even if the struct's stored properties do not have default values.</p><p>Swift defines two kinds of initializers for class types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Designated initializers</strong>: Methods that are able to fully initialize the object</li><li class="listitem" style="list-style-type: disc"><strong>Convenience initializers</strong>: Methods that rely on other methods to complete initialization</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec36"/>Deinitialization</h3></div></div></div><p>A deinitializer is called immediately before a class instance is deallocated. Swift automatically deallocates instances when they are no longer needed in order to free up resources (ARC).</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec37"/>Automatic Reference Counting</h3></div></div></div><p>Reference counting only applies to instances of classes. Structures and enumerations are value types, not reference types, and are not stored and passed by reference.</p><p>Weak references can be used to resolve strong reference cycles and can be defined as follows:</p><pre class="programlisting">weak var aWeakProperty &#13;
</pre><p>An unowned reference does not keep a strong reference hold on the instance it refers to. Unlike a weak reference, however, an unowned reference is always defined as a non-optional type. A closure capture list can be used to resolve closure strong reference cycles.</p><p>A capture in a closure can be defined as an unowned reference when the closure and the instance that it captures will always refer to each other and be deallocated at the same time.</p><p>A capture as a weak reference can be defined when the capture's reference may become <code class="literal">nil</code> at some point in the future. Weak references are always of an optional type. Let's consider the following example:</p><pre class="programlisting">class AClassWithLazyClosure {&#13;
    lazy var aClosure: (Int, String) -&gt; String = {&#13;
        [unowned self] (index: Int, stringToProcess: String) -&gt; String in&#13;
        // closure body goes here&#13;
        return ""&#13;
    }&#13;
}&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec38"/>Optionals and optional chaining</h3></div></div></div><p>Optionals are Swift types that can have some or none values.
Optional chaining is a process to query and call properties, methods, and subscripts on an optional that might currently be <code class="literal">nil</code>. Optional chaining in Swift is similar to messaging <code class="literal">nil</code> in Objective-C, but in a way that works for any type and can be checked for success or failure. Let's consider the following example:</p><pre class="programlisting">// Optional chaining&#13;
class Residence {&#13;
    var numberOfRooms = 1&#13;
}&#13;
&#13;
class Person {&#13;
    var residence: Residence?&#13;
}&#13;
&#13;
let jeanMarc = Person()&#13;
// This can be used for calling methods and subscripts through optional&#13;
  chaining too&#13;
if let roomCount = jeanMarc.residence?.numberOfRooms {&#13;
    // Use the roomCount&#13;
}&#13;
</pre><p>In this example, we were able to access <code class="literal">numberOfRooms</code>, which was a property of an optional type (<code class="literal">Residence</code>), using optional chaining.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec39"/>Error handling</h3></div></div></div><p>Swift provides support to throw, catch, propagate, and manipulate recoverable errors at runtime.</p><p>Value types should conform to the <code class="literal">ErrorType</code> protocol to be represented as errors. The following example presents some 4xx and 5xx HTTP errors as <code class="literal">enum</code>:</p><pre class="programlisting">enum HttpError: ErrorType {&#13;
    case badRequest&#13;
    case unauthorized&#13;
    case forbidden&#13;
    case requestTimeOut&#13;
    case unsupportedMediaType&#13;
    case internalServerError&#13;
    case notImplemented&#13;
    case badGateway&#13;
    case serviceUnavailable&#13;
}&#13;
</pre><p>We will be able to throw errors using the <code class="literal">throw</code> keyword and mark functions that can throw errors with the <code class="literal">throws</code> keyword.</p><p>We can use a <code class="literal">do-catch</code> statement to handle errors by running a block of code. The following example presents JSON parsing error handling in a <code class="literal">do-catch</code> statement:</p><pre class="programlisting">protocol HttpProtocol{&#13;
    func didRecieveResults(results:NSDictionary)&#13;
}&#13;
&#13;
struct WebServiceManager {&#13;
    var delegate:HttpProtocol?&#13;
    let data: NSData&#13;
    func test() {&#13;
        do {&#13;
            let jsonResult: NSDictionary = try&#13;
              NSJSONSerialization.JSONObjectWithData(self.data,&#13;
              options: NSJSONReadingOptions.MutableContainers) as!&#13;
              NSDictionary&#13;
            self.delegate?.didRecieveResults(jsonResult)&#13;
        } catch let error as NSError {&#13;
            print("json error" + error.localizedDescription)&#13;
        }&#13;
    }&#13;
}&#13;
</pre><p>We can use a <code class="literal">defer</code> statement to execute a set of statements just before code execution leaves the current code block, regardless of how the execution leaves the current block of code.</p></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec40"/>Type casting</h3></div></div></div><p>Type casting is a way to check the type of an instance and/or to deal with that instance as if it is a different superclass or subclass from somewhere else in its class hierarchy. There are two types of operators to check and cast types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Type check operator (<code class="literal">is</code>): This checks whether an instance is of a definite subclass type.</li><li class="listitem" style="list-style-type: disc">Type cast operator (<code class="literal">as</code> and <code class="literal">as?</code>): A constant or variable of a definite class type may refer to an instance of a subclass under the hood. If this is the case, we can try to downcast it to the subclass type with <code class="literal">as</code>.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec41"/>Any and AnyObject</h3></div></div></div><p>Swift provides two special type aliases to work with non-specific types:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AnyObject</code> can represent an instance of any class type</li><li class="listitem" style="list-style-type: disc"><code class="literal">Any</code> can represent an instance of any type, including structs, enumerations, and function types</li></ul></div><p>The <code class="literal">Any</code> and <code class="literal">AnyObject</code> type aliases must be used only when we explicitly require the behavior and capabilities that they provide. Being precise about the types we expect to work with in our code is a better approach than using the <code class="literal">Any</code> and <code class="literal">AnyObject</code> types as they can represent any type and pose dynamism instead of safety. Let's consider the following example:</p><pre class="programlisting">class Movie {&#13;
    var director: String&#13;
    var name: String&#13;
    init(name: String, director: String) {&#13;
        self.director = director&#13;
        self.name = name&#13;
    }&#13;
}&#13;
&#13;
let objects: [AnyObject] = [&#13;
    Movie(name: "The Shawshank Redemption", director: "Frank Darabont"),&#13;
    Movie(name: "The Godfather", director: "Francis Ford Coppola")&#13;
]&#13;
&#13;
for object in objects {&#13;
    let movie = object as! Movie&#13;
    print("Movie: '\(movie.name)', dir. \(movie.director)")&#13;
}&#13;
&#13;
// Shorter syntax&#13;
for movie in objects as! [Movie] {&#13;
    print("Movie: '\(movie.name)', dir. \(movie.director)")&#13;
}&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec42"/>Nested types</h3></div></div></div><p>Enumerations are often created to support a specific class or structure's functionality. Likewise, it can be convenient to declare utility classes and structures purely to use within the context of a complex type.</p><p>Swift enables us to declare nested types whereby we nest supporting enumerations, classes, and structures within the definition of the type that they support. The following example, borrowed from <em>The Swift Programming Language (Swift 3.0)</em> by <em>Apple Inc.,</em> presents nested types:</p><pre class="programlisting">struct BlackjackCard {&#13;
    // nested Suit enumeration&#13;
    enum Suit: Character {&#13;
        case spades = "♠",&#13;
        hearts = "♡",&#13;
        diamonds = "♢",&#13;
        clubs = "♣"&#13;
    }&#13;
 &#13;
    // nested Rank enumeration&#13;
    enum Rank: Int {&#13;
        case two = 2, three, four, five, six, seven, eight, nine, ten&#13;
        case jack, queen, king, ace&#13;
 &#13;
        // nested struct&#13;
        struct Values {&#13;
            let first: Int, second: Int?&#13;
        }&#13;
 &#13;
        var values: Values {&#13;
            switch self {&#13;
            case .ace:&#13;
                return Values(first: 1, second: 11)&#13;
            case .jack, .queen, .king:&#13;
                return Values(first: 10, second: nil)&#13;
            default:&#13;
                return Values(first: self.rawValue, second: nil)&#13;
            }&#13;
        }&#13;
    }&#13;
 &#13;
    let rank: Rank, suit: Suit&#13;
 &#13;
    var description: String {&#13;
        var output = "suit is \(suit.rawValue),"&#13;
        output += " value is \(rank.values.first)"&#13;
        if let second = rank.values.second {&#13;
            output += " or \(second)"&#13;
        }&#13;
        return output&#13;
    }&#13;
}&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec43"/>Extensions</h3></div></div></div><p>Extensions add new functionality to an existing class, structure, or enumeration type. This includes the ability to extend types for which we do not have access to the original source code.</p><p>Extensions in Swift enable us to perform the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Define instance methods and type methods</li><li class="listitem" style="list-style-type: disc">Provide new initializers</li><li class="listitem" style="list-style-type: disc">Define and use new nested types</li><li class="listitem" style="list-style-type: disc">Define subscripts</li><li class="listitem" style="list-style-type: disc">Add computed properties and computed static properties</li><li class="listitem" style="list-style-type: disc">Make an existing type conform to a new protocol</li></ul></div><p>Extensions enable us to add new functionality to a type but we will not be able to override the existing functionality.</p><p>In the following example, we extend <code class="literal">AType</code> by making it conform to two protocols:</p><pre class="programlisting">extension AType: AProtocol, BProtocol {&#13;
}&#13;
</pre><p>The following example presents an extension to <code class="literal">Double</code> by adding computed properties:</p><pre class="programlisting">// Computed Properties&#13;
extension Double {&#13;
    var mm: Double { return self / 1_000.0 }&#13;
    var ft: Double { return self / 3.2884 }&#13;
}&#13;
&#13;
let threeInch = 76.2.mm&#13;
let fiveFeet = 5.ft&#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec44"/>Protocols</h3></div></div></div><p>A <code class="literal">protocol</code> defines signatures or types of methods, properties, and other requirements that fit to a specific task or piece of functionality. The protocol doesn't actually implement any functionality. It only describes what an implementation will look like. A class, structure, or enumeration that provides an actual implementation of requirements can adopt the protocol. Protocols use the same syntax as normal methods but are not allowed to specify default values for method parameters. The <code class="literal">is</code> operator can be used to check whether an instance conforms to a protocol. We can check for protocol conformance only if our protocol is marked with <code class="literal">@objc</code> for classes. The <code class="literal">as</code> operator can be used to cast to a specific protocol.</p><div><div><div><div><h4 class="title"><a id="ch01lvl4sec19"/>Protocols as types</h4></div></div></div><p>Any protocol that we define will become a fully-fledged type to use in our code. We can use a protocol as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A parameter type or return type in a function, method, or initializer</li><li class="listitem" style="list-style-type: disc">The type of a constant, variable, or property</li><li class="listitem" style="list-style-type: disc">The type of items in an array, dictionary, or other container</li></ul></div><p>Let's see the following example:</p><pre class="programlisting">protocol ExampleProtocol {&#13;
    var simpleDescription: String { get }&#13;
    mutating func adjust()&#13;
}&#13;
&#13;
// Classes, enumerations and structs can all adopt protocols.&#13;
class SimpleClass: ExampleProtocol {&#13;
    var simpleDescription: String = "A very simple class example"&#13;
    var anotherProperty: Int = 79799&#13;
 &#13;
    func adjust() {&#13;
        simpleDescription += " Now 100% adjusted..."&#13;
    }&#13;
}&#13;
 &#13;
var aSimpleClass = SimpleClass()&#13;
aSimpleClass.adjust()&#13;
let aDescription = aSimpleClass.simpleDescription&#13;
&#13;
struct SimpleStructure: ExampleProtocol {&#13;
    var simpleDescription: String = "A simple struct"&#13;
    // Mutating to mark a method that modifies the structure - For classes&#13;
      we do not need to use mutating keyword&#13;
    mutating func adjust() {&#13;
        simpleDescription += " (adjusted)"&#13;
    }&#13;
}&#13;
&#13;
var aSimpleStruct = SimpleStructure()&#13;
aSimpleStruct.adjust()&#13;
let aSimpleStructDescription = aSimpleStruct.simpleDescription&#13;
</pre></div><div><div><div><div><h4 class="title"><a id="ch01lvl4sec20"/>Protocol extensions</h4></div></div></div><p>Protocol extensions allow us to define behavior on protocols rather than in each type's individual conformance or global function. By creating an extension on a protocol, all conforming types automatically gain this method implementation without any additional modification. We can specify constraints that conforming types must satisfy before the methods and properties of the extensions are available when we define a protocol extension. For instance, we can extend our <code class="literal">ExampleProtocol</code> to provide default functionality as follows:</p><pre class="programlisting">extension ExampleProtocol {&#13;
    var simpleDescription: String {&#13;
        get {&#13;
            return "The description is: \(self)"&#13;
        }&#13;
        set {&#13;
            self.simpleDescription = newValue&#13;
        }&#13;
    }&#13;
 &#13;
    mutating func adjust() {&#13;
        self.simpleDescription = "adjusted simple description"&#13;
    }&#13;
}&#13;
</pre></div></div><div><div><div><div><h3 class="title"><a id="ch01lvl3sec45"/>Access control</h3></div></div></div><p>Access control restricts access to parts of our code from code in other source files and modules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Public</strong>: This enables entities to be used within any source file from their defining module and also in a source file from another module that imports the defining module</li><li class="listitem" style="list-style-type: disc"><strong>Internal</strong>: This enables entities to be used within any source file from their defining module, but not in any source file outside of this module</li><li class="listitem" style="list-style-type: disc"><strong>Private</strong>: This restricts the use of an entity to its own defining source file</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Summary</h1></div></div></div><p>This chapter started by explaining why functional programming matters, and then it introduced key paradigms in functional programming. Furthermore, it introduced the basics of the Swift programming language with code examples. At this point, we should have a broad view of functional programming concepts and the Swift programming language. All the topics in this chapter will be covered in detail in upcoming chapters.</p><p>We will begin to dive deeper into these topics by functions as they are the most essential building blocks in functional programming. Therefore, the following chapter will explain functions and give examples for pure, first-class, higher-order, and nested functions. Also, it will explain slightly more advanced topics such as memoization, function currying, and composition.</p></div></body></html>