<html><head></head><body><div id="book-content"><div id="sbo-rt-content"><div id="_idContainer126">
			<h1 id="_idParaDest-374" class="chapter-number"><a id="_idTextAnchor474"/>15</h1>
			<h1 id="_idParaDest-375"><a id="_idTextAnchor475"/>Beyond Architecture</h1>
			<p>In this chapter, we are going to go through a few topics that will help engineers build better software. Some of the topics may not be related to software architecture, but consideration of their usage will support and enhance <span class="No-Break">better architectures.</span></p>
			<p>After reading this chapter, engineers should be equipped with a few tricks up their sleeves to boost their productivity and remove impediments when implementing software with a certain architecture style in mind. These tools are Kotlin-related if implemented in code; otherwise, some of them are general <span class="No-Break">engineering utilities.</span></p>
			<p>Hopefully, the conceptual understanding of all the architectural topics in previous chapters can be translated into practical and pragmatic solutions, with the aid of the toolkit in <span class="No-Break">this chapter.</span></p>
			<p>We are going to cover the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>Powered <span class="No-Break">by Kotlin</span></li>
				<li>Transitioning <span class="No-Break">from Java</span></li>
				<li>Continuous integration <span class="No-Break">and delivery</span></li>
				<li>Developer <span class="No-Break">experience matters</span></li>
				<li>Final thoughts on <span class="No-Break">software architecture</span></li>
			</ul>
			<h1 id="_idParaDest-376"><a id="_idTextAnchor476"/>Technical requirements</h1>
			<p>You can find all the code files used in this chapter on <span class="No-Break">GitHub:</span><span class="No-Break"> </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15"><span class="No-Break">https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-15</span></a></p>
			<h1 id="_idParaDest-377"><a id="_idTextAnchor477"/>Powered by Kotlin</h1>
			<p>Kotlin as a programming language has<a id="_idIndexMarker1418"/> provided a lot of syntactic support for engineers to concisely express the intent of their code. Moreover, some of the features allow engineers to separate concerns and organize the code to be <span class="No-Break">more manageable.</span></p>
			<h2 id="_idParaDest-378"><a id="_idTextAnchor478"/>Extension functions</h2>
			<p>Kotlin extension functions<a id="_idIndexMarker1419"/> allow adding extra functionalities to an existing class without modifying its source code. This <a id="_idIndexMarker1420"/>feature is useful and even mandatory for the following <span class="No-Break">use cases:</span></p>
			<ul>
				<li>Add more functions to a class from an external library, or a final class. For example, we want to extract the first letter of each word and join them by a dot, so <strong class="source-inline">Sam Payne</strong> would become <strong class="source-inline">S.P</strong>. The Kotlin String does not provide a function for this, so we can write an extension <span class="No-Break">function instead:</span><pre class="source-code">
fun String.getFirstLetters(): String =
    split(" ").joinToString(".") {
        it.first().toString()
    }</pre></li>				<li>Enhance a class to fit in certain Kotlin language features, such as operator override (<strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, <strong class="source-inline">in</strong>, etc.). The use of operator override will be discussed in detail in <span class="No-Break">coming sections.</span></li>
				<li>Add null safety functions to handle situations such as trying to concatenate a nullable list of strings. Having a nullable receiver as <strong class="source-inline">List&lt;String&gt;?</strong> in the extension function ensures that a string will be created, whether the list is null or not. The implementation is <span class="No-Break">shown here:</span><pre class="source-code">
fun List&lt;String&gt;?.concat(): String = this?.joinToString(",")?: ""</pre></li>			</ul>
			<p>However, there is also a use case that would support better architecture. Extension functions can be used to separate concerns of a class by isolating its functions in a different package with <span class="No-Break">non-public visibility.</span></p>
			<p>For example, we have the <strong class="source-inline">Name</strong> data class from the previous example. This data class is a domain entity that needs to be converted to different formats, depending on the <span class="No-Break">operation’s context.</span></p>
			<p>Given that an object of the <strong class="source-inline">Name</strong> class needs to be converted to a JSON string, there are a few common function <span class="No-Break">signature styles:</span></p>
			<ul>
				<li><strong class="bold">As a member function</strong>: A member function on the <strong class="source-inline">Name</strong> class has exposed the JSON representation of the<a id="_idIndexMarker1421"/> object to <span class="No-Break">all usages:</span><pre class="source-code">
data class Name(val value: String) {
    fun toJson(): String = "{\"name\":\"$value\"}"
}</pre><p class="list-inset">However, not all usages need this function. Business logic is unlikely to need the JSON representation of the object. This approach mixes up the concerns of business logic and external<a id="_idIndexMarker1422"/> representation, and worse, this external representation does not apply to all <span class="No-Break">situations either.</span></p></li>				<li><strong class="bold">As a vanilla function</strong>: As a <a id="_idIndexMarker1423"/>vanilla function, the <strong class="source-inline">toJson</strong> is now public to all projects that have access to the <span class="No-Break"><strong class="source-inline">Name</strong></span><span class="No-Break"> class:</span><pre class="source-code">
fun toJson(name: Name): String = "{\"name\":\"${name.value}\"}"</pre></li>			</ul>
			<p>It is functionally<a id="_idIndexMarker1424"/> equivalent to the <strong class="bold">non-local extension function</strong> implementation; the difference is that the extension function moves the parameter to the <span class="No-Break">function receiver:</span></p>
			<pre class="source-code">
fun Name.toJson(): String = "{\"name\":\"$value\"}"</pre>			<p>The vanilla function implementation creates noise when an engineer searches for functions whose names start with <strong class="source-inline">to</strong>, especially in an IDE and if all data classes have separate <strong class="source-inline">toJson</strong> functions. This<a id="_idIndexMarker1425"/> phenomenon is called <strong class="bold">scope pollution</strong> as we expose functions more than necessary. A quick workaround to this is to have a class or a singleton Kotlin object with a member function <span class="No-Break">for this:</span></p>
			<pre class="source-code">
object NameJsonConverter {
    fun toJson(name: Name): String = "{\"name\":\"${name.value}\"}"
}</pre>			<p>However, if the JSON transformation is only required for external integration, then it may be possible to locate the transformation functions together with the external integration code, and the function<a id="_idIndexMarker1426"/> can be private as a <strong class="bold">local </strong><span class="No-Break"><strong class="bold">extension function</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
private fun Name.toJson(): String = "{\"name\":\"$value\"}"</pre>			<p>This approach allows engineers to extend the functionality of a class while restricting the usage only under the context that is within the same file. In other words, different concerns around an entity can be separated by having local extension functions grouped by files in the <span class="No-Break">source base.</span></p>
			<p>This is nothing new, as a private visibility modifier to a function does exactly that. Nonetheless, the ability to <a id="_idIndexMarker1427"/>put the data class as the receiver of a function and extend its behaviors brings <span class="No-Break">several benefits:</span></p>
			<ul>
				<li>One fewer parameter in <span class="No-Break">the list</span></li>
				<li>Focus on the entity as it becomes <span class="No-Break">the receiver</span></li>
				<li>Call the function as if it were a member of <span class="No-Break">the class</span></li>
				<li>No need <span class="No-Break">for inheritance</span></li>
				<li>Fluent call chaining with other functions that are either member functions or <span class="No-Break">extension functions</span></li>
			</ul>
			<p>Kotlin extension functions enhance the flexibility and readability of your code, by allowing engineers to add new functionalities to existing classes in a modular way. Meanwhile, there is a way to restrict the usage to avoid scope pollution and to separate concerns. After all, Kotlin extension functions promote better coding practices and make code easier to understand <span class="No-Break">and maintain.</span></p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor479"/>Infix modifier</h2>
			<p>A Kotlin infix modifier is another way <a id="_idIndexMarker1428"/>to create more readable and expressive code. We discussed <strong class="bold">behavior-driven development</strong> (<strong class="bold">BDD</strong>) in <a href="B21737_13.xhtml#_idTextAnchor418"><span class="No-Break"><em class="italic">Chapter 13</em></span></a> on the Gherkin language. A Kotlin infix <a id="_idIndexMarker1429"/>modifier enables writing test scenarios in Kotlin that deceptively look like Gherkin. For example, we define an <a id="_idIndexMarker1430"/>empty singleton Kotlin object as <span class="No-Break"><strong class="source-inline">When</strong></span><span class="No-Break"> here:</span></p>
			<pre class="source-code">
object When</pre>			<p>Let us define a <strong class="source-inline">PreCondition</strong> class and an <strong class="source-inline">Action</strong> class related to integer (<strong class="source-inline">Int</strong>) <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
typealias PreCondition = () -&gt; Int
typealias Action = (Int) -&gt; Int</pre>			<p><strong class="bold">Type aliases</strong> in Kotlin allow <a id="_idIndexMarker1431"/>engineers to create a new name for an existing type. They also allow engineers to quickly map a name to a function type. The type alias for a function type is especially beneficial in declaring interfaces of a single function, which helps engineers implement<a id="_idIndexMarker1432"/> code that conforms<a id="_idIndexMarker1433"/> to the <strong class="bold">single-responsibility principle</strong> (<strong class="bold">SRP</strong>), as discussed in <a href="B21737_02.xhtml#_idTextAnchor045"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><span class="No-Break">.</span></p>
			<p>It may still seem puzzling how they can look like Gherkin language for the BDD test scenario at this point. When we add <strong class="source-inline">infix</strong> functions, the code will start to support <span class="No-Break">natural language:</span></p>
			<pre class="source-code">
infix fun When.number(n: Int): PreCondition = { n }
infix fun PreCondition.then(action: Action): Int = action(this())</pre>			<p><strong class="source-inline">PreCondition</strong> here is used as a return type and the receiver of another function. We need an implementation of <strong class="source-inline">Action</strong> and a function to verify the result to complete a simple <span class="No-Break">test scenario:</span></p>
			<pre class="source-code">
object Square: Action {
    override fun invoke(p1: Int): Int = p1 * p1
}
infix fun Int.shouldBe(expected: Int) {
    require(this == expected) {
        "Expected: $expected but was $this"
    }
}</pre>			<p>Putting them all together, we can produce a test scenario <span class="No-Break">like this:</span></p>
			<pre class="source-code">
((When.number(2)).then(Square)).shouldBe(5)</pre>			<p>When running this line, it should throw an exception with the <span class="No-Break">following message:</span></p>
			<pre class="source-code">
Expected: 5 but was 4</pre>			<p>The exciting part of this example is that the infix feature from Kotlin lets us omit the dots for function invocation and the brackets for the single parameter for each infix function. So, the code becomes remarkably close to natural language and the Gherkin <span class="No-Break">language syntax:</span></p>
			<pre class="source-code">
When number 2 then Square shouldBe 5</pre>			<p>Of course, it would take a long time to have a fully-fledged Gherkin-style code for BDD test scenarios from this point beyond. However, this example has demonstrated how Kotlin infix functions can make<a id="_idIndexMarker1434"/> the code readable <span class="No-Break">and expressive.</span></p>
			<p>There are some ground rules for having an infix function in Kotlin <span class="No-Break">to follow:</span></p>
			<ul>
				<li>It is either a member function of a class or an extension function with <span class="No-Break">a receiver</span></li>
				<li>There can only be <span class="No-Break">one parameter</span></li>
			</ul>
			<p>Infix functions are usually used in building<a id="_idIndexMarker1435"/> intuitive and readable <strong class="bold">domain-specific languages</strong> (<strong class="bold">DSLs</strong>). They are used a lot in chaining operations, such as the example we have <span class="No-Break">just demonstrated.</span></p>
			<h2 id="_idParaDest-380"><a id="_idTextAnchor480"/>Operator override</h2>
			<p>The operator override is another <a id="_idIndexMarker1436"/>way to make your code readable and intuitive. It allows engineers to define custom <a id="_idIndexMarker1437"/>behaviors for operators such as <strong class="source-inline">+</strong>, <strong class="source-inline">-</strong>, and so on. The syntax was already shown previously when we discussed <span class="No-Break">extension functions:</span></p>
			<pre class="source-code">
data class Name(val value: String)
operator fun Name.plus(other: Name): Name =
    Name("$value ${other.value}")
fun main() { println(Name("Sam") + Name("Payne")) }</pre>			<p>The <strong class="source-inline">operator</strong> modifier before the <strong class="source-inline">fun</strong> keyword indicates the intention to override a built-in operator. The return type needs to be the same as the receiver or the belonging class. All operators that<a id="_idIndexMarker1438"/> can be overridden are listed in <span class="No-Break"><em class="italic">Table 15.1</em></span><span class="No-Break">:</span></p>
			<table id="table001-5" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Operator</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Function name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Example</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
+</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
plus</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a + b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
+</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
unaryPlus</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
+a</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
-</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
minus</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a - b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
-</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
unaryMinus</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
-a</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
*</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
times</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a * b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
/</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
div</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a / b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
%</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
rem</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a % b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
==</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
equals</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a == b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
!=</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
notEquals</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a != b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
&gt;</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
compareTo</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a &gt; b</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
[]</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
get</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
val value = a[key]</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
[]</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
set</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a[key] = value</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
+</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
unaryPlus</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
+a</pre>						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<pre class="source-code">
()</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
invoke</pre>						</td>
						<td class="No-Table-Style">
							<pre class="source-code">
a()</pre>						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.1 – Kotlin operators that can be overridden</p>
			<p>It is important that operators are overridden with compatible semantics. For example, the <strong class="source-inline">+</strong> operator should create <a id="_idIndexMarker1439"/>a new instance of the type with the two objects of the same type combined. If the <strong class="source-inline">plus</strong> function has side effects such as updating the value of an existing object, then it is not appropriate to override <span class="No-Break">the operator.</span></p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor481"/>Scoping functions</h2>
			<p>Scoping functions in Kotlin execute a<a id="_idIndexMarker1440"/> block of code within the context of an object. A scope starts with an opening curly bracket, <strong class="source-inline">{</strong>, and ends with a closing curly bracket, <strong class="source-inline">}</strong>, which is already natural to programming languages. We already have class scopes, function scopes, and lambda scopes, all of which use curly brackets to indicate the boundaries. Also, the inner scopes have visibility and access to the declared values and functions from the enclosing scopes. For example, a member function has access to other<a id="_idIndexMarker1441"/> functions from its <span class="No-Break">encompassing class.</span></p>
			<h3>Built-in scoping functions</h3>
			<p>Scoping functions in Kotlin <a id="_idIndexMarker1442"/>provide another means to have a confined scope that focuses on a context object. There are five scoping functions provided, as shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B21737_15_1.jpg" alt="Figure 15.1 – Kotlin built-in scoping functions" width="1661" height="731"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.1 – Kotlin built-in scoping functions</p>
			<p>Each of the five scoping functions (<strong class="source-inline">let</strong>, <strong class="source-inline">apply</strong>, <strong class="source-inline">run</strong>, <strong class="source-inline">with</strong>, and <strong class="source-inline">also</strong>) has its own use case and behavior. There are two main differences among them. The first difference is whether the context object is <strong class="source-inline">it</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">this</strong></span><span class="No-Break">.</span></p>
			<p>The following three statements return the same result <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"35"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
"3".let { it + "5" }
"3".run { this + "5" }
with("3") { this + "5" }</pre>			<p>The <strong class="source-inline">let</strong> function uses <strong class="source-inline">it</strong> as the context object, while <strong class="source-inline">run</strong> and <strong class="source-inline">with</strong> use <strong class="source-inline">this</strong> as the <span class="No-Break">context object.</span></p>
			<p>It is also noticeable that <strong class="source-inline">run</strong> and <strong class="source-inline">with</strong> are functionally equivalent, but the syntax is different. The <strong class="source-inline">run</strong> function is an extension function, while <strong class="source-inline">with</strong> is a top-level function. Engineers can make use of the <a id="_idIndexMarker1443"/>difference to communicate the intent of the usage. Typically, the context object is the focus of the operation when using the <strong class="source-inline">run</strong> function. If another object is the focus of the operation, the <strong class="source-inline">with</strong> function can be <span class="No-Break">used instead.</span></p>
			<p>The second difference is whether the result of the lambda or the receiver is returned. This is like a peeking function where engineers want to insert an extra operation but do not want to alter the result. The following two statements return the same result <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">"3"</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
    "3".also { println(it) }
    "3".apply { println(this) }</pre>			<p>Any output evaluated in the lambda expressions is not used as <span class="No-Break">return values.</span></p>
			<h3>Custom scoping functions</h3>
			<p>Writing your own scoping<a id="_idIndexMarker1444"/> functions can bring powerful features to your system. It is particularly useful in building up a result within a predefined scope. It is often that a system is required to perform a full validation on an incoming request and report all validation failures in <span class="No-Break">the response.</span></p>
			<p>We need a builder class that can accumulate validation errors, as <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
class ValidationBuilder {
    private val failures = mutableListOf&lt;String&gt;()
    fun evaluate(
        result: Boolean,
        failureMessage: () -&gt; String
    ) {
        if (!result) failures.add(failureMessage())
    }
    fun getErrors() = failures.toList()
}</pre>			<p>The <strong class="source-inline">ValidationBuilder</strong> class uses a mutable list of String to collect all validation errors found in the process. Then, we <a id="_idIndexMarker1445"/>can define a custom scoping function that defines the start and the end of the validation, and validation is performed within <span class="No-Break">the scope:</span></p>
			<pre class="source-code">
fun &lt;T&gt; T.validate(
    build: ValidationBuilder.(T) -&gt; Unit
): List&lt;String&gt; =
    ValidationBuilder()
        .also { builder -&gt; builder.build(this) }
        .getErrors()</pre>			<p>This scoping function is an extension function using a generic type as the receiver, so the <strong class="source-inline">validate</strong> function can be invoked on any object. It takes a lambda expression as a parameter, in which an instance of <strong class="source-inline">ValidationBuilder</strong> is passed as a context object identified by <strong class="source-inline">this</strong>. At the end of the <strong class="source-inline">validate</strong> function, all errors collected are returned as an <span class="No-Break">immutable </span><span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break">.</span></p>
			<p>An example usage can look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
fun main() {
    val failures = "Some very%long nickname".validate {
        evaluate(it.length &lt; 20) { "Must be under 20 characters: \"$it\"" }
        evaluate(it.contains("%").not()) { "Must not contains % character"}
    }
    println("failures: $failures")
}</pre>			<p>This is a simple validation on a <strong class="source-inline">String</strong> object with <span class="No-Break">two rules:</span></p>
			<ul>
				<li>Must be less than <span class="No-Break">20 characters</span></li>
				<li>Must not contain the percent <span class="No-Break">sign, </span><span class="No-Break"><strong class="source-inline">%</strong></span></li>
			</ul>
			<p>The validation starts<a id="_idIndexMarker1446"/> with the <strong class="source-inline">String</strong> object with the <strong class="source-inline">validate</strong> extension function. Inside the lambda scope, the <strong class="source-inline">evaluate</strong> function is called twice with the evaluations and the error messages. <strong class="source-inline">ValidationBuilder</strong> collects error messages if the evaluation has failed. A list of validation errors is returned and printed to the console. The console should have the <span class="No-Break">following output:</span></p>
			<pre class="console">
failures: [Must be under 20 characters: "Some very%long nickname", Must not contains % character]</pre>			<p>The output has shown how full validation can be performed on a string with the custom <span class="No-Break">scoping function.</span></p>
			<p>Custom scoping functions are also popular with complex object building, such as a large domain object. In fact, it is <a id="_idIndexMarker1447"/>used in the popular framework <strong class="bold">Ktor</strong> to build the server-side <span class="No-Break">routing configuration:</span></p>
			<pre class="source-code">
routing {
    route("/hello", HttpMethod.Get) {
        handle {
            call.respondText("Hello")
        }
    }
}</pre>			<p>We have demonstrated the use of a custom scoping function to perform full validation and collect all validation errors. Custom scoping functions are particularly useful in collecting elements within the scope, with the builder passed in as a <span class="No-Break">context object.</span></p>
			<p>We are going to cover the topic of transitioning from Java to Kotlin in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-382"><a id="_idTextAnchor482"/>Transitioning from Java</h1>
			<p>Kotlin as a programming language was developed by JetBrains, a software company known for software development tools such as IntelliJ IDEA. The project started in 2010 and it aimed to create a language that is compatible with Java but with improvements over some of the <a id="_idIndexMarker1448"/>drawbacks of Java. The name <em class="italic">Kotlin</em> comes from Kotlin Island in the Baltic Sea near St. <span class="No-Break">Petersburg, Russia.</span></p>
			<p>Kotlin 1.0 was released in July 2011 with features such as null safety, static typing, and type inference. It started to gain popularity in 2016 when it introduced features such as 100% Java interoperability, extension functions, lambda expressions, and <span class="No-Break">higher-order functions.</span></p>
			<p>In 2017, Google announced official support for Kotlin on Android. Google’s collaboration with JetBrains on Kotlin supporting Android has made Kotlin a popular choice for Android developers. In 2018, JetBrains introduced Kotlin Multiplatform, which enables Kotlin code to be translated and compiled to run in Android, iOS, and web applications. Around the same time, Kotlin for backend services gained more and more attention from backend engineers, especially those with a <span class="No-Break">Java background.</span></p>
			<p>The 100% Java interoperability has enabled many Java engineers to smoothly transition to writing Kotlin code for commercial applications. There are a few tools and tips that we are going to share <span class="No-Break">with you.</span></p>
			<p>The IntelliJ IDEs from JetBrains have provided a tool to convert a Java file code to a Kotlin file code. It might sound magical, but the reality is that there are still a couple more adjustments needed to be truly <span class="No-Break">idiomatic Kotlin.</span></p>
			<h2 id="_idParaDest-383"><a id="_idTextAnchor483"/>Enabling Kotlin in a Java project</h2>
			<p>Given that there is a <a id="_idIndexMarker1449"/>Java project already, we need to set up the project to compile Kotlin <span class="No-Break">source code.</span></p>
			<p>If the project uses Gradle, adding a Kotlin plugin is sufficient, such as the following code with Gradle <span class="No-Break">Kotlin DSL:</span></p>
			<pre class="source-code">
plugins {
    kotlin("jvm") version "2.0.20"
}</pre>			<p>This is the equivalent of the setting with <span class="No-Break">Gradle Groovy:</span></p>
			<pre class="source-code">
plugins {
    id 'org.jetbrains.kotlin.jvm' version '2.0.20'
}</pre>			<p>Projects using Maven<a id="_idIndexMarker1450"/> would require the following changes <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">pom.xml</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
&lt;properties&gt;
    &lt;kotlin.version&gt;2.0.20&lt;/kotlin.version&gt;
&lt;/properties&gt;
&lt;plugins&gt;
    &lt;plugin&gt;
        &lt;artifactId&gt;kotlin-maven-plugin&lt;/artifactId&gt;
        &lt;groupId&gt;org.jetbrains.kotlin&lt;/groupId&gt;
        &lt;version&gt;2.0.20&lt;/version&gt;
    &lt;/plugin&gt;
&lt;/plugins&gt;</pre>			<p>The preceding configuration defines the Kotlin version as <strong class="source-inline">2.0.20</strong>. Also, it imports a plugin that enables the compilation of Kotlin <span class="No-Break">source code.</span></p>
			<h2 id="_idParaDest-384"><a id="_idTextAnchor484"/>Converting Java files and moving them to Kotlin folders</h2>
			<p>Kotlin files can be<a id="_idIndexMarker1451"/> located under the <strong class="source-inline">src/main/java</strong> and <strong class="source-inline">src/test/java</strong> folders, but it is recommended to have them stored under <strong class="source-inline">src/main/kotlin</strong> and <span class="No-Break"><strong class="source-inline">src/test/kotlin</strong></span><span class="No-Break">, respectively.</span></p>
			<p>Let us convert the <a id="_idIndexMarker1452"/>following Java class to Kotlin, using IntelliJ’s <span class="No-Break">conversion tool:</span></p>
			<pre class="source-code">
public class Household {
    private final String name;
    private final List&lt;String&gt; members = new ArrayList&lt;&gt;();
    public Household(String name, List&lt;String&gt; members) {
        this.name = name;
        this.members.addAll(members);
    }
    public String getName() {
        return name;
    }
    public List&lt;String&gt; getMembers() {
        return new ArrayList(members);
    }
}</pre>			<p>This Java class is immutable, so all fields<a id="_idIndexMarker1453"/> are private, and the list is not exposed in the getter for immutability. As <a id="_idIndexMarker1454"/>you convert the Java file using the conversion tool, IntelliJ reminds you that some corrections still need to <span class="No-Break">be made.</span></p>
			<p>This is the Kotlin class after conversion by the tool (in IntelliJ, right-click the Java file and choose <strong class="bold">Convert Java File to </strong><span class="No-Break"><strong class="bold">Kotlin File</strong></span><span class="No-Break">):</span></p>
			<pre class="source-code">
class Household(val name: String, members: List&lt;String?&gt;) {
    private val members: MutableList&lt;String?&gt; = ArrayList()
    init {
        this.members.addAll(members)
    }
    fun getMembers(): List&lt;String?&gt; {
        return ArrayList&lt;Any?&gt;(members)
    }
}</pre>			<p>There are some immediate changes to be made to become an idiomatic <span class="No-Break">Kotiln class:</span></p>
			<ol>
				<li>Update to a Kotlin data class since this class is intended to be an <span class="No-Break">entity class.</span></li>
				<li>Replace the <strong class="source-inline">init</strong> block with a constructor as much as possible. Only true initialization logic should remain in the <span class="No-Break"><strong class="source-inline">init</strong></span><span class="No-Break"> block.</span></li>
				<li>Use Kotlin’s immutable <strong class="source-inline">List</strong> interface as a member field. The same should apply to other <strong class="source-inline">Collection</strong> interfaces. Using Kotlin’s collection interfaces closes off the risks of the <a id="_idIndexMarker1455"/>collection <span class="No-Break">being mutated.</span></li>
				<li>Remove the <strong class="source-inline">getMembers</strong> getter function as there is no need to return a new copy of the list due to the immutable <span class="No-Break"><strong class="source-inline">List</strong></span><span class="No-Break"> interface.</span></li>
				<li>Remove the nullable<a id="_idIndexMarker1456"/> symbol (<strong class="source-inline">?</strong>) unless there is a reason to expect nullable values. This is an opportunity for engineers to eliminate null checks that become unnecessary after converting <span class="No-Break">to Kotlin.</span></li>
			</ol>
			<p>This is the result of the conversion, which started with the tool and ended with some <span class="No-Break">manual corrections:</span></p>
			<pre class="source-code">
data class Household(val name: String, val members: List&lt;String&gt;)</pre>			<p>If the Java entity class was using an external library <a id="_idIndexMarker1457"/>such as Lombok (<a href="https://projectlombok.org/">https://projectlombok.org/</a>) to auto-generate setter and getter functions, then we would need to remove the Lombok <span class="No-Break">annotations, too.</span></p>
			<p>Java 14 has introduced a<a id="_idIndexMarker1458"/> new feature called <strong class="bold">record classes</strong> that work like Kotlin data classes. An example of a Java record class is <span class="No-Break">shown here:</span></p>
			<pre class="source-code">
public record Account(String number, String holderName) {}</pre>			<p>Converting it to Kotlin is relatively straightforward, but there is a <strong class="source-inline">JvmRecord</strong> annotation <span class="No-Break">that remains:</span></p>
			<pre class="console">
@JvmRecord
data class Account(val number: String, val holderName: String)</pre>			<p>The annotation is only there to preserve some of the function names such as <strong class="source-inline">account.getNumber()</strong> for backward <a id="_idIndexMarker1459"/>compatibility reasons. If this is not a concern, we can remove this annotation and let <a id="_idIndexMarker1460"/>users of this class use <span class="No-Break"><strong class="source-inline">account.number</strong></span><span class="No-Break"> instead.</span></p>
			<h2 id="_idParaDest-385"><a id="_idTextAnchor485"/>Idiomatic expressions, code styling, and conventions</h2>
			<p>Converting a Java file to a Kotlin file is a great opportunity for engineers to start adopting Kotlin’s idiomatic expressions <a id="_idIndexMarker1461"/>and conventions. It is highly recommended that the engineers pick a lint tool to unify the Kotlin style from <span class="No-Break">the beginning:</span></p>
			<ul>
				<li><span class="No-Break">Ktlint (</span><a href="https://github.com/pinterest/ktlint"><span class="No-Break">https://github.com/pinterest/ktlint</span></a><span class="No-Break">)</span></li>
				<li><span class="No-Break">KtFmtFormat (</span><a href="https://github.com/facebook/ktfmt"><span class="No-Break">https://github.com/facebook/ktfmt</span></a><span class="No-Break">)</span></li>
				<li>Detekt (<a href="https://github.com/detekt/detekt">https://github.com/detekt/detekt</a>) – also a static code <span class="No-Break">analysis tool</span></li>
				<li>Spotless (<a href="https://github.com/diffplug/spotless">https://github.com/diffplug/spotless</a>) – also supports <span class="No-Break">other languages</span></li>
			</ul>
			<p>Picking the “best” code style is the least concern to engineering quality, but having a unified style is important for the team to focus on more important aspects such as correctness <span class="No-Break">and responsiveness.</span></p>
			<h2 id="_idParaDest-386"><a id="_idTextAnchor486"/>Sequence of conversion</h2>
			<p>Given an existing Java project, it is also<a id="_idIndexMarker1462"/> recommended to convert Java classes in the <span class="No-Break">following sequence:</span></p>
			<ol>
				<li>Test classes as these represent the lowest risk. This is a safe space for engineers to learn Kotlin and make mistakes with a <span class="No-Break">low impact.</span></li>
				<li>Top-level classes that no other classes <span class="No-Break">depend on.</span></li>
				<li>If the application uses layered architectures, as covered in <a href="B21737_07.xhtml#_idTextAnchor255"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, classes in the outer layers (i.e., adapters, imperative shells, frameworks, and drivers) should be converted first, then go inward until reaching the code. The Kotlin interoperability with Java is smoother when Kotlin code calls Java code than <span class="No-Break">vice versa.</span></li>
			</ol>
			<p>During the conversion, engineers <a id="_idIndexMarker1463"/>often start looking to replace frameworks in Java with equivalent libraries in Kotlin; we are going to discuss these in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-387"><a id="_idTextAnchor487"/>Framework replacement</h2>
			<p>During the conversion journey, it is inevitable<a id="_idIndexMarker1464"/> that someone will bring up the discussion of whether a Java library should be replaced by another library that supports native Kotlin. We discussed the paradox of new frameworks in <a href="B21737_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, and on the specific topic of conversion from Java to Kotlin, there are a few things we should keep <span class="No-Break">in mind:</span></p>
			<ul>
				<li>Everything still works! It seems obvious but the team could choose not to replace any existing framework, due to the 100% <span class="No-Break">Java interoperability.</span></li>
				<li>This is likely a one-way trip. The new Kotlin library may not aim to support Java projects, except those libraries that already existed before Kotlin became popular. If the project still uses Java but needs to use the new Kotlin library with Java, the usage may <span class="No-Break">be awkward.</span></li>
				<li>There are multiple Kotlin libraries that the open source community has contributed to provide a Kotlin-first library experience. Some of them look similar in terms of approaches, activities, and number of contributors. The team may fall into the paralysis of analysis, not knowing which one to use. This is more of a general open source framework adoption concern, but it affects transitioning from Java <span class="No-Break">to Kotlin.</span></li>
				<li>It is not uncommon for contributors to stop some of the efforts for Kotlin-first newer frameworks. It is a natural evolution where some of the ideas have turned out to be not so viable or feasible. The team can always wait till the Kotlin-first library matures. Again, this is a concern for open source projects <span class="No-Break">in general.</span></li>
				<li>Some of the existing Java frameworks have Kotlin support as an extra dependency to help engineers with the transition. The Kotlin module may just be enough and there is no need to phase out the <span class="No-Break">framework altogether.</span></li>
				<li>Kotlin-first frameworks <a id="_idIndexMarker1465"/>developed by popular communities or reputable organizations supporting Kotlin are likely to have stronger support <span class="No-Break">and continuity.</span></li>
			</ul>
			<p>Despite the numerous factors for framework replacement, there are a few Kotlin-first frameworks that are worth <span class="No-Break">a look:</span></p>
			<ul>
				<li><strong class="bold">Client and </strong><span class="No-Break"><strong class="bold">server frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Spring: </span><a href="https://spring.io/"><span class="No-Break">https://spring.io/</span></a></li><li><span class="No-Break">Ktor: </span><a href="https://ktor.io/"><span class="No-Break">https://ktor.io/</span></a></li><li><span class="No-Break">Http4K: </span><a href="https://www.http4k.org/"><span class="No-Break">https://www.http4k.org/</span></a></li><li><span class="No-Break">Micronaut: </span><a href="https://micronaut.io/"><span class="No-Break">https://micronaut.io/</span></a></li><li><span class="No-Break">Vert.x: </span><a href="https://github.com/vert-x3/vertx-lang-kotlin"><span class="No-Break">https://github.com/vert-x3/vertx-lang-kotlin</span></a></li><li><span class="No-Break">Retrofit: </span><a href="https://square.github.io/retrofit/"><span class="No-Break">https://square.github.io/retrofit/</span></a></li></ul></li>
				<li><strong class="bold">Language </strong><span class="No-Break"><strong class="bold">enhancement frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Arrow: </span><a href="https://arrow-kt.io/"><span class="No-Break">https://arrow-kt.io/</span></a></li><li><span class="No-Break">Result4K: </span><a href="https://github.com/npryce/result4k"><span class="No-Break">https://github.com/npryce/result4k</span></a></li><li><span class="No-Break">Coroutines: </span><a href="https://github.com/Kotlin/kotlinx.coroutines"><span class="No-Break">https://github.com/Kotlin/kotlinx.coroutines</span></a></li></ul></li>
				<li><strong class="bold">Dependency </strong><span class="No-Break"><strong class="bold">injection frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Koin: </span><a href="https://insert-koin.io/"><span class="No-Break">https://insert-koin.io/</span></a></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Persistence frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Exposed: </span><a href="https://github.com/JetBrains/Exposed"><span class="No-Break">https://github.com/JetBrains/Exposed</span></a></li></ul></li>
				<li><span class="No-Break"><strong class="bold">Testing frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Kotest: </span><a href="https://kotest.io/"><span class="No-Break">https://kotest.io/</span></a></li><li><span class="No-Break">Spek: </span><a href="https://www.spekframework.org/"><span class="No-Break">https://www.spekframework.org/</span></a></li><li><span class="No-Break">Mockk: </span><a href="https://mockk.io/"><span class="No-Break">https://mockk.io/</span></a></li></ul></li>
				<li><span class="No-Break"><strong class="bold">UI frameworks</strong></span><span class="No-Break">:</span><ul><li><span class="No-Break">Jetpack: </span><a href="https://developer.android.com/jetpack"><span class="No-Break">https://developer.android.com/jetpack</span></a></li><li>Compose <a id="_idIndexMarker1466"/><span class="No-Break">Multiplatform: </span><a href="https://github.com/JetBrains/compose-multiplatform"><span class="No-Break">https://github.com/JetBrains/compose-multiplatform</span></a></li></ul></li>
			</ul>
			<h2 id="_idParaDest-388"><a id="_idTextAnchor488"/>Continuous transition</h2>
			<p>One of the challenges of <a id="_idIndexMarker1467"/>transitioning to Kotlin is the combination with other changes, driven by business or <span class="No-Break">technical stakeholders.</span></p>
			<p>It is important that the transition to Kotlin takes place incrementally and continuously. For example, a new business feature can be written in Kotlin entirely, with some usage of existing <span class="No-Break">Java classes.</span></p>
			<p>Engineers can also phase in Kotlin converted code when there is sufficient time and space, even during the development of other changes. The team can adopt a policy that, if a Java class needs to be updated, it is also converted to Kotlin. This policy adds a small overhead to each change, but it keeps the transition going without the need <span class="No-Break">to halt.</span></p>
			<p>Keeping risks manageable is the key to transitioning a Java project <span class="No-Break">to Kotlin.</span></p>
			<h2 id="_idParaDest-389"><a id="_idTextAnchor489"/>The future of Kotlin</h2>
			<p>Kotlin has grown out from being a<a id="_idIndexMarker1468"/> better Java. Especially with Kotlin Multiplatform, Kotlin has become one of the most versatile programming languages in the market, as it can be used to write Android, iOS, desktop, web, data science, and backend applications. With the recent Kotlin V2 release, Kotlin continues to grow in popularity and usage. Engineers should keep an eye on Kotlin’s emerging trends (e.g., Kotlin Multiplatform, Kotlin Native, and cloud integration) and embrace its exciting <span class="No-Break">upcoming progression.</span></p>
			<p>Next, we will discuss continuous integration <span class="No-Break">and delivery.</span></p>
			<h1 id="_idParaDest-390"><a id="_idTextAnchor490"/>Continuous integration and delivery</h1>
			<p><strong class="bold">Continuous integration</strong> (<strong class="bold">CI</strong>) and <strong class="bold">continuous delivery</strong> (<strong class="bold">CD</strong>) play a crucial role in software development productivity. They are collectively named <strong class="bold">CI/CD</strong> in many discussions due to their <span class="No-Break">close relationship.</span></p>
			<p>When we discussed the cost of finding and fixing an issue with an application in <a href="B21737_13.xhtml#_idTextAnchor418"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, we mentioned that the<a id="_idIndexMarker1469"/> cost to fix an issue is lower if it is found earlier in the development process. In a typical environment in which a team of engineers work collaboratively on a source repository, it is also less expensive to fix an issue that is caused by code conflicts from <span class="No-Break">this collaboration.</span></p>
			<p>CI is a software development practice in which engineers frequently integrate their changes into a shared source repository. The primary goal of CI is to detect integration issues early and reduce the time it takes to release new features or fixes. The practice of CI includes <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Frequent commits</strong>: Changes are frequently committed by multiple engineers in a team. Each engineer also frequently updates their local source project to receive changes from other team members. The commits are as frequent as multiple times <span class="No-Break">a day.</span></li>
				<li><strong class="bold">Automated project builds</strong>: Each commit integrates with the source repository and triggers an automated build to compile all <span class="No-Break">source code.</span></li>
				<li><strong class="bold">Automated testing and feedback</strong>: Each commit also triggers an automated test suite that includes a diverse variety of tests and quality assurance metrics, as discussed in <em class="italic">Chapters 12</em>, <em class="italic">13</em>, <span class="No-Break">and </span><span class="No-Break"><em class="italic">14</em></span><span class="No-Break">:</span><ul><li><span class="No-Break">Unit tests</span></li><li><span class="No-Break">Component tests</span></li><li><span class="No-Break">Integration tests</span></li><li>Automated <span class="No-Break">GUI testing</span></li><li><span class="No-Break">End-to-end testing</span></li><li><span class="No-Break">Performance testing</span></li><li>Code <span class="No-Break">vulnerability scanning</span></li><li>Code <span class="No-Break">style linting</span></li><li>Static <span class="No-Break">code analysis</span></li><li>Code coverage <span class="No-Break">by tests</span></li></ul><p class="list-inset">These test checks are part of the project build after code compilation. If any of the preceding checks fails the <a id="_idIndexMarker1470"/>verification, the project build will fail and engineers will be notified. Engineers will then troubleshoot and fix the issue based on <span class="No-Break">the feedback.</span></p></li>
				<li><strong class="bold">Version control</strong>: CI uses a version control system to manage the code base. It supports keeping a full history of commits with audit records. It allows engineers to branch from the main code repository and later merge the branch back to the <span class="No-Break">main branch.</span></li>
				<li><strong class="bold">Integration with deployment</strong>: CI is the first gate of quality that certifies whether an application is good enough for deployment. Once all checks and tests have passed, then the build process can continue the preparation <span class="No-Break">for deployment.</span></li>
			</ul>
			<p>By shortening the feedback loop of <em class="italic">code-integrate-test-fix</em>, the team can deliver new features and fixes more frequently, reduce the time to market, and respond to user feedback quickly. It also improves the collaboration within the team and improves overall software quality through automated testing for <span class="No-Break">each integration.</span></p>
			<p>There is, however, another significant factor that would affect software development productivity. Most engineers who work in a team would have discussed the topic of branching strategies under a version control system. There are two popular strategies that keep on recurring in this never-ending debate: feature-based and <span class="No-Break">trunk-based development.</span></p>
			<h2 id="_idParaDest-391"><a id="_idTextAnchor491"/>Feature-based development</h2>
			<p>Feature-based development can be <a id="_idIndexMarker1471"/>characterized by its<a id="_idIndexMarker1472"/> higher number and longer life of branches. Engineers can work in on their own branch in isolation. Each branch contains a big chunk of cohesive work, such as a feature or a release, and therefore, it lasts for a long period to gather all the changes required. At the same time, there are other long-lived branches<a id="_idIndexMarker1473"/> that represent other features. An example of feature-based development is shown in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.2</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B21737_15_2.jpg" alt="Figure 15.2 – An example of feature-based development" width="1650" height="550"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.2 – An example of feature-based development</p>
			<p>In this example, <strong class="bold">Trunk</strong> is the main branch that absorbs all changes from other branches. <strong class="bold">Feature 1</strong> branches out from <strong class="bold">Trunk</strong> and development continues in this feature branch. At the same time, the team needs to prepare a new release, so the <strong class="bold">Release 1</strong> branch is created from <strong class="bold">Trunk</strong>. The release branch is deployed to the UAT environment for acceptance testing as a <span class="No-Break">release candidate.</span></p>
			<p>After a few commits in the <strong class="bold">Feature 1</strong> branch, <strong class="bold">Feature 2</strong> needs to start development and it needs to make <a id="_idIndexMarker1474"/>some changes from the <strong class="bold">Feature 1</strong> branch, so <strong class="bold">Feature 2</strong> branches out from the <strong class="bold">Feature 1</strong> branch, and the development of <strong class="bold">Feature 2</strong> continues in the new branch. <strong class="bold">Feature 1</strong> development is completed, so, a pull request is created for review, and subsequently, the branch is merged <span class="No-Break">into </span><span class="No-Break"><strong class="bold">Trunk</strong></span><span class="No-Break">.</span></p>
			<p>Engineers working on <strong class="bold">Feature 2</strong> want to keep its branch up to date, so they rebase the <strong class="bold">Feature 2</strong> branch from the latest <strong class="bold">Trunk</strong>. The <strong class="bold">Release 1</strong> branch does not need to rebase because <strong class="bold">Feature 1</strong> is not included in the <span class="No-Break">coming release.</span></p>
			<p>The <strong class="bold">Release 1</strong> branch has been deployed to production. There are a couple of bugs found after the production release, and unfortunately, one of them is a critical bug. So the <strong class="bold">Release 1</strong> branch cannot be merged into <strong class="bold">Trunk</strong> yet. While some engineers work on the lower priority fixes in the <strong class="bold">Release 1</strong> branch, a few engineers need to work on a hotfix immediately and fix the critical bug in the production environment. So, a hotfix branch is created for the critical <span class="No-Break">bug fix.</span></p>
			<p>The critical bug fix has been completed, deployed, and verified in UAT. So, it is released to the production environment. The hotfix branch is then merged into the <strong class="bold">Release 1</strong> branch. Afterward, all production bug fixes are completed, deployed, and verified in UAT. So, there is another production release to wrap up this release. The <strong class="bold">Release 1</strong> branch is then merged <span class="No-Break">into </span><span class="No-Break"><strong class="bold">Trunk</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="bold">Feature 2</strong> branch is not completed yet, so it needs to be rebased from <strong class="bold">Trunk</strong>. At the same time, engineers <a id="_idIndexMarker1475"/>start to prepare a new release by creating a new release branch <span class="No-Break">from </span><span class="No-Break"><strong class="bold">Trunk</strong></span><span class="No-Break">.</span></p>
			<p>Feature-based development isolates <a id="_idIndexMarker1476"/>branches and keeps them focused on their purposes. The <strong class="bold">Release 1</strong> branch in the example has naturally prevented <strong class="bold">Feature 1</strong> from affecting the release. Also, the hotfix branch gives engineers a stable and safe space to concentrate on fixing the critical production bug, knowing that the critical fix can be patched as a priority without needing to consider other unrelated changes. Feature-based development uses pull requests that encourage code review and collaboration <span class="No-Break">among engineers.</span></p>
			<p>However, numerous long-lived branches bring the overhead of branch management. It introduces a high complexity of conflicts when merging or rebasing branches. This is particularly bad when there is substantial refactoring such as moving a file to another folder in one branch while the file is updated in another branch. This type of tree conflict often results in complex, time-consuming, and error-prone code merges. The mitigation of this issue is to rebase long-living <span class="No-Break">branches frequently.</span></p>
			<h2 id="_idParaDest-392"><a id="_idTextAnchor492"/>Trunk-based development</h2>
			<p>Trunk-based development encourages<a id="_idIndexMarker1477"/> engineers to work on a single branch, which is <em class="italic">Trunk</em> (also known as <strong class="bold">main</strong>). However, each<a id="_idIndexMarker1478"/> commit to the <em class="italic">Trunk</em> branch is done by merging from short-lived branches as <span class="No-Break">pull requests.</span></p>
			<p>It advocates small, frequent, and<a id="_idIndexMarker1479"/> incremental changes to be committed to <em class="italic">Trunk</em> frequently. Each branch is short-lived and usually does not last more than a few days. There are frequent rebase or merge operations for each branch to get the latest changes from <em class="italic">Trunk</em>. An example of trunk-based development is illustrated in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.3</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B21737_15_3.jpg" alt="Figure 15.3 – An example of trunk-based development" width="1585" height="456"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.3 – An example of trunk-based development</p>
			<p>In this example, the <strong class="bold">Feature 1</strong> branch is created from <strong class="bold">Trunk</strong> for development. The <strong class="bold">Feature 2</strong> branch is also created from <strong class="bold">Trunk</strong> <span class="No-Break">for development.</span></p>
			<p>The <strong class="bold">Feature 1</strong> branch has<a id="_idIndexMarker1480"/> developed the code to a milestone where it is tested, verified, and releasable, but the feature itself is not completed. So, a pull request for <strong class="bold">Feature 1</strong> is created for review, and subsequently, the branch is merged <span class="No-Break">into </span><span class="No-Break"><strong class="bold">Trunk</strong></span><span class="No-Break">.</span></p>
			<p><strong class="bold">Feature 1</strong> development<a id="_idIndexMarker1481"/> needs to continue. So, a new branch is created from <strong class="bold">Trunk</strong> for the continuation of the <strong class="bold">Feature </strong><span class="No-Break"><strong class="bold">1</strong></span><span class="No-Break"> development.</span></p>
			<p>At the same time, the <strong class="bold">Feature 2</strong> branch has detected a commit made in <strong class="bold">Trunk</strong>, so the corresponding engineer rebases the branch from <strong class="bold">Trunk</strong> to get the <span class="No-Break">latest code.</span></p>
			<p>Afterward, the development of <strong class="bold">Feature 2</strong> is completed, tested, and verified in its branch. So, a pull request is created for <strong class="bold">Feature 2</strong> for review. The branch is then approved and merged <span class="No-Break">into </span><span class="No-Break"><strong class="bold">Trunk</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="bold">Feature 1</strong> branch has detected a commit made in <strong class="bold">Trunk</strong>, so the corresponding engineer rebases the branch from <strong class="bold">Trunk</strong> to get the <span class="No-Break">latest code.</span></p>
			<p>Trunk-based development emphasizes that the <em class="italic">Trunk</em> branch should also be good enough for a release at any time. There is no concept of a release branch. That is why all branches should be tested, verified, and reviewed by peers <span class="No-Break">before merging.</span></p>
			<p>To extend this concept, each commit can trigger a software release to environments, even to production. This approach fits very well with the practice of CD, where software is frequently delivered to customers, vastly reducing the time to market. It also implies that automated tests should be more rigorous and thorough in the branch to assure software quality in the early stages <span class="No-Break">of development.</span></p>
			<p>Trunk-based development also fits well with rapid development and short iterations that are advocated in Agile development methodologies. The quick turnarounds and short feedback loop enable the team to evolve the software <span class="No-Break">product faster.</span></p>
			<p>The frequent commits and rebasing <a id="_idIndexMarker1482"/>also reduce the complexity of merge conflict resolution. Any integration issue can be identified and fixed early, so the feedback loop for engineers is shorter. The <a id="_idIndexMarker1483"/>branch management is simplified because the <em class="italic">Trunk</em> branch is the <span class="No-Break">only focus.</span></p>
			<p>Having a long-living branch is an anti-pattern under trunk-based development. For larger feature development, the changes need to be split into multiple branches, and therefore, multiple commits to the <span class="No-Break"><em class="italic">Trunk</em></span><span class="No-Break"> branch.</span></p>
			<p>Engineers need to make judgment calls on splitting the changes sensibly. It requires more thought and discipline from engineers to make sure each commit to <em class="italic">Trunk</em> is safe and can be released. <strong class="bold">Feature flagging</strong> is a common technique in hiding features in development and still allows code to be <a id="_idIndexMarker1484"/>released to production. Feature flagging will be covered in the <span class="No-Break">next section.</span></p>
			<p>It is not uncommon for an engineer to have added changes that are not ready for production by mistake, despite the changes having been merged into <em class="italic">Trunk</em>. To make matters worse, there are other changes committed afterward. At this moment, <em class="italic">Trunk</em> is not ready for release. This situation leaves engineers with a few <span class="No-Break">difficult choices:</span></p>
			<ul>
				<li><strong class="bold">Roll back</strong>: Reverse all the commits to where <em class="italic">Trunk</em> is still safe for release. That would generate one more commit to <em class="italic">Trunk</em> for reversion. Re-apply the other required changes from new branches after <span class="No-Break">the reversion.</span></li>
				<li><strong class="bold">Cherry-picking</strong>: Create a new branch from the latest <em class="italic">Trunk</em> and carefully unpick the unwanted changes. Merges this branch back <span class="No-Break">to </span><span class="No-Break"><em class="italic">Trunk</em></span><span class="No-Break">.</span></li>
				<li><strong class="bold">Roll forward</strong>: Create a new branch from the latest <em class="italic">Trunk</em> and continue to work on the change with a focus on making <em class="italic">Trunk</em> ready for release again. Merge this branch back <span class="No-Break">to </span><span class="No-Break"><em class="italic">Trunk</em></span><span class="No-Break">.</span></li>
			</ul>
			<p>All the preceding choices require careful execution by engineers and none of them are easy. Many engineers would prefer rolling forward to keep the flow of development going at the cost of leaving <a id="_idIndexMarker1485"/>some commits in <em class="italic">Trunk</em> unfit <span class="No-Break">for release.</span></p>
			<h2 id="_idParaDest-393"><a id="_idTextAnchor493"/>Comparison between feature-based and trunk-based development</h2>
			<p>The choice<a id="_idIndexMarker1486"/> between feature-based and trunk-based is highly related to ways of working in the team<a id="_idIndexMarker1487"/> and in the organization. This is an example of where <strong class="bold">Conway’s Law</strong> applies, as covered in <a href="B21737_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, where organization<a id="_idIndexMarker1488"/> structure affects the software<a id="_idIndexMarker1489"/> <span class="No-Break">development process.</span></p>
			<table id="table002" class="No-Table-Style _idGenTablePara-1">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Feature-based development</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Trunk-based development</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">Long-lived branches</span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">Short-lived branches</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Dedicated branches <span class="No-Break">for release</span></p>
						</td>
						<td class="No-Table-Style">
							<p><em class="italic">Trunk</em> is the branch <span class="No-Break">for release</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Large features developed in <span class="No-Break">long-lived branches</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Large features are split into multiple <span class="No-Break">short-lived branches</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>High complexity in merge and <span class="No-Break">rebase operations</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Low complexity in merge and <span class="No-Break">rebase operations</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Slower feedback for <span class="No-Break">integration issues</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Faster feedback for <span class="No-Break">integration issues</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Development <span class="No-Break">in isolation</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Development <span class="No-Break">with collaboration</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Roll back is <span class="No-Break">more common</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Roll forward is <span class="No-Break">more common</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>A hotfix branch for <span class="No-Break">urgent issues</span></p>
						</td>
						<td class="No-Table-Style">
							<p>No concept of <span class="No-Break">hotfix branches</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>The release branch <span class="No-Break">is stable</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Complex operations to fix unreleasable commits in <span class="No-Break">the trunk</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>Release is <span class="No-Break">less frequent</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Release can be <span class="No-Break">more frequent</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 15.2 – Comparison between feature-based and trunk-based development</p>
			<p>Both development approaches have their advantages and trade-offs. Ultimately, the choice depends on the team size, project complexity, and development practice. Some teams may adopt a hybrid <a id="_idIndexMarker1490"/>approach to maximize the benefits of each approach and reduce <span class="No-Break">the drawbacks.</span></p>
			<p>For example, a team may decide to have trunk-based development but a release branch is created to aim for each<a id="_idIndexMarker1491"/> release. It reduces the need to unpick unwanted changes for release and keeps release preparation away from the development of other <span class="No-Break">ongoing features.</span></p>
			<p>The preceding example can be seen as a release strategy; nonetheless, there are more release strategies that we want to cover, and we are going to cover them in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-394"><a id="_idTextAnchor494"/>Release versus deployment versus launch</h2>
			<p>Once an application is ready for release, there<a id="_idIndexMarker1492"/> is a new landscape of concerns and strategies on how it gets into the hands of customers and end users. At certain times in history, it was just a binary condition of whether it was out or not. Modern releases are more sophisticated <span class="No-Break">and complicated.</span></p>
			<p>Firstly, we need to make distinctions among three concepts: release, deployment, and launch. These concepts might be used interchangeably in some organizations; however, they have subtle differences that should <span class="No-Break">be discussed.</span></p>
			<p><strong class="bold">Deployment</strong> is the least misunderstood <a id="_idIndexMarker1493"/>concept. Deployment implies that the executable software artifact built from source code and configuration has been loaded to the target environment. This section focuses on the production environment. It is an operational and technical task that is often automated by scripts – optionally, with an approval process that involves <span class="No-Break">human intervention.</span></p>
			<p><strong class="bold">Release</strong> means the application is now <a id="_idIndexMarker1494"/>available to the<a id="_idIndexMarker1495"/> users in the target environment. Sometimes, we might also say releasing a feature, which means the intent of making the feature available to users. Deployment is the prerequisite of release. A feature in an application, even if the application has been deployed, may still not be available to <span class="No-Break">some users.</span></p>
			<p><strong class="bold">Launching</strong> an application is the least technically involved out of all three concepts. The term <em class="italic">launch</em> does not mean <a id="_idIndexMarker1496"/>starting up an application. Instead, it implies the software product is marketed, advertised, and, optionally, has a launch event such as a press conference or an exhibition. Launching<a id="_idIndexMarker1497"/> a software product is not part of the CI/CD life cycle. Releasing is the prerequisite of launching as users need to access the application. Launching would involve a go-to-market plan, with a variety of non-technical stakeholders involved (e.g., marketing, sales, customer <span class="No-Break">services, etc.).</span></p>
			<p>With these distinctions, release strategies of software products are where the complications are in relation to CD. We are going to cover a few common release <span class="No-Break">strategies next.</span></p>
			<h2 id="_idParaDest-395"><a id="_idTextAnchor495"/>Blue-green release</h2>
			<p><strong class="bold">Blue-green release</strong> keeps<a id="_idIndexMarker1498"/> the current version (<em class="italic">blue</em>) of an application in the production environment and has <a id="_idIndexMarker1499"/>a new version (<em class="italic">green</em>) deployed to a replica of the production environment. This strategy allows the new version of the application to be deployed while keeping the current version available <span class="No-Break">to users.</span></p>
			<p>This strategy typically applies to server-side web-based applications and the <strong class="bold">Domain Name System</strong> (<strong class="bold">DNS</strong>) to route web<a id="_idIndexMarker1500"/> requests to the new or current version of the application. The blue-green release strategy can be seen in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B21737_15_4.jpg" alt="Figure 15.4 – An example of a blue-green release" width="1295" height="688"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.4 – An example of a blue-green release</p>
			<p>The DNS, by default, routes web requests to <strong class="bold">Zone 1</strong> (<strong class="bold">Blue</strong>) where the current versions of applications are running. The applications in the <strong class="bold">Blue</strong> zone communicate with each other only, by keeping them<a id="_idIndexMarker1501"/> in the same <strong class="bold">local area </strong><span class="No-Break"><strong class="bold">network</strong></span><span class="No-Break"> (</span><span class="No-Break"><strong class="bold">LAN</strong></span><span class="No-Break">).</span></p>
			<p>While the <strong class="bold">Blue</strong> zone keeps <a id="_idIndexMarker1502"/>the system available to users, engineers can deploy the new versions of applications to the <strong class="bold">Green</strong> zone, without the risk of causing an outage. Moreover, engineers and QAs can test and verify the new versions in the <strong class="bold">Green</strong> zone by using a<a id="_idIndexMarker1503"/> specific domain name (e.g., <strong class="source-inline">api.zone2.contract.system</strong> in contrast to the general <strong class="source-inline">api.contract.system</strong>). Engineers can even troubleshoot and fix issues found in the <span class="No-Break">new </span><span class="No-Break"><a id="_idIndexMarker1504"/></span><span class="No-Break">versions.</span></p>
			<p>Once the new versions are verified and ready to be used by users, the traffic can be switched in the DNS, so web requests are routed to <strong class="bold">Zone 2</strong>. <strong class="bold">Zone 2</strong> is now the new <strong class="bold">Blue</strong> zone in effect. There is no more <strong class="bold">Green</strong> zone, as illustrated in <span class="No-Break"><em class="italic">Figure 15</em></span><span class="No-Break"><em class="italic">.5</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B21737_15_5.jpg" alt="Figure 15.5 – A blue-green release (after switching)" width="1402" height="750"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.5 – A blue-green release (after switching)</p>
			<p><strong class="bold">Zone 1</strong> is now running older versions of applications that can be shut down till the next deployment, which turns this zone into the new <strong class="bold">Green</strong> zone. It is important to note that <strong class="bold">Blue</strong>/<strong class="bold">Green</strong> is the role of<a id="_idIndexMarker1505"/> the zone that is going to flip from one another <span class="No-Break">over time.</span></p>
			<p>A blue-green release is not the same as a rolling deployment. Rolling deployment aims to keep the service available while deployment is in progress. Rolling deployment usually takes the <span class="No-Break">following</span><span class="No-Break"><a id="_idIndexMarker1506"/></span><span class="No-Break"> steps:</span></p>
			<ol>
				<li>Scale down the current number of application instances <span class="No-Break">to one.</span></li>
				<li>Deploy the new version of the application to the target number as <span class="No-Break">new instances.</span></li>
				<li>Start all instances of the <span class="No-Break">new version.</span></li>
				<li>Notify the load balancer of the existence of the new running instances, or let them <span class="No-Break">be discovered.</span></li>
				<li>Once all instances of the new version are confirmed to be running by the probe endpoints, shut down the older <span class="No-Break">application instance.</span></li>
			</ol>
			<p>Unlike the blue-green release, there is no time window in which engineers and QAs can test the newer version of the application without it being available to users. Additionally, this is a deployment technique only. It is not concerned with whether the application is available to users or not. It only cares whether the application has transitioned to the new<a id="_idIndexMarker1507"/> version without outage <span class="No-Break">or downtime.</span></p>
			<h2 id="_idParaDest-396"><a id="_idTextAnchor496"/>Dark release/feature flagging</h2>
			<p>There are methods to verify new features without making them available to users. The new features can be deployed to the <a id="_idIndexMarker1508"/>production environment normally but remain hidden from <a id="_idIndexMarker1509"/>users, using <strong class="bold">feature flagging</strong> (also known as <span class="No-Break"><strong class="bold">dark release</strong></span><span class="No-Break">).</span></p>
			<p>The feature toggle can be <a id="_idIndexMarker1510"/>managed in a <span class="No-Break">few ways:</span></p>
			<ul>
				<li><strong class="bold">Central</strong>: There is a central service or resource that dictates whether a feature is available to the <span class="No-Break">given user</span></li>
				<li><strong class="bold">Individual</strong>: Each component or service manages its own <span class="No-Break">feature flags</span></li>
				<li><strong class="bold">Per request</strong>: A non-publicly known request parameter is used to enable the feature to serve <span class="No-Break">this request</span></li>
			</ul>
			<p>Regardless of how feature flags are managed, this approach allows engineers and QAs to verify pre-released features before the features are available to users. The feature is only switched on when the team is happy with the verification results. In addition, the feature can be switched off even after it was made available to users, and thus it minimizes the impact of <span class="No-Break">related issues.</span></p>
			<p>Feature flagging works well with the <a id="_idIndexMarker1511"/>practice of <strong class="bold">trunk-based development</strong>, as discussed in previous sections. With the feature flag switched off, engineers can continue to develop the feature and merge their changes to the trunk. However, all automated tests should pass to ensure that existing functions still work as intended with the unfinished and switched-off feature in the <span class="No-Break">code base.</span></p>
			<p>Feature flags mainly <a id="_idIndexMarker1512"/>concern releases and making a feature available to users. Some organizations may extend feature flagging to support user segmentation and A/B testing, as mentioned in <a href="B21737_13.xhtml#_idTextAnchor418"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>. This is not an anti-pattern, but only an enhancement of the system beyond <span class="No-Break">feature flagging.</span></p>
			<h2 id="_idParaDest-397"><a id="_idTextAnchor497"/>Canary release</h2>
			<p>A <strong class="bold">canary release</strong> is a staged release strategy that makes the newly deployed software available to a small subset of users before<a id="_idIndexMarker1513"/> rolling it out to all target users. It operates at the application level, not a feature in an application. It aims for incremental availability to users, and there are a lot of variations<a id="_idIndexMarker1514"/> in this strategy in the initial selection of users and strategic increase of availability. There are a few factors that would affect <span class="No-Break">this strategy:</span></p>
			<ul>
				<li>The team might want to invite subject matter experts or domain experts to start using the application first, to gather feedback that might shape the product before the public <span class="No-Break">uses it.</span></li>
				<li>The organization might want to initially release the software product to users in a selected geographic region. This could be due to the geographic context of the application, legal restrictions, or related marketing events. The organization might want to expand its geographic <span class="No-Break">territory incrementally.</span></li>
				<li>The team might want to initially release the application to certain types of devices or operating systems of devices. This could be due to compatibility concerns, especially in the Android application landscape, or due to the popularity of certain devices in <span class="No-Break">the market.</span></li>
			</ul>
			<p>A canary release is sometimes mistaken for the concept of beta testing. After a software product is signed off by internal QAs, some organizations might want to invite expert users to internal testing. Testing<a id="_idIndexMarker1515"/> internally, typically with <strong class="bold">white-box testing</strong> techniques, as discussed in <a href="B21737_13.xhtml#_idTextAnchor418"><span class="No-Break"><em class="italic">Chapter 13</em></span></a>, is called <strong class="bold">alpha testing</strong>. Testing by external users before public<a id="_idIndexMarker1516"/> release is called <span class="No-Break"><strong class="bold">beta testing</strong></span><span class="No-Break">.</span></p>
			<p>However, beta testing is not considered <a id="_idIndexMarker1517"/>a production release because the version of the software product being tested is usually not the final version. Beta testing is only for a <span class="No-Break">limited period.</span></p>
			<p>Feedback and suggestions <a id="_idIndexMarker1518"/>from selected users are gathered to validate the product concepts, usability, and functionality. They are also used for further enhancement of the product. Releasing a non-final version of the software product for beta testing does not require a canary <span class="No-Break">release strategy.</span></p>
			<h2 id="_idParaDest-398"><a id="_idTextAnchor498"/>Choosing a release strategy</h2>
			<p>Choosing a release strategy is <a id="_idIndexMarker1519"/>not easy or straightforward. However, it is certainly not recommended to do a Big Bang release with planned outages, as we discussed in <a href="B21737_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>. There are other factors involved in the decision, such as infrastructure readiness, marketing strategies, service uptime objectives, and so on. From a purely technical point of view, we can potentially use a decision tree to recommend a release strategy, as shown in <span class="No-Break"><em class="italic">Figure</em></span><span class="No-Break"> </span><span class="No-Break"><em class="italic">15</em></span><span class="No-Break"><em class="italic">.6</em></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/B21737_15_6.jpg" alt="Figure 15.6 – An example of a technical decision tree of release strategies" width="1471" height="747"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 15.6 – An example of a technical decision tree of release strategies</p>
			<p>Releasing a feature in an application should consider feature flagging or dark release first because it is the least expensive choice compared to others. If it is about releasing an entire application and it is a server-side application, a blue-green release or canary release can be considered. If the application involves desktop, mobile, or web applications, then a canary<a id="_idIndexMarker1520"/> release should <span class="No-Break">be considered.</span></p>
			<p>Please note this is more about technical restrictions of which release strategies can be used, instead of considering which one provides the best outcome due to other non-technical <span class="No-Break">factors involved.</span></p>
			<p>We are at the end of the discussion on CI/CD. A well-automated CI/CD pipeline saves a lot of time for engineers in trying to integrate with other people’s work and deliver the application to multiple environments. In a sense, it improves the experience of engineers working on software products. We are going to cover a bit more on the topic of the developer experience in the <span class="No-Break">next section.</span></p>
			<h1 id="_idParaDest-399"><a id="_idTextAnchor499"/>Developer experience</h1>
			<p><strong class="bold">Developer experience</strong> (<strong class="bold">DX</strong>) is what engineers <a id="_idIndexMarker1521"/>experience while developing software. It includes everything from tools, processes, environments, teams, organizations, and the culture of development. We will bring up a few suggestions for improving DX in the <span class="No-Break">following sections.</span></p>
			<h2 id="_idParaDest-400"><a id="_idTextAnchor500"/>Why does DX matter?</h2>
			<p>DX might, at first glance, look like the<a id="_idIndexMarker1522"/> general satisfaction of any person working on a project. However, a great DX brings a lot of benefits to not only the engineers themselves but also to the software product and to <span class="No-Break">the organization:</span></p>
			<ul>
				<li><strong class="bold">Productivity and efficiency</strong>: Efficient tools, automated workflows, concise documentation, and smooth development processes remove the burden from engineers, so they can focus on coding <span class="No-Break">and problem-solving.</span></li>
				<li><strong class="bold">Product quality</strong>: Stable environments and intuitive tools reduce friction in the everyday work of engineers, so they can focus on delivering high-quality code with attention <span class="No-Break">to detail.</span></li>
				<li><strong class="bold">Operation cost</strong>: Automated tools and processes reduce the labor cost for engineers to support the system. Also, better tools lead to fewer mistakes and thus reduce the time and resources spent on <span class="No-Break">fixing issues.</span></li>
				<li><strong class="bold">Learning curve</strong>: Streamlined onboarding process, good documentation, and intuitive processes make it quicker for a new engineer to get up to speed and <span class="No-Break">become productive.</span></li>
				<li><strong class="bold">Collaboration</strong>: Good DX encourages communication and collaboration within the team and improves team morale. It also improves the interactions between engineers and stakeholders, which leads to <span class="No-Break">better outcomes.</span></li>
				<li><strong class="bold">Innovation</strong>: A safe and supportive environment fosters a culture of innovation and experimentation. Engineers<a id="_idIndexMarker1523"/> can be creative in their solutions without the fear of failure. High-quality tools allow for trying new ideas collaboratively and <span class="No-Break">learning collectively.</span></li>
				<li><strong class="bold">Job satisfaction and retention</strong>: A satisfactory working environment keeps engineers more engaged and motivated. When they enjoy the work they do, employee turnover can be lowered. In return, it saves time and resources on recruitment <span class="No-Break">and training.</span></li>
				<li><strong class="bold">Talent acquisition</strong>: If an organization has a reputation for great DX among technology communities, it attracts top talent to join the team and improves the branding of <span class="No-Break">the organization.</span></li>
			</ul>
			<p>DX has an influential role in delivering high-quality software products, ultimately leading to more healthy organizations and better business outcomes. We are going to cover a few areas that can improve <span class="No-Break">DX next.</span></p>
			<h2 id="_idParaDest-401"><a id="_idTextAnchor501"/>Onboarding</h2>
			<p>Apart from the general onboarding, there should be comprehensive documentation for engineering topics, such as <span class="No-Break">the </span><span class="No-Break"><a id="_idIndexMarker1524"/></span><span class="No-Break">following:</span></p>
			<ul>
				<li>Development processes (Kanban, <span class="No-Break">Scrum, etc.)</span></li>
				<li>Tech stacks used in <span class="No-Break">the organization</span></li>
				<li>In-house libraries <span class="No-Break">and frameworks</span></li>
				<li><strong class="bold">Architecture decision records</strong> (<strong class="bold">ADRs</strong>), as <a id="_idIndexMarker1525"/>mentioned in <a href="B21737_01.xhtml#_idTextAnchor013"><span class="No-Break"><em class="italic">Chapter 1</em></span></a></li>
				<li>Engineering practices <span class="No-Break">and conventions</span></li>
				<li>Specialized engineering environments set up (e.g., backend, frontend, data, <span class="No-Break">platform, etc.)</span></li>
			</ul>
			<p>These documents are best updated by each new engineer joining the organization, as it can keep the information <a id="_idIndexMarker1526"/>up <span class="No-Break">to date.</span></p>
			<p>Having a technical peer assigned as an onboarding partner is a helpful welcoming gesture for new engineers. The onboarding partner can pair with the new engineer in setting up environments for work, requesting appropriate permissions, adding the new engineer to the corresponding communication channel, and <span class="No-Break">answering questions.</span></p>
			<h2 id="_idParaDest-402"><a id="_idTextAnchor502"/>Tools</h2>
			<p>Tools play a big part in an engineer’s<a id="_idIndexMarker1527"/> productivity. Investing in good engineering tools brings not only great DX but also tangible productivity to the engineering teams. These tools include, but are not limited to, <span class="No-Break">the following:</span></p>
			<ul>
				<li>A <strong class="bold">single sign-on</strong> (<strong class="bold">SSO</strong>) portal to access <a id="_idIndexMarker1528"/>all other third-party tools. Instead of having everyone remember passwords for each third-party tool, logging in to these tools via a central portal saves a lot of time. This applies to all tools beyond <span class="No-Break">engineering tools.</span></li>
				<li>Streamlined method to log in to any environment or infrastructure without compromising security and auditing. Historically, engineers need to access a server using means<a id="_idIndexMarker1529"/> such as the <strong class="bold">Secure Shell</strong> (<strong class="bold">SSH</strong>) protocol with a terminal tool. In modern days, there are better ways to access a server in any environment. These tools (such as Teleport, JumpCloud, CyberArk, etc.) support a simple request-approval workflow for access, wrapping around the terminal tool, establishing tunneling, restricting certain access, and logging all the activities during access to secure <span class="No-Break">the environment.</span></li>
				<li>Each engineer may have their own toolkit in their pocket, such as some scripts for certain tasks. It is recommended to have a source repository to host all these scripts and small toolkits accessible to all engineers. Not only can the organization absorb the secret powerful scripts from engineers but it also establishes a standard toolkit to help engineers perform their <span class="No-Break">daily tasks.</span></li>
				<li>There are circumstances where engineers need to call an API endpoint to perform certain tasks, such as rehydrating an event topic by requesting the publisher to publish all messages again. It is recommended that the organization has a shared collection of operational endpoints to reduce the time for engineers to craft these <a id="_idIndexMarker1530"/>steps themselves. In addition, it is likely that those API endpoints require getting an authorization token as a bearer token to invoke endpoints (see <a href="B21737_14.xhtml#_idTextAnchor442"><span class="No-Break"><em class="italic">Chapter 14</em></span></a> for a detailed flow); the orchestration of getting these tokens should be scripted and shared among<a id="_idIndexMarker1531"/> engineers. An example of this tool is <span class="No-Break"><strong class="bold">Postman Collections</strong></span><span class="No-Break">.</span></li>
				<li>The dependencies of a Kotlin project are silently out of date over time. Use automation tools<a id="_idIndexMarker1532"/> such as <strong class="bold">Dependabot</strong> to automatically create pull requests that <span class="No-Break">update dependencies.</span></li>
				<li>Use <strong class="bold">artificial intelligence</strong> (<strong class="bold">AI</strong>) applications in multiple areas of software development. Apart from the normal <a id="_idIndexMarker1533"/>syntactic code completion features provided by the IDEs, there are also AI assistants that hint at semantic code completion by understanding the existing code base. There are also embedded <strong class="bold">large language model</strong> (<strong class="bold">LLM</strong>) chatbots that provide live technical <a id="_idIndexMarker1534"/>advice with example code snippets. There are also pull request bots that understand the intent of pull requests and provide <span class="No-Break">useful feedback.</span></li>
			</ul>
			<h2 id="_idParaDest-403"><a id="_idTextAnchor503"/>Development processes</h2>
			<p>Organizations should invest in tools that support software development processes. Each team could have adopted slightly <a id="_idIndexMarker1535"/>different methodologies such as Scrum or Kanban, and the team would need a dashboard to run the <span class="No-Break">daily standup.</span></p>
			<p>As remote working has become a trend, organizations should invest in tools such as issue-tracking systems, digital Kanban or Scrum boards, and online retrospective tools to enable the team to run any software <span class="No-Break">development process.</span></p>
			<h2 id="_idParaDest-404"><a id="_idTextAnchor504"/>Communication and collaboration</h2>
			<p>Modern organizations will already have invested in multiple communication tools for instant messaging, video<a id="_idIndexMarker1536"/> conferencing, screen sharing and pairing, and emails. It is recommended that emails should only be used for external communication. Instant messaging should be the major way <span class="No-Break">of communication.</span></p>
			<p>Moreover, it is recommended that each team has a channel where engineers can think out loud about their problem-solving. Members of the channel should form a habit of using threads to post messages about a specific problem. By concentrating discussion of a problem, it is possible to introduce AI bots to summarize the discussion for others to <span class="No-Break">catch up.</span></p>
			<p>The instant messaging system should integrate with other tools, so engineers have a one-stop shop to receive notifications and work reactively. This can include receiving notifications of a visual design change from design collaboration tools, a change of an issue in issue management tools, an alert from monitoring tools, approval in a pull request, or simply a daily meeting <span class="No-Break">schedule summary.</span></p>
			<p>Engineers need to have tools to immediately jump on a remote pair-programming huddle with the capability to share screens and even take over control of <span class="No-Break">input devices.</span></p>
			<p>Some IDEs, such as IntelliJ Ultimate, have the capability to run pair-programming sessions. These tools enhance the collaboration between engineers and encourage <span class="No-Break">collective learning.</span></p>
			<p>There are other tools that enhance collaboration between engineers and other disciplines in the team. For example, an online collaborative design tool such as Figma or Miro can be used as a sketchpad for engineers to work with designers and product managers to understand <span class="No-Break">the requirements.</span></p>
			<p>Engineers in the same specialization (backend, frontend, data, testing, platform, etc.) can have their own forum as a <em class="italic">trade guild</em> in which engineers can share their learning and discuss topics that are closely related to <span class="No-Break">their work.</span></p>
			<h2 id="_idParaDest-405"><a id="_idTextAnchor505"/>Feedback and continuous improvement</h2>
			<p>It is important to periodically<a id="_idIndexMarker1537"/> receive qualitative and quantitative feedback from engineers to discover any room for improvement. It is recommended to conduct regular surveys, feedback sessions, or retrospective sessions to gain insights into the satisfaction of engineers and to identify areas <span class="No-Break">of improvement.</span></p>
			<p>As discussed in <a href="B21737_11.xhtml#_idTextAnchor358"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, the <strong class="bold">SPACE</strong> metrics <a id="_idIndexMarker1538"/>provide a comprehensive and holistic assessment of the productivity and well-being of <span class="No-Break">engineering teams.</span></p>
			<p>Most importantly, the engineering management needs to acknowledge the feedback and implement corresponding changes to<a id="_idIndexMarker1539"/> improve the DX. Being listened to and seeing feedback taken on board would vastly improve the satisfaction and morale of <span class="No-Break">engineering teams.</span></p>
			<h2 id="_idParaDest-406"><a id="_idTextAnchor506"/>Recognition and rewards</h2>
			<p>Engineering teams and management should recognize and celebrate achievements by teams or individuals. This <a id="_idIndexMarker1540"/>can be done by explicitly shouting out the team and its members for their accomplishments or giving actual rewards for successful releases, innovative ideas, and implemented improvements. Recognition and rewards can boost morale <span class="No-Break">and motivation.</span></p>
			<h1 id="_idParaDest-407"><a id="_idTextAnchor507"/>Final thoughts on software architecture</h1>
			<p>As we are coming to the end of the book, I would like to share my final thoughts on software architecture. I am going to<a id="_idIndexMarker1541"/> cover the current trends and how we could equip ourselves to surf on the never-ending waves <span class="No-Break">of change.</span></p>
			<h2 id="_idParaDest-408"><a id="_idTextAnchor508"/>Small, reactive, and independent services</h2>
			<p>Although there are a few justifications for writing a monolithic application, as discussed in <a href="B21737_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, software components are<a id="_idIndexMarker1542"/> getting smaller and smaller. It is less common to see a new project written with the aim of becoming a monolith these days. Instead, engineers would aggressively split out small services that communicate over APIs <span class="No-Break">or events.</span></p>
			<p>Small services improve scalability, flexibility, and ease of deployment. Teams can develop, deploy, and scale services independently. Microservices and nanoservices are small enough to be owned by one team, and thus they encourage autonomy and empower the team to make its own decisions. Even if a wrong decision was made (e.g., choosing the wrong framework), it is comparatively easy to pivot and refactor the service without affecting other <span class="No-Break">software components.</span></p>
			<p>Application logic has also shifted from imperative to reactive and from synchronous to asynchronous processing. Many new systems embrace event-driven architectures and reactive handling. Many business use cases do not require everything to be completed to receive a response. A lot of processing can be done in real-time asynchronously by reacting to events. We<a id="_idIndexMarker1543"/> covered the combination of CQRS and event-sourcing in <a href="B21737_09.xhtml#_idTextAnchor307"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, which provides an example of responding to synchronous requests earlier and having the rest of the processes <span class="No-Break">executed asynchronously.</span></p>
			<p>Having a system split into small services brings the challenge of keeping overall system behaviors consistent. This leads to the discussion of idempotence, replication, and recovery, as discussed in <a href="B21737_10.xhtml#_idTextAnchor334"><span class="No-Break"><em class="italic">Chapter 10</em></span></a><span class="No-Break">.</span></p>
			<p>This change in thinking has improved responsiveness and scalability, making it easier to integrate with numerous services and handle high-throughput scenarios. We covered performance and scalability in depth in <a href="B21737_12.xhtml#_idTextAnchor379"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>. <span class="No-Break">We also</span></p>
			<h2 id="_idParaDest-409"><a id="_idTextAnchor509"/>The shift-left paradigms – API-first and security-first approaches</h2>
			<p>Continuing with software component downsizing, APIs become more important. In fact, the API-first design approach <a id="_idIndexMarker1544"/>has gained popularity these days. The API-first approach advocates that APIs should be developed before the <a id="_idIndexMarker1545"/>actual implementation of <span class="No-Break">the features.</span></p>
			<p>This approach facilitates communication and collaboration between teams. It unblocks the development of the consumer side (e.g., another service or a frontend application) earlier and allows for parallel development. Developing APIs first also gives engineers a perspective to discover corner use cases before implementing them. We provided an example of the use of OpenAPI specifications in <a href="B21737_04.xhtml#_idTextAnchor102"><span class="No-Break"><em class="italic">Chapter 4</em></span></a><span class="No-Break">.</span></p>
			<p>The increasing popularity of DevSecOps, as discussed in <a href="B21737_14.xhtml#_idTextAnchor442"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, has brought security to the engineers’ attention. By integrating security practices into software development (e.g., threat modeling), teams can address security concerns and incorporate them into early<a id="_idIndexMarker1546"/> technical design. This approach has enhanced the security posture and reduced vulnerabilities of <span class="No-Break">an application.</span></p>
			<h2 id="_idParaDest-410"><a id="_idTextAnchor510"/>The influence of cloud and serverless architectures</h2>
			<p>Cloud computing and serverless architectures have changed the landscape of software development forever. Cloud <a id="_idIndexMarker1547"/>providers manage the infrastructure and automatically scale resources. Engineers can focus on fulfilling business requirements in code rather than tackling infrastructure concerns. Moreover, serverless architectures are cost-effective and reduce <span class="No-Break">operational overhead.</span></p>
			<p>The numerous services and tooling for cloud environments, such as Kubernetes, allow applications to take advantage of cloud provider features to improve scalability <span class="No-Break">and resilience.</span></p>
			<p>Moreover, there is a wide range of PaaS and SaaS running on the cloud, which makes it easier to integrate these services with any application. These services include relational databases, messaging services, identity providers, email services, and even fully-fledged enterprise software systems. We discussed serverless architecture in <a href="B21737_06.xhtml#_idTextAnchor212"><span class="No-Break"><em class="italic">Chapter 6</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-411"><a id="_idTextAnchor511"/>Composable architecture</h2>
			<p>The idea of small services extends to<a id="_idIndexMarker1548"/> breaking down software into independent modules or components that can be easily assembled or replaced. This building block approach leads to composable architecture, where each block aims to address specific concerns. These modules are designed to be cohesive to integrate with <span class="No-Break">any application.</span></p>
			<p>This approach increases the agility and flexibility of the overall architecture. It enables applications to rapidly adapt to a technology and to experiment with multiple options at a <span class="No-Break">lower cost.</span></p>
			<p>For instance, the <em class="italic">household service</em> that was brought up in many chapters can be reused in business problems other than household exchanging services. The service can easily integrate with other systems (e.g., voting, recycling, etc.) due to its modularity and high cohesiveness. We discussed in length how to define bounded contexts that result in well-defined services in <a href="B21737_08.xhtml#_idTextAnchor289"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>. We also discussed layered and modular architectures in <a href="B21737_07.xhtml#_idTextAnchor255"><span class="No-Break"><em class="italic">Chapter 7</em></span></a><span class="No-Break">.</span></p>
			<p>Architecture patterns continue to grow and evolve. Having composable architecture enables each pattern to independently advance <span class="No-Break">and improve.</span></p>
			<h2 id="_idParaDest-412"><a id="_idTextAnchor512"/>Observability and monitoring</h2>
			<p>Observability and monitoring have become an integral part of software architectures these days. Not only do engineers<a id="_idIndexMarker1549"/> want to gain an understanding of system behaviors through logging, tracing, and monitoring tools but engineers also want to identify <span class="No-Break">issues quicker.</span></p>
			<p>Observability and monitoring tools run in the cloud and are easy to integrate, typically using the Sidecar pattern, as mentioned in <a href="B21737_14.xhtml#_idTextAnchor442"><span class="No-Break"><em class="italic">Chapter 14</em></span></a>, which is also an approach to <span class="No-Break">composable architecture.</span></p>
			<p>Auditing has also become an important aspect of software products. Having the ability to understand actions performed in the system provides insights into technical and business processes. This is particularly helpful for systems that need to comply <span class="No-Break">with regulations.</span></p>
			<p>We covered the topic of auditing and monitoring models in <a href="B21737_11.xhtml#_idTextAnchor358"><span class="No-Break"><em class="italic">Chapter 11</em></span></a><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-413"><a id="_idTextAnchor513"/>AI and machine learning</h2>
			<p>AI and <strong class="bold">machine learning</strong> (<strong class="bold">ML</strong>) are significantly shaping the future of software architectures. ML is a subset of AI that<a id="_idIndexMarker1550"/> focuses on learning <a id="_idIndexMarker1551"/>from data to generate predictions and <span class="No-Break">help decision-making.</span></p>
			<p>AI/ML consumes a lot of data to train its model, thus making software architectures increasingly data-centric. Systems that use AI/ML need to efficiently collect, store, and process large volumes <span class="No-Break">of data.</span></p>
			<p>Cloud providers provide ready-to-use AI/ML services so engineers can run them without managing the infrastructure and automatically scale them on demand. These services (e.g., AWS Bedrock, Azure OpenAI, and GCP Vertex AI) include natural language processing, behavior analysis, predictive analytics, generating recommendations, summarizing data, and pattern recognition, and the list is <span class="No-Break">still growing.</span></p>
			<p>Even better, these AI/ML APIs use the format and transport that engineers are already familiar with, such as JSON payload and HTTP requests. Engineers can leverage advanced AI capabilities without needing deep expertise in AI/ML. The ease of integration has sped up <span class="No-Break">development cycles.</span></p>
			<p>Apart from using AI/ML in business applications, they are also used in monitoring, incident response, threat detection, semantic code completion, and chat box support for engineers. The ubiquitous features powered by AI/ML are driving a transformative shift in software architecture, promoting data-centric designs, modularity, and integration of advanced analytics <span class="No-Break">into applications.</span></p>
			<p>AI and ML will shape not <a id="_idIndexMarker1552"/>only how applications are built but also how they interact with data in real time. We are still witnessing the evolution of AI and ML, and we have not seen the full scale of <span class="No-Break">them yet.</span></p>
			<h1 id="_idParaDest-414"><a id="_idTextAnchor514"/>Summary</h1>
			<p>We covered a few Kotlin language features that can assist engineers in achieving better architectures, including extension functions, infix functions, operator overriding, and <span class="No-Break">scoping functions.</span></p>
			<p>Then, we covered the necessary steps to transition a Java project into a Kotlin project. We walked through the tools and manual correction required to convert a Java class into an idiomatic Kotlin class. We also mentioned a few opportunities to improve code quality during the conversion. We delved into the topic of transition strategies in terms of the sequence of conversion and framework transition. We emphasized the importance of continuous transition to Kotlin, and how the transition could incrementally progress in the everyday business feature <span class="No-Break">coding works.</span></p>
			<p>We moved to the topic of CI and CD and presented the two main integration approaches: feature-based and trunk-based development. We compared them in terms of their pros, cons, and suitability in the context of <span class="No-Break">organizational structure.</span></p>
			<p>We made distinctions between three concepts: the deployment, release, and launch of a software product. Then, we walked through three release strategies: blue-green, feature flagging, and canary release. We presented a sample decision tree to help engineers select which release strategy is suitable from a <span class="No-Break">technical perspective.</span></p>
			<p>We also covered the topic of DX, explaining its importance and how it benefits the software product, the team, and <span class="No-Break">the organization.</span></p>
			<p>We made numerous suggestions for improving DX, including onboarding, tools, development processes, communication, collaboration, feedback, continuous improvement, recognition, <span class="No-Break">and rewards.</span></p>
			<p>Lastly, we reflected on the software architecture that was discussed throughout the whole book, with a focus on current trends and <span class="No-Break">future development.</span></p>
		</div>
	</div></div></body></html>