["```java\nAlarmManager am = (AlarmManager)getSystemService(ALARM_SERVICE);\n```", "```java\nvoid set(int type, long triggerAtMillis, PendingIntent operation)\n```", "```java\n    SystemClock.elapsedRealtime()\n    ```", "```java\n    System.currentTimeMillis()\n    ```", "```java\nlong delay = TimeUnit.HOURS.toMillis(24L);\nam.set(AlarmManager.ELAPSED_REALTIME, delay, pending);\n```", "```java\nlong delay = TimeUnit.MINUTES.toMillis(5L);\nlong time = System.currentTimeMillis() + delay;\nam.set(AlarmManager.RTC, time, pending);\n```", "```java\nCalendar calendar = Calendar.getInstance();\n// Tomorrow at 9 if already passed 9pm today\nif (calendar.get(Calendar.HOUR_OF_DAY) >= 21) {\n    calendar.add(Calendar.DATE, 1);\n}\ncalendar.set(Calendar.HOUR_OF_DAY, 21);\ncalendar.set(Calendar.MINUTE, 0);\ncalendar.set(Calendar.SECOND, 0);\nam.set(AlarmManager.RTC, calendar.getTimeInMillis(), pending);\n```", "```java\nam.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, delay, pending);\nam.set(AlarmManager.RTC_WAKEUP, time, pending);\n```", "```java\nam.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);\n```", "```java\nam.setExact(AlarmManager.RTC_WAKEUP, time, pending);\n```", "```java\nif (Build.VERSION.SDK_INT >= 23) {\n  // Wakes up the device in Doze Mode\n  am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);\n} else if (Build.VERSION.SDK_INT >= 19) {\n  // Wakes up the device in Idle Mode\n  am.setExact(AlarmManager.RTC_WAKEUP, time, pending);\n} else {\n  // Old APIs\n  am.set(AlarmManager.RTC_WAKEUP, time, pending);\n}\n```", "```java\nlong delay = TimeUnit.HOURS.toMillis(10L);\nlong time = System.currentTimeMillis() + delay;\n\nif (Build.VERSION.SDK_INT >= 23) {\n     am.setAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time, pending);\n}\n```", "```java\n# Emulate a charger unplug\nadb shell dumpsys battery unplug\n# Emulate a charger plug in\nadb shell dumpsys battery set ac 1\n```", "```java\n// Enable the doze mode, step required on Android Emulator\nadb shell dumpsys deviceidle enable\n// To goes directly go IDLE mode\nadb shell dumpsys deviceidle force-idle\n```", "```java\n// Goes from IDLE -> IDLE_MAINTENANCE state\nadb shell dumpsys deviceidle step\n```", "```java\n// Goes from IDLE,IDLE_MAINTENANCE -> ACTIVE state\nadb shell dumpsys deviceidle disable\n```", "```java\nif (Build.VERSION.SDK_INT >= 19) {\n  long delay = TimeUnit.MINUTES.toMillis(5L);\n  long window = TimeUnit.MINUTES.toMillis(3L);\n  long time = System.currentTimeMillis() + delay; \n  am.setWindow(AlarmManager.RTC_WAKEUP, time, window, pending);\n}\n```", "```java\nadb shell dumpsys alarm\n\n```", "```java\n...\nBatch{bfce57 num=1 start=6199180 end=6199180 flgs=0x5}:\nRTC_WAKEUP #0: Alarm{\n d38d44 type 0 when 1449181419460  \n    com.packpublishing.asynchronousandroid}\n tag=*walarm*:my_alarm\n type=0 whenElapsed=+58s670ms when=2015-12-03 22:23:39\n    window=0 repeatInterval=0 count=0 flags=0x5\n    operation=PendingIntent{a58bbe0: PendingIntentRecord{\n     466e99 android broadcastIntent}}\n```", "```java\n// Function to set the Alarm\nvoid set1HourAlarm(long time) {\n  AlarmManager am= (AlarmManager) getSystemService(ALARM_SERVICE);\n  long time = in1HourTime();\n  am.set(AlarmManager.RTC, time, createPendingIntent(time));\n}\n\n// Cancel the alarm\nvoid cancel1HourAlarm(long time) {\n  AlarmManager am= (AlarmManager) getSystemService(ALARM_SERVICE);\n  // Remove the alarms matching the Intent\n  am.cancel(createPendingIntent(time));\n}\n\n// Creates the Pending Intent to set and cancel the alarm\nPendingIntent createPendingIntent(long time) {\n  Intent intent = new Intent(\"my_alarm\");\n  PendingIntent pending = PendingIntent.\n    getBroadcast(this, ALARM_CODE, intent,\n                 PendingIntent.FLAG_UPDATE_CURRENT);\n  // extras don't affect matching\n  intent.putExtra(\"exactTime\", time);\n  return pending;\n}\n// Calculate the Time\nlong in1HourTime() {\n  long delay = TimeUnit.MINUTES.toMillis(5L);\n  long time = System.currentTimeMillis() + delay;\n  return time;\n}\n```", "```java\n   void setRepeating(\n       int type, long triggerAtMillis,\n       long intervalMillis, PendingIntent operation);\n\n   void setInexactRepeating(\n       int type, long triggerAtMillis,\n       long intervalMillis, PendingIntent operation)\n```", "```java\n   AlarmManager.INTERVAL_FIFTEEN_MINUTES\n   AlarmManager.INTERVAL_HALF_HOUR\n   AlarmManager.INTERVAL_HOUR\n   AlarmManager.INTERVAL_HALF_DAY\n   AlarmManager.INTERVAL_DAY\n```", "```java\nIntent intent = new Intent(\"my_alarm\");\nPendingIntent broadcast = PendingIntent.getBroadcast(\n  this, 0, intent,PendingIntent.FLAG_UPDATE_CURRENT);\nlong start = System.currentTimeMillis() +\n             TimeUnit.HOURS.toMillis(2L);\nAlarmManager am = (AlarmManager)\n                  getSystemService(ALARM_SERVICE);\nam.setRepeating(\n  AlarmManager.RTC_WAKEUP, start,\n  AlarmManager.INTERVAL_FIFTEEN_MINUTES, broadcast);\n```", "```java\nam.setInexactRepeating(\n  AlarmManager.RTC_WAKEUP, start,\n  AlarmManager.INTERVAL_FIFTEEN_MINUTES, broadcast);\n```", "```java\nIntent intent = new Intent(\"my_alarm\");\nPendingIntent broadcast = PendingIntent.getBroadcast(\n  this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n// Updates the delivery intent extras\nintent.putExtra(\"my_int\",3);\nam.setRepeating(\n  AlarmManager.RTC_WAKEUP, System.currentTimeMillis(),\n  AlarmManager.INTERVAL_HALF_HOUR, broadcast);\n```", "```java\n void setAlarmClock(AlarmClockInfo info, PendingIntent operation)\n```", "```java\nIntent intent = new Intent(\"my_clock_alarm\");\nCalendar calendar = Calendar.getInstance();\ncalendar.add(Calendar.DATE, 1);\ncalendar.set(Calendar.HOUR_OF_DAY, 22);\ncalendar.set(Calendar.MINUTE, 0);\ncalendar.set(Calendar.SECOND, 0);\n\nPendingIntent broadcast = PendingIntent.getBroadcast(\n                                   AlarmClockActivity.this, 0, intent, \n                                   PendingIntent.FLAG_UPDATE_CURRENT);\n\n// Only applies to newer versions\nIf ( Build.VERSION.SDK_INT >= 21 ) {\n\n  AlarmClockInfo alarmInfo = new AlarmClockInfo(          \n     calendar.getTimeInMillis(),    \n     // Create a Pending intent to show Alarm Details\n     createShowDetailsPI());\n  am.setAlarmClock(alarmInfo, broadcast);\n\n} else {\n\n  am.set(AlarmManager.RTC_WAKEUP,\n         calendar.getTimeInMillis(), broadcast);\n}\n...\nPendingIntent createShowDetailsPI() {\n    ntent showIntent = new Intent(AlarmClockActivity.this,\n                                  ShowAlarmActivity.class);\n    return PendingIntent.getActivity(AlarmClockActivity.this, 0,\n                                     showIntent,                                                 \n                                     PendingIntent.\n                                       FLAG_UPDATE_CURRENT);\n}\n```", "```java\nIntent intent = new Intent(\"my_clock_alarm\");\nPendingIntent broadcast = PendingIntent.getBroadcast(\n  this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\nam.cancel(broadcast);\n```", "```java\nPendingIntent.getActivities(Context, int,Intent[],int)\nPendingIntent.getActivity(Context,int, Intent, int)\nPendingIntent.getService(Context,int, Intent, int)\nPendingIntent.getBroadcast(Context,int, Intent, int)\n```", "```java\n   Intent intent = new Intent(context, HomeActivity.class);\n   intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n   PendingIntent pending = PendingIntent.getActivity(\n       Context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\n```", "```java\n   Intent first = new Intent(context, ListActivity.class);\n   Intent second = new Intent(context, DetailActivity.class);\n   first.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\n   PendingIntent pending = PendingIntent.getActivities(\n       context, 0,\n       new Intent[]{first, second},\n       PendingIntent.FLAG_UPDATE_CURRENT);\n```", "```java\n<receiver android:name=\".chapter6.SMSDispacther\">\n  <intent-filter>\n    <action android:name=\"sms_dispacther\"/>\n  </intent-filter>\n</receiver>\n```", "```java\npublic class SMSDispatchActivity extends Activity {\n  // UI Code omitted for brevity\n  …\n  private OnClickListener mSubmit = new OnClickListener() {\n    ...\n    // Calculate the scheduled time\n    // time = now + N*hours\n    long delay = TimeUnit.HOURS.toMillis(hours);\n    long time = System.currentTimeMillis() + delay;\n\n    // Store the UI Form on the Intent\n    intent.putExtra(SMSDispatcher.TO_KEY, phoneMumber);\n    intent.putExtra(SMSDispatcher.TEXT_KEY, text);\n\n    // Create the Broadcast Pending Intent\n    PendingIntent broadcast = PendingIntent.getBroadcast(\n      getBaseContext(), 0, intent,\n      PendingIntent.FLAG_UPDATE_CURRENT);  \n\n    // Set an exact Alarm\n    if (Build.VERSION.SDK_INT >= 23) {\n      am.setExactAndAllowWhileIdle(AlarmManager.RTC_WAKEUP, time,\n                                   broadcast);\n    } else if (Build.VERSION.SDK_INT >= 19) {\n      am.setExact(AlarmManager.RTC_WAKEUP, time, broadcast);\n    } else {\n      am.set(AlarmManager.RTC_WAKEUP, time, broadcast);\n    }\n  }\n}\n```", "```java\npublic class SMSDispatcher extends BroadcastReceiver {\n\n  public static final String TO_KEY = \"to\";\n  public static final String TEXT_KEY = \"text\";\n\n  @Override\n  public void onReceive(Context context, Intent intent) {\n     // Retrieve the Destination number and the\n    // message from the intent extras\n    String to = intent.getStringExtra(TO_KEY);\n    String text = intent.getStringExtra(TEXT_KEY);\n\n    Log.i(\"SMS Dispatcher\", \"Delivering message to \" + to);\n    SmsManager sms = SmsManager.getDefault();   \n    sms.sendTextMessage(to, null, text, null, 0), null);\n  }\n}\n```", "```java\n<receiver android:name=\".chapter6.SMSDispatcher\">\n  <intent-filter>\n      <action android:name=\"sms_dispatch\"/>\n  </intent-filter>\n  <intent-filter>\n      <action android:name=\"sms_delivered\"/>\n  </intent-filter>\n</receiver>\n```", "```java\n@Override\npublic void onReceive(Context context, Intent intent) {\n\n    if ( intent.getAction().equals(DELIVERED_ACTION) ) {\n      processDispatch(context, intent);\n    } else if (intent.getAction().equals(DISPATCH_ACTION)) {\n      processDelivered(context, intent);\n    }\n}\n```", "```java\nvoid processDispatch(Context context, Intent intent) {\n  ...\n  Intent deliveredIntent = new Intent(\"sms_delivered\");\n  deliveredIntent.putExtra(SMSDispatcher.TO_KEY, to);\n  deliveredIntent.putExtra(SMSDispatcher.TEXT_KEY, text);\n  sms.sendTextMessage(to, null, text, null,\n    PendingIntent.getBroadcast(context,\n      DISPATCH_ACTION.hashCode(), deliveredIntent, 0));\n}\n```", "```java\nvoid processDelivered(Context context, Intent intent) {\n  String to = intent.getStringExtra(TO_KEY);\n  String text = intent.getStringExtra(TEXT_KEY);\n  String title = null;\n  switch (getResultCode()) {\n  case Activity.RESULT_OK:\n    title = \"Message Delivered to \" + to;\n    break;\n  default:\n    title = \"Message Delivery failed to \" + to;\n    break;\n  }\n  NotificationCompat.Builder builder = new\n    NotificationCompat.Builder(context)\n      .setContentTitle(title)\n      .setContentText(text)\n      .setSmallIcon(android.R.drawable.stat_notify_chat)\n      .setStyle(new NotificationCompat.BigTextStyle()\n         .bigText(text));\n  NotificationManager nm = (NotificationManager)\n                           context.getSystemService(\n                             Context.NOTIFICATION_SERVICE);\n  nm.notify(intent.hashCode(), builder.build());\n}\n```", "```java\npublic final PendingResult goAsync()\n```", "```java\npublic void onReceive(final Context context, final Intent intent) {\n   ...\n   final PendingResult result = goAsync();\n   AsyncTaskCompat.executeParallel(\n    new AsyncTask<Void, Void, Void>() {\n      @Override\n      protected Void doInBackground(Void... params) {\n        try {\n          // ... do some work here, for up to 10 seconds\n          processDispatch(context, intent);\n        } finally {\n          result.setResultCode(Activity.RESULT_OK);\n         result.finish();\n        }\n        return null;\n      }\n    });\n   ...\n}\n```", "```java\nIntent intent = new Intent(this,SMSDispatcherIntentService.class);\nintent.putExtra(SMSDispatcherIntentService.TO_KEY, phoneNumber);\nintent.putExtra(SMSDispatcherIntentService.TEXT_KEY, text);\nPendingIntent service = PendingIntent.getService(\n   context, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT);\nam.set(AlarmManager.RTC_WAKEUP, time, service);\n```", "```java\n<service android:name=\".chapter6.SMSDispatcherIntentService\" >\n</service>\n```", "```java\n  <uses-permission android:name=\"android.permission.WAKE_LOCK\" />\n```", "```java\nPowerManager pm = (PowerManager)ctx.getSystemService(\n                     Context.POWER_SERVICE);\nWakeLock lock = pm.newWakeLock(\n  PowerManager.PARTIAL_WAKE_LOCK, \"my_app\");\n\n// Acquire the Power Lock\nlock.acquire();\n\n// Do your work here while CPU will stay on …\n\n// Release the Power lock\nlock.release();\n```", "```java\nComponentName startWakefulService(Context context, Intent intent);\n```", "```java\nboolean completeWakefulIntent(Intent intent);\n```", "```java\npublic class WakefulSMSDispatcher extends BroadcastReceiver {\n\n  @Override\n  public void onReceive(Context context, Intent intent) {\n    // Forward intent to SMSDispatcherIntentService class,\n    // the wakeful receiver is needed in case the\n    // schedule is triggered while the device\n    // is asleep otherwise the service may not have time to\n    // receive the intent.\n    intent.setClass(context, SMSDispatcherIntentService.class);\n    WakefulBroadcastReceiver.startWakefulService(context, intent);\n  }\n}\n```", "```java\npublic class SMSDispatcherIntentService extends IntentService {\n\n  @Override\n  protected void onHandleIntent(Intent intent) {\n    try {\n      ...\n      sms.sendTextMessage(to, null, text, null, null);\n    } finally {\n      WakefulBroadcastReceiver.completeWakefulIntent(intent);\n    }\n  }\n}\n```", "```java\npublic class BootBroadcastReceiver extends BroadcastReceiver {\n\n  @Override\n  public void onReceive(Context context, Intent intent) {\n    // Retrieve the persisted alarms\n    List<SMSSchedule> persistedAlarms = getStoredSchedules();\n    // Set again the alarms\n    ...\n  }\n  List<SMSSchedule> getStoredSchedules() {...}\n}\n```", "```java\n<receiver\n    android:name=\".chapter6.BootBroadcastReceiver\"\n    android:enabled=\"true\" >\n    <intent-filter>\n        <action android:name=\"android.intent.action.BOOT_COMPLETED\" />\n    </intent-filter>\n</receiver>\n```", "```java\n<uses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\" />\n```"]