["```kt\nnew Thread(() -> {\n   for (int i = 0; i < 100; i++) {\n      System.out.println(\"T1: \" + i);\n   }\n}).start();\n\nnew Thread(() -> {\n   for (int i = 0; i < 100; i++) {\n      System.out.println(\"T2: \" + i);\n   }\n}).start();\n```", "```kt\n...\nT2: 12\nT2: 13\nT1: 60\nT2: 14\nT1: 61\nT2: 15\nT2: 16\n...\n```", "```kt\nval t1 = thread {\n    for (i in 1..100) {\n        println(\"T1: $i\")\n    }\n}\n\nval t2 = thread {\n    for (i in 1..100) {\n        println(\"T2: $i\")\n    }\n}\n```", "```kt\nval t2 = thread(start = false) {\n    for (i in 1..100) {\n        println(\"T2: $i\")\n    }\n}\n...\n// Later\nt2.start()\n```", "```kt\nThread t1 = new Thread(() -> {\n    for (int i = 0; i < 100; i++) {\n        System.out.println(\"T1: \" + i);\n    }\n});\nt1.setDaemon(true);\nt1.start();\n```", "```kt\nval t3 = thread(isDaemon = true) {\n    for (i in 1..1_000_000) {\n        println(\"T3: $i\")\n    }\n}\n```", "```kt\nvar counter = 0\nval latch = CountDownLatch(100_000)\nfor (i in 1..100_000) {\n    thread {\n        counter++\n        latch.countDown()\n    }\n}\n\nlatch.await()\nprintln(\"Counter $counter\")\n```", "```kt\nvar counter = 0\nval latch = CountDownLatch(100_000)\nfor (i in 1..100_000) {\n    thread{\n        synchronized(latch) {\n            counter++\n            latch.countDown()\n        }\n    }\n}\n\nlatch.await()\nprintln(\"Counter $counter\")\n```", "```kt\nval counter = AtomicInteger()\ntry {\n    for (i in 0..10_000) {\n        thread {\n            counter.incrementAndGet()\n            Thread.sleep(100)\n        }\n    }\n} catch (oome: OutOfMemoryError) {\n    println(\"Spawned ${counter.get()} threads before crashing\")\n    System.exit(-42)\n}\n```", "```kt\n// Try setting this to 1, number of cores, 100, 2000, 3000 and see what happens\nval pool = Executors.newFixedThreadPool(100)\n```", "```kt\n\nval counter = AtomicInteger(0)\n\nval start = System.currentTimeMillis()\nfor (i in 1..10_000) {\n    pool.submit {\n        // Do something\n        counter.incrementAndGet()\n\n        // Simulate wait on IO\n        Thread.sleep(100)\n\n        // Do something again\n        counter.incrementAndGet()\n    }\n}\n```", "```kt\npool.awaitTermination(20, TimeUnit.SECONDS)\npool.shutdown()\n\nprintln(\"Took me ${System.currentTimeMillis() - start} millis to complete ${counter.get() / 2} tasks\")\n```", "```kt\ndependencies {\n    ...\n    compile \"org.jetbrains.kotlinx:kotlinx-coroutines-core:0.21\"\n    ...\n}\n```", "```kt\nThe feature \"coroutines\" is experimental\n```", "```kt\nkotlin {\n    experimental {\n        coroutines 'enable'\n    }\n}\n```", "```kt\nval latch = CountDownLatch(10_000)\nval c = AtomicInteger()\n\nval start = System.currentTimeMillis()\nfor (i in 1..10_000) {\n    launch(CommonPool) {\n        c.incrementAndGet()\n        delay(100)\n        c.incrementAndGet()\n        latch.countDown()\n    }\n}\n\nlatch.await(10, TimeUnit.SECONDS)\n\nprintln(\"Executed ${c.get() / 2} coroutines in ${System.currentTimeMillis() - start}ms\")\n```", "```kt\nobject CoroutineFactory {\n    fun greedyLongCoroutine(index: Int) = async {\n        var uuid = UUID.randomUUID()\n        for (i in 1..100_000) {\n            val newUuid = UUID.randomUUID()\n\n            if (newUuid < uuid) {\n                uuid = newUuid\n            }\n        }\n\n        println(\"Done greedyLongCoroutine $index\")\n        latch.countDown()\n    }\n\n    fun shortCoroutine(index: Int) = async {\n        println(\"Done shortCoroutine $index!\")\n        latch.countDown()\n    }\n}\n```", "```kt\nval latch = CountDownLatch(10 * 2)\nfun main(args: Array<String>) {\n\n    for (i in 1..10) {\n        CoroutineFactory.greedyLongCoroutine(i)\n    }\n\n    for (i in 1..10) {\n        CoroutineFactory.shortCoroutine(i)\n    }\n\n    latch.await(10, TimeUnit.SECONDS)\n}\n```", "```kt\nDone greedyLongCoroutine 2\nDone greedyLongCoroutine 4\nDone greedyLongCoroutine 3\nDone greedyLongCoroutine 5\nDone shortCoroutine 1! <= You should have finished long ago!\nDone shortCoroutine 2!\nDone shortCoroutine 3!\nDone shortCoroutine 4!\nDone shortCoroutine 5!\nDone shortCoroutine 6!\nDone shortCoroutine 7!\nDone shortCoroutine 8!\nDone shortCoroutine 9!\nDone shortCoroutine 10!\nDone greedyLongCoroutine 6\nDone greedyLongCoroutine 7\nDone greedyLongCoroutine 1\nDone greedyLongCoroutine 8\nDone greedyLongCoroutine 9\nDone greedyLongCoroutine 10\n```", "```kt\nfun profile(id: String): Profile {\n    val bio = fetchBioOverHttp(id) // takes 1s\n    val picture = fetchPictureFromDB(id) // takes 100ms\n    val friends = fetchFriendsFromDB(id) // takes 500ms\n    return Profile(bio, picture)\n}\n```", "```kt\nfun profile(id: String): Profile {\n    val bio = fetchBioOverHttpThread(id) // still takes 1s\n    val picture = fetchPictureFromDBThread(id) // still takes 100ms\n    val friends = fetchFriendsFromDBThread(id) // still takes 500ms\n    return Profile(bio, picture)\n}\n```", "```kt\nfun profile(id: String): Profile {\n    val bio = fetchBioOverHttpThreadPool()\n    val picture = fetchPictureFromDBThreadPool()\n    val friends = fetchFriendsFromDBThreadPool()\n    return Profile(bio, picture)\n}\n```", "```kt\nfun fetchBioOverHttp(id: String): Bio {\n    doSomething() // 50ms\n    val result = httpCall() // 900ms\n    return Bio(result) // 50ms\n}\n```", "```kt\nsuspend fun httpCall(): Result { \n    ...\n}\n```", "```kt\nfun fetchBioOverHttp(id: String): Bio {\n   doSomething() // 50ms\n   httpCall() { // It was marked as suspend, so I can rewrite it!\n      callback(it)\n   } // Thread is released after 50ms\n}\n\n// This will be called after 950ms\nfun callback(httpResult: Result) {\n   return Bio(httpResult) \n}\n```", "```kt\nfun CoroutineFactory.longCoroutine(index: Int) = launch {\n    var uuid = UUID.randomUUID()\n    for (i in 1..100_000) {\n        val newUuid = UUID.randomUUID()\n\n        if (newUuid < uuid) {\n            uuid = newUuid\n        }\n\n        if (i % 100 == 0) {\n            yield()\n        }\n    }\n\n    println(\"Done longCoroutine $index\")\n    latch.countDown()\n}\n```", "```kt\n...\nfor (i in 1..10) {\n    CoroutineFactory.longCoroutine(i)\n}\n...\n```", "```kt\nDone shortCoroutine 0!\nDone shortCoroutine 1!\nDone shortCoroutine 2!\nDone shortCoroutine 3!\nDone shortCoroutine 5!\nDone shortCoroutine 6!\nDone shortCoroutine 7!\nDone shortCoroutine 8!\nDone shortCoroutine 9!\nDone shortCoroutine 4!\nDone longCoroutine 4 <= That makes more sense\nDone longCoroutine 2\nDone longCoroutine 3\nDone longCoroutine 9\nDone longCoroutine 5\nDone longCoroutine 1\nDone longCoroutine 10\nDone longCoroutine 6\nDone longCoroutine 7\nDone longCoroutine 8\n```", "```kt\nval j = launch(CommonPool) {\n    for (i in 1..10_000) {\n        if (i % 1000 == 0) {\n            println(i)\n            yield()\n        }\n    }\n}\n```", "```kt\nrunBlocking {\n    j.join()\n}\n```", "```kt\nval cancellable = launch {\n    try {\n        for (i in 1..1000) {\n            println(\"Cancellable: $i\")\n            computeNthFibonacci(i)\n            yield()\n        }\n    }\n    catch (e: CancellationException) {\n        e.printStackTrace()\n    }\n}\n```", "```kt\nval notCancellable = launch {\n    for (i in 1..1000) {\n        println(\"Not cancellable $i\")\n        computeNthFibonacci(i)\n    }\n}\n```", "```kt\nprintln(\"Canceling cancellable\")\ncancellable.cancel()\nprintln(\"Canceling not cancellable\")\nnotCancellable.cancel()\n```", "```kt\nrunBlocking {\n    cancellable.join()\n    notCancellable.join()\n}\n```", "```kt\nval userProfile = async {\n    delay(Random().nextInt(100))\n    \"Profile\"\n}\n```", "```kt\nval userHistory = async {\n    delay(Random().nextInt(200))\n    listOf(1, 2, 3)\n}\n```", "```kt\nrunBlocking {\n    println(\"User profile is ${userProfile.await()} and his history is ${userHistory.await()}\")\n}\n\n```", "```kt\n val coroutine = async {\n    withTimeout(500, TimeUnit.MILLISECONDS) {\n        try {\n            val time = Random().nextInt(1000)\n\n            println(\"It will take me $time to do\")\n\n            delay(time)\n\n            println(\"Returning profile\")\n            \"Profile\"\n        }\n        catch (e: TimeoutCancellationException) {\n            e.printStackTrace()\n        }\n    }\n}\n```", "```kt\nval result = try {\n    coroutine.await()\n}\ncatch (e: TimeoutCancellationException) {\n    \"No Profile\"\n}\n\nprintln(result)\n```", "```kt\nsuspend fun produceBeautifulUuid(): String {\n    try {\n        val uuids = List(1000) {\n            yield()\n            UUID.randomUUID()\n        }\n\n        println(\"Coroutine done\")\n        return uuids.sorted().first().toString()\n    } catch (t: CancellationException) {\n        println(\"Got cancelled\")\n    }\n\n    return \"\"\n}\n```", "```kt\nval parentJob = Job()\n\nList(10) {\n    async(CommonPool + parentJob) {\n        produceBeautifulUuid()\n    }\n}\n\ndelay(100)\nparentJob.cancel()\ndelay(1000) // Wait some more time\n```", "```kt\nasync(CommonPool, parent= parentJob)\n```", "```kt\nfun player(name: String,\n           input: Channel<Int>,\n           output: Channel<Int>) = launch {\n    for (m in input) {\n        val d = Random().nextInt(100)\n        println(\"$name got $m, ${if (d > m) \"won\" else \"lost\" }\")\n\n        delay(d)\n        output.send(d)\n    }\n}\n```", "```kt\nfun main(vararg args: String) {\n    val p1p2 = Channel<Int>()\n    val p2p1 = Channel<Int>()\n\n    val player1 = player(\"Player 1\", p2p1, p1p2)\n    val player2 = player(\"Player 2\", p1p2, p2p1)\n\n    runBlocking {\n        p2p1.send(0)\n        delay(1000)\n    }\n}\n```", "```kt\n...\nPlayer 1 got 62, won\nPlayer 2 got 65, lost\nPlayer 1 got 29, lost\nPlayer 2 got 9, won\nPlayer 1 got 46, won\nPlayer 2 got 82, lost\nPlayer 1 got 81, lost\n...\n```", "```kt\nval publisher: ReceiveChannel<Int> = produce {\n        for (i in 2018 downTo 1970) { // Years back to Unix\n            send(i)\n            delay(20)\n        }\n}\n```", "```kt\npublisher.consumeEach {\n    println(\"Got $it\")\n}\n```", "```kt\nGot 35\nGot 34\nGot 33\nGot 32\nGot 31\nGot 30\nGot 29\n```", "```kt\nval firstProducer = produce<String> {\n    delay(Random().nextInt(100))\n    send(\"First\")\n}\n\nval secondProducer = produce<String> {\n    delay(Random().nextInt(100))\n    send(\"Second\")\n}\n\nval winner = select<String> {\n    firstProducer.onReceive {\n        it.toLowerCase()\n    }\n    secondProducer.onReceive {\n        it.toUpperCase()\n    }\n}\n\nprintln(winner)\n```", "```kt\n// Producer 1\nval firstProducer = produce {\n    for (c in 'a'..'z') {\n        delay(Random().nextInt(100))\n        send(c.toString())\n    }\n\n}\n\n// Producer 2\nval secondProducer = produce {\n    for (c in 'A'..'Z') {\n        delay(Random().nextInt(100))\n        send(c.toString())\n    }\n}\n\n// Receiver\nprintln(select<String> {\n    firstProducer.onReceive {\n        it\n    }\n    secondProducer.onReceive {\n        it\n    }\n})\n```", "```kt\n// Receiver\nfor (i in 1..10) {\n    println(select<String> {\n        firstProducer.onReceive {\n            it\n        }\n        secondProducer.onReceive {\n            it\n        }\n    })\n}\n```", "```kt\n// Producer 2\nval secondProducer = produce {\n    for (c in 'A'..'Z') {\n        delay(Random().nextInt(100))\n        send(c.toString())\n    }\n    close()\n}\n```", "```kt\n// Receiver\nwhile(true) {\n    val result = select<String?> {\n        firstProducer.onReceiveOrNull {\n            it\n        }\n        secondProducer.onReceiveOrNull {\n            it\n        }\n    }\n\n    if (result == null) {\n        break\n    }\n    else {\n```", "```kt\n        println(result)\n    }\n}\n```", "```kt\ndata class Task (val description: String)\nval me = actor<Task> {\n    while (!isClosedForReceive) {\n        println(receive().description.repeat(10))\n    }\n}\n```", "```kt\n// Imagine this is Michael the PM\nfun michael(actor: SendChannel<Task>) {\n\n    runBlocking {\n        // He has some range of tasks\n        for (i in 'a'..'z') {\n            // That he's sending to me\n            actor.send(Task(i.toString()))\n        }\n        // And when he's done with the list, he let's me know\n        actor.close()\n        // That doesn't mean I'm done working on it, though\n    }\n}\n\n// And he's calling me\nmichael(me)\n```", "```kt\nval meAgain = actor<Task> {\n    var next = receiveOrNull()\n\n    while (next != null) {\n        println(next.description.toUpperCase())\n        next = receiveOrNull()\n    }\n}\n\n// Michael still can call me in the same manner\nmichael(meAgain)\n\n```", "```kt\nval meWithRange = actor<Task> {\n    for (t in channel) {\n        println(t.description)\n    }\n\n    println(\"Done everything\")\n```", "```kt\n}\n\nmichael(meWithRange)\n```", "```kt\ndata class ReportRequest(val name: String,\n                                 val from: LocalDate,\n                                 val to: LocalDate)\nval reportsActor = actor<ReportRequest>(capacity=100) {\n    for (req in this) {\n        generateReport(req)\n    }\n}\n```", "```kt\nreportsActor.send(ReportRequest(\"Monthly Report\",\n        LocalDate.of(2018, 1, 1),\n        LocalDate.of(2018, 1, 31)))\n```"]