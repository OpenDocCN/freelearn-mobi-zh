<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Asynchronous Programming in Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Asynchronous Programming in Android</h1></div></div></div><p>Asynchronous programming has become an important topic of discussion in the past few years, especially when using the concurrent processing capabilities available on the most recent mobile hardware.</p><p>In recent years, the number of independent processing units (cores) available on the CPU have increased, so to benefit from this new processing power, a new programming model called asynchronous programming has appeared to orchestrate the work between the several independent hardware-processing units available on the device. Asynchronous programming comes to the rescue to solve the problems that could arise from this new processing paradigm.</p><p>Android applications, since they mostly run on devices with multiple units of processing, should take advantage of asynchronous programming to scale and improve the application performance when blocking operations, and when CPU-intensive tasks are required.</p><p>Android is an open source operating system (OS) based on Linux kernel that was devised in 2003 by Andy Rubin, Nick Sears, Chris White, and Rick Miner, and then acquired by Google in July, 2005.</p><p>The Android OS, actually maintained by Google and the Open Handset Alliance, was created to provide an open mobile-device platform for devices with limited resources of computation, memory, and energy.</p><p>The platform has been incorporating advanced mobile devices standards, such as NFC and Bluetooth LE, and its scope has grown from a pure smartphone platform to a broader software platform for smart watches, TVs, tablets, and consoles.</p><p>The maintainers have been regularly updating the platform with great features and some improvements over minor and major releases since the first release.</p><p>The following diagram displays the Android versions over time:</p><div class="mediaobject"><img src="graphics/Image_B05062_01_01a.jpg" alt="Asynchronous Programming in Android"/></div><div class="section" title="Android software stack"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>Android software stack</h1></div></div></div><p>Android software <a id="id0" class="indexterm"/>stack (C libraries and Java frameworks), orchestrated by the Android runtime (Dalvik VM, and most recently, ART) was created around the Linux kernel to provide highly interactive user experiences over a well-proven group of technologies.</p><p>In each new OS version, a well-defined application interface (API) is provided to the developer in order to create applications around the new features and standards introduced with the release.</p><p>The Android application compiled code (bytecode), typically a Java compiled code, runs on a virtual machine based on Dalvik or ART.</p><div class="section" title="Dalvik runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec06"/>Dalvik runtime</h2></div></div></div><p>The <span class="strong"><strong>Dalvik VM</strong></span> (<span class="strong"><strong>DVM</strong></span>) runtime, created by <a id="id1" class="indexterm"/><span class="strong"><strong>Dan Borstein</strong></span>, was the first runtime for the platform and is a <a id="id2" class="indexterm"/>register-based virtual machine that was <a id="id3" class="indexterm"/>created to run the Java code efficiently in a constrained runtime with a limited amount of power processing, RAM, and electric power.</p><p>Dalvik's creators claim that the DVM is, on an average, around 30% more efficient than the standard Java VM (Oracle). According to Bornstein, it requires 30% less instructions and 35 % less coding units.</p><p>Clearly, Google has gone to great lengths to squeeze every drop of performance out of each mobile device to help developers build responsive applications.</p><p>The virtual machine, which runs the Java code compiled and transformed to the dex format over the dx tool, runs on a Linux process with its own memory space and file descriptors. It also manages its own group of threads.</p><p>In more advanced architectures, an Android application might run a service in a separate process and communicate over the IPC mechanism, but most of the time, it runs on a single self-contained process.</p><p>The dex file and <a id="id4" class="indexterm"/>application resources are packed in an <a id="id5" class="indexterm"/><span class="strong"><strong>Android application package</strong></span> (<span class="strong"><strong>APK</strong></span>) by the AAPT and installed over Google Play in the end user devices.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>The application store distribution model has become extremely popular on the mobile platforms since the launch of the Apple iPhone in 2007.</p></div></div><p>Since Android 2.2 the <a id="id6" class="indexterm"/>DVM comes with a trace-based <span class="strong"><strong>Just-In-Time</strong></span> (<span class="strong"><strong>JIT</strong></span>) compilation feature that actively optimizes every time the application runs some short segments of frequently used bytecode called traces.</p><p>The generated machine code provides significant performance improvements in the application execution and on the time spent on some intensive CPU tasks, and thereafter, decreases the battery power used.</p></div><div class="section" title="ART runtime"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>ART runtime</h2></div></div></div><p>The ART runtime is a <a id="id7" class="indexterm"/>new version of the DVM and was introduced to improve the runtime performance and memory consumption. The new runtime was introduced in Android 4.4 KitKat as an experimental runtime, and since the Android 5.0 Lollipop, it has become the main Android runtime.</p><p>This new runtime, making use of <a id="id8" class="indexterm"/>the <span class="strong"><strong>ahead-of-time</strong></span> (<span class="strong"><strong>AOT</strong></span>) compilation, brings new app-performance optimizations on startup time and application execution. The AOT, as opposed to DVM JIT (Just in Time), compiles the dex files during the installation time using the device dex2oat tool. The compiled code generated from the dex2oat tool generates system-dependent code for the target device and removes the delay introduced by the JIT compilation during each application execution.</p><p>The AOT compiler also reduces the number of processor cycles used by the application as it removes the time spent by the JIT compiler to convert the code into machine code, and then uses less battery power to run the application.</p><p>One of the drawbacks of the AOT compilation is the larger memory footprint in comparison with the JIT used by DVM.</p><p>With the new runtime, some <a id="id9" class="indexterm"/>improvements were also introduced in the <a id="id10" class="indexterm"/>memory allocation and on <span class="strong"><strong>Garbage Collection</strong></span> (<span class="strong"><strong>GC</strong></span>), resulting in a more responsive UI and better application experience.</p></div><div class="section" title="Memory sharing and Zygote"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Memory sharing and Zygote</h2></div></div></div><p>Basically, the <a id="id11" class="indexterm"/>platform runs an instance of DVM/ART for each application, but large optimization of the platform is brought about by the way a new DVM instance is created and managed.</p><p>A special process called the <a id="id12" class="indexterm"/>Zygote (first life cell in an animal's reproduction)—the process that all the Android applications are based on—is launched when an Android device initially boots.</p><p>The Zygote starts up a virtual machine, preloads the core libraries, and initializes various shared structures. It then waits for instructions by listening on a socket.</p><p>When a new Android application is launched, the Zygote receives a command to create a virtual machine to run the application on. It does this by forking its pre-warmed VM process and creating a new child process that shares some memory portions with the parent, using a technique <a id="id13" class="indexterm"/>called <span class="strong"><strong>copy-on-write</strong></span> (<span class="strong"><strong>COW</strong></span>).</p><p>The COW technique, available on most Unix systems, only allocates new memory on the child process when the process tries to change the memory cloned from the parent process.</p><p>This technique has some fantastic benefits, as listed in the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">First, the virtual machine and core libraries are already loaded into the memory. Not having to read this significant chunk of data from the filesystem to initialize the virtual machine drastically reduces the startup overhead.</li><li class="listitem" style="list-style-type: disc">Second, the memory in which these core libraries and common structures reside is shared by the Zygote with all other applications, resulting in saving a lot of memory when the user is running multiple apps.</li></ul></div></div></div></div>
<div class="section" title="Android process model"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Android process model</h1></div></div></div><p>Android is a <a id="id14" class="indexterm"/>multiuser, multitasking system that can run multiple applications in parallel, where all the applications attempt to acquire CPU time to execute its job.</p><p>Each application runs independently on an isolated Linux process cloned from the Zygote process, and by default, all the Android components run within the same process with the same name as the <a id="id15" class="indexterm"/>application package specified in <span class="strong"><strong>Android Application Manifest</strong></span> (<span class="strong"><strong>AAM</strong></span>).</p><p>The Linux kernel will fairly allocate small amounts of CPU time for application execution called CPU time slices. This time-slicing approach means that even a single-processor device can appear to be actively working in more than one application at the same time, when in fact, each application is taking very short turns on the CPU.</p><div class="section" title="Process ranks"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Process ranks</h2></div></div></div><p>The Android operating <a id="id16" class="indexterm"/>system tries to maintain the application running for as long as possible, but when the available memory is low, it will try to free resources in the system by killing the processes with lower importance first.</p><p>This is when process ranking <a id="id17" class="indexterm"/>comes into the picture; the Android processes are ranked in the next five categories from the higher priority to the lower priorities:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Foreground process</strong></span>: This is a <a id="id18" class="indexterm"/>process that hosts an activity or service that the user is currently interacting with: a service started in the foreground or service running its life cycle callbacks</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Visible process</strong></span>: This is a <a id="id19" class="indexterm"/>process that hosts a paused activity or service bounded to a visible activity</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Service process</strong></span>: This is a <a id="id20" class="indexterm"/>process that hosts a service not bound to a visible activity</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Background process</strong></span>: This is a process that hosts a non-visible activity; all background <a id="id21" class="indexterm"/>processes are sorted over a <span class="strong"><strong>Least-Recently-Used</strong></span> (<span class="strong"><strong>LRU</strong></span>) list, therefore, the most recently used processes are the last killed <a id="id22" class="indexterm"/>processes when they have the same rank</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Empty process</strong></span>: This is a <a id="id23" class="indexterm"/>process used to cache inactive Android components and to improve any component startup time</li></ul></div><p>When the system reaches a point that it needs to release resources, the processes available to be killed will be <a id="id24" class="indexterm"/>sorted, taking into account the process rank, last used processes, and components running.</p></div><div class="section" title="Process sandboxing"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Process sandboxing</h2></div></div></div><p>The Android application <a id="id25" class="indexterm"/>always runs under a unique <span class="strong"><strong>Linux </strong></span><a id="id26" class="indexterm"/><span class="strong"><strong>user ID</strong></span> (<span class="strong"><strong>UID</strong></span>) assigned to the application during the application installation so that the process runs on a sandboxed environment, which by default, isolates your data and code execution from other apps.</p><p>In some cases, a user could explicitly be required to share the UID with another application to have access to their data:</p><div class="informalexample"><pre class="programlisting">USER     PID   PPID  VSIZE  RSS  PC  NAME
root            319   1     1537236 31324 S zygote
….
u0_a221   5993  319   1731636 41504 S com.whatsapp
u0_a96    3018  319   1640252 29540 S com.dropbox.android
u0_a255   4892  319   1583828 34552 S com.accuweather.android…</pre></div><p>The preceding table that results from running the <code class="literal">adb shell ps</code> command in the computer with Android SDK Table is a list of Android running processes.</p><p>The first column shows the <a id="id27" class="indexterm"/><span class="strong"><strong>user identifier</strong></span> (<span class="strong"><strong>UID</strong></span>) assigned at the time of installation, the <a id="id28" class="indexterm"/>second column is the <span class="strong"><strong>process ID</strong></span> (<span class="strong"><strong>PID</strong></span>), the third column <a id="id29" class="indexterm"/>shows the <span class="strong"><strong>parent process ID</strong></span> (<span class="strong"><strong>PPID</strong></span>) that for Android applications is the Zygote process, and the last column shows the application package.</p><p>From this list, we can assure that the WhatsApp application is running under the user ID <code class="literal">u0_a221</code> with the process ID <code class="literal">5993</code> and the parent process is the Zygote process with the PID <code class="literal">319</code>.</p></div></div>
<div class="section" title="Android thread model"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Android thread model</h1></div></div></div><p>Within an Android <a id="id30" class="indexterm"/>process, there may be many threads of execution. Each thread is a separate sequential flow of control within the overall program—it executes its instructions in order, one after the other, and they also share allocated slices of CPU time managed by the operating system task scheduler.</p><p>While the application process is started by the system and prevented from directly interfering with data in the memory address space of other processes, the threads may be started by an application code and can communicate and share data with other threads within the same process. Apart from the shared data that all the threads share in the same process, a thread <a id="id31" class="indexterm"/>can use its own memory cache to store its data in its own memory space.</p><div class="section" title="The main thread"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>The main thread</h2></div></div></div><p>When the application <a id="id32" class="indexterm"/>process starts, apart from DVM housekeeping threads, the system creates a thread of execution called <code class="literal">main</code>. This thread, as the name explains, plays a crucial role in the application lifetime as it is the thread that interacts with the Android UI components, updating the state and their look on the device screen.</p><p>Moreover, by default, all the Android application components (<code class="literal">Activity</code>, <code class="literal">Service</code>, <code class="literal">ContentProvider</code>, and <code class="literal">BroadcastsReceiver</code>) are also executed over the main thread line of execution. The following image shows the lists of threads running inside an application process with the <a id="id33" class="indexterm"/>main thread at the top of the list with a unique <span class="strong"><strong>thread ID</strong></span> (<span class="strong"><strong>TID</strong></span>) assigned by the system:</p><div class="mediaobject"><img src="graphics/Image_B05062_01_02.jpg" alt="The main thread"/></div><p>The main thread, also known as UI Thread, is also the thread where your UI event handling occurs, so to keep your application as responsible as possible, you should:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Avoid any kind of <a id="id34" class="indexterm"/>long execution task, such as <span class="strong"><strong>input/output</strong></span> (<span class="strong"><strong>I/O</strong></span>) that could block the processing for an indefinite amount of time</li><li class="listitem" style="list-style-type: disc">Avoid CPU-intensive tasks that could make this thread occupied for a long time</li></ul></div><p>The following diagram <a id="id35" class="indexterm"/>displays the main interactions and components involved in the <code class="literal">Looper</code> line of execution thread:</p><div class="mediaobject"><img src="graphics/Image_B05062_01_03.jpg" alt="The main thread"/></div><p>The <span class="strong"><strong>UI/Main</strong></span> thread, which <a id="id36" class="indexterm"/>has a <code class="literal">Looper</code> facility attached to it, holds a queue of messages (<code class="literal">MessageQueue</code>) with some unit of work to be executed sequentially.</p><p>When a message is ready to be <a id="id37" class="indexterm"/>processed on the queue, the <span class="strong"><strong>Looper Thread</strong></span> pops the message from the queue and forwards it synchronously to the target handler specified on the message.</p><p>When the target <code class="literal">Handler</code> finishes its work with the current message, the <code class="literal">Looper</code> thread will be ready to process the next message available on the queue. Hence, if the <code class="literal">Handler</code> spent a noticeable amount of time processing the message, it will prevent <code class="literal">Looper</code> from processing other pending messages.</p><p>For example, when we write the code in an <code class="literal">onCreate()</code> method in the <code class="literal">Activity</code> class, it will be executed on the main thread. Likewise, when we attach listeners to user-interface components to handle taps and other user-input gestures, the listener callback executes on the main thread.</p><p>For apps that do little I/O or processing, such as applications that don't do complex math calculations, don't use the <a id="id38" class="indexterm"/>network to implement features, or don't use filesystem resources, this single thread model is fine. However, if we need to perform CPU-intensive calculations, read or write files from permanent storage, or talk to a web service, any further events that arrive while we're doing this work will be blocked until we're finished.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>Since the Android 5.0 (Lollipop), a <a id="id39" class="indexterm"/>new important thread named <span class="strong"><strong>RenderThread</strong></span> was introduced to keep the UI animations smooth even when the main thread is occupied doing stuff.</p></div></div></div><div class="section" title="The Application Not Responding (ANR) dialog"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>The Application Not Responding (ANR) dialog</h2></div></div></div><p>As you <a id="id40" class="indexterm"/>can imagine, if the <a id="id41" class="indexterm"/>main thread is busy with a heavy calculation or reading data from a network socket, it cannot immediately respond to user input such as a tap or swipe.</p><p>An application that doesn't respond quickly to user interaction will feel unresponsive—anything more than a couple of hundred milliseconds delay is noticeable. This is such a pernicious problem that the Android platform protects users from applications that do too much on the main thread.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>If an app does not respond to user input within five seconds, the user will see the <span class="strong"><strong>Application Not Responding</strong></span> (<span class="strong"><strong>ANR</strong></span>) dialog and will be offered the option to quit the application.</p></div></div><p>The following screenshot shows a typical Android ANR dialog:</p><div class="mediaobject"><img src="graphics/Image_B05062_01_04.jpg" alt="The Application Not Responding (ANR) dialog"/></div><p>Android works hard to synchronize the user interface redraws with the hardware-refresh rate. This means that it aims to redraw at the rate of 60 frames per second—that's just 16.67 ms per frame. If we do work on the main thread that takes anywhere near 16 ms, we risk affecting the frame rate, resulting in jank—stuttering animations, jerky scrolling, and so on.</p><p>Ideally, of <a id="id42" class="indexterm"/>course, we don't want to drop a single frame. Jank, unresponsiveness, and especially the ANR, offer a very poor user experience, which translates into bad reviews and unpopular applications. A rule to <a id="id43" class="indexterm"/>live by when building Android applications is: do not block the main thread!</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>Android provides a helpful strict mode setting in <span class="strong"><strong>Developer Options</strong></span> on each device, which will flash on the screen when applications perform long-running operations on the main thread.</p></div></div><p>Further protection was added to the platform in Honeycomb (API level 11) with the introduction of a new <code class="literal">Exception</code> class, <code class="literal">NetworkOnMainThreadException</code>, a subclass of <code class="literal">RuntimeException</code> that is thrown if the system detects network activity initiated on the main thread.</p></div><div class="section" title="Maintaining responsiveness"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Maintaining responsiveness</h2></div></div></div><p>Ideally then, we <a id="id44" class="indexterm"/>may want to offload any long-running operations from the main thread so that they can be handled in the background by another thread, and the main thread can continue to process user-interface updates smoothly and respond in a timely fashion to user interactions.</p><p>The typical time-consuming tasks that should be handled on a background thread include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Network communications</li><li class="listitem" style="list-style-type: disc">Input and output file operations on the local filesystem</li><li class="listitem" style="list-style-type: disc">Image and video processing</li><li class="listitem" style="list-style-type: disc">Complex math calculations</li><li class="listitem" style="list-style-type: disc">Text processing</li><li class="listitem" style="list-style-type: disc">Data encoding and decoding</li></ul></div><p>For this to be <a id="id45" class="indexterm"/>useful, we must be able to coordinate the work and safely pass data between cooperating threads—especially between background threads and the main thread, and it is exactly to solve this problem that asynchronous programming is used.</p><p>Let's get started with the synchronous versus asynchronous diagram:</p><div class="mediaobject"><img src="graphics/Image_B05062_01_05.jpg" alt="Maintaining responsiveness"/></div><p>The preceding example graphically shows the main differences between the two models of processing. On the left-hand side, the data download task occurs on the main thread, keeping the thread busy until the download data is finished. So if the user interacts with the UI and generates an event such as a touch event, the application will suffer a lag or will become unresponsive if the download task takes a substantial amount of time to finish.</p><p>On the right-hand side, the asynchronous model will hand over the download data task to another background thread, keeping the main thread available to process any event coming from the UI <a id="id46" class="indexterm"/>interaction. When the downloaded data is available, the background task could post the result to the main thread if the data handling needs to update any UI state.</p><p>When we use an asynchronous model to program our application, the Android OS will also take advantage of additional CPU cores available in the most recent devices to execute multiple background threads at the same time and increase the application's power efficiency.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>This simultaneous execution of separate code paths that potentially interact with each other is known as <a id="id47" class="indexterm"/><span class="strong"><strong>concurrency</strong></span>.</p><p>The simultaneous execution of subunits of work in parallel to complete one unit of work is known as <a id="id48" class="indexterm"/><span class="strong"><strong>parallelism</strong></span>.</p></div></div></div></div>
<div class="section" title="Concurrency in Android"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Concurrency in Android</h1></div></div></div><p>As explained before, in <a id="id49" class="indexterm"/>order to achieve a scalable application in a multicore device environment, the Android developer should be capable of creating concurrent lines of execution that combine and aggregate data from multiple resources.</p><p>The Android SDK, as it is based on a subset of Java SDK, derived from the Apache Harmony project, provides access to low-level concurrency constructs such as <code class="literal">java.lang.Thread</code>, <code class="literal">java.lang.Runnable</code>, and the <code class="literal">synchronized</code> and <code class="literal">volatile</code> keywords.</p><p>These constructs are the most basic building blocks to achieve concurrency and parallelism, and all the high-level asynchronous constructs are created around these building blocks.</p><p>The most basic one, <code class="literal">java.lang.Thread</code>, is the class that is mostly used and is the construct that creates a new independent line of execution in a Java program:</p><div class="informalexample"><pre class="programlisting">public class MyThread extends Thread {
    public void run() {
        Log.d("Generic", "My Android Thread is running ...");
    }
}</pre></div><p>In the preceding code, we <a id="id50" class="indexterm"/>subclassed <code class="literal">java.lang.Thread</code> to create our own independent line of execution. When <code class="literal">Thread</code> is started, the run method will be called automatically and it will print the message on the Android log:</p><div class="informalexample"><pre class="programlisting">MyThread myThread = new MyThread();
myTread.start();</pre></div><p>At this time, we will create an instance of our <code class="literal">MyThread</code>, and when we start it in the second line, the system creates a thread inside the process and executes the <code class="literal">run()</code> method.</p><p>Other helpful thread-related methods include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Thread.currentThread()</code>: This retrieves the current running instance of the thread</li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread.sleep(time)</code>: This pauses the current thread from execution for the given period of time</li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread.getName()</code> and <code class="literal">Thread.getId()</code>: These get the name and TID, respectively so that they can be useful for debugging purposes</li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread.isAlive()</code>: This checks whether the thread is currently running or it has already finished its job</li><li class="listitem" style="list-style-type: disc"><code class="literal">Thread.join()</code>: This blocks the current thread and waits until the accessed thread finishes its execution or dies</li></ul></div><p>The <code class="literal">Runnable</code> interface, which is another building block that comes from the Java API, is an interface defined to specify and encapsulate code that is intended to be executed by a Java thread instance or any other class that handles this <code class="literal">Runnable</code>:</p><div class="informalexample"><pre class="programlisting">package java.lang;

public interface Runnable {   
    public abstract void run();
}</pre></div><p>In the following code, we basically created the <code class="literal">Runnable</code> subclass so that it implements the <code class="literal">run()</code> method and can be passed and executed by a thread:</p><div class="informalexample"><pre class="programlisting">public class MyRunnable implements Runnable {

    public void run(){
        Log.d("Generic","Running in the Thread " +
                        Thread.currentThread().getId());
	// Do your work here
	...
    }
}</pre></div><p>Now our <code class="literal">Runnable</code> subclass can be passed to <code class="literal">Thread</code> and is executed independently in the concurrent line of execution:</p><div class="informalexample"><pre class="programlisting">Thread thread = new Thread(new MyRunnable());
thread.start();</pre></div><p>While starting new threads is easy, concurrency is actually a very difficult thing to do. Concurrent software faces <a id="id51" class="indexterm"/>many issues that fall into two broad categories: correctness (producing consistent and correct results) and liveness (making progress towards completion). <code class="literal">Thread</code> creation could also cause some performance overhead, and too many threads can reduce the performance, as the OS will have switch between these lines of execution.</p><div class="section" title="Correctness issues in concurrent programs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Correctness issues in concurrent programs</h2></div></div></div><p>A <a id="id52" class="indexterm"/>common example of a correctness problem occurs when two threads need to modify the value of the same variable based on its current value. Let's consider that we have a <code class="literal">myInt</code> integer variable with the current value of 2.</p><p>In order to increment <code class="literal">myInt</code>, we first need to read its current value and then add 1 to it. In a single-threaded world, the two increments would happen in a strict sequence—we will read the initial value 2, add 1 to it, set the new value back to the variable, and then repeat the sequence. After the two increments, <code class="literal">myInt</code> holds the value 4.</p><p>In a multithreaded environment, we will run into potential timing issues. It is possible that two threads trying to increment the variable would both read the same initial value 2, add 1 to it, and set the result (in both cases, 3) back to the variable:</p><div class="informalexample"><pre class="programlisting">int myInt = 2;
...
public class MyThread extends Thread {

    public void run() {
         super.run();
         myInt++;
   }
}
...
Thread t1 = new MyThread();
Thread t2 = new MyThread();
t1.start();
t2.start();</pre></div><p>Both threads behaved correctly in their localized view of the world, but in terms of the overall program, we will clearly have a correctness problem; 2 + 2 should not equal 3! This kind of timing issue is known as a race condition.</p><p>A common <a id="id53" class="indexterm"/>solution to correctness problems, such as race conditions, is mutual exclusion—preventing multiple threads from accessing certain resources at the same time. Typically, this is achieved by ensuring that threads acquire an exclusive lock before reading or updating shared data.</p><p>To achieve this correctness, we can make use of the <code class="literal">synchronized</code> construct to solve the correctness issue on the following piece of code:</p><div class="informalexample"><pre class="programlisting">Object lock = new Object();
public class MyThread extends Thread {
    public void run() {
        super.run();
        synchronized(lock) {
            myInt++;
        }
    }
}</pre></div><p>In the preceding code, we used the intrinsic lock available in each Java object to create a mutually exclusive scope of code that will enforce that the increment sentence will work properly and will not suffer from correctness issues as explained previously. When one of the threads gets access to the protected scope, it is said that the thread acquired the lock, and after the thread gets out of the protected scope, it releases the lock that could be acquired by another thread.</p><p>Another way to create mutually exclusive scopes is to create a method with a synchronized method:</p><div class="informalexample"><pre class="programlisting">int myInt = 2;
synchronized void increment(){
    myInt++;
}
...
public class <span class="strong"><strong>IncrementThread</strong></span> extends Thread {
    public void run() {
        super.run();
        increment();
    }
}</pre></div><p>The synchronized method will use the object-intrinsic lock, where <code class="literal">myInt</code> is defined to create a <a id="id54" class="indexterm"/>mutually exclusive zone so <code class="literal">IncrementThread</code>, incrementing <code class="literal">myInt</code> through the <code class="literal">increment()</code>, will prevent any thread interference and memory consistency errors.</p></div><div class="section" title="Liveness issues in concurrent programs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Liveness issues in concurrent programs</h2></div></div></div><p>Liveness <a id="id55" class="indexterm"/>can be thought of as the ability of the application to do useful work and make progress towards goals. Liveness problems tend to be an unfortunate side effect of the solution to the correctness problems.</p><p>Both properties should be achieved in a proper concurrent program, notwithstanding the correctness is concerned with making progress in a program preventing a deadlock, livelock, or starvation from happening, and the correctness is concerned with making consistent and correct results.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>Deadlock is a situation where two or more threads are unable to proceed because each is waiting for the others to do something. Livelock is a situation where two or more threads continuously change their states in response to the changes in the other threads without doing any useful work.</p></div></div><p>By locking access to data or system resources, it is possible to create bottlenecks where many threads are contending to access a single lock, leading to potentially significant delays.</p><p>Worse, where multiple locks are used, it is possible to create a situation where no thread can make <a id="id56" class="indexterm"/>progress because each requires exclusive access to a lock that another thread currently owns—a situation known as a deadlock.</p></div><div class="section" title="Thread coordination"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Thread coordination</h2></div></div></div><p>Thread <a id="id57" class="indexterm"/>coordination is an important topic in concurrent programming, especially when we want to perform the following tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Synchronize access of threads to shared resources or shared memory:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Shared database, files, system services, instance/class variables, or queues</li></ul></div></li><li class="listitem" style="list-style-type: disc">Coordinate work and execution within a group of threads:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Parallel execution, pipeline executions, inter-dependent tasks, and so on</li></ul></div></li></ul></div><p>When we want to coordinate thread efforts to achieve a goal, we should try to avoid waiting or polling mechanisms that keep the CPU busy while we wait for an event in another thread.</p><p>The following example shows us a small loop where we will continuously occupy the CPU while we wait for a certain state change to happen:</p><div class="informalexample"><pre class="programlisting">while(!readyToProcess) {
  // do nothing .. busy waiting wastes processor time.
}</pre></div><p>To overcome the coordination issue, and to implement our own constructs, we should use some low-level signals or messaging mechanisms to communicate between threads and coordinate the interaction.</p><p>In Java, every object has the <code class="literal">wait()</code>, <code class="literal">notify()</code>, and <code class="literal">notifyAll()</code>methods that provide low-level mechanisms to send thread signals between a group of threads and put a thread in a waiting state until a condition is met.</p><p>This mechanism, also known as <span class="emphasis"><em>monitor</em></span> or <span class="emphasis"><em>guard</em></span>, is a design pattern commonly used in another languages and it ensures that only one thread can enter a given section of code at any given time with an ability to wait until a condition happens.</p><p>This design pattern, in comparison with our previous example, delivers a better and efficient CPU-cycle management while waiting for any particular situation to happen on another thread, and is generally used in situations where we need to coordinate work between different lines of execution.</p><p>In the following code example, we are going to explain how to use this construct to create a basic multithreaded <code class="literal">Logger</code> with 10 threads that will wait in the monitor section until a message is pushed (condition) by any other thread in the application.</p><p>The <code class="literal">Logger</code>, which is responsible for logging on to the output, has a queue with a maximum of 20 positions to store the new logging text messages:</p><div class="informalexample"><pre class="programlisting">public class Logger {
    LinkedList&lt;String&gt; queue = new LinkedList&lt;String&gt;();
    private final int MAX_QUEUE_SIZE = 20;
    private final int MAX_THREAD_COUNT = 10;</pre></div><p>In the next code, we will create a <code class="literal">Runnable</code> unit of work that runs indefinitely and retrieves a message from the queue to print the message on the Android log.</p><p>After that, we will create and start 10 threads that are going to execute the <code class="literal">Runnable</code> unit of work <code class="literal">task</code>:</p><div class="informalexample"><pre class="programlisting">public void start() {
    // Creates the Loop as a Runnable
    Runnable task = new Runnable() {
        @Override
        public void run() {
            while(true) {
                String message = pullMessage();
                Log.d(Thread.currentThread().
                         getName(),message);
		     // Do another processing
             }
         }
     };
    // Create a Group of Threads for processing
    for(int i=0; i&lt; MAX_THREAD_COUNT; i++){
         new Thread(task).start();
    }
 }</pre></div><p>The <code class="literal">pullMessage()</code>, which is a <code class="literal">synchorized</code> method, runs a mutual exclusion and puts the thread in the waiting state when it reaches the <code class="literal">wait()</code> method. All the created threads will stay in this state until another thread calls <code class="literal">notifyAll()</code>:</p><div class="informalexample"><pre class="programlisting">// Pulls a message from the queue
// Only returns when a new message is retrieves
// from the queue.
private synchronized String pullMessage(){
    while (queue.isEmpty()) {
        try {
            wait();
        } catch (InterruptedException e) { ... }
    }
    return queue.pop();
}
// Push a new message to the tail of the queue if
// the queue has available positions
public synchronized void pushMessage(String logMsg) {
    if ( queue.size()&lt; MAX_QUEUE_SIZE ) {
        queue.push(logMsg);      
        notifyAll();
    }
}</pre></div><p>When any thread is in the waiting state, it releases the lock temporarily and gives a chance to another thread to enter the mutual exclusion to push new messages or enter into the wait state.</p><p>In the following snippet, we will first create the <code class="literal">Logger</code> instance and then we will call the start method to start the working threads and we will push 10 messages into a queue of work to be processed.</p><p>When the <code class="literal">pushMessage()</code>method is invoked, a new logging message is inserted at the end of the queue and <code class="literal">notifiyAll()</code> is invoked to notify all the available threads.</p><p>As the <code class="literal">pullMessage()</code> method runs in a mutual-exclusion (synchronized) zone, only one thread will wake up and return from the <code class="literal">pull</code> method. Once <code class="literal">pullMessage()</code> returns, the logging message is printed:</p><div class="informalexample"><pre class="programlisting">Logger logger =new Logger();
logger.start();
for ( int i=0; i&lt; 10 ; i++) {
    ...
    logger.pushMessage(date+" : "+"Log Message #"+i);
}</pre></div><p>In the following console output, we have an example of the output that this code will generate and the logging messages are processed by any available threads in an ordered manner:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>D/Thread-108(23915): &lt;Date&gt;: Log Message #0</strong></span>
<span class="strong"><strong>D/Thread-109(23915): ...: Log Message #1</strong></span>
<span class="strong"><strong>D/Thread-110(23915): ...: Log Message #2</strong></span>
<span class="strong"><strong>D/Thread-111(23915): ...: Log Message #3</strong></span>
</pre></div><p>This kind of low-level construct can also be used to control shared resources (polling) to manage background execution (parallelism) and control thread pools.</p></div><div class="section" title="Concurrent package constructs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Concurrent package constructs</h2></div></div></div><p>Other Java <a id="id58" class="indexterm"/>concurrent constructs provided by <code class="literal">java.util.concurrent</code>, which are also available on Android SDK are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Lock objects</strong></span> (<code class="literal">java.util.concurrent</code>): They implement locking behaviors with a higher level idiom.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Executors</strong></span>: These are high-level APIs to launch and manage a group of thread executions (<code class="literal">ThreadPool</code>, and so on).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Concurrent collections</strong></span>: These are the collections where the methods that change the collection are protected from synchronization issues.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Synchronizers</strong></span>: These are high-level constructs that coordinate and control thread execution (Semaphore, Cyclic Barrier, and so on).</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Atomic variables</strong></span> (<code class="literal">java.util.concurrent.atomic</code>): These are classes that provide thread-safe operations on single variables. One example of it is <code class="literal">AtomicInteger</code> that could be used in our example to solve the correctness issue.</li></ul></div><p>Some Android-specific constructs use these classes as basic building blocks to implement their concurrent behavior, although they could be used by a developer to build custom concurrent constructs to solve a specific use case.</p><div class="section" title="Executor framework"><div class="titlepage"><div><div><h3 class="title"><a id="ch01lvl3sec01"/>Executor framework</h3></div></div></div><p>The <code class="literal">Executor</code> <a id="id59" class="indexterm"/>framework is another framework available on <code class="literal">java.util.concurrent</code> that provides an interface to submit <code class="literal">Runnable</code> tasks, decoupling the task submission from the way the task will run:</p><div class="informalexample"><pre class="programlisting">public interface Executor {
  void execute(Runnable command);
}</pre></div><p>Each <code class="literal">Executor</code>, which implements the interface that we defined earlier, can manage the asynchronous resources, such as thread creation destruction and caching, and task queueing in a variety of ways to achieve the perfect behavior to a specific use case.</p><p>The <code class="literal">java.util.concurrent</code> comes with a group of implementations available out of the box that cover most generic use cases, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Executors.newCachedThreadPool()</code>: This is a thread poll that could grow and reuse previously created threads</li><li class="listitem" style="list-style-type: disc"><code class="literal">Executors.newFixedThreadPool</code> (<code class="literal">nThreads</code>): This is a thread pool with a fixed number of threads and a message queue for store work</li><li class="listitem" style="list-style-type: disc"><code class="literal">Executors.newSingleThreadPool()</code>: This is similar to newFixedThreadPool, but with only one working thread</li></ul></div><p>To run a task on <code class="literal">Executor</code>, the <a id="id60" class="indexterm"/>developer has to invoke <code class="literal">execute()</code> by passing <code class="literal">Runnable</code> as an argument:</p><div class="informalexample"><pre class="programlisting">public class MyRunnable implements Runnable {
    public void run() {
        Log.d("Generic", "Running From Thread " +
              Thread.currentThread().getId());   
	 // Your Long Running Computation Task
    }
}
public void startWorking(){
    Executor executor = Executors.newFixedThreadPool(5);
    for ( int i=0; i &lt; 20; i++ ) {
        executor.execute(new MyRunnable());
    }
}</pre></div><p>In the preceding code, we created <code class="literal">ThreadPool</code> over the factory methods with a fixed number of five threads ready to process work.</p><p>After the <code class="literal">ExecutorService</code> instance creation, new <code class="literal">Runnable</code> tasks are posted for asynchronous processing.</p><p>When a new unit of work is submitted, a thread that is free to work is chosen to handle the task; but when all the threads are occupied, <code class="literal">Runnable</code> will wait in a local queue until a thread is ready to work.</p></div></div></div>
<div class="section" title="Android primary building blocks"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Android primary building blocks</h1></div></div></div><p>A typical Android <a id="id61" class="indexterm"/>application is composed of the following four main building blocks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.Activity</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.app.Service</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.content.BroadcastReceiver</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">android.content.ContentProvider</code></li></ul></div><p>The Activity, Service, and <code class="literal">BroadcastReceiver</code> are activated explicitly or implicitly over an asynchronous message called <code class="literal">Intent</code>.</p><p>Each of these building blocks have their own life cycle, so they could be exposed to different concurrency issues if an asynchronous architecture is used to offload work from the main thread.</p><div class="section" title="Activity concurrent issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Activity concurrent issues</h2></div></div></div><p>The <a id="id62" class="indexterm"/>Activity building block has a tight connection with a presentation layer because it's the entity that manages the UI view over a defined tree of fragments and views that display information and respond to user interactions.</p><p>Android applications are typically composed of one or more subclasses of <code class="literal">android.app.Activity</code>. An Activity instance has a very well-defined lifecycle that the system manages through the execution of lifecycle method callbacks, all of which are executed on the main thread.</p><p>To keep the application responsive and reactive, and the activity transition smooth, the developer should understand the nature of each Activity lifecycle callback.</p><p>The most important callbacks on the Activity lifecycle are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onCreate()</code>: At this state, Activity is not visible, but it is here where all the private Activity resources (views and data) are created. The long and intensive computations should be done asynchronously in order to decrease the time when the users don't get a visual feedback during an Activity transition.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onStart()</code>: This is the callback called when the UI is visible, but not able to interact on the screen. Any lag here could make the user angry as any touch event generated at this stage is going to be missed by the system.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onResume()</code>: This is the callback called when Activity is going to be in the foreground and at an interactable state.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onPause()</code>: This is a callback called when Activity is going to the background and is not visible. Computations should end quickly as the next Activity will not resume until this method ends.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onStop()</code>: This is a callback called when Activity is no longer visible, but can be restarted.</li><li class="listitem" style="list-style-type: disc"><code class="literal">onDestroy()</code>: This is a callback called when the Activity instance is going to be destroyed in the background. All the resources and references that belong to this instance have to be released.</li></ul></div><p>An Activity <a id="id63" class="indexterm"/>instance that is completed should be eligible for garbage collection, but background threads that refer to Activity or part of its view hierarchy can prevent garbage collection and create a memory leak.</p><p>Similarly, it is easy to waste CPU cycles (and battery life) by continuing to do background work when the result can never be displayed as Activity is completed.</p><p>Finally, the Android platform is free at any time to kill processes that are not the user's current focus. This means that if we have long-running operations to complete, we need some way of letting the system know not to kill our process yet.</p><p>All of this complicates the do-not-block–the-main-thread rule as we need to worry about canceling background work in a timely fashion or decoupling it from the Activity lifecycle where appropriate.</p></div><div class="section" title="Manipulating the user interface"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec19"/>Manipulating the user interface</h2></div></div></div><p>The other <a id="id64" class="indexterm"/>Android-specific problem lies not in what you can do with the UI thread, but in what you cannot do.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>You cannot manipulate the user interface from any thread other than the main thread.</p></div></div><p>This is because the user interface toolkit is not thread-safe, that is, accessing it from multiple threads may cause correctness problems. In fact, the user interface toolkit protects itself from potential problems by actively denying access to user interface components from threads other than the one that originally created these components.</p><p>If the system detects this, it will instantly notify the application by throwing <code class="literal">CalledFromWrongThreadException</code>.</p><p>The final challenge then lies in safely synchronizing background threads with the main thread so that the main thread can update the user interface with the results of the background work.</p><p>If the developer has access to an <code class="literal">Activity</code> instance, the <code class="literal">runOnUiThread</code> instance method can be used to update the UI from a background thread.</p><p>The method <a id="id65" class="indexterm"/>accepts a <code class="literal">Runnable</code> object like the one used to create an execution task for a thread:</p><div class="informalexample"><pre class="programlisting">public final void runOnUiThread (Runnable)</pre></div><p>In the following example, we are going to use this facility to publish the result from a synonym search that was processed by a background thread.</p><p>To accomplish the goal during the <code class="literal">OnCreate</code> activity callback, we will set up <code class="literal">onClickListener</code> to run <code class="literal">searchTask</code> on a created thread:</p><div class="informalexample"><pre class="programlisting">// Get the Views references
Button search = (Button) findViewById(R.id.searchBut);
final EditText word = (EditText) findViewById(R.id.wordEt);

// When the User clicks on the search button 
// it searches for a synonym
search.setOnClickListener(new View.OnClickListener() {
    @Override
    public void onClick(View v) {
        // Runnable that Searchs for the synonym and
        // and updates the UI.
        Runnable searchTask = new Runnable() {
            @Override
            public void run() {
                // Retrieves the synonym for the word
                String result = searchSynomim(
                   word.getText().toString());
                // Runs the Runnable SetSynonymResult
                // to publish the result on the UI Thread
                runOnUiThread(new SetSynonymResult(result));
            }
        };
        // Executes the search synonym an independent thread
        Thread thread = new Thread(searchTask);
        Thread.start();
    }
});</pre></div><p>When the user clicks on the <span class="strong"><strong>Search</strong></span> button, we will create a <code class="literal">Runnable</code> anonymous class that searches for the word typed in <code class="literal">R.id.wordEt EditText</code> and starts the thread to execute <code class="literal">Runnable</code>.</p><p>When the search completes, we will create an instance of <code class="literal">Runnable</code> <code class="literal">SetSynonymResult</code> to publish <a id="id66" class="indexterm"/>the result back on the synonym <code class="literal">TextView</code> over the UI thread:</p><div class="informalexample"><pre class="programlisting">class SetSynonymResult implements Runnable {
    final String synonym;

    SetSynonymResult(String synonym){
      this.synonym = synonym;
    }
    public void run() {
      TextView tv = (TextView)findViewById(R.id.synonymTv);
      tv.setText(this.synonym);
    }
};</pre></div><p>This technique is sometime not the most convenient one, especially when we don't have access to an Activity instance; therefore, in the following chapters, we are going to discuss simpler and cleaner techniques to update the UI from a background computing task.</p></div><div class="section" title="Service concurrent issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec20"/>Service concurrent issues</h2></div></div></div><p>These are <a id="id67" class="indexterm"/>the Android entities that run in the background, which usually perform tasks in the <code class="literal">name</code> application that does not require any user interaction.</p><p>
<code class="literal">Service</code>, by default, runs in the main thread of the application process. It does not create its own thread, so if your <code class="literal">Service</code> is going to do any blocking operation, such as downloading an image, play a video, or access a network API, the user should design a strategy to offload the time of the work from the main thread into another thread.</p><p>As <code class="literal">Service</code> could have its own concurrent strategy, it should also take into account that, like Activity, it should update the UI over the main thread, so a strategy to post back the results from the background into the main loop is imperative.</p><p>In the Android services domain, the way the service is started distinguishes the nature of <code class="literal">Service</code> into the following two groups:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Started services</strong></span>: This is the service that is started by <code class="literal">startService()</code> that can run <a id="id68" class="indexterm"/>definitively even if the component that started it was destroyed. A started service does not interact directly with the component that started it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bound services</strong></span>: This service exists while at least one Android component is bounded to it by calling <code class="literal">bindService()</code>. It provides a two-way (client-server) communication channel for communication between components.</li></ul></div></div><div class="section" title="Started services issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec21"/>Started services issues</h2></div></div></div><p>When we <a id="id69" class="indexterm"/>implement a started service, any application component is able to start it when it invokes the <code class="literal">startService(Intent)</code> method. Once the system receives <code class="literal">startService(Intent)</code> and the service is not yet <a id="id70" class="indexterm"/>started, the system calls <code class="literal">onCreate()</code> and then <code class="literal">onStartCommand()</code> with the arguments encapsulated on an Intent object. If the <code class="literal">Service</code> already exists, only <code class="literal">onStartCommand()</code> is invoked.</p><p>The callbacks used by a started service are as follows:</p><div class="informalexample"><pre class="programlisting">// Called every time a component starts the Service
// The service arguments are passed over the intent
int onStartCommand(Intent intent, int flags, int startId)

// Used to initialize your Service resources
void onCreate()

// Used to release your Service resources
void onDestroy()</pre></div><p>In the <code class="literal">onStartCommand()</code> callback, once a long computing task is required to handle the service request, a handover to the background threads should be explicitly implemented and coordinated in order to avoid an undesired ANR:</p><div class="informalexample"><pre class="programlisting">int onStartCommand (Intent intent, int flags, int startId){
    // Hand over the request processing to your
    // background tasks
...
}</pre></div><p>When the service is done, and it needs to publish results to the UI, a proper technique to communicate <a id="id71" class="indexterm"/>with the main thread should <a id="id72" class="indexterm"/>be used.</p></div><div class="section" title="Bound services issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec22"/>Bound services issues</h2></div></div></div><p>A bound <a id="id73" class="indexterm"/>service generally used when a strong interaction between an Android component and a service is required.</p><p>When the service runs on the <a id="id74" class="indexterm"/>same process, the interaction between the Android component (client) and the bound service (server) is always provided by a <code class="literal">Binder</code> class returned on <code class="literal">onBind()</code>. With the <code class="literal">Binder</code> instance on hand, the client has access to the service's public methods, so when any component invokes the bound service public methods, the component should be aware of the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When a long running operation is expected to take place during the method invocation, the invocation must occur in a separate thread</li><li class="listitem" style="list-style-type: disc">If the method is invoked in a separated thread, and the service wants to update the UI, the service must run the update over the main thread:<div class="informalexample"><pre class="programlisting">public class MyService extends Service {
 
    // Binder given to clients
    private final IBinder mBinder = new MyBinder();

     public class MyBinder extends Binder {
         MyService getService() {
             // Return this instance of MyService
             // so clients can call public methods
             return MyService.this;
        }
    }
    @Override
   
    public IBinder onBind(Intent intent) {
        return mBinder;
    }

     /** Method for clients */
    public int myPublicMethod() {
      //
    }
...</pre></div></li></ul></div></div></div>
<div class="section" title="Service in a separate process"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Service in a separate process</h1></div></div></div><p>When an <a id="id75" class="indexterm"/>Android service runs on its own process, it runs in an independent process, with its own address space, making the communication with the main process UI thread harder to implement the following:</p><div class="informalexample"><pre class="programlisting">&lt;service
  android:name="SynonymService"
  android:process=":my_synonnym_search_proc"
  android:icon="@drawable/icon"
  android:label="@string/service_name"
  &gt;
&lt;/service&gt;</pre></div><p>To implement a service <a id="id76" class="indexterm"/>in a different process, we need to use an <span class="strong"><strong>inter-process communication</strong></span> (<span class="strong"><strong>IPC</strong></span>) technique to send messages between your application and the service.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>IPC is the activity of sharing data across multiple processes, usually using a well-defined communication protocol. It typically has a process that acts as the client and a process that acts as the server.</p></div></div><p>There are two technologies available on the Android SDK to implement this, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>AIDL</strong></span> (<span class="strong"><strong>Android Interface Definition Language</strong></span>): This allows you to define an <a id="id77" class="indexterm"/>interface over a set of primitive types. It allows you create multithreaded processing services, but it adds other levels of complexity to your implementation. This is only recommended to advanced programmers.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Messenger</strong></span>: This is a simple interface that creates a queue of work for you in the service side. This executes all the tasks sequentially on single thread managed by a <code class="literal">Handler</code>.</li></ul></div><p>We haven't given more details about these techniques yet; however, an example of this construct is going to be presented later in a more advanced chapter where all the concepts involved are more mature.</p><div class="section" title="Broadcast receiver concurrent issues"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec23"/>Broadcast receiver concurrent issues</h2></div></div></div><p>This building <a id="id78" class="indexterm"/>block is a component that subscribes to system and application events and is notified when these events occur on the system. The broadcast receivers are defined statically in the application manifest or dynamically via the <code class="literal">Context.registerReceiver()</code>.</p><p>The broadcast received is activated though the <code class="literal">onReceive()</code>callback and this method runs on the main thread, blocking another Android component from running if we try to execute time-consuming tasks.</p><p>Once <code class="literal">onReceive()</code> finishes, the system considers the object inactive and can release the resources attached to this instance and recycle the whole object. This behavior has a tremendous impact on what we can do inside, because if we hand over some processing to a concurrent thread, the resources that belong to <code class="literal">BroadcastReceiver</code> might be recycled and are no longer available, or in an extreme case, the process could be killed if there were no important components running on it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip02"/>Tip</h3><p>Android version 11 introduced the <code class="literal">goAsync()</code>method on the broadcast receiver to keep the broadcast active after returning from the <code class="literal">onReceive()</code> function.</p></div></div></div><div class="section" title="Android concurrency constructs"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec24"/>Android concurrency constructs</h2></div></div></div><p>The good <a id="id79" class="indexterm"/>news is that the Android platform provides specific constructs to address the concurrency general issues and to solve the specific problems presented by Android.</p><p>There are constructs that allow us to defer tasks to run later on the main thread, communicate easily between cooperating threads, and issue work to the managed pools of worker threads and reintegrate the results back in the main thread.</p><p>There are solutions to the constraints of the Activity lifecycle, both for medium-term operations that closely involve the user interface and longer-term work that must be completed even if the user leaves the application.</p><p>While some of these constructs were only introduced with newer releases of the Android platform, they are available through the support libraries, and with a few exceptions, the examples in this book <a id="id80" class="indexterm"/>target devices that run API level 8 (Android 2.2) and higher versions.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>In this chapter, we took a detailed look at the available Android runtimes, Android processes, and thread models.</p><p>We then introduced the concurrent issues that we would cope with when we try to implement robust concurrent programs.</p><p>Finally, we listed the basic concurrent building blocks available on the SDK to design concurrent programs.</p><p>In the next chapter, we'll take a look at some Android-specific low-level building blocks on which the other concurrency mechanisms are built: <code class="literal">Handler</code>, <code class="literal">Looper</code>, and <code class="literal">LooperThread</code>.</p></div></body></html>