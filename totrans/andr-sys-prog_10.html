<html><head></head><body>
        <section>

            <header>
                <h1 class="header-title">Enabling Graphics</h1>
            </header>

            <article>
                
<p>In the last chapter, we learnt how to boot the x86vbox device using PXE and NFS. We can boot the device to an embedded Linux environment, which is the first stage of the Android-x86 boot. In this stage, we can use a debug console to verify the status of the system so that we can make sure everything is right before we start the real Android system. In this chapter, we will talk about the first issue we meet during Android system boot up. This is about how to enable the Android graphics system for the x86vbox device. We will cover the following topics in this chapter:</p>
<ul>
<li>Overview of Android graphics architecture</li>
<li>Delving into graphics HAL</li>
<li>Analyzing the Android emulator graphics HAL for comparison</li>
</ul>
<div class="packt_infobox">The graphics system probably is the most complicated software stack in the Android system architecture.<br/>
As you will see, the content in this chapter is much longer than the rest. Reading and understanding the content in this chapter may be harder. What I suggest is that you can open a source code editor and load the relevant source code while you read this chapter. This will help you a lot to understand the source code and the points that I want to address in this chapter.</div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Introduction to the Android graphics architecture</h1>
            </header>

            <article>
                
<p>The graphics system in Android is similar to the architecture that we discussed in <a href="e0f861c2-5832-402f-89d3-cfc75785e759.xhtml">Chapter 3</a>, <em><span class="ChapterrefPACKT">Discovering Kernel, HAL, and Virtual Hardware</span></em>. There we used goldfish lights HAL as an example to do a detailed analysis from the application level to the HAL and device driver layer. This analysis helps us to understand the Android architecture vertically.</p>
<p>However, the graphics system could be the most complicated system in the Android architecture. It would require another book to give a detailed introduction to the Android graphics system. The focus of this book is on how we can port Android systems to a new hardware platform. To focus on this goal, we will address the graphics HAL in this chapter instead of discussing the entire graphics system. The graphics system will work if we can choose the right graphics HAL and configure it right.</p>
<p>According to Google documents about the implementation of graphics, Android graphics support requires the following components:</p>
<ul>
<li>EGL driver</li>
<li>OpenGL ES 1.x driver</li>
<li>OpenGL ES 2.0 driver</li>
<li>OpenGL ES 3.x driver (optional)</li>
<li>Vulkan (optional)</li>
<li>Gralloc HAL implementation</li>
<li>Hardware Composer HAL implementation</li>
</ul>
<p>In the preceding list, OpenGL ES implementation is the most complicated component in the graphics system. We will discuss how it is chosen and integrated in an Android emulator and Android-x86. We won't go into the details of how to analyze the OpenGL ES implementation, but we will have an overview about the underlying OpenGL ES libraries. OpenGL ES 1.x and 2.0 must be supported in an Android system. OpenGL ES 3.x is an optional component at the moment. EGL driver is usually implemented as part of the OpenGL ES implementation and we will see this when we discuss the Android emulator and Android-x86 (x86vbox) graphics system.</p>
<p>Vulkan is a new generation of GPU API from Khronos Group. Vulkan is new and optional and was only introduced in Android 7. Covering Vulkan is beyond the scope of this book, so we won't discuss it. Gralloc HAL is the one that handles the graphics hardware and it is our focus for a deep analysis. In most of the porting work of the graphics system, Gralloc HAL is the key to enabling graphics.</p>
<p>Hardware composer is part of the graphics HAL. However, it is not a component that we must have for Android emulator or Android-x86. The <strong>Hardware Composer</strong> (<strong>HWC</strong>) HAL is used to composite surfaces to the screen. The HWC abstracts objects such as overlays and helps offload some work that would normally be done with OpenGL.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="482" width="563" class=" image-border" src="assets/image_10_001.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Android graphics architecture</div>
<p>As we can see from the preceding Android graphics architecture diagram, we can also divide related components into different layers in the Android architecture as we did in previous chapters. This architecture diagram is a simplified view of a graphics system. <strong>SurfaceFlinger</strong> is the system service to the application layer for graphics-related system support. <strong>SurfaceFlinger</strong> will connect to the <strong>OpenGL ES</strong> library and <strong>HAL</strong> layer components to perform the actual work. In the <strong>HAL</strong>, we have <strong>HWC</strong>, <strong>gralloc</strong>, and a vender-specific GPU library that will talk to the drivers in the kernel space.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Delving into graphics HAL</h1>
            </header>

            <article>
                
<p>After we have an overview of graphics system architecture, we will analyze the Gralloc module, which is the graphics HAL. In the AOSP source code, the skeleton of Gralloc HAL implementation can be found at the following folder:</p>
<p><kbd>$AOSP/hardware/libhardware/modules/gralloc</kbd></p>
<p>This is a general implementation that provides a reference for developers to create their own Gralloc module. Gralloc will access framebuffer and GPU to provide services to the upper layer. In this section, we will analyze this general implementation first. After the analysis of this general Gralloc HAL module, we will introduce the Gralloc HAL of the Android emulator.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Loading the Gralloc module</h1>
            </header>

            <article>
                
<p>When application developers draw images to the screen, there are two ways to do it. They can use Canvas or OpenGL. Beginning in Android 4.0, both methods use hardware acceleration by default. To use hardware acceleration, we need to use Open GL libraries and eventually the Gralloc module will be loaded as part of the graphics system initialization. As we saw in <a href="e0f861c2-5832-402f-89d3-cfc75785e759.xhtml">Chapter 3</a>, <em><span class="ChapterrefPACKT">Discovering Kernel, HAL, and Virtual Hardware</span></em>, each HAL module has a reference ID that can be used by the <kbd>hw_get_module</kbd> function to load it to memory. The <kbd>hw_get_module</kbd> function is defined in the <kbd>$AOSP/hardware/libhardware/hardware.c</kbd> file:</p>
<pre>
int hw_get_module(const char *id, const struct hw_module_t **module) <br/>{ <br/>    return hw_get_module_by_class(id, NULL, module); <br/>} 
</pre>
<p>In <kbd>hw_get_module</kbd>, it actually calls another function, <kbd>hw_get_module_by_class</kbd>, to do the work:</p>
<pre>
int hw_get_module_by_class(const char *class_id, const char *inst, <br/>                           const struct hw_module_t **module) <br/>{ <br/>    int i = 0; <br/>    char prop[PATH_MAX] = {0}; <br/>    char path[PATH_MAX] = {0}; <br/>    char name[PATH_MAX] = {0}; <br/>    char prop_name[PATH_MAX] = {0}; <br/><br/><br/>    if (inst) <br/>        snprintf(name, PATH_MAX, "%s.%s", class_id, inst); <br/>    else <br/>        strlcpy(name, class_id, PATH_MAX); <br/><br/>    snprintf(prop_name, sizeof(prop_name), "ro.hardware.%s", name); <br/>    if (property_get(prop_name, prop, NULL) &gt; 0) { <br/>        if (hw_module_exists(path, sizeof(path), name, prop) == 0) { <br/>            goto found; <br/>        } <br/>    } <br/><br/>    for (i=0 ; i&lt;HAL_VARIANT_KEYS_COUNT; i++) { <br/>        if (property_get(variant_keys[i], prop, NULL) == 0) { <br/>            continue; <br/>        } <br/>        if (hw_module_exists(path, sizeof(path), name, prop) == 0) { <br/>            goto found; <br/>        } <br/>    } <br/><br/>    /* Nothing found, try the default */ <br/>    if (hw_module_exists(path, sizeof(path), name, "default") == 0) { <br/>        goto found; <br/>    } <br/><br/>    return -ENOENT; <br/><br/>found: <br/>    return load(class_id, path, module); <br/>} 
</pre>
<p>In the preceding function, it tries to find the Gralloc module shared library using the following names in <kbd>/system/lib/hw</kbd> or <kbd>/vendor/lib/hw</kbd>:</p>
<pre>
gralloc.&lt;ro.hardware&gt;.so <br/>gralloc.&lt;ro.product.board&gt;.so <br/>gralloc.&lt;ro.board.platform&gt;.so <br/>gralloc.&lt;ro.arch&gt;.so 
</pre>
<p>If any of the preceding files exist, they will call the <kbd>load</kbd> function to load the shared library. If none of them exist, a default shared library, <kbd>gralloc.default.so</kbd>, will be used. The hardware module ID for Gralloc is defined in the <kbd>gralloc.h</kbd> file as follows:</p>
<pre>
#define GRALLOC_HARDWARE_MODULE_ID "gralloc" 
</pre>
<p>The <kbd>load</kbd> function will call <kbd>dlopen</kbd> to load the library and will call <kbd>dlsym</kbd> to get the address of the data structure <kbd>hw_module_t</kbd>:</p>
<pre>
static int load(const char *id, <br/>        const char *path, <br/>        const struct hw_module_t **pHmi) <br/>{ <br/>    int status = -EINVAL; <br/>    void *handle = NULL; <br/>    struct hw_module_t *hmi = NULL; <br/><br/>    handle = dlopen(path, RTLD_NOW); <br/>    if (handle == NULL) { <br/>        char const *err_str = dlerror(); <br/>        ALOGE("load: module=%s\n%s", path, err_str?err_str:"unknown"); <br/>        status = -EINVAL; <br/>        goto done; <br/>    } <br/><br/>    const char *sym = HAL_MODULE_INFO_SYM_AS_STR; <br/>    hmi = (struct hw_module_t *)dlsym(handle, sym); <br/>    if (hmi == NULL) { <br/>        ALOGE("load: couldn't find symbol %s", sym); <br/>        status = -EINVAL; <br/>        goto done; <br/>    } <br/><br/>    if (strcmp(id, hmi-&gt;id) != 0) { <br/>        ALOGE("load: id=%s != hmi-&gt;id=%s", id, hmi-&gt;id); <br/>        status = -EINVAL; <br/>        goto done; <br/>    } <br/><br/>    hmi-&gt;dso = handle; <br/><br/>    status = 0; <br/><br/>    done: <br/>    if (status != 0) { <br/>        hmi = NULL; <br/>        if (handle != NULL) { <br/>            dlclose(handle); <br/>            handle = NULL; <br/>        } <br/>    } else { <br/>        ALOGV("loaded HAL id=%s path=%s hmi=%p handle=%p", <br/>                id, path, *pHmi, handle); <br/>    } <br/><br/>    *pHmi = hmi; <br/><br/>    return status; <br/>} 
</pre>
<p>After we get the address of the data structure <kbd>hw_module_t</kbd>, we can call the <kbd>open</kbd> method defined in Gralloc HAL to initialize the framebuffer and GPU.</p>
<p>As we discussed in <a href="e0f861c2-5832-402f-89d3-cfc75785e759.xhtml">Chapter 3</a>, <em><span class="ChapterrefPACKT">Discovering Kernel, HAL, and Virtual Hardware</span></em>, the hardware vendor needs to implement three HAL data structures as follows:</p>
<pre>
struct hw_module_t; <br/>struct hw_module_methods_t; <br/>struct hw_device_t; 
</pre>
<p>After the HAL shared library is loaded, the data structure <kbd>hw_module_t</kbd> is used to discover the HAL module, as we can see in the preceding code snippet. Each HAL module should implement an <kbd>open</kbd> method in the data structure <kbd>hw_module_methods_t</kbd>, which is responsible for the initialization of hardware. We can see that the <kbd>gralloc_device_open</kbd> function is defined as the <kbd>open</kbd> method in the following code snippet for the Gralloc module:</p>
<pre>
static struct hw_module_methods_t gralloc_module_methods = { <br/>        .open = gralloc_device_open <br/>}; <br/><br/>struct private_module_t HAL_MODULE_INFO_SYM = { <br/>    .base = { <br/>        .common = { <br/>            .tag = HARDWARE_MODULE_TAG, <br/>            .version_major = 1, <br/>            .version_minor = 0, <br/>            .id = GRALLOC_HARDWARE_MODULE_ID, <br/>            .name = "Graphics Memory Allocator Module", <br/>            .author = "The Android Open Source Project", <br/>            .methods = &amp;gralloc_module_methods <br/>        }, <br/>        .registerBuffer = gralloc_register_buffer, <br/>        .unregisterBuffer = gralloc_unregister_buffer, <br/>        .lock = gralloc_lock, <br/>        .unlock = gralloc_unlock, <br/>    }, <br/>    .framebuffer = 0, <br/>    .flags = 0, <br/>    .numBuffers = 0, <br/>    .bufferMask = 0, <br/>    .lock = PTHREAD_MUTEX_INITIALIZER, <br/>    .currentBuffer = 0, <br/>}; 
</pre>
<p>In the data structure <kbd>hw_module_methods_t</kbd>, the <kbd>open</kbd> method is assigned as a static function, <kbd>gralloc_device_open</kbd>. The <kbd>HAL_MODULE_INFO_SYM</kbd> symbol is defined as <kbd>struct private_module_t</kbd>.</p>
<p>You may notice that we actually cast the <kbd>HAL_MODULE_INFO_SYM_AS_STR</kbd> symbol to <kbd>hw_module_t</kbd>, while we loaded the Gralloc module. In this default Gralloc module, the data structure <kbd>hw_module_t</kbd> is implemented using another two inherited data structures, <kbd>private_module_t</kbd> and <kbd>gralloc_module_t</kbd>. Let's look at the relationship between <kbd>private_module_t</kbd>, <kbd>gralloc_module_t</kbd>, and <kbd>hw_module_t</kbd>.</p>
<div class="packt_infobox">If you feel a little lost with the analysis, I suggest you look at the source code while you read this section. If you don't have the AOSP source code available, there is a very good cross-reference site for AOSP code at <a href="http://xref.opersys.com/">http://xref.opersys.com/</a>.<br/>
You can visit this site and search for the data structures that we are discussing.</div>
<p>The data structure <kbd>private_module_t</kbd> is defined in the following file:</p>
<p><kbd>$AOSP/hardware/libhardware/modules/gralloc/gralloc_priv.h</kbd></p>
<pre>
struct private_module_t { <br/>    gralloc_module_t base; <br/><br/>    private_handle_t* framebuffer; <br/>    uint32_t flags; <br/>    uint32_t numBuffers; <br/>    uint32_t bufferMask; <br/>    pthread_mutex_t lock; <br/>    buffer_handle_t currentBuffer; <br/>    int pmem_master; <br/>    void* pmem_master_base; <br/><br/>    struct fb_var_screeninfo info; <br/>    struct fb_fix_screeninfo finfo; <br/>    float xdpi; <br/>    float ydpi; <br/>    float fps; <br/>}; 
</pre>
<p>As we can see, the first base field, or member variable in C++ terms, is the data structure <kbd>gralloc_module_t</kbd>. The second member variable framebuffer is a pointer of data type <kbd>private_handle_t</kbd>. It is a handle pointing to the framebuffer and we will explore it later.</p>
<p>The member variable <kbd>flags</kbd> is used to indicate whether the system can support double buffering. If it is supported the <kbd>PAGE_FLIP</kbd> bit is set to 1; otherwise, it is set to 0.</p>
<p>The <kbd>numBuffers</kbd> member variable indicates the number of buffers in the framebuffer. It is related to the visible resolution and virtual resolution. For example, if the visible resolution of the display is 800 x 600, the virtual resolution can be 1600 x 600. In this case, the framebuffer can have two buffers for the display and the system can support double buffers for the display.</p>
<p>The <kbd>bufferMask</kbd> member variable is used to mark the use of buffers in a framebuffer device. If we assume there are two buffers in the framebuffer, the <kbd>bufferMask</kbd> variable can have four values in binary 00, 01, 10, and 11. The value 00 indicates both buffers are empty. The value 01 means the first buffer is in use and the second buffer is empty. The value 10 means the first buffer is empty and the second buffer is in use. The value 11 means both buffers are busy.</p>
<p>The <kbd>lock</kbd> member variable is used to protect access to <kbd>private_module_t</kbd>.</p>
<p>The <kbd>currentBuffer</kbd> member variable is used to track the current buffer for rendering.</p>
<p>The <kbd>info</kbd> and <kbd>finfo</kbd> member variables are data types <kbd>fb_var_screeninfo</kbd> and <kbd>fb_fix_screeninfo</kbd>. They are used to store the properties of the display device. The properties in <kbd>fb_var_screeninfo</kbd> are programmable while the properties in <kbd>fb_fix_screeninfo</kbd> are read-only.</p>
<p>The <kbd>xdpi</kbd> and <kbd>ydpi</kbd> member variables are used to describe the pixel density in terms of horizontal and vertical.</p>
<p>The <kbd>fps</kbd> member variable is the refresh rate of the display in frames per second.</p>
<p>The <kbd>gralloc_module_t</kbd> data structure is defined in the following file:</p>
<p><kbd>$AOSP/hardware/libhardware/include/hardware/gralloc.h</kbd></p>
<pre>
typedef struct gralloc_module_t { <br/>    struct hw_module_t common; <br/>    int (*registerBuffer)(struct gralloc_module_t const* module, <br/>            buffer_handle_t handle); <br/>    int (*unregisterBuffer)(struct gralloc_module_t const* module, <br/>            buffer_handle_t handle); <br/>    int (*lock)(struct gralloc_module_t const* module, <br/>            buffer_handle_t handle, int usage, <br/>            int l, int t, int w, int h, <br/>            void** vaddr); <br/>    int (*unlock)(struct gralloc_module_t const* module, <br/>            buffer_handle_t handle); <br/>    ... <br/>} 
</pre>
<p>As we expect, the first field in <kbd>gralloc_module_t</kbd> is <kbd>hw_module_t</kbd> from the preceding code snippet. The relationship among these three data structures is similar to the following UML class diagram in object-oriented notation:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="306" width="687" class=" image-border" src="assets/image_10_002.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Relationship between Gralloc data structures</div>
<p>This is the way to simulate inheritance relationships in the C language. In this way, we can cast data types of <kbd>private_module_t</kbd> to <kbd>gralloc_module_t</kbd> or <kbd>hw_module_t</kbd>.</p>
<p>A set of member functions is defined in <kbd>gralloc_module_t</kbd>. We will look at four of them in this chapter.</p>
<p>The <kbd>registerBuffer</kbd> and <kbd>unregisterBuffer</kbd> member functions are used to register or unregister a buffer. To register a buffer, we map a buffer to the process space of the application.</p>
<p>The <kbd>lock</kbd> and <kbd>unlock</kbd> member functions are used to lock or unlock a buffer. The buffer is described using <kbd>buffer_handle_t</kbd> as a parameter of the function. We can use the <kbd>l</kbd>, <kbd>t</kbd>, <kbd>w</kbd>, and <kbd>h</kbd> parameters to provide the position and the size of the buffer. After the buffer is locked, we can get the address of the buffer in the <kbd>vaddr</kbd> output parameter. We should unlock the buffer after use.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing GPU</h1>
            </header>

            <article>
                
<p>We have talked about HAL data structures <kbd>hw_module_t</kbd> and <kbd>hw_module_methods_t</kbd> for the Gralloc module. The last one, <kbd>hw_device_t</kbd>, is initialized in the <kbd>open</kbd> method of the Gralloc HAL module. Now we can look at the <kbd>open</kbd> method of the Gralloc module as follows:</p>
<pre>
int gralloc_device_open(const hw_module_t* module, const char* name, <br/>        hw_device_t** device) <br/>{ <br/>    int status = -EINVAL; <br/>    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { <br/>        gralloc_context_t *dev; <br/>        dev = (gralloc_context_t*)malloc(sizeof(*dev)); <br/><br/>        memset(dev, 0, sizeof(*dev)); <br/><br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = gralloc_close; <br/><br/>        dev-&gt;device.alloc   = gralloc_alloc; <br/>        dev-&gt;device.free    = gralloc_free; <br/><br/>        *device = &amp;dev-&gt;device.common; <br/>        status = 0; <br/>    } else { <br/>        status = fb_device_open(module, name, device); <br/>    } <br/>    return status; <br/>} 
</pre>
<p>As we can see here, the <kbd>gralloc_device_open</kbd> function can be used to initialize two kinds of device, <kbd>GRALLOC_HARDWARE_GPU0</kbd> and <kbd>GRALLOC_HARDWARE_FB0</kbd>, according to the <kbd>name</kbd> input parameter.</p>
<p>Let's look at the initialization of the GPU0 device first. The output parameter of the <kbd>open</kbd> method is the address of the <kbd>hw_device_t</kbd> data structure. After the calling applications get an instance of <kbd>hw_device_t</kbd>, they can use the hardware device to do their work. In the <kbd>open</kbd> method of Gralloc HAL, it allocates the memory for the <kbd>gralloc_context_t</kbd> data structure first. After that, it populates its <kbd>device</kbd> member variable and assigns the output parameter to the address of the <kbd>dev-&gt;device.common</kbd> member variable. As we expect, the output is the address of an <kbd>hw_device_t</kbd> instance. Let's look at the relationship between <kbd>gralloc_context_t</kbd>, <kbd>alloc_device_t</kbd>, and <kbd>hw_device_t</kbd>:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="212" width="334" class=" image-border" src="assets/image_10_003.png"/></div>
<p>As we can see from the preceding diagram, the first field or member variable of <kbd>gralloc_context_t</kbd> is <kbd>device</kbd>, which is data type <kbd>alloc_device_t</kbd>:</p>
<pre>
struct gralloc_context_t { <br/>    alloc_device_t  device; <br/>    /* our private data here */ <br/>}; 
</pre>
<p>The following is the definition of the <kbd>alloc_device_t</kbd> data structure. It is defined in the <kbd>gralloc.h</kbd> file:</p>
<pre>
typedef struct alloc_device_t { <br/>    struct hw_device_t common; <br/><br/>    int (*alloc)(struct alloc_device_t* dev, <br/>            int w, int h, int format, int usage, <br/>            buffer_handle_t* handle, int* stride); <br/><br/>    int (*free)(struct alloc_device_t* dev, <br/>            buffer_handle_t handle); <br/><br/>    void (*dump)(struct alloc_device_t *dev, char *buff, int buff_len); <br/><br/>    void* reserved_proc[7]; <br/>} alloc_device_t; 
</pre>
<p>We can see that the data type of the first field of <kbd>alloc_device_t</kbd> is <kbd>hw_device_t</kbd>. This is the technique for simulating inheritance relationships in the C language that we mentioned when we discussed the relationship between <kbd>private_module_t</kbd>, <kbd>gralloc_module_t</kbd> and <kbd>hw_module_t</kbd>.</p>
<p>The <kbd>alloc</kbd> and <kbd>free</kbd> methods of the Gralloc device are implemented in the <kbd>gralloc_alloc</kbd> and <kbd>gralloc_free</kbd> functions in the <kbd>gralloc.cpp</kbd> file.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing framebuffer</h1>
            </header>

            <article>
                
<p>If we call the <kbd>open</kbd> method of the Gralloc module with the <kbd>name</kbd> value as <kbd>GRALLOC_HARDWARE_FB0</kbd>, it will initialize the framebuffer device. The <kbd>fb_device_open</kbd> function is called to open the framebuffer device:</p>
<pre>
status = fb_device_open(module, name, device); 
</pre>
<p>The <kbd>fb_device_open</kbd> function is implemented in the <kbd>framebuffer.cpp</kbd> file as follows:</p>
<pre>
int fb_device_open(hw_module_t const* module, const char* name, <br/>        hw_device_t** device) <br/>{ <br/>    int status = -EINVAL; <br/>    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { <br/>        /* initialize our state here */ <br/>        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev)); <br/>        memset(dev, 0, sizeof(*dev)); <br/><br/>        /* initialize the procs */ <br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = fb_close; <br/>        dev-&gt;device.setSwapInterval = fb_setSwapInterval; <br/>        dev-&gt;device.post            = fb_post; <br/>        dev-&gt;device.setUpdateRect = 0; <br/><br/>        private_module_t* m = (private_module_t*)module; <br/>        status = mapFrameBuffer(m); <br/>        if (status &gt;= 0) { <br/>            int stride = m-&gt;finfo.line_length / <br/>            (m-&gt;info.bits_per_pixel &gt;&gt; 3); <br/>            /* <br/>             * Auto detect current depth and select mode <br/>             */ <br/>            int format; <br/>            if (m-&gt;info.bits_per_pixel == 32) { <br/>                format = (m-&gt;info.red.offset == 16) ?  <br/>                HAL_PIXEL_FORMAT_BGRA_8888 <br/>                : (m-&gt;info.red.offset == 24) ? <br/>                HAL_PIXEL_FORMAT_RGBA_8888 : <br/>                HAL_PIXEL_FORMAT_RGBX_8888; <br/>            } else if (m-&gt;info.bits_per_pixel == 16) { <br/>                format = HAL_PIXEL_FORMAT_RGB_565; <br/>            } else { <br/>                ALOGE("Unsupported format %d", m-&gt;info.bits_per_pixel); <br/>                return -EINVAL; <br/>            } <br/>            const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.flags) = 0; <br/>            const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.width) = m-&gt;info.xres; <br/>            const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.height) = m-&gt;info.yres; <br/>            const_cast&lt;int&amp;&gt;(dev-&gt;device.stride) = stride; <br/>            const_cast&lt;int&amp;&gt;(dev-&gt;device.format) = format; <br/>            const_cast&lt;float&amp;&gt;(dev-&gt;device.xdpi) = m-&gt;xdpi; <br/>            const_cast&lt;float&amp;&gt;(dev-&gt;device.ydpi) = m-&gt;ydpi; <br/>            const_cast&lt;float&amp;&gt;(dev-&gt;device.fps) = m-&gt;fps; <br/>            const_cast&lt;int&amp;&gt;(dev-&gt;device.minSwapInterval) = 1; <br/>            const_cast&lt;int&amp;&gt;(dev-&gt;device.maxSwapInterval) = 1; <br/>            *device = &amp;dev-&gt;device.common; <br/>        } <br/>    } <br/>    return status; <br/>} 
</pre>
<p>In the <kbd>fb_device_open</kbd> function, it allocates memory for the <kbd>fb_context_t</kbd> data structure. After that, it populates the fields in the data structure. As we discussed in the GPU0 initialization, we expect the output as an instance of the <kbd>hw_device_t</kbd> data structure so that the caller can use the framebuffer device through the <kbd>hw_device_t</kbd> HAL data structure. We have a similar inheritance relationship between these three data structures, <kbd>fb_context_t</kbd>, <kbd>framebuffer_device_t</kbd>, and <kbd>hw_device_t</kbd>, as shown in the following diagram:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="217" width="345" class=" image-border" src="assets/image_10_004.png"/></div>
<div class="packt_figure CDPAlignCenter CDPAlign packt_figref">Relationship between fb_context_t, framebuffer_device_t, and hw_device_t</div>
<p>The <kbd>fb_context_t</kbd> data structure includes <kbd>framebuffer_device_t</kbd> as the first field as follows:</p>
<pre>
struct fb_context_t { <br/>    framebuffer_device_t  device; <br/>}; 
</pre>
<p>In turn, the <kbd>framebuffer_device_t</kbd> data structure includes <kbd>hw_device_t</kbd> as the first field, so <kbd>fb_context_t</kbd> can be used as either <kbd>framebuffer_device_t</kbd> or <kbd>hw_device_t</kbd>:</p>
<pre>
typedef struct framebuffer_device_t { <br/>    struct hw_device_t common; <br/><br/>    const uint32_t  flags; <br/><br/>    const uint32_t  width; <br/>    const uint32_t  height; <br/><br/>    const int       stride; <br/><br/>    const int       format; <br/><br/>    const float     xdpi; <br/>    const float     ydpi; <br/><br/>    const float     fps; <br/><br/>    const int       minSwapInterval; <br/><br/>    const int       maxSwapInterval; <br/><br/>    const int       numFramebuffers; <br/><br/>    int reserved[7]; <br/>    int (*setSwapInterval)(struct framebuffer_device_t* window, <br/>            int interval); <br/>    int (*setUpdateRect)(struct framebuffer_device_t* window, <br/>            int left, int top, int width, int height); <br/>    int (*post)(struct framebuffer_device_t* dev, buffer_handle_t <br/>    buffer); <br/>    int (*compositionComplete)(struct framebuffer_device_t* dev); <br/>    void (*dump)(struct framebuffer_device_t* dev, char *buff, int <br/>    buff_len); <br/>    int (*enableScreen)(struct framebuffer_device_t* dev, int enable); <br/>    void* reserved_proc[6]; <br/><br/>} framebuffer_device_t; 
</pre>
<p>As for the rest of the fields in <kbd>framebuffer_device_t</kbd>, they are:</p>
<ul>
<li><kbd>flags</kbd>: Used to describe some attributes of the framebuffer.</li>
<li><kbd>width</kbd> and <kbd>height</kbd>: Dimensions of the framebuffer in pixels.</li>
<li><kbd>stride</kbd>: Framebuffer stride in pixels or the number of pixels per line.</li>
<li><kbd>format</kbd>: Framebuffer pixel format. It can be <kbd>HAL_PIXEL_FORMAT_RGBX_8888</kbd>, <kbd>HAL_PIXEL_FORMAT_565</kbd>, and so on.</li>
<li><kbd>xdpi</kbd> and <kbd>ydpi</kbd>: Resolution of the framebuffer's display panel in pixels per inch.</li>
<li><kbd>fps</kbd>: Display panel refresh rate in frames per second.</li>
<li><kbd>minSwapInterval</kbd>: Minimum swap interval supported by this framebuffer.</li>
<li><kbd>maxSwapInterval</kbd>: Maximum swap interval supported by this framebuffer.</li>
<li><kbd>numFramebuffers</kbd>: Number of framebuffers supported.</li>
</ul>
<p>Before it can fill in all the fields of <kbd>framebuffer_device_t</kbd>, the <kbd>fb_device_open</kbd> function calls a <kbd>mapFrameBuffer</kbd> function to get the information about the framebuffer. Besides getting framebuffer information, this <kbd>mapFrameBuffer</kbd> function also maps the framebuffer to the current process space so that the current process can use it. In Android, the Gralloc module is owned and managed by SurfaceFlinger.</p>
<p>Let's have a look at the <kbd>mapFrameBuffer</kbd> function now:</p>
<pre>
static int mapFrameBuffer(struct private_module_t* module) <br/>{ <br/>    pthread_mutex_lock(&amp;module-&gt;lock); <br/>    int err = mapFrameBufferLocked(module); <br/>    pthread_mutex_unlock(&amp;module-&gt;lock); <br/>    return err; <br/>} 
</pre>
<p>As we can see, <kbd>mapFrameBuffer</kbd> acquires a mutex first and calls another function, <kbd>mapFrameBufferLocked</kbd>, to do the rest of the work:</p>
<pre>
int mapFrameBufferLocked(struct private_module_t* module) <br/>{ <br/>    // already initialized... <br/>    if (module-&gt;framebuffer) { <br/>        return 0; <br/>    } <br/><br/>    char const * const device_template[] = { <br/>            "/dev/graphics/fb%u", <br/>            "/dev/fb%u", <br/>            0 }; <br/><br/>    int fd = -1; <br/>    int i=0; <br/>    char name[64]; <br/><br/>    while ((fd==-1) &amp;&amp; device_template[i]) { <br/>        snprintf(name, 64, device_template[i], 0); <br/>        fd = open(name, O_RDWR, 0); <br/>        i++; <br/>    } <br/>    if (fd &lt; 0) <br/>        return -errno; <br/>    ... 
</pre>
<p>In the <kbd>mapFrameBufferLocked</kbd> function, it checks whether there is a <kbd>/dev/graphics/fb0</kbd> or <kbd>/dev/fb0</kbd> device node. If the device node exists, it tries to open it and stores the file descriptor in the <kbd>fd</kbd> variable:</p>
<pre>
    ... <br/>    struct fb_fix_screeninfo finfo; <br/>    if (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) <br/>        return -errno; <br/><br/>    struct fb_var_screeninfo info; <br/>    if (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == -1) <br/>        return -errno; <br/>    ... 
</pre>
<p>Next, it will use <kbd>ioctl</kbd> commands to get framebuffer information. There are two framebuffer data structures, <kbd>fb_fix_screeninfo</kbd> and <kbd>fb_var_screeninfo</kbd>, which can be used to communicate with framebuffer. The <kbd>fb_fix_screeninfo</kbd> data structure stores fixed framebuffer information and the <kbd>fb_var_screeninfo</kbd> data structure stores programmable framebuffer information:</p>
<pre>
    ... <br/>    info.reserved[0] = 0; <br/>    info.reserved[1] = 0; <br/>    info.reserved[2] = 0; <br/>    info.xoffset = 0; <br/>    info.yoffset = 0; <br/>    info.activate = FB_ACTIVATE_NOW; <br/><br/>    /* <br/>     * Request NUM_BUFFERS screens (at lest 2 for page flipping) <br/>     */ <br/>    info.yres_virtual = info.yres * NUM_BUFFERS; <br/><br/><br/>    uint32_t flags = PAGE_FLIP; <br/>#if USE_PAN_DISPLAY <br/>    if (ioctl(fd, FBIOPAN_DISPLAY, &amp;info) == -1) { <br/>        ALOGW("FBIOPAN_DISPLAY failed, page flipping not supported"); <br/>#else <br/>    if (ioctl(fd, FBIOPUT_VSCREENINFO, &amp;info) == -1) { <br/>        ALOGW("FBIOPUT_VSCREENINFO failed, page flipping not supported"); <br/>#endif <br/>        info.yres_virtual = info.yres; <br/>        flags &amp;= ~PAGE_FLIP; <br/>    } <br/><br/>    if (ioctl(fd, FBIOGET_FSCREENINFO, &amp;finfo) == -1) <br/>        return -errno; <br/><br/>    if (finfo.smem_len &lt;= 0) <br/>        return -errno; <br/><br/>    if (finfo.smem_len / finfo.line_length &lt; info.yres_virtual) <br/>        info.yres_virtual = finfo.smem_len / finfo.line_length; <br/><br/>    if (info.yres_virtual &lt; info.yres * 2) { <br/>        // we need at least 2 for page-flipping <br/>        info.yres_virtual = info.yres; <br/>        flags &amp;= ~PAGE_FLIP; <br/>        ALOGW("page flipping not supported (yres_virtual=%d, <br/>        requested=%d)", <br/>                info.yres_virtual, info.yres*2); <br/>    } <br/>    ... 
</pre>
<p>After it gets the framebuffer information, it tries to set the virtual resolution of the framebuffer device. The <kbd>xres</kbd> and <kbd>yres</kbd> fields are used to store the visible resolution of the framebuffer device while the <kbd>xres_virtual</kbd> and <kbd>yres_virtual</kbd> fields are used to store the virtual resolution of the framebuffer device.</p>
<p>To set the virtual resolution, it tries to increase the virtual vertical resolution as the <kbd>info.yres * NUM_BUFFERS</kbd> value. <kbd>NUM_BUFFERS</kbd> is a macro for the number of buffers that can be used in the framebuffer devices. In our case, the <kbd>NUM_BUFFERS</kbd> value is <kbd>2</kbd>, so we can use the double buffer technology for the display. It sets the virtual resolution using the <kbd>ioctl</kbd> command <kbd>FBIOPUT_VSCREENINFO</kbd>. If it can set the virtual resolution successfully, it will set the <kbd>PAGE_FLIP</kbd> bit in <kbd>flags</kbd>; otherwise, it will clear the <kbd>PAGE_FLIP</kbd> bit:</p>
<pre>
    ... <br/>    if (ioctl(fd, FBIOGET_VSCREENINFO, &amp;info) == -1) <br/>        return -errno; <br/><br/>    if (finfo.smem_len / finfo.line_length &lt; info.yres_virtual) <br/>        info.yres_virtual = finfo.smem_len / finfo.line_length; <br/><br/>    uint64_t  refreshQuotient = <br/>    ( <br/>            uint64_t( info.upper_margin + info.lower_margin + info.yres ) * <br/>            ( info.left_margin  + info.right_margin + info.xres ) * <br/>            info.pixclock <br/>    ); <br/><br/>    /* Beware, info.pixclock might be 0 under emulation, so avoid  <br/>     * a division-by-0 here (SIGFPE on ARM) */ <br/>    int refreshRate = refreshQuotient &gt; 0 ? (int)(1000000000000000LLU / <br/>    refreshQuotient) : 0; <br/><br/>    if (refreshRate == 0) { <br/>        // bleagh, bad info from the driver <br/>        refreshRate = 60*1000;  // 60 Hz <br/>    } <br/>    ... 
</pre>
<p>After it sets the virtual resolution, it will calculate the refresh rate. To understand the calculation of the refresh rate, you can refer to the document in the Linux kernel source code at <kbd>Documentation/fb/framebuffer.txt</kbd>:</p>
<pre>
    ... <br/>    if (int(info.width) &lt;= 0 || int(info.height) &lt;= 0) { <br/>        // the driver doesn't return that information <br/>        // default to 160 dpi <br/>        info.width  = ((info.xres * 25.4f)/160.0f + 0.5f); <br/>        info.height = ((info.yres * 25.4f)/160.0f + 0.5f); <br/>    } <br/><br/>    float xdpi = (info.xres * 25.4f) / info.width; <br/>    float ydpi = (info.yres * 25.4f) / info.height; <br/>    float fps  = refreshRate / 1000.0f; <br/><br/>    module-&gt;finfo = finfo; <br/>    module-&gt;xdpi = xdpi; <br/>    module-&gt;ydpi = ydpi; <br/>    module-&gt;fps = fps; <br/>    ... 
</pre>
<p>Next, it will calculate the pixel density for both horizontal and vertical. It also converts the refresh rate to frames per second and stores this to <kbd>fps</kbd>. After it has all the information, it will store them to the fields of the data structure, <kbd>private_module_t</kbd>.</p>
<p>Finally, it will map the framebuffer to the process address space:</p>
<pre>
    ... <br/>    while (info.yres_virtual &gt; 0) { <br/>        size_t fbSize = roundUpToPageSize(finfo.line_length * <br/>        info.yres_virtual); <br/>        module-&gt;numBuffers = info.yres_virtual / info.yres; <br/>        void* vaddr = mmap(0, fbSize, PROT_READ|PROT_WRITE, MAP_SHARED, <br/>        fd, 0); <br/>        if (vaddr != MAP_FAILED) { <br/>            module-&gt;info = info; <br/>            module-&gt;flags = flags; <br/>            module-&gt;bufferMask = 0; <br/>            module-&gt;framebuffer = new private_handle_t(dup(fd), <br/>            fbSize, 0); <br/>            module-&gt;framebuffer-&gt;base = intptr_t(vaddr); <br/>            memset(vaddr, 0, fbSize); <br/>            return 0; <br/>        } <br/><br/>        ALOGE("Error mapping the framebuffer (%s)", strerror(errno)); <br/><br/>        info.yres_virtual -= info.yres; <br/>        ALOGW("Fallback to use fewer buffer: %d", info.yres_virtual /  <br/>        info.yres); <br/>        if (ioctl(fd, FBIOPUT_VSCREENINFO, &amp;info) == -1) <br/>            break; <br/><br/>        if (info.yres_virtual &lt;= info.yres) <br/>            flags &amp;= ~PAGE_FLIP; <br/>    } <br/><br/>    return -errno; <br/>} 
</pre>
<p>The size of the framebuffer by virtual resolution is <kbd>finfo.line_length * info.yres_virtual</kbd>. The value of <kbd>finfo.line_length</kbd> is equal to the number of bytes per line and the value of <kbd>info.yres_virtual</kbd> is the number of lines per frame. In order to do memory mapping, we have to round the size to the page boundary using the <kbd>roundUpToPageSize</kbd> function.</p>
<p>The actual number of buffers that can be used in the framebuffer device is <kbd>info.yres_virtual</kbd> divided by <kbd>info.yres</kbd> and it is stored in the <kbd>numBuffers</kbd> field. The <kbd>bufferMask</kbd> field is set to 0 and this means all buffers are empty and can be used.</p>
<p>It calls the <kbd>mmap</kbd> system call to map the framebuffer to the current process address space. The starting address of the framebuffer in the current process address space is <kbd>vaddr</kbd>, which is returned from the <kbd>mmap</kbd> system call. It is stored to the <kbd>framebuffer-&gt;base</kbd> field, so that the Gralloc module can use it to allocate buffers for the applications later.</p>
<p>Up to now, we have completed the analysis of the <kbd>mapFrameBuffer</kbd> function. This function is the one that is responsible for most of the work in initializing framebuffer devices in the Gralloc HAL module.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating and releasing the graphic buffer</h1>
            </header>

            <article>
                
<p>So far in this chapter, we have discussed loading the Gralloc module and the <kbd>open</kbd> method provided by the Gralloc module. Let's now review the points when the upper layer loads, initializes, and uses the Gralloc module:</p>
<ul>
<li>For example, the Gralloc module is used mostly by <kbd>SurfaceFlinger</kbd>. <kbd>SurfaceFlinger</kbd> uses Gralloc; when it creates an instance of <kbd>FramebufferNativeWindow</kbd>, in the <kbd>FramebufferNativeWindow</kbd> constructor, it will call <kbd>hw_get_module</kbd> to get an instance of <kbd>hw_module_t</kbd>.</li>
<li>In the <kbd>hw_module_t</kbd> data structure, it has a field called <kbd>methods</kbd> with data type <kbd>hw_module_methods_t</kbd>. In <kbd>hw_module_methods_t</kbd>, it has an <kbd>open</kbd> method that returns a <kbd>hw_device_t</kbd> data structure.</li>
<li>With <kbd>hw_device_t</kbd>, <kbd>SurfaceFlinger</kbd> can use the <kbd>alloc</kbd> and <kbd>free</kbd> methods inside <kbd>hw_device_t</kbd> to allocate or release graphic buffers.</li>
</ul>
<p>Let's look at how the Gralloc module allocates and releases graphic buffers in this section. We will look at the source code of <kbd>gralloc_alloc</kbd> first:</p>
<pre>
static int gralloc_alloc(alloc_device_t* dev, <br/>        int w, int h, int format, int usage, <br/>        buffer_handle_t* pHandle, int* pStride) <br/>{ <br/>    if (!pHandle || !pStride) <br/>        return -EINVAL; <br/><br/>    size_t size, stride; <br/><br/>    int align = 4; <br/>    int bpp = 0; <br/>    switch (format) { <br/>        case HAL_PIXEL_FORMAT_RGBA_8888: <br/>        case HAL_PIXEL_FORMAT_RGBX_8888: <br/>        case HAL_PIXEL_FORMAT_BGRA_8888: <br/>            bpp = 4; <br/>            break; <br/>        case HAL_PIXEL_FORMAT_RGB_888: <br/>            bpp = 3; <br/>            break; <br/>        case HAL_PIXEL_FORMAT_RGB_565: <br/>        case HAL_PIXEL_FORMAT_RAW16: <br/>            bpp = 2; <br/>            break; <br/>        default: <br/>            return -EINVAL; <br/>    } <br/><br/>    private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>                        dev-&gt;common.module); <br/><br/>    size_t bpr = usage &amp; GRALLOC_USAGE_HW_FB ? m-&gt;finfo.line_length : <br/>    (w*bpp + (align-1)) &amp; ~(align-1); <br/>    size = bpr * h; <br/>    stride = bpr / bpp; <br/><br/>    int err; <br/>    if (usage &amp; GRALLOC_USAGE_HW_FB) { <br/>        err = gralloc_alloc_framebuffer(dev, size, usage, pHandle); <br/>    } else { <br/>        err = gralloc_alloc_buffer(dev, size, usage, pHandle); <br/>    } <br/><br/>    if (err &lt; 0) { <br/>        return err; <br/>    } <br/><br/>    *pStride = stride; <br/>    return 0; <br/>} 
</pre>
<p>As we can see in the preceding code snippet, the <kbd>alloc</kbd> method is implemented in the <kbd>gralloc_alloc</kbd> function. <kbd>gralloc_alloc</kbd> has the following parameters:</p>
<ul>
<li><kbd>dev</kbd>: It has an <kbd>alloc_device</kbd> data type that inherits from <kbd>hw_device_t</kbd>.</li>
<li><kbd>w</kbd> : It is the width of the graphic buffer.</li>
<li><kbd>h</kbd>: It is the height of graphic buffer.</li>
<li><kbd>format</kbd> : It defines the color format of pixels. For example, the format can be <kbd>HAL_PIXEL_FORMAT_RGBA_8888</kbd>, <kbd>HAL_PIXEL_FORMAT_RGB_888</kbd>, <kbd>HAL_PIXEL_FORMAT_RGB_565</kbd>, and so on.</li>
<li><kbd>usage</kbd> : It defines the use of graphic buffer. For example, if the <kbd>GRALLOC_USAGE_HW_FB</kbd> bit is set, the buffer will be allocated from the framebuffer.</li>
<li><kbd>pHandle</kbd> : It has a <kbd>buffer_handle_t</kbd> data type. We will discuss the details of this data structure. It is used to store the allocated buffer.</li>
<li><kbd>pStride</kbd> : The number of pixels per line.</li>
</ul>
<p>In <kbd>gralloc_alloc</kbd>, it checks the format of pixels to decide the size of pixels. It can be 32 bits, 24 bits, 16 bits, and so on. The size of the pixel is stored in the <kbd>bpp</kbd> variable. The <kbd>bpr</kbd> variable is the number of bytes per line and it is calculated using <kbd>w</kbd> multiplied by <kbd>bpp</kbd>. The <kbd>bpr</kbd> variable needs to be aligned to four bytes boundary for memory allocation. The size of the buffer can be calculated using <kbd>h</kbd> multiplied by <kbd>bpr</kbd>.</p>
<p>After the size of the buffer is calculated, it will call the <kbd>gralloc_alloc_framebuffer</kbd> or <kbd>gralloc_alloc_buffer</kbd> functions according to the <kbd>GRALLOC_USAGE_HW_FB</kbd> bit.</p>
<p>The graphic buffer that is allocated by <kbd>gralloc_alloc</kbd> is stored in the <kbd>buffer_handle_t</kbd> data type. <kbd>buffer_handle_t</kbd> is defined as a pointer of <kbd>native_handle</kbd>. <kbd>native_handle</kbd> is used as a parent class of <kbd>private_handle_t</kbd>. <kbd>private_handle_t</kbd> is the actual data type used to manage the graphic buffer and it is a hardware-dependent data structure.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img height="212" width="315" class=" image-border" src="assets/image_10_005.png"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Relationship between private_handle_t and native_handle</div>
<p>The preceding diagram shows the relationship between <kbd>private_handle_t</kbd> and <kbd>native_handle</kbd>. The following is the definition of <kbd>native_handle</kbd>:</p>
<pre>
typedef struct native_handle <br/>{ <br/>    int version;     /* sizeof(native_handle_t) */ <br/>    int numFds;      /* number of file-descriptors at &amp;data[0] */ <br/>    int numInts;     /* number of ints at &amp;data[numFds] */ <br/>    int data[0];     /* numFds + numInts ints */ <br/>} native_handle_t; 
</pre>
<p>The <kbd>version</kbd> field is set to the size of <kbd>native_handle</kbd>. The <kbd>numFds</kbd> and <kbd>numInts</kbd> fields describe the number of file descriptors and integers in the <kbd>data</kbd> array. The <kbd>data</kbd> array is used to store hardware-specific information, which we can see in the following definition of <kbd>private_handle_t</kbd>:</p>
<pre>
#ifdef __cplusplus <br/>struct private_handle_t : public native_handle { <br/>#else <br/>struct private_handle_t { <br/>    struct native_handle nativeHandle; <br/>#endif <br/><br/>    enum { <br/>        PRIV_FLAGS_FRAMEBUFFER = 0x00000001 <br/>    }; <br/><br/>    // file-descriptors <br/>    int     fd; <br/>    // ints <br/>    int     magic; <br/>    int     flags; <br/>    int     size; <br/>    int     offset; <br/><br/>    // FIXME: the attributes below should be out-of-line <br/>    uint64_t base __attribute__((aligned(8))); <br/>    int     pid; <br/><br/>#ifdef __cplusplus <br/>    static inline int sNumInts() { <br/>        return (((sizeof(private_handle_t) - <br/>        sizeof(native_handle_t))/sizeof(int)) - sNumFds); <br/>    } <br/>    static const int sNumFds = 1; <br/>    static const int sMagic = 0x3141592; <br/><br/>    private_handle_t(int fd, int size, int flags) : <br/>        fd(fd), magic(sMagic), flags(flags), size(size), offset(0), <br/>        base(0), pid(getpid()) <br/>    { <br/>        version = sizeof(native_handle); <br/>        numInts = sNumInts(); <br/>        numFds = sNumFds; <br/>    } <br/>    ~private_handle_t() { <br/>        magic = 0; <br/>    } <br/><br/>    static int validate(const native_handle* h) { <br/>        const private_handle_t* hnd = (const private_handle_t*)h; <br/>        if (!h || h-&gt;version != sizeof(native_handle) || <br/>                h-&gt;numInts != sNumInts() || h-&gt;numFds != sNumFds || <br/>                hnd-&gt;magic != sMagic) <br/>        { <br/>            ALOGE("invalid gralloc handle (at %p)", h); <br/>            return -EINVAL; <br/>        } <br/>        return 0; <br/>    } <br/>#endif <br/>}; 
</pre>
<p>The <kbd>fd</kbd> member variable is a file descriptor that is used to describe a framebuffer or shared memory region. The <kbd>magic</kbd> member variable is stored as a magic number defined in the <kbd>sMagic</kbd> static variable. The <kbd>flags</kbd> member variable is used to describe the type of graphic buffer. For example, if it is equal to <kbd>PRIV_FLAGS_FRAMEBUFFER</kbd>, this buffer is allocated from framebuffer. The <kbd>size</kbd> member variable is the size of the graphic buffer. The <kbd>offset</kbd> member variable is the offset from the starting address in memory. The <kbd>base</kbd> member variable is the address allocated for the buffer. The <kbd>pid</kbd> member variable is the process ID of the creator of the graphic buffer.</p>
<p>The constructor fills in the member variables of <kbd>native_handle</kbd>. The <kbd>validate</kbd> member function is used to validate whether the graphic buffer is an instance of <kbd>private_handle_t</kbd> or not.</p>
<p>As we mentioned previously, the Gralloc module that we are analyzing is the default implementation in AOSP, and is built as <kbd>galloc.default.so</kbd>. In this implementation, GPU is not used and the buffer will be allocated either in the framebuffer or shared memory. Even though this is not the ideal case for performance, it has the least hardware dependency, which is good as a reference to understand a more complicated Gralloc module implementation.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating from framebuffer</h1>
            </header>

            <article>
                
<p>As we can see from the <kbd>gralloc_alloc</kbd> function, when the <kbd>usage</kbd> bit is set to <kbd>GRALLOC_USAGE_HW_FB</kbd>, the <kbd>gralloc_alloc_framebuffer</kbd> function is called. The <kbd>gralloc_alloc_framebuffer</kbd> function will allocate the buffer from the framebuffer device:</p>
<pre>
static int gralloc_alloc_framebuffer_locked(alloc_device_t* dev, <br/>        size_t size, int usage, buffer_handle_t* pHandle) <br/>{ <br/>    private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>            dev-&gt;common.module); <br/><br/>    // allocate the framebuffer <br/>    if (m-&gt;framebuffer == NULL) { <br/>        // initialize the framebuffer, the framebuffer is mapped once <br/>        // and forever. <br/>        int err = mapFrameBufferLocked(m); <br/>        if (err &lt; 0) { <br/>            return err; <br/>        } <br/>    } <br/><br/>    const uint32_t bufferMask = m-&gt;bufferMask; <br/>    const uint32_t numBuffers = m-&gt;numBuffers; <br/>    const size_t bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres; <br/>    if (numBuffers == 1) { <br/>        // If we have only one buffer, we never use page-flipping.  <br/>        // Instead we return a regular buffer which will be <br/>        // memcpy'ed to the main screen when post is called. <br/>        int newUsage = (usage &amp; ~GRALLOC_USAGE_HW_FB) |   <br/>        GRALLOC_USAGE_HW_2D; <br/>        return gralloc_alloc_buffer(dev, bufferSize, newUsage, <br/>        pHandle); <br/>    } <br/><br/>    if (bufferMask &gt;= ((1LU&lt;&lt;numBuffers)-1)) { <br/>        // We ran out of buffers. <br/>        return -ENOMEM; <br/>    } <br/><br/>    // create a "fake" handles for it <br/>    intptr_t vaddr = intptr_t(m-&gt;framebuffer-&gt;base); <br/>    private_handle_t* hnd = new private_handle_t(dup(m-&gt;framebuffer-<br/>    &gt;fd), <br/>    size, private_handle_t::PRIV_FLAGS_FRAMEBUFFER); <br/><br/>    // find a free slot <br/>    for (uint32_t i=0 ; i&lt;numBuffers ; i++) { <br/>        if ((bufferMask &amp; (1LU&lt;&lt;i)) == 0) { <br/>            m-&gt;bufferMask |= (1LU&lt;&lt;i); <br/>            break; <br/>        } <br/>        vaddr += bufferSize; <br/>    } <br/><br/>    hnd-&gt;base = vaddr; <br/>    hnd-&gt;offset = vaddr - intptr_t(m-&gt;framebuffer-&gt;base); <br/>    *pHandle = hnd; <br/><br/>    return 0; <br/>} <br/><br/>static int gralloc_alloc_framebuffer(alloc_device_t* dev, <br/>        size_t size, int usage, buffer_handle_t* pHandle) <br/>{ <br/>    private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>            dev-&gt;common.module); <br/>    pthread_mutex_lock(&amp;m-&gt;lock); <br/>    int err = gralloc_alloc_framebuffer_locked(dev, size, usage,  <br/>    pHandle); <br/>    pthread_mutex_unlock(&amp;m-&gt;lock); <br/>    return err; <br/>} 
</pre>
<p><kbd>gralloc_alloc_framebuffer</kbd> acquires a mutex first and calls to another function, <kbd>gralloc_alloc_framebuffer_locked</kbd>. In the locked version, it calls to a <kbd>mapFrameBufferLocked</kbd> function, which we analyzed before to get the framebuffer information and map it to the current process address space.</p>
<p>It will check whether the framebuffer device can support double buffering or not. If it can support double buffering, it creates a new <kbd>private_handle_t</kbd> instance and fills in the information in this instance and returns to the caller. If the buffer is allocated from the framebuffer device, it will mark the <kbd>flags</kbd> member variable of <kbd>private_handle_t</kbd> to <kbd>PRIV_FLAGS_FRAMEBUFFER</kbd>. It will also set the framebuffer <kbd>usage</kbd> status in <kbd>bufferMask</kbd>, which is a member variable of <kbd>private_module_t</kbd>.</p>
<p>If it cannot support double buffering, it calls to <kbd>gralloc_alloc_buffer</kbd> to allocate a buffer from the system memory and returns to the caller.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Allocating from system memory</h1>
            </header>

            <article>
                
<p>When the <kbd>usage</kbd> bit is not set to <kbd>GRALLOC_USAGE_HW_FB</kbd> or the system cannot support double buffering, we have to allocate the buffer from system memory using <kbd>gralloc_alloc_buffer</kbd>. Let's look at the implementation of <kbd>gralloc_alloc_buffer</kbd>:</p>
<pre>
static int gralloc_alloc_buffer(alloc_device_t* dev, <br/>        size_t size, int /*usage*/, buffer_handle_t* pHandle) <br/>{ <br/>    int err = 0; <br/>    int fd = -1; <br/><br/>    size = roundUpToPageSize(size); <br/><br/>    fd = ashmem_create_region("gralloc-buffer", size); <br/>    if (fd &lt; 0) { <br/>        ALOGE("couldn't create ashmem (%s)", strerror(-errno)); <br/>        err = -errno; <br/>    } <br/><br/>    if (err == 0) { <br/>        private_handle_t* hnd = new private_handle_t(fd, size, 0); <br/>        gralloc_module_t* module = reinterpret_cast&lt;gralloc_module_t*&gt;( <br/>                dev-&gt;common.module); <br/>        err = mapBuffer(module, hnd); <br/>        if (err == 0) { <br/>            *pHandle = hnd; <br/>        } <br/>    } <br/><br/>    ALOGE_IF(err, "gralloc failed err=%s", strerror(-err)); <br/><br/>    return err; <br/>} 
</pre>
<p>In <kbd>gralloc_alloc_buffer</kbd>, it rounds up the buffer size to the page size first. Then it creates an anonymous shared memory region using <kbd>ashmem_create_region</kbd>. It creates a new <kbd>private_handle_t</kbd> instance to represent this shared memory region.</p>
<p>This shared memory region is described as a file descriptor. To use it, we need to map it to the current process address space. This is done with the <kbd>mapBuffer</kbd> function:</p>
<pre>
int mapBuffer(gralloc_module_t const* module, <br/>        private_handle_t* hnd) <br/>{ <br/>    void* vaddr; <br/>    return gralloc_map(module, hnd, &amp;vaddr); <br/>} 
</pre>
<p><kbd>mapBuffer</kbd> calls to another function, <kbd>gralloc_map</kbd>, to do the memory mapping:</p>
<pre>
static int gralloc_map(gralloc_module_t const* /*module*/, <br/>        buffer_handle_t handle, <br/>        void** vaddr) <br/>{ <br/>    private_handle_t* hnd = (private_handle_t*)handle; <br/>    if (!(hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER)) { <br/>        size_t size = hnd-&gt;size; <br/>        void* mappedAddress = mmap(0, size, <br/>                PROT_READ|PROT_WRITE, MAP_SHARED, hnd-&gt;fd, 0); <br/>        if (mappedAddress == MAP_FAILED) { <br/>            ALOGE("Could not mmap %s", strerror(errno)); <br/>            return -errno; <br/>        } <br/>        hnd-&gt;base = uintptr_t(mappedAddress) + hnd-&gt;offset; <br/>        //ALOGD("gralloc_map() succeeded fd=%d, off=%d, size=%d, vaddr=%p", <br/>        //        hnd-&gt;fd, hnd-&gt;offset, hnd-&gt;size, mappedAddress); <br/>    } <br/>    *vaddr = (void*)hnd-&gt;base; <br/>    return 0; <br/>} 
</pre>
<p>In <kbd>grallo_map</kbd>, if the file descriptor in <kbd>private_handle_t</kbd> is a framebuffer device, we don't have to do the mapping again, since the framebuffer is initialized and mapped to the <kbd>SurfaceFlinger</kbd> address space in <kbd>fb_device_open</kbd>, as we analyzed before.</p>
<p>If it is a shared memory region, it needs to be mapped to the current process address space using the <kbd>mmap</kbd> system function.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Releasing graphic buffers</h1>
            </header>

            <article>
                
<p>As we mentioned previously, the Gralloc module can be used to allocate and release graphic buffers. Now that we have learnt how to allocate buffers from framebuffer devices or system memory, let's have a look at how to release graphic buffers.</p>
<p>To release graphic buffers, the <kbd>gralloc_free</kbd> function is used:</p>
<pre>
static int gralloc_free(alloc_device_t* dev, <br/>        buffer_handle_t handle) <br/>{ <br/>    if (private_handle_t::validate(handle) &lt; 0) <br/>        return -EINVAL; <br/><br/>    private_handle_t const* hnd = reinterpret_cast&lt;private_handle_t const*&gt;<br/>    (handle); <br/>    if (hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) { <br/>        // free this buffer <br/>        private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>                dev-&gt;common.module); <br/>        const size_t bufferSize = m-&gt;finfo.line_length * m-&gt;info.yres; <br/>        int index = (hnd-&gt;base - m-&gt;framebuffer-&gt;base) / bufferSize; <br/>        m-&gt;bufferMask &amp;= ~(1&lt;&lt;index);  <br/>    } else {  <br/>        gralloc_module_t* module = reinterpret_cast&lt;gralloc_module_t*&gt;( <br/>                dev-&gt;common.module); <br/>        terminateBuffer(module, const_cast&lt;private_handle_t*&gt;(hnd)); <br/>    } <br/><br/>    close(hnd-&gt;fd); <br/>    delete hnd; <br/>    return 0; <br/>} 
</pre>
<p>To release a graphic buffer, the buffer is described using <kbd>buffer_handle_t</kbd>. <kbd>gralloc_free</kbd> will validate the buffer first using the <kbd>private_handle_t::validate</kbd> static function.</p>
<p>The <kbd>handle</kbd> parameter can be cast to a pointer of <kbd>private_handle_t</kbd> as we recall from the discussion on <kbd>private_handle_t</kbd> and <kbd>native_handle</kbd> previously. If the <kbd>flags</kbd> field of <kbd>hnd</kbd> is <kbd>PRIV_FLAGS_FRAMEBUFFER</kbd>, it means the buffer is allocated from the framebuffer device. It will update <kbd>bufferMask</kbd> to release it from the framebuffer.</p>
<p>If the buffer is allocated from system memory, it will call the <kbd>terminateBuffer</kbd> function to release the memory:</p>
<pre>
int terminateBuffer(gralloc_module_t const* module, <br/>        private_handle_t* hnd) <br/>{ <br/>    if (hnd-&gt;base) { <br/>        // this buffer was mapped, unmap it now <br/>        gralloc_unmap(module, hnd); <br/>    } <br/><br/>    return 0; <br/>} 
</pre>
<p>The <kbd>terminateBuffer</kbd> function calls to another function, <kbd>gralloc_unmap</kbd>, to release the memory:</p>
<pre>
static int gralloc_unmap(gralloc_module_t const* /*module*/, <br/>        buffer_handle_t handle) <br/>{ <br/>    private_handle_t* hnd = (private_handle_t*)handle; <br/>    if (!(hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER))  <br/>    { <br/>        void* base = (void*)hnd-&gt;base; <br/>        size_t size = hnd-&gt;size; <br/>        //ALOGD("unmapping from %p, size=%d", base, size); <br/>        if (munmap(base, size) &lt; 0) { <br/>            ALOGE("Could not unmap %s", strerror(errno)); <br/>        } <br/>    } <br/>    hnd-&gt;base = 0; <br/>    return 0; <br/>} 
</pre>
<p>In <kbd>gralloc_unmap</kbd>, again, it checks that this buffer is not from the framebuffer and it calls the <kbd>munmap</kbd> system function to release it.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Rendering framebuffer</h1>
            </header>

            <article>
                
<p>As we discussed previously in this chapter, the Gralloc module can support two kinds of device: Gralloc devices and framebuffer devices. In the <kbd>open</kbd> method of the Gralloc device, it creates a device named <kbd>GRALLOC_HARDWARE_GPU0</kbd> and supports two methods, <kbd>alloc</kbd> and <kbd>free</kbd>, as we can see in the following snippet. We have discussed both methods in detail earlier in this chapter:</p>
<pre>
    ... <br/>    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { <br/>        gralloc_context_t *dev; <br/>        dev = (gralloc_context_t*)malloc(sizeof(*dev)); <br/><br/>        /* initialize our state here */ <br/>        memset(dev, 0, sizeof(*dev)); <br/><br/>        /* initialize the procs */ <br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = gralloc_close; <br/><br/>        dev-&gt;device.alloc   = gralloc_alloc; <br/>        dev-&gt;device.free    = gralloc_free; <br/><br/>        *device = &amp;dev-&gt;device.common; <br/>    ... 
</pre>
<p>In the <kbd>open</kbd> method of the framebuffer device, it creates a device named <kbd>GRALLOC_HARDWARE_FB0</kbd> and supports four methods <kbd>close</kbd>, <kbd>setSwapInterval</kbd>, <kbd>post</kbd>, and <kbd>setUpdateRect</kbd>:</p>
<pre>
    ... <br/>    if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { <br/>        /* initialize our state here */ <br/>        fb_context_t *dev = (fb_context_t*)malloc(sizeof(*dev)); <br/>        memset(dev, 0, sizeof(*dev)); <br/><br/>        /* initialize the procs */ <br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = fb_close; <br/>        dev-&gt;device.setSwapInterval = fb_setSwapInterval; <br/>        dev-&gt;device.post            = fb_post; <br/>        dev-&gt;device.setUpdateRect = 0; <br/><br/>        private_module_t* m = (private_module_t*)module; <br/>    ... 
</pre>
<p>You can refer to the AOSP source code or the following URL for information about the implementation of these methods:</p>
<p><a href="http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp"><span class="URLPACKT">http://xref.opersys.com/android-7.0.0_r1/xref/hardware/libhardware/modules/gralloc/framebuffer.cpp</span></a></p>
<p>Let's look at the <kbd>post</kbd> method, which is implemented in <kbd>fb_post</kbd>:</p>
<pre>
static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer) <br/>{ <br/>    if (private_handle_t::validate(buffer) &lt; 0) <br/>        return -EINVAL; <br/><br/>    fb_context_t* ctx = (fb_context_t*)dev; <br/><br/>    private_handle_t const* hnd = reinterpret_cast&lt;private_handle_t const*&gt;<br/>    (buffer); <br/>    private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>            dev-&gt;common.module); <br/><br/>    if (hnd-&gt;flags &amp; private_handle_t::PRIV_FLAGS_FRAMEBUFFER) { <br/>        const size_t offset = hnd-&gt;base - m-&gt;framebuffer-&gt;base; <br/>        m-&gt;info.activate = FB_ACTIVATE_VBL; <br/>        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length; <br/>        if (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == -1) { <br/>            ALOGE("FBIOPUT_VSCREENINFO failed"); <br/>            m-&gt;base.unlock(&amp;m-&gt;base, buffer);  <br/>            return -errno; <br/>        } <br/>        m-&gt;currentBuffer = buffer; <br/><br/>    } else { <br/>        // If we can't do the page_flip, just copy the buffer to the front  <br/>        // FIXME: use copybit HAL instead of memcpy <br/><br/>        void* fb_vaddr; <br/>        void* buffer_vaddr; <br/><br/>        m-&gt;base.lock(&amp;m-&gt;base, m-&gt;framebuffer,  <br/>                GRALLOC_USAGE_SW_WRITE_RARELY,  <br/>                0, 0, m-&gt;info.xres, m-&gt;info.yres, &amp;fb_vaddr); <br/><br/>        m-&gt;base.lock(&amp;m-&gt;base, buffer,  <br/>                GRALLOC_USAGE_SW_READ_RARELY,  <br/>                0, 0, m-&gt;info.xres, m-&gt;info.yres, &amp;buffer_vaddr); <br/><br/>        memcpy(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-<br/>        &gt;info.yres); <br/><br/>        m-&gt;base.unlock(&amp;m-&gt;base, buffer);  <br/>        m-&gt;base.unlock(&amp;m-&gt;base, m-&gt;framebuffer);  <br/>    } <br/><br/>    return 0; <br/>} 
</pre>
<p>After an application has prepared the graphic buffer, it needs to post the buffer to the display so that users can see it on the screen. This <kbd>fb_post</kbd> function is used to display the graphic buffer to the screen. It takes two parameters, <kbd>dev</kbd> and <kbd>buffer</kbd>. The <kbd>dev</kbd> parameter is the pointer of an instance of the data structure of <kbd>framebuffer_device_t</kbd>, which was discussed previously (refer to the diagram about the relationship between <kbd>fb_context_t</kbd> and <kbd>framebuffer_device_t</kbd>). As per the previous discussion, <kbd>dev</kbd> can be cast to <kbd>ctx</kbd>, which is a pointer of <kbd>fb_context_t</kbd>.</p>
<p>After we have an instance of the device, we can get the instance of the Gralloc module from it as follows:</p>
<pre>
private_module_t* m = reinterpret_cast&lt;private_module_t*&gt;( <br/>dev-&gt;common.module); 
</pre>
<p>Another parameter is <kbd>buffer</kbd> and it has a <kbd>buffer_handle_t</kbd> data type. It includes the buffer to be posted. As we discussed previously, it can be cast as a point of <kbd>private_handle_t</kbd> and it is stored in the <kbd>hnd</kbd> variable. This buffer can be a graphic buffer in system memory or it can be part of the framebuffer. Based on the value of the <kbd>hnd-&gt;flags</kbd> member variable, we can find out what kind of buffer it is.</p>
<p>If it is a buffer as part of the framebuffer, we need to activate it as the buffer for the display. This can be done using the framebuffer's <kbd>ioctl</kbd> function. To call the <kbd>ioctl</kbd> function, we need a data structure of <kbd>fb_var_screeninfo</kbd> and this can be found in <kbd>m-&gt;info</kbd>. To swap the buffer in double buffering, we just need to set the vertical offset and activate it as follows:</p>
<pre>
    ... <br/>        m-&gt;info.activate = FB_ACTIVATE_VBL; <br/>        m-&gt;info.yoffset = offset / m-&gt;finfo.line_length; <br/>        if (ioctl(m-&gt;framebuffer-&gt;fd, FBIOPUT_VSCREENINFO, &amp;m-&gt;info) == -1) { <br/>    ... 
</pre>
<p>If it is a buffer allocated in system memory, we need to copy it to the framebuffer. In this case, it tries to lock both the graphic buffer and framebuffer first, and then it copies the graphic buffer using <kbd>memcpy</kbd>:</p>
<pre>
memcpy(fb_vaddr, buffer_vaddr, m-&gt;finfo.line_length * m-&gt;info.yres); 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Graphics HAL of the Android emulator</h1>
            </header>

            <article>
                
<p>After we have analyzed the default Gralloc module implementation, we want to briefly look at another Gralloc module implementation so that we can compare how a Gralloc module should be implemented on varying Graphic hardware.</p>
<p>The Gralloc module we will analyze in this section is the Gralloc module used by the Android emulator. The default Gralloc module <kbd>gralloc.default.so</kbd> only uses framebuffer devices and it doesn't use GPU. If the default Gralloc module is used, OpenGL support has to be implemented in the software layer. This is the case with VirtualBox for the time being, since there is no Mesa/DRM-compliant implementation in the VirtualBox host side for OpenGL. This doesn't mean VirtualBox doesn't support OpenGL. It does support OpenGL and 3D hardware acceleration, but the implementation is not compliant with the open source Mesa/DRM architecture.</p>
<div class="packt_infobox">If you are interested in this topic about OpenGL support on VirtualBox, you may read the following threads in the Android-x86 discussion group:<br/>
<a href="https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI"><span class="URLPACKT">https://groups.google.com/forum/?hl=en#!starred/android-x86/gZYx6oWx4LI</span></a></div>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Overview of hardware GLES emulation</h1>
            </header>

            <article>
                
<p>3D graphics support on Andriod emulator is implemented in different ways as follows:</p>
<ul>
<li><kbd>host</kbd>: This is the default mode. This is also called hardware GLES emulation. It uses specific translator libraries to convert guest EGL/GLES commands into host GL ones. This requires valid OpenGL drivers installed on the host machine.</li>
<li><kbd>swiftshader</kbd>: This is a software library for high-performance graphics rendering on the CPU. It takes advantage of SIMD on modern CPUs to perform graphics rendering.</li>
<li><kbd>mesa</kbd>: This is deprecated. It is a software library using the Mesa3D library. It is slower than swiftshader mode, and slower than the <kbd>host</kbd> mode by a large margin.</li>
<li><kbd>guest</kbd>: This is a pure software implementation on the guest side.</li>
</ul>
<p>To choose a graphic mode in the emulator, you can either specify it on the command line with the <kbd>-gpu</kbd> option or define it in the <kbd>config.ini</kbd> configuration file as follows:</p>
<pre>
hw.gps=yes <br/>hw.gpu.enabled=yes <br/>hw.gpu.mode=swiftshader 
</pre>
<p>We will look at the Gralloc module implementation in the <kbd>host</kbd> mode here. In the hardware GLES emulation, there are several host "translator" libraries implemented: EGL, GLES 1.1, and GLES 2.0 ABIs (Application Binary Interface) defined by Khronos. These libraries translate the corresponding function calls into calls to the appropriate host OpenGL APIs.</p>
<p>There are the same set of system libraries implemented inside the emulated guest system for EGL, GLES 1.1, and GLES 2.0 ABIs. They collect the sequence of EGL/GLES function calls and translate them into a custom wire protocol stream that is sent to the emulator program through a high-speed communication channel called a "QEMU pipe." The pipe is implemented with a custom kernel driver and it can provide a very fast channel for communication between the host and the guest system. I have given a brief introduction about the QEMU pipe in <a href="e0f861c2-5832-402f-89d3-cfc75785e759.xhtml">Chapter 3</a>, <em><span class="ChapterrefPACKT">Discovering Kernel, HAL, and Virtual Hardware</span></em> and you can refer to it for more information.</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="EmailPACKT"><img height="513" width="413" class=" image-border" src="assets/image_10_006.png"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Hardware GLES emulation</div>
<p>You can find the preceding diagram in the emulator source code at <kbd>$AOSP/external/qemu/distrib/android-emugl/DESIGN</kbd>.</p>
<p>The emulator source code is not downloaded using the manifest file in this chapter. You can refer to the following URL:</p>
<p><a href="https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN"><span class="URLPACKT">https://android.googlesource.com/platform/external/qemu/+/master/distrib/android-emugl/DESIGN</span></a></p>
<p>Or you can get the entire repository using the following command:</p>
<pre>
<strong>$ git clone https://android.googlesource.com/platform/external/qemu</strong>  
</pre>
<p>The preceding diagram shows components on both the host (emulator) side and the guest side for the GLES emulation. We may treat the host side implementation as GPU, and <strong>QEMU PIPE</strong> is the connection between GPU and CPU. There are two things that need to access GPU for 3D graphics acceleration: the Gralloc module and the vendor library. The vendor library here refers to the hardware GLES emulation library for Android emulator. The Gralloc module is the one that we want to explore in this section.</p>
<p>The GLES hardware emulation Gralloc module is very similar to the default Gralloc module that we have discussed in this chapter. It needs to implement the following three HAL data structures:</p>
<pre>
struct hw_module_t; <br/>struct hw_module_methods_t; <br/>struct hw_device_t; 
</pre>
<p>For the first data structure, <kbd>hw_module_t</kbd>, both Gralloc modules have their own implementation called <kbd>private_module_t</kbd>, which is inherited from <kbd>hw_module_t</kbd>, but the definitions are different, as we can see in the following snippet.</p>
<p>The <kbd>private_module_t</kbd> in the default Gralloc module is as follows:</p>
<pre>
struct private_module_t { <br/>    gralloc_module_t base; <br/><br/>    private_handle_t* framebuffer; <br/>    uint32_t flags; <br/>    uint32_t numBuffers; <br/>    uint32_t bufferMask; <br/>    pthread_mutex_t lock; <br/>    buffer_handle_t currentBuffer; <br/>    int pmem_master; <br/>    void* pmem_master_base; <br/><br/>    struct fb_var_screeninfo info; <br/>    struct fb_fix_screeninfo finfo; <br/>    float xdpi; <br/>    float ydpi; <br/>    float fps; <br/>}; 
</pre>
<p>The <kbd>private_module_t</kbd> in the GLES emulation Gralloc module is as follows:</p>
<pre>
struct private_module_t { <br/>    gralloc_module_t base; <br/>}; 
</pre>
<p>For the <kbd>hw_device_t</kbd> data structure implementation, we can get the details from the following table. We can create two kinds of devices, <kbd>GPU0</kbd> and <kbd>FB0</kbd>, using the <kbd>open</kbd> method in the <kbd>hw_module_methods_t</kbd> data structure. In both implementations, data structures inherited from <kbd>hw_device_t</kbd> are used:</p>
<table class="table">
<tbody>
<tr>
<td>
<p><strong>hw_device_t in</strong><br/>
<strong>Gralloc module</strong></p>
</td>
<td>
<p><strong>GPU0</strong></p>
</td>
<td>
<p><strong>FB0</strong></p>
</td>
</tr>
<tr>
<td>
<p>Android emulator</p>
</td>
<td>
<p><kbd>gralloc_device_t</kbd></p>
</td>
<td>
<p><kbd>fb_device_t</kbd></p>
</td>
</tr>
<tr>
<td>
<p>Default Gralloc</p>
</td>
<td>
<p><kbd>gralloc_context_t</kbd></p>
</td>
<td>
<p><kbd>fb_context_t</kbd></p>
</td>
</tr>
</tbody>
</table>
<p>We have analyzed both <kbd>gralloc_context_t</kbd> and <kbd>fb_context_t</kbd> in the <em><span class="ChapterrefPACKT">Initializing GPU</span></em> section. We can look at the definitions of <kbd>gralloc_device_t</kbd> and <kbd>fb_device_t</kbd> in the following GLES emulation implementation:</p>
<pre>
struct gralloc_device_t { <br/>    alloc_device_t  device; <br/><br/>    AllocListNode *allocListHead;    // double linked list of allocated buffers <br/>    pthread_mutex_t lock; <br/>}; <br/><br/>struct fb_device_t { <br/>    framebuffer_device_t  device; <br/>}; 
</pre>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Initializing GPU0 and FB0 in GLES emulation</h1>
            </header>

            <article>
                
<p>As we know, device initialization is done in the <kbd>open</kbd> method defined in the <kbd>hw_module_methods_t</kbd> data structure. Let's look at the implementation of the <kbd>open</kbd> method in GLES emulation. It is implemented in the <kbd>gralloc_device_open</kbd> function, as we can see in the following snippet:</p>
<pre>
static int gralloc_device_open(const hw_module_t* module, <br/>                               const char* name, <br/>                               hw_device_t** device) <br/>{ <br/>    int status = -EINVAL; <br/><br/>    D("gralloc_device_open %s\n", name); <br/><br/>    pthread_once( &amp;sFallbackOnce, fallback_init ); <br/>    if (sFallback != NULL) { <br/>        return sFallback-&gt;common.methods-&gt;open(&amp;sFallback-&gt;common, <br/>        name, device); <br/>    } <br/><br/>    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { <br/><br/>        // Create host connection and keep it in the TLS. <br/>        // return error if connection with host can not be established <br/>        HostConnection *hostCon = HostConnection::get(); <br/>        if (!hostCon) { <br/>            ALOGE("gralloc: failed to get host connection <br/>            while opening %s\n", <br/>            name); <br/>            return -EIO; <br/>        } <br/><br/>        // <br/>        // Allocate memory for the gralloc device (alloc interface) <br/>        // <br/>        gralloc_device_t *dev; <br/>        dev = (gralloc_device_t*)malloc(sizeof(gralloc_device_t)); <br/>        if (NULL == dev) { <br/>            return -ENOMEM; <br/>        } <br/><br/>        // Initialize our device structure <br/>        // <br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = gralloc_device_close; <br/><br/>        dev-&gt;device.alloc   = gralloc_alloc; <br/>        dev-&gt;device.free    = gralloc_free; <br/>        dev-&gt;allocListHead  = NULL; <br/>        pthread_mutex_init(&amp;dev-&gt;lock, NULL); <br/><br/>        *device = &amp;dev-&gt;device.common; <br/>        status = 0; <br/>    } <br/>    else if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { <br/>    ... <br/>    } <br/><br/>    return status; <br/>} 
</pre>
<p>The preceding code snippet is part of the <kbd>GPU0</kbd> initialization. Before it creates the devices for <kbd>GPU0</kbd> or <kbd>FB0</kbd>, it will call a <kbd>fallback_init</kbd> function to check the system settings for hardware emulation. In <kbd>fallback_init</kbd>, it will check a <kbd>ro.kernel.qemu.gles</kbd> system property. If this property is set to 0, the GPU emulation will be disabled. The default Gralloc module will be used. In this case, the <kbd>open</kbd> method defined in the default Gralloc module, <kbd>sFallback</kbd>, will be called.</p>
<p>For the <kbd>GPU0</kbd> initialization, it will check whether the device name is equal to <kbd>GRALLOC_HARDWARE_GPU0</kbd> or not. If it is <kbd>GPU0</kbd>, it will get the host connection first. The host connection is the QEMU pipe link between the host and the guest system as we discussed before.</p>
<p>After that, it initializes the <kbd>GPU0</kbd> device as the initialization process that we discussed for the default Gralloc module.</p>
<p>Next, let's have a look at the <kbd>FB0</kbd> initialization as follows:</p>
<pre>
static int gralloc_device_open(const hw_module_t* module, <br/>                               const char* name, <br/>                               hw_device_t** device) <br/>{ <br/>    int status = -EINVAL; <br/><br/>    D("gralloc_device_open %s\n", name); <br/><br/>    pthread_once( &amp;sFallbackOnce, fallback_init ); <br/>    if (sFallback != NULL) { <br/>        return sFallback-&gt;common.methods-&gt;open(&amp;sFallback-&gt;common, <br/>        name, device); <br/>    } <br/><br/>    if (!strcmp(name, GRALLOC_HARDWARE_GPU0)) { <br/>      ... <br/>    } <br/>    else if (!strcmp(name, GRALLOC_HARDWARE_FB0)) { <br/><br/>        // return error if connection with host can not be established <br/>        DEFINE_AND_VALIDATE_HOST_CONNECTION; <br/><br/>        // <br/>        // Query the host for Framebuffer attributes <br/>        // <br/>        D("gralloc: query Frabuffer attribs\n"); <br/>        EGLint width = rcEnc-&gt;rcGetFBParam(rcEnc, FB_WIDTH); <br/>        D("gralloc: width=%d\n", width); <br/>        EGLint height = rcEnc-&gt;rcGetFBParam(rcEnc, FB_HEIGHT); <br/>        D("gralloc: height=%d\n", height); <br/>        EGLint xdpi = rcEnc-&gt;rcGetFBParam(rcEnc, FB_XDPI); <br/>        D("gralloc: xdpi=%d\n", xdpi); <br/>        EGLint ydpi = rcEnc-&gt;rcGetFBParam(rcEnc, FB_YDPI); <br/>        D("gralloc: ydpi=%d\n", ydpi); <br/>        EGLint fps = rcEnc-&gt;rcGetFBParam(rcEnc, FB_FPS); <br/>        D("gralloc: fps=%d\n", fps); <br/>        EGLint min_si = rcEnc-&gt;rcGetFBParam(rcEnc,  <br/>        FB_MIN_SWAP_INTERVAL); <br/>        D("gralloc: min_swap=%d\n", min_si); <br/>        EGLint max_si = rcEnc-&gt;rcGetFBParam(rcEnc, <br/>        FB_MAX_SWAP_INTERVAL); <br/>        D("gralloc: max_swap=%d\n", max_si); <br/><br/>        // <br/>        // Allocate memory for the framebuffer device <br/>        // <br/>        fb_device_t *dev; <br/>        dev = (fb_device_t*)malloc(sizeof(fb_device_t)); <br/>        if (NULL == dev) { <br/>            return -ENOMEM; <br/>        } <br/>        memset(dev, 0, sizeof(fb_device_t)); <br/><br/>        // Initialize our device structure <br/>        // <br/>        dev-&gt;device.common.tag = HARDWARE_DEVICE_TAG; <br/>        dev-&gt;device.common.version = 0; <br/>        dev-&gt;device.common.module = const_cast&lt;hw_module_t*&gt;(module); <br/>        dev-&gt;device.common.close = fb_close; <br/>        dev-&gt;device.setSwapInterval = fb_setSwapInterval; <br/>        dev-&gt;device.post            = fb_post; <br/>        dev-&gt;device.setUpdateRect   = 0; //fb_setUpdateRect; <br/>        dev-&gt;device.compositionComplete = fb_compositionComplete; <br/><br/>        const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.flags) = 0; <br/>        const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.width) = width; <br/>        const_cast&lt;uint32_t&amp;&gt;(dev-&gt;device.height) = height; <br/>        const_cast&lt;int&amp;&gt;(dev-&gt;device.stride) = width; <br/>        const_cast&lt;int&amp;&gt;(dev-&gt;device.format) = <br/>        HAL_PIXEL_FORMAT_RGBA_8888; <br/>        const_cast&lt;float&amp;&gt;(dev-&gt;device.xdpi) = xdpi; <br/>        const_cast&lt;float&amp;&gt;(dev-&gt;device.ydpi) = ydpi; <br/>        const_cast&lt;float&amp;&gt;(dev-&gt;device.fps) = fps; <br/>        const_cast&lt;int&amp;&gt;(dev-&gt;device.minSwapInterval) = min_si; <br/>        const_cast&lt;int&amp;&gt;(dev-&gt;device.maxSwapInterval) = max_si; <br/>        *device = &amp;dev-&gt;device.common; <br/><br/>        status = 0; <br/>    } 
</pre>
<p>In the <kbd>FB0</kbd> initialization, it tries to get the host connection and an <kbd>rcEnc</kbd> pointer, which is an instance of the <kbd>renderControl_encoder_context_t</kbd> data structure, using the <kbd>DEFINE_AND_VALIDATE_HOST_CONNECTION</kbd> macro. With <kbd>rcEnc</kbd>, it can get the framebuffer attributes (<kbd>width</kbd>, <kbd>height</kbd>, <kbd>xdpi</kbd>, <kbd>ydpi</kbd>, <kbd>fps</kbd>, <kbd>min_si</kbd>, and <kbd>max_si</kbd>) from the host connection. After that, it creates an instance of the <kbd>fb_device_t</kbd> data structure and fills in the framebuffer attributes in this instance of <kbd>fb_device_t</kbd>.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">GPU0 device implementation</h1>
            </header>

            <article>
                
<p>As we did for the default Gralloc module, we will analyze the <kbd>alloc</kbd> and <kbd>free</kbd> methods in the <kbd>GPU0</kbd> device. The <kbd>alloc</kbd> method is implemented in the <kbd>gralloc_alloc</kbd> function. The <kbd>gralloc_alloc</kbd> function is much longer than the one in the default Gralloc module, but it basically does three things:</p>
<ul>
<li>Checks the <kbd>usage</kbd> parameter and decides the pixel format to decide the size of the pixel.</li>
<li>According to the information provided by the <kbd>usage</kbd> parameter, <kbd>w</kbd>, <kbd>h</kbd>, <kbd>format</kbd>, and <kbd>usage</kbd> create a shared memory region and allocate buffers in the host side (GPU).</li>
<li>Stores both the shared memory region and host side (GPU) buffer information in the Gralloc device data structure <kbd>grdev</kbd>.</li>
</ul>
<p>Now let's take a look at the code for <kbd>gralloc_alloc</kbd>:</p>
<pre>
static int gralloc_alloc(alloc_device_t* dev, <br/>                         int w, int h, int format, int usage, <br/>                         buffer_handle_t* pHandle, int* pStride) <br/>{ <br/>    D("gralloc_alloc w=%d h=%d usage=0x%x\n", w, h, usage); <br/><br/>    gralloc_device_t *grdev = (gralloc_device_t *)dev; <br/>    if (!grdev || !pHandle || !pStride) { <br/>        ALOGE("gralloc_alloc: Bad inputs (grdev: %p, pHandle: %p, <br/>        pStride: %p", <br/>        grdev, pHandle, pStride); <br/>        return -EINVAL; <br/>    } <br/><br/>    // <br/>    // Note: in screen capture mode, both sw_write <br/>    // and hw_write will be on <br/>    // and this is a valid usage <br/>    // <br/>    bool sw_write = (0 != (usage &amp; GRALLOC_USAGE_SW_WRITE_MASK)); <br/>    bool hw_write = (usage &amp; GRALLOC_USAGE_HW_RENDER); <br/>    bool sw_read = (0 != (usage &amp; GRALLOC_USAGE_SW_READ_MASK)); <br/>    bool hw_cam_write = usage &amp; GRALLOC_USAGE_HW_CAMERA_WRITE; <br/>    bool hw_cam_read = usage &amp; GRALLOC_USAGE_HW_CAMERA_READ; <br/>    bool hw_vid_enc_read = usage &amp; GRALLOC_USAGE_HW_VIDEO_ENCODER; <br/><br/>    // Keep around original requested format for later validation <br/>    int frameworkFormat = format; <br/>    // Pick the right concrete pixel format given the endpoints as    <br/>    // encoded in the usage bits.  <br/>    // Every end-point pair needs explicit listing here. <br/>    if (format == HAL_PIXEL_FORMAT_IMPLEMENTATION_DEFINED) { <br/>        // Camera as producer <br/>        ... <br/>    if (usage &amp; GRALLOC_USAGE_HW_FB) { <br/>        // keep space for postCounter <br/>        ashmem_size += sizeof(uint32_t); <br/>    } <br/><br/>    if (sw_read || sw_write || hw_cam_write || hw_vid_enc_read) { <br/>        // keep space for image on guest memory if SW access is needed <br/>        // or if the camera is doing writing <br/>        if (yuv_format) { <br/>            size_t yStride = (w*bpp + (align - 1)) &amp; ~(align-1); <br/>            size_t uvStride = (yStride / 2 + (align - 1)) &amp; ~(align-1); <br/>            size_t uvHeight = h / 2; <br/>            ashmem_size += yStride * h + 2 * (uvHeight * uvStride); <br/>            stride = yStride / bpp; <br/>        } else { <br/>            size_t bpr = (w*bpp + (align-1)) &amp; ~(align-1); <br/>            ashmem_size += (bpr * h); <br/>            stride = bpr / bpp; <br/>        } <br/>    } <br/><br/>    D("gralloc_alloc format=%d, ashmem_size=%d, stride=%d, <br/>    tid %d\n", format, <br/>            ashmem_size, stride, gettid()); 
</pre>
<p>In the preceding code of <kbd>gralloc_alloc</kbd>, it creates an instance of data structure <kbd>gralloc_device_t</kbd> first. After that, it checks the <kbd>usage</kbd> and <kbd>format</kbd> parameters to decide the size of the pixels and the corresponding GLES color format and pixel type to store in the <kbd>bpp</kbd>, <kbd>glFormat</kbd>, and <kbd>glType</kbd> variables. With the necessary information, it can calculate the size of the shared memory that needs to be allocated for the graphic buffer and stores it in the <kbd>ashmem_size</kbd> variable:</p>
<pre>
    // <br/>    // Allocate space in ashmem if needed <br/>    // <br/>    int fd = -1; <br/>    if (ashmem_size &gt; 0) { <br/>        // round to page size; <br/>        ashmem_size = (ashmem_size + (PAGE_SIZE-1)) &amp; ~(PAGE_SIZE-1); <br/><br/>        fd = ashmem_create_region("gralloc-buffer", ashmem_size); <br/>        if (fd &lt; 0) { <br/>            ALOGE("gralloc_alloc failed to create ashmem region: %s\n", <br/>                    strerror(errno)); <br/>            return -errno; <br/>        } <br/>    } <br/><br/>    cb_handle_t *cb = new cb_handle_t(fd, ashmem_size, usage, <br/>                                      w, h, frameworkFormat, format, <br/>                                      glFormat, glType); <br/><br/>    if (ashmem_size &gt; 0) { <br/>        // <br/>        // map ashmem region if exist <br/>        // <br/>        void *vaddr; <br/>        int err = map_buffer(cb, &amp;vaddr); <br/>        if (err) { <br/>            close(fd); <br/>            delete cb; <br/>            return err; <br/>        } <br/><br/>        cb-&gt;setFd(fd); <br/>    } <br/><br/>    // <br/>    // Allocate ColorBuffer handle on the host (only if h/w access is   <br/>    //allowed) only do this for some h/w usages, not all. <br/>    // <br/>    if (usage &amp; (GRALLOC_USAGE_HW_TEXTURE | GRALLOC_USAGE_HW_RENDER | <br/>                    GRALLOC_USAGE_HW_2D | GRALLOC_USAGE_HW_COMPOSER | <br/>                    GRALLOC_USAGE_HW_FB) ) { <br/>        DEFINE_HOST_CONNECTION; <br/>        if (hostCon &amp;&amp; rcEnc) { <br/>            cb-&gt;hostHandle = rcEnc-&gt;rcCreateColorBuffer(rcEnc, w, h, <br/>            glFormat); <br/>            D("Created host ColorBuffer 0x%x\n", cb-&gt;hostHandle); <br/>        } <br/><br/>        if (!cb-&gt;hostHandle) { <br/>           // Could not create colorbuffer on host !!! <br/>           close(fd); <br/>           delete cb; <br/>           return -EIO; <br/>        } <br/>    } 
</pre>
<p>As for the shared memory size <kbd>ashmem_size</kbd>, it allocates a shared memory region using the <kbd>ashmem_create_region</kbd> function and it obtains the shared memory region as an <kbd>fd</kbd> file descriptor. To store the shared memory region and the GPU buffer (the host side buffer), which we will discuss now, it creates an instance of the <kbd>cb_handle_t</kbd> data structure. If we recall, we used the <kbd>private_handle_t</kbd> data structure in the default Gralloc module to represent an allocated graphic buffer. Here, <kbd>cb_handle_t</kbd> is an equivalent of <kbd>private_handle_t</kbd>:</p>
<pre>
struct cb_handle_t : public native_handle { <br/><br/>    cb_handle_t(int p_fd, int p_ashmemSize, int p_usage, <br/>                int p_width, int p_height, int p_frameworkFormat, <br/>                int p_format, int p_glFormat, int p_glType) : <br/>    ... <br/>    // file-descriptors <br/>    int fd;   <br/><br/>    // ints <br/>    int magic; <br/>    int usage; <br/>    int width; <br/>    int height; <br/>    int frameworkFormat; <br/>    int format; <br/>    int glFormat; <br/>    int glType; <br/>    int ashmemSize; <br/><br/>    union { <br/>        intptr_t ashmemBase; <br/>        uint64_t padding; <br/>    } __attribute__((aligned(8))); <br/><br/>    int ashmemBasePid; <br/>    int mappedPid; <br/>    int lockedLeft; <br/>    int lockedTop; <br/>    int lockedWidth; <br/>    int lockedHeight; <br/>    uint32_t hostHandle; <br/>}; 
</pre>
<p>Because <kbd>cb_handle_t</kbd> is a large data structure, in the preceding code snippet we did not show all the member functions of <kbd>cb_handle_t</kbd>. From the member variables, we can see that they are similar to <kbd>private_handle_t</kbd>. You can refer to the section on <kbd>private_handle_t</kbd> for an explanation of most member variables. Pay attention to the last member variable, <kbd>hostHandle</kbd>, which is used to store the buffer allocated on GPU (the host side in GLES emulation). If you are interested in host side GLES emulation, you can refer to the QEMU source code.</p>
<p>Let's look at the last piece of code for <kbd>gralloc_alloc</kbd>:</p>
<pre>
    // <br/>    // alloc succeeded - insert the allocated handle to the allocated    <br/>    // list <br/>    // <br/>    AllocListNode *node = new AllocListNode(); <br/>    pthread_mutex_lock(&amp;grdev-&gt;lock); <br/>    node-&gt;handle = cb; <br/>    node-&gt;next =  grdev-&gt;allocListHead; <br/>    node-&gt;prev =  NULL; <br/>    if (grdev-&gt;allocListHead) { <br/>        grdev-&gt;allocListHead-&gt;prev = node; <br/>    } <br/>    grdev-&gt;allocListHead = node; <br/>    pthread_mutex_unlock(&amp;grdev-&gt;lock); <br/><br/>    *pHandle = cb; <br/>    if (frameworkFormat == HAL_PIXEL_FORMAT_YCbCr_420_888) { <br/>        *pStride = 0; <br/>    } else { <br/>        *pStride = stride; <br/>    } <br/>    return 0; <br/>} 
</pre>
<p>After the buffer is allocated on GPU and the shared memory region is acquired from the system memory, they are stored in the <kbd>grdev</kbd> variable and added to a linked list node to the double linked list in <kbd>gralloc_device_t</kbd>.</p>
<p>For the <kbd>free</kbd> method of <kbd>gralloc_device_t</kbd>, it is much simpler than <kbd>alloc</kbd>. To save space, I won't list the source code here. The <kbd>free</kbd> method is implemented in the <kbd>gralloc_free</kbd> function. What it does is:</p>
<ol>
<li>Validate the <kbd>buffer_handle_t</kbd> point to a valid <kbd>cb_handle_t</kbd> data structure.</li>
<li>Release the buffer on the host side (GPU), calling the <kbd>rcCloseColorBuffer</kbd> function.</li>
<li>Un-map the buffer in the shared memory region and release the shared memory.</li>
<li>Remove the node from the linked list.</li>
<li>Free the memory used by the <kbd>cb_handle_t</kbd> data structure.</li>
</ol>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">FB0 device implementation</h1>
            </header>

            <article>
                
<p>For the implementation of the <kbd>FB0</kbd> device, we will look at the <kbd>post</kbd> method as we did for the default Gralloc module analysis. This is implemented in the <kbd>fb_post</kbd> function and we can look at the implementation as follows:</p>
<pre>
static int fb_post(struct framebuffer_device_t* dev, buffer_handle_t buffer) <br/>{ <br/>    fb_device_t *fbdev = (fb_device_t *)dev; <br/>    cb_handle_t *cb = (cb_handle_t *)buffer; <br/><br/>    if (!fbdev || !cb_handle_t::validate(cb) || !cb-&gt;canBePosted()) { <br/>        return -EINVAL; <br/>    } <br/><br/>    // Make sure we have host connection <br/>    DEFINE_AND_VALIDATE_HOST_CONNECTION; <br/><br/>    // increment the post count of the buffer <br/>    intptr_t *postCountPtr = (intptr_t *)cb-&gt;ashmemBase; <br/>    if (!postCountPtr) { <br/>        // This should not happen <br/>        return -EINVAL; <br/>    } <br/>    (*postCountPtr)++; <br/><br/>    // send post request to host <br/>    rcEnc-&gt;rcFBPost(rcEnc, cb-&gt;hostHandle); <br/>    hostCon-&gt;flush(); <br/><br/>    return 0; <br/>} 
</pre>
<p>What it does is very simple; it increases the post count of the buffer and calls to the <kbd>rcFBpost</kbd> function to update the buffer in GPU.</p>
<p>We have completed our analysis of Android emulator graphics HAL now. I hope the analysis of the generic graphics HAL and Android emulator graphics HAL has helped you understand the graphics HAL in your system.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    

        <section>

            <header>
                <h1 class="header-title">Summary</h1>
            </header>

            <article>
                
<p>In this chapter, we explored and reviewed two Gralloc HAL module implementations, the default Gralloc module and the one used by Android emulator. The default Gralloc HAL uses framebuffer devices only and the OpenGLES support uses a software implementation. The one used by Android emulator is a hardware emulation on the host side. The implementation is similar to the GPU-based Gralloc module.</p>
<p>Since graphics systems are so complex, we will continue exploring this topic a little more when looking at VirtualBox-specific implementation in the next chapter. We will explain the loading process of Gralloc HAL and OpenGL ES libraries. We will build a VirtualBox extension pack for Android so that we can utilize the capability provided by VirtualBox.</p>


            </article>

            <footer style="margin-top: 5em;">
                
            </footer>

        </section>
    </body></html>