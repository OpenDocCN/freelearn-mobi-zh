# 18

# 内存管理

多年来，我主要使用的编程语言是C和基于C的面向对象语言。这些语言要求对内存管理有很好的掌握，并知道何时释放内存。幸运的是，现代语言如Swift为我们处理内存管理。然而，了解这种内存管理的工作原理是个好主意，这样我们可以避免导致内存管理失败的陷阱。

在本章中，我们将学习：

+   ARC 的工作原理

+   强引用循环是什么

+   如何使用弱引用和无主引用来防止强引用循环

如我们在*第17章*中看到的，*自定义值类型*，结构体是值类型，类是引用类型。这意味着当我们在我们应用程序中传递一个结构体的实例时，例如一个方法的参数，我们在内存中创建了一个新的结构体实例。这个结构体的新实例仅在结构体被创建的作用域内有效。一旦结构体超出作用域，结构体的新实例将被自动销毁，内存将被释放。这使得结构体的内存管理非常简单且无痛苦。

相反，类是引用类型。这意味着我们只为类的实例分配一次内存，即它最初被创建时。当我们在我们应用程序中传递类的实例时，无论是作为函数参数还是通过将其分配给变量，我们实际上是在传递一个指向内存中实例存储位置的引用。由于类的实例可能在多个作用域中被引用（与结构体不同），它不能被自动销毁，当它超出作用域时不会释放内存，因为它可能在另一个作用域中被引用。因此，Swift需要某种形式的内存管理来跟踪和释放当类不再需要时由类的实例使用的内存。Swift使用**自动引用计数**（**ARC**）来跟踪和管理内存使用。

在ARC中，对于Swift来说，大部分的内存管理工作很简单。ARC会自动跟踪类的实例引用，当一个实例不再需要时（当没有引用指向它时），ARC会自动销毁该实例并释放内存。有一些情况下，ARC需要关于关系的额外信息来正确管理内存。在我们查看ARC需要帮助的情况之前，让我们看看ARC本身是如何工作的。

# ARC 的工作原理

每当我们创建一个新类的实例时，**ARC**会分配存储该实例所需的内存。这确保了有足够的内存来存储与该类实例相关的信息，并且锁定内存，防止任何内容覆盖它。

当类的实例不再需要时，ARC将释放为实例分配的内存，以便它可以用于其他目的。这确保了我们不会占用不再需要的内存。当内存被保留给不再需要的实例时，这被称为**内存泄漏**。

如果ARC释放了一个仍然需要的类的实例的内存，那么将无法从内存中检索到类信息。如果我们尝试在内存释放后访问类的实例，应用程序可能会崩溃或数据可能会损坏。为了确保不会释放仍然需要的类的实例的内存，ARC会计算实例被引用的次数；也就是说，有多少活跃的属性、变量或常量指向类的实例。一旦类的实例的引用计数等于零（即没有任何东西引用该实例），内存就会被标记为释放。

所有的前一个示例都在playground中运行正常；然而，以下示例将不会运行。当我们在一个playground中运行示例代码时，ARC不会释放我们创建的对象；这是设计上的，这样我们就可以看到应用程序的运行情况以及每个步骤中对象的状态。因此，我们需要将这些样本作为一个iOS或macOS项目来运行。让我们看看ARC是如何工作的一个例子。我们首先使用以下代码创建一个`MyClass`类：

[PRE0]

在这个类中，我们有一个`name`属性，它将通过接受一个字符串值的初始化器来设置。这个类还有一个在类的实例被销毁并从内存中移除之前被调用的析构器。这个析构器会在控制台打印一条消息，让我们知道类的实例即将被移除。

现在，让我们看看展示ARC如何创建和销毁类实例的代码：

[PRE1]

在这个例子中，我们首先创建了两个名为`class1ref1`（代表类1引用1）和`class2ref1`（代表类2引用1）的`MyClass`类的实例。然后我们为`class2ref1`创建了一个第二个引用，名为`class2ref2`。

现在，为了看到ARC是如何工作的，我们需要开始将引用设置为`nil`。我们首先将`class1ref1`设置为`nil`。由于只有一个引用指向`class1ref1`，析构器将被调用。一旦析构器完成其任务，在我们的例子中，它会在控制台打印一条消息，让我们知道类的实例已经被销毁，内存已经被释放。

然后，我们将`class2ref1`设置为`nil`，但是这个类有一个第二个引用（`class2ref2`），这阻止了ARC销毁实例，因此不会调用析构器。

最后，我们将`class2ref2`设置为`nil`，这允许ARC销毁这个`MyClass`类的实例。

如果我们运行这段代码，我们将看到以下输出，它说明了ARC是如何工作的：

[PRE2]

从例子中看起来，ARC处理内存管理得很好。然而，有可能编写代码来阻止ARC正常工作。

# 强引用循环

**强引用循环**，或称为**强保留循环**，是指两个类的实例相互持有强引用，阻止ARC释放任何一个实例。再次强调，我们无法在这个例子中使用playground，因此我们需要创建一个Xcode项目。在这个项目中，我们首先创建两个名为`MyClass1_Strong`和`MyClass2_Strong`的类，代码如下：

[PRE3]

从代码中我们可以看出，`MyClass1_Strong`包含了一个`MyClass2_Strong`的实例，因此`MyClass2_Strong`的实例不能被释放，直到`MyClass1_Strong`被销毁。我们还可以从代码中看到，`MyClass2_Strong`包含了一个`MyClass1_Strong`的实例，因此，`MyClass1_Strong`的实例不能被释放，直到`MyClass2_Strong`被销毁。这创建了一个依赖循环，其中两个实例都不能被销毁，直到另一个被销毁。

让我们通过运行以下代码来看看它是如何工作的：

[PRE4]

在这个例子中，我们创建了`MyClass1_Strong`和`MyClass2_Strong`两个类的实例。然后我们将`class1`实例的`class2`属性设置为`MyClass2_Strong`实例。我们还设置了`class2`实例的`class1`属性为`MyClass1_Strong`实例。这意味着`MyClass1_Strong`实例不能被销毁，直到`MyClass2_Strong`实例被销毁。这也意味着每个实例的引用计数器永远不会达到零，因此ARC不能销毁这些实例，在这种情况下会产生以下输出：

[PRE5]

这种无法销毁实例的能力会导致内存泄漏，应用程序继续使用内存而不正确地释放它。这可能导致应用程序最终崩溃。

要解决强引用循环，我们需要防止其中一个类保持对另一个类实例的强引用，从而允许ARC销毁它们。Swift提供了两种方法，允许我们定义属性为弱引用或无所有者引用。

弱引用和无所有者引用之间的区别是，弱引用所引用的实例可以是`nil`，而无所有者引用所引用的实例不能是`nil`。这意味着当我们使用弱引用时，属性必须是可选属性。让我们看看我们如何使用无所有者和弱引用来解决强引用循环。让我们首先看看无所有者引用。

## 无所有者引用

我们首先创建另外两个类，`MyClass1_Unowned`和`MyClass2_Unowned`：

[PRE6]

`MyClass1_Unowned` 类在先前的示例中看起来与 `MyClass1_Strong` 和 `MyClass2_Strong` 类非常相似。这里的区别在于 `MyClass1_Unowned` 类——我们将 `class2` 属性设置为 `unowned`，这意味着它不能为 `nil`，并且它不会保持对它所引用的实例的强引用。由于 `class2` 属性不能为 `nil`，因此我们还需要在类初始化时将其设置。

让我们看看如何使用以下代码初始化和销毁这些类的实例：

[PRE7]

在前面的代码中，我们创建了一个 `MyClass_Unowned` 类的实例，然后使用该实例创建了一个 `MyClass1_Unowned` 类的实例。然后我们将 `MyClass2` 实例的 `class1` 属性设置为刚刚创建的 `MyClass1_Unowned` 实例。

这再次在两个类之间创建了依赖关系的引用循环，但这次 `MyClass1_Unowned` 实例并没有对 `MyClass2_Unowned` 实例保持强引用，允许 ARC 在不再需要时释放这两个实例。

如果我们运行此代码，我们将看到以下输出，显示 `class1` 和 `class2` 实例都已释放，并且内存已释放：

[PRE8]

如我们所见，两个实例都得到了适当的释放。现在让我们看看如何使用弱引用来防止强引用循环。

## 弱引用

我们再次从创建两个新类开始：

[PRE9]

`MyClass1_Weak` 和 `MyClass2_Weak` 类与我们在先前的示例中创建的、展示了强引用循环如何工作的类非常相似。区别在于我们在 `MyClass2_Weak` 类中定义了 `class1` 属性为一个弱引用。

现在，让我们看看如何使用以下代码初始化和销毁这些类的实例：

[PRE10]

在前面的代码中，我们创建了 `MyClass1_Weak` 和 `MyClass2_Weak` 类的实例，并将这些类的属性设置为指向另一个类的实例。再次，这创建了一个依赖关系的循环，但由于我们将 `MyClass2_Weak` 类的 `class1` 属性设置为弱引用，它不会创建强引用，允许释放这两个实例。

如果我们运行代码，我们将看到以下输出，显示 `class1_Weak` 和 `class2_Weak` 实例都已释放，并且内存已释放：

[PRE11]

另外值得一提的是，闭包的保留循环与强引用循环完全相同；闭包默认情况下实际上是一个强引用。我们会使用弱引用和非拥有引用来防止这种情况，正如本章所解释的那样，只需将持有类实例的变量更改为持有闭包实例即可。

建议您避免创建循环依赖，正如本节所示，但有时您可能需要它们。在这些情况下，请记住，ARC需要一些帮助来释放它们。

# 摘要

在本章中，我们解释了自动引用计数（ARC）的工作原理，以便您了解应用程序中内存是如何管理的。我们展示了强引用循环是什么，并解释了它如何导致 ARC 失败。我们通过展示如何使用弱引用和非拥有引用来防止强引用循环来结束本章。

在下一章中，我们将探讨如何正确格式化我们的 Swift 代码以保持一致性和可读性。
