<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;A First Look at OpenGL ES"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. A First Look at OpenGL ES</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Setting up the OpenGL ES environment</li><li class="listitem" style="list-style-type: disc">Drawing shapes on GLSurfaceView</li><li class="listitem" style="list-style-type: disc">Applying projection and camera view while drawing</li><li class="listitem" style="list-style-type: disc">Moving the triangle with rotation</li><li class="listitem" style="list-style-type: disc">Rotating the triangle with user input</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec78"/>Introduction</h1></div></div></div><p>As we saw in the previous chapter, Android offers many tools for handling graphics and animations. Though the canvas and drawable objects are designed for custom drawing, when you need high performance graphics, especially 3D gaming graphics, Android also supports OpenGL ES. <span class="strong"><strong>Open Graphics Library for Embedded Systems</strong></span> (<span class="strong"><strong>OpenGL ES</strong></span>), is targeted for embedded system. (Embedded systems <a id="id626" class="indexterm"/>include consoles and phones.)</p><p>This chapter is meant to serve as an introduction to using OpenGL ES on Android. As usual, we'll provide the steps and explain how things work, but we aren't going to be digging into the math or technical details of OpenGL. If you are already familiar with OpenGL ES from other platforms, such as iOS, this chapter should get you up and running quickly. If you are new to OpenGL, hopefully, these recipes will help you decide whether this is an area you want to pursue.</p><p>Android supports the following versions<a id="id627" class="indexterm"/> of OpenGL:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL ES 1.0</strong></span>: Android 1.0</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL ES 2.0</strong></span>: Introduced in Android 2.2 (API 8)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL ES 3.0</strong></span>: Introduced in Android 4.3 (API 18)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL ES 3.1</strong></span>: Introduced <a id="id628" class="indexterm"/>in Android 5.0 (API 21)</li></ul></div><p>The recipes for this chapter are of an introductory nature and target OpenGL ES 2.0 and higher. OpenGL ES 2.0 is available for nearly all devices currently available. Unlike OpenGL ES 2.0 and lower, OpenGL 3.0 and higher require driver implementation from the hardware manufacturer. This means, even if your application is running on Android 5.0, OpenGL 3.0 and higher may not be available. Therefore, it's a good programming practice to check the available OpenGL versions at runtime. Alternatively, if your application requires 3.0 and higher features, you can add a <code class="literal">&lt;uses-feature/&gt;</code> element to your Android manifest. (We'll discuss this in the first recipe that follows.)</p><p>Unlike the other chapters in this book, this chapter is written more as a tutorial with each recipe building on lessons learned from the previous recipe. The <span class="emphasis"><em>Getting ready</em></span> section of each recipe will clarify the prerequisites.</p></div></div>
<div class="section" title="Set up the OpenGL ES environment"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec79"/>Set up the OpenGL ES environment</h1></div></div></div><p>Our<a id="id629" class="indexterm"/> first recipe will start by showing the steps to set up an activity to use an OpenGL <code class="literal">GLSurfaceView</code>. Similar to the Canvas, the <code class="literal">GLSurfaceView</code> is where your will perform your OpenGL drawing. As this is the starting point, the other recipes will refer to this recipe as the base step when they need a <code class="literal">GLSurfaceView</code> created.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec282"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">SetupOpenGL</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet</strong></span> options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for <span class="strong"><strong>Activity Type</strong></span>.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec283"/>How to do it...</h2></div></div></div><p>We'll start by indicating the application's use of OpenGL in the Android Manifest, and then we'll add the OpenGL classes to the activity. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the Android Manifest and add the following XML:<div class="informalexample"><pre class="programlisting">&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following global variables:<div class="informalexample"><pre class="programlisting">private GLSurfaceView mGLSurfaceView;</pre></div></li><li class="listitem">Add the following inner class to the <code class="literal">MainActivity</code> class:<div class="informalexample"><pre class="programlisting">class CustomGLSurfaceView extends GLSurfaceView {

    private final GLRenderer mGLRenderer;

    public CustomGLSurfaceView(Context context){
        super(context);
		setEGLContextClientVersion(2);
        mGLRenderer = new GLRenderer();
        setRenderer(mGLRenderer);
    }
}</pre></div></li><li class="listitem">Add <a id="id630" class="indexterm"/>another inner class to the <code class="literal">MainActivity</code> class:<div class="informalexample"><pre class="programlisting">class GLRenderer implements GLSurfaceView.Renderer {
    public void onSurfaceCreated(GL10 unused, EGLConfig config) {
        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
    }
    public void onDrawFrame(GL10 unused) {
	GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }
    public void onSurfaceChanged(GL10 unused, int width, int height) {
        GLES20.glViewport(0, 0, width, height);}
}</pre></div></li><li class="listitem">Add the following code to the existing <code class="literal">onCreate()</code> method:<div class="informalexample"><pre class="programlisting">mGLSurfaceView = new CustomGLSurfaceView(this);
setContentView(mGLSurfaceView);</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec284"/>How it works...</h2></div></div></div><p>If you ran the preceding application, you saw the activity created and the background set to gray. Since these are the basic steps to setting up OpenGL, you'll be reusing this code for the other recipes in this chapter as well. Here is the process explained in detail:</p><div class="section" title="Declaring OpenGL in the Android Manifest"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec34"/>Declaring OpenGL in the Android Manifest</h3></div></div></div><p>We <a id="id631" class="indexterm"/>start by declaring our requirement to use <a id="id632" class="indexterm"/>OpenGL ES version 2.0 in the Android Manifest with this line:</p><div class="informalexample"><pre class="programlisting">&lt;uses-feature android:glEsVersion="0x00020000" android:required="true" /&gt;</pre></div><p>If we were using Version 3.0, we would use this:</p><div class="informalexample"><pre class="programlisting">&lt;uses-feature android:glEsVersion="0x00030000" android:required="true" /&gt;</pre></div><p>For <a id="id633" class="indexterm"/>Version 3.1, use<a id="id634" class="indexterm"/> this:</p><div class="informalexample"><pre class="programlisting">&lt;uses-feature android:glEsVersion="0x00030001" android:required="true" /&gt;</pre></div></div><div class="section" title="Extending the GLSurfaceView class"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec35"/>Extending the GLSurfaceView class</h3></div></div></div><p>Create a<a id="id635" class="indexterm"/> custom OpenGL <code class="literal">SurfaceView</code> class by extending <code class="literal">GLSurfaceView</code>, as we do in this code:</p><div class="informalexample"><pre class="programlisting">class CustomGLSurfaceView extends GLSurfaceView {

    private final GLRenderer mGLRenderer;

    public CustomGLSurfaceView(Context context){
        super(context);
        setEGLContextClientVersion(2);
        mGLRenderer = new GLRenderer();
        setRenderer(mGLRenderer);
    }
}</pre></div><p>Here, we instantiate an OpenGL rendered class and pass it to the <code class="literal">GLSurfaceView</code> class with the <code class="literal">setRenderer()</code> method. The OpenGL <code class="literal">SurfaceView</code> provides a surface for our OpenGL drawing, similar to the <code class="literal">Canvas</code> and <code class="literal">SurfaceView</code> objects. The actual drawing is done in the <code class="literal">Renderer</code>, which we'll create next:</p></div><div class="section" title="Creating an OpenGL rendered class"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec36"/>Creating an OpenGL rendered class</h3></div></div></div><p>The last step<a id="id636" class="indexterm"/> is to create the <code class="literal">GLSurfaceView.Renderer</code> class and implement the following three callbacks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">onSurfaceCreated()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onDrawFrame()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">onSurfaceChanged()</code></li></ul></div><p>Here is the code:</p><div class="informalexample"><pre class="programlisting">class GLRenderer implements GLSurfaceView.Renderer {
    public void onSurfaceCreated(GL10 unused, EGLConfig config) {
        GLES20.glClearColor(0.5f, 0.5f, 0.5f, 1.0f);
    }
    public void onDrawFrame(GL10 unused) {
        GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    }
    public void onSurfaceChanged(GL10 unused, int width, int height) {
        GLES20.glViewport(0, 0, width, height);
    }
}</pre></div><p>Right now, all we're<a id="id637" class="indexterm"/> doing with this class is setting up the callbacks and clearing the screen using the color we specify with <code class="literal">glClearColor()</code> (gray in this case).</p></div></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec285"/>There's more...</h2></div></div></div><p>With the OpenGL environment set up, we'll continue to the next recipe where we'll actually draw on the view.</p></div></div>
<div class="section" title="Drawing shapes on GLSurfaceView"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec80"/>Drawing shapes on GLSurfaceView</h1></div></div></div><p>The previous<a id="id638" class="indexterm"/> recipe set up the activity to use OpenGL. This <a id="id639" class="indexterm"/>recipe will continue by showing how to draw on <code class="literal">OpenGLSurfaceView</code>.</p><p>First, we need to define the shape. With OpenGL, it is important to realize the order in which the vertices of a shape are defined are very important, as they determine the front (face) and back of the shape. It's customary (and the default behavior) to define the vertices counter clockwise. (Though this behavior can be changed, it requires additional code and is not standard practice.)</p><p>It's also important to understand the OpenGL screen coordinate system, as it differs from the Android canvas. The default coordinate system defines (<code class="literal">0,0,0</code>) as the center of the screen. The four edge points are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Top left</strong></span>: (-1.0, 1.0, 0)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Top right</strong></span>: (1.0, 1.0, 0)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bottom left</strong></span>: (-1.0, -1.0, 0)</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Bottom right</strong></span>: (1.0, -1.0, 0)</li></ul></div><p>The <span class="emphasis"><em>Z</em></span> axis comes straight out of the screen or straight behind.</p><p>Here is an illustration showing the <span class="emphasis"><em>X</em></span>, <span class="emphasis"><em>Y</em></span>, and <span class="emphasis"><em>Z</em></span> axes:</p><div class="mediaobject"><img src="graphics/B05057_10_01.jpg" alt="Drawing shapes on GLSurfaceView"/></div><p>We're going to<a id="id640" class="indexterm"/> create a <code class="literal">Triangle</code> class since it is the base <a id="id641" class="indexterm"/>shape. In OpenGL, you generally use a collection of triangles to create objects. To draw a shape with OpenGL, we need to define the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Vertex shader</strong></span>: This is to<a id="id642" class="indexterm"/> draw the shape</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fragment shader</strong></span>: This is to <a id="id643" class="indexterm"/>color the shape</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Program</strong></span>: This is an OpenGL ES object for the preceding shaders</li></ul></div><p>The shaders are defined using<a id="id644" class="indexterm"/> <span class="strong"><strong>OpenGL Shading Language</strong></span> (<span class="strong"><strong>GLSL</strong></span>), and then compiled and added to the OpenGL program object.</p><p>Here are two screenshots showing the triangle in both portrait and landscape orientation:</p><div class="mediaobject"><img src="graphics/B05057_10_02.jpg" alt="Drawing shapes on GLSurfaceView"/></div><div class="mediaobject"><img src="graphics/B05057_10_03.jpg" alt="Drawing shapes on GLSurfaceView"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec286"/>Getting ready</h2></div></div></div><p>Create a new<a id="id645" class="indexterm"/> project in Android Studio and call it: <code class="literal">ShapesWithOpenGL</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet </strong></span>options and select <span class="strong"><strong>Empty Activity</strong></span> when<a id="id646" class="indexterm"/> prompted for <span class="strong"><strong>Activity Type</strong></span>.</p><p>This recipe uses the OpenGL environment created in the previous recipe <span class="emphasis"><em>Set up the Open GL environment</em></span>. Refer to the previous recipe if you have not already completed those steps.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec287"/>How to do it...</h2></div></div></div><p>As indicated previously, we'll be using the OpenGL environment created in the previous recipe. The steps that follow will walk you through creating a class for the triangle shape and drawing it on the GLSurfaceView:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Create a new Java class called <code class="literal">Triangle</code>.</li><li class="listitem">Add the following global declarations to the <code class="literal">Triangle</code> class:<div class="informalexample"><pre class="programlisting">private final String vertexShaderCode ="attribute vec4 vPosition;" +"void main() {" +"  gl_Position = vPosition;" +"}";

private final String fragmentShaderCode ="precision mediump float;" +"uniform vec4 vColor;" +"void main() {" +"  gl_FragColor = vColor;" +"}";

final int COORDS_PER_VERTEX = 3;
float triangleCoords[] = {
        0.0f,  0.66f, 0.0f,
        -0.5f, -0.33f, 0.0f,
        0.5f, -0.33f, 0.0f
};

float color[] = { 0.63f, 0.76f, 0.22f, 1.0f };

private final int mProgram;
private FloatBuffer vertexBuffer;
private int mPositionHandle;
private int mColorHandle;
private final int vertexCount = triangleCoords.length / COORDS_PER_VERTEX;
private final int vertexStride = COORDS_PER_VERTEX * 4;</pre></div></li><li class="listitem">Add the following <code class="literal">loadShader()</code> method to the <code class="literal">Triangle</code> class:<div class="informalexample"><pre class="programlisting">public int loadShader(int type, String shaderCode){
    int shader = GLES20.glCreateShader(type);
    GLES20.glShaderSource(shader, shaderCode);
    GLES20.glCompileShader(shader);
    return shader;
}</pre></div></li><li class="listitem">Add<a id="id647" class="indexterm"/> the <code class="literal">Triangle</code> constructor, as <a id="id648" class="indexterm"/>shown:<div class="informalexample"><pre class="programlisting">public Triangle() {
    int vertexShader = loadShader(GLES20.GL_VERTEX_SHADER,vertexShaderCode);
    int fragmentShader = loadShader(GLES20.GL_FRAGMENT_SHADER,fragmentShaderCode);
    mProgram = GLES20.glCreateProgram();
    GLES20.glAttachShader(mProgram, vertexShader);
    GLES20.glAttachShader(mProgram, fragmentShader);
    GLES20.glLinkProgram(mProgram);

    ByteBuffer bb = ByteBuffer.allocateDirect(triangleCoords.length * 4);
    bb.order(ByteOrder.nativeOrder());

    vertexBuffer = bb.asFloatBuffer();
    vertexBuffer.put(triangleCoords);
    vertexBuffer.position(0);
}</pre></div></li><li class="listitem">Add the <code class="literal">draw()</code> method, as follows:<div class="informalexample"><pre class="programlisting">public void draw() {
    GLES20.glUseProgram(mProgram);
    mPositionHandle = GLES20.glGetAttribLocation(mProgram, "vPosition");
    GLES20.glEnableVertexAttribArray(mPositionHandle);
    GLES20.glVertexAttribPointer(mPositionHandle, COORDS_PER_VERTEX,GLES20.GL_FLOAT, false,vertexStride, vertexBuffer);
    mColorHandle = GLES20.glGetUniformLocation(mProgram, "vColor");
    GLES20.glUniform4fv(mColorHandle, 1, color, 0);
    GLES20.glDrawArrays(GLES20.GL_TRIANGLES, 0, vertexCount);
    GLES20.glDisableVertexAttribArray(mPositionHandle);
}</pre></div></li><li class="listitem">Now open <code class="literal">MainActivity.java</code> and add a <code class="literal">Triangle</code> variable to the <code class="literal">GLRenderer</code> class as follows:<div class="informalexample"><pre class="programlisting">private Triangle mTriangle;</pre></div></li><li class="listitem">Initialize the <code class="literal">Triangle</code> variable in the <code class="literal">onSurfaceCreated()</code> callback, as follows:<div class="informalexample"><pre class="programlisting">mTriangle = new Triangle();</pre></div></li><li class="listitem">Call the <code class="literal">draw()</code> method in the <code class="literal">onDrawFrame()</code> callback:<div class="informalexample"><pre class="programlisting">mTriangle.draw();</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec288"/>How it works...</h2></div></div></div><p>As mentioned in the<a id="id649" class="indexterm"/> introduction, to draw with OpenGL, we first<a id="id650" class="indexterm"/> have to define the shaders, which we do with the following code:</p><div class="informalexample"><pre class="programlisting">private final String vertexShaderCode ="attribute vec4 vPosition;" +"void main() {" +"  gl_Position = vPosition;" +"}";

private final String fragmentShaderCode ="precision mediump float;" +"uniform vec4 vColor;" +"void main() {" +"  gl_FragColor = vColor;" +"}";</pre></div><p>Since this is uncompiled<a id="id651" class="indexterm"/> <span class="strong"><strong>OpenGL Shading Language</strong></span> (<span class="strong"><strong>OpenGLSL</strong></span>), the next step is to compile and attach it to our OpenGL object, which we do with the following two OpenGL ES methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">glAttachShader()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">glLinkProgram()</code></li></ul></div><p>After setting up the shaders, we create <code class="literal">ByteBuffer</code> to store the triangle vertices, which are defined in <code class="literal">triangleCoords</code>. The <code class="literal">draw()</code> method is where the actual drawing occurs using the GLES20 library calls, which is called from the <code class="literal">onDrawFrame()</code> callback.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec289"/>There's more...</h2></div></div></div><p>You may have noticed, from the screenshots in the introduction, that the triangles in the Portrait and Landscape do look identical. As you can see from the code, we make no distinction in the orientation when drawing. We'll explain why this is happening and show how to correct this issue in the next recipe.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec290"/>See also</h2></div></div></div><p>For more information on the<a id="id652" class="indexterm"/> OpenGL Shading Language, refer the following link:</p><p>
<a class="ulink" href="https://www.opengl.org/documentation/glsl/">https://www.opengl.org/documentation/glsl/</a>
</p></div></div>
<div class="section" title="Applying Projection and Camera View while drawing"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec81"/>Applying Projection and Camera View while drawing</h1></div></div></div><p>As we saw in the <a id="id653" class="indexterm"/>previous recipe, when we draw our shape to the <a id="id654" class="indexterm"/>screen, the shape is skewed by the screen orientation. The reason for this is because, by default, OpenGL assumes a perfectly square screen. We mentioned before, the default screen coordinates for the top right is (1,1,0) and bottom left is (-1,-1,0).</p><p>Since most device screens are not perfectly square, we need to map the display coordinates to match our physical device. In OpenGL, we do this with <span class="emphasis"><em>Projection</em></span>. This recipe will show how to use Projection to match the GLSurfaceView coordinates with the device coordinates. Along with the Projection, we'll also show how to set the Camera View. Here's a screenshot showing the final result:</p><div class="mediaobject"><img src="graphics/B05057_10_04.jpg" alt="Applying Projection and Camera View while drawing"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec291"/>Getting ready</h2></div></div></div><p>Create a new project in <a id="id655" class="indexterm"/>Android Studio and call it: <code class="literal">ProjectionAndCamera</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet</strong></span> options and select <span class="strong"><strong>Empty Activity</strong></span> when <a id="id656" class="indexterm"/>prompted for <span class="strong"><strong>Activity Type</strong></span>.</p><p>This recipe builds on the previous recipe <span class="emphasis"><em>Drawing shapes on the GLSurfaceView</em></span>. If you have not already typed in the previous recipe, do so before starting these steps.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec292"/>How to do it...</h2></div></div></div><p>As stated previously, this recipe will build on the previous recipe, so complete those steps before starting. We will be modifying the previous code to add projection and camera view to the drawing calculations. Here are the steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">Triangle</code> class and add the following global declaration to the existing declarations:<div class="informalexample"><pre class="programlisting">private int mMVPMatrixHandle;</pre></div></li><li class="listitem">Add a matrix variable to <code class="literal">vertexShaderCode</code> and use it in the position calculation. Here is the final result:<div class="informalexample"><pre class="programlisting">private final String vertexShaderCode =
    "attribute vec4 vPosition;" +
    "uniform mat4 uMVPMatrix;" +
    "void main() {" +
    "  gl_Position = uMVPMatrix * vPosition;" +
    "}";</pre></div></li><li class="listitem">Change the <code class="literal">draw()</code> method to pass in a matrix parameter as follows:<div class="informalexample"><pre class="programlisting">public void draw(float[] mvpMatrix) {</pre></div></li><li class="listitem">To use the transformation matrix, add the following code to the <code class="literal">draw()</code> method just before the <code class="literal">GLES20.glDrawArrays()</code> method:<div class="informalexample"><pre class="programlisting">mMVPMatrixHandle = GLES20.glGetUniformLocation(mProgram, "uMVPMatrix");
GLES20.glUniformMatrix4fv(mMVPMatrixHandle, 1, false, mvpMatrix, 0);</pre></div></li><li class="listitem">Open <code class="literal">MainActivity.java</code> and add the following class variables to the <code class="literal">GLRenderer</code> class:<div class="informalexample"><pre class="programlisting">private final float[] mMVPMatrix = new float[16];
private final float[] mProjectionMatrix = new float[16];
private final float[] mViewMatrix = new float[16];</pre></div></li><li class="listitem">Modify the <code class="literal">onSurfaceChanged()</code> callback to calculate the position matrix as follows:<div class="informalexample"><pre class="programlisting">public void onSurfaceChanged(GL10 unused, int width, int height) {
    GLES20.glViewport(0, 0, width, height);
    float ratio = (float) width / height;
    Matrix.frustumM(mProjectionMatrix, 0, -ratio, ratio, -1, 1, 3, 7);
}</pre></div></li><li class="listitem">Modify the <code class="literal">onDrawFrame()</code> callback to calculate the Camera View as follows:<div class="informalexample"><pre class="programlisting">public void onDrawFrame(GL10 unused) {
    Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
    Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);
    GLES20.glClear(GLES20.GL_COLOR_BUFFER_BIT);
    mTriangle.draw(mMVPMatrix);
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec293"/>How it works...</h2></div></div></div><p>First, we modify<a id="id657" class="indexterm"/> the <code class="literal">vertexShaderCode</code> to include a matrix<a id="id658" class="indexterm"/> variable. We calculate the matrix in the <code class="literal">onSurfaceChanged()</code> callback using the height and width, which are passed in as parameters. We pass the transformation matrix to the <code class="literal">draw()</code> method to use it when calculating the position to draw.</p><p>Before we call the <code class="literal">draw()</code> method, we calculate the camera view. These two lines of code calculate the camera view:</p><div class="informalexample"><pre class="programlisting">Matrix.setLookAtM(mViewMatrix, 0, 0, 0, -3, 0f, 0f, 0f, 0f, 1.0f, 0.0f);
Matrix.multiplyMM(mMVPMatrix, 0, mProjectionMatrix, 0, mViewMatrix, 0);</pre></div><p>Without this code, there would actually be no triangle drawn as the camera perspective would not "see" our vertices. (This goes back to our discussion on how the order of the vertices dictate the front and back of the image.)</p><p>When you run the program now, you'll see the output shown in the <span class="emphasis"><em>Introduction</em></span>. Notice we have a uniform triangle now, even when the display is rotated.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec294"/>There's more...</h2></div></div></div><p>In the next recipe, we will start showing the power of OpenGL by rotating the triangle.</p></div></div>
<div class="section" title="Moving the triangle with rotation"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec82"/>Moving the triangle with rotation</h1></div></div></div><p>What we've <a id="id659" class="indexterm"/>demonstrated so far with OpenGL would probably<a id="id660" class="indexterm"/> be easier using the traditional canvas or drawable objects. This recipe will show a bit of the power of OpenGL by rotating the triangle. Not that we can't create movement with the other drawing methods, but how easily we can do this with OpenGL!</p><p>This recipe will demonstrate how to rotate the triangle, as this screenshot shows:</p><div class="mediaobject"><img src="graphics/B05057_10_05.jpg" alt="Moving the triangle with rotation"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec295"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">CreatingMovement</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet</strong></span> options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for <span class="strong"><strong>Activity Type</strong></span>.</p><p>This recipe builds on the previous recipe <span class="emphasis"><em>Applying Projection and Camera View While Drawing</em></span>. If you have not already typed in the previous recipe, do so before continuing.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec296"/>How to do it...</h2></div></div></div><p>Since we are continuing from the previous recipe, we have very little work to do. Open <code class="literal">MainActivity.java</code> and follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add a Matrix to the <code class="literal">GLRendered</code> class:<div class="informalexample"><pre class="programlisting">private float[] mRotationMatrix = new float[16];</pre></div></li><li class="listitem">In the <code class="literal">onDrawFrame()</code> callback, replace the existing <code class="literal">mTriangle.draw(mMVPMatrix);</code> statement with the following code:<div class="informalexample"><pre class="programlisting">float[] tempMatrix = new float[16];
long time = SystemClock.uptimeMillis() % 4000L;
float angle = 0.090f * ((int) time);
Matrix.setRotateM(mRotationMatrix, 0, angle, 0, 0, -1.0f);
Matrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0);
mTriangle.draw(tempMatrix);</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec297"/>How it works...</h2></div></div></div><p>We're using<a id="id661" class="indexterm"/> the <code class="literal">Matrix.setRotateM()</code> method to calculate a<a id="id662" class="indexterm"/> new rotation matrix based on the angle we pass in. For this example, we're using the system uptime to calculate an angle. We can use whatever method we want to derive an angle, such as a sensor reading or touch events.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec298"/>There's more...</h2></div></div></div><p>Using the system clock provides the added benefit of creating continuous movement, which certainly looks better for demonstration purposes. The next recipe will demonstrate how to use user input to derivate an angle for rotating the triangle.</p><div class="section" title="The render mode"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec37"/>The render mode</h3></div></div></div><p>OpenGL offers a <code class="literal">setRenderMode()</code> option to <a id="id663" class="indexterm"/>draw only when the view is dirty. This can be enabled by adding the following code to the <code class="literal">CustomGLSurfaceView()</code> constructor just below the <code class="literal">setRenderer()</code> call:</p><div class="informalexample"><pre class="programlisting">setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);</pre></div><p>This will cause the display to update once, then wait until we request an update with <code class="literal">requestRender()</code>.</p></div></div></div>
<div class="section" title="Rotating the triangle with user input"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec83"/>Rotating the triangle with user input</h1></div></div></div><p>The previous example <a id="id664" class="indexterm"/>demonstrated rotating the triangle based on the <a id="id665" class="indexterm"/>system clock. This created a continuously rotating triangle, depending on the render mode we used. But what if you wanted to respond to the input from the user?</p><p>In this recipe, we'll show how to respond to user input by overriding the <code class="literal">onTouchEvent()</code> callback from <code class="literal">GLSurfaceView</code>. We'll still rotate the triangle using the <code class="literal">Matrix.setRotateM()</code> method, but instead of deriving an angle from the system time, we'll calculate an angle based on the touch location.</p><p>Here's a screenshot <a id="id666" class="indexterm"/>showing this recipe running on a physical <a id="id667" class="indexterm"/>device (to highlight the touch, the <span class="strong"><strong>Show touches</strong></span> developer option is enabled):</p><div class="mediaobject"><img src="graphics/B05057_10_06.jpg" alt="Rotating the triangle with user input"/></div><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec299"/>Getting ready</h2></div></div></div><p>Create a new project in Android Studio and call it: <code class="literal">RotateWithUserInput</code>. Use the default <span class="strong"><strong>Phone &amp; Tablet</strong></span> options and select <span class="strong"><strong>Empty Activity</strong></span> when prompted for <span class="strong"><strong>Activity Type</strong></span>.</p><p>This recipe demonstrates an alternative approach to the previous recipe and therefore will be based on <span class="emphasis"><em>Applying projection and camera view while drawing </em></span>(the same starting point as the previous recipe.)</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec300"/>How to do it...</h2></div></div></div><p>As stated previously, we <a id="id668" class="indexterm"/>will continue, not from the previous recipe, but <a id="id669" class="indexterm"/>from the <span class="emphasis"><em>Applying projection and camera view while drawing</em></span> recipe. Open <code class="literal">MainActivity.java</code> and follow these steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Add the following global variables to the <code class="literal">MainActivity</code> class:<div class="informalexample"><pre class="programlisting">private float mCenterX=0;
private float mCenterY=0;</pre></div></li><li class="listitem">Add the following code the <code class="literal">GLRendered</code> class:<div class="informalexample"><pre class="programlisting">private float[] mRotationMatrix = new float[16];
public volatile float mAngle;
public void setAngle(float angle) {
    mAngle = angle;
}
</pre></div></li><li class="listitem">In the same class, modify the <code class="literal">onDrawFrame()</code> method by replacing the existing <code class="literal">mTriangle.draw(mMVPMatrix);</code> statement with the following code:<div class="informalexample"><pre class="programlisting">float[] tempMatrix = new float[16];
Matrix.setRotateM(mRotationMatrix, 0, mAngle, 0, 0, -1.0f);
Matrix.multiplyMM(tempMatrix, 0, mMVPMatrix, 0, mRotationMatrix, 0);
mTriangle.draw(tempMatrix);</pre></div></li><li class="listitem">Add the following code to the <code class="literal">onSurfaceChanged()</code> callback:<div class="informalexample"><pre class="programlisting">mCenterX=width/2;
mCenterY=height/2;</pre></div></li><li class="listitem">Add the following code to the <code class="literal">CustomGLSurfaceView</code> constructor, which is below <code class="literal">setRenderer()</code>:<div class="informalexample"><pre class="programlisting">setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);</pre></div></li><li class="listitem">Add the following <code class="literal">onTouchEvent()</code> to the <code class="literal">CustomGLSurfaceView</code> class:<div class="informalexample"><pre class="programlisting">@Override
public boolean onTouchEvent(MotionEvent e) {
  float x = e.getX();
  float y = e.getY();
  switch (e.getAction()) {
      case MotionEvent.ACTION_MOVE:
          double angleRadians = Math.atan2(y-mCenterY,x-mCenterX);
          mGLRenderer.setAngle((float)Math.toDegrees(-angleRadians));
          requestRender();
  }
  return true;
}</pre></div></li><li class="listitem">You're ready to run the application on a device or emulator.</li></ol></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec301"/>How it works...</h2></div></div></div><p>The obvious difference<a id="id670" class="indexterm"/> between this example and the previous recipe <a id="id671" class="indexterm"/>is how we derive the angle to pass to the <code class="literal">Matrix.setRotateM()</code> call. We also changed the <code class="literal">GLSurfaceView</code> render mode using <code class="literal">setRenderMode()</code> to only draw on request. We made the request using <code class="literal">requestRender()</code> after calculating a new angle in the <code class="literal">onTouchEvent()</code> callback.</p><p>We also demonstrated the importance of deriving our own <code class="literal">GLSurfaceView</code> class. Without our <code class="literal">CustomGLSurfaceView</code> class, we would not have a way to override the <code class="literal">onTouchEvent</code> callback, or any other callbacks from <code class="literal">GLSurfaceView</code>.</p></div><div class="section" title="There's more..."><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec302"/>There's more...</h2></div></div></div><p>This concludes the OpenGL ES recipes but we've only just touched upon the power of OpenGL. If you're serious about learning OpenGL, see the links in the next section and check out one of the many books written on OpenGL.</p><p>It's also worth checking out one of the many frameworks available, such as the Unreal Engine:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip29"/>Tip</h3><p>Unreal Engine 4<a id="id672" class="indexterm"/> is a complete suite of game development tools made by game<a id="id673" class="indexterm"/> developers, for game developers.</p><p>
<a class="ulink" href="https://www.unrealengine.com/what-is-unreal-engine-4">https://www.unrealengine.com/what-is-unreal-engine-4</a>
</p></div></div></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec303"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL</strong></span>: The Industry <a id="id674" class="indexterm"/>Standard for High Performance Graphics<p>
<a class="ulink" href="https://www.opengl.org/">https://www.opengl.org/</a>
</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>OpenGL ES</strong></span>: The <a id="id675" class="indexterm"/>Standard for Embedded Accelerated 3D Graphics<p>
<a class="ulink" href="https://www.khronos.org/opengles/">https://www.khronos.org/opengles/</a>
</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Unreal Engine</strong></span>: Android<a id="id676" class="indexterm"/> Quick Start<p>
<a class="ulink" href="https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html">https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html</a>
</p></li></ul></div></div></div></body></html>