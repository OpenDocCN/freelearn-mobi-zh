<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-76"><a id="_idTextAnchor334"/>5</h1>
<h1 id="_idParaDest-77"><a id="_idTextAnchor335"/>iPad Project – Photo Gallery Enhanced View</h1>
<p>In this chapter, we will work on implementing enhanced view and page navigation functionalities in our photo gallery project. In the previous chapter, we looked at the design of the photo gallery and how it works uniquely due to it being developed for a large device. Then, we broke it down into two views and a fullscreen mode. Afterward, we implemented the first view, which was the highlight view. To do this, we figured out the components required. We then implemented all the components using SwiftUI. At the end of the previous chapter, we only had a fancy wireframe for the highlight view and no connection to another view. Now, we will create the enhanced view and implement all the functionality to provide navigation between the views and send image metadata between the highlight and enhanced views.</p>
<p>This chapter will be split into the following sections:</p>
<ul>
<li><code>EnhancedView</code> Design Overview</li>
<li>Updating <code>HighlightView</code></li>
<li>Testing <code>EnhancedView</code></li>
<li>Extra tasks</li>
</ul>
<p>By the end of this chapter, you will have created a fully functional photo gallery that leverages the iPad’s immense screen real estate, which is yours to be modified, tweaked, and used as you see fit. I will give you exercises when we reach the end of the chapter to implement more advanced functionality into the photo gallery. This will transition nicely into our next project, the Mac App Store.</p>
<h1 id="_idParaDest-78"><a id="_idTextAnchor336"/>Technical Requirements</h1>
<p>This chapter requires you to download Xcode version 14 or above from Apple’s App Store.</p>
<p>To install Xcode just search for Xcode in the App Store, then select and download the latest version. Open Xcode and follow any additional installation instructions. Once Xcode has opened and launched, you’re ready to go.</p>
<p>Version 14 of Xcode has the following features/requirements:</p>
<ul>
<li>Includes SDKs for iOS 16, iPadOS 16, macOS 12.3, tvOS 16, and watchOS 9.</li>
<li>Supports on-device debugging in iOS 11 or later, tvOS 11 or later, and watchOS 4 or later.</li>
<li>Requires a Mac running macOS Monterey 12.5 or later.</li>
</ul>
<p>For further information regarding technical details, please refer to <a href="B18783_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</p>
<p>The code files for this chapter can be found here:</p>
<p><a href="https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects/tree/main/Code/Chapter%205%20-%20iPad%20Project%20-%20Photo%20Gallery%20Enhanced%20View">https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects/tree/main/Code/Chapter%205%20-%20iPad%20Project%20-%20Photo%20Gallery%20Enhanced%20View</a></p>
<p>In the next section, we will look at the <code>EnhancedView</code>. We will break it down into components that we can implement.</p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor337"/>EnhancedView design overview</h1>
<p>In this section, we will <a id="_idIndexMarker242"/>implement the <code>EnhancedView</code>. If you recall, in the previous chapter, we discussed the design of the <code>EnhancedView</code>. The following figures show the portrait and landscape modes of the <code>EnhancedView</code> as a reminder:</p>
<div><div><img alt="Figure 5.1 – EnhancedView wireframe preview in portrait mode" src="img/Figure_5.01_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – EnhancedView wireframe preview in portrait mode</p>
<div><div><img alt="Figure 5.2 – EnhancedView wireframe preview in landscape mode" src="img/Figure_5.02_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – EnhancedView wireframe preview in landscape mode</p>
<p>Before we code<a id="_idIndexMarker243"/> our application, we will break down the <code>EnhancedView</code> into the elements that comprise it. As a little task, see whether you can figure out what they are. Don’t worry if you don’t know the exact UI component names; we will look at the components in the following sections.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The components are the same for portrait and landscape orientation.</p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor338"/>The Text component</h2>
<p>The <code>Text</code> component<a id="_idIndexMarker244"/> is one of the simplest components offered by SwiftUI. It allows you to display a string of characters/numbers, which is very useful for headings and providing information. We will use it three times for the following features:</p>
<ul>
<li>Image title</li>
<li>Date</li>
<li>Image description</li>
</ul>
<p>The following figures show <code>Text</code> components:</p>
<div><div><img alt="Figure 5.3 – Image Title text component" src="img/Figure_5.03_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Image Title text component</p>
<div><div><img alt="Figure 5.4 – Image date text component" src="img/Figure_5.04_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Image date text component</p>
<div><div><img alt="Figure 5.5 – Image description text component" src="img/Figure_5.05_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Image description text component</p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor339"/>The Image component</h2>
<p>The <code>Image</code> component<a id="_idIndexMarker245"/> is one of the core components offered by SwiftUI. It allows you to display an image, which can be used to provide a visual representation or to a body of text. We will use it to show a bigger version of the image that was selected from the <code>HighlightView</code>. The following figure shows the image in <code>EnhancedView</code>:</p>
<div><div><img alt="Figure 5.6 – Image component" src="img/Figure_5.06_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – Image component</p>
<p>In the next section, we will create <code>EnhancedView</code> and implement it using the components we discussed using SwiftUI in our application.</p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor340"/>Adding EnhancedView Components</h2>
<p>In this section, we will <a id="_idIndexMarker246"/>add the previously discussed components to create our <code>EnhancedView</code>. However, we first need to create the <code>EnhancedView</code> file. Doing so is simple; follow these steps:</p>
<ol>
<li>We will now create a new SwiftUI View for the results page. Right-click the gallery folder inside of your <strong class="bold">Project Navigator</strong> pane and select <strong class="bold">New File...</strong>:</li>
</ol>
<div><div><img alt="Figure 5.7 – Select New File﻿..." src="img/Figure_5.07_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – Select New File...</p>
<ol>
<li value="2">Next, we will select the type of file we want to add, which is a <strong class="bold">SwiftUI View</strong> (selecting this provides a SwiftUI template, which saves us the time and effort of retyping the SwiftUI file structure every time) in the <strong class="bold">User </strong><strong class="bold">Interface</strong> section:</li>
</ol>
<div><div><img alt="Figure 5.8 – SwiftUI View selection" src="img/Figure_5.08_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – SwiftUI View selection</p>
<ol>
<li value="3">Finally, we must <a id="_idIndexMarker247"/>rename our <code>EnhancedView</code> and press <strong class="bold">Create</strong>:</li>
</ol>
<div><div><img alt="Figure 5.9 – Naming our view" src="img/Figure_5.09_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – Naming our view</p>
<p>So far, we have looked at the wireframes and the components that compose them. Finally, we created our <code>EnhancedView</code> file.</p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor341"/>Updating HighlightView</h1>
<p>The first thing I will do is<a id="_idIndexMarker248"/> update the code to align with my coding standards; feel free to do the same. Now, we will add five state variables. One will be used to track whether an image has been clicked, and the other four will be used to pass data from the <code>HighlightView</code> to the <code>EnhancedView</code>. Add the code after the adaptive columns like so:</p>
<pre class="source-code">
private let adaptiveColumns =[
    GridItem( .adaptive( minimum: 300 ) )
]
@State private var isClicked: Bool = false
@State private var imageFile: String = ""
@State private var imageName: String = ""
@State private var imageDate: String = ""
@State private var imageDescription: String = ""</pre>
<p>Now, update the body to match the following code:</p>
<pre class="source-code">
var body: some View{
    NavigationView
    {
        ScrollView
        {
            LazyVGrid( columns: adaptiveColumns, spacing: 20 )
            {
                ForEach( images.indices )
                { i in
                    NavigationLink( destination: EnhancedView( imageFile: $imageFile, imageName: $imageName, imageDate: $imageDate, imageDescription: $imageDescription ), isActive: $isClicked, label:
                        {
                        Image( images[i] )
                            .resizable( )
                            .scaledToFill( )
                            .frame( width: 300, height: 300 )
                            .onTapGesture {
                                imageFile = images[i]
                                imageName = "FireDEV Podcast"
                                imageDate = "22/09/2022"
                                imageDescription = "Aspiring entrepreneurs and industry professionals alike can learn a lot from a fireside chat with interesting people in the industry. From small indie developers to CEOs of major companies, these chats provide an opportunity to gain insight into the unique stories of success that have led these individuals to their current positions. Through conversations about their experiences and challenges, we can gain valuable knowledge about their successes, failures, and the strategies they used to reach their goals. We can also gain insight into their motivations and the values that drive their decisions. By engaging in a fireside chat with these industry leaders, we can gain a better understanding of the industry and the people within it, and gain valuable knowledge that can help us to reach our own goals."
                                isClicked = true
                            }
                    } )
                }
            }
        }
    }
    .navigationViewStyle( StackNavigationViewStyle( ) )
}</pre>
<p>We just added a lot of code, so let’s unpack it all:</p>
<ul>
<li><code>NavigationView {</code>: We<a id="_idIndexMarker249"/> implement a navigation system that will allow us to go to the <code>EnhancedView</code> and back. Using this code for the <code>NavigationView</code> alone will result in a split system, thus at the end we add the proceeding code to remove the split view mode.</li>
<li><code>.navigationViewStyle( StackNavigationViewStyle( ) )</code>: Coupled with the new <code>NavigationView</code>, we wrap each image around a <code>NavigationLink</code>, which allows it to be clickable so we can navigate to another view.</li>
<li><code>NavigationLink( destination: EnhancedView( imageFile: $imageFile, imageName: $imageName, imageDate: $imageDate, imageDescription: $imageDescription ), isActive: $isClicked, label</code>: Within the <code>NavigationLink</code>, we have several parameters. Let’s break down the purpose of each one:<ul><li><code>destination: EnhancedView(</code>: Sets the view to navigate to upon clicking the image.</li><li><code>imageFile: $imageFile</code>: Passes the <code>imageFile</code> state variable that was created previously to the <code>EnhancedView</code>. This variable is the path/filename of the image. This will be stored as a string.</li><li><code>imageName: $imageName</code>: Passes the <code>imageName</code> state variable to the <code>EnhancedView</code>. This variable is the name/title of the image.</li><li><code>imageDate: $imageDate</code>: Passes the <code>imageDate</code> state variable that was created <a id="_idIndexMarker250"/>previously to the <code>EnhancedView</code>. This variable is the date of the image. This could be the creation date, edit date, or some other relevant date.</li><li><code>imageDescription: $imageDescription</code>: Passes the <code>imageDescription</code> state variable to the <code>EnhancedView</code>. This variable is the description of the image.</li></ul></li>
<li><code>isActive: $isClicked</code>: Tracks whether the image has been clicked. If so, it will navigate to the <code>EnhancedView</code>.</li>
<li><code>label</code>: Although we are not using any form of text for the button, the image will be used as a label, which will act as the clickable label/image for navigation.</li>
</ul>
<p>The next step is to add clickable functionality to the image allowing the user to navigate from the <code>HighlightView</code> to the <code>EnhancedView</code>. Update the image code within the <code>NavigationLink</code> as follows:</p>
<pre class="source-code">
Image( images[i] )    .resizable( )
    .scaledToFill( )
    .frame( width: 300, height: 300 )
    .onTapGesture {
        imageFile = images[i]
        imageName = "FireDEV Podcast"
        imageDate = "22/09/2022"
        imageDescription = "Aspiring entrepreneurs and industry professionals alike can learn a lot from a fireside chat with interesting people in the industry. From small indie developers to CEOs of major companies, these chats provide an opportunity to gain insight into the unique stories of success that have led these individuals to their current positions. Through conversations about their experiences and challenges, we can gain valuable knowledge about their successes, failures, and the strategies they used to reach their goals. We can also gain insight into their motivations and the values that drive their decisions. By engaging in a fireside chat with these industry leaders, we can gain a better understanding of the industry and the people within it, and gain valuable knowledge that can help us to reach our own goals."
        isClicked = true
    }</pre>
<p>We have added an <code>onTapGesture</code> function. The purpose of this is to assign the metadata for the image to the <code>@State</code> variables created earlier. All the metadata variables are hardcoded, except <code>imageFile</code>, which uses an array. Feel free to extend the current array to become a multidimensional data container to store unique metadata for each image. Finally, we set <code>isClicked</code> to <code>true</code>; this tells the view to navigate to the <a id="_idIndexMarker251"/>designated view on the <code>NavigationLink</code>, which is the <code>EnhancedView</code>.</p>
<p>All these changes will result in the following code for the <code>HighlightView</code>:</p>
<pre class="source-code">
import SwiftUIstruct HighlightView: View
{
    private let images: [String] =
    [
        "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV", "FireDEV"
    ]
    private let adaptiveColumns =
    [
        GridItem( .adaptive( minimum: 300 ) )
    ]
    @State private var isClicked: Bool = false
    @State private var imageFile: String = ""
    @State private var imageName: String = ""
    @State private var imageDate: String = ""
    @State private var imageDescription: String = ""
    var body: some View
    {
        NavigationView
        {
            ScrollView
            {
                LazyVGrid( columns: adaptiveColumns, spacing: 20 )
                {
                    ForEach( images.indices )
                    { i in
                        NavigationLink( destination: EnhancedView( imageFile: $imageFile, imageName: $imageName, imageDate: $imageDate, imageDescription: $imageDescription ), isActive: $isClicked, label:
                            {
                            Image( images[i] )
                                .resizable( )
                                .scaledToFill( )
                                .frame( width: 300, height: 300 )
                                .onTapGesture {
                                    imageFile = images[i]
                                    imageName = "FireDEV Podcast"
                                    imageDate = "22/09/2022"
                                    imageDescription = "Aspiring entrepreneurs and industry professionals alike can learn a lot from a fireside chat with interesting people in the industry. From small indie developers to CEOs of major companies, these chats provide an opportunity to gain insight into the unique stories of success that have led these individuals to their current positions. Through conversations about their experiences and challenges, we can gain valuable knowledge about their successes, failures, and the strategies they used to reach their goals. We can also gain insight into their motivations and the values that drive their decisions. By engaging in a fireside chat with these industry leaders, we can gain a better understanding of the industry and the people within it, and gain valuable knowledge that can help us to reach our own goals."
                                    isClicked = true
                                }
                        } )
                    }
                }
            }
        }
        .navigationViewStyle( StackNavigationViewStyle( ) )
    }
}
struct ContentView_Previews: PreviewProvider
{
    static var previews: some View
    {
        HighlightView( )
    }
}</pre>
<p>That was a lot to unpack! Feel free to take another look at this section before moving on. Remember, you have access to the GitHub repository for online access for easy copy and paste: <a href="https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects">https://github.com/PacktPublishing/Elevate-SwiftUI-Skills-by-Building-Projects</a>.<a id="_idTextAnchor342"/></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor343"/>Implementing EnhancedView</h2>
<p>First, we need to implement code to<a id="_idIndexMarker252"/> handle the rotation functionality. Add the following code above the <code>EnhancedView</code> struct:</p>
<pre class="source-code">
struct DeviceRotationViewModifier: ViewModifier{
    let action: ( UIDeviceOrientation ) -&gt; Void
    func body( content: Content ) -&gt; some View
    {
        content
            .onAppear( )
            .onReceive( NotificationCenter.default.publisher( for: UIDevice.orientationDidChangeNotification ) )
                { _ in
                    action( UIDevice.current.orientation )
                }
    }
}
extension View
{
    func onRotate( perform action: @escaping ( UIDeviceOrientation ) -&gt; Void ) -&gt; some View
        {
            self.modifier( DeviceRotationViewModifier( action: action ) )
        }
}</pre>
<p>The<a id="_idIndexMarker253"/> preceding code we added allows us to render the content again when rotating the screen. This will be used shortly when detecting the device’s orientation. Now, we can add the <code>@Binding</code> variables at the start of our <code>EnhancedView</code> struct, which allows us to pass in metadata:</p>
<pre class="source-code">
@Binding var imageFile: String@Binding var imageName: String
@Binding var imageDate: String
@Binding var imageDescription: String</pre>
<p>Now, we will add two variables, the first detecting the device’s orientation and the second detecting the device screen size in pixels. The former will be used to determine the correct layout, and the latter will be used when sizing components. Add the following code:</p>
<pre class="source-code">
@State private var orientation = UIDeviceOrientation.unknownlet screenSize: CGRect = UIScreen.main.bounds</pre>
<p>In the body, we will create a group, which will contain two layouts, one for each orientation: portrait and landscape. Add the following code, and we will discuss everything that is happening:</p>
<pre class="source-code">
Group{
    if ( orientation.isLandscape )
    {
        LazyHStack
        {
            VStack
            {
                Image( imageFile )
                    .resizable( )
                    .scaledToFit( )
            }.frame( width: screenSize.width * 0.5 )
            VStack
            {
                Text( imageName )
                    .fontWeight(.bold)
                Text( imageDate )
                Text( imageDescription )
            }.frame( width: screenSize.width * 0.5 )
        }
    }
    else
    {
        LazyVStack
        {
            VStack
            {
                Image( imageFile )
                    .resizable( )
                    .scaledToFit( )
            }.frame( height: screenSize.height * 0.5 )
            VStack
            {
                Text( imageName )
                    .fontWeight( .bold )
                Text( imageDate )
                Text( imageDescription )
            }.frame( height: screenSize.height * 0.5 )
        }
    }
}
.onRotate
{ newOrientation in
    orientation = newOrientation
}</pre>
<p>Let’s run <a id="_idIndexMarker254"/>through the code we just added, bit by bit. First, we check which orientation the device is in. By default, we check whether it’s landscape. If not, it must be portrait, and we handle the component sizes and positioning accordingly:</p>
<pre class="source-code">
if ( orientation.isLandscape )</pre> <p>Next, we create a lazy horizontal stack for storing the components in the landscape orientation:</p>
<pre class="source-code">
LazyHStack</pre> <p>Next, we<a id="_idIndexMarker255"/> create two vertical stacks. The frame width is set to half of the screen’s width. This effectively creates an equal splitscreen design. Feel free to modify the multiplier if you would like a custom split. Inside the first vertical stack, we put the image, which is set to <code>resizable</code> and <code>scaledToFit</code>. In the second vertical stack, we put the text metadata in simple <code>Text</code> components:</p>
<pre class="source-code">
VStack{
    Image( imageFile )
        .resizable( )
        .scaledToFit( )
}.frame( width: screenSize.width * 0.5 )
VStack
{
    Text( imageName )
        .fontWeight(.bold)
    Text( imageDate )
    Text( imageDescription )
}.frame( width: screenSize.width * 0.5 )</pre>
<p>In the <code>else</code> statement, we simply use <code>LazyVStack</code> as it pertains to the portrait orientation. The only other change made is to the frame size: it is not linked to the screen’s width but its height. The rest remains the same.</p>
<p>Finally, we add a detector to our <code>Group</code> component, which simply detects when the device has been rotated and updates the orientation variable, which is used to detect which mode to draw:</p>
<pre class="source-code">
.onRotate{ newOrientation in
    orientation = newOrientation
}</pre>
<p>The only thing that remains is updating the preview provider at the bottom of the <code>EnhancedView</code> file. Update the code as follows:</p>
<pre class="source-code">
struct EnhancedView_Previews: PreviewProvider{
    static var previews: some View
    {
        EnhancedView( imageFile: .constant( "" ), imageName: .constant( "" ), imageDate: .constant( "" ), imageDescription: .constant( "" ) )
    }
}</pre>
<p>The preceding<a id="_idIndexMarker256"/> code just adds a default set of parameters to be passed through for the preview. I have left it blank as I used the simulator for testing, but feel free to put in dummy data to ensure you can properly add text using the preview.</p>
<p>In this section, we implemented the <code>EnhancedView</code> code. In the next section, we will take a look at the result. Feel free to modify the layout for landscape and portrait to make it un<a id="_idTextAnchor344"/>ique.</p>
<h1 id="_idParaDest-85"><a id="_idTextAnchor345"/>Testing EnhancedView</h1>
<p>In this section, we will <a id="_idIndexMarker257"/>finally get to test our application. Launching it up will take us to the <code>HighlightView</code>; click on any image and it will take you to the <code>EnhancedView</code>. The portrait mode will look as follows:</p>
<div><div><img alt="Figure 5.10 – Portrait mode" src="img/Figure_5.10_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – Portrait mode</p>
<p>Rotating the application will result in the following output:</p>
<div><div><img alt="Figure 5.11 – Landscape mode" src="img/Figure_5.11_B18783.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – Landscape mode</p>
<p>Now, our application is <a id="_idIndexMarker258"/>complete and features a navigational menu for going back to the <code>HighlightView</code>.<a id="_idTextAnchor346"/></p>
<p class="callout-heading">Note</p>
<p class="callout">If you require help with rotating the simulator, please refer to the previous chapter.</p>
<h1 id="_idParaDest-86"><a id="_idTextAnchor347"/>Extra tasks</h1>
<p>Now that the application is<a id="_idIndexMarker259"/> complete, here is a list of extra tasks for you to complete to enhance your application:</p>
<ul>
<li>Use different source data:<ul><li>Different images</li><li>Different title</li><li>Different description</li><li>Different date</li></ul></li>
<li>Load images from the internet</li>
<li>Load metadata from the internet</li>
<li>Extend the scope of supported devices to iPhone as well, thus providing you with the opportunity to consider cross-platform design</li>
<li>Make the image fullscreen without any extra information</li>
<li>Fullscreen tap for more info: A single tap while in fullscreen will show the photo’s title</li>
<li>Collections: Different sets of images</li>
<li>A side panel, which displays all the collection names, hidden in portrait mode, activated using a button; always visible in landscape mode</li>
<li>Delete and rename: Allows the user to delete images from the gallery and rename them</li>
<li>Sharing: The ability to share an image</li>
<li>Different <a id="_idIndexMarker260"/>display modes: List and grid view</li>
</ul>
<p>We will summarize what we have covered in this chapter, but first, we will look at the code for implementing a few of the extra<a id="_idTextAnchor348"/> tasks.</p>
<h2 id="_idParaDest-87"><a id="_idTextAnchor349"/>Fullscreen mode</h2>
<p>In order to add fullscreen mode to <a id="_idIndexMarker261"/>the <code>EnhancedView</code>, we will add a new <code>@State</code> variable called <code>isFullScreen</code>. We will use this variable to toggle between fullscreen mode and regular mode. Additionally, we will need to add <code>onTapGesture</code> to the image so that when the image is tapped, it toggles fullscreen mode. Here is the modified code:</p>
<pre class="source-code">
import SwiftUIstruct EnhancedView: View
{
    @Binding var imageFile: String
    @Binding var imageName: String
    @Binding var imageDate: String
    @Binding var imageDescription: String
    @State private var orientation = UIDeviceOrientation.unknown
    @State private var isFullScreen: Bool = false
    let screenSize: CGRect = UIScreen.main.bounds
    var body: some View
    {
        Group
        {
            if isFullScreen {
                Image(imageFile)
                    .resizable()
                    .scaledToFit()
                    .edgesIgnoringSafeArea(.all)
                    .onTapGesture {
                        self.isFullScreen.toggle()
                    }
            }
            else if orientation.isLandscape {
                LazyHStack
                {
                    VStack
                    {
                        Image(imageFile)
                            .resizable()
                            .scaledToFit()
                            .onTapGesture {
                                self.isFullScreen.toggle()
                            }
                    }.frame(width: screenSize.width * 0.5)
                    VStack
                    {
                        Text(imageName)
                            .fontWeight(.bold)
                        Text(imageDate)
                        Text(imageDescription)
                    }.frame(width: screenSize.width * 0.5)
                }
            }
            else {
                LazyVStack
                {
                    VStack
                    {
                        Image(imageFile)
                            .resizable()
                            .scaledToFit()
                            .onTapGesture {
                                self.isFullScreen.toggle()
                            }
                    }.frame(height: screenSize.height * 0.5)
                    VStack
                    {
                        Text(imageName)
                            .fontWeight(.bold)
                        Text(imageDate)
                        Text(imageDescription)
                    }.frame(height: screenSize.height * 0.5)
                }
            }
        }
    }
}
struct EnhancedView_Previews: PreviewProvider
{
    static var previews: some View
    {
        EnhancedView(imageFile: .constant(""), imageName: .constant(""), imageDate: .constant(""), imageDescription: .constant(""))
    }
}</pre>
<p>Let’s see what this modified code does:</p>
<ul>
<li>Adds a new <code>@State</code> variable, <code>isFullScreen</code>, to keep track of whether the view is in fullscreen mode or not.</li>
<li>Adds a new condition at the beginning of the <code>Group</code> that, if <code>isFullScreen</code> is <code>true</code>, shows the image in fullscreen mode. In this condition, we use <code>.edgesIgnoringSafeArea(.all)</code> to ensure the image takes up the entire screen, and <code>.onTapGesture</code> to toggle <code>isFullScreen</code> when the image is<a id="_idIndexMarker262"/> tapped.</li>
<li>Modifies the existing <code>Image</code> views in both landscape and portrait mode by adding <code>.onTapGesture</code> to toggle <code>isFullScreen</code> when the image is tapped.</li>
</ul>
<p>This results in the image taking up the full screen when tapped and returning to its original size when tapp<a id="_idTextAnchor350"/>ed again.</p>
<h2 id="_idParaDest-88"><a id="_idTextAnchor351"/>Collections</h2>
<p>To add collections (albums) and a side panel to display the names of these collections, we will make several <a id="_idIndexMarker263"/>changes to the code:</p>
<ol>
<li>Create a data structure to represent a collection of images.</li>
<li>Modify <code>HighlightView</code> to display a list of collections in a side panel when in landscape mode.</li>
<li>Show the images of the selected collection.</li>
</ol>
<p>This is how you can do it:</p>
<pre class="source-code">
import SwiftUI// Data structure representing an image collection
struct ImageCollection {
    let name: String
    let images: [String]
}
struct HighlightView: View {
    // Sample data
    private let collections: [ImageCollection] = [
        ImageCollection(name: "Collection 1", images: ["FireDEV", "FireDEV", "FireDEV"]),
        ImageCollection(name: "Collection 2", images: ["FireDEV", "FireDEV", "FireDEV", "FireDEV"]),
        ImageCollection(name: "Collection 3", images: ["FireDEV", "FireDEV"])
    ]
    private let adaptiveColumns = [GridItem(.adaptive(minimum: 300))]
    @State private var isClicked: Bool = false
    @State private var imageFile: String = ""
    @State private var imageName: String = ""
    @State private var imageDate: String = ""
    @State private var imageDescription: String = ""
    @State private var selectedCollection: ImageCollection?
    var body: some View {
        NavigationView {
            GeometryReader { geometry in
                if geometry.size.width &gt; geometry.size.height {
                    // Horizontal mode, show side panel
                    HStack {
                        // Side Panel
                        List(collections, id: \.name) { collection in
                            Button(action: {
                                selectedCollection = collection
                            }) {
                                Text(collection.name)
                            }
                        }
                        .frame(width: geometry.size.width * 0.25)
                        // Images
                        ScrollView {
                            LazyVGrid(columns: adaptiveColumns, spacing: 20) {
                                if let images = selectedCollection?.images {
                                    ForEach(0..&lt;images.count, id: \.self) { i in
                                        Image(images[i])
                                            .resizable()
                                            .scaledToFill()
                                            .frame(width: 300, height: 300)
                                    }
                                }
                            }
                        }
                    }
                } else {
                    // Vertical mode, just show images
                    ScrollView {
                        LazyVGrid(columns: adaptiveColumns, spacing: 20) {
                            if let images = selectedCollection?.images {
                                ForEach(0..&lt;images.count, id: \.self) { i in
                                    Image(images[i])
                                        .resizable()
                                        .scaledToFill()
                                        .frame(width: 300, height: 300)
                                }
                            }
                        }
                    }
                    .onAppear {
                        // Select the first collection by default
                        if selectedCollection == nil {
                            selectedCollection = collections.first
                        }
                    }
                }
            }
        }
        .navigationViewStyle(StackNavigationViewStyle())
    }
}
struct ContentView_Previews: PreviewProvider {
    static var previews: some View {
        HighlightView()
    }
}</pre>
<p>Let’s explain the<a id="_idIndexMarker264"/> changes:</p>
<ul>
<li>We added a struct called <code>ImageCollection</code> that represents a collection of images with a name.</li>
<li>We updated the <code>collections</code> property to be an array of <code>ImageCollections</code>.</li>
<li>We removed the old <code>images</code> array as it’s now part of the collections.</li>
<li>We used <code>GeometryReader</code> to determine whether the view is in horizontal or vertical mode. In horizontal mode, a side panel is displayed with a list of collection names.</li>
<li>In horizontal mode, clicking on a collection name in the side panel updates the <code>selectedCollection</code> state variable, which in turn updates the images displayed to the right of the side panel.</li>
<li>In vertical mode, only the images of the selected collection are displayed. By default, the first <a id="_idIndexMarker265"/>collection is selected.</li>
</ul>
<p>This code demonstrates how you can create an adaptive layout that shows a side panel in horizontal mode and adjusts its content based on the selected<a id="_idTextAnchor352"/> collection.</p>
<h1 id="_idParaDest-89"><a id="_idTextAnchor353"/>Summary</h1>
<p>In this chapter, we covered the design of our <code>EnhancedView</code> using wireframes. These wireframes helped us break down the views into their components. We then implemented the SwiftUI components to match the design from the wireframe. Though the components were the same for the portrait and landscape orientation, we configured their positions and sizes accordingly. It is very important to make sure each orientation that is supported is best utilized in line with industry standards. We also updated the <code>HighlightView</code> to pass in data to the <code>EnhancedView</code>. This data was used to display content in components added in <code>EnhancedView</code>. Then, we covered extra tasks for you to undertake; feel free to look over this chapter again before proceeding. We have now completed our second application, which is ready for you to modify and use as you see fit.</p>
<p>In our next chapter, we will start our next application, the App Store for Mac. We will naturally look at the design and break it down to help us understand and implement the application for our next platform.</p>
</div>
</body></html>