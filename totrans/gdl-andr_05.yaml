- en: Chapter 5. Managing Multimodule Builds
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Android Studio allows you to create modules for not just apps and libraries,
    but also for Android Wear, Android TV, Google App Engine, and more. All of these
    modules can be used together in a single project. For example, you might want
    to create an app that uses Google Cloud Endpoints for the backend and includes
    integration with Android Wear. In that case, you could have a project with three
    different modules: one for the app, one for the backend, and one for the Android
    Wear integration. Knowing how multimodule projects are structured and built can
    speed up your development cycle significantly.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation for Gradle and the Gradle Android plugin both use the term
    multiproject builds. In Android Studio, however, there is a distinction between
    a *module* and a *project*. A module can be an Android app or a Google App Engine
    backend, for example. A project, on the other hand, is a collection of modules.
    In this book, we use the terms module and project in the same way the IDE does,
    to avoid confusion. Keep this in mind when you browse through the documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the theory of multimodule builds, and then show
    some examples that can be useful in real-life projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a multimodule build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding modules to a project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tips and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The anatomy of a multimodule build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Usually, a multimodule project works by having a root directory that contains
    all modules in subdirectories. To tell Gradle how the project is structured, and
    which directories contain modules, you need to provide a `settings.gradle` file
    in the root of the project. Each module can then provide its own `build.gradle`
    file. We already learned how `settings.gradle` and the `build.gradle` files work
    in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"), *Basic Build
    Customization*, so here we will just focus on how to use them for multimodule
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what a multimodule project could look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the simplest and most straightforward way to set up a project with
    multiple modules. The `settings.gradle` file declares all the modules in the project
    and looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This makes sure that the app and library modules are included in the build configuration.
    All you need to do is to add the name of the directory of the module.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the library module as a dependency to the app module, you need to add
    this to the `build.gradle` file of the app module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In order to add a dependency on a module, you need to use the `project()` method,
    with the module path as the parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to use subdirectories to organize your modules, Gradle can be configured
    to suit your needs. For example, you could have a directory structure that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The app module is still located in the root as it was earlier, but the project
    now has two different libraries. These library modules are not located in the
    project root directory, but in a specific libraries directory. With this directory
    structure, you can declare the app and library modules in `settings.gradle` like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how easy it is to declare modules within a subdirectory. All paths are
    relative to the root directory (where the `settings.gradle` file is). The colon
    is used as a replacement for the forward slash in the path.
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding a module in a subdirectory as a dependency to another module, you
    should always reference it from the root. This means that if the app module in
    the previous example depends on `library1`, the `build.gradle` file for the app
    module should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: If you declare dependencies in a subdirectory, all paths should still be relative
    to the root directory. The reason for this is that Gradle constructs your project's
    dependency model starting at the root of the project.
  prefs: []
  type: TYPE_NORMAL
- en: The build lifecycle revisited
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knowing how the build process model is constructed makes it easier to understand
    how multimodule projects are composed. We already talked about the build lifecycle
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with Gradle and Android Studio"),
    *Getting Starting with Gradle and Android Studio*, so you already know the basics,
    but some details are important specifically for multimodule builds.
  prefs: []
  type: TYPE_NORMAL
- en: In the first phase, the initialization phase, Gradle looks for a `settings.gradle`
    file. If this file does not exist, Gradle assumes that you have a single module
    build. If you have multiple modules though, the settings file is where you can
    define the subdirectories that contain the individual modules. If those subdirectories
    contain their own `build.gradle` files, Gradle will process those, and merge them
    into the build process model. This explains why you should always declare dependencies
    on a module with a path relative to the root directory. Gradle will always try
    to figure out dependencies from the root.
  prefs: []
  type: TYPE_NORMAL
- en: Once you understand how the build process model is put together, it becomes
    clear that there are several strategies to configure multimodule project builds.
    You could configure the settings for all the modules in a `build.gradle` file
    in the root directory. This makes it easy to get an overview of the entire build
    configuration for a project, but it could get very messy, especially when you
    have modules that require different plugins that each have their own DSL. Another
    way is to have `build.gradle` files separately for every module. This strategy
    makes sure that the modules are not tightly coupled to each other. It also makes
    it easier to track build changes, because you do not need to figure out which
    change applies to which module.
  prefs: []
  type: TYPE_NORMAL
- en: The last strategy is the hybrid approach. You can have a build file in the root
    of the project to define common properties for all modules, and a build file per
    module to configure settings that apply only to that specific module. Android
    Studio follows this approach. It creates a `build.gradle` file in the root directory,
    and another `build.gradle` file for the module.
  prefs: []
  type: TYPE_NORMAL
- en: Module tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As soon as you have multiple modules in your project, you need to think twice
    before running tasks. When you run a task from the root of the project in the
    command-line interface, Gradle will figure out which modules have a task with
    that name and execute it for every module. For example, if you have one mobile
    app module and one Android Wear module, running `gradlew assembleDebug` will build
    the debug version of both the mobile app module and the Android Wear module. When
    you change the directory to one of the modules, however, Gradle will only run
    the tasks for that particular module, even when you use the Gradle wrapper in
    the root of the project. For example, running `../gradlew assembleDebug` from
    the Android Wear module directory will only build the Android Wear module.
  prefs: []
  type: TYPE_NORMAL
- en: Switching directories to run module-specific tasks can get annoying. Luckily,
    there is another way. You can prepend a task name with the module name to run
    the task only on that specific module. For example, to build the Android Wear
    module only, you can use the `gradlew :wear:assembleDebug` command.
  prefs: []
  type: TYPE_NORMAL
- en: Adding modules to a project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Adding a new module is as simple as going through a wizard in Android Studio.
    The wizard also sets up the basics of the build file. In some cases, adding a
    module will even cause Android Studio to edit the build file of your app module.
    For example, when adding an Android Wear module, the IDE assumes that you want
    to use it for your Android app, and add a line in the build file to reference
    the Android Wear module.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what the **New Module** dialog in Android Studio looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding modules to a project](img/B01061_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the following sections, we will show different modules that can be added
    to an Android project with Android Studio, explain their custom properties, and
    specify how they alter the build process.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a Java library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you add a new Java library module, the `build.gradle` file generated by
    Android Studio looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Java library modules use the Java plugin instead of the Android plugins we are
    used to seeing. This means that a lot of Android-specific properties and tasks
    are not available, but you do not need those for a Java library anyway.
  prefs: []
  type: TYPE_NORMAL
- en: The build file also has basic dependency management set up, so you can add JAR
    files to your `libs` folder without needing any special configuration. You can
    add more dependencies, using what you learned in [Chapter 3](ch03.html "Chapter 3. Managing
    Dependencies"), *Managing Dependencies*. The dependency configuration does not
    depend on the Android plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Java library module named `javalib` as a dependency to your app module,
    for example, simply add this line to the build configuration file for the app
    module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This tells Gradle to import a module named `javalib` in the build. If you add
    this dependency in your app module, the `javalib` module will always be built
    before the build for the app module itself is started.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an Android library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We briefly mentioned Android libraries in [Chapter 3](ch03.html "Chapter 3. Managing
    Dependencies"), *Managing Dependencies*, where we called them library projects.
    Both names are used throughout the documentation and in various tutorials. In
    this section, we will use the name `Androidlibrary` because that is the name used
    in the **New Module** dialog in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default `build.gradle` file for an Android library starts with this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Adding a dependency on an Android library module is done in the exact same
    way as with Java libraries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: An Android library contains not only the Java code of the library, but also
    all Android resources, such as the manifest, strings, and layouts. After referencing
    an Android library in your app, you can use all of the library's classes and resources
    in the app.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating Android Wear
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are looking to add deep integration of your app to Android Wear, you
    will need to add an Android Wear module. It is interesting to note that Android
    Wear modules also use the Android application plugin. This means that all build
    properties and tasks are available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only part of the `build.gradle` file that is different from a regular Android
    app module is the dependency configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Every Android Wear app depends on a few Android Wear–specific libraries provided
    by Google. In order to use an Android Wear app with your Android app, you need
    to package it with the app. You can do this by adding a dependency in the Android
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `wearApp` configuration makes sure that the APK of the Wear module is added
    to the final APK of the Android app and does the necessary configuration for you.
  prefs: []
  type: TYPE_NORMAL
- en: Using Google App Engine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Google App Engine** is a cloud computing platform that you can use to host
    web applications, without having to set up your own server. It is free to use
    up to a certain usage level, which makes it a good environment for experimentation.
    Google App Engine also provides a service called Cloud Endpoints, which is used
    to create RESTful services. Using Google App Engine with Cloud Endpoints makes
    it easy to build a backend for your apps. The App Engine Gradle plugin makes it
    even easier by generating a client library for your Android app, meaning you do
    not need to write any of the API-related code yourself. This makes Google App
    Engine an interesting option for an app backend, so in the following section we
    will look at how the App Engine Gradle plugin works, and how we can make use of
    Cloud Endpoints.'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new Google App Engine module with Cloud Endpoints, open the **New
    Module** dialog from **File** | **New Module…** and select **Google Cloud Module**.
    When setting up the module, you can change the type to include Cloud Endpoints.
    Then, select the client module that will be using this backend.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using Google App Engine](img/B01061_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A thorough explanation of Google App Engine and Cloud Endpoints is beyond the
    scope of this book; we will only look at the Gradle integration in both the App
    Engine module and the client app module.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing the build file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `build.gradle` file for this module becomes quite big, so we will only
    look at the most interesting parts, beginning with the new build script dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The App Engine plugin needs to be defined in `classpath` of the build script.
    We have seen this earlier when adding the Android plugin. When that is in place,
    we can apply the App Engine plugin along with two other plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The Java plugin is primarily used to generate JAR files for Cloud Endpoints.
    The WAR plugin is necessary to run and distribute the entire backend. The WAR
    plugin generates a WAR file, which is how Java web applications are distributed.
    Finally, the App Engine plugin adds a number of tasks to build, run, and deploy
    the entire backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next important block defines the dependencies of the App Engine module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first dependency uses `appengineSdk` to specify which SDK should be used
    in this module. The `endpoints` dependencies are necessary for Cloud Endpoints
    to work. These are only added if you choose to use Cloud Endpoints in your module.
    The servlet dependency is a requirement for any Google App Engine module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Configure any App Engine–specific settings in the `appengine` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Setting the `downloadSdk` property to true makes it easy to run a local development
    server, because it automatically downloads the SDK if it is not present. If you
    already set up the Google App Engine SDK on your device, you can set the `downloadSdk`
    property to `false`.
  prefs: []
  type: TYPE_NORMAL
- en: The `appcfg` block is used to configure the App Engine SDK. In a typical Google
    App Engine installation, you can manually configure some settings by using the
    `appcfg` command-line tool. Using the `appcfg` block, instead of the command-line
    tool, makes the configuration a lot more portable, as anyone who ever builds the
    module will have the same configuration without needing to execute any external
    commands.
  prefs: []
  type: TYPE_NORMAL
- en: The endpoints block contains some Cloud Endpoints–specific settings.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A detailed explanation of Google App Engine and Cloud Endpoints configurations
    is out of the scope of this book. If you wish to know more, look at the documentation
    at [https://cloud.google.com/appengine/docs](https://cloud.google.com/appengine/docs).
  prefs: []
  type: TYPE_NORMAL
- en: Using the backend in an app
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you create the App Engine module, Android Studio automatically adds a
    dependency to the build file of the Android app module. This dependency looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We saw syntax like this earlier (when referencing Java and Android libraries),
    using `project` to define the dependency, but with two parameters instead of just
    one. The `path` parameter is the default parameter. We used it earlier, but without
    specifying its name. A Google App Engine module can have different types of output.
    You can specify the output you want with the `configuration` parameter. We need
    the App Engine module to generate Cloud Endpoints, so we use the `android-endpoints`
    configuration. Internally, this configuration runs the `_appengineEndpointsAndroidArtifact`
    task. This task generates a JAR file that contains classes that you can use in
    your Android app module. This JAR file contains not only the models used in the
    Cloud Endpoints, but also API methods. Integration like this is what makes multimodule
    projects nice to work with because it speeds up development time. The Gradle tasks
    in the App Engine module also make it easy to run and deploy your backend.
  prefs: []
  type: TYPE_NORMAL
- en: Custom tasks
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The App Engine plugin adds a lot of tasks, but the ones you will use the most
    are `appengineRun` and `appengineUpdate`.
  prefs: []
  type: TYPE_NORMAL
- en: The `appengineRun` task is used to start a local development server that you
    can use to test your entire backend locally before uploading it to Google App
    Engine. The first time you run this task, the build may take a while because Gradle
    needs to download the App Engine SDK. We set this behavior earlier with `downloadSdk
    = true`. To stop the server, you can use `appengineStop`.
  prefs: []
  type: TYPE_NORMAL
- en: Once you are ready to deploy your backend to Google App Engine and start using
    it in production, you can use `appengineUpdate`. This task handles all the deployment
    details. If you have set `oauth2 = true` in the `appengine` configuration block,
    this task will open a browser window, so you can log in to your Google account
    and get an authentication token. If you prefer not having to do this every time
    you need to deploy, you can log in to Android Studio with your Google account
    and use the IDE to deploy the backend. Android Studio runs the same Gradle task,
    but it will take care of the authentication for you.
  prefs: []
  type: TYPE_NORMAL
- en: Tips and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a few ways to make it easier to deal with multimodule projects, and
    there are a few things to keep in mind when working with several modules. Being
    aware of these can save you time and frustration.
  prefs: []
  type: TYPE_NORMAL
- en: Running module tasks from Android Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"),
    *Basic Build Customization*, it is possible to run Gradle tasks straight from
    Android Studio. When you have multiple modules, Android Studio recognizes them,
    and shows a grouped overview of all available tasks.
  prefs: []
  type: TYPE_NORMAL
- en: '![Running module tasks from Android Studio](img/B01061_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Gradle tool window makes it easier to run module-specific tasks. There is
    no option to run a task for all modules at the same time, so if you wish to do
    that, the command-line interface is still faster.
  prefs: []
  type: TYPE_NORMAL
- en: Speeding up multimodule builds
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you build a multimodule project, Gradle processes all modules sequentially.
    With more and more cores available in computers, we can make the build process
    a lot faster by building the modules in parallel. This feature already exists
    in Gradle, but is not enabled by default.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to apply parallel build execution to your project, you need to
    configure the `parallel` property in the `gradle.properties` file on the root
    of the project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Gradle attempts to choose the right number of threads, based on available CPU
    cores. To prevent issues that may arise from executing two tasks from the same
    module in parallel, each thread *owns* an entire module.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Parallel build execution is an incubating feature. This means that it is under
    active development and the implementation may change at any time. This feature
    has been a part of Gradle for a while now, though, and is already widely used.
    It is, therefore, safe to assume that the implementation will not disappear or
    change drastically.
  prefs: []
  type: TYPE_NORMAL
- en: Your mileage may vary, but you might be able to shave off a significant amount
    of time from your builds by simply enabling parallel build execution. There is
    one caveat, however. For this to work efficiently, you will need to make sure
    your modules are decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: Module coupling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"),
    *Basic Build Customization*, it is possible to define properties for all modules
    in a project, using `allprojects` in the `build.gradle` file. When you have a
    project with multiple modules, you can use `allprojects` in any module to apply
    properties to all the modules in the project. Gradle even makes it possible for
    one module to reference properties from another module. These powerful features
    can make maintenance for multimodule builds a lot easier. The downside, though,
    is that your modules become coupled.
  prefs: []
  type: TYPE_NORMAL
- en: Two modules are considered to be coupled as soon as they access each other's
    tasks or properties. This has several consequences. For example, you give up portability.
    If you ever decide to extract a library out of the project, you will not be able
    to build the library before copying all project-wide settings first. Module coupling
    also has an effect on parallel builds. Using the `allprojects` block in any of
    the modules will render parallel build execution useless. Be aware of this when
    you add project-wide properties to any of the modules.
  prefs: []
  type: TYPE_NORMAL
- en: You can avoid coupling by not directly accessing tasks or properties from other
    modules. If you need this behavior, you can use the root module as an intermediary
    so that modules are coupled only to the root module and not to each other.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We started the chapter by looking at the structure of multimodule builds. Then,
    we looked at how to set up multiple modules in a single project. We also saw that
    adding new modules affects how build tasks are run.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at some practical examples of new modules, and how each of them
    can be integrated into a project. Finally, we mentioned some tips and tricks that
    make it easier to work with multiple modules in one project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will set up various kinds of tests, and see how to use
    Gradle to make it easier to run these tests. We will look at running unit tests
    directly on the Java Virtual Machine, but also at running tests on a real device
    or an emulator.
  prefs: []
  type: TYPE_NORMAL
