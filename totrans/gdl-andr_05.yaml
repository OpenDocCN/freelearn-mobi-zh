- en: Chapter 5. Managing Multimodule Builds
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。管理多模块构建
- en: 'Android Studio allows you to create modules for not just apps and libraries,
    but also for Android Wear, Android TV, Google App Engine, and more. All of these
    modules can be used together in a single project. For example, you might want
    to create an app that uses Google Cloud Endpoints for the backend and includes
    integration with Android Wear. In that case, you could have a project with three
    different modules: one for the app, one for the backend, and one for the Android
    Wear integration. Knowing how multimodule projects are structured and built can
    speed up your development cycle significantly.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 允许你创建不仅适用于应用和库，还适用于 Android Wear、Android TV、Google App Engine
    等模块。所有这些模块都可以在单个项目中一起使用。例如，你可能想要创建一个使用 Google Cloud Endpoints 作为后端并包含 Android
    Wear 集成的应用。在这种情况下，你可以有一个包含三个不同模块的项目：一个用于应用，一个用于后端，一个用于 Android Wear 集成。了解多模块项目的结构和构建方式可以显著加快你的开发周期。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The documentation for Gradle and the Gradle Android plugin both use the term
    multiproject builds. In Android Studio, however, there is a distinction between
    a *module* and a *project*. A module can be an Android app or a Google App Engine
    backend, for example. A project, on the other hand, is a collection of modules.
    In this book, we use the terms module and project in the same way the IDE does,
    to avoid confusion. Keep this in mind when you browse through the documentation.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 和 Gradle Android 插件的文档都使用了“多项目构建”这个术语。然而，在 Android Studio 中，模块和项目之间有一个区别。一个模块可以是
    Android 应用或 Google App Engine 后端，例如。另一方面，项目是一组模块的集合。在这本书中，我们使用模块和项目这两个术语的方式与 IDE
    相同，以避免混淆。当你浏览文档时，请记住这一点。
- en: 'In this chapter, we will cover the theory of multimodule builds, and then show
    some examples that can be useful in real-life projects:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍多模块构建的理论，然后展示一些在实际项目中可能有用的示例：
- en: Anatomy of a multimodule build
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多模块构建的解剖结构
- en: Adding modules to a project
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向项目中添加模块
- en: Tips and best practices
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小贴士和最佳实践
- en: The anatomy of a multimodule build
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多模块构建的解剖结构
- en: Usually, a multimodule project works by having a root directory that contains
    all modules in subdirectories. To tell Gradle how the project is structured, and
    which directories contain modules, you need to provide a `settings.gradle` file
    in the root of the project. Each module can then provide its own `build.gradle`
    file. We already learned how `settings.gradle` and the `build.gradle` files work
    in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"), *Basic Build
    Customization*, so here we will just focus on how to use them for multimodule
    projects.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，多模块项目通过一个根目录来工作，该目录包含所有模块的子目录。为了告诉 Gradle 项目的结构以及哪些目录包含模块，你需要在项目的根目录中提供一个
    `settings.gradle` 文件。然后，每个模块可以提供自己的 `build.gradle` 文件。我们已经在 [第 2 章](ch02.html
    "第 2 章。基本构建定制") 中学习了 `settings.gradle` 和 `build.gradle` 文件的工作方式，*基本构建定制*，所以在这里我们将只关注如何为多模块项目使用它们。
- en: 'This is what a multimodule project could look like:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是多模块项目可能的样子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is the simplest and most straightforward way to set up a project with
    multiple modules. The `settings.gradle` file declares all the modules in the project
    and looks like this:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置具有多个模块的项目最简单、最直接的方式。`settings.gradle` 文件声明了项目中的所有模块，其外观如下：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This makes sure that the app and library modules are included in the build configuration.
    All you need to do is to add the name of the directory of the module.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了应用和库模块被包含在构建配置中。你所需做的只是添加模块目录的名称。
- en: 'To add the library module as a dependency to the app module, you need to add
    this to the `build.gradle` file of the app module:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要将库模块作为依赖添加到应用模块中，你需要在应用模块的 `build.gradle` 文件中添加以下内容：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In order to add a dependency on a module, you need to use the `project()` method,
    with the module path as the parameter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了添加对模块的依赖，你需要使用 `project()` 方法，并将模块路径作为参数。
- en: 'If you want to use subdirectories to organize your modules, Gradle can be configured
    to suit your needs. For example, you could have a directory structure that looks
    like this:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要使用子目录来组织你的模块，Gradle 可以配置以适应你的需求。例如，你可以有一个看起来像这样的目录结构：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The app module is still located in the root as it was earlier, but the project
    now has two different libraries. These library modules are not located in the
    project root directory, but in a specific libraries directory. With this directory
    structure, you can declare the app and library modules in `settings.gradle` like
    this:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 应用模块仍然位于根目录，就像之前一样，但现在项目有两个不同的库。这些库模块并不位于项目根目录中，而是在一个特定的库目录中。有了这种目录结构，你可以在`settings.gradle`中这样声明应用和库模块：
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice how easy it is to declare modules within a subdirectory. All paths are
    relative to the root directory (where the `settings.gradle` file is). The colon
    is used as a replacement for the forward slash in the path.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注意声明子目录内模块的简单性。所有路径都是相对于根目录的（`settings.gradle`文件所在的目录）。冒号用作路径中正斜杠的替代。
- en: 'When adding a module in a subdirectory as a dependency to another module, you
    should always reference it from the root. This means that if the app module in
    the previous example depends on `library1`, the `build.gradle` file for the app
    module should look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 当在子目录中添加一个模块作为另一个模块的依赖项时，你应该始终从根目录引用它。这意味着如果前一个示例中的应用模块依赖于`library1`，那么应用模块的`build.gradle`文件应该看起来像这样：
- en: '[PRE5]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: If you declare dependencies in a subdirectory, all paths should still be relative
    to the root directory. The reason for this is that Gradle constructs your project's
    dependency model starting at the root of the project.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个子目录中声明依赖项，所有路径都应该相对于根目录。这是因为Gradle从项目的根目录开始构建你的项目的依赖模型。
- en: The build lifecycle revisited
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重新审视构建生命周期
- en: Knowing how the build process model is constructed makes it easier to understand
    how multimodule projects are composed. We already talked about the build lifecycle
    in [Chapter 1](ch01.html "Chapter 1. Getting Started with Gradle and Android Studio"),
    *Getting Starting with Gradle and Android Studio*, so you already know the basics,
    but some details are important specifically for multimodule builds.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 了解构建过程模型是如何构建的，使得理解多模块项目是如何组成的变得更容易。我们已经在[第1章](ch01.html "第1章。使用Gradle和Android
    Studio入门")中讨论了构建生命周期，*使用Gradle和Android Studio入门*，所以你已经知道了基础知识，但一些细节对于多模块构建尤为重要。
- en: In the first phase, the initialization phase, Gradle looks for a `settings.gradle`
    file. If this file does not exist, Gradle assumes that you have a single module
    build. If you have multiple modules though, the settings file is where you can
    define the subdirectories that contain the individual modules. If those subdirectories
    contain their own `build.gradle` files, Gradle will process those, and merge them
    into the build process model. This explains why you should always declare dependencies
    on a module with a path relative to the root directory. Gradle will always try
    to figure out dependencies from the root.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个阶段，初始化阶段，Gradle寻找一个`settings.gradle`文件。如果这个文件不存在，Gradle假设你有一个单模块构建。如果你有多个模块，设置文件就是你可以定义包含单个模块的子目录的地方。如果那些子目录包含它们自己的`build.gradle`文件，Gradle将处理它们，并将它们合并到构建过程模型中。这就是为什么你应该始终使用相对于根目录的路径来声明模块依赖的原因。Gradle总是会尝试从根目录中确定依赖项。
- en: Once you understand how the build process model is put together, it becomes
    clear that there are several strategies to configure multimodule project builds.
    You could configure the settings for all the modules in a `build.gradle` file
    in the root directory. This makes it easy to get an overview of the entire build
    configuration for a project, but it could get very messy, especially when you
    have modules that require different plugins that each have their own DSL. Another
    way is to have `build.gradle` files separately for every module. This strategy
    makes sure that the modules are not tightly coupled to each other. It also makes
    it easier to track build changes, because you do not need to figure out which
    change applies to which module.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你理解了构建过程模型是如何构建的，就会变得清楚，有几种策略可以配置多模块项目的构建。你可以在根目录的`build.gradle`文件中为所有模块配置设置。这使得你可以轻松地获得整个项目的构建配置概览，但可能会变得非常混乱，尤其是当你有需要不同插件的模块时，每个插件都有自己的DSL。另一种方法是为每个模块单独创建`build.gradle`文件。这种策略确保模块之间不是紧密耦合的。它还使得跟踪构建更改变得更容易，因为你不需要弄清楚哪个更改适用于哪个模块。
- en: The last strategy is the hybrid approach. You can have a build file in the root
    of the project to define common properties for all modules, and a build file per
    module to configure settings that apply only to that specific module. Android
    Studio follows this approach. It creates a `build.gradle` file in the root directory,
    and another `build.gradle` file for the module.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种策略是混合方法。你可以在项目根目录中有一个构建文件来定义所有模块的通用属性，并为每个模块有一个构建文件来配置仅适用于该特定模块的设置。Android
    Studio遵循这种方法。它在根目录中创建一个`build.gradle`文件，并为每个模块创建另一个`build.gradle`文件。
- en: Module tasks
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块任务
- en: As soon as you have multiple modules in your project, you need to think twice
    before running tasks. When you run a task from the root of the project in the
    command-line interface, Gradle will figure out which modules have a task with
    that name and execute it for every module. For example, if you have one mobile
    app module and one Android Wear module, running `gradlew assembleDebug` will build
    the debug version of both the mobile app module and the Android Wear module. When
    you change the directory to one of the modules, however, Gradle will only run
    the tasks for that particular module, even when you use the Gradle wrapper in
    the root of the project. For example, running `../gradlew assembleDebug` from
    the Android Wear module directory will only build the Android Wear module.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的项目中包含多个模块，在运行任务之前你需要三思。当你从项目根目录在命令行界面中运行任务时，Gradle会确定哪些模块具有该名称的任务，并为每个模块执行它。例如，如果你有一个移动应用模块和一个Android
    Wear模块，运行`gradlew assembleDebug`将构建移动应用模块和Android Wear模块的调试版本。然而，当你更改目录到其中一个模块时，即使你在项目根目录中使用Gradle包装器，Gradle也只会为该特定模块运行任务。例如，从Android
    Wear模块目录运行`../gradlew assembleDebug`将仅构建Android Wear模块。
- en: Switching directories to run module-specific tasks can get annoying. Luckily,
    there is another way. You can prepend a task name with the module name to run
    the task only on that specific module. For example, to build the Android Wear
    module only, you can use the `gradlew :wear:assembleDebug` command.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 切换目录以运行特定模块的任务可能会让人感到烦恼。幸运的是，还有另一种方法。你可以在任务名称前加上模块名称，以便只在该特定模块上运行该任务。例如，要仅构建Android
    Wear模块，可以使用`gradlew :wear:assembleDebug`命令。
- en: Adding modules to a project
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将模块添加到项目中
- en: Adding a new module is as simple as going through a wizard in Android Studio.
    The wizard also sets up the basics of the build file. In some cases, adding a
    module will even cause Android Studio to edit the build file of your app module.
    For example, when adding an Android Wear module, the IDE assumes that you want
    to use it for your Android app, and add a line in the build file to reference
    the Android Wear module.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 添加新模块就像在Android Studio中通过向导一样简单。向导还会设置构建文件的基本设置。在某些情况下，添加模块甚至会导致Android Studio编辑你的应用模块的构建文件。例如，当添加Android
    Wear模块时，IDE假设你想将其用于你的Android应用，并在构建文件中添加一行以引用Android Wear模块。
- en: 'This is what the **New Module** dialog in Android Studio looks like:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Android Studio中的**新建模块**对话框的样子：
- en: '![Adding modules to a project](img/B01061_05_01.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![将模块添加到项目中](img/B01061_05_01.jpg)'
- en: In the following sections, we will show different modules that can be added
    to an Android project with Android Studio, explain their custom properties, and
    specify how they alter the build process.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下章节中，我们将展示如何使用Android Studio将不同的模块添加到Android项目中，解释它们的自定义属性，并指定它们如何改变构建过程。
- en: Adding a Java library
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加Java库
- en: 'When you add a new Java library module, the `build.gradle` file generated by
    Android Studio looks like this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加一个新的Java库模块时，Android Studio生成的`build.gradle`文件看起来像这样：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Java library modules use the Java plugin instead of the Android plugins we are
    used to seeing. This means that a lot of Android-specific properties and tasks
    are not available, but you do not need those for a Java library anyway.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Java库模块使用Java插件而不是我们习惯看到的Android插件。这意味着许多Android特定的属性和任务不可用，但无论如何你都不需要这些属性来创建Java库。
- en: The build file also has basic dependency management set up, so you can add JAR
    files to your `libs` folder without needing any special configuration. You can
    add more dependencies, using what you learned in [Chapter 3](ch03.html "Chapter 3. Managing
    Dependencies"), *Managing Dependencies*. The dependency configuration does not
    depend on the Android plugin.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 构建文件还设置了基本的依赖管理，因此你可以将JAR文件添加到你的`libs`文件夹中，而无需任何特殊配置。你可以添加更多依赖项，使用你在[第3章](ch03.html
    "第3章。管理依赖项")中学到的知识，*管理依赖项*。依赖项配置不依赖于Android插件。
- en: 'To add a Java library module named `javalib` as a dependency to your app module,
    for example, simply add this line to the build configuration file for the app
    module:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 要将名为 `javalib` 的 Java 库模块作为依赖项添加到您的应用模块中，例如，只需将此行添加到应用模块的构建配置文件中：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This tells Gradle to import a module named `javalib` in the build. If you add
    this dependency in your app module, the `javalib` module will always be built
    before the build for the app module itself is started.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉Gradle在构建中导入名为 `javalib` 的模块。如果您在应用模块中添加此依赖项，则 `javalib` 模块将在启动应用模块本身的构建之前始终被构建。
- en: Adding an Android library
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加 Android 库
- en: We briefly mentioned Android libraries in [Chapter 3](ch03.html "Chapter 3. Managing
    Dependencies"), *Managing Dependencies*, where we called them library projects.
    Both names are used throughout the documentation and in various tutorials. In
    this section, we will use the name `Androidlibrary` because that is the name used
    in the **New Module** dialog in Android Studio.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第3章](ch03.html "第3章。管理依赖项")中简要提到了Android库，称为库项目。这两个名称在文档和各个教程中都被使用。在本节中，我们将使用
    `Androidlibrary` 这个名称，因为在Android Studio的 **新建模块** 对话框中使用的是这个名称。
- en: 'The default `build.gradle` file for an Android library starts with this line:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: Android库的默认 `build.gradle` 文件以这一行开始：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Adding a dependency on an Android library module is done in the exact same
    way as with Java libraries:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 以与Java库相同的方式添加对Android库模块的依赖项：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: An Android library contains not only the Java code of the library, but also
    all Android resources, such as the manifest, strings, and layouts. After referencing
    an Android library in your app, you can use all of the library's classes and resources
    in the app.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Android库不仅包含库的Java代码，还包含所有Android资源，如清单、字符串和布局。在您的应用中引用Android库后，您可以在应用中使用库的所有类和资源。
- en: Integrating Android Wear
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成Android Wear
- en: If you are looking to add deep integration of your app to Android Wear, you
    will need to add an Android Wear module. It is interesting to note that Android
    Wear modules also use the Android application plugin. This means that all build
    properties and tasks are available.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想将您的应用深度集成到Android Wear中，您需要添加一个Android Wear模块。值得注意的是，Android Wear模块也使用Android应用程序插件。这意味着所有构建属性和任务都是可用的。
- en: 'The only part of the `build.gradle` file that is different from a regular Android
    app module is the dependency configuration:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规Android应用模块不同的 `build.gradle` 文件的部分是依赖项配置：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Every Android Wear app depends on a few Android Wear–specific libraries provided
    by Google. In order to use an Android Wear app with your Android app, you need
    to package it with the app. You can do this by adding a dependency in the Android
    app:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 每个Android Wear应用都依赖于Google提供的几个特定于Android Wear的库。为了使用Android Wear应用与您的Android应用一起使用，您需要将其打包到应用中。您可以通过在Android应用中添加依赖项来实现这一点：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `wearApp` configuration makes sure that the APK of the Wear module is added
    to the final APK of the Android app and does the necessary configuration for you.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`wearApp` 配置确保Wear模块的APK被添加到Android应用的最终APK中，并为您执行必要的配置。'
- en: Using Google App Engine
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Google App Engine
- en: '**Google App Engine** is a cloud computing platform that you can use to host
    web applications, without having to set up your own server. It is free to use
    up to a certain usage level, which makes it a good environment for experimentation.
    Google App Engine also provides a service called Cloud Endpoints, which is used
    to create RESTful services. Using Google App Engine with Cloud Endpoints makes
    it easy to build a backend for your apps. The App Engine Gradle plugin makes it
    even easier by generating a client library for your Android app, meaning you do
    not need to write any of the API-related code yourself. This makes Google App
    Engine an interesting option for an app backend, so in the following section we
    will look at how the App Engine Gradle plugin works, and how we can make use of
    Cloud Endpoints.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**Google App Engine** 是一个云平台，您可以使用它来托管Web应用，而无需设置自己的服务器。在达到一定使用量之前，它是免费的，这使得它成为实验的好环境。Google
    App Engine还提供了一种名为Cloud Endpoints的服务，用于创建RESTful服务。使用Google App Engine与Cloud Endpoints一起使用，可以轻松构建应用的后端。App
    Engine Gradle插件通过为您的Android应用生成客户端库，使这变得更加容易，这意味着您不需要自己编写任何API相关的代码。这使得Google
    App Engine成为应用后端的一个有趣选择，因此，在下一节中，我们将探讨App Engine Gradle插件的工作原理以及我们如何利用Cloud Endpoints。'
- en: To create a new Google App Engine module with Cloud Endpoints, open the **New
    Module** dialog from **File** | **New Module…** and select **Google Cloud Module**.
    When setting up the module, you can change the type to include Cloud Endpoints.
    Then, select the client module that will be using this backend.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的带有 Cloud Endpoints 的 Google App Engine 模块，请从 **文件** | **新建模块…** 打开 **新建模块**
    对话框，并选择 **Google Cloud 模块**。在设置模块时，您可以更改类型以包括 Cloud Endpoints。然后，选择将使用此后端的客户端模块。
- en: '![Using Google App Engine](img/B01061_05_02.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Google App Engine](img/B01061_05_02.jpg)'
- en: A thorough explanation of Google App Engine and Cloud Endpoints is beyond the
    scope of this book; we will only look at the Gradle integration in both the App
    Engine module and the client app module.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 对 Google App Engine 和 Cloud Endpoints 的全面解释超出了本书的范围；我们只会查看 App Engine 模块和客户端应用模块中的
    Gradle 集成。
- en: Analyzing the build file
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分析构建文件
- en: 'The `build.gradle` file for this module becomes quite big, so we will only
    look at the most interesting parts, beginning with the new build script dependency:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块的 `build.gradle` 文件变得相当大，所以我们只看最有趣的部分，从新的构建脚本依赖项开始：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The App Engine plugin needs to be defined in `classpath` of the build script.
    We have seen this earlier when adding the Android plugin. When that is in place,
    we can apply the App Engine plugin along with two other plugins:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine 插件需要在构建脚本的 `classpath` 中定义。我们之前在添加 Android 插件时已经看到过这一点。当它就位后，我们可以应用
    App Engine 插件以及另外两个插件：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The Java plugin is primarily used to generate JAR files for Cloud Endpoints.
    The WAR plugin is necessary to run and distribute the entire backend. The WAR
    plugin generates a WAR file, which is how Java web applications are distributed.
    Finally, the App Engine plugin adds a number of tasks to build, run, and deploy
    the entire backend.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Java 插件主要用于为 Cloud Endpoints 生成 JAR 文件。WAR 插件对于运行和分发整个后端是必要的。WAR 插件生成 WAR 文件，这是
    Java 网络应用程序的分发方式。最后，App Engine 插件添加了构建、运行和部署整个后端的任务。
- en: 'The next important block defines the dependencies of the App Engine module:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个重要的块定义了 App Engine 模块的依赖项：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first dependency uses `appengineSdk` to specify which SDK should be used
    in this module. The `endpoints` dependencies are necessary for Cloud Endpoints
    to work. These are only added if you choose to use Cloud Endpoints in your module.
    The servlet dependency is a requirement for any Google App Engine module.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个依赖项使用 `appengineSdk` 来指定在此模块中应使用哪个 SDK。`endpoints` 依赖项对于 Cloud Endpoints
    的工作是必要的。这些依赖项只有在您选择在模块中使用 Cloud Endpoints 时才会添加。servlet 依赖项是任何 Google App Engine
    模块的要求。
- en: 'Configure any App Engine–specific settings in the `appengine` block:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `appengine` 块中配置任何特定于 App Engine 的设置：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Setting the `downloadSdk` property to true makes it easy to run a local development
    server, because it automatically downloads the SDK if it is not present. If you
    already set up the Google App Engine SDK on your device, you can set the `downloadSdk`
    property to `false`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `downloadSdk` 属性设置为 true 可以轻松运行本地开发服务器，因为它会自动下载 SDK，如果它不存在的话。如果您已经在设备上设置了
    Google App Engine SDK，可以将 `downloadSdk` 属性设置为 `false`。
- en: The `appcfg` block is used to configure the App Engine SDK. In a typical Google
    App Engine installation, you can manually configure some settings by using the
    `appcfg` command-line tool. Using the `appcfg` block, instead of the command-line
    tool, makes the configuration a lot more portable, as anyone who ever builds the
    module will have the same configuration without needing to execute any external
    commands.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`appcfg` 块用于配置 App Engine SDK。在典型的 Google App Engine 安装中，您可以使用 `appcfg` 命令行工具手动配置一些设置。使用
    `appcfg` 块而不是命令行工具可以使配置更加便携，因为任何构建过此模块的人都将拥有相同的配置，而无需执行任何外部命令。'
- en: The endpoints block contains some Cloud Endpoints–specific settings.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: endpoints 块包含一些 Cloud Endpoints 特定的设置。
- en: Note
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A detailed explanation of Google App Engine and Cloud Endpoints configurations
    is out of the scope of this book. If you wish to know more, look at the documentation
    at [https://cloud.google.com/appengine/docs](https://cloud.google.com/appengine/docs).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中不包含对 Google App Engine 和 Cloud Endpoints 配置的详细解释。如果您想了解更多信息，请查看[https://cloud.google.com/appengine/docs](https://cloud.google.com/appengine/docs)上的文档。
- en: Using the backend in an app
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在应用中使用后端
- en: 'When you create the App Engine module, Android Studio automatically adds a
    dependency to the build file of the Android app module. This dependency looks
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建 App Engine 模块时，Android Studio 会自动将依赖项添加到 Android 应用模块的构建文件中。这个依赖项看起来是这样的：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We saw syntax like this earlier (when referencing Java and Android libraries),
    using `project` to define the dependency, but with two parameters instead of just
    one. The `path` parameter is the default parameter. We used it earlier, but without
    specifying its name. A Google App Engine module can have different types of output.
    You can specify the output you want with the `configuration` parameter. We need
    the App Engine module to generate Cloud Endpoints, so we use the `android-endpoints`
    configuration. Internally, this configuration runs the `_appengineEndpointsAndroidArtifact`
    task. This task generates a JAR file that contains classes that you can use in
    your Android app module. This JAR file contains not only the models used in the
    Cloud Endpoints, but also API methods. Integration like this is what makes multimodule
    projects nice to work with because it speeds up development time. The Gradle tasks
    in the App Engine module also make it easy to run and deploy your backend.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前看到过这样的语法（在引用 Java 和 Android 库时），使用 `project` 来定义依赖关系，但有两个参数而不是一个。`path`
    参数是默认参数。我们之前使用过它，但没有指定其名称。Google App Engine 模块可以有不同的输出类型。你可以使用 `configuration`
    参数指定你想要的输出。我们需要 App Engine 模块生成 Cloud Endpoints，所以我们使用 `android-endpoints` 配置。内部，此配置运行
    `_appengineEndpointsAndroidArtifact` 任务。此任务生成一个包含你可以用于你的 Android 应用模块的类的 JAR 文件。此
    JAR 文件不仅包含 Cloud Endpoints 中使用的模型，还包括 API 方法。这种集成使得多模块项目易于工作，因为它可以加快开发时间。App Engine
    模块中的 Gradle 任务也使得运行和部署你的后端变得容易。
- en: Custom tasks
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义任务
- en: The App Engine plugin adds a lot of tasks, but the ones you will use the most
    are `appengineRun` and `appengineUpdate`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: App Engine 插件添加了许多任务，但你最常使用的是 `appengineRun` 和 `appengineUpdate`。
- en: The `appengineRun` task is used to start a local development server that you
    can use to test your entire backend locally before uploading it to Google App
    Engine. The first time you run this task, the build may take a while because Gradle
    needs to download the App Engine SDK. We set this behavior earlier with `downloadSdk
    = true`. To stop the server, you can use `appengineStop`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`appengineRun` 任务用于启动一个本地开发服务器，你可以用它来在将代码上传到 Google App Engine 之前本地测试你的整个后端。第一次运行此任务时，构建可能需要一些时间，因为
    Gradle 需要下载 App Engine SDK。我们之前通过 `downloadSdk = true` 设置了这种行为。要停止服务器，你可以使用 `appengineStop`。'
- en: Once you are ready to deploy your backend to Google App Engine and start using
    it in production, you can use `appengineUpdate`. This task handles all the deployment
    details. If you have set `oauth2 = true` in the `appengine` configuration block,
    this task will open a browser window, so you can log in to your Google account
    and get an authentication token. If you prefer not having to do this every time
    you need to deploy, you can log in to Android Studio with your Google account
    and use the IDE to deploy the backend. Android Studio runs the same Gradle task,
    but it will take care of the authentication for you.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你准备好将后端部署到 Google App Engine 并在生产中使用它，你可以使用 `appengineUpdate`。此任务处理所有部署细节。如果你在
    `appengine` 配置块中设置了 `oauth2 = true`，此任务将打开一个浏览器窗口，以便你可以登录到你的 Google 账户并获取一个身份验证令牌。如果你不希望每次部署时都这样做，你可以使用你的
    Google 账户登录到 Android Studio，并使用 IDE 部署后端。Android Studio 会运行相同的 Gradle 任务，但它将为你处理身份验证。
- en: Tips and best practices
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小贴士和最佳实践
- en: There are a few ways to make it easier to deal with multimodule projects, and
    there are a few things to keep in mind when working with several modules. Being
    aware of these can save you time and frustration.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种方法可以使处理多模块项目更容易，当与多个模块一起工作时，有一些事情需要记住。意识到这些可以节省你的时间和挫败感。
- en: Running module tasks from Android Studio
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 Android Studio 运行模块任务
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"),
    *Basic Build Customization*, it is possible to run Gradle tasks straight from
    Android Studio. When you have multiple modules, Android Studio recognizes them,
    and shows a grouped overview of all available tasks.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第 2 章](ch02.html "第 2 章。基本构建自定义")中看到的，*基本构建自定义*，你可以直接从 Android Studio
    运行 Gradle 任务。当你有多个模块时，Android Studio 会识别它们，并显示所有可用任务的分组概览。
- en: '![Running module tasks from Android Studio](img/B01061_05_03.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![从 Android Studio 运行模块任务](img/B01061_05_03.jpg)'
- en: The Gradle tool window makes it easier to run module-specific tasks. There is
    no option to run a task for all modules at the same time, so if you wish to do
    that, the command-line interface is still faster.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle 工具窗口使运行特定模块的任务变得更容易。没有选项可以同时为所有模块运行任务，所以如果你希望这样做，命令行界面仍然更快。
- en: Speeding up multimodule builds
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 加速多模块构建
- en: When you build a multimodule project, Gradle processes all modules sequentially.
    With more and more cores available in computers, we can make the build process
    a lot faster by building the modules in parallel. This feature already exists
    in Gradle, but is not enabled by default.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当你构建一个多模块项目时，Gradle会按顺序处理所有模块。随着计算机中可用核心数量的增加，我们可以通过并行构建模块来使构建过程更快。这个特性在Gradle中已经存在，但默认情况下并未启用。
- en: 'If you want to apply parallel build execution to your project, you need to
    configure the `parallel` property in the `gradle.properties` file on the root
    of the project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想将并行构建执行应用于你的项目，你需要在项目根目录下的`gradle.properties`文件中配置`parallel`属性：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Gradle attempts to choose the right number of threads, based on available CPU
    cores. To prevent issues that may arise from executing two tasks from the same
    module in parallel, each thread *owns* an entire module.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: Gradle会尝试根据可用的CPU核心数选择合适的线程数。为了避免在并行执行同一模块的两个任务时可能出现的問題，每个线程都“拥有”整个模块。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Parallel build execution is an incubating feature. This means that it is under
    active development and the implementation may change at any time. This feature
    has been a part of Gradle for a while now, though, and is already widely used.
    It is, therefore, safe to assume that the implementation will not disappear or
    change drastically.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 并行构建执行是一个孵化特性。这意味着它正在积极开发中，实现可能会随时更改。然而，这个特性已经存在于Gradle中一段时间了，并且已经被广泛使用。因此，可以假设实现不会消失或发生重大变化。
- en: Your mileage may vary, but you might be able to shave off a significant amount
    of time from your builds by simply enabling parallel build execution. There is
    one caveat, however. For this to work efficiently, you will need to make sure
    your modules are decoupled.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 你的体验可能会有所不同，但通过简单地启用并行构建执行，你可能会从构建中节省大量的时间。然而，有一个注意事项。为了有效地工作，你需要确保你的模块是解耦的。
- en: Module coupling
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块耦合
- en: As we saw in [Chapter 2](ch02.html "Chapter 2. Basic Build Customization"),
    *Basic Build Customization*, it is possible to define properties for all modules
    in a project, using `allprojects` in the `build.gradle` file. When you have a
    project with multiple modules, you can use `allprojects` in any module to apply
    properties to all the modules in the project. Gradle even makes it possible for
    one module to reference properties from another module. These powerful features
    can make maintenance for multimodule builds a lot easier. The downside, though,
    is that your modules become coupled.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第2章](ch02.html "第2章。基本构建定制")中看到的，*基本构建定制*，你可以使用`build.gradle`文件中的`allprojects`来为项目中的所有模块定义属性。当你有一个包含多个模块的项目时，你可以在任何模块中使用`allprojects`来将属性应用于项目中的所有模块。Gradle甚至使得一个模块可以引用另一个模块的属性。这些强大的功能可以使多模块构建的维护变得更加容易。然而，缺点是，你的模块变得耦合了。
- en: Two modules are considered to be coupled as soon as they access each other's
    tasks or properties. This has several consequences. For example, you give up portability.
    If you ever decide to extract a library out of the project, you will not be able
    to build the library before copying all project-wide settings first. Module coupling
    also has an effect on parallel builds. Using the `allprojects` block in any of
    the modules will render parallel build execution useless. Be aware of this when
    you add project-wide properties to any of the modules.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 两个模块一旦互相访问对方的任务或属性，就被认为是耦合的。这有几个后果。例如，你放弃了可移植性。如果你决定从项目中提取库，你必须先复制所有全局设置，然后才能构建库。模块耦合也会影响并行构建。在任何一个模块中使用`allprojects`块将使并行构建执行变得无用。当你向任何模块添加全局属性时，请注意这一点。
- en: You can avoid coupling by not directly accessing tasks or properties from other
    modules. If you need this behavior, you can use the root module as an intermediary
    so that modules are coupled only to the root module and not to each other.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过不直接从其他模块访问任务或属性来避免耦合。如果你需要这种行为，你可以使用根模块作为中介，这样模块就只与根模块耦合，而不是彼此耦合。
- en: Summary
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We started the chapter by looking at the structure of multimodule builds. Then,
    we looked at how to set up multiple modules in a single project. We also saw that
    adding new modules affects how build tasks are run.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从查看多模块构建的结构开始本章。然后，我们探讨了如何在单个项目中设置多个模块。我们还看到，添加新模块会影响构建任务的执行方式。
- en: We then looked at some practical examples of new modules, and how each of them
    can be integrated into a project. Finally, we mentioned some tips and tricks that
    make it easier to work with multiple modules in one project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后查看了一些新模块的实际示例，以及它们如何被整合到项目中。最后，我们提到了一些技巧和窍门，这些技巧和窍门使得在一个项目中使用多个模块变得更加容易。
- en: In the next chapter, we will set up various kinds of tests, and see how to use
    Gradle to make it easier to run these tests. We will look at running unit tests
    directly on the Java Virtual Machine, but also at running tests on a real device
    or an emulator.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将设置各种类型的测试，并探讨如何使用Gradle来简化这些测试的运行。我们将查看如何在Java虚拟机上直接运行单元测试，同时也会探讨如何在真实设备或模拟器上运行测试。
