<html><head></head><body><h1 id="e-aEBY">Chapter 4. Displaying User Profile</h1>
<p id="e-k1lC">In this chapter, we are going to extend our social application with user information fetched from the Facebook Platform. We are going to take a look at the types of information we can fetch with and without explicitly asking for the user's permission. We will learn how to fetch extra user information using <code>FBSession</code>.</p>
<h1 id="e-wCCq">Understanding Facebook Platform</h1>
<p id="e-o0Xy">The Facebook protects enforces a user's data through a permission system. In order to access a user's information, we need to ask the user to give the application permissions to fetch such data. You can find the whole list of user information at <a href="https://developers.facebook.com/docs/reference/api/user/.">https://developers.facebook.com/docs/reference/api/user/.</a></p>
<p id="e-guuc">When users log in to our system, they give the application permission to access their basic information. Basic information includes the following:</p>
<ul id="e-nnJL">
<li id="e-H4ag"><code>id</code></li>
<li id="e-RXBb"><code>name</code></li>
<li id="e-WZya"><code>first_name</code></li>
<li id="e-T0sS"><code>last_name</code></li>
<li id="e-zxpv"><code>link</code></li>
<li id="e-gmHw"><code>username</code></li>
<li id="e-cMFZ"><code>gender</code></li>
<li id="e-nKaJ"><code>locale</code></li>
<li id="e-t1xi"><code>age_range</code></li>
</ul>
<p id="e-xNoP">You can find basic information on friends at</p>
<p id="e-GVSt"><a href="https://developers.facebook.com/docs/reference/login/public-profile-and-friend-list/">https://developers.facebook.com/docs/reference/login/public-profile-and-friend-list/</a>.</p>
<p id="e-MV3N">If we are planning to use any other user information types, we will need to ask the user and be sure our application is smart enough to handle denied/revoked permissions.</p>
<p id="e-PCmm"><strong>Email</strong> is important information that needs to be carefully handled. Users need to give their permission to access such data. Do not spam the user's e-mail.</p>
<p id="e-QN43"><a href="https://developers.facebook.com/docs/reference/login/-permissions/">https://developers.facebook.com/docs/reference/login/-permissions/</a></p>
<p id="e-nwGQ"><strong>Extended Profile Properties</strong> permissions give access to the remaining fields not included in basic information. You can find complete information about Extended Profile properties at</p>
<p id="e-JCAW"><a href="https://developers.facebook.com/docs/reference/login/extended-profile-properties/">https://developers.facebook.com/docs/reference/login/extended-profile-properties/</a>.</p>
<p id="e-f286"><strong>Extended Permissions</strong> give access to sensitive information plus the ability to publish and delete data on the Social Graph. Information is available at</p>
<p id="e-H0C8"><a href="https://developers.facebook.com/docs/reference/login/extended-permissions/">https://developers.facebook.com/docs/reference/login/extended-permissions/</a>.</p>
<p id="e-zVGP"><strong>OpenGraph Permissions</strong> give the ability to interact with Open Graph. Users will be able to publish and retrieve actions on Open Graph through our application.</p>
<p id="e-VJlU"><a href="https://developers.facebook.com/docs/reference/login/open-graph-permissions/">https://developers.facebook.com/docs/reference/login/open-graph-permissions/</a></p>
<p id="e-MdHj">For the scope of this chapter, we will be using the user's basic and e-mail information to display in our application.</p>

<h1 id="e-vJFh">Setting up the user profile interface</h1>
<p id="e-XdwN">In the previous chapter, we implemented the Storyboard Facebook Scene to show the profile picture after a user has logged in. In this part of the chapter, we are going to extend the scene to include their name and e-mail.</p>
<p id="e-FDzr">The name information is already provided through the basic permissions. Now, for the user's e-mail, we will need to explicitly ask the user to give us access to it.</p>
<p id="e-r5lx">First, we need to add two new labels to our Facebook Scene to display the new information. The following figure shows the look of the scene after adding the labels:</p>
<img data-width="296" data-height="500" src="img/cIj0azJJ.jpg"/><p id="e-Qc2z">The new labels will be dynamically set with the user's information after the user logs in. When the user logs out, we will replace the name and e-mail info with empty strings.</p>
<p id="e-Rd1P">Click on the <strong>Show the Assistant Editor</strong> button, and drag-and-drop the labels one at a time within the <code>LBFacebookViewController.m</code> interface statement.</p>
<p id="e-WTQ9">The following code snippet shows the result of creating label references:</p>
<pre id="e-Rnsf">import "LBFacebookViewController.h"
#import &amp;lt;FacebookSDK/FacebookSDK.h&amp;gt;
 
@interface LBFacebookViewController () &amp;lt;FBLoginViewDelegate, FBFriendPickerDelegate, UIAlertViewDelegate&amp;gt;
 @property (weak, nonatomic) IBOutlet FBLoginView *fbLoginView;
 @property (weak, nonatomic) IBOutlet FBProfilePictureView *profilePictureView;
 @property (weak, nonatomic) IBOutlet UILabel *nameLabel;
 @property (weak, nonatomic) IBOutlet UILabel *emailLabel;
 @end</pre>
<p id="e-Me9H">Now that we have the label references for name and e-mail, we can fetch the user's information from Open Graph.</p>

<h1 id="e-JsTH">Fetching a user's information</h1>
<p id="e-SHyg">In this section, we are going to focus on implementing the code to show and hide a user's name and e-mail.</p>
<p id="e-HvsO">In the previous chapter, we created a delegate method for the <code>FBLoginView</code> component in the Facebook Scene to access a user's information. Hide <strong>Assistant Editor</strong> and open the <code>LBFacebookViewController.m</code> file. We need to add some code to the <code>loginViewFetchedUserInfo</code> method to customize the new labels.</p>
<p id="e-Ypur">Starting with customizing the name label, we can use the <code>(id&amp;lt;FBGraphUser&amp;gt;)user</code> input parameter provided by the method to access the user's name and set the label.</p>
<pre id="e-tREM">// delegate called after the application has received
// the user information from Facebook platform
- (void)loginViewFetchedUserInfo:(FBLoginView *)loginView user:(id&amp;lt;FBGraphUser&amp;gt;)user
{
  [self.profilePictureView setProfileID:user.id];
  self.nameLabel.text = user.name;
}</pre>
<p id="e-mv6D">The <code>self.nameLabel.test = user.name</code> code line will set the UI name label content with a user's name provided by the <code>FBLoginView</code> callback.</p>
<p id="e-AZFv">When the user logs out, we need to set the name label content with an empty string as follows:</p>
<pre id="e-P5j7">// delegate to handle the logged out mode
- (void)loginViewShowingLoggedOutUser:(FBLoginView *)loginView
{
  [self.profilePictureView setProfileID:nil];
  self.nameLabel.text = @"Name";
}</pre>
<p id="e-ORsH">The <code>self.nameLabel.test = @"Name"</code> instruction will set the name label back to the default content.</p>
<p id="e-l4ix">In order to fetch a user's e-mail, we first need to ask the user to give the application access to this information. We need to customize <code>FBLoginView</code> by adding the e-mail permission as follows:</p>
<pre id="e-k5B7">- (void)viewDidLoad
{
  [super viewDidLoad];
  
  [self.fbLoginView setDelegate:self];
  
  // setting email read permission
  NSArray *readPermissions = [NSArray arrayWithObject:@"email"];
  [self.fbLoginView setReadPermissions:readPermissions];
}</pre>
<p id="e-GGFY">The previous code snippet shows how to set additional permissions to <code>FBLoginView</code>. First define a list with read permissions that the application needs and set the <code>FBLoginView readPermissions</code> field with the created array.</p>
<p id="e-lwJq">The following screenshot shows the user permission interface with the additional e-mail request:</p>
<img data-width="307" data-height="650" src="img/BankWSko.jpg"/><p id="e-kDHS">If the user accepted the request, we can fetch the user information through the <code>FBLoginView</code> delegate using the following code:</p>
<pre id="e-q3Vm">// delegate called after the application has received
// the user information from Facebook platform
- (void)loginViewFetchedUserInfo:(FBLoginView *)loginView user:(id&amp;lt;FBGraphUser&amp;gt;)user
{
  [self.profilePictureView setProfileID:user.id];
  self.nameLabel.text = user.name;
  
  if ([user objectForKey:@"email"]) {
    self.emailLabel.text = [user objectForKey:@"email"];
  }
  
}
 // delegate to handle the logged out mode
- (void)loginViewShowingLoggedOutUser:(FBLoginView *)loginView
{
  [self.profilePictureView setProfileID:nil];
  self.nameLabel.text = @"Name";
  self.emailLabel.text = @"Email";
}</pre>
<p id="e-F5iI">The first method will fetch the e-mail field only if it is present in the Platform response. The second method will replace the user's e-mail with default content.</p>
<p id="e-Sk2F">The following screenshot shows the final result:</p>
<img data-width="308" data-height="650" src="img/KhYhdtDE.jpg"/>
<h1 id="e-A2Vg">Creating the friends view interface</h1>
<p id="e-FWRl">When we think about social activities, we think about sharing experiences and moments of life with our friends.</p>
<p id="e-VldD">In this part of the chapter, we are going to create a simple friend picker view controller. The controller will display all friends associated with our Facebook account and provide the ability to select one or more of them.</p>
<p id="e-iRLo">In the next chapters, we are going to use the friend picker to share parts of our information with them.</p>
<p id="e-Drz3">Using Version 2.x of the Facebook SDK, implementing the friends list would involve a lot of work compared to the new SDK. Building a friends list with the previous SDK would have involved the creation of a new UI component to display friends' information, for example, table view controller. The logic behind this is also challenging because we are supposed to handle the security token extension and parse the response in order to populate the friends list UI.</p>
<p id="e-bUdL">Creating a friends list is a completely different story with Facebook iOS SDK 3.x. With the Version 3.x of SDK, Facebook engineers worked really well to create flawless out-of-the-box, ready-to-use components. One such component is <code>FBFriendPickerViewController</code>.</p>
<p id="e-mHLy"><code>FBFriendPickerViewController</code> encapsulates user interaction and logic to handle a user's friends list. It will provide a table-like UI, because it inherits from <code>UITabelViewController</code>. The entire communication from/to Facebook Platform is completely handled by the new component.</p>
<p id="e-Utqh">Some of the customizations we can perform on <code>FBFriendPickerViewController</code> are the ability to sort by first or last name, changing the way friends' names are displayed, and so on.</p>
<p id="e-T8QQ">The following screenshot shows the final result of the UI using the new view controller:</p>
<img data-width="309" data-height="650" src="img/lxlO1N6Y.jpg"/><p id="e-rvHE">The friends list will only be enabled when the selected users are logged in.</p>

<h1 id="e-Vh6O">Creating the UI</h1>
<p id="e-AoDN">In order to display the friends list, we need to start by adding a new button to the Facebook UI. Open Storyboard and select the Facebook scene. Holding the <em>Ctrl</em> keyboard button, drag-and-drop a button from the <strong>Object Library</strong> and place it underneath the e-mail label. Set the label text, for example <strong>Friends</strong>, for the new button. Deselect the option <strong>Enabled</strong> by navigating to <strong>Utilities Panel</strong> | <strong>Attribute Inspector</strong>.</p>
<p id="e-Lbut">The screenshots 1 to 5 show the <strong>Attribute Inspector</strong> with the <strong>Enabled</strong> option not checked.</p>
<img data-width="700" data-height="234" src="img/IA6PwehN.jpg"/><p id="e-XBjV">The <strong>Friends</strong> button will trigger the code that will create an instance of <code>FBFriendPickerViewController</code> only if the user is already logged in; otherwise, it will be disabled. Since we need to enable and disable the button, we need to have a reference of the button in our <code>LBFacebookViewController</code>, which will be accessed using the <code>FBLoginView</code> delegates. To create the button reference, open the Assistant Editor and create the friends button reference by dragging and dropping the button within the <code>LBFacebookViewController</code> interface statement.</p>
<img data-width="800" data-height="334" src="img/OXMcGTgo.jpg"/><p id="e-X8tP">When the user clicks on the <strong>Friends</strong> button, it will trigger the code to create the friends list. To map the <code>click</code> event on the <strong>Friends</strong> button with the <code>LBFacebookViewController</code> method, hold the <em>Ctrl</em> keyboard button and drag-and-drop the button after the <code>loginViewShowingLoggedOutUser</code> method. XCode will ask for the name of the new method that will map the <strong>Touch Up Inside</strong> event.</p>
<img data-width="500" data-height="296" src="img/nt3OH8Kl.jpg"/><p id="e-bYTb">After we click on <strong>Connect</strong>, XCode will generate the method following the code:</p>
<pre id="e-tskO">- (IBAction)onFriendsClick:(id)sender {
  
}</pre>
<p id="e-Gxgj">The previous snippet will contain the code to show an instance of <code>FBFriendPickerViewController</code>.</p>
<h2 id="e-nXt7">Displaying FBFriendPickerViewController</h2>
<p id="e-MN6k">In order to show the UI friends list component, we need to keep an instance of <code>FBFriendPickerViewController</code> within <code>LBFacebookViewController</code>. Open the <code>LBFacebookViewController.m</code> file, and add a new instance of <code>FBFriendPickerViewController</code> within the <code>interface</code> statement.</p>
<p id="e-v9Tj">The following code shows the <code>interface</code> statement.</p>
<pre id="e-QQul">@interface LBFacebookViewController () &amp;lt;FBLoginViewDelegate, FBFriendPickerDelegate&amp;gt;
 @property (weak, nonatomic) IBOutlet FBLoginView *fbLoginView;
@property (weak, nonatomic) IBOutlet FBProfilePictureView *profilePictureView;
@property (weak, nonatomic) IBOutlet UILabel *nameLabel;
@property (weak, nonatomic) IBOutlet UILabel *emailLabel;
@property (weak, nonatomic) IBOutlet UIButton *friendPickerButton;
@property (strong, nonatomic) FBFriendPickerViewController *friendPickerViewController;
 @end</pre>
<p id="e-cKqO">We will notice that <code>FBFriendPickerViewController</code> is also a delegate of <code>FBFriendPickerViewController</code> as the previous code snippet is showing on the first line of the <code>interface</code> statement.</p>
<p id="e-ogdQ">Now we need to update the <code>onFriendsClick</code>method to initialize or re-use the <code>friendPickerViewController</code>property and display the friends list. The next application method shows the <code>onFriendsClick</code> method implementation.</p>
<pre id="e-Uw5n">#pragma mark - FBFriendPickerViewController
- (IBAction)onFriendsClick:(id)sender {
  if (self.friendPickerViewController == nil) {
    self.friendPickerViewController = [[FBFriendPickerViewController alloc] init];
    self.friendPickerViewController.title = @"Pick a Friend";
    [self.friendPickerViewController setDelegate:self];
  }
  
  [self.friendPickerViewController loadData];
  [self.friendPickerViewController clearSelection];
  
  [self presentViewController:self.friendPickerViewControlleranimated:YES completion:^{
    NSLog(@"Friends list ready");
  }];
}</pre>
<p id="e-C5xt">The first part of the method checks whether <code>friendPickerViewController</code> is already initialized. If it is not initialized, the method will allocate new memory for the instance and set title for the UI and current class as delegate for the friends list controller. The <code>loadData</code> method will load the friends' information from the Platform, or from the cache if it is still valid. The <code>clearSelection</code> method will clear the user selection if the friends list UI was already used. At the end of the method, we show the new view controller using the <code>presentViewController</code> method that will push the <code>FBFriendPickerViewController</code> view at the top of the UI stack.</p>
<p id="e-UCtY">As we said, <code>FBFriendPickerViewController</code> needs a delegate in order to interact with users and the rest of the application.</p>
<p id="e-IBty">For the scope of this chapter, we are going to use two delegate methods to handle the <strong>Done</strong> and <strong>Cancel</strong> button in <code>FBFriendPicker</code> view. In this chapter, the two delegate methods will only hide the friends list UI. The next code shows the delegate method for <code>FBFriendPickerViewController</code>.</p>
<pre id="e-A6Oz">#pragma mark - FBFriendPickerViewController delegate
- (void)facebookViewControllerDoneWasPressed:(id)sender {
  [self dismissViewControllerAnimated:YES completion:^{
    NSLog(@"Friend Picker Done Button Clicked");
  }];
}
 - (void)facebookViewControllerCancelWasPressed:(id)sender {
  [self dismissViewControllerAnimated:YES completion:^{
    NSLog(@"Friend Picker Cancel Button Clicked");
  }];
}</pre>
<p id="e-IAV5">Both delegate methods in the previous code call <code>dismissViewControllerAnimated</code> that will pop the friends list UI from the stack.</p>
<h2 id="e-iMw3">Customizing the friends list using a search bar</h2>
<p id="e-aVnW">In the previous section, we created the friends list UI that also includes the ability to navigate the user's friends list using the index on the right side of the interface.</p>
<p id="e-z3OA">Users have a lot of friends and sometimes the index cannot be fast enough. We would like to provide users with a search bar on top of the friends list.</p>
<p id="e-B5Td">We will start creating a new class that will inherit from <code>FBFriendPickerViewController</code>. The new class will contain a <code>UISearchBar</code> UI component, and because of it we need to set the same class as a <code>UISearchBar</code> delegate. While the user is typing within the search bar, the new class will filter the friends entries based on the search query content.</p>
<p id="e-fG8k">In order to create the new class, open the <strong>Project Navigator</strong> and select the <code>iLikeBook</code> folder within <strong>iLikeBook</strong> project. Right-click on it and select <strong>New File…</strong>, and then select the <code>Cocoa Touch</code> and <code>Objective-C class</code> templates. Click on <strong>Next</strong> and set the class name, for example <code>LBFriendPickerViewController</code>, and set <code>FBFriendPickerViewController</code> as a subclass. The new class will have the same functionalities and properties of <code>FBFriendPickerViewController</code>. Click on <strong>Next</strong> to create the file. We can now see two new files in the <strong>Project Navigator</strong>.</p>
<p id="e-PxhJ">In order to extend our new friend picker controller, we need two more properties as follows:</p>
<ul id="e-T0pk">
<li id="e-neiY">
<code>SearchText</code>: It is a variable that contains the current search query. The <code>Friend Picker</code> delegate will access it to filter out the friends that do not satisfy the search query.</li>
<li id="e-LaPR">
<code>UISearchBar</code>: It is the UI component that will allow the user to type the search query.</li>
</ul>
<p id="e-tayh"><code>SearchText</code>, as we mentioned in the preceding points, will be used to filter out friends from the <code>Friend Picker</code> list; therefore we can define it as public. Open the <code>LBFriendPickerViewController.h</code> file, and add the <code>SearchText</code>variable as a public field. The following listing shows it within the <code>LBFriendPickerViewController</code> class.</p>
<pre id="e-R1Em">#import &amp;lt;FacebookSDK/FacebookSDK.h&amp;gt;
@interface LBFriendPickerViewController : FBFriendPickerViewController
 // Keep track of user's search query
@property (strong, nonatomic) NSString *searchText;
 @end</pre>
<h3 id="e-Nlhm">Note</h3>
<p id="e-vtRM">For more information, you can check these two URLs: <a href="https://developers.facebook.com/docs/reference/ios/3.2/protocol/FBFriendPickerDelegate">https://developers.facebook.com/docs/reference/ios/3.2/protocol/FBFriendPickerDelegate</a></p>
<p id="e-Kns6"><a href="http://developer.apple.com/library/ios/#documentation/uikit/reference/UISearchBarDelegate_Protocol/Reference/Reference.html">http://developer.apple.com/library/ios/#documentation/uikit/reference/UISearchBarDelegate_Protocol/Reference/Reference.html</a></p>
<p id="e-oXEG">Now open <code>LBFriendPickerViewController.h</code>; we are going to implement the UI for friends search.</p>
<p id="e-u7Og">Start adding the <code>UISearchBar</code> component to the <code>interface</code> statement. We also need to define the current class as <code>UISearchBarDelegate</code> in order to capture the user's input as the following snippet:</p>
<pre id="e-gtZ4">@interface LBFriendPickerViewController () &amp;lt;UISearchBarDelegate&amp;gt;
 @property (weak, nonatomic) UISearchBar *searchBar;
 @end</pre>
<p id="e-a1uw">The <code>UISearchBar</code> will appear on top of the friends list, and the width will be exactly the same as the container view width. The bar will be built by the application after the container view loads.</p>
<img data-width="646" data-height="290" src="img/KAb33AEJ.jpg"/><p id="e-bp2u">Create an <code>init</code> method if one does not already exist. Within this method, call the parent <code>init</code> method and set the <code>searchBar</code> variable as <code>nil</code>, as displayed in the following code snippet.</p>
<pre id="e-dDkf">- (id)init
{
  self = [super init];
  if (self) {
    self.searchBar = nil;
  }
  return self;
}</pre>
<p id="e-dy2I">We need to customize the <code>viewDidLoad</code> method in order to build the <code>UISearchBar</code> on the friend picker view.</p>
<pre id="e-XqW2">- (void)viewDidLoad
{
  [super viewDidLoad];
  [self addSearchBarToFriendPickerView];
}</pre>
<p id="e-ZKij">The previous code shows the new <code>viewDidLoad</code> method with the new, not yet defined method <code>addSearchBarToFriendPickerView</code>. The new method initializes the <code>searchBar</code>, only if this one is set to <code>nil</code>. After the initialization is complete, the <code>searchBar</code> is added to the view container.</p>
<p id="e-abvT">The following snippet shows the <code>addSearchBarToFriendPickerView</code> implementation.</p>
<pre id="e-Dpex">- (void)addSearchBarToFriendPickerView
{
  if (self.searchBar == nil) {
    CGFloat searchBarHeight = 44.0;
    self.searchBar = [[UISearchBar alloc]initWithFrame:CGRectMake(0, 0, self.view.bounds.size.width,searchBarHeight)];
    self.searchBar.autoresizingMask =self.searchBar.autoresizingMask |UIViewAutoresizingFlexibleWidth;
    self.searchBar.delegate = self;
    self.searchBar.showsCancelButton = YES;
    
    // Adding the searchBar to the current view and resize thefriends' list table view
    [self.canvasView addSubview:self.searchBar];
    CGRect newFrame = self.view.bounds;
    newFrame.size.height -= searchBarHeight;
    newFrame.origin.y = searchBarHeight;
    self.tableView.frame = newFrame;
  }
}</pre>
<p id="e-w6qm">The preceding method first checks whether the <code>searchBar</code> is already initialized; if it is not, the method will do it. The <code>searchBarHeight</code> variable is the final height of <code>UISearchBar</code> that will be used as an input parameter to initialize the <code>searchBar</code> variable when creating a custom frame.</p>
<p id="e-J4cf">Moving forward, we will define <code>searchBar autoresizingMask</code> in order to have the same width as the view container. <code>UISearchBar</code> needs a delegate to access the user's search query; therefore we set a delegate. Using the <code>self.searchBar.showsCancelButton</code>instruction, we can set the <strong>Cancel</strong> button within the <code>UISearchBar</code> button as visible or hidden.</p>
<p id="e-E2fd">The <code>searchBar</code> component needs to be added to the current view. Since <code>LBFriendPickerViewController</code> is inheriting <code>FBFriendPickerViewController</code>, we can receive access to the parent view using the <code>self.canvasView</code> property. The <code>searchBar</code> component will be displayed on the top because we defined the frame with position (<code>0</code>, <code>0</code>).</p>
<p id="e-uaG8">After adding the search bar, we need to resize the friends table view height using <code>searchBarHeight</code>.</p>
<p id="e-hGvm">The UI part is now complete; we still need to take care of the communication between the <code>UISearchBar</code> and <code>LBFriendPickerViewController</code> classes.</p>
<p id="e-Ew0D">Create a helper method to handle the search, as shown in the following code sample:</p>
<pre id="e-vbSm">- (void)handleSearch: (UISearchBar *)searchBar {
  [NSObject cancelPreviousPerformRequestsWithTarget:selfselector:@selector(handleRealSearch:) object:searchBar];
  
  [self performSelector:@selector(handleRealSearch:)withObject:searchBar afterDelay:0.5f];
}
 - (void)handleRealSearch:(UISearchBar *)searchBar
{
  self.searchText = searchBar.text;
  [self updateView];
}</pre>
<p id="e-Q1Mk">The preceding method will set the <code>searchText</code> property with the current <code>UISearchBar</code> content value, and will call <code>updateView</code>. The  <code>UpdateView</code> method will call the <code>LBFriendPickerViewController</code> delegate method to filter out the users. We will dive into that method later in this section.</p>
<p id="e-qpd8"><code>UISearchBar</code> needs the delegate methods to handle a user's search. We need to create three delegate methods to handle the following:</p>
<ul id="e-QL9l">
<li id="e-wacD">Search bar text is changed.</li>
<li id="e-Phjg">
<strong>Search</strong> button is clicked.</li>
<li id="e-fl7f">
<strong>Cancel</strong> button is clicked.</li>
</ul>
<p id="e-zxbb">The text change method is pretty simple. While the user is typing, the application will dynamically filter out users. The code for the new delegate method is shown in the following snippet:</p>
<pre id="e-g1Dz">- (void)searchBar:(UISearchBar *)searchBar textDidChange:(NSString *)searchText
{
    [self handleSearch:searchBar];
}</pre>
<p id="e-sPwM">The <code>textDidChange</code> method uses the <code>handleSearch</code> helper to handle the search.</p>
<p id="e-Pn1D">To handle the <strong>Search</strong> button, click and create the method as shown in the following code:</p>
<pre id="e-M9zW">- (void)searchBarSearchButtonClicked:(UISearchBar*)searchBar
{
  [self handleSearch:searchBar];
  [searchBar resignFirstResponder];
}</pre>
<p id="e-nT0u">The only difference with the previous delegate method is the call to <code>resignFirstResponder</code> that will hide the keypad after clicking on the <strong>Search</strong> button.</p>
<p id="e-Zxom">The <strong>Cancel</strong> button method is more complicated; it will reset the <code>searchText</code> and <code>searchBar</code> content values as empty strings, update the view, and hide the keypad.</p>
<pre id="e-CYiO">- (void)searchBarCancelButtonClicked:(UISearchBar *) searchBar {
  self.searchBar.text = @"";
  [self handleSearch:searchBar];
  [searchBar resignFirstResponder];
}</pre>
<p id="e-v1iM">As a final touch, we need to override the <code>clearSelection</code> method to perform the parent duty and reset the  <code>searchText</code> and <code>searchBar</code> contents.</p>
<pre id="e-LQmQ">- (void)clearSelection
{
  [super clearSelection];
  self.searchText = nil;
  self.searchBar.text = @"";
}</pre>
<p id="e-iSIe">Now that we have the new friend picker controller, we need to use it. Previously, we used the <code>FBFriendPickerViewController</code> inside <code>LBFriendPickerViewController</code>.</p>
<p id="e-iQrb">Open <code>LBFriendPickerViewController.m</code> and replace the <code>FBFriendPickerViewController</code> property and its initialization with <code>LBFriendPickerViewController</code>, the new class just created. You should have only two occurrences of it.</p>
<pre id="e-CRbx">@property (strong, nonatomic) LBFriendPickerViewController *friendPickerViewController;
 self.friendPickerViewController = [[LBFriendPickerViewController alloc] init];</pre>
<p id="e-beqJ">The last method we need to implement is the delegate method to filter out the users from the friends list. At the end of the <code>LBFriendPickerViewController.m</code>, create the method shown in the following code snippet:</p>
<pre id="e-FWlo">- (BOOL)friendPickerViewController:(FBFriendPickerViewController *)friendPicker shouldIncludeUser:(id&amp;lt;FBGraphUser&amp;gt;)user
{
  NSString *searchText =self.friendPickerViewController.searchText;
  if (searchText &amp;amp;&amp;amp; ![searchText isEqualToString:@""]) {
    NSRange result = [user.namerangeOfString:searchTextoptions:NSCaseInsensitiveSearch];
    if (result.location != NSNotFound) {
    return YES;
  } else {
    return NO;
  }
} else {
  return YES;
}
return YES;
}</pre>
<p id="e-j0aG">The method listed in the preceding code will check each of the users in our friends list in order to find a match with the current user search query, and will return true and false. LBFriendPickerViewController and UISearchBar call this method.</p>
<p id="e-ALqY">The following screenshot shows the final result of the customization:</p>
<img data-width="307" data-height="650" src="img/X7clOEd2.jpg"/>
<h1 id="e-LHtH">Summary</h1>
<p id="e-iqJn">In this chapter we discussed which information we can fetch using basic permission. Using storyboard, we built the profile UI where we display the Facebook profile name and picture. Using <code>FBLoginView</code>, we implemented login and logout flows without handling Facebook session information.</p>
<p id="e-Gzio">We inserted a new button within the profile UI that will trigger a new modal view controller. The new controller inherits from <code>FBFriendPickerViewController</code> that will enable our social app to easily fetch the friends list.</p>
<p id="e-lK7L">We customized the friends list UI by inserting a new search component that we can use to filter friends based on the user's input.</p>
</body></html>