- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Event Sourcing and CQRS
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源和 CQRS
- en: 'The previous chapter, on **Domain-Driven Design** (**DDD**), laid the foundation
    for us to dive into two powerful architectural patterns that answer to the demand
    for scalable, responsive, and maintainable applications: **Event Sourcing** and
    **Command-Query Responsibility** **Segregation** (**CQRS**).'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章关于**领域驱动设计（DDD**）为我们奠定了基础，让我们深入探讨两种强大的架构模式，这些模式满足了可扩展、响应和可维护应用程序的需求：**事件源**和**命令-查询责任分离（CQRS**）。
- en: Firstly, we will explore the foundation of Event Sourcing. We will discuss how
    we can use Event Sourcing to model our domain, how to persist the state of your
    domain, and how to reconstruct the current state from the persisted events. We
    will explore the benefits of this approach.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将探讨事件源的基础。我们将讨论如何使用事件源来建模我们的领域，如何持久化领域状态，以及如何从持久化的事件中重建当前状态。我们将探讨这种方法的优点。
- en: Next, we will turn our attention to CQRS, examining how it separates the responsibilities
    of commands (write) and queries (read). We will discuss the key components of
    a CQRS architecture, including the command and query handlers, the domain model,
    and the event store. We will delve into the benefits of this separation.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将把注意力转向 CQRS，探讨它如何分离命令（写）和查询（读）的责任。我们将讨论 CQRS 架构的关键组件，包括命令和查询处理器、领域模型和事件存储。我们将深入探讨这种分离的优点。
- en: As we delve deeper, we will examine the practical considerations of implementing
    CQRS and Event Sourcing together, including data modeling, event schema design,
    and handling eventual consistency. We will also discuss strategies for integrating
    these patterns into your existing software ecosystem, ensuring a seamless and
    scalable transition.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们进一步深入，我们将检查实现 CQRS 和事件源相结合的实际考虑因素，包括数据建模、事件架构设计和处理最终一致性。我们还将讨论将这些模式集成到现有软件生态系统中的策略，确保无缝且可扩展的过渡。
- en: Through real-world examples and best practices, you will gain a comprehensive
    understanding of how CQRS and Event Sourcing can transform the way you approach
    software design and development. By the end of this chapter, you will be equipped
    with the knowledge and tools to harness the power of these patterns and unlock
    the full potential of your applications.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实际示例和最佳实践，您将全面了解如何将 CQRS 和事件源转化为您对软件设计和开发的方法。到本章结束时，您将具备利用这些模式的力量并释放应用程序全部潜能的知识和工具。
- en: 'We will go through the main topics in the following order:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将按照以下顺序介绍以下主要内容：
- en: Event Sourcing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件源
- en: Command-Query Responsibility Segregation (CQRS)
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令-查询责任分离（CQRS）
- en: Combining CQRS and Event Sourcing
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结合 CQRS 和事件源
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 上找到本章使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-9)
- en: Event Sourcing
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件源
- en: '**Event Sourcing** is a data management pattern, and its origin can be traced
    back to the 1990s, when engineers recognized the limitations of traditional data
    storage **Create, Read, Update, and Delete** (**CRUD**), particularly in the context
    of building complex and event-driven systems.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**事件源**是一种数据管理模式，其起源可以追溯到 20 世纪 90 年代，当时工程师认识到传统数据存储**创建、读取、更新和删除（CRUD**）的局限性，尤其是在构建复杂和事件驱动系统的背景下。'
- en: Event Sourcing has its roots in the principles of **Domain-Driven Design** (**DDD**),
    as covered in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289). DDD introduced
    the concept of an **Aggregate** as a fundamental building block of the domain
    model, and Aggregates usually need to be persisted in data storage.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源起源于领域驱动设计（**DDD**）的原则，如[*第 8 章*](B21737_08.xhtml#_idTextAnchor289)所述。DDD
    引入了**聚合**作为领域模型的基本构建块的概念，并且聚合通常需要保存在数据存储中。
- en: The classic CRUD approach and its limitations
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 经典的 CRUD 方法及其局限性
- en: 'The classic CRUD approach is sufficient for capturing the latest snapshot of
    an Aggregate by CRUD operations, usually with the use of a relational database.
    There are, however, limitations to this approach:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 经典的 CRUD 方法通过 CRUD 操作捕获聚合的最新快照是足够的，通常使用关系数据库。然而，这种方法存在局限性：
- en: '**History, auditability, and traceability**: While the CRUD approach can capture
    the current snapshot of an Aggregate, its ability to keep audit trails of all
    changes made to the Aggregate over time is limited.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**历史、可审计性和可追溯性**：虽然CRUD方法可以捕捉聚合体的当前快照，但其保留所有随时间对聚合体所做的变更的审计轨迹的能力有限。'
- en: This is usually overcome by custom data persistence code to keep historical
    records, or with the assistance of database update triggers. This can make it
    challenging to track the history of changes, understand how the system reached
    a particular state, and comply with regulatory requirements.
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这通常通过自定义数据持久化代码来保持历史记录，或者通过数据库更新触发器的辅助来实现。这可能会使得跟踪变更历史、理解系统如何达到特定状态以及遵守监管要求变得具有挑战性。
- en: '**Modeling complex domains**: CRUD-based systems work well with simple and
    straightforward data models, but they can struggle to effectively represent and
    manage the evolution of complex domain models over time.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**建模复杂领域**：基于CRUD的系统与简单直接的数据模型配合良好，但它们在有效表示和管理复杂领域模型随时间演进方面可能会遇到困难。'
- en: Traditionally, with the use of relational databases, a complex Aggregate object
    results in convoluted database schemas, complex data persistence operations, and
    difficulties in maintaining and evolving the system.
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传统上，使用关系型数据库时，复杂的聚合对象会导致复杂的数据库模式、复杂的数据持久化操作，以及维护和演进系统的困难。
- en: '**Event-driven capabilities**: The CRUD approach has no support for event-driven
    architectures, where the system needs to react to and propagate changes in a decoupled,
    scalable manner.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**事件驱动能力**：CRUD方法不支持事件驱动架构，在这种架构中，系统需要以解耦和可扩展的方式对变化做出反应并传播。'
- en: '**Concurrency and consistency**: CRUD-based systems often rely on traditional
    locking mechanisms to ensure data consistency, which often leads to performance
    bottlenecks in distributed, concurrent, and high-load environments.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发和一致性**：基于CRUD的系统通常依赖于传统的锁定机制来确保数据一致性，这往往会导致在分布式、并发和高负载环境中的性能瓶颈。'
- en: Maintaining strong consistency in the face of concurrent updates can be a significant
    challenge in CRUD systems.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在并发更新的情况下维护强一致性在CRUD系统中可能是一个重大的挑战。
- en: '**Versioning and evolution**: Updating and evolving CRUD-based systems can
    be problematic, as changes to the data model or business logic may require complex
    migrations and data transformations.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制和演进**：更新和演进基于CRUD的系统可能会出现问题，因为数据模型或业务逻辑的更改可能需要复杂的迁移和数据转换。'
- en: Versioning and handling historical data can also be more complicated in a CRUD-centric
    approach.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在以CRUD为中心的方法中，版本控制和处理历史数据也可能更加复杂。
- en: '**Analytics and reporting**: CRUD systems focus on the current snapshot of
    Aggregates, which can make it challenging to analyze, generate reports, or derive
    insights from the historical data of Aggregates.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分析和报告**：CRUD系统关注聚合体的当前快照，这可能会使得分析、生成报告或从聚合体的历史数据中提取洞察变得具有挑战性。'
- en: In the face of these challenges, the idea of capturing the full history of Aggregate
    changes began to gain traction.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 面对这些挑战，捕捉聚合体变更全历史的想法开始受到关注。
- en: Events as first-class citizens
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件作为一等公民
- en: Event Sourcing aims to solve these challenges by making events first-class citizens.
    The term *event* here entails the same concept as the *event* in DDD mentioned
    in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289). An event captures the change
    in an aggregate, making it a key element in this framework.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源旨在通过将事件作为一等公民来解决这些挑战。这里的“事件”一词与在[*第8章*](B21737_08.xhtml#_idTextAnchor289)中提到的DDD中的“事件”具有相同的概念。一个事件捕捉了聚合体的变化，使其成为该框架中的关键元素。
- en: Event Sourcing persists all the events of aggregates in an event store. There
    are no update or delete operations to an event because an event represents a change
    that has already happened to an aggregate. In other words, events are immutable
    and are stored as a journal in chronological order. Event stores are often not
    relational databases; they can be NoSQL databases or persistent queues.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源将聚合体的所有事件持久化存储在事件存储中。事件没有更新或删除操作，因为事件代表了已经发生变化的聚合体。换句话说，事件是不可变的，并且按时间顺序存储为日志。事件存储通常不是关系型数据库；它们可以是NoSQL数据库或持久队列。
- en: In contrast to CRUD, in which the latest snapshot of an aggregate is a first-class
    citizen, Event Sourcing derives the latest snapshot of an aggregate by replaying
    the events from the aggregate from the first to the last event. As a result, the
    full history of an aggregate is preserved and no custom code is required to provide
    an audit trail of the aggregate.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 与CRUD不同，在CRUD中，一个聚合的最新快照是一个一等公民，事件源通过从第一个事件到最新事件重放聚合中的事件来推导出聚合的最新快照。因此，聚合的完整历史被保留，并且不需要自定义代码来提供聚合的审计跟踪。
- en: Moreover, the history of an aggregate is captured as a linear timeline and naturally
    eliminates the challenge of keeping strong consistency with concurrent updates.
    There should be, however, version validation before a request to mutate an aggregate
    is accepted and eventually generates an event. This is to prevent the **Lost Update**
    problem, where concurrent updates of the same aggregate overwrite each other unknowingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，聚合的历史被捕获为一个线性时间线，并自然地消除了保持并发更新强一致性的挑战。然而，在接收对聚合进行更改的请求之前，应该进行版本验证，并最终生成事件。这是为了防止**丢失更新**问题，即并发更新相同聚合时，不知情地覆盖彼此。
- en: Functional representations of Event Sourcing
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件源的功能表示
- en: 'The idea of representing the state of a system as a sequence of immutable events
    aligns well with the functional programming paradigm. Aggregates and events are
    immutable. Each change is performed by creating a new version of an aggregate
    from an event through stateless functions. This can be expressed through two basic
    functions written as Kotlin lambdas:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将系统的状态表示为不可变事件的序列的想法与函数式编程范式很好地一致。聚合和事件都是不可变的。每次更改都是通过通过无状态函数从事件创建聚合的新版本来执行的。这可以通过两个基本函数表达，这两个函数被写成Kotlin
    lambda表达式：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first function creates an initial aggregate. Subsequently, the update functions
    take the current version of the aggregate and create a new version.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个函数创建一个初始聚合。随后，更新函数获取聚合的当前版本并创建一个新版本。
- en: An example of how a request is handled with Event Sourcing
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件源处理请求的一个示例
- en: Suppose there is a request to update an existing aggregate. The service that
    receives the request would need to get the latest version of the aggregate to
    validate the request. So, the service gets all the events for the aggregate from
    the event store.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 假设有一个请求要更新现有的聚合。接收请求的服务需要获取聚合的最新版本以验证请求。因此，服务从事件存储中获取聚合的所有事件。
- en: All the events are replayed to recreate the latest snapshot of the aggregate.
    Assuming the request is all good, the service creates a new event. The service
    then plays this event on the current aggregate and creates an updated version
    of the aggregate.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 所有事件都被重放以重新创建聚合的最新快照。假设请求一切正常，服务创建一个新事件。然后服务将此事件播放到当前聚合上，并创建聚合的更新版本。
- en: The transaction is committed by appending the new event in the event store.
    The updated version of the aggregate can be used as a response to the original
    requester.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在事件存储中附加新事件来提交事务。更新的聚合版本可以用作对原始请求者的响应。
- en: 'The whole interaction is illustrated as a sequence diagram, as shown in *Figure
    9**.1*:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 整个交互被表示为一个序列图，如图*图9.1*所示：
- en: '![Figure 9.1 – An example of Event Sourcing](img/B21737_09_1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1 – 事件源的一个示例](img/B21737_09_1.jpg)'
- en: Figure 9.1 – An example of Event Sourcing
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 事件源的一个示例
- en: It is important to point out that the aggregate is not directly updated by the
    service. It is achieved by the handling of the new event. Also, the event store
    is responsible for distributing the new event to subscribers that are interested
    in these events.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，聚合不是由服务直接更新的。这是通过处理新事件来实现的。此外，事件存储负责将新事件分发给对这些事件感兴趣的所有订阅者。
- en: Benefits of Event Sourcing
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件源的好处
- en: 'The benefits of Event Sourcing come from the persistence of full audit trails
    of an Aggregate:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源的好处来自于聚合完整审计跟踪的持久性：
- en: '**Full audit trails with intents**: Not only are the full audit trails of an
    aggregate preserved, but also the intent of each change is captured. The name
    of each event of the aggregate ideally should come from the ubiquitous language
    so it becomes a business-aware and user-friendly history.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**带有意图的完整审计跟踪**：不仅保留了聚合的完整审计跟踪，而且每个更改的意图也被捕获。聚合的每个事件的名称理想情况下应来自通用语言，使其成为业务感知和用户友好的历史。'
- en: '**Time travel**: With the full history captured as a linear sequence of events,
    it is possible to travel back in time to construct a historical representation
    of the aggregate. It helps engineers to reproduce a scenario that happened in
    the past for investigation and troubleshooting purposes. It also enables users
    to see the historical aggregate as a feature.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间旅行**：由于完整的历史被捕获为一系列线性的事件，因此可以回到过去构建聚合体的历史表示。这有助于工程师重现过去发生的场景，用于调查和故障排除。它还使用户能够将历史聚合体作为一个功能来查看。'
- en: '**Creation of read models**: Having multiple consumers of the same event of
    an Aggregate opens the door to multiple read models. Each read model consumes
    the same event but transforms it to meet its specific requirements. This approach
    provides diverse views tailored for particular business purposes.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建读取模型**：一个聚合体的事件有多个消费者时，就会开启多个读取模型的大门。每个读取模型都消费相同的事件，但将其转换为满足其特定需求。这种方法提供了针对特定商业目的的定制化视图。'
- en: Deciding whether Event Sourcing should be used
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 决定是否使用事件溯源
- en: Choosing Event Sourcing as the way to store aggregates and their audit trails
    should not be taken lightly. It is a fundamental shift in how we reason about
    data, and it requires noticeable effort to make it work.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 选择将事件溯源作为存储聚合体及其审计跟踪的方式不应轻率行事。这在我们对数据的推理方式上是一个根本性的转变，并且需要显著的努力才能使其工作。
- en: From the *YAGNI* principle we covered in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013),
    engineers should build the simplest things that work. When there is more than
    one solution, the simplest solution should be chosen.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们在[*第1章*](B21737_01.xhtml#_idTextAnchor013)中提到的*YAGNI*原则来看，工程师应该构建最简单可行的事物。当有多种解决方案时，应该选择最简单的解决方案。
- en: A simple solution is different from an easy solution
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案与容易的解决方案不同
- en: Simple solutions are not complicated or are straightforward to reason about.
    Easy solutions require less effort to make. Take the example of capturing a new
    field. If we believe that the field should belong to a new entity, then creating
    a new entity that has the field is the most intuitive and straightforward approach.
    However, a new entity may mean adding new database tables, new validations, and
    new exposed APIs. On the other hand, if we attach the new field to an existing
    entity, we only need to enhance the existing entity, database table, and APIs.
    There is less effort involved in coding and testing, even though the field does
    not belong to the existing entity. This is an easy solution as less effort is
    required, but it is not simple because it is not intuitive and is instead confusing
    to see the field in an entity to which it does not belong.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的解决方案不复杂，或者容易推理。容易的解决方案需要更少的努力来实现。以捕获一个新字段为例。如果我们认为该字段应该属于一个新实体，那么创建一个具有该字段的新实体是最直观和直接的方法。然而，新实体可能意味着添加新的数据库表、新的验证和新的公开API。另一方面，如果我们将新字段附加到现有实体上，我们只需要增强现有实体、数据库表和API。在编码和测试中涉及的精力更少，即使该字段不属于现有实体。这是一个容易的解决方案，因为需要的努力较少，但它并不简单，因为它不直观，而且看到不属于实体的字段会让人困惑。
- en: 'An decision tree to determine if an aggregate should use Event Sourcing is
    shown in *Figure 9**.2*:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9.2*展示了确定聚合体是否应该使用事件溯源的决策树：'
- en: '![Figure 9.2 – A decision tree whether to use Event Sourcing](img/B21737_09_2.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2 – 是否使用事件溯源的决策树](img/B21737_09_2.jpg)'
- en: Figure 9.2 – A decision tree whether to use Event Sourcing
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 是否使用事件溯源的决策树
- en: The most decisive factor is whether the aggregate being considered to use Event
    Sourcing belongs to a Generic subdomain or not. In [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289),
    we identified Core domains, Supporting subdomains, and Generic subdomains. A Generic
    subdomain has a high likelihood of being fully replaced by off-the-shelf software
    products, which makes the benefits of using Event Sourcing not significant.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 最决定性的因素是考虑使用事件溯源的聚合体是否属于通用子域。在[*第8章*](B21737_08.xhtml#_idTextAnchor289)中，我们确定了核心域、支持子域和通用子域。通用子域有很大可能性被现成的软件产品完全取代，这使得使用事件溯源的好处并不显著。
- en: If the aggregate involved belongs to either a Core domain or a Supporting subdomain,
    the next step in the consideration is whether it is required to keep the full
    audit trails of the aggregate. Full audit trails can be used for regulatory reporting,
    replaying events to get a particular historical state of the aggregate, or performing
    time-series data analysis. It is a powerful feature of Event Sourcing, but not
    all aggregates need such power.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果涉及的聚合属于核心域或支持子域，下一步考虑的是是否需要保留聚合的完整审计跟踪。完整审计跟踪可用于监管报告、回放事件以获取聚合的特定历史状态，或进行时间序列数据分析。这是事件源的一个强大功能，但并非所有聚合都需要这种功能。
- en: Another hint that helps when considering Event Sourcing is if there are multiple
    read models for the Aggregate. The definition of a read model here is the same
    as the read models that can be discovered during **Event Storming**, which was
    also covered in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有助于考虑事件源的提示是，如果聚合有多个读取模型。这里的读取模型定义与在**第8章**（[*Chapter 8*](B21737_08.xhtml#_idTextAnchor289)）中提到的**事件风暴**期间可以发现的读取模型相同。
- en: An aggregate that requires multiple read models can benefit from Event Sourcing.
    Each read model can consume the same event of the aggregate, but it transforms
    the data to its unique representation of the aggregate as a materialized view.
    Sometimes, a read model might even combine data from other aggregates or entities.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 需要多个读取模型的聚合可以从事件源中受益。每个读取模型都可以消费聚合的相同事件，但将其转换为聚合的物化视图的独特表示。有时，读取模型甚至可能结合来自其他聚合或实体的数据。
- en: Event Sourcing uses events extensively for each change in an aggregate, and
    events are often processed asynchronously. If the operations for the aggregate
    are predominately synchronous, it imposes challenges in implementing Event Sourcing
    for the aggregate. There are techniques to synchronously process events to update
    aggregates, and the implementation has a cost.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 事件源广泛使用事件来记录聚合的每个变化，事件通常异步处理。如果聚合的操作主要是同步的，那么在聚合中实现事件源会带来挑战。有技术可以同步处理事件以更新聚合，但实现会有成本。
- en: It is important to reiterate that this is just an example decision tree. Each
    organization may have other factors in its decision-making. Sometimes, it may
    even make a different decision given the same question.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要重申，这只是一个示例决策树。每个组织在决策中可能有其他因素。有时，即使面对相同的问题，也可能做出不同的决定。
- en: Usage of Event Sourcing with a real-life example
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用事件源的实际示例
- en: 'Let’s revisit the real-life example of villagers exchanging services, with
    the three bounded contexts identified in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下村民交换服务的实际示例，这是在**第8章**（[*Chapter 8*](B21737_08.xhtml#_idTextAnchor289)）中确定的三个边界上下文：
- en: 'Core domains: **Contract Service**'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 核心域：**合同服务**
- en: 'Supporting subdomain: **Household Service**'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 支持子域：**家庭服务**
- en: 'Generic subdomain: **Notification Service**'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用子域：**通知服务**
- en: Walking through the decision tree (see *Figure 9**.2*) mentioned in the previous
    section, Notification Service, as a Generic subdomain, can be safely ruled out
    from using Event Sourcing.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前一小节中提到的决策树（见*图9**.2*），作为通用子域的通知服务可以安全地排除使用事件源。
- en: Household as an aggregate in Household Service does not need to keep full audit
    trails because only the latest states of households are needed for business cases.
    The CRUD approach is sufficient.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在家庭服务中作为聚合的家庭户不需要保留完整审计跟踪，因为仅需要家庭户的最新状态来处理业务案例。CRUD方法就足够了。
- en: Contract as an aggregate in Contract Service may need to keep full audit trails
    because disputes are likely to arise between households on the agreements in the
    contract.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 作为合同服务中聚合的合同可能需要保留完整审计跟踪，因为家庭之间在合同协议上可能发生争议。
- en: There are also multiple read models involving contracts. The primary read model
    of a contract is the one that specifies the details of the contract between two
    households.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 还涉及多个涉及合同的读取模型。合同的主体读取模型是规定两个家庭之间合同细节的那个。
- en: There can also be a unilateral read model for each household. It contains a
    list of services that the household should provide and to which household. There
    is another list of services that the household expects to receive and from which
    household.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 每个家庭也可以有一个单方面的读取模型。它包含一个家庭应提供的服务列表以及应提供服务的家庭。还有一个列表，列出了家庭期望接收的服务以及期望提供服务的家庭。
- en: In addition, there is potential read model that aims to highlight the most wanted
    services in the village and the most active households in exchanging services.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个潜在的读取模型，旨在突出村庄中最受欢迎的服务和最活跃的服务交换家庭。
- en: The negotiation process of a contract involves multiple rounds of amendments
    until both households agree. When a contract is drafted by one household, an email
    is sent to another household asynchronously. During the negotiation process, any
    change made by one household results in an email notification to the other household
    involved. There are also multiple messages between two households in providing
    the services as per the contract. This asynchronous nature of communication suggests
    that a contract is a suitable candidate for using Event Sourcing in the Contract
    Service.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 合同的谈判过程涉及多轮修改，直到双方家庭达成一致。当一个家庭起草合同时，会异步地向另一个家庭发送电子邮件。在谈判过程中，一个家庭所做的任何更改都会导致涉及的家庭收到电子邮件通知。在根据合同提供服务的过程中，两个家庭之间也有多个消息。这种通信的异步性质表明，合同是合约服务中使用事件溯源的合适候选者。
- en: In this example, we are going to focus on using Event Sourcing to capture the
    full history of the aggregate contract in Contract Service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将专注于使用事件溯源来捕获合约服务中聚合合约的完整历史。
- en: 'Let’s revisit the aggregate contract as a data class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新审视聚合合约作为数据类：
- en: '[PRE1]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `Contract` data class contains an `id` field, which uniquely identifies
    this aggregate. There is also a field named `version`, which is a monotonic increasing
    integer that shows how many events have been played for this aggregate.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contract`数据类包含一个`id`字段，该字段唯一标识此聚合。还有一个名为`version`的字段，它是一个单调递增的整数，显示为该聚合播放了多少事件。'
- en: 'The basic construct of a `ContractEvent` should have the unique identifier
    of the aggregate and the time when the event happened:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContractEvent`的基本结构应包含聚合的唯一标识符和事件发生的时间：'
- en: '[PRE2]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It also has a target version, which is the version of the aggregate after the
    event is applied.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 它还有一个目标版本，这是事件应用后的聚合版本。
- en: 'In this example, we are using a simple in-memory event store. It has two basic
    functions. The `append` function adds a new event at the tail of the sequence
    by the aggregate ID, and the `get` function returns a chronological sequence of
    events given the aggregate ID:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个简单的内存事件存储。它有两个基本功能。`append`函数通过聚合ID在序列末尾添加新事件，而`get`函数根据聚合ID返回事件的按时间顺序的序列：
- en: '[PRE3]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If this is a real system, reputable event store middleware should be used to
    make it durable, highly available, and resilient.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是一个真实系统，应使用信誉良好的事件存储中间件来确保其持久性、高可用性和弹性。
- en: 'The creation of the aggregate contract starts with a household that has drafted
    a contract, and it should contain all the information required to create the first
    version of the aggregate:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 聚合合约的创建始于起草了合同的家庭，并且它应包含创建聚合第一个版本所需的所有信息：
- en: '[PRE4]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Contract Drafted Event` class should provide a function to create the
    aggregate. It is a simple function that puts the values into the appropriate structure:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contract Drafted Event`类应提供一个创建聚合的函数。这是一个简单的函数，将值放入适当的结构中：'
- en: '[PRE5]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Any subsequent event must take a parameter of the current version of the aggregate
    to generate a new version. For instance, an event that captures when a household
    amends and agrees to a drafted contract could look like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何后续事件都必须使用聚合的当前版本作为参数来生成新版本。例如，一个捕捉家庭修改并同意起草合同的事件的示例可能如下所示：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that this event does not necessarily follow the data structure of the
    aggregate. The key point is to keep the event lean and simple. So, this event
    only mentions one household, and it relies on the corresponding `play` function
    to apply the change correctly. Note that the `play` function takes a parameter
    of the current aggregate:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此事件不一定遵循聚合的数据结构。关键点是保持事件简洁简单。因此，此事件仅提及一个家庭，并依赖于相应的`play`函数来正确应用更改。注意，`play`函数接受当前聚合的参数：
- en: '[PRE7]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You will notice there is a `validate` function, which is important for ensuring
    data integrity:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到有一个`validate`函数，这对于确保数据完整性非常重要：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This `validate` function asserts that the event refers to the aggregate in the
    parameter. Then, it asserts that the current aggregate is one version lower than
    the target version of the event. Finally, it asserts that the involved household
    is mentioned in the aggregate contract.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 此`validate`函数断言事件引用的是参数中的聚合。然后，它断言当前聚合比事件的目标版本低一个版本。最后，它断言涉及的户主在聚合合同中被提及。
- en: 'There should be an iterative function that takes a list of `Contract Events`
    and eventually returns a `Contract` object:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应该有一个迭代函数，它接受一个`Contract Events`列表，并最终返回一个`Contract`对象：
- en: '[PRE9]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The function uses a `List` of contract events as the receiver. The return type
    is nullable in the case of an empty list. It assumes the first event is `ContractCreatedEvent`,
    which sets up the initial snapshot of the `Contract`. It loops from the second
    event to the last, generates a new version of the `Contract`, sets it as `current`
    to pass to the next event, and at the end returns the `Contract` object. An example
    of its usage is as follows. A list of events of the same aggregate is ordered
    and is played sequentially:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数使用合同事件的`List`作为接收者。在空列表的情况下，返回类型是可空的。它假设第一个事件是`ContractCreatedEvent`，它设置了`Contract`的初始快照。它从第二个事件循环到最后一个事件，生成一个新的`Contract`版本，将其设置为`current`以传递给下一个事件，并在最后返回`Contract`对象。其用法示例如下。同一聚合的事件列表是有序的，并且是顺序播放的：
- en: '[PRE10]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The code does not directly update the aggregate. Instead, it creates a few
    events and lets them play through. Eventually, the version should be `3` because
    the first version is `0`. The following should be printed to the console when
    the previous code is executed:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 代码不会直接更新聚合。相反，它创建了一些事件，并让它们通过。最终版本应该是`3`，因为第一个版本是`0`。当执行前面的代码时，以下内容应打印到控制台：
- en: '[PRE11]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example illustrates a simple form of Event Sourcing where each event generates
    a new version of the aggregate. These events should be persisted to an event store
    as permanent storage and be received by subscribers so other read models can be
    built upon.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例说明了事件溯源的一种简单形式，其中每个事件都会生成聚合的新版本。这些事件应持久化到事件存储中作为永久存储，并由订阅者接收，以便可以构建其他读取模型。
- en: In complex systems, processing an event could produce a list of events as reactions,
    and that would require a recursive function to walk through the processing. It
    may also require grouping related events as one transaction due to the chained
    reactions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂系统中，处理一个事件可能会产生一系列作为反应的事件，这需要递归函数来遍历处理。它还可能需要将相关事件分组为一个事务，因为连锁反应。
- en: Although the example here is simple, there are many ways Event Sourcing can
    go wrong. We are going to discuss some best practices that should be considered
    in the implementation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这里的例子很简单，但事件溯源可能会出错的方式有很多。我们将讨论一些在实现中应考虑的最佳实践。
- en: Event Sourcing best practices
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件溯源最佳实践
- en: Event Sourcing is a different way to reason about an aggregate in a domain from
    the classic CRUD approach. It only works if we design and architect our system
    with the mindset of events being first-class citizens. Otherwise, it could become
    an anti-pattern and undo all the benefits that it brings. Here are some of the
    fundamental best practices.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源是一种从经典CRUD方法中不同的方式来推理领域中的聚合。它只有在我们将系统和架构设计为将事件视为一等公民的心态时才有效。否则，它可能成为一种反模式，并抵消它带来的所有好处。以下是一些基本最佳实践。
- en: Randomization and idempotence
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 随机化和幂等性
- en: 'It is important that replaying the same sequence of events for an aggregate
    generates the same snapshot of the aggregate every time. In other words, the processing
    of events must be idempotent. There are two major factors that could violate this
    behavior: time and randomization.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个聚合，重新播放相同的事件序列每次都应该生成相同的聚合快照。换句话说，事件的处理必须是幂等的。有两个主要因素可能会违反这种行为：时间和随机化。
- en: 'If the event processing contains logic that makes use of the time the event
    is processed, then it will generate different results depending on the time of
    processing. For example, the following `expire` variable would have different
    Boolean values based on the system clock:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件处理包含利用事件处理时间的逻辑，那么它将根据处理时间生成不同的结果。例如，以下`expire`变量将根据系统时钟具有不同的布尔值：
- en: '[PRE12]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Any information related to the system clock should be stamped on the event instead.
    In this way, the result has been determined and will not change over time. Any
    time-based trigger or schedule job should obtain the system time and have the
    value captured in the events.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与系统时钟相关的任何信息都应该在事件上盖章。这样，结果就已经确定，并且不会随时间改变。任何基于时间的触发器或计划作业都应该获取系统时间，并将值捕获在事件中。
- en: 'Any randomization at the time of event processing will also generate different
    outcomes for each iteration. Values generated from randomization should be captured
    in the event payload, and there is no randomization involved in the event processing.
    If identifiers must be generated during the processing, they can be unique values
    within the scope of the event. Externally, they are used together with the event
    identifiers as composite keys. Here is an example:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 事件处理过程中的任何随机化都会在每次迭代中产生不同的结果。从随机化生成的值应该被捕获在事件有效负载中，事件处理过程中不涉及任何随机化。如果在处理过程中必须生成标识符，它们可以是事件范围内的唯一值。在外部，它们与事件标识符一起用作复合键。以下是一个例子：
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The value inside the event can be identified externally by concatenation of
    the event ID and the value ID inside the event, delimited by a hyphen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 事件内部的价值可以通过事件ID和事件内部的价值ID的连接来外部识别，这两个ID由连字符分隔。
- en: Event design
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件设计
- en: An event should have one and only one aggregate. Mixing multiple aggregates,
    whether they are of the same or different types, results in unnecessary coupling
    between aggregates. The coupling created by mixed aggregates in one event makes
    it difficult to scale events and their topics.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一个事件应该只有一个聚合。混合多个聚合，无论是同一类型还是不同类型，都会导致聚合之间不必要的耦合。在一个事件中由混合聚合产生的耦合使得扩展事件及其主题变得困难。
- en: There could be business cases where multiple aggregates are affected. In this
    scenario, multiple events should be created as a result, and each event describes
    what happened to each aggregate.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 可能存在多个聚合受到影响的情况。在这种情况下，应该创建多个事件作为结果，并且每个事件描述了每个聚合发生了什么。
- en: Each event should capture the intent of the change in an aggregate. For example,
    `ContractCreatedEvent` is a bad name because it does not describe why the aggregate
    contract is created. A better name would be in line with ubiquitous language,
    such as `ContractDraftedEvent`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 每个事件都应该捕捉到聚合变化的目的。例如，`ContractCreatedEvent`是一个不好的名称，因为它没有描述聚合合同创建的原因。更好的名称应该符合通用语言，例如`ContractDraftedEvent`。
- en: Event topologies
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件拓扑
- en: Events are published for subscribers to receive and can be logically grouped
    as **topics**. A topic here is not to be mistaken for the topic in traditional
    pub-sub messaging, in which messages are no longer in a topic once all subscribers
    acknowledge receipt. In Event Sourcing, events are meant to be kept permanently
    as an append-only and sequential log of events. For example, a Kafka topic with
    an infinite retention period can be used to keep events, and each topic represents
    a logical grouping of events.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 事件被发布供订阅者接收，并且可以逻辑上分组为**主题**。这里的主题不要与传统pub-sub消息中的主题混淆，在所有订阅者确认收到消息后，消息不再属于任何主题。在事件源中，事件旨在永久保留，作为事件的只追加和顺序日志。例如，一个具有无限保留期的Kafka主题可以用来保存事件，每个主题代表事件的逻辑分组。
- en: All events of one aggregate should only go to one topic only. This is to simplify
    creating and reading the linear history of an aggregate.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 一个聚合的所有事件应该只发送到一个主题。这是为了简化创建和读取聚合的线性历史。
- en: Spreading the events of an aggregate to multiple topics imposes difficulties
    in recreating the full history of an aggregate. It is also more difficult to scale
    performance and increase throughput, which are separate concerns from the event
    design.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 将聚合事件分散到多个主题会给重建聚合完整历史带来困难。这也使得性能扩展和吞吐量增加变得更加困难，这些都是与事件设计无关的独立问题。
- en: Event schema compatibility
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件模式兼容性
- en: As Event Sourcing intends to keep all historical events, it is important that
    all events are backward compatible; in other words, old events can still be read
    and processed when the event schema evolves.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件源旨在保留所有历史事件，因此所有事件都应该是向后兼容的；换句话说，当事件模式演变时，旧事件仍然可以被读取和处理。
- en: 'Maintaining backward compatibility is a big topic in itself. There are many
    things that can keep or break backward compatibility. Here are some examples:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 维护向后兼容性本身就是一个大话题。有许多因素可以保持或破坏向后兼容性。以下是一些例子：
- en: '**Keep**:'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持**：'
- en: Adding an optional field
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加可选字段
- en: Adding more enum values to a type
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向类型中添加更多枚举值
- en: Reducing the constraints of a field
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 减少字段的约束
- en: '**Break**:'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中断**：'
- en: Adding a mandatory field
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加必填字段
- en: Renaming a field
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重命名字段
- en: Changing the data type of a field
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 改变字段的类型
- en: Removing a field
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除字段
- en: Increasing the constraints of a field
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加字段的约束
- en: In the context of Event Sourcing, a backward-compatible event schema ensures
    that the system can always read the full history of an aggregate to re-create
    the latest snapshot of the aggregate.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件源的场景中，一个向后兼容的事件架构确保系统总能读取聚合的完整历史来重新创建聚合的最新快照。
- en: Forward and full compatibility
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 前向和完全兼容性
- en: Forward compatibility means that an old consumer can read and process events
    of a new schema. A fully compatible schema means it is both backward and forward
    compatible.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 前向兼容性意味着旧消费者可以读取和处理新架构的事件。完全兼容的架构意味着它既向后兼容又向前兼容。
- en: Performance and Memento
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能和备忘录
- en: While the current version of an aggregate can always be derived from all the
    events of that aggregate from the beginning of time, it is not always ideal to
    have to play these events if a current snapshot is requested.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然当前版本的聚合可以从该聚合从时间开始的所有事件中推导出来，但如果请求当前快照，则播放这些事件并不总是理想的。
- en: A performance optimization is to persist the latest version of the aggregate
    as a derived record. This pattern is called **Memento**. The usage of this pattern
    can be justified if current snapshots are frequently requested.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一种性能优化是将聚合的最新版本持久化为派生记录。这种模式称为**备忘录**。如果频繁请求当前快照，则使用此模式是有道理的。
- en: In the case of using events to recover the latest state of an aggregate, it
    may also be justified to use the Memento pattern. The reason for this is that
    the number of events will keep growing, and therefore the total time to replay
    all events will become longer and longer. Applying the Memento pattern changes
    the total time used for recovery versus number of events from linear to constant
    for a given aggregate.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用事件恢复聚合的最新状态的情况下，使用备忘录模式也可能是合理的。原因在于事件的数量会持续增长，因此重放所有事件的总时间会越来越长。应用备忘录模式将恢复所需的总时间与事件数量从线性变为对特定聚合的常数。
- en: Migration from CRUD
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从CRUD迁移
- en: Migrating an aggregate from CRUD to Event Sourcing is interesting in that usually,
    CRUD does not have full audit trails to allow a complete history to be rebuilt
    as events. Instead, the latest snapshots of aggregates are treated as the first
    versions, and then subsequent events are persisted.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 将聚合从CRUD迁移到事件源是有趣的，因为通常CRUD没有完整的审计跟踪来允许完全重建事件的历史。相反，聚合的最新快照被视为第一版本，然后后续事件被持久化。
- en: In this case, something like `ContractMigratedEvent` would be the first event.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，类似于`ContractMigratedEvent`的事件将是第一个事件。
- en: Moreover, the mutation of an aggregate will be done through the playing of events,
    not a direct update to the aggregate. As a result, any code that directly updates
    the aggregate will need to be deprecated.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，聚合的变更将通过事件的播放来完成，而不是直接更新聚合。因此，任何直接更新聚合的代码都需要被弃用。
- en: We have covered the basics of Event Sourcing with a real-life example and source
    code. There is another architectural pattern that works with Event Sourcing and
    is also based on DDD. We are going to cover this pattern now.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过一个真实世界的示例和源代码介绍了事件源的基本知识。还有一个与事件源一起工作且基于领域驱动设计（DDD）的架构模式。我们现在将介绍这个模式。
- en: Command-Query Responsibility Segregation (CQRS)
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 命令-查询责任分离（CQRS）
- en: 'The origin of CQRS can be traced back to another design pattern called **Command
    Query Separation** (**CQS**). CQS is the core concept that defines two types of
    operations handled in a system: a command that executes a task, and a query that
    returns information, and there should never be one function that does both jobs.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS的起源可以追溯到另一个称为**命令查询分离**（**CQS**）的设计模式。CQS是定义系统中处理两种类型操作的核心概念：执行任务的命令和返回信息的查询，并且不应该有一个函数同时执行这两项工作。
- en: The term CQS was created by Bertrand Meyer in his book *Object-Oriented Software
    Construction* in 1988\. He created it as part of his work on the Eiffel programming
    language.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 术语CQS是由伯特兰·梅耶在1988年他的书《面向对象软件构造》中提出的。他将其作为他在Eiffel编程语言上的工作的一部分。
- en: CQRS takes the defining principle of CQS and extends it to specific objects
    within a system, one retrieving data and one modifying data. CQRS is a broader
    architectural pattern, and CQS is the general principle of behavior.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 将 CQS 的定义原则扩展到系统中的特定对象，一个用于检索数据，一个用于修改数据。CQRS 是一个更广泛的架构模式，而 CQS 是行为的一般原则。
- en: The term CQRS was coined by Greg Young in 2010\. Since then, CQRS has gained
    traction, and various frameworks and libraries have been developed to support
    the pattern’s implementation in popular languages such as Java and .NET.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 术语 CQRS 由 Greg Young 在 2010 年提出。从那时起，CQRS 获得了关注，并开发了各种框架和库来支持在 Java 和 .NET 等流行语言中实现该模式的实现。
- en: 'There are four basic elements in CQRS: **aggregate**, **query**, **command**,
    and **event**.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 有四个基本元素：**聚合体**、**查询**、**命令**和**事件**。
- en: Aggregate
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 聚合
- en: Aggregate in CQRS has the same meaning as in Event Sourcing and DDD. It is an
    aggregated entity that represents the current state of the domain model. The aggregate
    contains a basket of other entities and value objects to represent a domain concept
    as defined in ubiquitous language.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CQRS 中，聚合体的含义与事件源和 DDD 中相同。它是一个表示领域模型当前状态的聚合实体。聚合体包含一系列其他实体和值对象，以表示通用语言中定义的领域概念。
- en: Query
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查询
- en: A query is a request from clients to retrieve a representation of the state
    of the domain model. Handling queries is a read-only operation and does not change
    the state of any aggregate. However, queries may be targeted to a certain read
    model related to an aggregate.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 查询是客户端请求检索领域模型状态的表示。处理查询是只读操作，不会改变任何聚合体的状态。然而，查询可能针对与聚合体相关的特定读取模型。
- en: Command
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 命令
- en: A command is a request from clients intending to change the state of an aggregate
    in the domain model. The intention is handled to determine whether the state should
    be changed and how. A command may only contain the necessary information for the
    change, and not the whole aggregate in the request.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 命令是客户端请求意图改变领域模型中聚合体的状态。处理意图以确定是否应该更改状态以及如何更改。命令可能只包含更改所需的信息，而不是请求中的整个聚合体。
- en: Event
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件
- en: An event is a confirmed and immutable change of the state of an aggregate. An
    event can be created because of a command, or because of the handling of another
    event. This is the same as the concept of events in DDD and Event Sourcing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 事件是聚合体状态的确认和不可变更改。事件可以由命令创建，也可以由处理另一个事件创建。这与 DDD 和事件源中的事件概念相同。
- en: How CQRS breaks down CRUD
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS 如何分解 CRUD
- en: CQRS has broken down the classic CRUD into many small queries, commands, and
    events. Each of them carries a precise meaning of what is happening, to the point
    that it matches the ubiquitous language.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 将经典的 CRUD 分解成许多小的查询、命令和事件。每个都精确地表达了正在发生的事情，以至于它与通用语言相匹配。
- en: Take the real-life example of the negotiation process of a service contract
    between two households. Both households can amend the contract and eventually
    agree to it.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以两个家庭之间服务合同的谈判过程为例。两个家庭都可以修改合同，并最终达成一致。
- en: '![Figure 9.3 – CRUD versus CQRS – update versus command](img/B21737_09_3.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – CRUD 与 CQRS – 更新与命令](img/B21737_09_3.jpg)'
- en: Figure 9.3 – CRUD versus CQRS – update versus command
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – CRUD 与 CQRS – 更新与命令
- en: In CRUD style, both amendments to and agreement of a contract result in a request
    to update the contract, and the difference is the content of the contract. In
    CQRS style, amendments and agreements have dedicated commands to capture not only
    what needs to be updated, but also the intent and business context of the update.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在 CRUD 风格中，合同的修改和同意都导致更新合同的请求，区别在于合同的内容。在 CQRS 风格中，修改和同意有专门的命令来捕捉不仅需要更新的内容，还包括更新的意图和业务背景。
- en: The CQRS style results in the amendment and agreement operations being separated.
    This leads to a cleaner and more modular design. The separation also allows independent
    scaling and the optimization of commands.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 风格导致修改和同意操作被分离。这导致设计更加清晰和模块化。分离还允许独立扩展和命令的优化。
- en: On the query side, as shown in the following figure, households A and B can
    get the contract between them by using a CRUD read request, and the responses
    will be the same for both households. However, the CQRS query allows multiple
    read models, and in this case, it can return a custom read model depending on
    which household makes the query.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在查询方面，如图所示，家庭 A 和 B 可以通过使用 CRUD 读取请求来获取它们之间的合同，并且对两个家庭来说，响应将是相同的。然而，CQRS 查询允许多个读取模型，在这种情况下，它可以返回一个根据哪个家庭发起查询而定的自定义读取模型。
- en: '![Figure 9.4 – CRUD versus CQRS – read versus query](img/B21737_09_4.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – CRUD 与 CQRS – 读与查询](img/B21737_09_4.jpg)'
- en: Figure 9.4 – CRUD versus CQRS – read versus query
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – CRUD 与 CQRS – 读与查询
- en: The CQRS style can build a materialized view for each household as a read model
    by consuming the events produced when a command is accepted. In CRUD style, these
    custom views are typically implemented using SQL commands and the custom views
    do not materialize.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 风格可以通过消费命令接受时产生的事件为每个家庭构建一个物化视图作为读取模型。在 CRUD 风格中，这些自定义视图通常使用 SQL 命令实现，并且这些自定义视图不会物化。
- en: A materialized read model can scale independently without concerns for commands.
    For example, if the read-write ratio of the aggregate contract heavily tilts towards
    reading, then it is sensible to consider materializing the corresponding read
    model in a separate data store infrastructure, so the writing is not affected
    even under a heavy load of query operations.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 物化读取模型可以在不担心命令的情况下独立扩展。例如，如果聚合体合同的读写比严重偏向于读取，那么在单独的数据存储基础设施中物化相应的读取模型是合理的，这样即使在查询操作的重压下，写入也不会受到影响。
- en: As read models are materialized by consuming events via asynchronous messaging,
    changes in the aggregates may not be immediately reflected in the read models
    but will eventually be synchronized.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于读取模型是通过异步消息消费事件而物化的，因此聚合体的变化可能不会立即反映在读取模型中，但最终会同步。
- en: It is important to point out that handling commands does need some existing
    information for validation, integrity checks, and concurrency control. These read
    operations are necessary for handling commands, but not for serving requests.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 需要指出的是，处理命令确实需要一些现有信息进行验证、完整性检查和并发控制。这些读取操作对于处理命令是必要的，但不是用于服务请求。
- en: When should CQRS be considered?
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时应考虑使用 CQRS？
- en: Like Event Sourcing, CQRS should be considered when a couple of prerequisites
    are met and there are legitimate problems that can be solved by CQRS. CQRS is
    a paradigm shift in how we reason about a system, and significant effort is required
    to implement it correctly. Applying CQRS to the wrong system increases the complexity
    with no benefits.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 与事件溯源一样，当满足一些先决条件并且存在可以通过 CQRS 解决的合法问题时，应考虑使用 CQRS。CQRS 是我们思考系统的一种范式转变，正确实现它需要付出巨大的努力。将
    CQRS 应用于错误系统会增加复杂性而没有带来任何好处。
- en: CQRS is an architectural pattern built upon DDD. If the current system has no
    concept of DDD, bounded contexts, or aggregates, then it is a non-starter. Even
    if the system includes bounded contexts, using CQRS may not be necessary for generic
    subdomains due to their limited complexity. CQRS is most likely beneficial only
    for core domains, where the domain itself is complex enough to warrant its use.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 是建立在 DDD（领域驱动设计）基础上的架构模式。如果当前系统没有 DDD、边界上下文或聚合的概念，那么它就不是一个起点。即使系统包括边界上下文，由于它们的复杂性有限，对于通用子域来说，使用
    CQRS 可能并不必要。CQRS 最有可能对核心域有益，因为域本身足够复杂，足以证明其使用价值。
- en: 'There are, however, a few signs that CQRS can be considered in the domain:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有几个迹象表明可以在领域内考虑使用 CQRS：
- en: Multiple actors working on the same aggregate. This usually means not all actors
    are concerned with everything in an aggregate. Some actors may work on a part
    of an aggregate but not all of it.
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多个角色在同一个聚合体上工作。这通常意味着并非所有角色都关心聚合体中的每一件事。一些角色可能只处理聚合体的一部分，而不是全部。
- en: Multiple use cases of updating the aggregate. There are specific use cases in
    which only a part of the aggregate should be updated.
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新聚合体的多种用例。存在一些特定的用例，其中只需要更新聚合体的一部分。
- en: Multiple views of the same aggregate. There are alternate views of the same
    aggregate, and sometimes there may even be a view combining multiple entities
    that deviate from the aggregate.
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同一个聚合体的多个视图。存在同一聚合体的替代视图，有时甚至可能有一个结合多个实体的视图，这些实体与聚合体有所偏离。
- en: Imbalanced read-write ratio. If either read or write operations are significantly
    more frequent than the other, read and write would need to be scaled differently
    as their needs are different.
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 读写比例不平衡。如果读取或写入操作比另一个操作显著频繁，那么读取和写入需要以不同的方式扩展，因为它们的需求不同。
- en: Benefits and costs of CQRS
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: CQRS 的益处和成本
- en: CQRS separates the concerns of read (query) and write (command) operations so
    their requirements can be met in isolation. This leads to smaller code footprints
    per function or per class, but there will be more functions or classes due to
    the separation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 将读取（查询）和写入（命令）操作的关注点分开，以便它们可以独立满足需求。这导致每个函数或类都有更小的代码量，但由于分离，会有更多的函数或类。
- en: This separation drives the code toward the **Single Responsibility Principle**
    (**SRP**), as mentioned in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045), where
    there should be one and only one reason to change a class. Each use case for each
    actor has its own class, either as a query or as a command.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这种分离推动了代码向**单一职责原则**（**SRP**）发展，正如在[*第二章*](B21737_02.xhtml#_idTextAnchor045)中提到的，即应该只有一个理由来更改一个类。每个演员的每个用例都有自己的类，无论是作为查询还是作为命令。
- en: The separation of queries and commands enables independent performance optimization,
    resulting in improved system performance and scalability overall. For example,
    queries can be optimized for faster execution due to the dedicated read models,
    and commands can be optimized for high throughput and consistency. However, this
    also results in more moving parts in the system and thus increases its complexity.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和命令的分离使得独立性能优化成为可能，从而在整体上提高了系统性能和可扩展性。例如，由于有专门的读取模型，查询可以优化以实现更快的执行，而命令可以优化以实现高吞吐量和一致性。然而，这也导致系统中移动部件增多，从而增加了其复杂性。
- en: Queries and commands are broken down into their own functions or classes. This
    means that extending functionality is unlikely to need to change existing queries
    and commands, and therefore it is easier than in CRUD, where there is a big repository
    class that contains all the CRUD operations.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 查询和命令被分解为其自己的函数或类。这意味着扩展功能不太可能需要更改现有的查询和命令，因此比 CRUD 更容易，在 CRUD 中有一个包含所有 CRUD
    操作的大仓库类。
- en: Dedicated queries and commands for each business case eliminate the need for
    clients to deal with unrelated fields and details about an aggregate, or to create
    a CRUD-style update or read request. This is in line with the **Interface Segregation
    Principle** (**ISP**), as mentioned in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045),
    where a client is not forced to depend on fields and functions it does not use.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 为每个业务案例提供专门的查询和命令消除了客户端处理与聚合无关的字段和细节，或创建 CRUD 风格的更新或读取请求的需要。这与在[*第二章*](B21737_02.xhtml#_idTextAnchor045)中提到的**接口隔离原则**（**ISP**）相一致，即客户端不应被迫依赖于它不使用的字段和函数。
- en: Supporting multiple read models using CRUD is challenging. It often requires
    complicated SQL statements to join relevant data together. Moreover, it is difficult
    to optimize performance as different read models have different needs. Quite often,
    compromises are made so that different read models have reasonably acceptable
    performance.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CRUD 支持多个读取模型具有挑战性。这通常需要复杂的 SQL 语句来联合相关数据。此外，由于不同的读取模型有不同的需求，优化性能也变得困难。很多时候，需要做出妥协，以便不同的读取模型具有合理可接受的性能。
- en: Using CQRS, read models are materialized by consuming the events of aggregates.
    They have their own storage so they can scale and optimize performance that is
    unique to the non-functional requirements. This comes at the cost of the replication
    of data in various forms, and more storage is needed to keep these read models.
    Also, each read model requires its own code to transform the event and persist
    data that’s relevant to its data structure.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 CQRS，读取模型通过消费聚合的事件来实现。它们有自己的存储，因此可以扩展并优化针对非功能性需求的独特性能。这以在多种形式复制数据为代价，并且需要更多的存储来保持这些读取模型。此外，每个读取模型都需要自己的代码来转换事件并持久化与其数据结构相关的数据。
- en: You may recognize the synergy between CQRS and Event Sourcing at this point.
    We are going to illustrate how they work together with a concrete example.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了 CQRS 和事件溯源之间的协同作用。我们将通过一个具体的例子来说明它们是如何一起工作的。
- en: Combining CQRS and Event Sourcing
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合 CQRS 和事件溯源
- en: CQRS and Event Sourcing are complementary patterns that work well together in
    building robust, scalable, and maintainable distributed systems.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS和事件溯源是互补的模式，在构建健壮、可扩展和可维护的分布式系统时协同工作得很好。
- en: 'The **command handler** in the CQRS architecture is responsible for validating
    write requests. If a command is valid, an event is persisted to an event store,
    which is the core of the Event Sourcing pattern. An example of how the CQRS command
    and Event Sourcing integrate is shown in *Figure 9**.5*:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在CQRS架构中，**命令处理器**负责验证写请求。如果命令有效，则将事件持久化到事件存储中，这是事件溯源模式的核心。CQRS命令和事件溯源如何集成的示例显示在*图9.5*中：
- en: '![Figure 9.5 – CQRS command and Event Sourcing](img/B21737_09_5.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – CQRS命令和事件溯源](img/B21737_09_5.jpg)'
- en: Figure 9.5 – CQRS command and Event Sourcing
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – CQRS命令和事件溯源
- en: The **service** receives a command from the **requester**. The **service** requires
    the current state of the aggregate, which is rebuilt by replaying events retrieved
    from the **Event Store**. The **command** passes the validation, so a new event
    is generated. The new event is played on the aggregate to generate a new state.
    The new event is appended to the **Event Store** and the updated aggregate is
    returned to the **requester**.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**服务**从**请求者**接收命令。**服务**需要聚合的当前状态，该状态通过重新播放从**事件存储**检索的事件来重建。**命令**通过验证，因此生成新的事件。新事件在聚合上播放以生成新状态。新事件附加到**事件存储**，并将更新的聚合返回给**请求者**。'
- en: Event Sourcing answered the question from CQRS of how to update an aggregate
    and inform subscribers of the changes to an aggregate. CQRS answered the question
    from Event Sourcing of how an event was created.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源回答了CQRS如何更新聚合并通知订阅者聚合变化的问题。CQRS回答了事件溯源如何创建事件的问题。
- en: 'The query, in turn, rebuilds the current state of the application by replaying
    the events stored in the event store. Also, multiple read models are rebuilt by
    transforming the event payloads to build their unique data structures. An example
    of how CQRS query and Event Sourcing integrate is shown in *Figure 9**.6*:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 查询反过来通过重新播放存储在事件存储中的事件来重建应用程序的当前状态。此外，通过将事件有效负载转换为构建它们独特的数据结构，重建多个读取模型。CQRS查询和事件溯源如何集成的示例显示在*图9.6*中：
- en: '![Figure 9.6 – CQRS query and Event Sourcing](img/B21737_09_6.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – CQRS查询和事件溯源](img/B21737_09_6.jpg)'
- en: Figure 9.6 – CQRS query and Event Sourcing
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – CQRS查询和事件溯源
- en: Event Sourcing provides a way for a CQRS query to rebuild a snapshot of a given
    aggregate. It enables the query to build any given read model as per the request.
    It also permits building a historical view of the aggregate from a given timestamp.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 事件溯源提供了一种方法，使CQRS查询能够重建给定聚合的快照。它使查询能够根据请求构建任何给定的读取模型。它还允许从给定的时间戳构建聚合的历史视图。
- en: This separation of concerns between the command and query models, combined with
    the event-driven nature of Event Sourcing, allows highly scalable, flexible, and
    maintainable systems that can easily adapt to changing business requirements.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 命令和查询模型之间的关注点分离，加上事件溯源的事件驱动特性，允许高度可扩展、灵活和可维护的系统，这些系统可以轻松适应不断变化的企业需求。
- en: Using CQRS and Event Sourcing together
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CQRS和事件溯源
- en: 'Extending from the previous example of Event Sourcing, adding CQRS would require
    a couple of command and query classes to be created. We will need a class to capture
    the query of the current state of a contract among households and a class to capture
    the command for drafting a contract. The corresponding code is shown here:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 从事件溯源的先例扩展，添加CQRS需要创建几个命令和查询类。我们需要一个类来捕获家庭之间合同当前状态的查询，以及一个类来捕获起草合同的命令。相应的代码如下：
- en: '[PRE14]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You will find these command classes look quite like the event classes. The
    differences are as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现这些命令类看起来很像事件类。区别如下：
- en: The command that creates the aggregate does not contain the aggregate ID
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建聚合的命令中不包含聚合ID
- en: The command does not contain the aggregate version or the timestamp
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命令中不包含聚合版本或时间戳
- en: This is because the aggregate ID, version, and timestamp are populated when
    handling the commands. In this example, command handling is not idempotent. It
    uses randomization for aggregate IDs and a system clock to stamp timestamps.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在处理命令时填充了聚合ID、版本和时间戳。在这个例子中，命令处理不是幂等的。它使用随机化聚合ID和系统时钟来标记时间戳。
- en: There could be various implementations that supply random values and system
    timestamps to make command handling idempotent. Both approaches can be justified
    if they are consistent and well understood.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有各种实现来提供随机值和系统时间戳，以使命令处理具有幂等性。如果它们是一致的并且被充分理解，这两种方法都可以被证明是合理的。
- en: 'In this example, the handling of every command has two potential outcomes.
    A successful outcome creates an event, and this event needs to be persisted. A
    failure outcome will inform the callers of the cause, and no event will be created.
    It is necessary to have a class to encapsulate the information for a failure outcome:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，每个命令的处理都有两种潜在的结果。成功的结果会创建一个事件，并且这个事件需要被持久化。失败的结果会通知调用者原因，并且不会创建事件。需要有一个类来封装失败结果的信息：
- en: '[PRE15]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Failure` class contains the original request, an optional message, and
    an optional `Throwable` object.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`Failure`类包含原始请求、可选消息和可选的`Throwable`对象。'
- en: 'Each query and command requires a handler. Taking advantage of the `EventStore`
    class in the example of Event Sourcing, the query handler is straightforward with
    the use of Kotlin extensions and the event store as a parameter:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 每个查询和命令都需要一个处理程序。利用事件源示例中的`EventStore`类，查询处理程序使用Kotlin扩展和事件存储作为参数，操作简单：
- en: '[PRE16]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The query handler simply gets all the events for the given `contractId` and
    then plays all events to re-create the latest version of `Contract` as the return
    value.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 查询处理程序简单地获取给定`contractId`的所有事件，然后播放所有事件以重新创建`Contract`的最新版本作为返回值。
- en: 'The command handler has two main styles: creating and updating. The handler
    for the creation command generates a random **Universally unique identifier**
    (**UUID**) and the timestamp. These fields are captured in the creation event:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序有两种主要风格：创建和更新。创建命令的处理程序生成一个随机的**通用唯一标识符**（**UUID**）和时间戳。这些字段被捕获在创建事件中：
- en: '[PRE17]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The command handler requires two callback functions, one for success and one
    for failure. Only one of the callback functions is invoked during the execution.
    If the command fails validation (in this case, when the same household is used
    for the draft contract), no event is created and the failure callback function
    is invoked. Otherwise, an event is created to capture the randomized contract
    ID, the time of the event, and the rest of the fields. The event is persisted
    to the event store. The event is then passed to the success callback function.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理程序需要两个回调函数，一个用于成功，一个用于失败。在执行过程中只会调用其中一个回调函数。如果命令验证失败（在这种情况下，当使用相同的家庭用于草案合同时），则不会创建事件，并调用失败回调函数。否则，将创建一个事件来捕获随机合同ID、事件时间以及其他字段。该事件被持久化到事件存储中。然后，该事件传递给成功回调函数。
- en: 'The handler for the update command requires validation of whether the aggregate
    exists, and whether the same aggregate ID is retained. The rest of the implementation
    is the handler for the create command:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 更新命令的处理程序需要验证聚合是否存在，以及是否保留了相同的聚合ID。其余的实现是创建命令的处理程序：
- en: '[PRE18]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'There is a `validate` function that is meant to be shared with other update
    command handlers:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`validate`的函数，旨在与其他更新命令处理程序共享：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The success callback function will have the `Contract` passed in because the
    latest version of the aggregate has been found and re-created. The failure callback
    function will have the `Failure` object passed in for delegation.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 成功回调函数将传入`Contract`，因为已经找到了并重新创建了聚合的最新版本。失败回调函数将传入`Failure`对象以进行委托。
- en: 'Finally, when using this example of CQRS and Event Sourcing, the client only
    needs to create a command and pass it in the event store to start with. Then,
    the extension `handle` function is invoked:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当使用此CQRS和事件源示例时，客户端只需创建一个命令并将其传递到事件存储中即可开始。然后，调用扩展`handle`函数：
- en: '[PRE20]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The success callback function captures `contractId` for future updates. To
    update the aggregate, an update command needs to be created and the contract ID
    needs to be specified. Afterwards, the `handle` extension function is invoked:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 成功回调函数捕获`contractId`以供未来的更新使用。要更新聚合，需要创建一个更新命令并指定合同ID。之后，调用`handle`扩展函数：
- en: '[PRE21]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'After all these updates, we can query the latest `Contract` and see if all
    these updates have accumulated. A query is created with the captured contract
    ID. The `handle` extension function is invoked, and the event store is passed
    in:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有这些更新之后，我们可以查询最新的 `Contract` 并查看所有这些更新是否已累积。通过捕获的合同 ID 创建了一个查询。调用 `handle`
    扩展函数，并将事件存储传递进去：
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Because the event store keeps on capturing events as commands are handled,
    it already has the full history of the aggregate. This is the console output you
    get after executing all the commands and queries:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因为事件存储在处理命令时持续捕获事件，它已经拥有了聚合的完整历史。这是执行所有命令和查询后得到的控制台输出：
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This example has illustrated the powerful combination of CQRS and Event Sourcing
    at work. They complement each other and work together seamlessly. It has also
    demonstrated that each command and query has its own class and functions. This
    breaks down the traditional CRUD approach, where there are usually repository
    classes that contain all four types of operations in a big file.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例展示了 CQRS 和事件溯源在工作中的强大组合。它们相互补充，无缝协作。它还演示了每个命令和查询都有自己的类和函数。这打破了传统的 CRUD 方法，其中通常有一个包含所有四种操作的大文件的仓库类。
- en: Outbox pattern
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Outbox 模式
- en: It is worth pointing out that in real systems, there is a trend to also apply
    the **Outbox** pattern to manage the delivery of events in a reliable and fault-tolerant
    manner. This is implemented by having an outbox of messages in persistent storage,
    such as a relational database table.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 值得指出的是，在实际系统中，也存在一种趋势，即也将 **Outbox** 模式应用于以可靠和容错的方式管理事件交付。这是通过在持久存储中（如关系数据库表）拥有消息的
    Outbox 来实现的。
- en: There is a separate process that reads the unsent outbox messages and delivers
    them to the target destinations. If a message is delivered, the corresponding
    record is considered sent and will be deleted.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个独立的过程读取未发送的 Outbox 消息并将它们发送到目标目的地。如果消息已发送，则相应的记录被视为已发送并将被删除。
- en: If the event store is unavailable, this delivery process will retry delivery
    automatically until the event store is operational again. The delivery process
    can also scale independently and potentially deliver messages to different destinations
    in parallel.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果事件存储不可用，此交付过程将自动重试交付，直到事件存储再次可用。交付过程还可以独立扩展，并可能并行地将消息发送到不同的目标。
- en: A similar pattern to the Outbox pattern is the **Change Data Capture** (**CDC**)
    pattern. CDC detects changes to records by database triggers, transaction logs,
    or change trackers and creates an event. The created event eventually goes into
    the event stream or topic. While events are created before the Outbox process,
    events are retrospectively created in CDC. That means that CDC is less intuitive
    in capturing the intent of the event.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Outbox 模式类似的是 **变更数据捕获**（**CDC**）模式。CDC 通过数据库触发器、事务日志或变更跟踪器检测记录的变化，并创建一个事件。创建的事件最终进入事件流或主题。虽然事件在
    Outbox 过程之前创建，但 CDC 中的事件是事后创建的。这意味着 CDC 在捕获事件意图方面不太直观。
- en: Traditional relational databases provide strong consistency and transactional
    guarantees. This means we can have one transaction for normal database operations
    and event delivery as database records for either Outbox or CDC, achieving the
    all-or-none transactional behavior.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的关联数据库提供强一致性事务保证。这意味着我们可以有一个事务用于常规数据库操作和事件交付，作为 Outbox 或 CDC 的数据库记录，实现全有或全无的事务行为。
- en: By storing the Outbox messages in relational databases, the reliability, fault
    tolerance, consistency, and scalability of event sending are also improved.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在关系数据库中存储 Outbox 消息，事件发送的可靠性、容错性、一致性和可扩展性也得到了提高。
- en: Popular frameworks and infrastructure for CQRS and Event Sourcing
  id: totrans-245
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CQRS 和事件溯源的流行框架和基础设施
- en: CQRS and Event Sourcing are architecture concepts that do not rely on a particular
    technology or framework. They are also agnostic to programming languages. However,
    there are frameworks and infrastructure that aim to support CQRS or Event Sourcing.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: CQRS 和事件溯源是架构概念，不依赖于特定的技术或框架。它们对编程语言也是中立的。然而，有一些框架和基础设施旨在支持 CQRS 或事件溯源。
- en: 'CQRS / Event Sourcing frameworks:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CQRS / 事件溯源框架：
- en: Axon framework ([https://www.axoniq.io/products/axon-framework](https://www.axoniq.io/products/axon-framework))
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Axon 框架 ([https://www.axoniq.io/products/axon-framework](https://www.axoniq.io/products/axon-framework))
- en: Akka ([https://akka.io/](https://akka.io/))
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Akka ([https://akka.io/](https://akka.io/))
- en: 'Event stores:'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 事件存储：
- en: EventStore ([https://www.eventstore.com/](https://www.eventstore.com/))
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: EventStore ([https://www.eventstore.com/](https://www.eventstore.com/))
- en: Apache Cassandra ([https://cassandra.apache.org/](https://cassandra.apache.org/))
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Cassandra ([https://cassandra.apache.org/](https://cassandra.apache.org/))
- en: MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/))
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB ([https://www.mongodb.com/](https://www.mongodb.com/))
- en: 'Messaging infrastructure:'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息基础设施：
- en: RabbitMQ streams ([https://www.rabbitmq.com/docs/streams](https://www.rabbitmq.com/docs/streams))
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ 流 ([https://www.rabbitmq.com/docs/streams](https://www.rabbitmq.com/docs/streams))
- en: Apache Kafka ([https://kafka.apache.org/](https://kafka.apache.org/))
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apache Kafka ([https://kafka.apache.org/](https://kafka.apache.org/))
- en: It is important to mention that using these tools does not automatically make
    CQRS or Event Sourcing work in your system. Your current framework and infrastructure
    may already be ready for these architecture styles, as long as the team implements
    the system using the semantics of CQRS and Event Sourcing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，使用这些工具并不能自动使 CQRS 或事件溯源在你的系统中生效。只要团队使用 CQRS 和事件溯源的语义实现系统，你的当前框架和基础设施可能已经为这些架构风格做好了准备。
- en: Summary
  id: totrans-258
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began by covering the classic CRUD architecture and its limitations. Then,
    we introduced Event Sourcing as an alternative approach to managing data and explored
    its history. We delved into how a team can decide whether Event Sourcing should
    be considered in their systems.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了经典的 CRUD 架构及其局限性。然后，我们介绍了事件溯源作为管理数据的替代方法，并探讨了其历史。我们深入探讨了团队如何决定是否应该在他们的系统中考虑事件溯源。
- en: We used the real-life example of villagers exchanging services to demonstrate
    how Event Sourcing can be implemented. We also briefly laid out a plan for how
    a CRUD system can migrate to Event Sourcing.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过村民交换服务的现实生活例子来展示事件溯源的实施方法。我们还简要概述了 CRUD 系统迁移到事件溯源的计划。
- en: Afterward, we moved to the topic of CQRS architecture. We discussed using commands
    as write operations and queries as read operations. We mentioned the basic constructs
    of CQRS and how they relate to the DDD and Event Sourcing architectures. We saw
    a side-by-side comparison of CRUD and CQRS in breaking down multiple update operations.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们转向了 CQRS 架构的主题。我们讨论了使用命令作为写操作和查询作为读操作。我们提到了 CQRS 的基本结构以及它们与 DDD 和事件溯源架构的关系。我们看到了
    CRUD 和 CQRS 在分解多个更新操作时的对比。
- en: We then discussed using both CQRS and Event Sourcing. We described how these
    two architectures complement each other with the extension of the real-life example.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着讨论了使用 CQRS 和事件溯源。我们描述了如何通过扩展现实生活中的例子来使这两种架构相互补充。
- en: Lastly, we briefly covered using the Outbox pattern with CQRS and Event Sourcing.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了使用 Outbox 模式与 CQRS 和事件溯源的结合使用。
- en: In the next chapter, we are going to discuss the idempotence, replication, and
    recovery aspects of distributed systems.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论分布式系统的幂等性、复制和恢复方面。
