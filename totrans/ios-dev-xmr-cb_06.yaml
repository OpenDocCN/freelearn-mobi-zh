- en: Chapter 6. Web Services
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。网络服务
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Consuming web services
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费网络服务
- en: Consuming REST services
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消费REST服务
- en: Communicating with native APIs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与原生API通信
- en: Using WCF services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用WCF服务
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Providing online information to the user is a crucial part of mobile development.
    In this chapter, we will discuss developing apps that communicate with web services
    to provide information. We will see how to consume and invoke web services based
    on SOAP. We will also discuss on how to use REST web services and how to parse
    the popular JSON data format from a web server. Last but not least, we will take
    a look at how to use the native iOS APIs for communication and also how to use
    WCF services.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户提供在线信息是移动开发的关键部分。在本章中，我们将讨论开发与网络服务通信的应用程序以提供信息。我们将了解如何基于SOAP消费和调用网络服务。我们还将讨论如何使用REST网络服务以及如何从网络服务器解析流行的JSON数据格式。最后但同样重要的是，我们将探讨如何使用原生iOS
    API进行通信以及如何使用WCF服务。
- en: All examples in this chapter use **XSP**, a lightweight web server that is shipped
    with the Mono Framework; so, there is no need to have a live web service up and
    running online or locally to make use of the provided code.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有示例都使用**XSP**，这是一个与Mono框架一起提供的轻量级网络服务器；因此，无需在线或本地运行一个实时网络服务即可使用提供的代码。
- en: Consuming web services
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费网络服务
- en: In this recipe, we will learn how to use a SOAP web service in a Xamarin.iOS
    project.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何在Xamarin.iOS项目中使用SOAP网络服务。
- en: Getting ready
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** project in Xamarin Studio and name
    it `WebServiceApp`. This chapter's code contains a web service project named `MTWebService`.
    This is the web service that will be used.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**项目，并将其命名为`WebServiceApp`。本章的代码包含一个名为`MTWebService`的网络服务项目。这就是我们将要使用的网络服务。
- en: 'To use the `MTWebService` web service, we need a web server. Mono Framework
    provides us with the XSP lightweight web server for testing purposes. Open a terminal
    and type the following command to get to the web service''s directory, replacing
    `<code_directory>` with the path the downloaded code is in:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`MTWebService`网络服务，我们需要一个网络服务器。Mono框架为我们提供了一个用于测试目的的XSP轻量级网络服务器。打开一个终端，并键入以下命令以进入网络服务的目录，将`<code_directory>`替换为下载的代码所在的路径：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Run the XSP web server by typing `xsp4` in the prompt. You will see an output
    that is similar to the following:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在提示符中键入`xsp4`以运行XSP网络服务器。您将看到类似于以下输出的内容：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The web server is now up and running.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 网络服务器现在正在运行。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此菜谱的以下步骤：
- en: We need to add a reference to the web service in our project. Right-click on
    the project in the **Solution** pad and navigate to **Add** | **Add Web Reference**.
    In the dialog box that will be shown, add `http://localhost:8080/MTTestWebService.asmx?wsdl`
    in the **Web Service Url** field and click on the **Jump to** button.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在项目中添加对网络服务的引用。在**解决方案**面板中的项目上右键单击，然后导航到**添加** | **添加Web引用**。在随后显示的对话框中，在**Web服务URL**字段中添加`http://localhost:8080/MTTestWebService.asmx?wsdl`，然后单击**转到**按钮。
- en: Select **.NET 2.0 Web Services** in the **Framework** combo box.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**框架**组合框中选择**.NET 2.0 Web Services**。
- en: Set the **Reference** field to `mtWebService`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**引用**字段设置为`mtWebService`。
- en: With all the settings properly entered, the dialog box should look similar to
    the following screenshot. Click on the **OK** button to add the web reference:![How
    to do it...](img/8924OT_06_01.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在所有设置正确输入后，对话框应类似于以下截图。单击**确定**按钮以添加Web引用：![如何操作...](img/8924OT_06_01.jpg)
- en: Add a button and label to `WebServiceAppViewController`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`WebServiceAppViewController`添加一个按钮和标签。
- en: 'In the `ViewDidLoad` method of the controller, add the following code:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的`ViewDidLoad`方法中，添加以下代码：
- en: '[PRE2]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add the following `using` directive to the `WebServiceAppViewController.cs`
    file:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到`WebServiceAppViewController.cs`文件中：
- en: '[PRE3]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Compile and run the app on the simulator. Click on the **Fetch** button and
    the output should be displayed on the screen.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。单击**获取**按钮，输出应显示在屏幕上。
- en: How it works...
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Xamarin.iOS apps can consume web services just like a .NET desktop application.
    The XSP lightweight web server is installed when installing the Mono Framework
    by default, which is a requirement for the Xamarin installation. When running
    the `xsp4` command in the terminal without any parameters, it sets its base directory
    to the current directory by default and starts listening on the `8080` port. If
    the web server is started, the web service description can be viewed by entering
    `http://localhost:8080/MTTestWebService.asmx` in a browser.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS 应用可以像 .NET 桌面应用程序一样消费 Web 服务。XSP 轻量级 Web 服务器在默认情况下通过安装 Mono 框架安装，这是
    Xamarin 安装的要求。在终端中运行 `xsp4` 命令且不带任何参数时，它默认将其基本目录设置为当前目录并开始监听 `8080` 端口。如果 Web
    服务器已启动，可以在浏览器中输入 `http://localhost:8080/MTTestWebService.asmx` 来查看 Web 服务描述。
- en: Xamarin Studio reads the **WSDL** information from the provided URL and creates
    the necessary proxy that will allow us to use the web service in the project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio 从提供的 URL 读取 **WSDL** 信息并创建必要的代理，这将允许我们在项目中使用 Web 服务。
- en: 'We then set the **Framework** value to **.NET 2.0 Web Services** and provide
    a **Reference** name, which will reflect the namespace of the web reference. To
    make use of the web service within our code, we instantiate it and then just call
    the method we are interested in:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 **Framework** 值设置为 **.NET 2.0 Web Services** 并提供一个 **Reference** 名称，这将反映
    Web 引用的命名空间。为了在我们的代码中使用 Web 服务，我们实例化它，然后只需调用我们感兴趣的方法：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There's more...
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Apart from using a local hosted web service, there are also numerous sample
    web services on the Internet. A simple search will yield many results.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用本地托管 Web 服务外，互联网上还有许多示例 Web 服务。简单的搜索会产生许多结果。
- en: Invoking web service methods asynchronously
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 异步调用 Web 服务方法
- en: 'The created proxy also contains methods based on Begin/End and the event to
    invoke the web service asynchronously. The following example shows us how to use
    the event-based methods:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 创建的代理还包含基于 Begin/End 和用于调用 Web 服务异步的事件的方法。以下示例展示了如何使用基于事件的方法：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note the `InvokeOnMainThread` call inside the event handler; it is being called
    on a separate thread. So, if we want to access the main thread in it, we need
    to wrap our calls with `InvokeOnMainThread`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 注意在事件处理程序内部调用的 `InvokeOnMainThread`；它是在一个单独的线程上被调用的。因此，如果我们想在其中访问主线程，我们需要用 `InvokeOnMainThread`
    来包装我们的调用。
- en: The XSP shutdown
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XSP 关闭
- en: To shut down the XSP web server, just click on the *Return* key in the terminal
    where it was executed from.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要关闭 XSP Web 服务器，只需在执行它的终端中点击 *Return* 键。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Communicating with native APIs* recipe
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*与原生 API 通信* 配方'
- en: Consuming REST services
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消费 REST 服务
- en: In this recipe, we will discuss how to properly use and consume REST services
    with Xamarin.iOS.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将讨论如何正确使用和消费 REST 服务与 Xamarin.iOS。
- en: Getting ready
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new **Single View Application** in Xamarin Studio and name it `ForecastApp`.
    In this recipe, we will use the **Open Meteo Foundation** REST API. The use of
    this API is subject to the terms of use stated in this page: [http://openmeteofoundation.org/terms-of-use](http://openmeteofoundation.org/terms-of-use).'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **Single View Application** 并命名为 `ForecastApp`。在这个配方中，我们将使用
    **Open Meteo Foundation** REST API。使用此 API 受此页面中声明的使用条款约束：[http://openmeteofoundation.org/terms-of-use](http://openmeteofoundation.org/terms-of-use)。
- en: How to do it...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to complete this recipe:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此配方：
- en: Add a label and a button on `ForecastAppViewController`. Make sure that the
    label's **Lines** property is set to at least three lines.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ForecastAppViewController` 上添加一个标签和一个按钮。确保标签的 **Lines** 属性设置为至少三行。
- en: 'Add the following code in the controller''s `ViewDidLoad` method:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE6]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add the `System.Net.Http` and `System.Json` references to the project. Don't
    forget to include the corresponding `using` directives to the `ForecastAppViewcontroller.cs`
    file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `System.Net.Http` 和 `System.Json` 引用添加到项目中。别忘了将相应的 `using` 指令包含到 `ForecastAppViewcontroller.cs`
    文件中。
- en: Compile and run the app on the simulator. Click on the **Get Forecast** button
    to display the current temperature and wind speed on the screen.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击 **获取预报** 按钮以在屏幕上显示当前温度和风速。
- en: How it works...
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe, we created an app that uses a REST API to get the current forecast
    for a location. We are using the `async`/`await` pattern that allows us to connect
    and retrieve the data asynchronously. This helps us make sure that our app will
    not freeze while it is connected to retrieve the data.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们创建了一个使用REST API获取位置当前预报的应用程序。我们使用`async`/`await`模式，允许我们异步连接和检索数据。这有助于确保我们的应用程序在连接到检索数据时不会冻结。
- en: 'As it all happens when we click on the button, its `TouchUpInside` handler
    method needs to be marked `async`, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有操作都是在点击按钮时发生的，因此其`TouchUpInside`处理方法需要标记为`async`，如下所示：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We then use the `HttpClient` class, which is part of the `System.Net.Http`
    namespace that provides us with asynchronous methods to connect to endpoints,
    as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`HttpClient`类，它是`System.Net.Http`命名空间的一部分，为我们提供了连接到端点的异步方法，如下所示：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We pass the endpoint to the `GetStringAsync` method, and we get back a JSON
    response string.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将端点传递给`GetStringAsync`方法，并返回一个JSON响应字符串。
- en: 'After retrieving the response, we need to parse it to extract the information
    we need from it. We do this by using the `System.Json` namespace. This namespace
    contains a set of simple classes that allow us to parse JSON strings, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取响应后，我们需要解析它以从中提取所需的信息。我们通过使用`System.Json`命名空间来完成此操作。该命名空间包含一组简单的类，允许我们解析JSON字符串，如下所示：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The temperature is contained in the JSON response under the temp key that contains
    an array, albeit with a single item, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 温度包含在JSON响应的`temp`键下，该键包含一个数组，尽管只有一个条目，如下所示：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After we read the information we need from the JSON response, we display it
    as follows:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们从JSON响应中读取所需的信息后，我们按以下方式显示它：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: There's more...
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `System.Json` namespace is very helpful for parsing simple JSON strings.
    However, things could get very complicated if we have to parse large and more
    complex objects. There are a number of open source libraries we can download and
    use in our Xamarin.iOS projects. The most popular are as follows:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Json`命名空间对于解析简单的JSON字符串非常有帮助。然而，如果我们必须解析大型且更复杂的对象，事情可能会变得非常复杂。我们可以下载并使用在Xamarin.iOS项目中的一些开源库。以下是最受欢迎的几个：'
- en: '**Xamarin port of NewtonSoft Json.NET from Andrew Young**: Even if this is
    outdated, it is fully functional for Xamarin projects. You can find the page at
    [https://github.com/ayoung/Newtonsoft.Json](https://github.com/ayoung/Newtonsoft.Json).'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Andrew Young的NewtonSoft Json.NET的Xamarin端口**：即使这个版本已经过时，它对于Xamarin项目来说仍然完全可用。您可以在[https://github.com/ayoung/Newtonsoft.Json](https://github.com/ayoung/Newtonsoft.Json)找到该页面。'
- en: '**ServiceStack.Text**: You can find the page at [https://github.com/ServiceStack/ServiceStack.Text](https://github.com/ServiceStack/ServiceStack.Text).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ServiceStack.Text**：您可以在[https://github.com/ServiceStack/ServiceStack.Text](https://github.com/ServiceStack/ServiceStack.Text)找到该页面。'
- en: See also
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Consuming web services* recipe
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费Web服务*菜谱'
- en: Communicating with native APIs
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与原生API通信
- en: In this recipe, we will discuss using native iOS APIs to connect and consume
    REST services.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论使用原生iOS API连接和消费REST服务。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will work on the `ForecastApp` we created in the previous
    recipe, *Consuming REST services*. Open the project in Xamarin Studio.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将基于之前菜谱中创建的`ForecastApp`，即*消费REST服务*，进行工作。在Xamarin Studio中打开项目。
- en: How to do it…
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Comment out the code in the `ViewDidLoad` method and add the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中注释掉代码并添加以下代码：
- en: '[PRE12]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the following class to the project:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下类添加到项目中：
- en: '[PRE13]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Compile and run the app on the simulator. Click on the **Get Forecast** button
    to fetch and display the forecast data.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击**获取预报**按钮以获取并显示预报数据。
- en: How it works…
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'The `NSUrlConnection` class is the native iOS class that provides basic connectivity
    functionality. We initialize it by passing `NSUrlRequest` and a delegate object,
    as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUrlConnection`类是提供基本连接功能的原生iOS类。我们通过传递`NSUrlRequest`和一个代理对象来初始化它，如下所示：'
- en: '[PRE14]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `ConnectionDelegate` class that we created acts as the delegate object
    of our `NSUrlConnection`. Inside the class, we need to override the `ReceivedData`
    method to fill our internal buffer with the data received from the service, as
    follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的`ConnectionDelegate`类充当我们的`NSUrlConnection`的代理对象。在类内部，我们需要重写`ReceivedData`方法以用从服务接收到的数据填充我们的内部缓冲区，如下所示：
- en: '[PRE15]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Similarly to reading data from the `Stream` object of `HttpWebResponse`, the
    `ReceivedData` method will be called as soon as new data becomes available. Inside
    `ReceivedData`, we make sure we append the data to our buffer. When all the data
    has been received and the response is finished, the `FinishedLoading` method will
    be called, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于从`HttpWebResponse`的`Stream`对象中读取数据，一旦有新数据可用，就会调用`ReceivedData`方法。在`ReceivedData`内部，我们确保将数据追加到我们的缓冲区。当所有数据都已接收且响应完成时，将调用`FinishedLoading`方法，如下所示：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'After initializing the `NSUrlConnection` instance, we call its `Start` method
    to initiate the connection, as follows:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化`NSUrlConnection`实例后，我们调用其`Start`方法来启动连接，如下所示：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: There's more…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If something goes wrong with the connection, the `FailedWithError` method of
    `NSUrlConnectionDelegate` will be called. We can override it to get information
    on the error that occurred, as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果连接出现错误，`NSUrlConnectionDelegate`的`FailedWithError`方法将被调用。我们可以重写它以获取发生的错误信息，如下所示：
- en: '[PRE18]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Synchronous NSUrlConnection
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 同步NSUrlConnection
- en: 'Using the `NSUrlConnection` class with a delegate object means that the connection
    will take place asynchronously on the thread that it was started from. If we wanted
    to start a synchronous connection, we can use the `SendSynchronousRequest` static
    method, as follows:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 使用具有委托对象的`NSUrlConnection`类意味着连接将在启动它的线程上异步进行。如果我们想启动一个同步连接，可以使用`SendSynchronousRequest`静态方法，如下所示：
- en: '[PRE19]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Usability
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 用户体验
- en: As you might have already noticed, using `NSUrlConnection` is a bit more complicated
    than plain old Mono BCL classes. In general, using BCL classes is the best practice
    for most scenarios, as it helps us maintain a multi-platform code base, among
    other things.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，使用`NSUrlConnection`比使用普通的Mono BCL类要复杂一些。通常，在大多数场景中使用BCL类是最佳实践，因为它有助于我们维护一个多平台代码库，等等。
- en: There are some cases, however, where the native APIs are very useful and are
    the only available solution. For example, iOS supports certain connectivity features
    in the background, which are only possible with the native APIs.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在某些情况下，原生API非常有用，并且是唯一可用的解决方案。例如，iOS支持在后台运行某些连接功能，这些功能只能通过原生API实现。
- en: See also
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Consuming REST services* recipe
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费REST服务*菜谱'
- en: The *Updating data in the background* recipe in [Chapter 12](ch12.html "Chapter 12. Multitasking"),
    *Multitasking*
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在[第12章](ch12.html "第12章。多任务")的*在后台更新数据*菜谱中，*多任务*
- en: Using WCF services
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用WCF服务
- en: In this recipe, we will learn how to consume WCF services with Xamarin.iOS.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用Xamarin.iOS消费WCF服务。
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The WCF service support is only available in business and enterprise licenses
    of Xamarin.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: WCF服务支持仅适用于Xamarin的商业和企业许可证。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'For this project, we will need a running WCF service. A WCF service can be
    found in the code download of this chapter. To start the service, open a terminal
    and go to the project''s directory. Start the service by running the `start_wcfservice.sh`
    shell script, as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，我们需要一个正在运行的WCF服务。WCF服务可以在本章的代码下载中找到。要启动服务，打开终端并转到项目的目录。通过运行`start_wcfservice.sh`shell脚本启动服务，如下所示：
- en: '[PRE20]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: After the service is started, create a new **Single View Application** in Xamarin
    Studio and name it `WcfServiceApp`. A machine running on Windows will also be
    needed.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 服务启动后，在Xamarin Studio中创建一个新的**单视图应用程序**，命名为`WcfServiceApp`。还需要一台运行Windows的机器。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add the references to the `System.Runtime.Serialization` and `System.ServiceModel`
    namespaces of the project and their corresponding `using` directives in the `WcfServiceAppViewController.cs`
    file.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中将`System.Runtime.Serialization`和`System.ServiceModel`命名空间及其对应的`using`指令添加到`WcfServiceAppViewController.cs`文件中。
- en: 'Xamarin.iOS does not provide full support for WCF services. To generate a proxy
    for the client, we will need to use the `slsvcutil` tool on a Windows machine.
    Run the following command in the command prompt under Windows:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xamarin.iOS不完全支持WCF服务。为了生成客户端代理，我们需要在Windows机器上使用`slsvcutil`工具。在Windows的命令提示符下运行以下命令：
- en: '[PRE21]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This command will produce a C# source file named `service.cs`. Add this file
    to the Xamarin.iOS project. Replace the IP address in the following highlighted
    code with your own to make it work correctly.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将生成一个名为`service.cs`的C#源文件。将此文件添加到Xamarin.iOS项目中。将以下突出显示代码中的IP地址替换为您自己的以使其正确工作。
- en: 'Add a label and a button on the view of `WcfServiceAppViewController`. Add
    the following code in the `ViewDidLoad` method:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`WcfServiceAppViewController`的视图中添加一个标签和一个按钮。在`ViewDidLoad`方法中添加以下代码：
- en: '[PRE22]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, add the following method:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加以下方法：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Compile and run the app on the simulator. Click on the button and watch the
    data returned from the service get populated in the label.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击按钮，观察从服务返回的数据填充到标签中。
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Xamarin.iOS relies on Mono Framework's support for WCF services, which is not
    complete. Although, the fact that WCF services can be used in iOS apps makes Xamarin.iOS
    more appealing to .NET developers.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin.iOS依赖于Mono Framework对WCF服务的支持，但这并不完整。尽管如此，WCF服务可以在iOS应用程序中使用，这使得Xamarin.iOS对.NET开发者更具吸引力。
- en: However, there is no tool to create the client proxy on a Mac, and Xamarin Studio
    can not create a proper proxy either; so, we will need to have access to a Windows
    machine to do this with the Silverlight Service Model Proxy Generation Tool (`SLsvcUtil.exe`).
    The source file that this tool generates allows us to consume the WCF service
    in our project.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有工具可以在Mac上创建客户端代理，Xamarin Studio也无法创建合适的代理；因此，我们需要访问一台Windows机器来使用Silverlight服务模型代理生成工具（`SLsvcUtil.exe`）来完成这项工作。该工具生成的源文件允许我们在项目中使用WCF服务。
- en: It is important to use Silverlight Version 3.0 `slsvcutil` to create the client
    proxy.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Silverlight版本3.0的`slsvcutil`创建客户端代理非常重要。
- en: Apart from Mono Framework's support, there is another limitation, that is, the
    dynamic code generation is not allowed on iOS. This makes any code that relies
    on the `System.Reflection.Emit` namespace unusable. In fact, the `System.Reflection.Emit`
    namespace is not available at all in Xamarin.iOS.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 除了Mono Framework对WCF服务的支持外，还有一个限制，那就是iOS上不允许动态代码生成。这使得任何依赖于`System.Reflection.Emit`命名空间中的代码都无法使用。实际上，在Xamarin.iOS中，`System.Reflection.Emit`命名空间根本不可用。
- en: After copying the produced file on Mac, we add it to the project, and we are
    ready to use the WCF service. The preceding highlighted code shows us how to instantiate
    the service object. Note that the default constructor of the service object cannot
    be used, as Xamarin.iOS does not support the `System.Configuration` namespace.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac上复制生成的文件后，我们将其添加到项目中，我们就准备好使用WCF服务了。前面高亮显示的代码显示了如何实例化服务对象。请注意，服务对象的默认构造函数不能使用，因为Xamarin.iOS不支持`System.Configuration`命名空间。
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The actual communication occurs by calling the method''s asynchronous implementation
    after setting a handler to its corresponding completion event. Note that in this
    case, there is no alternative to using synchronous invocations or the `BeginInvoke`
    and `EndInvoke` pattern:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的通信是通过在设置相应完成事件的处理器后调用方法的异步实现来进行的。请注意，在这种情况下，没有使用同步调用或`BeginInvoke`和`EndInvoke`模式的替代方案：
- en: '[PRE24]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The result returned from the service can be retrieved through the specified
    `EventArgs` derivative''s `Result` property:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过指定的`EventArgs`派生类的`Result`属性检索服务返回的结果：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: When debugging a project that consumes WCF services, remember to set the address
    of the machine the service is running on, instead of localhost or 127.0.0.1\.
    This is because when we run the app on the device, the app will fail to connect
    to the service.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 当调试一个消费WCF服务的项目时，请记住设置服务运行在的机器的地址，而不是localhost或127.0.0.1。这是因为当我们运行应用程序在设备上时，应用程序将无法连接到服务。
- en: More information on Xamarin Studio's WCF support
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于Xamarin Studio的WCF支持的更多信息
- en: There is an option of adding a WCF web reference through Xamarin Studio in the
    **Add Web References** window shown in the *Consuming web services* recipe. However,
    it is not yet complete and the proxy it generates will not work.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在“*消费Web服务*”配方中显示的“**添加Web引用**”窗口中，可以通过Xamarin Studio添加一个WCF Web引用。然而，它尚未完成，并且它生成的代理将无法工作。
- en: WCF service creation
  id: totrans-141
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: WCF服务创建
- en: The object returned from the `WcfService` service and the actual service itself
    was created completely on a Mac as a Xamarin Studio project. As there is no WCF
    project template, the **Empty Project** template was used.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 从`WcfService`服务返回的对象以及实际的服务本身完全是在Mac上作为一个Xamarin Studio项目创建的。由于没有WCF项目模板，使用了**空项目**模板。
- en: See also
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Consuming web services* recipe
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*消费Web服务*配方'
