["```swift\n    func update() { }\n    ```", "```swift\n    override func update(currentTime: NSTimeInterval) {\n        player.update()\n    }\n    ```", "```swift\nlet groundPosition = CGPoint(x: -self.size.width, y: 30)\n```", "```swift\n// Create a physics body based on one frame of Pierre's animation.\n// We will use the third frame, when his wings are tucked in,\n// and use the size from the spawn function's parameters:\nlet bodyTexture = textureAtlas.textureNamed(\"pierre-flying-3.png\")\nself.physicsBody = SKPhysicsBody(\n    texture: bodyTexture,\n    size: size)\n// Pierre will lose momentum quickly with a high linearDamping:\nself.physicsBody?.linearDamping = 0.9\n// Adult penguins weigh around 30kg:\nself.physicsBody?.mass = 30\n// Prevent Pierre from rotating:\n        self.physicsBody?.allowsRotation = false\n```", "```swift\n    import CoreMotion\n    ```", "```swift\n    let motionManager = CMMotionManager()\n    ```", "```swift\n    self.motionManager.startAccelerometerUpdates()\n    ```", "```swift\n    // Unwrap the accelerometer data optional:\n    if let accelData = self.motionManager.accelerometerData {\n        var forceAmount:CGFloat\n        var movement = CGVector()\n\n        // Based on the device orientation, the tilt number\n        // can indicate opposite user desires. The  \n        // UIApplication class exposes an enum that allows\n        // us to pull the current orientation.\n        // We will use this opportunity to explore Swift's    \n        // switch syntax and assign the correct force for the \n        // current orientation:\n        Switch\n       UIApplication.sharedApplication().statusBarOrientation {\n        case .LandscapeLeft:\n            // The 20,000 number is an amount that felt right\n            // for our example, given Pierre's 30kg mass:\n            forceAmount = 20000\n        case .LandscapeRight:\n            forceAmount = -20000\n        default:\n            forceAmount = 0\n        }\n\n        // If the device is tilted more than 15% towards complete\n        // vertical, then we want to move the Penguin:\n        if accelData.acceleration.y > 0.15 {\n            movement.dx = forceAmount\n        }\n        // Core Motion values are relative to portrait view. // Since we are in landscape, use y-values for x-axis.\n        else if accelData.acceleration.y < -0.15 {\n            movement.dx = -forceAmount\n        }\n\n        // Apply the force we created to the player:\n        player.physicsBody?.applyForce(movement)\n    }\n    ```", "```swift\noverride func touchesBegan(touches: Set<NSObject>, withEvent \n    event: UIEvent) {\n    for touch in (touches as! Set<UITouch>) {\n        // Find the location of the touch:\n        let location = touch.locationInNode(self)\n        // Locate the node at this location:\n        let nodeTouched = nodeAtPoint(location)\n        // Attempt to downcast the node to the GameSprite protocol\n        if let gameSprite = nodeTouched as? GameSprite {\n            // If this node adheres to GameSprite, call onTap:\n            gameSprite.onTap()\n        }\n    }\n}\n```", "```swift\nself.xScale = 4\nself.yScale = 4\n```", "```swift\n    // Store whether we are flapping our wings or in free-fall:\n    var flapping = false\n    // Set a maximum upward force.\n    // 57,000 feels good to me, adjust to taste:\n    let maxFlappingForce:CGFloat = 57000\n    // Pierre should slow down when he flies too high:\n    let maxHeight:CGFloat = 1000\n    ```", "```swift\n    self.runAction(soarAnimation, withKey: \"soarAnimation\")\n    ```", "```swift\n    // If flapping, apply a new force to push Pierre higher.\n    if self.flapping {\n        var forceToApply = maxFlappingForce\n\n        // Apply less force if Pierre is above position 600\n        if position.y > 600 {\n            // The higher Pierre goes, the more force we \n            // remove. These next three lines determine the   \n            // force to subtract:\n            let percentageOfMaxHeight = position.y / maxHeight\n            let flappingForceSubtraction = \n                percentageOfMaxHeight * maxFlappingForce\n            forceToApply -= flappingForceSubtraction\n        }\n        // Apply the final force:\n        self.physicsBody?.applyForce(CGVector(dx: 0, dy: \n            forceToApply))\n    }\n\n    // Limit Pierre's top speed as he climbs the y-axis.\n    // This prevents him from gaining enough momentum to shoot\n    // over our max height. We bend the physics for gameplay:\n    if self.physicsBody?.velocity.dy > 300 {\n        self.physicsBody?.velocity.dy = 300\n    }\n    ```", "```swift\n    // Begin the flap animation, set flapping to true:\n    func startFlapping() {\n        self.removeActionForKey(\"soarAnimation\")\n        self.runAction(flyAnimation, withKey: \"flapAnimation\")\n        self.flapping = true\n    }\n\n    // Stop the flap animation, set flapping to false:\n    func stopFlapping() {\n        self.removeActionForKey(\"flapAnimation\")\n        self.runAction(soarAnimation, withKey: \"soarAnimation\")\n        self.flapping = false\n    }\n    ```", "```swift\n    player.startFlapping()\n    ```", "```swift\n    override func touchesEnded(touches: Set<NSObject>, withEvent event: UIEvent) {\n        player.stopFlapping()\n    }\n\n    override func touchesCancelled(touches: Set<NSObject>!, withEvent event: UIEvent) {\n        player.stopFlapping()\n    }\n    ```", "```swift\n// Set gravity\nself.physicsWorld.gravity = CGVector(dx: 0, dy: -5)\n```", "```swift\n    var screenCenterY = CGFloat()\n    ```", "```swift\n    // Store the vertical center of the screen:\n    screenCenterY = self.size.height / 2\n    ```", "```swift\n    override func didSimulatePhysics() {\n        var worldYPos:CGFloat = 0\n\n        // Zoom the world as the penguin flies higher\n        if (player.position.y > screenCenterY) {\n            let percentOfMaxHeight = (player.position.y - \n                screenCenterY) / (player.maxHeight - \n                screenCenterY)\n            let scaleSubtraction = (percentOfMaxHeight > 1 ? 1 : percentOfMaxHeight) * 0.6\n            let newScale = 1 - scaleSubtraction\n            world.yScale = newScale\n            world.xScale = newScale\n            // The player is above half the screen size\n            // so adjust the world on the y-axis to follow:\n            worldYPos = -(player.position.y * world.yScale - \n                (self.size.height / 2))\n        }\n\n        let worldXPos = -(player.position.x * world.xScale - \n            (self.size.width / 3))\n\n        // Move the world for our adjustment:\n        world.position = CGPoint(x: worldXPos, y: worldYPos)\n    }\n    ```", "```swift\n// Set a constant velocity to the right:\nself.physicsBody?.velocity.dx = 200\n```", "```swift\n    let initialPlayerPosition = CGPoint(x: 150, y: 250)\n    var playerProgress = CGFloat()\n    ```", "```swift\n    // Spawn the player:\n    player.spawn(world, position: initialPlayerPosition)\n    ```", "```swift\n    // Keep track of how far the player has flown\n    playerProgress = player.position.x - initialPlayerPosition.x\n    ```", "```swift\n    var jumpWidth = CGFloat()\n    // Note the instantiation value of 1 here:\n    var jumpCount = CGFloat(1)\n    ```", "```swift\n    func createChildren() {\n        if let texture = groundTexture {\n            var tileCount:CGFloat = 0\n            let textureSize = texture.size()\n            let tileSize = CGSize(width: textureSize.width / 2, \n                height: textureSize.height / 2)\n\n            while tileCount * tileSize.width < self.size.width {\n                let tileNode = SKSpriteNode(texture: texture)\n                tileNode.size = tileSize\n                tileNode.position.x = tileCount * tileSize.width\n                tileNode.anchorPoint = CGPoint(x: 0, y: 1)\n                self.addChild(tileNode)\n\n                tileCount++\n            }\n\n            // Find the width of one-third of the children nodes\n     jumpWidth = tileSize.width * floor(tileCount / 3)\n        }\n    }\n    ```", "```swift\n    func checkForReposition(playerProgress:CGFloat) {\n        // The ground needs to jump forward\n        // every time the player has moved this distance:\n        let groundJumpPosition = jumpWidth * jumpCount\n\n        if playerProgress >= groundJumpPosition {\n            // The player has moved past the jump position!\n            // Move the ground forward:\n            self.position.x += jumpWidth\n            // Add one to the jump count:\n            jumpCount++\n        }\n    } \n    ```", "```swift\n    // Check to see if the ground should jump forward:\n    ground.checkForReposition(playerProgress)\n    ```"]