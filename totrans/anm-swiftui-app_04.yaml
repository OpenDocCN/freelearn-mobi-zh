- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Record Player
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a record player that will move an arm over the
    record, make the record spin, and play music when a button is pressed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Sure, record players are a bit outdated now, but this project is a good way
    to learn new techniques about rotation – specifically, how to rotate objects around
    an anchor point. And you can always modify the design to look like a turntable,
    as many DJs still use vinyl, especially due to the vinyl resurgence in the last
    few years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, *didn’t we rotate circles in the first project?* Well,
    this project is different. In the last project, the rotation animation we applied
    was on SwiftUI-created shapes, (specifically, circles), but in this project, we
    will be applying a rotation animation onto a photo image, then controlling it
    with a button, and mixing in some sounds to add to the user experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s list our objectives for this project:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the record player elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining all the elements into one view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the finished project in the `Chapter 4` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, let’s get started on the first objective: adding some images to the project.
    First, we need to create a new project in Xcode. I called mine `Record Player`
    (you can copy this name or choose something else if you like). Then, we need to
    fill out the other fields exactly as we did in the last chapter. Once this is
    done, we are ready to start.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the images themselves, we need three: the record, the record
    player arm that will move over the record, and a wood grain image that we can
    use as the record player box. All of these images can be found on GitHub by clicking
    the link provided in the *Technical* *requirements* section.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: There are three main methods to add images to the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is using Xcode’s special file folder called the `Assets.xcassets`
    file in Xcode and you will be taken to the Assets catalog. The catalog is split
    into two sections: the section on the left is where your files are listed, and
    the section on the right is where you can actually see your files when you click
    on them in the left pane. To bring your images into the catalog, simply drag them
    into the left column:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Adding files to the Assets catalog ](img/B18674_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Adding files to the Assets catalog'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: These images will be accessible by referencing their name in the code we write
    (we will see how to do this shortly).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method to add image files to the project is just by dragging and
    dropping them into the Project navigator. However, this method includes the extra
    step of choosing how and where you want to copy the files into the project via
    the following pop-up window:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Adding files into the Project navigator ](img/B18674_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2：通过项目导航器添加文件](img/B18674_04_02.jpg)'
- en: 'Figure 4.2: Adding files into the Project navigator'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：通过项目导航器添加文件
- en: Here, you want to make sure that you tick the checkbox that says **Copy items
    if needed**. That’s important because Xcode will copy your files into the project,
    so if they are no longer available on your computer, it won’t matter, as they
    are part of your project now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你想要确保勾选了说**如果需要则复制项目**的复选框。这是很重要的，因为Xcode会复制你的文件到项目中，所以如果它们在你的电脑上不再可用，那没关系，因为它们现在是项目的一部分了。
- en: You also want to make sure that you check the boxes for the specific target
    you want to copy those resources to. For example, if you want to build the app
    on your Mac, then you want to check the **Record Player (macOS)** option in the
    **Add to targets** box. If you’re just building it for the iPhone, then check
    the **Record Player (iOS)** option. You can also check both if you prefer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你还想要确保你勾选了你想复制那些资源的特定目标。例如，如果你想在你的Mac上构建应用，那么你想要在**添加到目标**框中勾选**唱机 (macOS)**选项。如果你只是为iPhone构建它，那么勾选**唱机
    (iOS)**选项。你也可以两者都勾选，如果你更喜欢的话。
- en: 'The final method is opening the **File** menu and selecting the **Add Files**
    **to…** option:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种方法是打开**文件**菜单并选择**添加文件到…**选项：
- en: '![Figure 4.3: Adding files to the project via the File menu ](img/B18674_04_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3：通过文件菜单添加文件到项目](img/B18674_04_03.jpg)'
- en: 'Figure 4.3: Adding files to the project via the File menu'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3：通过文件菜单添加文件到项目
- en: Now that we have added all the images, the next objective is to create the record
    player.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了所有图像，下一个目标是创建唱机。
- en: Creating the record player elements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建唱机元素
- en: 'To create our record player, we will create three separate files, each in charge
    of performing specific tasks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建我们的唱机，我们将创建三个独立的文件，每个文件负责执行特定的任务：
- en: The first file will hold the record player box
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个文件将包含唱机盒子
- en: The second file will hold the spinning record, the record player arm, and the
    button to control it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个文件将包含旋转的唱片，唱机臂和用于控制它的按钮
- en: The third file will hold the sound file that will play when the record player
    animation starts
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个文件将包含当唱机动画开始时播放的声音文件
- en: Let’s get started with the first file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个文件开始。
- en: Creating the record player box
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建唱机盒子
- en: 'To create the file to hold the record player box, in Xcode, open the **File**
    menu, select **New**, then select **File**. You will notice that this brings up
    several template options:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建包含唱机盒子的文件，在Xcode中打开**文件**菜单，选择**新建**，然后选择**文件**。你会注意到这会弹出一个模板选项：
- en: '![Figure 4.4: Creating a new SwiftUI file ](img/B18674_04_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图4.4：创建新的SwiftUI文件](img/B18674_04_04.jpg)'
- en: 'Figure 4.4: Creating a new SwiftUI file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.4：创建新的SwiftUI文件
- en: Looking at the top of the window, the row of tabs lets you select which platform
    you want to write code for. We’re only interested in iOS apps, so select the **iOS**
    tab. Then, under the **User Interface** heading, select **SwiftUI View**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 查看窗口顶部，选项卡行让你选择你想为哪个平台编写代码。我们只对iOS应用感兴趣，所以选择**iOS**选项卡。然后，在**用户界面**标题下，选择**SwiftUI视图**。
- en: Click `RecordPlayerBox`. Make sure your targets are selected in the checkboxes
    so that the file and everything it contains will work correctly when you run the
    project. Once your targets have been set, click **Create**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 点击`RecordPlayerBox`。确保你的目标在复选框中被选中，这样当运行项目时，文件及其包含的一切都将正常工作。一旦你的目标被设置，点击**创建**。
- en: 'Now, we have our new file to write our code, and you’ll notice it’s the same
    as the `ContentView` file, except it’s called `RecordPlayerBox`. Working in the
    `body` property, we will start with a `ZStack`; this will be our main stack to
    hold all of our views. Within the `ZStack`, we can build a rectangle using one
    of the images in the Assets catalog. Enter the following code, and then let’s
    look at what it does:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有了新的文件来编写我们的代码，你会注意到它与`ContentView`文件相同，只是它被命名为`RecordPlayerBox`。在`body`属性中工作，我们将从一个`ZStack`开始；这将是我们存放所有视图的主要堆栈。在`ZStack`内部，我们可以使用资产库中的一个图像来构建一个矩形。输入以下代码，然后让我们看看它做了什么：
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we added a `Rectangle` view, and then, using the `frame` modifier, it
    gets a dimension of `345` points for the width and height, making a square.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个`Rectangle`视图，然后，使用`frame`修饰符，它获得了`345`点的宽度和高度，形成了一个正方形。
- en: Then, using the `cornerRadius` modifier, we rounded the corners of the rectangle
    by `10` points.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用`cornerRadius`修饰符，我们将矩形的角落圆滑了`10`点。
- en: The next line of code is the `Image` initializer, which is a view that displays
    an image. We want to use the wood grain image that’s in the Assets catalog, so
    we accessed it by typing the image’s name within quotes to create a string inside
    the `Image` initializer. In our case, we typed `"woodGrain"`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码是`Image`初始化器，它是一个显示图像的视图。我们想要使用Assets目录中的木纹图像，所以我们通过在`Image`初始化器中输入图像的名称来访问它，以创建一个字符串。在我们的例子中，我们输入了`"woodGrain"`。
- en: Now we have our image, but we have to resize it. In order to do that, we need
    to use the `resizable` modifier, which is used to prepare an image or other view
    to be resized so it fits within its parent view. When it’s applied to an `Image`
    view, the `resizable` modifier will determine how the image should be scaled to
    fit within the space available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了我们的图像，但我们需要调整其大小。为了做到这一点，我们需要使用`resizable`修饰符，它用于准备一个图像或其他视图以便调整大小，使其适合其父视图。当它应用于`Image`视图时，`resizable`修饰符将确定图像应该如何缩放以适应可用空间。
- en: Then, the `frame` modifier resizes the wood image to a width and height of `325`
    points. This will make it a little smaller than the `Rectangle` dimensions; however,
    making it smaller will allow some of the rectangle edges to show through, creating
    a border. The reason why the border is black is that the default color for creating
    a rectangle shape is black, as it is with all shapes. We can change it to any
    color we want by using a `color` modifier, but I think I’ll leave it black here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`frame`修饰符将木纹图像的大小调整为`325`点宽度和高度。这将使其略小于矩形的尺寸；然而，减小它将允许一些矩形边缘显示出来，从而创建一个边框。边框之所以是黑色，是因为创建矩形形状的默认颜色是黑色，就像所有形状一样。我们可以通过使用`color`修饰符将其更改为我们想要的任何颜色，但我想我会在这里保持黑色。
- en: The final line of code creates a shadow by using the `shadow` modifier. Again,
    all the modifiers we are adding are for the wood grain image, so each modifier
    placed on the wood grain has its own specific task of modifying the wood grain
    image in some way. Since this modifier is placed on the wood grain image and is
    using a white color, a white shadow will be radiating around the image. Setting
    the radius to a value of `3` means the shadow will extend out from the image by
    3 points. We can also choose to put a value in for the `x` and `y` parameters,
    which will move the shadow on those axes either left, right, up, or down.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行代码通过使用`shadow`修饰符创建阴影。同样，我们添加的所有修饰符都是为了木纹图像，所以每个放置在木纹上的修饰符都有其特定的任务，以某种方式修改木纹图像。由于这个修饰符放置在木纹图像上，并且使用白色颜色，因此会在图像周围辐射出白色阴影。将半径设置为`3`意味着阴影将从图像延伸出`3`点。我们还可以选择为`x`和`y`参数输入一个值，这将沿着这些轴移动阴影，向左、向右、向上或向下。
- en: How much the shadow is moved depends on the size of the value you put in. For
    example, if you put a value of `10` in for the `x` parameter, the shadow will
    extend out from the right edge 10 points; if you put a value of `10` in for the
    `y` parameter, the shadow will extend out 10 points from the bottom edge of the
    box. I put in a value of `0` because I want the shadow directly over the wood
    grain image; it won’t be shifted left or right or up and down.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 阴影移动的量取决于你放入的值的尺寸。例如，如果你为`x`参数输入一个值为`10`，阴影将从右侧边缘延伸出`10`点；如果你为`y`参数输入一个值为`10`，阴影将从盒子的底部边缘延伸出`10`点。我输入了一个值为`0`，因为我想要阴影直接覆盖木纹图像；它不会向左或向右或向上或向下移动。
- en: Play with these numbers and with the color of the shadow so you can see how
    much the values that we’ve used affect the shadow location and intensity. Don’t
    expect to see much of a difference with this `shadow` modifier yet though, because
    its color is white, and we’re working over a white background. When we add a gradient
    to the whole background later, the shadow will become more prominent.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整这些数字和阴影的颜色，你可以看到我们使用的值对阴影位置和强度的影响有多大。不过，尽管如此，你仍然不太可能看到`shadow`修饰符带来的明显差异，因为它的颜色是白色，而我们是在白色背景上工作的。当我们稍后为整个背景添加渐变时，阴影将变得更加突出。
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can easily see which modifiers you have on any given view by the way Xcode
    indents them. For example, look at the `Rectangle` view again. Its two modifiers,
    `frame` and `cornerRadius`, are indented to the right, which means they are acting
    on the rectangle only. The same goes for `Image("Woodgrain")`; its two modifiers
    are indented to the right as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过Xcode缩进来轻松地看到任何给定视图上的修饰符。例如，再次查看`Rectangle`视图。它的两个修饰符`frame`和`cornerRadius`向右缩进，这意味着它们只作用于矩形。同样，对于`Image("Woodgrain")`；它的两个修饰符也向右缩进。
- en: 'Here’s a quick shortcut if your code starts to get messy and the indenting
    is not lined up: press *Command* + *A* to select everything in the file, and then
    press *Control* + *I*. Xcode then properly indents the whole file, every bit of
    code, in one go.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的代码开始变得混乱，缩进没有对齐，这里有一个快捷方式：按下*Command* + *A*选择文件中的所有内容，然后按下*Control* + *I*。Xcode然后一次性正确缩进整个文件，每一行代码。
- en: 'Now, look at **Preview** to see how your record player box looks. The following
    is what I have according to the code we have written:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看**预览**窗口，看看你的唱片机盒子看起来如何。以下是根据我们编写的代码我所看到的内容：
- en: '![Figure 4.5: The finished box ](img/B18674_04_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：完成的盒子](img/B18674_04_05.jpg)'
- en: 'Figure 4.5: The finished box'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：完成的盒子
- en: Before we continue, I want to show you how you can alter the previews to display
    your creations in a size that fits the view or views on the screen. Notice in
    *Figure 4**.5* that our box is much smaller than the iPhone **Preview** screen;
    sometimes, you might want to preview what you make in a screen size that fits
    the size of the view you just made – in our example, we made a box view. Here
    is how to shrink the **Preview** screen down to fit the box view.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，我想向你展示如何修改预览，以显示适合屏幕上视图或视图的大小。注意在*图 4.5*中，我们的盒子比 iPhone **预览**屏幕小得多；有时，你可能想要在一个适合你刚刚制作的视图大小的屏幕上预览你所做的，在我们的例子中，我们制作了一个盒子视图。以下是缩小**预览**屏幕以适应盒子视图的方法。
- en: At the bottom of every SwiftUI file is a struct that will have the same name
    as the struct we just used to write our code. This is a special struct that is
    used for development purposes, and it creates the **Preview** window that we need
    so we can see our work in real time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个 SwiftUI 文件的底部都有一个结构体，其名称将与我们刚才用来编写代码的结构体相同。这是一个用于开发目的的特殊结构体，它创建了我们需要的**预览**窗口，这样我们就可以实时查看我们的工作。
- en: 'Inside the preview struct, add this modifier right at the end of the `RecordPlayerBox()`
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在预览结构体中，在`RecordPlayerBox()`代码的末尾添加以下修饰符：
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `sizeThatFits` value will bring the **Preview** window size down
    to about the same size as our finished box. I don’t want it exactly the same size,
    so I added a bit of padding around it. Here is the result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`sizeThatFits`值将**预览**窗口的大小降低到与我们的完成盒子大致相同的大小。我不想让它完全一样的大小，所以我给它周围添加了一些填充。这是结果：
- en: '![Figure 4.6: The finished box fitting to the Preview screen ](img/B18674_04_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：完成的盒子适应预览屏幕](img/B18674_04_06.jpg)'
- en: 'Figure 4.6: The finished box fitting to the Preview screen'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：完成的盒子适应预览屏幕
- en: By using the `previewLayout` modifier, you can customize the **Preview** window
    to suit your needs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`previewLayout`修饰符，你可以自定义**预览**窗口以满足你的需求。
- en: 'And that’s our finished box. Simple, right? Now, with the record player box
    done, we can move on to our next objective: creating the spinning record.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的完成盒子。简单，对吧？现在，唱片机盒子完成之后，我们可以继续我们的下一个目标：创建旋转唱片。
- en: Creating the spinning record
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建旋转唱片
- en: As mentioned earlier, our second file is going to contain the record code. However,
    for simplicity’s sake, we’re actually going to make the record player arm and
    button in this file too. We could split those tasks up into separate files as
    we did with the box, so each part has its own file, but I think that for this
    small project, this one file will do the job for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们的第二个文件将包含唱片代码。然而，为了简单起见，我们实际上将在这个文件中也制作唱片机臂和按钮。我们可以像处理盒子那样将这些任务分开到单独的文件中，这样每个部分都有自己的文件，但我认为对于这个小型项目，这个文件就可以为我们完成工作。
- en: 'Since we are creating three different views in this one file, let’s give it
    a name that reflects each view the file will have, so `RecordButtonArmView`. Now,
    do you remember how to make a new SwiftUI file? If not, jump back to the *Creating
    the record player box* section for a refresher. There’s also a shortcut to creating
    a new file: simply press *Command* + *N* and choose the file template you want
    to use; we want the **SwiftUI View** template from the options.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在这个文件中创建了三个不同的视图，让我们给它起一个名字，反映文件将拥有的每个视图，所以叫`RecordButtonArmView`。现在，你还记得如何创建一个新的
    SwiftUI 文件吗？如果不记得，请回到*创建唱片机盒子*部分进行复习。还有一个创建新文件的快捷方式：只需按下*Command* + *N*，然后选择你想要使用的文件模板；我们想要的是选项中的**SwiftUI
    View**模板。
- en: 'With the file made, let’s work on making that spinning record. As we have done
    before, we will need properties to make everything work, so working at the top
    of the file, within the struct, add the following variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 文件创建完成后，让我们着手制作那个旋转唱片。就像我们之前做的那样，我们需要属性来使一切正常工作，所以我们在文件的顶部，在结构体内部，添加以下变量：
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One of these variables is a little different, so let me explain what we’re doing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个变量有点不同，让我解释一下我们在做什么。
- en: The first three variables are `State` variables. The `rotateRecord` variable
    is going to keep track of the spinning record and will initiate the spinning animation
    when its value changes to `true`. The next `State` variable, `moveArm`, will keep
    track of the record player arm, and the third `State` variable, `duration`, is
    used to set the duration of the spinning record.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个变量是`State`变量。`rotateRecord`变量将跟踪旋转的唱片，并在其值变为`true`时启动旋转动画。下一个`State`变量`moveArm`将跟踪唱机臂，第三个`State`变量`duration`用于设置旋转唱片的持续时间。
- en: The final variable is a computed property. A computed property is a property
    that does not store a value but is, instead, computed every time it is accessed,
    meaning the code in its body will run every time the variable is used. The property
    we made is of the `Animation` type, which means we can use this in the `animation`
    modifiers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个变量是一个计算属性。计算属性是一个不存储值而是每次访问时都会计算其值的属性，这意味着其体内的代码会在每次变量使用时运行。我们创建的属性是`Animation`类型，这意味着我们可以在`animation`修饰符中使用它。
- en: By using `Animation.linear`, we initialize this variable with a linear timing
    curve for the animation. Remember we talked about timing curves in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034)
    – a linear curve is a curve with no easing in or easing out; it’s simply a steady,
    non-fluctuating animation from the beginning to the middle, and to the end.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Animation.linear`，我们为动画初始化这个变量，使用线性时间曲线。记得我们讨论过[*第2章*](B18674_02.xhtml#_idTextAnchor034)中的时间曲线——线性曲线是一个没有缓动进入或缓动退出的曲线；它是一个从开始到中间再到结束的稳定、无波动的动画。
- en: Then, by keeping the `duration` parameter as `0`, this means the animation will
    have no duration and cannot start yet. This will change in order to start the
    animation later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将`duration`参数保持为`0`，这意味着动画将没有持续时间，还不能开始。这将改变，以便稍后开始动画。
- en: Then, we’re using the `repeatForever` option because we want the spinning record
    to keep going until we stop it. And finally, the `autoReverses` parameter is set
    to `false`, as we don’t want the record to spin backward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`repeatForever`选项，因为我们希望旋转的唱片继续旋转，直到我们停止它。最后，`autoReverses`参数设置为`false`，因为我们不希望唱片反向旋转。
- en: 'Using a computed property in this way simplifies things, as now we only need
    to pass that property into the `animation` modifier, and four values will have
    been set with one computed property: `Animation.linear` curve, `duration`, `repeatForever`,
    and `autoReverses`. A computed property is also helpful if you are calling the
    animation modifier in several different places because rather than changing all
    the separate places to alter the animation, you could simply change the variable
    in one place. For example, if you want the auto-reverse feature in all of your
    other animations, all you have to do is change `autoreverses` in one place to
    `true`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用计算属性可以简化事情，因为现在我们只需要将那个属性传递给`animation`修饰符，一个计算属性就会设置四个值：`Animation.linear`曲线、`duration`、`repeatForever`和`autoReverses`。如果你在多个不同位置调用动画修饰符，计算属性也非常有用，因为你不需要改变所有单独的位置来改变动画，只需简单地更改一个位置中的变量。例如，如果你想在你所有的其他动画中都有自动反转功能，你只需要将`autoreverses`在一个位置更改为`true`。
- en: 'We now have all the variables we need to set up this file. Next, we will actually
    add the record. Let’s first put everything in a main `ZStack`, which will hold
    all the views:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了设置这个文件所需的所有变量。接下来，我们将实际添加记录。首先，让我们将所有内容放入一个主`ZStack`中，它将包含所有视图：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of code accesses the `"record"` image in the Assets catalog to
    create the record on the screen by using the `Image` initializer (just as we did
    with the `"``woodGrain"` image).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码通过`Image`初始化器访问资产目录中的`"record"`图像，在屏幕上创建唱片（就像我们处理`"woodGrain"`图像一样）。
- en: Next, by using the `resizable` modifier again to initiate the resizing, we can
    change the size of the record image by using the `frame` modifier. Passing in
    a value of `280` points for the width and height makes the image just right for
    the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次使用`resizable`修饰符来启动调整大小，我们可以通过使用`frame`修饰符来改变记录图像的大小。传入宽度为`280`点，高度为`280`点的值，使图像正好适合屏幕。
- en: In the next line of code, we added the `rotationEffect` modifier to the record.
    This modifier will rotate (or spin) the image to any angle we want. For the `degrees`
    parameter, we’re using the ternary operator and rotating the record `360` degrees,
    which is one full rotation. So, the record will spin one complete revolution,
    but it will only do so when the `rotateRecord` variable becomes `true`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行代码中，我们向记录中添加了`rotationEffect`修饰符。这个修饰符会将图像旋转（或旋转）到我们想要的任何角度。对于`degrees`参数，我们使用三元运算符并将记录旋转`360`度，这是一个完整的旋转。因此，记录将完成一次完整的旋转，但只有在`rotateRecord`变量变为`true`时才会这样做。
- en: 'Next, we added the animation to the record, by using the `animation` modifier
    and passing in the `animateForever` computed property for its first parameter.
    Remember, this property is doing a few things for us already: it’s setting a timing
    curve to linear, making the animation repeat forever, and stopping the animation
    from playing in reverse.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`animation`修饰符并传入`animateForever`计算属性作为其第一个参数，将动画添加到记录中。记住，这个属性已经为我们做了几件事情：它设置了一个线性时间曲线，使动画无限重复，并阻止动画反向播放。
- en: Notice the use of the `delay` modifier. This will add a 1.5-second delay to
    the start of the spinning record. This delay is added because old record players
    didn’t start spinning until the arm swung over the record first. This will add
    a little realism to the animation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到`delay`修饰符的使用。这将给旋转唱片的开头添加1.5秒的延迟。这个延迟被添加是因为旧式唱机在臂越过唱片后才开始旋转。这将给动画增加一点现实感。
- en: Finally, the animation’s `value` parameter gets passed in the `rotateRecord`
    variable, which supplies the animation to the record.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，动画的`value`参数通过`rotateRecord`变量传递，为记录提供动画。
- en: 'Before we move onto the record player arm, let’s make **Preview** smaller so
    it reflects the size of the record, just like we did with the box:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始处理唱机臂之前，让我们将**预览**缩小，使其反映唱机的尺寸，就像我们处理盒子时做的那样：
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the record is complete and ready to spin some tunes. Here’s what it looks
    like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唱片已经完成并准备好播放音乐。看起来是这样的：
- en: '![Figure 4.7: Record disk ](img/B18674_04_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图4.7：唱片](img/B18674_04_07.jpg)'
- en: 'Figure 4.7: Record disk'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.7：唱片
- en: Nothing will happen yet because we have to add the other views and functionality,
    but we’re making good progress. Next up, let’s work on the record player arm.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 目前还没有发生任何事情，因为我们必须添加其他视图和功能，但我们正在取得良好的进展。接下来，让我们开始处理唱机臂。
- en: Creating the record player arm
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建唱机臂
- en: 'With the spinning record completed, the next objective is the record player’s
    arm. Still working in the `RecordButtonArmView` file, here is the code I want
    you to add, just underneath the call to the `animation` modifier for the record:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 完成旋转的记录后，下一个目标是唱机的臂。仍然在`RecordButtonArmView`文件中工作，下面是我想要你添加的代码，就在调用记录的`animation`修饰符之后：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the record image, we use the `Image` initializer to display the `"playerArm"`
    image that we imported earlier into the Assets catalog. It gets resizable behaviors
    using the `resizable` modifier, and the aspect ratio is set to `fit`, which will
    fit the image proportionally on the screen. Next, the image’s width and height
    are set to `150` points, using the `frame` modifier, as we have seen before.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 与记录图像类似，我们使用`Image`初始化器来显示我们之前导入到资产目录中的`"playerArm"`图像。它使用`resizable`修饰符获得可调整大小的行为，并将宽高比设置为`fit`，这将按比例将图像适配到屏幕上。接下来，使用`frame`修饰符将图像的宽度和高度设置为`150`点，正如我们之前所看到的。
- en: Continuing, the next line of code sets a shadow with a gray color and casts
    it around the arm with a `2`-point radius. If you like, you can change the radius
    to whatever size you prefer, and experiment to see what works for you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 继续操作，下一行代码设置了一个灰色阴影，并以`2`点半径投射到臂上。如果你喜欢，你可以将半径更改为你喜欢的任何大小，并尝试看看什么对你来说效果最好。
- en: Then, the arm gets rotated by -35 degrees; this value lines it up perpendicular
    with the record on the left. Also, we set the anchor point here to `topTrailing`,
    so when the arm swings over the record, the `topTrailing` (or top-right) anchor
    point will not move but will serve as a pivot point for the whole arm to move.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，臂被旋转了-35度；这个值使其与左侧的唱片垂直对齐。我们还在这里设置了锚点为`topTrailing`，所以当臂越过唱片时，`topTrailing`（或右上角）锚点不会移动，但将作为整个臂移动的支点。
- en: The next line of code calls the `rotationEffect` modifier again – this time,
    passing in the `moveArm` variable. Once this becomes `true`, the arm will move
    `8` points to the left, and when it’s `false`, it goes back to its original spot,
    using a value of `0`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码再次调用`rotationEffect`修改器——这次传递的是`moveArm`变量。一旦这个变量变为`true`，臂部将向左移动`8`点，而当它是`false`时，它将回到原来的位置，使用值为`0`。
- en: As we have seen, to have an animation, we need the `animation` modifier, which
    is the next line of code. This has a linear timing curve and sets the animation
    to 2 seconds to complete, meaning it should take the arm 2 seconds to move over
    the record.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要有一个动画，我们需要`animation`修改器，这是下一行代码。它有一个线性时间曲线，并将动画设置为2秒完成，这意味着臂部应该用2秒时间移动到唱片上。
- en: Finally, we need to position the arm just right in relation to the spinning
    record, so using the `offset` modifier here, we can place it exactly where we
    want on the record player box. For our purposes, a record player’s arm is usually
    placed to the right of the record, with an inch or two of spacing between the
    arm and the record.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将臂部放置在相对于旋转唱片的位置恰到好处，因此在这里使用`offset`修改器，我们可以将其放置在唱机盒上我们想要的确切位置。就我们的目的而言，唱机的臂通常放置在唱片右侧，臂和唱片之间有一英寸或两英寸的间隔。
- en: 'Here’s what the project should look like so far with the arm in place:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，项目应该看起来是这样的，臂部已经放置好：
- en: '![Figure 4.8: Record player arm ](img/B18674_04_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：唱机臂](img/B18674_04_08.jpg)'
- en: 'Figure 4.8: Record player arm'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：唱机臂
- en: We’re actually almost done with the project, but two more key components are
    needed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们几乎完成了这个项目，但还需要两个关键组件。
- en: The first of these is a button that will start and stop the animation. This
    will be a dynamic button, meaning that the title of the button will change depending
    on what it’s doing. If the record player is not playing a record, we will keep
    the button color black, display the word **Play**, and show the triangular *play*
    symbol. If the record player is playing the record, then the button will be red,
    display the word **Stop**, and show the square *stop* symbol instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能中的第一个是一个可以开始和停止动画的按钮。这将是一个动态按钮，意味着按钮的标题会根据其功能而改变。如果唱机没有播放唱片，我们将保持按钮颜色为黑色，显示文字**播放**，并显示三角形的*播放*符号。如果唱机正在播放唱片，那么按钮将变为红色，显示文字**停止**，并显示正方形的*停止*符号。
- en: The second component is to add sound to the project. This involves importing
    an audio/video framework specifically made for sound and video files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是为项目添加声音。这涉及到导入一个专门为音频/视频文件制作的音频/视频框架。
- en: Let’s tackle the button component first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理按钮组件。
- en: Adding a custom dynamic button
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义动态按钮
- en: A button is a control that performs an action when triggered. It can be configured
    to display a text label, an image, or both. When the user taps it, an action is
    sent to its target, which can trigger a method to be executed. So, let’s add one
    now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是一个在触发时执行动作的控制。它可以配置为显示文本标签、图像或两者兼而有之。当用户点击它时，会向其目标发送一个动作，这可以触发要执行的方法。所以，我们现在就添加一个。
- en: 'Still working in the `RecordButtonArmView` file, as before, I will add the
    button code, and then explain how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`RecordButtonArmView`文件中工作，就像之前一样，我将添加按钮代码，然后解释它是如何工作的：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Button` control has an `action` parameter, and this is where we put the
    code that we want to be executed when the button is pressed. Inside this `action`
    closure, we toggled the `rotateRecord` variable before doing anything else. The
    reason for this is that we want the button to change the state of the variable
    because that’s the one that controls the spinning record. So, by toggling it,
    we’re changing the state right away.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`控制有一个`action`参数，这就是我们放置当按钮被按下时要执行代码的地方。在这个`action`闭包内部，我们在做其他任何事情之前切换了`rotateRecord`变量。这样做的原因是我们希望按钮改变变量的状态，因为这是控制旋转唱片的变量。所以，通过切换它，我们立即改变了状态。'
- en: Next, we checked to see what the state of `rotateRecord` is when using an `if
    else` statement. If it’s `true`, we set the duration variable to `0.8` seconds,
    as that’s how long we want it to take for the record to spin one revolution (this
    is a good speed for producing a spinning record effect). Next, we want to set
    the `moveArm` variable to `true` when the button is pressed, because setting that
    to `true` gets the arm to move over the record by `8` degrees.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查使用`if else`语句时`rotateRecord`的状态。如果它是`true`，我们将持续时间变量设置为`0.8`秒，因为这是我们希望唱片旋转一周所需的时间（这是产生旋转唱片效果的好速度）。接下来，我们希望在按钮按下时将`moveArm`变量设置为`true`，因为将其设置为`true`会使臂移动到唱片上`8`度。
- en: 'All of that happens if `rotateRecord` is true, but if it’s `false`, the code
    falls into the `else` block. In the `else` block, the `duration` is set to `0`,
    which effectively stops the record from spinning, and `moveArm` is set to `false`,
    which will allow the arm to animate back to its original starting position: off
    the record, and to the right side.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在`rotateRecord`为`true`时发生，但如果它是`false`，代码将进入`else`块。在`else`块中，`duration`被设置为`0`，这实际上停止了唱片的旋转，`moveArm`被设置为`false`，这将允许臂动画回到其原始起始位置：离开唱片，并移向右侧。
- en: 'Then, we move into the labeling part of the button. Within this initializer,
    I declared an `HStack`, and inside there, another `if else` statement. I’m using
    the not operator (`!`) in front of the `rotateRecord` variable too, which will
    read like this: if the `rotateRecord` variable is not `true` (this is another
    way of saying the variable is `false`), then the record is not playing, so set
    the text for the button to the word `"Play"`, make it bold and black, and provide
    a system image for it (a triangular *play* button). But if the code falls into
    the `else` block here, it means the record is spinning; in this case, we want
    to make the text bold, change the foreground color to red, and provide a system
    image of a *stop* button.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入按钮的标签部分。在这个初始化器中，我声明了一个`HStack`，并在其中使用了一个`if else`语句。我在`rotateRecord`变量前面也使用了非运算符（`!`），这将读作：如果`rotateRecord`变量不是`true`（这是另一种说变量是`false`的方式），则唱片没有播放，因此将按钮的文本设置为单词`"Play"`，使其加粗并变黑，并提供一个系统图像（一个三角形的*播放*按钮）。但如果代码进入这里的`else`块，则意味着唱片正在旋转；在这种情况下，我们希望使文本加粗，将前景色改为红色，并提供一个*停止*按钮的系统图像。
- en: To finish off the button, we added a little bit of padding on its horizontal
    and vertical sides, gave it a capsule shape, and used the `strokeBorder` modifier
    to put a `2`-point black line around the button.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成按钮，我们在其水平和垂直两侧添加了一些填充，使其呈胶囊形状，并使用`strokeBorder`修饰符在按钮周围绘制了一条2点的黑色线条。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be wondering, why use the not operator (`!`) when you can say `if
    false` instead? You can use the `if false` statement instead of `if !true`, but
    the `!` operator can help to make your code more readable. For example, consider
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么使用非运算符（`!`）而不是可以说`if false`？你可以使用`if false`语句代替`if !true`，但`!`运算符可以帮助使你的代码更易读。例如，考虑以下代码：
- en: '`if !``fingerprintAccepted {`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`if !fingerprintAccepted {`'
- en: '`//``access granted`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`//access granted`'
- en: '`}` `else {`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` `else {`'
- en: '`//``access denied`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`//access denied`'
- en: '`}`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The `!` operator negates the Boolean value, making the code more readable because
    it emphasizes the opposite of what is expected. In the example, if `fingerprintAccepted`
    is `false`, access will be granted. If `fingerprintAccepted` is `true`, access
    will be denied. The `!` operator makes it clear that the code is checking for
    the opposite of `fingerprintAccepted`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符否定布尔值，使代码更易读，因为它强调了预期的相反。在示例中，如果`fingerprintAccepted`为`false`，则允许访问。如果`fingerprintAccepted`为`true`，则拒绝访问。`!`运算符清楚地表明代码正在检查`fingerprintAccepted`的相反值。'
- en: 'With that code placed into your project, the current interface should look
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将该代码放入您的项目中后，当前界面应如下所示：
- en: '![Figure 4.9: Adding the button control ](img/B18674_04_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：添加按钮控件](img/B18674_04_09.jpg)'
- en: 'Figure 4.9: Adding the button control'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：添加按钮控件
- en: Now, there’s a **Play** button to control the record. Next up, we want our record
    player animation to actually play sound, so let’s do that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个**播放**按钮来控制录音。接下来，我们希望我们的唱片机动画能够实际播放声音，所以让我们来做这件事。
- en: Creating a sound file to play audio
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个音频文件以播放音频
- en: Now, we are going to add sound to the project so that it plays when the record
    spins. To do this, navigate back to the GitHub folder for this project and drag
    the `.m4a` file called `music` into the Project navigator. Make sure to check
    the **Copy files to project** box if that box is unchecked.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向项目中添加声音，以便在录音旋转时播放。为此，导航回此项目的GitHub文件夹，并将名为`music`的`.m4a`文件拖放到项目导航器中。如果该框未被勾选，请确保勾选**Copy
    files to project**框。
- en: With our `.m4a` audio file, we need to create a separate Swift file for this
    sound. Press *Command* + *N* to create a new file, but instead of creating a SwiftUI
    View file, we will create a simple Swift file instead. Then, name it `PlaySound`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`.m4a`音频文件，我们需要为这个声音创建一个单独的Swift文件。按*Command* + *N*键创建一个新文件，但不要创建SwiftUI
    View文件，而是创建一个简单的Swift文件。然后，将其命名为`PlaySound`。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between a SwiftUI View file and Swift file is the purpose
    of the code contained in the file. A SwiftUI View file contains the code needed
    to define a view and its layout, while Swift file can contain a wide range of
    code that is not specifically related to defining views.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI View文件和Swift文件之间的主要区别是文件中包含的代码的目的。SwiftUI View文件包含定义视图及其布局所需的代码，而Swift文件可以包含广泛与定义视图无关的代码。
- en: 'In this file, the first thing we need to do is import the `AVFoundation` framework:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先需要做的是导入`AVFoundation`框架：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AVFoundation` framework includes classes and methods that allow developers
    to manipulate and work with audio and video in their apps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVFoundation`框架包括类和方法，允许开发者在他们的应用程序中操作和与音频和视频一起工作。'
- en: 'Next, let’s instantiate (create) an audio player:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实例化（创建）一个音频播放器：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that this variable is an optional type, denoted by a question mark at
    the end. I made it optional because if for any reason the music file cannot be
    found within the project, it will stop the app from crashing. Instead, the app
    will still work but simply won’t play the music.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个变量是一个可选类型，其末尾有一个问号。我将其设置为可选，因为如果出于任何原因在项目中找不到音乐文件，它将阻止应用程序崩溃。相反，应用程序仍然可以工作，但只是不会播放音乐。
- en: 'Now, let’s now create a function called `playSound` that will search through
    the project for the audio file, and load it if it finds it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`playSound`的函数，该函数将在项目中搜索音频文件，并在找到时加载它：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s how the function works. It has two parameters, both of which are strings:
    one is called `sound` and the other is called `type`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数的工作原理。它有两个参数，都是字符串：一个叫做`sound`，另一个叫做`type`。
- en: The first thing we do is to create a `path` constant using what is called `if
    let` statement. Optional binding is a feature that lets us check the value of
    an optional, and if there is a value in it (meaning it’s not nil), then bind that
    optional to a variable or constant.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是使用所谓的`if let`语句创建一个`path`常量。可选绑定是一个特性，它允许我们检查可选值，如果其中包含值（意味着它不是nil），则将该可选绑定到变量或常量。
- en: This constant called `path` will be assigned a path from the app’s bundle. The
    bundle is where the app and its resources are stored, and we need to get the path
    to the sound file that we added to the project, which is in the app’s bundle.
    We can access the main bundle of the app by using the `Bundle.main` property.
    This property returns a `Bundle` object that represents the main bundle of the
    app, and we can use this object to access any of the resources in the app, such
    as images, sounds, or other files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`path`的常量将被分配一个来自应用程序包的路径。包是应用程序及其资源存储的地方，我们需要获取添加到项目中的声音文件的路径，该文件位于应用程序包中。我们可以通过使用`Bundle.main`属性来访问应用程序的主包。这个属性返回一个表示应用程序主包的`Bundle`对象，我们可以使用这个对象来访问应用程序中的任何资源，例如图像、声音或其他文件。
- en: 'So, the `if let` statement reads as follows: the code searches the main bundle
    for a file with the given sound’s name and type extension. If found, the file
    path is stored in the `path` constant and runs the code in the `do` block. Otherwise,
    if for whatever reason the path to the file can’t be found, then the file we are
    looking for is missing or corrupt, and the flow of the program will proceed into
    the `catch` block and execute the code there.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`if let`语句的读取方式如下：代码会在主包中搜索具有给定声音名称和类型扩展名的文件。如果找到，则将文件路径存储在`path`常量中，并在`do`块中运行代码。否则，如果由于任何原因找不到文件的路径，那么我们正在寻找的文件缺失或损坏，程序流程将进入`catch`块并执行那里的代码。
- en: Okay, let’s assume the file path has found our sound file, then the code moves
    into the `do` block, in which the code will try to create an audio player using
    that `path` constant. If that is successful, then it will try to play that file.
    But again, if for any reason the file can’t be played, the code will then fall
    into the `catch` block and print an error message to the console (`"Could not
    find and play the sound file"`). That error message won’t be shown to the user,
    it’s only for our debugging purposes, but the user’s app won’t crash with this
    code in place; the sound just won’t play.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们假设文件路径已经找到了我们的声音文件，然后代码进入`do`块，在这个块中，代码将尝试使用那个`path`常量创建一个音频播放器。如果这成功了，它将尝试播放那个文件。但是，如果由于任何原因文件无法播放，代码将进入`catch`块，并将错误消息打印到控制台（`"Could
    not find and play the sound file"`）。这个错误消息不会显示给用户，它只是为了我们的调试目的，但用户的应用程序不会因为这段代码而崩溃；只是声音不会播放。
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Here, it would be helpful to show the user an alert if we fall into the `catch`
    block; however, we won’t do that just yet. If you would like to do this, we will
    cover this in [*Chapter 12*](B18674_12.xhtml#_idTextAnchor172), where we create
    a word game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果我们进入`catch`块，显示一个警告给用户将是有帮助的；然而，我们目前不会这样做。如果您想这样做，我们将在[*第12章*](B18674_12.xhtml#_idTextAnchor172)中介绍，在那里我们创建一个文字游戏。
- en: Okay, we have everything in place to test the app, but before we can do that,
    we need to combine our three files – the `RecordPlayerBox`, `RecordButtonArmView`,
    and `PlaySound` files – into one unified view.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，我们已经将所有东西都准备好了来测试应用程序，但在我们能够这样做之前，我们需要将我们的三个文件——`RecordPlayerBox`、`RecordButtonArmView`和`PlaySound`文件——合并成一个统一的视图。
- en: Combining all the elements into one view
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有元素合并到一个视图中
- en: 'To put all of our finished views together into one unified grouping to make
    the finished project, let’s go back into the `ContentView` file and add the following
    code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们所有的完成视图组合成一个统一的分组以制作完成的项目，让我们回到`ContentView`文件并添加以下代码：
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we’re using `ZStack` as the main view because we want to layer our other
    views on top of each other.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们使用`ZStack`作为主视图，因为我们想将其他视图叠加在一起。
- en: 'First, let’s look at the `RadialGradient` view. This is a struct that takes
    an array of colors that are placed one by one between the open and closed brackets.
    Within those brackets, you can put as many colors as you want, separating each
    color by a comma (I’m using two colors: white and black).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们看看`RadialGradient`视图。这是一个结构体，它接受一个颜色数组，这些颜色一个接一个地放在开闭括号之间。在这些括号内，你可以放尽可能多的颜色，每个颜色之间用逗号分隔（我在这里使用两种颜色：白色和黑色）。
- en: 'The `RadialGradient` view works by using the first color in the array to color
    the center of the background, and subsequent colors will surround that center.
    Using `startRadius` and `endRadius` values of `20` and `600`, respectively, will
    make the radial gradient expand to cover the entire screen; however, it doesn’t
    include the safe areas of the iPhone (again, those are that little area by the
    notch at the top and a small area at the bottom of the phone). We can handle the
    safe areas in two ways: we can use the `ignoreSafeArea` modifier as we’ve done
    before, or we can use the `scaleEffect` modifier as we are doing here. By passing
    in `1.2` as a value for the `scaleEffect` modifier, the gradient scales up 1.2
    times the size of the iPhone screen, covering all the edges. This is effectively
    doing the same thing as the `ignoreSafeArea` modifier would do.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`RadialGradient`视图通过使用数组中的第一个颜色来着色背景的中心，后续的颜色将围绕那个中心。使用`startRadius`和`endRadius`的值分别为`20`和`600`，可以使径向渐变扩展以覆盖整个屏幕；然而，它不包括iPhone的安全区域（再次强调，那些是顶部缺口附近的小区域和手机底部的小区域）。我们可以用两种方式处理安全区域：我们可以使用之前使用过的`ignoreSafeArea`修饰符，或者我们可以使用这里使用的`scaleEffect`修饰符。通过将`1.2`作为`scaleEffect`修饰符的值传递，渐变将扩展到iPhone屏幕的1.2倍大小，覆盖所有边缘。这实际上与`ignoreSafeArea`修饰符所做的是一样的。'
- en: The next line of code makes a call to the `RecordPlayerBox` view and places
    it over the gradient (remember that we are working in `ZStack`, so views get stacked
    up onto one another). The final line of code makes a call to `RecordButtonArmView`,
    placing it over the box, to complete the interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码调用`RecordPlayerBox`视图并将其放置在渐变之上（记住我们正在`ZStack`中工作，所以视图会堆叠在一起）。最后一行代码调用`RecordButtonArmView`，将其放置在盒子之上，以完成界面。
- en: 'This is how our project will look (if you didn’t make any modifications along
    the way, that is):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们的项目将看起来像什么（如果你在过程中没有做任何修改的话）：
- en: '![Figure 4.10: The finished interface ](img/B18674_04_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10：完成后的界面](img/B18674_04_10.jpg)'
- en: 'Figure 4.10: The finished interface'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：完成后的界面
- en: The final piece of the puzzle is to use the sound file that we created. This
    is easy to do, so as a challenge, try and think of where you would place the audio
    code to get the app to play music.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是使用我们创建的声音文件。这很简单，所以作为一个挑战，试着想想你会在哪里放置音频代码，让应用播放音乐。
- en: 'Did you figure it out? If you thought of putting code into the body of the
    button, then you are correct! The button is the view that controls the action:
    it gets the arm to swing over the record, and the record to spin, as well. So,
    inside the `RecordButtonArmView` file, and then inside the button’s `if` statement,
    add the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你想出来了吗？如果你想到了在按钮的主体中放置代码，那么你是正确的！按钮是控制动作的视图：它使臂摆动到唱片上方，唱片也会旋转。所以，在 `RecordButtonArmView`
    文件中，然后在按钮的 `if` 语句中，添加以下代码：
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line of code calls the function that we made in the `PlaySound` file, passing
    in the name of our music file, which is simply called `music`, and the file extension
    for the `type` parameter, which is `m4a`. When the button is pressed, it means
    the user wants to spin the record and play the music, and this code will grab
    the music file and play it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码调用了我们在 `PlaySound` 文件中创建的函数，传递了我们的音乐文件名，简单地称为 `music`，以及 `type` 参数的文件扩展名，它是
    `m4a`。当按钮被按下时，意味着用户想要旋转唱片并播放音乐，这段代码将获取音乐文件并播放它。
- en: 'When the button is pressed again, that means the user wants to stop the music,
    so we need to add the following code to the `else` block to do just that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮再次被按下时，这意味着用户想要停止音乐，因此我们需要在 `else` 块中添加以下代码来做到这一点：
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This line of code calls the audio player that we created and uses the `stop`
    function to stop the music. Notice the use of the question mark before calling
    the `stop` function. That’s because the `audioPlayer` variable was created as
    an optional. When we create optional variables, we need to use the question mark
    or exclamation mark when using them too.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码调用了我们创建的音频播放器，并使用 `stop` 函数停止音乐。注意在调用 `stop` 函数之前使用问号。这是因为 `audioPlayer`
    变量被创建为可选的。当我们创建可选变量时，在使用它们时也需要使用问号或感叹号。
- en: Testing the project
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试项目
- en: 'And with that, the project is done. Let’s come back to `ContentView` and test
    everything out. If you hit the **Play** button in the **Preview** window or run
    it in the simulator, you should see that the record won’t start spinning until
    the player’s arm is directly over the record. As the record starts spinning, you
    should hear a golden oldy from the big band era of the 40s, complete with the
    scratchy intro sound that old records were notoriously famous for. You will also
    notice that the text on the button changes from **Play** to **Stop**, and the
    color of the button changes from black to red, as shown in this figure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，项目完成了。让我们回到 `ContentView` 并测试一下。如果你在 **预览** 窗口中点击 **播放** 按钮，或者在模拟器中运行它，你应该会看到唱片只有在播放器的臂直接在唱片上方时才会开始旋转。当唱片开始旋转时，你应该会听到来自
    40 年代大乐队时代的经典老歌，包括老唱片臭名昭著的嘶嘶声。你还会注意到按钮上的文字从 **播放** 变为 **停止**，按钮的颜色从黑色变为红色，如图所示：
- en: '![Figure 4.11: The spinning record ](img/B18674_04_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：旋转唱片](img/B18674_04_11.jpg)'
- en: 'Figure 4.11: The spinning record'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：旋转唱片
- en: When you press **Stop**, the arm goes back to its original place, the record
    stops, and the **Play** button will reappear again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 当你按下 **停止** 时，臂会回到原来的位置，唱片停止旋转，**播放** 按钮将再次出现。
- en: After all of that, that completes our second project!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 经过这一切，我们的第二个项目就完成了！
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: To recap what we covered in this project, we added images to the Assets catalog
    and accessed them in our code. Then, we created three separate files to hold the
    elements that we need – one to hold the record player box; one to hold the spinning
    record, the arm moved with an anchor point, and a dynamic button; and one in which
    we wrote code to access a sound file. Once we created these elements, we merged
    them into one view, to create a record and animated record player.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾我们在本项目中涵盖的内容，我们向资产目录中添加了图像并在我们的代码中访问它们。然后，我们创建了三个单独的文件来保存我们需要的元素——一个用于保存唱片机盒子；一个用于保存旋转唱片、移动的臂和动态按钮；还有一个用于编写代码以访问声音文件。一旦创建了这些元素，我们就将它们合并到一个视图中，以创建一个唱片和动画唱片机。
- en: In the next chapter, we’re going to continue working with Swift animations by
    exploring colors. We will create a simple project that displays various images
    and then, using `hueRotation`, change the color of the images to display a kaleidoscope
    effect. We will also look at how to pass data bidirectionally to another view,
    which gives up more flexibility than using the `@State` property wrapper.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过探索颜色来使用 Swift 动画。我们将创建一个简单的项目，显示各种图像，然后使用 `hueRotation` 改变图像的颜色，以显示万花筒效果。我们还将探讨如何双向传递数据到另一个视图，这比使用
    `@State` 属性包装器提供了更多的灵活性。
