- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Record Player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a record player that will move an arm over the
    record, make the record spin, and play music when a button is pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Sure, record players are a bit outdated now, but this project is a good way
    to learn new techniques about rotation – specifically, how to rotate objects around
    an anchor point. And you can always modify the design to look like a turntable,
    as many DJs still use vinyl, especially due to the vinyl resurgence in the last
    few years.
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, *didn’t we rotate circles in the first project?* Well,
    this project is different. In the last project, the rotation animation we applied
    was on SwiftUI-created shapes, (specifically, circles), but in this project, we
    will be applying a rotation animation onto a photo image, then controlling it
    with a button, and mixing in some sounds to add to the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s list our objectives for this project:'
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the record player elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining all the elements into one view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the finished project in the `Chapter 4` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, let’s get started on the first objective: adding some images to the project.
    First, we need to create a new project in Xcode. I called mine `Record Player`
    (you can copy this name or choose something else if you like). Then, we need to
    fill out the other fields exactly as we did in the last chapter. Once this is
    done, we are ready to start.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the images themselves, we need three: the record, the record
    player arm that will move over the record, and a wood grain image that we can
    use as the record player box. All of these images can be found on GitHub by clicking
    the link provided in the *Technical* *requirements* section.'
  prefs: []
  type: TYPE_NORMAL
- en: There are three main methods to add images to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is using Xcode’s special file folder called the `Assets.xcassets`
    file in Xcode and you will be taken to the Assets catalog. The catalog is split
    into two sections: the section on the left is where your files are listed, and
    the section on the right is where you can actually see your files when you click
    on them in the left pane. To bring your images into the catalog, simply drag them
    into the left column:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Adding files to the Assets catalog ](img/B18674_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Adding files to the Assets catalog'
  prefs: []
  type: TYPE_NORMAL
- en: These images will be accessible by referencing their name in the code we write
    (we will see how to do this shortly).
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method to add image files to the project is just by dragging and
    dropping them into the Project navigator. However, this method includes the extra
    step of choosing how and where you want to copy the files into the project via
    the following pop-up window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Adding files into the Project navigator ](img/B18674_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Adding files into the Project navigator'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you want to make sure that you tick the checkbox that says **Copy items
    if needed**. That’s important because Xcode will copy your files into the project,
    so if they are no longer available on your computer, it won’t matter, as they
    are part of your project now.
  prefs: []
  type: TYPE_NORMAL
- en: You also want to make sure that you check the boxes for the specific target
    you want to copy those resources to. For example, if you want to build the app
    on your Mac, then you want to check the **Record Player (macOS)** option in the
    **Add to targets** box. If you’re just building it for the iPhone, then check
    the **Record Player (iOS)** option. You can also check both if you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method is opening the **File** menu and selecting the **Add Files**
    **to…** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Adding files to the project via the File menu ](img/B18674_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Adding files to the project via the File menu'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added all the images, the next objective is to create the record
    player.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player elements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our record player, we will create three separate files, each in charge
    of performing specific tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: The first file will hold the record player box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second file will hold the spinning record, the record player arm, and the
    button to control it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third file will hold the sound file that will play when the record player
    animation starts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the first file.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the file to hold the record player box, in Xcode, open the **File**
    menu, select **New**, then select **File**. You will notice that this brings up
    several template options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Creating a new SwiftUI file ](img/B18674_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Creating a new SwiftUI file'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the top of the window, the row of tabs lets you select which platform
    you want to write code for. We’re only interested in iOS apps, so select the **iOS**
    tab. Then, under the **User Interface** heading, select **SwiftUI View**.
  prefs: []
  type: TYPE_NORMAL
- en: Click `RecordPlayerBox`. Make sure your targets are selected in the checkboxes
    so that the file and everything it contains will work correctly when you run the
    project. Once your targets have been set, click **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have our new file to write our code, and you’ll notice it’s the same
    as the `ContentView` file, except it’s called `RecordPlayerBox`. Working in the
    `body` property, we will start with a `ZStack`; this will be our main stack to
    hold all of our views. Within the `ZStack`, we can build a rectangle using one
    of the images in the Assets catalog. Enter the following code, and then let’s
    look at what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we added a `Rectangle` view, and then, using the `frame` modifier, it
    gets a dimension of `345` points for the width and height, making a square.
  prefs: []
  type: TYPE_NORMAL
- en: Then, using the `cornerRadius` modifier, we rounded the corners of the rectangle
    by `10` points.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code is the `Image` initializer, which is a view that displays
    an image. We want to use the wood grain image that’s in the Assets catalog, so
    we accessed it by typing the image’s name within quotes to create a string inside
    the `Image` initializer. In our case, we typed `"woodGrain"`.
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our image, but we have to resize it. In order to do that, we need
    to use the `resizable` modifier, which is used to prepare an image or other view
    to be resized so it fits within its parent view. When it’s applied to an `Image`
    view, the `resizable` modifier will determine how the image should be scaled to
    fit within the space available.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `frame` modifier resizes the wood image to a width and height of `325`
    points. This will make it a little smaller than the `Rectangle` dimensions; however,
    making it smaller will allow some of the rectangle edges to show through, creating
    a border. The reason why the border is black is that the default color for creating
    a rectangle shape is black, as it is with all shapes. We can change it to any
    color we want by using a `color` modifier, but I think I’ll leave it black here.
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code creates a shadow by using the `shadow` modifier. Again,
    all the modifiers we are adding are for the wood grain image, so each modifier
    placed on the wood grain has its own specific task of modifying the wood grain
    image in some way. Since this modifier is placed on the wood grain image and is
    using a white color, a white shadow will be radiating around the image. Setting
    the radius to a value of `3` means the shadow will extend out from the image by
    3 points. We can also choose to put a value in for the `x` and `y` parameters,
    which will move the shadow on those axes either left, right, up, or down.
  prefs: []
  type: TYPE_NORMAL
- en: How much the shadow is moved depends on the size of the value you put in. For
    example, if you put a value of `10` in for the `x` parameter, the shadow will
    extend out from the right edge 10 points; if you put a value of `10` in for the
    `y` parameter, the shadow will extend out 10 points from the bottom edge of the
    box. I put in a value of `0` because I want the shadow directly over the wood
    grain image; it won’t be shifted left or right or up and down.
  prefs: []
  type: TYPE_NORMAL
- en: Play with these numbers and with the color of the shadow so you can see how
    much the values that we’ve used affect the shadow location and intensity. Don’t
    expect to see much of a difference with this `shadow` modifier yet though, because
    its color is white, and we’re working over a white background. When we add a gradient
    to the whole background later, the shadow will become more prominent.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You can easily see which modifiers you have on any given view by the way Xcode
    indents them. For example, look at the `Rectangle` view again. Its two modifiers,
    `frame` and `cornerRadius`, are indented to the right, which means they are acting
    on the rectangle only. The same goes for `Image("Woodgrain")`; its two modifiers
    are indented to the right as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick shortcut if your code starts to get messy and the indenting
    is not lined up: press *Command* + *A* to select everything in the file, and then
    press *Control* + *I*. Xcode then properly indents the whole file, every bit of
    code, in one go.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at **Preview** to see how your record player box looks. The following
    is what I have according to the code we have written:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The finished box ](img/B18674_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The finished box'
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, I want to show you how you can alter the previews to display
    your creations in a size that fits the view or views on the screen. Notice in
    *Figure 4**.5* that our box is much smaller than the iPhone **Preview** screen;
    sometimes, you might want to preview what you make in a screen size that fits
    the size of the view you just made – in our example, we made a box view. Here
    is how to shrink the **Preview** screen down to fit the box view.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of every SwiftUI file is a struct that will have the same name
    as the struct we just used to write our code. This is a special struct that is
    used for development purposes, and it creates the **Preview** window that we need
    so we can see our work in real time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the preview struct, add this modifier right at the end of the `RecordPlayerBox()`
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `sizeThatFits` value will bring the **Preview** window size down
    to about the same size as our finished box. I don’t want it exactly the same size,
    so I added a bit of padding around it. Here is the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: The finished box fitting to the Preview screen ](img/B18674_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: The finished box fitting to the Preview screen'
  prefs: []
  type: TYPE_NORMAL
- en: By using the `previewLayout` modifier, you can customize the **Preview** window
    to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s our finished box. Simple, right? Now, with the record player box
    done, we can move on to our next objective: creating the spinning record.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the spinning record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, our second file is going to contain the record code. However,
    for simplicity’s sake, we’re actually going to make the record player arm and
    button in this file too. We could split those tasks up into separate files as
    we did with the box, so each part has its own file, but I think that for this
    small project, this one file will do the job for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are creating three different views in this one file, let’s give it
    a name that reflects each view the file will have, so `RecordButtonArmView`. Now,
    do you remember how to make a new SwiftUI file? If not, jump back to the *Creating
    the record player box* section for a refresher. There’s also a shortcut to creating
    a new file: simply press *Command* + *N* and choose the file template you want
    to use; we want the **SwiftUI View** template from the options.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the file made, let’s work on making that spinning record. As we have done
    before, we will need properties to make everything work, so working at the top
    of the file, within the struct, add the following variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: One of these variables is a little different, so let me explain what we’re doing.
  prefs: []
  type: TYPE_NORMAL
- en: The first three variables are `State` variables. The `rotateRecord` variable
    is going to keep track of the spinning record and will initiate the spinning animation
    when its value changes to `true`. The next `State` variable, `moveArm`, will keep
    track of the record player arm, and the third `State` variable, `duration`, is
    used to set the duration of the spinning record.
  prefs: []
  type: TYPE_NORMAL
- en: The final variable is a computed property. A computed property is a property
    that does not store a value but is, instead, computed every time it is accessed,
    meaning the code in its body will run every time the variable is used. The property
    we made is of the `Animation` type, which means we can use this in the `animation`
    modifiers.
  prefs: []
  type: TYPE_NORMAL
- en: By using `Animation.linear`, we initialize this variable with a linear timing
    curve for the animation. Remember we talked about timing curves in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034)
    – a linear curve is a curve with no easing in or easing out; it’s simply a steady,
    non-fluctuating animation from the beginning to the middle, and to the end.
  prefs: []
  type: TYPE_NORMAL
- en: Then, by keeping the `duration` parameter as `0`, this means the animation will
    have no duration and cannot start yet. This will change in order to start the
    animation later.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we’re using the `repeatForever` option because we want the spinning record
    to keep going until we stop it. And finally, the `autoReverses` parameter is set
    to `false`, as we don’t want the record to spin backward.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using a computed property in this way simplifies things, as now we only need
    to pass that property into the `animation` modifier, and four values will have
    been set with one computed property: `Animation.linear` curve, `duration`, `repeatForever`,
    and `autoReverses`. A computed property is also helpful if you are calling the
    animation modifier in several different places because rather than changing all
    the separate places to alter the animation, you could simply change the variable
    in one place. For example, if you want the auto-reverse feature in all of your
    other animations, all you have to do is change `autoreverses` in one place to
    `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We now have all the variables we need to set up this file. Next, we will actually
    add the record. Let’s first put everything in a main `ZStack`, which will hold
    all the views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code accesses the `"record"` image in the Assets catalog to
    create the record on the screen by using the `Image` initializer (just as we did
    with the `"``woodGrain"` image).
  prefs: []
  type: TYPE_NORMAL
- en: Next, by using the `resizable` modifier again to initiate the resizing, we can
    change the size of the record image by using the `frame` modifier. Passing in
    a value of `280` points for the width and height makes the image just right for
    the screen.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line of code, we added the `rotationEffect` modifier to the record.
    This modifier will rotate (or spin) the image to any angle we want. For the `degrees`
    parameter, we’re using the ternary operator and rotating the record `360` degrees,
    which is one full rotation. So, the record will spin one complete revolution,
    but it will only do so when the `rotateRecord` variable becomes `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we added the animation to the record, by using the `animation` modifier
    and passing in the `animateForever` computed property for its first parameter.
    Remember, this property is doing a few things for us already: it’s setting a timing
    curve to linear, making the animation repeat forever, and stopping the animation
    from playing in reverse.'
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `delay` modifier. This will add a 1.5-second delay to
    the start of the spinning record. This delay is added because old record players
    didn’t start spinning until the arm swung over the record first. This will add
    a little realism to the animation.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the animation’s `value` parameter gets passed in the `rotateRecord`
    variable, which supplies the animation to the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move onto the record player arm, let’s make **Preview** smaller so
    it reflects the size of the record, just like we did with the box:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the record is complete and ready to spin some tunes. Here’s what it looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Record disk ](img/B18674_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Record disk'
  prefs: []
  type: TYPE_NORMAL
- en: Nothing will happen yet because we have to add the other views and functionality,
    but we’re making good progress. Next up, let’s work on the record player arm.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player arm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the spinning record completed, the next objective is the record player’s
    arm. Still working in the `RecordButtonArmView` file, here is the code I want
    you to add, just underneath the call to the `animation` modifier for the record:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the record image, we use the `Image` initializer to display the `"playerArm"`
    image that we imported earlier into the Assets catalog. It gets resizable behaviors
    using the `resizable` modifier, and the aspect ratio is set to `fit`, which will
    fit the image proportionally on the screen. Next, the image’s width and height
    are set to `150` points, using the `frame` modifier, as we have seen before.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing, the next line of code sets a shadow with a gray color and casts
    it around the arm with a `2`-point radius. If you like, you can change the radius
    to whatever size you prefer, and experiment to see what works for you.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the arm gets rotated by -35 degrees; this value lines it up perpendicular
    with the record on the left. Also, we set the anchor point here to `topTrailing`,
    so when the arm swings over the record, the `topTrailing` (or top-right) anchor
    point will not move but will serve as a pivot point for the whole arm to move.
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `rotationEffect` modifier again – this time,
    passing in the `moveArm` variable. Once this becomes `true`, the arm will move
    `8` points to the left, and when it’s `false`, it goes back to its original spot,
    using a value of `0`.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen, to have an animation, we need the `animation` modifier, which
    is the next line of code. This has a linear timing curve and sets the animation
    to 2 seconds to complete, meaning it should take the arm 2 seconds to move over
    the record.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to position the arm just right in relation to the spinning
    record, so using the `offset` modifier here, we can place it exactly where we
    want on the record player box. For our purposes, a record player’s arm is usually
    placed to the right of the record, with an inch or two of spacing between the
    arm and the record.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what the project should look like so far with the arm in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Record player arm ](img/B18674_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Record player arm'
  prefs: []
  type: TYPE_NORMAL
- en: We’re actually almost done with the project, but two more key components are
    needed.
  prefs: []
  type: TYPE_NORMAL
- en: The first of these is a button that will start and stop the animation. This
    will be a dynamic button, meaning that the title of the button will change depending
    on what it’s doing. If the record player is not playing a record, we will keep
    the button color black, display the word **Play**, and show the triangular *play*
    symbol. If the record player is playing the record, then the button will be red,
    display the word **Stop**, and show the square *stop* symbol instead.
  prefs: []
  type: TYPE_NORMAL
- en: The second component is to add sound to the project. This involves importing
    an audio/video framework specifically made for sound and video files.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s tackle the button component first.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a custom dynamic button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A button is a control that performs an action when triggered. It can be configured
    to display a text label, an image, or both. When the user taps it, an action is
    sent to its target, which can trigger a method to be executed. So, let’s add one
    now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Still working in the `RecordButtonArmView` file, as before, I will add the
    button code, and then explain how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `Button` control has an `action` parameter, and this is where we put the
    code that we want to be executed when the button is pressed. Inside this `action`
    closure, we toggled the `rotateRecord` variable before doing anything else. The
    reason for this is that we want the button to change the state of the variable
    because that’s the one that controls the spinning record. So, by toggling it,
    we’re changing the state right away.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we checked to see what the state of `rotateRecord` is when using an `if
    else` statement. If it’s `true`, we set the duration variable to `0.8` seconds,
    as that’s how long we want it to take for the record to spin one revolution (this
    is a good speed for producing a spinning record effect). Next, we want to set
    the `moveArm` variable to `true` when the button is pressed, because setting that
    to `true` gets the arm to move over the record by `8` degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of that happens if `rotateRecord` is true, but if it’s `false`, the code
    falls into the `else` block. In the `else` block, the `duration` is set to `0`,
    which effectively stops the record from spinning, and `moveArm` is set to `false`,
    which will allow the arm to animate back to its original starting position: off
    the record, and to the right side.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we move into the labeling part of the button. Within this initializer,
    I declared an `HStack`, and inside there, another `if else` statement. I’m using
    the not operator (`!`) in front of the `rotateRecord` variable too, which will
    read like this: if the `rotateRecord` variable is not `true` (this is another
    way of saying the variable is `false`), then the record is not playing, so set
    the text for the button to the word `"Play"`, make it bold and black, and provide
    a system image for it (a triangular *play* button). But if the code falls into
    the `else` block here, it means the record is spinning; in this case, we want
    to make the text bold, change the foreground color to red, and provide a system
    image of a *stop* button.'
  prefs: []
  type: TYPE_NORMAL
- en: To finish off the button, we added a little bit of padding on its horizontal
    and vertical sides, gave it a capsule shape, and used the `strokeBorder` modifier
    to put a `2`-point black line around the button.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'You might be wondering, why use the not operator (`!`) when you can say `if
    false` instead? You can use the `if false` statement instead of `if !true`, but
    the `!` operator can help to make your code more readable. For example, consider
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '`if !``fingerprintAccepted {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//``access granted`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}` `else {`'
  prefs: []
  type: TYPE_NORMAL
- en: '`//``access denied`'
  prefs: []
  type: TYPE_NORMAL
- en: '`}`'
  prefs: []
  type: TYPE_NORMAL
- en: The `!` operator negates the Boolean value, making the code more readable because
    it emphasizes the opposite of what is expected. In the example, if `fingerprintAccepted`
    is `false`, access will be granted. If `fingerprintAccepted` is `true`, access
    will be denied. The `!` operator makes it clear that the code is checking for
    the opposite of `fingerprintAccepted`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that code placed into your project, the current interface should look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: Adding the button control ](img/B18674_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: Adding the button control'
  prefs: []
  type: TYPE_NORMAL
- en: Now, there’s a **Play** button to control the record. Next up, we want our record
    player animation to actually play sound, so let’s do that.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sound file to play audio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we are going to add sound to the project so that it plays when the record
    spins. To do this, navigate back to the GitHub folder for this project and drag
    the `.m4a` file called `music` into the Project navigator. Make sure to check
    the **Copy files to project** box if that box is unchecked.
  prefs: []
  type: TYPE_NORMAL
- en: With our `.m4a` audio file, we need to create a separate Swift file for this
    sound. Press *Command* + *N* to create a new file, but instead of creating a SwiftUI
    View file, we will create a simple Swift file instead. Then, name it `PlaySound`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between a SwiftUI View file and Swift file is the purpose
    of the code contained in the file. A SwiftUI View file contains the code needed
    to define a view and its layout, while Swift file can contain a wide range of
    code that is not specifically related to defining views.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this file, the first thing we need to do is import the `AVFoundation` framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `AVFoundation` framework includes classes and methods that allow developers
    to manipulate and work with audio and video in their apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s instantiate (create) an audio player:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Notice that this variable is an optional type, denoted by a question mark at
    the end. I made it optional because if for any reason the music file cannot be
    found within the project, it will stop the app from crashing. Instead, the app
    will still work but simply won’t play the music.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s now create a function called `playSound` that will search through
    the project for the audio file, and load it if it finds it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how the function works. It has two parameters, both of which are strings:
    one is called `sound` and the other is called `type`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we do is to create a `path` constant using what is called `if
    let` statement. Optional binding is a feature that lets us check the value of
    an optional, and if there is a value in it (meaning it’s not nil), then bind that
    optional to a variable or constant.
  prefs: []
  type: TYPE_NORMAL
- en: This constant called `path` will be assigned a path from the app’s bundle. The
    bundle is where the app and its resources are stored, and we need to get the path
    to the sound file that we added to the project, which is in the app’s bundle.
    We can access the main bundle of the app by using the `Bundle.main` property.
    This property returns a `Bundle` object that represents the main bundle of the
    app, and we can use this object to access any of the resources in the app, such
    as images, sounds, or other files.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the `if let` statement reads as follows: the code searches the main bundle
    for a file with the given sound’s name and type extension. If found, the file
    path is stored in the `path` constant and runs the code in the `do` block. Otherwise,
    if for whatever reason the path to the file can’t be found, then the file we are
    looking for is missing or corrupt, and the flow of the program will proceed into
    the `catch` block and execute the code there.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let’s assume the file path has found our sound file, then the code moves
    into the `do` block, in which the code will try to create an audio player using
    that `path` constant. If that is successful, then it will try to play that file.
    But again, if for any reason the file can’t be played, the code will then fall
    into the `catch` block and print an error message to the console (`"Could not
    find and play the sound file"`). That error message won’t be shown to the user,
    it’s only for our debugging purposes, but the user’s app won’t crash with this
    code in place; the sound just won’t play.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Here, it would be helpful to show the user an alert if we fall into the `catch`
    block; however, we won’t do that just yet. If you would like to do this, we will
    cover this in [*Chapter 12*](B18674_12.xhtml#_idTextAnchor172), where we create
    a word game.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have everything in place to test the app, but before we can do that,
    we need to combine our three files – the `RecordPlayerBox`, `RecordButtonArmView`,
    and `PlaySound` files – into one unified view.
  prefs: []
  type: TYPE_NORMAL
- en: Combining all the elements into one view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To put all of our finished views together into one unified grouping to make
    the finished project, let’s go back into the `ContentView` file and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Again, we’re using `ZStack` as the main view because we want to layer our other
    views on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the `RadialGradient` view. This is a struct that takes
    an array of colors that are placed one by one between the open and closed brackets.
    Within those brackets, you can put as many colors as you want, separating each
    color by a comma (I’m using two colors: white and black).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RadialGradient` view works by using the first color in the array to color
    the center of the background, and subsequent colors will surround that center.
    Using `startRadius` and `endRadius` values of `20` and `600`, respectively, will
    make the radial gradient expand to cover the entire screen; however, it doesn’t
    include the safe areas of the iPhone (again, those are that little area by the
    notch at the top and a small area at the bottom of the phone). We can handle the
    safe areas in two ways: we can use the `ignoreSafeArea` modifier as we’ve done
    before, or we can use the `scaleEffect` modifier as we are doing here. By passing
    in `1.2` as a value for the `scaleEffect` modifier, the gradient scales up 1.2
    times the size of the iPhone screen, covering all the edges. This is effectively
    doing the same thing as the `ignoreSafeArea` modifier would do.'
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code makes a call to the `RecordPlayerBox` view and places
    it over the gradient (remember that we are working in `ZStack`, so views get stacked
    up onto one another). The final line of code makes a call to `RecordButtonArmView`,
    placing it over the box, to complete the interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our project will look (if you didn’t make any modifications along
    the way, that is):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: The finished interface ](img/B18674_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: The finished interface'
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of the puzzle is to use the sound file that we created. This
    is easy to do, so as a challenge, try and think of where you would place the audio
    code to get the app to play music.
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you figure it out? If you thought of putting code into the body of the
    button, then you are correct! The button is the view that controls the action:
    it gets the arm to swing over the record, and the record to spin, as well. So,
    inside the `RecordButtonArmView` file, and then inside the button’s `if` statement,
    add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This line of code calls the function that we made in the `PlaySound` file, passing
    in the name of our music file, which is simply called `music`, and the file extension
    for the `type` parameter, which is `m4a`. When the button is pressed, it means
    the user wants to spin the record and play the music, and this code will grab
    the music file and play it.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the button is pressed again, that means the user wants to stop the music,
    so we need to add the following code to the `else` block to do just that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This line of code calls the audio player that we created and uses the `stop`
    function to stop the music. Notice the use of the question mark before calling
    the `stop` function. That’s because the `audioPlayer` variable was created as
    an optional. When we create optional variables, we need to use the question mark
    or exclamation mark when using them too.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And with that, the project is done. Let’s come back to `ContentView` and test
    everything out. If you hit the **Play** button in the **Preview** window or run
    it in the simulator, you should see that the record won’t start spinning until
    the player’s arm is directly over the record. As the record starts spinning, you
    should hear a golden oldy from the big band era of the 40s, complete with the
    scratchy intro sound that old records were notoriously famous for. You will also
    notice that the text on the button changes from **Play** to **Stop**, and the
    color of the button changes from black to red, as shown in this figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: The spinning record ](img/B18674_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: The spinning record'
  prefs: []
  type: TYPE_NORMAL
- en: When you press **Stop**, the arm goes back to its original place, the record
    stops, and the **Play** button will reappear again.
  prefs: []
  type: TYPE_NORMAL
- en: After all of that, that completes our second project!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap what we covered in this project, we added images to the Assets catalog
    and accessed them in our code. Then, we created three separate files to hold the
    elements that we need – one to hold the record player box; one to hold the spinning
    record, the arm moved with an anchor point, and a dynamic button; and one in which
    we wrote code to access a sound file. Once we created these elements, we merged
    them into one view, to create a record and animated record player.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to continue working with Swift animations by
    exploring colors. We will create a simple project that displays various images
    and then, using `hueRotation`, change the color of the images to display a kaleidoscope
    effect. We will also look at how to pass data bidirectionally to another view,
    which gives up more flexibility than using the `@State` property wrapper.
  prefs: []
  type: TYPE_NORMAL
