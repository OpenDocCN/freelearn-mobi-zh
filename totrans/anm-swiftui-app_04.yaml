- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Record Player
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this project, we will create a record player that will move an arm over the
    record, make the record spin, and play music when a button is pressed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Sure, record players are a bit outdated now, but this project is a good way
    to learn new techniques about rotation – specifically, how to rotate objects around
    an anchor point. And you can always modify the design to look like a turntable,
    as many DJs still use vinyl, especially due to the vinyl resurgence in the last
    few years.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: You might be thinking, *didn’t we rotate circles in the first project?* Well,
    this project is different. In the last project, the rotation animation we applied
    was on SwiftUI-created shapes, (specifically, circles), but in this project, we
    will be applying a rotation animation onto a photo image, then controlling it
    with a button, and mixing in some sounds to add to the user experience.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start, let’s list our objectives for this project:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the record player elements
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining all the elements into one view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the project
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the finished project in the `Chapter 4` folder on GitHub: [https://github.com/PacktPublishing/Animating-SwiftUI-Applications](https://github.com/PacktPublishing/Animating-SwiftUI-Applications).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Adding images to the Assets catalog
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay, let’s get started on the first objective: adding some images to the project.
    First, we need to create a new project in Xcode. I called mine `Record Player`
    (you can copy this name or choose something else if you like). Then, we need to
    fill out the other fields exactly as we did in the last chapter. Once this is
    done, we are ready to start.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'When it comes to the images themselves, we need three: the record, the record
    player arm that will move over the record, and a wood grain image that we can
    use as the record player box. All of these images can be found on GitHub by clicking
    the link provided in the *Technical* *requirements* section.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: There are three main methods to add images to the project.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method is using Xcode’s special file folder called the `Assets.xcassets`
    file in Xcode and you will be taken to the Assets catalog. The catalog is split
    into two sections: the section on the left is where your files are listed, and
    the section on the right is where you can actually see your files when you click
    on them in the left pane. To bring your images into the catalog, simply drag them
    into the left column:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Adding files to the Assets catalog ](img/B18674_04_01.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Adding files to the Assets catalog'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: These images will be accessible by referencing their name in the code we write
    (we will see how to do this shortly).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'The second method to add image files to the project is just by dragging and
    dropping them into the Project navigator. However, this method includes the extra
    step of choosing how and where you want to copy the files into the project via
    the following pop-up window:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Adding files into the Project navigator ](img/B18674_04_02.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Adding files into the Project navigator'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Here, you want to make sure that you tick the checkbox that says **Copy items
    if needed**. That’s important because Xcode will copy your files into the project,
    so if they are no longer available on your computer, it won’t matter, as they
    are part of your project now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: You also want to make sure that you check the boxes for the specific target
    you want to copy those resources to. For example, if you want to build the app
    on your Mac, then you want to check the **Record Player (macOS)** option in the
    **Add to targets** box. If you’re just building it for the iPhone, then check
    the **Record Player (iOS)** option. You can also check both if you prefer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'The final method is opening the **File** menu and selecting the **Add Files**
    **to…** option:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: Adding files to the project via the File menu ](img/B18674_04_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: Adding files to the project via the File menu'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added all the images, the next objective is to create the record
    player.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player elements
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our record player, we will create three separate files, each in charge
    of performing specific tasks:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: The first file will hold the record player box
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second file will hold the spinning record, the record player arm, and the
    button to control it
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third file will hold the sound file that will play when the record player
    animation starts
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get started with the first file.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player box
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create the file to hold the record player box, in Xcode, open the **File**
    menu, select **New**, then select **File**. You will notice that this brings up
    several template options:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Creating a new SwiftUI file ](img/B18674_04_04.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Creating a new SwiftUI file'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the top of the window, the row of tabs lets you select which platform
    you want to write code for. We’re only interested in iOS apps, so select the **iOS**
    tab. Then, under the **User Interface** heading, select **SwiftUI View**.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Click `RecordPlayerBox`. Make sure your targets are selected in the checkboxes
    so that the file and everything it contains will work correctly when you run the
    project. Once your targets have been set, click **Create**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have our new file to write our code, and you’ll notice it’s the same
    as the `ContentView` file, except it’s called `RecordPlayerBox`. Working in the
    `body` property, we will start with a `ZStack`; this will be our main stack to
    hold all of our views. Within the `ZStack`, we can build a rectangle using one
    of the images in the Assets catalog. Enter the following code, and then let’s
    look at what it does:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we added a `Rectangle` view, and then, using the `frame` modifier, it
    gets a dimension of `345` points for the width and height, making a square.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: Then, using the `cornerRadius` modifier, we rounded the corners of the rectangle
    by `10` points.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code is the `Image` initializer, which is a view that displays
    an image. We want to use the wood grain image that’s in the Assets catalog, so
    we accessed it by typing the image’s name within quotes to create a string inside
    the `Image` initializer. In our case, we typed `"woodGrain"`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Now we have our image, but we have to resize it. In order to do that, we need
    to use the `resizable` modifier, which is used to prepare an image or other view
    to be resized so it fits within its parent view. When it’s applied to an `Image`
    view, the `resizable` modifier will determine how the image should be scaled to
    fit within the space available.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `frame` modifier resizes the wood image to a width and height of `325`
    points. This will make it a little smaller than the `Rectangle` dimensions; however,
    making it smaller will allow some of the rectangle edges to show through, creating
    a border. The reason why the border is black is that the default color for creating
    a rectangle shape is black, as it is with all shapes. We can change it to any
    color we want by using a `color` modifier, but I think I’ll leave it black here.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: The final line of code creates a shadow by using the `shadow` modifier. Again,
    all the modifiers we are adding are for the wood grain image, so each modifier
    placed on the wood grain has its own specific task of modifying the wood grain
    image in some way. Since this modifier is placed on the wood grain image and is
    using a white color, a white shadow will be radiating around the image. Setting
    the radius to a value of `3` means the shadow will extend out from the image by
    3 points. We can also choose to put a value in for the `x` and `y` parameters,
    which will move the shadow on those axes either left, right, up, or down.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: How much the shadow is moved depends on the size of the value you put in. For
    example, if you put a value of `10` in for the `x` parameter, the shadow will
    extend out from the right edge 10 points; if you put a value of `10` in for the
    `y` parameter, the shadow will extend out 10 points from the bottom edge of the
    box. I put in a value of `0` because I want the shadow directly over the wood
    grain image; it won’t be shifted left or right or up and down.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Play with these numbers and with the color of the shadow so you can see how
    much the values that we’ve used affect the shadow location and intensity. Don’t
    expect to see much of a difference with this `shadow` modifier yet though, because
    its color is white, and we’re working over a white background. When we add a gradient
    to the whole background later, the shadow will become more prominent.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: You can easily see which modifiers you have on any given view by the way Xcode
    indents them. For example, look at the `Rectangle` view again. Its two modifiers,
    `frame` and `cornerRadius`, are indented to the right, which means they are acting
    on the rectangle only. The same goes for `Image("Woodgrain")`; its two modifiers
    are indented to the right as well.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a quick shortcut if your code starts to get messy and the indenting
    is not lined up: press *Command* + *A* to select everything in the file, and then
    press *Control* + *I*. Xcode then properly indents the whole file, every bit of
    code, in one go.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, look at **Preview** to see how your record player box looks. The following
    is what I have according to the code we have written:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The finished box ](img/B18674_04_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The finished box'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Before we continue, I want to show you how you can alter the previews to display
    your creations in a size that fits the view or views on the screen. Notice in
    *Figure 4**.5* that our box is much smaller than the iPhone **Preview** screen;
    sometimes, you might want to preview what you make in a screen size that fits
    the size of the view you just made – in our example, we made a box view. Here
    is how to shrink the **Preview** screen down to fit the box view.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of every SwiftUI file is a struct that will have the same name
    as the struct we just used to write our code. This is a special struct that is
    used for development purposes, and it creates the **Preview** window that we need
    so we can see our work in real time.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the preview struct, add this modifier right at the end of the `RecordPlayerBox()`
    code:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Using the `sizeThatFits` value will bring the **Preview** window size down
    to about the same size as our finished box. I don’t want it exactly the same size,
    so I added a bit of padding around it. Here is the result:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: The finished box fitting to the Preview screen ](img/B18674_04_06.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: The finished box fitting to the Preview screen'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: By using the `previewLayout` modifier, you can customize the **Preview** window
    to suit your needs.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: 'And that’s our finished box. Simple, right? Now, with the record player box
    done, we can move on to our next objective: creating the spinning record.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Creating the spinning record
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, our second file is going to contain the record code. However,
    for simplicity’s sake, we’re actually going to make the record player arm and
    button in this file too. We could split those tasks up into separate files as
    we did with the box, so each part has its own file, but I think that for this
    small project, this one file will do the job for us.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we are creating three different views in this one file, let’s give it
    a name that reflects each view the file will have, so `RecordButtonArmView`. Now,
    do you remember how to make a new SwiftUI file? If not, jump back to the *Creating
    the record player box* section for a refresher. There’s also a shortcut to creating
    a new file: simply press *Command* + *N* and choose the file template you want
    to use; we want the **SwiftUI View** template from the options.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: 'With the file made, let’s work on making that spinning record. As we have done
    before, we will need properties to make everything work, so working at the top
    of the file, within the struct, add the following variables:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: One of these variables is a little different, so let me explain what we’re doing.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一个变量有点不同，让我解释一下我们在做什么。
- en: The first three variables are `State` variables. The `rotateRecord` variable
    is going to keep track of the spinning record and will initiate the spinning animation
    when its value changes to `true`. The next `State` variable, `moveArm`, will keep
    track of the record player arm, and the third `State` variable, `duration`, is
    used to set the duration of the spinning record.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 前三个变量是`State`变量。`rotateRecord`变量将跟踪旋转的唱片，并在其值变为`true`时启动旋转动画。下一个`State`变量`moveArm`将跟踪唱机臂，第三个`State`变量`duration`用于设置旋转唱片的持续时间。
- en: The final variable is a computed property. A computed property is a property
    that does not store a value but is, instead, computed every time it is accessed,
    meaning the code in its body will run every time the variable is used. The property
    we made is of the `Animation` type, which means we can use this in the `animation`
    modifiers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个变量是一个计算属性。计算属性是一个不存储值而是每次访问时都会计算其值的属性，这意味着其体内的代码会在每次变量使用时运行。我们创建的属性是`Animation`类型，这意味着我们可以在`animation`修饰符中使用它。
- en: By using `Animation.linear`, we initialize this variable with a linear timing
    curve for the animation. Remember we talked about timing curves in [*Chapter 2*](B18674_02.xhtml#_idTextAnchor034)
    – a linear curve is a curve with no easing in or easing out; it’s simply a steady,
    non-fluctuating animation from the beginning to the middle, and to the end.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用`Animation.linear`，我们为动画初始化这个变量，使用线性时间曲线。记得我们讨论过[*第2章*](B18674_02.xhtml#_idTextAnchor034)中的时间曲线——线性曲线是一个没有缓动进入或缓动退出的曲线；它是一个从开始到中间再到结束的稳定、无波动的动画。
- en: Then, by keeping the `duration` parameter as `0`, this means the animation will
    have no duration and cannot start yet. This will change in order to start the
    animation later.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，通过将`duration`参数保持为`0`，这意味着动画将没有持续时间，还不能开始。这将改变，以便稍后开始动画。
- en: Then, we’re using the `repeatForever` option because we want the spinning record
    to keep going until we stop it. And finally, the `autoReverses` parameter is set
    to `false`, as we don’t want the record to spin backward.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`repeatForever`选项，因为我们希望旋转的唱片继续旋转，直到我们停止它。最后，`autoReverses`参数设置为`false`，因为我们不希望唱片反向旋转。
- en: 'Using a computed property in this way simplifies things, as now we only need
    to pass that property into the `animation` modifier, and four values will have
    been set with one computed property: `Animation.linear` curve, `duration`, `repeatForever`,
    and `autoReverses`. A computed property is also helpful if you are calling the
    animation modifier in several different places because rather than changing all
    the separate places to alter the animation, you could simply change the variable
    in one place. For example, if you want the auto-reverse feature in all of your
    other animations, all you have to do is change `autoreverses` in one place to
    `true`.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式使用计算属性可以简化事情，因为现在我们只需要将那个属性传递给`animation`修饰符，一个计算属性就会设置四个值：`Animation.linear`曲线、`duration`、`repeatForever`和`autoReverses`。如果你在多个不同位置调用动画修饰符，计算属性也非常有用，因为你不需要改变所有单独的位置来改变动画，只需简单地更改一个位置中的变量。例如，如果你想在你所有的其他动画中都有自动反转功能，你只需要将`autoreverses`在一个位置更改为`true`。
- en: 'We now have all the variables we need to set up this file. Next, we will actually
    add the record. Let’s first put everything in a main `ZStack`, which will hold
    all the views:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经拥有了设置这个文件所需的所有变量。接下来，我们将实际添加记录。首先，让我们将所有内容放入一个主`ZStack`中，它将包含所有视图：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first line of code accesses the `"record"` image in the Assets catalog to
    create the record on the screen by using the `Image` initializer (just as we did
    with the `"``woodGrain"` image).
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码通过`Image`初始化器访问资产目录中的`"record"`图像，在屏幕上创建唱片（就像我们处理`"woodGrain"`图像一样）。
- en: Next, by using the `resizable` modifier again to initiate the resizing, we can
    change the size of the record image by using the `frame` modifier. Passing in
    a value of `280` points for the width and height makes the image just right for
    the screen.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，再次使用`resizable`修饰符来启动调整大小，我们可以通过使用`frame`修饰符来改变记录图像的大小。传入宽度为`280`点，高度为`280`点的值，使图像正好适合屏幕。
- en: In the next line of code, we added the `rotationEffect` modifier to the record.
    This modifier will rotate (or spin) the image to any angle we want. For the `degrees`
    parameter, we’re using the ternary operator and rotating the record `360` degrees,
    which is one full rotation. So, the record will spin one complete revolution,
    but it will only do so when the `rotateRecord` variable becomes `true`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we added the animation to the record, by using the `animation` modifier
    and passing in the `animateForever` computed property for its first parameter.
    Remember, this property is doing a few things for us already: it’s setting a timing
    curve to linear, making the animation repeat forever, and stopping the animation
    from playing in reverse.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Notice the use of the `delay` modifier. This will add a 1.5-second delay to
    the start of the spinning record. This delay is added because old record players
    didn’t start spinning until the arm swung over the record first. This will add
    a little realism to the animation.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the animation’s `value` parameter gets passed in the `rotateRecord`
    variable, which supplies the animation to the record.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move onto the record player arm, let’s make **Preview** smaller so
    it reflects the size of the record, just like we did with the box:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, the record is complete and ready to spin some tunes. Here’s what it looks
    like:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: Record disk ](img/B18674_04_07.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: Record disk'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: Nothing will happen yet because we have to add the other views and functionality,
    but we’re making good progress. Next up, let’s work on the record player arm.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Creating the record player arm
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the spinning record completed, the next objective is the record player’s
    arm. Still working in the `RecordButtonArmView` file, here is the code I want
    you to add, just underneath the call to the `animation` modifier for the record:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Similar to the record image, we use the `Image` initializer to display the `"playerArm"`
    image that we imported earlier into the Assets catalog. It gets resizable behaviors
    using the `resizable` modifier, and the aspect ratio is set to `fit`, which will
    fit the image proportionally on the screen. Next, the image’s width and height
    are set to `150` points, using the `frame` modifier, as we have seen before.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Continuing, the next line of code sets a shadow with a gray color and casts
    it around the arm with a `2`-point radius. If you like, you can change the radius
    to whatever size you prefer, and experiment to see what works for you.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: Then, the arm gets rotated by -35 degrees; this value lines it up perpendicular
    with the record on the left. Also, we set the anchor point here to `topTrailing`,
    so when the arm swings over the record, the `topTrailing` (or top-right) anchor
    point will not move but will serve as a pivot point for the whole arm to move.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code calls the `rotationEffect` modifier again – this time,
    passing in the `moveArm` variable. Once this becomes `true`, the arm will move
    `8` points to the left, and when it’s `false`, it goes back to its original spot,
    using a value of `0`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行代码再次调用`rotationEffect`修改器——这次传递的是`moveArm`变量。一旦这个变量变为`true`，臂部将向左移动`8`点，而当它是`false`时，它将回到原来的位置，使用值为`0`。
- en: As we have seen, to have an animation, we need the `animation` modifier, which
    is the next line of code. This has a linear timing curve and sets the animation
    to 2 seconds to complete, meaning it should take the arm 2 seconds to move over
    the record.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，要有一个动画，我们需要`animation`修改器，这是下一行代码。它有一个线性时间曲线，并将动画设置为2秒完成，这意味着臂部应该用2秒时间移动到唱片上。
- en: Finally, we need to position the arm just right in relation to the spinning
    record, so using the `offset` modifier here, we can place it exactly where we
    want on the record player box. For our purposes, a record player’s arm is usually
    placed to the right of the record, with an inch or two of spacing between the
    arm and the record.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将臂部放置在相对于旋转唱片的位置恰到好处，因此在这里使用`offset`修改器，我们可以将其放置在唱机盒上我们想要的确切位置。就我们的目的而言，唱机的臂通常放置在唱片右侧，臂和唱片之间有一英寸或两英寸的间隔。
- en: 'Here’s what the project should look like so far with the arm in place:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，项目应该看起来是这样的，臂部已经放置好：
- en: '![Figure 4.8: Record player arm ](img/B18674_04_08.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图4.8：唱机臂](img/B18674_04_08.jpg)'
- en: 'Figure 4.8: Record player arm'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.8：唱机臂
- en: We’re actually almost done with the project, but two more key components are
    needed.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们几乎完成了这个项目，但还需要两个关键组件。
- en: The first of these is a button that will start and stop the animation. This
    will be a dynamic button, meaning that the title of the button will change depending
    on what it’s doing. If the record player is not playing a record, we will keep
    the button color black, display the word **Play**, and show the triangular *play*
    symbol. If the record player is playing the record, then the button will be red,
    display the word **Stop**, and show the square *stop* symbol instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能中的第一个是一个可以开始和停止动画的按钮。这将是一个动态按钮，意味着按钮的标题会根据其功能而改变。如果唱机没有播放唱片，我们将保持按钮颜色为黑色，显示文字**播放**，并显示三角形的*播放*符号。如果唱机正在播放唱片，那么按钮将变为红色，显示文字**停止**，并显示正方形的*停止*符号。
- en: The second component is to add sound to the project. This involves importing
    an audio/video framework specifically made for sound and video files.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个组件是为项目添加声音。这涉及到导入一个专门为音频/视频文件制作的音频/视频框架。
- en: Let’s tackle the button component first.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先处理按钮组件。
- en: Adding a custom dynamic button
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加自定义动态按钮
- en: A button is a control that performs an action when triggered. It can be configured
    to display a text label, an image, or both. When the user taps it, an action is
    sent to its target, which can trigger a method to be executed. So, let’s add one
    now.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮是一个在触发时执行动作的控制。它可以配置为显示文本标签、图像或两者兼而有之。当用户点击它时，会向其目标发送一个动作，这可以触发要执行的方法。所以，我们现在就添加一个。
- en: 'Still working in the `RecordButtonArmView` file, as before, I will add the
    button code, and then explain how it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在`RecordButtonArmView`文件中工作，就像之前一样，我将添加按钮代码，然后解释它是如何工作的：
- en: '[PRE6]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `Button` control has an `action` parameter, and this is where we put the
    code that we want to be executed when the button is pressed. Inside this `action`
    closure, we toggled the `rotateRecord` variable before doing anything else. The
    reason for this is that we want the button to change the state of the variable
    because that’s the one that controls the spinning record. So, by toggling it,
    we’re changing the state right away.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button`控制有一个`action`参数，这就是我们放置当按钮被按下时要执行代码的地方。在这个`action`闭包内部，我们在做其他任何事情之前切换了`rotateRecord`变量。这样做的原因是我们希望按钮改变变量的状态，因为这是控制旋转唱片的变量。所以，通过切换它，我们立即改变了状态。'
- en: Next, we checked to see what the state of `rotateRecord` is when using an `if
    else` statement. If it’s `true`, we set the duration variable to `0.8` seconds,
    as that’s how long we want it to take for the record to spin one revolution (this
    is a good speed for producing a spinning record effect). Next, we want to set
    the `moveArm` variable to `true` when the button is pressed, because setting that
    to `true` gets the arm to move over the record by `8` degrees.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查使用`if else`语句时`rotateRecord`的状态。如果它是`true`，我们将持续时间变量设置为`0.8`秒，因为这是我们希望唱片旋转一周所需的时间（这是产生旋转唱片效果的好速度）。接下来，我们希望在按钮按下时将`moveArm`变量设置为`true`，因为将其设置为`true`会使臂移动到唱片上`8`度。
- en: 'All of that happens if `rotateRecord` is true, but if it’s `false`, the code
    falls into the `else` block. In the `else` block, the `duration` is set to `0`,
    which effectively stops the record from spinning, and `moveArm` is set to `false`,
    which will allow the arm to animate back to its original starting position: off
    the record, and to the right side.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都在`rotateRecord`为`true`时发生，但如果它是`false`，代码将进入`else`块。在`else`块中，`duration`被设置为`0`，这实际上停止了唱片的旋转，`moveArm`被设置为`false`，这将允许臂动画回到其原始起始位置：离开唱片，并移向右侧。
- en: 'Then, we move into the labeling part of the button. Within this initializer,
    I declared an `HStack`, and inside there, another `if else` statement. I’m using
    the not operator (`!`) in front of the `rotateRecord` variable too, which will
    read like this: if the `rotateRecord` variable is not `true` (this is another
    way of saying the variable is `false`), then the record is not playing, so set
    the text for the button to the word `"Play"`, make it bold and black, and provide
    a system image for it (a triangular *play* button). But if the code falls into
    the `else` block here, it means the record is spinning; in this case, we want
    to make the text bold, change the foreground color to red, and provide a system
    image of a *stop* button.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们进入按钮的标签部分。在这个初始化器中，我声明了一个`HStack`，并在其中使用了一个`if else`语句。我在`rotateRecord`变量前面也使用了非运算符（`!`），这将读作：如果`rotateRecord`变量不是`true`（这是另一种说变量是`false`的方式），则唱片没有播放，因此将按钮的文本设置为单词`"Play"`，使其加粗并变黑，并提供一个系统图像（一个三角形的*播放*按钮）。但如果代码进入这里的`else`块，则意味着唱片正在旋转；在这种情况下，我们希望使文本加粗，将前景色改为红色，并提供一个*停止*按钮的系统图像。
- en: To finish off the button, we added a little bit of padding on its horizontal
    and vertical sides, gave it a capsule shape, and used the `strokeBorder` modifier
    to put a `2`-point black line around the button.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成按钮，我们在其水平和垂直两侧添加了一些填充，使其呈胶囊形状，并使用`strokeBorder`修饰符在按钮周围绘制了一条2点的黑色线条。
- en: Note
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You might be wondering, why use the not operator (`!`) when you can say `if
    false` instead? You can use the `if false` statement instead of `if !true`, but
    the `!` operator can help to make your code more readable. For example, consider
    the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，为什么使用非运算符（`!`）而不是可以说`if false`？你可以使用`if false`语句代替`if !true`，但`!`运算符可以帮助使你的代码更易读。例如，考虑以下代码：
- en: '`if !``fingerprintAccepted {`'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`if !fingerprintAccepted {`'
- en: '`//``access granted`'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`//access granted`'
- en: '`}` `else {`'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`}` `else {`'
- en: '`//``access denied`'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`//access denied`'
- en: '`}`'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`}`'
- en: The `!` operator negates the Boolean value, making the code more readable because
    it emphasizes the opposite of what is expected. In the example, if `fingerprintAccepted`
    is `false`, access will be granted. If `fingerprintAccepted` is `true`, access
    will be denied. The `!` operator makes it clear that the code is checking for
    the opposite of `fingerprintAccepted`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`!`运算符否定布尔值，使代码更易读，因为它强调了预期的相反。在示例中，如果`fingerprintAccepted`为`false`，则允许访问。如果`fingerprintAccepted`为`true`，则拒绝访问。`!`运算符清楚地表明代码正在检查`fingerprintAccepted`的相反值。'
- en: 'With that code placed into your project, the current interface should look
    like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 将该代码放入您的项目中后，当前界面应如下所示：
- en: '![Figure 4.9: Adding the button control ](img/B18674_04_09.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图4.9：添加按钮控件](img/B18674_04_09.jpg)'
- en: 'Figure 4.9: Adding the button control'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.9：添加按钮控件
- en: Now, there’s a **Play** button to control the record. Next up, we want our record
    player animation to actually play sound, so let’s do that.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，有一个**播放**按钮来控制录音。接下来，我们希望我们的唱片机动画能够实际播放声音，所以让我们来做这件事。
- en: Creating a sound file to play audio
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个音频文件以播放音频
- en: Now, we are going to add sound to the project so that it plays when the record
    spins. To do this, navigate back to the GitHub folder for this project and drag
    the `.m4a` file called `music` into the Project navigator. Make sure to check
    the **Copy files to project** box if that box is unchecked.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将向项目中添加声音，以便在录音旋转时播放。为此，导航回此项目的GitHub文件夹，并将名为`music`的`.m4a`文件拖放到项目导航器中。如果该框未被勾选，请确保勾选**Copy
    files to project**框。
- en: With our `.m4a` audio file, we need to create a separate Swift file for this
    sound. Press *Command* + *N* to create a new file, but instead of creating a SwiftUI
    View file, we will create a simple Swift file instead. Then, name it `PlaySound`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`.m4a`音频文件，我们需要为这个声音创建一个单独的Swift文件。按*Command* + *N*键创建一个新文件，但不要创建SwiftUI
    View文件，而是创建一个简单的Swift文件。然后，将其命名为`PlaySound`。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The main difference between a SwiftUI View file and Swift file is the purpose
    of the code contained in the file. A SwiftUI View file contains the code needed
    to define a view and its layout, while Swift file can contain a wide range of
    code that is not specifically related to defining views.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI View文件和Swift文件之间的主要区别是文件中包含的代码的目的。SwiftUI View文件包含定义视图及其布局所需的代码，而Swift文件可以包含广泛与定义视图无关的代码。
- en: 'In this file, the first thing we need to do is import the `AVFoundation` framework:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，我们首先需要做的是导入`AVFoundation`框架：
- en: '[PRE7]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `AVFoundation` framework includes classes and methods that allow developers
    to manipulate and work with audio and video in their apps.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVFoundation`框架包括类和方法，允许开发者在他们的应用程序中操作和与音频和视频一起工作。'
- en: 'Next, let’s instantiate (create) an audio player:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们实例化（创建）一个音频播放器：
- en: '[PRE8]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that this variable is an optional type, denoted by a question mark at
    the end. I made it optional because if for any reason the music file cannot be
    found within the project, it will stop the app from crashing. Instead, the app
    will still work but simply won’t play the music.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个变量是一个可选类型，其末尾有一个问号。我将其设置为可选，因为如果出于任何原因在项目中找不到音乐文件，它将阻止应用程序崩溃。相反，应用程序仍然可以工作，但只是不会播放音乐。
- en: 'Now, let’s now create a function called `playSound` that will search through
    the project for the audio file, and load it if it finds it:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`playSound`的函数，该函数将在项目中搜索音频文件，并在找到时加载它：
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here’s how the function works. It has two parameters, both of which are strings:
    one is called `sound` and the other is called `type`.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个函数的工作原理。它有两个参数，都是字符串：一个叫做`sound`，另一个叫做`type`。
- en: The first thing we do is to create a `path` constant using what is called `if
    let` statement. Optional binding is a feature that lets us check the value of
    an optional, and if there is a value in it (meaning it’s not nil), then bind that
    optional to a variable or constant.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的是使用所谓的`if let`语句创建一个`path`常量。可选绑定是一个特性，它允许我们检查可选值，如果其中包含值（意味着它不是nil），则将该可选绑定到变量或常量。
- en: This constant called `path` will be assigned a path from the app’s bundle. The
    bundle is where the app and its resources are stored, and we need to get the path
    to the sound file that we added to the project, which is in the app’s bundle.
    We can access the main bundle of the app by using the `Bundle.main` property.
    This property returns a `Bundle` object that represents the main bundle of the
    app, and we can use this object to access any of the resources in the app, such
    as images, sounds, or other files.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个名为`path`的常量将被分配一个来自应用程序包的路径。包是应用程序及其资源存储的地方，我们需要获取添加到项目中的声音文件的路径，该文件位于应用程序包中。我们可以通过使用`Bundle.main`属性来访问应用程序的主包。这个属性返回一个表示应用程序主包的`Bundle`对象，我们可以使用这个对象来访问应用程序中的任何资源，例如图像、声音或其他文件。
- en: 'So, the `if let` statement reads as follows: the code searches the main bundle
    for a file with the given sound’s name and type extension. If found, the file
    path is stored in the `path` constant and runs the code in the `do` block. Otherwise,
    if for whatever reason the path to the file can’t be found, then the file we are
    looking for is missing or corrupt, and the flow of the program will proceed into
    the `catch` block and execute the code there.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`if let`语句的读取方式如下：代码会在主包中搜索具有给定声音名称和类型扩展名的文件。如果找到，则将文件路径存储在`path`常量中，并在`do`块中运行代码。否则，如果由于任何原因找不到文件的路径，那么我们正在寻找的文件缺失或损坏，程序流程将进入`catch`块并执行那里的代码。
- en: Okay, let’s assume the file path has found our sound file, then the code moves
    into the `do` block, in which the code will try to create an audio player using
    that `path` constant. If that is successful, then it will try to play that file.
    But again, if for any reason the file can’t be played, the code will then fall
    into the `catch` block and print an error message to the console (`"Could not
    find and play the sound file"`). That error message won’t be shown to the user,
    it’s only for our debugging purposes, but the user’s app won’t crash with this
    code in place; the sound just won’t play.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Here, it would be helpful to show the user an alert if we fall into the `catch`
    block; however, we won’t do that just yet. If you would like to do this, we will
    cover this in [*Chapter 12*](B18674_12.xhtml#_idTextAnchor172), where we create
    a word game.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have everything in place to test the app, but before we can do that,
    we need to combine our three files – the `RecordPlayerBox`, `RecordButtonArmView`,
    and `PlaySound` files – into one unified view.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: Combining all the elements into one view
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To put all of our finished views together into one unified grouping to make
    the finished project, let’s go back into the `ContentView` file and add the following
    code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, we’re using `ZStack` as the main view because we want to layer our other
    views on top of each other.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s look at the `RadialGradient` view. This is a struct that takes
    an array of colors that are placed one by one between the open and closed brackets.
    Within those brackets, you can put as many colors as you want, separating each
    color by a comma (I’m using two colors: white and black).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'The `RadialGradient` view works by using the first color in the array to color
    the center of the background, and subsequent colors will surround that center.
    Using `startRadius` and `endRadius` values of `20` and `600`, respectively, will
    make the radial gradient expand to cover the entire screen; however, it doesn’t
    include the safe areas of the iPhone (again, those are that little area by the
    notch at the top and a small area at the bottom of the phone). We can handle the
    safe areas in two ways: we can use the `ignoreSafeArea` modifier as we’ve done
    before, or we can use the `scaleEffect` modifier as we are doing here. By passing
    in `1.2` as a value for the `scaleEffect` modifier, the gradient scales up 1.2
    times the size of the iPhone screen, covering all the edges. This is effectively
    doing the same thing as the `ignoreSafeArea` modifier would do.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The next line of code makes a call to the `RecordPlayerBox` view and places
    it over the gradient (remember that we are working in `ZStack`, so views get stacked
    up onto one another). The final line of code makes a call to `RecordButtonArmView`,
    placing it over the box, to complete the interface.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'This is how our project will look (if you didn’t make any modifications along
    the way, that is):'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: The finished interface ](img/B18674_04_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: The finished interface'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: The final piece of the puzzle is to use the sound file that we created. This
    is easy to do, so as a challenge, try and think of where you would place the audio
    code to get the app to play music.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'Did you figure it out? If you thought of putting code into the body of the
    button, then you are correct! The button is the view that controls the action:
    it gets the arm to swing over the record, and the record to spin, as well. So,
    inside the `RecordButtonArmView` file, and then inside the button’s `if` statement,
    add the following code:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This line of code calls the function that we made in the `PlaySound` file, passing
    in the name of our music file, which is simply called `music`, and the file extension
    for the `type` parameter, which is `m4a`. When the button is pressed, it means
    the user wants to spin the record and play the music, and this code will grab
    the music file and play it.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'When the button is pressed again, that means the user wants to stop the music,
    so we need to add the following code to the `else` block to do just that:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This line of code calls the audio player that we created and uses the `stop`
    function to stop the music. Notice the use of the question mark before calling
    the `stop` function. That’s because the `audioPlayer` variable was created as
    an optional. When we create optional variables, we need to use the question mark
    or exclamation mark when using them too.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: Testing the project
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'And with that, the project is done. Let’s come back to `ContentView` and test
    everything out. If you hit the **Play** button in the **Preview** window or run
    it in the simulator, you should see that the record won’t start spinning until
    the player’s arm is directly over the record. As the record starts spinning, you
    should hear a golden oldy from the big band era of the 40s, complete with the
    scratchy intro sound that old records were notoriously famous for. You will also
    notice that the text on the button changes from **Play** to **Stop**, and the
    color of the button changes from black to red, as shown in this figure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: The spinning record ](img/B18674_04_11.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: The spinning record'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: When you press **Stop**, the arm goes back to its original place, the record
    stops, and the **Play** button will reappear again.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: After all of that, that completes our second project!
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To recap what we covered in this project, we added images to the Assets catalog
    and accessed them in our code. Then, we created three separate files to hold the
    elements that we need – one to hold the record player box; one to hold the spinning
    record, the arm moved with an anchor point, and a dynamic button; and one in which
    we wrote code to access a sound file. Once we created these elements, we merged
    them into one view, to create a record and animated record player.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to continue working with Swift animations by
    exploring colors. We will create a simple project that displays various images
    and then, using `hueRotation`, change the color of the images to display a kaleidoscope
    effect. We will also look at how to pass data bidirectionally to another view,
    which gives up more flexibility than using the `@State` property wrapper.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续通过探索颜色来使用 Swift 动画。我们将创建一个简单的项目，显示各种图像，然后使用 `hueRotation` 改变图像的颜色，以显示万花筒效果。我们还将探讨如何双向传递数据到另一个视图，这比使用
    `@State` 属性包装器提供了更多的灵活性。
