- en: Chapter 6. Using Core Data for Persistence
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you do any serious form of iOS development, data persistence is something
    that you are bound to come across sooner rather than later. After all, what good
    is an app when it does not save your user data and requires you to fill it in
    again when you start the app again subsequently?
  prefs: []
  type: TYPE_NORMAL
- en: This is where data persistence comes into the scene. As it is, iOS developers
    have a few options for data persistence ranging from property list, binary format
    to SQLite, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: As with these options, each has its good and bad points, and when to use each
    particular method of persistence will depend on your use case. You will also have
    to write specific code to handle data persistence for SQLite and binary data.
    Core Data can be used to store data in **plist**, SQLite, and other formats, which
    makes it a pretty powerful framework in itself as we will see in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Why use Core Data?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Core Data concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting Core Data into practice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting into the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving data into the persistent store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting data from the persistent store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why use Core Data?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You might be thinking to yourself, "Why do I have to learn another method when
    there are so many ways already available to us?" So, in this section and on the
    following pages, we will see why Core Data is the preferred way to store data
    on iOS and the Mac OS platform.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing you need to know is that Core Data is not another method of
    data persistence per se; it is actually an abstraction over SQLite, plists, and
    so on. This means that you can actually use Apple's Core Data API to save your
    data into the persistent store just by using the Core Data API without needing
    to write plist-specific or SQLite-specific code if you choose to store your data
    as plists or SQLite respectively. This abstraction layer illustrates the basic
    concept of why Core Data is so powerful.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have your mind blown, the abstraction layer means that you can
    just use the Core Data APIs, and the abstraction layer will handle all the storage-specific
    code for you as all this high-level stuff will help you get away from writing
    low-level stuff, specific for each different data persistent format such as SQLite,
    property list, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Core Data integrates very tightly with iCloud and provides a host of benefits
    related to iCloud, such as data synching. It also allows you to do entity modeling
    with the benefits of querying while making it very fast in terms of access speed
    plus giving you the freedom to choose the storage type that can be SQLite, XML,
    or NSDate. With all the benefits that Core Data provides, it comes with a trade-off
    in which you need to write a bit more code compared to NSCoding. However, as we
    will see later, the amount of code is not a lot, and the Core Data framework is
    not complex to understand too.
  prefs: []
  type: TYPE_NORMAL
- en: A few more things that I would like to mention about Core Data is that since
    it is so tightly integrated into the Apple platforms, you can have access to a
    lot of related classes such as `NSFetchedResultsController` that make it easy
    for you to get your entities into `UITableViews`. It also has a nice graphical
    object model editor that allows you to easily think about your object/entity design
    and conceptualize it easily using Core Data's visual tools. With all these benefits,
    let's dig into Core Data now.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Core Data concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Core Data allows you to store your data in a variety of storage types. So,
    if you want to use other types of memory store, such as XML or binary store, you
    can use the following store types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSSQLiteStoreType`: This is the option you most commonly use as it just stores
    your database in a SQLite database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSXMLStoreType`: This will store your data in an XML file, which is slower,
    but you can open the XML file and it will be human readable. This has the option
    of helping you debug errors relating to storage of data. However, do note that
    this storage type is only available for Mac OS X.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSBinaryStoreType`: This occupies the least amount of space and also produces
    the fastest speed as it stores all data as a binary file, but the entire database
    binary need to be able to fit into memory in order to work properly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSInMemoryStoreType`: This stores all data in memory and provides the fastest
    access speed. However, the size of your database to be saved cannot exceed the
    available free space in memory since the data is stored in memory. However, do
    note that memory storage is ephemeral and is not stored permanently to disk.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Next, there are two concepts that you need to know, and they are:'
  prefs: []
  type: TYPE_NORMAL
- en: Entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attributes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, these terms may be foreign to you. However, for those of you who have knowledge
    of databases, you will know it as tables and columns. So, to put it in an easy-to-understand
    picture, think of Core Data entities as your database tables and Core Data attributes
    as your database columns.
  prefs: []
  type: TYPE_NORMAL
- en: So, Core Data handles data persistence using the concepts of entity and attributes,
    which are abstract data types, and actually saves the data into plists, SQLite
    databases, or even XML files (applicable only to the Mac OS). Going back a bit
    in time, Core Data is a descendant of Apple's **Enterprise Objects Framework**
    (**EOF**), which was introduced by NeXT, Inc in 1994, and EOF is an **Object-relational
    mapper** (**ORM**), but Core Data itself is not an ORM. Core Data is a framework
    for managing the object graph, and one of its powerful capabilities is that it
    allows you to work with extremely large datasets and object instances that normally
    would not fit into memory by putting objects in and out of memory when necessary.
    Core Data will map the Objective-C data type to the related data types, such as
    string, date, and integer, which will be represented by `NSString`, `NSDate`,
    and `NSNumber` respectively. So, as you can see, Core Data is not a radically
    new concept that you need to learn as it is grounded in the simple database concepts
    that we all know. Since entity and attributes are abstract data types, you cannot
    access them directly as they do not exist in physical terms. So to access them,
    you need to use the Core Data classes and methods provided by Apple.
  prefs: []
  type: TYPE_NORMAL
- en: 'The number of classes for Core Data is actually pretty long, and you won''t
    be using all of them regularly. So, here is a list of the more commonly used classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Class name | Example use case |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `NSManagedObject` | Accessing attributes and rows of data |'
  prefs: []
  type: TYPE_TB
- en: '| `NSManagedObjectContext` | Fetching data and saving data |'
  prefs: []
  type: TYPE_TB
- en: '| `NSManagedObjectModel` | Storage |'
  prefs: []
  type: TYPE_TB
- en: '| `NSFetchRequest` | Requesting data |'
  prefs: []
  type: TYPE_TB
- en: '| `NSPersistentStoreCoordinator` | Persisting data |'
  prefs: []
  type: TYPE_TB
- en: '| `NSPredicate` | Data query |'
  prefs: []
  type: TYPE_TB
- en: 'Now, explore each of these classes in depth:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSManagedObject`: This is a record that you will use and perform operations
    on and all entities will extend this class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSManagedObjectContext`: This can be thought of as an intelligent scratchpad
    where temporary copies are brought into it after you fetch objects from the persistent
    store. So, any modifications done in this intelligent scratchpad are not saved
    until you save those changes into the persistent store, `NSManagedObjectModel`.
    Think of this as a collection of entities or a database schema, if you will.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSFetchRequest`: This is an operation that describes the search criteria,
    which you will use to retrieve data from the persistent store, a kind of the common
    SQL query that most developers are familiar with.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSPersistentStoreCoordinator`: This is like the glue that associates your
    managed object context and persistent.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSPersistentStoreCoordinator`: Without this, your modifications will not be
    saved to the persistent store.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSPredicate`: This is used to define logical conditions used in a search or
    for filtering in-memory. Basically, it means that `NSPredicate` is used to specify
    how data is to be fetched or filtered and you can use it together with `NSFetchRequest`
    as `NSFetchRequest` has a predicate property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Putting it into practice
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have covered the basics of Core Data, let''s proceed with some
    code examples of how to use Core Data, where we use Core Data to store customer
    details in a `Customer` table. The information we want to store is:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`phone_number`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`address`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`age`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Do note that all attribute names must be in lowercase and should not have spaces
    in them. For example, we will use Core Data to store customer details mentioned
    earlier as well as retrieve, update, and delete the customer records using the
    Core Data framework and methods.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will select **File** | **New** | **File** and then select **iOS**
    | **Core Data**:![Putting it into practice](img/00026.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will proceed to create a new **Entity** called **Customer** by clicking
    on the **Add Entity** button in the bottom left of the screen, as shown here:![Putting
    it into practice](img/00027.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will proceed to add in the attributes for our **Customer** entity and
    give them the appropriate **Type**, which can be **String** for attributes such
    as **name** or **address** and **Integer 16** for **age**:![Putting it into practice](img/00028.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we need to add **CoreData.framework**, as shown in the following screenshot:![Putting
    it into practice](img/00029.jpeg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So with this, we have created a Core Data model class consisting of a `Customer`
    entity and some attributes. Do note that all core model classes have the `.xcdatamodeld`
    file extension and for us, we can save our Core Data model as `Model.xcdatamodeld`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we will create a sample application that uses Core Data in the following
    ways:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Saving a record
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Searching for a record
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Deleting a record
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading records
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, I won''t cover the usage of UIKit and storyboard, but instead focus on
    the core code needed to give you an example of Core Data works. So, to start things
    off, here are a few screenshots of the application for you to have a look at to
    see what we''ll do:'
  prefs: []
  type: TYPE_NORMAL
- en: This is the main screen when you start the app:![Putting it into practice](img/00030.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The screen to insert a record is shown here:![Putting it into practice](img/00031.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The screen to list all records from our persistent store is as follows:![Putting
    it into practice](img/00032.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By deleting a record from the persistent store, you will get the following output:![Putting
    it into practice](img/00033.jpeg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting into the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with our code examples:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our code, we will first declare some Core Data objects in our `AppDelegate`
    class inside our `AppDelegate.h` file such as:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These are declared here so that we can access them easily from any screen.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we will declare the code for each of the objects in `AppDelegate.m` such
    as the following lines of code that will create an instance of `NSManagedObjectContext`
    and return an existing instance if the instance already exists. This is important
    as you want only one instance of the context to be present to avoid conflicting
    access to the context:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method will create the `NSManagedObjectModel` instance and then return
    the instance, but it will return an existing `NSManagedObjectModel` instance if
    it already exists:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method will create an instance of the `NSPersistentStoreCoordinator` class
    if it does not exist, and also return an existing instance if it already exists.
    We will also make some logs appear in our Xcode console using the `NSLog` method
    to tell the user if the instance of `NSPersistentStoreCoordinator` is nil and
    use the `NSSQLiteStoreType` keyword to signify to the system that we intend to
    store the data in a SQLite database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following lines of code will return a URL of the location to store your
    data on the device:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, what we have done is to check whether the objects such as `_managedObjectModel`
    are nil and if they are not nil, then we return the object, or we will create
    the object and then return it. This concept is exactly the same concept of lazy
    loading, which we covered in [Chapter 5](part0044_split_000.html#page "Chapter 5. Managing
    Your Application Data"), *Managing Your Application Data*. We apply the same methodology
    to `managedObjectContext` and `persistentStoreCoordinator`. We did this so that
    we know that we only have one instance of `managedObjectModel`, `managedObjectContext`,
    and `persistentStoreCoordinator` created and present at any given time. This is
    to help us avoid having multiple copies of these objects, which will increase
    the chance of a memory leak.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that memory management is still a real issue in the post-ARC world. So
    what we have done is follow best practices that will help us avoid memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: In the example code that was shown, we adopted a structure so that only one
    instance of `managedObjectModel`, `managedObjectContext`, and `persistentStoreCoordinator`
    is available at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's move on to showing you how to store data in our persistent store.
    As you can see in the preceding screenshot, we have fields such as `name`, `age`,
    `address`, `email`, and `phone_number`, which correspond to the appropriate fields
    in our `Customer` entity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The example code in this chapter will be provided in its entirety on the Packt
    Publishing website, and you can download it and run the Xcode project directly.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data into the persistent store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To do a successful save using Core Data, you require:'
  prefs: []
  type: TYPE_NORMAL
- en: '`NSManagedObject`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSManagedObjectContext`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSPersistentStoreCoordinator`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NSManagedObjectModel`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, in our screen that saves these variables into our `Customer` entity, the
    following code fragment does all the magic for the `(IBAction)save:(id)sender`
    method. This will enable us to save our data from a new customer or update an
    existing customer''s information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So, the steps we need to remember are:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the instance of `NSManagedObjectContext`, which sets `persistentStoreCoordinator`
    using `managedObjectModel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of `NSManagedObject` and set the values you want to save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use an object of the `NSManagedObjectContext` type and call the `save` method
    since the context will represent all changes that you have done and you need to
    call the `save` method in order to save the changes from the context to disk.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Deleting data from the persistent store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now move on to delete a record from the persistent store. In our table
    view, we will load the customers using an instance of `NSFetchRequest`, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will declare `customers` as a mutable array to store our records from
    the `Customer` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete a record, we just need to get our `Customer` record, which is an
    instance of `NSManagedObject` from the `customers` array, then use an instance
    of `managedObjectContext` to call the `deleteObject` method on it, and finally,
    call the `save` method to save our updated records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Updating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Finally, to update a record, it is much simpler than you think, thanks to the
    abstraction layer. To update data, we just assign the values to our `customer`
    object in the `(IBAction)save:(id)sender` method, which you saw earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will add the following code after we set the values of our `customer` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `customer` is an instance of `NSManagedObject`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The code for updating data is to be added after the following code fragment,
    inside the – `(IBAction)save:(id)sender` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, to wrap it all up, Core Data is not something that is overly complex and
    the code to use Core Data is pretty straightforward as we have seen in our code
    examples shown earlier. The Core Data framework is a relatively easy framework
    to use to handle data storage abstraction without worrying about different data
    storage formats.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts that you have to know are the Core Data classes such as `NSManagedObject`,
    `NSManagedObjectContext`, `NSPersistentStoreCoordinator`, and so on and the related
    methods such as `save` and `deleteObject`. With these simple lines of code, you
    can leverage the power of the Core Data framework to do data persistence on a
    high-level abstraction without concerning yourself with the low-level data format
    specifications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be introduced to key-value programming and how
    it can be used to allow us to be notified of state changes. So, I hope you enjoyed
    this chapter on Core Data!
  prefs: []
  type: TYPE_NORMAL
