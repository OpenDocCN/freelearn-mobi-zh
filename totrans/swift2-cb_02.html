<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Standard Library and Collections" id="NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Standard Library and Collections</h1></div></div></div><p class="calibre7">In this chapter, we will cover the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating HTML manually</li><li class="listitem">Printing your object description</li><li class="listitem">Quizzing the user</li><li class="listitem">Searching for perfect numbers</li><li class="listitem">Sorting an array of products</li><li class="listitem">Finding the way out</li><li class="listitem">Creating your own set</li><li class="listitem">Organizing a dinner room</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Standard Library and Collections" id="NQU21-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec19" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre7">It's important to know the usage of collections and standard library, mainly for those people who come from Objective-C because there are some differences here.</p><p class="calibre7">In this chapter, we will create some apps to use these features. After these recipes, you should have a good understanding about the Swift programming language.</p><p class="calibre7">As mentioned in the previous chapter, most of our recipes will be created on iOS, but you can develop them on Mac OS X if you want.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating HTML manually"><div class="book" id="OPEK2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Creating HTML manually</h1></div></div></div><p class="calibre7">HTML started <a id="id44" class="calibre1"/>as a simple format for displaying web pages and links. Nowadays, this format has become very common and it is used everywhere. There are even frameworks such as PhoneGap that create applications with this file type.</p><p class="calibre7">In this recipe, we will create HTML using only strings; the main idea is to know about string manipulation. In this case, we will create the HTML code for a visiting card.</p></div>

<div class="book" title="Creating HTML manually">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec47" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Open your Xcode and create a single view project called <code class="email">Chapter2 HTML</code>.</p></div></div>

<div class="book" title="Creating HTML manually">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec48" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's create HTML <a id="id45" class="calibre1"/>manually by following these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Click on the storyboard and add the following layout:<div class="mediaobject"><img src="../images/00024.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Then, connect <a id="id46" class="calibre1"/>the text fields with the following properties on the view controller:<div class="informalexample"><pre class="programlisting">@IBOutlet weak var nameTextField: UITextField!
@IBOutlet weak var addressTextField: UITextField!
@IBOutlet weak var postCodeTextField: UITextField!
@IBOutlet weak var phoneTextField: UITextField!</pre></div></li><li class="listitem" value="3">Link these properties with the corresponding text field on the view, and before creating an action button, we will create a <code class="email">Card</code> class with the following code:<div class="informalexample"><pre class="programlisting">class Card {
    private let TEMPLATE = "&lt;div class=\"personalcard\"&gt;" + "&lt;p class=\"name\"&gt;#name#&lt;/p&gt;" + "&lt;p class=\"address\"&gt;#address#&lt;/p&gt;" + "&lt;p class=\"postcode\"&gt;#postcode#&lt;/p&gt;" + "&lt;p class=\"phone\"&gt;#phone#&lt;/p&gt;" + "&lt;/div"
    
    var name:String?
    var address:String?
    var postCode:String?
    var phone:String?
    
    init(){}
}</pre></div><p class="calibre15">As you can see, we are creating a class with the same information as our <a id="id47" class="calibre1"/>application. The main difference is that we have a constant called <code class="email">TEMPLATE</code>, which has a model of our HTML.</p><div class="note" title="Note"><h3 class="title2"><a id="note07" class="calibre1"/>Note</h3><p class="calibre7">Note that this constant is private because it's something that we shouldn't see (for example, from the view controller). Also notice that we have a plus sign at the end of each line that needs to continue on the next line. The reason is that we can't concatenate strings without using an operator as we used in Objective-C.</p></div><p class="calibre15">Swift doesn't need a semicolon at the instruction end. However, if you have a huge line, you have to tell the compiler that the line is going to continue, with a plus sign, for example, or by indicating on the next line that it is continuing from the previous one, with a dot operator, for example.</p><p class="calibre15">If you've been programming with Objective-C or C++, you may be asking why we've created an empty initializer. The reason is: it is not necessary; theoretically, because we only have constants and optional values. However, some Swift versions, for whatever reason, don't detect it and force you to create an empty initializer.</p><p class="calibre15">What are the attributes' initial values? The answer is <span class="strong"><em class="calibre9">nil</em></span>. Have a look to see whether all of them are optional; otherwise, we will have to set their values to something.</p><div class="note" title="Note"><h3 class="title2"><a id="tip12" class="calibre1"/>Tip</h3><p class="calibre7">Avoid using empty values such as empty strings to initialize an attribute; it is better to use optional attributes.</p></div></li><li class="listitem" value="4">At this time, we have the basic structure. Now we need to create the button event, so link <a id="id48" class="calibre1"/>the touch up event with the following action on the view controller:<div class="informalexample"><pre class="programlisting">@IBAction func showHTML(sender: AnyObject) {
  var card = Card()
  
  card.name = nameTextField.text
  card.address = addressTextField.text
  card.postCode = postCodeTextField.text
  card.phone = phoneTextField.text
  
  let alert = UIAlertController(title: "HTML", message: card.toHtml(), preferredStyle:.Alert)
  self.presentViewController(alert, animated: true, completion: nil)
}</pre></div></li><li class="listitem" value="5">Now we will have a look at whether this action is very clear. We will start creating a <code class="email">card</code> object, then we will receive the information we need from our view, and at the end, display it.<div class="note" title="Note"><h3 class="title2"><a id="tip13" class="calibre1"/>Tip</h3><p class="calibre7">Avoid spaghetti code; do not create an enormous action and try to divide it into classes and methods. Have a look at the Model-View-Controller pattern on Wikipedia.</p></div></li><li class="listitem" value="6">Everything is fine except for one detail: the <code class="email">Card</code> class has no method called <code class="email">toHtml</code>. No problem, let's implement it. Go back to our <code class="email">Card</code> class and add the following method:<div class="informalexample"><pre class="programlisting">func toHtml() -&gt; String{
  var html = TEMPLATE.stringByReplacingOccurrencesOfString("#name#", withString: self.name!)
  .stringByReplacingOccurrencesOfString("#address#", withString: self.address!)
  .stringByReplacingOccurrencesOfString("#postcode#", withString: self.postCode!)
  .stringByReplacingOccurrencesOfString("#phone#", withString: self.phone!)
  return html;
}</pre></div></li><li class="listitem" value="7">Now it's time to test it; just press play on your Xcode IDE, fill in the fields and press the <a id="id49" class="calibre1"/>button, and you should see a message like the one shown here:<div class="mediaobject"><img src="../images/00025.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating HTML manually">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec49" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Strings have a lot of methods; some of them are used to modify the current string, while others only return values, and others create a new string based on the original one. In our case, we used <code class="email">stringByReplacingOccurrencesOfString</code>, which generates a new string by replacing our marks <code class="email">(#something#</code>) with the corresponding attribute.</p><p class="calibre7">We can chain the result of each replacement to do the next one, preventing reassignment on each line.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip14" class="calibre1"/>Tip</h3><p class="calibre7">Nowadays, iPhones and iPads have 1 gigabyte or more of RAM, which should be enough for most of the traditional HTML templates. However, if you have a very big template with lots of replacements, you might need to look for a more optimized method for it. Replacing strings on big string variables allocates a lot of memory and you might get a poor performance.</p></div></div></div>

<div class="book" title="Creating HTML manually">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec50" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre7">If you look at this method documentation, you will see that there are two additional arguments, one called <code class="email">options</code> and another one called <code class="email">range</code>. They are used to specify a special comparator to search our string mark, and the other one uses only part of our string. As we didn't have to use them and they are optional, we've just omitted them; it wasn't <a id="id50" class="calibre1"/>necessary to fill them with nil values as we used to do in Objective-C.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip15" class="calibre1"/>Tip</h3><p class="calibre7">If your project has objects that need to create HTML, XML, or JSON code, you can create a base object with a method specific to the corresponding casting to standardize it.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Printing your object description"><div class="book" id="PNV62-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Printing your object description</h1></div></div></div><p class="calibre7">The idea of this <a id="id51" class="calibre1"/>recipe is to see the Swift way of creating a string using variable values. In Objective-C, we have a class method called <code class="email">stringWithFormat</code>, but this method isn't used in Swift with the same frequency as it is used in Objective-C because now we have interpolation. In this example, we will create an app, which will show the user three possible products. When the user chooses one of them, the app must show the information of this product and also its price, if it's available.</p></div>

<div class="book" title="Printing your object description">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec51" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new single view project called <code class="email">Chapter2 Product Value</code>. Now, let's click on the storyboard and add three buttons, as shown here:<div class="mediaobject"><img src="../images/00026.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Once you've done this, you can add a new swift file called <code class="email">Product</code>. Now we will create a <a id="id52" class="calibre1"/>class with a product name, its price, and the manufacturer name.<p class="calibre15">In this case, the only information that can be omitted is the product price; the other attributes are not optional. This means that we will need an initializer with at least the product name and the manufacturer name.</p></li><li class="listitem" value="3">As we would like to use our product with interpolation, we need to implement the <code class="email">CustomStringConvertable</code> protocol, which forces us to implement a property called <code class="email">description</code>. Once we have this information, we can implement our class with the following code:<div class="informalexample"><pre class="programlisting">class Product: CustomStringConvertible{
  var price:Double?
  var name: String
  var manufacturer: String
  
  init(name: String, manufacturer: String){
    self.name = name
    self.manufacturer = manufacturer
  }
  
  var description:String {
    return "\(self.name) (\(self.manufacturer))"
  }
}</pre></div></li><li class="listitem" value="4">Now we can go to the view controller and create three products as attributes; following our <a id="id53" class="calibre1"/>examples, we will create <code class="email">television</code>, <code class="email">gabion</code>, and <code class="email">locker</code>. So, let's add the following attributes:<div class="informalexample"><pre class="programlisting">  private let television = Product(name: "Television", manufacturer: "Telefunken")
  private let gabion = Product(name: "Gabion", manufacturer: "Maccaferri")
  private let locker = Product(name: "Locker", manufacturer: "Danalockers")</pre></div></li><li class="listitem" value="5">The next step is to create an auxiliary function, which is going to convert a double into a string with two digits of precision. I will create this function on the view controller file but outside its class. If in a project you are going to use this function in more than one file, I recommend you create another file for this function using the following code:<div class="informalexample"><pre class="programlisting">func doubleFormatter(value: Double) -&gt; String{
  return String(format: "%.2f", value)</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip16" class="calibre1"/>Tip</h3><p class="calibre7">It is a good idea to have one or more files dedicated to auxiliary functions and class extensions. This will make your code maintenance easier.</p></div></li><li class="listitem" value="6">The last thing we need to do is to create the button action. As you know, we have three buttons, and all of them will perform the same function; the only difference is the product that will be displayed. For this reason, we will create only one function and differentiate the product according to its sender.<div class="note" title="Note"><h3 class="title2"><a id="tip17" class="calibre1"/>Tip</h3><p class="calibre7">Avoid repeating code, even if they are next to each other or if they are small code. This is because when the project starts receiving changes, it will generate new bugs.</p></div></li><li class="listitem" value="7">Another detail that I would like to mention is that, in this example, I will show the product price after adding VAT (20%). This is to make you aware of the power of Swift string interpolation:<div class="informalexample"><pre class="programlisting">@IBAction func showDescription(sender: UIButton) {
  var message:String
  var product: Product

  if sender.titleLabel?.text == "Television"{
    product = television
  }else if sender.titleLabel?.text == "Gabion" {
    product = gabion
  }else if sender.titleLabel?.text == "Locker"{
    product = locker
  }else{
    return
  }
  message = "You've chosen \(product)"

  if let price = product.price {
    message += " which costs \(doubleFormatter(price * 1.20)))"
  }

    let alert = UIAlertController(title: "Product information", message: message, preferredStyle:.Alert)
               self.presentViewController(alert, animated: true, completion: nil)</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note08" class="calibre1"/>Note</h3><p class="calibre7">In this sample, we used the buttons' titles to know the product chosen, but it's a bad practice. It was done this way only to create a small example focused on string interpolation. Imagine that you need to translate your program to other languages or if you have to add a small amount of information <a id="id54" class="calibre1"/>to this label; it will make you fix a lot of code.</p></div></li><li class="listitem" value="8">Now our app is complete; try to press play and then the app buttons. You should see an alert view like this one:<div class="mediaobject"><img src="../images/00027.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Printing your object description">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec52" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">One of the greatest features of Swift is string interpolation; it allows you to have expressions like the one we did while calculating the price with VAT included. This also allows you to call functions like we called <code class="email">doubleFormatter</code> to have our number shown with two digits. This also allows us to print an object.</p><p class="calibre7">If we wanted to, we can <a id="id55" class="calibre1"/>even call object methods or property, for example. We can show the manufacturer name in uppercase, changing our description to <code class="email">\(self.name) \(self.manufacturer.uppercaseString))</code>.</p><p class="calibre7">Remember that if you want to print your own object, it must follow the <code class="email">CustomStringConvertable</code> protocol and implement the property called <code class="email">description</code>. Some languages such as Java have the equivalent method (<code class="email">toString</code> in case of Java) on a base class and you only need to override it. However, Swift has no base if you don't specify it, and this is the reason you can't overwrite the <code class="email">description</code> property without specifying the usage of the <code class="email">CustomStringConvertable</code> protocol.</p><p class="calibre7">To use string interpolation, just create a string and when you need an external value, just |wrap it between <code class="email">\(</code> (backslash and open parenthesis) and <code class="email">)</code> (closed parenthesis), for example, <code class="email">\(variable)</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip18" class="calibre1"/>Tip</h3><p class="calibre7">If the expression is getting too complex in a way that makes it difficult to use, just create a new variable with its value inside the string. This is also a good practice in terms of software maintenance. Objective-C doesn't have this feature; you have to create a new string using a class method named <code class="email">stringWithFormat</code>. We used the Swift equivalent one, which is now an initializer.</p></div><p class="calibre7">I would also like to point out that we created a constant inside our <code class="email">if</code> statement. In this case, we are not verifying whether the price is true or if it is greater than zero, we are just checking that it does not have a nil value. In case of a product that costs 0, for example, it would also evaluate to true.</p><p class="calibre7">Last but not least, notice that our variable message is not optional but that it wasn't initialized where declared. The reason for this is that the compiler will check it before reading it and setting it, and there is no possibility of having it uninitialized.</p><p class="calibre7">The initial value for this variable depends on the product value, which can't be nil; this is the reason we were <a id="id56" class="calibre1"/>forced to add an <code class="email">else</code> statement and <code class="email">exit</code> from our function. Otherwise, the compiler would find a possible way to have the product set to nil and it would fail due to our interpolation.</p></div></div>

<div class="book" title="Printing your object description">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec53" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre7">Another good solution for our <code class="email">doubleFormatter</code> function is to create an extension. To do this, just change our formatter code to the following one:</p><div class="informalexample"><pre class="programlisting">extension Double {
    func precision(numDigits: Int) -&gt; String {
        return NSString(format: "%.\(numDigits)f", self)
    }
}</pre></div><p class="calibre7">This means that now we've added a new method to double types, and we can call it whenever we want. Of course, we also have to change the interpolation that uses our double value. Now, we can use the class extension replacing the corresponding line with this one:</p><div class="informalexample"><pre class="programlisting">message += " which costs \((price * 1.20).precision(2)))"Adding different characters</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Quizzing the user"><div class="book" id="QMFO2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Quizzing the user</h1></div></div></div><p class="calibre7">Sometimes, we <a id="id57" class="calibre1"/>need to add some icons on our application, but depending on the icon you want, it's not necessary to add an image; you can use Unicode characters. Let's create a quiz app using strings alone.</p><p class="calibre7">The idea for this app is to create an app where the user needs to answer a question in 12 seconds. After the quiz, the app will show the user his score, such as the number of right and wrong questions.</p></div>

<div class="book" title="Quizzing the user">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec54" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Once we know the concept of this program, let's create a new project and name it <code class="email">Chapter 2 Unicode</code>.</p></div></div>

<div class="book" title="Quizzing the user">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec55" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre7">To create a quiz app, follow these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, let's create a <a id="id58" class="calibre1"/>new file called <code class="email">Quiz</code> and add a class with a <a id="id59" class="calibre1"/>question to it, with three possible answers and the right answer, as follows:<div class="informalexample"><pre class="programlisting">class Quiz {
    var question:String
    // First possible answer
    var ①:String
    // second possible answer
    var ②:String
    // third possible answer
    var ③:String
    // Right answer
    var 👌:Int
    
    init(question:String, ①:String, ②:String, ③:String, 👌:Int){
        self.question = question
        self.① = ①
        self.② = ②
        self.③ = ③
        self.👌 = 👌
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="tip19" class="calibre1"/>Tip</h3><p class="calibre7">To add Unicode characters to your code, you can copy from a website or go to <span class="strong"><strong class="calibre8">Edit</strong></span> | <span class="strong"><strong class="calibre8">Special characters</strong></span>.</p></div></li><li class="listitem" value="2">Now that we've got this happy class, we need to create another one to store our quizzes and manage the user's answers:<div class="informalexample"><pre class="programlisting">class QuizManager {
    private var quizzes:[Quiz] = []
    private var currentQuestion = 0
    // Total right answers
    private var 👍 = 0
    // Total wrong answers
    private var 👎 = 0
    
    func addQuiz(quiz:Quiz) {
        self.quizzes.append(quiz)
    }
    
    func getCurrentQuestion() -&gt; Quiz? {
        if currentQuestion &lt; quizzes.count {
            return self.quizzes[currentQuestion]
        }
        return nil
    }
    
    // Answer to the current question.
    // Returns true if it was the right answer
    func answer(questionNumber:Int) -&gt; Bool{
        var rightAnswer:Bool
        if getCurrentQuestion()!.👌 == questionNumber {
            rightAnswer = true
            👍++
        }else {
            rightAnswer = false
            👎++
        }
        return rightAnswer
    }
    
    func get👍() -&gt; Int {
        return 👍
    }
    
    func get👎() -&gt; Int {
        return 👎
    }
}</pre></div></li><li class="listitem" value="3">The next step is to add one label for the question, three buttons for the possible <a id="id60" class="calibre1"/>answers, and one label to show the timer. Don't forget to <a id="id61" class="calibre1"/>hide the navigation bar if you don't want to show it. Your screen should look similar to this:<div class="mediaobject"><img src="../images/00028.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="4">Now it's time to create the corresponding properties on our view controller and link <a id="id62" class="calibre1"/>them. Besides these components, we will also need a timer and <a id="id63" class="calibre1"/>another variable to know how much time has passed. Call these properties as shown here:<div class="informalexample"><pre class="programlisting">    @IBOutlet var questionLabel: UILabel!
    @IBOutlet var timerLabel: UILabel!
    @IBOutlet var answer①Button: UIButton!
    @IBOutlet var answer②Button: UIButton!
    @IBOutlet var answer③Button: UIButton!
    var quizTimer: NSTimer?
    var elapsedTime:Int
    var quizManager:QuizManager</pre></div></li><li class="listitem" value="5">Ok, now it's time to initialize these components. This is the reason we will create an initializer. In Objective-C, we used to set up the <code class="email">viewDidLoad</code> method, as this method is called after the controller's view has been loaded in memory, but now on Swift, every object must have each non-optional property initialized. This is the reason we will overwrite the <code class="email">init</code> method. Don't worry <a id="id64" class="calibre1"/>about the meaning of each line; it will be explained <a id="id65" class="calibre1"/>soon:<div class="informalexample"><pre class="programlisting">    required init(coder: NSCoder) {
        self.elapsedTime = 0
        quizManager = QuizManager()
        super.init(coder: coder)
        setupQuizManager()
        
    }
private func setupQuizManager(){
        quizManager.addQuiz(Quiz(question: "What's the capital of Australia?", ①: "Sidney", ②: "Melbourne", ③: "Canberra", 👌: 3))
        quizManager.addQuiz(Quiz(question: "What is the smallest planet in the solar system?", ①: "The moon", ②: "Mercury", ③: "The sun", 👌: 2))
        quizManager.addQuiz(Quiz(question: "In which year was Harley Davison founded?", ①: "1903", ②: "2013", ③: "80BC", 👌: 1))
    }</pre></div><p class="calibre15">The first question you might have is: why did we use <code class="email">required</code> instead of <code class="email">override</code>? This is because the initializer was defined as required on the base class (<code class="email">UIViewController</code>); in this case, we must re-implement this method.</p></li><li class="listitem" value="6">The next step is to set <code class="email">elapsedTime</code>. We will not use it now, but as it is not optional, we must set it here. Note that both <code class="email">elapsedTime</code> and <code class="email">quizManager</code> are initialized before the super class. After initializing the super class, we can add the questions to the quiz manager; which is the reason we have a call to <code class="email">setupQuizManager</code>.</li><li class="listitem" value="7">Ok, now we can show the first question on screen. To do this, we need the famous <code class="email">viewDidLoad</code> function. We can't do it on the initializer because the labels and the buttons haven't been instantiated. You can also see the <code class="email">prepareNextQuestion</code> method, which verifies whether there are more questions. If so, this shows the next question; if not, then it shows your score:<div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
        prepareNextQuestion()
    }
    private func prepareNextQuestion(){
        if quizTimer != nil {
            quizTimer!.invalidate()
        }
        guard let quiz = quizManager.getCurrentQuestion() else {
               let message = "Total \u{1F44D} \(quizManager.get👍())\nTotal \u{1F44E} \(quizManager.get👎())"
                let alert = UIAlertController(title: "Product information", message: message, preferredStyle:.Alert)
                self.presentViewController(alert, animated: true, completion: nil)
                return
            }

            elapsedTime = 0
            questionLabel.text = quiz.question
            answer1Button.setTitle(quiz.1, forState:.Normal)
            answer2Button.setTitle(quiz.2, forState:.Normal)
            answer3Button.setTitle(quiz.3, forState:.Normal)
    }</pre></div><p class="calibre15">You will notice that we are using the new <code class="email">guard</code> keyword introduced in Swift 2.0. Using guard will allow you to define an exit strategy if a particular condition is not met. This really comes in handy when unwrapping optionals; all code after the guard condition will contain the unwrapped value(s) without indentation and scope issues.</p></li><li class="listitem" value="8">There is <a id="id66" class="calibre1"/>something that is still missing, it's the timer callback. Remember that <a id="id67" class="calibre1"/>we would like to show the user how much time he has left to answer the question, and after this, we have to skip to the next question. As you can see in the preceding method, we call a method named <code class="email">tick</code>; this means that with each second, we have to increase the value of <code class="email">elapsedTime</code>, and when the timer is over, we will consider that the question was answered incorrect:<div class="informalexample"><pre class="programlisting">    func tick(){
        guard elapsedTime &lt; 12 else {
                quizManager.answer(0)
                prepareNextQuestion()
        return
            }

           let baseCharCode = 0x1F550
           timerLabel.text = String(Character(UnicodeScalar(baseCharCode + elapsedTime)))
           elapsedTime++
    }</pre></div></li><li class="listitem" value="9">If you press play now, you can see the app working except for one small detail. The <a id="id68" class="calibre1"/>user can't answer! Notice that there is no button action, so we <a id="id69" class="calibre1"/>need to add it, and remember that once the user has pressed the button, it will go to the next question:<div class="informalexample"><pre class="programlisting">    @IBAction func answer(sender: UIButton) {
        var userAnswer:Int
        switch(sender){
        case answer①Button:
            userAnswer = 1
        case answer②Button:
            userAnswer=2
        case answer③Button:
            userAnswer=3
        default:
            userAnswer = 0
        }
        quizManager.answer(userAnswer)
        prepareNextQuestion()   
    }</pre></div></li></ol><div class="calibre13"/></div><p class="calibre7">Cool, now we have our app working!</p></div></div>

<div class="book" title="Quizzing the user">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec56" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">In this recipe, we learned some ways of using Unicode happy characters. Now you can create you own WhatsApp-like program. We saw that we can have variable names with Unicode characters; if you want, you can name your variables in Japanese! You can also create strings with Unicode values using <code class="email">String(Character(UnicodeScalar(UNICODE_VALUE)))</code>, or you can also use it with interpolations such as <code class="email">Total \u{1F44D}</code>.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip20" class="calibre1"/>Tip</h3><p class="calibre7">Take care while using Unicode characters; you may be complicating the other team members' lives. Remember that not everybody speaks Japanese or Chinese, and sometimes symbols are similar to others.</p></div><p class="calibre7">We also learned that it's <a id="id70" class="calibre1"/>possible to write an integer in hexadecimal; it's only necessary to add the prefix <code class="email">0x</code>.</p></div></div>

<div class="book" title="Quizzing the user">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec57" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">If you want to see <a id="id71" class="calibre1"/>more Unicode symbols, there are some pages that can help us. I <a id="id72" class="calibre1"/>recommend <a class="calibre1" href="http://unicode-table.com">http://unicode-table.com</a> and <a class="calibre1" href="http://www.alanwood.net/demos/wingdings.html">http://www.alanwood.net/demos/wingdings.html</a>.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Searching for perfect numbers" id="RL0A1-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec23" class="calibre1"/>Searching for perfect numbers</h1></div></div></div><p class="calibre7">Believe it or not, computers were born as giant calculators, and until now, their main function was to do powerful calculations. Let's add a little bit of math to our Swift project to create an app that will look for the first perfect number and show it to the user.</p><p class="calibre7">The main question you <a id="id73" class="calibre1"/>probably have now is: what's a perfect number? A perfect number is a positive integer that is equal to the sum of its divisors. For example, 6 is a perfect number because if you sum its divisors (1 + 2 + 3), its result is 6.</p><p class="calibre7">In this recipe, we will learn how to use the range operators.</p></div>

<div class="book" title="Searching for perfect numbers" id="RL0A1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec58" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Let's start by creating a new Swift project called <code class="email">Chapter2 Perfect Number</code>.</p></div></div>

<div class="book" title="Searching for perfect numbers" id="RL0A1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec59" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Follow these steps to search for perfect numbers:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Click on the storyboard and create a layout similar to the one shown here:<div class="mediaobject"><img src="../images/00029.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li><li class="listitem" value="2">Now, let's <a id="id74" class="calibre1"/>link the text fields with the following properties:<div class="informalexample"><pre class="programlisting">    @IBOutlet var startText: UITextField!
    @IBOutlet var endText: UITextField!</pre></div></li><li class="listitem" value="3">Good, before we create the button action, we will create a function called <code class="email">isPerfect</code>, which will check whether the number passed as an argument is a perfect number or not. After this, we will create the button action:<div class="informalexample"><pre class="programlisting">    func isPerfect(number:Int) -&gt; Bool {
        var sum = 0
              (1..&lt;number).forEach { (i) -&gt; () in
          if number % i == 0 {
              sum += i
          }
       return sum == number
    }
    
    @IBAction func search(sender: UIButton) {
        var rangeStart:Int = startText.text.toInt()!
        var rangeEnd:Int = endText.text.toInt()!
        for i in rangeStart ... rangeEnd {
            if isPerfect(i){
              <span class="strong"><strong class="calibre8">let alert = UIAlertController(title: "Found", message: "\(i) is a perfect number"), preferredStyle:.Alert)</strong></span>
<span class="strong"><strong class="calibre8">               self.presentViewController(alert, animated: true, completion: nil)</strong></span>
              
              return
            }
        }

        <span class="strong"><strong class="calibre8">let message = "No perfect  number found between \(rangeStart) and \(rangeEnd)"</strong></span>
<span class="strong"><strong class="calibre8">        let alert = UIAlertController(title: "HTML", message: message, preferredStyle:.Alert)</strong></span>
<span class="strong"><strong class="calibre8">        self.presentViewController(alert, animated: true, completion: nil)</strong></span>
    }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Searching for perfect numbers" id="RL0A1-bba3081a9dc049b7aa5e4f7cc42ef8bb">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec60" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">As you can see, we used a <code class="email">for</code> loop twice. The first time we used the closed-range operator (<code class="email">…</code>), which was used to include the last number (<code class="email">rangeEnd</code>), because we want to check the last number <a id="id75" class="calibre1"/>the user entered.</p><p class="calibre7">The second time we used the half-open operator (<code class="email">..&lt;</code>) to exclude the last number because we don't want to include the last number into the sum.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note09" class="calibre1"/>Note</h3><p class="calibre7">The first version of Swift, the half-open operator, was only two dots (<code class="email">..</code>). After some beta versions, it was renamed to <code class="email">..&lt;</code>. For this reason, you can find some code on the Internet that does not work anymore.</p></div><p class="calibre7">You can also use these operators on <code class="email">switch</code> statements; they are very handy sometimes, mainly when you don't want to write the typical C <code class="email">for</code> loop.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Sorting an array of products"><div class="book" id="SJGS2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec24" class="calibre1"/>Sorting an array of products</h1></div></div></div><p class="calibre7">In this recipe, we will <a id="id76" class="calibre1"/>learn how to manage an array in Swift. Here, we will create an array of products (very typical), add products to it, remove unavailable products, and sort the array by price.</p></div>

<div class="book" title="Sorting an array of products">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec61" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new Swift single view project called <code class="email">Chapter 2 SortingProduct</code>.</p></div></div>

<div class="book" title="Sorting an array of products">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec62" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Let's create and sort an array of products by following these steps:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Before we start with the view part, let's create the model part of our application. In our case, we will create the <code class="email">Product</code> class. So, create a new file called <code class="email">Product.swift</code> and type the following code:<div class="informalexample"><pre class="programlisting">class Product: CustomStringConvertable {
    var name:String
    var price:Double
    var available:Bool
    
    init(name:String, price:Double, available:Bool){
        self.name = name
        self.price = price
        self.available = available
    }
    
    var description: String {
        return "\(self.name): \(self.price)£ available: \(self.available)"
    }
}</pre></div></li><li class="listitem" value="2">As you can see, the idea of this class is to create objects with their name, price, and availability. We also inherited it from <code class="email">CustomStringConvertable</code> to make use of its <code class="email">description</code> property.</li><li class="listitem" value="3">Now you can click on the storyboard and add two labels, one for the full catalog, which means that it will show every product in its original order, no matter how much it costs or whether it's available or not.</li><li class="listitem" value="4">The other label will show the same products but filtered for availability and sorted by price. So, now link your labels with the following properties and also create a product array as a property:<div class="informalexample"><pre class="programlisting">    var products:[Product] = [] // this is our catalog
    @IBOutlet var catalogLabel: UILabel!
    @IBOutlet var availableLabel: UILabel!</pre></div></li><li class="listitem" value="5">You can create additional labels if you want to know their meaning. I created one with the title <code class="email">Catalog</code> and another one with the title <code class="email">Available Products</code>. It is also important to set a new number of lines on <code class="email">catalogLabel</code> and <code class="email">availableLabel</code>; otherwise, it will display only the first product.</li><li class="listitem" value="6">The next <a id="id77" class="calibre1"/>step is to create the initialize; here, we only need to add some products to our array. As it's just a sample, the products will be hardcoded, but in real apps, we should retrieve them from a database or from the Internet:<div class="informalexample"><pre class="programlisting">required init(coder aDecoder: NSCoder) {
    super.init(coder: aDecoder)
    products.append(Product(name: "Shirt", price: 19, available: true))
    products.append(Product(name: "Socks", price: 1.99, available: true))
    products.append(Product(name: "Trousers", price: 22.50, available: false))
    products.append(Product(name: "T-Shirt", price: 10, available: true))
    products.append(Product(name: "Shoes", price: 32.20, available: false))
    products.append(Product(name: "Women shoes", price: 54, available: true))
    products.append(Product(name: "Men underwear", price: 9.99, available: true))
    products.append(Product(name: "Bra", price: 12.5, available: true))
    products.append(Product(name: "Panty", price: 4.45, available: true))
    products.append(Product(name: "Tennis shoes", price: 27, available: false))
}</pre></div></li><li class="listitem" value="7">After this, we can display our catalog when the view has loaded so that we can start using our <code class="email">catalog</code> label:<div class="informalexample"><pre class="programlisting">    override func viewDidLoad() {
        super.viewDidLoad()
  let descriptions = products.map{$0.description}
  let labelText = descriptions.joinWithSeperator("")
        catalogLabel.text = labelText
    }</pre></div></li><li class="listitem" value="8">Okay, now it is time to add a button and create its action:<div class="informalexample"><pre class="programlisting">    @IBAction func showAvailableProducts(sender: UIButton) {
        var availableProducts = products.filter { (product:Product) -&gt; Bool in
            return product.available
        }
        availableProducts.sort(&lt;) 
  let descriptions = availableProducts.map{$).description}
  let labelText = descriptions.joinWithSeperator(" ") 

        availableLabel.text = labelText
    }</pre></div></li></ol><div class="calibre13"/></div><p class="calibre7">The application is <a id="id78" class="calibre1"/>done; once you click on the button, you will see a result similar to the one shown here:</p><div class="mediaobject"><img src="../images/00030.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Sorting an array of products">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec63" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Arrays in Swift are very <a id="id79" class="calibre1"/>similar to mutable arrays in Objective-C; they can add objects, remove them, and so on, but there are some differences. In the Swift programming language, you have to specify the object type that the array contains, like we did when we wrote the type between brackets.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip21" class="calibre1"/>Tip</h3><p class="calibre7">You can create an array of any kind of object, as we used to do in Objective-C, by declaring a variable as <code class="email">[AnyObject]</code>. However, this should be avoided if it's not necessary. There is also the possibility of using NSArray instead of Array; in this case, we will have the same methods that we have for Objective-C.</p></div><p class="calibre7">You can also see something new on the <code class="email">viewDidLoad</code> method; we called a closure named <code class="email">map</code>, and this is because we want to create a big string with every product from our catalog delimited by a new line character (<code class="email">\n</code>). To do this, we had to convert our <code class="email">Product</code> array to a <code class="email">String</code> array. The <code class="email">map</code> function helps us with this because we can pass one function as an argument function that converts each element into the desired new type.</p><p class="calibre7">Another new function is <a id="id80" class="calibre1"/>the <code class="email">filter</code> function; this function receives another function as an argument, which returns a Boolean value. If the returned value is true, it means that the current element is valid and shouldn't be filtered; if the returned value is false, of course the new array will not contain this element.</p><p class="calibre7">Last but not least, we have the <code class="email">sort</code> function. This function doesn't create a new array; it modifies the current one. Consider that, in this case, we have an array of our own class, something that the compiler doesn't know how to order. In this case, we have to tell this function when two objects are ordered and when they are not.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip22" class="calibre1"/>Tip</h3><p class="calibre7">Take care when using functions that modify an array; once it's done, you can't roll back.</p></div></div></div>

<div class="book" title="Sorting an array of products">
<div class="book" title="There's more..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec64" class="calibre1"/>There's more...</h2></div></div></div><p class="calibre7">There are two ways of declaring an array, one of them is the way we did using brackets, and the other form of declaring an array is using <code class="email">Array&lt;Product&gt;</code>. There is no difference; they create the same kind of object. In both cases, you can't inherit from this type.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="tip23" class="calibre1"/>Tip</h3><p class="calibre7">Arrays were declared such as <code class="email">Type[]</code> on the first version of Swift, then it was replaced by <code class="email">[Type]</code>.</p></div><p class="calibre7">There are more array functions that can help us to manipulate the array such as <code class="email">reduce</code>, <code class="email">reverse</code>, or <code class="email">removeRange</code>. If you've worked with NoSQL databases, you might be habituated to this kind of function. You can also create an array extension to manipulate arrays in your own way.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Finding the way out"><div class="book" id="TI1E2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec25" class="calibre1"/>Finding the way out</h1></div></div></div><p class="calibre7">In this recipe, you will <a id="id81" class="calibre1"/>learn about tuples. This new type didn't exist in Objective-C and it's very useful in Swift, mainly when it's necessary to return more than one value. For example, there are a lot of functions that need to return a value and an error code. In other languages, we usually return the value and the error value is returned as an argument.</p><p class="calibre7">You will also learn how to use a two-dimensional array, which in Objective-C was more complicated. In this case, we will use an array of an enumeration.</p><p class="calibre7">So, this time, we will create an application that will find the way out of a maze. Of course, we will not waste our time designing a maze; we will present the result into a text view.</p></div>

<div class="book" title="Finding the way out">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec65" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new Swift single view project called <code class="email">Chapter 2 Maze</code>.</p></div></div>

<div class="book" title="Finding the way out">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec66" class="calibre1"/>How to do it…</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">First, let's create the model part of this maze. The maze for us is an array with four different possibilities: walls that we can't pass through, aisles where we can walk through, a way out that is our goal, and used, which means that we've already used this path so we shouldn't use it again; this will prevent walking around in circles. So, the first thing we will do is to create a file called <code class="email">Maze</code> and add the following code:<div class="informalexample"><pre class="programlisting">enum BlockType{
    case AISLE,
         WALL,
         USED,
         WAYOUT
}</pre></div></li><li class="listitem" value="2">Before we start implementing our <code class="email">maze</code> class, we know that we will need a type to store one coordinate of the maze and another one to know whether the path was found, and in the case it is found, we should have the path that is found:<div class="informalexample"><pre class="programlisting">typealias Position = (x: Int, y:Int)
typealias Way = (found: Bool, way: [Position])</pre></div></li><li class="listitem" value="3">Good, now it's time to create our class; in this case, we will need a two-dimensional array that represents the maze, another array that will contain the path to the way out, and two properties to know the width and the height of the maze:<div class="informalexample"><pre class="programlisting">class Maze{
    private var maze:[[BlockType]] = []
    private lazy var stack:[Position] = []
    private var width: Int
    private var height: Int</pre></div></li><li class="listitem" value="4">The first method that we will create is the initializer; in this case, it will be necessary to create a maze specifying its size. When we create the two-dimensional array, we will fill it with <code class="email">AISLE</code>; to create walls, we will use another method <a id="id82" class="calibre1"/>that we will create afterwards:<div class="informalexample"><pre class="programlisting">    init(width: Int, height: Int){
        self.width = width
        self.height = height
        for _ in 1...height{
            var row:[BlockType] = []
            for _ in 1...width{
                row.append(.AISLE)
            }
            maze.append(row)
        }
    }</pre></div></li><li class="listitem" value="5">Now we need methods to create the walls and the way out. In a more completed case, we should check whether the position is valid or not, but in this case, we will not bother ourselves with every detail. So, here are the methods:<div class="informalexample"><pre class="programlisting">    func addWall(position: Position) {
        maze[position.y][position.x] = .WALL
    }
    
    func setWayout(position: Position){
        maze[position.y][position.x] = .WAYOUT
    }</pre></div></li><li class="listitem" value="6">The next operation is to create the main method that will try to figure out one way to exit from the maze. In this case, the programmer shouldn't give the start point so that this method will have no argument, but we need to walk through the maze. However, the idea is to create a recursive function that will receive a new position and look for the next position, which is why this second function is private:<div class="informalexample"><pre class="programlisting">    func findWayOut() -&gt; Way{
        self.initStack()
        return self.next((0,0))
    }
    
    private func next(position: Position) -&gt; Way {
        
        stack.append(position)
        if self.maze[position.y][position.x] == .WAYOUT {
            return (true, self.stack)
        }
        
        maze[position.y][position.x] = .USED
        
        // UP
        if position.y &gt; 0 &amp;&amp; (maze[position.y-1][position.x] == .AISLE || maze[position.y-1][position.x] == .WAYOUT)
        {
            let result = next((position.x, position.y-1))
            if result.found {
                maze[position.y][position.x] = .AISLE
                return result
            }
        }
        
        // LEFT
        if position.x &gt; 0 &amp;&amp; (maze[position.y][position.x-1] == .AISLE || maze[position.y][position.x-1] == .WAYOUT)
        {
            let result = next((position.x-1, position.y))
            if result.found {
                maze[position.y][position.x] = .AISLE
                return result
            }
        }

        // DOWN
        if position.y+1 &lt; self.height &amp;&amp; (maze[position.y+1][position.x] == .AISLE || maze[position.y+1][position.x] == .WAYOUT)
        {
            let result = next((position.x, position.y+1))
            if result.found {
                maze[position.y][position.x] = .AISLE
                return result
            }
        }
        
        // RIGHT
        if position.x+1 &lt; self.width &amp;&amp; (maze[position.y][position.x+1] == .AISLE || maze[position.y][position.x+1] == .WAYOUT)
        {
            let result = next((position.x+1, position.y))
            if result.found {
                maze[position.y][position.x] = .AISLE
                return result
            }
        }
        
        maze[position.y][position.x] = .AISLE
        stack.removeLast()
        
        return (false, [])
    }
    
    private func initStack(){
        stack = []
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note10" class="calibre1"/>Note</h3><p class="calibre7">You may have noticed by this code that Swift has lazy evaluation. This is a good thing because we didn't have to create a nested <code class="email">if</code> function when we had to check whether the position was inside the array bound.</p></div></li><li class="listitem" value="7">Now it's time to <a id="id83" class="calibre1"/>complete our sample. Go to the storyboard and add a text view and a button to it. Link the text view with your code, calling it <code class="email">textView</code>. Then, create an action for your button, adding the following code:<div class="informalexample"><pre class="programlisting">    @IBAction func findWayOut(sender: UIButton) {
        var resultString = ""
        var maze = Maze(width: 8, height: 5)
        maze.setWayout((7,4))
        maze.addWall((1,0))
        maze.addWall((1,1))
        maze.addWall((1,2))
        maze.addWall((1,4))
        maze.addWall((3,0))
        maze.addWall((3,1))
        maze.addWall((3,3))
        maze.addWall((4,3))
        maze.addWall((5,1))
        maze.addWall((5,3))
        maze.addWall((6,1))
        maze.addWall((6,3))
        maze.addWall((6,4))
        maze.addWall((7,1))
        let (found:Bool, way:[Position]) = maze.findWayOut()
        if found {
            for position in way {
                resultString+= "(\(position.x),\(position.y)) \n"
            }
        }else{
            resultString+="No path found"
        }
        textView.text = resultString
    }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Finding the way out">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec67" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">A lot of code needs some explanation. Let's start from the beginning. We've created an enumeration with four possible values. It is better to use enumerations than an integer or a string because you prevent the usage of non-existing values.</p><p class="calibre7">After this, we've declared two type aliases; the idea of this instruction is to rename a type like we did with <code class="email">Position</code> and <code class="email">Way</code>. This doesn't create a new type but helps us in terms of software maintenance; for example, if you use an array of integers that has a possibility of being changed to an array of doubles, it's a better idea to use a <code class="email">typealias</code> than replace every declaration to <code class="email">[Double]</code>. This feature is equivalent to <code class="email">typedef</code> on the C programming language.</p><p class="calibre7">Now, let's talk about the <a id="id84" class="calibre1"/>attributes. The first attribute is not optional and this is inside double brackets, which means that it is a two-dimensional array. Usually, by human definition, we say that the first dimension of an array is the row and the second is the column.</p><p class="calibre7">When we talk about positions, for example, in a Cartesian plane, we refer to <code class="email">x</code> as the columns and <code class="email">y</code> as the rows, and this is the reason why you will see the <code class="email">y</code> coordinate coming before the <code class="email">x</code> one, such as <code class="email">maze[position.y][position.x+1] == .AISLE</code>.</p><p class="calibre7">The stack is also a non-optional attribute because we don't need the nil value, but this means that we must initialize it with something. As we initialize every time when <code class="email">findWayOut</code> is called, and the first time it will be initialized twice: one on the initializer and another inside the function itself. To prevent this double initialization, we will add the <code class="email">lazy</code> modifier, which means that it should be initialized with the same value in the declaration only the first time that this variable is going to be read if it wasn't initialized before.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note11" class="calibre1"/>Note</h3><p class="calibre7">It used to be <code class="email">@lazy</code> instead of just <code class="email">lazy</code> on the first version of Swift.</p></div><p class="calibre7">Let's talk about the initializer; to create a maze, it's necessary to receive the width and the height as arguments. As the arguments have the same name as the attributes, it's necessary to differentiate between them. In this case, the attributes are called <code class="email">self.width</code> and <code class="email">self.height</code>, and the arguments are called <code class="email">width</code> and <code class="email">height</code>.</p><p class="calibre7">The next step is the wildcard expression, which means that the current value of the <code class="email">for</code> loop is not used. In this case, instead of assigning it to a variable, we just use an underscore. Notice that the underscore is used in both loops and the inner loop doesn't affect the outer loop, and vice versa.</p><p class="calibre7">There is another way to create an array in only one line; this should be even more efficient because it's different when you create an array with a capacity rather than adding each element one by one. Try replacing both the <code class="email">for</code> loops with this single line:</p><div class="informalexample"><pre class="programlisting">maze = [[BlockType]](count: height, repeatedValue: [BlockType](count: width, repeatedValue: .AISLE))</pre></div><p class="calibre7">The next two methods are very similar, but one of them has the prefix <code class="email">add</code> and the other one has the prefix <code class="email">set</code>. It's only for software maintenance; we can have lots of walls, but only one way out. In this code, we are not checking it but it should be checked in the future. In cases like this, instead of a setter, we can use a property.</p><p class="calibre7">Another thing to add here is that when the attributes were assigned, it wasn't necessary to specify the enumeration type, such as <code class="email">BlockType.WALL</code>, but only its value, for example, <code class="email">.WALL</code>. The reason for this is that Swift knows the assigned type and that it can be omitted.</p><p class="calibre7">Then, we have the method <a id="id85" class="calibre1"/>that will be called to find the way out. It only initializes the stack to ensure that it is an empty array and then it calls the <code class="email">next</code> function. Note that this looks like we have a function with double parentheses, but it's not true, we are passing a tuple as an argument.</p><p class="calibre7">Tuples are like arrays with a fixed size. To create it, use parenthesis instead of brackets. The interesting feature about tuples in Swift is that you can name the values as if it were a dictionary or an object. So, it's up to you to create a tuple as <code class="email">(0,0)</code> or <code class="email">(x:0, y:0)</code>. In cases like the <code class="email">Way</code> type, where the elements have different meaning, I would suggest that you name the values; otherwise, it would be very difficult to remember what the element on the first position represents, if there is a path for way out or not, and that the second one represents the path itself.</p><p class="calibre7">Also, have a look at the view controller when the <code class="email">findWayOut</code> method returns its values. This looks like that they are assigned to a tuple, but it's not true, they are assigned to two variables; this feature we didn't have on C or Objective-C. This means that if you want to swap the values of two variables, you can just use a sentence, for example, <code class="email">(var1, var2) = (var2, var1)</code>, without creating any auxiliary variable as we used to do on Objective-C.</p><p class="calibre7">In this recipe, we used an array as a stack to store the path that we've already walked through, and using the <code class="email">removeLast</code> method we could return back a step, as if we had some kind of breadcrumb and that is the secret to finding the way out. We just need to follow a path, and if we get lost, we only need to collect the breadcrumbs and try another one.</p><p class="calibre7">After finding the goal, the <a id="id86" class="calibre1"/>user will see the path as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00031.jpeg" alt="How it works…" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Finding the way out">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec68" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Tuples in Swift can be used in different ways; they are also very useful in some switch cases; however, don't try <a id="id87" class="calibre1"/>to substitute dictionaries or arrays with tuples, each type has its own function.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note12" class="calibre1"/>Note</h3><p class="calibre7">Swift 1.2 introduced a native type called <code class="email">Set</code> that does what this recipe does.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating your own set"><div class="book" id="UGI02-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec26" class="calibre1"/>Creating your own set</h1></div></div></div><p class="calibre7">Sometimes the included set type in Swift is not enough to solve our problems, so in this recipe, we will create our own set. The goal of this recipe is not only to show how you could create your own set, but also how to overload operators.</p><p class="calibre7">For this recipe, we will <a id="id88" class="calibre1"/>create a simple shopping list program where the user can write the product that he needs to buy and its quantity. If he tries to add it twice, the product will not appear twice, rather it will sum the quantity to the existing product.</p><p class="calibre7">There will be a switch button that when disabled means the user won't be able to add the product to the shopping list if it already exists, and of course, there will be a button to display our list.</p></div>

<div class="book" title="Creating your own set">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec69" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">As usual, create a new project called <code class="email">Chapter2 ShoppingList</code>, and then create a Swift file called <code class="email">ShoppingList</code>. The idea here is to create our container and the type that it will store; in this case, the <code class="email">Product</code> class.</p></div></div>

<div class="book" title="Creating your own set">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec70" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">Product is something that is related with our container; we can even say that this is like a part of it. So, in this case, we can create a nested class to work with it. In this class, we will need only two attributes: its name and its quantity. Follow these steps to create your own sets:</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In this case, we will create its description, and it will implement the <code class="email">Comparable</code> protocol. We will use this protocol to know whether two objects represent the same product. Let's start coding:<div class="informalexample"><pre class="programlisting">class ShoppingList: CustomStringConvertable {
    class Product: Comparable, CustomStringConvertable {
        var name:String
        lazy var quantity:Int = 1
        
        init(_ name:String){
            self.name = name
        }
        
        var description: String {
            return "\(name): \(quantity)"
        }
    }</pre></div></li><li class="listitem" value="2">Now we need to create the shopping list attributes. We only need an array to store our products:<div class="informalexample"><pre class="programlisting">private var set:[Product] = []</pre></div></li><li class="listitem" value="3">As the shopping list is a set, we should implement the basic methods. One method is used to add a product and another one is used to know whether the shopping list already has a product. And, of course, we will also add the <code class="email">description</code> property:<div class="informalexample"><pre class="programlisting">    func contains(product: Product)-&gt; Bool{
        for currentProduct in set {
            if currentProduct == product {
                return true
            }
        }
        return false
    }

    func add(product:Product){
        for currentProduct in set {
            if currentProduct == product {
                currentProduct += product.quantity
                return
            }
        }
        set.append(product)
    }
    
    var description: String {
  let descriptions = set.map{$0.description}
  return descriptions.joinWithString(" ")
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note13" class="calibre1"/>Note</h3><p class="calibre7">Note that we compared a product with another using the double equality operator (<code class="email">==</code>). The main question is how does the compiler make the comparison? Actually, the compiler can't make this comparison without the programmer's help. First of all, as you can see, we used the <code class="email">Comparable</code> protocol in this program. This is not really necessary, but it's good to implement this protocol in case we also need to use a product with other containers.</p></div></li><li class="listitem" value="4">Even if it's a <a id="id89" class="calibre1"/>comparable, we have to implement a function that will tell the runtime whether two products are equals or not. This function must be called <code class="email">==</code> (yes, double equals), and it must be declared on the global scope: outside classes and functions. So, here we have the corresponding code:<div class="informalexample"><pre class="programlisting">func ==(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -&gt; Bool{
  return leftProduct.name.lowercaseString == rightProduct.name.lowercaseString
}</pre></div></li><li class="listitem" value="5">If we were implementing only the <code class="email">Equatable</code> protocol, we wouldn't need to implement any other method; however, as we are implementing <code class="email">Comparable</code>, we will also need to implement the operators <code class="email">&lt;</code>, <code class="email">&lt;=</code>, <code class="email">&gt;</code>, and <code class="email">&gt;=</code>:<div class="informalexample"><pre class="programlisting">func &lt;=(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -&gt; Bool{
    return leftProduct.name &lt;= rightProduct.name
}
func &gt;=(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -&gt; Bool{
    return leftProduct.name &gt;= rightProduct.name
}
func &gt;(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -&gt; Bool{
    return leftProduct.name &gt; rightProduct.name
}
func &lt;(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -&gt; Bool{
    return leftProduct.name &lt; rightProduct.name
}</pre></div></li><li class="listitem" value="6">As we are creating <a id="id90" class="calibre1"/>some operators, let's continue with them. Let's overload the <code class="email">+=</code> operator twice, once to add more units to a product and another to add a product into the shopping list:<div class="informalexample"><pre class="programlisting">func +=(shoppingList: ShoppingList, product: ShoppingList.Product) -&gt; ShoppingList{
    shoppingList.add(product)
    return shoppingList
}

func +=(product: ShoppingList.Product, quantity: Int) -&gt; ShoppingList.Product{
    product.quantity += quantity
    return product
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note14" class="calibre1"/>Note</h3><p class="calibre7">Note that it wasn't necessary to implement any protocol to overload this operator, and it wasn't even necessary for the previous operators, but it's a good idea to implement the <code class="email">Comparable</code> protocol to use with other functions or algorithms.</p></div><div class="note" title="Note"><h3 class="title2"><a id="tip24" class="calibre1"/>Tip</h3><p class="calibre7">Implement the <code class="email">Comparable</code> or <code class="email">Equatable</code> protocols when you can use it with other generic objects, for example, when you think the object could be ordered.</p></div></li><li class="listitem" value="7">A good feature of <a id="id91" class="calibre1"/>Swift is that you don't need to overload only existing operators; you can also create new operators. In this case, we will create two new operators: <code class="email">=&gt;</code> that will tell us whether a product is in our shopping list and <code class="email">!=&gt;</code>, which is the opposite operator. I will explain this in detail later. Use these operators in the following code:<div class="informalexample"><pre class="programlisting">infix operator =&gt; { associativity left precedence 140 }
infix operator !=&gt; { associativity left precedence 140 }

func =&gt;(product:ShoppingList.Product, shoppingList:ShoppingList)-&gt;Bool {
    return shoppingList.contains(product)
}

func !=&gt;(product:ShoppingList.Product, shoppingList:ShoppingList)-&gt;Bool {
    return !shoppingList.contains(product)
}</pre></div></li><li class="listitem" value="8">Now that the model is done, let's create the view. Enter two text fields: one for the product name and another one for the quantity; one switch to allow appending products or not; two buttons, one to add the product to the list and another one to display the list; and a text view. Let's connect them, except the buttons with the following attributes:<div class="informalexample"><pre class="programlisting">    @IBOutlet var fieldQuantity: UITextField!
    @IBOutlet var fieldProduct: UITextField!
    @IBOutlet var appendSwitch: UISwitch!
    @IBOutlet var textResult: UITextView!</pre></div></li><li class="listitem" value="9">Add an attribute that represents the application shopping list:<div class="informalexample"><pre class="programlisting">var shoppingList: ShoppingList = ShoppingList()</pre></div></li><li class="listitem" value="10">Now we need to add the button actions. Let's start with the easiest thing: the display button that will show the description of the shopping list into the text view:<div class="informalexample"><pre class="programlisting">    @IBAction func showList(sender: UIButton) {
        textResult.text = shoppingList.description
    }</pre></div></li><li class="listitem" value="11">Now we have to create the add button action. In this case, it will be necessary to check <a id="id92" class="calibre1"/>whether the user introduced a number on the quantity text field and also whether it was possible to add the product to the shopping list:<div class="informalexample"><pre class="programlisting">    @IBAction func addToList(sender: UIButton) {
        var product = ShoppingList.Product(fieldProduct.text)
        if  let quantity = Int(fieldQuantity.text) {
            product.quantity = quantity
            if appendSwitch.on || product !=&gt; shoppingList{
                shoppingList += product
            }else {
              let alert = UIAlertController(title: "Wrong Product", message: "This product is already on your list"), preferredStyle:.Alert)
              self.presentViewController(alert, animated: true, completion: nil)
            }
          }else {

            let alert = UIAlertController(title: "Wrong Value", message: "Oops! I need a number on the quantity field"), preferredStyle:.Alert)
            self.presentViewController(alert, animated: true, completion: nil)
            
            fieldQuantity.text = ""
        }
        clear()
    }</pre></div><p class="calibre15">The <code class="email">clear</code> function is just an auxiliary method to empty the text fields every time we press the add button:</p><div class="informalexample"><pre class="programlisting">    private func clear(){
        fieldQuantity.text = ""
        fieldProduct.text = ""
        fieldQuantity.becomeFirstResponder()
    }</pre></div></li><li class="listitem" value="12">Now you can click on play and add some products, repeat some products, and display them. You should have a result like the one shown here:<div class="mediaobject"><img src="../images/00032.jpeg" alt="How to do it…" class="calibre10"/></div><p class="calibre14"> </p></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Creating your own set">
<div class="book" title="How it works…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec71" class="calibre1"/>How it works…</h2></div></div></div><p class="calibre7">Overloading operators is something very common in Swift; you can overload existing operators and you can <a id="id93" class="calibre1"/>create your own operator. If you want to create your own operator, the <a id="id94" class="calibre1"/>first thing you have to do is to report some properties of your operator. First, you have to choose if you type the usage:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Infix</strong></span>: This means that the operator is used between two objects; for example, in our sample, we <a id="id95" class="calibre1"/>created the <code class="email">!=&gt;</code> operator to be used between a product and a set.</li><li class="listitem"><span class="strong"><strong class="calibre8">Prefix</strong></span>: This means <a id="id96" class="calibre1"/>that the operator will operate only with the object that is on its right. For example, let's imagine that we would like to create the <code class="email">!!!</code> operator, which could mean that we would like to empty the shopping list; in this case, we should use it as <code class="email">!!!shoppingList</code>.</li><li class="listitem"><span class="strong"><strong class="calibre8">Postfix</strong></span>: This operator <a id="id97" class="calibre1"/>will operate only with the object that is on its left, such as <code class="email">shoppingList!!!</code>.</li></ul></div><p class="calibre7">The next step is to write the word <code class="email">operator</code> and the name you've chosen for it. After this, you have to add <a id="id98" class="calibre1"/>between parentheses the properties of this operator. Associativity values are left, right, and none. This is as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Left-associative</strong></span>: This means that when there's more than one operator with the same <a id="id99" class="calibre1"/>precedence, the one that is furthest left is going to be evaluated first</li><li class="listitem"><span class="strong"><strong class="calibre8">Right-associative</strong></span>: This, <a id="id100" class="calibre1"/>as you can imagine, is the opposite of the left-associative</li><li class="listitem"><span class="strong"><strong class="calibre8">None-associative</strong></span>: This <a id="id101" class="calibre1"/>means that it's not permitted to have more than one operator with the same precedence</li></ul></div><p class="calibre7">Precedence is like a priority. Higher precedence is evaluated first.</p></div></div>

<div class="book" title="Creating your own set">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec72" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">Swift allows changing the function of existing operators, for example, you can declare the following function:</p><div class="informalexample"><pre class="programlisting">func  + (i:Int, j:Int) -&gt; Int {
    return 10
}</pre></div><p class="calibre7">This will make every integer sum operator return <code class="email">10</code>. This is something curious, but I wouldn't do that in sane conditions. Even worse than this is if you create recursive calls like this code:</p><div class="informalexample"><pre class="programlisting">func  + (i:Int, j:Int) -&gt; Int {
    if i == 1 &amp;&amp; j == 1 {
    return 10
    }else {
        return i + j
    }
}</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Organizing a dinner room"><div class="book" id="VF2I2-bba3081a9dc049b7aa5e4f7cc42ef8bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec27" class="calibre1"/>Organizing a dinner room</h1></div></div></div><p class="calibre7">In this recipe, we will learn how to use other features from the Swift programming language. We will <a id="id102" class="calibre1"/>copy the range of elements from an array, use dictionaries, subscripts, switches, and name a loop.</p><p class="calibre7">For this app, we will create a dinner for a company. In this case, it's not a wedding table where couples must be seated next to each other, rather we only need people of the same group sat together on the same table, probably because they are from the same team or something similar.</p><p class="calibre7">We will create a class that represents a room. To add a new guest into this room, we will need to specify the name of someone who belongs to this group, which is already inside the room. If the person we want to add to this room is the first one, we will use the nil value as the name of the person who belongs to this group.</p><p class="calibre7">In the case of adding someone to a table that is full, one person from this table must be reallocated to another table. Of course, we won't use the most optimized algorithm because that's not our main goal.</p></div>

<div class="book" title="Organizing a dinner room">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch02lvl2sec73" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre7">Create a new Swift single view project called <code class="email">Chapter2 DinnerRoom</code>.</p></div></div>

<div class="book" title="Organizing a dinner room">
<div class="book" title="How to do it…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch02lvl2sec74" class="calibre1"/>How to do it…</h2></div></div></div><p class="calibre7">As usual, we need to start with the model part of the Model-View-Controller. For this code, we will need a class for the room, another for a table that will store the seats with the person that is seated there, a group, which is the range of the table of people that belongs to the same team, and of course, we will also need a class to represent a person.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Let's start with the <code class="email">person</code> class; in this case, we only need to store his name and the group he belongs to. As there is a period where the person can be without any group, this attribute should be optional. So, create a new Swift file called <code class="email">person.swift</code> and add the following code:<div class="informalexample"><pre class="programlisting">class Person: Equatable {
    var name: String
    var group:Group?
    init(_ name: String){
        self.name = name
    }
}</pre></div></li><li class="listitem" value="2">As you can see, this class inherits from the <code class="email">Equatable</code> protocol, which means that we must implement the <code class="email">==</code> operator, as follows:<div class="informalexample"><pre class="programlisting">func ==(person1:Person, person2:Person)-&gt;Bool{
    return person1.name == person2.name
}</pre></div></li><li class="listitem" value="3">Good, now let's create the <code class="email">Group</code> class. Remember that a group doesn't have a name; it's just a range of people who are sitting together. In this case, we need to <a id="id103" class="calibre1"/>store where the range starts, where it finishes, and its table. As you may imagine, we need to create a file called <code class="email">group.swift</code> and add the following code:<div class="informalexample"><pre class="programlisting">class Group {
    unowned var table:Table
    var rangeStart: Int
    var rangeEnd:Int
    var size:Int {
        return rangeEnd - rangeStart + 1
    }
    
    init (table:Table, entryPoint:Int){
        self.table = table
        rangeStart = entryPoint
        rangeEnd = entryPoint
    }
    
    func shift(){
        rangeStart++
        rangeEnd++
    }
    
    func increase(){
        rangeEnd++
    }
}</pre></div><div class="note" title="Note"><h3 class="title2"><a id="note15" class="calibre1"/>Note</h3><p class="calibre7">Note that the <code class="email">size</code> property has no setters, only a getter, and it's not related with a new attribute; that's what is called a <code class="email">computed</code> property. Also, note that we had to add an <code class="email">unowned</code> modifier to the <code class="email">table</code> attribute; this is because if we had a UML class diagram, we can see that a room contains tables that contain people who belong to a group that knows its table. As you can see, we have a cycle, which by default would prevent the reference counter from reaching zero, and as a consequence, it would create a memory leak. Adding <code class="email">unowned</code> will help us to avoid this problem.</p></div></li><li class="listitem" value="4">The next class is <code class="email">Room</code>. This class needs to store its tables and also the guests that are already in the room. This second attribute is not mandatory, but it is faster for the computer looking into a dictionary than searching for it, and it is also faster for the programmer because he will write less code. Add <code class="email">room.swift</code> to <a id="id104" class="calibre1"/>your project and start adding the following code:<div class="informalexample"><pre class="programlisting">class Room: CustomStringConvertable {
    let STANDARD_TABLE_SIZE = 3
    var guests:[String: Person] = [String: Person] ()
    var tables = [Table]()
    
    func add(table:Table){
        tables.append(table)
    }
    
    func add(person:Person){
        guests[person.name] = person
    }

    var description:String {
  let descriptions = tables.map{$0.description}
  return descriptions.joinWithSeperator("Table: ")
    }</pre></div></li><li class="listitem" value="5">Now, look at the <code class="email">guests</code> attribute, as we have two types between brackets and separated by a colon; this means that it's not an array, it's a dictionary. Alternatively, you can also write <code class="email">Dictionary&lt;String,Person&gt;</code> instead of <code class="email">[String: Person]</code>. One difference with dictionaries from Objective-C to Swift is that you must specify the key and the value types.<div class="note" title="Note"><h3 class="title2"><a id="note16" class="calibre1"/>Note</h3><p class="calibre7">When possible, try to use dictionaries instead of searching for elements, as you will have a better performance.</p></div><p class="calibre15">If you are a good observer, you can see that we repeated the <code class="email">add</code> function. The difference is on the arguments type. This means that you can overload methods and functions in Swift.</p></li><li class="listitem" value="6">Now, to check whether someone is already in this room, we will use the brackets operator so we can type code such as <code class="email">if room["Harry Potter"] == true {...</code>. To enable it in Swift, we have to write some kind of special function called subscript. In this case, we will write a read-only <code class="email">subscript</code>:<div class="informalexample"><pre class="programlisting">    subscript(name:String)-&gt;Bool{
        get{
            if let guest = guests[name] {
                return true
            }
            return false
        }
        // No setter
    }</pre></div></li><li class="listitem" value="7">Now we only need to use the same idea to add someone in the room; remember that we have to specify someone's name from the same group or nil when it's the <a id="id105" class="calibre1"/>first person. Following this idea, we can add someone into the room with a code similar to <code class="email">room["Harry Potter"] = Person("David Copperfield")</code>:<div class="informalexample"><pre class="programlisting">    subscript(name:String?)-&gt;Person{
        get{
            assertionFailure("Sorry, no subscript getter")
        }
        
        set(newValue){
            guests[newValue.name] = newValue
            // if the key is nil we will have to look for
            // the first table that is not null. If we
            // are not able to find it we have to create a new table
            if let personName = name {
                if let guest = guests[personName]{
                    // now we need to find its table
                    var guestGroup = guest.group!
                    newValue.group = guestGroup
                    // now we have to check the group table is full
                    if guestGroup.table.full {
                    // the table is full, if we have only 1 group it is not possible to add
                    // any one to this table, otherwise the last group should move to another table
                      if guestGroup.table.size == guestGroup.size {
                        // The group is bigger than the supported size
                        assertionFailure("Group too big")
                        }else{
                          // the last table group should go to a new table
                          
                          var lastGroup = guestGroup.table.getLastGroup()!
                          tables.append( guestGroup.table.transferGroup(lastGroup))
                          // now the guestGroup table has free space
                        }
                    }
                    guestGroup.table.add(newValue)
                    guestGroup.increase()
                }else
                {
                    assertionFailure("This guest should exists")
                }
                
            }else {
                // this person belongs to a new group
                var table = freeTable()
                var index = table.add(newValue)
                var group = Group(table: table, entryPoint: index)
                newValue.group = group
            }
        }
    }
    
    private func freeTable() -&gt; Table {
        for table in tables {
            if !table.full {
                return table
            }
        }
        var newTable = Table(STANDARD_TABLE_SIZE)
        tables.append(newTable)
        return newTable
    }</pre></div><p class="calibre15">As you can see, we added an assertion into the getter method of the subscript; the <a id="id106" class="calibre1"/>reason is that subscripts can be read-only or read-write but they can't be write-only. In this case, there is no sense in asking for a return value, so the only thing we can do is to create an assertion to prevent problems.</p><div class="note" title="Note"><h3 class="title2"><a id="tip25" class="calibre1"/>Tip</h3><p class="calibre7">Don't use <code class="email">assertionFailure</code> regularly; try to create code that can detect errors and continue to work.</p></div></li><li class="listitem" value="8">Create a new file called <code class="email">table.swift</code>. Before we start coding the <code class="email">Table</code> class, we need to know that a table will have an array of seats. We can have a free seat or an <a id="id107" class="calibre1"/>occupied one. If it's occupied, it's by someone, so we need to know who is occupying the seat. For cases such as this, Swift allows us to use enumerations:<div class="informalexample"><pre class="programlisting">enum TableSeat {
    case FREE,
    OCCUPIED(Person)
}</pre></div><p class="calibre15">The only problem with enumeration is that we need to use <code class="email">switch</code> cases a lot of times, so in this case, where we want to know whether one seat is free or occupied by someone, it's a good idea to overload the operators <code class="email">==</code> and <code class="email">!=</code>:</p><div class="informalexample"><pre class="programlisting">func == (seat1:TableSeat, seat2:TableSeat) -&gt; Bool {
    switch(seat1,seat2){
    case (.FREE,.FREE):
        return true
    case (.OCCUPIED(let person1),.OCCUPIED(let person2)):
        return person1 == person2
    default:
        return false
    }
}

func != (seat1:TableSeat, seat2:TableSeat) -&gt; Bool {
    return !(seat1 == seat2)
}</pre></div></li><li class="listitem" value="9">Now we can start typing the <code class="email">Table</code> class. Basically, we need to store an array of seats, but we can have some auxiliary computed properties and methods, as follows:<div class="informalexample"><pre class="programlisting">    private var seats:[TableSeat]
    
    init (_ size: Int){
        seats = [TableSeat](count: size, repeatedValue: TableSeat.FREE)
    }
    
    var full:Bool {
        return seats.last! !=  .FREE
    }
    
    var freeSeats:Int {
        var total = 0
            for i in seats.reverse() {
                if i == TableSeat.FREE {
                    ++total
                }else{
                    break
                }
            }
            return total
    }
    
    var nextFreeSeat:Int {
        return seats.count - self.freeSeats
    }

    var description:String {
        let takenSeats = seats.filter({ (seat) -&gt; Bool in
        switch seat {
            case .FREE:
                return false
            case .OCCUPIED:
                return true
            }
        }).map({(seat) -&gt; String in
            switch seat {
                case .FREE:
                    assertionFailure("???")
                case .OCCUPIED(let person):
                    return person.name
            }
        })
    
    return takenSeats.joinWithString(", ")

    private func shift(group:Group){
        seats[(group.rangeStart+1)...(group.rangeEnd+1)] = seats[group.rangeStart...group.rangeEnd]
        seats[group.rangeStart] = .FREE
        group.shift()
    }
    
    var size:Int {
        return seats.count
    }
    
    func getLastGroup() -&gt; Group? {
        for seat in seats.reverse() {
            switch seat {
            case .OCCUPIED(let bySomeone):
                return bySomeone.group
            case .FREE:
                continue
            }
        }
        // no group
        return nil
    }
    
    func  transferGroup(group: Group)-&gt;Table{
        var newTable = Table(seats.count) // creating a new table with the same size
        newTable.seats[0..&lt;(group.size)] = seats[group.rangeStart...group.rangeEnd]
        seats[group.rangeStart...group.rangeEnd] = [TableSeat](count: group.size, repeatedValue: .FREE)[0...(group.size-1)]
        group.table = newTable
        return newTable
    }

func add(person:Person)-&gt;Int {
        var lastAllocatedSeat = self.nextFreeSeat-1
        // return -1 if it wasn't possible
        if self.full {
            return -1
        }
        var index = lastAllocatedSeat + 1
        if let group = person.group {
          // who we have to shift the groups until we find
            // the new person's group and them we keep
            // him (or her) on the array
            searching:
                while lastAllocatedSeat&gt;=0 {
                  // in this case the seat should be always occupied
                    // but as the compiler doesn't know we have to retrieve
                    // its value
                    switch seats[lastAllocatedSeat] {
                    case .FREE:
                        assertionFailure("shouldn't be any free seat here")
                    case .OCCUPIED(let groupPerson):
                        if groupPerson.group !== person.group {
                            // different groups, let's move the group to the right
                            lastAllocatedSeat = groupPerson.group!.rangeStart-1
                            shift(groupPerson.group!)
                            
                        }else{
                            break searching
                        }
                    }
            }
            index = lastAllocatedSeat + 1
            
        }else{
            // if the person group is null means that it's a new group so
            // can add him on the first available seat
        }
        self.seats[index] = .OCCUPIED(person)
        return index
    }
}</pre></div></li><li class="listitem" value="10">Before giving <a id="id108" class="calibre1"/>much explanation, we will test the previous code by adding <code class="email">textView</code> to our view controller and some people into <code class="email">room.swift</code>:<div class="informalexample"><pre class="programlisting">    @IBOutlet var textView: UITextView!
    var room:Room = Room()
    
    override func viewDidLoad() {
        super.viewDidLoad()

        room[nil] = Person("Mr Peter File")
        room[nil] = Person("Ms Mary Simpson")
        room["Mr Peter File"] = Person("Mr Taro Mashimoto")
        room[nil] = Person("Mr Stuart Johnson")
        room["Ms Mary Simpson"] = Person("Mr Scott Chesterford")
        
        self.textView.text = room.description
    }</pre></div></li></ol><div class="calibre13"/></div></div></div>

<div class="book" title="Organizing a dinner room">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch02lvl2sec75" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre7">As you can see, we used some new features here. We were able to copy a range of seats using the <code class="email">…</code> operator, which is an awesome feature that can save us from typing a lot of loops that do the same thing.</p><div class="informalexample" title="Note"><h3 class="title2"><a id="note17" class="calibre1"/>Note</h3><p class="calibre7">Note that this slice operator (<code class="email">…</code>), when working with a part of an array, the compiler can create a good optimization for a better performance.</p></div><p class="calibre7">Another good feature is the <a id="id109" class="calibre1"/>
<code class="email">switch</code> statement that can work with a combination of values. Look at the <code class="email">==</code> operator and you'll see that we don't need to create inner switched cases for each case. Talking about the equalities operator, have a look at the <code class="email">add</code> method that we used: <code class="email">!==</code> instead of <code class="email">!=</code>. The reason is that when we need to check whether two objects have the same instance, we have to use the operator <code class="email">===</code> or <code class="email">!==</code> to check whether they don't share the same instance.</p><p class="calibre7">We also used a label to name a loop (searching), the reason for that is, by default, the <code class="email">break</code> statement will exit from the switch, not from our loop. We can control this situation with some Boolean variables, but we can avoid it breaking with <code class="email">break searching</code>.</p><p class="calibre7">Another good trick was walking in the reverse way on our arrays. We did it using the method reverse. Of course, we did it knowing that we have a small array; I can't imagine a table for one million people. Using reverse with big arrays is not a good idea because a new array will be created internally.</p></div></div>

<div class="book" title="Organizing a dinner room">
<div class="book" title="There's more…"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch02lvl2sec76" class="calibre1"/>There's more…</h2></div></div></div><p class="calibre7">You can still use the old <code class="email">NSDictionary</code> class, but I will follow the same rule that we saw with <code class="email">NSArray</code>. Swift dictionaries are safer, and if you need a dictionary, store completely different object types. It would be better to review your code as it could be very painful to maintain this code.</p><p class="calibre7">You have only just started learning about assertions, but further on in this book, you will learn how to deal with assertions.</p><p class="calibre7">When you need to work with functions without specifying the input or output type, Swift gives you the feature of <a id="id110" class="calibre1"/>generics. We will learn more about this in the next chapter.</p></div></div></body></html>