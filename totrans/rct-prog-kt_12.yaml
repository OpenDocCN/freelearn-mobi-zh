- en: Reactive Kotlin and Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, our learning about reactive programming in Kotlin is almost complete. We
    have arrived at the last, but probably the most important, chapter of this book.
    Android is probably the biggest platform for Kotlin. During the last Google IO—Google
    IO 17, Google announced official support for Kotlin and added Kotlin as a first-class
    citizen of the Android application development. Kotlin is now the only officially
    supported Android application development language other than Java.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive programming is already there in Android—most of the top libraries in
    Android support reactiveness. So, it is quite obvious that in a book titled *Reactive
    Programming in Kotlin*, we must cover Android as well.
  prefs: []
  type: TYPE_NORMAL
- en: Teaching you Android development from scratch is beyond the scope of this book,
    as it's a vast topic. You can find many books out there if you would like to learn
    Android development from scratch. This book assumes you have some basic knowledge
    in Android application development and can work with `RecyclerView`, `Adapter`,
    `Activity`, Fragment, CardView, AsyncTask, and more. If you are not familiar with
    any of the topics mentioned, you can read *Expert Android Programming* by *Prajyot
    Mainkar*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, are you wondering what this chapter has for you? Take a look at the following
    list of the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kotlin in Android Studio 2.3.3 and 3.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with `ToDoApp` in Android and Kotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: API calls with Retrofit 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up RxAndroid and RxKotlin
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using RxKotlin with Retrofit 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developing our app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A brief introduction to RxBinding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started with setting up Kotlin in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Kotlin in Android Studio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We strongly encourage you to use Android Studio 3.0 for Android development,
    irrespective of whether you're using Kotlin or not. Android Studio 3.0 is the
    latest version of Android Studio, with a lot of bug fixes, new features, and improved
    Gradle build time.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Android Studio 3.0, you don''t need to do any setup to use Kotlin for Android
    development. You just need to select Include Kotlin support while creating a new
    project. Here is a screenshot for your reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/522fe92a-f72c-4e55-a816-7b254c3fed99.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We've highlighted the Include Kotlin support section of the Android Studio—Create
    Android Project dialog.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if you''re using Android Studio 2.3.3, then follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Go to Android Studio | Settings | Plugins.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Search for `Kotlin` (take a look at the following screenshot) and install that
    plugin as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/deb76a4a-bd0c-427a-afd6-19311956e6b4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Start a new Android project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To apply the Kotlin plugin to the project, open the project level `build.gradle`
    and modify the content, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/68e6de34-8c0a-43a0-8f44-b674e9e0a53d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Open the `build.gradle` in your module (or we might say, app level `build.gradle`)
    and add the following `dependencies`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: You are now all set to start writing Kotlin code in Android Studio.
  prefs: []
  type: TYPE_NORMAL
- en: However, before starting with the Kotlin code, let's first review our `build.gradle`.
    The preceding code that I showed for Android Studio 2.3.3 is valid for Android
    Studio 3.0 as well, you just don't have to manually add this as Android Studio
    3.0 automatically adds it for you. However, what is the purpose of those lines?
    Let's inspect them.
  prefs: []
  type: TYPE_NORMAL
- en: In the project level `build.gradle` file, the `ext.kotlin_version = "1.1.51"`
    line creates a variable in Gradle with the name of `kotlin_version`; this variable
    will hold a `String` value, `1.1.51` (which is the latest version of Kotlin at
    the time of writing this book). We are writing this in a variable, as this version
    is required in a number of places in the project level and app level `build.gradle`
    file. If we declare it once and use it in multiple places, then there will be
    consistency, and there won't be any chance for human mistakes.
  prefs: []
  type: TYPE_NORMAL
- en: Then, on the same file (project level `build.gradle`), we will add `classpath
    "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"`. This will define
    a classpath used by Gradle to search for `kotlin-jre` when we add them as a dependency.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the app level `build.gradle` file, we will write `implementation "org.jetbrains.kotlin:kotlin-stdlib-jre7:$kotlin_version"`.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started with the Kotlin code. As we mentioned in the previous
    chapter, we will create a `ToDoApp`. There will be three screens, one for the `ToDo
    List`, one to create a `ToDo`, and one to edit/delete `ToDo`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with ToDoApp on Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As mentioned earlier, we are using Android Studio 3.0 (stable) for this project.
    The following screenshot depicts the project structure that we''re using:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/71882bb0-c011-4d63-b1db-f39e50862a2e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this project, we are using package-by features, and I do prefer to use package-by
    for Android development, mainly for its scalability and maintainability. Also,
    note that it is best practice to use package-by feature in Android; although,
    you can obviously use your preferred model. You can read more about the package-by
    feature at [https://hackernoon.com/package-by-features-not-layers-2d076df1964d](https://hackernoon.com/package-by-features-not-layers-2d076df1964d).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's understand the package structure used in this application. The root
    package here is `com.rivuchk.todoapplication`, the package for the application,
    identical with the `applicationId`. The root package contains two classes—`ToDoApp`
    and `BaseActivity`. The `ToDoApp` class extends `android.app.Application` so that
    we can have our own implementation of the `Application` class. Now, what is `BaseActivity`?
    `BaseActivity` is an abstract class created within this project, and all activities
    in this project should extend `BaseActivity`; so, if we want to implement something
    throughout all the activities in this project, we can write the code in `BaseActivity`
    and rest assured that all activities will now implement the same.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have an `apis` package for the classes and files related to the API
    calls (we will use Retrofit) and `datamodels` for models (POJO) classes.
  prefs: []
  type: TYPE_NORMAL
- en: We have the `Utils` package for `CommonFunctions` and `Constants` (a singleton
    `Object` to hold constant variables such as `BASE_URL` and others).
  prefs: []
  type: TYPE_NORMAL
- en: The `addtodo`, `tododetails`, and `todolist` are three feature-based packages.
    The `todolist` package contains `Activity` and `Adapter` for displaying the list
    of todos. The `tododetails` package contains the `Activity` responsible to display
    the details of todo. We will use the same `Activity` to edit as well. The `addtodo`
    package holds the `Activity` that will be used to accomplish the functionality
    of adding a todo.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting with the activities and layouts, I want you to take a look
    inside `BaseActivity` and `ToDoApp`, so here is the code inside the `ToDoApp.kt`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'A small class indeed; it contains only a `companion object` to provide us with
    the instance. This class will grow as we move ahead with this chapter. We declared
    `ToDoApp` as the `application` class for this project in the manifest, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BaseActivity` is also now small. As with the `ToDoApp`, it''ll also grow
    over the course of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: For now, `BaseActivity` only hides the `onCreate` method from the `Activity`
    class, and provides a new abstract method—`onCreateBaseActivity`. This class also
    mandates that we override `onCreateBaseActivity` in child classes so that if there's
    anything we need to implement inside the `onCreate` method, of all activities,
    we can do that inside the `onCreate` method of `BaseActivity`, and forget the
    rest.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get started with the `todolist`. This package contains all the sources
    required to display the list of todos. If you look at the previous screenshot
    carefully, you should notice that the package contains two classes—`TodoListActivity`
    and `ToDoAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start with the design of `TodoListActivity`; when completed, this
    `Activity` should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ae96f7fb-8770-4d9a-b0c0-0af6aac2131e.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As the screenshot depicts, we will need a `FloatingActionButton` and a `RecyclerView`
    for this `Activity`, so here is the XML layout for this example—`activity_todo_list.xml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Take a look at the preceding layout. In the declaration of `RecyclerView`, we
    set `layoutManager` to `LinearLayoutManager` and orientation to vertical-all from
    the layout itself, so we would not need to worry about setting it inside the code.
  prefs: []
  type: TYPE_NORMAL
- en: We used a `FloatingActionButton` to add new todos. We also used `AppBarLayout`
    as an action bar.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to move ahead and take a look inside the `onCreateBaseActivity`
    method of the `TodoListActivity`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding program, we created an instance of `ToDoAdapter` to set it
    as the adapter of `rvToDoList`, the `RecyclerView` where we will display the list
    of todos. While creating the instance of `ToDoAdapter`, we passed a `lambda`;
    this `lambda` should be called when an item from the `rvToDoList` is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also called a `fetchTodoList()`function at the end of the `onCreateBaseActivity`
    method. As the name indicates, it is responsible to fetch the todo list from the
    REST API. We will see the definition and go into the details of this method later,
    but, for now, let''s take a look at `Adapter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Study the preceding code carefully. It's the complete `ToDoAdapter` class. We
    took an instance of `context` as a comment `(1)` constructor parameter. We used
    that `context` to get an instance of `Inflater`, which in turn was used to inflate
    the layouts inside the `onCreateViewHolder` method. We created a blank `ArrayList`
    of `ToDoModel`. We used that list to get item counts of the adapter `getItemCount()`
    function, and inside the `onBindViewHolder` function, to pass it to the `ViewHolder`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: We also took a lambda as a `val` parameter inside the constructor of `ToDoAdapter`—`onItemClick`
    (comment `(2)`). That lambda should receive an instance of `ToDoModel` as a parameter
    and should return unit.
  prefs: []
  type: TYPE_NORMAL
- en: We used that lambda at `bindView` of `ToDoViewHolder`, inside `onClick` (comment
    `(7)`) of `itemView` (the view for that item in the list). So, whenever we click
    on an item, the `onItemClick` lambda will be called, which is passed from the
    `TodoListActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, focus on comment `(5)`—`setDataset()` method. This method is used to assign
    a new list to the adapter. It will clear the `ArrayList`—`TodoList` and add all
    items from the passed list to it. This method, `setDataset`, should be called
    by the `fetchTodoList()` method in `TodoListActivity`. That `fetchTodoList()`
    method is responsible for fetching the list from the REST API, and it will pass
    that list to the adapter.
  prefs: []
  type: TYPE_NORMAL
- en: We will look inside the `fetchTodoList()` method later, but let's concentrate
    on the REST API and Retrofit 2 for API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Retrofit 2 for API calls
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrofit by Square is one of the most famous and widely used REST clients for
    Android. It internally uses OkHTTP for HTTP and network calls. The word REST client
    makes it different from other networking libraries in Android. While most of the
    networking libraries (Volley, OkHTTP, and others) focus on synchronous/asynchronous
    requests, prioritization, ordered requests, concurrent/parallel requests, caching,
    and more. Retrofit gives more attention to making network calls and parsing data
    more like method calls. It simply turns your HTTP API into a Java interface. And
    it doesn't even try to solve network problems by itself, but delegates this to
    OkHTTP internally.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how does it transform an HTTP API into a Java interfaces? Retrofit simply
    uses a converter to serialize/deserialize **POJO** (**plain old Java object**)
    classes into/from JSON or XML. Now, what is a converter? Converters are those
    helper classes that parse JSON/XML for you. A converter generally uses the `Serializable`
    interface internally to convert to/from JSON/XML and POJO classes (data classes
    in Kotlin). It being pluggable gives you many choices of converters, such as the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Gson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jackson
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Guava
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moshi
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Java 8 converter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Protobuf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SimpleXML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use Gson for our book. To work with Retrofit, you''ll need the following
    three classes:'
  prefs: []
  type: TYPE_NORMAL
- en: A `Model` class (POJO or data class)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class to provide you with the Retrofit client instance with the help of `Retrofit.Builder()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `Interface` that defines possible HTTP operations, including the request
    type (GET or POST), parameters/request body/query strings, and finally the response
    type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, let's get started with the `Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before creating the class, we need to know the structure of the JSON response
    first. We all saw JSON responses in the previous chapter, but, as a quick recap,
    here is the JSON response for the `GET_TODO_LIST` API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `error_code` denotes whether there are any errors. If `error_code` is a
    non-zero value, then there must be an error. If it's zero, then there is no error,
    and you can proceed with parsing the data.
  prefs: []
  type: TYPE_NORMAL
- en: The `error_message` will contain information for you if there's an error. If
    the `error_code` is zero, the `error_message` will be blank.
  prefs: []
  type: TYPE_NORMAL
- en: The `data` key will hold a JSON array for the list of todos.
  prefs: []
  type: TYPE_NORMAL
- en: One thing to note here is that `error_code` and `error_message` will be consistent
    for all APIs in our project, so it will be better if we create a base class for
    all the APIs, and then we extend that class for each API when required.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is our `BaseAPIResponse` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We have two `val` properties in this class—`errorCode` and `errorMessage`; note
    the annotations `@SerializedName`. This annotation is used by Gson to declare
    the serialized name for a property; the serialized name should be the same as
    the JSON response. You can easily avoid this annotation if you have the same variable
    name as the JSON response. If the variable name is different, the serialized name
    is used to match the JSON response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now move ahead with `GetToDoListAPIResponse`; the following is the class
    definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we skipped the `@Serialized` annotation for `data`, as we are using the
    same name as the JSON response. The remaining two properties are declared by the
    `BaseAPIResponse` class.
  prefs: []
  type: TYPE_NORMAL
- en: For data, we are using an `ArrayList` of `ToDoModel`; `Gson` will take care
    of the rest to convert a JSON array to an `ArrayList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now take a look at the `ToDoModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `builder` class for Retrofit is simple, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `getClient()` function is responsible to create and provide you with a Retrofit
    client. The `getAPIService()` function helps you with pairing the Retrofit client
    with your defined HTTP operations and create an instance of the interface.
  prefs: []
  type: TYPE_NORMAL
- en: We used `OkHttpClient` and `Retrofit.Builder()` to create the `Retrofit` instance.
    If you're not familiar with them, you may visit [http://www.vogella.com/tutorials/Retrofit/article.html](http://www.vogella.com/tutorials/Retrofit/article.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create the interface for the HTTP operations—`APIService`—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have created API interfaces for all our APIs. Note the return types of the
    functions. They return a `Call` instance that encapsulates the actual expected
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what is `Call` instance? And what is the purpose of using it?
  prefs: []
  type: TYPE_NORMAL
- en: The `Call` instance is an invocation of a Retrofit method that sends a request
    to a webserver and returns a response. Each call yields its own HTTP request and
    response pair. What to do with the `Call<T>` instance? We have to `enqueue` it
    with a `Callback<T>` instance.
  prefs: []
  type: TYPE_NORMAL
- en: So, the same pull mechanism, same callback hell. However, we should be reactive,
    shouldn't we? Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: RxKotlin with Retrofit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Android, we can use RxAndroid in addition to RxKotlin for added Android flavors
    and benefits, and Retrofit supports them as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s start by modifying our `build.gradle` in favor of ReactiveX. Add
    the following dependencies to the app level `build.gradle`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first one will provide Retrofit 2 Adapters for RxJava 2, while the following
    two add RxAndroid and RxKotlin to the project.
  prefs: []
  type: TYPE_NORMAL
- en: Note that RxKotlin is a wrapper on top of RxJava, so adapters for RxJava 2 will
    work perfectly with RxKotlin 2.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have added the dependencies, let's move on by modifying our code
    to work with `Observable`/`Flowable` instead of `Call`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the modified `APIClient.kt` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This time, we added an OkHttp Logging interceptor (`HttpLoggingInterceptor`)
    along with an RxJava adapter. This OkHttp Logging interceptor will help us log
    requests and responses. Coming back to the RxJava adapters, look at the highlighted
    code—we added `RxJava2CallAdapterFactory` as the `CallAdapterFactory` of the Retrofit
    client.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need to modify the `APIService.kt` file as well, to make the functions
    return `Observable` instead of `Call`, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: All the APIs now return `Observable` instead of `Call`. Finally, we are all
    set to look inside the `fetchTodoList()` function from `TodoListActivity`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The function does a simple task; it subscribes to the API (`Observable` from
    the API) and sets the data to the adapter when it arrives. You should consider
    adding logic to check the error code before setting the data here, but for now
    it works quite well. The screenshot of this activity is already shown at the beginning
    of this chapter, so we will omit it here.
  prefs: []
  type: TYPE_NORMAL
- en: Making Android events reactive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have made our API calls reactive, but what about our events? Remember the
    `ToDoAdapter`; we took a lambda, used it inside `ToDoViewHolder`, and created
    and passed the lambda at `TodoListActivity`. Quite messy. This should be reactive
    as well, shouldn't it? So, let's make the events reactive as well.
  prefs: []
  type: TYPE_NORMAL
- en: '`Subject` plays an awesome role in making events reactive. As `Subject` is
    a great combination of `Observable` and `Observer`, we can use them as `Observer`
    inside `Adapter` and as `Observable` inside `Activity`, thus making passing events
    easy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s modify the `ToDoAdapter` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The adapter looks cleaner now. We've got a `Subject` instance in the constructor,
    and when the `itemView` is clicked, we call the `onNext` event of the `Subject`
    and pass both the `itemView` and `ToDoModel` instance with help of `Pair`.
  prefs: []
  type: TYPE_NORMAL
- en: However, it still looks like something is missing. The `onClick` method is still
    a callback; can't we make it reactive as well? Let's do that.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing RxBinding in Android
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To aid us Android developers, Jake Wharton created the RxBinding library, which
    helps you get Android events in a reactive way. You can find them at [https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding).
    Let's get started by adding it to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following dependency to the app level `build.gradle` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Then we can replace `onClick` inside `ToDoViewHolder` with the following line
    of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s that easy. However, you''re probably thinking, what''s the benefit of
    making them reactive? The implementation here was simple enough, but think of
    a situation where you''ve tons of logic. You can easily divide the logic into
    operators, especially `map` and `filter` could be of great help to you. Not only
    that, but RxBindings provides you with consistency. For example, when we need
    to observe text changes on an `EditText`, we generally end up writing lines of
    code in a `TextWatcher` instance, but if you use RxBindings, it will let you do
    that as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Yes, it's really that simple and that easy. RxBinding provides you with a lot
    more benefits as well. You can take a look at [https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals](https://speakerdeck.com/lmller/kotlin-plus-rxbinding-equals)
    and [http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html](http://adavis.info/2017/07/using-rxbinding-with-kotlin-and-rxjava2.html).
  prefs: []
  type: TYPE_NORMAL
- en: So now, thanks to Jake Wharton, we can make our views and events reactive as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: Kotlin extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the end of this chapter, I would like to introduce you to the Kotlin extensions.
    No, not exactly the Kotlin extensions functions, although they are very much related
    to the Kotlin extension functions. Kotlin extensions is a curated list of the
    most commonly used extension functions in Android.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if you want an extension function to create a bitmap from a `View`/`ViewGroup`
    instance (especially useful while adding Markers in MapFragment), you can copy
    and paste the following extension function from there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, a more common case, when you need to hide your keyboard, the following
    extension function will help you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This online listing has a lot more extension functions for you, which are maintained
    by Ravindra Kumar (Twitter, GitHub—`@ravidsrk`). So, the next time you need an
    extension function, take a look at [http://kotlinextensions.com/](http://kotlinextensions.com/) before
    writing your own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are done with the final chapter of the book. In this chapter, we learned
    how to configure Retrofit for RxKotlin and RxAndroid. We learned how to make our
    Android views and events as well as our custom views reactive.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to use RxJava2Adapter for Retrofit and how to use `Subject` for
    event passing. We also learned how to use RxBindings.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, we tried to go to the depth of reactive programming and
    cover every possible concept, and we tried to make all our code reactive.
  prefs: []
  type: TYPE_NORMAL
- en: If you find any questions, or if you get any concerns regarding this book, feel
    free to drop a email at [rivu.chakraborty6174@gmail.com](mailto:rivu.chakraborty6174@gmail.com)
    and mention `Book Query - Reactive Programming in Kotlin` in the subject line
    of the email. You can also check out Rivu Chakraborty's website ([http://www.rivuchk.com](http://www.rivuchk.com))
    as he regularly posts there about Kotlin, Google Developer Group Kolkata, and
    Kotlin Kolkata User Group Meetups. He also writes tutorials and blogs there as
    well as writes introductions to Android Plugins developed by him. Also, when he
    writes blogs and articles elsewhere, he posts URLs to them on his site.
  prefs: []
  type: TYPE_NORMAL
- en: Thank you for reading this book. Happy reactive programming in Kotlin.
  prefs: []
  type: TYPE_NORMAL
