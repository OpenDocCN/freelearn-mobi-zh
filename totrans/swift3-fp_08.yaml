- en: Chapter 8. Functional Data Structures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are familiar with imperative data structures. In fact, there are lots of
    references for imperative data structures in different programming languages.
    In contrast, there aren''t many references for declarative data structures or
    functional data structures. This is because functional programming languages are
    not as mainstream as imperative programming languages. Additionally, designing
    and implementing functional data structures is more difficult in comparison to
    imperative counterparts because of the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Mutability is not recommended in functional programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional data structures are expected to be more flexible than their imperative
    counterparts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative data structures rely heavily on mutability and assignments and making
    them immutable needs extra development effort. Whenever we change an imperative
    data structure, we basically override the previous version; however, this is not
    the case with declarative programming as we expect that both the previous and
    new versions of the functional data structure will continue to survive and be
    utilized.
  prefs: []
  type: TYPE_NORMAL
- en: 'We might think why bother with functional data structures as they are more
    difficult to design and implement? There are two answers to this question: first
    of all, functional data structures are efficient and immutable data structures.
    Secondly, they support functional programming paradigms. We have already seen
    an example of these when we were introduced to algebraic data types in [Chapter
    4](ch04.html "Chapter 4. Enumerations and Pattern Matching"), *Enumerations and
    Pattern Matching*.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will further explore functional data structures with coding
    examples. The content of this chapter is heavily inspired by *Purely Functional
    Data Structures*, *Chris Okasaki*, *Cambridge University Press*, which is a great
    reference on this topic to date and has various examples with ML and Haskell programming
    languages. Reading Okasaki's book is highly recommended for functional programmers.
    In this chapter, we will cover the topic and explore some of the examples in Okasaki's
    book in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: 'Particularly, we will utilize structs and enumerations to implement the following
    functional data structures:'
  prefs: []
  type: TYPE_NORMAL
- en: Semigroup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monoid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binary Search Tree
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linked list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding examples for these data structures serve as a presentation of functional
    programming paradigms and techniques and they are not going to be complete.
  prefs: []
  type: TYPE_NORMAL
- en: We know that immutability is the most important property of functional data
    structures. To design and implement immutable data structures, we will not change
    a functional data structure and instead create a new version that lives along
    with the previous version. In fact, we will copy the parts that need to be changed
    without touching the original version of the data structure. So we will use value
    types such as structs and enumerations to be able to achieve this. In addition,
    as we will not change the original data structure directly, we will be able to
    share the original data structure parts with the new structure without being worried
    about how changing one version would affect the other version. Let's examine how
    we will achieve this by implementing different functional data structures.
  prefs: []
  type: TYPE_NORMAL
- en: Semigroup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, a Semigroup is an algebraic structure that has a set and
    a binary operation that takes two elements in the set and returns a Semigroup
    that has an associative operation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to have a set and a specific binary operation, or we can
    make this behavior generic and define a protocol as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Any type that conforms to this protocol requires to implement the `operation`
    method. Here, `self` presents the type that is conforming to this protocol. For
    instance, we can extend `Int` to conform to the Semigroup protocol and provide
    a summation on itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test this as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This test does not ensure the associativity of the binary operations. Let''s
    try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code ensures that our binary operator is associative; therefore,
    our Semigroup is verified. It does not look very nice though; let''s implement
    an operator for our operation to make it look better and more math friendly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s rewrite our test with the `<>` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So far, we extended only `Int` but we can extend any type. Let''s extend arrays
    as an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `operation` method is very similar to what we have for `Int`. The only
    difference is in the type, which is an array in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore we can extend String as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have established a general principle of composition (two objects combining
    into one) using a protocol. This pattern can be used for different purposes. For
    instance, we can implement a shorter version of reduce for arrays over Semigroups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sconcat` function name stands for semigroup concat; we can test it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Our last `sconcat` example works like `flatMap` and flattens elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, our Semigroup becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: A Semigroup is a great example of a simple data structure but it is not as popular
    as a Monoid, which we will examine in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Monoid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In computer science, a Monoid is a set, a binary operation, and an element
    of the set with the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Associativity of binary operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The element is the identity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Simply put, a structure is Monoid if the structure is a Semigroup with an element
    that is the identity. So let''s define a new protocol that extends our Semigroup
    protocol:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test our structure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'As Monoid has an element, we can use this as an initial and simplify our `reduce`
    method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Trees
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In computer science, a Tree is a very popular **abstract data type** (**ADT**)
    or a data structure implementing this ADT that simulates a hierarchical tree structure
    with a root value and subtrees of the children with a parent node, represented
    as a set of linked nodes.
  prefs: []
  type: TYPE_NORMAL
- en: A tree data structure can be defined recursively (locally) as a collection of
    nodes (starting at a root node), where each node is a data structure consisting
    of a value, together with a list of references to nodes (the *children*) with
    the constraints that no reference is duplicated and none point to the root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, a tree can be defined abstractly as a whole (globally) as an
    ordered tree, with a value assigned to each node. Both these perspectives are
    useful: while a tree can be analyzed mathematically as a whole, when actually
    represented as a data structure, it is usually represented and worked separately
    by a node (rather than as a list of nodes and an adjacency list of edges between
    nodes, as one may represent a digraph, for instance). For example, looking at
    a tree as a whole, one can talk about the *parent* node of a given node, but in
    general as a data structure, a given node only contains the list of its children
    but not a reference to its parent (if any).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a previous chapter, we implemented a generic binary tree in Swift. The following
    is an improved version of that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We define the `Tree` as an `enum` with three different cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Leaf**: If we are at the end of a branch of the `Tree`; simply put, if a
    node does not have any children, then it is a `Leaf`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Node**: A structure that has a left-hand side and right-hand side to it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following figure presents an example `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Trees](img/image_08_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A `Tree` is generic and the elements in it are comparable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this `Tree` is as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `functionalTree` is immutable or, in other words, it is persistent. It
    has a leaf as `lhs` and a node with two leaves as `rhs`. As this structure is
    immutable, we will not be worried whether it is going to change or not and we
    will be able to share this tree with other trees:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we used our first `Tree` called `functionalTree`
    as a part of `secondFT` and `thirdFT`.
  prefs: []
  type: TYPE_NORMAL
- en: Contains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This `Tree` is far from complete and needs lots of functionality. For instance,
    we may need to check whether the `Tree` contains a specific value. To be able
    to do this, we need to add the following method to our `Tree`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We can test contains method as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Binary Search Tree
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our assumption in our simple `Tree` was that only leaves contain a value. This
    is not always true. In fact, there are different types of trees with different
    utilities and a **Binary Search Tree** (**BST**) is one of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'In computer science, binary search trees, sometimes called ordered or sorted
    binary trees, are a particular type of container: data structures that store *items*
    (such as numbers, names, and so on) in memory. They allow fast lookup, the addition
    and removal of items, and implementation of either dynamic sets of items or lookup
    tables that allow finding an item by its key (for example, finding the phone number
    of a person by name).'
  prefs: []
  type: TYPE_NORMAL
- en: 'BSTs keep their keys in sorted order so that lookup and other operations can
    use the principle of binary search: when looking for a key in a tree (or a place
    to insert a new key), they traverse the tree from root to leaf, making comparisons
    to keys stored in the nodes of the tree and deciding, based on the comparison,
    whether to continue searching in the left or right subtrees. On an average, this
    means that each comparison allows the operations to skip about half of the tree
    so that each lookup, insertion, or deletion takes time proportional to the logarithm
    of the number of items stored in the tree. This is much better than the linear
    time required to find items by key in an (unsorted) array, but slower than the
    corresponding operations on hash tables.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s improve our simple tree and convert it to a BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BinarySearchTree` tree is very similar to the previous `Tree` and the
    only difference is that `node` contains the `element` and not the `leaf`. Using
    it is as simple as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, we create a BST as values stored in `lhs` are smaller than the root and
    values stored in `rhs` are larger than the root. In this example, `lhs` is a BST
    with `1` as value. Root has the value of `5` and `rhs` is a BST with `9` as value
    which is larger than root value.
  prefs: []
  type: TYPE_NORMAL
- en: Contains
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Additionally, our `contains` method requires to be modified as it will search
    only in leaves. Let''s improve this, assuming that our Tree is a BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This method searches for a specific `element` and returns `true` if it finds
    it in `node`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following presents an example usage of this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `isFound` variable is going to be `true` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make this BST a little more complete, let''s implement a property to check
    for its size:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This computed property is going to provide the size of the BST and we can use
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Elements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It would be great to be able to generate an array from BST elements. This can
    be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Empty
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can implement a helper method to generate empty BSTs as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is a computed property to check whether the BST is empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we created an empty BST and checked whether it is empty
    using the `isEmpty` property. Obviously, the result is going to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: This BST implementation is far from complete and requires to be improved by
    implementing methods to check whether it is a BST.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, our BST becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Even though it does not represent a full implementation of a BST, we were able
    to develop it in a functional style, and we will be able to share and reuse the
    tree among other trees because they are immutable.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are multiple types of lists including linked lists, doubly linked lists,
    multiple linked lists, circular linked lists, queues, and stacks.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will present a simple linked list that is one of the simplest
    and most popular data structures in imperative programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A linked list is a linear collection of data elements called nodes pointing
    to the next node using pointers. Linked lists contain their data in a linear and
    sequential manner. Simply, each node is composed of data and a reference to the
    next node in the sequence:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lists](img/image_08_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start with a simple version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Our approach is similar to our BST implementation approach. The difference resides
    in the `node` case that has a `data` element and a pointer to its next element,
    which is also a `LinkedList`.
  prefs: []
  type: TYPE_NORMAL
- en: Empty LinkedList
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our `LinkedList` needs a method to create it as empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This is as simple as returning `.end`.
  prefs: []
  type: TYPE_NORMAL
- en: Cons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to have a way to append items to `LinkedList`, so we implement it as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'This simple method appends the data to the front of `LinkedList`; in other
    words, it is like a push operation to a stack. We can test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of this operation should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Functional programming languages such as Haskell and Scala have operators for
    cons. It is `:` in Haskell and `::` in Scala. As we cannot use `:` in Swift to
    define an infix operator, we are going to use `<|` instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We will be able to test it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This statement produces the exact same result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, this `LinkedList` is far from complete but we already achieved great
    reusability as it is functional. We can use/share our `functionalLinkedList` with
    other linked lists without worrying about changes and inconsistencies. Let''s
    examine the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding examples, we use `functionalLinkedList` and add a new item
    (`4`) to it to obtain `secondLL` and `5` to obtain `thirdLL`. Also, we use `secondLL`
    to create `fourthLL`.
  prefs: []
  type: TYPE_NORMAL
- en: Contains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make this `LinkedList` a little more interesting, we will develop a contains
    method similar to the one that we developed for the BST:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This method recursively checks for a specific element in `LinkedList` and returns
    `true` if it finds the element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The result of this expression is going to be `true`.
  prefs: []
  type: TYPE_NORMAL
- en: Size
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can implement a computed `size` property to calculate the size of linked
    list as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This method recursively goes through `LinkedList` and counts the number of
    nodes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The result is going to be `3` in this example.
  prefs: []
  type: TYPE_NORMAL
- en: Elements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can implement a computed property to provide an array of elements as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we recur through LinkedList and return an array of data. We will be able
    to use this property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: This statement prints `[3, 2, 1]`.
  prefs: []
  type: TYPE_NORMAL
- en: isEmpty
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another common operation that `LinkedList` requires is a way to check whether
    it is empty. We can easily implement it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this computed property, we will create an empty `LinkedList` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the first `print` statement results in `true` and
    the second results in `false`.
  prefs: []
  type: TYPE_NORMAL
- en: map, filter, and reduce
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have wondered if we are going to be able to apply higher-order functions
    such as map, filter, and reduce to our linked list. We have implemented our linked
    list with a recursive `enum` and the recursive pattern is well-suited to higher-order
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with `map`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'Using this method, we will be able to transform elements in our linked list.
    Nothing fancy here; we use the same `cons` operator that we defined before. The
    following statement will test our method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The result should be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: So we can easily multiply elements in our linked list by `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the `filter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we check whether the `predicate` yields a result first. If it does, then
    we apply our `cons` operator to the data and recursively `filter` the next element.
    Otherwise, we just recursively apply `filter` to the next element. We can test
    this method as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we `filter` our linked list to the ones that
    are even. This statement results in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is great to be able to `map` and `filter` our linked list, but we need to
    have a `reduce` method as well. Let''s implement this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code example, we go through the linked list''s elements recursively
    and `reduce` the values to a single value. The following code presents a usage
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The result of this expression is going to be `6`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end, our `LinkedList` becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Stacks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A stack is a collection that is based on the **Last In First Out** (**LIFO**)
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following figure presents a sample stack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Stacks](img/image_08_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To implement a simple functional stack, we need to provide `push`, `pop`, `isEmpty`,
    and `size` operations. We implemented a functional `LinkedList` in the previous
    section, which can be used to implement a simple functional stack with the following
    operations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**push**: The `cons` operation in `LinkedList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**pop**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**isEmpty**: The `isEmpty` operation in `LinkedList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**size**: The `size` method in `LinkedList`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As seen here, the only operation that is missing is `pop`. Let''s implement
    that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this, we can execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'The result of the first `print` will be `3` and the result of the second `print`
    will be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: This is just an example implementation, and we utilize `Optional` Tuple as a
    return to obtain the popped element as well as the resulting new linked list.
  prefs: []
  type: TYPE_NORMAL
- en: One more thing that we need to do is to change the name of our `enum` to something
    more generic, such as list.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our stack becomes very similar to the list.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we implemented a linked list and a stack as a list. One of the key concepts
    in functional programming is the concept of lazy evaluation. We can make our list
    lazy so that the elements will be evaluated once we access them. We need to change
    `node` in such a way that it will return a function containing List as next, instead
    of the list itself. The function will be evaluated when it is called; therefore,
    our list will be lazy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start with modifying our `node` case. In our `LinkedList` example, `next`
    was of the `LinkedList<Element>` type. To make our list lazy, we will modify `next`
    to be a function that returns our List:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As we can see in the preceding code, our `Node` case is not defined as indirect
    because `next` is not of the `LazyList` type and is a reference to a function
    that returns `LazyList`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to accommodate this change into our properties and methods. It is going
    to be as easy as changing any `next` to `next()`. For example, our `size` property
    becomes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'If we followed the code and changed it properly, we would see that our `map`
    and `filter` do not compile. We need to change the operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Here, we change our `rhs` to a function type that matches our LazyList's `next`.
    This change did not fix our `map` and `filter` problems. It seems that the right-hand
    side of the `infix` operator is evaluated before being passed to it and we do
    not want this.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is because we do not pass a closure to our operator in the `map` and `filter`
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'In our `map` method example, `next().map(transform)` is not a closure. If we
    wrap it in `{ }`, then it becomes a closure. We can modify our `infix` operator
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The `@autoclosure` attribute creates an automatic closure around the expression.
    So when we write an expression such as `next().map(transform)`, it is automatically
    wrapped in a closure to become `{ next().map(transform) }` before it is passed
    to our `infix` operator.
  prefs: []
  type: TYPE_NORMAL
- en: Starting in Swift 1.2, `autoclosure` defaults to `noescape`. This attribute
    ensures that parameters are not stored for later execution and will not outlive
    the lifetime of the call. The `noescape` implementation adds minor performance
    optimizations and bypasses the need to annotate properties and methods with `self`.
  prefs: []
  type: TYPE_NORMAL
- en: The `escaping` annotation in brackets is necessary in order to signify that
    the closure will last longer than the lifetime of the scope that it is declared
    in.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to change our `cons` method by wrapping `self` in `{ }` as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test our `LazyList` and see if it works properly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Our lazy list now becomes as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the concept of functional data structures and explored
    examples of data structures implemented in a functional way, such as Semigroup,
    Monoid, BST, linked list, stack, and lazy list.
  prefs: []
  type: TYPE_NORMAL
- en: Even though none of the data structures are complete, they serve as structures
    that present functional programming paradigms and techniques. It would also be
    beneficial to examine the performance of any of these data structures.
  prefs: []
  type: TYPE_NORMAL
- en: In the following chapter, we will cover the importance of immutability by examining
    its benefits. We will also examine an example of a mutable versus an immutable
    implementation as well as the means to get and set immutable objects in a functional
    way, such as copy constructors and lenses.
  prefs: []
  type: TYPE_NORMAL
