- en: Chapter 2. Learning about Variables, Constants, Strings, and Operators
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：学习变量、常量、字符串和操作符
- en: The first program I ever wrote was written in the BASIC programming language,
    and was the typical Hello World application. This application was pretty exciting
    at first, but the excitement of printing static text wore off pretty quickly.
    For my second application, I used BASIC's input command to prompt the user for
    a name and then printed out a custom hello message to the user with their name
    in it. At the age of 12, it was pretty cool to display Hello Han Solo. This application
    led me to create numerous Mad Lib style applications that prompted the user for
    various words and then put those words into a story that was displayed after the
    user had entered all the required words. These applications introduced me to,
    and taught me, the importance of variables. Every useful application I created
    since then has used variables.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我写的第一个程序是用 BASIC 编程语言编写的，是一个典型的 Hello World 应用程序。这个应用程序一开始非常令人兴奋，但打印静态文本的兴奋感很快就消失了。对于我的第二个应用程序，我使用了
    BASIC 的输入命令来提示用户输入姓名，然后打印出包含用户姓名的定制问候消息。12岁时，显示“Hello Han Solo”非常酷。这个应用程序引导我创建了无数类似
    Mad Lib 的应用程序，这些应用程序会提示用户输入各种单词，然后在用户输入所有必需的单词后，将这些单词放入显示的故事中。这些应用程序让我了解了变量的重要性。从那时起，我创建的每个有用的应用程序都使用了变量。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What variables and constants are
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量和常量的定义
- en: The difference between explicit and inferred typing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式类型和隐式类型之间的区别
- en: Explaining numeric, string, and Boolean types
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释数字、字符串和布尔类型
- en: Defining what optional types are
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义可选类型
- en: Explaining how enumerations work in Swift
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 Swift 中枚举的工作原理
- en: Explaining how Swift's operators work
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释 Swift 操作符的工作原理
- en: Constants and variables
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常量和变量
- en: Constants and variables associate an identifier (such as `myName` or `currentTemperature`)
    with a value of a particular type (such as `String` or `Int`), where the identifier
    can be used to retrieve the value. The difference between a constant and a variable
    is that a variable can be updated or changed, while a constant cannot be changed
    once a value is assigned to it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量将一个标识符（如 `myName` 或 `currentTemperature`）与特定类型的值（如 `String` 或 `Int`）关联起来，其中标识符可以用来检索值。常量和变量之间的区别在于，变量可以被更新或更改，而一旦为常量分配了值，它就不能被更改。
- en: Constants are good for defining the values that you know will never change,
    such as the freezing temperature of water or the speed of light. Constants are
    also good for defining a value that we use many times throughout our application,
    such as a standard font size or maximum characters in a buffer. There will be
    numerous examples of constants throughout this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 常量适用于定义那些你知道永远不会改变的值，例如水的冰点或光速。常量也适用于定义我们在整个应用程序中多次使用的值，例如标准字体大小或缓冲区中的最大字符数。本书中将有多个常量示例。
- en: Variables tend to be more common in software development than constants, however.
    This is mainly because developers tend to prefer variables to constants. In Swift
    2 and Xcode 7, we are warned if we declare a variable that is never changed. This
    should increase the use of constants. We can make useful applications without
    using constants (although it is a good practice to use them); however, it is almost
    impossible to create a useful application without variables.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 变量在软件开发中比常量更常见。这主要是因为开发者倾向于更喜欢变量而不是常量。在 Swift 2 和 Xcode 7 中，如果我们声明了一个永远不会改变的变量，我们会收到警告。这应该会增加常量的使用。我们可以不使用常量来创建有用的应用程序（尽管使用它们是一种好习惯）；然而，没有变量几乎不可能创建一个有用的应用程序。
- en: Note
  id: totrans-13
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of constants is encouraged in Swift. If we do not expect or want the
    value to change, we should declare it as a constant. This adds a very important
    safety constraint to our code that ensures that the value never changes.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中鼓励使用常量。如果我们不期望或不想值发生变化，我们应该将其声明为常量。这为我们的代码添加了一个非常重要的安全约束，确保值永远不会改变。
- en: 'You can use almost any character in the identifier of a variable or constant
    (even Unicode characters); however, there are a few rules that you must follow:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎可以在变量或常量的标识符中使用任何字符（甚至 Unicode 字符）；然而，你必须遵循一些规则：
- en: An identifier must not contain any whitespace
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能包含任何空白字符
- en: An identifier must not contain any mathematical symbols
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能包含任何数学符号
- en: An identifier must not contain any arrows
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能包含任何箭头
- en: An identifier must not contain private use or invalid Unicode characters
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能包含私有用途或无效的 Unicode 字符
- en: An identifier must not contain line- or box-drawing characters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能包含行或框绘制字符
- en: An identifier must not start with a number, but they can contain numbers
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标识符不能以数字开头，但可以包含数字
- en: If you use a Swift keyword as an identifier, surround it with back ticks
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你将 Swift 关键字用作标识符，请用反引号包围它
- en: Note
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keywords are words that are used by the Swift programming language. Some examples
    of keywords that you will see in this chapter are `var` and `let`. You should
    avoid using Swift keywords as identifiers to avoid confusion when reading your
    code.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 关键字是 Swift 编程语言使用的单词。在本章中，你将看到的几个关键字示例是 `var` 和 `let`。你应该避免使用 Swift 关键字作为标识符，以避免阅读代码时产生混淆。
- en: Defining constants and variables
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义常量和变量
- en: 'Constants and variables must be defined prior to using them. To define a constant,
    you use the keyword, `let`, and to define a variable, you use the keyword, `var`.
    The following are some examples of constants and variables:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 常量和变量在使用之前必须定义。要定义一个常量，你使用关键字 `let`，要定义一个变量，你使用关键字 `var`。以下是一些常量和变量的示例：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We can declare multiple constants or variables in a single line by separating
    them with a comma. For example, we could shrink the preceding four lines of code
    down to two lines, as shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在一行中声明多个常量或变量，通过逗号分隔它们。例如，我们可以将前面的四行代码缩减为两行，如下所示：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'We can change the value of a variable to another value of a compatible type;
    however, as we noted earlier, we cannot change the value of a constant. Let''s
    look at the following Playground. Can you tell what is wrong with the code from
    the error message that is shown in the following screenshot:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将变量的值更改为兼容类型的另一个值；然而，正如我们之前提到的，我们不能更改常量的值。让我们看看以下 Playgrounds。你能从以下截图显示的错误消息中告诉代码有什么问题吗？
- en: '![Defining constants and variables](img/B05115_02_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![定义常量和变量](img/B05115_02_01.jpg)'
- en: Did you figure out what was wrong with the code? Any physicist can tell you
    that we cannot change the speed of light, and in our code, the `speedOfLightKmSec`
    variable is a constant, so we cannot change it either. Therefore, when we try
    to change the `speedOfLightKmSec` constant, an error is reported. We are able
    to change the value of the `highTemperture` variable without an error because
    it is a variable. We mentioned the difference between variables and constants
    a couple of times because it is a very important concept to grasp, especially
    when we define mutable and immutable collection types later in [Chapter 3](ch03.html
    "Chapter 3. Using Collections and Cocoa Data Types"), *Using Collections and Cocoa
    Data Types*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你弄清楚代码哪里出问题了吗？任何物理学家都会告诉你，我们无法改变光速，在我们的代码中，`speedOfLightKmSec` 变量是一个常量，所以我们也不能改变它。因此，当我们尝试改变
    `speedOfLightKmSec` 常量时，会报告一个错误。我们能够不报错地改变 `highTemperture` 变量的值，因为它是一个变量。我们提到变量和常量的区别好几次，因为这是一个非常重要的概念，尤其是在我们定义可变和不可变集合类型时，这在[第3章](ch03.html
    "第3章。使用集合和Cocoa数据类型")，*使用集合和Cocoa数据类型*中尤为重要。
- en: Type safety
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型安全
- en: 'Swift is a type-safe language. In a type-safe language, we are required to
    be clear on the types of values we store in a variable. We will get an error if
    we attempt to assign a value to a variable that is of a wrong type. The following
    Playground shows what happens if we attempt to put a string value into a variable
    that expects integer values; note that we will go over the most popular types
    a little later in the chapter:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种类型安全的语言。在类型安全的语言中，我们必须清楚地了解存储在变量中的值的类型。如果我们尝试将错误类型的值分配给变量，我们将得到一个错误。以下
    Playgrounds 展示了如果我们尝试将字符串值放入期望整数值的变量中会发生什么；注意，我们将在本章稍后讨论最流行的类型：
- en: '![Type safety](img/B05115_02_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![类型安全](img/B05115_02_02.jpg)'
- en: Swift performs a type check when it compiles code; therefore, it will flag any
    mismatched types with an error. The error message in this Playground explains
    pretty clearly that we are trying to insert a string literal into an integer variable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 在编译代码时执行类型检查；因此，它将用错误标记任何不匹配的类型。这个 Playgrounds 中的错误消息清楚地解释了我们在尝试将字符串字面量插入到整数变量中。
- en: So the question is, how does Swift know that `integerVar` is of the Int type?
    Swift uses type inference to figure out the appropriate type. Let's take a look
    at what type inference is.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 所以问题是，Swift 如何知道 `integerVar` 是 Int 类型？Swift 使用类型推断来确定合适的类型。让我们看看什么是类型推断。
- en: Type inference
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型推断
- en: 'Type inference allows us to omit the variable type when we define it. The compiler
    will infer the type, based on the initial value. For example, in Objective-C,
    we would define an integer like this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断允许我们在定义变量时省略变量类型。编译器将根据初始值推断类型。例如，在 Objective-C 中，我们会这样定义一个整数：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This tells the compiler that the `myInt` variable is of the Int type, and the
    initial value is the number `1`. In Swift, we would define the same integer like
    this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉编译器 `myInt` 变量是 Int 类型，初始值是数字 `1`。在 Swift 中，我们会这样定义相同的整数：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Swift infers that the variable type is an integer because the initial value
    is an integer. Let''s take a look at a couple of more examples:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 推断变量类型是整数，因为初始值是整数。让我们看看几个更具体的例子：
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the compiler will correctly infer that variable `x`
    is Double, variable `y` is String, and variable `z` is Boolean, based on the initial
    values.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，编译器将正确推断变量 `x` 是 Double，变量 `y` 是 String，变量 `z` 是 Boolean，基于初始值。
- en: Explicit types
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显式类型
- en: 'Type inference is a very nice feature in Swift and is one that you will probably
    get used to very quickly; however, there are times when we would like to explicitly
    define a variable''s type. For example, in the preceding example, the variable,
    `x`, is inferred to be `Double`, but what if we wanted the variable type to be
    `Float`? We can explicitly define a variable type like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 类型推断是 Swift 中一个非常棒的功能，你可能会很快习惯它；然而，有时我们可能希望显式定义变量的类型。例如，在前面的例子中，变量 `x` 被推断为
    `Double`，但如果我们想将变量类型设置为 `Float` 呢？我们可以像这样显式定义变量类型：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Notice the`: Float`(colon and the word `Float`) after the variable identifier;
    this tells the compiler to define the variable to be of the `Float` type and gives
    it an initial value of `3.14`. When we define a variable in this manner, we need
    to make sure that the initial value is of the same type we are defining the variable
    to be. If we try to give a variable an initial value, that is, a different type
    than we are defining it as, we will receive an error.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '注意变量标识符后面的 `: Float`（冒号和单词 `Float`）；这告诉编译器将变量定义为 `Float` 类型，并给它一个初始值 `3.14`。当我们以这种方式定义变量时，我们需要确保初始值与我们要定义的变量类型相同。如果我们尝试给变量一个初始值，即与我们定义的类型不同的类型，我们将收到一个错误。'
- en: 'We would also explicitly define the variable type if we were not setting an
    initial value. For example, the following line of code is invalid because the
    compiler does not know what type to set the variable, `x`, to:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们没有设置初始值，我们也会显式定义变量类型。例如，以下代码行是无效的，因为编译器不知道将变量 `x` 设置为哪种类型：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If we use this code in our application, we will receive a `Type annotation
    missing in pattern` error. If we are not setting an initial value for a variable,
    we are required to define the type like this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在应用程序中使用此代码，我们将收到一个 `Type annotation missing in pattern` 错误。如果我们没有为变量设置初始值，我们必须像这样定义类型：
- en: '[PRE7]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have seen how to explicitly define a variable type, let's take a
    look at some of the most commonly used types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何显式定义变量类型，让我们来看看一些最常用的类型。
- en: Numeric types
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: Swift contains many of the standard numeric types that are suitable for storing
    various integer and floating-point values.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 包含许多适合存储各种整数和浮点值的标准数值类型。
- en: Integers
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 整数
- en: 'An integer is a whole number. Integers can be either signed (positive, negative,
    or zero) or unsigned (positive or zero). Swift provides several integer types
    of different sizes. The following chart shows the value ranges for the different
    integer types:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 整数是一个整数。整数可以是带符号的（正数、负数或零）或无符号的（正数或零）。Swift 提供了多种不同大小的整数类型。以下图表显示了不同整数类型的值范围：
- en: '| Type | Minimum | Maximum |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| 类型 | 最小值 | 最大值 |'
- en: '| --- | --- | --- |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Int8 | -128 | 127 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| Int8 | -128 | 127 |'
- en: '| Int16 | -32,768 | 32,767 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| Int16 | -32,768 | 32,767 |'
- en: '| Int32 | -2,147,483,648 | 2,147,483,647 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| Int32 | -2,147,483,648 | 2,147,483,647 |'
- en: '| Int64 | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| Int64 | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
- en: '| Int | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| Int | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
- en: '|   |   |   |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|   |   |   |'
- en: '| UInt8 | 0 | 255 |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| UInt8 | 0 | 255 |'
- en: '| UInt16 | 0 | 65,535 |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| UInt16 | 0 | 65,535 |'
- en: '| UInt32 | 0 | 4,294,967,295 |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| UInt32 | 0 | 4,294,967,295 |'
- en: '| UInt64 | 0 | 18,446,744,073,709,551,615 |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| UInt64 | 0 | 18,446,744,073,709,551,615 |'
- en: '| UInt | 0 | 18,446,744,073,709,551,615 |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| UInt | 0 | 18,446,744,073,709,551,615 |'
- en: Tip
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Unless there is a specific reason to define the size of an integer, I would
    recommend using the standard `Int` or `UInt` type. This will save you from needing
    to convert between different types of integers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除非有特定的理由来定义整型的大小，否则我建议使用标准的 `Int` 或 `UInt` 类型。这将让您免于需要在不同的整型类型之间进行转换。
- en: 'In Swift, Int (as well as other numerical types) are actually named types,
    implemented in the Swift standard library using structures. This gives us a consistent
    mechanism for memory management for all the data types as well as properties that
    we can access. For the preceding chart, I retrieved the minimum and maximum values
    of each integer type using the `min` and `max` properties. Take a look at the
    following Playground to see how I retrieved the values:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，Int（以及其他数值类型）实际上是命名类型，使用 Swift 标准库中的结构体实现。这为我们提供了对所有数据类型以及我们可以访问的属性进行内存管理的一致机制。对于前面的图表，我使用
    `min` 和 `max` 属性检索了每种整型类型的最大和最小值。请查看以下 Playground，看看我是如何检索这些值的：
- en: '![Integers](img/B05115_02_03.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![整数](img/B05115_02_03.jpg)'
- en: 'Integers can also be represented as binary, octal, and hexadecimal numbers.
    We just need to add a prefix to the number to tell the compiler which base the
    number should be in. The following chart shows the prefix for each numerical base:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 整数也可以表示为二进制、八进制和十六进制数。我们只需在数字前添加一个前缀，告诉编译器数字应该使用哪种基数。以下图表显示了每种数值基数的前缀：
- en: '| Base | Prefix |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 基数 | 前缀 |'
- en: '| --- | --- |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Decimal | None |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 十进制 | 无 |'
- en: '| Binary | 0b |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 二进制 | 0b |'
- en: '| Octal | 0o |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 八进制 | 0o |'
- en: '| Hexadecimal | 0x |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 十六进制 | 0x |'
- en: 'The following Playground shows how the number, `95`, is represented in each
    of the numerical bases:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Playground 展示了数字 `95` 在每种数值基数中的表示方式：
- en: '![Integers](img/B05115_02_04.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![整数](img/B05115_02_04.jpg)'
- en: 'Swift also allows us to insert arbitrary underscores in our numeric literals.
    This can improve the readability of our code. As an example, if we were defining
    the speed of light, which is constant, we can define it like this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 还允许我们在数值字面量中插入任意下划线。这可以提高我们代码的可读性。例如，如果我们正在定义光速，这是一个常数，我们可以这样定义它：
- en: '[PRE8]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Swift will ignore these underscores; therefore, they do not affect the value
    of the numeric literals in any way.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 会忽略这些下划线；因此，它们不会以任何方式影响数值字面量的值。
- en: Floating-point
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 浮点数
- en: A floating-point number is a number with a decimal component. There are two
    standard floating-point types in Swift Float and Double. Float represents a 32-bit
    floating-point number, while Double represents a 64-bit floating-point number.
    Swift also supports an extended floating-point type, that is, **Float80**. The
    Float80 type is an 80-bit floating-point number.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点数是带有小数部分的数字。Swift 中有两种标准的浮点数类型：Float 和 Double。Float 表示 32 位浮点数，而 Double 表示
    64 位浮点数。Swift 还支持扩展的浮点数类型，即 **Float80**。Float80 类型是一个 80 位浮点数。
- en: 'It is recommended that we use the Double type over the Float type unless there
    is a specific reason to use the latter. The Double type has a precision of at
    least 15 decimal digits, while the Float type can be as little as six decimal
    digits. Lets look at an example of how this can effect our application without
    us knowing it. The following screenshot shows the results if we add two decimal
    numbers together and put the results in both a Float type and Double type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 建议我们使用 Double 类型而不是 Float 类型，除非有特定的理由使用后者。Double 类型至少有 15 位十进制数字的精度，而 Float
    类型的精度可能低至六位十进制数字。让我们看看一个例子，看看这如何在不为我们所知的情况下影响我们的应用程序。以下截图显示了如果我们将两个十进制数字相加并将结果放入
    Float 类型和 Double 类型中的结果：
- en: '![Floating-point](img/B05115_02_05.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![浮点数](img/B05115_02_05.jpg)'
- en: As we can see from the screenshots, the two decimal numbers that we are adding
    together contain nine digits post the decimal point; however, the results in the
    Float type only contains seven digits, while the results in the Double type contains
    the full nine digits.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如从截图所示，我们相加的两个十进制数字在十进制点后有九位数字；然而，Float 类型的结果只包含七位数字，而 Double 类型的结果包含完整的九位数字。
- en: The loss of precision can cause issues if we are working with currency or other
    numbers that need accurate calculations. The floating-point accuracy problem is
    not an issue confined to Swift; all the languages that implement the IEEE 754
    floating-point standard have similar issues. The best practice is to use Double
    for floating-point numbers unless there is a specific reason not to.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在处理货币或其他需要精确计算的数字时精度丢失，可能会引发问题。浮点精度问题并不仅限于Swift；所有实现IEEE 754浮点标准的语言都有类似的问题。最佳实践是，除非有特定原因不这样做，否则使用Double来表示浮点数。
- en: 'What if we have two variables, one is an Int and the other is a Double? Do
    you think we can add them together as the following code depicts:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有两个变量，一个是Int类型，另一个是Double类型？你认为我们能否像以下代码所示那样将它们相加：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we put the preceding code into a Playground, we would receive the following
    error: `binary operator ''+'' cannot be applied to operands of type ''Int'' and
    ''String`'''
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将前面的代码放入Playground中，我们会收到以下错误：`binary operator '+' cannot be applied to
    operands of type 'Int' and 'String'`
- en: 'This error lets us know that we are trying to add two different types of numbers,
    which is not allowed. To add an Int and a Double together, we need to convert
    the Int value into a Double value. The following code shows how to convert an
    Int value into a Double value so that we can add them together:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个错误告诉我们我们正在尝试将两种不同类型的数字相加，这是不允许的。要将Int和Double相加，我们需要将Int值转换为Double值。以下代码展示了如何将Int值转换为Double值以便我们可以将它们相加：
- en: '[PRE10]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Notice how we use the `Double()` function to convert the Int value to a Double
    value. All the numeric types in Swift have a conversion convenience initializer,
    similar to the `Double()` function shown in the preceding code sample. For example,
    the following code shows how you can convert an `Int` variable to `Float` and
    `UInt16` variables:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何使用`Double()`函数将Int值转换为Double值的。Swift中的所有数值类型都有一个类似于前面代码示例中的`Double()`函数的便利初始化器。例如，以下代码展示了如何将`Int`变量转换为`Float`和`UInt16`变量：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The Boolean type
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: Boolean values are often referred to as logical values because they can be either
    `true` or `false`. Swift has a built-in Boolean type called Bool that accepts
    one of the two built-in Boolean constants. These constants are `true` and `false`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值通常被称为逻辑值，因为它们可以是`true`或`false`。Swift有一个内置的布尔类型叫做Bool，它接受两个内置布尔常量之一。这些常量是`true`和`false`。
- en: 'Boolean constants and variables can be defined like this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔常量和变量可以定义为如下所示：
- en: '[PRE12]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Boolean values are especially useful when working with conditional statements,
    such as `if` and `while`. For example, what do you think this code would do:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔值在处理条件语句，如`if`和`while`时特别有用。例如，你认为以下代码会做什么：
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: If you answered that this code would print out `YEA, I cannot wait to learn
    it`, then you would be correct. Since `isSwiftCool` is set to true, the `YEA,
    I cannot wait to learn it` message is printed out, but `isItRaining` is false;
    therefore, the `Get a rain coat` message is not.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你回答说这段代码会打印出`YEA, I cannot wait to learn it`，那么你就对了。因为`isSwiftCool`被设置为true，所以会打印出`YEA,
    I cannot wait to learn it`信息，但`isItRaining`是false；因此，不会打印出`Get a rain coat`信息。
- en: 'You can also assign a Boolean value from a comparison operator like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以像这样从比较运算符中分配布尔值：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code, `z` is a Boolean variable containing a Boolean `true`
    value since `2` is greater than `1`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`z`是一个包含布尔`true`值的布尔变量，因为`2`大于`1`。
- en: The string type
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串类型
- en: 'A string is an ordered collection of characters, such as `Hello` or `Swift`.
    In Swift, the string type represents a string. We have seen several examples of
    strings already in this book, so the following code should look familiar. This
    code shows how to define two strings:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串是一个有序字符集合，例如`Hello`或`Swift`。在Swift中，字符串类型表示字符串。我们已经在这本书中看到了几个字符串的例子，所以以下代码应该看起来很熟悉。此代码展示了如何定义两个字符串：
- en: '[PRE15]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Since a string is an ordered collection of characters, we can iterate through
    each character of a string. The following code shows how to do this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 由于字符串是一个字符的有序集合，我们可以遍历字符串中的每个字符。以下代码展示了如何实现这一点：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The preceding code will display the results shown in the following screenshot:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将显示以下截图所示的结果：
- en: '![The string type](img/B05115_02_06.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![字符串类型](img/B05115_02_06.jpg)'
- en: 'There are two ways to add one string to another string. We can concatenate
    them or include them inline. To concatenate two strings, we use the `+` or `+=`
    operator. The following code shows how to concatenate two strings. The first example
    appends `stringB` to the end of `stringA` and the results are put into a new `stringC`
    variable. The second example appends `stringB` directly to the end of `stringA`
    without creating a new string:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种方法可以将一个字符串添加到另一个字符串中。我们可以连接它们或内联包含它们。要连接两个字符串，我们使用`+`或`+=`运算符。以下代码展示了如何连接两个字符串。第一个示例将`stringB`追加到`stringA`的末尾，并将结果放入新的`stringC`变量中。第二个示例直接将`stringB`追加到`stringA`的末尾，而不创建新的字符串：
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To include a string inline, with another string, we use a special sequence
    of characters `\( )`. The following code shows how to include a string inline
    with another string:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要将一个字符串内联包含在另一个字符串中，我们使用一个特殊的字符序列`\( )`。以下代码展示了如何将字符串内联包含在另一个字符串中：
- en: '[PRE18]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the previous example, `stringB` will contain the message, `Hello Jon`, because
    Swift will replace the `\(stringA)` sequence of characters with the value of `stringA`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，`stringB`将包含消息`Hello Jon`，因为Swift会将`\(stringA)`字符序列替换为`stringA`的值。
- en: 'In Swift, we define the mutability of variables and collections by using the
    `var` and `let` keywords. If we define a string as a variable using `var`, the
    string is mutable; this means that we can change and edit the value of the string.
    If we define a string as a constant using `let`, the string is immutable, meaning
    that we cannot change or edit the value once it is set. The following code shows
    the difference between a mutable and an immutable string:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，我们使用`var`和`let`关键字来定义变量和集合的可变性。如果我们使用`var`定义一个字符串为变量，则该字符串是可变的；这意味着我们可以更改和编辑字符串的值。如果我们使用`let`定义一个字符串为常量，则该字符串是不可变的，这意味着一旦设置，我们无法更改或编辑其值。以下代码展示了可变字符串和不可变字符串之间的区别：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Strings in Swift have three computed properties that can convert the case of
    the string. These properties are `capitalizedString`, `lowercaseString`, and `uppercaseString`.
    The following example demonstrates these properties:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Swift中的字符串有三个计算属性，可以将字符串的字母大小写进行转换。这些属性是`capitalizedString`、`lowercaseString`和`uppercaseString`。以下示例演示了这些属性：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'If we run this code, the results will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，结果将如下所示：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Swift provides four ways to compare a string; these are `string equality`,
    `prefix equality`, `suffix equality`, and `isEmpty`. The following example demonstrates
    these ways:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了四种比较字符串的方法；这些是`string equality`（字符串相等性）、`prefix equality`（前缀相等性）、`suffix
    equality`（后缀相等性）和`isEmpty`（是否为空）。以下示例演示了这些方法：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can replace all the occurrences of a target string with another string.
    This is done with the `stringByReplacingOccurrencesOfString()`method. The following
    code demonstrates this:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用另一个字符串替换目标字符串的所有出现。这是通过`stringByReplacingOccurrencesOfString()`方法完成的。以下代码演示了这一点：
- en: '[PRE23]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding example will print `one`,`two`,`three`,`four` to the screen because
    we are replacing all the occurrences of `to` with `two`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例将打印`one`,`two`,`three`,`four`到屏幕上，因为我们正在将所有`to`的出现替换为`two`。
- en: 'We can also retrieve substrings and individual characters from our strings.
    The following examples show various ways to do this:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以从我们的字符串中检索子字符串和单个字符。以下示例展示了各种实现方式：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding example, we use the `substringWithRange()` function to retrieve
    the substring between a start and end index. The indexes are created with the
    `startIndex.advanceBy()` function. The `startIndex` property return the index
    of the first character in the string and then we use the `advancedBy()` method
    to advance the index to the desired number of positions.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述示例中，我们使用`substringWithRange()`函数来检索从起始索引到结束索引之间的子字符串。索引是通过`startIndex.advanceBy()`函数创建的。`startIndex`属性返回字符串中第一个字符的索引，然后我们使用`advancedBy()`方法将索引推进到所需的位置数。
- en: The `substringToIndex()` function create a substring from the beginning of the
    string to the index. The `substringFromIndex()` function create a substring from
    the index to the end of the string. We then used the `last` property to get the
    last character of the string and the `first` property to get the first character.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`substringToIndex()`函数从字符串的开始创建到索引的子字符串。`substringFromIndex()`函数从索引创建到字符串末尾的子字符串。然后我们使用`last`属性获取字符串的最后一个字符，使用`first`属性获取第一个字符。'
- en: 'We can retrieve the number of characters in a string by using the count property.
    The following example shows how you can use this function:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用`count`属性来检索字符串中的字符数。以下示例展示了如何使用此功能：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This completes our whirlwind tour of strings. I know we went through these properties
    and functions very quickly, but we will be using strings extensively throughout
    this book, so we will have a lot of time to get used to them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了我们对字符串的快速浏览。我知道我们非常快地浏览了这些属性和函数，但在这本书中我们将广泛使用字符串，所以我们将有大量时间来熟悉它们。
- en: Optional variables
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可选变量
- en: All of the variables, which we have looked at so far, are considered to be non-optional
    variables. This means that the variables are required to have a non-nil value;
    however, there are times when we want or need our variables to contain `nil` values.
    This can occur if we return a `nil` from a function whose operation failed or
    if a value is not found.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止所查看的所有变量都被认为是非可选变量。这意味着变量必须有一个非nil值；然而，有时我们希望或需要我们的变量包含`nil`值。这可能会发生在我们从一个操作失败的函数返回`nil`值或找不到值时。
- en: 'In Swift, an optional variable is a variable that we are able to assign `nil`
    (no value) to. Optional variables and constants are defined using `?` (question
    mark). Let''s look at the following Playground; it shows us how to define `Optional`
    and shows what happens if we assign a `nil` value to a `Non-Optional` variable:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，可选变量是一个我们可以将其赋值为`nil`（无值）的变量。可选变量和常量使用`?`（问号）定义。让我们看看以下Playground；它展示了如何定义`Optional`以及如果我们给一个`Non-Optional`变量赋值`nil`会发生什么：
- en: '![Optional variables](img/B05115_02_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![可选变量](img/B05115_02_07.jpg)'
- en: Notice the error we receive when we try to assign a `nil` value to the non-optional
    variable. This error message tells us that the `stringTwo` variable does not conform
    to the `NilLiteralConvertible` protocol. When we see this error, remember that
    it means that we are assigning a `nil` value to a variable or constant that is
    not defined as an optional type.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意当我们尝试将`nil`值赋给非可选变量时收到的错误。这个错误信息告诉我们`stringTwo`变量不符合`NilLiteralConvertible`协议。当我们看到这个错误时，请记住这意味着我们正在将`nil`值赋给一个未定义为可选类型的变量或常量。
- en: 'Optional variables were added to the Swift language as a safety feature. They
    provide a compile time check of our variables to verify that they contain a valid
    value. Unless our code specifically defines a variable as optional, we can assume
    that the variable contains a valid value, and we do not have to check for `nil`
    values. Since we are able to define a variable prior to initiating it, this could
    give us a `nil` value in a non-optional variable; however, the compiler checks
    for this. The following Playground shows the error that we receive if we attempt
    to use a non-optional variable prior to initiating it:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 可选变量被添加到Swift语言中作为一个安全特性。它们提供了一个编译时检查，以验证我们的变量是否包含一个有效值。除非我们的代码明确将变量定义为可选的，否则我们可以假设变量包含一个有效值，我们不需要检查`nil`值。由于我们能够在初始化之前定义变量，这可能会在非可选变量中产生`nil`值；然而，编译器会检查这一点。以下Playground展示了如果我们尝试在初始化之前使用非可选变量时收到的错误：
- en: '![Optional variables](img/B05115_02_08.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![可选变量](img/B05115_02_08.jpg)'
- en: To verify that an optional variable or constant contains a valid (non-nil) value,
    our first thought may be to use the `!=` (not equals to) operator to verify that
    the variable is not equal to `nil`, but there are also other ways. These other
    ways are `Optional Binding` and `Optional Chaining`. Before we cover optional
    binding and optional chaining, let's see how to use the `!=` (not equals to) operator
    and what force unwrapping is.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 为了验证一个可选变量或常量是否包含一个有效的（非nil）值，我们首先可能想到使用`!=`（不等于）运算符来验证变量不等于`nil`，但还有其他方法。这些其他方法包括`Optional
    Binding`和`Optional Chaining`。在我们介绍可选绑定和可选链之前，让我们看看如何使用`!=`（不等于）运算符以及什么是强制解包。
- en: 'To use force unwrapping, we must first make sure that the optional has a non-nil
    value and then we can use the explanation point to access that value. The following
    example shows how we can do this:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用强制解包，我们首先必须确保可选变量包含一个非nil值，然后我们可以使用感叹号来访问该值。以下示例展示了我们如何做到这一点：
- en: '[PRE26]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this example, we create an optional variable named `name` and we assign it
    a value of `Jon`. We then use the `!=` operator to verify that the optional is
    not equal to `nil`. If it is not equal to `nil`, we are then able to use the explanation
    point to access its value. While this is a perfectly viable option, it is recommended
    that we use the optional binding method discussed next instead of force unwrapping.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了一个名为 `name` 的可选变量，并将其值设置为 `Jon`。然后我们使用 `!=` 运算符来验证可选值不等于 `nil`。如果不等于
    `nil`，我们就可以使用解释点来访问其值。虽然这是一个完全可行的选项，但建议我们使用接下来讨论的可选绑定方法，而不是强制展开。
- en: 'We use optional binding to check whether an optional variable or constant has
    a non-nil value, and, if so, assign that value to a temporary variable. For optional
    binding, we use the `if-let` or `if-var` keywords together. If we use `if-let`,
    the temporary value is a constant and cannot be changed, while the `if-var` keywords
    puts the temporary value into a variable that allows us to change the value. The
    following code illustrates how optional binding is used:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用可选绑定来检查可选变量或常量是否有非 `nil` 值，如果有，则将该值赋给一个临时变量。对于可选绑定，我们使用 `if-let` 或 `if-var`
    关键字。如果我们使用 `if-let`，则临时值是一个常量，不能更改，而 `if-var` 关键字将临时值放入一个变量中，允许我们更改该值。以下代码说明了如何使用可选绑定：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the preceding example, we use the `if let` keywords to check whether the
    `myOptional` variable is `nil`. If it is not `nil`, we assign the value to the
    `temp` variable and execute the code between the brackets. If the `myOptional`
    variable is `nil`, we execute the code in the `else` bracket, which prints out
    the message, `myOptional was nil`. One thing to note is that the `temp` variable
    is scoped only for the conditional block and cannot be used outside of the conditional
    block.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们使用 `if let` 关键字来检查 `myOptional` 变量是否为 `nil`。如果不是 `nil`，我们将值赋给 `temp`
    变量并执行括号内的代码。如果 `myOptional` 变量为 `nil`，则执行 `else` 括号内的代码，输出信息 `myOptional was nil`。需要注意的是，`temp`
    变量仅在条件块的作用域内有效，不能在条件块外部使用。
- en: 'It is perfectly acceptable with optional binding to assign the value to a variable
    of the same name. The following code illustrates this:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可选绑定将值赋给同名的变量是完全可接受的。以下代码说明了这一点：
- en: '[PRE28]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To illustrate the scope of the temporary variable, let''s take a look at the
    following code:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明临时变量的作用域，让我们看看以下代码：
- en: '[PRE29]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, the first line that is printed to the console is `Inside:
    Optional`( `test`) because we are within the scope of the `if-var` statement where
    we assign the value of `test` to the `myOptional` variable. The second line that
    is printed to the console would be `Outside: Optional`(`Jon`) because we are outside
    of the scope of the `if-var` statement where the `myOptional` variable is set
    to `Jon`.'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个例子中，打印到控制台的第一行是 `Inside: Optional`( `test`)，因为我们处于将 `test` 的值赋给 `myOptional`
    变量的 `if-var` 语句的作用域内。打印到控制台的第二行将是 `Outside: Optional`(`Jon`)，因为我们处于 `if-var` 语句的作用域之外，此时
    `myOptional` 变量被设置为 `Jon`。'
- en: 'We can also test multiple optional variables in one line. We do this by separating
    each optional check with a comma. The following example shows how to do this:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在一行中测试多个可选变量。我们通过在每个可选检查之间用逗号分隔来实现这一点。以下示例展示了如何这样做：
- en: '[PRE30]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Optional chaining allows us to call properties, methods, and subscripts on
    an optional that might be `nil`. If any of the chained values return `nil`, the
    return value will be `nil`. The following code gives an example of optional chaining
    using a fictitious `car` object. In this example, if either `car` or `tires` are
    `nil`, the variable `s` will be `nil`; otherwise, `s` will be equal to the `tireSize`
    property:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 可选链允许我们在可能为 `nil` 的可选对象上调用属性、方法和下标。如果链中的任何值返回 `nil`，则返回值将是 `nil`。以下代码通过一个虚构的
    `car` 对象示例了可选链的使用。在这个例子中，如果 `car` 或 `tires` 中的任何一个为 `nil`，变量 `s` 将为 `nil`；否则，`s`
    将等于 `tireSize` 属性：
- en: '[PRE31]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The following Playground illustrates the three ways to verify whether the optionals
    contain a valid value prior to using them:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 Playground 展示了在使用可选值之前验证它们是否包含有效值的三种方法：
- en: '![Optional variables](img/B05115_02_09.jpg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![可选变量](img/B05115_02_09.jpg)'
- en: 'In the preceding Playground, we begin by defining the optional string variable,
    `stringOne`. We then explicitly check for `nil` by using the `!=` operator. If
    `stringOne` is not equal to `nil`, we print the value of `stringOne` to the console.
    If `stringOne` is `nil`, we print the `Explicit Check: stringOne is nil` message
    to the console. As we can see in the results console, `Explicit Check: stringOne
    is nil is` printed to the console because we have not assigned a value to `stringOne`
    yet.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的游乐场中，我们首先定义了一个可选字符串变量`stringOne`。然后我们通过使用`!=`运算符显式检查`nil`。如果`stringOne`不等于`nil`，我们将`stringOne`的值打印到控制台。如果`stringOne`是`nil`，我们将打印`Explicit
    Check: stringOne is nil`消息到控制台。正如我们在结果控制台中看到的那样，因为尚未给`stringOne`赋值，所以打印了`Explicit
    Check: stringOne is nil`。'
- en: 'We then use optional binding to verify that `stringOne` is not `nil`. If `stringOne`
    is not `nil`, the value of `stringOne` is put into the `tmp` temporary variable,
    and we print the value of `tmp` to the console. If `stringOne` is `nil`, we print
    the `Optional Binding`: `stringOne` is `nil` message to the console. As we can
    see in the results console, `Optional Binding`: `stringOne is nil` is printed
    to the console because we have not assigned a value to `stringOne` yet.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '然后，我们使用可选绑定来验证`stringOne`不是`nil`。如果`stringOne`不是`nil`，则将`stringOne`的值放入临时变量`tmp`中，并将`tmp`的值打印到控制台。如果`stringOne`是`nil`，我们打印`Optional
    Binding: stringOne is nil`消息到控制台。正如我们在结果控制台中看到的那样，因为尚未给`stringOne`赋值，所以打印了`Optional
    Binding: stringOne is nil`。'
- en: We use optional chaining to assign the value of the `characters.count` property
    of the `stringOne` variable to the `charCount1` variable if `stringOne` is not
    `nil`. As we can see, the `charCount1` variable is `nil` because we have not assigned
    a value to `stringOne` yet.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`stringOne`不是`nil`，我们使用可选链将`stringOne`变量的`characters.count`属性的值赋给`charCount1`变量。正如我们所看到的，`charCount1`变量是`nil`，因为我们尚未给`stringOne`赋值。
- en: We then assign a value of [http://www.packtpub.com/all](http://www.packtpub.com/all)
    to the `stringOne` variable and rerun all the three tests again. This time `stringOne`
    has a non-nil value; therefore, the value of `charCount2` is printed to the console.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将[http://www.packtpub.com/all](http://www.packtpub.com/all)的值赋给`stringOne`变量，并再次运行所有三个测试。这次`stringOne`有一个非`nil`的值；因此，`charCount2`的值被打印到控制台。
- en: Note
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It would be tempting to say that I may need to set this variable to `nil`, so
    let me define it as optional, but that would be a mistake. The mindset for optionals
    should be to only use them if there is a specific reason for the variable to have
    `nil` value.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能会说，我可能需要将此变量设置为`nil`，所以让我将其定义为可选的，但那将是一个错误。对于可选的思维方式应该是，只有当变量有`nil`值的具体原因时才使用它们。
- en: Enumerations
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Enumerations (otherwise known as enums) are a special data type that enables
    us to group related types together and use them in a type safe manner. For those
    of us who are familiar with enums from other languages, such as C or Java, enums
    in Swift are not tied to integer values. We can define an enum with a type (string,
    character, integer, or floating-point) and then it's actual value (known as the
    raw value) will be the assigned value. Enums also support features that are traditionally
    supported only by classes such as computed properties and instance methods. We
    will discuss these advanced features in depth in [Chapter 5](ch05.html "Chapter 5. Classes
    and Structures"), *Classes and Structures*. In this section, we will look at the
    traditional enum features.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举（也称为枚举）是一种特殊的数据类型，它使我们能够将相关的类型分组在一起，并以类型安全的方式使用它们。对于那些熟悉来自其他语言（如C或Java）的枚举的人来说，Swift中的枚举并不依赖于整数值。我们可以定义一个具有类型（字符串、字符、整数或浮点数）的枚举，然后它的实际值（称为原始值）将是分配的值。枚举还支持传统上只有类才支持的功能，如计算属性和实例方法。我们将在[第5章](ch05.html
    "第5章。类和结构")*类和结构*中深入讨论这些高级功能。在本节中，我们将查看传统的枚举功能。
- en: 'We will define an enum that contains the list of `Planets` like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将定义一个枚举，其中包含类似这样的`Planets`列表：
- en: '[PRE32]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The values defined in an enum are considered to be the member values (or simply
    the members) of the enum. In most cases, you will see the member values defined
    like the preceding example because it is easy to read; however, there is a shorter
    version. This shorter version lets us define multiple members in a single line,
    separated by commas, as the following example shows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举中定义的值被认为是枚举的成员值（或简单地称为成员）。在大多数情况下，你将看到成员值像前面的示例那样定义，因为这样更容易阅读；然而，还有一个简短版本。这个简短版本允许我们在一行中定义多个成员，成员之间用逗号分隔，如下面的示例所示：
- en: '[PRE33]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can then use the `Planets` enum like this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`Planets`枚举如下：
- en: '[PRE34]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The type for the `planetWeLiveOn` and `furthestPlanet` variables is inferred
    when we initialize the variable with one of the member values of `Planets`. Once
    the variable type is inferred, we can then assign a new value without the `Planets`
    prefix, as shown here:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`Planets`枚举的一个成员值初始化变量`planetWeLiveOn`和`furthestPlanet`时，这些变量的类型会被推断出来。一旦变量类型被推断出来，我们就可以在不使用`Planets`前缀的情况下分配新值，如下所示：
- en: '[PRE35]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We can match an enum value using the traditional equals (`==`) operator or
    use a `switch` statement. The following example shows how to use the `equals`
    operator and the `switch` statement with an enum:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用传统的等于（`==`）运算符或使用`switch`语句来匹配枚举值。以下示例展示了如何使用`equals`运算符和`switch`语句与枚举一起使用：
- en: '[PRE36]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Enums can come prepopulated with raw values, which are required to be of the
    same type. This means that we can define our enum to contain string, character,
    integer, or floating-point values, but all of the members must be defined as the
    same type. The following example shows how to define an enum with string values:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举可以预先填充原始值，这些原始值必须是同一类型。这意味着我们可以定义我们的枚举以包含字符串、字符、整数或浮点值，但所有成员都必须定义为同一类型。以下示例展示了如何定义一个包含字符串值的枚举：
- en: '[PRE37]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding example creates an enum with three Apple devices. We then use
    the `rawValue` property to retrieve the raw value for the iPad member of the `Devices`
    enum. This example will print a message, saying `We are using an iPad`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子创建了一个包含三个苹果设备的枚举。然后我们使用`rawValue`属性来检索`Devices`枚举中`iPad`成员的原始值。此示例将打印一条消息，表示`We
    are using an iPad`。
- en: 'Let''s create another `Planets` enum, but this time, assign numbers to the
    members, as follows:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建另一个`Planets`枚举，但这次给成员分配数字，如下所示：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The big difference between the two enum examples is that in the second example,
    we only assign a value to the first member (`Mercury`). If integers are used for
    the raw values of an enum, we do not have to assign a value to each member. If
    no value is present, the raw values will be auto-incremented.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 两个枚举示例之间的主要区别在于，在第二个示例中，我们只给第一个成员（`Mercury`）赋值。如果枚举的原始值使用整数，我们就不必为每个成员赋值。如果没有值存在，原始值将自动递增。
- en: 'In Swift, enums can also have associated values. Associate values allow us
    to store additional information along with member values. This additional information
    can vary each time we use the member. It can also be of any type, and the types
    can be different for each member. Let''s take a look at how we might use associate
    types by defining a `Product` enum, which contains two types of products:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，枚举也可以有关联值。关联值允许我们在成员值之外存储额外的信息。这些额外信息每次使用成员时都可能不同。它也可以是任何类型，并且每个成员的类型可以不同。让我们通过定义一个包含两种产品的`Product`枚举来看看我们如何使用关联类型：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In the preceding example, we begin by defining a `Product` enum with two members—`Book`
    and `Puzzle`. The `Book` member has an associated value of `Double`, `Int`, `Int`,
    and the `Puzzle` member has an associated value of `Double, Int`. We then create
    two products `masterSwift` and `worldPuzzle`. We assign the `masterSwift` variable
    a value of `Product.Book` with the associated values of `49.99, 2015, 310`. We
    then assign the `worldPuzzle` variable a value of `Product.Puzzle` with the associated
    values of `9.99, 200`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们首先定义了一个包含两个成员——`Book`和`Puzzle`的`Product`枚举。`Book`成员关联的值类型为`Double`,
    `Int`, `Int`，而`Puzzle`成员关联的值类型为`Double, Int`。然后我们创建了两个产品`masterSwift`和`worldPuzzle`。我们将`masterSwift`变量赋值为`Product.Book`，并关联值为`49.99,
    2015, 310`。然后我们将`worldPuzzle`变量赋值为`Product.Puzzle`，并关联值为`9.99, 200`。
- en: We can then check the `Products` enum using a `switch` statement, as we did
    in some of the preceding enum examples. We also extract the associated values
    within the `switch` statement. In the previous example, we extracted the associated
    values as constants with the `let` keyword, but you can also extract the associated
    values as variables with the `var` keyword.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`switch`语句来检查`Products`枚举，就像我们在前面的枚举例子中所做的那样。我们还在`switch`语句中提取了关联值。在先前的例子中，我们使用`let`关键字将关联值作为常量提取出来，但您也可以使用`var`关键字将关联值作为变量提取出来。
- en: 'If you put the previous code into a Playground, the following results will
    be displayed:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将前面的代码放入Playground中，将显示以下结果：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Operators
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运算符
- en: An operator is a symbol or combination of symbols that we can use to check,
    change, or combine values. We have used operators in most of the examples so far
    in this book; however, we did not specifically call them operators. In this section,
    we will show how to use most of the basic operators that Swift supports.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 运算符是一个符号或符号的组合，我们可以用它来检查、更改或组合值。我们在本书中的大多数示例中都使用了运算符；然而，我们并没有特别称它们为运算符。在本节中，我们将展示如何使用
    Swift 支持的大多数基本运算符。
- en: Swift supports most standard C operators and also improves them to eliminate
    several common coding errors. For example, the assignment operator does not return
    a value to prevent it from being used when the equality operator (`==`) was meant
    to be used.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 支持大多数标准 C 运算符，并对其进行改进以消除几个常见的编码错误。例如，赋值运算符不返回值，以防止在打算使用相等运算符（`==`）时被误用。
- en: Let's look at the operators in Swift.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看 Swift 中的运算符。
- en: The assignment operator
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符
- en: The assignment operator initializes or updates a variable.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 赋值运算符初始化或更新变量。
- en: 'Prototype:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE41]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Example:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE42]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Comparison operators
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较运算符
- en: The comparison operator returns a Boolean `true` if the statement is true or
    a Boolean `false` if the statement is not true.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 比较运算符如果语句为真，则返回布尔 `true`；如果语句不为真，则返回布尔 `false`。
- en: 'Prototypes:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE43]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Example:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE44]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Arithmetic operators
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 算术运算符
- en: The arithmetic operators perform the four basic mathematical operations.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 算术运算符执行四种基本的数学运算。
- en: 'Prototypes:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE45]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Example:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE46]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The remainder operator
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 取模运算符
- en: The remainder operator calculates the remainder if the first operand is divided
    by the second operand.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 取模运算符计算第一个操作数除以第二个操作数的余数。
- en: 'Prototype:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE47]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE48]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Increment and decrement operators
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自增和自减运算符
- en: The increment and decrement operators are shortcuts to increment or decrement
    a variable by `1`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 自增和自减运算符是用于将变量增加或减少 `1` 的快捷方式。
- en: 'Prototypes:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE49]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Example:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE50]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Compound assignment operators
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 复合赋值运算符
- en: The compound assignment operators combine an arithmetic operator with an assignment
    operator.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 复合赋值运算符将算术运算符与赋值运算符结合。
- en: 'Prototypes:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE51]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Example:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE52]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The ternary conditional operator
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元条件运算符
- en: The ternary conditional operator assigns a value to a variable, based on the
    evaluation of a comparison operator or Boolean value.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 三元条件运算符根据比较运算符或布尔值的评估将值赋给变量。
- en: 'Prototype:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE53]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Example:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE54]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The logical NOT operator
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑非运算符
- en: The logical NOT operator inverts a Boolean value.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑非运算符反转布尔值。
- en: 'Prototype:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE55]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Example:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE56]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The logical AND operator
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑与运算符
- en: The logical AND operator returns `true` if both operands are true, otherwise
    it returns `false`.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑与运算符如果两个操作数都为真，则返回 `true`，否则返回 `false`。
- en: 'Prototype:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE57]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Example:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE58]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The logical OR operator
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 逻辑或运算符
- en: The logical OR operator returns `true` if either of the operands is true.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑或运算符如果任一操作数为真，则返回 `true`。
- en: 'Prototype:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 原型：
- en: '[PRE59]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Example:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 示例：
- en: '[PRE60]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: For those who are familiar with C and languages that have a similar syntax to
    C, these operators should look pretty familiar. For those who aren't that familiar
    with the C operators, rest assured that you will use them enough and they will
    become second nature.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 对于熟悉 C 语言及其类似语法的语言的人来说，这些运算符应该看起来相当熟悉。对于那些不太熟悉 C 运算符的人来说，请放心，你会足够多地使用它们，它们将变得习以为常。
- en: Summary
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we covered a lot of different topics. These topics ranged from
    variables and constants to data types and operators. The items in this chapter
    will be the foundation of every application that you write; therefore, it is important
    to understand the concepts discussed here.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的不同主题。这些主题从变量和常量到数据类型和运算符不等。本章中的内容将成为你编写每个应用程序的基础；因此，理解这里讨论的概念非常重要。
- en: In the next chapter, we will look at how we can use the Swift collection types
    to store related data. These collection types are the dictionary and array types.
    We will also look at how we can use the Cocoa and Foundation data types in Swift.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用 Swift 的集合类型来存储相关数据。这些集合类型包括字典和数组类型。我们还将探讨如何在 Swift 中使用 Cocoa
    和 Foundation 数据类型。
