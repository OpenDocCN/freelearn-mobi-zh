- en: Chapter 2. Learning about Variables, Constants, Strings, and Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first program I ever wrote was written in the BASIC programming language,
    and was the typical Hello World application. This application was pretty exciting
    at first, but the excitement of printing static text wore off pretty quickly.
    For my second application, I used BASIC's input command to prompt the user for
    a name and then printed out a custom hello message to the user with their name
    in it. At the age of 12, it was pretty cool to display Hello Han Solo. This application
    led me to create numerous Mad Lib style applications that prompted the user for
    various words and then put those words into a story that was displayed after the
    user had entered all the required words. These applications introduced me to,
    and taught me, the importance of variables. Every useful application I created
    since then has used variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What variables and constants are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between explicit and inferred typing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining numeric, string, and Boolean types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining what optional types are
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how enumerations work in Swift
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explaining how Swift's operators work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constants and variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Constants and variables associate an identifier (such as `myName` or `currentTemperature`)
    with a value of a particular type (such as `String` or `Int`), where the identifier
    can be used to retrieve the value. The difference between a constant and a variable
    is that a variable can be updated or changed, while a constant cannot be changed
    once a value is assigned to it.
  prefs: []
  type: TYPE_NORMAL
- en: Constants are good for defining the values that you know will never change,
    such as the freezing temperature of water or the speed of light. Constants are
    also good for defining a value that we use many times throughout our application,
    such as a standard font size or maximum characters in a buffer. There will be
    numerous examples of constants throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: Variables tend to be more common in software development than constants, however.
    This is mainly because developers tend to prefer variables to constants. In Swift
    2 and Xcode 7, we are warned if we declare a variable that is never changed. This
    should increase the use of constants. We can make useful applications without
    using constants (although it is a good practice to use them); however, it is almost
    impossible to create a useful application without variables.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of constants is encouraged in Swift. If we do not expect or want the
    value to change, we should declare it as a constant. This adds a very important
    safety constraint to our code that ensures that the value never changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use almost any character in the identifier of a variable or constant
    (even Unicode characters); however, there are a few rules that you must follow:'
  prefs: []
  type: TYPE_NORMAL
- en: An identifier must not contain any whitespace
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not contain any mathematical symbols
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not contain any arrows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not contain private use or invalid Unicode characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not contain line- or box-drawing characters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An identifier must not start with a number, but they can contain numbers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you use a Swift keyword as an identifier, surround it with back ticks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Keywords are words that are used by the Swift programming language. Some examples
    of keywords that you will see in this chapter are `var` and `let`. You should
    avoid using Swift keywords as identifiers to avoid confusion when reading your
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Defining constants and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Constants and variables must be defined prior to using them. To define a constant,
    you use the keyword, `let`, and to define a variable, you use the keyword, `var`.
    The following are some examples of constants and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We can declare multiple constants or variables in a single line by separating
    them with a comma. For example, we could shrink the preceding four lines of code
    down to two lines, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We can change the value of a variable to another value of a compatible type;
    however, as we noted earlier, we cannot change the value of a constant. Let''s
    look at the following Playground. Can you tell what is wrong with the code from
    the error message that is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Defining constants and variables](img/B05115_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Did you figure out what was wrong with the code? Any physicist can tell you
    that we cannot change the speed of light, and in our code, the `speedOfLightKmSec`
    variable is a constant, so we cannot change it either. Therefore, when we try
    to change the `speedOfLightKmSec` constant, an error is reported. We are able
    to change the value of the `highTemperture` variable without an error because
    it is a variable. We mentioned the difference between variables and constants
    a couple of times because it is a very important concept to grasp, especially
    when we define mutable and immutable collection types later in [Chapter 3](ch03.html
    "Chapter 3. Using Collections and Cocoa Data Types"), *Using Collections and Cocoa
    Data Types*.
  prefs: []
  type: TYPE_NORMAL
- en: Type safety
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Swift is a type-safe language. In a type-safe language, we are required to
    be clear on the types of values we store in a variable. We will get an error if
    we attempt to assign a value to a variable that is of a wrong type. The following
    Playground shows what happens if we attempt to put a string value into a variable
    that expects integer values; note that we will go over the most popular types
    a little later in the chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Type safety](img/B05115_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Swift performs a type check when it compiles code; therefore, it will flag any
    mismatched types with an error. The error message in this Playground explains
    pretty clearly that we are trying to insert a string literal into an integer variable.
  prefs: []
  type: TYPE_NORMAL
- en: So the question is, how does Swift know that `integerVar` is of the Int type?
    Swift uses type inference to figure out the appropriate type. Let's take a look
    at what type inference is.
  prefs: []
  type: TYPE_NORMAL
- en: Type inference
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type inference allows us to omit the variable type when we define it. The compiler
    will infer the type, based on the initial value. For example, in Objective-C,
    we would define an integer like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This tells the compiler that the `myInt` variable is of the Int type, and the
    initial value is the number `1`. In Swift, we would define the same integer like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift infers that the variable type is an integer because the initial value
    is an integer. Let''s take a look at a couple of more examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, the compiler will correctly infer that variable `x`
    is Double, variable `y` is String, and variable `z` is Boolean, based on the initial
    values.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Type inference is a very nice feature in Swift and is one that you will probably
    get used to very quickly; however, there are times when we would like to explicitly
    define a variable''s type. For example, in the preceding example, the variable,
    `x`, is inferred to be `Double`, but what if we wanted the variable type to be
    `Float`? We can explicitly define a variable type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the`: Float`(colon and the word `Float`) after the variable identifier;
    this tells the compiler to define the variable to be of the `Float` type and gives
    it an initial value of `3.14`. When we define a variable in this manner, we need
    to make sure that the initial value is of the same type we are defining the variable
    to be. If we try to give a variable an initial value, that is, a different type
    than we are defining it as, we will receive an error.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We would also explicitly define the variable type if we were not setting an
    initial value. For example, the following line of code is invalid because the
    compiler does not know what type to set the variable, `x`, to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If we use this code in our application, we will receive a `Type annotation
    missing in pattern` error. If we are not setting an initial value for a variable,
    we are required to define the type like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have seen how to explicitly define a variable type, let's take a
    look at some of the most commonly used types.
  prefs: []
  type: TYPE_NORMAL
- en: Numeric types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Swift contains many of the standard numeric types that are suitable for storing
    various integer and floating-point values.
  prefs: []
  type: TYPE_NORMAL
- en: Integers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An integer is a whole number. Integers can be either signed (positive, negative,
    or zero) or unsigned (positive or zero). Swift provides several integer types
    of different sizes. The following chart shows the value ranges for the different
    integer types:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Minimum | Maximum |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Int8 | -128 | 127 |'
  prefs: []
  type: TYPE_TB
- en: '| Int16 | -32,768 | 32,767 |'
  prefs: []
  type: TYPE_TB
- en: '| Int32 | -2,147,483,648 | 2,147,483,647 |'
  prefs: []
  type: TYPE_TB
- en: '| Int64 | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: '| Int | - 9,223,372,036,854,775,808 | 9,223,372,036,854,775,807 |'
  prefs: []
  type: TYPE_TB
- en: '|   |   |   |'
  prefs: []
  type: TYPE_TB
- en: '| UInt8 | 0 | 255 |'
  prefs: []
  type: TYPE_TB
- en: '| UInt16 | 0 | 65,535 |'
  prefs: []
  type: TYPE_TB
- en: '| UInt32 | 0 | 4,294,967,295 |'
  prefs: []
  type: TYPE_TB
- en: '| UInt64 | 0 | 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: '| UInt | 0 | 18,446,744,073,709,551,615 |'
  prefs: []
  type: TYPE_TB
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless there is a specific reason to define the size of an integer, I would
    recommend using the standard `Int` or `UInt` type. This will save you from needing
    to convert between different types of integers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, Int (as well as other numerical types) are actually named types,
    implemented in the Swift standard library using structures. This gives us a consistent
    mechanism for memory management for all the data types as well as properties that
    we can access. For the preceding chart, I retrieved the minimum and maximum values
    of each integer type using the `min` and `max` properties. Take a look at the
    following Playground to see how I retrieved the values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integers](img/B05115_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Integers can also be represented as binary, octal, and hexadecimal numbers.
    We just need to add a prefix to the number to tell the compiler which base the
    number should be in. The following chart shows the prefix for each numerical base:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Base | Prefix |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Decimal | None |'
  prefs: []
  type: TYPE_TB
- en: '| Binary | 0b |'
  prefs: []
  type: TYPE_TB
- en: '| Octal | 0o |'
  prefs: []
  type: TYPE_TB
- en: '| Hexadecimal | 0x |'
  prefs: []
  type: TYPE_TB
- en: 'The following Playground shows how the number, `95`, is represented in each
    of the numerical bases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integers](img/B05115_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Swift also allows us to insert arbitrary underscores in our numeric literals.
    This can improve the readability of our code. As an example, if we were defining
    the speed of light, which is constant, we can define it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Swift will ignore these underscores; therefore, they do not affect the value
    of the numeric literals in any way.
  prefs: []
  type: TYPE_NORMAL
- en: Floating-point
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A floating-point number is a number with a decimal component. There are two
    standard floating-point types in Swift Float and Double. Float represents a 32-bit
    floating-point number, while Double represents a 64-bit floating-point number.
    Swift also supports an extended floating-point type, that is, **Float80**. The
    Float80 type is an 80-bit floating-point number.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is recommended that we use the Double type over the Float type unless there
    is a specific reason to use the latter. The Double type has a precision of at
    least 15 decimal digits, while the Float type can be as little as six decimal
    digits. Lets look at an example of how this can effect our application without
    us knowing it. The following screenshot shows the results if we add two decimal
    numbers together and put the results in both a Float type and Double type:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Floating-point](img/B05115_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see from the screenshots, the two decimal numbers that we are adding
    together contain nine digits post the decimal point; however, the results in the
    Float type only contains seven digits, while the results in the Double type contains
    the full nine digits.
  prefs: []
  type: TYPE_NORMAL
- en: The loss of precision can cause issues if we are working with currency or other
    numbers that need accurate calculations. The floating-point accuracy problem is
    not an issue confined to Swift; all the languages that implement the IEEE 754
    floating-point standard have similar issues. The best practice is to use Double
    for floating-point numbers unless there is a specific reason not to.
  prefs: []
  type: TYPE_NORMAL
- en: 'What if we have two variables, one is an Int and the other is a Double? Do
    you think we can add them together as the following code depicts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we put the preceding code into a Playground, we would receive the following
    error: `binary operator ''+'' cannot be applied to operands of type ''Int'' and
    ''String`'''
  prefs: []
  type: TYPE_NORMAL
- en: 'This error lets us know that we are trying to add two different types of numbers,
    which is not allowed. To add an Int and a Double together, we need to convert
    the Int value into a Double value. The following code shows how to convert an
    Int value into a Double value so that we can add them together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice how we use the `Double()` function to convert the Int value to a Double
    value. All the numeric types in Swift have a conversion convenience initializer,
    similar to the `Double()` function shown in the preceding code sample. For example,
    the following code shows how you can convert an `Int` variable to `Float` and
    `UInt16` variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The Boolean type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Boolean values are often referred to as logical values because they can be either
    `true` or `false`. Swift has a built-in Boolean type called Bool that accepts
    one of the two built-in Boolean constants. These constants are `true` and `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Boolean constants and variables can be defined like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Boolean values are especially useful when working with conditional statements,
    such as `if` and `while`. For example, what do you think this code would do:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: If you answered that this code would print out `YEA, I cannot wait to learn
    it`, then you would be correct. Since `isSwiftCool` is set to true, the `YEA,
    I cannot wait to learn it` message is printed out, but `isItRaining` is false;
    therefore, the `Get a rain coat` message is not.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also assign a Boolean value from a comparison operator like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, `z` is a Boolean variable containing a Boolean `true`
    value since `2` is greater than `1`.
  prefs: []
  type: TYPE_NORMAL
- en: The string type
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A string is an ordered collection of characters, such as `Hello` or `Swift`.
    In Swift, the string type represents a string. We have seen several examples of
    strings already in this book, so the following code should look familiar. This
    code shows how to define two strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Since a string is an ordered collection of characters, we can iterate through
    each character of a string. The following code shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code will display the results shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The string type](img/B05115_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are two ways to add one string to another string. We can concatenate
    them or include them inline. To concatenate two strings, we use the `+` or `+=`
    operator. The following code shows how to concatenate two strings. The first example
    appends `stringB` to the end of `stringA` and the results are put into a new `stringC`
    variable. The second example appends `stringB` directly to the end of `stringA`
    without creating a new string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To include a string inline, with another string, we use a special sequence
    of characters `\( )`. The following code shows how to include a string inline
    with another string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the previous example, `stringB` will contain the message, `Hello Jon`, because
    Swift will replace the `\(stringA)` sequence of characters with the value of `stringA`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, we define the mutability of variables and collections by using the
    `var` and `let` keywords. If we define a string as a variable using `var`, the
    string is mutable; this means that we can change and edit the value of the string.
    If we define a string as a constant using `let`, the string is immutable, meaning
    that we cannot change or edit the value once it is set. The following code shows
    the difference between a mutable and an immutable string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Strings in Swift have three computed properties that can convert the case of
    the string. These properties are `capitalizedString`, `lowercaseString`, and `uppercaseString`.
    The following example demonstrates these properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If we run this code, the results will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Swift provides four ways to compare a string; these are `string equality`,
    `prefix equality`, `suffix equality`, and `isEmpty`. The following example demonstrates
    these ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We can replace all the occurrences of a target string with another string.
    This is done with the `stringByReplacingOccurrencesOfString()`method. The following
    code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example will print `one`,`two`,`three`,`four` to the screen because
    we are replacing all the occurrences of `to` with `two`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also retrieve substrings and individual characters from our strings.
    The following examples show various ways to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `substringWithRange()` function to retrieve
    the substring between a start and end index. The indexes are created with the
    `startIndex.advanceBy()` function. The `startIndex` property return the index
    of the first character in the string and then we use the `advancedBy()` method
    to advance the index to the desired number of positions.
  prefs: []
  type: TYPE_NORMAL
- en: The `substringToIndex()` function create a substring from the beginning of the
    string to the index. The `substringFromIndex()` function create a substring from
    the index to the end of the string. We then used the `last` property to get the
    last character of the string and the `first` property to get the first character.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can retrieve the number of characters in a string by using the count property.
    The following example shows how you can use this function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This completes our whirlwind tour of strings. I know we went through these properties
    and functions very quickly, but we will be using strings extensively throughout
    this book, so we will have a lot of time to get used to them.
  prefs: []
  type: TYPE_NORMAL
- en: Optional variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of the variables, which we have looked at so far, are considered to be non-optional
    variables. This means that the variables are required to have a non-nil value;
    however, there are times when we want or need our variables to contain `nil` values.
    This can occur if we return a `nil` from a function whose operation failed or
    if a value is not found.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, an optional variable is a variable that we are able to assign `nil`
    (no value) to. Optional variables and constants are defined using `?` (question
    mark). Let''s look at the following Playground; it shows us how to define `Optional`
    and shows what happens if we assign a `nil` value to a `Non-Optional` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional variables](img/B05115_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the error we receive when we try to assign a `nil` value to the non-optional
    variable. This error message tells us that the `stringTwo` variable does not conform
    to the `NilLiteralConvertible` protocol. When we see this error, remember that
    it means that we are assigning a `nil` value to a variable or constant that is
    not defined as an optional type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Optional variables were added to the Swift language as a safety feature. They
    provide a compile time check of our variables to verify that they contain a valid
    value. Unless our code specifically defines a variable as optional, we can assume
    that the variable contains a valid value, and we do not have to check for `nil`
    values. Since we are able to define a variable prior to initiating it, this could
    give us a `nil` value in a non-optional variable; however, the compiler checks
    for this. The following Playground shows the error that we receive if we attempt
    to use a non-optional variable prior to initiating it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional variables](img/B05115_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To verify that an optional variable or constant contains a valid (non-nil) value,
    our first thought may be to use the `!=` (not equals to) operator to verify that
    the variable is not equal to `nil`, but there are also other ways. These other
    ways are `Optional Binding` and `Optional Chaining`. Before we cover optional
    binding and optional chaining, let's see how to use the `!=` (not equals to) operator
    and what force unwrapping is.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use force unwrapping, we must first make sure that the optional has a non-nil
    value and then we can use the explanation point to access that value. The following
    example shows how we can do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we create an optional variable named `name` and we assign it
    a value of `Jon`. We then use the `!=` operator to verify that the optional is
    not equal to `nil`. If it is not equal to `nil`, we are then able to use the explanation
    point to access its value. While this is a perfectly viable option, it is recommended
    that we use the optional binding method discussed next instead of force unwrapping.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use optional binding to check whether an optional variable or constant has
    a non-nil value, and, if so, assign that value to a temporary variable. For optional
    binding, we use the `if-let` or `if-var` keywords together. If we use `if-let`,
    the temporary value is a constant and cannot be changed, while the `if-var` keywords
    puts the temporary value into a variable that allows us to change the value. The
    following code illustrates how optional binding is used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we use the `if let` keywords to check whether the
    `myOptional` variable is `nil`. If it is not `nil`, we assign the value to the
    `temp` variable and execute the code between the brackets. If the `myOptional`
    variable is `nil`, we execute the code in the `else` bracket, which prints out
    the message, `myOptional was nil`. One thing to note is that the `temp` variable
    is scoped only for the conditional block and cannot be used outside of the conditional
    block.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is perfectly acceptable with optional binding to assign the value to a variable
    of the same name. The following code illustrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To illustrate the scope of the temporary variable, let''s take a look at the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, the first line that is printed to the console is `Inside:
    Optional`( `test`) because we are within the scope of the `if-var` statement where
    we assign the value of `test` to the `myOptional` variable. The second line that
    is printed to the console would be `Outside: Optional`(`Jon`) because we are outside
    of the scope of the `if-var` statement where the `myOptional` variable is set
    to `Jon`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also test multiple optional variables in one line. We do this by separating
    each optional check with a comma. The following example shows how to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Optional chaining allows us to call properties, methods, and subscripts on
    an optional that might be `nil`. If any of the chained values return `nil`, the
    return value will be `nil`. The following code gives an example of optional chaining
    using a fictitious `car` object. In this example, if either `car` or `tires` are
    `nil`, the variable `s` will be `nil`; otherwise, `s` will be equal to the `tireSize`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The following Playground illustrates the three ways to verify whether the optionals
    contain a valid value prior to using them:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Optional variables](img/B05115_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding Playground, we begin by defining the optional string variable,
    `stringOne`. We then explicitly check for `nil` by using the `!=` operator. If
    `stringOne` is not equal to `nil`, we print the value of `stringOne` to the console.
    If `stringOne` is `nil`, we print the `Explicit Check: stringOne is nil` message
    to the console. As we can see in the results console, `Explicit Check: stringOne
    is nil is` printed to the console because we have not assigned a value to `stringOne`
    yet.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We then use optional binding to verify that `stringOne` is not `nil`. If `stringOne`
    is not `nil`, the value of `stringOne` is put into the `tmp` temporary variable,
    and we print the value of `tmp` to the console. If `stringOne` is `nil`, we print
    the `Optional Binding`: `stringOne` is `nil` message to the console. As we can
    see in the results console, `Optional Binding`: `stringOne is nil` is printed
    to the console because we have not assigned a value to `stringOne` yet.'
  prefs: []
  type: TYPE_NORMAL
- en: We use optional chaining to assign the value of the `characters.count` property
    of the `stringOne` variable to the `charCount1` variable if `stringOne` is not
    `nil`. As we can see, the `charCount1` variable is `nil` because we have not assigned
    a value to `stringOne` yet.
  prefs: []
  type: TYPE_NORMAL
- en: We then assign a value of [http://www.packtpub.com/all](http://www.packtpub.com/all)
    to the `stringOne` variable and rerun all the three tests again. This time `stringOne`
    has a non-nil value; therefore, the value of `charCount2` is printed to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It would be tempting to say that I may need to set this variable to `nil`, so
    let me define it as optional, but that would be a mistake. The mindset for optionals
    should be to only use them if there is a specific reason for the variable to have
    `nil` value.
  prefs: []
  type: TYPE_NORMAL
- en: Enumerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Enumerations (otherwise known as enums) are a special data type that enables
    us to group related types together and use them in a type safe manner. For those
    of us who are familiar with enums from other languages, such as C or Java, enums
    in Swift are not tied to integer values. We can define an enum with a type (string,
    character, integer, or floating-point) and then it's actual value (known as the
    raw value) will be the assigned value. Enums also support features that are traditionally
    supported only by classes such as computed properties and instance methods. We
    will discuss these advanced features in depth in [Chapter 5](ch05.html "Chapter 5. Classes
    and Structures"), *Classes and Structures*. In this section, we will look at the
    traditional enum features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define an enum that contains the list of `Planets` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The values defined in an enum are considered to be the member values (or simply
    the members) of the enum. In most cases, you will see the member values defined
    like the preceding example because it is easy to read; however, there is a shorter
    version. This shorter version lets us define multiple members in a single line,
    separated by commas, as the following example shows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use the `Planets` enum like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The type for the `planetWeLiveOn` and `furthestPlanet` variables is inferred
    when we initialize the variable with one of the member values of `Planets`. Once
    the variable type is inferred, we can then assign a new value without the `Planets`
    prefix, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can match an enum value using the traditional equals (`==`) operator or
    use a `switch` statement. The following example shows how to use the `equals`
    operator and the `switch` statement with an enum:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Enums can come prepopulated with raw values, which are required to be of the
    same type. This means that we can define our enum to contain string, character,
    integer, or floating-point values, but all of the members must be defined as the
    same type. The following example shows how to define an enum with string values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example creates an enum with three Apple devices. We then use
    the `rawValue` property to retrieve the raw value for the iPad member of the `Devices`
    enum. This example will print a message, saying `We are using an iPad`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create another `Planets` enum, but this time, assign numbers to the
    members, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The big difference between the two enum examples is that in the second example,
    we only assign a value to the first member (`Mercury`). If integers are used for
    the raw values of an enum, we do not have to assign a value to each member. If
    no value is present, the raw values will be auto-incremented.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Swift, enums can also have associated values. Associate values allow us
    to store additional information along with member values. This additional information
    can vary each time we use the member. It can also be of any type, and the types
    can be different for each member. Let''s take a look at how we might use associate
    types by defining a `Product` enum, which contains two types of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we begin by defining a `Product` enum with two members—`Book`
    and `Puzzle`. The `Book` member has an associated value of `Double`, `Int`, `Int`,
    and the `Puzzle` member has an associated value of `Double, Int`. We then create
    two products `masterSwift` and `worldPuzzle`. We assign the `masterSwift` variable
    a value of `Product.Book` with the associated values of `49.99, 2015, 310`. We
    then assign the `worldPuzzle` variable a value of `Product.Puzzle` with the associated
    values of `9.99, 200`.
  prefs: []
  type: TYPE_NORMAL
- en: We can then check the `Products` enum using a `switch` statement, as we did
    in some of the preceding enum examples. We also extract the associated values
    within the `switch` statement. In the previous example, we extracted the associated
    values as constants with the `let` keyword, but you can also extract the associated
    values as variables with the `var` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you put the previous code into a Playground, the following results will
    be displayed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An operator is a symbol or combination of symbols that we can use to check,
    change, or combine values. We have used operators in most of the examples so far
    in this book; however, we did not specifically call them operators. In this section,
    we will show how to use most of the basic operators that Swift supports.
  prefs: []
  type: TYPE_NORMAL
- en: Swift supports most standard C operators and also improves them to eliminate
    several common coding errors. For example, the assignment operator does not return
    a value to prevent it from being used when the equality operator (`==`) was meant
    to be used.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at the operators in Swift.
  prefs: []
  type: TYPE_NORMAL
- en: The assignment operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The assignment operator initializes or updates a variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Comparison operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The comparison operator returns a Boolean `true` if the statement is true or
    a Boolean `false` if the statement is not true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Arithmetic operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The arithmetic operators perform the four basic mathematical operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: The remainder operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The remainder operator calculates the remainder if the first operand is divided
    by the second operand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Increment and decrement operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The increment and decrement operators are shortcuts to increment or decrement
    a variable by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Compound assignment operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compound assignment operators combine an arithmetic operator with an assignment
    operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototypes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: The ternary conditional operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The ternary conditional operator assigns a value to a variable, based on the
    evaluation of a comparison operator or Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The logical NOT operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical NOT operator inverts a Boolean value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The logical AND operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical AND operator returns `true` if both operands are true, otherwise
    it returns `false`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The logical OR operator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The logical OR operator returns `true` if either of the operands is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: For those who are familiar with C and languages that have a similar syntax to
    C, these operators should look pretty familiar. For those who aren't that familiar
    with the C operators, rest assured that you will use them enough and they will
    become second nature.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of different topics. These topics ranged from
    variables and constants to data types and operators. The items in this chapter
    will be the foundation of every application that you write; therefore, it is important
    to understand the concepts discussed here.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at how we can use the Swift collection types
    to store related data. These collection types are the dictionary and array types.
    We will also look at how we can use the Cocoa and Foundation data types in Swift.
  prefs: []
  type: TYPE_NORMAL
