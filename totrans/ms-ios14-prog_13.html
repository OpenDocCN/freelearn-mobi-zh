<html><head></head><body>
		<div id="_idContainer129">
			<h1 id="_idParaDest-207"><em class="italic"><a id="_idTextAnchor447"/>Chapter 13</em>: Working with the Combine Framework</h1>
			<p>With the launch of <strong class="bold">Combine</strong>, Apple provided developers with a new way of handling events in their code; a functional and declarative approach, where developers can implement streams and publisher/subscriber paradigms easily, without the need for external libraries. Centralizing event processing in your apps with the help of Combine makes your code easier to understand than using other traditional methods like nested closures or callbacks all around your code.</p>
			<p>In this chapter, you will learn about the following topics: </p>
			<ul>
				<li>Understanding the Combine framework: We will review the basic components of the framework with code samples – publishers, subscribers, subjects, and operators.</li>
				<li>Combining publishers, subscribers, and operators: We will build a small feature in an example app mixing all these concepts together.</li>
				<li>Using operators to build error-proof streams: We will use <strong class="source-inline">flatMap</strong> and <strong class="source-inline">catch</strong> to create streams that can deal properly with errors in a real-world example app.</li>
			</ul>
			<p>By the end of the chapter, you should be able to use Combine in multiple parts of your own apps to produce simple, effective, and easy to understand declarative code that will help your app's code be easy to understand, extend, and maintain.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor448"/>Technical requirements</h1>
			<p>The code bundle for this chapter includes two starter projects called <strong class="bold">CombineExample_start</strong> and <strong class="bold">PublishersAndSubscribers_start</strong>. You can find them in the code bundle repository:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor449"/>Understanding the Combine framework</h1>
			<p>Apple released the <a id="_idIndexMarker592"/>Combine framework in 2019, and they defined it as a framework that provides a declarative Swift API for processing values over time. There are <strong class="bold">publishers</strong>, which produce those values, and <strong class="bold">subscribers</strong>, which consume them. These values that change over time may represent different asynchronous events. </p>
			<p>Let's see an overview of the Publisher and Subscriber protocol definitions to understand their key concepts in the following sections.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor450"/>Understanding Publisher</h2>
			<p>As mentioned before, publishers <a id="_idIndexMarker593"/>are used in Combine to produce values <a id="_idIndexMarker594"/>over time. Let's dig into the Swift protocol that defines them to understand the key concepts. The <strong class="source-inline">Publisher</strong> definition in Swift looks as follows:</p>
			<p class="source-code">public protocol Publisher {</p>
			<p class="source-code">    //1</p>
			<p class="source-code">    associatedtype Output</p>
			<p class="source-code">    //2</p>
			<p class="source-code">    associatedtype Failure : Error</p>
			<p class="source-code">    //3</p>
			<p class="source-code">    public func subscribe&lt;S&gt;(_ subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input</p>
			<p class="source-code">}</p>
			<p>Let's explain each numbered <a id="_idIndexMarker595"/>comment in more detail:</p>
			<ol>
				<li>Every <strong class="source-inline">Publisher</strong> instance has <a id="_idIndexMarker596"/>an associated type, <strong class="source-inline">Output</strong>. This defines the type of values that the publisher will generate over time.</li>
				<li>At the same time, the <strong class="source-inline">Publisher</strong> can also generate errors, and the associated type <strong class="source-inline">Failure</strong> is used to define the type of those errors. If a <strong class="source-inline">Publisher</strong> never generates errors, the <strong class="source-inline">Failure</strong> can be defined as type <strong class="source-inline">Never</strong>.</li>
				<li>Finally, a <strong class="source-inline">Publisher</strong> allows <strong class="source-inline">Subscriber</strong> entities to <strong class="source-inline">subscribe</strong> to it to receive the values that are being produced over time. Note that to generate a valid subscription, the publisher's <strong class="source-inline">Output</strong> type must match the subscriber's <strong class="source-inline">Input</strong> type. In the same way, the <strong class="source-inline">Failure</strong> type of both must match too.</li>
			</ol>
			<p>The following figure shows a summary of the <strong class="bold">Publisher</strong>:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/Figure_13.1_B14717.jpg" alt="Figure 13.1 – Publisher summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Publisher summary</p>
			<p>Now that we have an initial description of the critical concepts of a publisher, let's do the same with the <strong class="source-inline">Subscriber</strong> protocol.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor451"/>Understanding Subscriber</h2>
			<p>We have seen that <strong class="source-inline">Publisher</strong> entities produce<a id="_idIndexMarker597"/> values over time. Now let's see how <strong class="source-inline">Subscriber</strong> entities <a id="_idIndexMarker598"/>can consume those values. <strong class="source-inline">Publisher</strong> and <strong class="source-inline">Subscriber</strong> work closely together in Combine, so let's see their internal details. The <strong class="source-inline">Subscriber</strong> protocol in Swift looks like this:</p>
			<p class="source-code">public protocol Subscriber : CustomCombineIdentifierConvertible {</p>
			<p class="source-code">    //1</p>
			<p class="source-code">    associatedtype Input</p>
			<p class="source-code">    //2</p>
			<p class="source-code">    associatedtype Failure : Error</p>
			<p class="source-code">    //3</p>
			<p class="source-code">    func receive(subscription: Subscription)</p>
			<p class="source-code">    //4</p>
			<p class="source-code">    func receive(_ input: Self.Input) -&gt; Subscribers.Demand</p>
			<p class="source-code">    //5</p>
			<p class="source-code">    func receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)</p>
			<p class="source-code">}</p>
			<p>Again, let's review each numbered line:</p>
			<ol>
				<li value="1">A <strong class="source-inline">Subscriber</strong> entity is going to receive values over time. The associated type <strong class="source-inline">Input</strong> defines the type of those values. </li>
				<li>At the same time, the <strong class="source-inline">Subscriber</strong> can<a id="_idIndexMarker599"/> also receive errors, and the associated type <strong class="source-inline">Failure</strong> is used to define the type of those errors. If a <strong class="source-inline">Subscriber</strong> never receives errors, the <strong class="source-inline">Failure</strong> can be defined as type <strong class="source-inline">Never</strong>.</li>
				<li>This method informs the <strong class="source-inline">Subscriber</strong> that the subscription to the <strong class="source-inline">Publisher</strong> is successful and it may start requesting elements.</li>
				<li>Informs the <strong class="source-inline">Subscriber</strong> that the <strong class="source-inline">Publisher</strong> has produced a new item.</li>
				<li>Some subscriptions may end <a id="_idIndexMarker600"/>over time. In those scenarios, this method is called to inform the <strong class="source-inline">Subscriber</strong> that it will not receive any more values. It allows us to execute a completion block before finishing.</li>
			</ol>
			<p>The following figure shows a summary of the <strong class="bold">Subscriber</strong>:</p>
			<div>
				<div id="_idContainer119" class="IMG---Figure">
					<img src="image/Figure_13.2_B14717.jpg" alt="Figure 13.2 – Subscriber summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Subscriber summary</p>
			<p>If we put together both Publisher and Subscriber figures, we have the following schema:</p>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/Figure_13.3_B14717.jpg" alt="Figure 13.3 – Publisher and Subscriber schemas&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Publisher and Subscriber schemas</p>
			<p>Notice how the output-input<a id="_idIndexMarker601"/> and the failure types of the publisher and the<a id="_idIndexMarker602"/> subscriber must be equal.</p>
			<p>Now that we have a basic idea of what a publisher and a subscriber look like, let's see how they communicate. There are three steps, pictured in the following figure:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/Figure_13.4_B14717.jpg" alt="Figure 13.4 – Publisher and Subscriber communication process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Publisher and Subscriber communication process</p>
			<p>The following list describes<a id="_idIndexMarker603"/> the process in more detail:</p>
			<ol>
				<li value="1">In the first step, the <strong class="source-inline">Subscriber</strong> tells the <strong class="source-inline">Publisher</strong> that it wants to subscribe. The <strong class="source-inline">Publisher</strong> sends back<a id="_idIndexMarker604"/> a subscription. The <strong class="source-inline">Subscriber</strong> uses that subscription to start requesting elements. The subscriber can request from N to unlimited values.</li>
				<li>Now the <strong class="source-inline">Publisher</strong> is free to send those values over time. The <strong class="source-inline">Subscriber</strong> will receive those inputs.</li>
				<li>In subscriptions that are not expecting unlimited values, a completion event is sent to the <strong class="source-inline">Subscriber</strong>, so it is aware that the subscription is over.</li>
			</ol>
			<p>Now we have a basic idea of what a<a id="_idIndexMarker605"/> publisher is and what a subscriber is. We also know the steps involved in their communication. That is enough theory! Here is a practical<a id="_idIndexMarker606"/> example of a single publisher sending the values of an array to a subscriber. You can open a new Xcode playground and try the following code:</p>
			<p class="source-code">import Cocoa</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">//1</p>
			<p class="source-code">let publisher = [1,2,3,4].publisher</p>
			<p class="source-code">//2</p>
			<p class="source-code">let subscriber = publisher.sink { element in</p>
			<p class="source-code">  print(element)</p>
			<p class="source-code">}</p>
			<p>In the first comment, we create an array of integers from 1 to 4, and we use the convenience instance property <strong class="source-inline">publisher</strong> from the Sequence protocol to wrap it inside a new <strong class="source-inline">Publisher</strong> instance.</p>
			<p>In the second comment, we use the method <strong class="source-inline">sink</strong> to attach a subscriber to the publisher, defining inside its completion block an action to perform over each value received over time.</p>
			<p>If you execute this code, the output will be like this:</p>
			<p class="source-code">1</p>
			<p class="source-code">2</p>
			<p class="source-code">3</p>
			<p class="source-code">4</p>
			<p>The initial array contained the numbers from 1 to 4, and that is what we printed. But what if we just want to print the <a id="_idIndexMarker607"/>even numbers? How can we transform the data between the <a id="_idIndexMarker608"/>producer and the subscriber? Luckily for us, Combine provides <strong class="bold">Operators</strong> to help us. Let's see more about them next.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor452"/>Understanding Operators</h2>
			<p>An <strong class="bold">Operator</strong> is also a <strong class="bold">Publisher</strong>. It sits between <a id="_idIndexMarker609"/>a publisher and a <a id="_idIndexMarker610"/>subscriber. We say that an <a id="_idIndexMarker611"/>operator subscribes to a publisher ("upstream") and sends results to a subscriber ("downstream"). Operators can also be chained in sequence. In this section, we are going to review some operators with example code: <strong class="source-inline">filter</strong>, <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, <strong class="source-inline">scan</strong>, <strong class="source-inline">combineLatest</strong>, <strong class="source-inline">merge</strong>, and <strong class="source-inline">zip</strong>.</p>
			<h3>Using filter</h3>
			<p>The <strong class="source-inline">filter</strong> operator is used to<a id="_idIndexMarker612"/> just remove values matching some condition out of the stream.</p>
			<p>Let's see a fundamental example <a id="_idIndexMarker613"/>using the <strong class="source-inline">filter</strong> operator. Imagine that from the previous array (<strong class="source-inline">[1,2,3,4]</strong>), we only want to print the even numbers of the array. We do it as follows:</p>
			<p class="source-code">import Cocoa</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let publisher = [1,2,3,4].publisher</p>
			<p class="source-code">let subscriber = publisher</p>
			<p class="source-code"><strong class="bold">  .filter { $0 % 2 == 0}</strong></p>
			<p class="source-code">  .sink { print($0) }</p>
			<p>Note how the <strong class="source-inline">filter</strong> operator sits between the publisher and the subscriber, and defines a modification of the elements in a declarative way. </p>
			<p>If you run this code, you will obtain the following result in the console:</p>
			<p class="source-code">2</p>
			<p class="source-code">4</p>
			<p>Now let's see another example of how operators can be handy when working with Combine. Remember that the first rule of the subscriber and publisher is that the <strong class="source-inline">Input</strong> of the subscriber must be <a id="_idIndexMarker614"/>equal to the <strong class="source-inline">Output</strong> of the publisher. What happens when they <a id="_idIndexMarker615"/>are not equal? Well, operators can help us to transform the <strong class="source-inline">Output</strong> of a publisher to adapt it to the proper <strong class="source-inline">Input</strong> type of the subscriber. One of the operators that helps us is <strong class="source-inline">map</strong>. </p>
			<h3>Using map</h3>
			<p>The <strong class="source-inline">map</strong> operator <a id="_idIndexMarker616"/>helps us to apply a certain<a id="_idIndexMarker617"/> operation to every value of the stream, transforming it into a different type.</p>
			<p>The following code uses the <strong class="source-inline">map</strong> operator to transform the <strong class="source-inline">Output</strong> of a publisher (<strong class="source-inline">int</strong> values) into the <strong class="source-inline">Input</strong> that our subscriber needs (<strong class="source-inline">User</strong> instances):</p>
			<p class="source-code">let publisher = [1,2,3,4].publisher</p>
			<p class="source-code">let subscriber = publisher</p>
			<p class="source-code"><strong class="bold">  .map { return User(id: $0)}</strong></p>
			<p class="source-code">  .sink { print($0.description()) }</p>
			<p>The <strong class="source-inline">map</strong> operator is transforming a stream of <strong class="source-inline">Int</strong> values [<strong class="source-inline">1,2,3,4</strong>] into a stream of <strong class="source-inline">User</strong> instances. When we use the <strong class="source-inline">sink</strong>, we can call the <strong class="source-inline">description()</strong> method of those users.</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/Figure_13.5_B14717.jpg" alt="Figure 13.5 – Using map to transform outputs on the stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – Using map to transform outputs on the stream</p>
			<p>The previous figure<a id="_idIndexMarker618"/> represents how <strong class="source-inline">map</strong> changes the <strong class="bold">Output</strong> type (while the <strong class="bold">Failure</strong> type, in this case, keeps <a id="_idIndexMarker619"/>being the same). When working with<a id="_idIndexMarker620"/> Combine, using this kind of graph (on a document or just in your mind) can be really helpful to work with the proper <a id="_idIndexMarker621"/>types at every step of the stream.</p>
			<p>There are more operators available rather than just <strong class="source-inline">filter</strong> and <strong class="source-inline">map</strong>. Let's see other useful ones like <strong class="source-inline">reduce</strong>, <strong class="source-inline">scan</strong>, <strong class="source-inline">combineLatest</strong>, <strong class="source-inline">merge</strong>, and <strong class="source-inline">zip</strong>.</p>
			<h3>Using reduce</h3>
			<p>The <strong class="source-inline">reduce</strong> operator returns the<a id="_idIndexMarker622"/> result of combining all the values of the stream <a id="_idIndexMarker623"/>using a given operation to apply. </p>
			<p>You can try out the following examples in an Xcode playground. Go ahead and check this example of <strong class="source-inline">reduce</strong>:</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let reduceExample = [1,2,3,4].publisher</p>
			<p class="source-code"><strong class="bold">  .reduce(1, { $0 * $1 })</strong></p>
			<p class="source-code">  .sink(receiveValue: { print ("\($0)", terminator: " ") })</p>
			<p>If you execute this code, the output in the console is as follows:</p>
			<p class="source-code">24</p>
			<p>If you have used the regular <strong class="source-inline">reduce</strong> function from the Swift standard library, the <strong class="source-inline">reduce</strong> version from <a id="_idIndexMarker624"/>Combine should be easy to understand. It works the same but using values that come from a publisher. What <strong class="source-inline">reduce</strong> does is apply an <a id="_idIndexMarker625"/>operation and accumulate the result for the next value, starting with a given value. In our example, <strong class="source-inline">1, { $0 * $1 }</strong>, the first param is the initial value, hence <strong class="source-inline">1</strong>, and the following param is the operation to perform: multiply the current value (stored as <strong class="source-inline">$0</strong>) by the next incoming value (<strong class="source-inline">$1</strong>), and keep it for the next iteration. So, if our input is <strong class="source-inline">[1,2,3,4]</strong> and our starting value is <strong class="source-inline">1</strong>, what <strong class="source-inline">reduce</strong> is doing is <em class="italic">1 x 1 x 2 x 3 x 4 = 24</em>. The next operator that we are going to explain is very similar to reduce. Let's jump into <strong class="source-inline">scan</strong>.</p>
			<h3>Using scan</h3>
			<p>An operator very much <a id="_idIndexMarker626"/>related to <strong class="source-inline">reduce</strong> is <strong class="source-inline">scan</strong>. The <strong class="source-inline">scan</strong> operator does <a id="_idIndexMarker627"/>exactly the same as <strong class="source-inline">reduce</strong> but it emits the result at each step. Check this code:</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let scanExample = [1,2,3,4].publisher</p>
			<p class="source-code"><strong class="bold">  .scan(1, { $0 * $1 })</strong></p>
			<p class="source-code">  .sink(receiveValue: { print ("\($0)", terminator: " ") })</p>
			<p>Now, executing this will result in the following output:</p>
			<p class="source-code">1 2 6 24</p>
			<p>As you can see, it is giving us the same final result as <strong class="source-inline">reduce</strong> (<strong class="bold">24</strong>), but <strong class="source-inline">scan</strong> emits a value in each step, not just at the end. So, with <strong class="source-inline">scan</strong>, we get the following values over time:</p>
			<ul>
				<li>1x1 = <strong class="bold">1</strong></li>
				<li>1x2 = <strong class="bold">2</strong></li>
				<li>2x3 = <strong class="bold">6</strong></li>
				<li>6x4 = <strong class="bold">24</strong></li>
			</ul>
			<p>These operators (<strong class="source-inline">filter</strong>, <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, and <strong class="source-inline">scan</strong>) helped us to transform the values coming from another publisher. But some <a id="_idIndexMarker628"/>operators combine multiple <a id="_idIndexMarker629"/>publishers' input into one single stream output. Let's see some of them: <strong class="source-inline">combineLatest</strong>, <strong class="source-inline">merge</strong>, and <strong class="source-inline">zip</strong>.</p>
			<h3>Using combineLatest</h3>
			<p>It is a publisher that combines<a id="_idIndexMarker630"/> the latest values from two other publishers. Both<a id="_idIndexMarker631"/> publishers must have the same failure type. The downstream subscriber will receive a tuple of the most recent elements from the upstream publishers when any of them emit a new value.</p>
			<p>Try the following code in a playground:</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let chars = PassthroughSubject&lt;String, Never&gt;()</p>
			<p class="source-code">let numbers = PassthroughSubject&lt;Int, Never&gt;()</p>
			<p class="source-code">let cancellable = <strong class="bold">chars.combineLatest(numbers)</strong></p>
			<p class="source-code">    .sink { print("Result: \($0).") }</p>
			<p class="source-code">chars.send("a")</p>
			<p class="source-code">numbers.send(1)</p>
			<p class="source-code">chars.send("b")</p>
			<p class="source-code">chars.send("c")</p>
			<p class="source-code">numbers.send(2)</p>
			<p class="source-code">numbers.send(3)</p>
			<p>The output on the console is as follows:</p>
			<p class="source-code">Result: ("a", 1).</p>
			<p class="source-code">Result: ("b", 1).</p>
			<p class="source-code">Result: ("c", 1).</p>
			<p class="source-code">Result: ("c", 2).</p>
			<p class="source-code">Result: ("c", 3).</p>
			<p>Notice how we don't have any <a id="_idIndexMarker632"/>output until <strong class="source-inline">("a", 1).</strong>, which means that <strong class="source-inline">combineLatest</strong> doesn't produce any output until all the inputs send<a id="_idIndexMarker633"/> an initial value. After that, it will produce a value every time an input sends a new value, sending the latest from each of the inputs.</p>
			<p>There are also other versions of <strong class="source-inline">combineLatest</strong> to combine three or even four inputs, instead of just two: <strong class="source-inline">combineLatest3</strong>, <strong class="source-inline">combineLatest4</strong>.</p>
			<p>What if we only want to have the latest output of any of the input publishers (meaning just a value, not a tuple)? For those cases, we can use <strong class="source-inline">merge</strong>.</p>
			<h3>Using merge</h3>
			<p>With <strong class="source-inline">merge</strong>, we will aggregate<a id="_idIndexMarker634"/> multiple input publishers into a single stream, and the <a id="_idIndexMarker635"/>output will be just the latest value from any of them. Check out this code in a playground:</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let oddNumbers = PassthroughSubject&lt;Int, Never&gt;()</p>
			<p class="source-code">let evenNumbers = PassthroughSubject&lt;Int, Never&gt;()</p>
			<p class="source-code">let cancellable = <strong class="bold">oddNumbers.merge(with: evenNumbers)</strong></p>
			<p class="source-code">    .sink { print("Result: \($0).") }</p>
			<p class="source-code">oddNumbers.send(1)</p>
			<p class="source-code">evenNumbers.send(2)</p>
			<p class="source-code">oddNumbers.send(3)</p>
			<p>The output will be as follows:</p>
			<p class="source-code">Result: 1.</p>
			<p class="source-code">Result: 2.</p>
			<p class="source-code">Result: 3.</p>
			<p>As you can see, the output is one<a id="_idIndexMarker636"/> value at a time, which differs from the tuple with all the latest values from all the inputs that we got with <strong class="source-inline">combineLatest</strong>.</p>
			<p>There is another useful method to<a id="_idIndexMarker637"/> work with multiple publishers. Let's see what <strong class="source-inline">zip</strong> can do.</p>
			<h3>Using zip</h3>
			<p><strong class="source-inline">zip</strong> is a publisher that emits<a id="_idIndexMarker638"/> a pair of elements when both input publishers have emitted a <a id="_idIndexMarker639"/>new value. Let's see how it differs from <strong class="source-inline">combineLatest</strong> with the same example. Execute the following code in a playground:</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let chars = PassthroughSubject&lt;String, Never&gt;()</p>
			<p class="source-code">let numbers = PassthroughSubject&lt;Int, Never&gt;()</p>
			<p class="source-code">let cancellable = chars.zip(numbers)</p>
			<p class="source-code">    .sink { print("Result: \($0).") }</p>
			<p class="source-code">chars.send("a")</p>
			<p class="source-code">numbers.send(1)</p>
			<p class="source-code">// combineLatest output:  (a,1)</p>
			<p class="source-code">// zip output:            (a, 1)</p>
			<p class="source-code">chars.send("b")</p>
			<p class="source-code">// combineLatest output:  (b,1)</p>
			<p class="source-code">// zip output:            nothing</p>
			<p class="source-code">chars.send("c")</p>
			<p class="source-code">// combineLatest output:  (c,1)</p>
			<p class="source-code">// zip output:            nothing</p>
			<p class="source-code">numbers.send(2)</p>
			<p class="source-code">// combineLatest output:  (c,2)</p>
			<p class="source-code">// zip output:            (b,2)</p>
			<p class="source-code">numbers.send(3)</p>
			<p class="source-code">// combineLatest output:  (c,3)</p>
			<p class="source-code">// zip output:            (c,3)</p>
			<p>Check out the comments<a id="_idIndexMarker640"/> under each line, representing what <strong class="source-inline">combineLatest</strong> and <strong class="source-inline">zip</strong> will output every given time. Notice how <strong class="source-inline">zip</strong> doesn't send a new pair of values downstream until both of the publishers have emitted a new value. And when that happens, it will send a tuple with the oldest non-emitted values of both of them. <strong class="source-inline">CombineLatest</strong> will use the <a id="_idIndexMarker641"/>most recent and will emit a tuple every time one of the publishers emits a single new value (it will not wait to have both publishers emitting!). That is the main difference.</p>
			<p>With the basics about publisher, subscriber, and operator entities explained, let's see another useful entity in Combine in the next section: <strong class="bold">Subject</strong>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor453"/>Understanding Subject</h2>
			<p>As per the<a id="_idIndexMarker642"/> Apple documentation:</p>
			<p class="author-quote">"A subject is a publisher that exposes a method for outside callers to publish elements."</p>
			<p>The definition is pretty straightforward. Subjects<a id="_idIndexMarker643"/> are like publishers, but they have a method, <strong class="source-inline">send(_:)</strong>, which you can use to inject new elements into their stream. A single <strong class="source-inline">Subject</strong> allows multiple subscribers to be connected at the same time.</p>
			<p>There are two types of built-in subjects: <strong class="source-inline">CurrentValueSubject</strong> and <strong class="source-inline">PassthroughSubject</strong>. Let's see the differences between them.</p>
			<h3>Working with CurrentValueSubject</h3>
			<p>This is a subject that holds<a id="_idIndexMarker644"/> an initial value. It broadcasts the current value every time it changes. </p>
			<p>When a subscriber connects to a <strong class="source-inline">CurrentValueSubject</strong>, it will receive the current value, and the next ones when it changes. This means that a <strong class="source-inline">CurrentValueSubject</strong> has state. Here is an example (you can try this code in a playground):</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let currentValueSubject = <strong class="bold">CurrentValueSubject&lt;String, Never&gt;("first value")</strong></p>
			<p class="source-code">let subscriber = currentValueSubject.sink { print("received: \($0)") }</p>
			<p class="source-code">currentValueSubject.send("second value")</p>
			<p>If you execute this code, the output looks like this:</p>
			<p class="source-code">received: first value</p>
			<p class="source-code">received: second value</p>
			<p>Here are the interesting bits:</p>
			<ul>
				<li>When we initialize the subject, we need to pass an initial value.</li>
				<li>When the subscriber subscribes, it gets the current value that is held in the subject. Note how in the console output, the subscriber has printed <strong class="source-inline">first value</strong> even though we subscribed to the subject after that value was generated.</li>
				<li>Every time we call <strong class="source-inline">send(_:)</strong>, the subscribers get the next value.</li>
			</ul>
			<p>Now, let's see the other<a id="_idIndexMarker645"/> built-in type of subject, <strong class="source-inline">PassthroughSubject</strong>.</p>
			<h3>Working with PassthroughSubject</h3>
			<p>The main difference<a id="_idIndexMarker646"/> between <strong class="source-inline">PassthroughSubject</strong> and <strong class="source-inline">CurrentValueSubject</strong> is that <strong class="source-inline">PassthroughSubject</strong> doesn't hold any state. Check the following code (you can try it out in a playground):</p>
			<p class="source-code">import Combine</p>
			<p class="source-code">let passthroughSubject = PassthroughSubject&lt;String, Never&gt;()</p>
			<p class="source-code">passthroughSubject.send("first value")</p>
			<p class="source-code">let subscriber = passthroughSubject.sink { print("received: \($0)")}</p>
			<p class="source-code">passthroughSubject.send("second value")</p>
			<p>If you execute this code, here is the output:</p>
			<p class="source-code">received: second value</p>
			<p>Notice how the subscriber is created after the first value is sent. This first value is not received, because there was no subscriber connected yet. However, the second value is displayed in the output because it was sent after the subscription was established.</p>
			<p>We have seen the basic usage of <strong class="source-inline">Publisher</strong>, <strong class="source-inline">Subscriber</strong>, <strong class="source-inline">Operator</strong>, and <strong class="source-inline">Subject</strong>. Let's now create a bigger and more complex example to see how to apply Combine concepts to real-world apps.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor454"/>Combining Publishers, Subscribers, and Operators</h1>
			<p>In this section, we are <a id="_idIndexMarker647"/>going to mix the concepts of the<a id="_idIndexMarker648"/> previous section altogether in a real-world example feature. Let's assume that we have an app that <a id="_idIndexMarker649"/>contains a newsletter, and we allow the users to subscribe to the newsletter by entering their email address, using two <strong class="source-inline">UITextFields</strong>: the <strong class="bold">Email</strong> and <strong class="bold">Repeat Email</strong> fields. Let's <a id="_idIndexMarker650"/>assume that in our business logic, we need to check that the email is correct, and we are going to do the <a id="_idIndexMarker651"/>following checks:</p>
			<ul>
				<li>Local check: We will ask <a id="_idIndexMarker652"/>users to repeat the email address twice, and both should be the same.</li>
				<li>Local check: The email should contain an "@".</li>
				<li>Local check: The email should be five characters long, at least.</li>
				<li>Remote check: We will also assume that we have a remote method to check in the backend that the email is unique, meaning it doesn't exist yet.</li>
			</ul>
			<p>Once all these conditions match, we will enable a <strong class="bold">Sign-Up</strong> button in the user interface. We will use Combine to add all this business logic into an example app. Open the <strong class="bold">CombineExample_start</strong> project and launch it. You will see a screen where you can input an email address, and another <strong class="source-inline">UITextfield</strong> to repeat it. You will also see a <strong class="bold">Sign-up</strong> button, but it is always disabled (for now). Let's implement the business logic step by step to improve this. We are going to start by implementing the three local checks described in the list above. And we are going to use a handy Combine operator for this: <strong class="source-inline">combineLatest</strong>.</p>
			<p>Open the <strong class="source-inline">ViewController.swift</strong> file. You will notice a couple of vars that are tagged with the property wrapper <strong class="source-inline">@Published</strong>:</p>
			<p class="source-code">@Published var initialEmail: String = ""</p>
			<p class="source-code">@Published var repeatedEmail: String = ""</p>
			<p>What <strong class="source-inline">@Published</strong> is doing here is creating a Publisher from the property itself. So, every time <strong class="source-inline">initialEmail</strong> or <strong class="source-inline">repeatedEmail</strong> values change, they will get published to anyone subscribed to them. You can access the publisher of <strong class="source-inline">initialEmail</strong> by using <strong class="source-inline">$initialEmail</strong> (prefix a <strong class="source-inline">$</strong> to the property name). Notice the two <strong class="source-inline">IBActions</strong> defined in the same class:</p>
			<p class="source-code">@IBAction func emailChanged(_ sender: UITextField) {</p>
			<p class="source-code">  initialEmail = sender.text ?? ""</p>
			<p class="source-code">}</p>
			<p class="source-code">@IBAction func repeatedEmailChanged(_ sender: UITextField) {</p>
			<p class="source-code">  repeatedEmail = sender.text ?? ""</p>
			<p class="source-code">}</p>
			<p>By combining <strong class="source-inline">IBAction</strong> and <strong class="source-inline">@Published</strong>, we are creating a funnel in which every time the user<a id="_idIndexMarker653"/> types something in the <strong class="source-inline">initialEmail</strong> <strong class="source-inline">UITextField</strong>, it will get published<a id="_idIndexMarker654"/> through the <strong class="source-inline">$initialEmail</strong> publisher.</p>
			<p>Why is this handy? Remember<a id="_idIndexMarker655"/> that according to the business<a id="_idIndexMarker656"/> logic defined above, we need to ensure that both <strong class="source-inline">initialEmail</strong> and <strong class="source-inline">repeatedEmail</strong> are equal. Now we have<a id="_idIndexMarker657"/> two publishers that will emit their value<a id="_idIndexMarker658"/> every time the user types in either of the two text fields. How can we combine those two values to compare them? The Combine framework has the perfect method for this: <strong class="source-inline">CombineLatest</strong>. Add the following vars to the <strong class="source-inline">ViewController.swift</strong> file:</p>
			<p class="source-code">var validatedEmail: AnyPublisher&lt;String?, Never&gt; {</p>
			<p class="source-code">  return Publishers</p>
			<p class="source-code">    .CombineLatest($initialEmail, $repeatedEmail) //1</p>
			<p class="source-code">    .map { (email, repeatedEmail) -&gt; String? in  //2</p>
			<p class="source-code">      guard email == repeatedEmail, email.contains("@"), email.count &gt; 5 else { return nil }</p>
			<p class="source-code">      return email</p>
			<p class="source-code">    }</p>
			<p class="source-code">    .eraseToAnyPublisher() //3</p>
			<p class="source-code">}</p>
			<p class="source-code">var cancellable: AnyCancellable? //4</p>
			<p>Let's analyze the code comment by comment:</p>
			<ol>
				<li value="1">First, we are using <strong class="source-inline">Publishers.CombineLatest</strong> to combine two different publishers into one: <strong class="source-inline">$initialEmail</strong> and <strong class="source-inline">$repeatedEmail</strong>. This will result in a new stream (publisher) of type <strong class="source-inline">Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;</strong>. Don't let the long type scare you. It means "a publisher <a id="_idIndexMarker659"/>of two string publishers." The magic of <strong class="source-inline">CombineLatest</strong> is that if either of the two<a id="_idIndexMarker660"/> inputs changes, you will get the new value, but also the latest value that the other input had, which is very <a id="_idIndexMarker661"/>useful for cases like this.</li>
				<li>Second, we are <a id="_idIndexMarker662"/>applying the <strong class="source-inline">map</strong> operator over the "publisher of two string publishers." By using <strong class="source-inline">map</strong>, we are unwrapping the<a id="_idIndexMarker663"/> underlaying published strings to be able to<a id="_idIndexMarker664"/> use the string themselves and return a different result after working with them. Here is where we apply our business rules: If both emails are equal, they include an "@" and they are longer than five characters long, we return the <strong class="source-inline">email</strong>. Otherwise, we return <strong class="source-inline">nil</strong>. So, with <strong class="source-inline">map</strong>, we are transforming a stream output type into a new one, to adapt it to what we need.</li>
				<li>At this point, if we inspect the type of what we have, you will see this: <strong class="source-inline">Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt;</strong>. That is quite complex to read and use. But Combine provides us with a way to simplify this, because what is important is what is inside of the publisher itself, not all the wrappers around it. By using <strong class="source-inline">eraseToAnyPublisher</strong>, we are changing this type to just <strong class="source-inline">AnyPublisher&lt;String?, Never&gt;</strong>. This is much easier to understand and use (and if you want to publish it in an API, for example, it's much easier to digest by other developers).</li>
				<li>We create a cancellable<a id="_idIndexMarker665"/> property var to use it in the following piece of code.</li>
			</ol>
			<p>This flow can be<a id="_idIndexMarker666"/> represented as follows</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_13.6_B14717.jpg" alt="Figure 13.6 – validatedEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – validatedEmail stream</p>
			<p>Now, add this line of code to the <strong class="source-inline">viewDidLoad()</strong> method:</p>
			<p class="source-code">cancellable = validatedEmail.sink { print($0) }</p>
			<p>By calling <strong class="source-inline">sink</strong>, we are attaching a subscriber to the <strong class="source-inline">validatedEmail</strong> publisher, and we store it in our <a id="_idIndexMarker667"/>new <strong class="source-inline">var</strong> property <strong class="source-inline">cancellable</strong>. Every time we<a id="_idIndexMarker668"/> receive a new value, we will just print it into the console for testing purposes. Let's try it out! Execute the app and type any email address (in both fields) that fulfills all the <a id="_idIndexMarker669"/>conditions (for example, <strong class="source-inline">abc@email.com</strong>).</p>
			<p>When you type valid <a id="_idIndexMarker670"/>addresses, you will see it in the console. When the addresses are not valid, you will see <strong class="source-inline">nil</strong>.</p>
			<p>We have seen a lot of new Combine concepts packed into very little code. Before continuing with our demo project, we are going to look at a quick summary of these new concepts:</p>
			<ul>
				<li>The <strong class="source-inline">@Published</strong> property wrapper: Allows us to create a Publisher from a property variable. We can access the publisher by prefixing <strong class="source-inline">$</strong> to the name of the property. It only works on class properties, not on structs. </li>
				<li><strong class="source-inline">Publishers.CombineLatest</strong>: Allows us to combine two publishers into a single one that will always push<a id="_idIndexMarker671"/> the latest value of each one when there is a change (or <strong class="source-inline">nil</strong>, if there wasn't a previous value).</li>
				<li><strong class="source-inline">map</strong>: Allows us to<a id="_idIndexMarker672"/> transform the stream. We apply a <strong class="source-inline">map</strong> to a <a id="_idIndexMarker673"/>publisher with an <strong class="source-inline">Output</strong> type and we can transform it into a new, different <strong class="source-inline">Output</strong>. </li>
				<li><strong class="source-inline">eraseToAnyPublisher</strong>: Allows us to erase complex types to work with easier <strong class="source-inline">AnyPublisher&lt;Otutput, Failure&gt;</strong> streams. This is very handy when publishing our classes as an API, for example.</li>
			</ul>
			<p>After this little recap, we<a id="_idIndexMarker674"/> still have one feature pending to fulfill the list <a id="_idIndexMarker675"/>of requirements. We have<a id="_idIndexMarker676"/> implemented three local checks on the email addresses, but we still need to do the last one, which was this:</p>
			<ul>
				<li>Remote check: We will also assume that we have a remote method to check in the backend that the email is unique, meaning it doesn't exist yet.</li>
			</ul>
			<p>In the <strong class="source-inline">ViewController.swift</strong> file, there is a dummy method named <strong class="source-inline">func emailAvailable(…)</strong>. It just returns a completion block. This method is intended to represent a network call that returns <strong class="source-inline">True</strong> or <strong class="source-inline">False</strong> in the completion block according to whether the email already exists in the backend or not. For demo purposes, we are not going to implement the network call itself, just simulate the result.</p>
			<p>Let's implement this feature with Combine. We are going to create a new publisher that will emit a Bool indicating whether the email that the user types exists in the backend or not, using a fake network call, <strong class="source-inline">emailAvailable(…)</strong>. Add the following code to the <strong class="source-inline">ViewController.swift</strong> file:</p>
			<p class="source-code">var isNewEmail: AnyPublisher&lt;Bool, Never&gt; { //1</p>
			<p class="source-code">  return $initialEmail //2</p>
			<p class="source-code">    .debounce(for: 1, scheduler: RunLoop.main) //3</p>
			<p class="source-code">    .removeDuplicates() //4</p>
			<p class="source-code">    .flatMap { email in //5</p>
			<p class="source-code">      return Future { promise in</p>
			<p class="source-code">        self.emailAvailable(email) { available in</p>
			<p class="source-code">          promise(.success(available))</p>
			<p class="source-code">        }</p>
			<p class="source-code">      }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    .eraseToAnyPublisher()</p>
			<p class="source-code">}</p>
			<p>There are a lot of new concepts here, so let's go through the numbered comments one by one:</p>
			<ol>
				<li value="1">We are defining<a id="_idIndexMarker677"/> a new publisher, <strong class="source-inline">isNewEmail</strong>, of type <strong class="source-inline">&lt;Bool, Never&gt;</strong>. This publisher will help us to emit events that indicate<a id="_idIndexMarker678"/> whether the email that the user is typing exists in our database or not.</li>
				<li>To fetch any new<a id="_idIndexMarker679"/> value that the user types in the email<a id="_idIndexMarker680"/> field, we start by using the published property defined earlier in the <strong class="source-inline">$initialEmail</strong> section.</li>
				<li>Users can type/delete in<a id="_idIndexMarker681"/> text fields pretty fast. Our<a id="_idIndexMarker682"/> goal is to make a network call every time we receive a new value through the <strong class="source-inline">$initialEmail</strong> publisher (meaning every time the user is typing in the email field). That means that we will query the network a bit too much. The Combine <strong class="source-inline">.debounce</strong> method will help us to reduce the number of values we are processing. By using <strong class="source-inline">.debounce</strong>(<strong class="source-inline">1…)</strong>, we specify that from all the values that we get from <strong class="source-inline">$initialEmail</strong>, we will only process a value every <strong class="source-inline">1</strong> second. The rest of the values will be<a id="_idIndexMarker683"/> discarded. This is very helpful when working with publishers that are connected to the user interface and the network (text fields, buttons, search bars, and so on).</li>
				<li>Another useful<a id="_idIndexMarker684"/> method is <strong class="source-inline">removeDuplicates()</strong>. If the user types "<strong class="source-inline">abc</strong>" and then deletes the "<strong class="source-inline">c</strong>" to quickly type the "<strong class="source-inline">c</strong>" back, we will make several calls. But if we use <strong class="source-inline">removeDuplicates()</strong>, we will avoid this unnecessary behavior.</li>
				<li>The fifth step is a bit more <a id="_idIndexMarker685"/>complicated. This is where we<a id="_idIndexMarker686"/> perform a network call. First, we have a <strong class="source-inline">.flatMap</strong> wrapping everything. This function transforms elements from a publisher into a new type of publisher. Inside the <strong class="source-inline">flatMap</strong>, we have a <strong class="source-inline">Future</strong>. A <strong class="source-inline">Future</strong> is a publisher that eventually emits a single value and then finishes (or fails). Inside the <strong class="source-inline">Future</strong>, we have a <strong class="source-inline">Promise</strong>: A <strong class="source-inline">Promise</strong> in Combine is a <strong class="source-inline">typealias</strong> for a closure that takes a <strong class="source-inline">Result</strong>. Now let's describe the whole process again, but from inside out: The network call <strong class="source-inline">emailAvailable</strong> returns<a id="_idIndexMarker687"/> a result in the form of <strong class="source-inline">promise.success(…)</strong>. This Promise is wrapped in a Future, to become a publisher stream. That stream is a <strong class="source-inline">Future&lt;Bool, Never&gt;</strong> at this point. Now, we wrap <a id="_idIndexMarker688"/>everything with <strong class="source-inline">flatMap</strong>, so the upstream <strong class="source-inline">initialEmail: Published&lt;String&gt;.Publisher</strong> becomes <strong class="source-inline">AnyPublisher&lt;Bool, Never&gt;</strong> (with the help of <strong class="source-inline">eraseToAnyPublisher</strong> too).</li>
			</ol>
			<p>Here is the full flow to generate <strong class="source-inline">isNewEmail</strong>:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_13.7_B14717.jpg" alt="Figure 13.7 – isNewEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – isNewEmail stream</p>
			<p>So, after all this chain<a id="_idIndexMarker689"/> of transformations, we have a publisher, <strong class="source-inline">isNewEmail</strong>, that will emit a <strong class="source-inline">Bool</strong> indicating whether an email address is unique or <a id="_idIndexMarker690"/>not in our backend every time (almost, except <a id="_idIndexMarker691"/>duplicates and debounced) the user<a id="_idIndexMarker692"/> types in the UI! That is pretty cool! And it's very useful for our business logic checks.</p>
			<p>Our last step is going to be to <a id="_idIndexMarker693"/>combine the publisher of the local checks (<strong class="source-inline">validatedEmail</strong>) with the remote publisher (<strong class="source-inline">isNewEmail</strong>) to have a final output. The business logic required to enable the <strong class="bold">Sign-up</strong> button is that these publishers emit a valid email <strong class="source-inline">String</strong> and a <strong class="source-inline">True</strong> value, so all our conditions are met. What is the <a id="_idIndexMarker694"/>best way to combine the latest values of two different publishers and work with them? We just used it above! It is <strong class="source-inline">combineLatest</strong>. Add the following code to the <strong class="source-inline">ViewController.swift</strong> file:</p>
			<p class="source-code">var finalEmail: AnyPublisher&lt;String?, Never&gt; {</p>
			<p class="source-code">  return Publishers.CombineLatest(validatedEmail, isNewEmail).map { (email, isNew) -&gt; String? in</p>
			<p class="source-code">    guard isNew else { return nil }</p>
			<p class="source-code">    return email</p>
			<p class="source-code">  }</p>
			<p class="source-code">  .eraseToAnyPublisher()</p>
			<p class="source-code">}</p>
			<p>As detailed in the preceding code, we are using <strong class="source-inline">CombineLatest</strong> to work with the latest values of two different publishers. From <strong class="source-inline">validatedEmail</strong>, we get a valid email or a <strong class="source-inline">nil</strong> value <a id="_idIndexMarker695"/>otherwise. From <strong class="source-inline">isNewEmail</strong>, we get a <strong class="source-inline">Bool</strong> indicating whether the email exists in the database or not. The result of this is a<a id="_idIndexMarker696"/> new publisher, <strong class="source-inline">finalEmail</strong>, of type <strong class="source-inline">&lt;String?, Never&gt;</strong>. See the flow in the next figure:</p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_13.8_B14717.jpg" alt="Figure 13.8 – finalEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8 – finalEmail stream</p>
			<p>Now, how can we<a id="_idIndexMarker697"/> enable and disable the <strong class="bold">Sign-up</strong> button using <a id="_idIndexMarker698"/>this new publisher? Add the following code inside the <strong class="source-inline">viewDidLoad</strong> function and let's explain it in detail:</p>
			<p class="source-code">signupButtonCancellable = finalEmail</p>
			<p class="source-code">  .map { $0 != nil }</p>
			<p class="source-code">  .receive(on: RunLoop.main)</p>
			<p class="source-code">  .assign(to: \.isEnabled, on: signupButton)</p>
			<p>In this code, we start with the <strong class="source-inline">finalEmail</strong> publisher <strong class="source-inline">(&lt;String?, Never&gt;</strong>), we <strong class="source-inline">map</strong> over it, transforming<a id="_idIndexMarker699"/> the stream into <strong class="source-inline">&lt;Bool, Never&gt;</strong>, then we apply <strong class="source-inline">.receive</strong> to make sure we are executing this in the main thread (because we<a id="_idIndexMarker700"/> are handling the UI here, a <strong class="source-inline">UIButton</strong>). Finally, we assign the value inside the stream <strong class="source-inline">(&lt;Bool&gt;</strong>) to the <strong class="source-inline">signupButton</strong> <strong class="source-inline">isEnabled</strong> property! Check out the next figure, which details the steps of the stream:</p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_13.9_B14717.jpg" alt="Figure 13.9 – Assigning finalEmail to signUpButton&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9 – Assigning finalEmail to signUpButton</p>
			<p>And that is it<a href="mailto:abc@email.com">! Execute<span id="_idIndexMarker701"/> th</a>e app, and try it yourself: If you type some email address that matches all the conditions (like <strong class="source-inline">abc@email.com</strong>), the <strong class="bold">Sign-up</strong> button will be enabled. Otherwise, it will be disabled.</p>
			<p>In this section, we<a id="_idIndexMarker702"/> have learned about a lot of new Combine concepts and methods to combine different streams, transform outputs, modify the thread<a id="_idIndexMarker703"/> we are working on, handle<a id="_idIndexMarker704"/> user input, and so on. We used <strong class="source-inline">flatMap</strong> to transform <a id="_idIndexMarker705"/>elements of an upstream<a id="_idIndexMarker706"/> into a different type downstream. However, <strong class="source-inline">flatMap</strong> has more uses. One of them is to help streams recover from errors, with the help of <strong class="source-inline">catch</strong>. In the next section, we are going to see an example of how a stream can fail, and how to recover it using <strong class="source-inline">flatMap</strong> and <strong class="source-inline">catch</strong>.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor455"/>Using Operators to build error-proof streams</h1>
			<p>For this section, go ahead and<a id="_idIndexMarker707"/> open the project in<a id="_idIndexMarker708"/> the code bundle named <strong class="source-inline">PublishersAndSubscribers_start</strong>. Take a look at the file <strong class="source-inline">ViewController.swift</strong>.</p>
			<p>This file contains a <strong class="source-inline">User</strong> struct:</p>
			<p class="source-code">struct User: Codable {</p>
			<p class="source-code">  let id: String</p>
			<p class="source-code">  static var unknown: User {</p>
			<p class="source-code">    return User(id: "-1")</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">User</strong> struct is quite simple. It contains a <strong class="source-inline">String</strong> property <strong class="source-inline">id</strong>, and a <strong class="source-inline">static var</strong> named <strong class="source-inline">unknown</strong> that <a id="_idIndexMarker709"/>returns a <strong class="source-inline">User</strong> instance with <strong class="source-inline">id</strong> equal to <strong class="source-inline">-1</strong>. Apart from the <strong class="source-inline">User</strong> struct, the file contains the <strong class="source-inline">ViewController</strong> itself.</p>
			<p>The view controller <a id="_idIndexMarker710"/>contains two methods: </p>
			<ul>
				<li>First, <strong class="source-inline">postNotification()</strong>: This just fires a notification in the Notification Center that contains a <strong class="source-inline">User</strong> instance with <strong class="source-inline">id</strong> equal to <strong class="source-inline">123</strong>. The name of the notification is <strong class="source-inline">networkResult</strong>.</li>
				<li>Second, <strong class="source-inline">postNotificationThatFails()</strong>: This just fires a notification in the Notification Center that contains random data that is Base-64 encoded, not a <strong class="source-inline">User</strong> instance this time. The name of the notification is <strong class="source-inline">networkResult.</strong></li>
			</ul>
			<p>We will use Combine to consume these two notifications. Both methods represent a dummy network call, whose result is being sent through the Notification Center in this way. So, think of them as the network call response that you will fetch from your backend when trying to query for some object (a user in this case) and propagate to your app with notifications.</p>
			<p>Now, let's try to call <strong class="source-inline">postNotification()</strong> and consume the result using Combine. In the <strong class="source-inline">viewDidLoad()</strong> method, call <strong class="source-inline">postNotification()</strong>:</p>
			<p class="source-code">override func viewDidLoad() {</p>
			<p class="source-code">  super.viewDidLoad()</p>
			<p class="source-code">  postNotification()</p>
			<p class="source-code">}</p>
			<p>Now let's create a publisher that emits values from the Notification Center and use the <strong class="source-inline">cancellable</strong> property to<a id="_idIndexMarker711"/> consume them as a subscriber. Change the <strong class="source-inline">viewDidLoad()</strong> method to this:</p>
			<p class="source-code">override func viewDidLoad() {</p>
			<p class="source-code">  super.viewDidLoad()</p>
			<p class="source-code">  //1</p>
			<p class="source-code">  let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))</p>
			<p class="source-code">  //2</p>
			<p class="source-code">  cancellable = publisher.sink { item in</p>
			<p class="source-code">    print(item)</p>
			<p class="source-code">  }</p>
			<p class="source-code">  //3</p>
			<p class="source-code">  postNotification()</p>
			<p class="source-code">}</p>
			<p>Let's review the comments by lines:</p>
			<ol>
				<li value="1">First, we are<a id="_idIndexMarker712"/> creating a publisher that emits any value from the Notification Center that arrives under the name <strong class="source-inline">networkResult.</strong> This matches the notification name we are sending in the <strong class="source-inline">postNotification()</strong> method.</li>
				<li>We are subscribing to the publisher created in the previous step, and we store the result in the <strong class="source-inline">cancellable</strong> property. We are using <strong class="source-inline">sink</strong> when creating the subscriber to define a completion block that will print to the console any value received.</li>
				<li>Finally, we post a notification. </li>
			</ol>
			<p>If you execute this code and you check in the console, you should see this result:</p>
			<p class="source-code">name = networkResult, object = Optional(&lt;7b226964 223a2231 3233227d&gt;), userInfo = nil</p>
			<p>This means that our<a id="_idIndexMarker713"/> stream worked! We have sent a notification, our publisher has forwarded it, and our subscriber has printed it into the <a id="_idIndexMarker714"/>console. As you can see on the console output, the notification has three properties: <strong class="source-inline">name</strong>, <strong class="source-inline">object</strong>, and <strong class="source-inline">userInfo</strong>. We want to unwrap what is inside the <strong class="source-inline">object</strong> attribute. So, let's modify our publisher with an operator to transform what our subscriber receives. Change the publisher code for this one:</p>
			<p class="source-code">let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))</p>
			<p class="source-code">  <strong class="bold">.map { notification in return notification.object as! Data }</strong></p>
			<p>Execute it and check the output in the console:</p>
			<p class="source-code">12 bytes</p>
			<p>In this code, we are mapping over the notification value and sending the <strong class="source-inline">object</strong> content as <strong class="source-inline">Data</strong>. In the console output, you can see that our subscriber is receiving those bytes of data now, instead of the full notification. Great! The next step is going to be to transform these bytes of <strong class="source-inline">Data</strong> into a <strong class="source-inline">User</strong> instance. To do that, we need to decode the data. Combine has the perfect helper method for this. Change the publisher code to this:</p>
			<p class="source-code">let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))</p>
			<p class="source-code">  .map { notification in return notification.object as! Data }</p>
			<p class="source-code">  <strong class="bold">.decode(type: User.self, decoder: JSONDecoder())</strong></p>
			<p>By adding the preceding highlighted line, we are using the <strong class="source-inline">Data</strong> from the <strong class="source-inline">map</strong> operation and decoding it into a <strong class="source-inline">User</strong> instance! All in a single line. But if you try to execute now, you will get a <a id="_idIndexMarker715"/>compile error in the subscriber <strong class="source-inline">sink</strong> line saying the following:</p>
			<p class="source-code">Referencing instance method 'sink(receiveValue:)' on 'Publisher' requires the types' Publishers.Decode&lt;Publishers.Map&lt;NotificationCenter.Publisher, JSONDecoder.Input&gt;, User, JSONDecoder&gt;.Failure' (aka 'Error') and 'Never' be equivalent</p>
			<p>This means: If you inspect the <a id="_idIndexMarker716"/>method sink that we are using, you will discover that it requires the <strong class="source-inline">Failure</strong> type of the publisher that is consuming to be <strong class="source-inline">Never</strong>:</p>
			<p class="source-code">extension Publisher where Self.Failure == Never</p>
			<p>After adding the <strong class="source-inline">decode</strong> line, our publisher no longer has a <strong class="source-inline">Never</strong> type as failure, because <strong class="source-inline">decode</strong> can produce errors. So, the compiler is telling you that the types don't match anymore. We need to do something that catches any error produced by <strong class="source-inline">decode</strong> and transforms that into a <strong class="source-inline">Never</strong>-failing operation. Combine has another useful operator that can help us in this scenario: <strong class="source-inline">catch</strong>. Change the publisher code into this new block:</p>
			<p class="source-code">let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))</p>
			<p class="source-code">  .map { notification in return notification.object as! Data }</p>
			<p class="source-code">  .decode(type: User.self, decoder: JSONDecoder())</p>
			<p class="source-code">  <strong class="bold">.catch {_ in</strong></p>
			<p class="source-code"><strong class="bold">    return Just(User.unknown)</strong></p>
			<p class="source-code"><strong class="bold">  }</strong></p>
			<p>Let's explain <strong class="source-inline">catch</strong> in more detail. <strong class="source-inline">catch</strong> will handle any error in the upstream, and instead of crashing the app, it will complete/finish the publisher that produced the error and replace it with a new publisher (that you must provide in the <strong class="source-inline">return</strong> block). </p>
			<p>So in this scenario, if we get an error from the <strong class="source-inline">decode</strong> operation, our notification publisher will finish, and it will be replaced by <strong class="source-inline">Just(User.unknown)</strong>. <strong class="source-inline">Just</strong> is a publisher that only emits one value and then completes. Check the next figure:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_13.10_B14717.jpg" alt="Figure 13.10 – Catch replaces the failed stream with a new one&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10 – Catch replaces the failed stream with a new one</p>
			<p>The top part of the previous figure<a id="_idIndexMarker717"/> shows the stream when <a id="_idIndexMarker718"/>an error happens in the <strong class="source-inline">decode</strong> stage and <strong class="source-inline">catch</strong> enters into action. In the bottom part of the figure, you can see how <strong class="source-inline">catch</strong> drops the initial publisher and replaces it with the one defined in the <strong class="source-inline">catch</strong> block (a <strong class="source-inline">Just</strong> publisher in this case).</p>
			<p>Let's try out what will happen if we provide a value that will produce an error in the <strong class="source-inline">decode</strong> <strong class="source-inline">stage</strong>. At the end of the <strong class="source-inline">viewDidLoad()</strong>, just after <strong class="source-inline">postNotification()</strong>, add this line:</p>
			<p class="source-code">postNotificationThatFails()</p>
			<p>So, we are now sending two notifications, one with user data inside, and the other with a random string. The second<a id="_idIndexMarker719"/> should fail on the <strong class="source-inline">decode</strong> step. Execute the app; you will see this output:</p>
			<p class="source-code">User(id: "123")</p>
			<p class="source-code">User(id: "-1")</p>
			<p>That is great! The first <a id="_idIndexMarker720"/>notification got decoded and transformed into a proper user. The second failed to be decoded, but our <strong class="source-inline">catch</strong> block recovered the stream with a new publisher that passed an unknown <strong class="source-inline">User</strong> struct to the receiver. </p>
			<p>However, there is a problem with our solution. Add this line after <strong class="source-inline">postNotificationThatFails()</strong>, at the end of the <strong class="source-inline">viewDidLoad()</strong> method:</p>
			<p class="source-code">postNotification()</p>
			<p>So now we are sending three notifications: first a regular one, then one that fails, then another regular one. Execute the app and notice the output:</p>
			<p class="source-code">User(id: "123")</p>
			<p class="source-code">User(id: "-1")</p>
			<p>What is the issue here? The issue is that we only received two values, even though there are three notifications being sent! What is the problem then? The problem is that our <strong class="source-inline">catch</strong> block is replacing the failed stream with a <strong class="source-inline">Just</strong> publisher. As said before, a <strong class="source-inline">Just</strong> publisher only sends one value and then completes. Any value sent after the failure will be lost.</p>
			<p>Let's improve this solution so we can keep processing values after recovering from an error with the <strong class="source-inline">catch</strong> block. Replace the <strong class="source-inline">publisher</strong> block with the following one:</p>
			<p class="source-code">let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))</p>
			<p class="source-code">  .map { notification in return notification.object as! Data }</p>
			<p class="source-code">  <strong class="bold">.flatMap { data in</strong></p>
			<p class="source-code"><strong class="bold">    return Just(data)</strong></p>
			<p class="source-code">      .decode(type: User.self, decoder: JSONDecoder())</p>
			<p class="source-code">      .catch {_ in</p>
			<p class="source-code">        return Just(User.unknown)</p>
			<p class="source-code">      }</p>
			<p class="source-code">  <strong class="bold">}</strong></p>
			<p>In the preceding highlighted code, you can see that we have wrapped the <strong class="source-inline">decode</strong> and <strong class="source-inline">catch</strong> block in a <strong class="source-inline">flatMap</strong> + <strong class="source-inline">Just</strong> block. Check in the following figure the differences before and after the change:</p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Figure_13.11_B14717.jpg" alt="Figure 13.11 – Flow before and after flatMap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11 – Flow before and after flatMap</p>
			<p>Notice in the<a id="_idIndexMarker721"/> new code how, inside the <strong class="source-inline">flatMap</strong>, we are now<a id="_idIndexMarker722"/> creating a new second flow for every new value with this piece of code:</p>
			<p class="source-code">.flatMap { data in</p>
			<p class="source-code">    <strong class="bold">return Just(data)</strong></p>
			<p class="source-code"><strong class="bold">      .decode(type: User.self, decoder: JSONDecoder())</strong></p>
			<p class="source-code"><strong class="bold">      .catch {_ in</strong></p>
			<p class="source-code"><strong class="bold">        return Just(User.unknown)</strong></p>
			<p class="source-code"><strong class="bold">      }</strong></p>
			<p class="source-code">  }</p>
			<p>This is important because it means that when there is an error, and the <strong class="source-inline">catch</strong> replaces the stream with the <strong class="source-inline">Just(User.unknown)</strong> publisher, it will not replace the original stream; it will just replace the stream that we are creating for this specific element inside the <strong class="source-inline">flatMap</strong>. This means that for the next element that arrives from the Notification Center, we still have the main publisher working. Execute the app now and see the following results in the console:</p>
			<p class="source-code">User(id: "123")</p>
			<p class="source-code">User(id: "-1")</p>
			<p class="source-code">User(id: "123")</p>
			<p>That is great! Not only are we handling the errors, we still process new elements that arrive after! </p>
			<p>In this section, you have seen how to use <strong class="source-inline">flatMap</strong> and <strong class="source-inline">catch</strong> to make your streams error-proof. Let's wrap up the chapter now in the summary.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor456"/>Summary</h1>
			<p>In this chapter, we have learned about the basics of Combine: what a publisher is, what a subscriber is, why we need operators, which ones are more useful, and how all these elements chain together to help us. </p>
			<p>We have built two different apps to demonstrate how Combine can help in our apps, from processing user interface events, decoding, and applying business rules, to creating error-proof streams and methods to recover from operations that fail. Combine provides us with a lot of built-in functionalities that will make our code easy to read and maintain.</p>
			<p>In the next chapter, we are going to learn about one of the new features of iOS 14: App Clips.</p>
		</div>
	</body></html>