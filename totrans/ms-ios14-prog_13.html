<html><head></head><body>
		<div><h1 id="_idParaDest-207"><em class="italic"><a id="_idTextAnchor447"/>Chapter 13</em>: Working with the Combine Framework</h1>
			<p>With the launch of <strong class="bold">Combine</strong>, Apple provided developers with a new way of handling events in their code; a functional and declarative approach, where developers can implement streams and publisher/subscriber paradigms easily, without the need for external libraries. Centralizing event processing in your apps with the help of Combine makes your code easier to understand than using other traditional methods like nested closures or callbacks all around your code.</p>
			<p>In this chapter, you will learn about the following topics: </p>
			<ul>
				<li>Understanding the Combine framework: We will review the basic components of the framework with code samples – publishers, subscribers, subjects, and operators.</li>
				<li>Combining publishers, subscribers, and operators: We will build a small feature in an example app mixing all these concepts together.</li>
				<li>Using operators to build error-proof streams: We will use <code>flatMap</code> and <code>catch</code> to create streams that can deal properly with errors in a real-world example app.</li>
			</ul>
			<p>By the end of the chapter, you should be able to use Combine in multiple parts of your own apps to produce simple, effective, and easy to understand declarative code that will help your app's code be easy to understand, extend, and maintain.</p>
			<h1 id="_idParaDest-208"><a id="_idTextAnchor448"/>Technical requirements</h1>
			<p>The code bundle for this chapter includes two starter projects called <strong class="bold">CombineExample_start</strong> and <strong class="bold">PublishersAndSubscribers_start</strong>. You can find them in the code bundle repository:</p>
			<p><a href="https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition">https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition</a></p>
			<h1 id="_idParaDest-209"><a id="_idTextAnchor449"/>Understanding the Combine framework</h1>
			<p>Apple released the <a id="_idIndexMarker592"/>Combine framework in 2019, and they defined it as a framework that provides a declarative Swift API for processing values over time. There are <strong class="bold">publishers</strong>, which produce those values, and <strong class="bold">subscribers</strong>, which consume them. These values that change over time may represent different asynchronous events. </p>
			<p>Let's see an overview of the Publisher and Subscriber protocol definitions to understand their key concepts in the following sections.</p>
			<h2 id="_idParaDest-210"><a id="_idTextAnchor450"/>Understanding Publisher</h2>
			<p>As mentioned before, publishers <a id="_idIndexMarker593"/>are used in Combine to produce values <a id="_idIndexMarker594"/>over time. Let's dig into the Swift protocol that defines them to understand the key concepts. The <code>Publisher</code> definition in Swift looks as follows:</p>
			<pre>public protocol Publisher {
    //1
    associatedtype Output
    //2
    associatedtype Failure : Error
    //3
    public func subscribe&lt;S&gt;(_ subscriber: S) where S : Subscriber, Self.Failure == S.Failure, Self.Output == S.Input
}</pre>
			<p>Let's explain each numbered <a id="_idIndexMarker595"/>comment in more detail:</p>
			<ol>
				<li>Every <code>Publisher</code> instance has <a id="_idIndexMarker596"/>an associated type, <code>Output</code>. This defines the type of values that the publisher will generate over time.</li>
				<li>At the same time, the <code>Publisher</code> can also generate errors, and the associated type <code>Failure</code> is used to define the type of those errors. If a <code>Publisher</code> never generates errors, the <code>Failure</code> can be defined as type <code>Never</code>.</li>
				<li>Finally, a <code>Publisher</code> allows <code>Subscriber</code> entities to <code>subscribe</code> to it to receive the values that are being produced over time. Note that to generate a valid subscription, the publisher's <code>Output</code> type must match the subscriber's <code>Input</code> type. In the same way, the <code>Failure</code> type of both must match too.</li>
			</ol>
			<p>The following figure shows a summary of the <strong class="bold">Publisher</strong>:</p>
			<div><div><img src="img/Figure_13.1_B14717.jpg" alt="Figure 13.1 – Publisher summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.1 – Publisher summary</p>
			<p>Now that we have an initial description of the critical concepts of a publisher, let's do the same with the <code>Subscriber</code> protocol.</p>
			<h2 id="_idParaDest-211"><a id="_idTextAnchor451"/>Understanding Subscriber</h2>
			<p>We have seen that <code>Publisher</code> entities produce<a id="_idIndexMarker597"/> values over time. Now let's see how <code>Subscriber</code> entities <a id="_idIndexMarker598"/>can consume those values. <code>Publisher</code> and <code>Subscriber</code> work closely together in Combine, so let's see their internal details. The <code>Subscriber</code> protocol in Swift looks like this:</p>
			<pre>public protocol Subscriber : CustomCombineIdentifierConvertible {
    //1
    associatedtype Input
    //2
    associatedtype Failure : Error
    //3
    func receive(subscription: Subscription)
    //4
    func receive(_ input: Self.Input) -&gt; Subscribers.Demand
    //5
    func receive(completion: Subscribers.Completion&lt;Self.Failure&gt;)
}</pre>
			<p>Again, let's review each numbered line:</p>
			<ol>
				<li value="1">A <code>Subscriber</code> entity is going to receive values over time. The associated type <code>Input</code> defines the type of those values. </li>
				<li>At the same time, the <code>Subscriber</code> can<a id="_idIndexMarker599"/> also receive errors, and the associated type <code>Failure</code> is used to define the type of those errors. If a <code>Subscriber</code> never receives errors, the <code>Failure</code> can be defined as type <code>Never</code>.</li>
				<li>This method informs the <code>Subscriber</code> that the subscription to the <code>Publisher</code> is successful and it may start requesting elements.</li>
				<li>Informs the <code>Subscriber</code> that the <code>Publisher</code> has produced a new item.</li>
				<li>Some subscriptions may end <a id="_idIndexMarker600"/>over time. In those scenarios, this method is called to inform the <code>Subscriber</code> that it will not receive any more values. It allows us to execute a completion block before finishing.</li>
			</ol>
			<p>The following figure shows a summary of the <strong class="bold">Subscriber</strong>:</p>
			<div><div><img src="img/Figure_13.2_B14717.jpg" alt="Figure 13.2 – Subscriber summary&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.2 – Subscriber summary</p>
			<p>If we put together both Publisher and Subscriber figures, we have the following schema:</p>
			<div><div><img src="img/Figure_13.3_B14717.jpg" alt="Figure 13.3 – Publisher and Subscriber schemas&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.3 – Publisher and Subscriber schemas</p>
			<p>Notice how the output-input<a id="_idIndexMarker601"/> and the failure types of the publisher and the<a id="_idIndexMarker602"/> subscriber must be equal.</p>
			<p>Now that we have a basic idea of what a publisher and a subscriber look like, let's see how they communicate. There are three steps, pictured in the following figure:</p>
			<div><div><img src="img/Figure_13.4_B14717.jpg" alt="Figure 13.4 – Publisher and Subscriber communication process&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.4 – Publisher and Subscriber communication process</p>
			<p>The following list describes<a id="_idIndexMarker603"/> the process in more detail:</p>
			<ol>
				<li value="1">In the first step, the <code>Subscriber</code> tells the <code>Publisher</code> that it wants to subscribe. The <code>Publisher</code> sends back<a id="_idIndexMarker604"/> a subscription. The <code>Subscriber</code> uses that subscription to start requesting elements. The subscriber can request from N to unlimited values.</li>
				<li>Now the <code>Publisher</code> is free to send those values over time. The <code>Subscriber</code> will receive those inputs.</li>
				<li>In subscriptions that are not expecting unlimited values, a completion event is sent to the <code>Subscriber</code>, so it is aware that the subscription is over.</li>
			</ol>
			<p>Now we have a basic idea of what a<a id="_idIndexMarker605"/> publisher is and what a subscriber is. We also know the steps involved in their communication. That is enough theory! Here is a practical<a id="_idIndexMarker606"/> example of a single publisher sending the values of an array to a subscriber. You can open a new Xcode playground and try the following code:</p>
			<pre>import Cocoa
import Combine
//1
let publisher = [1,2,3,4].publisher
//2
let subscriber = publisher.sink { element in
  print(element)
}</pre>
			<p>In the first comment, we create an array of integers from 1 to 4, and we use the convenience instance property <code>publisher</code> from the Sequence protocol to wrap it inside a new <code>Publisher</code> instance.</p>
			<p>In the second comment, we use the method <code>sink</code> to attach a subscriber to the publisher, defining inside its completion block an action to perform over each value received over time.</p>
			<p>If you execute this code, the output will be like this:</p>
			<pre>1
2
3
4</pre>
			<p>The initial array contained the numbers from 1 to 4, and that is what we printed. But what if we just want to print the <a id="_idIndexMarker607"/>even numbers? How can we transform the data between the <a id="_idIndexMarker608"/>producer and the subscriber? Luckily for us, Combine provides <strong class="bold">Operators</strong> to help us. Let's see more about them next.</p>
			<h2 id="_idParaDest-212"><a id="_idTextAnchor452"/>Understanding Operators</h2>
			<p>An <code>filter</code>, <code>map</code>, <code>reduce</code>, <code>scan</code>, <code>combineLatest</code>, <code>merge</code>, and <code>zip</code>.</p>
			<h3>Using filter</h3>
			<p>The <code>filter</code> operator is used to<a id="_idIndexMarker612"/> just remove values matching some condition out of the stream.</p>
			<p>Let's see a fundamental example <a id="_idIndexMarker613"/>using the <code>filter</code> operator. Imagine that from the previous array (<code>[1,2,3,4]</code>), we only want to print the even numbers of the array. We do it as follows:</p>
			<pre>import Cocoa
import Combine
let publisher = [1,2,3,4].publisher
let subscriber = publisher
<strong class="bold">  .filter { $0 % 2 == 0}</strong>
  .sink { print($0) }</pre>
			<p>Note how the <code>filter</code> operator sits between the publisher and the subscriber, and defines a modification of the elements in a declarative way. </p>
			<p>If you run this code, you will obtain the following result in the console:</p>
			<pre>2
4</pre>
			<p>Now let's see another example of how operators can be handy when working with Combine. Remember that the first rule of the subscriber and publisher is that the <code>Input</code> of the subscriber must be <a id="_idIndexMarker614"/>equal to the <code>Output</code> of the publisher. What happens when they <a id="_idIndexMarker615"/>are not equal? Well, operators can help us to transform the <code>Output</code> of a publisher to adapt it to the proper <code>Input</code> type of the subscriber. One of the operators that helps us is <code>map</code>. </p>
			<h3>Using map</h3>
			<p>The <code>map</code> operator <a id="_idIndexMarker616"/>helps us to apply a certain<a id="_idIndexMarker617"/> operation to every value of the stream, transforming it into a different type.</p>
			<p>The following code uses the <code>map</code> operator to transform the <code>Output</code> of a publisher (<code>int</code> values) into the <code>Input</code> that our subscriber needs (<code>User</code> instances):</p>
			<pre>let publisher = [1,2,3,4].publisher
let subscriber = publisher
<strong class="bold">  .map { return User(id: $0)}</strong>
  .sink { print($0.description()) }</pre>
			<p>The <code>map</code> operator is transforming a stream of <code>Int</code> values [<code>1,2,3,4</code>] into a stream of <code>User</code> instances. When we use the <code>sink</code>, we can call the <code>description()</code> method of those users.</p>
			<div><div><img src="img/Figure_13.5_B14717.jpg" alt="Figure 13.5 – Using map to transform outputs on the stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.5 – Using map to transform outputs on the stream</p>
			<p>The previous figure<a id="_idIndexMarker618"/> represents how <code>map</code> changes the <strong class="bold">Output</strong> type (while the <strong class="bold">Failure</strong> type, in this case, keeps <a id="_idIndexMarker619"/>being the same). When working with<a id="_idIndexMarker620"/> Combine, using this kind of graph (on a document or just in your mind) can be really helpful to work with the proper <a id="_idIndexMarker621"/>types at every step of the stream.</p>
			<p>There are more operators available rather than just <code>filter</code> and <code>map</code>. Let's see other useful ones like <code>reduce</code>, <code>scan</code>, <code>combineLatest</code>, <code>merge</code>, and <code>zip</code>.</p>
			<h3>Using reduce</h3>
			<p>The <code>reduce</code> operator returns the<a id="_idIndexMarker622"/> result of combining all the values of the stream <a id="_idIndexMarker623"/>using a given operation to apply. </p>
			<p>You can try out the following examples in an Xcode playground. Go ahead and check this example of <code>reduce</code>:</p>
			<pre>import Combine
let reduceExample = [1,2,3,4].publisher
<strong class="bold">  .reduce(1, { $0 * $1 })</strong>
  .sink(receiveValue: { print ("\($0)", terminator: " ") })</pre>
			<p>If you execute this code, the output in the console is as follows:</p>
			<pre>24</pre>
			<p>If you have used the regular <code>reduce</code> function from the Swift standard library, the <code>reduce</code> version from <a id="_idIndexMarker624"/>Combine should be easy to understand. It works the same but using values that come from a publisher. What <code>reduce</code> does is apply an <a id="_idIndexMarker625"/>operation and accumulate the result for the next value, starting with a given value. In our example, <code>1, { $0 * $1 }</code>, the first param is the initial value, hence <code>1</code>, and the following param is the operation to perform: multiply the current value (stored as <code>$0</code>) by the next incoming value (<code>$1</code>), and keep it for the next iteration. So, if our input is <code>[1,2,3,4]</code> and our starting value is <code>1</code>, what <code>reduce</code> is doing is <em class="italic">1 x 1 x 2 x 3 x 4 = 24</em>. The next operator that we are going to explain is very similar to reduce. Let's jump into <code>scan</code>.</p>
			<h3>Using scan</h3>
			<p>An operator very much <a id="_idIndexMarker626"/>related to <code>reduce</code> is <code>scan</code>. The <code>scan</code> operator does <a id="_idIndexMarker627"/>exactly the same as <code>reduce</code> but it emits the result at each step. Check this code:</p>
			<pre>import Combine
let scanExample = [1,2,3,4].publisher
<strong class="bold">  .scan(1, { $0 * $1 })</strong>
  .sink(receiveValue: { print ("\($0)", terminator: " ") })</pre>
			<p>Now, executing this will result in the following output:</p>
			<pre>1 2 6 24</pre>
			<p>As you can see, it is giving us the same final result as <code>reduce</code> (<code>scan</code> emits a value in each step, not just at the end. So, with <code>scan</code>, we get the following values over time:</p>
			<ul>
				<li>1x1 = <strong class="bold">1</strong></li>
				<li>1x2 = <strong class="bold">2</strong></li>
				<li>2x3 = <strong class="bold">6</strong></li>
				<li>6x4 = <strong class="bold">24</strong></li>
			</ul>
			<p>These operators (<code>filter</code>, <code>map</code>, <code>reduce</code>, and <code>scan</code>) helped us to transform the values coming from another publisher. But some <a id="_idIndexMarker628"/>operators combine multiple <a id="_idIndexMarker629"/>publishers' input into one single stream output. Let's see some of them: <code>combineLatest</code>, <code>merge</code>, and <code>zip</code>.</p>
			<h3>Using combineLatest</h3>
			<p>It is a publisher that combines<a id="_idIndexMarker630"/> the latest values from two other publishers. Both<a id="_idIndexMarker631"/> publishers must have the same failure type. The downstream subscriber will receive a tuple of the most recent elements from the upstream publishers when any of them emit a new value.</p>
			<p>Try the following code in a playground:</p>
			<pre>import Combine
let chars = PassthroughSubject&lt;String, Never&gt;()
let numbers = PassthroughSubject&lt;Int, Never&gt;()
let cancellable = <strong class="bold">chars.combineLatest(numbers)</strong>
    .sink { print("Result: \($0).") }
chars.send("a")
numbers.send(1)
chars.send("b")
chars.send("c")
numbers.send(2)
numbers.send(3)</pre>
			<p>The output on the console is as follows:</p>
			<pre>Result: ("a", 1).
Result: ("b", 1).
Result: ("c", 1).
Result: ("c", 2).
Result: ("c", 3).</pre>
			<p>Notice how we don't have any <a id="_idIndexMarker632"/>output until <code>("a", 1).</code>, which means that <code>combineLatest</code> doesn't produce any output until all the inputs send<a id="_idIndexMarker633"/> an initial value. After that, it will produce a value every time an input sends a new value, sending the latest from each of the inputs.</p>
			<p>There are also other versions of <code>combineLatest</code> to combine three or even four inputs, instead of just two: <code>combineLatest3</code>, <code>combineLatest4</code>.</p>
			<p>What if we only want to have the latest output of any of the input publishers (meaning just a value, not a tuple)? For those cases, we can use <code>merge</code>.</p>
			<h3>Using merge</h3>
			<p>With <code>merge</code>, we will aggregate<a id="_idIndexMarker634"/> multiple input publishers into a single stream, and the <a id="_idIndexMarker635"/>output will be just the latest value from any of them. Check out this code in a playground:</p>
			<pre>import Combine
let oddNumbers = PassthroughSubject&lt;Int, Never&gt;()
let evenNumbers = PassthroughSubject&lt;Int, Never&gt;()
let cancellable = <strong class="bold">oddNumbers.merge(with: evenNumbers)</strong>
    .sink { print("Result: \($0).") }
oddNumbers.send(1)
evenNumbers.send(2)
oddNumbers.send(3)</pre>
			<p>The output will be as follows:</p>
			<pre>Result: 1.
Result: 2.
Result: 3.</pre>
			<p>As you can see, the output is one<a id="_idIndexMarker636"/> value at a time, which differs from the tuple with all the latest values from all the inputs that we got with <code>combineLatest</code>.</p>
			<p>There is another useful method to<a id="_idIndexMarker637"/> work with multiple publishers. Let's see what <code>zip</code> can do.</p>
			<h3>Using zip</h3>
			<p><code>zip</code> is a publisher that emits<a id="_idIndexMarker638"/> a pair of elements when both input publishers have emitted a <a id="_idIndexMarker639"/>new value. Let's see how it differs from <code>combineLatest</code> with the same example. Execute the following code in a playground:</p>
			<pre>import Combine
let chars = PassthroughSubject&lt;String, Never&gt;()
let numbers = PassthroughSubject&lt;Int, Never&gt;()
let cancellable = chars.zip(numbers)
    .sink { print("Result: \($0).") }
chars.send("a")
numbers.send(1)
// combineLatest output:  (a,1)
// zip output:            (a, 1)
chars.send("b")
// combineLatest output:  (b,1)
// zip output:            nothing
chars.send("c")
// combineLatest output:  (c,1)
// zip output:            nothing
numbers.send(2)
// combineLatest output:  (c,2)
// zip output:            (b,2)
numbers.send(3)
// combineLatest output:  (c,3)
// zip output:            (c,3)</pre>
			<p>Check out the comments<a id="_idIndexMarker640"/> under each line, representing what <code>combineLatest</code> and <code>zip</code> will output every given time. Notice how <code>zip</code> doesn't send a new pair of values downstream until both of the publishers have emitted a new value. And when that happens, it will send a tuple with the oldest non-emitted values of both of them. <code>CombineLatest</code> will use the <a id="_idIndexMarker641"/>most recent and will emit a tuple every time one of the publishers emits a single new value (it will not wait to have both publishers emitting!). That is the main difference.</p>
			<p>With the basics about publisher, subscriber, and operator entities explained, let's see another useful entity in Combine in the next section: <strong class="bold">Subject</strong>.</p>
			<h2 id="_idParaDest-213"><a id="_idTextAnchor453"/>Understanding Subject</h2>
			<p>As per the<a id="_idIndexMarker642"/> Apple documentation:</p>
			<p class="author-quote">"A subject is a publisher that exposes a method for outside callers to publish elements."</p>
			<p>The definition is pretty straightforward. Subjects<a id="_idIndexMarker643"/> are like publishers, but they have a method, <code>send(_:)</code>, which you can use to inject new elements into their stream. A single <code>Subject</code> allows multiple subscribers to be connected at the same time.</p>
			<p>There are two types of built-in subjects: <code>CurrentValueSubject</code> and <code>PassthroughSubject</code>. Let's see the differences between them.</p>
			<h3>Working with CurrentValueSubject</h3>
			<p>This is a subject that holds<a id="_idIndexMarker644"/> an initial value. It broadcasts the current value every time it changes. </p>
			<p>When a subscriber connects to a <code>CurrentValueSubject</code>, it will receive the current value, and the next ones when it changes. This means that a <code>CurrentValueSubject</code> has state. Here is an example (you can try this code in a playground):</p>
			<pre>import Combine
let currentValueSubject = <strong class="bold">CurrentValueSubject&lt;String, Never&gt;("first value")</strong>
let subscriber = currentValueSubject.sink { print("received: \($0)") }
currentValueSubject.send("second value")</pre>
			<p>If you execute this code, the output looks like this:</p>
			<pre>received: first value
received: second value</pre>
			<p>Here are the interesting bits:</p>
			<ul>
				<li>When we initialize the subject, we need to pass an initial value.</li>
				<li>When the subscriber subscribes, it gets the current value that is held in the subject. Note how in the console output, the subscriber has printed <code>first value</code> even though we subscribed to the subject after that value was generated.</li>
				<li>Every time we call <code>send(_:)</code>, the subscribers get the next value.</li>
			</ul>
			<p>Now, let's see the other<a id="_idIndexMarker645"/> built-in type of subject, <code>PassthroughSubject</code>.</p>
			<h3>Working with PassthroughSubject</h3>
			<p>The main difference<a id="_idIndexMarker646"/> between <code>PassthroughSubject</code> and <code>CurrentValueSubject</code> is that <code>PassthroughSubject</code> doesn't hold any state. Check the following code (you can try it out in a playground):</p>
			<pre>import Combine
let passthroughSubject = PassthroughSubject&lt;String, Never&gt;()
passthroughSubject.send("first value")
let subscriber = passthroughSubject.sink { print("received: \($0)")}
passthroughSubject.send("second value")</pre>
			<p>If you execute this code, here is the output:</p>
			<pre>received: second value</pre>
			<p>Notice how the subscriber is created after the first value is sent. This first value is not received, because there was no subscriber connected yet. However, the second value is displayed in the output because it was sent after the subscription was established.</p>
			<p>We have seen the basic usage of <code>Publisher</code>, <code>Subscriber</code>, <code>Operator</code>, and <code>Subject</code>. Let's now create a bigger and more complex example to see how to apply Combine concepts to real-world apps.</p>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor454"/>Combining Publishers, Subscribers, and Operators</h1>
			<p>In this section, we are <a id="_idIndexMarker647"/>going to mix the concepts of the<a id="_idIndexMarker648"/> previous section altogether in a real-world example feature. Let's assume that we have an app that <a id="_idIndexMarker649"/>contains a newsletter, and we allow the users to subscribe to the newsletter by entering their email address, using two <code>UITextFields</code>: the <strong class="bold">Email</strong> and <strong class="bold">Repeat Email</strong> fields. Let's <a id="_idIndexMarker650"/>assume that in our business logic, we need to check that the email is correct, and we are going to do the <a id="_idIndexMarker651"/>following checks:</p>
			<ul>
				<li>Local check: We will ask <a id="_idIndexMarker652"/>users to repeat the email address twice, and both should be the same.</li>
				<li>Local check: The email should contain an "@".</li>
				<li>Local check: The email should be five characters long, at least.</li>
				<li>Remote check: We will also assume that we have a remote method to check in the backend that the email is unique, meaning it doesn't exist yet.</li>
			</ul>
			<p>Once all these conditions match, we will enable a <code>UITextfield</code> to repeat it. You will also see a <code>combineLatest</code>.</p>
			<p>Open the <code>ViewController.swift</code> file. You will notice a couple of vars that are tagged with the property wrapper <code>@Published</code>:</p>
			<pre>@Published var initialEmail: String = ""
@Published var repeatedEmail: String = ""</pre>
			<p>What <code>@Published</code> is doing here is creating a Publisher from the property itself. So, every time <code>initialEmail</code> or <code>repeatedEmail</code> values change, they will get published to anyone subscribed to them. You can access the publisher of <code>initialEmail</code> by using <code>$initialEmail</code> (prefix a <code>$</code> to the property name). Notice the two <code>IBActions</code> defined in the same class:</p>
			<pre>@IBAction func emailChanged(_ sender: UITextField) {
  initialEmail = sender.text ?? ""
}
@IBAction func repeatedEmailChanged(_ sender: UITextField) {
  repeatedEmail = sender.text ?? ""
}</pre>
			<p>By combining <code>IBAction</code> and <code>@Published</code>, we are creating a funnel in which every time the user<a id="_idIndexMarker653"/> types something in the <code>initialEmail</code> <code>UITextField</code>, it will get published<a id="_idIndexMarker654"/> through the <code>$initialEmail</code> publisher.</p>
			<p>Why is this handy? Remember<a id="_idIndexMarker655"/> that according to the business<a id="_idIndexMarker656"/> logic defined above, we need to ensure that both <code>initialEmail</code> and <code>repeatedEmail</code> are equal. Now we have<a id="_idIndexMarker657"/> two publishers that will emit their value<a id="_idIndexMarker658"/> every time the user types in either of the two text fields. How can we combine those two values to compare them? The Combine framework has the perfect method for this: <code>CombineLatest</code>. Add the following vars to the <code>ViewController.swift</code> file:</p>
			<pre>var validatedEmail: AnyPublisher&lt;String?, Never&gt; {
  return Publishers
    .CombineLatest($initialEmail, $repeatedEmail) //1
    .map { (email, repeatedEmail) -&gt; String? in  //2
      guard email == repeatedEmail, email.contains("@"), email.count &gt; 5 else { return nil }
      return email
    }
    .eraseToAnyPublisher() //3
}
var cancellable: AnyCancellable? //4</pre>
			<p>Let's analyze the code comment by comment:</p>
			<ol>
				<li value="1">First, we are using <code>Publishers.CombineLatest</code> to combine two different publishers into one: <code>$initialEmail</code> and <code>$repeatedEmail</code>. This will result in a new stream (publisher) of type <code>Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;</code>. Don't let the long type scare you. It means "a publisher <a id="_idIndexMarker659"/>of two string publishers." The magic of <code>CombineLatest</code> is that if either of the two<a id="_idIndexMarker660"/> inputs changes, you will get the new value, but also the latest value that the other input had, which is very <a id="_idIndexMarker661"/>useful for cases like this.</li>
				<li>Second, we are <a id="_idIndexMarker662"/>applying the <code>map</code> operator over the "publisher of two string publishers." By using <code>map</code>, we are unwrapping the<a id="_idIndexMarker663"/> underlaying published strings to be able to<a id="_idIndexMarker664"/> use the string themselves and return a different result after working with them. Here is where we apply our business rules: If both emails are equal, they include an "@" and they are longer than five characters long, we return the <code>email</code>. Otherwise, we return <code>nil</code>. So, with <code>map</code>, we are transforming a stream output type into a new one, to adapt it to what we need.</li>
				<li>At this point, if we inspect the type of what we have, you will see this: <code>Publishers.Map&lt;Publishers.CombineLatest&lt;Published&lt;String&gt;.Publisher, Published&lt;String&gt;.Publisher&gt;, String?&gt;</code>. That is quite complex to read and use. But Combine provides us with a way to simplify this, because what is important is what is inside of the publisher itself, not all the wrappers around it. By using <code>eraseToAnyPublisher</code>, we are changing this type to just <code>AnyPublisher&lt;String?, Never&gt;</code>. This is much easier to understand and use (and if you want to publish it in an API, for example, it's much easier to digest by other developers).</li>
				<li>We create a cancellable<a id="_idIndexMarker665"/> property var to use it in the following piece of code.</li>
			</ol>
			<p>This flow can be<a id="_idIndexMarker666"/> represented as follows</p>
			<div><div><img src="img/Figure_13.6_B14717.jpg" alt="Figure 13.6 – validatedEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.6 – validatedEmail stream</p>
			<p>Now, add this line of code to the <code>viewDidLoad()</code> method:</p>
			<pre>cancellable = validatedEmail.sink { print($0) }</pre>
			<p>By calling <code>sink</code>, we are attaching a subscriber to the <code>validatedEmail</code> publisher, and we store it in our <a id="_idIndexMarker667"/>new <code>var</code> property <code>cancellable</code>. Every time we<a id="_idIndexMarker668"/> receive a new value, we will just print it into the console for testing purposes. Let's try it out! Execute the app and type any email address (in both fields) that fulfills all the <a id="_idIndexMarker669"/>conditions (for example, <code>abc@email.com</code>).</p>
			<p>When you type valid <a id="_idIndexMarker670"/>addresses, you will see it in the console. When the addresses are not valid, you will see <code>nil</code>.</p>
			<p>We have seen a lot of new Combine concepts packed into very little code. Before continuing with our demo project, we are going to look at a quick summary of these new concepts:</p>
			<ul>
				<li>The <code>@Published</code> property wrapper: Allows us to create a Publisher from a property variable. We can access the publisher by prefixing <code>$</code> to the name of the property. It only works on class properties, not on structs. </li>
				<li><code>Publishers.CombineLatest</code>: Allows us to combine two publishers into a single one that will always push<a id="_idIndexMarker671"/> the latest value of each one when there is a change (or <code>nil</code>, if there wasn't a previous value).</li>
				<li><code>map</code>: Allows us to<a id="_idIndexMarker672"/> transform the stream. We apply a <code>map</code> to a <a id="_idIndexMarker673"/>publisher with an <code>Output</code> type and we can transform it into a new, different <code>Output</code>. </li>
				<li><code>eraseToAnyPublisher</code>: Allows us to erase complex types to work with easier <code>AnyPublisher&lt;Otutput, Failure&gt;</code> streams. This is very handy when publishing our classes as an API, for example.</li>
			</ul>
			<p>After this little recap, we<a id="_idIndexMarker674"/> still have one feature pending to fulfill the list <a id="_idIndexMarker675"/>of requirements. We have<a id="_idIndexMarker676"/> implemented three local checks on the email addresses, but we still need to do the last one, which was this:</p>
			<ul>
				<li>Remote check: We will also assume that we have a remote method to check in the backend that the email is unique, meaning it doesn't exist yet.</li>
			</ul>
			<p>In the <code>ViewController.swift</code> file, there is a dummy method named <code>func emailAvailable(…)</code>. It just returns a completion block. This method is intended to represent a network call that returns <code>True</code> or <code>False</code> in the completion block according to whether the email already exists in the backend or not. For demo purposes, we are not going to implement the network call itself, just simulate the result.</p>
			<p>Let's implement this feature with Combine. We are going to create a new publisher that will emit a Bool indicating whether the email that the user types exists in the backend or not, using a fake network call, <code>emailAvailable(…)</code>. Add the following code to the <code>ViewController.swift</code> file:</p>
			<pre>var isNewEmail: AnyPublisher&lt;Bool, Never&gt; { //1
  return $initialEmail //2
    .debounce(for: 1, scheduler: RunLoop.main) //3
    .removeDuplicates() //4
    .flatMap { email in //5
      return Future { promise in
        self.emailAvailable(email) { available in
          promise(.success(available))
        }
      }
    }
    .eraseToAnyPublisher()
}</pre>
			<p>There are a lot of new concepts here, so let's go through the numbered comments one by one:</p>
			<ol>
				<li value="1">We are defining<a id="_idIndexMarker677"/> a new publisher, <code>isNewEmail</code>, of type <code>&lt;Bool, Never&gt;</code>. This publisher will help us to emit events that indicate<a id="_idIndexMarker678"/> whether the email that the user is typing exists in our database or not.</li>
				<li>To fetch any new<a id="_idIndexMarker679"/> value that the user types in the email<a id="_idIndexMarker680"/> field, we start by using the published property defined earlier in the <code>$initialEmail</code> section.</li>
				<li>Users can type/delete in<a id="_idIndexMarker681"/> text fields pretty fast. Our<a id="_idIndexMarker682"/> goal is to make a network call every time we receive a new value through the <code>$initialEmail</code> publisher (meaning every time the user is typing in the email field). That means that we will query the network a bit too much. The Combine <code>.debounce</code> method will help us to reduce the number of values we are processing. By using <code>.debounce</code>(<code>1…)</code>, we specify that from all the values that we get from <code>$initialEmail</code>, we will only process a value every <code>1</code> second. The rest of the values will be<a id="_idIndexMarker683"/> discarded. This is very helpful when working with publishers that are connected to the user interface and the network (text fields, buttons, search bars, and so on).</li>
				<li>Another useful<a id="_idIndexMarker684"/> method is <code>removeDuplicates()</code>. If the user types "<code>abc</code>" and then deletes the "<code>c</code>" to quickly type the "<code>c</code>" back, we will make several calls. But if we use <code>removeDuplicates()</code>, we will avoid this unnecessary behavior.</li>
				<li>The fifth step is a bit more <a id="_idIndexMarker685"/>complicated. This is where we<a id="_idIndexMarker686"/> perform a network call. First, we have a <code>.flatMap</code> wrapping everything. This function transforms elements from a publisher into a new type of publisher. Inside the <code>flatMap</code>, we have a <code>Future</code>. A <code>Future</code> is a publisher that eventually emits a single value and then finishes (or fails). Inside the <code>Future</code>, we have a <code>Promise</code>: A <code>Promise</code> in Combine is a <code>typealias</code> for a closure that takes a <code>Result</code>. Now let's describe the whole process again, but from inside out: The network call <code>emailAvailable</code> returns<a id="_idIndexMarker687"/> a result in the form of <code>promise.success(…)</code>. This Promise is wrapped in a Future, to become a publisher stream. That stream is a <code>Future&lt;Bool, Never&gt;</code> at this point. Now, we wrap <a id="_idIndexMarker688"/>everything with <code>flatMap</code>, so the upstream <code>initialEmail: Published&lt;String&gt;.Publisher</code> becomes <code>AnyPublisher&lt;Bool, Never&gt;</code> (with the help of <code>eraseToAnyPublisher</code> too).</li>
			</ol>
			<p>Here is the full flow to generate <code>isNewEmail</code>:</p>
			<div><div><img src="img/Figure_13.7_B14717.jpg" alt="Figure 13.7 – isNewEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.7 – isNewEmail stream</p>
			<p>So, after all this chain<a id="_idIndexMarker689"/> of transformations, we have a publisher, <code>isNewEmail</code>, that will emit a <code>Bool</code> indicating whether an email address is unique or <a id="_idIndexMarker690"/>not in our backend every time (almost, except <a id="_idIndexMarker691"/>duplicates and debounced) the user<a id="_idIndexMarker692"/> types in the UI! That is pretty cool! And it's very useful for our business logic checks.</p>
			<p>Our last step is going to be to <a id="_idIndexMarker693"/>combine the publisher of the local checks (<code>validatedEmail</code>) with the remote publisher (<code>isNewEmail</code>) to have a final output. The business logic required to enable the <code>String</code> and a <code>True</code> value, so all our conditions are met. What is the <a id="_idIndexMarker694"/>best way to combine the latest values of two different publishers and work with them? We just used it above! It is <code>combineLatest</code>. Add the following code to the <code>ViewController.swift</code> file:</p>
			<pre>var finalEmail: AnyPublisher&lt;String?, Never&gt; {
  return Publishers.CombineLatest(validatedEmail, isNewEmail).map { (email, isNew) -&gt; String? in
    guard isNew else { return nil }
    return email
  }
  .eraseToAnyPublisher()
}</pre>
			<p>As detailed in the preceding code, we are using <code>CombineLatest</code> to work with the latest values of two different publishers. From <code>validatedEmail</code>, we get a valid email or a <code>nil</code> value <a id="_idIndexMarker695"/>otherwise. From <code>isNewEmail</code>, we get a <code>Bool</code> indicating whether the email exists in the database or not. The result of this is a<a id="_idIndexMarker696"/> new publisher, <code>finalEmail</code>, of type <code>&lt;String?, Never&gt;</code>. See the flow in the next figure:</p>
			<div><div><img src="img/Figure_13.8_B14717.jpg" alt="Figure 13.8 – finalEmail stream&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.8 – finalEmail stream</p>
			<p>Now, how can we<a id="_idIndexMarker697"/> enable and disable the <code>viewDidLoad</code> function and let's explain it in detail:</p>
			<pre>signupButtonCancellable = finalEmail
  .map { $0 != nil }
  .receive(on: RunLoop.main)
  .assign(to: \.isEnabled, on: signupButton)</pre>
			<p>In this code, we start with the <code>finalEmail</code> publisher <code>(&lt;String?, Never&gt;</code>), we <code>map</code> over it, transforming<a id="_idIndexMarker699"/> the stream into <code>&lt;Bool, Never&gt;</code>, then we apply <code>.receive</code> to make sure we are executing this in the main thread (because we<a id="_idIndexMarker700"/> are handling the UI here, a <code>UIButton</code>). Finally, we assign the value inside the stream <code>(&lt;Bool&gt;</code>) to the <code>signupButton</code> <code>isEnabled</code> property! Check out the next figure, which details the steps of the stream:</p>
			<div><div><img src="img/Figure_13.9_B14717.jpg" alt="Figure 13.9 – Assigning finalEmail to signUpButton&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.9 – Assigning finalEmail to signUpButton</p>
			<p>And that is it<a href="mailto:abc@email.com">! Execute th</a>e app, and try it yourself: If you type some email address that matches all the conditions (like <code>abc@email.com</code>), the <strong class="bold">Sign-up</strong> button will be enabled. Otherwise, it will be disabled.</p>
			<p>In this section, we<a id="_idIndexMarker702"/> have learned about a lot of new Combine concepts and methods to combine different streams, transform outputs, modify the thread<a id="_idIndexMarker703"/> we are working on, handle<a id="_idIndexMarker704"/> user input, and so on. We used <code>flatMap</code> to transform <a id="_idIndexMarker705"/>elements of an upstream<a id="_idIndexMarker706"/> into a different type downstream. However, <code>flatMap</code> has more uses. One of them is to help streams recover from errors, with the help of <code>catch</code>. In the next section, we are going to see an example of how a stream can fail, and how to recover it using <code>flatMap</code> and <code>catch</code>.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor455"/>Using Operators to build error-proof streams</h1>
			<p>For this section, go ahead and<a id="_idIndexMarker707"/> open the project in<a id="_idIndexMarker708"/> the code bundle named <code>PublishersAndSubscribers_start</code>. Take a look at the file <code>ViewController.swift</code>.</p>
			<p>This file contains a <code>User</code> struct:</p>
			<pre>struct User: Codable {
  let id: String
  static var unknown: User {
    return User(id: "-1")
  }
}</pre>
			<p>The <code>User</code> struct is quite simple. It contains a <code>String</code> property <code>id</code>, and a <code>static var</code> named <code>unknown</code> that <a id="_idIndexMarker709"/>returns a <code>User</code> instance with <code>id</code> equal to <code>-1</code>. Apart from the <code>User</code> struct, the file contains the <code>ViewController</code> itself.</p>
			<p>The view controller <a id="_idIndexMarker710"/>contains two methods: </p>
			<ul>
				<li>First, <code>postNotification()</code>: This just fires a notification in the Notification Center that contains a <code>User</code> instance with <code>id</code> equal to <code>123</code>. The name of the notification is <code>networkResult</code>.</li>
				<li>Second, <code>postNotificationThatFails()</code>: This just fires a notification in the Notification Center that contains random data that is Base-64 encoded, not a <code>User</code> instance this time. The name of the notification is <code>networkResult.</code></li>
			</ul>
			<p>We will use Combine to consume these two notifications. Both methods represent a dummy network call, whose result is being sent through the Notification Center in this way. So, think of them as the network call response that you will fetch from your backend when trying to query for some object (a user in this case) and propagate to your app with notifications.</p>
			<p>Now, let's try to call <code>postNotification()</code> and consume the result using Combine. In the <code>viewDidLoad()</code> method, call <code>postNotification()</code>:</p>
			<pre>override func viewDidLoad() {
  super.viewDidLoad()
  postNotification()
}</pre>
			<p>Now let's create a publisher that emits values from the Notification Center and use the <code>cancellable</code> property to<a id="_idIndexMarker711"/> consume them as a subscriber. Change the <code>viewDidLoad()</code> method to this:</p>
			<pre>override func viewDidLoad() {
  super.viewDidLoad()
  //1
  let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))
  //2
  cancellable = publisher.sink { item in
    print(item)
  }
  //3
  postNotification()
}</pre>
			<p>Let's review the comments by lines:</p>
			<ol>
				<li value="1">First, we are<a id="_idIndexMarker712"/> creating a publisher that emits any value from the Notification Center that arrives under the name <code>networkResult.</code> This matches the notification name we are sending in the <code>postNotification()</code> method.</li>
				<li>We are subscribing to the publisher created in the previous step, and we store the result in the <code>cancellable</code> property. We are using <code>sink</code> when creating the subscriber to define a completion block that will print to the console any value received.</li>
				<li>Finally, we post a notification. </li>
			</ol>
			<p>If you execute this code and you check in the console, you should see this result:</p>
			<pre>name = networkResult, object = Optional(&lt;7b226964 223a2231 3233227d&gt;), userInfo = nil</pre>
			<p>This means that our<a id="_idIndexMarker713"/> stream worked! We have sent a notification, our publisher has forwarded it, and our subscriber has printed it into the <a id="_idIndexMarker714"/>console. As you can see on the console output, the notification has three properties: <code>name</code>, <code>object</code>, and <code>userInfo</code>. We want to unwrap what is inside the <code>object</code> attribute. So, let's modify our publisher with an operator to transform what our subscriber receives. Change the publisher code for this one:</p>
			<pre>let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))
  <strong class="bold">.map { notification in return notification.object as! Data }</strong></pre>
			<p>Execute it and check the output in the console:</p>
			<pre>12 bytes</pre>
			<p>In this code, we are mapping over the notification value and sending the <code>object</code> content as <code>Data</code>. In the console output, you can see that our subscriber is receiving those bytes of data now, instead of the full notification. Great! The next step is going to be to transform these bytes of <code>Data</code> into a <code>User</code> instance. To do that, we need to decode the data. Combine has the perfect helper method for this. Change the publisher code to this:</p>
			<pre>let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))
  .map { notification in return notification.object as! Data }
  <strong class="bold">.decode(type: User.self, decoder: JSONDecoder())</strong></pre>
			<p>By adding the preceding highlighted line, we are using the <code>Data</code> from the <code>map</code> operation and decoding it into a <code>User</code> instance! All in a single line. But if you try to execute now, you will get a <a id="_idIndexMarker715"/>compile error in the subscriber <code>sink</code> line saying the following:</p>
			<pre>Referencing instance method 'sink(receiveValue:)' on 'Publisher' requires the types' Publishers.Decode&lt;Publishers.Map&lt;NotificationCenter.Publisher, JSONDecoder.Input&gt;, User, JSONDecoder&gt;.Failure' (aka 'Error') and 'Never' be equivalent</pre>
			<p>This means: If you inspect the <a id="_idIndexMarker716"/>method sink that we are using, you will discover that it requires the <code>Failure</code> type of the publisher that is consuming to be <code>Never</code>:</p>
			<pre>extension Publisher where Self.Failure == Never</pre>
			<p>After adding the <code>decode</code> line, our publisher no longer has a <code>Never</code> type as failure, because <code>decode</code> can produce errors. So, the compiler is telling you that the types don't match anymore. We need to do something that catches any error produced by <code>decode</code> and transforms that into a <code>Never</code>-failing operation. Combine has another useful operator that can help us in this scenario: <code>catch</code>. Change the publisher code into this new block:</p>
			<pre>let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))
  .map { notification in return notification.object as! Data }
  .decode(type: User.self, decoder: JSONDecoder())
  <strong class="bold">.catch {_ in</strong>
<strong class="bold">    return Just(User.unknown)</strong>
<strong class="bold">  }</strong></pre>
			<p>Let's explain <code>catch</code> in more detail. <code>catch</code> will handle any error in the upstream, and instead of crashing the app, it will complete/finish the publisher that produced the error and replace it with a new publisher (that you must provide in the <code>return</code> block). </p>
			<p>So in this scenario, if we get an error from the <code>decode</code> operation, our notification publisher will finish, and it will be replaced by <code>Just(User.unknown)</code>. <code>Just</code> is a publisher that only emits one value and then completes. Check the next figure:</p>
			<div><div><img src="img/Figure_13.10_B14717.jpg" alt="Figure 13.10 – Catch replaces the failed stream with a new one&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.10 – Catch replaces the failed stream with a new one</p>
			<p>The top part of the previous figure<a id="_idIndexMarker717"/> shows the stream when <a id="_idIndexMarker718"/>an error happens in the <code>decode</code> stage and <code>catch</code> enters into action. In the bottom part of the figure, you can see how <code>catch</code> drops the initial publisher and replaces it with the one defined in the <code>catch</code> block (a <code>Just</code> publisher in this case).</p>
			<p>Let's try out what will happen if we provide a value that will produce an error in the <code>decode</code> <code>stage</code>. At the end of the <code>viewDidLoad()</code>, just after <code>postNotification()</code>, add this line:</p>
			<pre>postNotificationThatFails()</pre>
			<p>So, we are now sending two notifications, one with user data inside, and the other with a random string. The second<a id="_idIndexMarker719"/> should fail on the <code>decode</code> step. Execute the app; you will see this output:</p>
			<pre>User(id: "123")
User(id: "-1")</pre>
			<p>That is great! The first <a id="_idIndexMarker720"/>notification got decoded and transformed into a proper user. The second failed to be decoded, but our <code>catch</code> block recovered the stream with a new publisher that passed an unknown <code>User</code> struct to the receiver. </p>
			<p>However, there is a problem with our solution. Add this line after <code>postNotificationThatFails()</code>, at the end of the <code>viewDidLoad()</code> method:</p>
			<pre>postNotification()</pre>
			<p>So now we are sending three notifications: first a regular one, then one that fails, then another regular one. Execute the app and notice the output:</p>
			<pre>User(id: "123")
User(id: "-1")</pre>
			<p>What is the issue here? The issue is that we only received two values, even though there are three notifications being sent! What is the problem then? The problem is that our <code>catch</code> block is replacing the failed stream with a <code>Just</code> publisher. As said before, a <code>Just</code> publisher only sends one value and then completes. Any value sent after the failure will be lost.</p>
			<p>Let's improve this solution so we can keep processing values after recovering from an error with the <code>catch</code> block. Replace the <code>publisher</code> block with the following one:</p>
			<pre>let publisher = NotificationCenter.default.publisher(for: Notification.Name("networkResult"))
  .map { notification in return notification.object as! Data }
  <strong class="bold">.flatMap { data in</strong>
<strong class="bold">    return Just(data)</strong>
      .decode(type: User.self, decoder: JSONDecoder())
      .catch {_ in
        return Just(User.unknown)
      }
  <strong class="bold">}</strong></pre>
			<p>In the preceding highlighted code, you can see that we have wrapped the <code>decode</code> and <code>catch</code> block in a <code>flatMap</code> + <code>Just</code> block. Check in the following figure the differences before and after the change:</p>
			<div><div><img src="img/Figure_13.11_B14717.jpg" alt="Figure 13.11 – Flow before and after flatMap&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.11 – Flow before and after flatMap</p>
			<p>Notice in the<a id="_idIndexMarker721"/> new code how, inside the <code>flatMap</code>, we are now<a id="_idIndexMarker722"/> creating a new second flow for every new value with this piece of code:</p>
			<pre>.flatMap { data in
    <strong class="bold">return Just(data)</strong>
<strong class="bold">      .decode(type: User.self, decoder: JSONDecoder())</strong>
<strong class="bold">      .catch {_ in</strong>
<strong class="bold">        return Just(User.unknown)</strong>
<strong class="bold">      }</strong>
  }</pre>
			<p>This is important because it means that when there is an error, and the <code>catch</code> replaces the stream with the <code>Just(User.unknown)</code> publisher, it will not replace the original stream; it will just replace the stream that we are creating for this specific element inside the <code>flatMap</code>. This means that for the next element that arrives from the Notification Center, we still have the main publisher working. Execute the app now and see the following results in the console:</p>
			<pre>User(id: "123")
User(id: "-1")
User(id: "123")</pre>
			<p>That is great! Not only are we handling the errors, we still process new elements that arrive after! </p>
			<p>In this section, you have seen how to use <code>flatMap</code> and <code>catch</code> to make your streams error-proof. Let's wrap up the chapter now in the summary.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor456"/>Summary</h1>
			<p>In this chapter, we have learned about the basics of Combine: what a publisher is, what a subscriber is, why we need operators, which ones are more useful, and how all these elements chain together to help us. </p>
			<p>We have built two different apps to demonstrate how Combine can help in our apps, from processing user interface events, decoding, and applying business rules, to creating error-proof streams and methods to recover from operations that fail. Combine provides us with a lot of built-in functionalities that will make our code easy to read and maintain.</p>
			<p>In the next chapter, we are going to learn about one of the new features of iOS 14: App Clips.</p>
		</div>
	</body></html>