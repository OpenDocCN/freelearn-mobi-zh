<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. iOS Guided Rover</h1></div></div></div><p>In this chapter, we are going to build software that can be used to control a rover robot. What's new in this? Children have been playing with radio-controlled toys for years now, and sometimes, we still play with such toys!</p><p>However, we <a id="id251" class="indexterm"/>are going to build a robot that can be controlled by iOS devices in the following three different ways:</p><div><ul class="itemizedlist"><li class="listitem">Through manual commands: The two sliders on the iOS control: the rover's steering and the throttle</li><li class="listitem">By means of the iOS device movements in space: By moving an iOS device left and right, you can control the steering, and by moving the iOS device back and forth, you can control the throttle</li><li class="listitem">By using voice commands: By saying a few voice commands, an iOS device can control the steering and throttle</li></ul></div><p>Cool, isn't it? Let's quickly get started with this fascinating journey into robotics without forgetting that the techniques that you are going to learn here can be used in many other projects.</p><p>The chapter is organized into the following sections:</p><div><ul class="itemizedlist"><li class="listitem">iOS guided rover requirements: We will briefly set the project requirements</li><li class="listitem">Hardware: We will describe the hardware and the electronic circuit that is needed for the project</li><li class="listitem">The Arduino code: We will write the code for Arduino to control the external appliance and communicate with iOS devices</li><li class="listitem">The iOS code: We will write code for an iOS device</li><li class="listitem">How to go further: More ideas will be provided to improve the project and learn more</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>iOS guided rover requirements</h1></div></div></div><p>We <a id="id252" class="indexterm"/>are going to develop the Arduino and iOS software to do the following:</p><div><ul class="itemizedlist"><li class="listitem">Control the direction and speed of a rover, powered by two motors from the iOS device by:<div><ul class="itemizedlist"><li class="listitem">Using manual commands</li><li class="listitem">Moving the iOS device in space</li><li class="listitem">Using voice commands</li></ul></div></li><li class="listitem">Avoid obstacles</li><li class="listitem">Measure <a id="id253" class="indexterm"/>the slope and tilt angles so that the robot doesn't flip over</li><li class="listitem">Transfer commands and information back and forth between the rover and the iOS application by using the Bluetooth BLE.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Hardware</h1></div></div></div><p>We will<a id="id254" class="indexterm"/> assume that you have already built a rover robot like the<a id="id255" class="indexterm"/> ones shown on the following sites:</p><div><ul class="itemizedlist"><li class="listitem"><a class="ulink" href="http://bit.ly/1MzmIYs">http://bit.ly/1MzmIYs</a></li><li class="listitem"><a class="ulink" href="http://bit.ly/1Jo9qJS">http://bit.ly/1Jo9qJS</a></li><li class="listitem"><a class="ulink" href="http://bit.ly/1i7oTag">http://bit.ly/1i7oTag</a></li></ul></div><p>You can also buy two motors and two wheels (for more information, visit <a class="ulink" href="http://bit.ly/1i7oWTG">http://bit.ly/1i7oWTG</a> and <a class="ulink" href="http://bit.ly/1KeHtdf">http://bit.ly/1KeHtdf</a>) and make the chassis yourself with metal or wood.</p><p>You will <a id="id256" class="indexterm"/>find everything that you may need on eBay (<a class="ulink" href="http://www.ebay.com">http://www.ebay.com</a>) at an affordable price.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec47"/>Additional electronic components</h2></div></div></div><p>In <a id="id257" class="indexterm"/>this project, we will need some additional components:</p><div><ul class="itemizedlist"><li class="listitem">Sparkfun <a id="id258" class="indexterm"/>DC Motor Driver TB6612FBG (<a class="ulink" href="https://www.sparkfun.com/products/9457">https://www.sparkfun.com/products/9457</a> or <a class="ulink" href="http://www.adafruit.com/product/2448">http://www.adafruit.com/product/2448</a>)</li><li class="listitem">Sharp GP2Y0A21YK Distance <a id="id259" class="indexterm"/>Measuring Sensor Unit (<a class="ulink" href="https://www.sparkfun.com/products/242">https://www.sparkfun.com/products/242</a>), which can be replaced by similar units with minimum changes in the Arduino code</li><li class="listitem">Adafruit ADXL345 Triple-Axis <a id="id260" class="indexterm"/>Accelerometer (<a class="ulink" href="http://www.adafruit.com/products/1231">http://www.adafruit.com/products/1231</a>)</li><li class="listitem">330 Ω resistor 0.25w</li><li class="listitem">A red LED</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec48"/>What's an accelerometer?</h2></div></div></div><p>In this <a id="id261" class="indexterm"/>section, we will briefly discuss what an accelerometer is and how to use it.</p><p>An <a id="id262" class="indexterm"/>accelerometer is a device that measures acceleration along its 3 axes, and returns three voltage signals that are proportional to the acceleration.</p><p>The acceleration measured by the accelerometer gives us information about the inclination of the accelerometer with respect to the terrestrial gravitational field.</p><p>To understand how acceleration is related to the inclination of the accelerometer, let's examine the situation depicted in the following figures, where we consider only two axes (<em>z</em> and <em>x</em>):</p><div><img src="img/image00196.jpeg" alt="What's an accelerometer?"/></div><p style="clear:both; height: 1em;"> </p><p>In figure <strong>1</strong>, the accelerometer has the <em>z</em> axis is parallel to the gravity (<strong>g</strong>), and the <em>x</em> axis is orthogonal to the gravity. Hence, the acceleration along the <em>x</em> axis is zero. In figure <strong>2</strong>, the accelerometer rotates at an angle <strong>α</strong>. The acceleration along the accelerometer <em>x</em> axis is gx, and gx is what the accelerometer returns as the acceleration along the x axis. In conclusion, by rotating the accelerometer, we have an acceleration along the accelerometer <em>x</em> axis that is proportional to the rotation itself. The same is true for the <em>y</em> axis that is pointing into the page.</p><p>In this project, we use this behavior for mounting an accelerometer on the rover to measure its inclination along the transversal and the longitudinal axis. At the same time, we use the iOS device accelerometer to measure device inclination for controlling<a id="id263" class="indexterm"/> the direction and <a id="id264" class="indexterm"/>speed of the rover.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec49"/>Electronic circuit</h2></div></div></div><p>A DC motor<a id="id265" class="indexterm"/> rotates in one direction when powered up and rotates in the opposite direction when the voltage polarity is inverted.</p><p>The following circuit diagrams depict ways to use switches to power the DC motor to invert the voltage polarity and rotation direction. In the following circuit diagram, the motor rotates in the clockwise direction:</p><div><img src="img/image00197.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>While in the second case, it rotates in the anticlockwise direction:</p><div><img src="img/image00198.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>Transistors can replace switches in order to control the direction through electronic signals. A transistor-based <a id="id266" class="indexterm"/>circuit <a id="id267" class="indexterm"/>that replaces the four switches is called an H-bridge (<a class="ulink" href="http://bit.ly/1JBmdrE">http://bit.ly/1JBmdrE</a>).</p><p>Basically, an<a id="id268" class="indexterm"/> H-bridge is a circuit that allows you to control the DC motor direction through two input signals. When the first signal is high and the second one is low, the motor runs in one direction; when the first signal is low and the second one is high, the motor runs in the opposite direction. To control the speed of the motor, we also <a id="id269" class="indexterm"/>need a PWM signal (<a class="ulink" href="https://www.arduino.cc/en/Tutorial/PWM">https://www.arduino.cc/en/Tutorial/PWM</a>). The TB6612FBG motor driver includes two H-bridge circuits to power the two motors up to 1A.</p><p>The<a id="id270" class="indexterm"/> following table, derived from the TB6612FBG datasheet describes how to use the available input signals to control the motor:</p><div><table border="1"><colgroup><col/><col/><col/><col/><col/><col/><col/></colgroup><thead><tr><th colspan="4" valign="bottom" style="text-align: center">
<p>Input</p>
</th><th colspan="3" valign="bottom" style="text-align: center">
<p>Output</p>
</th></tr></thead><tbody><tr><td valign="top">
<p>
<strong>IN1</strong>
</p>
</td><td valign="top">
<p>
<strong>IN2</strong>
</p>
</td><td valign="top">
<p>
<strong>PWM</strong>
</p>
</td><td valign="top">
<p>
<strong>STBY</strong>
</p>
</td><td valign="top">
<p>
<strong>OUT1</strong>
</p>
</td><td valign="top">
<p>
<strong>OUT2</strong>
</p>
</td><td valign="top">
<p>
<strong>Mode</strong>
</p>
</td></tr><tr><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H/L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>Short brake</p>
</td></tr><tr><td rowspan="2" valign="top">
<p>L</p>
</td><td rowspan="2" valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>Motor runs</p>
</td></tr><tr><td valign="top">
<p>L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>Short brake</p>
</td></tr><tr><td rowspan="2" valign="top">
<p>H</p>
</td><td rowspan="2" valign="top">
<p>L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>Motor runs in the opposite direction</p>
</td></tr><tr><td valign="top">
<p>L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>Short brake</p>
</td></tr><tr><td valign="top">
<p>L</p>
</td><td valign="top">
<p>L</p>
</td><td valign="top">
<p>H</p>
</td><td valign="top">
<p>H</p>
</td><td colspan="2" valign="top" style="text-align: center">
<p>OFF (high impedance)</p>
</td><td valign="top">
<p>Stop</p>
</td></tr><tr><td valign="top">
<p>H/L</p>
</td><td valign="top">
<p>H/L</p>
</td><td valign="top">
<p>H/L</p>
</td><td valign="top">
<p>L</p>
</td><td colspan="2" valign="top" style="text-align: center">
<p>OFF (high impedance)</p>
</td><td valign="top">
<p>Standby</p>
</td></tr></tbody></table></div><p>To <a id="id271" class="indexterm"/>make the motor run in a direction, we have to make IN1 low and IN2 high. The PWM signals control the motor speed. To make the motor run in the opposition direction, we have to make IN1 high and IN2 low, and the PWM signals still control the motor's speed.</p><p>The PWM signals can be generated from Arduino by using the <code class="literal">analogWrite</code> function.</p><p>The following electric diagram of the electronic circuit is what we need for the project:</p><div><img src="img/image00199.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>As required, we need a distance sensor that has an analog output; the output voltage decreases as the distance to the front object decreases. The relation between the output voltage and distance is not linear (see the datasheet by visiting <a class="ulink" href="https://www.sparkfun.com/datasheets/Components/GP2Y0A21YK.pdf">https://www.sparkfun.com/datasheets/Components/GP2Y0A21YK.pdf</a>), but it can be linearized in <a id="id272" class="indexterm"/>the range of the distance of interest. In <a id="id273" class="indexterm"/>our application, we just need to stop the rover when it is very close to an obstacle. So, we don't care much about the actual distance. The red LED shows when an obstacle is very close to the rover.</p><p>ADXL345 is<a id="id274" class="indexterm"/> a 3-axis accelerometer. It measures the acceleration along its three axes (in [m/s<sup>2</sup>]). When the rover is completely at rest and leveled, the acceleration is 0 m/s<sup>2</sup> on the x axis, 0 m/s<sup>2</sup> on the y axis, and 9.8 m/s<sup>2</sup> on the z axis because of the gravitational force. When the rover is not leveled, the values read along the axis are different. When the measured values exceed a threshold, we know that the rover is going to flip over.</p><p>The following diagram shows how to mount the circuit on a breadboard:</p><div><img src="img/image00200.jpeg" alt="Electronic circuit"/></div><p style="clear:both; height: 1em;"> </p><p>You can<a id="id275" class="indexterm"/> see that we used two different power sources, one for Arduino and the electronic components, and the other for the motors. This was done for the following reasons:</p><div><ol class="orderedlist arabic"><li class="listitem">The motors can require a different voltage compared to the electronic components. The motor power source can have a different voltage up to 15V, as required by the TB6612FBG chip.</li><li class="listitem">Motors generate a lot of electric noise that can disturb the electronics. With this configuration, electronics and motors are electrically isolated.</li><li class="listitem">The<a id="id276" class="indexterm"/> rover can operate for a longer time, especially by using rechargeable batteries.</li></ol><div></div><div><h3 class="title"><a id="tip34"/>Tip</h3><p>
<strong>Motor wiring</strong>
</p><p>In case<a id="id277" class="indexterm"/> a motor spins in the wrong direction, you have to invert its wires.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec50"/>How to make the rover turn</h2></div></div></div><p>When both the motors spin at the same speed, the rover goes straight. To make it turn right, reduce the speed<a id="id278" class="indexterm"/> of the right motor. The more we reduce the speed, the more the rover turns. This is exactly the same as the method that is used to make the rover turn left.</p><p>That said, the Arduino code has to manage the rotation speed of the two motors in order to control the direction of the motor.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec51"/>How to mount the accelerometer</h2></div></div></div><p>It's <a id="id279" class="indexterm"/>very important that the accelerometer board be mounted in the right position in order to properly read acceleration and work with the Arduino code that is shown in the next chapter. The accelerometer board has to be tightly screwed to the rover chassis with a nut and a bolt (it is better to use two nuts and bolts, one for each side). </p><p>The schema is shown in the following image:</p><div><img src="img/image00201.jpeg" alt="How to mount the accelerometer"/></div><p style="clear:both; height: 1em;"> </p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec30"/>Arduino code</h1></div></div></div><p>The <a id="id280" class="indexterm"/>full <a id="id281" class="indexterm"/>code of this project can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>To have a better understanding of the explanations in the next few paragraphs, open the downloaded code while reading.</p><p>Before going <a id="id282" class="indexterm"/>any further, we need to install the following additional libraries from Adafruit:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Adafruit ADXL345</strong>: This is used to get measurements from the ADXL345 accelerometer</li><li class="listitem"><strong>Adafruit Unified Sensor</strong>: This is a general library that is required from the previous one</li></ul></div><p>To install the libraries into the Arduino IDE, open the menu <strong>Sketch</strong> | <strong>Include Library</strong> | <strong>Manage Libraries …</strong>. For more information, see <a class="link" title="Chapter 2. Bluetooth Pet Door Locker" href="part0019.xhtml#aid-I3QM1">Chapter 2</a>, <em>Bluetooth Pet Door Locker</em>.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec52"/>Setup code</h2></div></div></div><p>Please <a id="id283" class="indexterm"/>refer to the downloaded code, since the setup code is quite simple and doesn't require a detailed explanation.</p><p>Just note that <code class="literal">currentSpeed</code>, <code class="literal">leftSpeed</code>, and <code class="literal">rightSpeed</code> are: the current speed of the rover, the speed reduction of the left wheel used to make the rover turn left, and the speed reduction of the right wheel used to make the rover turn right respectively. They are obviously all set to zero in the setup function.</p><p>The <code class="literal">goingForward</code> variable indicates whether the rover is going forward or backward, and it is initially set to yes (forward).</p><p>The final lines initialize the accelerometer, as required by the library. The <code class="literal">xOffset</code> and <code class="literal">yOffset</code> variables are about tuning the accelerometer readings when the rover is at rest and in a plane. We will talk about them in the <em>Testing and tuning</em> section.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec53"/>Motor control functions</h2></div></div></div><p>Before<a id="id284" class="indexterm"/> getting into the explanation of the main code, we will take a look at the motor control functions, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">forward</code>: This configures the motor control to make the rover move forward</li><li class="listitem"><code class="literal">backward</code>: This configures the motor control to make the rover move backward</li><li class="listitem"><code class="literal">brake</code>: This stops the rover</li><li class="listitem"><code class="literal">throttle</code>: This controls the speed of the rover and its direction</li></ul></div><p>From the previous table for TB6612FBG (row 2), to make the motors go forward, we need to set IN1 to low and IN2 to high. This is exactly what the <code class="literal">forward</code> function does for both the motors:</p><div><pre class="programlisting">void forward() {

  digitalWrite(STBY, HIGH);

  digitalWrite(MR_I1, LOW);
  digitalWrite(MR_I2, HIGH);

  digitalWrite(ML_I1, LOW);
  digitalWrite(ML_I2, HIGH);
}</pre></div><p>The <code class="literal">backward</code> function is similar. From row 3 of the previous table, we need to set IN1 to high and IN2 to low to change the direction, as follows:</p><div><pre class="programlisting">void backward() {

  digitalWrite(STBY, HIGH);

  digitalWrite(MR_I1, HIGH);
  digitalWrite(MR_I2, LOW);

  digitalWrite(ML_I1, HIGH);
  digitalWrite(ML_I2, LOW);
}</pre></div><p>In both the functions, we set <code class="literal">STBY</code> to <code class="literal">HIGH</code> in case we previously stopped the rover by setting <code class="literal">STBY</code> to <code class="literal">LOW</code>.</p><p>Again, by using the table (row 5), use the following function to stop the rover:</p><div><pre class="programlisting">void brake(void) {

  digitalWrite(MR_I1, LOW);
  digitalWrite(MR_I2, LOW);

  digitalWrite(ML_I1, LOW);
  digitalWrite(ML_I2, LOW);

  digitalWrite(STBY, HIGH);
}</pre></div><p>The <code class="literal">throttle</code> function is very important as it controls the speed and direction of the rover:</p><div><pre class="programlisting">void throttle(int requiredSpeed, int requiredLeftSpeed, int requiredRightSpeed) {

  analogWrite(ML_PWM, requiredSpeed - requiredLeftSpeed);
  analogWrite(MR_PWM, requiredSpeed - requiredRightSpeed);
}</pre></div><p>To <a id="id285" class="indexterm"/>set the speed of each motor, we have to set an appropriate PWM signal to the PWM pin.</p><p>If you need to move the rover in a straight line, set the speed in such a way that it is equal for both motors. Otherwise, reduce the speed of the wheel that is on the rover's side, which we want to turn to.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec54"/>Main program</h2></div></div></div><p>The <code class="literal">loop</code> function <a id="id286" class="indexterm"/>of the rover control software is not very complex, and is as follows:</p><div><pre class="programlisting">void loop() {

  uart.pollACI();

  if (iOSConnected) {

    // Check accelerometer
    if (millis() - lastAccelerometerCheck &gt; ACCELEROMETER_CHECK_INTERVAL) {

      char buffer[32];
      char xBuffer[6];
      char yBuffer[6];

      lastAccelerometerCheck = millis();

      sensors_event_t event;

      accel.getEvent(&amp;event);

      event.acceleration.x += xOffset;
      event.acceleration.y += yOffset;

      dtostrf(event.acceleration.x, 0, 2, xBuffer);
      dtostrf(event.acceleration.y, 0, 2, yBuffer);

      snprintf(buffer, 32, "%s:%s", xBuffer, yBuffer);
      uart.write((uint8_t *)buffer, strlen(buffer));

      //        Serial.print("X: "); Serial.print(event.acceleration.x); Serial.print("  ");
      //        Serial.print("Y: "); Serial.print(event.acceleration.y); Serial.print("  ");Serial.println("m/s^2 ");

    }
  }

  // Reads distance

  distance = 0;
  for (int i = 0; i &lt; 16; i++)
    distance += analogRead(DISTANCEPIN);
  distance = distance / 16;

  if (distance &gt; DISTANCETHRESHOLD) {
    leftSpeed = 0;
    rightSpeed = 0;
    throttle(0, 0, 0);
    digitalWrite(DISTANCEINDICATORPIN, HIGH);
  }
  else {
    digitalWrite(DISTANCEINDICATORPIN, LOW);
  }
}</pre></div><p>When<a id="id287" class="indexterm"/> an iOS device is connected, after every <code class="literal">ACCELEROMETER_CHECK_INTERVAL</code> milliseconds, the acceleration values along the <em>x</em> and <em>y</em> axes are sent to the iOS device. Then, the distance sensor is read. If the distance from an obstacle is greater than <code class="literal">DISTANCETHRESHOLD</code>, the rover stops and the LED on the rover is turned on.</p><p>Since the distance sensor readings are quite variable (like with most of the analog sensors), the mean value of 16 readings is used through the following lines:</p><div><pre class="programlisting">for (int i = 0; i &lt; 16; i++)
    distance += analogRead(DISTANCEPIN);
  distance = distance / 16;</pre></div><p>To control the rover, the iOS function has to send the following commands:</p><div><ul class="itemizedlist"><li class="listitem">F: This is used to move the rover forward.</li><li class="listitem">B: This is used to move the rover backward.</li><li class="listitem">T=&lt;speed&gt;: This is used to move the rover at a speed of &lt;speed&gt;. The &lt;speed&gt; lies in the 0-100 range.</li><li class="listitem">R=&lt;speed&gt;: This is used to move the rover right by reducing the current speed of the right motor to &lt;speed&gt;. The &lt;speed&gt; lies in the 0-100 range.</li><li class="listitem">L=&lt;speed&gt;: This is used to move the rover left by reducing the current speed of the left motor to &lt;speed&gt;. The &lt;speed&gt; lies in the 0-100 range.</li></ul></div><p>As we already know from the <em>Bluetooth Pet Locker</em> project in <a class="link" title="Chapter 2. Bluetooth Pet Door Locker" href="part0019.xhtml#aid-I3QM1">Chapter 2</a>, <em>Bluetooth Pet Door Locker</em>, commands from the iOS controller are received in the <code class="literal">rxCallback</code> function:</p><div><pre class="programlisting">void rxCallback(uint8_t *buffer, uint8_t len) {

  if (len &gt; 0) {

    char value[32];

    if (buffer[0] == 'F') {

      forward();
      goingForward = true;
    }

    if (buffer[0] == 'B') {

      backward();
      goingForward = false;
    }

    if (buffer[0] == 'T') {

      strncpy(value, (const char *)&amp;buffer[2], len - 2);
      value[len - 2] = 0;

      currentSpeed = map(atoi(value), 0, 100, 0, 255);
      if (currentSpeed == 0) {
        rightSpeed = 0;
        leftSpeed = 0;
      }
    }

    if (buffer[0] == 'R') {

      strncpy(value, (const char *)&amp;buffer[2], len - 2);
      value[len - 2] = 0;
      //Serial.print("Right Speed "); Serial.println(atoi(value));
      rightSpeed = map(atoi(value), 0, 100, 0, currentSpeed);
      leftSpeed = 0;
    }

    if (buffer[0] == 'L') {

      strncpy(value, (const char *)&amp;buffer[2], len - 2);
      value[len - 2] = 0;

      leftSpeed = map(atoi(value), 0, 100, 0, currentSpeed);
      rightSpeed = 0;
    }

    throttle(currentSpeed, leftSpeed, rightSpeed);
  }

}</pre></div><p>The F(orward) and B(ackward) commands are very easy to handle, since we have the respective function to call.</p><p>For <a id="id288" class="indexterm"/>the T(hrottle) command, we get the required reduction speed in the <code class="literal">value</code> variable, and we proportionally scale it from the range of 0-100 to the range 0-255 (<code class="literal">currentSpeed = map(atoi(value), 0, 100, 0, 255)</code>). This is the expected range for the PWM signal.</p><p>The function ends by calling the <code class="literal">throttle</code> function, which sets the speed for both the motors, thus setting the PWM signal.</p><p>For the R(ight) command, we get the required reduction speed in the <code class="literal">value</code> variable. Then, we proportionally scale the 0-100 to the range 0-<code class="literal">currentSpeed</code>. In fact, the speed reduction of the right motor cannot be larger than the actual motor speed. In other words, when the command value is 255 (the maximum rotation speed), the speed of the right motor is reduced to 0, and the rover turns right. The same thing happens for the L(eft) command.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec31"/>iOS code</h1></div></div></div><p>In this <a id="id289" class="indexterm"/>chapter, we are going to look at the iOS application that remotely controls the rover. This application allows us to manually control the rover by the means of two sliders, that emulate the steering wheel and the throttle.</p><p>However, we are going to push the application a lot further by using the iOS device accelerometer and even voice commands. These techniques can be successfully applied to many other projects too.</p><p>Let's take a step at a time so that you can understand every important detail. We will start from the manual control. As<a id="id290" class="indexterm"/> always, the full code of this project can be downloaded from <a class="ulink" href="https://www.packtpub.com/books/content/support">https://www.packtpub.com/books/content/support</a>.</p><p>To have a better understanding of the explanations in the next paragraphs, open the downloaded code while reading.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec55"/>Creating the Xcode project</h2></div></div></div><p>We will<a id="id291" class="indexterm"/> create a new project as we already did in the previous chapters. The following are the parameters for the new project:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Project Type</strong>: Tabbed application</li><li class="listitem"><strong>Product Name</strong>: Rover</li><li class="listitem"><strong>Language</strong>: Objective-C</li><li class="listitem"><strong>Devices</strong>: Universal</li></ul></div><p>In the project's options, we need to deselect the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Landscape Right</strong></li><li class="listitem"><strong>Landscape Left</strong></li></ul></div><p>We do this because we are going to use the iOS accelerometer, and we don't want the screen to rotate when we rotate the device (see the following screenshot). To access the project's options, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the project in the left pane of Xcode.</li><li class="listitem">Select the <strong>General</strong> tab in the right pane.<div><img src="img/image00202.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div><p>We need<a id="id292" class="indexterm"/> additional code with the graphics components to show the rover inclination by the means of two gauges. The library can be downloaded <a id="id293" class="indexterm"/>from <a class="ulink" href="https://github.com/sabymike/MSSimpleGauge">https://github.com/sabymike/MSSimpleGauge</a>.</p><p>To install the additional code, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the preceding link and click on the <strong>Download ZIP</strong> button on the right.</li><li class="listitem">Unzip the downloaded ZIP file.</li><li class="listitem">Open the <code class="literal">Gauges</code> folder and copy the files to the <code class="literal">Rover</code> folder of your project.</li><li class="listitem">Select the <strong>Rover</strong> group in Xcode and right-click on it. Select <strong>Add Files to "Rover"…</strong>. Then, select the files that you just copied and click on <strong>Add</strong>. Make sure that <strong>Copy items if needed</strong> is selected (see the following screenshot):<div><img src="img/image00203.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">In <a id="id294" class="indexterm"/>Xcode, select the files that you just added, right-click on them, select <strong>New Group from Selection</strong>, and then enter <code class="literal">Gauges</code>. This helps us keep the code organized.</li><li class="listitem">To avoid a compilation error, open the file <code class="literal">MSArcLayer.h</code> and add <code class="literal">#import &lt;UIKit/UIKit.h&gt;</code> just before <code class="literal">#import &lt;QuartzCore/QuartzCore.h&gt;</code>.</li></ol><div></div><p>We also <a id="id295" class="indexterm"/>need the library to accept voice commands (OpenEars), which can be downloaded from <a class="ulink" href="http://www.politepix.com/openears/">http://www.politepix.com/openears/</a>.</p><p>Click on the <strong>Download OpenEars</strong> button. To install the library, you have to perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Uncompress the downloaded file.</li><li class="listitem">Inside your downloaded distribution, there is a folder called <code class="literal">Framework</code>. Drag the <code class="literal">Framework</code> folder into your app project in Xcode.</li></ol><div></div><p>Now that we have configured the required additional libraries, we can start creating the application.</p><p>The structure <a id="id296" class="indexterm"/>of this project is very close to the Pet Door Locker. So, we can reuse at least a part of the user interface and the code, by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select <strong>FirstViewController.h</strong> and <strong>FirstViewController.m</strong>, right-click on them, and click on <strong>Delete</strong> (see the following screenshot). Then, click on <strong>Move to Trash</strong>:<div><img src="img/image00204.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">By using the same procedure, delete <strong>SecondViewController</strong> and <strong>Main.storyboard</strong>.</li><li class="listitem">Open the <strong>PetDoorLocker</strong> project in Xcode.</li><li class="listitem">Select the following files and drag and drop them to the <strong>Rover</strong> project:<div><ul class="itemizedlist"><li class="listitem"><strong>PetDoorLockerViewController.h</strong></li><li class="listitem"><strong>PetDoorLockerViewController.m</strong></li><li class="listitem"><strong>BLEConnectionViewController.h</strong></li><li class="listitem"><strong>BLEConnectionViewController.m</strong></li><li class="listitem"><strong>Main.storyboard</strong></li></ul></div><p>Be sure that <strong>Copy items if needed</strong> is selected, and then click on <strong>Finish</strong>:</p><div><h3 class="title"><a id="note11"/>Note</h3><p>If you have added icons to the Tab Bar, don't forget to drag and drop them too.</p></div><div><ol class="orderedlist arabic"><li class="listitem">Rename <code class="literal">PetDoorLockerViewController</code> to <code class="literal">RoverViewController</code> by using the <a id="id297" class="indexterm"/>same procedure that we used in the previous chapters.</li><li class="listitem">Open the <strong>Main.storyboard</strong> and locate the main <strong>View</strong> controller.</li><li class="listitem">Delete the following GUI components:<div><ul class="itemizedlist"><li class="listitem">The <strong>Door Status</strong>, <strong>Temperature</strong>, <strong>Label</strong>, and <strong>Lock</strong> labels</li><li class="listitem">The <strong>switch</strong> component</li></ul></div></li><li class="listitem">Move the status view close to the <strong>connect</strong> button and update its Layout Constraints.</li><li class="listitem">Add the GUI components and the related Layout Constraints, as shown in the following screenshot:<div><img src="img/image00205.jpeg" alt="Creating the Xcode project"/></div><p style="clear:both; height: 1em;"> </p><p>At the top, there are two UIViews for which, the size is 64 x 128 and the class is MSRangeGauge (change it in the Property Inspector)</p></li></ol><div></div></li><li class="listitem">For<a id="id298" class="indexterm"/> the <strong>Throttle</strong> slider, go to the Property Inspector and set the following values:<div><ul class="itemizedlist"><li class="listitem"><strong>Minimum Value</strong>: 0</li><li class="listitem"><strong>Maximum Value</strong>: 100</li><li class="listitem"><strong>Current Value</strong>: 0</li><li class="listitem"><strong>Thumb Tin</strong>: Red or whatever you like</li></ul></div></li><li class="listitem">For the <strong>Steering</strong> slider, go to the Property Inspector and set the following values:<div><ul class="itemizedlist"><li class="listitem"><strong>Minimum Value</strong>: 0</li><li class="listitem"><strong>Maximum Value</strong>: 200</li><li class="listitem"><strong>Current Value</strong>: 100</li></ul></div></li><li class="listitem">For the Segment Control, go to the Property Inspector and set <strong>Segments</strong> to 3.</li><li class="listitem">Change the titles by double-clicking on each segment and entering the following values:<div><ul class="itemizedlist"><li class="listitem">Manual</li><li class="listitem">Accelerometer</li><li class="listitem">Voice</li></ul></div></li><li class="listitem">Select<a id="id299" class="indexterm"/> the View Controller container and in the Identity Inspector, change <strong>Class</strong> to <strong>RoverViewController</strong>.</li><li class="listitem">In the <code class="literal">RoverViewController.h</code> file, add <code class="literal">#import "MSRangeGauge.h"</code>.</li><li class="listitem">Link the GUI components to the RoverViewController code, as follows:<div><pre class="programlisting">@property (strong, nonatomic) IBOutlet UIView               *connectionStatus;
@property (strong, nonatomic) IBOutlet MSRangeGauge         *verticalIndicator;
@property (strong, nonatomic) IBOutlet MSRangeGauge         *horizontalIndicator;
@property (strong, nonatomic) IBOutlet UISlider             *throttleSlider;
@property (strong, nonatomic) IBOutlet UISlider             *steeringWheelSlider;
@property (strong, nonatomic) IBOutlet UISwitch             *directionSwitch;
@property (strong, nonatomic) IBOutlet UISegmentedControl   *modeSegment;</pre></div><div><h3 class="title"><a id="note12"/>Note</h3><p>In your <code class="literal">RoverViewController.m</code>, there still are some references to the older project. Don't bother about these references. We will remove them in the following sections.</p></div></li><li class="listitem">Link the Throttle slider to the method, as follows: <code class="literal">(IBAction)throttleChanged:(UISlider *)sender</code>.</li><li class="listitem">Link the Steering slider to the method, as follows: <code class="literal">(IBAction)steeringWheelChanged:(UISlider *)sender</code>.</li><li class="listitem">Link the forward/backward switch to the method, as follows: <code class="literal">(IBAction)directionChanged:(UISwitch *)sender</code>.</li><li class="listitem">Link the mode segment controller with the method, as follows: <code class="literal">(IBAction)modeChange:(UISegmentedControl *)sender</code>.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec56"/>Writing code for BLEConnectionViewController</h2></div></div></div><p>Since <a id="id300" class="indexterm"/>we have copied this View Controller from the PetDoorLocker project, we don't need to change it.</p><p>We saved some work!</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec57"/>Writing code for RoverViewController</h2></div></div></div><p>First, we <a id="id301" class="indexterm"/>have to remove<a id="id302" class="indexterm"/> the unnecessary code from the previous PetDoorLocker project that we don't need anymore, by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">RoverViewController.m</code>.</li><li class="listitem">Remove the following lines:<div><pre class="programlisting">@property (strong, nonatomic) IBOutlet UIView       *doorStatus;
@property (strong, nonatomic) IBOutlet UILabel      *temperature;
@property (strong, nonatomic) IBOutlet UISwitch     *manualLockSwitch;</pre></div></li><li class="listitem">Remove the lines that refer to <code class="literal">_temperature</code> and <code class="literal">_doorStatus</code> in the code. Please refer to the downloaded code in case you have any doubt.</li><li class="listitem">Empty the <code class="literal">dataReceived</code> function; we will rewrite it later:<div><pre class="programlisting">-(void)dataReceived:(NSString *)content {
    
}</pre></div></li><li class="listitem">Completely remove the <code class="literal">switchChanged</code> function.</li></ol><div></div><p>We can now start writing new code to control our rover.</p><p>Let's start from the easy part—receiving acceleration data from the rover. This data gives us information about the rover's inclination along its longitudinal and transverse axis.</p><p>This information will be shown by the two gauges (RMRangeGauges) that we added in the main screen. The gauges have to be initialized in the viewDidLoad method, as follows:</p><div><pre class="programlisting">- (void)viewDidLoad {
    
    [super viewDidLoad];
    
    _centralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil];
    
    _verticalIndicator.transform = CGAffineTransformMakeRotation(M_PI/2);
    
    _verticalIndicator.minValue = 0;
    _verticalIndicator.maxValue = 200;
    _verticalIndicator.upperRangeValue = 130;
    _verticalIndicator.lowerRangeValue = 70;
    _verticalIndicator.value = 100;
    _verticalIndicator.fillArcFillColor = [UIColor colorWithRed:.9 green:.1 blue:.1 alpha:1];
    _verticalIndicator.rangeFillColor   = [UIColor colorWithRed:.2 green:.9 blue:.2 alpha:1];
    
    _horizontalIndicator.minValue = 0;
    _horizontalIndicator.maxValue = 200;
    _horizontalIndicator.upperRangeValue = 130;
    _horizontalIndicator.lowerRangeValue = 70;
    _horizontalIndicator.value = 100;
    _horizontalIndicator.fillArcFillColor = [UIColor colorWithRed:.9 green:.1 blue:.1 alpha:1];
    _horizontalIndicator.rangeFillColor   = [UIColor colorWithRed:.2 green:.9 blue:.2 alpha:1];

    …

}</pre></div><p>The<a id="id303" class="indexterm"/> code is very easy to <a id="id304" class="indexterm"/>understand, thanks to the self-documenting names of the methods.</p><p>Since the gauges are horizontal and don't have any features to show the needle vertically, we use the following instruction:</p><div><pre class="programlisting">_verticalIndicator.transform = CGAffineTransformMakeRotation(M_PI/2);</pre></div><p>With the preceding code, we rotate the first gauge by 90 degrees in order to have a better indication of the vertical inclination.</p><p>The inclination data is received by the dataReceived method as a string: &lt;vertical inclination&gt;:&lt;horizontal inclination&gt;, and the values are set to the two gauges, as follows:</p><div><pre class="programlisting">-(void)dataReceived:(NSString *)content {
    
    NSArray *components = [content componentsSeparatedByString:@":"];
    if (components.count != 2) {
        return;
    }
    
    float x = [components[0] floatValue];
    float y = [components[1] floatValue];
    
    _verticalIndicator.value = 100+20*y;
    _horizontalIndicator.value = 100+20*x;
}</pre></div><p>In the <code class="literal">didDisconnectPeripheral</code> method, which is called when the Bluetooth device disconnects, we have to reset the position of the two gauges by adding the following lines:</p><div><pre class="programlisting">    _verticalIndicator.value = 100;
    _horizontalIndicator.value = 100;</pre></div><p>Since <a id="id305" class="indexterm"/>we have three modes <a id="id306" class="indexterm"/>to operate the Rover—manually, by using the iOS accelerometer, and through voice commands—we are going to divide the code writing into three different sections to have a better understanding of the code.</p><div><div><div><div><h3 class="title"><a id="ch04lvl3sec02"/>Code to control the rover manually</h3></div></div></div><p>For this <a id="id307" class="indexterm"/>scenario, we have to write the code that manages the Throttle slider to control the speed of the rover, the Steering slider to control its direction, and the switch to control its forward or backward movements.</p><p>The code for the Throttle slider is quite simple, since we only have to send a message to the rover in the form of T=&lt;speed&gt;, as follows:</p><div><pre class="programlisting">- (IBAction)throttleChanged:(UISlider *)sender {

    NSInteger throttle = sender.value;
    
    NSString *msg = [NSString stringWithFormat:@"T=%ld",(long)throttle];
    
    NSData* data;
    data=[msg dataUsingEncoding:NSUTF8StringEncoding];
    
    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
}</pre></div><p>The method that is used to control the direction is not that complex. It sends two messages depending on the position of the slider with respect to its middle—R=&lt;speed&gt; to turn the rover towards the right and L=&lt;speed&gt; to turn the rover towards the left:</p><div><pre class="programlisting">- (IBAction)steeringWheelChanged:(UISlider *)sender {
    
    NSInteger steering = sender.value-100;
    
    NSString *msg;
    
    if (steering&gt;0) {
        
        msg = [NSString stringWithFormat:@"R=%ld",(long)steering];
    }
    else {
        msg = [NSString stringWithFormat:@"L=%ld",(long)-steering];
    }
    
    NSData* data;
    data=[msg dataUsingEncoding:NSUTF8StringEncoding];
    
    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
}</pre></div><p>To<a id="id308" class="indexterm"/> complete the management of the two sliders, we need to change the <code class="literal">didConnectPeripheral</code> method so that when the iOS device connects to the Rover, the two sliders are reset to their initial position, as follows:</p><div><pre class="programlisting">- (void)centralManager:(CBCentralManager *)central didConnectPeripheral:(CBPeripheral *)peripheral {
    
    _steeringWheelSlider.value = 100;
    _throttleSlider.value = 0;

    
    [peripheral discoverServices:@[[CBUUID UUIDWithString:NRF8001BB_SERVICE_UUID]]];
}</pre></div><p>The last method that we need to write is to control the forward/backward direction. We need to send two simple messages to the rover—<code class="literal">F</code> is for forward and <code class="literal">B</code> is for backward:</p><div><pre class="programlisting">- (IBAction)directionChanged:(UISwitch *)sender {
    
    NSData* data;
    
    if (sender.on) {
        data=[@"F" dataUsingEncoding:NSUTF8StringEncoding];
    }
    else {
        data=[@"B" dataUsingEncoding:NSUTF8StringEncoding];
    }
    
    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
    
    _throttleSlider.value = 0;
    [self throttleChanged:_throttleSlider];
}</pre></div><p>To avoid undesirable behavior, each time we switch the direction, the rover is stopped, by setting the speed to 0 via the <code class="literal">[self throttleChanged:_throttleSlider]</code> method call.</p><p>We<a id="id309" class="indexterm"/> are now ready for the rover's first test.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec03"/>Testing the Rover with manual driving</h3></div></div></div><p>To<a id="id310" class="indexterm"/> perform the first rover test, you can use the following procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Upload the Arduino code and check the console for any error message. If everything goes fine, Arduino is ready to take control over your rover.</li><li class="listitem">Power up both the motors and Arduino itself.</li><li class="listitem">Upload the iOS application to your device.</li><li class="listitem">Go to the second tab to scan for the Bluetooth BLE breakout board.</li><li class="listitem">Go to the first tab and progressively increase the Throttle slider. You should see the rover moving forward.</li><li class="listitem">You can make it move right and left by moving the Steering slider.</li><li class="listitem">Turn the direction switch, the rover stops. On increasing the speed again, the rover moves in the opposite direction it was moving before.</li><li class="listitem">When going on a slope, you will see the needle of the vertical and/or the horizontal gauge move up or down and/or left or right.</li><li class="listitem">When moving against an obstacle, the rover should stop before colliding against it.</li></ol><div></div><div><h3 class="title"><a id="tip35"/>Tip</h3><p>
<strong>Weird rover movements</strong>
</p><p>If the rover moves in a wrong direction, you probably have not wired either or both of the motors properly. Swap the wires of the motor that is spinning in the wrong direction.</p><p>
<strong>Weird gauge indications</strong>
</p><p>If the gauges don't seem to be moving accordingly with the slope, don't worry too much about this for now. We are going to calibrate them later. For now, we only have to check whether the data is being properly transferred from the rover to the iOS device.</p></div><div><h3 class="title"><a id="tip36"/>Tip</h3><p>
<strong>Missing gauge indications</strong>
</p><p>If you cannot see any indication from the gauges, there may be an error in cabling the ADXL345 device. First double-check whether the Arduino console has any error message. If this doesn't help, remove the comments from the following two lines in the Arduino code (the <code class="literal">main loop</code>):</p><div><pre class="programlisting">Serial.print("X: ")
Serial.print(event.acceleration.x); Serial.print("  ");
Serial.print("Y: "); Serial.print(event.acceleration.y);
Serial.print("  ");Serial.println("m/s^2 ");</pre></div><p>Connect the iOS device again and check the Arduino console. If you can see the printed numbers, then the accelerometer is working and you have to double-check the iOS code.</p><p>
<strong>The rover hits obstacles</strong>
</p><p>The distance sensor is sensitive to<a id="id311" class="indexterm"/> the shape, reflectance, and position of the obstacles and sometimes, it's not able to avoid them. This is the reason why different types of sensors are used at the same time, and in different positions in real-world robots. To check whether the sensor is properly connected and it's working as expected, you can remove the comment in the following line (in the <code class="literal">main loop</code>):</p><div><pre class="programlisting">Serial.print("D: "); Serial.println(distance);</pre></div><p>You should now be able to see the distance in the Arduino console.</p></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec04"/>Code for controlling the rover by the means of the iOS accelerometer</h3></div></div></div><p>We <a id="id312" class="indexterm"/>are now going to improve our app by using the iOS accelerometer to control the steering and the throttle.</p><p>As we learned earlier, any deviation in the iOS device position can be measured and used to send appropriate commands to the rover with the help of the accelerometer that we mounted on the rover.</p><p>To access the accelerometer information, we need to use the <code class="literal">CMMotionManager</code> class. First, we add <code class="literal">#import &lt;CoreMotion/CoreMotion.h&gt;</code> to <code class="literal">RoverViewController.h</code>. Then, we create a property, as follows:</p><div><pre class="programlisting">@interface RoverViewController ()

…

@property (strong, nonatomic) CMMotionManager       *motionManager;

…

@end</pre></div><p>Finally, we initialize it in the <code class="literal">viewDidLoad</code> method, as follows:</p><div><pre class="programlisting">- (void)viewDidLoad {
    
    [super viewDidLoad];
    
…
    _motionManager = [[CMMotionManager alloc] init];
…
}</pre></div><p>The accelerometer is activated when the <a id="id313" class="indexterm"/>second button is selected on the segment controller, and the related method is called:</p><div><pre class="programlisting">- (IBAction)modeChange:(UISegmentedControl *)sender {
    
    _throttleSlider.value = 0;
    _steeringWheelSlider.value = 100;
    
    if (_modeSegment.selectedSegmentIndex==1) {
        
        …
        [self useAccelerometer];
    }
    
    …
}</pre></div><p>The <code class="literal">useAccelerometer</code> method actually activates the accelerometer:</p><div><pre class="programlisting">-(void)useAccelerometer {
    
    [_motionManager setDeviceMotionUpdateInterval:0.2];
    [_motionManager startDeviceMotionUpdatesUsingReferenceFrame:CMAttitudeReferenceFrameXArbitraryZVertical
                                                        toQueue:[NSOperationQueue mainQueue]
                                                    withHandler:^(CMDeviceMotion *motion, NSError *error) {
                                                        
                                                        CMQuaternion quat = motion.attitude.quaternion;
                                                        
                                                        [self sendAccelerometersCommands:quat];
                                                    }];
}</pre></div><p>The <code class="literal">[_motionManager setDeviceMotionUpdateInterval:0.2]</code> method instructs the motion manager to update our code with acceleration values every 0.2 seconds.</p><p>The next method actually starts updating <a id="id314" class="indexterm"/>our code of accelerometer values, which are received in the handler block.</p><p>Fortunately, iOS provide us with not only the actual value of acceleration along the three axes of the device, but also the quaternions. Don't be afraid of the name! They simply represent orientations and rotations of the iOS device in three dimensions (if you like mathematics, visit <a class="ulink" href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation</a>). From them, you<a id="id315" class="indexterm"/> can easily calculate the two angles of the<a id="id316" class="indexterm"/> pitch and roll of the iOS device (see the following image). </p><p>If you have a liking for mathematics, visit <a class="ulink" href="https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles">https://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles</a>:</p><div><img src="img/image00206.jpeg" alt="Code for controlling the rover by the means of the iOS accelerometer"/></div><p style="clear:both; height: 1em;"> </p><p>The roll is used to change the rover's direction of movement, and the pitch is used to control the throttle. The <code class="literal">-(void)sendAccelerometersCommands:(CMQuaternion)quad</code> method calculates<code class="literal"> </code>the two angles and generates the <a id="id317" class="indexterm"/>messages that need to be sent to the rover, as we did in <code class="literal">throttleChanged</code> and <code class="literal">steeringWheelChanged</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec05"/>Driving the rover by the means of the iOS device movement</h3></div></div></div><p>To <a id="id318" class="indexterm"/>test the rover, tap on the accelerometer, switch to forward, and hold the iOS device vertically. By moving the device forward around the pitch axis (see the previous image), the rover should start moving forward. The more the device moves forward, the more the rover's speed increases. By moving the device backward, the rover's speed reduces, and you can stop the rover by using this movement.</p><p>To turn the rover left or right, the device has to be turned left or right around the roll axis.</p><p>To make the commands more or less responsive, you can try to change the frequency at which the code is updated with new acceleration values, as follows:</p><div><pre class="programlisting">[_motionManager setDeviceMotionUpdateInterval:0.2];</pre></div><p>Don't forget that increasing the update interval increases the battery consumption. The tradeoff is strictly related to your rover and your needs.</p></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec06"/>Code for controlling the rover by voice commands</h3></div></div></div><p>Voice recognition has been a<a id="id319" class="indexterm"/> challenge for years, but nowadays, you can add this feature to your application in a matter of minutes.</p><p>We have already added the required library. So, we can start adding the required code by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">RoverViewController.h</code> and add <code class="literal">#import &lt;OpenEars/OEEventsObserver.h&gt;</code>.</li><li class="listitem">Change the interface from <code class="literal">@interface RoverViewController : UIViewController &lt;CBCentralManagerDelegate, CBPeripheralDelegate&gt;</code> to <code class="literal">@interface RoverViewController : UIViewController &lt;CBCentralManagerDelegate, CBPeripheralDelegate, OEEventsObserverDelegate&gt;</code>.</li><li class="listitem">Open <code class="literal">RoverViewController.m</code> and add the following imports:<div><pre class="programlisting">#import &lt;OpenEars/OELanguageModelGenerator.h&gt;
#import &lt;OpenEars/OEPocketsphinxController.h&gt;
#import &lt;OpenEars/OEAcousticModel.h&gt;
#import &lt;Slt/Slt.h&gt;
#import &lt;OpenEars/OEFliteController.h&gt;</pre></div></li><li class="listitem">Add the following properties:<div><pre class="programlisting">@property (strong, nonatomic) NSString              *lmPath;
@property (strong, nonatomic) NSString              *dicPath;

@property (strong, nonatomic) OEEventsObserver      *openEarsEventsObserver;
@property (strong, nonatomic) OEFliteController     *fliteController;
@property (strong, nonatomic) Slt                   *slt;</pre></div></li><li class="listitem">Initialize the properties by adding the<a id="id320" class="indexterm"/> following code to the <code class="literal">viewDidLoad</code> method. The <code class="literal">words</code> array contains the voice commands that will be recognized. The rest of the code is from the documentation of the libraries:<div><pre class="programlisting">    NSMutableArray *words = [[NSMutableArray alloc] initWithArray:@[@"RIGHT", @"LEFT", @"CENTER", @"FORWARD", @"SLOWFORWARD", @"FASTFORWARD", @"BACKWARD", @"SLOWBACKWARD", @"FASTBACKWARD",@"STOP"]];
    
    _fliteController = [[OEFliteController alloc] init];
    _slt = [[Slt alloc] init];
    
    OELanguageModelGenerator *lmGenerator = [[OELanguageModelGenerator alloc] init];
    
    NSError *err=nil;
    NSString  *name = @"RoverVoiceControl";
    
    err = [lmGenerator generateLanguageModelFromArray:words withFilesNamed:name forAcousticModelAtPath:[OEAcousticModel pathToModel:@"AcousticModelEnglish"]];
    
    if(err == nil) {
        
        _lmPath = [lmGenerator pathToSuccessfullyGeneratedLanguageModelWithRequestedName:name];
        _dicPath = [lmGenerator pathToSuccessfullyGeneratedDictionaryWithRequestedName:name];
        
    } else {
        NSLog(@"Error: %@",[err localizedDescription]);
    }</pre></div></li><li class="listitem">Change the <code class="literal">modeChange</code> method in the following way (turn off the voice commands recognition and/or accelerometer when they are not being used):<div><pre class="programlisting">- (IBAction)modeChange:(UISegmentedControl *)sender {
    
    _throttleSlider.value = 0;
    _steeringWheelSlider.value = 100;

    if (_modeSegment.selectedSegmentIndex==0) {
        [[OEPocketsphinxController sharedInstance] stopListening];
        [_motionManager stopDeviceMotionUpdates];
    }
    
    if (_modeSegment.selectedSegmentIndex==1) {
        
        [[OEPocketsphinxController sharedInstance] stopListening];
        [self useAccelerometer];
    }
    
    if (_modeSegment.selectedSegmentIndex==2) {
        
        [_motionManager stopDeviceMotionUpdates];
        [self useVoice];
    }
}</pre></div></li><li class="listitem">Add the following <code class="literal">useVoice</code> method. It <a id="id321" class="indexterm"/>activates the listening of voice commands and configures the library in order to call the <code class="literal">pocketsphinxDidReceiveHypothesis</code> delegate method when a voice command is recognized:<div><pre class="programlisting">-(void)useVoice {
    
    [[OEPocketsphinxController sharedInstance] setActive:TRUE error:nil];
    
    [[OEPocketsphinxController sharedInstance] startListeningWithLanguageModelAtPath:_lmPath
                                                                    dictionaryAtPath:_dicPath
                                                                 acousticModelAtPath:[OEAcousticModel pathToModel:@"AcousticModelEnglish"]
                                                                 languageModelIsJSGF:NO];
    
    [[OEPocketsphinxController sharedInstance] setSecondsOfSilenceToDetect:.7];
    [[OEPocketsphinxController sharedInstance] setVadThreshold:3.0];
    
    _openEarsEventsObserver = [[OEEventsObserver alloc] init];
    [_openEarsEventsObserver setDelegate:self];
}</pre></div></li><li class="listitem">Add the <code class="literal">pocketsphinxDidReceiveHypothesis</code> method, which can be copied from the downloaded code. It doesn't do <a id="id322" class="indexterm"/>much other than formatting and sending commands to the rover much as we already did for the other modes. We just need to point out the following:<div><ul class="itemizedlist"><li class="listitem">The <code class="literal">hypothesis</code> parameter is a string with the recognized command</li><li class="listitem">The <code class="literal">[_fliteController say:hypothesis withVoice:self.slt]</code> call allows you to hear the recognized command that is pronounced by your iOS device<div><pre class="programlisting">- (void) pocketsphinxDidReceiveHypothesis:(NSString *)hypothesis recognitionScore:(NSString *)recognitionScore utteranceID:(NSString *)utteranceID {
    
    [_fliteController say:hypothesis withVoice:self.slt];
    
    NSString *msg=nil;
    
    if ([hypothesis isEqualToString:@"FORWARD"]) {
        
        [_arduinoDevice writeValue:[@"F" dataUsingEncoding:NSUTF8StringEncoding] forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
        
        msg = [NSString stringWithFormat:@"T=%ld",60l];
    }
    
    …
    
    NSData* data;
    data=[msg dataUsingEncoding:NSUTF8StringEncoding];
    
    [_arduinoDevice writeValue:data forCharacteristic:_sendCharacteristic type:CBCharacteristicWriteWithoutResponse];
}</pre></div></li></ul></div></li><li class="listitem">To complete the app, we have to<a id="id323" class="indexterm"/> add few lines in the <code class="literal">applicationDidEnterBackground</code> method in the <code class="literal">AppDelegate.m</code> file to disconnect from the rover when the app is sent to the background:<div><pre class="programlisting">    UITabBarController *tabController = (UITabBarController *)_window.rootViewController;
    RoverViewController *roverController = tabController.viewControllers[0];
    
    [roverController disconnect];</pre></div></li></ol><div></div></div><div><div><div><div><h3 class="title"><a id="ch04lvl3sec07"/>Driving the rover by voice commands</h3></div></div></div><p>To<a id="id324" class="indexterm"/> try this feature, you have to tap on Voice and then speak any of the available commands. When the application identifies a voice command, it pronounces the recognized command and the rover will start moving accordingly.</p><p>Please note that the voice recognition takes some time. Hence, the rover is not very responsive. The voice mode is more appropriate in wide space and for long navigation (whatever this could mean for a rover!)</p><p>If you experience low background noises that trigger speech recognition, you can raise the value in this call in the range of 1.5-3.5:</p><div><pre class="programlisting">[[OEPocketsphinxController sharedInstance] setVadThreshold:3.0]</pre></div><p>To make the rover a little bit more responsive, you can try to reduce the time that the app should wait for after the speech ends to attempt recognizing the speech (the default value is 0.7 seconds), as follows:</p><div><pre class="programlisting">[[OEPocketsphinxController sharedInstance] setSecondsOfSilenceToDetect:.7];</pre></div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec58"/>Testing and tuning</h2></div></div></div><p>We have <a id="id325" class="indexterm"/>already tested each mode of driving the rover, but we<a id="id326" class="indexterm"/> may still have unreliable readings from the accelerometer that is mounted on the rover itself.</p><p>To<a id="id327" class="indexterm"/> calibrate the accelerometer's readings, use the following procedure:</p><div><ol class="orderedlist arabic"><li class="listitem">Make sure that the ADXL345 is firmly mounted on the rover, and its axes are parallel to the longitudinal and transverse axes of the rover.</li><li class="listitem">Place the rover on a firm, flat surface and ensure that the rover is in plane with the help of a spirit level.</li><li class="listitem">Comment out the following lines in the <code class="literal">loop</code> function of the Arduino code and upload it:<div><pre class="programlisting">      Serial.print("X: "); Serial.print(event.acceleration.x); Serial.print("  ");
      Serial.print("Y: "); Serial.print(event.acceleration.y); Serial.print("  ");Serial.println("m/s^2 ");</pre></div></li><li class="listitem">Power <a id="id328" class="indexterm"/>Arduino via the USB cable and open the console.</li><li class="listitem">Connect the iOS device. The acceleration reading appears on the console for both the axes. They should be 0 or very close to 0. If this is not the case, take 10 to 20 readings, calculate the average, and put these values in the <code class="literal">setup</code> function for the <code class="literal">xOffset</code> and <code class="literal">yOffset</code> variables.</li></ol><div></div><p>Now, the readings from the accelerometer should be more consistent, and the two needles on the iOS devices should help you drive the rover on rough terrain, avoiding overturns.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec32"/>How to go further</h1></div></div></div><p>The <a id="id329" class="indexterm"/>following are some suggestions to improve the project:</p><div><ol class="orderedlist arabic"><li class="listitem">Show the distance to the front obstacles in the iOS application.</li><li class="listitem">Stop the rover when its inclination goes beyond a certain threshold.</li><li class="listitem">Add more distance sensors or mount the distance sensor on a servo motor so that the rover can detect obstacles all around it.</li><li class="listitem">Mount different types of sensors for better obstacle avoidance (for instance, ultrasound distance sensors or laser distance sensors).</li><li class="listitem">Allow iOS device landscape orientation. Here's a hint—you need to get the actual iOS device orientation by using one of the orientation delegate methods (<code class="literal">willTransitionToTraitCollection,viewWillTransitionToSize</code>), which is provided by the <code class="literal">ViewController</code> class.</li></ol><div></div><p>Voice recognition can be used on many projects because it's very simple to set up and works pretty well. You can start adding voice recognition to the Wi-Fi Power Plug project.</p><p>If you need a challenge, try to improve your rover by making it move autonomously, which can be done by making the rover become aware of its position. (A hint—you can use particle filters to accomplish this, but this is a very tough subject. The Google car is based on this and a lot of other things as well).</p></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec33"/>Summary</h1></div></div></div><p>You were introduced to the fascinating world of robotics and controlled vehicles. You learned how to write Arduino code to control both the speed and the direction of rotation of DC motors, measure the distance with an analog infrared sensor, and measure acceleration along the three axes by using an accelerometer.</p><p>You learned how to use new graphical components such as the <code class="literal">UISlider</code> and the <code class="literal">UISegmentedControl</code> on an iOS device, and take advantage of the accelerometer that is sported by iOS devices. Moreover, you learned how to improve your projects with a very powerful and easy-to-use library for voice recognition and text to speech.</p><p>Don't forget that you now have a rover that you can drive without other people thinking that you are odd; you are not playing like you were a child, you are learning robotics! Have fun with your rover!</p><p>This chapter is quite long and the project was complex, but we can now catch our breath. In the next chapter, we will build a very simple but extremely powerful project. It controls the volume of your TV set by keeping it at almost the same level even if commercials are on air. Even if the project is pretty easy, you will learn a lot about IR transmitters and receivers, and digital signal processing.</p></div></body></html>