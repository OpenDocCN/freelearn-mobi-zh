- en: Chapter 8. Artificial Intelligence and Game Progression
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*In the previous chapter, we learned about adding user interface elements to
    our game. We added a hit points representation above our ships, added buttons,
    and even created our own dialog.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will add artificial intelligence to our game. The following
    are the topics we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: The concepts of fuzzy logic and state machines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enemy ships should move and attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some kind of progression to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Winning and losing the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, before we get to the actual coding, let's see the concepts of artificial
    intelligence that we will implement.
  prefs: []
  type: TYPE_NORMAL
- en: Artificial intelligence in theory
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal for the enemy ships is to move around and attack our ships if they
    get close enough. There are two concepts we need to look into in detail to help
    us implement this logic; we will discuss these in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Explaining fuzzy logic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a moving train as an example. We could use a Boolean value to describe
    its state. If it is set to true, it's moving fast; if it's set to false, it's
    not moving fast.
  prefs: []
  type: TYPE_NORMAL
- en: However, that will not be enough. Let's say the train is moving at 80 miles
    per hour and then at 100 miles per hour. At both speeds, our Boolean value will
    be true, but we have no way of differentiating it further. Also, we don't have
    a state if the train is not moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fuzzy logic describes an interval of values put into a colloquial term. Let''s
    take a step back and compare it to mathematical logic. Binary (two-valued) logic
    has two values: true and false. An expression such as *1 + 1 = 2* evaluates to
    "true". The expression "Adding one to one is most likely going to be two" will
    not make much sense in binary logic, but it will be possible in fuzzy logic.'
  prefs: []
  type: TYPE_NORMAL
- en: Fuzzy logic doesn't have the two values true and false, but it has in-between
    values such as a bit, quite, or about. This is similar to human thinking.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate this point further, let''s take a look at what our moving train
    example looks like if put in table form:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Term | Speed |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| Not moving | 0 miles per hour |'
  prefs: []
  type: TYPE_TB
- en: '| Really slow | 1 to 9 miles per hour |'
  prefs: []
  type: TYPE_TB
- en: '| Almost fast | 10 to 49 miles per hour |'
  prefs: []
  type: TYPE_TB
- en: '| Quite fast | 50 to 89 miles per hour |'
  prefs: []
  type: TYPE_TB
- en: '| Really fast | 90 to 119 miles per hour |'
  prefs: []
  type: TYPE_TB
- en: 'For our game, we can apply this to a similar value: the distance between the
    enemy ship and our own ship.'
  prefs: []
  type: TYPE_NORMAL
- en: Explaining state machines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'State machines are a number of states put into a sequential logic circuit.
    This sounds abstract, so let''s explain it in detail: a state, first of all, is
    a value that changes if a different state becomes active. A door has two states:
    locked and unlocked. If the door is locked, it stays locked until it''s unlocked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example that is closer to our game: we need a number of states,
    for example, **Move to player**, **Wait 3 seconds**, and **Attack player**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to put these states in some kind of order. Let''s say the enemy
    first moves to the player, and then it attacks and waits for 3 seconds. Then,
    the process starts again, as demonstrated in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining state machines](img/1509OS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So far, we know about states and state machines. Finite state machines are state
    machines with a finite number of states. The preceding figure is of course a simplified
    example of how finite state machines can work. Some of the models also have transitions
    to describe the action taken to move from one state to another. In illustrations,
    transitions are often accompanied by conditions such as "Is the player in sight?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Most simple AIs employ this strategy. One of the most prominent examples is
    **Quake**. To be fair, different AI mechanics are used in more complex and modern
    games. One example is the AI adapting to the player''s actions: if in a strategy
    game, the player chooses to attack a specific point, the AI would adapt to defend
    this position more and more depending on how often the player attacked.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For our purposes, a finite state machine is more than enough. So, let''s see
    what states we need for the enemy ship:'
  prefs: []
  type: TYPE_NORMAL
- en: We want the enemy ship to wander around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want the enemy ship to move to the vicinity of the player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want the enemy ship to attack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We want the enemy ship to wait a bit after an attack (for the player to recuperate)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s put these states into a diagram as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Explaining state machines](img/1509OS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Letting the enemy ship move and attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know about fuzzy logic and state machines, we can implement these
    as mechanics for our artificial intelligence.
  prefs: []
  type: TYPE_NORMAL
- en: Moving the ship
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we want the ship to move around—both wander around and move to
    the player ship.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – getting the enemy ship to move around
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order for the enemy ship to move around, we need to use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open our Xcode project if it's not already open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Battlefield.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define all AI states as `enum`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the `Battlefield` scene, add a new instance variable called `_aiState`,
    which is of the `AIState` type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a callback block type, as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Declare three new methods for the `Ship` class, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `Ship.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Move the contents of the `-(void) moveToX:(float) x andY:(float) y` method into
    the `-(void) moveToX:(float)x andY:(float)y withBlock:(ShipCallback) block` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the new `moveTo` method, add the following code just after the `[tweenY
    animateProperty:@"y" targetValue:targetY];` line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Implement the `checkDistanceToShip` method with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `moveToShip` method should have the following body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Reimplement the `moveToX:(float)x andY:(float)y` method, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Move on to the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the initializer, set the `_aiState` instance variable to `StateWanderAround`,
    as shown in the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Remove the tween and the juggler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s declare a helper method for getting a random position on the screen,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define a method called `updateAI`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `updateAI` method at the point where we initialized the juggler previously,
    as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now see that our own ship and the enemy ship are moving around on their own.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – getting the enemy ship to move around](img/1509OS_08_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we opened our game project; in the next step, we looked into the
    `Battlefield.h` file. All of the AI states we previously mentioned were put into
    `enum`. In step 4, we defined an instance variable that holds the default AI state.
  prefs: []
  type: TYPE_NORMAL
- en: We already had a `moveTo` method in our `Ship` class which lets us move any
    ship around on the screen. Unfortunately, we currently don't have a way of knowing
    when the movement is over. We can employ an Objective-C language feature which
    we used in the previous chapters, that is, blocks. We defined a block as a parameter;
    when the movement was over, the block was called. In step 6, we defined our block
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we declared the general methods for our `Ship` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Moving to a position and using a callback once the movement is done
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the distance between the current ship and any other ship
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving to another ship and using a callback once the operation is over
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then got ready to implement these methods in step 8\. We first moved the
    contents of the old `moveTo` method to the new one with the callback.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we just needed to call the callback block once the animation was over.
    Since the tweens could potentially have two different speeds depending on the
    distance between the touch point and the ship, we needed to record whether each
    tween was completed for both of the tweens. To check if the tween was actually
    complete, we added a block to the `onComplete` property of the tween. Once the
    tween was done, the block got called. Inside this block, we set a Boolean value
    to flag that the current tween was complete, and if both tweens are complete,
    we invoked the callback. To be able to use our local variables in the `onComplete`
    blocks, we needed to prefix them with `__blocks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 11, we implemented a method that calculates the distance between two
    ships: we took the center of both ships, converted them into `SPPoint`, and utilized
    the static `distanceFromPoint` method that `SPPoint` provides. We only needed
    to return the result.'
  prefs: []
  type: TYPE_NORMAL
- en: The `moveToShip` method called the `moveTo` method with the coordinates of the
    ship passed in and some randomness attached to it. We used the `arc4random` function
    to get a random value. The `arc4random` function returned a floating point number
    between zero and one. The `arc4random_uniform` function took a parameter and created
    a random number between zero and the passed-in parameter minus one. In step 13,
    the `moveTo` method without the callback just called the `moveTo` version, with
    the callback passing through `nil` as the callback parameter.
  prefs: []
  type: TYPE_NORMAL
- en: When we moved to the `Battlefield.m` file, we set the `_aiState` instance variable
    to the `WanderState` AI state. We then safely removed the tween and the juggler,
    which were previously responsible for the enemy ships' move animation.
  prefs: []
  type: TYPE_NORMAL
- en: In step 17, we implemented a method that gets us a random position on the screen.
    We also set a margin so that the position was definitely within the borders of
    the screen. We used the `SPPoint` class factory method to store both the `x` and
    `y` positions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next step, we implemented the method that updates the AI:'
  prefs: []
  type: TYPE_NORMAL
- en: If the ship is wandering around, we get a random position and move there.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ship has moved, it checks if the distance between the player and the
    ship parameter is less than 200 points. The ship then moves to the player. If
    that's not the case, we call the `updateAI` method again with the `WanderState`
    AI state.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the ship moved to the player, it checks again for the distance. If it's lower
    than 100 points, it begins attacking, else it's back to wandering around.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inside the initializer, we called the `updateAI` method with the enemy ship
    and our default AI state. This should be right where we previously initialized
    our instance variable `_juggler`.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, the enemy ship moved around if it was in the correct
    state. It moved to the player ship if it was in sight. If the enemy ship was getting
    too close to the player, it just stopped.
  prefs: []
  type: TYPE_NORMAL
- en: Attacking other ships
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the enemy ship is moving around, let's get it to attack our own ship.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – the enemy should attack the player
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the enemy to attack the players'' ship, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Ship.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Refactor our `_juggler` instance variable to be a property, as shown in the
    following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following line of code, add a method called `shootWithBlock` that
    should shoot and have a callback as its parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `Ship.m` file and move the contents of the `shoot` method into the
    `shootWithBlock` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `shootWithBlock` method, invoke the callback as its last statement inside
    the complete listener of the `currentClip` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Update the `shoot` method to call the `shootWithBlock` method with `nil`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `Battlefield.m` file and add a method for collision detection, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `onEnterFrame` method, replace the current collision detection with
    the `checkShipCollision` method, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `WanderAround` AI state with an additional attack opportunity, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in the following code, add these states to our `switch`-`case` statements
    in our `updateAI` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the enemy ship gets close enough to our ship and is in the attacking state,
    it begins to attack our ship. Refer to the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – the enemy should attack the player](img/1509OS_08_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the `Ship.h` file, we refactored the `_juggler` instance variable into a
    property since we needed to access it from the battlefield scene and its access
    should not be limited to a `Ship` instance. We added the `shootWithBlock` method,
    which we implemented in step 4, where we moved the contents of the `shoot` method
    to the new `shootWithBlock` method.
  prefs: []
  type: TYPE_NORMAL
- en: We then invoked the callback that should now be the last statement in the event
    listener where the `currentClip` tween is completed. In step 6, we updated the
    `shoot` method to call the `shootWithBlock` method with an empty block, just like
    we did in the previous example.
  prefs: []
  type: TYPE_NORMAL
- en: Since we used collision detection more than once, we put it into a separate
    method in the next step. Now, we can replace our old collision detection logic
    by calling the new collision detection. We need to call it twice, once with `_pirateShip`
    as the first parameters and `_enemyShip` as the second parameter. The order of
    the parameter needs to be the other way around when we call `checkShipCollision`
    for the second time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In step 9, we added an additional state transition. If the distance between
    the pirate ship and the enemy ship was less than 100 points, it attacked directly
    instead of moving to the player first. In the following steps, we added the following
    two missing states:'
  prefs: []
  type: TYPE_NORMAL
- en: In the attack state, we called the `shootWithBlock` method, and when the shooting
    was complete, we moved to the recuperating state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `StateRecuperate` AI state, we waited for 0.3 seconds and then moved
    on to wandering around
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we ran the example, our state machine was completely finished and all states
    were being used.
  prefs: []
  type: TYPE_NORMAL
- en: Adding fuzzy values to the AI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our AI works so far, but we don't have any fuzzy logic yet.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – spicing up the AI with fuzzy values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To replace our hardcoded values, we need to use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Battlefield.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new method called `fuzzyValue`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Using the following code, update the hardcoded values with the values from
    the `fuzzyValue` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example. If we were to insert logging to see what the values actually
    are, we would see the following output:![Time for action – spicing up the AI with
    fuzzy values](img/1509OS_08_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The goal for this example is to replace our hardcoded values with something
    that resembles fuzzy logic. In step 2, we added a method that checks against the
    value and returns a new random value each time. The randomness is not a necessary
    factor of fuzzy logic, but it is used in this case so that the values are inside
    a specific range.
  prefs: []
  type: TYPE_NORMAL
- en: If we were to have more fuzzy values, it would be a good idea to hold those
    values inside `NSDictionary`. This dictionary would have a colloquial term as
    its key and a block for its value. Inside the block would be logic to return a
    random number. If the fuzzy value gets passed in, we call the block and get a
    random number.
  prefs: []
  type: TYPE_NORMAL
- en: Next up, we updated the hardcoded values with the `fuzzyValue` method and put
    it in a colloquial term each time.
  prefs: []
  type: TYPE_NORMAL
- en: When we ran the example, the AI worked like it did before, but it had additional
    randomness now.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can improve the AI quite a bit by moving the AI logic away from the battlefield
    scene into a separate class. Since we used the strings for our fuzzy values quite
    a lot, it may be a good idea to move them into constants or even create our own
    macros.
  prefs: []
  type: TYPE_NORMAL
- en: Adding progression to our game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that our AI is implemented, let's add some progression to our game. We will
    need to add levels. Each level should have one more enemy ship, and we can upgrade
    the damage and hit points of our ship in between the levels.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a World class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We need to keep some values, such as the current level, in a separate entity,
    which we will describe as a `World` class.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a World class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To implement our `World` class, we need to use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Objective-C class called `World`, which is derived from `NSObject`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To add a `level` property from the `int` type, do the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a static variable called `level` in `World.h`, as shown in the following
    line of code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a static getter with the same name that returns the static variable, as
    shown in the following line of code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a static setter (`setLevel`) that sets the static variable, as shown in
    the following line of code:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
- en: Repeat step 2 for the properties `gold`, `hitpoints`, and `damage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need a `levelMax` property, but this one does not have a setter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to import the `Assets.h` file inside the `World.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a static `reset` method that needs to be declared in `World.h`. It should
    look like the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need a `log` method. It needs to be declared in `World.h` and needs
    to look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In `Game.m`, we need to call the `World` methods inside its initializer, as
    shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result. We should now see the following output in
    the console:![Time for action – adding a World class](img/1509OS_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, we created the `World` class. Objective-C does not support static
    properties. We can imitate that behavior of having a static property if we add
    static methods that have `methodName` as their name where we return a value. We
    also need to define a method called `setMethodName` that has a parameter. Now
    we can access `methodName` just like a property. However, inside the pseudo-getter,
    we can only access static variables.
  prefs: []
  type: TYPE_NORMAL
- en: After we were done with the setup, we needed to import the `Assets` class in
    step 5\. After that, we added a `reset` method, which loaded the damage and hit
    points from our `gameplay.json` file. We set the `gold`, `level`, and `levelMax`
    variables to default values. In our case, the current level was the first one;
    we had a maximum of three levels, and 200 was the amount we had at our disposal
    at the start for the `gold` variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `log` method that we implemented later logged all values except for the
    `levelMax` value. In step 8, we called the `reset` method, and we called `log`
    directly after that. When we ran the example, we saw the log output in the console.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Right now, the `gold`, `level`, and `levelMax` variables are being set directly
    in the code. It's a better idea to load them from the `gameplay.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the scene and dialog classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we move on to implementing the progression system, there are a few small
    things we need to refactor. Let''s tackle these issues:'
  prefs: []
  type: TYPE_NORMAL
- en: We have no way of resetting a scene if it's being shown again
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiline strings in dialogs are not displayed correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We cannot access the dialog's buttons outside the `Dialog` class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The dialog doesn't close after clicking on the buttons
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Time for action – updating the scene and dialog classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add our first buttons, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Dialog.h` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add properties for both **Yes** and **No** buttons using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Switch to `Dialog.m`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor all references from the local variables to use the properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the positions of `_title` and `_content` using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In both `onButtonYes` and `onButtonNo`, add `self.visible = NO;` as the first
    statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Scene.h`, declare a method called `reset` using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In `Scene.m`, implement the `reset` method with an empty body.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `SceneDirector.m`, update this portion of code in the `showScene` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we were to implement the `reset` method to the battlefield scene and add
    a logger message to the `reset` method of the battlefield scene, our output would
    change to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – updating the scene and dialog classes](img/1509OS_08_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We tackled the dialog issues first. In steps 2 to 4, we moved the buttons to
    be properties and updated all references inside the `Dialog` implementation. We
    then updated the position of the title and the message content. Long strings were
    not wider than the bounds of the dialog. In step 6, we hid the dialog once we
    tapped on any button.
  prefs: []
  type: TYPE_NORMAL
- en: For a scene to be able to reset itself, we first needed to add the `reset` method
    and just implement it as an empty method in `Scene.m`. We then needed to update
    the scene director to call the `reset` method from the current scene just after
    the scene turned visible.
  prefs: []
  type: TYPE_NORMAL
- en: If we ran the example now, and if we implemented the `reset` method in the battlefield
    scene and added a logger message, we would see that the `reset` method from the
    battlefield scene would actually be called.
  prefs: []
  type: TYPE_NORMAL
- en: Adding game mechanics to the pirate cove
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have a `World` class and we have updated the `Dialog` and `Scene`
    classes to fit our needs, we can add some game mechanics to the pirate cove. The
    pirate cove is the place where we can upgrade our ship.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – making the pirate cove playable
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To add game mechanics to the pirate cove, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Move the line of code `[SPTextField registerBitmapFontFromFile:@"PirateFont.fnt"];`
    from `Dialog.m` to the beginning of the `Game.m` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a button in `PirateCove.m`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the button to the display tree using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the following code, we add a text field to display the current amount of
    gold, which needs to be declared as an instance variable first:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the text field to the display tree using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a method that updates the amount of gold on the screen using the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `PirateCove.h` file, add an instance variable called`_dialogUpdateDamage`
    using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add an instance variable called `_goldDamage` as shown in the following line
    of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the initializer, add the following piece of code for the first dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the dialog to the display tree using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the method `onUpdateDamage` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Repeat steps 7 to 11 for the dialog that upgrades the hit points.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a `reset` method to the pirate cove scene as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the statement in the `Game.m` file to show the pirate cove when starting
    the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run the example to see the result. We can now upgrade our ship in the pirate
    cove, as shown in the following screenshot:![Time for action – making the pirate
    cove playable](img/1509OS_08_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In step 1, we moved the registration of the bitmap font to the `Game` class.
    We only needed it once. Since we only had one dialog previously, it didn't really
    matter where we registered the font. However, as we now have multiple dialogs,
    the initializer of the dialog would register the font multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: In step 2, we added a button that will be able to switch to the battlefield
    scene when we tap it. After we added the button to the display tree, we also added
    a text field to display the current amount of gold. We subsequently added the
    text field to the display tree. We also added a method that updates the text field.
  prefs: []
  type: TYPE_NORMAL
- en: In steps 6 to 11, we added a dialog to the screen that pops up when we tap the
    weaponsmith. It checks if we have enough gold at our disposal and lets us upgrade
    our damage if we do.
  prefs: []
  type: TYPE_NORMAL
- en: In step 13, we implemented the `reset` method. The intention is to make upgrading
    the ship more and more expensive depending on the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Adding progression to the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything is set in place for adding progression to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero –turning our game into a real game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s go ahead and implement game progression. The following are a few things
    you should keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: The `World` values need to be reset before the battlefield instance is created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the amount of gold once the player gets to a higher level
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the `reset` method of the battlefield scene to reset position and hit points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There needs to be a way to keep track of all the sunken ships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The enemies should probably be array-like objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game itself should not start when the battlefield is initialized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After considering the preceding points, the game should look like what is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Have a go hero –turning our game into a real game](img/1509OS_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Take a look at how the preceding points can be implemented, and take these
    source files as the base for the following exercises:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Battlefield.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Battlefield.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Battlefield.m)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Game.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Game.m)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ship.h`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.h)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Ship.m`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/Classes/Ship.m)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gameplay.json`: [https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json](https://raw.github.com/freezedev/pirategame/9d5f53b5cb5e2e9bad822f0abd944e539e9bbf58/gameplay.json)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding win and lose conditions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing we will do in this chapter is add win and lose conditions for
    our game. Right now, we will just show a text field that displays whether we have
    won or lost.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – being able to win or lose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To be able to win or lose the game, use the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Ship.h`, add a callback property using the following line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This callback property gets invoked if the ship is equal to or less than zero
    hit points, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the `Battlefield.h` file, add two properties for our new text fields as
    shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the initializer, add the following piece of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `onEnterFrame` method, update the progression system by adding the
    winning condition as shown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the example to see the result.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we now win or lose the game, a text field will be displayed on the screen,
    as shown in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Time for action – being able to win or lose](img/1509OS_08_10.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We needed to know the exact point when a ship gets destroyed, so we added a
    callback in steps 1 and 2\. Precisely at the moment when the player ship gets
    destroyed, we wanted to display something to inform that the player has lost the
    game.
  prefs: []
  type: TYPE_NORMAL
- en: We then added the text fields in steps 3 and 4\. The only thing we needed to
    consider here is that we need to access `self` (the instance itself) inside the
    block. Typically, we can't access any property from `self` in the block, but we
    do need this because the text field is a property on the instance itself. So,
    we needed to use an unsafe reference by using the `__weak` keyword. This is something
    that should be used with caution and, in general, only as a last resort. We also
    needed to make sure that the text fields were added as the last elements to the
    display tree so that they were always on top of all other elements. After we added
    the lose condition, we added the win condition in step 5\. When we ran the example,
    we saw a text popping up if we either lost or won the game.
  prefs: []
  type: TYPE_NORMAL
- en: Technically, we could also have created the text field dynamically once we won.
    It is best practice, however, to create everything at the beginning, especially
    with complex projects.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Q1\. `SPPoint` provides a method to get the distance between two points.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q2\. A finite state machine always needs transitions.
  prefs: []
  type: TYPE_NORMAL
- en: 'True'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'False'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Q3\. If we want to modify a local variable inside a block, what do we need to
    do?
  prefs: []
  type: TYPE_NORMAL
- en: Make it a weak reference
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Prefix the variable with `__block`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Refactor it to a property
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about artificial intelligence. Specifically, we
    covered fuzzy logic and finite state machines, and we also added more gameplay
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Now that our game is feature-complete but rough around the edges, let's add
    some audio to our game—which is the topic of the next chapter.
  prefs: []
  type: TYPE_NORMAL
