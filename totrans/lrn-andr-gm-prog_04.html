<html><head></head><body>
        

            
                <h1 class="header-title">Creating Sprites and Interactive Objects</h1>
            

            
                
<p>We have learned almost everything about the basics that we need to create various components in Android, so we can now move on to do some more exciting stuff. Now, at this point, we will start working on a proper 2D game. It will be a small 2D side scroller game like Mario. However, before we do that, let's first talk about games as a development concept. In order to understand more about games, you will need to understand a bit of <strong>Game Theory</strong>. So, before we proceed with creating images and backgrounds on screen, let's dive into some game theory. Here are a list of topics we will be covering in this chapter:</p>
<ul>
<li>Game Theory</li>
<li>Working with colors</li>
<li>Creating images on screen</li>
<li>Making a continuous scrolling background</li>
</ul>
<p>Let's start with the first one.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Game Theory</h1>
            

            
                
<p>If you observe a game carefully in its source code level, you will observe that a game is just a set of illusions to create certain effects and display them on screen. Perhaps, the best example of this can be the game that we are about to develop. In order to make your character move ahead, you can do either of two things:</p>
<ul>
<li>Make the character move ahead</li>
<li>Make the background move behind</li>
</ul>
<p>Let's take a look at this in a bit more detail. The preceding two points can be achieved with the help of some illusions; let's understand how.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Illusions</h1>
            

            
                
<p>Either of the two things mentioned in the preceding section will give you an illusion that the character is moving in a certain direction. Also, if you remember Mario properly, then you will notice that the clouds and grasses are one and the same, only their colors were changed. This was because of the memory limitations of the console platform at the time:</p>
<p><img class="image-border" src="img/B05066_04_02-2.png"/></p>
<p>Game developers use many such <em>tricks</em> in order to get their game running. Of course, in today's times, we don't have to worry much about memory limitations because our mobile device has the capability of the Apollo 11 rocket, which landed on the moon. Now, keeping in mind the mentioned two scenarios; we will use one of them in our game to make our character move.</p>
<p>We also have to understand that every game is a loop of activities. Unlike an app, you will need to draw your game resources at every single frame. The illusion of moving or any other effect will be stronger the more frames per second the mobile device can draw them. This concept is called as <strong>Frames Per Second</strong> (<strong>FPS</strong>). It's almost similar to that of the concept of old films where a huge film used to be projected on the screen by rolling per frame. Take a look at the following screenshot to understand this concept better:</p>
<div><img class="image-border" height="327" src="img/B05066_04_01.png" width="613"/></div>
<p>Sprite sheet of a game character</p>
<p class="CDPAlignLeft CDPAlign">You must have been wondering since the last chapter what a sprite means, if not the popular cold drink. As you can see in the preceding screenshot, a sprite sheet is simply an image consisting of multiple images within themselves in order to create an animation, and thereby a sprite is simply an image. If we want to make our character run, we will simply read the file <kbd>Run_000</kbd> and play it all the way sequentially through to <kbd>Run_009</kbd>, which will make it appear as though the character is running. We will take a look at this in <a href="517d0010-d72f-4ccc-9f45-365f6918e87f.xhtml"><em>Chapter 5</em></a>, <em>Adding Animation to Your Game</em>, which we will follow through.</p>
<p>A majority of things that you will be working with when making a game would be based on manipulating your movements. So, you will need to be clear about your coordinates system because it will come in handy—be it for firing a bullet out of a gun, character movement, or simply turning around to look here and there--all of it is based on the simple component of movement.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Game loop</h1>
            

            
                
<p>In its core, every game is basically just a loop of events. It is a set up to give calls to various functions and code blocks to execute in order to have draw calls on your screen, and thereby making the game playable. Mostly, your game comprises three parts:</p>
<ul>
<li>Initialize</li>
<li>Update</li>
<li>Draw</li>
</ul>
<p>Initializing the game means to set an entry point to your game through which the other two parts can be called. Your game begins here and is called just once.</p>
<p>Once your game is initialized, you need to start giving calls to your events that can be managed through your <kbd>update</kbd> function.</p>
<p>The <kbd>draw</kbd> function is responsible for drawing all your image data on the screen. Everything you see on the screen including your backgrounds, images, or even your GUI is the responsibility of the <kbd>draw</kbd> method.</p>
<p>To say the least, your game loop is the heart of your game. This is just a basic overview of the game loop, and there is much more complexity you can add to it. However, for now, this much information is sufficient for you to get started.</p>
<p>The following image perfectly illustrates what a game loop is:</p>
<div><img class="image-border" height="207" src="img/B05066_04_03.png" width="435"/></div>
<p>Image Source: <a href="https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469">https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469</a></p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Game Design Document</h1>
            

            
                
<p>Before starting a game, it is essential to create a <strong>Game Design Document (GDD)</strong>. This document serves as a groundwork for the game you will be making. In all, 99% of the time when we start making a game, we lose track of the features planned for it and deviate from the core game experience. So, it is always recommended to have a GDD in place in order to keep focus. A GDD consists of the following things:</p>
<ul>
<li>Gameplay mechanics</li>
<li>Story (if any)</li>
<li>Level design</li>
<li>Sound and music</li>
<li>UI planning and game controls</li>
</ul>
<p>You can read more about the Game Design Document by navigating to the following link:</p>
<p><a href="https://en.wikipedia.org/wiki/Game_design_document">https://en.wikipedia.org/wiki/Game_design_document</a></p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Prototyping</h1>
            

            
                
<p>When making a game, we need to test it simultaneously. A game is one of the most complex pieces of software, and if we mess up on one part there is a chance that it might break the entire game as a whole. This process can be called as <strong>Prototyping</strong>. Making a prototype of your game is one of the most important aspects of a game because this is where you test out the basic mechanics of your game. A prototype should be a simple working model of your game with basic functionality. It can also be termed as a <strong>stripped down version</strong> of your game.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Surface and Canvas</h1>
            

            
                
<p>We saw how to create images and buttons using components from our palette in an Android app. However, this concept is a bit different in games. In games, we work with something known as a <strong>Canvas</strong>, which is used to draw images onto our <strong>Surface</strong>. To give you a basic understanding, a Surface is anything that holds pixels onto it. Basically, a Surface holds your Canvas, which then maps it onto your views. All of your image manipulations are is based on this. So, for the purpose of drawing anything in our game, we will use a <kbd>SurfaceView</kbd> component.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Working with colors and images</h1>
            

            
                
<p>Now that we have learned these concepts as well as having an understanding of working on Android Studio, we can proceed to start working on making our game from scratch. Let's clear all the buttons and text views in our <kbd>activity_fullscreen.xml</kbd> file and remove all the references in our Java code so that it looks somewhat like this:</p>
<div><img class="image-border" src="img/B05066_04_03.png"/></div>
<p class="CDPAlignLeft CDPAlign">Take a look at the Component Tree window below your Palette for a proper reference:</p>
<div><img class="image-border" src="img/B05066_04_04.png"/></div>
<p class="CDPAlignLeft CDPAlign">Note here that at this point we are back to square one with our app.</p>
<p class="CDPAlignLeft CDPAlign">When you are done with this, just run and test your app once to check whether there are any errors; if not, then proceed further. We will now take a look at how to create basic colors using hex color codes and then proceed to create images for our background as well as other components.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating colors</h1>
            

            
                
<p class="CDPAlignLeft CDPAlign">This is fairly simple, and we have seen this in our previous chapter as well. Simply go to your <kbd>colors.xml</kbd> file located in the <kbd>app/res/values/</kbd> folder. Here, you can observe multiple hex color code values. A hex color code represents a six-digit alphanumeric value, which is responsible for giving a color. The value starts from <strong>#000000</strong> (black) to <strong>#ffffff</strong> (white). </p>
<p class="CDPAlignLeft CDPAlign">In our <kbd>colors.xml</kbd>, if you observe there are already predefined values as seen in the following screenshot:</p>
<div><img class="image-border" src="img/B05066_04_05.png"/></div>
<p>Hex color code values</p>
<p class="CDPAlignLeft CDPAlign">In this file, you can tweak in these values or simply add your own values as well. Let's say if you want to add the color red, then you simply add the following line into this code to get the red value:</p>
<pre>
&lt;color name="red"&gt;#ff0000&lt;/color&gt;
</pre>
<p class="CDPAlignLeft CDPAlign">If you observe the syntax closely, you will observe that this hex code is in the format of <kbd>RRGGBB</kbd>, which means that the first two alphanumeric digits constitute the composition of the red color, the second two digits correspond to the green color, and the last two digits correspond to that of the blue color. Also, with the name field, you can use this color in any component as we have done in our background. Go ahead, try and tweak some values in the <kbd>colorPrimary</kbd>, and see what changes happen.</p>
<p>Also, note here that in hex color code, we can only use numbers from 0-9 and characters from a-f. So, if you use something such as #99z9pt, then this won't give out any color or number output. Try this out so that you get a clearer understanding of this color code concept.</p>
<p class="CDPAlignLeft CDPAlign">That is all about colors in Android Studio. You can use them in your backgrounds, surfaces, and so on using your understanding of XML files as we have seen in previous chapters, or you also set them programmatically from your Java code. Let's now move on to the most interesting part, working with images.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Creating images</h1>
            

            
                
<p>We've taken a look at the project structure of an Android project. So, by now we are clear about the difference between where to put code files and where to put our resources. Images are resources, and therefore, they can either be put in the <kbd>res</kbd> folder of our Android Studio Project or AssetManager, but more specifically, we can't just put them in the <kbd>res</kbd> folder.</p>
<p>There is, by convention, a specific folder exclusively for our image resources, that is, the <kbd>drawable</kbd> folder. You can find this folder in <kbd>app/res/drawable</kbd>. If you are not able to see it, then create it manually by right-clicking on the <kbd>res</kbd> folder and selecting New | Android resource directory, and in Resource Type, select drawable. You do not have to do this if the <kbd>drawable</kbd> folder already exists in your folder:</p>
<div><img class="image-border" src="img/B05066_04_06.png"/></div>
<p>Creating the drawable folder</p>
<p class="CDPAlignLeft CDPAlign">This folder includes all your image resources in your project including resources, such as background images, icons, and sprite sheets. For the purpose of this game, we'll put all our image resources into the <kbd>drawable</kbd> folder. We will now create a background image, and in our next chapter, we will learn how to put another image on top of that. After we are done with this, we will create an <kbd>OnClickListener</kbd> on our newly created image on top of our background so that it changes the image. So for this, we will need three image resources. Let's call them the following:</p>
<ul>
<li><kbd>background_image</kbd></li>
<li><kbd>image_1</kbd></li>
<li><kbd>image_2</kbd></li>
</ul>
<p>For this chapter, we have taken the following stock images. You are free to use any images of your choice as you deem fit.</p>
<p><kbd>background_image</kbd>: The following is the background image we will be using for our game:</p>
<p><img class="image-border" src="img/B05066_04_11.png"/></p>
<p class="CDPAlignLeft CDPAlign"><kbd>image_1</kbd>: The following is one of the frames of our player:</p>
<div><img class="image-border" height="234" src="img/image_1.png" width="237"/></div>
<p class="CDPAlignLeft CDPAlign"><kbd>image_2</kbd>: The following is another image frame of our character:</p>
<div><img class="image-border" height="265" src="img/image_2.png" width="260"/></div>
<p>So, we will have our <kbd>background_image</kbd> and <kbd>image_1</kbd> on top of it. When we click on our <kbd>image_1</kbd>, it will get converted into <kbd>image_2</kbd>. Let's get some stock image resources and put them into our <kbd>res/drawable</kbd> folder. To do this, simply right-click on any images you want to put in the <kbd>drawable</kbd> folder and select Copy:</p>
<div><img class="image-border" src="img/B05066_04_07.png"/></div>
<p class="CDPAlignLeft CDPAlign">And then, right-click on the drawable folder and select Paste:</p>
<div><img class="image-border" src="img/B05066_04_08.png"/></div>
<p class="CDPAlignLeft CDPAlign">After this, you will be prompted with a dialog box. Press Ok to successfully import your image resources in your <kbd>project</kbd> folder.</p>
<p class="CDPAlignLeft CDPAlign">Now that we have our image resources in place, it's time to get them on our screen. You can do this right away by taking an ImageView component and setting its property to your desired image, but since we are making a game, we will go the <em>Canvas Way</em>. To do that, first we need to replace our entire Java code, in our <kbd>FullscreenActivity.java</kbd> and make it look like this:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.os.Bundle;<br/>import android.view.Window;<br/>import android.view.WindowManager;<br/>import android.app.Activity;<br/><br/>public class FullscreenActivity extends <strong>Activity</strong>{<br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/><strong>        //Set our game to full screen mode<br/>        getWindow().setFlags<br/>        (WindowManager.LayoutParams.FLAG_FULLSCREEN,<br/>        WindowManager.LayoutParams.FLAG_FULLSCREEN);</strong><br/><br/><strong>        //Set no title on screen<br/>        requestWindowFeature(Window.FEATURE_NO_TITLE);</strong><br/><br/><strong>        setContentView(new GameView(this));</strong><br/>    }<br/>}
</pre>
<p>All the changes you need to do in your existing code have been marked in <strong>bold</strong></p>
<p class="CDPAlignLeft CDPAlign">Note here that we have eliminated all the toggle status bar functions and have kept only our <kbd>onCreate</kbd> method. The other interesting thing we did with the <kbd>getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);</kbd> is that we have manually set our game to fullscreen mode. We also eliminated the Title screen window with <kbd>requestWindowFeature(Window.FEATURE_NO_TITLE);</kbd> code. Now, note here you will be getting an error on your <kbd>GameView(this)</kbd> code. This is because we still haven't created our <kbd>GameView</kbd> class. So, let's go ahead and make that but before that let's make one minor change in our manifest file.</p>
<p class="CDPAlignLeft CDPAlign">Open up your <kbd>AndroidManifest.xml</kbd> file located in the <kbd>app/manifests/</kbd> folder. In your <kbd>&lt;activity&gt;</kbd> code, add the orientation as landscape as follows:</p>
<pre>
&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;manifest xmlns:android="http://schemas.android.com/apk/res/android"<br/>    package="nikhil.nikmlnkr.game"&gt;<br/><br/>    &lt;application<br/>        android:allowBackup="true"<br/>        android:icon="@mipmap/ic_launcher"<br/>        android:label="@string/app_name"<br/>        android:supportsRtl="true"<br/>        android:theme="@style/AppTheme"&gt;<br/>        &lt;activity<br/>            <strong>android:screenOrientation=</strong><strong>"landscape"</strong><br/>            android:name=".FullscreenActivity"<br/>            android:configChanges="orientation<br/>            |keyboardHidden|screenSize"<br/>            android:label="@string/app_name"<br/>            android:theme="@style/FullscreenTheme"&gt;<br/>            &lt;intent-filter&gt;<br/>                &lt;action android:name="android.intent.action.MAIN" /&gt;<br/><br/>                &lt;category android:name=<br/>                "android.intent.category.LAUNCHER" /&gt;<br/>            &lt;/intent-filter&gt;<br/>        &lt;/activity&gt;<br/>    &lt;/application&gt;<br/><br/>&lt;/manifest&gt;
</pre>
<p>This will now explicitly tell the application that our game is in landscape mode.</p>
<p class="CDPAlignLeft CDPAlign">Now, let's move ahead and make our <kbd>GameView</kbd> class. To do so, simply right-click on your <kbd>app/java/packagename</kbd> folder and select New | Java Class, like this:</p>
<div><img class="image-border" src="img/B05066_04_09.png"/></div>
<p class="CDPAlignLeft CDPAlign">After you do so, a new window will open up asking you the details of the new class you want to make. Simply type in <kbd>GameView</kbd> inside of the Name text box and press OK to proceed, as shown in the following screenshot:</p>
<div><img class="image-border" src="img/B05066_04_10.png"/></div>
<p class="CDPAlignLeft CDPAlign">We will be needing two more classes to set our side-scrolling background image, so repeat the same process and create the following two classes:</p>
<ul>
<li><kbd>BackgroundImage</kbd></li>
<li><kbd>MainGameThread</kbd></li>
</ul>
<p>So, in total, you now have four classes in your project:</p>
<ul>
<li><kbd>BackgroundImage</kbd></li>
<li><kbd>FullscreenActivity</kbd></li>
<li><kbd>GameView</kbd></li>
<li><kbd>MainGameThread</kbd></li>
</ul>
<p>Our aim is to have a background image on the screen, which would continuously scroll through our view. Let's first open up our <kbd>BackgroundImage.java</kbd> file and write the following code in it:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.graphics.Bitmap;<br/>import android.graphics.Canvas;<br/><br/>public class BackgroundImage {<br/><br/>    private int xc, yc, dxc;<br/>    private Bitmap backgroundImage;<br/><br/>    public BackgroundImage(Bitmap res)<br/>    {<br/>        backgroundImage = res;<br/>    }<br/><br/>    public void setVector(int dxc)<br/>    {<br/>        this.dxc = dxc;<br/>    }<br/><br/>    public void update()<br/>    {<br/>        xc += dxc;<br/>        if(xc &lt; -GameView.WIDTH){<br/>            xc=0;<br/>        }<br/>    }<br/><br/>    public void draw(Canvas canvas)<br/>    {<br/>        canvas.drawBitmap(backgroundImage, xc, yc,null);<br/>        if(xc &lt; 0)<br/>        {<br/>            canvas.drawBitmap<br/>            (backgroundImage, xc + GameView.WIDTH, yc, null);<br/>        }<br/>    }<br/>}
</pre>
<p>Let's try to understand this code now. We have simply created a class here and following is a step-by-step breakdown of each code block inside our class:</p>
<ol>
<li>We imported Bitmap and Canvas, which is needed for our image and Canvas operations.</li>
<li>We declared private variables <kbd>xc</kbd>, <kbd>yc</kbd>, and <kbd>dxc</kbd>, which are simply the <em>x</em>, <em>y</em> coordinates and displacement in <em>x</em>. The default value of these variables will be zero since we haven't initialized them.</li>
<li>We then declared a Bitmap private variable, which will be holding our actual image file to be displayed on the screen.</li>
<li>Next, we created a constructor for our class, so we can pass an image into it using the res reference inside it and within our constructor, we equated this reference with our background image variable declared in step 3.</li>
<li>We then created a vector displacement method in order to add a unit vector to our image's position value in order to make it move.</li>
<li>Then, we used the update method that will be called every time and put all our displacement and reset logic in it. If the image goes out of our screen, then we reset the position to 0 in order to give a continuous movement effect.</li>
<li>Now, if you remember, we discussed at the beginning that in order to draw anything on the screen, you need a Canvas. So, using the draw method, we took a Canvas as a reference variable and included our draw logic in it. Observe here that we are drawing our background image twice. This is because if our image is scrolling continuously, then there will be a void in between and it'll appear black, so we use the same image and draw it twice on screen a bit further from our main image in order to give a continuous loop effect. In order to understand this as a live example, you can try removing either one of the <kbd>canvas.drawBitmap()</kbd> code to see for yourself.</li>
</ol>
<p>That's it for the <kbd>BackgroundImage.java</kbd> file. By this time, you must be getting a few errors on your <kbd>GameView.WIDTH</kbd> code. Don't worry about that. We will come to it later. Before addressing that error, we must first set up our game thread since all our update functions are going to be called from our thread. Our objectives for our <kbd>MainGameThread.java</kbd> file are the following:</p>
<ul>
<li>Give a continuous call to the update function</li>
<li>Base our performance on frames per second</li>
</ul>
<p>So, open up your <kbd>MainGameThread.java</kbd> file and type in the following:</p>
<pre>
package nikhil.nikmlnkr.game;<br/>import android.graphics.Canvas;<br/>import android.view.SurfaceHolder;<br/><br/>public class MainGameThread extends Thread<br/>{<br/>    private int framesPerSecond = 30;<br/>    private double averageFPS;<br/>    private SurfaceHolder surfaceHolder;<br/>    private GameView gameView;<br/>    private boolean running;<br/>    public static Canvas canvas;<br/><br/>    public MainGameThread(SurfaceHolder surfaceHolder, GameView <br/>    gameView){<br/>        super();<br/>        this.surfaceHolder = surfaceHolder;<br/>        this.gameView = gameView;<br/>    }<br/><br/>    public void setRunning(boolean b){<br/>        running=b;<br/>    }<br/><br/>    @Override<br/>    public void run(){<br/>        long startTime;<br/>        long timeMillis;<br/>        long waitTime;<br/>        long totalTime = 0;<br/>        int frameCount =0;<br/>        long targetTime = 1000/framesPerSecond;<br/><br/>        while(running) {<br/>            startTime = System.nanoTime();<br/>            canvas = null;<br/><br/>            //try locking the canvas for pixel editing<br/>            try {<br/>                canvas = this.surfaceHolder.lockCanvas();<br/>                synchronized (surfaceHolder) {<br/>                    this.gameView.update();<br/>                    this.gameView.draw(canvas);<br/>                }<br/>            } catch (Exception e) {<br/>            }<br/>            finally{<br/>                if(canvas!=null)<br/>                {<br/>                    try {<br/>                        surfaceHolder.unlockCanvasAndPost(canvas);<br/>                    }<br/>                    catch(Exception e){e.printStackTrace();}<br/>                }<br/>            }<br/>            timeMillis = (System.nanoTime() - startTime) / 1000000;<br/>            waitTime = targetTime-timeMillis;<br/><br/>            try{<br/>                this.sleep(waitTime);<br/>            }catch(Exception e){}<br/><br/>            totalTime += System.nanoTime()-startTime;<br/>            frameCount++;<br/>            if(frameCount == framesPerSecond){<br/>                averageFPS = 1000/((totalTime/frameCount)/1000000);<br/>                frameCount = 0;<br/>                totalTime = 0;<br/>                System.out.println(averageFPS);<br/>            }<br/>        }<br/>    }<br/>}
</pre>
<p>Here's what we have done in our <kbd>MainGameThread.java</kbd> file:</p>
<ol>
<li>We created all the variables needed to run our thread.</li>
<li>We created the constructor for our <kbd>MainGameThread</kbd> file by taking a <kbd>SurfaceHolder</kbd> and <kbd>GameView</kbd> references and set their references to <kbd>this</kbd> file.</li>
<li>We created a method to keep a track of our running thread with a return value of Boolean.</li>
<li>We override the default <kbd>run</kbd> method of a thread to make it do the stuff we need specifically:
<ol>
<li>We use our surfaceholder variable for manipulating our image pixel data.</li>
<li>We calculate our frames per second.</li>
<li>We take an average of frames per second to calculate and display it in the console view.</li>
</ol>
</li>
</ol>
<p>By doing this, we are now ready with our thread class and finally only left with our <kbd>GameView</kbd> class. In our <kbd>GameView</kbd>, we are actually going to put all the image data we built on screen and display it. So, let's open up the <kbd>GameView.java</kbd> file and start typing the following:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.content.Context;<br/>import android.graphics.BitmapFactory;<br/>import android.graphics.Canvas;<br/>import android.view.MotionEvent;<br/>import android.view.SurfaceHolder;<br/>import android.view.SurfaceView;<br/><br/><br/>public class GameView extends SurfaceView implements SurfaceHolder.Callback {<br/>    public static final int WIDTH = 1920;<br/>    public static final int HEIGHT = 1080;<br/>    private MainGameThread mainThread;<br/>    private BackgroundImage bgImg;<br/><br/>    public GameView(Context context){<br/>        super(context);<br/><br/><br/>        //set callback to the surfaceholder to track events<br/>        getHolder().addCallback(this);<br/><br/>        mainThread = new MainGameThread(getHolder(), this);<br/><br/>        //make gamePanel focusable so it can handle events<br/>        setFocusable(true);<br/>    }<br/><br/>    @Override<br/>    public void surfaceChanged(SurfaceHolder holder, int format, <br/>    int width, int height){}<br/><br/>    @Override<br/>    public void surfaceDestroyed(SurfaceHolder holder){<br/>        boolean retry = true;<br/>        while(retry){<br/>            try{<br/>                mainThread.setRunning(false);<br/>                mainThread.join();<br/>            }catch(InterruptedException e){e.printStackTrace();}<br/>            retry = false;<br/>        }<br/><br/>    }<br/><br/>    @Override<br/>    public void surfaceCreated(SurfaceHolder holder){<br/><br/>        bgImg = new BackgroundImage(BitmapFactory.decodeResource<br/>        (getResources(), R.drawable.background_image));<br/>        bgImg.setVector(-5);<br/><br/>        //we can safely start the game loop<br/>        mainThread.setRunning(true);<br/>        mainThread.start();<br/><br/>    }<br/>    @Override<br/>    public boolean onTouchEvent(MotionEvent event){<br/>        return super.onTouchEvent(event);<br/>    }<br/><br/>    public void update(){<br/>        bgImg.update();<br/>    }<br/><br/>    @Override<br/>    public void draw(Canvas canvas){<br/>        final float scaleFactorX = getWidth()/WIDTH;<br/>        final float scaleFactorY = getHeight()/HEIGHT;<br/>        if(canvas != null) {<br/>            final int savedState = canvas.save();<br/>            canvas.scale(scaleFactorX, scaleFactorY);<br/>            bgImg.draw(canvas);<br/>            canvas.restoreToCount(savedState);<br/>        }<br/>    }<br/>}
</pre>
<p>This code is pretty easy to understand. Our <kbd>GameView</kbd> is the place where we create our Surface and draw everything onto it. So, we have extended the <kbd>SurfaceView</kbd> and implemented our callback, <kbd>SurfaceHolder</kbd>. This gives us access to some pre-written methods, which we will be overriding. Before you understand these methods, let's try to understand the logic behind this code. It can be divided into the following:</p>
<ol>
<li>We create the default constructor for our GameView class, which then gives a call to start our <kbd>MainGameThread</kbd>.</li>
<li>Using predefined methods, we override them and create our Canvas on top of our surface.</li>
<li>We call the update function in our <kbd>BackgroundImage</kbd> class.</li>
<li>We set scaling of our image to match our phone's resolution dynamically.</li>
</ol>
<p>Now that we know the logic, we can now read through the methods and understand them each one by one. We have the following methods in our code:</p>
<ul>
<li><kbd>surfaceChanged</kbd>: We have created an empty method with parameters. If our surface changes, then this method is called</li>
<li><kbd>surfaceDestroyed</kbd>: If the surface is destroyed, this method is called</li>
<li><kbd>surfaceCreated</kbd>: After our surface is created, we can start the game loop; this is where we initialize our background image and set its resource, as you can see in the code, <kbd>bgImg = newBackgroundImage(BitmapFactory.decodeResource(getResources(), R.drawable.background_image));</kbd></li>
<li><kbd>onTouchEvent</kbd>: This method is called whenever there is a touch on the screen</li>
<li><kbd>update</kbd>: This method is the update method, and in here, we are giving a call to the <kbd>update</kbd> method of <kbd>BackgroundImage</kbd></li>
<li><kbd>draw</kbd>: This method gives a call to draw our image onto the screen, and we make some calculations to scale our image and set it properly onto our phone as per its resolution</li>
</ul>
<p>After you are done with this file, don't forget to check your <kbd>FullscreenActivity.java</kbd> and make sure that its code looks like this:</p>
<pre>
package nikhil.nikmlnkr.game;<br/><br/>import android.os.Bundle;<br/>import android.view.View;<br/>import android.view.Window;<br/>import android.view.WindowManager;<br/>import android.app.Activity;<br/><br/>public class FullscreenActivity extends Activity{<br/><br/>    @Override<br/>    protected void onCreate(Bundle savedInstanceState) {<br/>        super.onCreate(savedInstanceState);<br/>        //Set our game to full screen mode<br/>        getWindow().setFlags<br/>        (WindowManager.LayoutParams.FLAG_FULLSCREEN,<br/>        WindowManager.LayoutParams.FLAG_FULLSCREEN);<br/><br/>        //Set no title on screen<br/>        requestWindowFeature(Window.FEATURE_NO_TITLE);<br/><br/>        setContentView(new GameView(this));<br/>    }<br/>}
</pre>
<p>It is now recommended that you build an apk for this game and test it on your device since if you try running this on your emulator it will run extremely slow.</p>
<p>Build it and execute it on your device/emulator, and you will see an output like this in which your background image is continuously scrolling:</p>
<div><img class="image-border" src="img/B05066_04_11.png"/></div>
<p class="CDPAlignLeft CDPAlign">That's it! Your side-scrolling background is up and running.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    

        

            
                <h1 class="header-title">Summary</h1>
            

            
                
<p>Congratulations! You have successfully learned how to create images and work with colors in Android Studio. You have also implemented a side-scrolling background, which will act as a foundation for the further part of this game.</p>
<p>In the next chapter, we will create our player character and implement a click listener on our image objects as well as learn how to animate objects with the concept of sprite sheets we have just learned.</p>


            

            <footer style="margin-top: 5em;">
                
            </footer>

        
    </body></html>