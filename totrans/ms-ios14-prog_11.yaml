- en: '*Chapter 11*: Adding Media to Your App'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 11 章*：将媒体添加到您的应用程序中'
- en: A lot of the apps that people use every day make use of media in some way. Some
    apps show photos and videos in a user's feed. Other apps focus on playing audio
    or video, while there are also apps that allow users to record media and share
    it with their peers. You can probably name at least a couple of very well-known
    apps that make use of such media in one way or the other.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 人们每天使用的许多应用程序都以某种方式使用媒体。一些应用程序在用户的动态信息中展示照片和视频。其他应用程序专注于播放音频或视频，同时也有一些应用程序允许用户录制媒体并与他们的同伴分享。你可能至少能说出两三个非常著名的应用程序，它们以某种方式使用此类媒体。
- en: Because media has such a significant presence in people's daily lives, it's
    good to know how you can integrate media into your own apps. iOS has excellent
    support for media playback and offers several different ways to create and consume
    different types of media. Some ways provide less flexibility but are more straightforward
    to implement. Others are more complex but provide significant power to you as
    a developer.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 由于媒体在人们的日常生活中具有如此显著的存在感，了解如何将媒体集成到自己的应用程序中是很好的。iOS 对媒体播放提供了出色的支持，并提供了多种创建和消费不同类型媒体的方法。一些方法提供了较少的灵活性，但实现起来更直接。其他方法更复杂，但为你作为开发者提供了显著的力量。
- en: 'In this chapter, you will learn about several ways to play and record media
    on iOS. You will learn how to play and record video, play audio, and take pictures,
    and you''ll even learn how to apply filters to images with Apple''s Core Image
    framework. This chapter covers the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将了解在 iOS 上播放和录制媒体的好几种方法。你将学习如何播放和录制视频、播放音频、拍照，甚至还将学习如何使用苹果的 Core Image
    框架对图像应用滤镜。本章涵盖了以下主题：
- en: Playing audio and video
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音频和视频
- en: Recording video and taking pictures
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 录制视频和拍照
- en: Manipulating photos with Core Image
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Core Image 处理照片
- en: By the end of this chapter, you will have a great foundation that you can build
    on to create engaging experiences for your users, allowing them to not only view
    content but also to create their own content in your app.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个坚实的基础，你可以在此基础上为你的用户创建引人入胜的体验，使他们不仅能够查看内容，还能在你的应用程序中创建自己的内容。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code bundle for this chapter includes two starter projects called `Captured_start`
    and `MediaPlayback_start`. You can find them in the code bundle repository:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码包包括两个起始项目，分别称为 `Captured_start` 和 `MediaPlayback_start`。你可以在代码包仓库中找到它们：
- en: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)'
- en: Playing audio and video
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音频和视频
- en: To make playing audio and video files as simple and straightforward as can be,
    Apple has created the `AVFoundation` framework. This framework contains a lot
    of helper classes that provide very low-level control over how iOS plays audio
    and video files. You can use `AVFoundation` to build a rich, custom media player
    with as many features as you need for your purpose.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使播放音频和视频文件尽可能简单直接，苹果创建了 `AVFoundation` 框架。这个框架包含了许多辅助类，它们提供了对 iOS 播放音频和视频文件的低级别控制。你可以使用
    `AVFoundation` 来构建一个功能丰富的自定义媒体播放器，以满足你的需求。
- en: If you're looking for a simpler way to integrate media into your app, the `AVKit`
    framework might be what you need. `AVKit` contains several helpers that build
    upon the `AVFoundation` components to provide an excellent default player that
    supports many features, such as subtitles, AirPlay, and more.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在寻找一种更简单的方法将媒体集成到你的应用程序中，`AVKit` 框架可能正是你所需要的。`AVKit` 包含了几个辅助工具，它们建立在 `AVFoundation`
    组件之上，以提供一个支持许多功能（如字幕、AirPlay 等）的优秀默认播放器。
- en: In this section, you will learn how to implement a simple video player with
    `AVPlayerViewController` from the `AVKit` framework. You will also implement a
    more complex audio player with `AVFoundation` components that play audio in the
    background and display, on the lock screen, the audio track currently being played.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将学习如何使用 `AVKit` 框架中的 `AVPlayerViewController` 实现一个简单的视频播放器。你还将实现一个更复杂的音频播放器，使用
    `AVFoundation` 组件在后台播放音频，并在锁屏上显示当前播放的音频轨道。
- en: To follow along with the examples, you should open the `MediaPlayback_start`
    project in this chapter's code bundle. The starter app contains a straightforward
    interface with a tab bar and two pages. You will implement a video player on one
    page, and the audio player on the other page. The audio page comes with some predefined
    controls and actions that you will implement later.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随示例，你应该打开本章代码包中的 `MediaPlayback_start` 项目。起始应用包含一个带有标签栏和两个页面的简单界面。你将在一个页面上实现视频播放器，在另一个页面上实现音频播放器。音频页面包含一些预定义的控件和动作，你将在稍后实现。
- en: Creating a simple video player
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建简单的视频播放器
- en: 'The first thing you need to do to implement a video player is to obtain a video
    file. You can use any video that is encoded in the `h.264` format. A good sample
    video is the **Big Buck Bunny** sample movie that was created by the Blender Foundation.
    You can find this video at the following URL: [http://bbb3d.renderfarming.net/download.html](http://bbb3d.renderfarming.net/download.html).
    If you want to use this video to practice with, make sure to download the 2D version
    of the video.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 实现视频播放器的第一步是获取一个视频文件。你可以使用任何编码为 `h.264` 格式的视频。一个很好的示例视频是由 Blender 基金会创建的 **Big
    Buck Bunny** 示例电影。你可以在以下网址找到这个视频：[http://bbb3d.renderfarming.net/download.html](http://bbb3d.renderfarming.net/download.html)。如果你想用这个视频进行练习，请确保下载视频的
    2D 版本。
- en: As stated before, you will implement the video player using `AVPlayerViewController`.
    This view controller provides a convenient wrapper around several components from
    `AVFoundation`, and also provides default video controls, so you don't have to
    build your entire video player from scratch, as you will do for the audio player
    later.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，你将使用 `AVPlayerViewController` 来实现视频播放器。这个视图控制器围绕 `AVFoundation` 的几个组件提供了一个方便的包装，同时也提供了默认的视频控件，因此你不需要从头开始构建整个视频播放器，就像你稍后为音频播放器所做的那样。
- en: '`AVPlayerViewController` is highly configurable, which means that you can choose
    whether the player supports AirPlay, shows playback controls, whether it should
    be full screen when a video plays, and more. For a complete list of configurable
    options, you can refer to Apple''s `AVPlayerViewController` documentation.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVPlayerViewController` 具有高度的可配置性，这意味着你可以选择播放器是否支持 AirPlay、显示播放控件、视频播放时是否应该全屏，以及更多。要获取完整的配置选项列表，你可以参考
    Apple 的 `AVPlayerViewController` 文档。'
- en: 'Once you have found your test video, you should add it to the `MediaPlayback`
    project and ensure that the video is added to the app target. You can follow these
    steps:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦找到你的测试视频，你应该将其添加到 `MediaPlayback` 项目中，并确保视频已添加到应用目标中。你可以按照以下步骤操作：
- en: Click on your project.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你的项目。
- en: Click on your target.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击你的目标。
- en: Select **Build Phases**.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **构建阶段**。
- en: Expand **Copy Bundle Resources**.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开 **复制资源包**。
- en: Click **+** and select your file.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **+** 并选择你的文件。
- en: 'After doing this, open `VideoViewController.swift` and add the following line
    to import `AVKit`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在完成此操作后，打开 `VideoViewController.swift` 并添加以下行以导入 `AVKit`:'
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should also add a property to `VideoViewController` to hold on to your
    video player instance. Add the following line to the `VideoViewController` class
    to do this:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在 `VideoViewController` 中添加一个属性来保存你的视频播放器实例。将以下行添加到 `VideoViewController`
    类中以实现此功能：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Since `AVPlayerViewController` is a `UIViewController` subclass, you should
    add it to `VideoViewController` as a child view controller. Doing this will make
    sure that `VideoViewController` forwards any view controller life cycle events,
    such as `viewDidLoad()`, along with any changes in trait collections and more
    to the video player. To do this, add the following code to the `viewDidLoad()`
    method in `VideoViewController`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `AVPlayerViewController` 是 `UIViewController` 的子类，你应该将其添加到 `VideoViewController`
    中作为子视图控制器。这样做将确保 `VideoViewController` 将任何视图控制器生命周期事件（如 `viewDidLoad()`），以及任何在特性集合中的变化等转发给视频播放器。为此，请将以下代码添加到
    `VideoViewController` 中的 `viewDidLoad()` 方法：
- en: '[PRE2]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The previous code snippet adds the video player to the video view controller
    as a child view controller. When you add a view controller as a child view controller,
    you must always call `didMove(toParent:)` on the child controller to make sure
    that it knows that it has been added as a child view controller to another view
    controller. After adding the video player as a child view controller, the video
    player's view is added as a subview for the video view controller, and some constraints
    are set up to position the player view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码片段将视频播放器添加到视频视图控制器作为子视图控制器。当你添加一个视图控制器作为子视图控制器时，你必须始终在子控制器上调用`didMove(toParent:)`以确保它知道它已被添加为另一个视图控制器的子视图控制器。在将视频播放器作为子视图控制器添加后，视频播放器的视图被添加为视频视图控制器的子视图，并设置了一些约束来定位播放器视图。
- en: 'This is all you need to do to create an instance of the video player and make
    it appear in your view controller. The last step is to obtain a reference to your
    video file, create an `AVPlayer` that has a reference to the video file, and assign
    it to the player. Add the following code to do this:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建视频播放器实例并在你的视图控制器中显示它，你需要做以下所有事情。最后一步是获取你的视频文件的引用，创建一个指向视频文件的`AVPlayer`实例，并将其分配给播放器。添加以下代码来完成此操作：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code looks for a video file called `samplevideo.mp4` and obtains
    a URL for that file. It then creates an instance of `AVPlayer` that points to
    that video file and assigns it to the video player. The `AVPlayer` object is responsible
    for playing the video file. The `AVPlayerViewController` instance uses the `AVPlayer`
    instance to play the video and manages the actual playback of the video internally.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码查找名为`samplevideo.mp4`的视频文件，并为该文件获取一个URL。然后它创建一个指向该视频文件的`AVPlayer`实例，并将其分配给视频播放器。`AVPlayer`对象负责播放视频文件。`AVPlayerViewController`实例使用`AVPlayer`实例来播放视频，并在内部管理视频的实际播放。
- en: If you run your app after adding the player this way, you will find that the
    video plays perfectly well, and that you have access to all the controls you might
    need. This is a great demonstration of how simple it is to add basic media integration
    to your app. The next step is a little more complex. You will directly use an
    `AVAudioPlayer` instance to play an audio file that is controlled through several
    custom media controls. The player will even play audio in the background and integrate
    with the lock screen to show information about the current file. In other words,
    you will build a simple audio player that does everything a user would expect
    it to do.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你以这种方式添加播放器后运行你的应用程序，你会发现视频播放得非常完美，并且你可以访问你可能需要的所有控件。这是一个很好的演示，说明了将基本媒体集成添加到你的应用程序是多么简单。下一步会稍微复杂一些。你将直接使用`AVAudioPlayer`实例来播放一个音频文件，该文件通过几个自定义媒体控件进行控制。播放器甚至可以在后台播放音频，并与锁屏集成以显示当前文件的详细信息。换句话说，你将构建一个简单的音频播放器，它做用户期望它做的所有事情。
- en: Important note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When launching in the simulator, `AVKit` and large movie files can take some
    time to load up. Try it on a real device.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在模拟器中启动时，`AVKit`和大型电影文件可能需要一些时间来加载。尝试在真实设备上运行。
- en: Creating an audio player
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建音频播放器
- en: Before you can implement your audio player, you will need to obtain some `.mp3`
    files you wish to use in your player. If you don't have any audio files on your
    computer, you can get some files from The Free Music Archive website, available
    at [https://freemusicarchive.org/](https://freemusicarchive.org/)about, to obtain
    a couple of free songs that you would like to use for playback. Make sure to add
    them to the `MediaPlayer` Xcode project and ensure that they are included in the
    app target.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够实现你的音频播放器之前，你需要获取一些你希望在播放器中使用的`.mp3`文件。如果你电脑上没有音频文件，你可以从[https://freemusicarchive.org/](https://freemusicarchive.org/)网站获取一些文件，以获取一些你想要用于播放的免费歌曲。确保将它们添加到`MediaPlayer`
    Xcode项目中，并确保它们包含在应用程序目标中。
- en: 'You will build the audio player using the following steps:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你将按照以下步骤构建音频播放器：
- en: Implement the necessary controls to start and stop the player and navigate to
    the next and previous songs.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现必要的控件以启动和停止播放器以及导航到下一首和上一首歌曲。
- en: Implement the time scrubber.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现时间刮擦器。
- en: Read the file's metadata and show it to the user.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取文件的元数据并将其显示给用户。
- en: The user interface, outlets, and actions are already set up, so make sure to
    familiarize yourself with the existing code before following along with the implementation
    of the audio player.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面、输出和操作已经设置好了，所以在跟随音频播放器的实现之前，请确保熟悉现有的代码。
- en: Implementing basic audio controls
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现基本的音频控制
- en: Before you implement the audio player code, you will need to do a little bit
    of housekeeping. To be able to play audio, you need a list of the files that the
    player will play. In addition to this list, you also need to keep track of what
    song the user is currently playing, so you can determine the next and previous
    songs. Lastly, you also need to have the audio player itself. Instead of using
    a pre-built component, you will build your own audio player using an `AVAudioPlayer`
    object. `AVAudioPlayer` is perfect for implementing a simple audio player that
    plays a couple of local `.mp3` files. It offers some convenient helper methods
    to easily adjust the player's volume, seek to a specific timestamp in the song,
    and more.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现音频播放器代码之前，你需要做一些准备工作。为了能够播放音频，你需要一个播放器将要播放的文件列表。除了这个列表，你还需要跟踪用户当前正在播放的歌曲，以便你可以确定下一首和上一首歌曲。最后，你还需要有音频播放器本身。你将使用`AVAudioPlayer`对象自己构建自己的音频播放器。`AVAudioPlayer`非常适合实现一个简单的音频播放器，该播放器可以播放几个本地的`.mp3`文件。它提供了一些方便的辅助方法，可以轻松调整播放器的音量、跳转到歌曲中的特定时间戳等。
- en: 'Define the following properties in `AudioViewController.swift`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AudioViewController.swift`中定义以下属性：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, don''t forget to add the import:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，别忘了添加导入：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure to replace the files array with the filenames that you use for your
    own audio files. `audioPlayer` does not have a value yet at this point. You will
    set up the audio player next.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 确保将文件数组替换为你用于自己的音频文件的文件名。在此点`audioPlayer`还没有值。你将在设置音频播放器时进行设置。
- en: 'Before you can play audio, you need to obtain a reference to a media file and
    provide this reference to an `AVAudioPlayer` object. Any time you want to load
    a new media file, you will have to create a new instance of the audio player,
    since you can''t change the current file once a file is playing. Add the following
    helper method to `AudioViewController` to load the current track and create an
    `AVAudioPlayer` instance:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够播放音频之前，你需要获取一个媒体文件的引用并将其提供给`AVAudioPlayer`对象。任何你想加载新媒体文件的时候，你都必须创建一个新的音频播放器实例，因为一旦文件开始播放，你无法更改当前文件。向`AudioViewController`添加以下辅助方法以加载当前曲目并创建`AVAudioPlayer`实例：
- en: '[PRE6]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This method reads the filename for the current track and retrieves the local
    URL for it. This URL is then used to create and set the `audioPlayer` property
    on `AudioViewController`. The view controller is also assigned as the delegate
    for the audio player. You won''t implement any of the delegate methods just yet,
    but you can add the following extension to make `AudioViewController` conform
    to the `AVAudioPlayerDelegate` protocol to ensure your code compiles:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法读取当前曲目的文件名并检索其本地URL。然后，使用此URL在`AudioViewController`中创建并设置`audioPlayer`属性。视图控制器也被分配为音频播放器的代理。你目前不会实现任何代理方法，但你可以添加以下扩展，以确保`AudioViewController`符合`AVAudioPlayerDelegate`协议，从而确保你的代码可以编译：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s call `loadTrack()` on `viewDidLoad()` to instantiate `audioPlayer`
    and load the first song. Add the following method to `AudioViewController`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`viewDidLoad()`中调用`loadTrack()`以实例化`audioPlayer`并加载第一首歌曲。向`AudioViewController`添加以下方法：
- en: '[PRE8]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: You will implement one of the `AVAudioPlayerDelegate` methods when you add support
    for navigating to the next and previous tracks.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当你添加支持导航到下一首和上一首曲目时，你将实现`AVAudioPlayerDelegate`的一个方法。
- en: 'Add the following two methods to the audio view controller to add support for
    playing and pausing the current audio file:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 向音频视图控制器添加以下两个方法以支持播放和暂停当前音频文件：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'These methods are relatively straightforward. They call the audio player''s
    `play()` and `pause()` methods and update the button''s label, so it reflects
    the current player state. Add the following implementation for `playPauseTapped()`
    so that the play and pause methods get called when the user taps the play/pause
    button:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法相对简单。它们调用音频播放器的`play()`和`pause()`方法，并更新按钮的标签，以便反映当前播放器的状态。为`playPauseTapped()`添加以下实现，以便在用户点击播放/暂停按钮时调用播放和暂停方法：
- en: '[PRE10]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you run the app now, you can tap the play/pause button to start and stop
    the currently playing file. Make sure your device is not in silent mode, because
    the audio for your app is muted when the device is in silent mode. You will learn
    how to fix this when you implement the ability to play audio in the background.
    The next step is to add support for playing the next and previous tracks. Add
    the following two implementations to `AudioViewController` to do this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你可以点击播放/暂停按钮来开始和停止当前播放的文件。确保你的设备不是静音模式，因为当设备处于静音模式时，你的应用程序的音频会被静音。你将在实现后台播放音频的功能时学习如何解决这个问题。下一步是添加播放下一曲和上一曲的支持。将以下两个实现添加到
    `AudioViewController` 中以实现这一点：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code adjusts the current track index, loads the new track, and
    immediately plays it. Note that every time the user taps on the next or previous
    button, a fresh audio player has to be created by calling `loadTrack()`. If you
    run the app now, you can play audio, pause it, and skip to the next or previous
    tracks.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码调整当前曲目索引，加载新曲目，并立即播放。请注意，每次用户点击下一曲或上一曲按钮时，都必须通过调用 `loadTrack()` 创建一个新的音频播放器。如果你现在运行应用程序，你可以播放音频，暂停它，并跳转到下一曲或上一曲。
- en: 'When you allow a full song to play, it will not yet advance to the next song
    afterward. To implement this, you need to add an implementation for the `audioPlayerDidFinishPlaying(_:successfully:)`
    method from `AVAudioPlayerDelegate`. Add the following implementation to call
    `nextTapped()`, so the next song automatically plays when the current song finishes:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你允许一首完整的歌曲播放时，它之后不会自动跳转到下一首。为了实现这一点，你需要为 `AVAudioPlayerDelegate` 中的 `audioPlayerDidFinishPlaying(_:successfully:)`
    方法添加一个实现。将以下实现添加到调用 `nextTapped()`，以便在当前歌曲结束时自动播放下一首：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now that the first features are implemented, the next step is to implement the
    time scrubber that shows the current song's progress and allows the user to adjust
    the playhead's position.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在第一项功能已经实现，下一步是实现时间刮擦器，它显示当前歌曲的进度并允许用户调整播放头的位置。
- en: Implementing the time scrubber
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现时间刮擦器
- en: 'The user interface for the audio player app already contains a scrubber that
    is hooked up to the following three actions in the view controller:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 音频播放器应用的用户界面已经包含了一个与视图控制器中以下三个动作相连的刮擦器：
- en: '`sliderDragStart()`'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sliderDragStart()`'
- en: '`sliderDragEnd()`'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sliderDragEnd()`'
- en: '`sliderChanged()`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sliderChanged()`'
- en: When an audio file is playing, the scrubber should automatically update to reflect
    the current position in the song. However, when a user starts dragging the scrubber,
    it should not update its position until the user has chosen the scrubber's new
    position. When the user is done dragging the scrubber, it should adjust itself
    based on the song's progress again. Any time the value for the slider changes,
    the audio player should adjust the playhead, so the song's progress matches that
    of the scrubber.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当音频文件正在播放时，刮擦器应该自动更新以反映歌曲中的当前位置。然而，当用户开始拖动刮擦器时，它不应更新其位置，直到用户选择了刮擦器的新位置。当用户完成拖动刮擦器后，它应根据歌曲的进度再次调整自己。每当滑动条的值发生变化时，音频播放器应调整播放头，以便歌曲的进度与刮擦器匹配。
- en: 'Unfortunately, the `AVAudioPlayer` object does not expose any delegate methods
    to observe the progress of the current audio file. To update the scrubber regularly,
    you can implement a timer that updates the scrubber to the audio player''s current
    position every second. Add the following property to `AudioViewController`, so
    you can hold on to the timer after you have created it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`AVAudioPlayer` 对象没有公开任何代理方法来观察当前音频文件的进度。为了定期更新刮擦器，你可以实现一个定时器，每秒更新刮擦器到音频播放器的当前位置。将以下属性添加到
    `AudioViewController` 中，以便在创建定时器后保留它：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Also, add the following two methods to `AudioViewController` as a convenient
    way to start the timer when the user starts dragging the scrubber, or when a file
    starts playing, and stop it when a user stops dragging the scrubber or to preserve
    resources when the playback is paused:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将以下两个方法添加到 `AudioViewController` 中，作为在用户开始拖动刮擦器或文件开始播放时启动定时器，以及当用户停止拖动刮擦器或播放暂停时停止定时器或保留资源的便捷方式：
- en: '[PRE14]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a call to `startTimer()` in the `startPlayback()` method and a call to
    `stopTimer()` in the `pausePlayback()` method. If you run the app after doing
    this, the scrubber will immediately begin updating its position when a song starts
    playing. However, scrubbing does not work yet. Add the following implementations
    for the scrubber actions to enable manual scrubbing:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在`startPlayback()`方法中添加对`startTimer()`的调用，并在`pausePlayback()`方法中添加对`stopTimer()`的调用。如果你完成这些操作后运行应用，进度条将在歌曲开始播放时立即开始更新其位置。然而，拖动进度条的功能还没有实现。添加以下拖动进度条动作的实现以启用手动拖动：
- en: '[PRE15]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The preceding methods are relatively simple, but they provide a very powerful
    feature that immediately makes your homemade audio player feel like an audio player
    you might use every day. The final step for implementing the audio player's functionality
    is to display metadata about the current song.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述方法相对简单，但它们提供了一个非常强大的功能，立即让你的自制音频播放器感觉像你每天可能会使用的音频播放器。实现音频播放器功能的最后一步是显示当前歌曲的元数据。
- en: Displaying song metadata
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示歌曲元数据
- en: Most `.mp3` files contain metadata in the form of ID3 tags. These metadata tags
    are used by applications such as iTunes to extract information about a song and
    display it to the user, as well as to categorize a music library or filter it.
    You can gain access to an audio file's metadata through code by loading the audio
    file into an `AVPlayerItem` object and extracting the metadata for its internal
    `AVAsset` instance. An `AVAsset` object contains information about a media item,
    such as its type, location, and more. When you load a file using an `AVPlayerItem`
    object, it will automatically create a corresponding `AVAsset` object for you.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`.mp3`文件都包含ID3标签形式的元数据。这些元数据标签被诸如iTunes之类的应用程序用于提取有关歌曲的信息并显示给用户，以及用于对音乐库进行分类或过滤。你可以通过将音频文件加载到`AVPlayerItem`对象中并提取其内部`AVAsset`实例的元数据来通过代码访问音频文件的元数据。`AVAsset`对象包含有关媒体项的信息，例如其类型、位置等。当你使用`AVPlayerItem`对象加载文件时，它将自动为你创建相应的`AVAsset`对象。
- en: 'A single asset can contain loads of metadata in the metadata dictionary. Luckily,
    Apple has captured all of the valid ID3 metadata tags in the `AVMetadataIdentifier`
    object, so once you have extracted the metadata for an `AVAsset` instance, you
    can loop over all of its metadata to filter out the data you need. The following
    method does this, and sets the extracted values on the `titleLabel` variable of
    `AudioViewController`, as shown here:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 单个资产可以在元数据字典中包含大量的元数据。幸运的是，苹果已经将所有有效的ID3元数据标签捕获在`AVMetadataIdentifier`对象中，因此一旦你提取了`AVAsset`实例的元数据，你就可以遍历其所有元数据来筛选出你需要的数据。以下方法就是这样做的，并将提取的值设置在`AudioViewController`的`titleLabel`变量上，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Make sure to add a call to this method from `loadTrack()`, and pass the audio
    file's URL that you obtain in `loadTrack()` to `showMetadataForURL(_:)`. If you
    run your app now, your basic functionality should be all there. The metadata should
    be shown correctly, the scrubber should work, and you should be able to skip songs
    or pause the playback.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 确保从`loadTrack()`方法中调用此方法，并将你在`loadTrack()`中获得的音频文件URL传递给`showMetadataForURL(_:)`。如果你现在运行你的应用，你的基本功能应该都已经有了。元数据应该被正确显示，进度条应该可以工作，你应该能够跳过歌曲或暂停播放。
- en: Even though your media player seems to be pretty much done at this point, did
    you notice that the music pauses when you send the app to the background? To make
    your app feel more like a real audio player, you should implement background audio
    playback and make sure that the currently playing song is presented on the user's
    lock screen, similar to how the native music app for iOS works. This is precisely
    the functionality you will add next.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的媒体播放器看起来在这个阶段已经相当完善了，但你有没有注意到当你将应用发送到后台时音乐会暂停？为了让你的应用更像一个真正的音频播放器，你应该实现后台音频播放，并确保当前播放的歌曲显示在用户的锁屏上，类似于iOS的本地音乐应用的工作方式。这正是你接下来要添加的功能。
- en: Playing media in the background
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在后台播放媒体
- en: 'On iOS, playing audio in the background requires special permissions that you
    can enable in your app''s **Capabilities** tab. If you enable the **Background
    Modes** capability, you can select the **Audio, AirPlay, and Picture in Picture**
    option to make your app eligible for playing audio in the background. The following
    screenshot shows the enabled capability for playing audio in the background:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 中，后台播放音频需要特殊权限，您可以在应用的**功能**选项卡中启用这些权限。如果您启用了**后台模式**功能，可以选择**音频、AirPlay
    和画中画**选项，使您的应用有资格在后台播放音频。以下截图显示了启用后台播放音频的功能：
- en: '![Figure 11.1 − Background Modes'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 11.1 − Background Modes'
- en: '](img/Figure_11.1_B14717.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_11.1_B14717.jpg]'
- en: Figure 11.1 − Background Modes
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1 − 后台模式
- en: 'If you want to add proper support for background audio playback, there are
    three features you need to implement:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想添加对后台音频播放的适当支持，您需要实现以下三个功能：
- en: Set up an audio session, so audio continues playing in the background.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置音频会话，以便音频在后台继续播放。
- en: Submit metadata to the "now playing" info center.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将元数据提交给“正在播放”信息中心。
- en: Respond to playback actions from remote sources, such as the lock screen.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应来自远程源（如锁屏）的播放操作。
- en: 'You can set up the audio session for your app with just two lines of code.
    When you create an audio session, iOS will treat the audio played by your app
    slightly differently; for instance, your songs will play even if the device is
    set to silent. It also makes sure that your audio is played when your app is in
    the background, if you have the proper capabilities set up. Add the following
    code to `viewDidLoad()` to set up an audio session for the app:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 您只需两行代码即可为您的应用设置音频会话。当您创建音频会话时，iOS 会将您的应用播放的音频处理得略有不同；例如，即使设备设置为静音，您的歌曲也会播放。它还确保在您设置了适当的配置后，您的音频在应用处于后台时播放。将以下代码添加到`viewDidLoad()`中，以设置应用的音频会话：
- en: '[PRE17]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The second feature to add is to supply information about the currently playing
    track. All information about the currently playing media file should be passed
    to the `MPNowPlayingInfoCenter` object. This object is part of the `MediaPlayer`
    framework and is responsible for showing the user information about the currently
    playing media file on the lock screen and in the command center. Before you pass
    information to the "now playing" info center, make sure to import the `MediaPlayer`
    framework at the top of the `AudioViewController.swift` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 需要添加的第二个功能是提供关于当前播放曲目信息。关于当前播放媒体文件的所有信息都应该传递给`MPNowPlayingInfoCenter`对象。该对象是`MediaPlayer`框架的一部分，负责在锁屏和命令中心显示用户关于当前播放媒体文件的信息。在将信息传递给“正在播放”信息中心之前，请确保在`AudioViewController.swift`文件的顶部导入`MediaPlayer`框架：
- en: '[PRE18]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, add the following line of code to `viewDidLoad()`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下行代码添加到`viewDidLoad()`中：
- en: '[PRE19]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the documentation for `MPNowPlayingInfoCenter`, Apple states that you should
    always pass the most recent "now playing" information to the info center when
    the app goes to the background. To do this, the audio view controller should listen
    to the `UIApplication.didEnterBackgroundNotification` notification, so it can
    respond to the app going to the background. Add the following implementation for
    the `updateNowPlaying()` method to `AudioVideoController`:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MPNowPlayingInfoCenter`的文档中，Apple 表示，当应用进入后台时，您应该始终将最新的“正在播放”信息传递给信息中心。为此，音频视图控制器应监听`UIApplication.didEnterBackgroundNotification`通知，以便能够响应应用进入后台。将以下实现添加到`AudioVideoController`中的`updateNowPlaying()`方法：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code configures a dictionary with metadata about the currently
    playing file and passes it to the "now playing" info center. This method is called
    automatically when the app goes to the background, but you should also update
    the "now playing" information when a new song begins playing. Add a call to `updateNowPlaying()`
    in the `loadTrack()` method to make sure the "now playing" information is updated
    whenever a new track is loaded.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码配置了一个包含当前播放文件元数据的字典，并将其传递给“正在播放”信息中心。当应用进入后台时，此方法会自动调用，但您也应该在开始播放新歌曲时更新“正在播放”信息。在`loadTrack()`方法中添加对`updateNowPlaying()`的调用，以确保每次加载新曲目时都会更新“正在播放”信息。
- en: 'The next and final step is to respond to remote commands. When the user taps
    the play/pause button, next button, or previous button on the lock screen, this
    is sent to your app as a remote command. You should explicitly define the handlers
    that should be called by iOS when a remote command occurs. Add the following method
    to `AudioViewController` to add support for remote commands:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步和最后一步是响应远程命令。当用户在锁屏上点击播放/暂停按钮、下一按钮或上一按钮时，这将被发送到您的应用作为远程命令。您应该明确定义iOS在远程命令发生时应调用的处理程序。将以下方法添加到`AudioViewController`中，以添加对远程命令的支持：
- en: '[PRE21]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The preceding code obtains a reference to the remote command center and registers
    several handlers. It also calls `beginReceivingRemoteControlEvents()` on the application
    object to make sure it receives remote commands. Add a call to `configureRemoteCommands()`
    in `viewDidLoad()` to make sure that the app begins receiving remote commands
    as soon as the audio player is configured. As an exercise to practice, try implementing
    the commands to control the time scrubber and `+15` and `-15` from the lock screen
    yourself.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码获取远程命令中心的引用并注册了几个处理程序。它还在应用程序对象上调用`beginReceivingRemoteControlEvents()`以确保它接收远程命令。在`viewDidLoad()`中添加对`configureRemoteCommands()`的调用，以确保应用在音频播放器配置后立即开始接收远程命令。作为练习，尝试自己实现控制时间刮擦器和从锁屏发送的`+15`和`-15`命令。
- en: Try to run your app and send it to the background. You should be able to control
    media playback from both the control center and the lock screen. The visible metadata
    should correctly update when you skip to the next or previous song, and the scrubber
    should accurately represent the current position of playback in the song.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试运行您的应用并将其发送到后台。您应该能够从控制中心和锁屏控制媒体播放。当您跳转到下一首或上一首歌曲时，可见的元数据应正确更新，并且刮擦器应准确表示歌曲播放的当前位置。
- en: At this point, you have implemented a reasonably complete audio player that
    has pretty sophisticated behaviors. The next step in your exploration of media
    on iOS is to discover how you can take pictures and record video.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经实现了一个功能相对完整且行为相当复杂的音频播放器。在iOS上探索媒体的下一步是发现您如何拍照和录制视频。
- en: Recording video and taking pictures
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 录制视频和拍照
- en: In addition to playing existing media, you can also make apps that allow users
    to create their own content. In this section, you will learn how you can use a
    built-in component to enable users to take a picture. You will also learn how
    you can use a raw video feed to record a video. If you want to follow along with
    the samples in this section, make sure to grab the starter project for `Captured`
    from this chapter's code bundle.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 除了播放现有媒体外，您还可以创建允许用户创建自己内容的App。在本节中，您将了解如何使用内置组件来启用用户拍照。您还将了解如何使用原始视频流来录制视频。如果您想跟随本节中的示例，请确保从本章的代码包中获取`Captured`的起始项目。
- en: The starter project contains a couple of view controllers and some connected
    outlets and actions. Note that there is a `UIViewController` extension in the
    project, too.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 起始项目包含几个视图控制器和一些连接的输出和动作。请注意，项目中还有一个`UIViewController`扩展。
- en: This extension includes a helper method that makes displaying an alert to the
    user a little bit simpler. This extension will be used to show an alert that informs
    the user when their photo or video is stored in the camera roll.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此扩展包含一个辅助方法，使得向用户显示警报变得稍微简单一些。此扩展将用于显示一个警报，通知用户当他们的照片或视频存储在相机胶卷中时。
- en: 'Since a user''s camera and photo library are considered very privacy-sensitive,
    you need to make sure that you add the following privacy-related keys to the app''s
    `Info.plist`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 由于用户的相机和照片库被认为非常敏感，您需要确保将以下与隐私相关的键添加到应用的`Info.plist`中：
- en: '**Privacy - Camera Usage Description**: This property is required in order
    to access the camera so that you can take pictures and record video.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私 - 摄像头使用描述**：此属性是访问摄像头所必需的，以便您可以拍照和录制视频。'
- en: '**Privacy - Microphone Usage Description**: You must add this property so that
    your videos record audio, as well as images.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私 - 麦克风使用描述**：您必须添加此属性，以便您的视频能够录制音频，以及图像。'
- en: '**Privacy - Photo Library Additions Usage Description**: This property allows
    you to write photos to the user''s photo library.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**隐私 - 照片库添加使用描述**：此属性允许您将照片写入用户的照片库。'
- en: Make sure to provide a good description for the privacy keys, so the user knows
    why you need access to their camera, microphone, and photo library. The better
    your description is, the more likely the user is to allow your app to access the
    associated privacy-sensitive information. After adding the keys, you are ready
    to see how you can take a picture using the built-in `UIImagePickerController`
    component of UIKit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 确保为隐私键提供良好的描述，以便用户知道为什么你需要访问他们的相机、麦克风和照片库。你的描述越好，用户允许你的应用程序访问相关隐私敏感信息的可能性就越大。在添加键之后，你就可以看到如何使用UIKit内置的`UIImagePickerController`组件拍照了。
- en: Taking and storing a picture
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拍照和存储图像
- en: When you need a user to supply an image, they can do this by either selecting
    an image from their photo library or by taking a picture with the camera. `UIImagePickerController`
    supports both ways of picking an image. In this section, you will learn how you
    can allow users to take an image using the camera. Changing the example to allow
    users to select an image from their photo library should be straightforward, as
    long as you remember to add the `Info.plist`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要用户提供图像时，他们可以通过从他们的照片库中选择图像或通过使用相机拍照来实现。`UIImagePickerController`支持两种选择图像的方式。在本节中，你将学习如何允许用户使用相机拍照。只要记得添加`Info.plist`，将示例更改为允许用户从他们的照片库中选择图像应该是简单的。
- en: 'Add the following implementation for `viewDidLoad()` to the `ImageViewController`
    class:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`viewDidLoad()`的实现添加到`ImageViewController`类中：
- en: '[PRE22]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The previous implementation creates an instance of the `UIImagePickerController`
    object and configures it so that it uses the camera as the image source and presents
    it to the user. Note that the view controller is set as a delegate for the image
    picker.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现创建了一个`UIImagePickerController`对象的实例，并配置它使用相机作为图像源，并将其展示给用户。请注意，视图控制器被设置为图像选择器的代理。
- en: When the user has taken a picture, the image picker will notify its delegate
    about this so that it can extract the image and use it. In this case, the image
    should be given the `selectedImage` label in the view controller so that it can
    be shown in the image view, and saved when the user taps on the save button, and
    the `saveImage()` method is called as a result.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户拍照时，图像选择器会通知其代理，以便它可以提取图像并使用它。在这种情况下，图像应赋予视图控制器中的`selectedImage`标签，以便可以在图像视图中显示，并在用户点击保存按钮时保存，并调用`saveImage()`方法作为结果。
- en: 'Add the following extension to make `ImageViewController` conform to `UIImagePickerControllerDelegate`:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下扩展使`ImageViewController`符合`UIImagePickerControllerDelegate`：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that this extension also makes the image view controller conform to `UINavigationControllerDelegate`.
    The delegate property on the image picker controller requires all delegates to
    conform to both `UINavigationControllerDelegate` and `UIImagePickerControllerDelegate`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此扩展还使图像视图控制器符合`UINavigationControllerDelegate`。图像选择器控制器的代理属性要求所有代理都符合`UINavigationControllerDelegate`和`UIImagePickerControllerDelegate`。
- en: 'When the user has taken a picture with the camera, `imagePickerController(_:
    didFinishPickingMediaWithInfo)` is called to notify the delegate about the photo
    that the user took. The first thing that the preceding code does is dismiss the
    picker, as it''s no longer needed. The picture that the user just took is stored
    in the `info` dictionary as the original image. When the image is extracted from
    the dictionary, it is set as `selectedImage`.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用相机拍照后，会调用`imagePickerController(_:didFinishPickingMediaWithInfo)`来通知代理关于用户所拍摄的照片。前面代码所做的第一件事是关闭选择器，因为它不再需要。用户刚刚拍摄的照片作为原始图像存储在`info`字典中。当从字典中提取图像时，它被设置为`selectedImage`。
- en: 'To store the image, add the following implementation of `saveImage()`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 要存储图像，请添加以下`saveImage()`的实现：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The preceding code calls `UIImageWriteToSavedPhotosAlbum(_:_:_:_)` to store
    the image in the user's photo library. When the save operation completes, the
    `didSaveImage(_:withError:contextInfo:)` method will be called. If this method
    does not receive any errors, then the photo was successfully stored in the photo
    library and an alert is shown.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 前面代码调用`UIImageWriteToSavedPhotosAlbum(_:_:_:)`将图像存储在用户的照片库中。当保存操作完成后，将调用`didSaveImage(_:withError:contextInfo:)`方法。如果没有接收到任何错误，则表示照片已成功存储在照片库中，并显示一个警告。
- en: Allowing the user to take a picture by implementing `UIImagePickerController`
    is relatively straightforward, and it is a great way to implement a camera feature
    in your app without too much effort. Sometimes, you need more advanced access
    to the camera. In these cases, you can use `AVFoundation` to gain access to the
    raw video feed from the camera, as you will see next.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户通过实现 `UIImagePickerController` 来拍照相对简单，这是在不费太多力气的情况下在您的应用中实现相机功能的好方法。有时，您可能需要更高级的相机访问权限。在这些情况下，您可以使用
    `AVFoundation` 来获取来自摄像头的原始视频流，正如您接下来将看到的。
- en: Recording and storing video
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 录制和存储视频
- en: In the previous section, you used `AVFoundation` to build a simple audio player
    app. You will now use `AVFoundation` again, except instead of playing video or
    audio, you will now record video and store it in the user's photo library. When
    using `AVFoundation` to record a video feed, you do so with an `AVCaptureSession`
    object. A capture session is responsible for taking the input from one or more
    `AVCaptureDeviceInput` objects and writing it to an `AVCaptureOutput` subclass.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，您使用了 `AVFoundation` 来构建一个简单的音频播放器应用。现在，您将再次使用 `AVFoundation`，但这次不是播放视频或音频，而是录制视频并将其存储在用户的照片库中。当使用
    `AVFoundation` 来录制视频流时，您使用的是一个 `AVCaptureSession` 对象。捕获会话负责从一个或多个 `AVCaptureDeviceInput`
    对象获取输入并将其写入 `AVCaptureOutput` 子类。
- en: 'The following diagram shows the objects that are involved with recording media
    through `AVCaptureSession`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了通过 `AVCaptureSession` 录制媒体所涉及的对象：
- en: '![Figure 11.2 − AVCaptureSession entities'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.2 − AVCaptureSession 实体'
- en: '](img/Figure_11.2_B14717.jpg)'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_11.2_B14717.jpg)'
- en: Figure 11.2 − AVCaptureSession entities
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2 − AVCaptureSession 实体
- en: 'To get started on implementing the video recorder, make sure to import `AVFoundation`
    in `RecordVideoViewController.swift`. Also, add the following properties to the
    `RecordVideoViewController` class:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始实现视频录制功能，请确保在 `RecordVideoViewController.swift` 文件中导入 `AVFoundation`。同时，将以下属性添加到
    `RecordVideoViewController` 类中：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Most of the preceding properties should look familiar because they were also
    shown in the screenshot that outlined the components that are involved with `AVCaptureSession`.
    Note that `AVCaptureMovieFileOutput` is a subclass of `AVCaptureOutput`, specialized
    in capturing video. The preview layer will be used to render the video feed at
    runtime and present it to the user so that they can see what they are capturing
    with the camera.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数前面的属性应该看起来很熟悉，因为它们也出现在了展示与 `AVCaptureSession` 相关组件的截图里。注意，`AVCaptureMovieFileOutput`
    是 `AVCaptureOutput` 的一个子类，专门用于捕获视频。预览层将在运行时用于渲染视频流，并将其展示给用户，以便他们可以看到通过摄像头捕捉到的内容。
- en: 'The next step is to set up the `AVCaptureDevice` objects for the camera and
    microphone and associate them with `AVCaptureSession`. Add the following code
    to the `viewDidLoad()` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为摄像头和麦克风设置 `AVCaptureDevice` 对象，并将它们与 `AVCaptureSession` 关联起来。将以下代码添加到 `viewDidLoad()`
    方法中：
- en: '[PRE26]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The preceding code first obtains a reference to the camera and microphone that
    will be used to record the video and audio. The second step is to create the `AVCaptureDeviceInput`
    objects that are associated with the camera and microphone and associate them
    with the capture session. The video output is also added to the video capture
    session. If you examine the screenshot that you saw earlier and compare it with
    the preceding code snippet, you will find that all four components are present
    in this implementation.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先获取用于录制视频和音频的摄像头和麦克风的引用。第二步是创建与摄像头和麦克风关联的 `AVCaptureDeviceInput` 对象，并将它们与捕获会话关联起来。视频输出也被添加到视频捕获会话中。如果您检查之前看到的截图并与上述代码片段进行比较，您会发现这四个组件都存在于这个实现中。
- en: 'The next step is to provide the user with a view that shows the current camera
    feed so that they can see what they are recording. Add the following code to `viewDidLoad()`
    after the capture session setup code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为用户提供一个视图，显示当前的摄像头流，以便他们可以看到正在录制的内容。在捕获会话设置代码之后，将以下代码添加到 `viewDidLoad()`
    中：
- en: '[PRE27]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding code sets up the preview layer and associates it with the video
    capture session. The preview layer will directly use the capture session to render
    the camera feed. The capture session is then started. This does not mean that
    the recording session starts; rather, only that the capture session will begin
    processing the data from its camera and microphone inputs.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了预览层并将其与视频捕获会话关联。预览层将直接使用捕获会话来渲染相机视频流。然后启动捕获会话。这并不意味着录制会话开始；而是仅表示捕获会话将开始处理来自其相机和麦克风输入的数据。
- en: 'The preview layer is added to the view at this point, but it doesn''t cover
    the video view yet. Add the following implementation for `viewDidLayoutSubviews()`
    to `RecordVideoViewController` to set the preview layer''s size and position,
    so it matches the size and position of `videoView`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，预览层被添加到视图中，但它尚未覆盖视频视图。请向`RecordVideoViewController`中的`viewDidLayoutSubviews()`方法添加以下实现，以设置预览层的大小和位置，使其与`videoView`的大小和位置相匹配：
- en: '[PRE28]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Running the app now will already show you the camera feed. However, tapping
    the record button doesn''t work yet, because you haven''t yet implemented the
    `startStopRecording()` method. Add the following implementation for this method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序将显示相机视频流。然而，点击录制按钮目前不起作用，因为你还没有实现`startStopRecording()`方法。为此方法添加以下实现：
- en: '[PRE29]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s go over the preceding snippet step by step to see what exactly is going
    on:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步回顾前面的代码片段，看看到底发生了什么：
- en: First, the `isRecording` property for the video output is checked. If a recording
    is currently active, the recording should be stopped.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，检查视频输出的`isRecording`属性。如果当前有活动录制，则应停止录制。
- en: If no recording is currently active, a new path is created to store the video
    temporarily.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果当前没有活动录制，将创建一个新的路径以临时存储视频。
- en: Since the video output cannot overwrite an existing file, the `FileManager`
    object should attempt to remove any existing files at the temporary video file
    path.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于视频输出无法覆盖现有文件，`FileManager`对象应尝试删除临时视频文件路径上的任何现有文件。
- en: The video output will start recording to the temporary file. The view controller
    itself is passed as a delegate to be notified when the recording has begun and
    is stopped.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视频输出将开始将录制保存到临时文件。视图控制器本身作为委托传递，以便在录制开始和停止时接收通知。
- en: 'Since `RecordVideoViewController` does not conform to `AVCaptureFileOutputRecordingDelegate`
    yet, you should add the following extension to add conformance to `AVCaptureFileOutputRecordingDelegate`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`RecordVideoViewController`尚未遵守`AVCaptureFileOutputRecordingDelegate`协议，你应该添加以下扩展以添加对`AVCaptureFileOutputRecordingDelegate`协议的遵守：
- en: '[PRE30]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The preceding extension contains three methods. The first is a delegate method,
    called when the video output has begun recording. When the recording has started,
    the title of the `startStopButton` button is updated to reflect the current state.
    The second method is also a delegate method. This method is called when the recording
    has completed. If no errors occur, the video is stored at the temporary location
    you set up earlier. `UISaveVideoAtPathToSavedPhotosAlbum(_:_:_:_:)` is then called,
    to move the video from the temporary location to the user's photo library. This
    method is very similar to the `UIImageWriteToSavedPhotosAlbum(_:_:_:_:)` method
    that you used to store a picture. The third and final method in the extension
    is called when the video is stored in the user's photo library. When the video
    has been successfully stored, an alert is shown, and the title of the `startStopButton`
    button is updated again.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 上述扩展包含三个方法。第一个是委托方法，在视频输出开始录制时调用。当录制开始时，`startStopButton`按钮的标题更新以反映当前状态。第二个方法也是委托方法。当录制完成时调用此方法。如果没有发生错误，视频将存储在之前设置的临时位置。然后调用`UISaveVideoAtPathToSavedPhotosAlbum(_:_:_:_:)`，将视频从临时位置移动到用户的照片库。此方法与您用于存储图片的`UIImageWriteToSavedPhotosAlbum(_:_:_:_:)`方法非常相似。扩展中的第三个也是最后一个方法在视频存储在用户的照片库中时调用。当视频成功存储后，会显示一个警报，并且`startStopButton`按钮的标题再次更新。
- en: You can now run the app and record some videos! Even though you have done a
    lot of manual work by implementing the video recording logic directly with `AVCaptureSession`,
    most of the hard work is done inside of the `AVFoundation` framework. One final
    media-related feature to explore is applying visual filters to images using **Core
    Image**. Applying filters to images is a very popular functionality in lots of
    apps and it can make your photo app more appealing.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行应用并录制一些视频了！尽管你已经通过直接使用 `AVCaptureSession` 实现视频录制逻辑进行了大量的手动工作，但大部分困难的工作都是在
    `AVFoundation` 框架内部完成的。最后，我们探索一个与媒体相关的功能，即使用 **Core Image** 对图像应用视觉滤镜。在许多应用中，对图像应用滤镜是一个非常流行的功能，它可以使得你的照片应用更具吸引力。
- en: Manipulating photos with Core Image
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Core Image 操作照片
- en: In this chapter, you have already seen that iOS has powerful capabilities for
    recording and playing media. In this section, you will learn how you can manipulate
    images with Core Image. The Core Image framework provides many different filters
    that you can use to process both images and videos. You will expand on the photo-taking
    capabilities that you implemented in the `Captured` app so that users can grayscale
    and crop images.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你已经看到了 iOS 在录制和播放媒体方面具有强大的功能。在本节中，你将学习如何使用 Core Image 操作图像。Core Image 框架提供了许多不同的滤镜，你可以使用这些滤镜处理图像和视频。你将扩展在
    `Captured` 应用中实现的拍照功能，以便用户可以对图像进行灰度处理和裁剪。
- en: 'Every Core Image filter you apply to images is an instance of the `CIFilter`
    class. You can create instances of filters as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你应用于图像的每个 Core Image 滤镜都是 `CIFilter` 类的一个实例。你可以按照以下方式创建滤镜实例：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `name` parameter in the filter's initializer is expected to be a string
    that refers to a specific filter. You can refer to Apple's documentation on Core
    Image and the Core Image Filter Reference guide to see an overview of all the
    filters that you can use in your apps.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 滤镜初始化器中的 `name` 参数预期是一个字符串，它引用了一个特定的滤镜。你可以参考 Apple 的 Core Image 文档和 Core Image
    滤镜参考指南，以查看你可以在应用中使用的所有滤镜的概述。
- en: 'Every filter has a certain set of parameters that you need to set on the `CIFilter`
    instance to use the filter; for instance, a grayscale filter requires you to provide
    an input image. Other filters might take an intensity, location, or other properties.
    The best way to see how you can apply a filter to an image is through an example.
    Add the following implementation for `applyGrayScale()` to `ImageViewController.swift`
    to implement a grayscale filter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 每个滤镜都有一个特定的参数集，你需要设置在 `CIFilter` 实例上以使用该滤镜；例如，灰度滤镜要求你提供一个输入图像。其他滤镜可能需要强度、位置或其他属性。了解如何将滤镜应用于图像的最佳方式是通过示例。将以下实现添加到
    `ImageViewController.swift` 中的 `applyGrayScale()` 方法，以实现灰度滤镜：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code has a lot of small, interesting details, highlighted with
    numbered comments. Let''s go over the comments one by one to see how the grayscale
    filter is applied:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码有很多有趣的小细节，用编号注释突出显示。让我们逐个查看这些注释，看看灰度滤镜是如何应用的：
- en: The `UIImage` instance that is stored in `selectedImage` is converted into a
    `CGImage` instance. Strictly speaking, this conversion isn't required, but it
    does make applying other filters to the `UIImage` instance later a bit easier.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存储在 `selectedImage` 中的 `UIImage` 实例被转换为 `CGImage` 实例。严格来说，这种转换不是必需的，但它确实使得之后对
    `UIImage` 实例应用其他滤镜变得稍微容易一些。
- en: One downside of using `CGImage`, instead of `UIImage`, is that the orientation
    information that is stored in the image is lost. To make sure the final image
    maintains its orientation, the initial orientation is stored.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `CGImage` 而不是 `UIImage` 的一个缺点是，图像中存储的朝向信息会丢失。为了确保最终图像保持其朝向，初始朝向被存储。
- en: This step creates an instance of the grayscale filter.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此步骤创建了一个灰度滤镜的实例。
- en: Since Core Image does not directly support `CGImage` instances, the `CGImage`
    instance is converted into a `CIImage` instance that can be used with Core Image.
    The `CIImage` instance is then assigned as the input image for the grayscale filter,
    by calling `setValue(_:forKey:)` on the filter.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Core Image 不直接支持 `CGImage` 实例，因此 `CGImage` 实例被转换为 `CIImage` 实例，该实例可以与 Core
    Image 一起使用。然后通过在滤镜上调用 `setValue(_:forKey:)` 方法，将 `CIImage` 实例分配为灰度滤镜的输入图像。
- en: The fifth step extracts the new image from the filter and uses a `CIContext`
    object to export the `CIImage` output to a `CGImage` instance.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第五步从滤镜中提取新的图像，并使用 `CIContext` 对象将 `CIImage` 输出导出到 `CGImage` 实例。
- en: The sixth and final step is to create a new `UIImage` instance, based on the
    `CGImage` output. The initial orientation is passed to the new `UIImage` instance
    to make sure it has the same orientation as the original image.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第六步和最后一步是创建一个新的 `UIImage` 实例，基于 `CGImage` 输出。初始方向被传递到新的 `UIImage` 实例，以确保它与原始图像具有相同的方向。
- en: 'Even though there are a lot of steps involved, and you need to convert between
    different image types quite a bit, applying the filter is relatively simple. Most
    of the preceding code takes care of switching between image types, while the filter
    itself is set up in just a couple of lines. Try running the app now and taking
    a picture. The initial picture will be in full color. After you apply the grayscale
    filter, the image is automatically replaced with a grayscale version of the image,
    as shown in the following screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 即使涉及很多步骤，并且你需要在不同的图像类型之间进行相当多的转换，应用过滤器相对简单。大部分前面的代码负责在图像类型之间切换，而过滤器本身只需几行即可设置。现在尝试运行应用并拍照。初始图片将是全彩色的。在你应用灰度过滤器后，图片会自动替换为图像的灰度版本，如下面的截图所示：
- en: '![Figure 11.3 − Grayscale'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.3 - 灰度'
- en: '](img/Figure_11.3_B14717.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 11.3 - B14717](img/Figure_11.3_B14717.jpg)'
- en: Figure 11.3 − Grayscale
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3 - 灰度
- en: 'The next filter you will implement is a crop filter. The crop filter will crop
    the image so that it''s a square, rather than a portrait or landscape picture.
    The process for implementing the crop filter is mostly the same as for the grayscale
    filter, except for the values that need to be passed to the crop filter. Add the
    following implementation for `cropSquare()` to implement the crop filter:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你接下来要实现的过滤器是裁剪过滤器。裁剪过滤器将裁剪图像，使其成为方形，而不是肖像或风景图片。实现裁剪过滤器的过程基本上与灰度过滤器相同，只是需要传递给裁剪过滤器的值不同。将以下实现添加到
    `cropSquare()` 以实现裁剪过滤器：
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding code performs several calculations to figure out the best way
    to crop the image into a square. The `CGRect` instance specifies the crop coordinates
    and size, which are then used to create a `CIVector` object. This object is then
    passed to the filter as the value for the `inputRectangle` key. Apart from specifying
    the crop values, the process of applying the filter is identical, so the code
    should look familiar to you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码执行了几个计算，以确定将图像裁剪成方形的最佳方式。`CGRect` 实例指定了裁剪坐标和大小，然后用于创建一个 `CIVector` 对象。然后，这个对象被传递给过滤器作为
    `inputRectangle` 键的值。除了指定裁剪值之外，应用过滤器的过程是相同的，所以代码应该对你来说很熟悉。
- en: 'If you run the app now and tap the crop button, the image will be cropped,
    as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用并点击裁剪按钮，图片将被裁剪，如下面的截图所示：
- en: '![Figure 11.4 − Cropping the image'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 11.4 - 裁剪图像'
- en: '](img/Figure_11.4_B14717.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 11.4 - B14717](img/Figure_11.4_B14717.jpg)'
- en: Figure 11.4 − Cropping the image
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.4 - 裁剪图像
- en: There are many more filters available in Core Image, which you can play around
    with to build pretty advanced filters. You can even apply multiple filters to
    a single image to create elaborate effects for the pictures in your apps. Because
    all filters work in very similar ways, it's relatively easy to apply any filter
    to your images once you understand how the general process of applying a filter
    works. You can always use the code from the preceding examples if you need a reminder
    about how to apply Core Image filters.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: Core Image 中有更多可用的过滤器，你可以尝试使用它们来构建相当高级的过滤器。你甚至可以将多个过滤器应用到单个图像上，为你的应用中的图片创建复杂的效果。因为所有过滤器都以非常相似的方式工作，一旦你了解了应用过滤器的一般过程，将任何过滤器应用到你的图像上就相对容易。如果你需要提醒如何应用
    Core Image 过滤器，你可以始终使用前面示例中的代码。
- en: Summary
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned a lot about media in iOS. You saw how you
    can implement a video player with just a couple of lines of code. After that,
    you learned how to use `AVFoundation` directly to build an audio player that supports
    features such as stopping and resuming playback, skipping songs, and scrubbing
    forward or backward in a song. You even learned how you can keep playing audio
    when the app goes to the background or when the phone is set to silent mode. To
    apply the finishing touches to the audio player, you learned how you can use the
    `MediaPlayer` framework to show the currently playing file on the user's lock
    screen, and how to respond to control events that are sent to the app remotely.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了关于iOS中媒体的大量知识。你看到了如何仅用几行代码实现视频播放器。之后，你学习了如何直接使用`AVFoundation`构建支持如停止和恢复播放、跳过歌曲、在歌曲中前后滚动等功能的音频播放器。你甚至学习了如何在应用进入后台或手机设置为静音模式时继续播放音频。为了给音频播放器添加最后的修饰，你学习了如何使用`MediaPlayer`框架在用户的锁屏上显示当前播放的文件，以及如何响应发送到应用的远程控制事件。
- en: After implementing media playback, you learned how you can build apps that help
    users to create media. You saw that `UIImagePickerController` provides a quick
    and simple interface to allow users to take a picture with the camera. You also
    learned how you can use `AVFoundation` and an `AVCaptureSession` object to implement
    a custom video recording experience. To wrap it all up, you learned about the
    Core Image framework, and how you can use it to apply filters to images.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现媒体播放后，你学习了如何构建帮助用户创建媒体的应用。你看到`UIImagePickerController`提供了一个快速简单的界面，允许用户使用相机拍照。你还学习了如何使用`AVFoundation`和一个`AVCaptureSession`对象来实现自定义的视频录制体验。最后，你学习了关于Core
    Image框架，以及如何使用它来对图像应用滤镜。
- en: 'In the next chapter, you will learn everything you need to know about location
    services and how to use Core Location in your apps. Depending on the use case
    of your app, handling the user location properly can be a critical task for your
    app to be successful. Examples are well known by now: food delivery apps, map
    apps, sport tracker apps, and so on.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习关于位置服务以及如何在你的应用中使用Core Location所需了解的一切。根据你应用的使用场景，正确处理用户位置可能对你的应用成功至关重要。现在，这些例子已经众所周知：食品配送应用、地图应用、运动追踪应用等等。
