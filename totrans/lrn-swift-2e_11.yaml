- en: Chapter 11. A Whole New World – Developing an App
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章. 一个全新的世界 - 开发应用
- en: Until this point, we have been concentrating almost exclusively on learning
    Swift without learning much about the platforms that it was designed for. This
    is because learning a new platform is a completely different world from learning
    a language. Learning a programming language is like learning the basic grammar
    of a spoken language. The grammar between the spoken languages generally expresses
    similar concepts but the specific words of the languages are often more varied,
    even if they are sometimes recognizable. Learning a programming language is learning
    how to connect the specific vocabulary of your desired platform. This chapter
    will be about learning some of the vocabulary of the iOS framework.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们几乎完全专注于学习 Swift 而不是学习它所设计的平台。这是因为学习一个新的平台与学习一门语言完全不同。学习一门编程语言就像学习一门口语的基本语法。不同口语之间的语法通常表达相似的概念，但具体词汇往往更加多样化，即使有时可以辨认出来。学习一门编程语言就是学习如何连接你希望的平台的具体词汇。本章将介绍
    iOS 框架的一些词汇。
- en: 'We will do this by going through the process of starting to develop a simple
    camera app. Along the way, we will learn some of the most critical vocabularies
    to get started with any other kind of iOS app and many of the concepts will be
    transferable to OS X development. More specifically, we will cover:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过开发一个简单的相机应用的过程来实现这一点。在这个过程中，我们将学习一些开始任何其他类型 iOS 应用所需的最关键词汇，许多概念也适用于 OS
    X 开发。具体来说，我们将涵盖：
- en: Conceptualizing the app
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构想应用
- en: Setting up the app project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置应用项目
- en: Configuring the user interface
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置用户界面
- en: Running the app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行应用
- en: Temporarily saving a photo
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂时保存照片
- en: Populating our photo grid
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 填充我们的照片网格
- en: Refactoring to respect model-view-controller
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重构以尊重模型-视图-控制器
- en: Permanently saving a photo
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永久保存照片
- en: Conceptualizing the app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构想应用
- en: Before we even open up Xcode, we should have a good sense of what we plan to
    develop. We want to know the basics of what kind of data we are going to need
    to represent and what the user interface is going to be like. We don't yet need
    pixel perfect designs for every screen, but we should have a good idea of the
    flow of the app and what features we want to include in our first version.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们甚至打开 Xcode 之前，我们应该对我们计划开发的内容有一个很好的认识。我们想知道我们将需要哪些基本数据来表示，以及用户界面将是什么样的。我们目前不需要每个屏幕的像素完美设计，但我们应该有一个很好的应用流程和我们要在第一个版本中包含的功能的想法。
- en: Features
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 功能
- en: 'As we already discussed, we are going to develop a basic camera app. This leaves
    us with a very clear list of features, which we would want in a first version:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们已经讨论过的，我们将开发一个基本的相机应用。这给我们留下了一个非常明确的特征列表，我们希望在第一个版本中拥有：
- en: Take a photo
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 拍摄照片
- en: View gallery of previously taken photos
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看已拍摄照片的相册
- en: Label photos
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标记照片
- en: Delete photos
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除照片
- en: These are the highly critical features of a camera app. Clearly, we don't have
    any differentiating features that will make this app valuable above other existing
    apps, but this will be enough to learn the most critical parts of making an iOS
    app.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是相机应用高度关键的功能。显然，我们没有任何区别化的功能可以使这个应用比其他现有应用更有价值，但这足以学习制作 iOS 应用最关键的部分。
- en: Interface
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 界面
- en: 'Now that we have a list of features, we can come up with the basic flow of
    the app, otherwise referred to as a wireframe. The first screen of our app will
    be a gallery of any picture the user has already taken. There will be a button
    on the screen, which will allow them to take a new picture. It will also have
    the ability to activate the editing mode where they can delete photos or change
    their label:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了功能列表，我们可以构思应用的基本流程，也称为线框图。我们应用的第一屏将是一个相册，展示用户已经拍摄的所有图片。屏幕上会有一个按钮，允许他们拍摄新图片。它还将具有激活编辑模式的能力，在那里他们可以删除照片或更改标签：
- en: '![Interface](img/B05103_11_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![界面](img/B05103_11_01.jpg)'
- en: This interface will allow us to take advantage of the built-in picture-taking
    interface that we will look at in more detail later. This interface will also
    allow us to make it flexible to work on all the different phone and tablet screens.
    It may seem simple, but there are many components that have to fit together to
    make this application work. On the other hand, once you have a good understanding
    of the different components, it will start to seem simple again.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 此界面将允许我们利用稍后将要详细探讨的内置拍照界面。此界面还将允许我们使其灵活地适应所有不同的手机和平板屏幕。这看起来可能很简单，但有许多组件必须组合在一起才能使这个应用工作。另一方面，一旦你对不同的组件有了良好的理解，它将再次开始看起来很简单。
- en: Data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据
- en: Now that we know roughly how the app needs to work for the user, we can come
    up with at least a high-level concept of how the data should be stored. In this
    case, we simply have a flat list of images with different labels. The easiest
    way for us to store these files is in the local file system, with each image named
    after the user chosen label. The only thing to keep in mind with this system is
    that we will have to find a way to allow two different images with the same exact
    label. We will solve that problem in more detail when we get around to implementing
    it.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们大致了解了应用需要如何为用户工作，我们可以至少提出一个关于数据存储的高层次概念。在这种情况下，我们仅仅有一个带有不同标签的图像的扁平列表。我们存储这些文件的最简单方式是在本地文件系统中，每个图像以用户选择的标签命名。在这个系统中需要注意的唯一一点是我们将不得不找到一种方法来允许两个具有相同确切标签的不同图像。当我们着手实现时，我们将更详细地解决这个问题。
- en: Setting up the app project
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置应用项目
- en: 'Now that we have finished conceptualizing our app, we are ready to start coding.
    In [Chapter 3](ch03.html "Chapter 3. One Piece at a Time – Types, Scopes, and
    Projects"), *One Piece at a Time – Types, Scopes, and Projects*, we created a
    command-line project. This time, we are going to create an iOS Application. Once
    again, in Xcode, navigate to **File** | **New** | **Project…**. When a window
    appears, select the **Single View Application** from the **iOS** | **Application**
    menu:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了应用的概念化，我们准备开始编码。在 [第 3 章](ch03.html "第 3 章。一次一件——类型、作用域和项目")，*一次一件——类型、作用域和项目*
    中，我们创建了一个命令行项目。这次，我们将创建一个 iOS 应用。再次在 Xcode 中导航到 **文件** | **新建** | **项目…**。当窗口出现时，从
    **iOS** | **应用** 菜单中选择 **单视图应用**：
- en: '![Setting up the app project](img/B05103_11_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用项目](img/B05103_11_02.jpg)'
- en: From there, click on **Next** and then give the project the name `LearningCamera`.
    Any **Organization Name** and **Identifier** are fine. Finally, make sure that
    **Swift** is selected from the Language drop down menu and **Universal** is selected
    from the **Devices** drop down. Now select **Next** again and create the project.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，点击 **下一步**，然后给项目命名为 `LearningCamera`。任何 **组织名称** 和 **标识符** 都可以。最后，确保从语言下拉菜单中选择
    **Swift**，从 **设备** 下拉菜单中选择 **通用**。现在再次选择 **下一步** 并创建项目。
- en: 'Xcode will then present you with a project development window that looks somewhat
    different from a command-line project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 将向你展示一个项目开发窗口，它看起来与命令行项目略有不同：
- en: '![Setting up the app project](img/B05103_11_03.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![设置应用项目](img/B05103_11_03.jpg)'
- en: This default screen allows us to configure various attributes of the app including
    the version number, target devices, and much more. For our purposes, all of the
    defaults are fine. When you decide to submit an app to the app store, this screen
    will become much more important.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个默认屏幕允许我们配置应用的各种属性，包括版本号、目标设备等。就我们的目的而言，所有默认设置都很好。当你决定将应用提交到应用商店时，这个屏幕将变得非常重要。
- en: Xcode has also created a few different files and folders for us. We will be
    working exclusively in the `LearningCamera` folder. The `LearningCameraTests`
    folder is for automated tests; they are a fantastic idea but beyond the scope
    of this book. The final folder is the `Products` folder, which you won't have
    to change.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode 也为我们创建了一些不同的文件和文件夹。我们将仅在 `LearningCamera` 文件夹中工作。`LearningCameraTests`
    文件夹用于自动化测试；这是一个极好的想法，但超出了本书的范围。最后一个文件夹是 `Products` 文件夹，你不需要对其进行更改。
- en: In the `LearningCamera` folder, we have several important files. The first file
    is `AppDelegate.swift`, which is the entry point of the application. It has a
    class that was created for you, called `AppDelegate` that has a number of methods
    that are called at different points during the application life cycle. We won't
    have to modify this file for our purposes but it is an important file in many
    applications.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LearningCamera`文件夹中，我们有几个重要的文件。第一个文件是`AppDelegate.swift`，它是应用的入口点。它有一个为你创建的类，称为`AppDelegate`，该类在应用生命周期中的不同点调用了一些方法。我们不需要修改这个文件来完成我们的目的，但它在许多应用中是一个重要的文件。
- en: The second file is `ViewController.swift`. This holds a `UIViewController` subclass
    that is used to manage the interaction between the app's default view and the
    business logic. We will be doing a lot of work in there.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个文件是`ViewController.swift`。这个文件包含一个`UIViewController`子类，用于管理应用默认视图与业务逻辑之间的交互。我们将在那里做很多工作。
- en: The third file is `Main.storyboard`. This file contains the interface design
    for our views. Currently, it has only a single view that is managed by `ViewController`.
    We will be working with this file later to add and configure our visual components.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个文件是`Main.storyboard`。这个文件包含我们视图的界面设计。目前，它只有一个由`ViewController`管理的视图。我们将在稍后使用这个文件来添加和配置我们的视觉组件。
- en: The fourth file is `Assets.xcassets`. This is a container for all of the images
    that we would want to display in our app. Almost every app you make will have
    at least one image so this is a very important file too.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 第四个文件是`Assets.xcassets`。这是一个用于存放我们希望在应用中显示的所有图像的容器。你制作的几乎每个应用都会至少有一个图像，所以这也是一个非常重要的文件。
- en: Finally, the last file is `LaunchScreen.storyboard`. This file lets us manage
    the display while our app is launching. This is an extremely important part of
    a production application because this is the first thing a user sees every time
    they launch it; a well-designed launch process can make a huge difference. However,
    we do not have to do anything to this file for our learning purpose.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，最后一个文件是`LaunchScreen.storyboard`。这个文件让我们可以管理应用启动时的显示。这是生产应用的一个极其重要的部分，因为这是用户每次启动应用时看到的第一件事；一个精心设计的启动过程可以产生巨大的影响。然而，我们不需要对这个文件做任何事情来完成我们的学习目的。
- en: Configuring the user interface
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置用户界面
- en: 'Now that we have our bearings within the project, let''s jump into configuring
    the user interface of our app. As we discussed earlier, this is done within the
    `Main.storyboard` file. When we select that file, we are presented with a graphical
    editing tool, generally referred to as **Interface Builder**:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在项目中找到了方向，让我们开始配置我们应用的用户界面。正如我们之前讨论的，这是在`Main.storyboard`文件中完成的。当我们选择该文件时，我们会看到一个图形编辑工具，通常被称为**界面构建器**：
- en: '![Configuring the user interface](img/B05103_11_04.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_04.jpg)'
- en: In the center, there is a main view that is controlled by a `ViewController`
    instance. This is a blank canvas where we can add all of the interface elements
    we want.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在中间，有一个由`ViewController`实例控制的主要视图。这是一个空白画布，我们可以添加我们想要的任何界面元素。
- en: The first thing we want to do is add the bar along the top that is in our wireframes.
    This bar is called a **navigation bar** and we can add it directly, as it is one
    of the elements in our library. However, the frameworks will handle many complications
    for us if we use a **Navigation Controller** instead. A Navigation Controller
    is a view controller that contains other view controllers. Specifically, it adds
    a navigation bar to the top and allows us to push child view controllers onto
    it in the future. This controller creates the animation of a view being pushed
    on from the right in many applications. For example, when you select an e-mail
    in the Mail app, it animates in the contents of the e-mail; this uses a navigation
    controller. We will not have to push any view controllers on in this app, but
    it is good to be set up for the future and this is a superior way of getting a
    navigation bar at the top.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先想做的事情是添加我们线框中沿顶部的那条栏。这个栏被称为**导航栏**，我们可以直接添加它，因为它是我们库中的一个元素。然而，如果我们使用**导航控制器**，框架将为我们处理许多复杂问题。导航控制器是一个包含其他视图控制器的视图控制器。具体来说，它会在顶部添加一个导航栏，并允许我们在未来将其推送到子视图控制器上。这个控制器在许多应用中创建了一个视图从右侧推入的动画。例如，当你选择邮件应用中的电子邮件时，它会动画显示电子邮件的内容；这使用了导航控制器。我们不需要在这个应用中推送任何视图控制器，但为未来做好准备是好的，这也是在顶部获得导航栏的更优方式。
- en: 'Along the right, we have a library of elements we can drag onto the canvas,
    let''s start by finding the **Navigation Controller**. Drag it from the library
    to the pane on the left where the **View Controller Scene** is listed. This is
    going to add two new view controllers to the list:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着右侧，我们有一个元素库，我们可以将其拖拽到画布上，让我们先找到**导航控制器**。从库中将它拖拽到左侧的面板中，其中列出了**视图控制器场景**。这将向列表中添加两个新的视图控制器：
- en: '![Configuring the user interface](img/B05103_11_05.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_05.jpg)'
- en: 'We don''t want the new **Root View Controller**, only the **View Controller
    Scene** so let''s delete it. To do this, click on the **Root View Controller**
    with the yellow icon and press the *Delete* key. Next, we want to make the **View
    Controller Scene** the root view controller. The root view controller is the first
    controller to be shown within the **Navigation Controller**. To do this, right-click
    on the **Navigation Controller** with the yellow icon and drag it to the **View
    Controller** with the yellow icon below. The **View Controller** will be highlighted
    blue:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望有新的**根视图控制器**，只保留**视图控制器场景**，所以让我们将其删除。为此，点击带有黄色图标的**根视图控制器**并按下*删除*键。接下来，我们希望将**视图控制器场景**设置为根视图控制器。根视图控制器是在**导航控制器**内首先显示的控制器。为此，右键点击带有黄色图标的**导航控制器**并将其拖拽到下面的带有黄色图标的**视图控制器**上。**视图控制器**将被高亮显示为蓝色：
- en: '![Configuring the user interface](img/B05103_11_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_06.jpg)'
- en: Once you let go of the right mouse button, a menu will come up and you should
    click on **Root View Controller**. Finally, we want to make the navigation controller
    the first view controller to appear in the app. Select the **Navigation Controller**
    with the yellow icon and navigate to **View** | **Utilities** | **Show Attributes
    Inspector** from the main menu, and then scroll-down and check the **Is Initial
    View Controller** checkbox. Note that you can drag around the view controllers
    on the screen however, you want to make the file easier to navigate.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 释放鼠标右键后，会出现一个菜单，你应该点击**根视图控制器**。最后，我们希望将导航控制器设置为应用中首先出现的视图控制器。选择带有黄色图标的**导航控制器**，从主菜单中选择**视图**
    | **实用工具** | **显示属性检查器**，然后向下滚动并勾选**是否为初始视图控制器**复选框。请注意，你可以随意拖拽屏幕上的视图控制器，但请确保使文件更容易导航。
- en: 'Now we are ready to customize our main view. To focus the view, select **View
    Controller** from the pane on the left. Now double-click on the title and change
    it to `Gallery`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好自定义我们的主视图。为了聚焦视图，从左侧的面板中选择**视图控制器**。现在双击标题，将其更改为`Gallery`：
- en: '![Configuring the user interface](img/B05103_11_07.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_07.jpg)'
- en: 'Next, we want to add the "Take a Picture" button to our navigation bar. All
    buttons in toolbars are called **bar button items**. Find them in the library
    and then drag it to the right side of the toolbar (the place where you can drop
    it will turn blue when you get close to it). By default, the button will say **Item**,
    but we want it to be an add button instead. One option would be to change the
    text to an addition symbol, but there is a better option. After adding the button,
    you should be able to see it appear in the hierarchy that is to the left of the
    main view. In there, you will see the navigation bar with the new button item
    nested inside the **Gallery** title. If you select that item in the hierarchy,
    you will see some options we can configure about the item along the right-hand
    side of the screen. We want to change the System Item to **Add**:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们希望将“拍照”按钮添加到我们的导航栏中。工具栏中的所有按钮都称为**栏按钮项**。在库中找到它们，然后将它拖拽到工具栏的右侧（当你靠近时，可以放置它的位置会变为蓝色）。默认情况下，按钮会显示为**Item**，但我们希望它是一个添加按钮。一个选项是将文本更改为加号符号，但有一个更好的选项。添加按钮后，你应该能在左侧的主视图的层次结构中看到它。在那里，你会看到带有新按钮项的导航栏嵌套在**Gallery**标题下。如果你在层次结构中选择该项，你将在屏幕右侧看到一些关于该项目的配置选项。我们希望将系统项更改为**添加**：
- en: '![Configuring the user interface](img/B05103_11_08.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_08.jpg)'
- en: Now, you can do the same thing for the left-hand side of the navigation bar
    with the **Edit** identifier.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以用**编辑**标识符对导航栏的左侧做同样的操作。
- en: Finally, we need to add the gallery of photos. For this, we are going to use
    the **Collection View** from the library. Drag one onto the center of the view.
    A collection view is made of a variable amount of cells laid out in a grid. Each
    cell is a copy of a template cell and it can be configured in code to display
    specific data. When you dragged the collection view on, it also created a template
    cell for you. We will configure that soon.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要添加照片画廊。为此，我们将从库中使用**集合视图**。将其拖到视图的中心。集合视图由一定数量的单元格组成，这些单元格以网格形式排列。每个单元格都是模板单元格的副本，并且可以在代码中配置以显示特定数据。当您拖动集合视图时，它还为您创建了一个模板单元格。我们很快将配置它。
- en: 'First, we need to define the rules for the sizing of the collection view. This
    will allow the interface to adapt well to each different screen size. The tool
    we use to do this is called **Auto Layout**. Click on the collection view and
    then select the **Pin** icon in the lower right of the screen:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义集合视图大小的规则。这将使界面能够很好地适应每个不同的屏幕尺寸。我们用来做这个的工具称为**自动布局**。点击集合视图，然后点击屏幕右下角的**固定**图标：
- en: '![Configuring the user interface](img/B05103_11_09.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_09.jpg)'
- en: 'Configure this window to match the preceding screenshot. Click on each of the
    four struts so that they are highlighted red, uncheck **Constrain to margins**,
    and change each of the measurements to zero. After everything is configured, click
    on **Add 4 Constraints**. This will cause some yellow lines to appear that indicate
    that the view''s placement is not consistent with the rules we just created. We
    can resize the views ourselves to make it match or we can let Xcode do it for
    us: there will be a yellow icon next to the **Gallery Scene** on the left-hand
    side of the screen. Click on that and you will get a list of misplaced views.
    In there, you can click on the yellow triangle and click on **Fix Misplacement**.
    We also want to make the background white instead of black. Select the collection
    view and then change its **Background** to white in the Attributes Inspector.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 将此窗口配置为与前面的截图匹配。点击每个四条支柱，使它们突出显示为红色，取消选中**限制于边距**，并将每个测量值更改为零。配置完成后，点击**添加4个约束**。这将导致出现一些黄色线条，指示视图的放置与我们刚刚创建的规则不一致。我们可以自己调整视图的大小以使其匹配，或者让Xcode为我们做：屏幕左侧的**画廊场景**旁边将出现一个黄色图标。点击它，您将获得一个列表，其中包含放置不当的视图。在那里，您可以点击黄色三角形，然后点击**修复错位**。我们还想将背景改为白色而不是黑色。选择集合视图，然后在**属性检查器**中将**背景**更改为白色。
- en: The last thing we need to configure on this screen is the **collection view
    cell**. This is the box in the upper-left corner of the collection view. We need
    to change the size and add both an image and a label; let's start by changing
    the size. Click on the **Collection View** if it isn't already selected and navigate
    to **View** | **Utilities** | **Show Size Inspector** from the main menu. Change
    the **Cell Size** to be `110` points wide and `150` points tall.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕上我们需要配置的最后一件事情是**集合视图单元格**。这是集合视图左上角的一个框。我们需要更改大小并添加一个图像和一个标签；让我们先从更改大小开始。如果尚未选中，请点击**集合视图**，然后从主菜单导航到**视图**
    | **实用工具** | **显示大小检查器**。将**单元格大小**更改为宽度为`110`点，高度为`150`点。
- en: Now, we can drag in our image. In the library, this is called an **Image View**.
    Drag it into the cell and then change the height and width in the **Size Inspector**
    to `110` and **x** and **y** to `0`. Next, we want to drag a **Label** below the
    image view. Once it is placed, we want to configure the placement rules within
    the cell.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将我们的图片拖入。在库中，这被称为**图像视图**。将其拖入单元格中，然后在**大小检查器**中更改高度和宽度为`110`和**x**和**y**为`0`。接下来，我们想要将一个**标签**拖到图像视图下方。一旦放置好，我们想要配置单元格内的放置规则。
- en: 'First, select the **Image View**. We have to make it the full width and attach
    it to the top of the cell, so select the pin icon again and configure it as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，选择**图像视图**。我们必须使其全宽并附加到单元格的顶部，因此再次选择固定图标并按以下方式配置：
- en: '![Configuring the user interface](img/B05103_11_10.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_10.jpg)'
- en: 'It is pinned to the left, top, and right without constraining to margins and
    values of zero for all three measurements. Click on **Add 3 Constraints** and
    we are ready to define the rules for the label. We want the label to be full width
    and vertically centered. A label is going to automatically center the text, so
    we want the label to be tall enough to have a reasonable margin above and below
    the text. Click on the label and configure it as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 它被固定在左侧、顶部和右侧，没有约束到边距，所有三个测量值都为零。点击**添加 3 个约束**，我们就可以为标签定义规则了。我们希望标签能够全宽并且垂直居中。标签会自动居中文本，因此我们希望标签足够高，以便在文本上下方有合理的边距。点击标签并按照以下方式配置它：
- en: '![Configuring the user interface](img/B05103_11_11.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/B05103_11_11.jpg)'
- en: It is pinned in every direction without constraining to the margins and has
    zero for all measurements. It is also constrained to be 30 points tall by checking
    the **Height** checkbox. Click **Add 5 Constraints** and then have Xcode resize
    it for you again from the menu on the left. Also, make sure to select the center
    alignment in the Attributes Inspector and reduce the font size to `12`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 它在所有方向上都被固定，没有约束到边距，所有测量值都为零。它还通过勾选**高度**复选框被约束为30点高。点击**添加 5 个约束**，然后从左侧菜单让Xcode再次为您调整大小。同时，确保在属性检查器中选择居中对齐，并将字体大小减少到`12`。
- en: Running the app
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行应用
- en: 'Now we have most of our interface configured without writing a single piece
    of code. We can run the app to see what it looks like. To do this, first select
    the simulator you want to run it on from the menu in the top bar. Then you can
    click on the run button, which is the one with the black triangle. This will open
    up a new simulator window running your app:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经配置了大部分界面，而没有写任何代码。我们可以运行应用来查看它的样子。为此，首先从顶部栏的菜单中选择您想要运行它的模拟器。然后您可以点击运行按钮，即带有黑色三角形的按钮。这将打开一个新的模拟器窗口，运行您的应用：
- en: '![Running the app](img/B05103_11_12.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![运行应用](img/B05103_11_12.jpg)'
- en: You can rotate the virtual device from the **Hardware** menu to see what happens
    when you rotate it and you can try running it on various different simulators.
    We have configured our view so far to adapt to any screen size.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过**硬件**菜单旋转虚拟设备，以查看旋转时的效果，并且可以在不同的模拟器上尝试运行它。我们迄今为止已经配置了视图，使其能够适应任何屏幕尺寸。
- en: Allowing picture taking
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 允许拍照
- en: 'Now we are ready to move onto the programming. The first thing we need to allow
    the user to do is to take a new picture. In order to do that, we are going to
    need some code to run every time the user taps on the add button. We achieve this
    by connecting the trigger action of the add button to a method on our view controller.
    Normally we make a connection by right-click dragging from the button to the code;
    however, we can''t do this if we can''t see the interface and the code at the
    same time. The easiest way to do this is to show the **Assistant Editor**. You
    can do this by navigating to **View** | **Assistant Editor** | **Show Assistant
    Editor**. Also, make sure it is configured to be automatic by clicking on the
    bar at the top of the editor:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备进入编程环节。首先我们需要允许用户进行拍照操作。为了实现这一点，我们需要编写一些代码，每次用户点击添加按钮时都会执行这些代码。我们通过将添加按钮的触发动作连接到视图控制器上的一个方法来实现这一点。通常，我们通过右键拖动从按钮到代码来建立连接；然而，如果我们不能同时看到界面和代码，我们就无法这样做。最简单的方法是显示**辅助编辑器**。您可以通过导航到**视图**
    | **辅助编辑器** | **显示辅助编辑器**来做到这一点。同时，确保它被配置为自动，通过点击编辑器顶部的栏位：
- en: '![Allowing picture taking](img/B05103_11_13.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![允许拍照](img/B05103_11_13.jpg)'
- en: This mode causes the second view to automatically change to the most appropriate
    file according to what you have selected on the left. In this case, because we
    are working with the interface of our view controller, it shows the code for the
    view controller.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式会导致第二个视图自动更改为最合适的文件，根据您在左侧选择的文件。在这种情况下，因为我们正在处理视图控制器的界面，所以它显示的是视图控制器的代码。
- en: Our view controller code is generated with two methods to start. `viewDidLoad`
    is called when the view for the view controller is loaded. Most of the time this
    happens when the view controller is about to be displayed for the first time.
    `didReceiveMemoryWarning` is called when the system starts to run low on memory.
    This provides you an opportunity to help the system find more memory by deleting
    anything that isn't necessary.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的视图控制器代码最初生成了两个方法。`viewDidLoad`在视图控制器视图加载时被调用。大多数时候，这发生在视图控制器即将第一次显示时。`didReceiveMemoryWarning`在系统开始运行内存不足时被调用。这为你提供了一个机会，通过删除任何不必要的项目来帮助系统找到更多内存。
- en: 'We want to start by creating a connection from the button to a new method.
    You can do so by right clicking on the add button and dragging to below the `didReceiveMemoryWarning`
    method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想从按钮到一个新方法创建一个连接。你可以通过在添加按钮上右键单击并拖动到`didReceiveMemoryWarning`方法下方来完成此操作：
- en: '![Allowing picture taking](img/B05103_11_14.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![允许拍照](img/B05103_11_14.jpg)'
- en: When you release the right mouse button, a little window will appear. There
    you should select **Action** from the **Connection** menu and enter `didTapTakePhotoButton`.
    When you click on **Connect**, Xcode will create a new method for you and connect
    it to the button. You know it is connected because there is a filled in gray circle
    to the left of the method. Now, every time the user taps the button, this method
    will be executed. Note that this method has `@IBAction` at the beginning of it.
    This is needed for any method that is connected to an interface element.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当你释放鼠标右键时，会出现一个小窗口。在那里你应该从**连接**菜单中选择**操作**，并输入`didTapTakePhotoButton`。当你点击**连接**时，Xcode会为你创建一个新的方法并将其连接到按钮。你知道它已经连接，因为方法左侧有一个填充的灰色圆圈。现在，每次用户点击按钮时，这个方法都会被执行。请注意，这个方法在其开头有`@IBAction`。这是连接到界面元素的任何方法都需要的东西。
- en: 'We want this method to present the user with an interface to take a picture.
    Apple provides a class for us called `UIImagePickerController` that makes this
    very easy for us. All we need to do is create an instance of `UIImagePickerController`,
    configure it to allow taking pictures, and present it to the screen. The code
    looks like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望这个方法向用户提供一个拍照的界面。苹果为我们提供了一个名为`UIImagePickerController`的类，这使得这非常简单。我们只需要创建一个`UIImagePickerController`实例，将其配置为允许拍照，并将其呈现到屏幕上。代码看起来是这样的：
- en: '[PRE0]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Lets break this code down. On the first line, we are creating our image picker.
    On the second line, we are checking if the current device has a camera by using
    the `isSourceTypeAvailable:` class method of `UIImagePickerController`. If the
    camera source is available, we set that as the source type for the image picker
    on line three. Otherwise, by default, an image picker lets the user pick an image
    from their photo library. Since the simulator doesn't support taking a picture,
    you are going to be presented with an image picker instead of a camera when simulating
    the app. Finally, the last line asks our view controller to present our image
    picker by animating it on the screen. `presentViewController:animated:completion:`
    is a method implemented within the `UIViewController` class, the superclass of
    our `ViewController`, to make it easy for us to present new view controllers.
    If you run the app and click on the add button, you will be asked for permission
    to access the photos and then it will display the photo picker. You can tap the
    **Cancel** button in the upper right and the image picker controller will be dismissed.
    However, if you select a photo, nothing will happen.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码。在第一行，我们创建了一个图片选择器。在第二行，我们通过使用`UIImagePickerController`的`isSourceTypeAvailable:`类方法来检查当前设备是否有摄像头。如果摄像头源可用，我们在第三行将其设置为图片选择器的源类型。否则，默认情况下，图片选择器允许用户从他们的照片库中选择图片。由于模拟器不支持拍照，所以在模拟应用时，你会看到一个图片选择器而不是摄像头。最后，最后一行要求我们的视图控制器通过在屏幕上动画显示来呈现我们的图片选择器。`presentViewController:animated:completion:`是`UIViewController`类实现的一个方法，它是我们的`ViewController`的父类，这使得我们能够轻松地呈现新的视图控制器。如果你运行应用并点击添加按钮，你会被要求允许访问照片，然后它会显示图片选择器。你可以点击右上角的**取消**按钮，图片选择器控制器将被关闭。然而，如果你选择了一张照片，什么也不会发生。
- en: 'We need to write some code to handle the picking of a photo. To make this possible,
    image picker can have a delegate that receives a method call when an image is
    picked. We are going to make our view controller the delegate of the image picker
    and implement its protocol. First, we have to add a line to our action method
    above, that assigns our view controller as the delegate of the image picker. Add
    this line above the call to present the image picker:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写一些代码来处理照片的选择。为了使这成为可能，图像选择器可以有一个代理，当选择图像时接收方法调用。我们将使我们的视图控制器成为图像选择器的代理并实现其协议。首先，我们必须在我们的操作方法中添加一行，将我们的视图控制器分配为图像选择器的代理。在调用显示图像选择器之前添加此行：
- en: '[PRE1]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'When we do that, we will get a compiler error that says that we can''t make
    this assignment because our view controller doesn''t implement the necessary protocols.
    Lets change that. I like to implement each protocol as a separate extension in
    the same file to allow for better code separation. We need to implement both `UIImagePickerControllerDelegate`
    and `UINavigationControllerDelegate` according to the error. The only method that
    is important to us in either of these protocols is the one that is called when
    an image is picked. That leaves us with the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，我们会得到一个编译器错误，说我们无法进行这个赋值，因为我们的视图控制器没有实现必要的协议。让我们来改变一下。我喜欢在每个文件中实现每个协议作为一个单独的扩展，以便更好地分离代码。我们需要根据错误实现`UIImagePickerControllerDelegate`和`UINavigationControllerDelegate`。在这两个协议中，对我们来说唯一重要的方法是当选择图像时被调用的方法。这让我们有了以下代码：
- en: '[PRE2]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Our implementation for the `UINavigationControllerDelegate` delegate is empty
    but we have a simple implementation for the `imagePickerController:picker:didFinishPickingImage:editingInfo:`
    method. This is where we are going to add our handling code, but for now, we are
    just dismissing the presented view controller to return the user to the previous
    screen. This method does not force us to specify the view controller we are dismissing
    because the view controller already knows which one it is presenting. Now, if
    you run the app and select a photo, you will return to the previous screen but
    nothing else will happen. In order to make something meaningful happen with the
    photo, we are going to have to put a lot of other code in place. We have to both
    save the picture and implement our view controller to display the picture inside
    our collection view.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`UINavigationControllerDelegate`代理的实现是空的，但我们有一个简单的`imagePickerController:picker:didFinishPickingImage:editingInfo:`方法的实现。这就是我们将添加我们的处理代码的地方，但现在，我们只是关闭显示的视图控制器，将用户返回到上一个屏幕。这个方法并不强迫我们指定我们要关闭的视图控制器，因为视图控制器已经知道它正在显示哪个视图控制器。现在，如果你运行应用程序并选择一张照片，你将返回到上一个屏幕，但不会发生其他任何事情。为了使照片发生有意义的事情，我们必须放置大量的其他代码。我们必须保存图片并实现我们的视图控制器，以便在集合视图中显示图片。
- en: Temporarily saving a photo
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 临时保存照片
- en: 'To start, we are only going to concern ourselves with temporarily storing our
    pictures in memory. To do this, we can add an image array as a property of our
    view controller:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们只关心在内存中临时存储我们的图片。为此，我们可以将一个图像数组添加为视图控制器的一个属性：
- en: '[PRE3]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we saw in the image picker delegate method, UIKit provides a class `UIImage`
    that can represent images. Our `photos` property can store an array of these instances.
    This means that the first step for us is to add new images to our property when
    the callback is called:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在图像选择器代理方法中看到的，UIKit提供了一个可以表示图像的类`UIImage`。我们的`photos`属性可以存储这些实例的数组。这意味着当我们收到回调时，我们的第一步是向我们的属性添加新的图像：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now every time the user takes or picks a new photo, we add it to our list, which
    stores all of the images in memory. However, this isn't quite enough, we also
    want to require a label for each photo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次用户拍摄或选择一张新照片，我们都会将其添加到我们的列表中，该列表存储所有图像在内存中。然而，这还不够，我们还想为每张照片要求一个标签。
- en: 'To support this feature, let''s create a new structure called `Photo` that
    has an image and label property. At this point, I would create three groups in
    the `LearningCamera` folder: Model, View, and Controller by right-clicking on
    the `LearningCamera` folder and choosing **New Group**. I would move `ViewController.swift`
    into the **Controller** group and then create a new `Photo.swift` file by right-clicking
    on the **Model** group and selecting **New File…**. Just a plain **Swift File**
    is fine.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持这个功能，让我们创建一个新的结构体叫做 `Photo`，它包含一个图像和标签属性。在这个阶段，我会通过在 `LearningCamera` 文件夹上右键点击并选择
    **New Group** 来创建三个组：Model、View 和 Controller。我会将 `ViewController.swift` 移动到 **Controller**
    组中，然后通过在 **Model** 组上右键点击并选择 **New File…** 来创建一个新的 `Photo.swift` 文件。一个简单的 **Swift
    File** 就可以了。
- en: 'You should define your photo structure in that file:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该在那个文件中定义你的照片结构：
- en: '[PRE5]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have to import UIKit because that is what defines UIImage. The rest of our
    structure is straightforward as it just defines our two desired properties. The
    default initializer will be fine for now.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须导入 UIKit，因为它是定义 `UIImage` 的地方。我们的结构体的其余部分都很直接，因为它只定义了我们想要的两个属性。默认初始化器现在就足够了。
- en: 'Now, we can return to our `ViewController.swift` file and update our `photos`
    property to be of the type `Photo` instead of `UIImage`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以回到我们的 `ViewController.swift` 文件，并将我们的 `photos` 属性更新为 `Photo` 类型而不是 `UIImage`：
- en: '[PRE6]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This now creates a new problem for us. How do we ask the user for the label
    for the image? Let''s do that in a standard alert. To display an alert, UIKit
    has a class called `UIAlertController`. To use this, we will have to rework our
    function some. UIKit does not allow you to present more than one view controller
    from the same view controller at the same time. This means that we have to dismiss
    the photo picker and wait for that to complete before displaying our alert:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这现在给我们带来了一个新的问题。我们如何请求用户为图像提供标签？让我们在一个标准的提示框中这样做。为了显示提示框，UIKit 有一个名为 `UIAlertController`
    的类。为了使用它，我们可能需要重新设计我们的函数。UIKit 不允许你从同一个视图控制器在同一时间显示多个视图控制器。这意味着我们必须先关闭照片选择器，等待其完成后再显示我们的提示框：
- en: '[PRE7]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Lets break down this code, as it is somewhat complex. To start, we are using
    the trailing closure syntax for the `dismissViewControllerAnimated:completion:`
    method. This closure is called once the view controller has finished animating
    off the screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解这段代码，因为它有些复杂。首先，我们使用了尾随闭包语法来调用 `dismissViewControllerAnimated:completion:`
    方法。这个闭包在视图控制器完成动画离开屏幕后被调用。
- en: Next, we are creating an alert controller with a title, message, and `Alert`
    as its style. Before we can display the alert controller, we have to configure
    it with a text field and a save action. We start by adding the text field and
    use the trailing closure again on `addTextFieldWithConfigurationHandler:`. This
    closure is called to give us an opportunity to configure the text field. We are
    OK with the defaults but we are going to want to know the text contained in the
    text field when saving so we can create our save action directly within this alert
    and save ourselves the hassle of getting a reference to it later.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个带有标题、消息和 `Alert` 样式的提示框控制器。在我们能够显示提示框之前，我们必须使用一个文本框和一个保存操作来配置它。我们首先添加文本框，并在
    `addTextFieldWithConfigurationHandler:` 上再次使用尾随闭包。这个闭包被调用以给我们机会配置文本框。我们接受默认设置，但我们将想要知道在保存时文本框中的文本，这样我们就可以在这个提示框中直接创建保存操作，从而避免以后获取其引用的麻烦。
- en: Each action of an alert must be of the type `UIAlertAction`. In this case, we
    create one with the title `Save` with the default style. The last parameter of
    the `UIAlertAction` initializer is a closure that will be called when the user
    chooses that action. Again, we use the trailing closure syntax.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 提示框的每个操作都必须是 `UIAlertAction` 类型。在这种情况下，我们创建了一个标题为 `Save` 并具有默认样式的操作。`UIAlertAction`
    构造函数的最后一个参数是一个闭包，当用户选择该操作时会被调用。同样，我们使用了尾随闭包语法。
- en: Inside that callback, we get the text from the text field and use that, along
    with our image, to create a new `Photo` instance and add it to our `photos` array.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个回调内部，我们从文本框中获取文本，并使用它以及我们的图像来创建一个新的 `Photo` 实例，并将其添加到我们的 `photos` 数组中。
- en: Finally, we have to add our save action to the alert controller and then display
    the alert controller.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须将我们的保存操作添加到提示框控制器中，然后显示提示框控制器。
- en: Now if you run the app, it will ask you for a label for each photo after it
    is chosen but it still won't appear to be showing it because we are not displaying
    the saved photos yet. That is our next task.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行应用程序，它会在选择照片后要求你为每个照片提供一个标签，但它看起来仍然没有显示出来，因为我们还没有显示保存的照片。这是我们下一个任务。
- en: Populating our photo grid
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充我们的照片网格
- en: 'Now that we are maintaining a list of photos, we need to display it in our
    collection view. A collection view is populated by providing it with a data source
    that implements its `UICollectionViewDataSource` protocol. Probably the most common
    thing to do is to have the view controller be the data source. We can do this
    by opening the `Main.storyboard` back up and *control* dragging from the collection
    view to the view controller:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们正在维护一个照片列表，我们需要在集合视图中显示它。集合视图通过提供实现其 `UICollectionViewDataSource` 协议的数据源来填充。最常见的事情可能是让视图控制器成为数据源。我们可以通过重新打开
    `Main.storyboard` 并 *控制* 拖动从集合视图到视图控制器来实现这一点：
- en: '![Populating our photo grid](img/B05103_11_15.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![填充我们的照片网格](img/B05103_11_15.jpg)'
- en: 'When you let go, select **dataSource** from the menu. After that, all we need
    to do is implement the data source protocol. The two methods we need to implement
    are `collectionView:numberOfItemsInSection:` and `collectionView:cellForItemAtIndexPath:`.
    The former allows us to specify how many cells should be displayed and the latter
    allows us to customize each cell for a specific index into our list. It is easy
    for us to return the number of cells that we want:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你松开鼠标时，从菜单中选择 **dataSource**。之后，我们只需要实现数据源协议。我们需要实现的两个方法是 `collectionView:numberOfItemsInSection:`
    和 `collectionView:cellForItemAtIndexPath:`。前者允许我们指定应该显示多少个单元格，后者允许我们为列表中的特定索引自定义每个单元格。我们很容易返回我们想要的单元格数量：
- en: '[PRE8]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: All we have to do is return the number of elements in our `photos` property.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要返回我们 `photos` 属性中的元素数量。
- en: 'Configuring the cell is going to take a little bit more preparation. First,
    we need to create our own cell subclass that can reference the image and label
    we created in the storyboard. All collection view cells must subclass `UICollectionViewCell`.
    Let''s call ours `PhotoCollectionViewCell` and create a new file for it in the
    **View** group. Like we needed a connection from the storyboard to our code for
    tapping the add button, we need a connection for both the image and the label.
    However, this is a different type of connection. Instead of an action, this type
    of connection is called an outlet, which adds the object as a property to the
    view controller. We could use the same click and drag technique we used for the
    action, but this time we will set up the code in advance ourselves:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 配置单元格需要更多的准备工作。首先，我们需要创建自己的单元格子类，以便可以引用在故事板中创建的图像和标签。所有集合视图单元格都必须是 `UICollectionViewCell`
    的子类。让我们称它为 `PhotoCollectionViewCell` 并在 **View** 组中为它创建一个新文件。就像我们需要从故事板到我们的代码中建立点击添加按钮的连接一样，我们还需要为图像和标签建立连接。然而，这是一种不同类型的连接。这种类型的连接不是动作，而被称为输出，它将对象作为属性添加到视图控制器中。我们可以使用与动作相同的点击和拖动技术，但这次我们将自己提前设置代码：
- en: '[PRE9]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here we have specified two properties, each with a prefix of `@IBOutlet`. This
    prefix is what allows us to make the connection in Interface Builder just like
    we did with the data source. Both types are defined as implicitly unwrapped optionals
    because these connections cannot be set when the instance is initialized. Instead,
    they are connected when loading the view.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们指定了两个属性，每个属性都有一个前缀 `@IBOutlet`。这个前缀允许我们在 Interface Builder 中建立连接，就像我们处理数据源时做的那样。这两种类型都被定义为隐式解包的可选类型，因为这些连接在实例初始化时无法设置。相反，它们在加载视图时建立连接。
- en: 'Now that we have that setup, we can go back to the storyboard and make the
    connections. Currently the cell is still just the type of a generic cell so first
    we need to change it to our class. Find the cell inside the view hierarchy on
    the left and click on it. Select **View** | **Utilities** | **Show Identify Inspector**.
    In this inspection, we can set the class of the cell to our class by entering
    `PhotoCollectionViewCell` in the class field. Now if you navigate to **View**
    | **Utilities** | **Show Connections Inspector** you will see our two outlets
    listed as possible connections. Click and drag from the hollow gray circle next
    to **imageView** to the image view in the cell:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了环境，我们可以回到故事板并建立连接。目前这个单元格仍然只是一个通用单元格的类型，所以首先我们需要将其更改为我们的类。在左侧视图层次结构中找到单元格，并点击它。选择**视图**
    | **实用工具** | **显示识别检查器**。在这个检查器中，我们可以在类字段中输入`PhotoCollectionViewCell`来设置单元格的类。现在，如果你导航到**视图**
    | **实用工具** | **显示连接检查器**，你会看到我们的两个输出列在可能连接中列出。点击并从**imageView**旁边的空心灰色圆圈拖动到单元格中的图像视图：
- en: '![Populating our photo grid](img/B05103_11_16.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![填充我们的照片网格](img/B05103_11_16.jpg)'
- en: 'Once you let go, the connection will be made. Do the same thing with the **label**
    connection to the label we created before. We also need to set a reuse identifier
    for our cell so that we can reference this template in code. You can do this by
    returning to the Attributes Inspector and entering `DefaultCell` into the **Identifier**
    text field:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你松开鼠标，连接就会建立。用同样的方法对之前创建的**标签**连接进行操作。我们还需要为我们的单元格设置一个重用标识符，这样我们就可以在代码中引用这个模板。你可以通过返回属性检查器并在**标识符**文本字段中输入`DefaultCell`来完成此操作：
- en: '![Populating our photo grid](img/B05103_11_17.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![填充我们的照片网格](img/B05103_11_17.jpg)'
- en: 'We are also going to need a reference to the collection view from within our
    view controller. This is because we will need to ask the collection view to add
    a cell each time a photo is saved. You can add this by writing the code first
    or by right clicking and dragging from the collection view to the code. Either
    way, you should end up with a property like this on the view controller:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在视图控制器内部获取集合视图的引用。这是因为每次保存照片时，我们都需要要求集合视图添加一个单元格。你可以通过编写代码或通过右键单击并从集合视图拖动到代码来实现这一点。无论如何，你应该在视图控制器上得到一个类似这样的属性：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Then we are ready to implement the remaining data source method:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们就准备好实现剩余的数据源方法：
- en: '[PRE11]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The first line of this implementation asks the collection view for a cell with
    our `DefaultCell` identifier. To understand this fully, we have to understand
    a little bit more about how a collection view works. A collection view is designed
    to handle virtually any number of cells. We could want to display thousands of
    cells at once but it would not be possible to have thousands of cells in memory
    at one time. Instead, the collection view will automatically reuse cells that
    have been scrolled off the screen to save on memory. We have no way of knowing
    whether the cell we get back from this call is new or reused, so we must always
    assume it is being reused. This means that anything we configure on a cell in
    this method, must always be reset on each call, otherwise, some old configurations
    may still exist from its previous configuration. We end that call by casting the
    result to our `PhotoCollectionViewCell` class so that we can configure our subviews
    properly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个实现的第 一行要求集合视图提供一个带有我们的`DefaultCell`标识符的单元格。为了完全理解这一点，我们需要稍微了解一些集合视图的工作原理。集合视图被设计成可以处理几乎任何数量的单元格。我们可能想要一次性显示成千上万的单元格，但一次在内存中拥有成千上万的单元格是不可能的。相反，集合视图会自动重用已经滚动出屏幕的单元格以节省内存。我们无法知道从这个调用中获取的单元格是新的还是重用的，所以我们必须始终假设它正在被重用。这意味着在这个方法中对单元格所做的任何配置，都必须在每次调用时重置，否则，一些旧配置可能仍然存在。我们通过将结果转换为我们的`PhotoCollectionViewCell`类来结束这个调用，这样我们就可以正确地配置我们的子视图。
- en: Our second line is getting the correct photo out of our list. The `item` property
    on the `indexPath` variable is the index of the photo that we are using to configure
    the cell. At any time, this method could be called with any index between zero
    and the number returned in our previous data source method. This means that in
    our case, it will always be a number within our `photos` array, making it safe
    to assume that the index is properly within its bounds.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第二行是从我们的列表中获取正确的照片。`indexPath`变量上的`item`属性是我们用来配置单元格的照片的索引。任何时候，都可以用零到我们之前数据源方法返回的数字之间的任何索引调用此方法。这意味着在我们的情况下，它将始终是`photos`数组中的数字，因此可以安全地假设索引在其范围内。
- en: The next two lines set the image and label according to the photo and finally,
    the last line returns that cell so that the collection view can display it.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两行根据照片设置图像和标签，最后，最后一行返回该单元格，以便集合视图可以显示它。
- en: 'At this point, if you ran the app and added a photo you still wouldn''t see
    anything because the collection view will not automatically reload its data when
    an element is added to the photos array. That is because the `collectionView:numberOfItemsInSection:`
    method is a callback. Callbacks are only called when other code initiates it.
    This method is called once when the collection view is first loaded but we must
    ask it to be called again manually from then on. The easiest way to do this is
    to call `reloadData` on the collection view when we add a photo to the list. This
    causes all of the data and cells to be loaded again. However, this does not look
    very good because the cell will just pop into existence. Instead, we want to use
    the `insertItemsAtIndexPaths` method. When used properly, this will cause a cell
    to be animated onto the screen. The important thing to remember with this method
    is that you must only call it after `collectionView:numberOfItemsInSection:` returns
    the updated amount after the insertion. This means we must call it after we have
    already added our photo to our property:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果你运行了应用程序并添加了一张照片，你仍然什么也看不到，因为当向照片数组添加元素时，集合视图不会自动重新加载数据。这是因为`collectionView:numberOfItemsInSection:`方法是一个回调。回调只有在其他代码启动它时才会被调用。此方法在集合视图首次加载时调用一次，但我们必须手动请求它再次调用。最简单的方法是在我们向列表添加照片时在集合视图上调用`reloadData`。这会导致所有数据和单元格再次加载。然而，这看起来并不好，因为单元格会突然出现。相反，我们希望使用`insertItemsAtIndexPaths`方法。当正确使用时，这将导致单元格以动画方式出现在屏幕上。使用此方法时需要记住的重要事情是，你必须在`collectionView:numberOfItemsInSection:`返回插入后的更新数量之后调用它。这意味着我们必须在我们已经将照片添加到我们的属性之后调用它：
- en: '[PRE12]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Only the last two lines of this are new. First, we create an index path for
    where we want to insert our new item. An index path consists of both an item and
    a section. All of our items exist in a single section, so we can always set that
    to zero. We want the item to be one less than the total count of photos because
    we just added it to the end of the list. The last line is simply making the call
    to the insert items method that takes an array of index paths.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的最后两行是新的。首先，我们为要插入新项的位置创建一个索引路径。索引路径由项和部分组成。我们所有的项都存在于单个部分中，因此我们可以将其始终设置为零。我们希望项的总数减一，因为我们刚刚将其添加到列表的末尾。最后一行只是调用接受索引路径数组作为参数的插入项方法。
- en: Now you can run your app and all saved photos will be displayed in the collection
    view.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以运行你的应用程序，所有保存的照片都将显示在集合视图中。
- en: Refactoring to respect model-view-controller
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重构以尊重模型-视图-控制器
- en: We have already made some good progress on the core functionality of our app.
    However, before we move any further, we should reflect on the code we have written.
    Ultimately, we haven't actually written that many lines of code, but it can definitely
    be improved. The biggest shortcoming of our code is that we have put a lot of
    business logic inside our view controller. This is not a good separation of our
    different model, view, and controller layers. Let's take this opportunity to refactor
    this code into a separate type.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在我们的应用程序的核心功能上取得了一些进展。然而，在我们继续前进之前，我们应该反思我们所编写的代码。最终，我们实际上并没有编写很多代码行，但它肯定可以改进。我们代码的最大缺点是我们将大量业务逻辑放在了视图控制器中。这不是我们不同模型、视图和控制器层之间的良好分离。让我们利用这个机会将此代码重构为单独的类型。
- en: We will create a class called `PhotoStore` that will be responsible for storing
    our photos and that will implement the data source protocol. This will mean moving
    some of our code out of our view controller.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个名为 `PhotoStore` 的类，该类将负责存储我们的照片，并将实现数据源协议。这意味着将一些代码从我们的视图控制器中移出。
- en: 'First, we will move the photo''s property to the photo store class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将照片的属性移动到照片存储类中：
- en: '[PRE13]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that this new photo store class inherits from `NSObject`. This is necessary
    for us to be able to fully satisfy the `UICollectionViewDataSource` protocol,
    which is our next task.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个新的照片存储类继承自 `NSObject`。这对于我们能够完全满足 `UICollectionViewDataSource` 协议是必要的，这是我们下一个任务。
- en: 'We could simply move the code from our view controller to this class, but we
    do not want our model to deal directly with our view layer. The current implementation
    creates and configures our collection view cell. Lets allow the view controller
    to still handle that by providing our own callback for when we need a cell for
    a given photo. To do that, we will first need to add a callback property:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将代码从我们的视图控制器简单地移动到这个类中，但我们不希望我们的模型直接处理我们的视图层。当前的实现创建并配置我们的集合视图单元格。让我们允许视图控制器仍然处理它，通过提供我们自己的回调，当我们需要给定照片的单元格时。为此，我们首先需要添加一个回调属性：
- en: '[PRE14]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We need to provide an initializer now so that we can get the callback function.
    Next, we have to tweak our data source implementations and put them in this new
    class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要提供一个初始化器，这样我们就可以获取回调函数。接下来，我们必须调整我们的数据源实现，并将它们放入这个新类中：
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `collectionView:numberOfItemsInSection:` method can still just return the
    number of photos in our array, but `collectionView:cellForItemAtIndexPath:` is
    implemented to use the callback instead of creating a cell itself.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`collectionView:numberOfItemsInSection:` 方法仍然可以只返回我们数组中的照片数量，但 `collectionView:cellForItemAtIndexPath:`
    是通过回调来实现的，而不是创建一个单元格本身。'
- en: 'The second thing we need to add to this class is the ability to save a photo.
    Let''s add a method to take a new image and label that returns the index path
    that should be added:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加到这个类的第二件事是保存照片的能力。让我们添加一个方法来接受一个新的图像和标签，并返回应该添加的索引路径：
- en: '[PRE16]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This looks identical to the code we wrote in the view controller to do this,
    but it is better separated.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与我们在视图控制器中编写的代码相同，但分离得更好。
- en: 'Now our photo store is complete and we just have to update our view controller
    to use it instead of our old implementation. First, lets add a photo store property
    that is an implicitly unwrapped optional in `ViewController` so we can create
    it after the view is loaded:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的照片存储已经完成，我们只需更新我们的视图控制器以使用它而不是旧的实现。首先，让我们在 `ViewController` 中添加一个照片存储属性，它是一个隐式解包的可选值，这样我们就可以在视图加载后创建它：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'To create our photo store in `viewDidLoad`, we will call the photo store initializer
    and pass it a closure that can create the cell. For clarity, we will define that
    closure as a separate method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `viewDidLoad` 中创建我们的照片存储，我们将调用照片存储初始化器，并传递一个可以创建单元格的闭包。为了清晰起见，我们将定义这个闭包为一个单独的方法：
- en: '[PRE18]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This method looks almost identical to our old `collectionView:cellForItemAtIndexPath:`
    implementation; the only difference is that we already have a reference to the
    correct photo.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法看起来几乎与我们的旧 `collectionView:cellForItemAtIndexPath:` 实现相同；唯一的区别是我们已经有一个对正确照片的引用。
- en: 'This method allows our `viewDidLoad` implementation to be very simple. All
    we need to do is initialize the photo store with a reference to this method and
    make it the data source for the collection view:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法允许我们的 `viewDidLoad` 实现非常简单。我们所需做的只是用对这个方法的引用初始化照片存储，并使其成为集合视图的数据源：
- en: '[PRE19]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Lastly, we just have to update the save action to use the photo store:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需更新保存操作以使用照片存储：
- en: '[PRE20]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You can run the app again and it will operate as before, but now our code is
    modular, which will make any future changes much easier.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以再次运行应用程序，它将像以前一样操作，但现在我们的代码是模块化的，这将使未来的任何更改都更容易。
- en: Permanently saving a photo
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 永久保存照片
- en: Our app works pretty well for saving pictures, but as soon as the app quits,
    all of the photos are lost. We need to add a way to save the photos permanently.
    Our refactoring of the code allows us to work primarily within the model layer
    now.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序在保存图片方面工作得相当不错，但一旦应用程序退出，所有照片都会丢失。我们需要添加一种永久保存照片的方法。我们对代码的重构使我们现在主要在模型层工作。
- en: Before we write any code, we have to decide how we are going to store the photos
    permanently. There are many ways in which we can choose to save the photos, but
    one of the easiest is to save it to the file system, which is what we conceived
    of in our conception phase. Every app is provided a documents directory that is
    automatically backed up by the operating system as a part of normal backups. We
    can store our photos in there as files named after the label the user gives them.
    To avoid any problems with duplicate labels, where we would have multiple files
    named the same thing, we can nest every file inside a subdirectory named after
    the time the photos is saved. The time stamp will always be unique because we
    will never save two photos at the exact same time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写任何代码之前，我们必须决定我们将如何永久存储照片。我们可以选择多种方式来保存照片，但其中一种最简单的方式是将它们保存到文件系统中，这是我们构思阶段所设想的方式。每个应用程序都提供了一个文档目录，作为正常备份的一部分，操作系统会自动备份。我们可以将照片存储在那里，以用户提供的标签命名的文件命名。为了避免任何与重复标签相关的问题，即我们会有多份同名文件，我们可以将每个文件嵌套在以保存照片的时间命名的子目录中。时间戳总是唯一的，因为我们永远不会在完全相同的时间保存两张照片。
- en: 'Now that we have that decided, we can start to update our photo store code.
    First, we will want to have an easy way to use a consistent directory for saving.
    We can create that by adding a method called `getSaveDirectory`. This method can
    be private and, as a convention, I like to group private code in a private extension:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经决定了这一点，我们可以开始更新我们的照片存储代码。首先，我们希望有一个简单的方法来使用一致的目录进行保存。我们可以通过添加一个名为 `getSaveDirectory`
    的方法来实现这一点。这个方法可以是私有的，并且按照惯例，我喜欢将私有代码分组在私有扩展中：
- en: '[PRE21]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code first gets a URL representing the documents directory from an Apple-provided
    class called `NSFileManager`. You may notice that `NSFileManager` has a shared
    instance that can be accessed through the `defaultManager` class method. We then
    call the `URLForDirectory` method, give it information indicating that we want
    the documents directory for the current user, and return the result. Note that
    this method can throw an error, so we marked our own method as throwing and did
    not allow any errors to propagate.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码首先从名为 `NSFileManager` 的苹果提供类中获取表示文档目录的 URL。你可能注意到 `NSFileManager` 有一个共享实例，可以通过
    `defaultManager` 类方法访问。然后我们调用 `URLForDirectory` 方法，给它提供信息表明我们想要当前用户的文档目录，并返回结果。请注意，这个方法可能会抛出错误，所以我们标记了自己的方法为抛出错误，并且不允许任何错误传播。
- en: 'Now we can move on to saving all added images to disk. There are a number of
    things that we will need to be done. First, we need to get the current time stamp.
    We can do this by creating an `NSDate` instance, asking that for the time stamp
    and using string interpolation to turn it into a string:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以继续将所有添加的图片保存到磁盘上。我们需要完成的事情有很多。首先，我们需要获取当前的时间戳。我们可以通过创建一个 `NSDate` 实例，请求时间戳，并使用字符串插值将其转换为字符串来完成：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`NSDate` instances can represent any sort of time on any date. By default,
    all `NSDate` instances are created to represent the current time.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSDate` 实例可以代表任何日期上的任何时间。默认情况下，所有 `NSDate` 实例都是创建来表示当前时间的。'
- en: 'Next, we are going to want to append that onto our save directory to get the
    path where we are going to save the file. For that, we can use the `URLByAppendingPathComponent:`
    method of `NSURL`:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要将这个路径附加到我们的保存目录上，以获取我们将要保存文件的路径。为此，我们可以使用 `NSURL` 的 `URLByAppendingPathComponent:`
    方法：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This will ensure that the proper path slash is added, if it is not already
    there. Now we need to make sure that this directory exists before we try to save
    a file to it. This is done using a method on `NSFileManager`:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保如果还没有添加，正确的路径斜杠会被添加。现在我们需要确保在尝试将文件保存到该目录之前，这个目录已经存在。这是通过 `NSFileManager`
    上的一个方法来完成的：
- en: '[PRE24]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This method can throw if there is an error, which we will need to handle later.
    It is still considered a success if the directory already exists. Once we are
    sure that the directory has been created, we will want to create the path to the
    specific file using the label text:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有错误，这个方法可能会抛出异常，我们稍后会需要处理它。如果目录已经存在，这仍然被视为成功。一旦我们确信目录已经创建，我们就会想要创建一个指向特定文件的路径，使用标签文本：
- en: '[PRE25]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here we used string interpolation to add a `.jpg` extension to the file name.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了字符串插值来给文件名添加 `.jpg` 扩展名。
- en: 'Most importantly, we will need to convert our image to data that can be saved
    to a file. For that, UIKit provides a function called `UIImageJPEGRepresentation`
    that takes the `UIImage` and returns an `NSData` instance:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，我们需要将我们的图像转换为可以保存到文件中的数据。为此，UIKit提供了一个名为`UIImageJPEGRepresentation`的函数，它接受`UIImage`并返回一个`NSData`实例：
- en: '[PRE26]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The second parameter is a value between zero and one representing the compression
    quality we want. In this case, we want to save the file at full quality, so we
    use 1\. It then returns an optional data instance, so we will need to handle the
    scenario where it returns nil.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个参数是一个介于零和一之间的值，表示我们想要的压缩质量。在这种情况下，我们希望以全质量保存文件，所以我们使用1。然后它返回一个可选数据实例，因此我们需要处理它返回nil的情况。
- en: 'Finally, we need to save that data to the file path we created:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将数据保存到我们创建的文件路径：
- en: '[PRE27]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This method on `NSData` simply takes the file path and a Boolean indicating
    if we want it to write to a temporary location before it overwrites any existing
    file. It also returns `true` or `false` depending on if it is successful. Unlike
    directory creation, this will fail if the file already exists. However, since
    we are using the current time stamp that should never be a problem.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在`NSData`上的这种方法简单来说就是接收一个文件路径和一个布尔值，表示我们是否希望在覆盖任何现有文件之前将其写入临时位置。它还会根据是否成功返回`true`或`false`。与目录创建不同，如果文件已存在，这将失败。然而，由于我们使用的是当前时间戳，这应该永远不会成为问题。
- en: 'Lets combine all of this logic into a method on our photo structure that we
    can use later to save it to disk, which throws an error in case of an error:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将所有这些逻辑组合到我们的照片结构上的一个方法中，我们可以稍后使用它将其保存到磁盘，如果发生错误则抛出错误：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we define a nested enumeration for our possible errors. Then we define
    the method to take the root level directory where it should be saved. We allow
    any errors from the directory creation to propagate. We also need to throw our
    errors if the data comes back nil or if the `writeToURL:automatically:` method
    fails.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义一个嵌套枚举来表示我们的可能错误。然后我们定义一个方法来接受应该保存的根级目录。我们允许目录创建的任何错误传播。如果数据返回nil或`writeToURL:automatically:`方法失败，我们还需要抛出我们的错误。
- en: 'Now we need to update our `saveNewPhotoWithImage:labeled:` to use the `saveToDirectory:`
    method. Ultimately, if an error is thrown while saving the photo, we will want
    to display something to the user. That means that this method will need to just
    propagate the error, because the model should not be the one to display something
    to the user. That results in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要更新我们的`saveNewPhotoWithImage:labeled:`方法，以使用`saveToDirectory:`方法。最终，如果在保存照片时抛出错误，我们希望向用户显示一些内容。这意味着这个方法只需要传播错误，因为模型不应该向用户显示内容。这导致以下代码：
- en: '[PRE29]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'If the saving to directory fails, we will skip the rest of the method so we
    won''t add it to our photos list. That means we need to update the view controller
    code that calls it to handle the error. First, let''s add a method to make it
    easy to display an error with a given title and message:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果保存到目录失败，我们将跳过方法的其余部分，这样我们就不会将其添加到我们的照片列表中。这意味着我们需要更新调用它的视图控制器代码以处理错误。首先，让我们添加一个方法，使其能够轻松地显示一个带有给定标题和消息的错误：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This method is simple. It just creates an alert with an OK button and then
    presents it. Next, we can add a function to display any kind of error we will
    expect. It will take a title for the alert that will pop-up, so we can customize
    the error we are displaying for the scenario that produced it:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法很简单。它只是创建一个带有OK按钮的警报，然后显示它。接下来，我们可以添加一个函数来显示我们预期会遇到的任何类型的错误。它将接受一个弹出警报的标题，这样我们就可以为产生它的场景定制显示的错误：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We expect either the built-in error type of `NSError` that will come from Apple's
    APIs or the error type we defined in our photo type. The localized description
    property of Apple's errors just creates a description in the locale the device
    is currently configured for. We also handle any other error scenarios by just
    reporting it as an unknown error.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望的是来自Apple API的内置错误类型`NSError`，或者我们在我们的照片类型中定义的错误类型。Apple错误的本地化描述属性仅创建设备当前配置的区域的描述。我们还通过仅将其报告为未知错误来处理任何其他错误场景。
- en: 'I would also extract our save action creation to a separate method so we don''t
    overcomplicate things when we add in our do-catch blocks. This will be very similar
    to our previous code but we will wrap the call to `saveNewPhotoWithImage:labeled:`
    in a do-catch block and call our error handling method on any thrown errors:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我还会将我们的保存操作创建提取到一个单独的方法中，这样当我们添加 do-catch 块时，就不会使事情过于复杂。这将会非常类似于我们之前的代码，但我们将在
    `saveNewPhotoWithImage:labeled:` 的调用周围包裹一个 do-catch 块，并在抛出的任何错误上调用我们的错误处理方法：
- en: '[PRE32]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'That leaves us with just needing to update the `imagePickerController:didFinishPickingImage:editingInfo:`
    method to use our new save action creating method:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 这就剩下我们需要更新 `imagePickerController:didFinishPickingImage:editingInfo:` 方法，以便使用我们新的保存操作创建方法：
- en: '[PRE33]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: That completes the first half of permanently storing our photos. We are now
    saving the images to disk but that is useless if we don't load them from disk
    at all.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了永久存储我们照片的第一部分。我们现在正在将图像保存到磁盘，但如果我们从磁盘上根本不加载它们，那就毫无意义。
- en: 'To load an image from disk, we can use the `contentsOfFile:` initializer of
    `UIImage` that returns an optional image:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 要从磁盘加载图像，我们可以使用 `UIImage` 的 `contentsOfFile:` 初始化器，它返回一个可选的图像：
- en: '[PRE34]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To convert our file path URL to a string, which is what the initializer requires,
    we can use the relative path property.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 要将我们的文件路径 URL 转换为字符串，这是初始化器所要求的，我们可以使用相对路径属性。
- en: 'We can get the label for the photo by removing the file extension and getting
    the last component of the path:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过删除文件扩展名并获取路径的最后一个组件来获取照片的标签：
- en: '[PRE35]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now we can combine this logic into an initializer on our `Photo` struct. To
    do this, we will also have to create a simple initializer that takes the image
    and label so that our other code that uses the default initializer still works:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个逻辑组合到我们的 `Photo` 结构体的初始化器中。为此，我们还需要创建一个简单的初始化器，它接受图像和标签，这样我们的其他代码在使用默认初始化器时仍然可以正常工作：
- en: '[PRE36]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Lastly, we need to have the image store enumerate through the files in the
    documents directory calling this initializer for each one. To enumerate through
    a directory, `NSFileManager` has an `enumeratorAtFilePath:` method. It returns
    an enumerator instance that has a `nextObject` method. Each time it is called,
    it returns the next file or directory inside the original directory. Note that
    this will enumerate all children of each subdirectory it finds. This is a great
    example of the iterator pattern we saw in [Chapter 9](ch09.html "Chapter 9. Writing
    Code the Swift Way – Design Patterns and Techniques"), *Writing Code the Swift
    Way – Design Patterns and Techniques*. We can determine if the current object
    is a file using the `fileAttributes` property. All of that lets us write a `loadPhotos`
    method like this:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要让图片存储库遍历文档目录中的文件，并对每个文件调用此初始化器。要遍历一个目录，`NSFileManager` 有一个 `enumeratorAtFilePath:`
    方法。它返回一个具有 `nextObject` 方法的枚举器实例。每次调用它时，它都会返回原始目录内的下一个文件或目录。请注意，这将遍历它找到的每个子目录的所有子项。这是我们在[第9章](ch09.html
    "第9章。以Swift方式编写代码 – 设计模式和技术")中看到的迭代器模式的一个很好的例子，*以Swift方式编写代码 – 设计模式和技术*。我们可以使用
    `fileAttributes` 属性来确定当前对象是否是文件。所有这些都让我们能够编写一个像这样的 `loadPhotos` 方法：
- en: '[PRE37]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first thing we do in this method is remove all existing photos. This is
    to protect against calling this method when there are already photos in it. Next,
    we create an enumerator from our save directory. Then, we use a while loop to
    continue to get each next object until there are none left. Inside the loop we
    check if the object we just got is actually a file. If it is and we create the
    photo successfully with the full path, we add the photo to our photos array.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先删除所有现有的照片。这是为了防止在照片已经存在时调用此方法。接下来，我们从保存目录创建一个枚举器。然后，我们使用一个 while
    循环来继续获取每个下一个对象，直到没有剩余的对象。在循环内部，我们检查我们刚刚获取的对象是否实际上是一个文件。如果是，并且我们使用完整路径成功创建了照片，我们就将照片添加到我们的照片数组中。
- en: 'Finally, all we have to do is make sure this method is called at the appropriate
    time to load the photos. A great time to do this, considering we want to be able
    to show errors to the user, is right before the view will be displayed. As the
    view controllers have a method for right after the view has been loaded, there
    is also a method called `viewWillAppear:` that is called every time the view is
    about to appear. In here we can load the photos and also display any errors to
    the user with our `displayError:withTitle:` method:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需确保在适当的时间调用此方法来加载照片。考虑到我们希望能够在显示错误给用户之前完成这一操作，这是一个很好的时机。由于视图控制器有一个在视图加载后立即调用的方法，因此还有一个名为
    `viewWillAppear:` 的方法，每次视图即将出现时都会被调用。在这里，我们可以加载照片，并使用我们的 `displayError:withTitle:`
    方法向用户显示任何错误：
- en: '[PRE38]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Now if you run the app, save some photos, and quit it, your previously saved
    photos will be there when you run it again. We have completed the saving photos
    functionality!
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果你运行应用程序，保存一些照片，然后退出，当你再次运行它时，之前保存的照片将仍然存在。我们已经完成了保存照片的功能！
- en: Summary
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This app is far from being something that we could put on the store, but it
    gives you a good first dive into what it is like to build an iOS app. We have
    covered how to conceptualize an app and then how to go about making it a reality.
    We know how to configure an interface in a storyboard, how to run it, and we got
    into the practical details of saving photos both temporarily and permanently to
    disk and displaying those in our own custom interface. We even got some practice
    writing high quality code by ensuring our code sticks with the model-view-controller
    design pattern as best we can.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个应用程序远远不是我们可以上架的那种，但它让你对构建iOS应用程序的感觉有了很好的初步了解。我们已经介绍了如何构思一个应用程序，然后如何将其变为现实。我们知道如何在故事板中配置界面，如何运行它，我们还深入探讨了将照片临时和永久保存到磁盘以及在我们自己的自定义界面中显示这些照片的实用细节。我们甚至通过确保我们的代码尽可能遵循模型-视图-控制器设计模式来练习编写高质量代码。
- en: Even though we have covered a lot, this clearly isn't enough information to
    immediately write any other iOS app. The key is to get an insight into what the
    app development process looks like and to start to feel more comfortable in an
    iOS app project. All developers spend lots of time searching the documentation
    and the Internet for how to do specific things on any given platform. The key
    is being able to take solutions you find on the Internet or in books, determine
    the best one for your use case, and integrate them effectively into your own code.
    Over time, you will be able to do more and more on your own without looking it
    up, but with ever-changing frameworks and platforms, that will always be a part
    of your development cycle.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们已经覆盖了很多内容，但这显然不足以立即编写任何其他iOS应用程序。关键是要了解应用程序开发过程是什么样的，并开始在一个iOS应用程序项目中感到更加自在。所有开发者都会花费大量时间在文档和互联网上搜索如何在任何特定平台上完成特定任务。关键在于能够从互联网或书籍中找到解决方案，确定最适合你用例的最佳方案，并将它们有效地集成到自己的代码中。随着时间的推移，你将能够独立完成更多任务，而无需查阅资料，但随着框架和平台的不断变化，这始终将是你的开发周期的一部分。
- en: With that in mind, I now challenge you to complete the feature list we conceptualized.
    Figure out how to delete a picture and add whatever other features, usability
    tweaks, or visual tweaks you want. As I said before, app development is a completely
    new world to explore. There are so many things that you can tweak, even with this
    simple app; all of it will help you learn tons.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，我现在挑战你完成我们构思的功能列表。找出如何删除图片，并添加你想要的任何其他功能、可用性调整或视觉调整。正如我之前所说，应用程序开发是一个全新的世界去探索。即使在这个简单的应用程序中，你也可以调整很多东西；所有这些都将帮助你学习很多。
- en: Coming up in our final chapter, we will look at where you can go from here to
    become the best Swift developer you possibly can.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的最后一章中，我们将探讨你可以从这里开始，成为你所能成为的最佳Swift开发者。
