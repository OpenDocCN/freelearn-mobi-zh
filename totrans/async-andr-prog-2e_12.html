<html><head></head><body><div class="chapter" title="Chapter&#xA0;12.&#xA0;Asynchronous Programing with RxJava"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"/>Chapter 12. Asynchronous Programing with RxJava</h1></div></div></div><p>In previous chapters, we have been using Android-based constructs such as <code class="literal">Loader</code> and <code class="literal">AsyncTask</code> to offload work from the main thread to low priority background threads.</p><p>Although these straightforward constructs are able to deliver results that require intensive IO operations or network data, they don't provide out-of-the-box solutions for exception handling, task composition, and asynchronous event processing.</p><p>Beyond that, the popular <code class="literal">AsyncTask</code> construct is not able to deal with <code class="literal">Activity</code> or fragment configuration changes or cache results between configuration changes. Therefore, to cope with these kinds of problem, most of time the developer ends up creating a lot of extra code and complicated flows to handle the traits of these simple constructs.</p><p>To simplify the development of composable asynchronous work, we will introduce you to <code class="literal">RxJava</code>, a functional framework that allow us to observe, transform, filter, and react to streams of events (click, touch, network, I/O events, and so on) in order to compose complex lines of execution that are able to react to errors and chain asynchronous computations.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Introduction to RxJava</li><li class="listitem" style="list-style-type: disc">Creating Observables</li><li class="listitem" style="list-style-type: disc">Transforming Observables</li><li class="listitem" style="list-style-type: disc">Understanding Schedulers</li><li class="listitem" style="list-style-type: disc">Performing Asynchronous IO with Schedulers</li><li class="listitem" style="list-style-type: disc">Composing Tasks with RxJava</li><li class="listitem" style="list-style-type: disc">Observing UI events with RxJava</li><li class="listitem" style="list-style-type: disc">Combining Tasks with RxJava</li><li class="listitem" style="list-style-type: disc">Working with Subjects</li></ul></div><div class="section" title="Introduction to RxJava"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec92"/>Introduction to RxJava</h1></div></div></div><p>
<code class="literal">RxJava</code> is an <a id="id648" class="indexterm"/>implementation of Reactive Extensions (<code class="literal">ReactiveX</code>) on JVM, which was developed by Netflix and is used to compose asynchronous event processing that reacts to an observable source of events.</p><p>The framework extends the <code class="literal">Observer</code> pattern by allowing us to create a stream of events that could be intercepted by operator (input/output) functions that modify the original stream of events and deliver the result or an error to a final <code class="literal">Observer</code>. This framework abstracts away concerns about things such as low-level threading, synchronization, thread safety, concurrent data structures, and non-blocking I/O.</p><p>There are three main basic building blocks that interact with each other in <code class="literal">RxJava</code> processing, the <code class="literal">Observable</code>, the <code class="literal">Observer</code>, and the <code class="literal">Subscriber</code>.</p><p>An <code class="literal">Observable</code> is an entity that emits a sequence of events (zero or more events) of the generic type T (such as String or any Java type) at any point in time, or emits a <code class="literal">Throwable</code> when a failure occurs during the event processing. Beyond that, it provides methods to subscribe to its event stream and manage <code class="literal">Observer</code> subscriptions.</p><p>A <code class="literal">Single</code> is a special kind of Observable that can only emit either a single success event value or an error event.</p><p>An <code class="literal">Observer</code>, after registering as a subscriber, consumes the events of type <code class="literal">T</code> generated by the <code class="literal">Observable&lt;T&gt;</code>. An Observer must implement <code class="literal">Observer&lt;T&gt;</code>:</p><div class="informalexample"><pre class="programlisting">public interface Observer&lt;T&gt; {

    void <span class="strong"><strong>onCompleted</strong></span>();
    void <span class="strong"><strong>onError</strong></span>(Throwable e);
    void <span class="strong"><strong>onNext</strong></span>(T t);
}</pre></div><p>Any <code class="literal">Observer</code> will receive a callback to <code class="literal">onNext</code> whenever a new event is emitted by the Observable it's subscribed to until it receives <code class="literal">onCompleted</code> or <code class="literal">onError</code> to close the event stream.</p><p>A <code class="literal">Subscriber</code> is a helper abstract class you can use as your Observer's base if you want subscription support. The <code class="literal">Subscriber</code> class provides methods to cancel the Observable subscription:</p><div class="informalexample"><pre class="programlisting">abstract class <span class="strong"><strong>Subscriber</strong></span>&lt;T&gt;
   implements <span class="strong"><strong>Observer</strong></span>&lt;T&gt;, <span class="strong"><strong>Subscription</strong></span>


public interface <span class="strong"><strong>Subscription</strong></span> {

   void <span class="strong"><strong>unsubscribe</strong></span>();
   boolean <span class="strong"><strong>isUnsubscribed</strong></span>();
}</pre></div><p>
<code class="literal">unsubscribe</code> is the <a id="id649" class="indexterm"/>function used to cancel the <code class="literal">Observer</code> subscription. Therefore, once the <code class="literal">Observer</code> subscription is terminated, the Subscriber will no longer receive the events generated by the Observable.</p><p>Here is a simple graph displaying the common interactions between an <code class="literal">Observable</code> and a <code class="literal">Subscriber</code>:</p><div class="mediaobject"><img src="graphics/Image_B05062_12_01.jpg" alt="Introduction to RxJava"/></div><p>The <code class="literal">onNext(T)</code> Observer's callback is invoked when a new item is emitted by the Observable.</p><p>The <code class="literal">onError(Throwable)</code> Observer's callback is invoked to notify that an error condition was found and the stream will be terminated.</p><p>The <code class="literal">onCompleted()</code> Observer's callback is invoked to indicate that the stream has completed successfully <a id="id650" class="indexterm"/>and all the events were delivered with success.</p><div class="section" title="Cold versus Hot Observable"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec76"/>Cold versus Hot Observable</h2></div></div></div><p>An Observable can be classified as hot or cold based on the time that it starts emitting events. A cold <a id="id651" class="indexterm"/>Observable only starts emitting events to the Observers when an Observer subscribes to it. In this case, it is expected that the Observer will receive the stream from the beginning.</p><p>A hot Observable will begin emitting events as soon as it gets created, so the Observer will only receive the events emitted after the subscription is created. The events emitted before the subscription will not be received by the Observer.</p></div></div></div>
<div class="section" title="RxJava setup"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec93"/>RxJava setup</h1></div></div></div><p>Before we move <a id="id652" class="indexterm"/>further, let's add the required libraries to your project. If you're using Android Studio, just add the following dependencies to the module <code class="literal">build.gradle</code> script:</p><div class="informalexample"><pre class="programlisting">dependencies {
    …
    compile 'io.reactivex:rxandroid:1.1.0'
    compile 'io.reactivex:rxjava:1.1.0'
}</pre></div><p>
<code class="literal">rxjava</code> is a library that implements the Reactive Extensions (<a class="ulink" href="http://reactivex.io/">http://reactivex.io/</a>) on Java , and <code class="literal">rxandroid</code> is a library that adds classes to help write reactive components with <code class="literal">RxJava</code> in Android applications.</p></div>
<div class="section" title="Creating Observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec94"/>Creating Observables</h1></div></div></div><p>To create an <code class="literal">Observable</code>, we can either create an <code class="literal">Observable</code> from scratch using the <code class="literal">create</code> function and calling <a id="id653" class="indexterm"/>Observer methods explicitly, or we can use built-in <code class="literal">Observable</code> creation methods that convert common data types to <code class="literal">Observable</code> streams.</p><p>Let's start with a simple example and create an observable that emits a <code class="literal">String</code> using the creating <code class="literal">Observable.from</code> operator:</p><div class="informalexample"><pre class="programlisting">Observable&lt;String&gt; myObservable =
  Observable.from(Arrays.asList("Hello from RxJava",
                                "Welcome...",
                                "Goodbye"));</pre></div><p>The <code class="literal">Observable.from</code> static function creates <code class="literal">Observable</code> from an array that will synchronously emit <code class="literal">String</code> items to any Observer. The Observable created will be a cold Observable and will only start emitting events after an Observer subscribes to it.</p><p>Now, let's create a <code class="literal">Subscriber</code> that consumes the data and prints each <code class="literal">String</code> to the Android Log until <a id="id654" class="indexterm"/><code class="literal">Observable</code> invokes the <code class="literal">onComplete</code> callback:</p><div class="informalexample"><pre class="programlisting">Subscriber&lt;String&gt; mySubscriber = new Subscriber&lt;String&gt;() {

  @Override
  public void onCompleted() {
    Log.i(TAG, "Rx Java events completed");
  }

  @Override
  public void onError(Throwable e) {
    Log.e(TAG, "Error found processing stream", e);
  }

  @Override
  public void onNext(String s) {
    Log.i(TAG, "New event -" + s);
  }
};</pre></div><p>Next, with <code class="literal">Observable</code> and the subscriber class just defined, once we subscribe our <code class="literal">Subscriber</code> class on <code class="literal">Observable</code>, the <code class="literal">onNext()</code> function will be called three times passing each <code class="literal">String</code> in the Array, defined previously.</p><p>Subsequently, after all the <code class="literal">Strings</code> are consumed by the <code class="literal">Subscriber</code>, the <code class="literal">onCompleted</code> function is called to close the stream:</p><div class="informalexample"><pre class="programlisting">myObservable.subscribe(mySubscriber);</pre></div><p>The <code class="literal">Observable</code> instance is responsible for managing all subscriptions, notifying all its <code class="literal">Subscribers</code>, and it won't begin emitting items until we subscribe to them.</p><p>Apart from using <code class="literal">Observable.from</code> or another creation operator, we can create Observables by calling the <code class="literal">create</code> method and implementing <code class="literal">Observable.OnSubscribe&lt;T&gt;</code> that explicitly calls <code class="literal">onNext</code>, <code class="literal">onError</code>, and <code class="literal">onCompleted</code>.</p><p>Let's create our own <a id="id655" class="indexterm"/><code class="literal">Observable</code> that emits integer numbers using the <code class="literal">create</code> function:</p><div class="informalexample"><pre class="programlisting">Observable&lt;Integer&gt; myObservable = Observable.create(
   new Observable.OnSubscribe&lt;Integer&gt;() {
      @Override
      public void call(Subscriber&lt;? super Integer&gt; sub) {
          // Emitting Numbers
<span class="strong"><strong>          sub.onNext(10);</strong></span>
<span class="strong"><strong>          sub.onNext(3);</strong></span>
<span class="strong"><strong>          sub.onNext(9);</strong></span>
          // Stream completed with success
<span class="strong"><strong>          sub.onCompleted();</strong></span>
      }
  }
);</pre></div><p>Remember that a well-behaved <code class="literal">Observable</code> must attempt to call either the observer's <code class="literal">onCompleted</code> or <code class="literal">onError</code> exactly once after emitting all the items by calling the subscriber's <code class="literal">onNext</code> function.</p><p>Notice that the previous Observable is also classified as a cold Observable because it will only start emitting when a Subscriber entity subscribes to it.</p><p>Alternatively, we can subscribe to <code class="literal">Observable</code> using <code class="literal">Action</code> functions to handle the items dispatched in different separated functions. All that you need to do is pass an <code class="literal">Action1&lt;T&gt;</code> function for event processing, an <code class="literal">Action1&lt;Throwable&gt;</code> for the error emission, and <code class="literal">Action0</code> to receive the stream completion notification.</p><p>Let's write the required action functions that react to our <code class="literal">Observable&lt;String&gt;</code> emissions:</p><div class="informalexample"><pre class="programlisting">Action1&lt;Integer&gt; onNextAction = new Action1&lt;Integer&gt;() {
  @Override
  public void call(Integer s) { Log.i(TAG, "New number :" + s); }
};
Action1&lt;Throwable&gt; onError = new Action1&lt;Throwable&gt;() {
  @Override
  public void call(Throwable t) {
     Log.e(TAG, "Error: " + t.getMessage(), t);
  }
};
Action0 onComplete = new Action0() {
  @Override
  public void call() { Log.i(TAG, "Rx number stream completed")}
};

myObservable.<span class="strong"><strong>subscribe</strong></span>(onNextAction, onError, onComplete);</pre></div><p>Beyond the <code class="literal">from</code> operator and the <code class="literal">create</code> operator functions there are other simple <code class="literal">Observable</code> functions that <a id="id656" class="indexterm"/>can be used to build <code class="literal">Observable</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.just</code>: Creates an <code class="literal">Observable</code> from a short number of objects (Max 10 Objects):<div class="informalexample"><pre class="programlisting">Observable&lt;Integer&gt;.just(1,2,3)</pre></div></li><li class="listitem" style="list-style-type: disc"><code class="literal">Observable.range</code>: Emits a range of numbers:<div class="informalexample"><pre class="programlisting">Observable.range(1,10);</pre></div></li></ul></div></div>
<div class="section" title="Transforming Observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec95"/>Transforming Observables</h1></div></div></div><p>Apart from the ability to <a id="id657" class="indexterm"/>widely implement the <code class="literal">Observable-Subscribe</code> software pattern, the <code class="literal">RxJava</code> framework allows us to transform, filter, convert, aggregate, manipulate, and work with the stream of items emitted by <code class="literal">Observable</code> by using <code class="literal">Observable</code> operators. These entities are able to completely transform the event stream before the events are delivered to the final <code class="literal">Subscriber</code>.</p><p>
<code class="literal">RxJava</code> comes with a handy collection of operators that are able to transform the event's content and control the time that the event is delivered.</p><p>Let's describe the most common operators available on <code class="literal">RxJava</code>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">map</code>: Applies a function to each item emitted and emits the result of the function as a new item.</li><li class="listitem" style="list-style-type: disc"><code class="literal">flatMap</code>: Applies a function to each item emitted by the source <code class="literal">Observable</code> where the function returns an <code class="literal">Observable</code> that could emit a different number of items or a different type of event.</li><li class="listitem" style="list-style-type: disc"><code class="literal">filter</code>: A transformation operator that uses a function that verifies if each item emitted by the source <code class="literal">Observable</code> satisfies a condition. If the condition passes the item, it is forwarded to the following <code class="literal">Subscriber</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">first</code>: Emits only the first item emitted by the source <code class="literal">Observable</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">count</code>: Emits the number of items received from the original <code class="literal">Observable</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">zip</code>: Combines the emissions of two <code class="literal">Observables</code> using a function that receives the <code class="literal">N</code> item of each original <code class="literal">Observable</code> as an argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">contains</code>: Emits a <code class="literal">Boolean</code> event that indicates whether the source <code class="literal">Observable</code> has a specified <code class="literal">Object</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">merge</code>: Merges the events of multiple <code class="literal">Observers</code> into one event stream.</li><li class="listitem" style="list-style-type: disc"><code class="literal">delay</code>: Delays the emission of an item by a specified amount of time.</li></ul></div><p>For a more complete, detailed, and up-to-date list of operators supported by RxJava, check the <code class="literal">RxJava</code> Wiki on GitHub (<a class="ulink" href="https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators">https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators</a>).</p><p>The <code class="literal">RxJava</code> operators <a id="id658" class="indexterm"/>generally process an <code class="literal">Observable</code> and return an <code class="literal">Observable</code>. This design feature allows us to chain the operators and create a composed sequence of operators that transform the event stream. The last operator is responsible for delivering the items to the <code class="literal">Subscriber</code>, or deliver an error when something goes wrong.</p><p>Now, let's create our first operator example that transforms a multiline text emitted by the source Observable and delivers a new deliver an Integer with the number of lines that contain the word <code class="literal">RxJava</code>:</p><div class="informalexample"><pre class="programlisting">String content = "This is an example \n " +
                 "Looking for lines with the word RxJava\n" +
                 "We are finished.";
Observable
  .just(content)
  .<span class="strong"><strong>flatMap</strong></span>(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call(final String content) {
      return Observable.from(content.split("\n"));
    }})
  .<span class="strong"><strong>filter</strong></span>(new Func1&lt;String, Boolean&gt;() {
       @Override
    public Boolean call(final String line) {
      return line.contains("RxJava");
    }
  })
  <span class="strong"><strong>.count</strong></span>()
  <span class="strong"><strong>.subscribe</strong></span>(new Subscriber&lt;Integer&gt;() {
    ...
    @Override
    public void onNext(Integer s) {
      Log.i(TAG, "Number of Lines " + s);
    }
  });</pre></div><p>To start, we create an <code class="literal">Observable</code> from the original using the <code class="literal">Observable.just</code> creation operator passing the text source as the unique object.</p><p>Next, to split the original text in to lines, we use the <code class="literal">flatMap</code> operator, which receives the original text emitted by the first <code class="literal">Observable</code> and returns a new <code class="literal">Observable</code> created from the sliced lines array.</p><p>The new <code class="literal">Observable</code> coming from the <code class="literal">flatMap</code> operator will emit a single <code class="literal">String</code> for each line available on the original content, therefore, in order to count the lines with the word <code class="literal">RxJava</code>, we will discard the lines that don't have the word using the filter operator.</p><p>To finish, we will count the <a id="id659" class="indexterm"/>number of events emitted and publish the results to a Subscriber that is expecting an integer as a result.</p><p>Here is a graphical presentation of the previous functional pipeline:</p><div class="mediaobject"><img src="graphics/Image_B05062_12_02.jpg" alt="Transforming Observables"/></div><p>Yes. The extensive set of transformation operators allows us to create a complex functional processing chain <a id="id660" class="indexterm"/>that is able to transform the data on the way and deliver results to any <code class="literal">Subscriber</code> object in a readable and functional way.</p></div>
<div class="section" title="Understanding Schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec96"/>Understanding Schedulers</h1></div></div></div><p>There is an incorrect <a id="id661" class="indexterm"/>misconception and belief that <code class="literal">RxJava</code> processing is multithreaded by default. An <code class="literal">Observable</code> and the list of transformations applied by the specified operators occur on the same thread that the subscription is made.</p><p>Hence, on Android, if the subscription is carried out on the main thread, the operators chain processing will run on the main thread, blocking the UI until the work is done.</p><p>While this behavior might work for lightweight processing tasks, when the operation requires IO interaction or CPU-intensive computing, the task execution might block the main <code class="literal">Thread</code> and crash the application with an ANR.</p><p>To simplify the asynchronous and concurrent executions, the <code class="literal">RxJava</code> framework allows us to define a <code class="literal">Scheduler</code> entity that defines the thread where a unit of work is executed.</p><p>The <code class="literal">subscribeOn(Scheduler)</code> operator allows us to set the Scheduler that defines the thread on which the subscription has been made and the Observable will start to operate.</p><p>When no Scheduler is specified, the Observable and operations will run on the thread that invoked the <code class="literal">subscribe</code> function.</p><p>On Android, a <code class="literal">subscribe</code> function is typically invoked from an Android Activity or Fragment that runs on the main Thread, then if any operation takes a substantial amount of time to finish it will block the UI Thread and degrade the UI responsiveness.</p><p>By controlling the thread where the subscription is made, we are controlling the thread where the Observable and its operators are going to execute and even the thread where the subscriber will receive the callbacks.</p><p>The <code class="literal">observeOn(Scheduler)</code> allows us to set the Scheduler that defines the thread in which the Observer callbacks (<code class="literal">onNext</code>, <code class="literal">onError</code>, <code class="literal">onCompleted</code>) are invoked.</p><p>During the Observable and operator chain, we can use <code class="literal">ObserveOn</code> several times to change the thread where the computation will run.</p><p>To simplify <code class="literal">Scheduler</code> use, the <code class="literal">RxJava</code> and the <code class="literal">RxAndroid</code> library compiled a list of predefined <code class="literal">Schedulers</code> ready to be used to create multithreaded asynchronous chains:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Schedulers.immediate()</code>: Default <code class="literal">Scheduler</code> that returns a <code class="literal">Scheduler</code> that executes the work immediately in the current thread.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Schedulers.trampoline()</code>: Returns a <code class="literal">Scheduler</code> that queues work in the current thread to be executed after the current work completes.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Schedulers.newThread()</code>: Returns a <code class="literal">Scheduler</code>, spawns a new thread, and executes the work on the new <code class="literal">Thread</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Schedulers.computation()</code>: Returns a <code class="literal">Scheduler</code> intended for computational intensive work. This can be used for event loops, processing callbacks, and other computational work. Do not perform blocking IO work on this <code class="literal">Scheduler</code>. This <a id="id662" class="indexterm"/>Scheduler uses a fixed thread pool size where the size is dependent on the CPUs to optimize CPU usage and minimize CPU switching.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Schedulers.io()</code>: Creates and returns a <code class="literal">Scheduler</code> that executes the work of a cached pool of threads that grows and shrinks as needed, reusing already created threads that are idle to execute the require work. This <code class="literal">Scheduler</code> is intended for asynchronously performing blocking IO tasks, such as network or file system read and write.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Scheduler.from(Executor)</code>: Creates a Scheduler that will execute the unit of work on the <code class="literal">java.util.concurrent.Executor</code> passed as argument.</li><li class="listitem" style="list-style-type: disc"><code class="literal">AndroidSchedulers.mainThread()</code>: Creates a <code class="literal">Scheduler</code> that executes the required work on the Android application main thread. This Android <code class="literal">Scheduler</code>, provided by the <code class="literal">RxAndroid</code> library, is based on the <code class="literal">HandlerThread</code> that runs the unit of work serially.</li><li class="listitem" style="list-style-type: disc"><code class="literal">HandlerScheduler.from(Handler)</code>: Creates a Scheduler that executes work on a specified <code class="literal">Handler</code>. The <code class="literal">AndroidSchedulers.mainThread()</code> is of specialization of this <code class="literal">Scheduler</code> that runs on a <code class="literal">Handler</code> attached to the Android UI thread.</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note58"/>Note</h3><p>By default, <code class="literal">Rxjava</code> uses <code class="literal">Schedulers.immediate()</code>, which subscribes to the Observer on the current thread and delivers the events in the current thread.</p></div></div><p>RxJava allows us to define our own Scheduler, but for the scope of this book, we will only use the built-in Schedulers to cover our concurrency needs.</p></div>
<div class="section" title="Performing IO operations with Schedulers"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec97"/>Performing IO operations with Schedulers</h1></div></div></div><p>In the next <a id="id663" class="indexterm"/>example, we will use <code class="literal">Schedulers</code> to <a id="id664" class="indexterm"/>mirror the behavior of <code class="literal">AsyncTask</code> and retrieve text from the network on the background thread. Subsequently, the result will be published to a <code class="literal">Subscriber</code> that runs on the main <code class="literal">Thread</code>.</p><p>First of all, we will create a function that creates an <code class="literal">Observable</code> that emits the <code class="literal">String</code> retrieved from the network:</p><div class="informalexample"><pre class="programlisting">Observable&lt;String&gt; getTextFromNetwork(final String url) {

  return Observable.create(
    new Observable.OnSubscribe&lt;String&gt;() {
      @Override
      public void call(Subscriber&lt;? super String&gt; sub) {
        try {
          String text = downloadText(url);
<span class="strong"><strong>          sub.onNext(text);</strong></span>
<span class="strong"><strong>          sub.onCompleted();</strong></span>

        } catch (Throwable t) {
<span class="strong"><strong>          sub.onError(t);</strong></span>
        }
      }
    }
  );
}</pre></div><p>Before we specify the <code class="literal">Scheduler</code> used to run our asynchronous call, we need to state two assumptions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Since the code that runs on <code class="literal">Observable</code> performs a network operation we must run Observable on the background thread</li><li class="listitem" style="list-style-type: disc">To publish the result and update the UI, we must execute our Subscriber callbacks on the main <code class="literal">Thread</code></li></ul></div><p>Now, let's build up the asynchronous <code class="literal">RxJava</code> execution that retrieves the text and update the UI following the previous assumptions and using the <code class="literal">Scheduler</code> entities described earlier:</p><div class="informalexample"><pre class="programlisting">class MySubscriber extends Subscriber&lt;String&gt; {

  @Override
  public void onCompleted() {}

  @Override
  public void onError(Throwable e) {
     // Shows a Toast on Error
     Toast.makeText(RxSchedulerActivity.this,
                    e.getMessage(),
                    Toast.LENGTH_LONG).show();
    Log.e(TAG, "Error retrieving ", e);  
  }

  @Override
  public void onNext(String text) {
    // Updates the UI on Success
    EditText textFrame = (EditText)findViewById(R.id.text);
    textFrame.setText(text);
  }
};   

   ...

getTextFromNetwork("http://demo1472539.mockable.io/mytext")
  <span class="strong"><strong>.subscribeOn</strong></span>(Schedulers.io())
  <span class="strong"><strong>.observeOn</strong></span>(AndroidSchedulers.mainThread())
  <span class="strong"><strong>.subscribe</strong></span>(new MySubscriber())
);</pre></div><p>
<code class="literal">subscribeOn(Schedulers.io())</code> will make the <code class="literal">Observable</code> created by the <code class="literal">getTextFromNetwork</code> function run on the <code class="literal">Scheduler.io</code> thread pool intended for blocking IO operations.</p><p>Once we call the <a id="id665" class="indexterm"/>subscribe function, <a id="id666" class="indexterm"/><code class="literal">downloadText</code> will be queued to run on a thread managed by the <code class="literal">Scheduler</code> created by <code class="literal">Schedulers.io()</code>, emitting the results as a <code class="literal">String</code> in the <code class="literal">onNext()</code> function.</p><p>The <code class="literal">observeOn(AndroidSchedulers.mainThread())</code> ensures that the Subscriber callbacks <code class="literal">onNext</code>, <code class="literal">onCompleted</code>, and <code class="literal">onError</code> will run on the Android main Thread. Therefore, if the network operation completes with success, <code class="literal">OnNext</code> is invoked updating EditText with the result obtained.</p><p>If any exception is <a id="id667" class="indexterm"/>thrown during the network execution, a <code class="literal">Throwable</code> object is delivered to the <code class="literal">Subscriber.onError</code> callback, which executes <a id="id668" class="indexterm"/>on the UI Thread, and a <code class="literal">Toast</code> that shows an error is displayed on the UI.</p><p>This example shows how simple and concise an asynchronous <code class="literal">call</code> can be on <code class="literal">RxJava</code>. Moreover, it abstracts you from the thread management as <code class="literal">AsyncTask</code> does and provides you exception handling facilities to deal with exceptional errors.</p></div>
<div class="section" title="Canceling subscriptions"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec98"/>Canceling subscriptions</h1></div></div></div><p>When an Activity <a id="id669" class="indexterm"/>or a Fragment gets destroyed, our chain could continue to run in the background, preventing the Activity from being disposed if the chain has references to the Activity or Fragment. When you no longer need the result of the chain, it could make sense to cancel the subscription and terminate the chain execution.</p><p>When we call the <code class="literal">Observable.subscribe()</code> function, it returns a Subscription object that can be used to terminate the chain immediately:</p><div class="informalexample"><pre class="programlisting">Subscription subscription = getTextFromNetwork(
               "http://demo1472539.mockable.io/mytet")
               ...
               .subscribe(new MySubscriber());</pre></div><p>Again, the most appropriate Activity lifecycle method for this is <code class="literal">onPause</code>, which is guaranteed to be called before the Activity finishes:</p><div class="informalexample"><pre class="programlisting">protected void onPause() {
  super.onPause();
  if ((subscription != null) &amp;&amp; (isFinishing()))
    subscription.unsubscribe();
}</pre></div></div>
<div class="section" title="Composing Observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec99"/>Composing Observables</h1></div></div></div><p>As we explained <a id="id670" class="indexterm"/>earlier, an <code class="literal">Observable</code> interface is defined in a way that allows us to chain and combine different <code class="literal">Observables</code> to create complex tasks in a functional and declarative way.</p><p>Starting from our previous work, in our next example, we will make use of the <code class="literal">RxJava</code> composing feature and execute a second network call that depends on the previous <code class="literal">Observable</code> that will translate the text downloaded using a web service before we emit the translated text to the <code class="literal">Subscriber</code>.</p><p>To execute the translation on the network on a logically separate unit, we will create a new <code class="literal">Observable</code> that receives the text to translate, executes the task on the network, and emits the translated text as a String to the following <code class="literal">Observable</code>:</p><div class="informalexample"><pre class="programlisting">Observable&lt;String&gt; translateOnNetwork(final String url,
                                      final String toTranslate) {
  return Observable.create(
    new Observable.OnSubscribe&lt;String&gt;() {
      @Override
      public void call(Subscriber&lt;? super String&gt; ts){
        try {
          String text = translateText(
            "http://demo1472539.mockable.io/translate",
             toTranslate);

<span class="strong"><strong>          sub.onNext(text);</strong></span>
<span class="strong"><strong>          sub.onCompleted();</strong></span>
        } catch (Throwable t) {
<span class="strong"><strong>          sub.onError(t);</strong></span>
        }
      }
    }
  );
}</pre></div><p>Next, we are ready to chain the network executions and display the results on the UI using the same <code class="literal">Subscriber</code> used previously:</p><div class="informalexample"><pre class="programlisting">getTextFromNetwork(RETRIEVE_TEXT_URL)
  <span class="strong"><strong>.flatMap</strong></span>(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call(String toTranslate) {
      return translateOnNetwork(TRANSLATE_URL, toTranslate);
    }
  })
  <span class="strong"><strong>.subscribeOn</strong></span>(Schedulers.io())
  <span class="strong"><strong>.observeOn</strong></span>(AndroidSchedulers.mainThread())
  <span class="strong"><strong>.subscribe</strong></span>(new MySubscriber());</pre></div><p>The network IO operation defined on the <code class="literal">translateOnNetwork</code>, which depends on <code class="literal">getTextFromNetwork</code>, will only run if the previous operation finished with success, and takes the result from <code class="literal">getTextFromNetwork</code> as an argument.</p><p>After <code class="literal">translateOnNetwork Observable</code> receives the text content from the previous network operation, it will use it <a id="id671" class="indexterm"/>as input for its operation and will perform the translation of the previous content on the network, invoking the function <code class="literal">translateText(url, content)</code>.</p><p>Given that <code class="literal">translateText()</code> finishes with success, the translated content is delivered to the next Observable. Since the next Observable is the Subscriber, the result is delivered transparently on the main Thread to update the UI.</p><p>Besides that, since we override the <code class="literal">Subscriber</code> is <code class="literal">onError</code> function, if something goes wrong during the execution of either network requests, the error is propagated to our callback to be handled properly. Hence, with a few lines of code, we are able to inform the user that an asynchronous task has failed and we were not able to deliver the expected data to them.</p><p>Great, with a few lines of code we created a complex task that performs a chain of asynchronous network operations in the background, delivering the results on the main thread, or delivering an error when something goes wrong.</p></div>
<div class="section" title="Monitoring the event stream"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec100"/>Monitoring the event stream</h1></div></div></div><p>Although so far we <a id="id672" class="indexterm"/>have been using the <code class="literal">Observable</code> operators to manipulate stream events, there are operators that allow us to monitor the events without changing them. These operators, known sometimes as utility operators, are able to react to the events or errors emitted on the <code class="literal">Observable</code> chain created between the source <code class="literal">Observable</code> and the final <code class="literal">Subscriber</code> without creating any side effects.</p><p>Let's enumerate them and explain the more common utility operators used to observe the event stream:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">doOnSubscribe(Action0)</code>: Registers an <code class="literal">Action0</code> function to get called when a <code class="literal">Subscriber</code> subscribes to the <code class="literal">Observable</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">doOnUnsubscribe(Action0)</code>: Registers an <code class="literal">Action0</code> function to get called when a <code class="literal">Subscriber</code> unsubscribes from the <code class="literal">Observable</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">doOnNext(Action1)</code>: Registers an <code class="literal">Action1</code> to be called when a new event is emitted from the <a id="id673" class="indexterm"/>source <code class="literal">Observable</code>. The Event <code class="literal">&lt;T&gt;</code> object is also passed as an argument to the <code class="literal">Action1</code> function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">doOnCompleted(Action0)</code>: Registers an <code class="literal">Action0</code> function to be called when the source <code class="literal">Observable</code> emits the <code class="literal">onComplete</code> event.</li><li class="listitem" style="list-style-type: disc"><code class="literal">doOnError(Action1)</code>: Registers an <code class="literal">Action1</code> function to be called when an error is emitted from the source <code class="literal">Observable</code>. The <code class="literal">Throwable</code> emitted on the <code class="literal">OnError</code> is also passed to the <code class="literal">Action1.call</code> function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">doOnTerminate(Action0)</code>: Registers an <code class="literal">Action0</code> function to be invoked when an error or <code class="literal">onComplete</code> is emitted by the source <code class="literal">Observable</code>. This callback function also means that the previous <code class="literal">Observable</code> will emit no more items.</li></ul></div><p>These multipurpose operators will allow us to observe and debug complex chains that usually involve several transformations, create progress dialogs to show progress, cache results, and even generate processing analytics.</p><p>In our next example, we will make use of these operators to log the progress of our previous multi network operation in the Android Log, and to present a progress dialog on screen as long as the operation is progressing:</p><div class="informalexample"><pre class="programlisting">Observable.just(RETRIEVE_TEXT_URL)
  <span class="strong"><strong>.doOnNext</strong></span>(new Action1&lt;String&gt;() { // Runing on the main Thread
    @Override
    public void call(String url) {
      progress = ProgressDialog.show(RxSchedulerActivity.this,
                 "Loading",
                 "Performing async operation", true);
      Log.i(TAG, "Network IO Operation will start "+ tmark());
    }
  })
  <span class="strong"><strong>.observeOn</strong></span>(Schedulers.io()) // Running on a background Thread
  <span class="strong"><strong>.flatMap</strong></span>(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call(String url) {
      return getTextFromNetwork(url);
    }
  })
  <span class="strong"><strong>.doOnNext</strong></span>(new Action1&lt;String&gt;() {
    @Override
    public void call(String text) {
      Log.i(TAG, "Text retrieved w/ success " + tMark());
      Log.i(TAG, "Translating the text " + tMark());
    }
  })
  <span class="strong"><strong>.flatMap</strong></span>(new Func1&lt;String, Observable&lt;String&gt;&gt;() {
    @Override
    public Observable&lt;String&gt; call(String toTranslate) {
      return translateOnNetwork(TRANSLATE_URL, toTranslate);
    }
  })
  <span class="strong"><strong>.doOnNext</strong></span>(new Action1&lt;String&gt;() {
    @Override
    public void call(String translatedText) {
      Log.i(TAG, "Translation finished " + tMark());
    }
  })
  <span class="strong"><strong>.observeOn</strong></span>(
    AndroidSchedulers.mainThread() // Executing on main Thread
   )
  <span class="strong"><strong>.doOnTerminate</strong></span>(new Action0() {
    @Override
    public void call() {  
      if (progress != null)
        progress.dismiss();
      Log.i(TAG, "Dismissing dialog " + tMark());
    }
  })
  // Starts the execution on the main Thread
  <span class="strong"><strong>.subscribeOn</strong></span>(AndroidSchedulers.mainThread())
  <span class="strong"><strong>.subscribe</strong></span>(new MySubscriber());</pre></div><p>As you know, to make changes in the Android UI, it is imperative to run your code on the main Thread. Hence, in <a id="id674" class="indexterm"/>order to receive <code class="literal">doOnNext</code> from the first <code class="literal">Observable</code> in the main thread, we invoke <code class="literal">subscribeOn()</code> with <code class="literal">AndroidSchedulers.mainThread()</code> forcing the first <code class="literal">Observable</code>, the one created with the <code class="literal">just</code> operator, to emit notifications to <code class="literal">doOnNext</code> in the main Thread.</p><p>As soon as <code class="literal">doOnNext()</code> receives the notification with the String carrying the URL to retrieve the text, we display ProgressDialog in the UI and we log a message in the Android Log.</p><p>Next, since we want to perform network operations off the main thread, using the <code class="literal">observeOn</code> operator, we force following <code class="literal">Observables</code> to send notifications to the threads managed by the <code class="literal">IO Scheduler</code>. This means that the following operators and <code class="literal">Observables</code> will execute and emit events in the IO <code class="literal">Scheduler</code> threads.</p><p>In the meantime, between each network operation, we intercept the start of the second network operation to print the message in Android with a <code class="literal">doOnNext</code> between <code class="literal">getTextFromNetwork</code> and <code class="literal">translateOnNetwork Observables</code>.</p><p>When the network operations <a id="id675" class="indexterm"/>finish, and before we update the UI with the results and we dismiss the progress dialog, we switch the execution to the main thread by again invoking the operator <code class="literal">observeOn()</code> with the main <code class="literal">Thread Scheduler</code>.</p><p>Before we display the results on the screen, with the <code class="literal">doOnTerminate</code> operator we register an <code class="literal">Action</code> function to be called to dismiss the progress dialog previously started. As described before, the function will be invoked, whether the chain terminates with success or with an error.</p><p>At the end, the <code class="literal">Subscriber</code> callbacks will be invoked to update the UI with the results returned or to show an error message.</p><p>If the network operation terminates with success you should see a similar logging stream in the Android Log:</p><div class="informalexample"><pre class="programlisting">...54.390 I Network IO Operation will start T[main]
...54.850 I Text retrieved w/ success T[RxCachedThreadScheduler-1]
...54.850 I Translating the text T[RxCachedThreadScheduler-1]
...55.160 I Translation finished T[RxCachedThreadScheduler-1]
...55.200 I Dismissing dialog on T[main]</pre></div><p>For debugging purposes, <code class="literal">[&lt;Thread_Name&gt;]</code> shows the name of the thread that logged the message.</p></div>
<div class="section" title="Combining Observables"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec101"/>Combining Observables</h1></div></div></div><p>In the previous <a id="id676" class="indexterm"/>example, we used two <code class="literal">Observable</code> to create a simple sequence of network operations. The second asynchronous operation operated with the result of the first operation and the two operations that executed serially produced a String result that updates the UI.</p><p>In our next example, we will run two tasks in parallel and combine the results of both operations using a combining <code class="literal">RxJava</code> operator. Each operation will retrieve asynchronously a JSON Object from the network and combine both results in the JSON Object to produce the JSON <code class="literal">String</code> passed to the UI main <code class="literal">Thread</code>.</p><p>Since we only want to emit one Event or an error from the operation, we are going to use, for the first time, a special kind of Observer, <code class="literal">Single</code>.</p><p>While an <code class="literal">Observable</code> is able to invoke <code class="literal">onNext</code>, <code class="literal">onError</code>, and <code class="literal">onCompleted</code> Observer functions, a <code class="literal">Single</code> entity will only invoke either <code class="literal">onSuccess</code> or <code class="literal">onError</code> to a <code class="literal">SingleSubscriber</code>:</p><div class="informalexample"><pre class="programlisting"> // Success callback invoked on success
 void onSuccess(T value);

 // Callback to notify that an unrecoverable error has occurred
 void onError(Throwable error);</pre></div><p>After one of the callback functions is called, the <code class="literal">Single</code> finishes and the subscription to it ends. Like a regular <code class="literal">Observable</code>, the <code class="literal">Single</code> object emitted event can be processed with operators before it reaches the final <code class="literal">SingleSubscriber</code>.</p><p>Now, let's define the two <code class="literal">Single</code> operations that retrieve a single <code class="literal">JSONObject</code> from the network:</p><div class="informalexample"><pre class="programlisting">Single&lt;JSONObject&gt; postSingle = Single.create(
  new Single.OnSubscribe&lt;JSONObject&gt;() {
    @Override
    public void call(SingleSubscriber&lt;? super JSONObject&gt; sub) {
      try {
        // Retrieve the Post content JSON Object
        sub.onSuccess(
         getJson("http://demo1472539.mockable.io/post"));
      } catch (Throwable t) {
        sub.onError(t);
      }
    }
  }
).subscribeOn(Schedulers.newThread());

Single&lt;JSONObject&gt; authorSingle = Single.create(
  new Single.OnSubscribe&lt;JSONObject&gt;() {
    @Override
    public void call(SingleSubscriber&lt;? super JSONObject&gt; sub) {
      try {
        // Retrieve the Author content JSON Object
        sub.onSuccess(
          getJson("http://demo1472539.mockable.io/author"));
      } catch (Throwable t) {
        sub.onError(t);
      }
    }
  }
).subscribeOn(Schedulers.newThread());</pre></div><p>Like we did for the previous <code class="literal">Observable</code>, we used the <code class="literal">Single.create</code> static function to build a custom <code class="literal">Single</code> entity that either explicitly calls the <code class="literal">SingleSubscriber.onSuccess</code> function when the network operation finishes with success, or calls the <code class="literal">SingleSubscriber.onError</code> function when an error is thrown on the <code class="literal">getJson</code> IO operation.</p><p>The <code class="literal">getJSON</code> function <a id="id677" class="indexterm"/>will basically retrieve a JSON Object by connecting to the HTTP URL provided as an argument and return a <code class="literal">JSONObject</code>.</p><p>By forcing the Single to <code class="literal">subscribeOn</code> the <code class="literal">newThread Sheduler</code>, we are allowing each custom <code class="literal">Single</code> entity to run their operation concurrently on a new thread.</p><p>Since the two operations will run in parallel, we need to use the combining operator to combine the <code class="literal">Single</code> results together in a single <code class="literal">JSONObject</code> and emit the resulting JSON <code class="literal">String</code> to the final <code class="literal">SingleSubscriber</code>. The appropriate combining operator for our example is zip, because it is able to wait for the result of two or more <code class="literal">Single/Observable</code> and apply a function to each <code class="literal">Single</code> output object.</p><p>The function that receives the emitted objects as an argument can produce a result of the same type or of a different type.</p><p>This is the <code class="literal">zip</code> operator function definition for combining two Singles into a <code class="literal">Single&lt;R&gt;</code>:</p><div class="informalexample"><pre class="programlisting">   Single&lt;R&gt; zip(Single&lt;T1&gt; o1, // First Single
                 Single&lt;T2&gt; o2, // Second Single
                 final Func2&lt;T1,T2,R&gt; zipFunction)</pre></div><p>In our example, <code class="literal">R</code> is a String, <code class="literal">T1</code> and <code class="literal">T2</code> are a <code class="literal">JSONObject</code>, and <code class="literal">zipFunction</code> receives the <code class="literal">JSONObjects</code> arguments to generate a <code class="literal">String</code> as the result.</p><p>Now we are ready to use the <code class="literal">zip</code> operator and combine the result of each independent asynchronous operation into a <code class="literal">String</code>. The resulting string will update a <code class="literal">Widget</code>, so the final <code class="literal">Subscriber</code> should be invoked in the main Thread.</p><p>Let's write the functional <a id="id678" class="indexterm"/>code that fetches the <code class="literal">JSONObject</code> parts and dispatches the resulting <code class="literal">String</code> to the UI:</p><div class="informalexample"><pre class="programlisting">Single<span class="strong"><strong>.zip</strong></span>(postSingle, authorSingle,
           new Func2&lt;JSONObject, JSONObject, String&gt;() {
  @Override
  public String call(JSONObject post, JSONObject author) {
    String result = null;

    // Create the Root JSON Object
    JSONObject rootObj = new JSONObject();
    try {
      // Add the post object to root JSON Object
      rootObj.put("post", post);
      // Add the author object to root JSON Object
      rootObj.put("author", author);
      // Save the JSON Object, Encode the JSON Object
      // into a String
       result = rootObj.toString(2);
    } catch (Exception e) {
       Exceptions.propagate(e);
    }
    return result;
  }
})
.observeOn(AndroidSchedulers.mainThread())
.subscribe(subscriber);</pre></div><p>Using the zip operator, we combined the result of the two operations, <code class="literal">postSingle</code> and <code class="literal">authorSingle</code>, that ran on a new thread created by the <code class="literal">newThread</code> Scheduler, on the <code class="literal">Func2</code> that received the two <code class="literal">JSONObjects</code> as arguments and produced a <code class="literal">String</code>.</p><p>Since we subscribed the <code class="literal">Single</code> to work on its own Thread, the <code class="literal">zip</code> function will combine the result of both <code class="literal">Singles</code> on the thread built by the last defined Single (<code class="literal">authorSingle</code>) resulting in a log similar to the following output:</p><div class="informalexample"><pre class="programlisting">.040 I ...: Getting the Post Object on RxNewThreadScheduler-1
.050 I ...: Getting the Author Object on RxNewThreadScheduler-2
.660 I ...: Combining objects on RxNewThreadScheduler-2</pre></div><p>After combining the <a id="id679" class="indexterm"/>objects, the <code class="literal">String</code> produced by <code class="literal">Func2</code> is delivered to the final <code class="literal">Subscriber</code> in the main <code class="literal">Thread</code>.</p><p>All that remains is to implement the trivial <code class="literal">SingleSubscriber</code> that updates the UI:</p><div class="informalexample"><pre class="programlisting">SingleSubscriber&lt;String&gt; subscriber =
  new SingleSubscriber&lt;String&gt;() {
  ...
  @Override
  public void onSuccess(String result) { // Updates the UI }
};</pre></div></div>
<div class="section" title="Observing UI Events with RxJava"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec102"/>Observing UI Events with RxJava</h1></div></div></div><p>So far, we <a id="id680" class="indexterm"/>have been using <code class="literal">RxJava</code> to process and manipulate <a id="id681" class="indexterm"/>data streams, which simplified the development of asynchronous that require IO blocking operations that will hang the application for a while.</p><p>In this section, we want to explain how to use <code class="literal">RxJava</code> and reactive streams to simplify the handling of UI events generated from Android Widgets.</p><p>In our next example, we will present a list of Soccer Teams with an instant search result input field. As you type in the input field, the names available in the list will be filtered if the text that you typed matches the beginning of any soccer team on the list.</p><p>To achieve the result required, we will create a custom <code class="literal">Observable</code> that attaches a <code class="literal">TextWatcher</code> to the searching input field, listens for <code class="literal">onTextChanged</code> events, and emits a String event when the text changes.</p><p>The Observer will feed a reactive functional stream that will filter our list of teams in a Recycler View.</p><p>First, we will write a Custom Observable that registers <code class="literal">TextWatcher</code> to <code class="literal">EditField</code> when an <code class="literal">Observer</code> <a id="id682" class="indexterm"/>subscribes, and deregisters <a id="id683" class="indexterm"/><code class="literal">TextWatcher</code> when the subscription finishes:</p><div class="informalexample"><pre class="programlisting">public class TextChangeOnSubscribe
 implements <span class="strong"><strong>OnSubscribe&lt;String&gt;</strong></span> {
  // Don't Prevent the GC from recycling the Activity
  WeakReference&lt;EditText&gt; editText;

  // Receive the EditText View to verify Changes
  public TextChangeOnSubscribe(EditText editText) {
    this.editText = new WeakReference&lt;EditText&gt;(editText);
  }

  @Override
  public void call(final Subscriber&lt;? super String&gt; subscriber) {
    final TextWatcher watcher = new TextWatcher() {
   
      @Override
      public void onTextChanged(
        CharSequence s, int start, int before, int count) {

        // Emit a new String when the text changes
        <span class="strong"><strong>if (!subscriber.isUnsubscribed()) {</strong></span>
<span class="strong"><strong>          subscriber.onNext(s.toString());</strong></span>
<span class="strong"><strong>        }</strong></span>
      }
    };
    // Remove the Text change Watcher when the subscription ends
    subscriber.add(new MainThreadSubscription() {
      @Override
      protected void onUnsubscribe() {
        editText.get().removeTextChangedListener(watcher);
      }
    });
    // Sets the Watcher on the EditField
    editText.get().addTextChangedListener(watcher);
    subscriber.onNext("");
  }
};

...
EditText search = (EditText) findViewById(R.id.searchTv);
Observable&lt;String&gt; textChangeObs = Observable.
    create(new TextChangeOnSubscribe(search))
                                                     .debounce(400, TimeUnit.MILLISECONDS);</pre></div><p>The <code class="literal">TextChangeOnSubscribe</code> class, which implements the <code class="literal">OnSubscribe&lt;String&gt;</code> and receives a subscription callback, will set a <code class="literal">TextWatcher</code> in the received <code class="literal">EditField</code> once the subscription is performed by the <code class="literal">Subscriber</code>.</p><p>When <code class="literal">TextWatcher.onTextChanged</code> is invoked to notify a text change in <code class="literal">EditField</code>, a new String event with the new content should be emitted in the Subscriber.</p><p>To unregister the <code class="literal">TextWatcher</code> in the <code class="literal">EditField</code>, we add a <code class="literal">MainThreadSubscription</code> anonymous class to the subscriber list that removes our <code class="literal">TextChangeListener</code> in the <code class="literal">EditField</code>.</p><p>To prevent the <a id="id684" class="indexterm"/>text change event from generating too many <a id="id685" class="indexterm"/>updates in the UI, we used the <code class="literal">debounce</code> operator to only emit a new search term if there's been a 400 millisecond delay since the last text change event.</p><p>Next, we will use the search Events generated by our <code class="literal">Observable</code> to filter the teams available in the <code class="literal">ReciclerView</code> list:</p><div class="informalexample"><pre class="programlisting">List&lt;String&gt; soccerTeams = Arrays.asList(
  "Real Madrid","Barcelona","Sporting CP",...,"Chelsea");

subcription = Observable.<span class="strong"><strong>combineLatest</strong></span>(
  // Observables
<span class="strong"><strong>  Observable.just(soccerTeams), textChangeObs,</strong></span>
  // Combine Function
  new Func2&lt;List&lt;String&gt;, String, List&lt;String&gt;&gt;() {

    // Filter the list with the filter String and sort the list
    @Override
    public List&lt;String&gt; call(List&lt;String&gt; fullList,
                             String filter){
      List&lt;String&gt; result = new ArrayList&lt;String&gt;();
      for (String team : fullList) {
        if (team.startsWith(filter)) {
          result.add(team);
        }
      }
<span class="strong"><strong>      // Sort the Collection</strong></span>
      Collections.sort(result);
      return result;
    }
  })
 .observeOn(AndroidSchedulers.mainThread())
  .subscribe(new Action1&lt;List&lt;String&gt;&gt;() {
    @Override
    public void call(List&lt;String&gt; teams) {
      // Update the Recycler View with a filtered list of Teams
      mAdapter = new MyAdapter(teams);
      mRecyclerView.setAdapter(mAdapter);
    }
  });</pre></div><p>To filter the soccer team list with the search term emitted by the <code class="literal">textChangeEvent</code> we applied the operator <a id="id686" class="indexterm"/><code class="literal">combineLatest</code> to <code class="literal">textChangeObs</code> <code class="literal">Observable</code> and to the <code class="literal">Observable</code> created from the soccer team list with the operator just.</p><p>The <code class="literal">combineLatest</code> <a id="id687" class="indexterm"/>will combine the latest item emitted by each <code class="literal">Observable</code> using a specified function and emit items based on the results of this function invocation.</p><p>The function that combines both <code class="literal">Observables</code> will simply filter the soccer list with the last text content emitted by the <code class="literal">onTextChanged</code> and sort the resulting list.</p><p>To finalize, a new <code class="literal">RecyclerView.Adapter</code> is created with the resulting <code class="literal">List&lt;String&gt;</code> and the filtered list of teams will be displayed to the user.</p><p>Notice that to update our <code class="literal">RecyclerView</code> with the resulting filtered list, we explicitly set the <code class="literal">Observer</code> to run on the main Thread by passing the Android main Thread <code class="literal">Scheduler</code> to the <code class="literal">observeOn</code> operator.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note59"/>Note</h3><p>Don't forget to terminate the subscription before the Activity is destroyed by calling <code class="literal">subcription.unsubscribe();</code>
</p></div></div><p>Although, for educational purposes, we built our own Observables from the Android EditField Widget text change events, there is an easy-to-use, open source library named RxBinding (<a class="ulink" href="https://github.com/JakeWharton/RxBinding">https://github.com/JakeWharton/RxBinding</a>) that is able to create Observables for most Android Widgets available on the Android SDK.</p><p>If you don't want to implement your own Observables, or process UI events in a traditional way, you can <a id="id688" class="indexterm"/>make use of it to process Android UI <a id="id689" class="indexterm"/>events using a functional RxJava reactive paradigm.</p></div>
<div class="section" title="Working with Subjects"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec103"/>Working with Subjects</h1></div></div></div><p>So far, we have been <a id="id690" class="indexterm"/>working with <code class="literal">Observables</code>, <code class="literal">Subscriber</code>, <code class="literal">Observer</code>, and <code class="literal">Scheduler</code> entities to create our <code class="literal">RxJava</code> functional processing lines. In this section, we will introduce the reader to a new kind of entity in the <code class="literal">RxJava</code> framework, the <code class="literal">Subject</code>. The <code class="literal">Subject</code> is a sort of adapter or bridge entity that acts as an <code class="literal">Observable</code> and <code class="literal">Observer</code>:</p><div class="informalexample"><pre class="programlisting">public abstract class      <span class="strong"><strong>Subject</strong></span>&lt;T,R&gt;
                extends    <span class="strong"><strong>Observable</strong></span>&lt;R&gt;
                implements <span class="strong"><strong>Observer</strong></span>&lt;T&gt;</pre></div><p>Since it can act as a <code class="literal">Subscriber</code>, it can subscribe to one or more <code class="literal">Observables</code> that emit <code class="literal">Objects</code> of the generic type <code class="literal">T</code>, and since it acts as an <code class="literal">Observable</code>, it can emit events of the generic type <code class="literal">R</code> and receive subscriptions from other <code class="literal">Subscriber</code>. Hence, it can emit events of the same type as received or emit a different type of event.</p><p>For example, the <code class="literal">Subject&lt;String, Integer&gt;</code> will receive events of type <code class="literal">String</code> and emit events of the type <code class="literal">Integer</code>.</p><p>The <code class="literal">Subject</code> could receive the events from the <code class="literal">Observable</code> and generate a new event stream with different timings, proxy the events, convert to a new kind of event, queue the events, transform the events, or even generate new events.</p><p>A <code class="literal">Subject</code> is always considered a hot <code class="literal">Observable</code> and will begin emitting events as soon as it is created. This is a very important <code class="literal">Subject</code> feature and you should consider it when you want to process the full event stream sequence.</p><p>
<span class="strong"><strong>RxJava</strong></span> comes with some standard <span class="strong"><strong>Subject</strong></span> classes designed to be used in distinctive use cases. The list below will enumerate the most common ones:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">AsyncSubject</code>: Subjects that will only emit the last item emitted by the source <code class="literal">Observable</code> when the source <code class="literal">Observer</code> completes the stream by calling <code class="literal">onComplete()</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">PublishSubject</code>: The Subject only delivers to the Observers the events emitted after their subscription</li><li class="listitem" style="list-style-type: disc"><code class="literal">ReplaySubject</code>: Emits all the events emitted by the source <code class="literal">Observable</code>, even those that were emitted before the subscription is made</li><li class="listitem" style="list-style-type: disc"><code class="literal">BehaviorSubject</code>: Emits the last emitted item by the source <code class="literal">Observable</code> when the subscription is done, then continues to any other items emitted by the source observable</li></ul></div><p>In the following example, we <a id="id691" class="indexterm"/>will show you how to use <code class="literal">PublishSubject</code> and demonstrate how the events are propagated to a final <code class="literal">Observer</code> that subscribes and later unsubscribes to the <code class="literal">Subject</code>. Moreover, we will submit events to <code class="literal">Subject</code> before and after the subscription is made:</p><div class="informalexample"><pre class="programlisting">PublishSubject&lt;Integer&gt; pubSubject = PublishSubject.create();
pubSubject.onNext(1);
pubSubject.onNext(2);
Subscription subscription = pubSubject.doOnSubscribe(new Action0() {
  @Override
  public void call() {
    Log.i(TAG, "Observer subscribed to PublishSubject");
  }
}).doOnUnsubscribe(new Action0() {
  @Override
  public void call() {
    Log.i(TAG, "Observer unsubscribed to PublishSubject");
  }
}).subscribe(new Action1&lt;Integer&gt;() {
  @Override
  public void call(Integer integer) {
    Log.i(TAG, "New Event received from PublishSubject: " + integer);
  }
});
pubSubject.onNext(3);
pubSubject.onNext(4);
subscription.unsubscribe();
pubSubject.onNext(5);
pubSubject.onCompleted();</pre></div><p>First, we created the <code class="literal">PublishSubject</code> by calling the <code class="literal">PublishSubject.create</code> static function, and then we started delivering integers to it and calling the <code class="literal">onNext</code> function.</p><p>In the meantime, we subscribed to the <code class="literal">Subject</code> with an <code class="literal">Action1</code> function in order to consume the events.</p><p>To print the exact time <a id="id692" class="indexterm"/>when the subscription and unsubscription is made, we provided an <code class="literal">Action0</code> function to the <code class="literal">doOnUnsubscribe</code> and <code class="literal">doOnSubscribe</code> that prints a message to the Android Log.</p><p>As a result, the code above should output the following output:</p><div class="informalexample"><pre class="programlisting">... 43.230 I Observer subscribed to PublishSubject
... 43.230 I New Event received from PublishSubject: 3
... 43.230 I New Event received from PublishSubject: 4
... 43.230 I Observer unsubscribed to PublishSubject</pre></div><p>As described before, only the events dispatched while the final <code class="literal">Observer</code> is subscribed are emitted to the <code class="literal">Action</code> callback. Therefore, the events submitted before the subscriptions and after the unsubscription are not received by our Subscriber.</p><p>Now, for comparison, let's try to compare the event stream emitted by a <code class="literal">ReplaySubject</code>, with the exact sequence of events submitted to the Subject.</p><p>Again, the <code class="literal">ReplaySubject</code> class was built by calling the create static function, and as a result, you should see the following output:</p><div class="informalexample"><pre class="programlisting">.600 I Observer subscribed to ReplaySubject
.600 I New Event received from ReplaySubject: 1
.600 I New Event received from ReplaySubject: 2
.600 I New Event received from ReplaySubject: 3
.600 I New Event received from ReplaySubject: 4
.600 I Observer unsubscribed to ReplaySubject</pre></div><p>On the <a class="ulink" href="http://reactivex.io/documentation/subject.html">http://reactivex.io/documentation/subject.html</a> website, there are diagrams to help you understand graphically the interactions between Subjects, Subscribers, and source Observables.</p><p>As expected, <code class="literal">ReplaySubject</code> will receive all the events submitted to the <code class="literal">Subject</code>, even the ones delivered before the subscription was made are received by the <code class="literal">Observer</code>. After the <code class="literal">Observer</code> unsubscribes, it stops receiving the events from the <code class="literal">Subject</code>.</p><p>As an exercise, you can try <a id="id693" class="indexterm"/>to create the same for the <code class="literal">AsyncSubject</code> and <code class="literal">BehaviorSubject</code>.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec104"/>Summary</h1></div></div></div><p>In this final chapter, we learned how to use <code class="literal">RxJava</code>, an open source library that helps to process our Android application data or event streams using functional and reactive processing pipelines.</p><p>In the first sections, we learned in detail some of <code class="literal">RxJava</code> basic building blocks—<code class="literal">Observable</code>, <code class="literal">Observer</code>, and <code class="literal">Subscriber</code>.</p><p>Next, we introduced some of <code class="literal">RxJava</code> most common operators that are able to manipulate, transform, and combine event streams generated by an <code class="literal">Observable</code>.</p><p>In order to perform operations asynchronously and concurrently, we learned about the <code class="literal">Scheduler</code>, a magic <code class="literal">RxJava</code> entity that controls the concurrency, and is able to schedule <code class="literal">RxJava</code> units of work to run in background threads and feed the results back to the main Android Thread.</p><p>Next, using custom <code class="literal">Observables</code> and combining operators, we learned how to associate and compose interdependent complex blocking or long computing operations, such as REST API network operation.</p><p>In the meantime, we also learned how to react to a custom <code class="literal">Observable</code> that emits Android Widget UI events using a <code class="literal">RxJava</code> event functional pipeline.</p><p>Finally, we learned about the <code class="literal">Subject</code> <code class="literal">RxJava</code> entity, an entity that can act as an <code class="literal">Observer</code> and <code class="literal">Observable</code> and can act as a proxy between our source <code class="literal">Observable</code> and the final <code class="literal">Observer</code>.</p><p>Over the course of this book, we've armed ourselves with a powerful array of tools for building responsive Android applications. We discovered that it is incredibly important to move as much work as possible off the main thread, and explored a number of constructs and asynchronous techniques to make the smoothest and most awesome experience for your users.</p><p>Remember that to keep your application responsive and avoid any UI lost frames, an Android callback (<code class="literal">Service</code>, <code class="literal">Activity</code>, and so on) that runs on the main UI Thread should terminate in under 16 ms.</p></div></body></html>