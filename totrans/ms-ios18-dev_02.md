# <st c="0">2</st c="0">

# <st c="2">使用SwiftData简化我们的实体</st c="2">

<st c="41">让我们以苹果在过去几年中发布的最重要和最有用的框架之一——</st c="41"><st c="182">SwiftData</st c="182">——开始我们的iOS 18精通之旅。</st c="182">

**<st c="192">SwiftData</st>** <st c="202">是Swift宏使用的优秀示例，将老旧且深受喜爱的Core Data框架提升到了一个全新的简单化水平，并使其适应Swift和<st c="380">声明式编程</st c="380">的现代世界。</st c="209">

<st c="404">在本章中，我们将做以下事情：</st c="404">

+   <st c="447">了解SwiftData的</st c="447"><st c="463">背景</st c="463"></st c="463">

+   <st c="483">定义数据模型，包括其</st c="483"><st c="533">关系</st c="533">和属性</st c="533"></st c="533">

+   <st c="547">了解SwiftData容器</st c="547"><st c="584">和配置</st c="584"></st c="584">

+   <st c="602">使用模型上下文</st c="602"><st c="639">检索和操作数据</st c="639"></st c="639">

+   <st c="652">将我们的数据迁移到新的</st c="652"><st c="677">版本模式</st c="677"></st c="677">

<st c="692">这将是一次漫长的旅程，将会有一个令人兴奋的新框架！</st c="692">因此，在技术要求之后，让我们从框架的背景开始。</st c="754"><st c="828">框架</st c="828">

# <st c="842">技术要求</st c="842">

<st c="865">本章包含许多代码示例，其中一些可以在以下</st c="865"><st c="952">GitHub仓库</st c="952">中找到：</st c="952">

[<st c="970">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202</st c="970"]](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%202)

<st c="1056">要运行它们，我们需要Xcode 16</st c="1056">或更新的版本。</st c="1092">

# <st c="1101">理解SwiftData的背景</st c="1101">

<st c="1138">要了解SwiftData的背景及其根源，重要的是要退一步</st c="1138"><st c="1234">了解</st c="1234"><st c="1250">Core</st c="1250">数据</st c="1250"><st c="1255">框架</st c="1255"></st c="1255"></st c="1259">

<st c="1270">Core Data多年来一直是苹果平台的主要数据框架，甚至在iOS</st c="1270"><st c="1369">诞生之前。</st c="1369">

<st c="1378">Core Data是在iOS 3中添加到iOS的，它将处理数据图的能力灵活且高效地带给移动设备。</st c="1378">请注意，我没有提到单词</st c="1504"><st c="1543">数据库</st c="1543">或</st c="1504"><st c="1551">持久性</st c="1551">，这有一个很好的原因。</st c="1555"><st c="1566">我们应该记住，Core Data不是一个</st c="1598"><st c="1642">SQLite</st c="1642">包装器，尽管其持久存储在大多数情况下基于SQLite。</st c="1648">Core Data的主要目标是处理我们应用的</st c="1725"><st c="1778">数据层</st c="1778"></st c="1778">

<st c="1789">但处理应用程序的数据层意味着什么呢？</st> <st c="1844">嗯，大多数应用程序都与几个层一起工作——UI、业务逻辑和数据层。</st> <st c="1927">数据层建立在定义我们应用程序所处理的核心项目的数据实体之上。</st> <st c="2022">例如，一个待办事项应用程序可以具有诸如</st> *<st c="2075">列表</st>*<st c="2079">、</st> *<st c="2081">任务</st>*、 <st c="2086">或</st> *<st c="2090">提醒</st>*<st c="2098">之类的实体。</st> <st c="2154">一个音乐应用程序可以具有诸如</st> *<st c="2141">专辑</st>*<st c="2146">、</st> *<st c="2148">歌曲</st>*、 <st c="2152">或</st> *<st c="2157">播放列表</st>*<st c="2165">之类的实体。</st>

<st c="2166">数据层定义了不同的实体以及它们之间的关系。</st> <st c="2239">例如，一个专辑可以包含许多歌曲，一个列表可以包含许多任务。</st> <st c="2320">如果需要持久化，数据层也处理了不同实体的数据如何保存到磁盘上的问题。</st> <st c="2434">根据我们对数据层的理解，Core Data通过定义其数据模型、处理持久化、迁移甚至撤销操作来履行其作为应用程序数据层的角色。</st> <st c="2619">所以，如果Core Data是处理数据如此出色的框架，为什么我们</st> <st c="2696">还需要SwiftData？</st>

<st c="2711">Core Data是一个伟大的框架，但它是为不同的时代设计的，当时我们使用Objective-C进行编码，而UIKit甚至还没有被创建。</st> <st c="2859">从那时起，iOS开发世界已经发生了显著变化——我们现在有了Swift，而且更重要的是，我们有了SwiftUI。</st> <st c="2980">尽管Core Data已经更新以支持Swift和SwiftUI，但它仍然在类型安全、多线程和声明式编程的世界中感觉过时。</st> <st c="3148">在Core Data中获取和观察数据变化变得繁琐，因为我们使用了更适合UIKit/Objective-C时代的设计模式。</st> <st c="3292">在这种情况下，SwiftData承诺带来一个现代、直接的框架来更完美地处理数据，利用Swift</st> <st c="3440">和Combine的全部力量。</st>

<st c="3452">SwiftData最好的事情之一是它使用了</st> *<st c="3508">Swift宏</st>* <st c="3520">——我们在</st> [*<st c="3565">第10章</st>*](B21795_10.xhtml#_idTextAnchor329)<st c="3575">中学到的相同的Swift宏。</st> <st c="3575">这些宏帮助我们优雅地实现SwiftData，而无需使用</st> <st c="3640">样板代码。</st>

<st c="3657">是时候进入商业领域并创建我们的第一个</st> <st c="3710">SwiftData模型了！</st>

# <st c="3727">定义SwiftData模型</st>

<st c="3754">通常，在讨论数据框架时，我们通常会从基本设置开始。</st> <st c="3842">然而，这次，我们将从模型本身开始。</st> <st c="3899">为什么是那样呢？</st> <st c="3912">因为我想要展示如何简单地将现有的数据模型转换为 SwiftData 模型，使用以下代码片段：</st> <st c="4050">：</st>

[PRE0]

<st c="4294">在这段代码中，我们看到一个标准的</st> `<st c="4327">Book</st>` <st c="4331">类</st>，添加了一个名为</st> `<st c="4374">@Model</st>`<st c="4380">的宏。在我们展开</st> `<st c="4403">@Model</st>` <st c="4409">宏并查看它确切地做了什么之前，让我们关注当我们</st> <st c="4484">添加它时会发生什么。</st>

<st c="4491">添加</st> `<st c="4503">@Model</st>` <st c="4509">宏</st> <st c="4509">就足以将一个常规类转换为带有持久存储的模型。</st> <st c="4604">类似于 Core Data 实体的工作方式，类名是实体名，其变量是</st> `<st c="4705">实体属性。</st>`

<st c="4723">当我们</st> <st c="4732">将其与 Core Data 进行比较时，我们可以看到模型声明过程是相反的——在 Core Data 中，我们在模型编辑器中声明模型，然后生成其类，而在 SwiftData 中，我们取一个常规类并将其</st> <st c="4961">转换为模型。</st>

<st c="4969">但是</st> `<st c="4984">@Model</st>` <st c="4990">宏实际上做了什么？</st> <st c="5008">让我们展开它</st> <st c="5024">并看看。</st>

## <st c="5032">展开 @Model 宏</st>

<st c="5059">我们已经</st> <st c="5071">知道了 Swift 宏的能力，SwiftData 是探索一种新的</st> <st c="5159">宏实现</st> <st c="5159">的好机会。</st>

<st c="5180">要展开宏，我们可以右键单击</st> `<st c="5228">@Model</st>` <st c="5234">名称</st>，并从弹出菜单中选择**<st c="5251">展开宏</st>** <st c="5263">。</st> <st c="5286">现在类体看起来</st> <st c="5311">是这样的：</st>

[PRE1]

<st c="6354">那么，我们的美丽且简约的</st> `<st c="6402">Book</st>` <st c="6406">类</st> <st c="6414">发生了什么</st>？<st c="6414">看起来</st> `<st c="6434">@Model</st>` <st c="6440">宏</st> <st c="6462">在这里非常</st> <st c="6462">活跃。</st>

<st c="6474">为了简化，让我们尝试将其</st> <st c="6510">分解：</st>

+   `<st c="6523">Book</st>` `<st c="6598">PersistentModel</st>` `<st c="6613">和</st> `<st c="6618">Observable</st>` `<st c="6628">。` `<st c="6634">PersistentModel</st>` `<st c="6649">协议帮助 SwiftData 与我们的风格协同工作并访问其属性。</st> `<st c="6722">Observable</st>` `<st c="6736">协议允许我们通知数据的</st> `<st c="6785">更改。</st>`

+   `<st c="6914">PersistentModel</st>` <st c="6929">协议是，我们将发现它需要实现两个变量——</st>`<st c="7014">backingData</st>` <st c="7026">和</st> `<st c="7031">schemaMetaData</st>`<st c="7045">。我们可以在我们的宏展开代码中直接看到它们的实现。</st> <st c="7116">这些变量帮助SwiftData专门为我们存储和检索我们的实体信息。</st> <st c="7225">并且也许这正是Swift宏真正强大的地方——能够生成针对</st> <st c="7352">我们的类定制的代码。</st>

+   **<st c="7362">我们有属性宏</st>**<st c="7386">：如果我们查看类属性，我们可以看到它们现在有自己的宏。</st> <st c="7469">展开它们会显示它们现在已成为计算变量，因此我们可以从我们的内存以及我们的后端</st> <st c="7624">数据存储中存储和检索数据：</st>

    [PRE2]

<st c="7756">额外的代码行</st> <st c="7774">将所有内容组合在一起，例如观察和</st> <st c="7836">注册属性。</st>

<st c="7859">这很复杂吗？</st> <st c="7881">有一点。</st> <st c="7895">但这就是拥有宏的好处之一——简化复杂的实现。</st> <st c="7983">重要的是要理解，每个带有</st> `<st c="8048">@Model</st>` <st c="8054">宏的类立即获得自己的存储，并添加到</st> <st c="8121">SwiftData模式。</st>

<st c="8138">然而，要添加更复杂的数据模型，我们需要能够定义模型之间的关系。</st> <st c="8245">让我们看看它是如何工作的。</st>

## <st c="8268">添加关系</st>

<st c="8289">与现实生活不同，在SwiftData中，关系</st> <st c="8336">很简单。</st>

<st c="8347">一个</st> **<st c="8350">关系</st>** <st c="8362">是一个数据库模式，它定义了实体如何相互关联，在Core Data中，我们有两种类型的关系——</st> **<st c="8491">一对一</st>** <st c="8497">和</st> **<st c="8502">多对多</st>**<st c="8509">。简而言之，一个</st> *<st c="8523">一对一</st>** <st c="8529">关系意味着对于每个实体实例，我们都会有一个其他类型的实例。</st> <st c="8624">一个例子就是汽车和引擎——每辆汽车都有一台，且只有一台引擎，因此它们之间的关系将是一个</st> *<st c="8762">一对一</st>** <st c="8768">关系。</st> <st c="8783">然而，汽车和轮子有一个</st> *<st c="8815">多对多</st>** <st c="8822">关系，因为一辆汽车可以有</st> <st c="8859">多个轮子。</st>

<st c="8875">尽管解释足够简单，但在SwiftData中，它变得更简单。</st> <st c="8957">如果我们想在模型之间定义关系，我们只需要创建另一个变量，就像</st> <st c="9053">这里</st> <st c="9055">所示：</st>

[PRE3]

<st c="9317">在我们的</st> <st c="9325">示例中，我们向</st> `<st c="9379">Book</st>` <st c="9383">类中添加了以下两个属性：</st>

+   `<st c="9390">Author</st>`<st c="9397">：这是一个</st> *<st c="9410">一对多</st> <st c="9416">关系到</st> `<st c="9437">Author</st>` <st c="9443">实体，因为在我们这个例子中，每本书只有一个</st> <st c="9492">作者</st>

+   `<st c="9502">页数</st>`<st c="9508">：在</st> `<st c="9526">Page</st>` <st c="9530">实体的情况下，我们</st> <st c="9542">有一个</st> *<st c="9549">多对多</st> <st c="9556">关系，因为一本书可以包含</st> <st c="9596">多个页面</st>

<st c="9610">有一点需要注意，我们还需要用</st> `<st c="9663">Page</st>` <st c="9667">和</st> `<st c="9672">Author</st>` <st c="9678">实体标记上</st> `<st c="9697">@Model</st>` <st c="9703">宏，因为它们必须是我们模式的一部分。</st> <st c="9747">这可以在以下代码中看到：</st>

[PRE4]

<st c="9990">添加模型这么简单吗？</st> <st c="10001">简短的答案是，是的！</st> <st c="10019">在 SwiftData 中将实体相互链接与添加一个属性一样简单。</st> <st c="10045">Linking entities to each other in SwiftData is as easy as adding</st> <st c="10110">a property.</st>

<st c="10121">更长的答案是，嗯，我们需要做一些额外的工作来稍微定制一下这些关系。</st> <st c="10223">让我们来认识一下</st> `<st c="10238">@</st>``<st c="10239">关系</st>` <st c="10251">宏。</st>

<st c="10258">如果你熟悉 Core Data 关系，你可能知道除了声明</st> *<st c="10355">多对多</st> <st c="10362">和</st> *<st c="10367">一对多</st>*<st c="10373">.</st>

<st c="10374">多对多和一对多关系</st>

<st c="10407">一对多关系</st> <st c="10429">表示实体之间的关联，其中</st> <st c="10475">一个实体的一个实例与另一个不同实体的单个实例相关联。</st> <st c="10562">相反，多对多关系表示关联，其中一个实体的一个实例可以与另一个实体的多个实例相关联。</st> <st c="10707">例如，在一个书店数据库中，一对多关系可以将“书”实体与“作者”实体连接起来，因为每本书只有一个作者。</st> <st c="10849">相比之下，多对多关系可以将“书”实体与“类别”实体连接起来，因为一本书可以属于</st> <st c="10963">多个类别。</st>

<st c="10983">我们可以通过使用</st> `<st c="11028">@Relationship</st>` <st c="11041">宏来以两种主要方式自定义我们的关系。</st>

<st c="11068">让我们从定义</st> <st c="11099">删除规则。</st>

## <st c="11114">SwiftData 关系删除规则</st>

<st c="11152">如果我们删除一本书，</st> `<st c="11169">页面</st>` <st c="11174">和</st> `<st c="11179">作者</st>` <st c="11185">实体会发生什么？</st> <st c="11216">从逻辑上讲，所有书籍页面</st> <st c="11246">都需要被删除，但作者需要保留，因为他们可能与其他书籍相关联。</st> <st c="11348">我们可以用</st> *<st c="11381">删除规则</st>*<st c="11395">来表示这种逻辑；如果你熟悉 Core Data，它基本上与</st> <st c="11461">SwiftData</st> 相同。

<st c="11474">这就是我们如何在 SwiftData 中定义属性</st> <st c="11525">的逻辑：</st>

[PRE5]

@模型

class Book {

… <st c="13124">@关系（inverse: \Page.book） var pages: [Page] =</st>

<st c="13178">[]</st> …

}

@模型

class Page {

    var content: String <st c="13225">var book: Book?</st> init(content: String) {

        self.content = content

    }

}

[PRE6]

\Page.book

[PRE7]

let newPage = Page(content: "Swift 数据")

newPage.book = book

// book.pages 属性 <st c="13678">包含</st> 'newPage'

[PRE8]

@模型

class Folder {

    var parent: Folder? @关系（inverse: \Folder.parent） var subFolders:

    [文件夹]

    var name: String

    var id: UUID

    init(parent: Folder? = nil, subFolders: [Folder], name:

    String, id: UUID) {

        self.parent = parent

        self.subFolders = subFolders

        self.name = name

        self.id = id

    }

}

[PRE9]

var firstName: String? = "MyName"

[PRE10]

<st c="17295">@属性</st> 宏与 <st c="17321">.unique</st> 选项使我们的数据库特定属性值唯一。

            `<st c="17389">UUID</st>` <st c="17394">是属性唯一值的经典示例，但我们可以将其应用于任何其他类型的属性，例如用户 ID</st> <st c="17520">和名称。</st>

            <st c="17530">但是，将属性设置为</st> *<st c="17579">唯一</st>*<st c="17585">究竟意味着什么？当我们尝试插入一个已经存在</st> <st c="17663">唯一属性</st>的实例时，会发生什么？

            <st c="17680">在唯一属性的情况下，SwiftData 执行</st> `<st c="17769">INSERT</st>` <st c="17775">或</st> `<st c="17779">UPDATE</st>` <st c="17785">操作。</st> <st c="17797">这意味着如果已存在具有唯一值的实例，SwiftData 将不会在其存储中创建新对象，而是更新</st> <st c="17940">现有实例。</st>

            使用 `<st c="17958">@Attribute</st>` <st c="18000">宏将属性声明为唯一属性是直接的。</st> <st c="18037">然而，有时我们需要更复杂的功能。</st> <st c="18094">例如，假设我们有一个</st> `<st c="18127">Book</st>` <st c="18131">模型，具有</st> `<st c="18143">name</st>` <st c="18147">和</st> `<st c="18152">publicationName</st>` <st c="18167">属性。</st> <st c="18180">在我们的情况下，我们可以有两个同名或同</st> `<st c="18246">publicationName</st>`<st c="18261">的书籍，但我们不能有两个属性完全相同的书籍。</st> <st c="18327">`<st c="18346">publicationName</st>` <st c="18361">和</st> `<st c="18366">name</st>` <st c="18370">的组合构成了书籍的唯一标识。</st>

            <st c="18406">一个解决方案是维护一个属性，尝试从这两个属性中构建一个唯一的ID。</st> <st c="18505">另一个优雅的选项是使用</st> `<st c="18542">#Unique</st>` <st c="18549">宏来定义更复杂的</st> `<st c="18579">唯一性要求：</st>

[PRE11]

            <st c="18723">在这个代码示例中，我们通过组合两个键路径来强制执行</st> `<st c="18779">Book</st>` <st c="18783">模型的唯一性。</st> <st c="18818">就像属性参数一样，</st> `<st c="18853">.unique</st>`<st c="18860">，如果我们尝试插入一个新书籍实例，而我们已经有了一个同名和出版名称相同的实例，SwiftData将执行一个</st> `<st c="18994">upsert</st>` <st c="19000">操作并更新</st> `<st c="19022">该实例。</st>

            <st c="19036">尽管SwiftData处理唯一属性很好，但确保我们根据应用程序的要求仔细选择唯一属性和键路径是很重要的。</st> <st c="19211">过多的唯一属性可能导致复杂性和</st> <st c="19263">性能问题。</st>

            <st c="19282">唯一属性非常适合简化处理重复实例的任务。</st> <st c="19369">另一个可以简化我们生活的属性特性是</st> *<st c="19429">瞬态</st>*<st c="19438">。</st>

            <st c="19439">使用瞬态属性进行非持久化</st>

            <st c="19475">与SwiftData一起工作的好处是，所有属性都自动成为实体的</st> <st c="19577">属性，并且被持久保存到本地数据存储中。</st> <st c="19640">然而，有时，我们可能想要一个仅存在于内存中而不被持久保存的属性。</st> <st c="19717">内存中</st> *<st c="19728">并且不持久保存</st> *<st c="19757">的属性是一个很好的例子。</st> <st c="19842">实现这一目标的一种方法是创建一个函数或计算变量，然后根据相关属性返回一个值。</st> <st c="19973">然而，在其他情况下，计算变量或函数可能不是方便的解决方案。</st> <st c="20074">假设我们想要一个临时的计数器或维护一个仅与应用程序当前</st> <st c="20176">生命周期相关的标志。</st>

            <st c="20187">对于这类情况，我们</st> <st c="20217">有一个</st> *<st c="20224">瞬态</st> *<st c="20233">属性。</st> <st c="20245">瞬态属性不是一个新概念——Core Data从早期版本就支持瞬态属性。</st> <st c="20345">由于SwiftData基于Core Data的基本原理，它默认支持瞬态属性。</st>

            <st c="20445">以下是我们在SwiftData中声明</st> *<st c="20471">瞬态</st> *<st c="20480">属性</st> <st c="20490">的方法：</st>

[PRE12]

            <st c="20539">在这个代码片段中，</st> `<st c="20566">openCounter</st>` <st c="20577">变量不会被保存到本地持久</st> <st c="20631">存储中，并且每次我们从</st> <st c="20696">我们的数据库中检索实体时都会重新初始化。</st>

            <st c="20709">瞬态属性可能听起来是一个小功能，但在许多情况下，它确实能带来差异，瞬态宏提供了这种灵活性。</st> <st c="20877">全名或计算年龄是很好的例子</st> <st c="20926">。</st>

            <st c="20934">探索容器</st>

            <st c="20958">到目前为止，我们讨论了如何使用</st> `<st c="21031">@Model</st>` <st c="21037">宏声明不同的实体，使用</st> `<st c="21082">@Relationship</st>` <st c="21095">宏定义它们的关系，以及使用</st> `<st c="21144">@</st>``<st c="21145">Attribute</st>` <st c="21154">宏自定义它们的属性。</st>

            <st c="21161">然而，我们还没有讨论如何设置SwiftData与模式和一个</st> <st c="21241">持久存储</st>一起工作。</st>

            <st c="21258">当我们深入研究</st> `<st c="21283">@Model</st>` <st c="21289">宏时，与Core Data的比较是直接的，并且现在仍然是如此。</st> <st c="21370">在Core Data中，我们使用</st> `<st c="21410">NSPersistentContainer</st>`<st c="21431">设置堆栈，它将数据模型、存储和上下文等不同组件封装到一个我们可以</st> <st c="21557">与之工作的堆栈中。</st>

            <st c="21567">在SwiftData中，我们使用</st> `<st c="21589">模型容器</st>`<st c="21603">，它具有相同的职责。</st>

            <st c="21639">让我们尝试理解它是如何工作的。</st> <st c="21668">。</st>

            <st c="21677">设置模型容器</st>

            `<st c="21703">模型容器</st>` <st c="21718">对于使用SwiftData至关重要。</st> <st c="21732">原因是SwiftData有三个主要组件，容器将它们封装并</st> <st c="21851">一起包装：</st>

                +   `<st c="21962">@Model</st>` <st c="21968">宏到</st> <st c="21978">我们的实体</st>

                +   **<st c="21990">存储</st>**<st c="22000">：我们将保存数据的后端存储

                +   **<st c="22048">上下文</st>**<st c="22060">：这是我们与存储和沙盒的链接，我们可以添加、编辑和删除</st> <st c="22145">不同的记录</st>

            <st c="22162">以下是以基本和最小的方式创建</st> <st c="22207">容器的方法：</st>

[PRE13]

            <st c="22411">在这段代码中，我们从一个</st> `<st c="22455">模型容器</st>` <st c="22469">类型创建一个对象，并为其提供我们在</st> *<st c="22535">定义SwiftData</st>* *<st c="22556">模型</st>* <st c="22561">部分中早先创建的三个模型。</st>

            <st c="22570">请注意，在我们的情况下，我们有一个参数，</st> `<st c="22618">模式</st>`<st c="22624">，它包含与我们的容器相关的所有不同模型 –</st> `<st c="22691">书籍</st>`<st c="22695">，`<st c="22697">作者</st>`<st c="22703">，`<st c="22705">和</st> `<st c="22709">页面</st>`<st c="22713">。</st>

            <st c="22714">我们需要提供一个模型列表的事实可能会让人感到惊讶 – 为什么我们需要这样做呢？</st> <st c="22818">Xcode不能定位所有模型并自动将它们添加进去吗？</st> <st c="22880">的确，</st> `<st c="22884">@Model</st>` <st c="22890">宏在编译时扩展代码，但这并不意味着SwiftData在应用运行开始时设置时就知道我们所有的实体。</st> <st c="23044">因此，每次我们添加一个新的模型时，我们必须将其添加到我们的</st> `<st c="23121">模式</st>` <st c="23127">参数中的模型列表中。</st>

            <st c="23138">关于独立包含</st> `<st c="23163">书籍</st>` <st c="23167">实体，而不是</st> `<st c="23198">作者</st>` <st c="23204">实体 – 当我们将</st> `<st c="23230">书籍</st>` <st c="23234">模型添加到模型列表中时，它自动包含所有相关模型，包括那些与</st> <st c="23369">层次结构中更下方的模型</st> <st c="23380">相关的模型。</st> <st c="23380">这意味着，从理论上讲，我们可以在进行类似操作时只包含根对象：</st>

[PRE14]

            <st c="23498">这</st> <st c="23508">就足够包含</st> `<st c="23534">作者</st>` <st c="23540">和</st> `<st c="23545">页面</st>`<st c="23549">。</st>

            <st c="23550">所以，我们将如何使用我们刚刚创建的容器实例呢？</st> <st c="23616">让我们在下一节中看看。</st> <st c="23633">译文：</st>

            <st c="23646">使用模型容器修饰符连接容器</st>

            <st c="23705">现在我们有了模型容器，我们希望以某种方式将其与我们的UI连接起来，以便我们可以开始使用它。</st> <st c="23715">译文：</st>

            <st c="23809">为了做到这一点，我们将使用`<st c="23838">modelContainer</st>` `<st c="23852">修饰符将容器连接到我们的场景：</st> <st c="23890">译文：</st>

[PRE15]

            <st c="23982">在我们的代码示例中，我们将`<st c="24014">modelContainer</st>` `<st c="24028">修饰符添加到我们的`<st c="24045">WindowGroup</st>` `<st c="24056">中，使其在整个应用程序中可用。</st> <st c="24090">译文：</st>

            <st c="24100">我们不需要创建连接器并将其连接到`<st c="24154">WindowGroup</st>`，我们可以使用另一个`<st c="24186">modeContainer</st>` `<st c="24199">init</st>` `<st c="24204">方法，并仅传递实体列表：</st> <st c="24235">译文：</st>

[PRE16]

            <st c="24304">传递实体列表可以是一种简单且易于设置容器的方法。</st> <st c="24390">那么，为什么我们需要</st> `<st c="24413">ModelContainer</st>` <st c="24427">类呢？</st> <st c="24435">简单的回答是，一如既往，为了提供更多的定制。</st> <st c="24499">让我们</st> <st c="24505">看看吧！</st> <st c="24513">译文：</st>

            <st c="24513">译文：</st>

            <st c="24545">`<st c="24550">ModelContainer</st>` `<st c="24564">不仅提供了模式传递的功能；它还赋予我们配置特定模型的`<st c="24638">SwiftData</st>` `<st c="24647">存储并对其进行定制以满足我们`<st c="24698">特定需求`的能力。</st> <st c="24705">译文：</st>

            <st c="24722">为了做到这一点，我们将使用`<st c="24751">ModelConfiguration</st>` `<st c="24769">结构体，如下所示：</st> <st c="24778">译文：</st>

[PRE17]

            <st c="25128">让我们尝试理解这个代码片段中正在发生的事情。</st> <st c="25193">首先，我们创建一个包含我们模型列表的模式。</st> <st c="25246">然后，我们声明一个模型配置结构体，传递模式，并将其后端存储设置为内存。</st> <st c="25350">最后，我们根据我们的模式和刚刚创建的配置集合返回一个模型容器。</st> <st c="25449">译文：</st>

            <st c="25462">整个过程感觉有点笨拙、笨拙和重复——如果我们再次传递相同的模式，为什么还需要创建配置呢？</st> <st c="25613">而且为什么它是集合形式呢？</st> <st c="25634">主要配置思想是为不同的模型集合提供不同的行为。</st> <st c="25715">译文：</st>

            <st c="25725">这里有一个例子。</st> <st c="25745">想象一下，我们有一个头脑风暴草图应用。</st> <st c="25786">我们想在应用程序的持久存储中绘制并存储我们的概念，而白板画布上的所有绘图都保留在内存中。</st> <st c="25910">译文：</st>

            在此情况下，我们可以<st c="25920">创建两个配置，一个用于内存，一个用于</st> <st c="25942">持久存储和</st> **<st c="26022">CloudKit</st>** <st c="26030">集成：</st>

[PRE18]

            <st c="26550">在我们的例子中，我们创建了两个不同的模式——一个用于头脑风暴的模型列表和一个用于</st> <st c="26666">用户项目的模型列表。</st>

            <st c="26680">基于这些模型，我们创建了两个不同的配置。</st> <st c="26744">头脑风暴配置保存在内存中，而项目配置保存在本地并同步到</st> <st c="26860">CloudKit。</st>

            <st c="26872">使用两个不同的配置和两个应用程序功能的模式是模型配置使用的绝佳例子。</st> <st c="26997">我们可以使用模型配置进行额外的自定义，例如</st> <st c="27070">以下内容：</st>

                +   <st c="27084">不同的</st> <st c="27095">存储文件</st>

                +   <st c="27106">不同的</st> <st c="27117">组容器</st>

                +   <st c="27133">不同的</st> <st c="27144">自动保存机制</st>

            <st c="27166">然而，假设我们不需要模型配置来为不同的模型组配置不同的行为</st> <st c="27260">。</st> <st c="27292">在这种情况下，我们可以直接与模型容器一起工作，并使用整个模式</st> <st c="27377">来初始化它。</st>

            <st c="27391">我们现在知道如何声明和分组我们的模型以用于模型容器中的模式。</st> <st c="27486">但还有一个关键的东西缺失——如何插入、更新和获取数据。</st> <st c="27565">我们将通过放置拼图中的缺失部分——</st> <st c="27626">上下文。</st> 来完成这些操作。

            <st c="27638">使用模型上下文获取和操作我们的数据</st>

            <st c="27693">熟悉 Core Data 的开发者也熟悉**<st c="27764">上下文</st>**<st c="27771">的概念。上下文是我们的数据</st> <st c="27793">沙盒。</st> <st c="27802">这是我们可以操作和获取数据的地方，也是我们模型和</st> <st c="27844">持久存储之间的</st> <st c="27878">链接。</st>

            <st c="27922">要访问我们的上下文以从我们的 SwiftUI 视图中获取，我们可以使用一个名为</st> <st c="28011">modelContext</st> <st c="28029">的环境变量：</st>

[PRE19]

            <st c="28114">当使用</st> `<st c="28205">modelContainer</st>` <st c="28219">修饰符设置场景时，`<st c="28119">modelContext</st>` <st c="28131">环境变量始终可用。</st>

            <st c="28229">在非 SwiftUI</st> <st c="28245">实例中，我们可以使用我们的模型容器</st> `<st c="28308">mainContext</st>` <st c="28319">属性来访问上下文：</st>

[PRE20]

            <st c="28375">为了理解</st> <st c="28390">如何与模型上下文一起工作，我们将</st> <st c="28430">从最基本的操作开始，为我们的存储保存新的对象。</st>

            <st c="28500">保存新对象</st>

            <st c="28519">在本章的开头，在</st> *<st c="28561">定义SwiftData模型</st>* <st c="28587">部分，我们了解到我们的模型只是标记有</st> `<st c="28661">@</st>``<st c="28662">Model</st>` <st c="28667">宏的Swift类。</st>

            <st c="28674">我们在SwiftData中定义模型的方式也意味着新实例的创建对我们来说非常直接</st> <st c="28686">：</st>

[PRE21]

            <st c="28845">我们的下一步是将该书籍实例添加到</st> <st c="28892">我们的上下文中：</st>

[PRE22]

            <st c="28933">添加</st> `<st c="28941">newBook</st>` <st c="28948">到模型上下文并不一定意味着它被保存到我们的持久存储中，但它确实意味着它在我们的上下文中，并且已准备好被推送到我们的存储。</st> <st c="29129">在我们的上下文中，我们可以进行更改，添加和删除信息，而无需实际将这些操作保存到我们的数据存储中。</st> <st c="29247">上下文在处理并发操作或当我们想要管理</st> <st c="29466">撤销操作时非常有用。</st>

            <st c="29482">要实际保存到持久存储，我们可以使用上下文的</st> `<st c="29548">save()</st>` <st c="29554">方法：</st>

[PRE23]

var body: some Scene {

        WindowGroup {

            ContentView()

        }

        .modelContainer(for: Book.self, <st c="29938">isAutosaveEnabled:</st>

<st c="29956">false</st>)

    }

[PRE24]

let fetchDesciprtor = <st c="31509">FetchDescriptor</st><Book>(predicate:

#Predicate { $0.name == "My Book"})

        let book = try? modelContext.fetch(fetchDesciprtor).first

[PRE25]

let fetchDesciprtor = FetchDescriptor<Book>(predicate:

#Predicate { book in

            return book.pages.count > 10

        })

[PRE26]

<st c="32813">@Query private var books: [Book]</st> var body: some View {

List {

        ForEach(books) { book in

            Text(book.name)

        }

    }

}

[PRE27]

@Query(<st c="33764">filter: #Predicate<Book> {</st>

<st c="33791">$0.pages.count > 300</st>

<st c="33887">@Query</st> 仅返回包含超过300页的书籍。

            <st c="33951">当然，我们可以通过升级在谓词内的Swift表达式来执行更复杂的查询：</st> <st c="34045">：</st>

[PRE28]

            <st c="34179">在这个例子中，我们过滤出包含超过300页的书籍，但这次，我们还想</st> <st c="34278">接收那些我们尚未阅读或标记为收藏的书籍。</st> <st c="34341">我们使用Swift表达式来过滤结果，这使得我们的查询更加描述性和强大</st> <st c="34451">，比</st> `<st c="34456">NSPredicate</st>`<st c="34467">.</st>

            <st c="34468">然而，当在列表中显示数据时，仅仅过滤是不够的；还需要对其进行排序。</st> <st c="34572">这就是我们第二个主要</st> `<st c="34606">@</st>``<st c="34607">Query</st>` <st c="34612">功能的作用。</st>

            <st c="34621">对数据进行排序</st>

            <st c="34638">排序是向用户展示信息的一个基本方面。</st> <st c="34710">我们应该记住</st> <st c="34729">排序不是一个轻量级任务；它需要一个复杂的算法才能高效完成。</st>

            <st c="34824">这就是为什么我们需要确保我们可以按符合iOS 15中引入的`<st c="34912">SortComparator</st>` <st c="34926">协议的类型属性进行排序。</st>

            <st c="34966">让我们看看我们如何对</st> <st c="34997">过滤后的书籍进行排序：</st>

[PRE29]

            <st c="35172">在这个例子中，我们传递了一个`<st c="35210">SortDescriptor</st>` <st c="35224">数组——我们首先按书名排序，然后按页数排序。</st> <st c="35291">使用`<st c="35315">SortDescriptor</st>` <st c="35329">非常简单——我们使用一个指向所需属性的键路径来初始化它，就像在先前的例子中一样。</st>

            使用SwiftData进行排序极其简单。<st c="35426">然而，在底层，它需要运行必须针对性能进行优化的算法，以便高效工作。</st> <st c="35482">当我们处理100或200条记录时，我们不需要这些优化。</st> <st c="35519">然而，当我们的数据存储包含数千条记录时，情况就不同了。</st> <st c="35607">在这些情况下，我们需要对数据进行索引。</st> <st c="35679">我们的数据。</st>

            <st c="35798">添加#Index宏以提高性能</st>

            <st c="35838">在我们对数据进行索引之前，让我们先了解一下这究竟意味着什么。</st> <st c="35912">当执行排序或查询等读取操作时，我们希望我们的应用程序能够与数千条记录无缝工作。</st> <st c="36037">显然，对整个表进行全表扫描以查找名为</st> *<st c="36098">Mastering iOS 18</st>* <st c="36114">的书籍是不高效的。</st> <st c="36131">那么我们该怎么办呢？</st> <st c="36150">就像书籍索引一样，数据库索引包含键，帮助它定位特定记录。</st> <st c="36241">例如，如果我们想对书籍的</st> `<st c="36285">name</st>` <st c="36289">属性进行索引，我们可以创建一个数据结构，如B树，它可以帮助我们根据</st> <st c="36407">其名称定位精确实例。</st>

            <st c="36416">在SwiftData中，我们不需要创建任何结构来索引我们的数据。</st> <st c="36488">我们只需要将</st> `<st c="36517">#Index</st>` <st c="36523">宏添加到</st> <st c="36533">我们的模型中：</st>

[PRE30]

            <st c="36672">如果前面的代码看起来很熟悉，那是因为我们在</st> *<st c="36803">添加 @Attribute</st>* *<st c="36825">宏</st>* <st c="36830">部分添加了</st> `<st c="36769">#Unique</st>` <st c="36776">宏到我们的模型中时，我们做了类似的事情。</st>

            <st c="36839">在这种情况下，我们决定为我们</st> <st c="36887">模型添加两个索引：</st>

                +   <st c="36897">第一个是索引名称属性，允许应用程序按名称排序记录或查询特定</st> `<st c="37008">书籍名称</st>` <st c="37095">的数据。</st>

                +   <st c="37018">第二个索引是基于</st> `<st c="37071">name</st>` <st c="37075">和</st> `<st c="37080">publicationName</st>` <st c="37095">属性的</st>

            <st c="37106">如果您还记得从</st> *<st c="37132">添加 @Attribute 宏</st>* <st c="37159">部分，我们决定这个组合定义了我们书籍的独特性。</st> <st c="37233">为这个组合创建索引可以帮助我们在需要时快速找到特定的书籍</st> <st c="37313">。</st>

            <st c="37325">索引看起来像魔法——我们向索引列表中添加另一个键路径，然后一切运行得更快。</st> <st c="37431">那么，为什么不将此应用于所有属性呢？</st> <st c="37471">有什么</st> <st c="37478">问题吗？</st>

            <st c="37488">这是因为</st> <st c="37502">索引是有代价的。</st> <st c="37531">首先，我们需要复制一些我们的数据。</st> <st c="37577">如果我们需要索引名称属性，我们需要创建一个包含所有名称的结构。</st> <st c="37675">这导致我们的应用程序需要额外的存储空间。</st> <st c="37723">但添加索引并不止于存储——它还会影响性能。</st> <st c="37800">索引不是一次性操作，因为它需要维护。</st> <st c="37866">每次</st> `<st c="37871">插入</st>`<st c="37877">、</st> `<st c="37879">更新</st>`<st c="37885">或</st> `<st c="37890">删除</st>` <st c="37896">操作都需要 SwiftData 维护索引结构，从而影响</st> <st c="37973">操作性能。</st>

            <st c="37995">总的来说，索引是 SwiftData 的一个优秀功能。</st> <st c="38047">然而，请谨慎使用，并权衡其好处与</st> <st c="38103">成本。</st>

            <st c="38113">我们到目前为止已经学到了很多东西！</st> <st c="38151">我们学习了如何定义模型、创建实例、获取它们并将它们连接到</st> <st c="38237">UI。</st>

            <st c="38244">但我们知道，维护持久存储远不止这些。</st> <st c="38263">我们的第一个应用程序版本与我们的第50个版本大不相同，这也意味着我们的数据模式将在应用程序版本的生命周期中发生变化。</st> <st c="38472">但我们已经有一个数据满载的存储库，我们应该怎么办呢？</st> <st c="38537">这就是我们下一个主题——如何执行</st> <st c="38576">数据迁移。</st>

            <st c="38591">将我们的数据迁移到新架构</st>

            <st c="38626">对于那些使用过Core Data的人来说，数据迁移不是一个奇怪的表达。</st> <st c="38710">很明显，随着我们的应用发展，我们需要更改我们的</st> <st c="38724">架构。</st>

            <st c="38777">有两种类型的迁移——</st> *<st c="38814">轻量级</st>* <st c="38825">和</st> *<st c="38830">自定义</st>* <st c="38836">迁移。</st> <st c="38848">在轻量级迁移中，我们执行不需要自定义逻辑的更改。</st> <st c="38928">例如，添加实体、属性和关系都是轻量级迁移的好例子。</st> <st c="39038">相反，更改属性类型、使属性唯一以及基于其他属性创建新属性都是自定义迁移的例子。</st> <st c="39191">现在我们知道了有哪些迁移类型，了解何时进行迁移是重要的。</st>

            <st c="39310">在我们处于开发阶段时，在我们拥有App Store上的官方版本之前，迁移是不必要的。</st> <st c="39437">我们只需要在最终用户持有</st> <st c="39494">较旧架构的版本时进行迁移。</st> <st c="39526">这也意味着，如果我们对几个版本进行架构更改，我们必须确保SwiftData知道如何在整个</st> <st c="39663">这些版本中进行迁移。</st>

            <st c="39678">现在，让我们讨论SwiftData迁移的工作原理以及基本迁移</st> <st c="39761">组件。</st>

            <st c="39776">学习基本迁移过程</st>

            <st c="39813">SwiftData迁移有三个</st> <st c="39826">主要组件：</st>

                +   `<st c="39862">版本架构</st>`<st c="39877">: 描述特定的</st> <st c="39901">架构版本</st>

                +   `<st c="39915">迁移阶段</st>`<st c="39930">: 描述同一架构版本之间的迁移过程</st>

                +   `<st c="40004">架构迁移计划</st>`<st c="40024">: 描述架构迁移阶段是基于</st> <st c="40086">迁移阶段</st>

            <st c="40102">让我们尝试描述如何使用</st> *<st c="40160">图2</st>**<st c="40168">.2</st>*<st c="40170">来展示所有事物之间的联系：</st>

            ![图2.2：三个不同版本之间的迁移过程](img/B21795_02_2.jpg)

            <st c="40295">图2.2：三个不同版本之间的迁移过程</st>

            *<st c="40359">图2</st>**<st c="40368">.2</st>* <st c="40370">展示了三个不同版本的三个不同版本架构。</st> <st c="40439">每次我们将应用程序从一个版本迁移到另一个版本时，我们都会创建一个迁移</st> <st c="40461">阶段。</st> <st c="40525">一旦我们有了各种阶段，我们就可以将它们封装成一个大的</st> <st c="40588">迁移计划。</st>

            <st c="40603">回到我们的书籍应用，让我们尝试将我们的架构迁移以支持</st> `<st c="40678">副标题</st>` <st c="40686">为我们</st> `<st c="40695">Book</st>` <st c="40699">实体。</st>

            <st c="40707">首先，我们需要创建我们的</st> <st c="40737">版本架构。</st>

            <st c="40753">创建版本架构</st>

            <st c="40779">为了将</st> <st c="40791">我们的书籍迁移到新的架构，我们需要创建两个版本架构——第一个是我们当前的架构，第二个是</st> <st c="40912">目标架构：</st>

[PRE31]

            <st c="41502">在这段代码中，我们创建了两个符合</st> `<st c="41558">VersionedSchema</st>` <st c="41573">协议的枚举。</st> <st c="41584">作为协议定义的一部分，我们需要定义版本标识符以及哪些模型</st> <st c="41677">将发生变化。</st>

            <st c="41689">在这种情况下，我们向第二个版本添加了一个新的</st> `<st c="41705">副标题</st>` <st c="41713">属性。</st> <st c="41759">我们需要更新整个应用中使用的架构，包括新的</st> <st c="41824">属性。</st>

            <st c="41842">我们的下一步是定义不同的阶段和</st> <st c="41899">迁移计划。</st>

            <st c="41914">创建迁移阶段和计划</st>

            <st c="41953">我们应该</st> <st c="41964">将版本架构视为我们迁移过程的构建块。</st> *<st c="42044">图 2</st>**<st c="42052">.2</st>* <st c="42054">显示我们根据</st> <st c="42110">版本架构创建迁移阶段。</st>

            <st c="42128">这是一个迁移阶段的示例：</st>

[PRE32]

            <st c="42285">`<st c="42290">migrateV1toV2</st>` <st c="42303">阶段处理从</st> `<st c="42337">BookSchemaV1</st>` <st c="42349">到</st> `<st c="42353">BookSchemaV2</st>`<st c="42365">的迁移。</st> 注意，这是一个轻量级迁移——我们只添加了一个属性，所以这就是我们需要创建</st> <st c="42475">阶段的所有内容。</st>

            <st c="42485">关于自定义迁移呢？</st> <st c="42517">使用自定义迁移，我们需要提供一个闭包来处理迁移阶段前后数据，在那里我们执行所有</st> <st c="42652">所需的变化。</st>

            <st c="42669">这是一个从版本 V2 到 V3 的自定义过渡示例，其中我们移除了副标题属性并将其作为</st> <st c="42806">书名的一部分：</st>

[PRE33]

            <st c="43147">正如我们可以在代码示例中看到的那样，我们的</st> `<st c="43187">willMigrate</st>` <st c="43198">闭包接收一个上下文来工作，SwiftData 在需要时执行该闭包</st> <st c="43276">。</st>

            <st c="43288">我们获取所有书籍并从书名及其副标题属性中组装一个新的名称。</st> <st c="43382">在关闭代码的末尾，我们</st> <st c="43417">调用</st> `<st c="43422">context.save()</st>`<st c="43436">。</st>

            <st c="43437">现在我们有了迁移步骤，我们可以创建我们的</st> <st c="43495">迁移计划：</st>

[PRE34]

            <st c="44174">迁移</st> <st c="44189">计划只是符合</st> `<st c="44229">SchemaMigrationPlan</st>`<st c="44248">的另一个枚举，其中静态变量描述了模式列表和阶段（不是我们之前没有</st> <st c="44340">见过的东西）。</st>

            <st c="44353">现在，我们有了迁移计划，但SwiftData不知道如何处理它。</st> <st c="44432">我们的下一步将是将迁移计划连接到我们的</st> <st c="44491">SwiftData容器。</st>

            <st c="44511">将迁移计划连接到我们的容器</st>

            <st c="44558">将</st> <st c="44570">迁移计划连接到我们的容器可能是这个过程中最直接的一步。</st>

            <st c="44662">`<st c="44667">ModelContainer</st>` <st c="44681">结构体有一个</st> `<st c="44695">migrationPlan</st>` <st c="44708">属性专门用于此，我们需要传递迁移计划</st> <st c="44780">枚举类型：</st>

[PRE35]

            <st c="44904">注意SwiftData在语言范式方面迁移的工作方式。</st> <st c="44985">我们不需要初始化任何东西，因为我们只传递模式、阶段和计划类型。</st> <st c="45079">原因是SwiftUI的工作方式——由于我们在不可变环境中工作，使用静态变量和类型而不是实例要方便得多</st> <st c="45235">。</st>

            <st c="45248">在SwiftData中迁移不是一个简单的任务。</st> <st c="45294">它涉及到遵守多个协议、维护模式版本，以及理解如何构建存储以在轻量级和</st> <st c="45442">自定义迁移之间切换。</st>

            <st c="45459">但这是因为迁移，总的来说，是一个复杂且敏感的过程。</st> <st c="45539">在事先仔细规划我们的模式看起来如何时，可以减少模式版本和阶段的数量，简化我们在考虑</st> <st c="45684">我们将在某个时候迁移我们的存储时</st> <st c="45727">的过程。</st>

            <st c="45738">摘要</st>

            <st c="45746">SwiftData对希望支持iOS 17及以上版本的iOS开发者具有重要意义，它代表了从苹果之前框架Core Data的自然演进。</st> <st c="45911">在声明式Swift环境中，SwiftData比以前更无缝地</st> <st c="45999">对齐。</st>

            <st c="46011">在本章中，我们了解了SwiftData的背景，定义了不同的SwiftData模型，创建了关系，并自定义了模型属性。</st> <st c="46173">然后我们转向容器——一个将所有内容包装在一起、执行获取和保存操作的组件。</st> <st c="46277">最后，我们使用轻量级和自定义迁移将数据从不同的模式版本迁移过来。</st> <st c="46378">在整个章节中，我们看到了Swift宏和协议的广泛使用，这些在Swift的现代世界中比Objective-C更合适。</st> <st c="46517">。</st>

            <st c="46532">这章内容很多！</st> <st c="46563">请记住，数据层是复杂的，管理和维护它需要学习很多。</st> <st c="46596">数据层是项目的一侧；当然，另一侧是UI。</st> <st c="46741">为了完整理解数据层，探索UI如何监控变化是至关重要的。</st> <st c="46848">这就是为什么我们即将到来的章节将专注于</st> <st c="46902">观察框架。</st>

[PRE36]

[PRE37]
