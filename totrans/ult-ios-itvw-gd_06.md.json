["```swift\nclass Employee {  var name: String\n  var salary: Double\n  // responsibility 1: store employee data\n  init(name: String, salary: Double{\n    self.name = name\n    self.salary = salary\n  }\n  // responsibility 2: calculate payroll\n  func calculatePayroll() -> Double {\n  }\n}\n```", "```swift\nfunc sendPersonToServer(name: String, age: Int, email:     String, phone: String, address: String) {\n}\n```", "```swift\nstruct Person {    let name: String\n    let age: Int\n    let email: String\n    let phone: String\n    let address: String\n}\nfunc sendPersonToServer(person: Person) {\n}\n```", "```swift\nstruct A {    var name: String\n}\nvar a = A(name: \"Avi\")\nlet b = a\na.name = \"John\"\nprint(b)\n      print(a)\n```", "```swift\nstruct A {    var name: String\n}\nlet a = A(name: \"Avi\")\na.name = \"John\"\n```", "```swift\nclass A {    var name: String\n    init(name: String) {\n        self.name = name\n    }\n}\nlet a = A(name: \"Avi\")\na.name = \"John\"\n```", "```swift\nlet arrayWithDuplicates = [1, 2, 3, 3, 4, 5, 5]let arrayWithNoDuplicates = Array(Set(arrayWithDuplicates))\n```", "```swift\nvar newArray: [Int] = []for number in array {\n    if ! newArray.contains(number) {\n        newArray.append(number)\n   }\n}\n```", "```swift\nvar newArray: [Int] = []var newAddedItems = Set<Int>()\nfor number in array {\n    if ! newAddedItems.contains(number) {\n        newArray.append(number)\n        newAddedItems.insert(number)\n    }\n}\n```", "```swift\nlet numbers = [1, 2, 3, 3, 4, 5, 5]let uniqueNumbers = numbers.filter { number in\n    numbers.firstIndex(of: number) == numbers.lastIndex\n        (of: number)\n}\n```", "```swift\nstruct Queue<Element> {    private var array: [Element] = []\n    var isEmpty: Bool {\n        return array.isEmpty\n    }\n    var count: Int {\n        return array.count\n    }\n    mutating func enqueue(_ element: Element) {\n        array.append(element)\n    }\n    mutating func dequeue() -> Element? {\n        return array.isEmpty ? nil : array.removeFirst()\n    }\n}\n```", "```swift\nlet array = [1, 2, 3, 4, 5]let doubledArray = array.map { element in return element * 2\n}\n```", "```swift\nlet doubledArray = array.map { $0 * 2 }\n```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int\n    var address: String\n}\nlet person = Person(name: \"John\", age: 30, address: \"123 Main St.\")\nlet encoder = JSONEncoder()\nlet data = try encoder.encode(person)\nlet decoder = JSONDecoder()\nlet person = try decoder.decode(Person.self, from: data)\n```", "```swift\nPerson has three properties from the String and Int types. String and Int already conform to Codable, so we don’t need to do anything else. However, if we want to add additional custom properties, we need to make sure they conform to Codable as well.\n```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int\n    var address: String\n    var children: [Child]\n}\nstruct Child: Codable {\n    var name: String\n    var age: Int\n}\n```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int?\n    var address: String?\n}\n```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int\n    var address: String\n    enum CodingKeys: String, CodingKey {\n        case name = \"full_name\"\n        case age\n        case address\n    }\n}\nPerson struct has a name property, but that property is now mapped to a full_name key that will appear in the JSON.\n```", "```swift\n{  \"full_name\": \"Avi Tsadok\",\n  \"age\": 42,\n  \"address\": \"Hamargalit Street\n}\n```", "```swift\nstruct Person: Codable {    var name: String\n    var age: Int\n    var address: Address\n    var birthday: Date\n    enum CodingKeys: String, CodingKey {\n        case name\n        case age\n        case address\n        case birthday\n    }\n    enum Address: String, Codable {\n        case home\n        case work\n    }\n```", "```swift\ninit(from decoder: Decoder) throws {    let container = try decoder.container(keyedBy:CodingKeys.self)\n    name = try container.decode(String.self,forKey: .name)\n    age = try container.decode(Int.self, forKey: .age)\n    address = try container.decode(Address.self,forKey: .address)\n    // Decode birthday using a custom date formatter\n    let dateFormatter = DateFormatter()dateFormatter.dateFormat = \n    \"yyyy-MM-dd\"\n    if let birthdayString = try? container.decode(String.self, forKey: \n    .birthday) {\n        birthday = dateFormatter.date(from:birthdayString) ?? Date()\n        } else {\n        birthday = Date\n```", "```swift\nclass Configuration {    static let shared = Configuration()\n    private var values: [String: Any] = [:]\n    func setValue(_ value: Any, forKey key: String) {\n        values[key] = value\n    }\n    func value(forKey key: String) -> Any? {\n        return values[key]\n    }\n}\n// Setting configuration values\nConfiguration.shared.setValue(\"Dark\", forKey: \"theme\")\nConfiguration.shared.setValue(true, forKey: \"enable_notifications\")\n```", "```swift\nvar wordFrequencies: [String: Int] = [\"apple\": 4,     \"banana\": 3, \"cherry\": 2, \"date\": 1]\nvar highFrequencyWords: [String: Int] = [:]\nfor (word, frequency) in wordFrequencies {\n    if frequency >= 3 {\n        highFrequencyWords[word] = frequency\n    }\n}\nprint(highFrequencyWords)  // prints [\"apple\": 4, \"banana\": 3]\n```", "```swift\nfor (key, value) in dictionary {  // code to be executed for each key-value pair\n}\n```", "```swift\nlet wordFrequencies: [String: Int] = [\"apple\": 4,    \"banana\": 3, \"cherry\": 2, \"date\": 1]\nlet highFrequencyWords = wordFrequencies.filter { $0.value >= 3 }\nprint(highFrequencyWords)  // prints [\"apple\": 4, \"banana\": 3]\n```", "```swift\nvar wordFrequencies: [String: Int] = [\"apple\": 4,    \"banana\": 3, \"cherry\": 2, \"date\": 1]\nvar highFrequencyWords: [String: Int] = [:]\nfor (word, frequency) in wordFrequencies {\n    if frequency >= 3 {\n        highFrequencyWords[word] = frequency\n    }\n}\nprint(aWords)  // prints [\"apple\": 4]\n```", "```swift\nstruct Person: Hashable {    var age: Int\n    func hash(into hasher: inout Hasher) {\n        hasher.combine(age)\n    }\n}\nlet newSet: Set<Person> = [Person(age: 21),\n    Person(age: 35), Person(age: 49)]\n```"]