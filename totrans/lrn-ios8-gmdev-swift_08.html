<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;SceneKit"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. SceneKit</h1></div></div></div><p>So, this is it! Finally, we move from the 2D world to 3D. With SceneKit, we can make 3D games quite easily, especially since the syntax for SceneKit is quite similar to SpriteKit.</p><p>When we say 3D games, we don't mean that you get to put on your 3D glasses to make the game. In 2D games, we mostly work in the x and y coordinates. In 3D games, we deal with all three axes <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span>.</p><p>Additionally, in 3D games, we have different types of lights that we can use. Also, SceneKit has an inbuilt physics engine that will take care of forces such as gravity and will also aid collision detection.</p><p>We can also use SpriteKit in SceneKit for GUI and buttons so that we can add scores and interactivity to the game. So, there is a lot to cover in this chapter. Let's get started.</p><p>The topics covered in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a scene with SCNScene</li><li class="listitem" style="list-style-type: disc">Adding objects to a scene</li><li class="listitem" style="list-style-type: disc">Importing scenes from external 3D applications</li><li class="listitem" style="list-style-type: disc">Adding physics to the scene</li><li class="listitem" style="list-style-type: disc">Adding an enemy</li><li class="listitem" style="list-style-type: disc">Checking collision detection</li><li class="listitem" style="list-style-type: disc">Adding a SpriteKit overlay</li><li class="listitem" style="list-style-type: disc">Adding touch interactivity</li><li class="listitem" style="list-style-type: disc">Finishing the gameloop</li><li class="listitem" style="list-style-type: disc">Adding wall and floor parallax</li><li class="listitem" style="list-style-type: disc">Adding particles</li></ul></div><div class="section" title="Creating a scene with SCNScene"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Creating a scene with SCNScene</h1></div></div></div><p>First, we create a new<a id="id592" class="indexterm"/> SceneKit project. It is very similar to creating other <a id="id593" class="indexterm"/>projects. Only this time, make sure you select SceneKit from the <span class="strong"><strong>Game Technology</strong></span> drop-down list. Don't forget to select <span class="strong"><strong>Swift</strong></span> for the language field. Choose <span class="strong"><strong>iPad</strong></span> as the device and click on <span class="strong"><strong>Next</strong></span> to create the project in the selected directory, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_08_01.jpg" alt="Creating a scene with SCNScene"/></div><p>Once the project is created, open it. Click on the <code class="literal">GameViewController</code> class, and delete all the contents in the <code class="literal">viewDidLoad</code> function, delete the <code class="literal">handleTap</code> function, as we will be creating a separate class, and add touch behavior.</p><p>Create a new class called <code class="literal">GameSCNScene</code> and import the following headers. Inherit from the <code class="literal">SCNScene</code> class and add an <code class="literal">init</code> function that takes in a parameter called view of type <code class="literal">SCNView</code>:</p><div class="informalexample"><pre class="programlisting">import Foundation
import UIKit
import SceneKit

class GameSCNScene: SCNScene{

    let scnView: SCNView!
    let _size:CGSize!
    var scene: SCNScene!
    
        required init(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    init(currentview view: SCNView) {
        
        super.init()
    }
}</pre></div><p>Also, create two new <a id="id594" class="indexterm"/>constants <code class="literal">scnView</code> and <code class="literal">_size </code>of type <code class="literal">SCNView</code> <a id="id595" class="indexterm"/>and <code class="literal">CGSize</code>, respectively. Also, add a variable called <code class="literal">scene</code> of type <code class="literal">SCNScene</code>.</p><p>Since we are making a SceneKit game, we have to get the current view, which is the type <code class="literal">SCNView</code>, similar to how we got the view in SpriteKit where we typecasted the current view in SpriteKit to <code class="literal">SKView</code>.</p><p>We create a <code class="literal">_size</code> constant to get the current size of the view. We then create a new variable <code class="literal">scene</code> of type <code class="literal">SCNScene</code>. <code class="literal">SCNScene</code> is the class used to make scenes in SceneKit, similar to how we would use <code class="literal">SKScene</code> to create scenes in SpriteKit.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip11"/>Tip</h3><p>Swift would automatically ask to create the <code class="literal">required init</code> function, so we might as well include it in the class.</p></div></div><p>Now, move to the <code class="literal">GameViewController</code> class and create a global variable called <code class="literal">gameSCNScene</code> of type <code class="literal">GameSCNScene</code> and assign it in the <code class="literal">viewDidLoad</code> function, as follows:</p><div class="informalexample"><pre class="programlisting">class GameViewController: UIViewController {
  
  var gameSCNScene:GameSCNScene!
  
    override func viewDidLoad() {
      super.viewDidLoad()
      let scnView = view as SCNView
      gameSCNScene = GameSCNScene(currentview: scnView)
    }
}// UIViewController Class</pre></div><p>Great! Now we can add objects in the <code class="literal">GameSCNScene</code> class. It is better to move all the code to a single class so that we can keep the <code class="literal">GameSceneController</code> class clean.</p><p>In the <code class="literal">init</code> function of <code class="literal">GameSCNScene</code>, add the following after the <code class="literal">super.init</code> function:</p><div class="informalexample"><pre class="programlisting">scnView = view
_size = scnView.bounds.size                       

// retrieve the SCNView
scene = SCNScene()
scnView.scene = scene
scnView.allowsCameraControl = true
scnView.showsStatistics = true
scnView.backgroundColor = UIColor.yellowColor() </pre></div><p>Here, we first assign the <a id="id596" class="indexterm"/>current view to the <code class="literal">scnView</code> constant. Next, we<a id="id597" class="indexterm"/> set the <code class="literal">_size</code> constant to the dimensions of the current view.</p><p>Next we initialize the scene variable. Then, assign the scene to the scene of <code class="literal">scnView</code>. Next, enable <code class="literal">allowCameraControls</code> and <code class="literal">showStatistics</code>. This will enable us to control the camera and move it around to have a better look at the scene. Also, with statistics enabled, we will see the performance of the game to make sure that the FPS is maintained.</p><p>The <code class="literal">backgroundColor</code> property of <code class="literal">scnView</code> enables us to set the color of the view. I have set it to yellow so that objects are easily visible in the scene, as shown in the following screenshot. With all this set we can run the scene.</p><div class="mediaobject"><img src="graphics/B04014_08_02.jpg" alt="Creating a scene with SCNScene"/></div><p>Well, it is not all that <a id="id598" class="indexterm"/>awesome yet. One thing to notice is that we have still <a id="id599" class="indexterm"/>not added a camera or a light, but we still see the yellow scene. This is because while we have not added anything to the scene yet, SceneKit automatically provides a default light and camera for the scene created.</p></div></div>
<div class="section" title="Adding objects to the scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Adding objects to the scene</h1></div></div></div><p>Let us next add <a id="id600" class="indexterm"/>geometry to the scene. We can create some basic geometry <a id="id601" class="indexterm"/>such as spheres, boxes, cones, tori, and so on in SceneKit with ease. Let us create a sphere first and add it to the scene.</p><div class="section" title="Adding a sphere to the scene"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec69"/>Adding a sphere to the scene</h2></div></div></div><p>Create a function <a id="id602" class="indexterm"/>called <code class="literal">addGeometryNode</code> in the class and add the following <a id="id603" class="indexterm"/>code in it:</p><div class="informalexample"><pre class="programlisting">func addGeometryNode(){

   let sphereGeometry = SCNSphere(radius: 1.0)
   sphereGeometry.firstMaterial?.diffuse.contents = UIColor.orangeColor()
        
   let sphereNode = SCNNode(geometry: sphereGeometry)
   sphereNode.position = SCNVector3Make(0.0, 0.0, 0.0)
   scene.rootNode.addChildNode(sphereNode)        
}</pre></div><p>For creating geometry, we use the <code class="literal">SCNSphere</code> class to create a sphere shape. We can also call <code class="literal">SCNBox</code>, <code class="literal">SCNCone</code>, <code class="literal">SCNTorus</code>, and so on to create box, cone, or torus shapes respectively.</p><p>While creating the sphere, we have to provide the radius as a parameter, which will determine the size of the sphere. Although to place the shape, we have to attach it to a node so that we can place and add it to the scene.</p><p>So, create a new constant called <code class="literal">sphereNode</code> of type <code class="literal">SCNNode</code> and pass in the sphere geometry as a parameter. For positioning the node, we have to use the <code class="literal">SCNvector3Make</code> property to place our object in 3D space by providing the values for <code class="literal">x</code>, <code class="literal">y</code>, and <code class="literal">z</code>.</p><p>Finally, to add the <a id="id604" class="indexterm"/>node to the scene, we have to call <code class="literal">scene.rootNode</code> to add<a id="id605" class="indexterm"/> the <code class="literal">sphereNode</code> to scene, unlike SpriteKit where we would simply use <code class="literal">addChild</code> to add objects to the scene.</p><p>With the sphere added, let us run the scene. Don't forget to add <code class="literal">self.addGeometryNode()</code> in the <code class="literal">init</code> function.</p><p>We did add a sphere, so why are we getting a circle (shown in the following screenshot)? Well, the basic light source used by SceneKit just enables to us to see objects in the scene. If we want to see the actual sphere, we have to improve the light source of the scene.</p><div class="mediaobject"><img src="graphics/B04014_08_03.jpg" alt="Adding a sphere to the scene"/></div></div><div class="section" title="Adding light sources"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec70"/>Adding light sources</h2></div></div></div><p>Let us create a new<a id="id606" class="indexterm"/> function called <code class="literal">addLightSourceNode</code> as<a id="id607" class="indexterm"/> follows so that we can add custom lights to our scene:</p><div class="informalexample"><pre class="programlisting">func addLightSourceNode(){
        
    let lightNode = SCNNode()
    lightNode.light = SCNLight()
    lightNode.light!.type = SCNLightTypeOmni
    lightNode.position = SCNVector3(x: 10, y: 10, z: 10)
    scene.rootNode.addChildNode(lightNode)
        
    let ambientLightNode = SCNNode()
    ambientLightNode.light = SCNLight()
    ambientLightNode.light!.type = SCNLightTypeAmbient
    ambientLightNode.light!.color = UIColor.darkGrayColor()
    scene.rootNode.addChildNode(ambientLightNode)
}</pre></div><p>We can add some light sources to see some depth in our sphere object. Here we add two types of light source. The first is an omni light. Omni lights start at a point and then the light is scattered equally in all directions. We also add an ambient light source. An ambient light is the light that is reflected by other objects, such as moonlight.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>There are two more types of light sources: directional and spotlight. Spotlight is easy to understand, and we usually use it if a certain object needs to be brought to attention like a singer on a stage. Directional lights are used if you want light to go in a single direction, such as sunlight. The Sun is so far from the Earth that the light rays are almost parallel to each other when we see them.</p></div></div><p>For creating a light<a id="id608" class="indexterm"/> source, we create a node called <code class="literal">lightNode</code> of type <code class="literal">SCNNode</code>. We<a id="id609" class="indexterm"/> then assign <code class="literal">SCNLight</code> to the light property of <code class="literal">lightNode</code>. We assign the omni light type to be the type of the light. We assign position of the light source to be at 10 in all three <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="emphasis"><em>z</em></span> coordinates. Then, we add it to the rootnode of the scene.</p><p>Next we add an ambient light to the scene. The first two steps of the process are the same as for creating any light source:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">For the type of light we have to assign <code class="literal">SCNLightTypeAmbient</code> to assign an ambient type light source. Since we don't want the light source to be very strong, as it is reflected, we assign a <code class="literal">darkGrayColor</code> to the color.</li><li class="listitem">Finally, we add the light source to the scene.</li></ol></div><p>There is no need to add the ambient light source to the scene but it will make the scene have softer shadows. You can remove the ambient light source to see the difference.</p><p>Call the <code class="literal">addLightSourceNode</code> function in the <code class="literal">init</code> function. Now, build and run the scene to see an actual sphere with proper lighting, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_08_04.jpg" alt="Adding light sources"/></div><p>You can place a<a id="id610" class="indexterm"/> finger on the screen and move it to rotate the cameras as<a id="id611" class="indexterm"/> we have enabled camera control. You can use two fingers to pan the camera and you can double tap to reset the camera to its original position and direction.</p></div><div class="section" title="Adding a camera to the scene"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec71"/>Adding a camera to the scene</h2></div></div></div><p>Next let us add a <a id="id612" class="indexterm"/>camera to the scene, as the default camera is very close. Create a<a id="id613" class="indexterm"/> new function called <code class="literal">addCameraNode</code> to the class and add the following code in it:</p><div class="informalexample"><pre class="programlisting">func addCameraNode(){
        
 let cameraNode = SCNNode()
    cameraNode.camera = SCNCamera()
    cameraNode.position = SCNVector3(x: 0, y: 0, z: 15)
    scene.rootNode.addChildNode(cameraNode)        
}</pre></div><p>Here, again we create an empty node called <code class="literal">cameraNode</code>. We assign <code class="literal">SCNCamera</code> to the camera property of <code class="literal">cameraNode</code>. Next we position the camera such that we keep the <code class="literal">x</code> and <code class="literal">y</code> values at zero and move the camera back in the <code class="literal">z</code> direction by 15 units. Then we add the camera to the rootnode of the scene. Call the <code class="literal">addCameraNode</code> at the bottom of the <code class="literal">init</code> function.</p><p>In this scene, the origin <a id="id614" class="indexterm"/>is at the center of the scene, unlike SpriteKit where the origin of a <a id="id615" class="indexterm"/>scene is always at bottom right of the scene. Here the positive <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> are to the right and up from the center. The positive <span class="emphasis"><em>z</em></span> direction is toward you.</p><div class="mediaobject"><img src="graphics/B04014_08_05.jpg" alt="Adding a camera to the scene"/></div><p>We didn't move the sphere back or reduce its size here. This is purely because we brought the camera backward in the scene.</p><p>Let us next create a floor so that we can have a better understanding of the depth in the scene. Also, in this way, we will learn how to create floors in the scene.</p></div><div class="section" title="Adding a floor"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec72"/>Adding a floor</h2></div></div></div><p>In the class, add<a id="id616" class="indexterm"/> a new function called <code class="literal">addFloorNode</code> and add the following<a id="id617" class="indexterm"/> code:</p><div class="informalexample"><pre class="programlisting">func addFloorNode(){
             
     var floorNode = SCNNode()
     floorNode.geometry = SCNFloor()
     floorNode.position.y = -1.0
     scene.rootNode.addChildNode(floorNode)
}</pre></div><p>For creating a floor, we create a variable called <code class="literal">floorNode</code> of type <code class="literal">SCNNode</code>. We then assign <code class="literal">SCNFloor</code> to the geometry property of <code class="literal">floorNode</code>. For the position, we assign the <code class="literal">y</code> value to <code class="literal">-1</code> as we want the sphere to appear above the floor. At the end, as usual, we assign the <code class="literal">floorNode</code> to the root node of the scene.</p><p>In the following screenshot, I have rotated the camera to show the scene in full action. Here we can see the floor is gray in color and the sphere is casting its reflection on the floor, and we can also see the bright omni light at the top left of the sphere.</p><div class="mediaobject"><img src="graphics/B04014_08_06.jpg" alt="Adding a floor"/></div></div></div>
<div class="section" title="Importing scenes from external 3D applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec74"/>Importing scenes from external 3D applications</h1></div></div></div><p>Although we can add<a id="id618" class="indexterm"/> objects, cameras, and lights through<a id="id619" class="indexterm"/> code, it will become very tedious and confusing when we have a lot of objects added to the scene. In SceneKit, this problem can be easily overcome by importing scenes prebuilt in other 3D applications.</p><p>All 3D applications such as 3D StudioMax, Maya, Cheetah 3D, and Blender have the ability to export scenes in Collada (<code class="literal">.dae</code>) and Alembic (<code class="literal">.abc</code>) format. We can import these scenes with lighting, camera, and textured objects into SceneKit directly, without the need for setting up the scene.</p><p>In this section, we will import a Collada file into the scene. In the resources folder for this chapter, you will find the <code class="literal">monsterScene.DAE</code> file. Drag this file into the current project.</p><div class="mediaobject"><img src="graphics/B04014_08_07.jpg" alt="Importing scenes from external 3D applications"/></div><p>Along with the <a id="id620" class="indexterm"/>DAE file, also add the <code class="literal">monster.png</code> file<a id="id621" class="indexterm"/> to the project, otherwise you will see only the untextured monster mesh in the scene.</p><p>Click on the <code class="literal">monsterScene.DAE</code> file. If the textured monster is not automatically loaded, drag the <code class="literal">monster.png</code> file from the project into the monster mesh in the preview window. Release the mouse button once you see a (<span class="strong"><strong>+</strong></span>) sign while over the monster mesh. Now you will be able to see the monster properly textured.</p><p>The panel on the left shows the entities in the scene. Below the entities, the scene graph is shown and the view on the right is the preview pane.</p><p>Entities show all the objects in the scene and the scene graph shows the relation between these entities. If you have certain objects that are children to other objects, the scene graph will show them as a tree. For example, if you open the triangle next to <span class="strong"><strong>CATRigHub001</strong></span>, you will see all the child objects under it.</p><p>You can use the scene graph to move and rotate objects in the scene to fine-tune your scene. You can also add nodes, which can be accessed by code. You can see that we already have a camera and a spotlight in the scene. You can select each object and move it around using the arrow at the pivot point of the object.</p><p>You can also rotate the scene to get a better view by clicking and dragging the left mouse button on the preview scene. For zooming, scroll your mouse wheel up and down. To pan, hold the <span class="emphasis"><em>Alt</em></span> button on the keyboard and left-click and drag on the preview pane.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>One thing to note is that rotating, zooming, and panning in the preview pane won't actually move your camera. The camera is still at the same position and angle. To view from the camera, again select the <span class="strong"><strong>Camera001</strong></span> option from the drop-down list in the preview pane and the view will reset to the camera view.</p></div></div><p>At the bottom of the <a id="id622" class="indexterm"/>preview window, we can either <a id="id623" class="indexterm"/>choose to see the view through the camera or spotlight, or click-and-drag to rotate the free camera. If you have more than one camera in your scene, then you will have <span class="strong"><strong>Camera002</strong></span>, <span class="strong"><strong>Camera003</strong></span>, and so on in the drop-down list.</p><p>Below the view selection dropdown in the preview panel you also have a play button. If you click on the play button, you can look at the default animation of the monster getting played in the preview window.</p><p>The preview panel is just that; it is just to aid you in having a better understanding of the objects in the scene. In no way is it a replacement for a regular 3D package such as 3DSMax, Maya, or Blender.</p><p>You can create cameras, lights, and empty nodes in the scene graph, <span class="emphasis"><em>but you can't add geometry such as boxes and spheres</em></span>. You can add an empty node and position it in the scene graph, and then add geometry in code and attach it to the node.</p><p>Now that we have an understanding of the scene graph, let us see how we can run this scene in SceneKit.</p><p>In the <code class="literal">init</code> function, delete the line where we initialized the scene and add the following line instead. Also delete the objects, light, and camera we added earlier.</p><div class="informalexample"><pre class="programlisting"> 
 init(currentview view:SCNView){
    
super.init()
    scnView = view
    _size = scnView.bounds.size
    
    //retrieve the SCNView
    //scene = SCNScene()
   
 scene = SCNScene(named: "monsterScene.DAE")
    
    scnView.scene = scene
    scnView.allowsCameraControl  = true
    scnView.showsStatistics = true
    scnView.backgroundColor = UIColor.yellowColor()
    
//    self.addGeometryNode()
//    self.addLightSourceNode()
//    self.addCameraNode()
//    self.addFloorNode()
//    
  
}</pre></div><p>Build and run the<a id="id624" class="indexterm"/> game to see the following <a id="id625" class="indexterm"/>screenshot:</p><div class="mediaobject"><img src="graphics/B04014_08_08.jpg" alt="Importing scenes from external 3D applications"/></div><p>You will see the monster running and the yellow background that we initially assigned to the scene. While exporting the scene, if you export the animations as well, once the scene loads in SceneKit the animation starts playing automatically.</p><p>Also, you will <a id="id626" class="indexterm"/>notice that we have deleted the <a id="id627" class="indexterm"/>camera and light in the scene. So, how come the default camera and the light aren't loaded in the scene?</p><p>What is happening here is that while I exported the file, I inserted a camera in the scene and also added a spotlight. So, when we imported the file into the scene, SceneKit automatically understood that there is a camera already present, so it will use the camera as its default camera. Similarly, a spotlight is already added in the scene, which is taken as the default light source, and lighting is calculated accordingly.</p></div>
<div class="section" title="Adding objects and physics to the scene"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec75"/>Adding objects and physics to the scene</h1></div></div></div><p>Let us now see <a id="id628" class="indexterm"/>how we can access each of the objects in the scene graph <a id="id629" class="indexterm"/>and add gravity to the monster. Later in this chapter, we will <a id="id630" class="indexterm"/>see how we can add a touch interface by which we will<a id="id631" class="indexterm"/> be able to make the hero character jump by applying an upward force.</p><div class="section" title="Accessing the hero object and adding a physics body"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec73"/>Accessing the hero object and adding a physics body</h2></div></div></div><p>So, create a new<a id="id632" class="indexterm"/> function called <code class="literal">addColladaObjects</code> and call an <code class="literal">addHero</code> function in it. Create <a id="id633" class="indexterm"/>a global variable called <code class="literal">heroNode</code> of type <code class="literal">SCNNode</code>. We will use this node to access the hero object in the scene. In <a id="id634" class="indexterm"/>the <code class="literal">addHero</code> function, add the following code:</p><div class="informalexample"><pre class="programlisting">init(currentview view:SCNView){
    super.init()
    scnView = view
    _size = scnView.bounds.size
    
    //retrieve the SCNView
    //scene = SCNScene()
    scene = SCNScene(named: "monster.scnassets/monsterScene.DAE")
    
    scnView.scene = scene
    scnView.allowsCameraControl  = true
    scnView.showsStatistics = true
    scnView.backgroundColor = UIColor.yellowColor()
    
    <span class="strong"><strong>self.addColladaObjects()</strong></span>
    
//    self.addGeometryNode()  
//    self.addLightSourceNode()
//    self.addCameraNode()
//    self.addFloorNode()
    
  }

func addHero(){

    heroNode = SCNNode()
        
 var monsterNode = scene.rootNode.childNodeWithName(
 "CATRigHub001", recursively: false)
    heroNode.addChildNode(monsterNode!) 
 heroNode.position = SCNVector3Make(0, 0, 0)               
    
    let collisionBox = SCNBox(width: 10.0, height: 10.0,
           length: 10.0, chamferRadius: 0)

    heroNode.physicsBody?.physicsShape = 
SCNPhysicsShape(geometry: collisionBox, options: nil)
    
 heroNode.physicsBody = SCNPhysicsBody.dynamicBody()    
    heroNode.physicsBody?.mass = 20
    heroNode.physicsBody?.angularVelocityFactor = SCNVector3Zero 
 heroNode.name = "hero"
        
    scene.rootNode.addChildNode(heroNode)
}</pre></div><p>First, we <a id="id635" class="indexterm"/>call the <code class="literal">addColladaObjects</code> function in the <code class="literal">init</code> function, as<a id="id636" class="indexterm"/> highlighted. Then we create the <code class="literal">addHero</code> function. In it we <a id="id637" class="indexterm"/>initiate the <code class="literal">heroNode</code>. Then, to actually move the monster, we need access to the <code class="literal">CatRibHub001</code> node to move the monster. We gain access to it through the <code class="literal">ChildWithName</code> property of <code class="literal">scene.rootNode</code>. For each object that we wish to gain access to through code, we will have to use the <code class="literal">ChildWithName</code> property of the <code class="literal">rootNode</code> of the scene and pass in the name of the object.</p><p>If recursively is <a id="id638" class="indexterm"/>set to <code class="literal">true</code>, to get said object, SceneKit will go <a id="id639" class="indexterm"/>through all the child nodes to get access to the specific <a id="id640" class="indexterm"/>node. Since the node that we are looking for is right on top, we said <code class="literal">false</code> to save processing time.</p><p>We create a temporary variable called <code class="literal">monsterNode</code>. In the next step, we add the <code class="literal">monsterNode</code> variable to <code class="literal">heroNode</code>. We then set the position of the hero node to the origin.</p><p>For <code class="literal">heroNode</code> to interact with other physics bodies in the scene, we have to assign a shape to the physics body of <code class="literal">heroNode</code>. We could use the mesh of the monster, but the shape might not be calculated properly and a box is a much simpler shape than the mesh of the monster. For creating a box collider, we create a new box geometry roughly the width, height, and depth of the monster.</p><p>Then, using the <code class="literal">physicsBody.physicsShape</code> property of the <code class="literal">heroNode</code>, we assign the shape of the <code class="literal">collisionBox</code> we created for it. Since we want the body to be affected by gravity, we assign the physics body type to be dynamic. Later we will see other body types.</p><p>Since we want the body to be highly responsive to gravity, we assign a value of <code class="literal">20</code> to the <code class="literal">mass</code> of the body. In the next step, we set the <code class="literal">angularVelocityFactor</code> to <code class="literal">0</code> in all three directions, as we want the body to move straight up and down when a vertical force is applied. If we don't do this, the body will flip-flop around.</p><p>We also assign the name <code class="literal">hero</code> to the monster to check if the collided object is the hero or not. This will come in handy when we check for collision with other objects.</p><p>Finally, we add <code class="literal">heroNode</code> to the scene.</p><p>Add the <code class="literal">addColladaObjects</code> to the <code class="literal">init</code> function and comment or delete the <code class="literal">self.addGeometryNode</code>, <code class="literal">self.addLightSourceNode</code>, <code class="literal">self.addCameraNode</code>, and <code class="literal">self.addFloorNode</code> functions if you haven't already. Then, run the game to see the monster slowly falling through.</p><p>We will create a small patch of ground right underneath the monster so that it doesn't fall down.</p></div><div class="section" title="Adding the ground"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/>Adding the ground</h2></div></div></div><p>Create a new <a id="id641" class="indexterm"/>function<a id="id642" class="indexterm"/> called <code class="literal">addGround</code> and add the following:</p><div class="informalexample"><pre class="programlisting">func addGround(){
        
    let groundBox = SCNBox(width: 10, height: 2,
                           length: 10, chamferRadius: 0)

    let groundNode = SCNNode(geometry: groundBox)
        
    groundNode.position = SCNVector3Make(0, -1.01, 0)
    groundNode.physicsBody = SCNPhysicsBody.staticBody()
    groundNode.physicsBody?.restitution = 0.0

    scene.rootNode.addChildNode(groundNode)
}</pre></div><p>We create a new constant called <code class="literal">groundBox</code> of type <code class="literal">SCNBox,</code> with a width and length of <code class="literal">10</code>, and height of <code class="literal">2</code>. Chamfer is the rounding of the edges of the box. Since we didn't want any rounding of the corners, it is set to <code class="literal">0</code>.</p><p>Next we create a <code class="literal">SCNNode</code> called <code class="literal">groundNode</code> and assign <code class="literal">groundBox</code> to it. We place it slightly below the origin. Since the height of the box is <code class="literal">2</code>, we place it at <code class="literal">–1.01</code> so that <code class="literal">heroNode</code> will be <code class="literal">(0, 0, 0)</code> when the monster rests on the ground.</p><p>Next we assign the physics body of type static body. Also, since we don't want the hero to bounce off the ground when he falls on it, we set the restitution to <code class="literal">0</code>. Finally, we then add the ground to the scene's rootnode.</p><p>The reason we made this body static instead of dynamic is because a dynamic body gets affected by gravity and other forces but a static one doesn't. So, in this scene, even though gravity is acting downward, the hero will fall but <code class="literal">groundBox</code> won't as it is a static body.</p><p>You will see that the physics syntax is very similar to SpriteKit with static bodies and dynamic bodies, gravity, and so on. And once again, similar to SpriteKit, the physics simulation is automatically turned on when we run the scene.</p><p>Add the <code class="literal">addGround</code> function in the <code class="literal">addColladaObjects</code> functions and run the game to see the monster getting affected by gravity and stopping after coming in touch with the ground.</p><div class="mediaobject"><img src="graphics/B04014_08_09.jpg" alt="Adding the ground"/></div></div></div>
<div class="section" title="Adding an enemy node"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec76"/>Adding an enemy node</h1></div></div></div><p>To check collision<a id="id643" class="indexterm"/> in SceneKit, we can check for collision between the hero and the ground. But let us make it a little more interesting and also learn a new kind of body type: the kinematic body.</p><p>For this, we will create a new box called <code class="literal">enemy</code> and make it move and collide with the hero. Create a new global <code class="literal">SCNNode</code> called <code class="literal">enemyNode</code> as follows:</p><div class="informalexample"><pre class="programlisting">  let scnView: SCNView!
  let _size:CGSize!
  var scene: SCNScene!
  var heroNode:SCNNode!
  <span class="strong"><strong>var enemyNode:SCNNode!</strong></span>
</pre></div><p>Also, create a new function called <code class="literal">addEnemy</code> to the class and add the following in it:</p><div class="informalexample"><pre class="programlisting">func addEnemy(){
        
    let geo = SCNBox(width: 4.0,
  height: 4.0,
  length: 4.0,
  chamferRadius: 0.0)
        
    geo.firstMaterial?.diffuse.contents = UIColor.yellowColor()
        
    enemyNode = SCNNode(geometry: geo)
    enemyNode.position = SCNVector3Make(0, 20.0 , 60.0)
    enemyNode.physicsBody = SCNPhysicsBody.kinematicBody()
    scene.rootNode.addChildNode(enemyNode)
        
    enemyNode.name = "enemy"
}</pre></div><p>Nothing too fancy here! <a id="id644" class="indexterm"/>Just as when adding the <code class="literal">groundNode</code>, we have created a cube with all its sides four units long. We have also added a yellow color to its material. We then initialize <code class="literal">enemyNode</code> in the function. We position the node along the <span class="emphasis"><em>x</em></span>, <span class="emphasis"><em>y</em></span>, and <span class="strong"><strong>z</strong></span> axes. Assign the body type as kinematic instead of static or dynamic. Then we add the body to the scene and finally name the <code class="literal">enemyNode</code> as <code class="literal">enemy</code>, which we will be needing while checking for collision. Before we forget, call the <code class="literal">addEnemy</code> function in the <code class="literal">addColladaObjects</code> function after where we called the <code class="literal">addHero</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The difference between the kinematic body and other body types is that, like static, external forces cannot act on the body, but we can apply a force to a kinematic body to move it.</p></div></div><p>In the case of a static body, we saw that it is not affected by gravity and even if we apply a force to it, the body just won't move.</p><p>Here we won't be applying any force to move the enemy block but will simply move the object like we moved the enemy in the SpriteKit game. So, it is like making the same game, but in 3D instead of 2D, so that you can see that although we have a third dimension, the same principles of game development can be applied to both.</p><p>For moving the enemy, we need an <code class="literal">update</code> function for the enemy. So, let us add it to the scene by creating an <code class="literal">updateEnemy</code> function and adding the following to it:</p><div class="informalexample"><pre class="programlisting">func updateEnemy(){
    
     enemyNode.position.z += -0.9
        
     if((enemyNode.position.z - 5.0) &lt; -40){
            
        var factor = arc4random_uniform(2) + 1
            
        if( factor == 1 ){
            enemyNode.position = SCNVector3Make(0, 2.0 , 60.0)
        }else{
            enemyNode.position = SCNVector3Make(0, 15.0 , 60.0)
        }
   }
}</pre></div><p>In the <code class="literal">update</code> function, similar<a id="id645" class="indexterm"/> to how we moved the enemy in the SpriteKit game, we increment the <code class="literal">Z</code> position of the enemy node by 0.9. The difference being that we are moving the <span class="emphasis"><em>z</em></span> direction.</p><p>Once the enemy has gone beyond <code class="literal">–40</code> in the <span class="emphasis"><em>z</em></span> direction, we reset the position of the enemy. To create an additional challenge to the player, when the enemy resets, a random number is chosen between <code class="literal">1</code> and <code class="literal">2</code>. If it is <code class="literal">1</code>, then the enemy is placed closer to the ground, otherwise it is placed at 15 units from the ground.</p><p>Later, we will add a jump mechanic to the hero. So, when the enemy is closer to the ground, the hero has to jump over the enemy box, but when the enemy is spawned at a height, the hero shouldn't jump. If he jumps and hits the enemy box, then it is game over. Later we will also add a scoring mechanism to keep score.</p><p>For updating the enemy, we actually need an update function to add the <code class="literal">enemyUpdate</code> function to so that the enemy moves and his position resets. So, create a function called update in the class and call the <code class="literal">updateEnemy</code> function in it as follows:</p><div class="informalexample"><pre class="programlisting">    func update(){
    
        updateEnemy()
    }</pre></div><div class="section" title="Updating objects in the scene"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/>Updating objects in the scene</h2></div></div></div><p>In SceneKit, there is an<a id="id646" class="indexterm"/> update function that gets called after the scene is <a id="id647" class="indexterm"/>rendered. We will use this function to call the <code class="literal">update</code> function of our game. In the <code class="literal">GameViewController</code> class, add the following function:</p><div class="informalexample"><pre class="programlisting">func renderer(aRenderer: SCNSceneRenderer, updateAtTime time: NSTimeInterval) {
     
  gameSCNScene.update()
}</pre></div><p>To call the <code class="literal">rendererUpdateAtTime</code> function, the <code class="literal">GameViewController</code> class needs to inherit from <code class="literal">SCNSceneRendererDelegate</code>. So, where the class is created, add the following:</p><div class="informalexample"><pre class="programlisting">class GameViewController: UIViewController, <span class="strong"><strong>SCNSceneRendererDelegate</strong></span> { </pre></div><p>Next, in the <code class="literal">viewDidLoad</code> function, set the current delegate to self as follows:</p><div class="informalexample"><pre class="programlisting">let scnView = view as SCNView
<span class="strong"><strong>scnView.delegate = self</strong></span>
</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>Delegates are a part of code design patterns. Using delegates, a class can let a different class gain access and perform some of its responsibilities. Here <code class="literal">SceneRenderer</code> is delegating to <code class="literal">scnView</code> by assigning the delegate as self.</p></div></div><p>The <code class="literal">rendererUpdateAtTime</code> function is a system function that gets called after all the objects are rendered in the scene. So, once the scene is rendered, the objects in the scene can be updated, otherwise it might result in artifacting.</p><p>Now, if we build and run the game, we see <code class="literal">enemyBox</code> getting updated.</p><p>But there is a problem, when the box hits the hero, the hero gets knocked off his pedestal and goes flying. This is because, firstly, the hero is a dynamic body, so external forces will affect him. Secondly, though we are moving the box manually without applying any force, e we are still moving the box and there is some inertial force calculated by SceneKit, so once the box hits the hero, the energy is transferred to the hero, and it acts like an external force applied on the hero so the hero starts moving.</p><p>Since we constrained the rotation of the hero using <code class="literal">heroNode.physicsBody?.angularVelocityFactor = SCNVector3Zero</code>, when the box hits him, he is not rotating. If we comment or delete the line, the hero will spin because of the box hitting him.</p><div class="mediaobject"><img src="graphics/B04014_08_10.jpg" alt="Updating objects in the scene"/></div><p>We will fix this issue <a id="id648" class="indexterm"/>when we check for collision. When the collision occurs, we<a id="id649" class="indexterm"/> will reset the position of the hero and box to their initial positions. So, let us next look at how to check for collision.</p></div><div class="section" title="Checking for contact between objects"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/>Checking for contact between objects</h2></div></div></div><p>The physics engine of <a id="id650" class="indexterm"/>SceneKit has inbuilt functions that check for contact between objects when physics is enabled. A contact is triggered when two objects are just about to touch each other.</p><p>For checking contacts, we have to use the <code class="literal">didBeginContact</code> function of <code class="literal">physicsWorld</code>; so add the following code to the class. Also, we have to inherit from <code class="literal">SCNPhysicsContactDelegate</code> and set the <code class="literal">GameSCNScene</code> class as the contact delegate.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>Similar to calling <code class="literal">RenderDelegate</code> in <code class="literal">GameViewController</code>, to be able to receive "contact" events in the provided <code class="literal">GameSCNScene</code> by the physics engine and be able to manipulate them, the <code class="literal">GameSCNScene</code> class inherits from <code class="literal">SCNPhysicsContactDelegate</code> and the scene's <code class="literal">contactDelegate</code> is set to <code class="literal">self</code>.</p></div></div><p>So, at the top of the class, inherit<a id="id651" class="indexterm"/> from <code class="literal">SCNPhysicsContactDelegate</code>:</p><div class="informalexample"><pre class="programlisting">class GameSCNScene: SCNScene,<span class="strong"><strong>SCNPhysicsContactDelegate</strong></span>{</pre></div><p>And, in the <code class="literal">init</code> function, add the following to set the current class as contact delegate:</p><div class="informalexample"><pre class="programlisting">scene.physicsWorld.contactDelegate = self</pre></div><p>Next, add the <code class="literal">didBeginContact</code> function to the class as follows:</p><div class="informalexample"><pre class="programlisting">func physicsWorld(world: SCNPhysicsWorld, didBeginContact contact: SCNPhysicsContact) {
       

    if( (contact.nodeA.name == "hero" &amp;&amp;
 contact.nodeB.name == "enemy") )
    {
        contact.nodeA.physicsBody?.velocity = SCNVector3Zero
  println("contact")
            
 }
} </pre></div><p>When two physics objects collide, the nodes are stored in the contact variable. Since we already named our physics body objects, we check if the first body is of the hero's and the other body that the hero collided with is of the enemy. If true, we print out contact and also set the velocity of the first body to zero.</p><p>Since ours is a small game, we can guess that body <span class="emphasis"><em>A</em></span> would be the hero and body <span class="emphasis"><em>B</em></span> will be the enemy. In bigger games with many collisions happening in a second, it might be hard to determine which is body <span class="emphasis"><em>A</em></span> and which is body <span class="emphasis"><em>B</em></span>. In such cases, we will have to check for both cases, that is, is body <span class="emphasis"><em>A</em></span> of enemy or hero and vice versa for body <span class="emphasis"><em>B</em></span>, then make the necessary conclusion.</p><p>So, now we have added a hero and an enemy and we have our collision set up. Next we will see how to implement a 2D overlay over our 3D scene so that we can display buttons and score and add a game <a id="id652" class="indexterm"/>over condition for our simple game.</p></div></div>
<div class="section" title="Adding a SpriteKit overlay"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec77"/>Adding a SpriteKit overlay</h1></div></div></div><p>For showing scores and<a id="id653" class="indexterm"/> buttons for the game, we will add 2D SpriteKit layer. For adding the overlay, create a class called <code class="literal">OverlaySKscene</code>. In this class, add the following:</p><div class="informalexample"><pre class="programlisting">import SpriteKit

class OverlaySKScene: SKScene {
    
    let _gameScene: GameSCNScene!
    let myLabel: SKLabelNode!
    var gameOverLabel: SKLabelNode!
    var jumpBtn: SKSpriteNode!
    var playBtn: SKSpriteNode!
    
    required init?(coder aDecoder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    init(size: CGSize, gameScene: GameSCNScene){

    super.init(size: size)
    
    }
}</pre></div><p>To import SpriteKit we will have to create a subclass of SpriteKit. Create global variables of type <code class="literal">GameSCNScene</code>, <code class="literal">SKLabelNodes</code>, and <code class="literal">SpriteNodes</code>. Here we create two <code class="literal">LabelNodes</code>: one for displaying score and the other to show "game over" text. We also create two <code class="literal">spriteNodes</code>: one for the play button and the other for the jump button.</p><p>We add the required <code class="literal">init</code> function and the default init function. The default <code class="literal">init</code> will take in the size of the scene and reference to the <code class="literal">GameSCNScene</code> class as parameters.</p><p>In the <code class="literal">init</code> function, we initialize the super class.</p><div class="section" title="Adding labels and buttons"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec77"/>Adding labels and buttons</h2></div></div></div><p>Next, in<a id="id654" class="indexterm"/> the <code class="literal">init</code> function, add the <a id="id655" class="indexterm"/>following code:</p><div class="informalexample"><pre class="programlisting">        _gameScene = gameScene
        
        myLabel = SKLabelNode(fontNamed:"Chalkduster")
        myLabel.text = "Score: 0";
        myLabel.fontColor = UIColor.whiteColor()
        myLabel.fontSize = 65;
        myLabel.setScale(1.0)
        myLabel.position = CGPointMake(size.width * 0.5, size.height * 0.9)
        self.addChild(myLabel)

  gameOverLabel = SKLabelNode(fontNamed:"Chalkduster")
        gameOverLabel.text = "GAMEOVER";
        gameOverLabel.fontSize = 100;
        gameOverLabel.setScale(1.0)
        gameOverLabel.position = CGPointMake(size.width * 0.5, size.height * 0.5)
        gameOverLabel.fontColor = UIColor.whiteColor()
        self.addChild(gameOverLabel)
        gameOverLabel.hidden = true

        
        playBtn = SKSpriteNode(imageNamed: "playBtn")
        playBtn.position = CGPoint(x: size.width * 0.15, y: size.height * 0.2)
        self.addChild(playBtn)
        playBtn.name = "playBtn"
        
        jumpBtn = SKSpriteNode(imageNamed: "jumpBtn")
        jumpBtn.position = CGPoint(x: size.width * 0.9, y: size.height * 0.15)
        self.addChild(jumpBtn)
        jumpBtn.name = "jumpBtn"
        jumpBtn.hidden = true</pre></div><p>In the <code class="literal">init</code> function, first, we set the <code class="literal">gameScene</code> passed to the <code class="literal">_gameScene</code> property of the scene.</p><p>Next we initialize both the <code class="literal">scoreLabel</code> and <code class="literal">gameOverLabel</code>. We set the values for <code class="literal">text</code>, <code class="literal">color</code>, <code class="literal">textsize</code>, and <code class="literal">position</code> and add it to the scene. In <code class="literal">gameOverLabel</code>, we set hidden to <code class="literal">true</code>, as we only want the text to display once the game is over.</p><p>We then initialize the <a id="id656" class="indexterm"/>play and jump buttons that we made in<a id="id657" class="indexterm"/> SpriteKit. We set the jump button sprite to be hidden, as we want it to display only when the play button is clicked and the game starts. The images for the jump and play button are provided in the resources folder of the chapter.</p></div></div>
<div class="section" title="Adding touch interactivity"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec78"/>Adding touch interactivity</h1></div></div></div><p>For adding<a id="id658" class="indexterm"/> touch interactivity, we will use the <code class="literal">touchesBegan</code> function similar to how we have always used it in SpriteKit. So, here we get the location of the touch and name of the sprite under the touch location. If the sprite name is <code class="literal">jumpBtn</code> and the <code class="literal">gameOver</code> Boolean is <code class="literal">false</code>, then we call the <code class="literal">heroJump</code> function in the <code class="literal">gameScene</code> class. If <code class="literal">gameOver</code> is <code class="literal">true</code> and if the play button is clicked, then we call the <code class="literal">startGame</code> function in the SceneKit class.</p><p>So, add the function as follows to detect touches:</p><div class="informalexample"><pre class="programlisting">    override func touchesBegan(touches: NSSet, withEvent event: UIEvent) {
        /* Called when a touch begins */
        
        for touch: AnyObject in touches {
            let location = touch.locationInNode(self)
            
            let _node:SKNode = self.nodeAtPoint(location);
            
            if(_gameScene.gameOver == false){
            
                if(_node.name == "jumpBtn"){
                
                    _gameScene.heroJump()
                }
            
            }else{
                
                if(_node.name == "playBtn"){
                    
                    _gameScene.startGame()
                }
            }
        }
    }</pre></div><p>That's all for the SpriteKit class. We will be adding the <code class="literal">gameOver</code> Boolean, and <code class="literal">heroJump</code> and <code class="literal">startGame</code> functions in the SceneKit class. The code will show some errors until we <a id="id659" class="indexterm"/>create it, so ignore the errors for now.</p></div>
<div class="section" title="Finishing the game loop"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec79"/>Finishing the game loop</h1></div></div></div><p>Move back to the<a id="id660" class="indexterm"/> SceneKit class and import SpriteKit at the top of the class as follows:</p><div class="informalexample"><pre class="programlisting">import UIKit
import SceneKit
<span class="strong"><strong>import SpriteKit</strong></span>
</pre></div><p>Also, create a global variable called <code class="literal">skScene</code> of type <code class="literal">OverlaySKScene</code>. Add a new function called <code class="literal">addSpriteKitOverlay</code> and add the following code in the SceneKit class:</p><div class="informalexample"><pre class="programlisting">func addSpriteKitOverlay(){
        
    skScene = OverlaySKScene(size: _size, gameScene: self)
    scnView.overlaySKScene = skScene
    skScene.scaleMode = SKSceneScaleMode.ResizeFill
        
}</pre></div><p>Here we initialize the <code class="literal">skScene</code> global variable we created earlier and pass in the size of the current scene and the current SceneKit class. Next we assign the <code class="literal">skScene</code> class to the <code class="literal">overlaySKScene</code> property of <code class="literal">scnView</code>. Finally, we set the <code class="literal">scaleMode</code> of the <code class="literal">skScene</code> variable to type <code class="literal">SKSceneScaleMode.ResizeFill</code>.</p><p>Finally, call the <code class="literal">addSpriteKitOverlay</code> function in the <code class="literal">addColladaObjects</code> function as follows:</p><div class="informalexample"><pre class="programlisting">func addColladaObjects(){
        
        addHero()
        addGround()
        addEnemy()
        <span class="strong"><strong>addSpriteKitOverlay()</strong></span>
}</pre></div><div class="section" title="Making the hero jump"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/>Making the hero jump</h2></div></div></div><p>We still need<a id="id661" class="indexterm"/> to add the Boolean and functions to the class to make our game work. So, at the top of the class, create a global variable called <code class="literal">gameOver</code> and set it to <code class="literal">true</code>.</p><p>Next, create a new function called <code class="literal">heroJump</code> as follows:</p><div class="informalexample"><pre class="programlisting">func heroJump(){
        
heroNode.physicsBody?.applyForce(SCNVector3Make(0, 1400, 0), impulse: true) 
          
}</pre></div><p>Here we apply an upward force of <code class="literal">1400</code> units in the <span class="emphasis"><em>y</em></span> direction to <code class="literal">heroNode</code>.</p><p>Next, create the <code class="literal">gameStart</code> function as follows and add it into the class:</p><div class="informalexample"><pre class="programlisting">    func startGame(){
        
        gameOver = false
        skScene.jumpBtn.hidden = false
        skScene.myLabel.hidden = false
        skScene.playBtn.hidden = true
        skScene.gameOverLabel.hidden = true
        
        score = 0
        skScene.myLabel.text = "Score: \(score)"
    }</pre></div><p>The <code class="literal">gameOver</code> Boolean is set to <code class="literal">false</code>. We set the jump button and <code class="literal">scoreLabel</code> to be visible and hide the play button and <code class="literal">gameOverlabel</code>.</p><p>For keeping track and displaying the score, we need a score variable, so create a global variable called <code class="literal">score</code> of type <code class="literal">int</code> and initialize it to <code class="literal">0</code> at the top of the class. Again, in the <code class="literal">startGame</code> function, set the value to <code class="literal">0</code> so that every time the function is called the value is reset. Also, we set the <code class="literal">scoreLabel</code> text to reflect the current score at the start of the game.</p><p>For scoring in the game, we will increment the score every time the enemy block goes beyond the screen and gets reset. If the block hits the hero, then it will be game over.</p><p>So, in the <code class="literal">enemyUpdate</code> function, add the following highlighted line after we check if the enemy's <code class="literal">Z</code> position is less<a id="id662" class="indexterm"/> than <code class="literal">–40</code> to update the score and <code class="literal">scoreLabel</code> text:</p><div class="informalexample"><pre class="programlisting">    func updateEnemy(){
    
        enemyNode.position.z += -0.9
        
        if((enemyNode.position.z - 5.0) &lt; -40){
            
            var factor = arc4random_uniform(2) + 1
            
            if( factor == 1 ){
                enemyNode.position = SCNVector3Make(0, 2.0 , 60.0)
            }else{
                enemyNode.position = SCNVector3Make(0, 15.0 , 60.0)
            }
            <span class="strong"><strong> score++</strong></span>
<span class="strong"><strong>            skScene.myLabel.text = "Score: \(score)"</strong></span>
        }
    }</pre></div></div><div class="section" title="Setting a game over condition"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/>Setting a game over condition</h2></div></div></div><p>In the <code class="literal">didBeginContact</code> function, add the<a id="id663" class="indexterm"/> following right after we reset the velocity of the player to zero:</p><div class="informalexample"><pre class="programlisting">gameOver = true
GameOver()</pre></div><p>Here we set <code class="literal">gameOver</code> to <code class="literal">true</code> and call a <code class="literal">GameOver</code> function where we will set the visibility of the labels and buttons. So, add a new function called <code class="literal">GameOver</code> to the SceneKit class as follows:</p><div class="informalexample"><pre class="programlisting">func GameOver(){
        
    skScene.jumpBtn.hidden = true
    skScene.playBtn.hidden = false
    skScene.gameOverLabel.hidden = false
        
    enemyNode.position = SCNVector3Make(0, 2.0 , 60.0)
    heroNode.position = SCNVector3Make(0, 0, 0)
}</pre></div><p>Here, once the game is over, we hide the <code class="literal">jumpButton</code> and unhide the <code class="literal">playButton</code> and <code class="literal">gameOverLabel</code>. We then reset the position of the enemy and hero to their initial state.</p><p>Next we have to make sure that the <code class="literal">enemyUpdate</code> function is only called when <code class="literal">gameOver</code> is false. In the <code class="literal">update</code> function, enclose the <code class="literal">enemyUpdate</code> function in an <code class="literal">if </code>statement as follows:</p><div class="informalexample"><pre class="programlisting">if(!gameOver){
            
   updateEnemy()

}</pre></div><p>Finally, we have to adjust the<a id="id664" class="indexterm"/> gravity in the scene, otherwise the hero will get tossed into the air since the gravity is currently so low. In the <code class="literal">addColladaObjects</code> function, add the following line at the end of the function:</p><div class="informalexample"><pre class="programlisting">scene.physicsWorld.gravity = SCNVector3Make(0, -300, 0)</pre></div><p>Now our game loop is ready. If you press the play button, the game will start and the jump button will be visible, and the hero will jump when it is pressed. The score will increase each time the hero successfully avoids the enemy block, and the game will be over if he hits the enemy block. Once the game is over, the play button will be visible and jump button will be hidden. Tapping the play button again will reset everything and the game will start again.</p></div><div class="section" title="Fixing the jump"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec80"/>Fixing the jump</h2></div></div></div><p>There is still one <a id="id665" class="indexterm"/>problem though. You can keep on tapping the jump button and the hero will keep on going up. We don't want that. We want the hero to jump only when he is grounded. For this, we will add a small counter and disable the jump when the hero is in the air.</p><p>For this, add a new global variable called <code class="literal">jumpCounter</code> of type <code class="literal">int</code> and initialize it to <code class="literal">0</code>. In the <code class="literal">update</code> function of the class, add the following:</p><div class="informalexample"><pre class="programlisting">jumpCounter--
        
if(jumpCounter &lt; 0 ){
        
       jumpCounter = 0
}</pre></div><p>Here we decrement the value of <code class="literal">jumpCounter</code> and once it is less than zero, we set the value equal to <code class="literal">0</code>.</p><p>Next, in the <code class="literal">heroJump</code> function, enclose where we apply force to the hero to jump in an if condition as follows:</p><div class="informalexample"><pre class="programlisting">if(jumpCounter == 0){
                    heroNode.physicsBody?.applyForce(SCNVector3Make(0,
                    1400,
                    0),
                    impulse: true) 
     
    jumpCounter = 25
}</pre></div><p>Now, the hero will only <a id="id666" class="indexterm"/>jump when <code class="literal">jumpCounter</code> is equal to 0. If it is equal to <code class="literal">0</code>, then the force is applied and the counter is set to <code class="literal">25</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>The number was arrived at after trial and error to ensure that the jump button won't be pressed when the monster is in the air.</p></div></div><p>In the <code class="literal">update</code> function, we decrement this value, until then the force cannot be applied. Once <code class="literal">jumpCounter</code> is set to <code class="literal">0</code> again, the hero can jump again.</p><p>So, finally, we can run and test the game. Make sure the <code class="literal">addSpriteKitOverlay</code> function is called in the <code class="literal">addColladaObjects</code> function.</p><div class="mediaobject"><img src="graphics/B04014_08_11.jpg" alt="Fixing the jump"/></div></div></div>
<div class="section" title="Adding wall and floor parallax"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec80"/>Adding wall and floor parallax</h1></div></div></div><p>What is a <a id="id667" class="indexterm"/>game without a<a id="id668" class="indexterm"/> parallax effect? In SpriteKit, we added parallax using sprites, while in SceneKit, we will use planes to add it to the scene. Apart from adding parallax, we will also see how to add diffuse, normal, and specular maps to the plane. Also, we will learn what those terms even mean.</p><p>So, as usual, we create a new function in which we will add all these planes. Add four global <code class="literal">SCNNodes</code> as follows:</p><div class="informalexample"><pre class="programlisting">var parallaxWallNode1: SCNNode!
var parallaxWallNode2: SCNNode!
var parallaxFloorNode1: SCNNode!
var parallaxFloorNode2: SCNNode!</pre></div><p>Also, add a function to the <a id="id669" class="indexterm"/>scene called <code class="literal">addWallandFloorParallax</code> as<a id="id670" class="indexterm"/> follows:</p><div class="informalexample"><pre class="programlisting">    func addWallandFloorParallax(){
        
       //Preparing Wall geometry        
        let wallGeometry = SCNPlane(width: 250, height: 120)
        wallGeometry.firstMaterial?.diffuse.contents = "monster.scnassets/wall.png"
        wallGeometry.firstMaterial?.diffuse.wrapS = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.diffuse.wrapT = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.diffuse.mipFilter = SCNFilterMode.Linear
        wallGeometry.firstMaterial?.diffuse.contentsTransform = SCNMatrix4MakeScale(6.25, 3.0, 1.0)
        
        wallGeometry.firstMaterial?.normal.contents = "monster.scnassets/wall_NRM.png"
        wallGeometry.firstMaterial?.normal.wrapS = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.normal.wrapT = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.normal.mipFilter = SCNFilterMode.Linear
        wallGeometry.firstMaterial?.normal.contentsTransform = SCNMatrix4MakeScale(6.25, 3.0, 1.0)
        
        wallGeometry.firstMaterial?.specular.contents = "monster.scnassets/wall_SPEC.png"
        wallGeometry.firstMaterial?.specular.wrapS = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.specular.wrapT = SCNWrapMode.Repeat
        wallGeometry.firstMaterial?.specular.mipFilter = SCNFilterMode.Linear
        wallGeometry.firstMaterial?.specular.contentsTransform = SCNMatrix4MakeScale(6.25, 3.0, 1.0)
        
        wallGeometry.firstMaterial?.locksAmbientWithDiffuse = true
        
      //Preparing floor geometry
        let floorGeometry = SCNPlane(width: 120, height: 250)
        floorGeometry.firstMaterial?.diffuse.contents = "monster.scnassets/floor.png"
        floorGeometry.firstMaterial?.diffuse.wrapS = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.diffuse.wrapT = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.diffuse.mipFilter = SCNFilterMode.Linear
        floorGeometry.firstMaterial?.diffuse.contentsTransform = SCNMatrix4MakeScale(12.0, 25, 1.0)
        
        floorGeometry.firstMaterial?.normal.contents = "monster.scnassets/floor_NRM.png"
        floorGeometry.firstMaterial?.normal.wrapS = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.normal.wrapT = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.normal.mipFilter = SCNFilterMode.Linear
        floorGeometry.firstMaterial?.normal.contentsTransform = SCNMatrix4MakeScale(24.0, 50, 1.0)        
        floorGeometry.firstMaterial?.specular.contents = "monster.scnassets/floor_SPEC.png"
        floorGeometry.firstMaterial?.specular.wrapS = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.specular.wrapT = SCNWrapMode.Repeat
        floorGeometry.firstMaterial?.specular.mipFilter = SCNFilterMode.Linear
        floorGeometry.firstMaterial?.specular.contentsTransform = SCNMatrix4MakeScale(24.0, 50, 1.0)
        
        floorGeometry.firstMaterial?.locksAmbientWithDiffuse = true
        
        //assign wall geometry to wall nodes
  parallaxWallNode1 = SCNNode(geometry: wallGeometry)
        parallaxWallNode1.rotation = SCNVector4Make(0, 1, 0, Float(-M_PI / 2))
        parallaxWallNode1.position = SCNVector3Make(15, 0, 0)
        scene.rootNode.addChildNode(parallaxWallNode1)
        
        parallaxWallNode2 = SCNNode(geometry: wallGeometry)
        parallaxWallNode2.rotation = SCNVector4Make(0, 1, 0, Float(-M_PI / 2))
        parallaxWallNode2.position = SCNVector3Make(15, 0, 250)
        scene.rootNode.addChildNode(parallaxWallNode2)
        
        //assign floor geometry to floor nodes

        parallaxFloorNode1 = SCNNode(geometry: floorGeometry)
        parallaxFloorNode1.rotation = SCNVector4Make(0, 1, 0, Float(-M_PI / 2))
        parallaxFloorNode1.rotation = SCNVector4Make(1, 0, 0, Float(-M_PI / 2))
        
        parallaxFloorNode1.position = SCNVector3Make(15, 0, 0)
        scene.rootNode.addChildNode(parallaxFloorNode1)
        
        parallaxFloorNode2 = SCNNode(geometry: floorGeometry)
        parallaxFloorNode2.rotation = SCNVector4Make(0, 1, 0, Float(-M_PI / 2))
        parallaxFloorNode2.rotation = SCNVector4Make(1, 0, 0, Float(-M_PI / 2))
        parallaxFloorNode2.position = SCNVector3Make(15, 0, 250)
        scene.rootNode.addChildNode(parallaxFloorNode2)
    }</pre></div><p>OMG!! This is a<a id="id671" class="indexterm"/> whole lot of code. But don't panic. We will go through it systematically. Just<a id="id672" class="indexterm"/> look at the code where it says <code class="literal">preparing wall geometry</code>. First, we will see how the wall geometry is set up, and then once you have an understanding of it, we will see how to set up the floor geometry.</p><p>We create a new constant called <code class="literal">wallGeometry</code> and assign a <code class="literal">SCNPlane</code> to it. The difference between an <code class="literal">SCNPlane</code> and <code class="literal">SCNFloor</code> is that here we can set the dimensions of the plane. So, very simply we set the width and height of the plane to be <code class="literal">250</code> by <code class="literal">120</code> units.</p><p>Next, we assign a material to the plane. Until now, we have only seen how to assign a color to an object in SceneKit. Here we assign three kinds of maps to the plane. The first is a diffuse.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>A diffuse material is an image or texture that you want to paste on to a plane.</p></div></div><p>Textures are like wallpapers on walls. Imagine an unpainted wall; now you can either color the wall or apply wallpaper. Adding paint is done in the digital world by applying a color, like we did for <code class="literal">enemyblock</code> where we assigned a yellow diffuse color to it. To apply a wallpaper in the digital world, we apply using textures or images. Here we apply the <code class="literal">wall.png</code> image to the wall plane geometry.</p><p>Notice that the wall <a id="id673" class="indexterm"/>plane is pretty big in terms of width and height. If we let it be, the <a id="id674" class="indexterm"/>wall.png image will have to stretch to fit the dimension of the wall. So we use the <code class="literal">wrapt</code> and <code class="literal">wraps</code> functions so that the wall texture is repeated in both the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> direction of the plane without stretching the wall texture. So this is what happens in the next two lines. We are just repeating the wall texture over in both the directions until it fills the whole plane.</p><p>In the next step, we assign the <code class="literal">mipFiler</code> to <code class="literal">linear</code>. The filter will decide how much detail needs to be added to the texture. If the camera is far enough away, it will generate a lower resolution texture to reduce the burden on the CPU. If the camera comes closer, then a higher resolution image will be created so that all the details of the texture will be visible. This is purely used for optimization purposes. Linear filter mode is the most basic type of mode of filters. There are other modes called bilinear and trilinear, and so on that will give even better results but are computationally expensive. For our purposes, linear filtering will suffice. You can see the difference by changing the code and running the game on a device.</p><p>For the diffuse at the end, we scale down the texture of the image itself depending upon how big or small we want the texture to appear on the plane. While scaling, we have scaled it to the same proportion as the size of the geometry. So here in the <span class="emphasis"><em>x</em></span> and <span class="emphasis"><em>y</em></span> plane, we scale it down by a factor of 1/40 times the values of width and height of the geometry. Since we are not scaling in the <span class="emphasis"><em>z</em></span> direction, we keep it at <code class="literal">1</code>.</p><p>The following is the image of the diffuse map of the wall:</p><div class="mediaobject"><img src="graphics/B04014_08_12.jpg" alt="Adding wall and floor parallax"/></div><p>Now, the same <a id="id675" class="indexterm"/>five steps are repeated for the normal and the specular map. We saw that to <a id="id676" class="indexterm"/>add wallpaper to the plane we have to use a diffuse map. Now, what if this wallpaper has some bumps and holes in it? Not all walls are so smooth. So, to add this roughness to the wallpaper, we use what is called a normal map. The following is the image of the normal map:</p><div class="mediaobject"><img src="graphics/B04014_08_13.jpg" alt="Adding wall and floor parallax"/></div><p>It basically <a id="id677" class="indexterm"/>calculates how light should behave once it hits the normal surface. Depending <a id="id678" class="indexterm"/>on the direction of the light and if there is a dump or hole in the normal map, the lighting will be calculated automatically. All this is done using a normal map. A normal is nothing but an image. The code will take information from this image to create the desired effect. So, here we assign a normal map called <code class="literal">wall_NRM.png</code> and assign it as content. The next four steps are very similar to the ones we performed for diffuse maps.</p><p>Next, let us look at specular maps. This map will decide which parts of the texture are shiny and which parts are not. Imagine your wallpaper was made of stainless steel. To bring this effect, we assign the specular map, and to add this, we use the <code class="literal">wall_SPEC.png</code> file. The next four steps are the same, only now we do it separately for the specular map. The image of the specular map is as follows:</p><div class="mediaobject"><img src="graphics/B04014_08_14.jpg" alt="Adding wall and floor parallax"/></div><p>The same steps are repeated for the floor geometry as well, only this time we have flipped the width and height values.</p><p>Once the floor and wall geometries are ready, we assign them to the wall and floor nodes.</p><p>For the wall nodes, we assign the geometry to the node. Then we rotate the node so that the wall is vertical. We rotate the node by –90 degrees in the <span class="emphasis"><em>y</em></span> direction. Then we place the first wall at <code class="literal">(15, 0, 0)</code>, and then add it to the scene. We place the second wall node at <code class="literal">(15, 0, 250)</code>, which will make it adjacent to the first plane.</p><p>For the floor nodes, we follow a similar process, but here we have to rotate it twice to be horizontal to the ground.</p><p>With our wall and<a id="id679" class="indexterm"/> floor nodes ready, we can update the positions of the planes to create <a id="id680" class="indexterm"/>the parallax effect. So, in the <code class="literal">update</code> function, add the following code:</p><div class="informalexample"><pre class="programlisting">parallaxWallNode1.position.z += -0.5
parallaxWallNode2.position.z += -0.5
parallaxFloorNode1.position.z += -0.5
parallaxFloorNode2.position.z += -0.5        
        
if((parallaxWallNode1.position.z + 250) &lt;= 0){
     self.parallaxWallNode1.position = SCNVector3Make(15, 0, 250)
}
        
if((parallaxWallNode2.position.z + 250) &lt;= 0){
     self.parallaxWallNode2.position = SCNVector3Make(15, 0, 250)
}
        
if((parallaxFloorNode1.position.z + 250) &lt;= 0){
     self.parallaxFloorNode1.position = SCNVector3Make(15, 0, 250)
}
        
if((parallaxFloorNode2.position.z + 250) &lt;= 0){
     self.parallaxFloorNode2.position = SCNVector3Make(15, 0, 250)
}</pre></div><p>This will look very familiar to you now. Like we updated and reset the background sprites in the SpriteKit game, we are going update the positions of the four nodes and then reset the position of all of them if they have gone beyond 250 units in the <span class="emphasis"><em>z</em></span> direction.</p><p>Add the <code class="literal">addWallandFloorParallax</code> function to the <code class="literal">addColladaObjects</code> function.</p><p>For this scene, I have also added an ambient light node using the scene graph, as otherwise the scene was looking very dark. Go to the <code class="literal">monsterScene.DAE</code> file, and under the scene graph, click on the plus sign and add a new node. Next, right-click on the node and select <span class="strong"><strong>addLight</strong></span>. In the panel on the right, select the <span class="strong"><strong>Attributes</strong></span> inspector, and under the <span class="strong"><strong>Type</strong></span>, select <span class="strong"><strong>Ambient</strong></span>. Below <span class="strong"><strong>Type</strong></span>, select <span class="strong"><strong>Color</strong></span> and choose a dark blue or purple color. Run the game now and you should see the result, as shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/B04014_08_15.jpg" alt="Adding wall and floor parallax"/></div></div>
<div class="section" title="Adding particles"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec81"/>Adding particles</h1></div></div></div><p>As the icing on <a id="id681" class="indexterm"/>the cake, we will include a rain particle effect. For creating a particle effect in SceneKit, go to <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New</strong></span>, and under <span class="strong"><strong>Resource</strong></span>, select <span class="strong"><strong>SceneKit Particle system</strong></span>. Click on <span class="strong"><strong>Next</strong></span>, and on the next screen, select <span class="strong"><strong>Rain</strong></span> from the <span class="strong"><strong>Particle System Template</strong></span> drop-down list. Click on <span class="strong"><strong>Next</strong></span> and give the file a name. I called it <code class="literal">rain</code>. So now you will have <code class="literal">rain.scnp</code> and <code class="literal">spark.png</code> files in the project.</p><p>To position the particle better, go to the scene graph and create a node called <code class="literal">particleNode</code>, and translate and rotate the node such that it is pointing toward the hero.</p><p>Create a new function called <code class="literal">addRainParticle</code> to the class and add the following code:</p><div class="informalexample"><pre class="programlisting">func addRainParticle(){
        
let rain = SCNParticleSystem(named: "rain", inDirectory: nil)
            
    var particleEmitterNode = SCNNode()        
    particleEmitterNode = scene.rootNode.childNodeWithName("particleNode", recursively: true)!
        
    particleEmitterNode.addParticleSystem(rain)
    scene.rootNode.addChildNode(particleEmitterNode)

rain.warmupDuration = 10
        
}</pre></div><p>We create a new<a id="id682" class="indexterm"/> constant called <code class="literal">rain</code> and assign <code class="literal">SCNParticleSystem</code> to it, and provide the <code class="literal">rain</code> particle system we created in it.</p><p>A new <code class="literal">SCNNode</code> called <code class="literal">particleEmitterNode</code> is created and we assign the <code class="literal">particleNode</code> we created in the scene graph to it. Then we assign the rain particle system to it. Then we add the <code class="literal">particleEmitterNode</code> to the scene.</p><p>We use the <code class="literal">warmupDuration</code> of the particle system and assign a value of <code class="literal">10</code> to it. This is done so that when the game starts, the rain particle effect is fast-forwarded to look as if it was already raining.</p><p>You can select the <code class="literal">rain.scnp</code> file and change the parameters to better suit your needs. Build and run to see our finished SceneKit game. Call the <code class="literal">addRainParticle</code> function at the end of <code class="literal">addColladaObjects</code> function.</p><div class="mediaobject"><img src="graphics/B04014_08_16.jpg" alt="Adding particles"/></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip12"/>Tip</h3><p>Adding audio to the<a id="id683" class="indexterm"/> game is exactly like how we added the main theme into the SpriteKit game. So, I will leave you guys to experiment with it to figure out how to add audio to the scene.</p><p>Also, I didn't want to want to repeat again how to import the assets to the game as we have seen how to do that for over four chapters now. But make sure that while calling the files, you provide the correct folder locations. If not, then the assets won't be retrieved properly, causing build errors.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec82"/>Summary</h1></div></div></div><p>In this chapter, we saw how to make a 3D game in SceneKit. From making simple geometries to floors, we created a full-fledged game will a complete game loop. We added a scene already created in a 3D software package with animation and imported it into SceneKit. We didn't have to add a camera or a light source as it was already part of the 3D scene.</p><p>We imported the COLLADA object into the scene and saw how to access the objects through code. We added an enemy and physics to the scene. We used SceneKit's physics engine to calculate collision and also applied force to the hero object.</p><p>Additionally, you also saw how to integrate SpriteKit into SceneKit to display the score and buttons on the scene. We also used SpriteKit's <code class="literal">touchBegan</code> function to detect touches on the screen and created the play and jump buttons.</p><p>Parallax scrolling was also added to the scene using planes. Also, you saw different types of maps such as diffuse, normal, and specular maps, and the functionality of each. Finally, we added a rain particle system to the scene.</p><p>In the next chapter, you will dive deeper into graphics programming and see how objects are actually displayed on to the screen using the Metal Graphics library.</p></div></body></html>