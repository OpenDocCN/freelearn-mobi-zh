- en: <st c="0">3</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="2">Understanding SwiftUI Observation</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="35">In</st> [*<st c="39">Chapter 2</st>*](B21795_02.xhtml#_idTextAnchor043)<st
    c="48">, we discussed SwiftData, an essential framework for our data management.</st>
    <st c="122">However, for data management to be effective, we need something on
    the other side that can observe changes and display them for</st> <st c="250">the
    user.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="259">SwiftUI contains tools that allow us to observe these changes effectively
    and bind them to actions and UI updates.</st> <st c="375">However, these tools
    have become complex and confusing over</st> <st c="435">the years.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="445">Now, we’re about to explore how observation has become significantly
    more straightforward, all while delving into the heart of SwiftUI’s</st> <st c="583">data
    flow.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="593">In this chapter, we will cover the</st> <st c="629">following topics:</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="646">Go over the SwiftUI observation system and discuss</st> <st c="698">its
    problems</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="710">Add the</st> `<st c="719">@Observable</st>` <st c="730">macro and
    learn how</st> <st c="751">it works</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="759">Discuss observing properties, including</st> <st c="800">computed
    variables</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="818">Work with environment variables and adapt them to the</st> <st c="873">new
    framework</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="886">Talk about the new</st> `<st c="906">@Bindable</st>` <st c="915">property
    wrapper</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="932">Learn how to migrate our app to work with the</st> <st c="979">Observation
    framework</st>
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1000">Are you ready</st> <st c="1015">to start?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1024">Technical requirements</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1047">This chapter includes many code examples, some of which can be
    found in the following GitHub</st> <st c="1141">repository:</st> [<st c="1153">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3)
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1235">To run them, we will need Xcode 15</st> <st c="1271">or newer.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1280">Going over the SwiftUI observation system</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="1322">Before we discuss the</st> <st c="1344">current SwiftUI observation
    system, let’s recap the SwiftUI</st> <st c="1405">observation system.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1424">Before Xcode 15, nine property wrappers handled state and data
    updates</st> <st c="1496">in SwiftUI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1507">Let’s try to group them by</st> <st c="1535">app levels:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="1564">@</st>``<st c="1565">Binding</st>`<st c="1572">,</st> `<st c="1574">@Environment</st>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1600">@State</st>`<st c="1606">,</st> `<st c="1608">@Binding</st>`<st
    c="1616">,</st> `<st c="1618">@</st>``<st c="1619">StateObject</st>`<st c="1630">,</st>
    `<st c="1632">@Environment</st>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1668">@</st>``<st c="1669">ObservableObject</st>`<st c="1685">,</st>
    `<st c="1687">@Published</st>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="1715">@AppStorage</st>`<st c="1726">,</st> `<st c="1728">@</st>``<st
    c="1729">SceneStorage</st>`<st c="1741">,</st> `<st c="1743">@EnvironementObject</st>`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="1762">The different levels give us an idea of the different roles of
    the different wrappers.</st> <st c="1850">Let’s touch on some of these wrappers
    to understand how the</st> <st c="1910">system works.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="1923">A local</st> `<st c="1932">@State</st>` <st c="1938">property wrapper
    manages the state of primitive properties within the view.</st> <st c="2015">For
    example, whether a specific view is hidden, the number of available buttons, the
    current sorting method, and more are managed by</st> <st c="2148">this wrapper.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2161">The reason why we use a</st> `<st c="2186">@State</st>` <st c="2192">property
    wrapper is because SwiftUI views are immutable.</st> <st c="2250">This means that
    SwiftUI rebuilds the view each time a change occurs, but the</st> `<st c="2327">@State</st>`
    <st c="2333">values don’t change between one rendering session</st> <st c="2384">and
    another.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2396">The problem begins when we base our view on data model information.</st>
    <st c="2465">An example of this would be a bookstore app that displays a list
    of books from a local data file.</st> <st c="2563">In this case, our view must
    work with another data model object using the</st> `<st c="2637">ObservableObject</st>`
    <st c="2653">protocol.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2663">Let’s go over</st> <st c="2678">it now.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2685">Conforming to the ObservableObject protocol</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="2729">We can use the</st> `<st c="2745">ObservableObject</st>` <st c="2761">protocol
    in conjunction with the</st> `<st c="2795">@ObservedObject</st>` <st c="2810">property</st>
    <st c="2820">wrapper for</st> <st c="2832">classes that need to</st> <st c="2853">be
    observed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="2865">Here’s an example of a</st> `<st c="2889">UserData</st>` <st c="2897">class
    which becomes an</st> `<st c="2921">@ObservedObject</st>` <st c="2937">property
    wrapper:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: <st c="3175">There are three parts to</st> <st c="3200">implementing a data</st>
    <st c="3221">class observation:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="3254">ObservableObject</st>`<st c="3270">: If we want a class to be
    observed in SwiftUI, it must conform to the</st> `<st c="3342">ObservableObject</st>`
    <st c="3358">protocol.</st> <st c="3369">This indicates to SwiftUI that</st> <st
    c="3400">any instance derived from this class can be observed in</st> <st c="3456">a
    view.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="3475">@Published</st>``<st c="3536">@Published</st>` <st c="3546">property
    wrapper, SwiftUI creates a publisher and uses it inside the</st> <st c="3616">SwiftUI
    views.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`<st c="3658">@ObservedObject</st>``<st c="3697">@ObservedObject</st>` <st
    c="3712">property wrapper establishes a connection between the view and the object,
    allowing the view to be notified</st> <st c="3821">of chan</st><st c="3828">ges.</st>'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: <st c="3833">It’s essential to remember that the</st> `<st c="3870">@ObservedObject</st>`
    <st c="3885">property wrapper is solely for observation purposes – this means
    that the view cannot modify the observed object</st> <st c="3999">properties directly.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4019">If we want to change the observed object properties, we must use
    another property wrapper –</st> `<st c="4112">@</st>``<st c="4113">StateObj</st><st
    c="4121">ect</st>`<st c="4125">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4126">A</st> `<st c="4129">@StateObject</st>` <st c="4141">property wrapper
    is similar to</st> `<st c="4173">@State</st>`<st c="4179">, only that it works
    with observable objects and not</st> <st c="4232">primitive values.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4249">However, that doesn’t end</st> <st c="4276">here – if we want to
    create a two-way connection between the view and its subview, we need</st> <st
    c="4367">to add a</st> `<st c="4376">@Binding</st>` <st c="4384">property wrapper
    to the subview and a</st> `<st c="4423">@State</st>` <st c="4429">property wrapper
    to the</st> <st c="4454">parent view.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4466">Explaining the problem with the current observation situation</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="4528">The short recap of the current way observation works in SwiftUI
    emphasizes how complex and confusing it is to observe data</st> <st c="4652">in
    SwiftUI.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4663">Take, for example, the</st> `<st c="4687">ObservableObject</st>`
    <st c="4703">protocol – in most cases, we want to mark all of our properties with
    the</st> `<st c="4777">@Published</st>` <st c="4787">property wrapper.</st> <st
    c="4806">If that’s the case, why do we need to</st> <st c="4844">work hard?</st>
    <st c="4855">Don’t we have a way to add a</st> `<st c="4884">@Published</st>`
    <st c="4894">property wrapper to all</st> <st c="4919">our properties?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="4934">The observation framework uses Swift macros here, a feature that
    can help us reduce boilerplate code.</st> <st c="5037">To read more about it,
    go to</st> [*<st c="5066">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)
    <st c="5076">and read about</st> <st c="5092">Swift macros.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5105">Adding the @Observable macro</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="5134">The primary goal of the</st> <st c="5159">Observation framework
    is to simplify our work as much as possible, and it does that with the heavy use</st>
    <st c="5262">of macros.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5272">Let’s take a</st> `<st c="5286">Book</st>` <st c="5290">class,</st>
    <st c="5298">for example:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5493">The</st> `<st c="5498">Book</st>` <st c="5502">class is a standard</st>
    `<st c="5523">ObservableObject</st>` <st c="5539">class that contains four properties
    with a</st> `<st c="5583">@Published</st>` <st c="5593">property wrapper.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="5611">Using the</st> `<st c="5622">Observation</st>` <st c="5633">framework,
    we</st> <st c="5647">can get rid of all the property wrappers and the</st> `<st
    c="5697">ObservableObject</st>` <st c="5713">protocol and just add a macro attached
    to the</st> <st c="5760">class decl</st><st c="5770">aration:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: <st c="5912">The</st> `<st c="5917">@Observable</st>` <st c="5928">macro, like
    most macros, handles the tedious work on our behalf.</st> <st c="5994">It makes
    the</st> `<st c="6007">Book</st>` <st c="6011">struct observable and adds a publisher
    to</st> <st c="6054">its properties.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6069">Let’s try to use the</st> `<st c="6091">Book</st>` <st c="6095">class
    in</st> <st c="6105">a view:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: <st c="6280">In the preceding code, we have a button and a view with a</st>
    `<st c="6339">Text</st>` <st c="6343">view that displays the book title.</st>
    <st c="6379">Tapping on the button changes the</st> <st c="6413">book title.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6424">The change of the book</st> <st c="6447">title updates the text;
    however, the updates happen even though the book is not marked with a</st> `<st
    c="6542">@ObserverdObject</st>` <st c="6558">or</st> `<st c="6562">@StateObject</st>`
    <st c="6574">property wrapper!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6592">How can</st> <st c="6601">this be?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6609">Let’s dive a little bit deeper to</st> <st c="6644">find out!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6653">Learning how the @Observable macro works</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="6694">I know speaking about macros</st> <st c="6723">might get on your
    nerves, but do you remember that</st> `<st c="6775">@Observable</st>` <st c="6786">is
    a macro, and that we can</st> <st c="6815">expand it?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="6825">So, let’s expand it and see what’s going</st> <st c="6867">on there:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: <st c="7855">That’s a lot of work for one</st> <st c="7884">tiny macro!</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7895">It looks like there are also</st> <st c="7924">internal macr</st><st
    c="7938">os, such as</st> `<st c="7951">@ObservationTracked</st>`<st c="7970">,
    one of which</st> <st c="7985">I expanded.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="7996">So, what’s go</st><st c="8010">ing</st> <st c="8015">on here?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="8023">There are five things we can</st> <st c="8053">see here:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="8157">Observable</st>`<st c="8167">, not a protocol.</st> <st c="8185">The
    protocol itself is empty, but SwiftUI uses that to mark the class as observed.</st>
    <st c="8268">Using an extension, you</st> <st c="8291">can see the protocol conformation
    at the end of the</st> <st c="8344">macro code.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8378">observationRegistrar</st>`<st c="8398">: The</st> `<st c="8405">observationRegistrar</st>`
    <st c="8425">variable is a singleton struct responsible for managing the registration
    of observed class properties.</st> <st c="8529">SwiftUI relies on this struct
    to detect when an observed property is accessed</st> <st c="8607">or modified.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8709">Observation</st>` <st c="8720">framework needs these getters
    and setters to track every access or</st> <st c="8788">modification attempt.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="8947">@Observable</st>` <st c="8958">macro added a private variable
    for each original variable just for that.</st> <st c="9032">The getter and the
    setter use the private variable to return and mutate the</st> <st c="9108">stored
    values.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="9172">access()</st>` <st c="9180">and</st> `<st c="9185">withMutation()</st>`
    <st c="9199">methods.</st> <st c="9209">The computed variables call these methods
    to notify the</st> `<st c="9265">observationRegistrar</st>` <st c="9285">instance
    about any data modification access.</st> <st c="9331">Afterward, the</st> `<st
    c="9346">observationRegistrar</st>` <st c="9366">instance tells SwiftUI about</st>
    <st c="9396">these changes.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="9410">The reason we have so much code underneath is that the</st> *<st
    c="9466">Observation</st>* <st c="9477">framework’s goal is to simplify the process
    of observing data models.</st> <st c="9548">Conforming the class to the</st> *<st
    c="9576">Observable</st>* <st c="9586">protocol without the macro is not enough
    – marking the actual model with</st> `<st c="9660">@ObservedObject</st>` <st c="9675">would
    still be required in the SwiftUI view.</st> <st c="9721">The</st> *<st c="9725">Observation</st>*
    <st c="9736">framework tracks each property using its getter and setter methods,
    making it much cleaner to implement in</st> <st c="9844">our views.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9854">Notice that there’s a small macro inside that expanded code we
    haven’t discussed –</st> `<st c="9938">@</st>``<st c="9939">ObservationIgnored</st>`<st
    c="9957">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="9958">Excluding properties from observation using @ObservationIgnored</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="10022">We already</st> <st c="10034">understand that, unlike the</st>
    <st c="10062">previous pattern of adding the</st> `<st c="10093">@Published</st>`
    <st c="10103">property wrapper for each variable, in the</st> `<st c="10147">@Observable</st>`
    <st c="10158">macro, all the properties are observed</st> <st c="10198">by default.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10209">Let’s think of the consequences of that – how can it affect</st>
    <st c="10270">our work?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10279">The fact that every property is now observed means that each time
    it appears in our SwiftUI view and we modify it, our view</st> <st c="10404">gets
    updated.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10417">SwiftUI is indeed a highly optimized framework, but it is optimized
    because it only updates views when needed.</st> <st c="10529">If a</st> <st c="10534">particular
    data model property doesn’t need to be dynamic and observed, we should exclude
    it from tracking.</st> <st c="10642">It’s essential to balance observing many
    properties</st> <st c="10694">to keep our UI responsive and impact</st> <st c="10731">its
    performance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="10747">Let’s try to add a property that is not supposed to</st> <st c="10800">be
    observed:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: <st c="10991">In this code example, we added a property named</st> `<st c="11039">lastPageRead</st>`<st
    c="11051">. It’s an important property, but it doesn’t</st> <st c="11096">affect
    our UI state, and we don’t display or even consider it when laying our views.</st>
    <st c="11181">Therefore, we will ignore it using the</st> `<st c="11220">@</st>``<st
    c="11221">ObservationIgnored</st>` <st c="11239">macro.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11246">Unlike the</st> `<st c="11258">@ObservationTracked</st>` <st c="11277">macro,
    which the</st> `<st c="11295">@Observable</st>` <st c="11306">macro uses to create
    the getters and the setters for the observed properties,</st> `<st c="11385">@ObservationIgnored</st>`
    <st c="11404">doesn’t modify the property.</st> <st c="11434">SwiftUI uses that
    macro only to determine which property it doesn’t register using the</st> `<st
    c="11521">observati</st><st c="11530">onRegister</st>` <st c="11541">object.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11549">The default observation of</st> <st c="11576">all properties gives
    us another exciting and powerful feature out of the box – observing</st> **<st
    c="11666">computed variables</st>**<st c="11684">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11685">Observing computed variables</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="11714">First, a reminder – a computed variable is a property that has
    a getter and an optional setter.</st> <st c="11811">This means that a</st> <st
    c="11829">computed variable doesn’t have its storage, and its value is derived
    from other variables (which can also be</st> <st c="11938">computed variables).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="11958">Look at the</st> <st c="11971">following code:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: <st c="12169">The</st> `<st c="12173">Book</st>` <st c="12177">class conforms
    to the good old</st> `<st c="12209">ObservableObject</st>` <st c="12225">protocol.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12235">Notice that the</st> `<st c="12252">totalWordsInBook</st>` <st
    c="12268">property is a computed variable – it multiplies the</st> `<st c="12321">pages</st>`
    <st c="12326">and</st> `<st c="12331">averageWordsPerPage</st>` <st c="12350">variables
    to return the total number of words in</st> <st c="12400">the book.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12409">We want to observe the computed variable to present its results
    in one of our SwiftUI views, so we have marked it with the</st> `<st c="12533">@Published</st>`
    <st c="12543">property wrapper.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12561">Unfortunately, this is impossible.</st> <st c="12597">Try to compile
    results with the</st> <st c="12629">following error:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="12645">Property wrapper cannot be applied to a</st>* *<st c="12686">computed
    property</st>*'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12703">That’s a big downside for conforming to the</st> `<st c="12748">ObservableObject</st>`
    <st c="12764">protocol, as it can be a helpful</st> <st c="12798">use case.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="12807">Working with the Observable macro works t</st><st c="12849">his
    out</st> <st c="12858">quite nicely:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: <st c="13018">In the preceding code, we just</st> <st c="13050">added the computed
    variable, and we can observe it in our view with</st> <st c="13118">no problems.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13130">How does it work?</st> <st c="13149">How can we observe a computed
    variable if it doesn’t have a back store for</st> <st c="13224">its value?</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13234">So, there’s a reason why I always make sure to explain how things
    work underneath.</st> <st c="13318">If we go back to the</st> *<st c="13339">Learning
    how the @Observable macro works</st>* <st c="13379">section, we expanded the</st>
    `<st c="13405">@Observable</st>` <st c="13416">macro and saw interesting details
    of how the observation and tracking work.</st> <st c="13493">Every</st> <st c="13499">observed
    property becomes a computed value and is tracked using a getter and</st> <st c="13576">a
    setter.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="13585">So, when we add a computed variable whose value is derived from
    another observed property, it means that whenever we access this computed variable,
    we also access the other properties.</st> <st c="13771">This access triggers the</st>
    <st c="13796">observation framework.</st>
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="13818">Figure 3</st>**<st c="13827">.1</st>* <st c="13829">shows how
    observing computed variables works in a</st> <st c="13880">visual way:</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1: How SwiftUI observes computed variables](img/B21795_03_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '<st c="13988">Figure 3.1: How SwiftUI observes computed variables</st>'
  prefs: []
  type: TYPE_NORMAL
- en: '*<st c="14039">Figure 3</st>**<st c="14048">.1</st>* <st c="14050">nicely shows</st>
    <st c="14064">how the computed variables are derived from other properties and
    how accessing them would eventually go</st> <st c="14168">down to the</st> `<st
    c="14180">observationRegister</st>` <st c="14200">object.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14207">Let’s try to see that</st> <st c="14230">in action:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: <st c="14649">In the preceding code, we update the</st> `<st c="14687">averageWordsPerPage</st>`
    <st c="14706">and</st> `<st c="14711">pages</st>` <st c="14716">properties when</st>
    <st c="14732">tapping the</st> **<st c="14745">Change</st>** <st c="14751">button.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14759">The update triggers the observation</st> <st c="14795">framework
    and updates the view because we access</st> `<st c="14845">totalWordsInBook</st>`
    <st c="14861">in the following line, even though it’s a</st> <st c="14904">computed
    variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="14922">However, adding the</st> `<st c="14943">@ObservationIgnored</st>`
    <st c="14962">property to both of these properties (</st>`<st c="15001">averageWordsPerPage</st>`
    <st c="15021">and</st> `<st c="15026">pages</st>`<st c="15031">) won’t trigger
    the</st> `<st c="15052">totalWordsInBook</st>` <st c="15068">computed property
    because the</st> `<st c="15099">@Observation</st>` <st c="15111">framework can’t
    tell that something has changed.</st> <st c="15161">The nice thing is that we’ve
    learned how it works by expanding our</st> `<st c="15228">@</st>``<st c="15229">Observable</st>`
    <st c="15239">macro.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15246">By now,</st> <st c="15255">we know very well how the</st> `<st
    c="15281">@Observable</st>` <st c="15292">macro works and how variables and computed
    variables</st> <st c="15346">are observed.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15359">Now, let’s move one step</st> <st c="15384">further and see how
    to use</st> <st c="15411">these observed variables as</st> <st c="15440">environment
    variables.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15462">Working with environment variables</st>
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: <st c="15497">A view that works directly with an observed object is a common
    use case.</st> <st c="15571">For example, a view can work with a</st> `<st c="15607">ViewModel</st>`
    <st c="15616">class or have a SwiftData query that fetches data models from the</st>
    <st c="15683">persistent store.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15700">However, there are</st> <st c="15719">cases where we have an observed
    object shared across</st> <st c="15773">different views.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="15789">Some examples of such a use case are</st> <st c="15827">as follows:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '**<st c="15838">App settings</st>**<st c="15851">: The user profile is part
    of app settings and can be stored in an</st> <st c="15919">environment variable</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="15939">Themes and styling</st>**<st c="15958">: Primary color tint
    font style, spaces,</st> <st c="16000">and more</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**<st c="16008">User authentication state</st>**<st c="16034">: The login state
    is a good examp</st><st c="16068">le of an</st> <st c="16078">environment variable</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="16098">Sharing the same object down a view hierarchy can be cumbersome,
    but SwiftUI offers a helpful feature known as</st> **<st c="16210">environment
    variables</st>**<st c="16231">. While environment variables aren’t a recent addition
    to iOS (they have been available before iOS 17), the Observation framework provides</st>
    <st c="16370">comprehensive support.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16392">There are two ways of adding</st> <st c="16422">an environment
    variable to our project – by type or by keys.</st> <st c="16483">Let’s start with
    the more straightforward way:</st> <st c="16530">by type.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16538">Adding an environment variable by type</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="16577">Let’s try to add theming support for</st> <st c="16614">our books
    project.</st> <st c="16634">We’ll start by creating our</st> `<st c="16662">Themes</st>`
    <st c="16668">class:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '<st c="16735">Our</st> `<st c="16740">Themes</st>` <st c="16746">class has
    only one property for now: the primary color.</st> <st c="16803">Notice that we
    added the</st> `<st c="16828">@Observable</st>` <st c="16839">macro to update
    our UI when the</st> <st c="16872">theme changes.</st>'
  prefs: []
  type: TYPE_NORMAL
- en: <st c="16886">Next, we will add our observed object to our</st> `<st c="16932">BookApp</st>`
    <st c="16939">struct:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17083">In the</st> `<st c="17091">BookApp</st>` <st c="17098">struct,
    we’re making</st> <st c="17120">two changes:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="17264">@State</st>` <st c="17270">or</st> `<st c="17274">@ObservedObject</st>`<st
    c="17289">.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="17392">themes</st>` <st c="17398">object easily.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="17413">Now, let’s turn to our view</st> <st c="17442">and see how we
    can</st> <st c="17461">use it:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: <st c="17708">Adding the themes instance to our</st> `<st c="17743">ContentView</st>`
    <st c="17754">struct is straightforward.</st> <st c="17782">We’re using the</st>
    `<st c="17798">@Environment</st>` <st c="17810">property wrapper to inject the
    themes object we</st> <st c="17859">created earlier.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17875">We use the theme’s primary color in the body part to color our</st>
    <st c="17939">book title.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="17950">Now, we must note that we can use the environment variable in</st>
    *<st c="18013">every</st>* <st c="18018">view in the hierarchy, even if we haven’t</st>
    <st c="18061">initialized it with the</st> <st c="18085">environment modifier.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18106">Here’s an example</st> <st c="18125">of that:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: <st c="18384">In the preceding code, we created another SwiftUI component called</st>
    `<st c="18452">MyTitle</st>`<st c="18459">, which has the environment</st> <st
    c="18487">variable themes.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18503">The</st> `<st c="18508">MyTitle</st>` <st c="18515">view is part
    of the</st> `<st c="18536">ContentView</st>` <st c="18547">hierarchy.</st> <st
    c="18559">Therefore, it has direct access to the</st> `<st c="18598">themes</st>`
    <st c="18604">variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18614">Passing environment variables by type is simple!</st> <st c="18664">However,
    when working on a big scale, it has some drawbacks.</st> <st c="18725">I believe
    that the main disadvantage is that we are coupling our code to a specific type.</st>
    <st c="18815">In the</st> `<st c="18822">themes</st>` <st c="18828">example, we
    work with an explicit</st> <st c="18863">variety (</st>`<st c="18872">Themes</st>`<st
    c="18879">).</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18882">SwiftUI provides us with a</st> <st c="18909">better way to manage
    environment variables, and that’s working with</st> <st c="18978">environment
    keys.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="18995">Adding environment variable by key</st>
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: <st c="19030">Managing environment</st> <st c="19052">variables is much better
    when our project becomes</st> <st c="19102">more significant.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19119">Using environment keys improves the separation between our view
    and the</st> <st c="19192">actual variable.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="19208">To better manage environment values, SwiftUI has two</st> <st
    c="19262">primary components:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '`<st c="19281">EnvironmentValues</st>` **<st c="19299">struct</st>**<st c="19306">:
    This is a container of different environment values structured in a key-value
    form.</st> <st c="19393">It can be accessed from any view in the app.</st> <st
    c="19438">We can extend the struct and add</st> <st c="19471">new variables.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<st c="19485">EnvironmentKey</st>` **<st c="19500">protocol</st>**<st c="19509">:
    It allows us to add a key for a new variable and use that key to add a new</st>
    <st c="19587">environment value.</st>'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: <st c="19605">Let’s see how it works</st> <st c="19629">in practice:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: <st c="19835">The first thing that we did was add a new</st> `<st c="19878">EnvironmentKey</st>`
    <st c="19892">type named</st> `<st c="19904">ThemesKey</st>`<st c="19913">. Part
    of the</st> `<st c="19927">EnvironmentKey</st>` <st c="19941">protocol is setting
    the variable default value, which is, in this case, a</st> `<st c="20016">Themes</st>`
    <st c="20022">instance.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20032">Once we have a new environment key, we must add it to our</st>
    `<st c="20091">EnvironmentValues</st>` <st c="20108">container.</st> <st c="20120">We
    do that by extending the container and adding a new computed variable</st> <st
    c="20193">named</st> `<st c="20199">themes</st>`<st c="20205">.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20206">The getter and the setter are straightforward – the</st> `<st
    c="20259">get</st>` <st c="20262">function returns the value according to the
    relevant key (</st>`<st c="20321">ThemesKey</st>`<st c="20331">), and the</st>
    `<st c="20343">set</st>` <st c="20346">function stores a new variable on</st>
    <st c="20381">that key.</st>
  prefs: []
  type: TYPE_NORMAL
- en: <st c="20390">After we have extended</st> <st c="20413">the container, we can
    easily access that key from any view that</st> <st c="20478">we have:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: <st c="20569">Remember the environment modifier from earlier?</st> <st c="20618">We
    can remove</st> <st c="20632">it now:</st>
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'struct ContentView: View { <st c="22606">@State var email: String = ""</st>
    var body: some View {'
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'TextField("Email", text: <st c="22692">$email</st>)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'struct MyCounter: View { <st c="22958">@Binding var value: Int</st> var body:
    some View {'
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Button("Increase") {
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: value += 1
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'struct ContentView: View { <st c="23080">@State var count: Int = 0</st> var
    body: some View {'
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'MyCounter(value: <st c="23154">$count</st>)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Value = \(count)")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'struct ContentView: View { <st c="23962">var counter = Counter()</st> var body:
    some View {'
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: 'CounterView(counter: <st c="24038">counter</st>)'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Text("Value = \(counter.value)")
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: 'struct CounterView: View {'
  prefs: []
  type: TYPE_NORMAL
- en: '<st c="24114">@Bindable var counter: Counter</st> var body: some View {'
  prefs: []
  type: TYPE_NORMAL
- en: VStack {
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: Button("Increase") { <st c="24197">counter.increment()</st> }
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
