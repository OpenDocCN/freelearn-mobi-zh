- en: <st c="0">3</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">3</st>
- en: <st c="2">Understanding SwiftUI Observation</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">理解 SwiftUI 观察系统</st>
- en: <st c="35">In</st> [*<st c="39">Chapter 2</st>*](B21795_02.xhtml#_idTextAnchor043)<st
    c="48">, we discussed SwiftData, an essential framework for our data management.</st>
    <st c="122">However, for data management to be effective, we need something on
    the other side that can observe changes and display them for</st> <st c="250">the
    user.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="35">在第</st> [*<st c="39">第二章</st>*](B21795_02.xhtml#_idTextAnchor043)<st
    c="48">中，我们讨论了 SwiftData，这是我们数据管理的一个基本框架。</st> <st c="122">然而，为了使数据管理有效，我们还需要另一侧能够观察变化并向用户显示它们的东西。</st>
- en: <st c="259">SwiftUI contains tools that allow us to observe these changes effectively
    and bind them to actions and UI updates.</st> <st c="375">However, these tools
    have become complex and confusing over</st> <st c="435">the years.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="259">SwiftUI 包含允许我们有效地观察这些变化并将它们绑定到操作和 UI 更新的工具。</st> <st c="375">然而，这些工具在多年中变得复杂且令人困惑。</st>
- en: <st c="445">Now, we’re about to explore how observation has become significantly
    more straightforward, all while delving into the heart of SwiftUI’s</st> <st c="583">data
    flow.</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="445">现在，我们将探讨观察如何变得简单得多，同时深入到 SwiftUI 数据流的</st> <st c="583">核心。</st>
- en: <st c="593">In this chapter, we will cover the</st> <st c="629">following topics:</st>
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="593">在本章中，我们将涵盖以下主题：</st>
- en: <st c="646">Go over the SwiftUI observation system and discuss</st> <st c="698">its
    problems</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="646">回顾 SwiftUI 观察系统并讨论</st> <st c="698">其问题</st>
- en: <st c="710">Add the</st> `<st c="719">@Observable</st>` <st c="730">macro and
    learn how</st> <st c="751">it works</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="710">添加</st> `<st c="719">@Observable</st>` <st c="730">宏并学习它是如何</st>
    <st c="751">工作的</st>
- en: <st c="759">Discuss observing properties, including</st> <st c="800">computed
    variables</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="759">讨论观察属性，包括</st> <st c="800">计算变量</st>
- en: <st c="818">Work with environment variables and adapt them to the</st> <st c="873">new
    framework</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="818">使用环境变量并将它们适应到</st> <st c="873">新框架</st>
- en: <st c="886">Talk about the new</st> `<st c="906">@Bindable</st>` <st c="915">property
    wrapper</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="886">讨论新的</st> `<st c="906">@Bindable</st>` <st c="915">属性包装器</st>
- en: <st c="932">Learn how to migrate our app to work with the</st> <st c="979">Observation
    framework</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="932">学习如何将我们的应用程序迁移到与</st> <st c="979">观察框架</st> <st c="994">一起工作</st>
- en: <st c="1000">Are you ready</st> <st c="1015">to start?</st>
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1000">准备好开始了吗？</st> <st c="1015">？</st>
- en: <st c="1024">Technical requirements</st>
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1024">技术要求</st>
- en: <st c="1047">This chapter includes many code examples, some of which can be
    found in the following GitHub</st> <st c="1141">repository:</st> [<st c="1153">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1047">本章包含许多代码示例，其中一些可以在以下 GitHub</st> <st c="1141">仓库中找到：</st> [<st
    c="1153">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter3)
- en: <st c="1235">To run them, we will need Xcode 15</st> <st c="1271">or newer.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1235">要运行它们，我们需要 Xcode 15</st> <st c="1271">或更高版本。</st>
- en: <st c="1280">Going over the SwiftUI observation system</st>
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1280">回顾 SwiftUI 观察系统</st>
- en: <st c="1322">Before we discuss the</st> <st c="1344">current SwiftUI observation
    system, let’s recap the SwiftUI</st> <st c="1405">observation system.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1322">在我们讨论当前的 SwiftUI 观察系统之前，让我们回顾一下 SwiftUI</st> <st c="1405">观察系统。</st>
- en: <st c="1424">Before Xcode 15, nine property wrappers handled state and data
    updates</st> <st c="1496">in SwiftUI.</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1424">在 Xcode 15 之前，九个属性包装器处理了 SwiftUI 中的状态和数据更新</st> <st c="1496">。</st>
- en: <st c="1507">Let’s try to group them by</st> <st c="1535">app levels:</st>
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1507">让我们尝试按</st> <st c="1535">应用程序级别</st> <st c="1540">对它们进行分组：</st>
- en: '`<st c="1564">@</st>``<st c="1565">Binding</st>`<st c="1572">,</st> `<st c="1574">@Environment</st>`'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1564">@</st>``<st c="1565">Binding</st>`<st c="1572">,</st> `<st c="1574">@Environment</st>`'
- en: '`<st c="1600">@State</st>`<st c="1606">,</st> `<st c="1608">@Binding</st>`<st
    c="1616">,</st> `<st c="1618">@</st>``<st c="1619">StateObject</st>`<st c="1630">,</st>
    `<st c="1632">@Environment</st>`'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1600">@State</st>`<st c="1606">,</st> `<st c="1608">@Binding</st>`<st
    c="1616">,</st> `<st c="1618">@</st>``<st c="1619">StateObject</st>`<st c="1630">,</st>
    `<st c="1632">@Environment</st>`'
- en: '`<st c="1668">@</st>``<st c="1669">ObservableObject</st>`<st c="1685">,</st>
    `<st c="1687">@Published</st>`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1668">@</st>``<st c="1669">ObservableObject</st>`<st c="1685">,</st>
    `<st c="1687">@Published</st>`'
- en: '`<st c="1715">@AppStorage</st>`<st c="1726">,</st> `<st c="1728">@</st>``<st
    c="1729">SceneStorage</st>`<st c="1741">,</st> `<st c="1743">@EnvironementObject</st>`'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="1715">@AppStorage</st>`、`<st c="1726">@</st>` `<st c="1729">SceneStorage</st>`、`<st
    c="1741">@EnvironmentObject</st>`'
- en: <st c="1762">The different levels give us an idea of the different roles of
    the different wrappers.</st> <st c="1850">Let’s touch on some of these wrappers
    to understand how the</st> <st c="1910">system works.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="1762">不同的级别让我们了解不同包装器的不同角色。</st>` `<st c="1850">让我们来探讨一些这些包装器，以了解系统是如何工作的。</st>`'
- en: <st c="1923">A local</st> `<st c="1932">@State</st>` <st c="1938">property wrapper
    manages the state of primitive properties within the view.</st> <st c="2015">For
    example, whether a specific view is hidden, the number of available buttons, the
    current sorting method, and more are managed by</st> <st c="2148">this wrapper.</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="1923">一个本地的</st>` `<st c="1932">@State</st>` 属性包装器管理视图内部原始属性的状态。例如，一个特定视图是否隐藏、可用按钮的数量、当前排序方法等都是由这个包装器管理的。'
- en: <st c="2161">The reason why we use a</st> `<st c="2186">@State</st>` <st c="2192">property
    wrapper is because SwiftUI views are immutable.</st> <st c="2250">This means that
    SwiftUI rebuilds the view each time a change occurs, but the</st> `<st c="2327">@State</st>`
    <st c="2333">values don’t change between one rendering session</st> <st c="2384">and
    another.</st>
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="2161">我们使用 <st c="2186">@State</st>` 属性包装器的原因是 SwiftUI 视图是不可变的。</st>`
    `<st c="2192">这意味着 SwiftUI 每次发生变化时都会重建视图，但 <st c="2327">@State</st>` `<st c="2333">值在渲染会话之间不会改变。</st>`'
- en: <st c="2396">The problem begins when we base our view on data model information.</st>
    <st c="2465">An example of this would be a bookstore app that displays a list
    of books from a local data file.</st> <st c="2563">In this case, our view must
    work with another data model object using the</st> `<st c="2637">ObservableObject</st>`
    <st c="2653">protocol.</st>
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="2396">问题开始于我们基于数据模型信息构建视图的时候。</st>` `<st c="2465">例如，一个书店应用从本地数据文件中显示书籍列表的情况。</st>`
    `<st c="2563">在这种情况下，我们的视图必须使用 `<st c="2637">ObservableObject</st>` 协议与另一个数据模型对象协同工作。</st>'
- en: <st c="2663">Let’s go over</st> <st c="2678">it now.</st>
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="2663">现在我们来回顾一下</st>`。'
- en: <st c="2685">Conforming to the ObservableObject protocol</st>
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="2685">遵守 ObservableObject 协议</st>`'
- en: <st c="2729">We can use the</st> `<st c="2745">ObservableObject</st>` <st c="2761">protocol
    in conjunction with the</st> `<st c="2795">@ObservedObject</st>` <st c="2810">property</st>
    <st c="2820">wrapper for</st> <st c="2832">classes that need to</st> <st c="2853">be
    observed.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `<st c="2729">ObservableObject</st>` 协议与 `<st c="2795">@ObservedObject</st>`
    属性包装器一起用于需要被观察的类。
- en: <st c="2865">Here’s an example of a</st> `<st c="2889">UserData</st>` <st c="2897">class
    which becomes an</st> `<st c="2921">@ObservedObject</st>` <st c="2937">property
    wrapper:</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="2865">这是一个 <st c="2889">UserData</st>` 类的例子，它成为一个 `<st c="2921">@ObservedObject</st>`
    属性包装器：</st>`'
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="3175">There are three parts to</st> <st c="3200">implementing a data</st>
    <st c="3221">class observation:</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="3175">实现数据类观察有三个部分：</st>`'
- en: '`<st c="3254">ObservableObject</st>`<st c="3270">: If we want a class to be
    observed in SwiftUI, it must conform to the</st> `<st c="3342">ObservableObject</st>`
    <st c="3358">protocol.</st> <st c="3369">This indicates to SwiftUI that</st> <st
    c="3400">any instance derived from this class can be observed in</st> <st c="3456">a
    view.</st>'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="3254">ObservableObject</st>`：如果我们想让一个类在 SwiftUI 中被观察，它必须遵守 `<st c="3342">ObservableObject</st>`
    协议。这表示 SwiftUI，任何从这个类派生出的实例都可以在视图中被观察。'
- en: '`<st c="3475">@Published</st>``<st c="3536">@Published</st>` <st c="3546">property
    wrapper, SwiftUI creates a publisher and uses it inside the</st> <st c="3616">SwiftUI
    views.</st>'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="3475">@Published</st>` `<st c="3536">@Published</st>` 属性包装器，SwiftUI
    创建了一个发布者，并在 SwiftUI 视图中使用它。'
- en: '`<st c="3658">@ObservedObject</st>``<st c="3697">@ObservedObject</st>` <st
    c="3712">property wrapper establishes a connection between the view and the object,
    allowing the view to be notified</st> <st c="3821">of chan</st><st c="3828">ges.</st>'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`<st c="3658">@ObservedObject</st>` `<st c="3697">@ObservedObject</st>` 属性包装器在视图和对象之间建立连接，允许视图在变化时被通知。'
- en: <st c="3833">It’s essential to remember that the</st> `<st c="3870">@ObservedObject</st>`
    <st c="3885">property wrapper is solely for observation purposes – this means
    that the view cannot modify the observed object</st> <st c="3999">properties directly.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3833">记住，`<st c="3870">@ObservedObject</st>` <st c="3885">属性包装器仅用于观察目的——这意味着视图不能直接修改观察对象的属性。</st>
- en: <st c="4019">If we want to change the observed object properties, we must use
    another property wrapper –</st> `<st c="4112">@</st>``<st c="4113">StateObj</st><st
    c="4121">ect</st>`<st c="4125">.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4019">如果我们想更改观察对象属性，我们必须使用另一个属性包装器——</st> `<st c="4112">@</st>``<st c="4113">StateObj</st><st
    c="4121">ect</st>`<st c="4125">。</st>
- en: <st c="4126">A</st> `<st c="4129">@StateObject</st>` <st c="4141">property wrapper
    is similar to</st> `<st c="4173">@State</st>`<st c="4179">, only that it works
    with observable objects and not</st> <st c="4232">primitive values.</st>
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4126">一个</st> `<st c="4129">@StateObject</st>` <st c="4141">属性包装器与</st>
    `<st c="4173">@State</st>`<st c="4179">类似，只是它适用于可观察对象而不是</st> <st c="4232">原始值。</st>
- en: <st c="4249">However, that doesn’t end</st> <st c="4276">here – if we want to
    create a two-way connection between the view and its subview, we need</st> <st
    c="4367">to add a</st> `<st c="4376">@Binding</st>` <st c="4384">property wrapper
    to the subview and a</st> `<st c="4423">@State</st>` <st c="4429">property wrapper
    to the</st> <st c="4454">parent view.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4249">然而，这还没有结束——如果我们想在视图和其子视图之间创建双向连接，我们需要</st> <st c="4367">在子视图中添加一个</st>
    `<st c="4376">@Binding</st>` <st c="4384">属性包装器，并在父视图中添加一个</st> `<st c="4423">@State</st>`
    <st c="4429">属性包装器。</st>
- en: <st c="4466">Explaining the problem with the current observation situation</st>
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="4466">解释当前观察情况的问题</st>
- en: <st c="4528">The short recap of the current way observation works in SwiftUI
    emphasizes how complex and confusing it is to observe data</st> <st c="4652">in
    SwiftUI.</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4528">对当前SwiftUI中观察数据方式的简要回顾强调了在SwiftUI中观察数据是多么复杂和令人困惑。</st>
- en: <st c="4663">Take, for example, the</st> `<st c="4687">ObservableObject</st>`
    <st c="4703">protocol – in most cases, we want to mark all of our properties with
    the</st> `<st c="4777">@Published</st>` <st c="4787">property wrapper.</st> <st
    c="4806">If that’s the case, why do we need to</st> <st c="4844">work hard?</st>
    <st c="4855">Don’t we have a way to add a</st> `<st c="4884">@Published</st>`
    <st c="4894">property wrapper to all</st> <st c="4919">our properties?</st>
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4663">以</st> `<st c="4687">ObservableObject</st>` <st c="4703">协议</st>
    <st c="4777">为例</st>，在大多数情况下，我们希望将所有属性标记为使用</st> `<st c="4777">@Published</st>`
    <st c="4787">属性包装器</st>。如果这样，为什么我们还需要努力工作呢？难道我们没有一种方法可以将</st> `<st c="4777">@Published</st>`
    <st c="4884">属性包装器添加到所有</st> <st c="4919">属性中吗？
- en: <st c="4934">The observation framework uses Swift macros here, a feature that
    can help us reduce boilerplate code.</st> <st c="5037">To read more about it,
    go to</st> [*<st c="5066">Chapter 10</st>*](B21795_10.xhtml#_idTextAnchor329)
    <st c="5076">and read about</st> <st c="5092">Swift macros.</st>
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4934">观察框架在这里使用Swift宏，这是一个可以帮助我们减少样板代码的功能。</st> <st c="5037">要了解更多信息，请访问</st>
    [*<st c="5066">第10章</st>*](B21795_10.xhtml#_idTextAnchor329) <st c="5076">并了解</st>
    <st c="5092">Swift宏。</st>
- en: <st c="5105">Adding the @Observable macro</st>
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="5105">添加`@Observable`宏</st>
- en: <st c="5134">The primary goal of the</st> <st c="5159">Observation framework
    is to simplify our work as much as possible, and it does that with the heavy use</st>
    <st c="5262">of macros.</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5134">观察框架的主要目标是尽可能简化我们的工作，它通过大量使用宏来实现这一点。</st>
- en: <st c="5272">Let’s take a</st> `<st c="5286">Book</st>` <st c="5290">class,</st>
    <st c="5298">for example:</st>
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5272">让我们以</st> `<st c="5286">Book</st>` <st c="5290">类</st> <st c="5298">为例：</st>
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="5493">The</st> `<st c="5498">Book</st>` <st c="5502">class is a standard</st>
    `<st c="5523">ObservableObject</st>` <st c="5539">class that contains four properties
    with a</st> `<st c="5583">@Published</st>` <st c="5593">property wrapper.</st>
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5493">`<st c="5498">Book</st>` <st c="5502">`类是一个标准的`<st c="5523">ObservableObject</st>`
    <st c="5539">类，包含四个属性，每个属性都使用`<st c="5583">@Published</st>` <st c="5593">属性包装器。</st>
- en: <st c="5611">Using the</st> `<st c="5622">Observation</st>` <st c="5633">framework,
    we</st> <st c="5647">can get rid of all the property wrappers and the</st> `<st
    c="5697">ObservableObject</st>` <st c="5713">protocol and just add a macro attached
    to the</st> <st c="5760">class decl</st><st c="5770">aration:</st>
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5611">使用</st> `<st c="5622">Observation</st>` <st c="5633">框架，我们可以摆脱所有的属性包装器和</st>
    `<st c="5697">ObservableObject</st>` <st c="5713">协议，只需在</st> <st c="5760">类声明</st><st
    c="5770">中添加一个宏：</st>
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="5912">The</st> `<st c="5917">@Observable</st>` <st c="5928">macro, like
    most macros, handles the tedious work on our behalf.</st> <st c="5994">It makes
    the</st> `<st c="6007">Book</st>` <st c="6011">struct observable and adds a publisher
    to</st> <st c="6054">its properties.</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5912">`<st c="5917">@Observable</st>` <st c="5928">宏，像大多数宏一样，为我们处理繁琐的工作。</st>
    <st c="5994">它使`<st c="6007">Book</st>` <st c="6011">结构体可观察，并为它的属性添加了一个发布者。</st>
- en: <st c="6069">Let’s try to use the</st> `<st c="6091">Book</st>` <st c="6095">class
    in</st> <st c="6105">a view:</st>
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6069">让我们尝试在一个</st> `<st c="6091">Book</st>` <st c="6095">类中</st> `<st
    c="6105">使用视图：</st>
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="6280">In the preceding code, we have a button and a view with a</st>
    `<st c="6339">Text</st>` <st c="6343">view that displays the book title.</st>
    <st c="6379">Tapping on the button changes the</st> <st c="6413">book title.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6280">在上面的代码中，我们有一个按钮和一个带有</st> `<st c="6339">Text</st>` <st c="6343">视图的视图，该视图显示书籍标题。</st>
    <st c="6379">点击按钮会更改书籍标题。</st>
- en: <st c="6424">The change of the book</st> <st c="6447">title updates the text;
    however, the updates happen even though the book is not marked with a</st> `<st
    c="6542">@ObserverdObject</st>` <st c="6558">or</st> `<st c="6562">@StateObject</st>`
    <st c="6574">property wrapper!</st>
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6424">书籍标题的更改更新了文本；然而，即使书籍没有标记为</st> `<st c="6542">@ObserverdObject</st>`
    <st c="6558">或</st> `<st c="6562">@StateObject</st>` <st c="6574">属性包装器，更新也会发生！</st>
- en: <st c="6592">How can</st> <st c="6601">this be?</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6592">这怎么可能？</st>
- en: <st c="6609">Let’s dive a little bit deeper to</st> <st c="6644">find out!</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6609">让我们深入一点，</st> <st c="6644">看看发生了什么！</st>
- en: <st c="6653">Learning how the @Observable macro works</st>
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="6653">了解 @Observable 宏的工作原理</st>
- en: <st c="6694">I know speaking about macros</st> <st c="6723">might get on your
    nerves, but do you remember that</st> `<st c="6775">@Observable</st>` <st c="6786">is
    a macro, and that we can</st> <st c="6815">expand it?</st>
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6694">我知道谈论宏可能会让你感到厌烦，但你记得</st> `<st c="6775">@Observable</st>` <st c="6786">是一个宏，而且我们可以</st>
    <st c="6815">展开它吗？</st>
- en: <st c="6825">So, let’s expand it and see what’s going</st> <st c="6867">on there:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6825">所以，让我们展开它，看看发生了什么：</st>
- en: '[PRE4]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="7855">That’s a lot of work for one</st> <st c="7884">tiny macro!</st>
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7855">这为一个</st> <st c="7884">微小的宏做了很多工作！</st>
- en: <st c="7895">It looks like there are also</st> <st c="7924">internal macr</st><st
    c="7938">os, such as</st> `<st c="7951">@ObservationTracked</st>`<st c="7970">,
    one of which</st> <st c="7985">I expanded.</st>
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7895">看起来还有</st> <st c="7924">内部宏</st><st c="7938">，例如</st> `<st c="7951">@ObservationTracked</st>`<st
    c="7970">，其中之一</st> <st c="7985">我已经展开了。</st>
- en: <st c="7996">So, what’s go</st><st c="8010">ing</st> <st c="8015">on here?</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7996">所以，这里发生了什么？</st>
- en: <st c="8023">There are five things we can</st> <st c="8053">see here:</st>
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8023">这里有五件事情我们可以</st> <st c="8053">看到：</st>
- en: '`<st c="8157">Observable</st>`<st c="8167">, not a protocol.</st> <st c="8185">The
    protocol itself is empty, but SwiftUI uses that to mark the class as observed.</st>
    <st c="8268">Using an extension, you</st> <st c="8291">can see the protocol conformation
    at the end of the</st> <st c="8344">macro code.</st>'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8157">Observable</st>`<st c="8167">，不是一个协议。</st> <st c="8185">该协议本身是空的，但SwiftUI使用它来标记类为被观察的。</st>
    <st c="8268">使用扩展，你</st> <st c="8291">可以在宏代码的末尾看到协议的符合情况。</st>'
- en: '`<st c="8378">observationRegistrar</st>`<st c="8398">: The</st> `<st c="8405">observationRegistrar</st>`
    <st c="8425">variable is a singleton struct responsible for managing the registration
    of observed class properties.</st> <st c="8529">SwiftUI relies on this struct
    to detect when an observed property is accessed</st> <st c="8607">or modified.</st>'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8378">observationRegistrar</st>`<st c="8398">：`<st c="8405">observationRegistrar</st>`
    <st c="8425">变量是一个单例结构体，负责管理被观察类属性的注册。</st> <st c="8529">SwiftUI依赖于这个结构体来检测当被观察属性被访问</st>
    <st c="8607">或修改时。</st>'
- en: '`<st c="8709">Observation</st>` <st c="8720">framework needs these getters
    and setters to track every access or</st> <st c="8788">modification attempt.</st>'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8709">Observation</st>` <st c="8720">框架需要这些获取器和设置器来跟踪每个访问或</st> <st
    c="8788">修改尝试。</st>'
- en: '`<st c="8947">@Observable</st>` <st c="8958">macro added a private variable
    for each original variable just for that.</st> <st c="9032">The getter and the
    setter use the private variable to return and mutate the</st> <st c="9108">stored
    values.</st>'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8947">@Observable</st>` <st c="8958">宏为每个原始变量添加了一个私有变量，仅为此目的。</st>
    <st c="9032">获取器和设置器使用私有变量来返回和修改存储的值。</st>'
- en: '`<st c="9172">access()</st>` <st c="9180">and</st> `<st c="9185">withMutation()</st>`
    <st c="9199">methods.</st> <st c="9209">The computed variables call these methods
    to notify the</st> `<st c="9265">observationRegistrar</st>` <st c="9285">instance
    about any data modification access.</st> <st c="9331">Afterward, the</st> `<st
    c="9346">observationRegistrar</st>` <st c="9366">instance tells SwiftUI about</st>
    <st c="9396">these changes.</st>'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9172">access()</st>` <st c="9180">和</st> `<st c="9185">withMutation()</st>`
    <st c="9199">方法。</st> <st c="9209">计算变量调用这些方法来通知</st> `<st c="9265">observationRegistrar</st>`
    <st c="9285">实例关于任何数据修改访问。</st> <st c="9331">之后，</st> `<st c="9346">observationRegistrar</st>`
    <st c="9366">实例会告诉 SwiftUI 这些变化。</st>'
- en: <st c="9410">The reason we have so much code underneath is that the</st> *<st
    c="9466">Observation</st>* <st c="9477">framework’s goal is to simplify the process
    of observing data models.</st> <st c="9548">Conforming the class to the</st> *<st
    c="9576">Observable</st>* <st c="9586">protocol without the macro is not enough
    – marking the actual model with</st> `<st c="9660">@ObservedObject</st>` <st c="9675">would
    still be required in the SwiftUI view.</st> <st c="9721">The</st> *<st c="9725">Observation</st>*
    <st c="9736">framework tracks each property using its getter and setter methods,
    making it much cleaner to implement in</st> <st c="9844">our views.</st>
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9410">我们下面有这么多代码的原因是，</st> *<st c="9466">Observation</st>* <st c="9477">框架的目标是简化观察数据模型的过程。</st>
    <st c="9548">没有宏，使类符合</st> *<st c="9576">Observable</st>* <st c="9586">协议是不够的
    – 在 SwiftUI 视图中仍然需要用</st> `<st c="9660">@ObservedObject</st>` <st c="9675">标记实际的模型。</st>
    <st c="9721">*<st c="9725">Observation</st>* <st c="9736">框架通过其 getter 和 setter
    方法跟踪每个属性，这使得它在我们的视图中实现起来更加简洁。</st>
- en: <st c="9854">Notice that there’s a small macro inside that expanded code we
    haven’t discussed –</st> `<st c="9938">@</st>``<st c="9939">ObservationIgnored</st>`<st
    c="9957">.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9854">请注意，在我们之前讨论的展开代码中有一个小的宏 –</st> `<st c="9938">@</st>``<st c="9939">ObservationIgnored</st>`<st
    c="9957">。</st>
- en: <st c="9958">Excluding properties from observation using @ObservationIgnored</st>
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="9958">使用 @ObservationIgnored 排除属性观察</st>
- en: <st c="10022">We already</st> <st c="10034">understand that, unlike the</st>
    <st c="10062">previous pattern of adding the</st> `<st c="10093">@Published</st>`
    <st c="10103">property wrapper for each variable, in the</st> `<st c="10147">@Observable</st>`
    <st c="10158">macro, all the properties are observed</st> <st c="10198">by default.</st>
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10022">我们已经</st> <st c="10034">了解到，与之前为每个变量添加</st> `<st c="10093">@Published</st>`
    <st c="10103">属性包装器的模式不同，在</st> `<st c="10147">@Observable</st>` <st c="10158">宏中，所有属性默认都是被观察的。</st>
- en: <st c="10209">Let’s think of the consequences of that – how can it affect</st>
    <st c="10270">our work?</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10209">让我们思考一下这个的后果 – 它会如何影响</st> <st c="10270">我们的工作？</st>
- en: <st c="10279">The fact that every property is now observed means that each time
    it appears in our SwiftUI view and we modify it, our view</st> <st c="10404">gets
    updated.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10279">每个属性现在都被观察的事实意味着每次它在我们的 SwiftUI 视图中出现并且我们修改它时，我们的视图</st> <st c="10404">都会被更新。</st>
- en: <st c="10417">SwiftUI is indeed a highly optimized framework, but it is optimized
    because it only updates views when needed.</st> <st c="10529">If a</st> <st c="10534">particular
    data model property doesn’t need to be dynamic and observed, we should exclude
    it from tracking.</st> <st c="10642">It’s essential to balance observing many
    properties</st> <st c="10694">to keep our UI responsive and impact</st> <st c="10731">its
    performance.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10417">SwiftUI 确实是一个高度优化的框架，但它是优化了，因为它只在需要时更新视图。</st> <st c="10529">如果一个特定的数据模型属性不需要是动态的和被观察的，我们应该将其排除在跟踪之外。</st>
    <st c="10642">保持我们的 UI 响应并影响</st> <st c="10694">其性能，观察许多属性是至关重要的。</st>
- en: <st c="10747">Let’s try to add a property that is not supposed to</st> <st c="10800">be
    observed:</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10747">让我们尝试添加一个不应该</st> <st c="10800">被观察的属性：</st>
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="10991">In this code example, we added a property named</st> `<st c="11039">lastPageRead</st>`<st
    c="11051">. It’s an important property, but it doesn’t</st> <st c="11096">affect
    our UI state, and we don’t display or even consider it when laying our views.</st>
    <st c="11181">Therefore, we will ignore it using the</st> `<st c="11220">@</st>``<st
    c="11221">ObservationIgnored</st>` <st c="11239">macro.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="10991">在这个代码示例中，我们添加了一个名为</st> `<st c="11039">lastPageRead</st>`<st c="11051">的属性。这是一个重要的属性，但它不影响我们的
    UI 状态，我们在布局视图时不会显示或考虑它。</st> <st c="11181">因此，我们将使用</st> `<st c="11220">@</st>``<st
    c="11221">ObservationIgnored</st>` <st c="11239">宏来忽略它。</st>
- en: <st c="11246">Unlike the</st> `<st c="11258">@ObservationTracked</st>` <st c="11277">macro,
    which the</st> `<st c="11295">@Observable</st>` <st c="11306">macro uses to create
    the getters and the setters for the observed properties,</st> `<st c="11385">@ObservationIgnored</st>`
    <st c="11404">doesn’t modify the property.</st> <st c="11434">SwiftUI uses that
    macro only to determine which property it doesn’t register using the</st> `<st
    c="11521">observati</st><st c="11530">onRegister</st>` <st c="11541">object.</st>
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="11246">与 `<st c="11258">@ObservationTracked</st>` `<st c="11277">宏不同，该宏是
    `<st c="11295">@Observable</st>` `<st c="11306">宏用来创建观察属性获取器和设置器的，` `<st c="11385">@ObservationIgnored</st>`
    `<st c="11404">不会修改属性。</st>` `<st c="11434">SwiftUI 只使用该宏来确定它不使用 `<st c="11521">观察</st>`
    `<st c="11530">注册</st>` `<st c="11541">对象。</st>`'
- en: <st c="11549">The default observation of</st> <st c="11576">all properties gives
    us another exciting and powerful feature out of the box – observing</st> **<st
    c="11666">computed variables</st>**<st c="11684">.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="11549">默认观察所有属性为我们提供了一个即插即用的令人兴奋且强大的功能——观察` `<st c="11666">计算变量</st>`
    `<st c="11684">。</st>`'
- en: <st c="11685">Observing computed variables</st>
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`<st c="11685">观察计算变量`'
- en: <st c="11714">First, a reminder – a computed variable is a property that has
    a getter and an optional setter.</st> <st c="11811">This means that a</st> <st
    c="11829">computed variable doesn’t have its storage, and its value is derived
    from other variables (which can also be</st> <st c="11938">computed variables).</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="11714">首先，提醒一下——计算变量是一个具有获取器和可选设置器的属性。</st>` `<st c="11811">这意味着计算变量没有自己的存储，其值是从其他变量（也可以是计算变量）派生出来的。</st>`'
- en: <st c="11958">Look at the</st> <st c="11971">following code:</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="11958">看看下面的代码：</st>`'
- en: '[PRE6]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="12169">The</st> `<st c="12173">Book</st>` <st c="12177">class conforms
    to the good old</st> `<st c="12209">ObservableObject</st>` <st c="12225">protocol.</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12169">` `<st c="12173">Book</st>` `<st c="12177">类遵循古老的 `<st c="12209">ObservableObject</st>`
    `<st c="12225">协议。</st>`'
- en: <st c="12235">Notice that the</st> `<st c="12252">totalWordsInBook</st>` <st
    c="12268">property is a computed variable – it multiplies the</st> `<st c="12321">pages</st>`
    <st c="12326">and</st> `<st c="12331">averageWordsPerPage</st>` <st c="12350">variables
    to return the total number of words in</st> <st c="12400">the book.</st>
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12235">注意，` `<st c="12252">totalWordsInBook</st>` `<st c="12268">属性是一个计算变量——它将`
    `<st c="12321">pages</st>` `<st c="12326">和` `<st c="12331">averageWordsPerPage</st>`
    `<st c="12350">变量相乘，以返回书中的总字数。</st>`'
- en: <st c="12409">We want to observe the computed variable to present its results
    in one of our SwiftUI views, so we have marked it with the</st> `<st c="12533">@Published</st>`
    <st c="12543">property wrapper.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望观察计算变量，以便在我们的 SwiftUI 视图中展示其结果，因此我们使用 `<st c="12409">` `<st c="12533">@Published</st>`
    `<st c="12543">属性包装器。</st>`
- en: <st c="12561">Unfortunately, this is impossible.</st> <st c="12597">Try to compile
    results with the</st> <st c="12629">following error:</st>
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12561">遗憾的是，这是不可能的。</st>` `<st c="12597">尝试使用以下错误编译结果：</st>` `<st c="12629">`'
- en: '*<st c="12645">Property wrapper cannot be applied to a</st>* *<st c="12686">computed
    property</st>*'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*`<st c="12645">属性包装器不能应用于计算属性</st>`* *`<st c="12686">`*'
- en: <st c="12703">That’s a big downside for conforming to the</st> `<st c="12748">ObservableObject</st>`
    <st c="12764">protocol, as it can be a helpful</st> <st c="12798">use case.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12703">遵循 `<st c="12748">ObservableObject</st>` `<st c="12764">协议有一个很大的缺点，因为它可能是一个有用的用例。</st>`'
- en: <st c="12807">Working with the Observable macro works t</st><st c="12849">his
    out</st> <st c="12858">quite nicely:</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="12807">使用 Observable 宏可以很好地解决这个问题：</st>` `<st c="12849">`'
- en: '[PRE7]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="13018">In the preceding code, we just</st> <st c="13050">added the computed
    variable, and we can observe it in our view with</st> <st c="13118">no problems.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们只是添加了计算变量，并且我们可以没有问题地在我们的视图中观察它 `<st c="13018">` `<st c="13050">`
    `<st c="13118">`。
- en: <st c="13130">How does it work?</st> <st c="13149">How can we observe a computed
    variable if it doesn’t have a back store for</st> <st c="13224">its value?</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="13130">它是如何工作的？</st>` `<st c="13149">如果一个计算变量没有其值的后端存储，我们如何观察它？</st>`'
- en: <st c="13234">So, there’s a reason why I always make sure to explain how things
    work underneath.</st> <st c="13318">If we go back to the</st> *<st c="13339">Learning
    how the @Observable macro works</st>* <st c="13379">section, we expanded the</st>
    `<st c="13405">@Observable</st>` <st c="13416">macro and saw interesting details
    of how the observation and tracking work.</st> <st c="13493">Every</st> <st c="13499">observed
    property becomes a computed value and is tracked using a getter and</st> <st c="13576">a
    setter.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13234">因此，我总是确保解释事物底层工作原理的原因。</st> <st c="13318">如果我们回到</st> *<st c="13339">学习@Observable宏的工作原理</st>
    <st c="13379">部分，我们扩展了</st> `<st c="13405">@Observable</st> <st c="13416">宏，并看到了观察和跟踪工作的有趣细节。</st>
    <st c="13493">每个</st> <st c="13499">观察属性都成为一个计算值，并使用getter和</st> <st c="13576">setter进行跟踪。</st>
- en: <st c="13585">So, when we add a computed variable whose value is derived from
    another observed property, it means that whenever we access this computed variable,
    we also access the other properties.</st> <st c="13771">This access triggers the</st>
    <st c="13796">observation framework.</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13585">因此，当我们添加一个值从另一个观察属性派生的计算变量时，这意味着每次我们访问这个计算变量时，也会访问其他属性。</st> <st
    c="13771">这种访问触发了</st> <st c="13796">观察框架。</st>
- en: '*<st c="13818">Figure 3</st>**<st c="13827">.1</st>* <st c="13829">shows how
    observing computed variables works in a</st> <st c="13880">visual way:</st>'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="13818">图3</st>**<st c="13827">.1</st> <st c="13829">以可视化的方式展示了观察计算变量是如何工作的：</st>'
- en: '![Figure 3.1: How SwiftUI observes computed variables](img/B21795_03_1.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1：SwiftUI如何观察计算变量](img/B21795_03_1.jpg)'
- en: '<st c="13988">Figure 3.1: How SwiftUI observes computed variables</st>'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13988">图3.1：SwiftUI如何观察计算变量</st>
- en: '*<st c="14039">Figure 3</st>**<st c="14048">.1</st>* <st c="14050">nicely shows</st>
    <st c="14064">how the computed variables are derived from other properties and
    how accessing them would eventually go</st> <st c="14168">down to the</st> `<st
    c="14180">observationRegister</st>` <st c="14200">object.</st>'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*<st c="14039">图3</st>**<st c="14048">.1</st> <st c="14050">很好地展示了计算变量是如何从其他属性派生的，以及访问它们最终会如何</st>
    <st c="14064">下降到</st> `<st c="14180">observationRegister</st> <st c="14200">对象。</st>'
- en: <st c="14207">Let’s try to see that</st> <st c="14230">in action:</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14207">让我们看看它是如何</st> <st c="14230">付诸实践的：</st>
- en: '[PRE8]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="14649">In the preceding code, we update the</st> `<st c="14687">averageWordsPerPage</st>`
    <st c="14706">and</st> `<st c="14711">pages</st>` <st c="14716">properties when</st>
    <st c="14732">tapping the</st> **<st c="14745">Change</st>** <st c="14751">button.</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14649">在之前的代码中，当我们点击</st> `<st c="14687">averageWordsPerPage</st> <st
    c="14706">和</st> `<st c="14711">pages</st> <st c="14716">属性时，会更新</st> <st c="14732">，当我们点击</st>
    **<st c="14745">Change</st> <st c="14751">按钮。</st>
- en: <st c="14759">The update triggers the observation</st> <st c="14795">framework
    and updates the view because we access</st> `<st c="14845">totalWordsInBook</st>`
    <st c="14861">in the following line, even though it’s a</st> <st c="14904">computed
    variable.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14759">更新触发观察框架并更新视图，因为我们访问了</st> <st c="14845">totalWordsInBook</st>
    <st c="14861">，即使在下一行中它是一个</st> <st c="14904">计算变量。</st>
- en: <st c="14922">However, adding the</st> `<st c="14943">@ObservationIgnored</st>`
    <st c="14962">property to both of these properties (</st>`<st c="15001">averageWordsPerPage</st>`
    <st c="15021">and</st> `<st c="15026">pages</st>`<st c="15031">) won’t trigger
    the</st> `<st c="15052">totalWordsInBook</st>` <st c="15068">computed property
    because the</st> `<st c="15099">@Observation</st>` <st c="15111">framework can’t
    tell that something has changed.</st> <st c="15161">The nice thing is that we’ve
    learned how it works by expanding our</st> `<st c="15228">@</st>``<st c="15229">Observable</st>`
    <st c="15239">macro.</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14922">然而，将</st> `<st c="14943">@ObservationIgnored</st> <st c="14962">属性添加到这两个属性（</st>`<st
    c="15001">averageWordsPerPage</st> <st c="15021">和</st> `<st c="15026">pages</st>
    <st c="15031">）中不会触发</st> `<st c="15052">totalWordsInBook</st> <st c="15068">计算属性，因为</st>
    `<st c="15099">@Observation</st> <st c="15111">框架无法知道有什么东西发生了变化。</st> <st c="15161">好事是我们通过扩展我们的</st>
    `<st c="15228">@</st>``<st c="15229">Observable</st> <st c="15239">宏来了解了它是如何工作的。</st>
- en: <st c="15246">By now,</st> <st c="15255">we know very well how the</st> `<st
    c="15281">@Observable</st>` <st c="15292">macro works and how variables and computed
    variables</st> <st c="15346">are observed.</st>
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15246">到目前为止，</st> <st c="15255">我们非常清楚</st> `<st c="15281">@Observable</st>
    <st c="15292">宏是如何工作的，以及变量和计算变量是如何被观察的。</st>
- en: <st c="15359">Now, let’s move one step</st> <st c="15384">further and see how
    to use</st> <st c="15411">these observed variables as</st> <st c="15440">environment
    variables.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15359">现在，让我们再进一步，看看如何将这些观察变量用作</st> <st c="15411">环境变量。</st>
- en: <st c="15462">Working with environment variables</st>
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="15462">使用环境变量</st>
- en: <st c="15497">A view that works directly with an observed object is a common
    use case.</st> <st c="15571">For example, a view can work with a</st> `<st c="15607">ViewModel</st>`
    <st c="15616">class or have a SwiftData query that fetches data models from the</st>
    <st c="15683">persistent store.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15497">直接与观察对象工作的视图是一个常见的用例。</st> <st c="15571">例如，一个视图可以与一个</st> `<st
    c="15607">ViewModel</st>` <st c="15616">类一起工作，或者有一个SwiftData查询从</st> <st c="15683">持久存储中检索数据模型。</st>
- en: <st c="15700">However, there are</st> <st c="15719">cases where we have an observed
    object shared across</st> <st c="15773">different views.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15700">然而，也有一些</st> <st c="15719">情况，我们有一个在多个视图中共享的观察对象。</st>
- en: <st c="15789">Some examples of such a use case are</st> <st c="15827">as follows:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="15789">此类用例的一些示例如下：</st> <st c="15827">。</st>
- en: '**<st c="15838">App settings</st>**<st c="15851">: The user profile is part
    of app settings and can be stored in an</st> <st c="15919">environment variable</st>'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15838">应用设置</st>**<st c="15851">：用户资料是应用设置的一部分，可以存储在一个</st> <st c="15919">环境变量</st>中'
- en: '**<st c="15939">Themes and styling</st>**<st c="15958">: Primary color tint
    font style, spaces,</st> <st c="16000">and more</st>'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="15939">主题和样式</st>**<st c="15958">：主颜色色调、字体样式、间距，以及更多</st>'
- en: '**<st c="16008">User authentication state</st>**<st c="16034">: The login state
    is a good examp</st><st c="16068">le of an</st> <st c="16078">environment variable</st>'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="16008">用户认证状态</st>**<st c="16034">：登录状态是环境变量的一个好例子</st><st c="16068">。</st>
    <st c="16078">环境变量</st>'
- en: <st c="16098">Sharing the same object down a view hierarchy can be cumbersome,
    but SwiftUI offers a helpful feature known as</st> **<st c="16210">environment
    variables</st>**<st c="16231">. While environment variables aren’t a recent addition
    to iOS (they have been available before iOS 17), the Observation framework provides</st>
    <st c="16370">comprehensive support.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16098">在视图层次结构中共享相同的对象可能会很麻烦，但SwiftUI提供了一个有用的功能，称为</st> **<st c="16210">环境变量</st>**<st
    c="16231">。虽然环境变量不是iOS最近才添加的（它们在iOS 17之前就已经可用），但Observation框架提供了</st> <st c="16370">全面的支持。</st>
- en: <st c="16392">There are two ways of adding</st> <st c="16422">an environment
    variable to our project – by type or by keys.</st> <st c="16483">Let’s start with
    the more straightforward way:</st> <st c="16530">by type.</st>
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16392">有两种方法可以将环境变量添加到我们的项目中——按类型或按键。</st> <st c="16483">让我们从更直接的方法开始：</st>
    <st c="16530">按类型。</st>
- en: <st c="16538">Adding an environment variable by type</st>
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="16538">按类型添加环境变量</st>
- en: <st c="16577">Let’s try to add theming support for</st> <st c="16614">our books
    project.</st> <st c="16634">We’ll start by creating our</st> `<st c="16662">Themes</st>`
    <st c="16668">class:</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16577">让我们尝试为我们的</st> <st c="16614">书籍项目</st>添加主题支持。我们将首先创建我们的</st> `<st
    c="16662">Themes</st>` <st c="16668">类：</st>
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '<st c="16735">Our</st> `<st c="16740">Themes</st>` <st c="16746">class has
    only one property for now: the primary color.</st> <st c="16803">Notice that we
    added the</st> `<st c="16828">@Observable</st>` <st c="16839">macro to update
    our UI when the</st> <st c="16872">theme changes.</st>'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16735">我们的</st> `<st c="16740">Themes</st>` <st c="16746">类目前只有一个属性：主颜色。</st>
    <st c="16803">注意，我们添加了</st> `<st c="16828">@Observable</st>` <st c="16839">宏来更新我们的UI，当</st>
    <st c="16872">主题改变时。</st>
- en: <st c="16886">Next, we will add our observed object to our</st> `<st c="16932">BookApp</st>`
    <st c="16939">struct:</st>
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="16886">接下来，我们将我们的观察对象添加到我们的</st> `<st c="16932">BookApp</st>` <st c="16939">结构体</st>中：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="17083">In the</st> `<st c="17091">BookApp</st>` <st c="17098">struct,
    we’re making</st> <st c="17120">two changes:</st>
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17083">在</st> `<st c="17091">BookApp</st>` <st c="17098">结构体中，我们进行了两个更改：</st>
- en: '`<st c="17264">@State</st>` <st c="17270">or</st> `<st c="17274">@ObservedObject</st>`<st
    c="17289">.</st>'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="17264">@State</st>` <st c="17270">或</st> `<st c="17274">@ObservedObject</st>`<st
    c="17289">。</st>'
- en: '`<st c="17392">themes</st>` <st c="17398">object easily.</st>'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="17392">主题</st>` <st c="17398">对象易于访问。</st>'
- en: <st c="17413">Now, let’s turn to our view</st> <st c="17442">and see how we
    can</st> <st c="17461">use it:</st>
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17413">现在，让我们转向我们的视图</st> <st c="17442">并看看我们如何</st> <st c="17461">使用它：</st>
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: <st c="17708">Adding the themes instance to our</st> `<st c="17743">ContentView</st>`
    <st c="17754">struct is straightforward.</st> <st c="17782">We’re using the</st>
    `<st c="17798">@Environment</st>` <st c="17810">property wrapper to inject the
    themes object we</st> <st c="17859">created earlier.</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 将主题实例添加到我们的 `<st c="17743">ContentView</st>` 结构体中很简单。我们使用 `<st c="17798">@Environment</st>`
    属性包装器来注入我们之前创建的主题对象。
- en: <st c="17875">We use the theme’s primary color in the body part to color our</st>
    <st c="17939">book title.</st>
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在主体部分使用主题的主要颜色来为我们的 `<st c="17939">书名</st>` 着色。
- en: <st c="17950">Now, we must note that we can use the environment variable in</st>
    *<st c="18013">every</st>* <st c="18018">view in the hierarchy, even if we haven’t</st>
    <st c="18061">initialized it with the</st> <st c="18085">environment modifier.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须注意，我们可以在层次结构中的每个视图中使用环境变量，即使我们没有使用环境修改器初始化它。
- en: <st c="18106">Here’s an example</st> <st c="18125">of that:</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE12]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: <st c="18384">In the preceding code, we created another SwiftUI component called</st>
    `<st c="18452">MyTitle</st>`<st c="18459">, which has the environment</st> <st
    c="18487">variable themes.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个名为 `<st c="18452">MyTitle</st>` 的另一个 SwiftUI 组件，它具有环境变量 `themes`。
- en: <st c="18503">The</st> `<st c="18508">MyTitle</st>` <st c="18515">view is part
    of the</st> `<st c="18536">ContentView</st>` <st c="18547">hierarchy.</st> <st
    c="18559">Therefore, it has direct access to the</st> `<st c="18598">themes</st>`
    <st c="18604">variable.</st>
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="18508">MyTitle</st>` 视图是 `<st c="18536">ContentView</st>` 层次结构的一部分。因此，它可以直接访问
    `<st c="18598">themes</st>` 变量。'
- en: <st c="18614">Passing environment variables by type is simple!</st> <st c="18664">However,
    when working on a big scale, it has some drawbacks.</st> <st c="18725">I believe
    that the main disadvantage is that we are coupling our code to a specific type.</st>
    <st c="18815">In the</st> `<st c="18822">themes</st>` <st c="18828">example, we
    work with an explicit</st> <st c="18863">variety (</st>`<st c="18872">Themes</st>`<st
    c="18879">).</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 通过类型传递环境变量很简单！然而，当在大规模工作的时候，它有一些缺点。我相信主要缺点是我们将代码耦合到了一个特定的类型。在 `<st c="18822">themes</st>`
    的例子中，我们处理的是一个显式的类型（`<st c="18872">Themes</st>`）。
- en: <st c="18882">SwiftUI provides us with a</st> <st c="18909">better way to manage
    environment variables, and that’s working with</st> <st c="18978">environment
    keys.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftUI 提供了一种更好的方式来管理环境变量，那就是使用环境键。
- en: <st c="18995">Adding environment variable by key</st>
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过键添加环境变量
- en: <st c="19030">Managing environment</st> <st c="19052">variables is much better
    when our project becomes</st> <st c="19102">more significant.</st>
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的项目变得更重要时，管理环境变量会更好。
- en: <st c="19119">Using environment keys improves the separation between our view
    and the</st> <st c="19192">actual variable.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用环境键提高了我们的视图和实际变量之间的分离。
- en: <st c="19208">To better manage environment values, SwiftUI has two</st> <st
    c="19262">primary components:</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地管理环境值，SwiftUI 有两个主要组件：
- en: '`<st c="19281">EnvironmentValues</st>` **<st c="19299">struct</st>**<st c="19306">:
    This is a container of different environment values structured in a key-value
    form.</st> <st c="19393">It can be accessed from any view in the app.</st> <st
    c="19438">We can extend the struct and add</st> <st c="19471">new variables.</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="19281">EnvironmentValues</st>` **<st c="19299">结构体</st>**：这是一个以键值形式结构化的不同环境值的容器。它可以从应用中的任何视图访问。我们可以扩展这个结构体并添加新的变量。'
- en: '`<st c="19485">EnvironmentKey</st>` **<st c="19500">protocol</st>**<st c="19509">:
    It allows us to add a key for a new variable and use that key to add a new</st>
    <st c="19587">environment value.</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="19485">EnvironmentKey</st>` **<st c="19500">协议</st>**：它允许我们为新的变量添加一个键，并使用该键添加新的环境值。'
- en: <st c="19605">Let’s see how it works</st> <st c="19629">in practice:</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看它在实践中是如何工作的：
- en: '[PRE13]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: <st c="19835">The first thing that we did was add a new</st> `<st c="19878">EnvironmentKey</st>`
    <st c="19892">type named</st> `<st c="19904">ThemesKey</st>`<st c="19913">. Part
    of the</st> `<st c="19927">EnvironmentKey</st>` <st c="19941">protocol is setting
    the variable default value, which is, in this case, a</st> `<st c="20016">Themes</st>`
    <st c="20022">instance.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19835">我们首先做的是添加一个新的</st> `<st c="19878">EnvironmentKey</st>` <st c="19892">类型，命名为</st>
    `<st c="19904">ThemesKey</st>`<st c="19913">。部分</st> `<st c="19927">EnvironmentKey</st>`
    <st c="19941">协议是设置变量的默认值，在这种情况下，是一个</st> `<st c="20016">Themes</st>` <st c="20022">实例。</st>
- en: <st c="20032">Once we have a new environment key, we must add it to our</st>
    `<st c="20091">EnvironmentValues</st>` <st c="20108">container.</st> <st c="20120">We
    do that by extending the container and adding a new computed variable</st> <st
    c="20193">named</st> `<st c="20199">themes</st>`<st c="20205">.</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20032">一旦我们有一个新的环境键，我们必须将其添加到我们的</st> `<st c="20091">EnvironmentValues</st>`
    <st c="20108">容器中。</st> <st c="20120">我们通过扩展容器并添加一个名为</st> `<st c="20199">themes</st>`<st
    c="20205">的新计算变量来实现这一点。</st>
- en: <st c="20206">The getter and the setter are straightforward – the</st> `<st
    c="20259">get</st>` <st c="20262">function returns the value according to the
    relevant key (</st>`<st c="20321">ThemesKey</st>`<st c="20331">), and the</st>
    `<st c="20343">set</st>` <st c="20346">function stores a new variable on</st>
    <st c="20381">that key.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20206">获取器和设置器都很直接 –</st> `<st c="20259">get</st>` <st c="20262">函数根据相关键（</st>`<st
    c="20321">ThemesKey</st>`<st c="20331">）返回值，而</st> `<st c="20343">set</st>` <st
    c="20346">函数在该键上存储一个新的变量。</st>
- en: <st c="20390">After we have extended</st> <st c="20413">the container, we can
    easily access that key from any view that</st> <st c="20478">we have:</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20390">在扩展容器之后</st> <st c="20413">，我们可以轻松地从任何我们拥有的视图中访问该键：</st> <st c="20478"></st>
- en: '[PRE14]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: <st c="20569">Remember the environment modifier from earlier?</st> <st c="20618">We
    can remove</st> <st c="20632">it now:</st>
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="20569">还记得之前提到的环境修饰符吗？</st> <st c="20618">现在我们可以移除它了：</st>
- en: '[PRE15]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'struct ContentView: View { <st c="22606">@State var email: String = ""</st>
    var body: some View {'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ContentView: View { <st c="22606">@State var email: String = ""</st>
    var body: some View {'
- en: VStack {
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: 'TextField("Email", text: <st c="22692">$email</st>)'
  id: totrans-157
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'TextField("电子邮件", text: <st c="22692">$email</st>)'
- en: '}'
  id: totrans-158
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'struct MyCounter: View { <st c="22958">@Binding var value: Int</st> var body:
    some View {'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct MyCounter: View { <st c="22958">@Binding var value: Int</st> var body:
    some View {'
- en: VStack {
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: Button("Increase") {
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("增加") {
- en: value += 1
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: value += 1
- en: '}'
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'struct ContentView: View { <st c="23080">@State var count: Int = 0</st> var
    body: some View {'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ContentView: View { <st c="23080">@State var count: Int = 0</st> var
    body: some View {'
- en: VStack {
  id: totrans-171
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: 'MyCounter(value: <st c="23154">$count</st>)'
  id: totrans-172
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'MyCounter(value: <st c="23154">$count</st>)'
- en: Text("Value = \(count)")
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("值 = \(count)")
- en: '}'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'struct ContentView: View { <st c="23962">var counter = Counter()</st> var body:
    some View {'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ContentView: View { <st c="23962">var counter = Counter()</st> var body:
    some View {'
- en: VStack {
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: 'CounterView(counter: <st c="24038">counter</st>)'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'CounterView(counter: <st c="24038">counter</st>)'
- en: Text("Value = \(counter.value)")
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("值 = \(counter.value)")
- en: '}'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: 'struct CounterView: View {'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct CounterView: View {'
- en: '<st c="24114">@Bindable var counter: Counter</st> var body: some View {'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="24114">@Bindable var counter: Counter</st> var body: some View {'
- en: VStack {
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: Button("Increase") { <st c="24197">counter.increment()</st> }
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Button("增加") { <st c="24197">counter.increment()</st> }
- en: '}'
  id: totrans-189
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE18]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
