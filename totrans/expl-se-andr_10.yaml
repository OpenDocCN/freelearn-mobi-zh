- en: Chapter 10. Placing Applications in Domains
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。将应用程序放置在域中
- en: In [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android Is Weird*,
    we introduced the zygote and that all applications, APKs in Android speak, emanate
    from the zygote just like services emanate from the `init` process. As such, they
    need to be labeled, as we did in the previous chapter. Recall that labeling is
    the same as placing a process in a domain of that label. Applications need to
    be labeled as well.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。Android很奇怪")中，我们介绍了zygote以及所有Android中的应用程序（APKs）都像服务从`init`进程产生一样，源自zygote。因此，它们需要被标记，就像我们在上一章中所做的那样。回想一下，标记与将进程放置在具有该标记的域中是相同的。应用程序也需要被标记。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: APK is the file extension and format for installable application packages on
    Android. It's analogous to the desktop package formats like RPM (Redhat based)
    or DEB (Debian based).
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: APK是Android上可安装应用程序包的文件扩展名和格式。它与桌面包格式类似，如RPM（基于Redhat）或DEB（基于Debian）。
- en: 'In this chapter, we will learn to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习：
- en: Properly label application private data directories and their runtime contexts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正确标记应用程序私有数据目录及其运行时上下文
- en: Further examine zygote and methods to secure it
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 进一步检查zygote及其安全方法
- en: Discover how a finished `mac_permssions.xml` file assigns `seinfo` value
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发现如何将完成的`mac_permssions.xml`文件分配`seinfo`值
- en: Create a new custom domain
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个新的自定义域名
- en: The case to secure the zygote
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护zygote的案例
- en: Android applications with elevated permissions and capabilities are spawned
    from the zygote. An example of this is the system server, a large process comprised
    of native and non-native code hosting a variety of services. The system server
    houses the activity manager, package manager, GPS feeds and so on. The system
    server also runs with a highly sensitive UID of `system` (`1000`). Also, many
    OEMs package what are known as **system apps**, which are standalone applications
    running with the `system` UID.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 具有提升权限和能力的Android应用程序是从zygote产生的。一个例子是系统服务器，这是一个由本地和非本地代码组成的大型进程，托管了各种服务。系统服务器包含活动管理器、包管理器、GPS数据等。系统服务器还以高度敏感的UID
    `system` (`1000`) 运行。此外，许多OEMs打包了所谓的**系统应用**，这些是运行在`system` UID上的独立应用程序。
- en: The zygote also spawns applications that do not need elevated permissions. All
    third-party applications represent this. Third party applications run as their
    own UID, separate from sensitive UIDs, such as `system`. Additionally, applications
    get spawned into various UIDs such as `media`, `nfc`, and so on. OEMs tend to
    define additional UIDs.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: zygote还会产生不需要提升权限的应用程序。所有第三方应用程序都代表这一点。第三方应用程序以它们自己的UID运行，与敏感的UID（如`system`）分开。此外，应用程序还会被产生到各种UID中，如`media`、`nfc`等。OEMs倾向于定义额外的UID。
- en: 'It''s important to note that to get into a special UID, like `system`, you
    must be signed with the proper key. Android has four major keys used to sign applications:
    `media`, `platform`, `shared`, and `testkey`. They are located in `build/target/product/security`,
    along with a `README`.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，要进入特殊UID，如`system`，你必须使用适当的密钥进行签名。Android有四个主要密钥用于签名应用程序：`media`、`platform`、`shared`和`testkey`。它们位于`build/target/product/security`中，还有一个`README`。
- en: 'According to the `README`, the key usage is as follows:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据`README`，关键用法如下：
- en: '`testkey`: A generic key for packages that do not otherwise specify a key.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`testkey`: 未指定密钥的包的通用密钥。'
- en: '`platform`: A test key for packages that are part of the core platform.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`platform`: 核心平台部分包的测试密钥。'
- en: '`shared`: A test key for things that are shared in the home/contacts process.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shared`: 在家庭/联系人过程中共享的测试密钥。'
- en: '`media`: A test key for packages that are part of the media/download system.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`media`: 媒体/下载系统部分包的测试密钥。'
- en: In order to request `system` UID for your application, you must be signed with
    the `platform` key. Possession of the private key is required to execute in these
    more privileged environments.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了请求应用程序的`system` UID，你必须使用`platform`密钥进行签名。在这些更受特权的环境中执行需要拥有私钥。
- en: As you can see, we have applications executing at a variety of permission levels,
    and trust levels. We cannot trust third party applications since they are created
    by unknown entities, and we can trust things signed with our private keys. However,
    before SELinux, application permissions were still bound by the same DAC permission
    limitations as those identified in [Chapter 1](ch01.html "Chapter 1. Linux Access
    Controls"), *Linux Access Controls*. Because of these properties, it makes the
    zygote a prime target for attack, as well as fortification with SELinux.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们有在多种权限级别和信任级别上执行的应用程序，我们不能信任第三方应用程序，因为它们是由未知实体创建的，我们可以信任用我们的私钥签名的应用程序。然而，在SELinux之前，应用程序权限仍然受到与[第1章](ch01.html
    "第1章。Linux访问控制")中确定的相同DAC权限限制的约束，*Linux访问控制*。由于这些属性，这使得受精卵成为攻击的主要目标，以及使用SELinux进行加固。
- en: Fortifying the zygote
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加强受精卵
- en: Now that we have identified a problem with zygote, the next step is understanding
    how to get applications into appropriate domains. We need either SELinux policy
    or code changes to place new processes into a domain. In [Chapter 9,](ch09.html
    "Chapter 9. Adding Services to Domains") *Adding Services to Domains*, we covered
    dynamic domain transitions with init-based services and the end of the chapter
    mentions the importance of the `exec()` syscall in the "Limitations on App Labeling"
    section. This is the trigger on which dynamic domain transitions occur. If there
    is no `exec` in the path, we would have to rely on code changes. However, one
    also has to consider the signing key in this security model, and there is no way
    in pure SELinux policy language to express the key the process was signed with.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经确定了受精卵的问题，下一步是了解如何将应用程序放入适当的域中。我们需要SELinux策略或代码更改来将新进程放入一个域。在[第9章](ch09.html
    "第9章。将服务添加到域") *将服务添加到域* 中，我们介绍了基于init的服务动态域转换，并在章节末尾提到“应用标签限制”部分中的`exec()`系统调用的作用。这是动态域转换发生的触发器。如果没有`exec`在路径中，我们就必须依赖代码更改。然而，在这个安全模型中，还必须考虑签名密钥，而在纯SELinux策略语言中无法表达进程所签名的密钥。
- en: Rather than exploring the whole zygote, we can dissect the following patches
    that introduce application labeling into Android. Additionally, we can discover
    how the introduced design meets the requirements of respecting the signing key,
    working within the design of SELinux and the zygote.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是探索整个受精卵，我们可以剖析以下引入应用标签到Android中的补丁。此外，我们还可以发现引入的设计如何满足尊重签名密钥、在SELinux和受精卵设计中工作的要求。
- en: Plumbing the zygote socket
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索受精卵套接字
- en: In [Chapter 3](ch03.html "Chapter 3. Android Is Weird"), *Android Is Weird*,
    we learned that the zygote listens for requests to spawn a new application from
    a socket. The first patch to examine is [https://android-review.googlesource.com/#/c/31066/](https://android-review.googlesource.com/#/c/31066/).
    This patch modifies three files in the base frameworks of Android. The first file
    is `Process.java` in the method `startViaZygote()`. This method is the main entry
    point for other methods with respect to building string arguments and passing
    them to the zygote with `zygoteSendArgsAndGetResult()`. The patch introduces a
    new argument called `seinfo`. Later on, we will see how this gets used. It appears
    that this patch is plumbing this new `seinfo` argument over the socket. Note that
    this code is called external to the zygote process.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第3章](ch03.html "第3章。Android很奇怪") *Android很奇怪* 中，我们了解到受精卵正在监听从套接字生成新应用程序的请求。要检查的第一个补丁是[https://android-review.googlesource.com/#/c/31066/](https://android-review.googlesource.com/#/c/31066/)。此补丁修改了Android基础框架中的三个文件。第一个文件是`Process.java`中的`startViaZygote()`方法。此方法是构建字符串参数并将其传递给受精卵的`zygoteSendArgsAndGetResult()`方法的入口点。补丁引入了一个名为`seinfo`的新参数。稍后我们将看到它是如何被使用的。看起来这个补丁是通过套接字将这个新的`seinfo`参数进行管道传输。请注意，此代码是在受精卵进程外部调用的。
- en: The next file to look at in this patch is `ZygoteConnection.java`. This code
    executes from within the context. The patch starts off by declaring a string member
    variable `peerContext` in the `ZygoteConnection` class. In the constructor, this
    `peerContext` member is set to the value obtained from a call to `SELinux.getPeerContext(mSocket.getFileDescriptor())`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个补丁中要查看的下一个文件是`ZygoteConnection.java`。此代码在上下文中执行。补丁首先在`ZygoteConnection`类中声明一个字符串成员变量`peerContext`。在构造函数中，这个`peerContext`成员被设置为从调用`SELinux.getPeerContext(mSocket.getFileDescriptor())`获得的值。
- en: 'Since the `LocalSocket` `mSocket` is a Unix domain socket under the hood, you
    can obtain the connected client''s credentials. In this case, the call to `getPeerContext()`
    gets the client''s security context, or in more formal terms, the process label.
    After the initialization, further down in method `runOnce()`, we see it being
    used in calls to `applyUidSecurityPolicy` and other `apply*SecurityPolicy` routines.
    The protected method `runOnce()` is called to read one start command from the
    socket and arguments. Eventually, after the `apply*SecurityPolicy` checks, it
    calls `forkandSpecialize()`. Each security policy check has been modified to use
    SELinux on top of the existing DAC security controls. If we review `applyUidSecurityPolicy`,
    we see they make the call:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`LocalSocket`的`mSocket`底层是一个Unix域套接字，你可以获取已连接客户端的凭证。在这种情况下，`getPeerContext()`调用获取客户端的安全上下文，或者更正式地说，进程标签。初始化之后，在`runOnce()`方法中进一步使用，我们看到它在调用`applyUidSecurityPolicy`和其他`apply*SecurityPolicy`例程中使用。受保护的`runOnce()`方法被调用以从套接字读取一个启动命令和参数。最终，在`apply*SecurityPolicy`检查之后，它调用`forkandSpecialize()`。每个安全策略检查都已修改为在现有的DAC安全控制之上使用SELinux。如果我们审查`applyUidSecurityPolicy`，我们会看到他们进行了调用：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is an example of a userspace leveraging mandatory access controls in what
    is known as an object manager. Additionally, a security check has been added for
    the mysterious `seinfo` string in the `applyseInfoSecurityPolicy()` method. All
    the security checks here for SELinux specify the target class `zygote`. So if
    we look into `sepolicy access_vectors`, we see the added class `zygote`. This
    is a custom class for Android and defines all the vectors checked in the security
    checks.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个用户空间利用已知为对象管理器的强制访问控制的示例。此外，在`applyseInfoSecurityPolicy()`方法中，还增加了一个对神秘`seinfo`字符串的安全检查。这里的所有SELinux安全检查都指定了目标类`zygote`。因此，如果我们查看`sepolicy
    access_vectors`，我们会看到添加的类`zygote`。这是一个为Android定义的定制类，并定义了安全检查中检查的所有向量。
- en: The last file we'll consider from this patch is `ActivityManagerService.java`.
    The `ActivityManager` is responsible for starting applications and managing their
    lifecycles. It's a consumer of the `Process.start` API and needs to specify `seinfo`.
    This patch is simple, and for now, just sends `null`. Later, we will see the patch
    enabling its use.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将考虑的这个补丁的最后一个是`ActivityManagerService.java`。`ActivityManager`负责启动应用程序并管理它们的生命周期。它是`Process.start`
    API的消费者，并需要指定`seinfo`。这个补丁很简单，目前只是发送`null`。稍后，我们将看到启用其使用的补丁。
- en: The next patch, [https://android-review.googlesource.com/#/c/31063/](https://android-review.googlesource.com/#/c/31063/),
    executes within the context of the Android Dalvik VM and is coded in the VM zygote
    process space. The `forkAndSpecialize()` we saw in `ZygoteConnection` ends up
    in this native routine. It enters using `static pid_t forkAndSpecializeCommon(const
    u4* args, bool isSystemServer)`. This routine is responsible for creating the
    new process that becomes the application.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个补丁[https://android-review.googlesource.com/#/c/31063/](https://android-review.googlesource.com/#/c/31063/)在Android
    Dalvik VM的上下文中执行，并在VM受精卵进程空间中编码。我们在`ZygoteConnection`中看到的`forkAndSpecialize()`最终结束在这个本地例程中。它通过`static
    pid_t forkAndSpecializeCommon(const u4* args, bool isSystemServer)`进入。这个例程负责创建成为应用程序的新进程。
- en: It begins with housekeeping code moving from Java to C and sets up the `niceName`
    and `seinfo` values as C-style strings. Eventually, the code calls `fork()` and
    the child process starts doing things, like executing `setgid` and `setuid`. The
    `uid` and `gid` values are specified to the zygote connection with the `Process.start`
    method. We also see a new call to `setSELinuxContext()`. As an aside, the order
    of these events is important here. If you set the SELinux context of the new process
    too early, the process would need additional capabilities in the new context to
    do things like `setuid` and `setgid`. However, those permissions are best left
    to the `zygote` domain, so the application domain we entered can be as minimal
    as possible.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 它从将家务代码从Java迁移到C开始，并设置了`niceName`和`seinfo`值作为C风格的字符串。最终，代码调用`fork()`，子进程开始执行一些操作，例如执行`setgid`和`setuid`。`uid`和`gid`值通过`Process.start`方法指定给受精卵连接。我们还看到了对`setSELinuxContext()`的新调用。顺便说一下，这些事件的顺序在这里很重要。如果你过早地设置新进程的SELinux上下文，进程在新上下文中执行`setuid`和`setgid`等操作将需要额外的能力。然而，这些权限最好留给`zygote`域，因此我们进入的应用程序域可以尽可能小。
- en: Continuing, `setSELinuxContext` eventually calls `selinux_android_setcontext()`.
    Note that the `HAVE_SELINUX` conditional compilation macros were removed after
    this commit, but prior to the 4.3 release. Also note that `selinux_android_setcontext()`
    is defined in `libselinux`, so our journey will take us there. Here we see the
    mysterious `seinfo` is still being passed along.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 继续看，`setSELinuxContext` 最终调用 `selinux_android_setcontext()`。注意，在这次提交之后移除了 `HAVE_SELINUX`
    条件编译宏，但在 4.3 版本之前。另外，注意 `selinux_android_setcontext()` 定义在 `libselinux` 中，所以我们的旅程将带我们到那里。在这里我们看到神秘的
    `seinfo` 仍然被传递。
- en: The next patch to evaluate is [https://android-review.googlesource.com/#/c/39601/](https://android-review.googlesource.com/#/c/39601/).
    This patch actually passes a more meaningful `seinfo` value from the Java layer.
    Rather than being set to `null`, this patch introduces some parsing logic from
    an XML file, and passes this along to the `Process.start` method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个需要评估的补丁是[https://android-review.googlesource.com/#/c/39601/](https://android-review.googlesource.com/#/c/39601/).
    这个补丁实际上从 Java 层传递了一个更有意义的 `seinfo` 值。而不是设置为 `null`，这个补丁引入了一些从 XML 文件中解析的逻辑，并将其传递给
    `Process.start` 方法。
- en: 'This patch modifies two major components: `PackageManager` and `installd`.
    `PackageManager` runs inside the `system_server`, and performs application installation.
    It maintains the state of all installed packages in the system. The second component,
    a service known as `installd`, is a very privileged root service that creates
    all the applications'' private directories on disk. Rather than giving system
    server, and therefore `PackageManager`, the capability to create these directories,
    only `installd` has these permissions. Using this approach, even the system server
    cannot read data in your private data directories unless you make it world readable.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补丁修改了两个主要组件：`PackageManager` 和 `installd`。`PackageManager` 在 `system_server`
    内运行，并执行应用程序安装。它维护系统中所有已安装包的状态。第二个组件，一个名为 `installd` 的服务，是一个非常特权的根服务，在磁盘上创建所有应用程序的私有目录。而不是给系统服务器和因此
    `PackageManager`，创建这些目录的能力，只有 `installd` 有这些权限。使用这种方法，即使系统服务器也无法读取你的私有数据目录中的数据，除非你将其设置为全局可读。
- en: This patch is larger than the others, so we are only going to inspect the parts
    directly relevant to our discussion. We'll start by looking at `PackageManagerService.java`.
    This class is the package manager, proper for Android. In the constructor for
    `PackageManagerService()`, we see the addition of `mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();`.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这个补丁比其他补丁要大，所以我们只将检查与我们的讨论直接相关的部分。我们将从查看 `PackageManagerService.java` 开始。这个类是
    Android 的包管理器。在 `PackageManagerService()` 构造函数中，我们看到添加了 `mFoundPolicyFile = SELinuxMMAC.readInstallPolicy();`。
- en: Based on the naming, we can conjecture that this method is looking for some
    type of policy configuration file, and if found, returns true, setting the `mFoundPolicyFile`
    member variable. We also see some calls to `createDataDirs` and `mInstaller.*`
    calls. These we can ignore, since those calls are headed to `installd`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 根据命名，我们可以推测这个方法正在寻找某种类型的策略配置文件，如果找到，则返回 true，设置 `mFoundPolicyFile` 成员变量。我们还看到一些对
    `createDataDirs` 和 `mInstaller.*` 的调用。我们可以忽略这些调用，因为这些调用是前往 `installd` 的。
- en: 'The next major portion adds the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个主要部分添加了以下内容：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It's important to note that this code was added into the `scanPackageLI()` method.
    This method is called every time a package needs to be scanned for installation.
    So at a high level, if some policy file is found during service startup, then
    a `seinfo` value is assigned to the package.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，这段代码被添加到了 `scanPackageLI()` 方法中。每次需要扫描安装包时都会调用这个方法。所以从高层次来看，如果在服务启动期间找到了某个策略文件，那么就会为该包分配一个
    `seinfo` 值。
- en: The next file to look at is `ApplicationInfo.java`, a container class for maintaining
    meta information about a package. As we can see, the `seinfo` value is specified
    here for storage purposes. Additionally, there is some code for serializing and
    deserializing the class via the Android specific `Parcel` implementation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个要查看的文件是 `ApplicationInfo.java`，这是一个用于维护包元信息的容器类。正如我们所见，`seinfo` 值在这里指定用于存储目的。此外，还有一些代码用于通过
    Android 特定的 `Parcel` 实现序列化和反序列化该类。
- en: At this point, we should have a closer look at the `SELinuxMMAC.java` code to
    confirm our understanding of what's going on. The class starts by declaring two
    locations for policy files.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们应该更仔细地查看 `SELinuxMMAC.java` 代码，以确认我们对正在发生的事情的理解。该类首先声明了两个策略文件的位置。
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'According to this, policy files can exist in two locations- `/data/system/mac_permissions.xml`
    and `/system/etc/security/mac_permissions.xml`. Eventually, we see the call from
    `PackageManagerService` initialization to the method defined in the class `readInstallPolicy()`,
    which eventually reduces to a call of:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据这个，策略文件可以存在于两个位置 - `/data/system/mac_permissions.xml` 和 `/system/etc/security/mac_permissions.xml`。最终，我们看到从
    `PackageManagerService` 初始化调用类 `readInstallPolicy()` 中定义的方法的调用，这最终简化为一个调用：
- en: '[PRE3]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With `policyFiles` set to `INSTALL_POLICY_FILE`, this code uses the array to
    find a file at the specified locations. It is priority based, with the `/data`
    location taking precedence over `/system`. The rest of the code in this method
    looks like parsing logic and fills up two hash tables that were defined in the
    class declaration:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `policyFiles` 设置为 `INSTALL_POLICY_FILE` 时，此代码使用数组在指定位置查找文件。它是基于优先级的，其中 `/data`
    位置比 `/system` 位置具有更高的优先级。此方法中的其余代码看起来像是解析逻辑，并填充了在类声明中定义的两个哈希表：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `sSigSeinfo` maps `Signatures`, or signing keys, to `seinfo` strings. The
    other map, `sPackageSeinfo` maps a package name to a string.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`sSigSeinfo` 映射 `Signatures`（或签名密钥）到 `seinfo` 字符串。另一个映射 `sPackageSeinfo` 将包名映射到字符串。'
- en: At this point, we can read some formatted XML from the `mac_permissions.xml`
    file and create internal mappings from signing key to `seinfo` and package name
    to `seinfo`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们可以从 `mac_permissions.xml` 文件中读取一些格式化的 XML，并从签名密钥到 `seinfo` 以及包名到 `seinfo`
    创建内部映射。
- en: The other call from `PackageManagerService` into this class came from `void
    assignSeinfoValue(PackageParser.Package pkg)`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 `PackageManagerService` 到这个类的另一个调用来自 `void assignSeinfoValue(PackageParser.Package
    pkg)`。
- en: 'Let''s investigate what this method can do. It starts by checking if the application
    is system UID or a system installed app. In other words, it checks whether the
    application is a third-party application:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来调查一下这个方法能做什么。它首先检查应用程序是否是系统 UID 或系统安装的应用程序。换句话说，它检查该应用程序是否是第三方应用程序：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code has subsequently been dropped by Google, and was initially a requirement
    for merge. We can, however, continue our evaluation. The code loops over all the
    signatures in the package, and checks against the hash table. If it is signed
    with something in that map, it uses the associated `seinfo` value. The other case
    is that it matches by package name. In either case, the package''s `ApplictionInfo`
    class `seinfo` value is updated to reflect this and be used elsewhere by `installd`
    and zygote application spawn:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码已被谷歌删除，最初是合并的要求。然而，我们可以继续评估。代码遍历包中的所有签名，并与哈希表进行比对。如果它使用该映射中的某个签名，则使用关联的 `seinfo`
    值。另一种情况是它通过包名进行匹配。在任一情况下，包的 `ApplictionInfo` 类的 `seinfo` 值都会更新以反映这一点，并由 `installd`
    和 zygote 应用程序启动使用：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As an aside, what is merged into mainline AOSP and what is maintained in the
    NSA Bitbucket repositories is a bit different. The NSA has additional controls
    in these policy files that can cause an application installation to abort. Google
    and the NSA are "forked" over this issue, so to speak. In the NSA versions of
    `SELinuxMMAC.java`, you can specify that applications matching a specific signature
    or package name are allowed to have certain sets of Android-level permissions.
    For instance, you can block all applications from being installed that request
    `CAMERA` permissions or block applications signed with certain keys. This also
    highlights how important it can be to find patches within large code bases and
    quickly come up to speed on how projects evolve, which can often seem daunting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁白，合并到主线 AOSP 的内容与在 NSA Bitbucket 仓库中维护的内容略有不同。NSA 在这些策略文件中增加了额外的控制，这可能导致应用程序安装中断。可以说，谷歌和
    NSA 在这个问题上“分道扬镳”。在 NSA 版本的 `SELinuxMMAC.java` 中，你可以指定匹配特定签名或包名的应用程序可以拥有某些 Android
    级别的权限集。例如，你可以阻止所有请求 `CAMERA` 权限的应用程序安装，或者阻止使用特定密钥签名的应用程序。这也突显了在大型代码库中找到补丁并快速了解项目如何演变的重要性，这通常可能显得令人畏惧。
- en: The last file in this patch for us to consider is `ActivityManagerService.java`.
    This patch replaces the null with `app.info.seinfo`. After all that work and all
    that plumbing, we finally have the mystical `seinfo` value fully parsed, associated
    per application package, and sent along to the zygote for use in `selinux_android_setcontext()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要考虑的这个补丁中的最后一个文件是 `ActivityManagerService.java`。此补丁将 `null` 替换为 `app.info.seinfo`。在所有这些工作和所有这些管道之后，我们最终完全解析了神秘的
    `seinfo` 值，将其与每个应用程序包相关联，并将其发送到 zygote 以用于 `selinux_android_setcontext()`。
- en: Now it would benefit us to sit back and think about some of the properties we
    wanted to achieve in labeling applications. One of them is to somehow couple a
    security context with the application signing key, and this is precisely the main
    benefit of `seinfo`. This is a highly sensitive and trusted string associated
    value of a signing key. The actual contents of the string are arbitrary and dictated
    in `mac_permissions.xml`, which is the next stop on our adventure.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，坐下来思考一下我们想要在标签应用中实现的一些属性将对我们有益。其中之一是 somehow 将安全上下文与应用签名密钥相关联，这正是`seinfo`的主要好处。这是一个高度敏感且受信任的字符串关联值，与签名密钥相关联。字符串的实际内容是任意的，并在`mac_permissions.xml`中指定，这是我们冒险的下一站。
- en: The mac_permissions.xml file
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml`文件'
- en: The `mac_permissions.xml` file has a very confusing name. Expanded, the name
    is MAC permissions. However, its major mainline functionality is to map a signing
    key to a `seinfo` string. Secondarily, it can also be used to configure a non-mainstream
    install-time permission-checking feature, known as install time MMAC. MMAC controls
    are part of the NSA's work to implement mandatory access controls in the middleware
    layer. MMAC stands for "Middleware Mandatory Access Controls". Google has not
    merged any of the MMAC features. However, since we used the NSA Bitbucket repositories,
    our code base contains these features.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml`文件有一个非常令人困惑的名称。展开后，名称是MAC权限。然而，其主要主要功能是将签名密钥映射到`seinfo`字符串。其次，它还可以用于配置非主流的安装时权限检查功能，称为安装时MMAC。MMAC控制是NSA在中间件层实施强制访问控制的工作的一部分。MMAC代表“中间件强制访问控制”。谷歌没有合并任何MMAC功能。然而，由于我们使用了NSA
    Bitbucket存储库，我们的代码库包含这些功能。'
- en: 'The `mac_permissions.xml` is an XML file, and should adhere to the following
    rules, where italicized portions are only supported on NSA branches:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`mac_permissions.xml`是一个XML文件，应遵循以下规则，其中斜体部分仅在NSA分支上受支持：'
- en: A signature is a hex encoded X.509 certificate and is required for each signer
    tag.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 签名是一个十六进制编码的X.509证书，并且对于每个签名者标签都是必需的。
- en: 'A `<signer signature="" >` element may have multiple child elements:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<signer signature="" >`元素可以有多个子元素：'
- en: '`allow-permission`: It produces a set of maximal allowed permissions (whitelist)'
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow-permission`：它生成一组最大允许权限（白名单）。'
- en: '`deny-permission`: It produces a blacklist of permissions to deny'
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deny-permission`：它生成一个拒绝权限的黑名单。'
- en: '`allow-all`: It is a wildcard tag that will allow every permission requested'
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`allow-all`：它是一个通配符标签，将允许请求的所有权限。'
- en: '`package`: It is a complex tag which defines allow, deny, and wildcard sub-elements
    for a specific package name protected by the signature'
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`package`：它是一个复杂的标签，为受签名保护的特定包名称定义允许、拒绝和通配符子元素。'
- en: Zero or more global `<package name="">` tags are allowed. These tags allow a
    policy to be set outside any signature for specific package names.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许存在零个或多个全局`<package name="">`标签。这些标签允许为特定包名称设置策略，而不考虑任何签名。
- en: A `<default>` tag is allowed that can contain install policy for all apps not
    signed with a previously listed cert and not having a per package global policy.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许存在一个`<default>`标签，它可以包含未使用先前列出的证书签名的所有应用程序的安装策略，并且没有每个包的全局策略。
- en: Unknown tags at any level are skipped.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何级别的未知标签都将被跳过。
- en: Zero or more signer tags are allowed.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许存在零个或多个签名者标签。
- en: Zero or more package tags are allowed per signer tag.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个签名者标签允许存在零个或多个包标签。
- en: A `<package name="">` tag may not contain another `<package name="">` tag. If
    found, it's skipped.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<package name="">`标签可能不包含另一个`<package name="">`标签。如果找到，则跳过。'
- en: 'When multiple sub-elements appear for a tag, the following logic is used to
    ultimately determine the type of enforcement:'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当一个标签出现多个子元素时，使用以下逻辑最终确定执行类型：
- en: A blacklist is used if at least one deny-permission tag is found.
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果至少找到一个拒绝权限的标签，则使用黑名单。
- en: A whitelist is used, if not a blacklist, and at least one allow-permission tag
    is found.
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果不是黑名单，并且至少找到一个允许权限的标签，则使用白名单。
- en: A wildcard (accept all permissions) policy is used if not a blacklist and not
    a whitelist, and at least one allow-all tag is present.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果既不是黑名单也不是白名单，并且至少有一个允许所有权限的标签存在，则使用通配符（接受所有权限）策略。
- en: If a `<package name="">` sub-element is found, then that sub-element's policy
    is used according to the earlier logic and overrides any signature global policy
    type.
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果找到一个`<package name="">`子元素，则根据之前的逻辑使用该子元素的策略，并覆盖任何签名全局策略类型。
- en: In order for a policy stanza to be enforced, at least one of the preceding situations
    must apply. Meaning, empty signer, default or package tags will not be accepted.
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了强制执行策略段落，至少必须满足前面的一个条件。这意味着，空签名者、默认或包标签将不被接受。
- en: Each `signer/default/package` (global or attached to a signer) tag is allowed
    to contain one `<seinfo value=""/>` tag. This tag represents additional info that
    each app can use in setting an SELinux security context on the eventual process.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`signer/default/package`（全局或附加到签名者）标签都可以包含一个`<seinfo value=""/>`标签。此标签代表每个应用程序可以在最终进程中设置SELinux安全上下文时使用的附加信息。
- en: Strict enforcing of any XML stanza is not enforced in most cases. This mainly
    applies to duplicate tags, which are allowed. In the event that a tag already
    exists, the original tag is replaced.
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在大多数情况下，不会强制执行任何XML段落的严格规则。这主要适用于重复的标签，它们是被允许的。如果已存在标签，则原始标签将被替换。
- en: There are also no checks on the validity of permission names. Although valid
    Android permissions are expected, nothing prevents unknowns.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于权限名称的有效性也没有进行检查。尽管预期有效的Android权限，但没有任何东西阻止未知权限。
- en: 'Following are the enforcement decisions:'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以下是一些强制执行决策：
- en: All signatures used to sign an app are checked for policy according to signer
    tags. However, only one of the signature policies has to pass.
  id: totrans-82
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于签名应用程序的所有签名都根据签名者标签进行检查策略。然而，只需要通过一个签名策略。
- en: In the event that none of the signature policies pass, or none even match, then
    a global package policy is sought. If found, this policy mediates the install.
  id: totrans-83
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何签名策略通过，或者甚至没有匹配，那么会寻找全局包策略。如果找到，则此策略将调解安装。
- en: The default tag is consulted last, if needed.
  id: totrans-84
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，最后会咨询默认标签。
- en: A local package policy always overrides any parent policy.
  id: totrans-85
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地包策略始终覆盖任何父策略。
- en: If none of the cases apply, then the app is denied.
  id: totrans-86
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果没有任何情况适用，则应用程序将被拒绝。
- en: 'The following examples ignore the Install MMAC support and focus on the mainline
    usage of `seinfo` mapping. The following is an example of stanza mapping all things
    signed with the platform key to `seinfo` value platform:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例忽略了安装MMAC支持，并专注于`seinfo`映射的主线用法。以下是将所有使用平台密钥签名的项目映射到`seinfo`值`platform`的段落映射示例：
- en: '[PRE7]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here is an example mapping all things signed with the release key to the release
    domain with the exception of the browser. The browser gets assigned a `seinfo`
    value of `browser`, as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，将所有使用发布密钥签名的项目映射到发布域，除了浏览器。浏览器被分配了一个`seinfo`值为`browser`，如下所示：
- en: '[PRE8]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Anything with an unknown key, gets mapped to the default tag:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有未知密钥的项目都将映射到默认标签：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The signing tags are of interest, the `@PLATFORM` and `@RELEASE` are special
    processing strings used during build. Another mapping file maps these to actual
    key values. The file that is processed and placed onto the device has all key
    references replaced with hex encoded public keys rather than these placeholders.
    It also has all whitespace and comments stripped to reduce size. Let's take a
    look by pulling the built file from the device and formatting it.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 签名标签很有趣，`@PLATFORM`和`@RELEASE`是在构建期间使用的特殊处理字符串。另一个映射文件将这些映射到实际键值。处理并放置到设备上的文件将所有键引用替换为十六进制编码的公钥，而不是这些占位符。它还删除了所有空白和注释以减小大小。让我们通过从设备中提取构建文件并格式化它来查看。
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, scroll to the top of the formatted output; you should see the following:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，滚动到格式化输出的顶部；你应该看到以下内容：
- en: '[PRE11]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that `signature=@PLATFORM` is now a hex string. This hex string is a
    valid X509 certificate.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`signature=@PLATFORM`现在是一个十六进制字符串。这个十六进制字符串是一个有效的X509证书。
- en: keys.conf
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: keys.conf
- en: 'The actual magic doing the mapping from `signature=@PLATFORM` in `mac_permissions.xml`
    is `keys.conf`. This configuration file allows you to map a pem encoded x509 to
    an arbitrary string. The convention is to start them with `@`, but this is not
    enforced. The format of the file is based on the Python config parser and contains
    sections. The section names are the tags in the `mac_permissions.xml` file you
    wish to replace with key values. The platform example is:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上执行从`mac_permissions.xml`中的`signature=@PLATFORM`映射的魔法是`keys.conf`。此配置文件允许您将pem编码的x509映射到任意字符串。惯例是以`@`开头，但这不是强制性的。文件的格式基于Python配置解析器，并包含部分。部分名称是您希望在`mac_permissions.xml`文件中用键值替换的标签。平台示例如下：
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In Android, when you build, you can have three levels of builds: `engineering`,
    `userdebug`, or `user`. In the `keys.conf` file, you can associate a key to be
    used for all levels with the section attribute `ALL`, or you can assign different
    keys per level. This is helpful when building release or user builds with very
    special release keys. We see an example of this in the `@RELEASE` section:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，当你构建时，你可以有三个构建级别：`engineering`、`userdebug` 或 `user`。在 `keys.conf`
    文件中，你可以使用 `ALL` 部分属性关联一个用于所有级别的密钥，或者你可以为每个级别分配不同的密钥。这对于使用非常特殊的发布密钥构建发布或用户构建非常有用。我们可以在
    `@RELEASE` 部分看到一个例子：
- en: '[PRE13]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The file also allows the use of environment variables through the traditional
    `$` special character. The default location for the pem files is `build/target/product/security`.
    However, you should *never* use these keys for a user release build. These keys
    are the AOSP test keys and are public! By doing so, anyone can use the system
    key to sign their app and gain system privilege. The `keys.conf` file is only
    used during the build and is not located on the system.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 该文件还允许通过传统的 `$` 特殊字符使用环境变量。pem 文件默认位置是 `build/target/product/security`。然而，你绝对不应该在用户发布构建中使用这些密钥。这些密钥是
    AOSP 测试密钥，是公开的！这样做的话，任何人都可以使用系统密钥来签名他们的应用程序并获得系统权限。`keys.conf` 文件仅在构建期间使用，并且不在系统上。
- en: seapp_contexts
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: seapp_contexts
- en: 'So far, we have looked at how a finished `mac_permssions.xml` file assigns
    the `seinfo` value. Now we should address how the labeling is actually configured
    and utilizes this value. The labeling of applications is managed in another configuration
    file, `seapp_contexts`. Like `mac_permissions.xml`, it is loaded to the device.
    However, the default location is `/seapp_contexts`. The format of `seapp_contexts`
    is the `key=value` pair mappings per line, adhering to the following rules:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了如何一个完成的 `mac_permssions.xml` 文件分配 `seinfo` 值。现在我们应该解决如何实际配置和利用这个值。应用程序的标签化管理在另一个配置文件
    `seapp_contexts` 中进行。与 `mac_permissions.xml` 类似，它被加载到设备上。然而，默认位置是 `/seapp_contexts`。`seapp_contexts`
    的格式是每行 `key=value` 对映射，遵循以下规则：
- en: 'Input selectors:'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入选择器：
- en: '`isSystemServer` (boolean)'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSystemServer`（布尔值）'
- en: '`user` (string)'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user`（字符串）'
- en: '`seinfo` (string)'
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seinfo`（字符串）'
- en: '`name` (string)'
  id: totrans-110
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`（字符串）'
- en: '`sebool` (string)'
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sebool`（字符串）'
- en: 'Input selector rules:'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入选择器规则：
- en: '`isSystemServer=true` can only be used once.'
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`isSystemServer=true` 只能使用一次。'
- en: An unspecified `isSystemServer` defaults to false.
  id: totrans-114
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定的 `isSystemServer` 默认为 false。
- en: An unspecified string selector will match any value.
  id: totrans-115
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 未指定的字符串选择器将匹配任何值。
- en: A user string selector that ends in `*` will perform a prefix match.
  id: totrans-116
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以 `*` 结尾的用户字符串选择器将执行前缀匹配。
- en: '`user=_app` will match any regular app UID.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user=_app` 将匹配任何常规应用程序 UID。'
- en: '`user=_isolated` will match any isolated service UID.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`user=_isolated` 将匹配任何隔离服务 UID。'
- en: All specified input selectors in an entry must match (logical AND).
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个条目中所有指定的输入选择器必须匹配（逻辑与）。
- en: Matching is case-insensitive.
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 匹配不区分大小写。
- en: 'Precedence rules in order:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优先规则顺序：
- en: '`isSystemServer=true` before `isSystemServer=false`'
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `isSystemServer=false` 之前 `isSystemServer=true`
- en: Specified `user=` string before unspecified `user=` string
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定的 `user=` 字符串在未指定的 `user=` 字符串之前。
- en: Fixed the `user=` string before the `user=` prefix (ending in `*`)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `user=` 前缀（以 `*` 结尾）之前修复了 `user=` 字符串。
- en: Longer `user=` prefix before shorter `user=` prefix
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 较长的 `user=` 前缀在较短的 `user=` 前缀之前。
- en: Specified `seinfo=` string before unspecified `seinfo=` string.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未指定的 `seinfo=` 字符串之前指定 `seinfo=` 字符串。
- en: Specified `name=` string before unspecified `name=` string.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未指定的 `name=` 字符串之前指定 `name=` 字符串。
- en: Specified `sebool=` string before unspecified `sebool=` string.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在未指定的 `sebool=` 字符串之前指定 `sebool=` 字符串。
- en: 'Outputs:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出：
- en: '`domain` (string): It specifies the process domain for the application.'
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`domain`（字符串）：它指定应用程序的进程域。'
- en: '`type` (string): It specifies the disk label for the applications'' private
    data directory.'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`（字符串）：它指定应用程序私有数据目录的磁盘标签。'
- en: '`levelFrom` (string; one of `none`, `all`, `app`, or `user`): It gives the
    MLS specifier.'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom`（字符串；`none`、`all`、`app` 或 `user` 之一）：它给出 MLS 指定器。'
- en: '`level` (string): It shows the hardcoded MLS value.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`（字符串）：它显示硬编码的 MLS 值。'
- en: 'Output rules:'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出规则：
- en: Only entries that specify `domain=` will be used for app process labeling.
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有指定 `domain=` 的条目才会用于应用程序进程标签。
- en: Only entries that specify `type=` will be used for app directory labeling.
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有指定 `type=` 的条目才会用于应用程序目录标签。
- en: '`levelFrom=user` is only supported for `_app` or `_isolated` UIDs.'
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom=user` 只支持 `_app` 或 `_isolated` UIDs。'
- en: '`levelFrom=app` or `levelFrom=all` is only supported for `_app` UIDs.'
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`levelFrom=app` 或 `levelFrom=all` 只支持 `_app` UIDs。'
- en: '`level` may be used to specify a fixed level for any UID.'
  id: totrans-139
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`level`可以用来指定任何UID的固定级别。'
- en: 'During application spawn, this file is used by the `selinux_android_setcontext()`
    and `selinux_android_setfilecon2()` functions to look up the proper application
    domain or filesystem context, respectively. The source for these can be found
    in `external/libselinux/src/android.c` and are recommended reads. For example,
    this entry places all applications with UID `bluetooth` in the `bluetooth` domain
    with a data directory label of `bluetooth_data_file`:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序启动期间，此文件由`selinux_android_setcontext()`和`selinux_android_setfilecon2()`函数使用，分别查找适当的应用程序域或文件系统上下文。这些函数的源代码可以在`external/libselinux/src/android.c`中找到，建议阅读。例如，此条目将所有UID为`bluetooth`的应用程序放置在`bluetooth`域中，数据目录标签为`bluetooth_data_file`：
- en: '[PRE14]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This example places all third party or "default" applications into a process
    domain of `untrusted_app` and a data directory of `app_data_file`. It additionally
    uses MLS categories of `levelFrom=app` to help provide additional MLS-based separations.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '此示例将所有第三方或“默认”应用程序放入`untrusted_app`进程域和`app_data_file`数据目录中。它还使用`levelFrom=app`的MLS类别来帮助提供基于MLS的额外分离。 '
- en: '[PRE15]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Currently, this feature is experimental as this breaks some known application
    compatibility issues. At the time of this writing, this was a hot item of focus
    for both Google and NSA engineers. Since it is experimental, let's validate its
    functionality and then disable it.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个功能是实验性的，因为它破坏了一些已知的应用兼容性问题。在撰写本文时，这是谷歌和NSA工程师关注的焦点。由于它是实验性的，让我们验证其功能，然后禁用它。
- en: 'We have not installed any third party applications yet, so we''ll need to do
    so in order to experiment. FDroid is a useful place to find third party applications,
    so let''s download something from there and install it. We can use the `0xbenchmark`
    application located at [https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark](https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark)
    with an APK at [https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk](https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk),
    as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有安装任何第三方应用程序，因此我们需要这样做以便进行实验。FDroid是一个寻找第三方应用程序的有用地方，因此让我们从那里下载一些并安装它。我们可以使用位于[https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark](https://f-droid.org/repository/browse/?fdid=org.zeroxlab.zeroxbenchmark)的`0xbenchmark`应用程序，其APK位于[https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk](https://f-droid.org/repo/org.zeroxlab.zeroxbenchmark_9.apk)，如下所示：
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Tip
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Check `logcat` for the install time `seinfo` value:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 检查`logcat`以获取安装时的`seinfo`值：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'From your UDOO, launch the `0xbenchmark` APK. We should see it running with
    its label in `ps`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 从您的UDOO设备启动`0xbenchmark` APK。我们应该在`ps`中看到它运行并带有其标签：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Notice the level portion of the context string `s0:c40,c256`. These categories
    were created with the `level=app` setting from `seapp_contexts`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意上下文字符串的级别部分`s0:c40,c256`。这些类别是从`seapp_contexts`中的`level=app`设置创建的。
- en: To disable it, we could simply remove the key-value pair for level from the
    entry in `seapp_contexts`, or we could leverage the `sebool` conditional assignment.
    Let's use the Boolean approach. Modify the sepolicy `seapp_contexts` file so the
    existing `untrusted_app` entry is modified, and a new one is added. Change `user=_app
    domain=untrusted_app type=app_data_file` to `user=_app sebool=app_level domain=untrusted_app
    type=app_data_file levelFrom=app`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用它，我们可以简单地从`seapp_contexts`条目中删除`level`的键值对，或者我们可以利用`sebool`条件赋值。让我们使用布尔方法。修改`sepolicy`的`seapp_contexts`文件，以便修改现有的`untrusted_app`条目，并添加一个新的条目。将`user=_app
    domain=untrusted_app type=app_data_file`更改为`user=_app sebool=app_level domain=untrusted_app
    type=app_data_file levelFrom=app`。
- en: 'Build that with `mmm external/sepolicy`, as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下命令构建：`mmm external/sepolicy`：
- en: '[PRE19]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Well, there was a build error complaining about not finding the `selinux` Boolean
    on line 42 of `seapp_contexts`. Let''s attempt to correct the issue by declaring
    the Boolean. In `app.te`, add: `bool app_level false;`. Now push the newly built
    `seapp_contexts` and sepolicy file to the device and trigger a dynamic reload:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，有一个构建错误，抱怨在`seapp_contexts`的第42行找不到`selinux`布尔值。让我们通过声明布尔值来尝试纠正这个问题。在`app.te`中添加：`bool
    app_level false;`。现在将新构建的`seapp_contexts`和sepolicy文件推送到设备并触发动态重新加载：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can verify that the Boolean exists by:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过以下方式验证布尔值的存在：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Due to design limitations, we need to uninstall and reinstall the application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 由于设计限制，我们需要卸载并重新安装应用程序：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Re-install and check the context of the process *after* launching it:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 重新安装并检查启动应用程序后的进程上下文：
- en: '[PRE23]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Great! It failed. After some debugging, we discovered the source of the issue
    is that the path `/data/security` is not world searchable, causing a DAC permissions
    failure.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！失败了。经过一些调试，我们发现问题的根源是路径 `/data/security` 不是对所有人可搜索的，导致 DAC 权限失败。
- en: Note
  id: totrans-165
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We found this by printing off the result and error codes in `android.c` where
    we saw the `fopen` on `seapp_contexts_file[]` array (files in priority order)
    while checking the result of `fp = fopen(seapp_contexts_file[i++], "r")` in `selinux_android_seapp_context_reload()`
    and using `selinux_log()` to dump the data to `logcat`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过打印 `android.c` 中的结果和错误代码找到了这个问题，我们在 `selinux_android_seapp_context_reload()`
    中检查 `fp = fopen(seapp_contexts_file[i++], "r")` 的结果时，在 `seapp_contexts_file[]`
    数组（按优先级排序的文件）上看到了 `fopen`，并使用 `selinux_log()` 将数据转储到 `logcat`。
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Remember the `set selinux` context occurs after the UID switch, so we need to
    make it searchable for others. We can fix the permissions on the UDOO `init.rc`
    script by changing `device/fsl/imx6/etc/init.rc`. Specifically, change the line
    `mkdir /data/security 0700 system system` to `mkdir /data/security 0711 system
    system`. Build and flash the `bootimage`, and try the context test again.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 `set selinux` 上下文发生在 UID 切换之后，因此我们需要使其对其他人可搜索。我们可以通过更改 `device/fsl/imx6/etc/init.rc`
    中的 UDOO `init.rc` 脚本的权限来修复权限。具体来说，将行 `mkdir /data/security 0700 system system`
    更改为 `mkdir /data/security 0711 system system`。构建并刷新 `bootimage`，然后再次尝试上下文测试。
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So far, we've demonstrated how to use the `sebool` option on `seapp_contexts`
    to disable the MLS categories. It's important to note that when changing categories
    or types on APKs, it is required to remove and install the APK, or you will orphan
    the process from its data directory because it won't have access permissions under
    most circumstances.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经展示了如何使用 `sebool` 选项在 `seapp_contexts` 上禁用 MLS 类别。重要的是要注意，在更改 APK 上的类别或类型时，需要删除和安装
    APK，否则你将使进程与其数据目录分离，因为在大多数情况下它将没有访问权限。
- en: 'Next, let''s take this APK, uninstall it, and assign it a unique domain by
    changing its `seinfo` string. Typically, you use this feature to take a set of
    applications signed with a common key and get them into a custom domain to do
    custom things. For example, if you''re an OEM, you may need to allow custom permissions
    to third party applications that are not signed with an OEM controlled key. Start
    by uninstalling the APK:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们取这个 APK，卸载它，并通过更改其 `seinfo` 字符串为其分配一个唯一的域。通常，你使用此功能将使用共同密钥签名的应用程序集放入自定义域以执行自定义操作。例如，如果你是
    OEM，你可能需要允许使用 OEM 控制的密钥未签名的第三方应用程序自定义权限。首先，卸载 APK：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Create a new entry in `mac_permissions.xml` by adding:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `mac_permissions.xml` 中通过添加以下内容创建一个新的条目：
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now we need to get a pem file for `keys.conf`. So unpackage the APK and extract
    the public certificate:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要为 `keys.conf` 获取一个 pem 文件。所以解包 APK 并提取公钥证书：
- en: '[PRE28]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We''ll have to strip any cruft from the generated `CERT.pem` file. If you open
    it up, you should see these lines at the top:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要从生成的 `CERT.pem` 文件中删除任何冗余内容。如果你打开它，你应该在顶部看到这些行：
- en: '[PRE29]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: They need to be removed, so remove *only* the subject and issuer lines. The
    file should start with `BEGIN CERTIFICATE` and end with `END CERTIFICATE` scissor
    lines.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 它们需要被移除，所以只移除主题和发行者行。文件应从 `BEGIN CERTIFICATE` 开始，以 `END CERTIFICATE` 剪刀线结束。
- en: 'Let''s move this to a new folder in our workspace called `certs` and move the
    certificate into this folder with a better name:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把这项工作移到我们工作区的新文件夹中，命名为 `certs`，并将证书以更好的名称移动到这个文件夹中：
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can set up our `keys.conf` by adding:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加以下内容来设置我们的 `keys.conf`：
- en: '[PRE31]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Don''t forget to update `seapp_contexts` in order to use the new mapping:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更新 `seapp_contexts` 以使用新的映射：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now declare the new types to be used. The domain type should be declared in
    a file called `benchmark_app.te` in `sepolicy`:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明要使用的新类型。域类型应在 `sepolicy` 中的名为 `benchmark_app.te` 的文件中声明：
- en: '[PRE33]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Also, add the `benchmark_app_data_file` in `file.te`:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 还要在 `file.te` 中添加 `benchmark_app_data_file`：
- en: '[PRE34]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-190
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You may not always want *all* of these attributes, especially if you're doing
    something security critical. Make sure you look at each attribute and macro and
    see its usage. You don't want to open up an unintended hole by having an overly
    permissive domain.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能并不总是想要所有这些属性，特别是如果你正在做一些安全关键的事情。确保你查看每个属性和宏的用法。你不希望通过过度宽容的域打开一个意外的漏洞。
- en: Rebuild the policy, push the required pieces, and trigger a reload.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 重建策略，推动所需的组件，并触发重新加载。
- en: '[PRE35]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Start a shell and grep logcat to see the `seinfo` value the benchmark APK is
    installed as. Then install the APK:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 启动一个 shell 并使用 grep 查找 logcat 来查看基准 APK 安装的 `seinfo` 值。然后安装 APK：
- en: '[PRE36]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'On the `logcat` output, you should see:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在`logcat`输出中，你应该看到：
- en: '[PRE37]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: It should have been `seinfo=benchmark`! What could have happened?
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 应该是`seinfo=benchmark`！可能发生了什么？
- en: 'The problem is in `frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`.
    It looks in `/data/security/mac_permissions.xml`; so we can just push `mac_permissions.xml`.
    This is another bug in the dynamic policy reload and has to do with historical
    changes in this loading procedure. The culprit is within the `frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`
    file:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 问题出在`frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`文件中。它查找`/data/security/mac_permissions.xml`；所以我们只需推送`mac_permissions.xml`。这是动态策略重新加载中的另一个错误，与这个加载过程的历史变化有关。罪魁祸首就在`frameworks/base/services/java/com/android/server/pm/SELinuxMMAC.java`文件中：
- en: '[PRE38]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: To get around this, remount `system` and push it to the default location.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，请重新挂载`system`并将其推送到默认位置。
- en: '[PRE39]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This does *not* require a `setprop selinux.reload_policy 1`. Uninstall and
    reinstall the benchmark APK, and check the logs:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不需要执行`setprop selinux.reload_policy 1`。请卸载并重新安装基准APK，并检查日志：
- en: '[PRE40]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'OK. It still didn''t work. When we examined the code, the `mac_permissions.xml`
    file was loaded during package manager service start. This file won''t get reloaded
    without a reboot, so let''s uninstall the benchmark APK, and reboot the UDOO.
    After it''s been booted and `adb` is enabled, trigger a dynamic reload, install
    the APK, and check `logcat`. It should have:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。它仍然没有工作。当我们检查代码时，发现`mac_permissions.xml`文件在包管理器服务启动时被加载。这个文件在没有重启的情况下不会重新加载，所以让我们卸载基准APK，并重启UDOO。启动后，启用`adb`，触发动态重新加载，安装APK，并检查`logcat`。它应该有：
- en: '[PRE41]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now let''s verify the process domain by launching the APK, checking `ps`, and
    verifying its application private directory:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们通过启动APK、检查`ps`和验证其应用程序私有目录来验证进程域：
- en: '[PRE42]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This time, all the types check out. We successfully created a new custom domain.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，所有类型都通过了检查。我们成功创建了一个新的自定义域。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we investigated how to properly label application private data
    directories as well as their runtime contexts via the configuration files and
    SELinux policy. We also looked into the subsystems and code to make all of this
    work as well as some basic things that may go wrong along the way. In the next
    chapter, we will expand on how the policy and configuration files get built by
    peering into the SE for Android build system.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何通过配置文件和SELinux策略正确标记应用程序私有数据目录及其运行时上下文。我们还研究了使所有这些工作正常运行的子系统以及可能出错的一些基本事项。在下一章中，我们将扩展如何通过查看SE
    for Android构建系统来构建策略和配置文件。
