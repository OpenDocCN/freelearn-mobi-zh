<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Match 3 and Recursive Methods"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Match 3 and Recursive Methods</h1></div></div></div><p>We will now move to a modern classic game that features addictive gameplay, predictive coding, and artificial randomness. We will also work with recursive methods—methods that call themselves repeatedly.</p><p>In this chapter, we cover the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Basic state machines</li><li class="listitem" style="list-style-type: disc">Detecting matches</li><li class="listitem" style="list-style-type: disc">Predictive logic</li><li class="listitem" style="list-style-type: disc">Artificial randomness</li></ul></div><div class="section" title="The project is…"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>The project is…</h1></div></div></div><p>We will be building a Match 3 game in this chapter. <a id="id222" class="indexterm"/>
<a id="id223" class="indexterm"/>This game is heavily influenced by several of the extremely popular games of the genre, but we will be sticking to core mechanics in this chapter. What is being left out? We will not be including any special modes for matching four or five gems in a row, though those matches will still be scored. We will explore one approach to avoiding a "no more moves" situation using predictive logic and artificial randomness. We will assume you have familiarity with the basic structural concepts from <a class="link" href="ch01.html" title="Chapter 1. Thanks for the Memory Game">Chapter 1</a>, <span class="emphasis"><em>Thanks for the Memory Game</em></span>, so we will dive directly into the Match 3-specific code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p>We will be using classes with names such as <code class="literal">MAMenuLayer</code>, <code class="literal">MAPlayfieldLayer</code>, <code class="literal">MAMenuScene</code>, and <code class="literal">MAPlayfieldScene</code> throughout the book. The two-letter prefix will be different for each game (<code class="literal">MT</code> for <a class="link" href="ch01.html" title="Chapter 1. Thanks for the Memory Game">Chapter 1</a>, <span class="emphasis"><em>Thanks for the Memory Game</em></span>, <code class="literal">MA</code> for this chapter, and so on), but the role each class plays will be the same. This structure is our foundational nomenclature, so we should assume we have classes named in this fashion in each project.</p></div></div></div></div>
<div class="section" title="Basic gem interaction"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Basic gem interaction</h1></div></div></div><p>In this game, we only really have one type of object to play with—we will refer to these playing pieces as gems, since that is the most commonly used image in Match 3 games. We will look at some of the internals of the <a id="id224" class="indexterm"/>
<a id="id225" class="indexterm"/>
<code class="literal">MAGem</code> class, and <a id="id226" class="indexterm"/>then move on to how we actually handle the gems before tackling the more intricate logic.</p><div class="section" title="The MAGem header"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>The MAGem header</h2></div></div></div><p>We start out by looking at the header for the <code class="literal">MAGem</code> class, which is a subclass of <code class="literal">CCSprite</code>. We have a couple of new things <a id="id227" class="indexterm"/>here. <a id="id228" class="indexterm"/>We are using the <a id="id229" class="indexterm"/>
<a id="id230" class="indexterm"/>
<code class="literal">@class</code> statement to tell this class that there is another class called <a id="id231" class="indexterm"/>
<a id="id232" class="indexterm"/>
<code class="literal">MAPlayfieldLayer</code> that exists, but we don't want to import that class here. <code class="literal">MAGem</code> will be imported by <code class="literal">MAPlayfieldLayer</code>, and we don't want to get stuck in an infinite "import" loop.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id233" class="indexterm"/>
<a id="id234" class="indexterm"/>
<code class="literal">MAGem.h</code>
</p><div class="informalexample"><pre class="programlisting">@class MAPlayfieldLayer;

typedef enum {
    kGemAnyType = 0,
    kGem1,
    kGem2,
    kGem3,
    kGem4,
    kGem5,
    kGem6,
    kGem7
} GemType;

typedef enum {
    kGemIdle = 100,
    kGemMoving,
    kGemScoring,
    kGemNew
} GemState;

@interface MAGem : CCSprite {
    NSInteger _rowNum; // Row number for this gem
    NSInteger _colNum; // Column number for this gem
    GemType _gemType; // The enum value of the gem
    GemState _gemState; // The current state of the gem
    MAPlayfieldLayer *gameLayer; // The game layer
}

@property (nonatomic, assign) NSInteger rowNum;
@property (nonatomic, assign) NSInteger colNum;
@property (nonatomic, assign) GemType gemType;
@property (nonatomic, assign) GemState gemState;
@property (nonatomic, assign) MAPlayfieldLayer *gameLayer;

-(BOOL) isGemSameAs:(MAGem*)otherGem;
-(BOOL) isGemInSameRow:(MAGem*)otherGem;
-(BOOL) isGemInSameColumn:(MAGem*)otherGem;
-(BOOL) isGemBeside:(MAGem*)otherGem;

-(void) highlightGem;
-(void) stopHighlightGem;

- (BOOL) containsTouchLocation:(CGPoint)pos;
@end</pre></div><p>You will notice we begin the class with two sections of <code class="literal">typedef enum</code>. This is a C construct that is basically an integer constant. Inside the curly braces is a comma-separated list of all of the named elements we want to use, and after the closing curly brace, we give a name to this enumerated value. In the first <code class="literal">typedef</code> statement, we are establishing that we have a new object type called <code class="literal">GemType</code>. Valid values for this are <code class="literal">kGemAnyType</code>, <code class="literal">kGem1</code>, <code class="literal">kGem2</code>, and so on. <a id="id235" class="indexterm"/>You will also notice that the first value is assigned to an integer, <code class="literal">0</code>. If you omit this assignment, the named values will automatically be assigned unique integer values. Because we <a id="id236" class="indexterm"/>have explicitly declared that the first value is <code class="literal">0</code>, the compiler will automatically assign incremental integers to the remaining values. This gives a small peek at the flexibility of these values. Even though we use the named values for them, we can also treat them as integers if there is a need. For example, <code class="literal">kGem1</code> and the integer value <code class="literal">1</code> are identical and can be used interchangeably.</p><p>Once we have built these <a id="id237" class="indexterm"/>
<code class="literal">typedef</code> sections, we can treat the <a id="id238" class="indexterm"/>
<a id="id239" class="indexterm"/>
<code class="literal">GemType</code> and <a id="id240" class="indexterm"/>
<a id="id241" class="indexterm"/>
<code class="literal">GemState</code> types the same as any other valid data type, as we have done in the variable declarations. These will also be valid to use in any other class that imports the <code class="literal">MAGem</code> class.</p><p>One important feature we have added to the <code class="literal">MAGem</code> class is a primitive state machine. We use the <code class="literal">gemState</code> variable to hold the current state of the gem. The gem can only be in a single state at a time. The possible states are <code class="literal">kGemNew</code>, <code class="literal">kGemIdle</code>, <code class="literal">kGemScoring</code>, and <code class="literal">kGemMoving</code> (as defined in the second <a id="id242" class="indexterm"/>
<a id="id243" class="indexterm"/>
<code class="literal">typedef enum</code> statement). These could also be handled by a series of <code class="literal">BOOL</code> variables for each state, but that gets confusing very quickly. Since the states are mutually exclusive, using a single state <a id="id244" class="indexterm"/>
<a id="id245" class="indexterm"/>variable is the preferred way to handle this.</p></div><div class="section" title="The MAGem class"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>The MAGem class</h2></div></div></div><p>Now we turn our attention to the <code class="literal">MAGem.m</code> file. Because <code class="literal">MAGem</code> is a subclass of <code class="literal">CCSprite</code>, we have intentionally avoided overriding any methods. <a id="id246" class="indexterm"/>Although it is common to override the <a id="id247" class="indexterm"/>
<a id="id248" class="indexterm"/>
<code class="literal">init</code> method, we are taking an alternate approach here. All of our instance variables will be set by the calling method, not by the <code class="literal">init</code> method. This illustrates the fact that there is not a single right <a id="id249" class="indexterm"/>answer to any situation. This approach actually leads to slightly fewer lines of code, since the gems will only be created by a single method in our <a id="id250" class="indexterm"/>
<a id="id251" class="indexterm"/>
<code class="literal">MAPlayfieldLayer</code> class. Functionally, there is no difference between setting these values in a custom <code class="literal">init</code> method versus the approach taken here.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id252" class="indexterm"/>
<a id="id253" class="indexterm"/>
<code class="literal">MAGem.m</code>
</p><div class="informalexample"><pre class="programlisting">@implementation MAGem

@synthesize rowNum = _rowNum;
@synthesize colNum = _colNum;
@synthesize gemType = _gemType;
@synthesize gemState = _gemState;

@synthesize gameLayer;

-(BOOL) isGemSameAs:(MAGem*)otherGem {
    // Is the gem the same type as the other Gem?
    return (self.gemType == otherGem.gemType);
}

-(BOOL) isGemInSameRow:(MAGem*)otherGem {
    // Is the gem in the same row as the other Gem?
    return (self.rowNum == otherGem.rowNum);
}

-(BOOL) isGemInSameColumn:(MAGem*)otherGem {
    // Is the gem in the same column as the other gem?
    return (self.colNum == otherGem.colNum);
}</pre></div><p>We have a few helper methods in this class that will make the matching logic easier. Look at the method <a id="id254" class="indexterm"/>
<a id="id255" class="indexterm"/>
<code class="literal">isGemSameAs</code> in this class. Since this is in the <a id="id256" class="indexterm"/>
<a id="id257" class="indexterm"/>
<code class="literal">MAGem</code> class, we can pass it another <code class="literal">MAGem</code> instance as an argument, and it compares the <code class="literal">gemType</code> variables to determine whether they are the same type of gem. If they are the same, we return <code class="literal">YES</code>. If they are different, we return <code class="literal">NO</code>. We follow the same pattern for the <a id="id258" class="indexterm"/>
<a id="id259" class="indexterm"/>
<code class="literal">isGemInSameRow</code> and <a id="id260" class="indexterm"/>
<a id="id261" class="indexterm"/>
<code class="literal">isGemInSameColumn</code> methods. The code in these <a id="id262" class="indexterm"/>
<a id="id263" class="indexterm"/>methods is extremely simple but will allow us to simplify how we interact with the gems.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id264" class="indexterm"/>
<a id="id265" class="indexterm"/>
<code class="literal">MAGem.m</code>
</p><div class="informalexample"><pre class="programlisting">-(BOOL) isGemBeside:(MAGem*)otherGem {
    // If the row is the same, and the other gem is 
    // +/- 1 column, they are neighbors
    if ([self isGemInSameRow:otherGem] &amp;&amp; 
        ((self.colNum == otherGem.colNum - 1) || 
        (self.colNum == otherGem.colNum + 1))
        ) {
        return YES;
    }
    // If the column is the same, and the other gem is 
    // +/- 1 row, they are neighbors
    else if ([self isGemInSameColumn:otherGem] &amp;&amp; 
                 ((self.rowNum == otherGem.rowNum - 1) || 
                  (self.rowNum == otherGem.rowNum + 1))
                 ) {
        return YES;
    } else {
        return NO;
    }
}</pre></div><p>The <a id="id266" class="indexterm"/>
<a id="id267" class="indexterm"/>
<code class="literal">isGemBeside</code> method is a little more involved. We first check to see whether the two gems in question (the current gem and <code class="literal">otherGem</code>) are in the same row, using the method we just saw. We also check to see whether the <a id="id268" class="indexterm"/>
<a id="id269" class="indexterm"/>
<code class="literal">colNum</code> variable of the <a id="id270" class="indexterm"/>
<a id="id271" class="indexterm"/>
<code class="literal">otherGem</code> object is either one greater or one less than the current gem. If this is true, we return <code class="literal">YES</code>. We then check to see whether <code class="literal">otherGem</code> is in the same column and whether they are in adjacent rows, in the same manner. This method (with the other <a id="id272" class="indexterm"/>
<a id="id273" class="indexterm"/>
<code class="literal">isGem</code> methods) will make comparisons between <a id="id274" class="indexterm"/>gems trivial to implement later.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id275" class="indexterm"/>
<a id="id276" class="indexterm"/>
<code class="literal">MAGem.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) highlightGem {
    // Build a simple repeating "wobbly" animation
    CCMoveBy *moveUp = [CCMoveBy actionWithDuration:0.1
                        position:ccp(0,3)];
    CCMoveBy *moveDown = [CCMoveBy actionWithDuration:0.1
                        position:ccp(0,-3)];
    CCSequence *moveAround = [CCSequence actions:moveUp,
                        moveDown, nil];
    CCRepeatForever *gemHop = [CCRepeatForever
                        actionWithAction:moveAround];
    
    [self runAction:gemHop];
}

-(void) stopHighlightGem {
    // Stop all actions (the wobbly) on the gem
    [self stopAllActions];

    // We call to the gameLayer itself to make sure we 
    // haven't left the gem a little off-base
    // (from the highlightGem movements)
    [gameLayer performSelector:@selector(resetGemPosition:)
                    withObject:self];
}</pre></div><p>In the preceding code, we see the <a id="id277" class="indexterm"/>
<a id="id278" class="indexterm"/>
<code class="literal">highlightGem</code> and <a id="id279" class="indexterm"/>
<a id="id280" class="indexterm"/>
<code class="literal">stopHighlightGem</code> methods. These will be used when the player touches a gem. The gem will hop up and down when it is selected. <code class="literal">stopHighlightGem</code> makes a call to the <code class="literal">resetGemPosition</code> <a id="id281" class="indexterm"/>
<a id="id282" class="indexterm"/>method in the <a id="id283" class="indexterm"/>
<a id="id284" class="indexterm"/>
<code class="literal">GameLayer</code> class. We do this because the gem itself has no knowledge of where it is supposed to be on the screen. We could migrate the positioning code into the <code class="literal">MAGem</code> class to avoid this cross-class calling, but this works well, so we will leave it this way. </p></div><div class="section" title="Generating gems"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Generating gems</h2></div></div></div><p>We will build a new subclass of <code class="literal">CCLayer</code>, called <a id="id285" class="indexterm"/>
<a id="id286" class="indexterm"/>
<code class="literal">MAPlayfieldLayer</code>, and <a id="id287" class="indexterm"/>we will set up a couple of <a id="id288" class="indexterm"/>methods to control all gem creation.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id289" class="indexterm"/>
<a id="id290" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(MAGem*) generateGemForRow:(NSInteger)rowNum
    andColumn:(NSInteger)colNum ofType:(GemType)newType {
    GemType gemNum;
    
    if (newType == kGemAnyType) {
        // If we passed a kGemAnyType, randomize the gem
        gemNum = (arc4random() % totalGemsAvailable) + 1;
    } else {
        // If we passed another value, use that gem type
        gemNum = newType;
    }

    // Generate the sprite name
    NSString *spritename = [NSString stringWithFormat:
                            @"gem%i.png", gemNum];

    // Build the MAGem, which is just an enhanced CCSprite
    MAGem *thisGem = [MAGem
                    spriteWithSpriteFrameName:spritename];
    
    // Set the gem's vars
    [thisGem setRowNum:rowNum];
    [thisGem setColNum:colNum];
    [thisGem setGemType:(GemType)gemNum];
    [thisGem setGemState:kGemNew];
    [thisGem setGameLayer:self];
    
    // Set the position for this gem
    [thisGem setPosition:[self positionForRow:rowNum
                                    andColumn:colNum]];
    
    // Add the gem to the array
    [gemsInPlay addObject:thisGem];
    
    // We return the newly created gem, which is already
    // added to the gemsInPlay array
    // It has NOT been added to the layer yet.
    return thisGem;
}

-(void) addGemForRow:(NSInteger)rowNum
           andColumn:(NSInteger)colNum
              ofType:(GemType)newType {

    // Add a replacement gem
    MAGem *thisGem = [self generateGemForRow:rowNum
                    andColumn:colNum ofType:newType];
    
    // We reset the gem above the screen
    [thisGem setPosition:ccpAdd(thisGem.position,
                                ccp(0,size.height))];

    // Add the gem to the scene
    [self addChild:thisGem];
    
    // Drop it to the correct position
    [self moveToNewSlotForGem:thisGem];
}</pre></div><p>Combined, these two methods take care of creating a new gem, assigning all variables (including the <a id="id291" class="indexterm"/>
<a id="id292" class="indexterm"/>
<code class="literal">GameLayer</code> variable we use to refer to the layer from the <code class="literal">MAGem</code> class), and putting the gem into play. Why two methods? The <a id="id293" class="indexterm"/>
<a id="id294" class="indexterm"/>
<code class="literal">addGemForRow:</code> method takes control over three aspects of the addition: adding the gem to the layer, setting the position to a position higher than the screen, and calling the method to drop the gem into its proper position. The <a id="id295" class="indexterm"/>
<a id="id296" class="indexterm"/>
<code class="literal">generateGemsForRow:</code> method does everything except putting the gem into play. We do this because there are situations where we want to create a gem without making it visible, such as <a id="id297" class="indexterm"/>when we build the initial board. </p><p>Since we are keeping a reference to the playfield layer inside the <code class="literal">MAGem</code> class (in the <code class="literal">setGameLayer:</code> line in the <a id="id298" class="indexterm"/>
<a id="id299" class="indexterm"/>
<code class="literal">generate</code> methods), we need to be <a id="id300" class="indexterm"/>memory-conscious and set that property to <code class="literal">nil</code> when the gem's <a id="id301" class="indexterm"/>
<a id="id302" class="indexterm"/>
<code class="literal">dealloc</code> method is run.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id303" class="indexterm"/>
<a id="id304" class="indexterm"/>
<code class="literal">MAGem.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) dealloc {
    [self setGameLayer:nil];
    
    [super dealloc];
}</pre></div></div></div>
<div class="section" title="Building the playfield"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Building the playfield</h1></div></div></div><p>The creation of a basic playfield is very similar to the setup for the Memory game in <a class="link" href="ch01.html" title="Chapter 1. Thanks for the Memory Game">Chapter 1</a>, <span class="emphasis"><em>Thanks for the Memory Game</em></span>, with some slight variations. We do not want the playfield to start with three-in-a-row matches, so we want to <a id="id305" class="indexterm"/>check for matching situations <a id="id306" class="indexterm"/>and change the gems around to make sure the board is "clean" when the game starts.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id307" class="indexterm"/>
<a id="id308" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) generatePlayfield {
    // Randomly select gems and place on the board
    // Iterate through all rows and columns
    for (int row = 1; row &lt;= boardRows; row++) {
        for (int col = 1; col &lt;= boardColumns; col++) {
            // Generate a gem for this slot
            [self generateGemForRow:row andColumn:col
                             ofType:kGemAnyType];
        }
    }
    
    // We check for matches now, and remove any gems 
    // from starting in the scoring position
    [self fixStartingMatches];

    // Add the gems to the layer
    for (MAGem *aGem in gemsInPlay) {
        [aGem setGemState:kGemIdle];
        [matchsheet addChild:aGem];
    }
}</pre></div><p>In this method, we iterate through all positions and call <code class="literal">generateGemForRow:</code> for each slot on the board. As you recall, the <a id="id309" class="indexterm"/>
<a id="id310" class="indexterm"/>
<code class="literal">generateGemForRow:</code> method does not add the gems to the layer, so we can manipulate the board before we introduce it to the player. We call the <a id="id311" class="indexterm"/>
<a id="id312" class="indexterm"/>
<code class="literal">fixStartingMatches</code> method to correct any starting three-in-a-row situations, and then we iterate through all of the gems in the <code class="literal">gemsInPlay</code>  array and add them to the board. (You may notice that, when a gem is first added, it is set to the state <code class="literal">kGemNew</code>, and when it is added to the board, it is changed to <code class="literal">kGemIdle</code>. <a id="id313" class="indexterm"/>This is to avoid any accidental matches occurring when a new gem has been created but is not yet visible. By the time we add it to the board, it is ready to play, so <code class="literal">kGemIdle</code> is the <a id="id314" class="indexterm"/>correct state at that time.) Now we need to see how the <a id="id315" class="indexterm"/>
<a id="id316" class="indexterm"/>
<code class="literal">fixStartingMatches</code> method works.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id317" class="indexterm"/>
<a id="id318" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) fixStartingMatches {
    // This method checks for any possible matches
    // and will remove those gems. After fixing the gems,
    // we call this method again (from itself) until we
    // have a clean result
    [self checkForMatchesOfType:kGemNew];
    if ([gemMatches count] &gt; 0) {
        
        // get the first matching gem
        MAGem *aGem = [gemMatches objectAtIndex:0];

        // Build a replacement gem
        [self generateGemForRow:[aGem rowNum] andColumn:
                    [aGem colNum] ofType:kGemAnyType];
            
        // Destroy the original gem
        [gemsInPlay removeObject:aGem];
        [gemMatches removeObject:aGem];
            
        // We recurse so we can see if the board is clean
        // When we have no gemMatches, we stop recursion
        [self fixStartingMatches];
    }
}</pre></div><p>This method starts with the <a id="id319" class="indexterm"/>
<a id="id320" class="indexterm"/>
<code class="literal">checkForMatchesOfType</code> method, which we will cover shortly. For now, we only need to know that it reviews all gems in the <code class="literal">gemsInPlay</code> array and any three-in-a-row matching gems are added to the <code class="literal">gemMatches</code> array. This method calls that check, and if there are any gems in the <code class="literal">gemMatches</code> array, it destroys the first gem in the <code class="literal">gemMatches</code> array and creates a new replacement. After it has replaced this <span class="emphasis"><em>one</em></span> gem, it calls itself, so it can check the entire board again. Why not fix all of them at once? The <a id="id321" class="indexterm"/>
<a id="id322" class="indexterm"/>
<code class="literal">gemMatches</code> array contains <span class="emphasis"><em>all</em></span> matches, which means that if there is only a single three-in-a-row match on the board, there are three <a id="id323" class="indexterm"/>gems in the array. We only need to replace one of those gems to "fix" this match on the board, so the other two gems in that match will be unchanged. To help visually explain this, look at the following comparison:</p><div class="mediaobject"><img src="graphics/9007_02_01.jpg" alt="Building the playfield"/></div><p>When the board was first generated, it created an instant match, as seen within the red box in the left image. After the <a id="id324" class="indexterm"/>
<a id="id325" class="indexterm"/>
<code class="literal">fixStartingMatches</code> method was run, it replaced the first gem in the match (the top one, in this case) and replaced it with a new, randomly generated gem. There is no longer a three-in-a-row match, so we are done. The <code class="literal">fixStartingMatches</code> method will run itself again <a id="id326" class="indexterm"/>after this one gem is changed, just to make sure we don't have another match situation. When all three-in-a-row match conditions have been fixed in this manner, the game setup can continue. </p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>For the remainder of the book, we will be focusing on the implementation (<code class="literal">.m</code>) files. With a few exceptions, we will not be spending time going over the details of the headers, so you will want to consult the code bundle for this book if you are uncertain about a variable or property that is used within the code presented here. Our goal is primarily to understand how the various methods and objects power the games, and most of the important details are in the implementation files.</p></div></div></div>
<div class="section" title="Checking for matches"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec21"/>Checking for matches</h1></div></div></div><p>There is only one method left to see the initial board built. The method <code class="literal">checkForMatchesOfType</code> <a id="id327" class="indexterm"/>
<a id="id328" class="indexterm"/>takes a <a id="id329" class="indexterm"/>
<a id="id330" class="indexterm"/>
<code class="literal">desiredGemState</code> value as a parameter. We do this because, during the initial board setup, we <a id="id331" class="indexterm"/>only want to check gems that are in the state <code class="literal">kGemNew</code>. Later, during actual gameplay, we only want to <a id="id332" class="indexterm"/>check for matches when the gems are in the state <code class="literal">kGemIdle</code>. (During gameplay, the gems in the <code class="literal">kGemNew</code> state will be outside the visible screen before they are dropped on to the screen, and we definitely do not want to include them in matches until they drop into position.) Let's look at the method now, in two parts:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id333" class="indexterm"/>
<a id="id334" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code> (<code class="literal">checkForMatchesOfType</code>, part 1)</p><div class="informalexample"><pre class="programlisting">-(void) checkForMatchesOfType:(GemType)desiredGemState {
  // Let's look for horizontal matches    
  for (MAGem *aGem in gemsInPlay) {
    // Let's grab the first gem
    if (aGem.gemState == desiredGemState) {
      // If it is the desired state, let's look
      // for a matching neighbor gem
      for (MAGem *bGem in gemsInPlay) {
        // If the gem is the same type and state,
        // in the same row, and to the right
        if ([aGem isGemSameAs:bGem] &amp;&amp;
          [aGem isGemInSameRow:bGem] &amp;&amp;
            aGem.colNum == bGem.colNum - 1 &amp;&amp;
            bGem.gemState == desiredGemState) {
            // Now we loop through again,
            // looking for a 3rd in a row
            for (MAGem *cGem in gemsInPlay) {
              // If this is the 3rd gem in a row
              // in the desired state
              if (aGem.colNum == cGem.colNum - 2 &amp;&amp;
                  cGem.gemState == desiredGemState) {
                   // Is the gem the same type
                   // and in the same row?
                   if ([aGem isGemSameAs:cGem] &amp;&amp;
                 [aGem isGemInSameRow:cGem]) {
                         // Add gems to match array
                  [self addGemToMatch:aGem];
                   [self addGemToMatch:bGem];
                  [self addGemToMatch:cGem];
                          break;
                   }
              }
           }  
        } 
     }
  }</pre></div><p>This method looks a little daunting, so let's take it apart. We have two main sections, one for the horizontal matches and one for vertical matches. What we see in the preceding code is just the horizontal match checking. The outer <span class="emphasis"><em>for</em></span> loop iterates through all of the gems in the <a id="id335" class="indexterm"/>
<a id="id336" class="indexterm"/>
<code class="literal">gemsInPlay</code> array, naming this gem <code class="literal">aGem</code>. We immediately check to make sure <code class="literal">aGem</code> has the <a id="id337" class="indexterm"/>
<a id="id338" class="indexterm"/>
<code class="literal">desiredGemState</code> value we are looking for. If not, the rest of this section is skipped. If the <code class="literal">gemState</code> has the <code class="literal">desiredGemState</code> value, we start a second <span class="emphasis"><em>for</em></span> loop on the same <a id="id339" class="indexterm"/>
<a id="id340" class="indexterm"/>
<code class="literal">gemsInPlay</code> array, this time calling the <a id="id341" class="indexterm"/>gem being evaluated <code class="literal">bGem</code>. We check to see whether the following conditions <a id="id342" class="indexterm"/>are true: </p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">aGem </code>is the same type as <code class="literal">bGem</code> (using the <code class="literal">isGemSameAs</code> method)</li><li class="listitem" style="list-style-type: disc"><code class="literal">aGem </code>is in the same row as <code class="literal">bGem</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">aGem</code>'s <code class="literal">colNum</code> is equal to the <code class="literal">bGem</code>'s <code class="literal">colNum</code> – 1 </li><li class="listitem" style="list-style-type: disc"><code class="literal">bGem</code> is in the <code class="literal">desiredGemState</code></li></ul></div><p>If all these conditions are true, it means that the <code class="literal">aGem</code> being evaluated has an identical gem to the right of it. So, we have a two-in-a-row situation. Now we start a third <span class="emphasis"><em>for </em></span>loop using the <a id="id343" class="indexterm"/>
<a id="id344" class="indexterm"/>
<code class="literal">gemsInPlay</code> array, the same as the other two loops. With the third loop, we break the conditions into two separate <span class="emphasis"><em>if</em></span> statements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">aGem</code>'s <code class="literal">colNum</code> is equal to <code class="literal">cGem</code>'s <code class="literal">colNum</code> – 2</li><li class="listitem" style="list-style-type: disc"><code class="literal">cGem</code>'s gem state is equal to the <code class="literal">desiredGemState</code></li></ul></div><p>And in the second <span class="emphasis"><em>if</em></span> statement, we check these statements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">aGem</code> is of the same type as <code class="literal">cGem</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">aGem</code> is in the same row as <code class="literal">cGem</code></li></ul></div><p>If all of these conditions are true, we have made a three-in-a-row match. All three gems involved in the matching are then added to the <a id="id345" class="indexterm"/>
<a id="id346" class="indexterm"/>
<code class="literal">gemMatches</code> array. Instead of adding the gems directly to the array, we use the method <code class="literal">addGemToMatch</code>.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id347" class="indexterm"/>
<a id="id348" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addGemToMatch:(MAGem*)thisGem {
    // Only adds it to the array if it isn't already there
    if ([gemMatches indexOfObject:thisGem] == NSNotFound) {
        [gemMatches addObject:thisGem];
    }
}</pre></div><p>Because we are checking the whole board, we often find multiple matches that involve the same gem. Since we only want each matching gem represented once, the <code class="literal">addGemToMatch</code> method checks to make sure the gem is <a id="id349" class="indexterm"/>not already in the array before adding it.</p><p>Now we can take a look at the second half of the method:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id350" class="indexterm"/>
<a id="id351" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code> (<code class="literal">checkForMatchesOfType</code>, part 2)</p><div class="informalexample"><pre class="programlisting"> // Let's look for vertical matches
  for (MAGem *aGem in gemsInPlay) {
    // Let's grab the first gem
    if (aGem.gemState == desiredGemState) {
       // If it is the desired state, let's look for a
      // matching neighbor gem
      for (MAGem *bGem in gemsInPlay) {
        // If the gem is the same type and state,
      // in the same column, and above
        if ([aGem isGemSameAs:bGem] &amp;&amp;
          [aGem isGemInSameColumn:bGem] &amp;&amp;
            aGem.rowNum == bGem.rowNum - 1 &amp;&amp;
            bGem.gemState == desiredGemState) {
              // Now we looking for a 3rd in the column
              for (MAGem *cGem in gemsInPlay) {
                 // If this is the 3rd gem in a row
                 if (bGem.rowNum == cGem.rowNum - 1 &amp;&amp;
                     cGem.gemState == desiredGemState) {
                       // Is the gem the same type and
                 // in the same column?
                      if ([bGem isGemSameAs:cGem] &amp;&amp;
                          [bGem isGemInSameColumn:cGem]) {
                            // Add gems to match array
                            [self addGemToMatch:aGem];
                     [self addGemToMatch:bGem];
                      [self addGemToMatch:cGem];
                            break;

                      } 
                   }
                }
             }
          } 
       }
    }
  }
}</pre></div><p>The second half of this method checks for vertical matches. You will notice that the code looks strikingly similar to the horizontal check we just reviewed <a id="id352" class="indexterm"/>in detail. The vertical check is almost the same as the horizontal, except that all references to rows and columns <a id="id353" class="indexterm"/>are reversed. Everything else is in the same structure.</p><div class="section" title="Collecting touches"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec22"/>Collecting touches</h2></div></div></div><p>Now that we have a board built, we need to add some mechanics to move the gems so we can make matches. Let's look at the touch <a id="id354" class="indexterm"/>handlers, <a id="id355" class="indexterm"/>starting with the <a id="id356" class="indexterm"/>
<a id="id357" class="indexterm"/>
<code class="literal">ccTouchBegan</code> method:</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(BOOL) ccTouchBegan:(UITouch *)touch withEvent:(UIEvent *)event {
    
    CGPoint location = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:location];
    
    // If we reached game over, any touch returns to menu
    if (isGameOver) {
        [[CCDirector sharedDirector]
                replaceScene:[MAMenuScene scene]];
        return YES;
    }
    
    // If the back button was pressed, we exit
    if (CGRectContainsPoint([backButton boundingBox],
                            convLoc)) {
        [[CCDirector sharedDirector]
         replaceScene:[MAMenuScene node]];
        return YES;
    }
    
    // If we have only 0 or 1 gem in gemsTouched, track
    if ([gemsTouched count] &lt; 2) {
        // Check each gem
        for (MAGem *aGem in gemsInPlay) {
            // If the gem was touched AND the gem is idle,
            // return YES to track the touch
            if ([aGem containsTouchLocation:convLoc] &amp;&amp;
                            aGem.gemState == kGemIdle) {
                return YES;
            }
        }
    }

    // If we failed to find any good touch, return
    return NO;
}</pre></div><p>The <a id="id358" class="indexterm"/>
<a id="id359" class="indexterm"/>
<code class="literal">ccTouchBegan</code> method controls whether we track a specific touch. If we have reached a "game over" condition (indicated by the <code class="literal">gameOver</code> variable), we go back to the menu. We also trigger the same <code class="literal">replaceScene</code> method if <code class="literal">backButton</code> is touched. We handle these situations in <code class="literal">ccTouchBegan</code>, so we can override <a id="id360" class="indexterm"/>any other logic that might be going on and can leave the game whenever we want to.</p><p>This is the first time we have encountered the <code class="literal">gemsTouched</code> array, so we will explain it here. When the player touches any gem, we add that gem to the <code class="literal">gemsTouched</code> array. When we have two gems in the <a id="id361" class="indexterm"/>
<a id="id362" class="indexterm"/>
<code class="literal">gemsTouched</code> array, we swap the position of the gems and check for a match. If there are two gems in the array, we know something else is happening in the game (swapping gems, checking for matches, moving gems around, and so on), so we stop tracking the touch at that point. If we have less than two gems in the array, we iterate through the <code class="literal">gemsInPlay</code> array to determine which (if any) gem was touched. When we find one, we return <code class="literal">YES</code> to allow the touch to be tracked.</p><p>Now that we have a touch being tracked, the handler <a id="id363" class="indexterm"/>continues with the <a id="id364" class="indexterm"/>
<a id="id365" class="indexterm"/>
<code class="literal">ccTouchMoved</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id366" class="indexterm"/>
<a id="id367" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) ccTouchMoved:(UITouch *)touch withEvent:(UIEvent *)event {
    // Swipes are handled here.
    [self touchHelper:touch withEvent:event];
}</pre></div><p>There is not much here. This method passes everything along to our own <code class="literal">touchHelper</code> method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id368" class="indexterm"/>
<a id="id369" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) touchHelper:(UITouch *)touch withEvent:(UIEvent *)event {
    // If we're already checking for a match, ignore
    if ([gemsTouched count] &gt;= 2 || gemsMoving == YES) {
        return;
    }
    
    CGPoint location = [touch locationInView:[touch view]];
    CGPoint convLoc = [[CCDirector sharedDirector]
                       convertToGL:location];
    
    // Let's figure out which gem was touched (if any)
    for (MAGem *aGem in gemsInPlay) {
        if ([aGem containsTouchLocation:convLoc] &amp;&amp;
            aGem.gemState == kGemIdle) {
            // We can't add the same gem twice
            if ([gemsTouched containsObject:aGem] == NO) {
                // Add the gem to the array
                [self playDing];
                [gemsTouched addObject:aGem];
                [aGem highlightGem];
            }
        }
    }
    
    // We now have touched 2 gems.  Let's swap them.
    if ([gemsTouched count] &gt;= 2) {
        MAGem *aGem = [gemsTouched objectAtIndex:0];
        MAGem *bGem = [gemsTouched objectAtIndex:1];
        
        // If the gems are adjacent, we can swap
        if ([aGem isGemBeside:bGem]) {
            [self swapGem:aGem withGem:bGem];
        } else {
            // They're not adjacent, so let's drop
            // the first gem
            [aGem stopHighlightGem];
            [gemsTouched removeObject:aGem];
        }
    }
}</pre></div><p>As the player slides their finger on the board, <code class="literal">ccTouchMoved</code> will be triggered constantly, which in turn will call the <a id="id370" class="indexterm"/>
<a id="id371" class="indexterm"/>
<code class="literal">touchHelper</code> method repeatedly. The first check is to make sure that we don't already have two objects in the <code class="literal">gemsTouched</code>  array (the same "protection" as in <code class="literal">ccTouchBegan</code>) and to make sure we don't have any gems moving (where the<code class="literal"> gemsMoving</code> variable is <code class="literal">YES</code>). If we do, <a id="id372" class="indexterm"/>we call <code class="literal">return</code>, to stop tracking this touch.</p><p>If the touch comes in contact with a gem, and the gem is not already in the <code class="literal">gemsTouched</code> array, we play a sound, add it to the <a id="id373" class="indexterm"/>
<a id="id374" class="indexterm"/>
<code class="literal">gemsTouched</code> array, and send a message to the gem to run the <a id="id375" class="indexterm"/>
<a id="id376" class="indexterm"/>
<code class="literal">highlightGem</code> method. Since this code is called from the <code class="literal">ccTouchMoved</code> method, each gem will be added to the array (up to the stated maximum of two) as we swipe across multiple gems. We have swipe detection without needing any gesture detection code.</p><p>The final <span class="emphasis"><em>if</em></span> statement is to check whether we <a id="id377" class="indexterm"/>have gathered two gems in the <code class="literal">gemsTouched</code> array. If we have, we first check to make sure the gems are adjacent (the <code class="literal">isGemBeside</code> method). If they are adjacent, we call <code class="literal">swapGem</code> and pass the two gems to that method. If not, we stop highlighting the first gem in the array and remove it from the <code class="literal">gemsTouched</code> array, so the second touch is now the only gem in the <code class="literal">gemsTouched</code> array.</p><p>Now let's look at the final touch handler method, <code class="literal">ccTouchEnded</code>.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id378" class="indexterm"/>
<a id="id379" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) ccTouchEnded:(UITouch *)touch withEvent:(UIEvent *)event {
    // Taps are handled here.    
    [self touchHelper:touch withEvent:event];
}</pre></div><p>What's going on here? The checks that we needed in the <code class="literal">ccTouchEnded</code> method are exactly the same checks that we used in the <code class="literal">ccTouchMoved</code> method, so we can call the same code, rather than copying all the code into both <a id="id380" class="indexterm"/>methods; this is why we created the <code class="literal">touchHelper</code> method. Looking at both the <a id="id381" class="indexterm"/>
<a id="id382" class="indexterm"/>
<code class="literal">ccTouchMoved</code> and <a id="id383" class="indexterm"/>
<a id="id384" class="indexterm"/>
<code class="literal">ccTouchEnded</code> methods together, we have the flexibility to be able to swipe or tap on gems to select them. <code class="literal">ccTouchMoved</code> is only called when the touch moves (that is, a swipe), so a simple tap will not activate the code in that method. The <code class="literal">ccTouchEnded</code> method is only called when the touch ends (that is, the finger is lifted off the screen). By triggering the same code in both places, we can cover both styles of player interaction. </p></div><div class="section" title="Moving gems"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec23"/>Moving gems</h2></div></div></div><p>Let's briefly look at the methods we use to handle <a id="id385" class="indexterm"/>
<a id="id386" class="indexterm"/>gem movements:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id387" class="indexterm"/>
<a id="id388" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void)swapGem:(MAGem*)aGem withGem:(MAGem*)bGem {
    NSInteger tempRowNumA;
    NSInteger tempColNumA;
    
    // Stop the highlight
    [aGem stopHighlightGem];
    [bGem stopHighlightGem];
    
    // Grab the temp location of aGem
    tempRowNumA = [aGem rowNum];
    tempColNumA = [aGem colNum];

    // Set the aGem to the values from bGem
    [aGem setRowNum:[bGem rowNum]];
    [aGem setColNum:[bGem colNum]];
    
    // Set the bGem to the values from the aGem temp vars
    [bGem setRowNum:tempRowNumA];
    [bGem setColNum:tempColNumA];
    // Move the gems
    [self moveToNewSlotForGem:aGem];
    [self moveToNewSlotForGem:bGem];
}</pre></div><p>The <a id="id389" class="indexterm"/>
<a id="id390" class="indexterm"/>
<code class="literal">swapGem</code> method is very basic. We use temporary variables to assist with swapping the <code class="literal">rowNum</code> and <code class="literal">colNum</code> values of the two gems <a id="id391" class="indexterm"/>passed to the method. After they are changed, we call the <a id="id392" class="indexterm"/>
<a id="id393" class="indexterm"/>
<code class="literal">moveToNewSlotForGem</code> method on both gems.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id394" class="indexterm"/>
<a id="id395" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) moveToNewSlotForGem:(MAGem*)aGem {
    // Set the gem's state to moving
    [aGem setGemState:kGemMoving];

    // Move the gem, play sound, let it rest
    CCMoveTo *moveIt = [CCMoveTo
            actionWithDuration:0.2
            position:[self positionForRow:[aGem rowNum]
                                andColumn:[aGem colNum]]];
    CCCallFunc *playSound = [CCCallFunc
            actionWithTarget:self
                    selector:@selector(playSwoosh)];
    CCCallFuncND *gemAtRest = [CCCallFuncND
            actionWithTarget:self
            selector:@selector(gemIsAtRest:) data:aGem];
    [aGem runAction:[CCSequence actions:moveIt,
                     playSound, gemAtRest, nil]];
}</pre></div><p>The <a id="id396" class="indexterm"/>
<a id="id397" class="indexterm"/>
<code class="literal">moveToNewSlotForGem</code> method first sets the gem's state to <code class="literal">kGemMoving</code>, so this gem will not take part in any matching logic while in motion. Then, we use a <code class="literal">CCMoveTo</code> action to move the gem where it should be (based on the new <code class="literal">rowNum</code> and <a id="id398" class="indexterm"/>
<a id="id399" class="indexterm"/>
<code class="literal">colNum</code> variables we just assigned to it), play a sound effect, and then call the <code class="literal">gemIsAtRest</code> <a id="id400" class="indexterm"/>
<a id="id401" class="indexterm"/>method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id402" class="indexterm"/>
<a id="id403" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) gemIsAtRest:(MAGem*)aGem {
    // Reset the gem's state to Idle
    [aGem setGemState:kGemIdle];
    
    // Identify that we need to check for matches
    checkMatches = YES;
}</pre></div><p>The <code class="literal">gemIsAtRest</code> method resets the gem's state, so it is <a id="id404" class="indexterm"/>now <code class="literal">kGemIdle</code>. This means it will now be allowed to participate in any matching checks that are performed on the board. We also set the <code class="literal">checkMatches</code> variable to <code class="literal">YES</code>. <a id="id405" class="indexterm"/>This is the trigger we use to identify that the board is now stable enough to check for a potential match.</p></div></div>
<div class="section" title="Checking moves"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec22"/>Checking moves</h1></div></div></div><p>We are close to completing a basic Match 3 game. <a id="id406" class="indexterm"/>Let's look at a couple more methods we <a id="id407" class="indexterm"/>need to finish it.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id408" class="indexterm"/>
<a id="id409" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) checkMove {
    // A move was made, so check for potential matches
    [self checkForMatchesOfType:kGemIdle];

    // Did we have any matches?
    if ([gemMatches count] &gt; 0) {
        // Iterate through all matched gems
        for (MAGem *aGem in gemMatches) {
            // If the gem is not already in scoring state
            if (aGem.gemState != kGemScoring) {
                // Trigger the scoring &amp; removal of gem
                [self animateGemRemoval:aGem]; 
            }
        }
        // All matches processed.  Clear the array.
        [gemMatches removeAllObjects];
    // If we have any selected/touched gems, we must
    // have made an incorrect move
    } else if ([gemsTouched count] &gt; 0) {
        // If there was only one gem, grab it
        MAGem *aGem = [gemsTouched objectAtIndex:0];
        
        // If we had 2 gems in the touched array
        if ([gemsTouched count] == 2) {
            // Grab the second gem
            MAGem *bGem = [gemsTouched objectAtIndex:1];
            // Swap them back to their original slots
            [self swapGem:aGem withGem:bGem];
        } else {
            // If we only had 1 gem, stop highlighting it
            [aGem stopHighlightGem];
        }
    }
    // Touches were processed.  Clear the touched array.
    [gemsTouched removeAllObjects];
}</pre></div><p>By now, you should be familiar enough with the way the gem arrays are handled in this code, and so you should find this method pretty simple. First, we call the <code class="literal">checkForMatchesOfType</code> method to <a id="id410" class="indexterm"/>
<a id="id411" class="indexterm"/>populate the <code class="literal">gemMatches</code> array with matching gems (if any are found). If we find any matches, all matching gems are sent to the <code class="literal">animateGemRemoval</code> method. Once that loop is complete, we remove all gems from the <code class="literal">gemMatches</code> array. If we have any gems in the <a id="id412" class="indexterm"/>
<a id="id413" class="indexterm"/>
<code class="literal">gemsTouched</code> array, we call <code class="literal">stopHighlightGem</code> on them. If there were two gems in <a id="id414" class="indexterm"/>that array, it means we had a move that did not make a match, so we call <code class="literal">swapGem</code> to move them back to where they started from. After that has been resolved, <a id="id415" class="indexterm"/>we clear the <code class="literal">gemsTouched</code> array. By the end of this method, the two temporary arrays are empty and all matches have been resolved.</p><div class="section" title="Removing gems"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec24"/>Removing gems</h2></div></div></div><p>Now let's look at the methods used to remove <a id="id416" class="indexterm"/>gems <a id="id417" class="indexterm"/>from the board:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id418" class="indexterm"/>
<a id="id419" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) animateGemRemoval:(MAGem*)aGem {
    // We swap the image to "boom", and animate it out
    CCCallFuncND *changeImage = [CCCallFuncND
            actionWithTarget:self
            selector:@selector(changeGemFace:) data:aGem];
    CCCallFunc *updateScore = [CCCallFunc
            actionWithTarget:self
            selector:@selector(incrementScore)];
    CCCallFunc *addTime = [CCCallFunc
            actionWithTarget:self
            selector:@selector(addTimeToTimer)];
    CCMoveBy *moveUp = [CCMoveBy actionWithDuration:0.3
            position:ccp(0,5)];
    CCFadeOut *fade = [CCFadeOut actionWithDuration:0.2];
    CCCallFuncND *removeGem = [CCCallFuncND
            actionWithTarget:self
            selector:@selector(removeGem:) data:aGem];
    
    [aGem runAction:[CCSequence actions:changeImage,
            updateScore, addTime, moveUp, fade,
            removeGem, nil]];
}</pre></div><div class="informalexample"><pre class="programlisting">-(void) changeGemFace:(MAGem*)aGem {
    // Swap the gem texture to the "boom" image
    [aGem setDisplayFrame:[[CCSpriteFrameCache
                        sharedSpriteFrameCache]
                        spriteFrameByName:@"boom.png"]];
}</pre></div><div class="informalexample"><pre class="programlisting">-(void) removeGem:(MAGem*)aGem {
    // Clean up after ourselves and get rid of this gem
    [gemsInPlay removeObject:aGem];
    [aGem setGemState:kGemScoring];
    [self fillHolesFromGem:aGem];
    [aGem removeFromParentAndCleanup:YES];
    checkMatches = YES;
} </pre></div><p>These three methods, taken together, handle everything we need to neatly animate a matched gem. <a id="id420" class="indexterm"/>
<a id="id421" class="indexterm"/>
<code class="literal">changeGemFace</code> uses a method we haven't seen before. Since all of our images are part of the same <code class="literal">CCSpriteBatchNode</code>, we are able to use the <a id="id422" class="indexterm"/>
<a id="id423" class="indexterm"/>
<code class="literal">setDisplayFrame</code> method to change the image of the sprite on the fly. Here, we replace the gem's image with the "boom" image. We move it up the screen and fade it out, so it disappears from the board neatly. (We also update the score and <a id="id424" class="indexterm"/>add time to the timer, but we won't be discussing those features of the game here. If you don't use a score or a timer, you can easily remove those <a id="id425" class="indexterm"/>actions.) There is one important method called from the <a id="id426" class="indexterm"/>
<a id="id427" class="indexterm"/>
<code class="literal">removeGem</code> method, <code class="literal">fillHolesFromGem</code>. Let's see what it does:</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id428" class="indexterm"/>
<a id="id429" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) fillHolesFromGem:(MAGem*)aGem {
    // aGem passed is one that is being scored.
    // We know we will need to fill in the holes, so 
    // this method takes care of that.
    
    for (MAGem *thisGem in gemsInPlay) {
        // If thisGem is in the same column and ABOVE
        // the current matching gem, we reset the
        // position down, so we can fill the hole
        if (aGem.colNum == thisGem.colNum &amp;&amp; 
            aGem.rowNum &lt; thisGem.rowNum) {
            // Set thisGem to drop down one row
            [thisGem setRowNum:thisGem.rowNum - 1];            
            [self moveToNewSlotForGem:thisGem];
        }
    }

    
    // Call the smart fill method.
    [self smartFill];
}</pre></div><p>This method looks for any gems that are in the same column as the passed gem, <code class="literal">aGem</code>. We iterate through the <code class="literal">gemsInPlay</code> array, looking for any gems in a row above <code class="literal">aGem</code>, reset their <code class="literal">rowNum</code> variable to one row lower, and then trigger the <code class="literal">moveToNewSlotForGem</code> <a id="id430" class="indexterm"/>
<a id="id431" class="indexterm"/>method. This will effectively <a id="id432" class="indexterm"/>fill in any gaps in the board. It doesn't add any new gems to the board, but collapses them all downward so any remaining <a id="id433" class="indexterm"/>holes are at the top of the board. (The <code class="literal">smartFill</code> method is covered in the <span class="emphasis"><em>Predictive logic</em></span> section of this chapter.)</p></div><div class="section" title="The update method"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec25"/>The update method</h2></div></div></div><p>We now turn our attention to the <a id="id434" class="indexterm"/>
<a id="id435" class="indexterm"/>
<code class="literal">update</code> method, which will tie it all <a id="id436" class="indexterm"/>together.</p><p>
<span class="strong"><strong>Filename</strong></span>: <code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) update:(ccTime)dt {
    
    gemsMoving = NO;
    
    // See if we have any gems currently moving
    for (MAGem *aGem in gemsInPlay) {
        if (aGem.gemState == kGemMoving) {
            gemsMoving = YES;
            break;
        }
    }
    
    // If we flagged that we need to check the board
    if (checkMatches) {
        [self checkMove];
        [self checkMovesRemaining];
        checkMatches = NO;
    }
    
    // Too few gems left.  Let's fill it up.
    // This will avoid any holes if our smartFill left
    // gaps, which is common on 4 and 5 gem matches.
    if ([gemsInPlay count] &lt; boardRows * boardColumns &amp;&amp;
        gemsMoving == NO) {
        [self addGemsToFillBoard];
    }
    
    // Update the timer value &amp; display

    // Game Over / Time's Up

    }
} </pre></div><p>Now we tie together a couple of loose ends in the code. We start with the <code class="literal">gemsMoving</code> <code class="literal">BOOL</code>, which we used in the touch handler. We set the value in the <code class="literal">update</code> method by iterating through all the gems to determine whether there are any gems in the state <code class="literal">kGemMoving</code>. If any gems are moving, <code class="literal">gemsMoving</code> is set to <code class="literal">YES</code>.</p><p>The <code class="literal">BOOL</code> <code class="literal">checkMatches</code> is next. If this variable has been set to <code class="literal">YES</code>, we run the <code class="literal">checkMove</code> method. <a id="id437" class="indexterm"/>
<a id="id438" class="indexterm"/>As we saw earlier, this method takes care of handling all the matching logic and removal of matched gems. <a id="id439" class="indexterm"/>At the end of this <span class="emphasis"><em>if</em></span> statement, we reset the <a id="id440" class="indexterm"/>
<a id="id441" class="indexterm"/>
<code class="literal">checkMatches</code> variable to <code class="literal">NO</code> to indicate the matches are resolved. (We will discuss <code class="literal">checkMovesRemaining</code> in the <a id="id442" class="indexterm"/>next section).</p><p>The final portion of the core <code class="literal">update</code> method checks to see if we don't have enough gems on the board and if nothing is moving. If both of these conditions are true, we call the <code class="literal">addGemsToFillBoard</code> <a id="id443" class="indexterm"/>
<a id="id444" class="indexterm"/>method to fill in any missing gems. (There are also the timer update and the game-over checks at the end. We will not be discussing those here, so the code details have been omitted. Please see the accompanying code for those portions of the update method.)</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id445" class="indexterm"/>
<a id="id446" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) addGemsToFillBoard {
    // Loop through all positions, see if we have a gem
    for (int i = 1; i &lt;= boardRows; i++) {
        for (int j = 1; j &lt;= boardColumns; j++) {
            
            BOOL missing = YES;

            // Look for a missing gem in each slot
            for (MAGem *aGem in gemsInPlay) {
                if (aGem.rowNum == i &amp;&amp; aGem.colNum == j
                    &amp;&amp; aGem.gemState != kGemScoring) {
                    // Found a gem, not missing
                    missing = NO;
                }
            }
            // We didn't find anything in this slot.
            if (missing) {
                [self addGemForRow:i andColumn:j
                            ofType:kGemAnyType];
            }
        }
    }
    // We possibly changed the board, trigger match check
    checkMatches = YES;
}</pre></div><p>We iterate through all the spaces on the board, and then, through all the gems in the <code class="literal">gemsInPlay</code> array. If we find a gem in that slot, we <a id="id447" class="indexterm"/>set the <code class="literal">missing</code> variable to <code class="literal">NO</code>. If we do not find a gem in a <a id="id448" class="indexterm"/>given slot (that is, <code class="literal">missing = YES</code>), we call the <code class="literal">addGemForRow</code> method to add a new random gem to fill in that slot.</p></div></div>
<div class="section" title="Predictive logic"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec23"/>Predictive logic</h1></div></div></div><p>So far, we have mostly covered straightforward code that takes care of basic game mechanics. There is one problem, though. The game can produce a board that is impossible to make a move on. Worse, we have no way of knowing that there are no more moves remaining. We aim to correct that deficiency now, <a id="id449" class="indexterm"/>in a rather dense method called <a id="id450" class="indexterm"/>
<a id="id451" class="indexterm"/>
<code class="literal">checkMovesRemaining</code>. First, we should cover the basic concept of how this is accomplished.</p><p>If you recall, the <a id="id452" class="indexterm"/>
<a id="id453" class="indexterm"/>
<code class="literal">checkForMatchesOfType</code> method we reviewed earlier did a good job of finding any actual matches on the board. We could code this predictive method in that style, but it quickly gets confusing since you need to be able to determine matches up to five gems in a row to get an accurate count of moves remaining. Here, we take another approach by writing the <code class="literal">gemType</code> values into a "C-style" array, so we can easily get a single view of the whole board without massive nested loops.</p><p>The challenge is determining all the possible ways a player can legally move a gem and how the board would look after the move. We iterate through all positions from the bottom left corner, and we will test what happens if the gem is moved to the right, and also what happens if the gem is moved up. Even though the player can also move left and down, those will already be taken care of because swapping one gem downwards is the same as swapping the one below it upwards.</p><p>We start our test scenarios by creating a "letter map" of the board area, with the letter "a" representing the board slot being evaluated, like so:</p><div class="mediaobject"><img src="graphics/9007_02_02.jpg" alt="Predictive logic"/></div><p>We will use this letter map and assign variables to represent the value at each specified position in the array. For example, the variable <code class="literal">f</code> is at location <code class="literal">row+1</code> and <code class="literal">col+1</code>, relative to the letter <span class="emphasis"><em>a</em></span>. From there, we will test a "deformed" version of the map, first with the <span class="emphasis"><em>a </em></span>and <span class="emphasis"><em>b</em></span> positions swapped, and then by testing <span class="emphasis"><em>a</em></span> and <span class="emphasis"><em>e</em></span> swapped. From there, we count up all the matches that can be made with a single move, and we set that as the <code class="literal">movesRemaining</code> <a id="id454" class="indexterm"/>
<a id="id455" class="indexterm"/>variable. (This code is pretty long, <a id="id456" class="indexterm"/>but there's no good way to break it up here.)</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id457" class="indexterm"/>
<a id="id458" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(void) checkMovesRemaining {

    NSInteger matchesFound = 0;
    NSInteger gemsInAction = 0;
    
    // Create a temporary C-style array
    NSInteger map[12][12];
    
    // Make sure it is cleared
    for (int i = 1; i&lt; 12; i++) {
        for (int j = 1; j &lt; 12; j++) {
            map[i][j] = 0;
        }
    }
    
    // Load all gem types into it
    for (MAGem *aGem in gemsInPlay) {
        if (aGem.gemState != kGemIdle) {
            // If gem is moving or scoring, fill with zero
            map[aGem.rowNum][aGem.colNum] = 0;
            gemsInAction++;
        } else {            
            map[aGem.rowNum][aGem.colNum] = aGem.gemType;
        }
    }
    
    // Loop through all slots on the board
    for (int row = 1; row &lt;= boardRows; row++) {
        for (int col = 1; col &lt;= boardColumns; col++) {

            // Grid variables look like:
            //
            //        j
            //        h i
            //    k l e f g 
            //    m n a b c d
            //        o p
            //        q r
            
            // where "a" is the root gem we're testing
            // The swaps we test are a/b and a/e
            // So we need to identify all possible matches
            // that those swaps could cause
            GemType a = map[row][col];
            GemType b = map[row][col+1];
            GemType c = map[row][col+2];
            GemType d = map[row][col+3];
            GemType e = map[row+1][col];
            GemType f = map[row+1][col+1];
            GemType g = map[row+1][col+2];
            GemType h = map[row+2][col];
            GemType i = map[row+2][col+1];
            GemType j = map[row+3][col];
            GemType k = map[row+1][col-2];
            GemType l = map[row+1][col-1];
            GemType m = map[row][col-2];
            GemType n = map[row][col-1];
            GemType o = map[row-1][col];
            GemType p = map[row-1][col+1];
            GemType q = map[row-2][col];
            GemType r = map[row-2][col+1];
            
            // deform the board-swap of a and b, test
            GemType newA = b;
            GemType newB = a;
            
            matchesFound = matchesFound +
                [self findMatcheswithA:h andB:e
                            andC:newA andD:o andE:q];
            matchesFound = matchesFound + 
                [self findMatcheswithA:i andB:f
                            andC:newB andD:p andE:r];
            matchesFound = matchesFound +
                [self findMatcheswithA:m andB:n
                            andC:newA andD:0 andE:0];
            matchesFound = matchesFound +
                [self findMatcheswithA:newB andB:c
                            andC:d andD:0 andE:0];

            // Now we swap a and e, then test
            newA = e;
            GemType newE = a;
            matchesFound = matchesFound +
                [self findMatcheswithA:m andB:n
                            andC:newA andD:b andE:c];
            matchesFound = matchesFound +
                [self findMatcheswithA:k andB:l
                            andC:newE andD:f andE:g];
            matchesFound = matchesFound +
                [self findMatcheswithA:newA andB:o
                            andC:q andD:0 andE:0];
            matchesFound = matchesFound +
                [self findMatcheswithA:newE andB:h
                            andC:j andD:0 andE:0];
        }
    }

    // See if we have gems in motion on the board
    // Set the BOOL so other methods don't try to fix 
    // any "problems" with a moving board
    gemsMoving = (gemsInAction &gt; 0);
    
    movesRemaining = matchesFound;
}</pre></div><p>To keep the positioning straight, you can see that we have put in a textual version of the letter map into the code. This is a convenience, since trying to read the patterns from the code itself is rather tiresome and challenging. When we look at possible matches after deforming the board, there are four possible ways <a id="id459" class="indexterm"/>we can match for each of the deformations, as illustrated here:</p><div class="mediaobject"><img src="graphics/9007_02_03.jpg" alt="Predictive logic"/></div><p>To assist with this checking, we add a helper method.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id460" class="indexterm"/>
<a id="id461" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting">-(NSInteger) findMatcheswithA:(NSInteger)a
                         andB:(NSInteger)b
                         andC:(NSInteger)c
                         andD:(NSInteger)d
                         andE:(NSInteger)e {
    NSInteger matches = 0;
    
    if (a == b &amp;&amp; b == c &amp;&amp; c == d &amp;&amp; d == e &amp;&amp;
                            a + b + c + d + e != 0) {
        // 5 match
        matches++;        
    } else if (a == b &amp;&amp; b == c &amp;&amp; c == d  &amp;&amp;
                            a + b + c + d != 0) {
        // 4 match (left)
        matches++;
    } else if (b == c &amp;&amp; c == d &amp;&amp; d == e &amp;&amp;
                            b + c + d + e != 0) {
        // 4 match (right)
        matches++;
    } else if (a == b &amp;&amp; b == c &amp;&amp; a + b + c != 0) {
        // 3 match (left)
        matches++;
    } else if (b == c &amp;&amp; c == d &amp;&amp; b + c + d != 0) {
        // 3 match (mid)
        matches++;
    } else if (c == d &amp;&amp; d == e &amp;&amp; c + d + e != 0) {
        // 3 match (right)
        matches++;
    }
    return matches;
}</pre></div><p>Any combination of five gems could result in a match of three, four, or five in a row. We pass five gems in a row to this method, and it checks for five in a row first, then four in a row, and then three in a row. It is an <span class="emphasis"><em>if…else-if</em></span> structure because a five-in-a-row match would also trigger as four-in-a-row and three-in-a-row <a id="id462" class="indexterm"/>matches, so we let it act as a waterfall to avoid over-counting the matches. You will also notice that we are making sure that one of the variables is not <code class="literal">0</code>. As we saw in the <code class="literal">checkMovesRemaining</code> method itself, we only record the gem type for gems that are in the <code class="literal">kGemIdle</code> state. All other gem states (<code class="literal">kGemMoving</code>, <code class="literal">kGemScoring</code>, and <code class="literal">kGemNew</code>), as well as positions off the board, will be represented as <code class="literal">0</code> in the map.</p></div>
<div class="section" title="Artificial randomness"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec24"/>Artificial randomness</h1></div></div></div><p>So now, we can evaluate the board to see all potential moves. Then what? We could put in a trigger in the <code class="literal">update</code> method to flash a "no more moves" message and cause game over, but that's no fun, is it? Our goal is to make a game that will keep going forever. This is where we are finally ready to find out details of the <code class="literal">smartFill</code> method we saw in the code earlier. This is a really long method, listed in its entirety. It is a critical method to the process, so please bear with us.</p><p>
<span class="strong"><strong>Filename</strong></span>: <a id="id463" class="indexterm"/>
<a id="id464" class="indexterm"/>
<code class="literal">MAPlayfieldLayer.m</code>
</p><div class="informalexample"><pre class="programlisting"> -(void) smartFill {
    // In case we were scheduled, unschedule it first
    [self unschedule:@selector(smartFill)];
    
    // If anything is moving, we don't want to fill yet
    if (gemsMoving) {
        // We reschedule so we retry when gems not moving
        [self schedule:@selector(smartFill) interval:0.05];
        return;
    }
    
    // If we have plenty of matches, use a random fill
    if (movesRemaining &gt;= 6) {
        [self addGemsToFillBoard];
        return;
    }
    
    // Create a temporary C-style array
    // We make it bigger than the playfield on purpose
    // This way we can evaluate past the edges
    NSInteger map[12][12];
    
    // Make sure it is cleared
    for (int i = 1; i&lt; boardRows + 5; i++) {
        for (int j = 1; j &lt; boardColumns + 5; j++) {
            if (i &gt; boardRows || j &gt; boardColumns) {
                // If row or column is bigger than board,
                // assign a -1 value
                map[i][j] = -1;
            } else {
                // If it is on the board, zero it
                map[i][j] = 0;
            }
        }
    }
    
    // Load all gem types into it
    for (MAGem *aGem in gemsInPlay) {
        // We don't want to include scoring gems
        if (aGem.gemState == kGemScoring) {
            map[aGem.rowNum][aGem.colNum] = 0;
        } else {
            // Assign the gemType to the array slot
            map[aGem.rowNum][aGem.colNum] = aGem.gemType;
        }
    }
    
    // Parse through the map, looking for zeroes
    for (int row = 1; row &lt;= boardRows; row++) {
        for (int col = 1; col &lt;= boardColumns; col++) {
            
            // We use "intelligent randomness" to fill 
            // holes when close to running out of matches
            
            // Grid variables look like:
            //        
            //        h
            //        e   g 
            //      n a b c 
            //      s o p t
            //    
            
            // where "a" is the root gem we're testing
            
            GemType a = map[row][col];
            GemType b = map[row][col+1];
            GemType c = map[row][col+2];
            GemType e = map[row+1][col];
            GemType g = map[row+1][col+2];
            GemType h = map[row+2][col];
            GemType n = map[row][col-1];
            GemType o = map[row-1][col];
            GemType p = map[row-1][col+1];
            GemType s = map[row-1][col-1];
            GemType t = map[row-1][col+2];
            
            // Vertical hole, 3 high
            if (a == 0 &amp;&amp; e == 0 &amp;&amp; h == 0) {
                if ((int)p &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:p];
                    [self addGemForRow:row+1 andColumn:col
                                ofType:p];
                    [self addGemForRow:row+2 andColumn:col
                                ofType:kGemAnyType];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                
                if ((int)s &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:s];
                    [self addGemForRow:row+1 andColumn:col
                                ofType:s];
                    [self addGemForRow:row+2 andColumn:col
                                ofType:kGemAnyType];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                
                if ((int)n &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:kGemAnyType];
                    [self addGemForRow:row+1 andColumn:col
                                ofType:n];
                    [self addGemForRow:row+2 andColumn:col
                                ofType:n];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                
                if ((int)b &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:kGemAnyType];
                    [self addGemForRow:row+1 andColumn:col
                                ofType:b];
                    [self addGemForRow:row+2 andColumn:col
                                ofType:b];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
            }
            
            
            // Horizontal hole, 3 high
            if (a == 0 &amp;&amp; b == 0 &amp;&amp; c == 0) {
                if ((int)o &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:kGemAnyType];
                    [self addGemForRow:row andColumn:col+1
                                ofType:o];
                    [self addGemForRow:row andColumn:col+2
                                ofType:o];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                
                if ((int)t &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:t];
                    [self addGemForRow:row andColumn:col+1
                                ofType:t];
                    [self addGemForRow:row andColumn:col+2
                                ofType:kGemAnyType];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                
                if ((int)e &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:kGemAnyType];
                    [self addGemForRow:row andColumn:col+1
                                ofType:e];
                    [self addGemForRow:row andColumn:col+2
                                ofType:e];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
                if ((int)g &gt;= 1) {
                    [self addGemForRow:row andColumn:col
                                ofType:g];
                    [self addGemForRow:row andColumn:col+1
                                ofType:g];
                    [self addGemForRow:row andColumn:col+2
                                ofType:kGemAnyType];
                    [self checkMovesRemaining];
                    [self smartFill];
                    return;
                }
            }
        }
    }
}</pre></div><p>This structure of code should look familiar to you, as it uses the same design structure as the <a id="id465" class="indexterm"/>
<a id="id466" class="indexterm"/>
<code class="literal">checkMovesRemaining</code> method. It uses the same "map" array concept, albeit with fewer variables needed for this method. There are two subtle differences in the top portion of the code. The first is that if the <a id="id467" class="indexterm"/>
<a id="id468" class="indexterm"/>
<code class="literal">gemsMoving</code> variable is <code class="literal">YES</code>, we schedule the <code class="literal">smartFill</code> method with an interval of <code class="literal">0.05</code> and immediately exit the method (with the <code class="literal">return</code> statement). The first thing the method does, in fact, is unschedule itself if it was already scheduled. This causes the <a id="id469" class="indexterm"/>
<a id="id470" class="indexterm"/>
<code class="literal">smartFill</code> method to wait until the board has stabilized with nothing moving. This allows us to always check a static board without worrying about the difference between an empty slot and a slot with a moving gem.</p><p>The second interesting portion of the top of the method is the check for whether <code class="literal">movesRemaining</code> is greater than or equal to six. If that is true, we have plenty of moves remaining, so the <a id="id471" class="indexterm"/>
<a id="id472" class="indexterm"/>
<code class="literal">addGemsToFillBoard</code> method we saw earlier will be called, which will generate random gems to fill in the board. Why six? Ideally, we would want to be able to kick in this <code class="literal">smartFill</code> method only when we are down to one or two moves remaining, but since a single move has the potential of eliminating several other moves (by shifting the board, or by using gems that were also potentially part of another match), testing showed six is a safe number to use to avoid a deadlocked board.</p><p>We also have one difference in the way the map is populated. In this case, we check if any position is outside of the actual board area and assign a value of <code class="literal">-1</code>. If it is a "hole in the board", it will be assigned <code class="literal">0</code>. In this way, we can make sure we are only filling in the board itself, and not areas outside the board. (These external <code class="literal">-1</code> values are sometimes called <a id="id473" class="indexterm"/>
<a id="id474" class="indexterm"/>
<span class="strong"><strong>sentinel values</strong></span> because they guard the edges of the board.)</p><p>Here is our fill-in map for the <code class="literal">smartFill</code> method:</p><div class="mediaobject"><img src="graphics/9007_02_04.jpg" alt="Artificial randomness"/></div><p>The goal is to fill in the holes in the board with something that will be usable in making a match. We do this by copying a nearby gem, so we can guarantee a match. However, depending on where on the board the hole is, we cannot always guarantee there will be a single gem we can always clone (relative to the hole), so we iterate through a few likely possibilities until we find one and then call <code class="literal">smartFill</code> again to take care of any further holes. You will notice that, in all situations, we clone two gems and leave the third gem to be set as <code class="literal">kGemAnyType</code>—randomized. This gives us some level of randomness that adds spice to the situation, even as we spoon feed the player a viable board.</p><p>This <a id="id475" class="indexterm"/>
<a id="id476" class="indexterm"/>
<code class="literal">smartFill</code> method does not do a complete job by itself; it can leave small 1- or 2-gem holes if there is a four-in-a-row or five-in-a-row match. The remaining holes will be filled in by the call to the <a id="id477" class="indexterm"/>
<a id="id478" class="indexterm"/>
<code class="literal">addGemsToFillBoard</code> method in the update loop. This is by design, since we did not want to add even more code to handle artificial randomness for 4- and 5-gem holes. The added calculations required are not necessary to fulfill our goal of keeping the game going. As a final note, if you want to remove all of the "artificial randomness", you only have to comment out the call to the <code class="literal">smartFill</code> method at the end of the <code class="literal">fillHolesFromGem</code> method<a id="id479" class="indexterm"/>
<a id="id480" class="indexterm"/>. Of course, then you will need to add a "no more moves" handler to react to that situation.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec25"/>Summary</h1></div></div></div><p>We have covered a lot of ground in a short period of time, and we've covered more than one approach to some of the challenges this game presents to us. We have learned how to control a grid of gems with the appearance of gravity (in other words, filling in holes), we have learned how to match by using nested <span class="emphasis"><em>for</em></span> loops. We have also learned how to check for matches and how to check for predictive matches using a "C-style" array without forcing ourselves to use C-style arrays throughout the code. Finally, we addressed the idea of artificial randomness to give the player an ongoing game experience without risking a "no more moves" situation.</p><p>The code bundle for this chapter also includes both scoring and a progress timer, which we saw traces of but didn't really discuss here. The implementation is very simple, so we leave it to you, the reader, to explore these features on your own. The example "tests" contained within the sample projects included with the cocos2d download are a great resource for lesser-known classes, such as <code class="literal">CCProgressTimer</code>.</p><p>In the next chapter, we will tackle a classic mole-whacking game, and learn how to trick the player's eye.</p></div></body></html>