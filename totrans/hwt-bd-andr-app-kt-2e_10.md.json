["```swift\ntestImplementation 'junit:junit:4.13.2'\n```", "```swift\nclass MyClass {\n    fun factorial(n: Int): Int {\n        return IntArray(n) {\n            it+1\n        }.reduce { acc, i ->\n            acc * i\n        }\n    }\n}\n```", "```swift\nimport org.junit.Assert.assertEquals\nimport org.junit.Test\nclass MyClassTest {\n    private val myClass = MyClass()\n    @Test\n    fun computesFactorial() {\n        val n = 3\n        val result = myClass.factorial(n)\n        assertEquals(6, result)\n    }\n}\n```", "```swift\n@RunWith(Parameterized::class)\nclass MyClassTest(\n    private val input: Int,\n    private val expected: Int\n) {\n    companion object {\n        @Parameterized.Parameters\n        @JvmStatic\n        fun getData(): Collection<Array<Int>> = listOf(\n            arrayOf(0, 1),\n            arrayOf(1, 1),\n            arrayOf(2, 2),\n            arrayOf(3, 6),\n            arrayOf(4, 24),\n            arrayOf(5, 120)\n        )\n    }\n    private val myClass = MyClass()\n    @Test\n    fun computesFactorial() {\n        val result = myClass.factorial(input)\n        assertEquals(expected, result)\n    }\n}\n```", "```swift\nfun factorial(n: Int): Int {\n        return IntArray(n) {\n            it + 1\n        }.fold(1, { acc, i -> acc * i })\n    }\n```", "```swift\nclass MyClassTest2 {\n    private val myClass = MyClass()\n    @Test(expected =\n        MyClass.FactorialNotFoundException::class)\n    fun computeNegatives() {\n        myClass.factorial(-10)\n    }\n}\n```", "```swift\nclass MyClass {\n    @Throws(FactorialNotFoundException::class)\n    fun factorial(n: Int): Int {\n        if (n < 0) {\n            throw FactorialNotFoundException\n        }\n        return IntArray(n) {\n            it + 1\n        }.fold(1, { acc, i -> acc * i })\n    }\n    object FactorialNotFoundException : Throwable()\n}\n```", "```swift\n@RunWith(Parameterized::class)\nclass MyClassTest(\n    private val input: Int,\n    private val expected: BigInteger\n) {\n    companion object {\n        @Parameterized.Parameters\n        @JvmStatic\n        fun getData(): Collection<Array<Any>> = listOf(\n            arrayOf(0, BigInteger.ONE),\n            arrayOf(1, BigInteger.ONE),\n            arrayOf(2, BigInteger.valueOf(2)),\n            arrayOf(3, BigInteger.valueOf(6)),\n            arrayOf(4, BigInteger.valueOf(24)),\n            arrayOf(5, BigInteger.valueOf(120)),\n            arrayOf(13, BigInteger(\"6227020800\")),\n            arrayOf(25, BigInteger(\n            \"15511210043330985984000000\"))\n        )\n    }\n    private val myClass = MyClass()\n    @Test\n    fun computesFactorial() {\n        val result = myClass.factorial(input)\n        assertEquals(expected, result)\n    }\n}\n```", "```swift\n    @Throws(FactorialNotFoundException::class)\n    fun factorial(n: Int): BigInteger {\n        if (n < 0) {\n            throw FactorialNotFoundException\n        }\n        return IntArray(n) {\n            it + 1\n        }.fold(BigInteger.ONE, { acc, i -> acc *\n            i.toBigInteger() })\n    }\n```", "```swift\n    @Throws(FactorialNotFoundException::class)\n    fun factorial(n: Int): BigInteger {\n        if (n < 0) {\n            throw FactorialNotFoundException\n        }\n        var result = BigInteger.ONE\n        for (i in 1..n){\n            result = result.times(i.toBigInteger())\n        }\n        return result\n    }\n```", "```swift\n    companion object {\n        var result: BigInteger = BigInteger.ONE\n    }\n    @Throws(FactorialNotFoundException::class)\n    fun factorial(n: Int): BigInteger {\n        if (n < 0) {\n            throw FactorialNotFoundException\n        }\n        for (i in 1..n) {\n            result = result.times(i.toBigInteger())\n        }\n        return result\n    }\n```", "```swift\n    @Before\n    fun setUp(){\n        MyClass.result = BigInteger.ONE\n    }\n    @After\n    fun tearDown(){\n        MyClass.result = BigInteger.ONE\n    }\n    @Test\n    fun computesFactorial() {\n        val result = myClass.factorial(input)\n        assertEquals(expected, result)\n    }\n```", "```swift\nclass ResultRule : TestRule {\n    override fun apply(\n        base: Statement,\n        description: Description?\n    ): Statement? {\n        return object : Statement() {\n            @Throws(Throwable::class)\n            override fun evaluate() {\n                MyClass.result = BigInteger.ONE\n                try {\n                    base.evaluate()\n                } finally {\n                    MyClass.result = BigInteger.ONE\n                }\n            }\n        }\n    }\n}\n```", "```swift\n    @JvmField\n    @Rule\n    val resultRule = ResultRule()\n    private val myClass = MyClass()\n    @Test\n    fun computesFactorial() {\n        val result = myClass.factorial(input)\n        assertEquals(expected, result)\n    }\n```", "```swift\ntestImplementation 'org.mockito:mockito-core:4.5.1'\n```", "```swift\nclass StringConcatenator(private val context: Context) {\n    fun concatenate(@StringRes stringRes1: Int,\n      @StringRes stringRes2: Int): String {\n          return context.getString(stringRes1).plus(context\n          .getString(stringRes2))\n    }\n}\n```", "```swift\nclass StringConcatenatorTest {\n    private val context = Mockito.mock(Context::class.java)\n    private val stringConcatenator =\n        StringConcatenator(context)\n    @Test\n    fun concatenate() {\n        val stringRes1 = 1\n        val stringRes2 = 2\n        val string1 = \"string1\"\n        val string2 = \"string2\"\n        Mockito.`when`(context.getString(stringRes1))\n            .thenReturn(string1)\n        Mockito.`when`(context.getString(stringRes2))\n            .thenReturn(string2)\n        val result =\n            stringConcatenator.concatenate(stringRes1,\n            stringRes2)\n        assertEquals(string1.plus(string2), result)\n    }\n}\n```", "```swift\nclass SpecificStringConcatenator(private val\nstringConcatenator: StringConcatenator) {\n    fun concatenateSpecificStrings(): String {\n        return stringConcatenator.concatenate(\n            R.string.string_1, R.string.string_2)\n    }\n}\n```", "```swift\nclass SpecificStringConcatenatorTest {\n    private val stringConcatenator = Mockito\n        .mock(StringConcatenator::class.java)\n    private val specificStringConcatenator =\n        SpecificStringConcatenator(stringConcatenator)\n    @Test\n    fun concatenateSpecificStrings() {\n        val expected = \"expected\"\n        Mockito.'when'(stringConcatenator.concatenate(\n            R.string.string_1, R.string.string_2))\n            .thenReturn(expected)\n        val result = specificStringConcatenator\n            .concatenateSpecificStrings()\n        assertEquals(expected, result)\n    }\n}\n```", "```swift\n    mock-maker-inline\n    ```", "```swift\nclass SpecificStringConcatenator(private val\nstringConcatenator: StringConcatenator) {\n    fun concatenateSpecificStrings(): String {\n        return stringConcatenator.concatenate(\n        R.string.string_1, R.string.string_2)\n    }\n    fun concatenateWithCallback(callback: Callback) {\n        callback.onStringReady(concatenateSpecificStrings())\n    }\n    interface Callback {\n        fun onStringReady(input: String)\n    }\n}\n```", "```swift\n    @Test\n    fun concatenateWithCallback() {\n        val expected = \"expected\"\n        Mockito.`when`(stringConcatenator.concatenate(\n            R.string.string_1, R.string.string_2))\n            .thenReturn(expected)\n        val callback = Mockito.mock(\n            SpecificStringConcatenator.Callback::class.java\n        )\n        specificStringConcatenator.concatenateWithCallback(\n            callback)\n        Mockito.verify(callback).onStringReady(expected)\n    }\n```", "```swift\n    @Test\n    fun concatenateWithCallback() {\n        val expected = \"expected\"\n        val spy = Mockito.spy(specificStringConcatenator)\n        Mockito.`when`(spy.concatenateSpecificStrings())\n            .thenReturn(expected)\n        val callback =\n         Mockito.mock(SpecificStringConcatenator.Callback::\n            class.java)\n        specificStringConcatenator.concatenateWithCallback(\n            callback)\n        Mockito.verify(callback).onStringReady(expected)\n    }\n```", "```swift\n@RunWith(MockitoJUnitRunner::class)\nclass SpecificStringConcatenatorTest {\n    @Mock\n    lateinit var stringConcatenator: StringConcatenator\n    @InjectMocks\n    lateinit var specificStringConcatenator:\n        SpecificStringConcatenator\n}\n```", "```swift\ntestImplementation \"org.mockito.kotlin:\nmockito-kotlin:4.1.0\"\n```", "```swift\nclass StringConcatenatorTest {\n    private val context = mock<Context>()\n    private val stringConcatenator =\n        StringConcatenator(context)\n    @Test\n    fun concatenate() {\n        val stringRes1 = 1\n        val stringRes2 = 2\n        val string1 = \"string1\"\n        val string2 = \"string2\"\n        whenever(context.getString(stringRes1)).thenReturn(\n            string1)\n        whenever(context.getString(stringRes2)).thenReturn(\n            string2)\n        val result = stringConcatenator.concatenate(\n            stringRes1, stringRes2)\n        assertEquals(string1.plus(string2), result)\n    }\n}\n```", "```swift\n@RunWith(MockitoJUnitRunner::class)\nclass SpecificStringConcatenatorTest {\n    @Mock\n    lateinit var stringConcatenator: StringConcatenator\n    @InjectMocks\n    lateinit var specificStringConcatenator:\n        SpecificStringConcatenator\n    @Test\n    fun concatenateSpecificStrings() {\n        val expected = \"expected\"\n        whenever(stringConcatenator.concatenate(\n            R.string.string_1, R.string.string_2))\n            .thenReturn(expected)\n        val result = specificStringConcatenator\n            .concatenateSpecificStrings()\n        assertEquals(expected, result)\n    }\n    @Test\n    fun concatenateWithCallback() {\n        val expected = \"expected\"\n        val spy = spy(specificStringConcatenator)\n        whenever(spy.concatenateSpecificStrings())\n            .thenReturn(expected)\n        val callback =\n            mock<SpecificStringConcatenator.Callback>()\n        specificStringConcatenator.concatenateWithCallback(\n            callback)\n        verify(callback).onStringReady(expected)\n    }\n}\n```", "```swift\nclass NumberAdder {\n    @Throws(InvalidNumberException::class)\n    fun sum(n: Int, callback: (BigInteger) -> Unit) {\n        if (n < 0) {\n            throw InvalidNumberException\n        }\n        var result = BigInteger.ZERO\n        for (i in 1..n){\n            result = result.plus(i.toBigInteger())\n        }\n        callback(result)\n    }\n    object InvalidNumberException : Throwable()\n}\n```", "```swift\n    testImplementation 'junit:junit:4.13.2'\n    testImplementation 'org.mockito:mockito-core:4.5.1'\n    testImplementation 'org.mockito.kotlin:\n    mockito-kotlin:4.1.0'\n    ```", "```swift\n    @RunWith(Parameterized::class)\n    class NumberAdderParameterTest(\n        private val input: Int,\n        private val expected: BigInteger\n    ) {\n        companion object {\n            @Parameterized.Parameters\n            @JvmStatic\n            fun getData(): List<Array<out Any>> = listOf(\n                arrayOf(0, BigInteger.ZERO),\n                arrayOf(1, BigInteger.ONE),\n                arrayOf(5, 15.toBigInteger()),\n                arrayOf(20, 210.toBigInteger()),\n                arrayOf(Int.MAX_VALUE, BigInteger(\n                \"2305843008139952128\"))\n            )\n        }\n        private val numberAdder = NumberAdder()\n        @Test\n        fun sum() {\n            val callback = mock<(BigInteger) -> Unit>()\n            numberAdder.sum(input, callback)\n            verify(callback).invoke(expected)\n        }\n    }\n    ```", "```swift\n    @RunWith(MockitoJUnitRunner::class)\n    class NumberAdderErrorHandlingTest {\n        @InjectMocks\n        lateinit var numberAdder: NumberAdder\n        @Test(expected =\n            NumberAdder.InvalidNumberException::class)\n        fun sum() {\n            val input = -1\n            val callback = mock<(BigInteger) -> Unit>()\n            numberAdder.sum(input, callback)\n        }\n    }\n    ```", "```swift\n    class NumberAdder {\n        @Throws(InvalidNumberException::class)\n        fun sum(n: Int, callback: (BigInteger) -> Unit) {\n            if (n < 0) {\n                throw InvalidNumberException\n            }\n            callback(n.toBigInteger()\n            .times((n.toBigInteger() +\n            1.toBigInteger())).divide(2.toBigInteger()))\n        }\n        object InvalidNumberException : Throwable()\n    }\n    ```", "```swift\nGiven I am not logged in\nAnd I open the application\nWhen I enter my credentials\nAnd click Login\nThen I see the Main screen\n```", "```swift\n    testImplementation 'org.robolectric:robolectric:4.9'\n    testImplementation 'androidx.test.ext:junit:1.1.4'\n```", "```swift\nclass FactorialGenerator {\n    @Throws(FactorialNotFoundException::class)\n    fun factorial(n: Int): BigInteger {\n        if (n < 0) {\n            throw FactorialNotFoundException\n        }\n        var result = BigInteger.ONE\n        for (i in 1..n) {\n            result = result.times(i.toBigInteger())\n        }\n        return result\n    }\n    object FactorialNotFoundException : Throwable()\n}\n```", "```swift\nclass TextFormatter(\n    private val factorialGenerator: FactorialGenerator,\n    private val context: Context\n) {\n    fun getFactorialResult(n: Int): String {\n        return try {\n            context.getString(R.string.result,\n            factorialGenerator.factorial(n).toString())\n        } catch (e: FactorialGenerator\n          .FactorialNotFoundException) {\n               context.getString(R.string.error)\n        }\n    }\n}\n```", "```swift\nclass MainActivity : AppCompatActivity() {\n    private lateinit var textFormatter: TextFormatter\n    override fun onCreate(savedInstanceState: Bundle?) {\n        super.onCreate(savedInstanceState)\n        setContentView(R.layout.activity_main)\n        textFormatter = TextFormatter(FactorialGenerator(),\n            applicationContext)\n        findViewById<Button>(R.id.button)\n            .setOnClickListener {\n                findViewById<TextView>(R.id.text_view)\n                .text = textFormatter.getFactorialResult(\n                findViewById<EditText>(R.id.edit_text).text\n                .toString()\n                .toInt())\n        }\n    }\n}\n```", "```swift\n@RunWith(AndroidJUnit4::class)\nclass MainActivityTest {\n    private val context =\n        getApplicationContext<Application>()\n    @Test\n    fun `show factorial result in text view`() {\n        val scenario = launch(MainActivity::class.java)\n        scenario.moveToState(Lifecycle.State.RESUMED)\n        scenario.onActivity { activity ->\n            activity.findViewById<EditText>(R.id.edit_text)\n                .setText(5.toString())\n            activity.findViewById<Button>(R.id.button)\n                .performClick()\n            assertEquals(\n                context.getString(R.string.result, \"120\"),\n                activity.findViewById<TextView>(\n                R.id.text_view).text\n            )\n        }\n    }\n}\n```", "```swift\n@Config(\n    sdk = [Build.VERSION_CODES.TIRAMISU],\n    minSdk = Build.VERSION_CODES.KITKAT,\n    maxSdk = Build.VERSION_CODES.TIRAMISU,\n    application = Application::class,\n    assetDir = \"/assetDir/\"\n)\n@RunWith(AndroidJUnit4::class)\nclass MainActivityTest\n```", "```swift\nsdk=33\nminSdk = 14\nmaxSdk = 33\n```", "```swift\n    testImplementation 'androidx.fragment:\n    fragment-testing:1.5.5'\n    testImplementation 'androidx.test.espresso:\n    espresso-core:3.5.0'\n```", "```swift\nval scenario = launchFragmentInContainer<MainFragment>()\nscenario.moveToState(Lifecycle.State.CREATED)\n```", "```swift\nonView(Matcher<View>).perform(ViewAction)\n```", "```swift\nonView(Matcher<View>).check(ViewAssertion)\n```", "```swift\nonView(allOf(withId(R.id.edit_text),\nwithParent(withId(R.id.root))))\n```", "```swift\nonView(withId(R.id.text_view)).check(matches(withText(\n\"My text\"))))\n```", "```swift\nonView(withId(R.id.button)).perform(click())\n```", "```swift\n@RunWith(AndroidJUnit4::class)\nclass MainActivityTest {\n    @Test\n    fun `show factorial result in text view`() {\n        val scenario = launch(MainActivity::class.java)\n        scenario.moveToState(Lifecycle.State.RESUMED)\n        scenario.onActivity { activity ->\n            onView(withId(R.id.edit_text)).perform(\n                typeText(\"5\"))\n            onView(withId(R.id.button)).perform(click())\n            onView(withId(R.id.text_view))\n                .check(matches(withText(activity.getString(\n                R.string.result, \"120\"))))\n        }\n    }\n}\n```", "```swift\nGiven I open the application\nAnd I insert the number n\nWhen I press the Calculate button\nThen I should see the text \"The sum of numbers from 1 to n is [result]\"\nGiven I open the application\nAnd I insert the number -n\nWhen I press the Calculate button\nThen I should see the text \"Error: Invalid number\"\n```", "```swift\n        testImplementation 'junit:junit:4.13.2'\n        testImplementation\n            'org.mockito:mockito-core:4.5.1'\n        testImplementation\n            'org.mockito.kotlin:mockito-kotlin:4.1.0'\n        testImplementation\n            'org.robolectric:robolectric:4.9'\n        testImplementation 'androidx.test.ext:junit:1.1.4'\n        testImplementation\n            'androidx.test.espresso:espresso-core:3.5.0'\n        androidTestImplementation\n            'androidx.test.ext:junit:1.1.4'\n        androidTestImplementation\n            'androidx.test.espresso:espresso-core:3.5.0'\n        androidTestImplementation\n            'androidx.test:rules:1.5.0'\n    ```", "```swift\n    testOptions.unitTests.includeAndroidResources = true\n    ```", "```swift\n    sdk=32\n    ```", "```swift\n    mock-maker-inline\n    ```", "```swift\n    class NumberAdder {\n        @Throws(InvalidNumberException::class)\n        fun sum(n: Int, callback: (BigInteger) -> Unit) {\n            if (n < 0) {\n                throw InvalidNumberException\n            }\n            callback(n.toBigInteger().times((n.toLong() +\n            1).toBigInteger()).divide(2.toBigInteger()))\n        }\n        object InvalidNumberException : Throwable()\n    }\n    ```", "```swift\n    @RunWith(Parameterized::class)\n    class NumberAdderParameterTest(\n        private val input: Int,\n        private val expected: BigInteger\n    ) {\n        private val numberAdder = NumberAdder()\n        @Test\n        fun sum() {\n            val callback = mock<(BigInteger) -> Unit>()\n            numberAdder.sum(input, callback)\n            verify(callback).invoke(expected)\n        }\n    }\n    ```", "```swift\n    @RunWith(MockitoJUnitRunner::class)\n    class NumberAdderErrorHandlingTest {\n        @InjectMocks\n        lateinit var numberAdder: NumberAdder\n        @Test(expected =\n            NumberAdder.InvalidNumberException::class)\n        fun sum() {\n            val input = -1\n            val callback = mock<(BigInteger) -> Unit>()\n            numberAdder.sum(input, callback)\n        }\n    }\n    ```", "```swift\n    class TextFormatter(\n        private val numberAdder: NumberAdder,\n        private val context: Context\n    ) {\n        fun getSumResult(n: Int, callback: (String) ->\n        Unit) {\n            try {\n                numberAdder.sum(n) {\n                    callback(context.getString(\n                    R.string\n                    .the_sum_of_numbers_from_1_to_is,\n                    n, it.toString())\n                    )\n                }\n            } catch (\n              e: NumberAdder.InvalidNumberException) {\n                  callback(context.getString(\n                  R.string.error_invalid_number))\n            }\n        }\n    }\n    ```", "```swift\n    @RunWith(MockitoJUnitRunner::class)\n    class TextFormatterTest {\n        @InjectMocks\n        lateinit var textFormatter: TextFormatter\n        @Mock\n        lateinit var numberAdder: NumberAdder\n        @Mock\n        lateinit var context: Context\n        @Test\n        fun getSumResult_success() {\n            val n = 10\n            val sumResult = BigInteger.TEN\n            val expected = \"expected\"\n            whenever(numberAdder.sum(eq(n),\n            any())).thenAnswer {\n                (it.arguments[1] as (BigInteger) ->\n                Unit).invoke(sumResult)\n            }\n            whenever(context.getString(\n            R.string.the_sum_of_numbers_from_1_to_is,\n            n, sumResult.toString())\n            ).thenReturn(expected)\n            val callback = mock<(String) -> Unit>()\n            textFormatter.getSumResult(n, callback)\n            verify(callback).invoke(expected)\n        }\n    }\n    ```", "```swift\n    @Test\n    fun getSumResult_error() {\n        val n = 10\n        val expected = \"expected\"\n        whenever(numberAdder.sum(eq(n),\n            any())).thenThrow(NumberAdder\n            .InvalidNumberException)\n            whenever(context.getString(\n            R.string.error_invalid_number))\n            .thenReturn(expected)\n        val callback = mock<(String) -> Unit>()\n        textFormatter.getSumResult(n, callback)\n        verify(callback).invoke(expected)\n    }\n```", "```swift\n        <string name=\"the_sum_of_numbers_from_1_to_is\">\n            The sum of numbers from 1 to %1$d is:\n            %2$s</string>\n        <string name=\"error_invalid_number\">Error: Invalid\n            number</string>\n        <string name=\"calculate\">Calculate</string>\n    ```", "```swift\n        <EditText\n            android:id=\"@+id/edit_text\"\n            android:layout_width=\"match_parent\"\n            android:layout_height=\"wrap_content\"\n            android:inputType=\"number\" />\n        <Button\n            android:id=\"@+id/button\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center_horizontal\"\n            android:text=\"@string/calculate\" />\n    ```", "```swift\n    class MainActivity : AppCompatActivity() {\n        private lateinit var textFormatter: TextFormatter\n        override fun onCreate(savedInstanceState: Bundle?)\n        {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.activity_main)\n            textFormatter = TextFormatter(NumberAdder(),\n                applicationContext)\n            findViewById<Button>(R.id.button)\n            .setOnClickListener {\n                textFormatter.getSumResult(findViewById\n                <EditText>(R.id.edit_text).text.toString()\n                .toIntOrNull() ?: 0) {\n                    findViewById<TextView>(R.id.text_view)\n                    .text = it\n                }\n            }\n        }\n    }\n    ```", "```swift\n    @RunWith(AndroidJUnit4::class)\n    class MainActivityTest {\n        @Test\n        fun `show sum result in text view`() {\n            val scenario =\n                launch(MainActivity::class.java)\n            scenario.moveToState(Lifecycle.State.RESUMED)\n            scenario.onActivity { activity ->\n                onView(withId(R.id.edit_text))\n                    .perform(replaceText(\"5\"))\n                onView(withId(R.id.button)).perform(click(\n                ))\n                onView(withId(R.id.text_view))\n                  .check(matches(withText(\n                  activity.getString(\n                  R.string.the_sum_of_numbers_from_1_to_is\n                  , 5, \"15\"))))\n            }\n        }\n    }\n    ```", "```swift\n    @RunWith(AndroidJUnit4::class)\n    class MainActivityUiTest {\n        @Test\n        fun showSumResultInTextView() {\n            val scenario =\n                launch(MainActivity::class.java)\n            scenario.moveToState(Lifecycle.State.RESUMED)\n            onView(withId(R.id.edit_text)).perform(\n                replaceText(\"5\"))\n            onView(withId(R.id.button)).perform(click())\n            onView(withId(R.id.text_view)).check(matches(\n               withText(getApplicationContext<Application>\n               ().getString(R.string\n               .the_sum_of_numbers_from_1_to_is, 5, \"15\"))\n               ))\n        }\n    }\n    ```", "```swift\nandroid {\n    ...\n    defaultConfig {\n        ...\n        testInstrumentationRunner\n            \"androidx.test.runner.AndroidJUnitRunner\"\n        testInstrumentationRunnerArguments\n            clearPackageData: 'true'\n    }\n    testOptions {\n        execution 'ANDROIDX_TEST_ORCHESTRATOR'\n    }\n}\ndependencies {\n    ...\n    androidTestUtil 'androidx.test:orchestrator:1.4.2'\n}\n```", "```swift\ntestInstrumentationRunner \"com.android.CustomTestRunner\"\n```", "```swift\nclass CustomTestRunner: AndroidJUnitRunner() {\n    @Throws(Exception::class)\n    override fun newApplication(\n        cl: ClassLoader?,\n        className: String?,\n        context: Context?\n    ): Application? {\n        return super.newApplication(cl,\n        MyApplication::class.java.name, context)\n    }\n}\n```", "```swift\n@RunWith(AndroidJUnit4::class)\nclass MainActivityUiTest {\n}\n```", "```swift\n    @Test\n    fun myTest() {\n        onView(withId(R.id.edit_text)).perform(replaceText\n            (\"5\"))\n        onView(withId(R.id.button)).perform(click())\n        onView(withId(R.id.text_view)).check(matches(\n            withText(\"my test\")))\n    }\n```", "```swift\nclass MyScreenRobot {\n    fun setText(): MyScreenRobot {\n        onView(ViewMatchers.withId(R.id.edit_text))\n            .perform(ViewActions.replaceText(\"5\"))\n        return this\n    }\n    fun pressButton(): MyScreenRobot {\n        onView(ViewMatchers.withId(R.id.button))\n            .perform(ViewActions.click())\n        return this\n    }\n    fun assertText(): MyScreenRobot {\n        onView(ViewMatchers.withId(R.id.text_view))\n            .check(ViewAssertions.matches(ViewMatchers\n            .withText(\"my test\")))\n        return this\n    }\n}\n```", "```swift\n    @Test\n    fun myTest() {\n       MyScreenRobot()\n           .setText()\n           .pressButton()\n           .assertText()\n    }\n```", "```swift\nclass MyHeavyliftingComponent(private val\ncountingIdlingResource:CountingIdlingResource) {\n    fun doHeavyWork() {\n        countingIdlingResource.increment()\n        // do work\n        countingIdlingResource.decrement()\n    }\n}\n```", "```swift\nclass MyApplication : Application(){\n    val countingIdlingResource =\n        CountingIdlingResource(\"My heavy work\")\n    val myHeavyliftingComponent =\n        MyHeavyliftingComponent(countingIdlingResource)\n}\n```", "```swift\n@RunWith(AndroidJUnit4::class)\nclass MyTest {\n    @Before\n    fun setUp() {\n        val myApplication =\n            getApplicationContext<MyApplication>()\n        IdlingRegistry.getInstance()\n            .register(myApplication.countingIdlingResource)\n    }\n}\n```", "```swift\nandroidTestImplementation 'androidx.test.espresso:\nespresso-intents:3.5.0'\n```", "```swift\n        onView(withId(R.id.button)).perform(click())\n        intended(allOf(hasComponent(hasShortClassName\n            (\".MainActivity\")), hasExtra(MainActivity\n            .MY_EXTRA, \"myExtraValue\")))\n```", "```swift\nandroidTestImplementation\n'com.android.support.test.espresso:espresso-contrib:3.5.0'\n```", "```swift\nonView(withId(R.id.recycler_view))\n.perform(RecyclerViewActions.actionOnItemAtPosition(0,\nclick()))\n```", "```swift\nonView(withId(R.id.recycler_view)).perform(\nRecyclerViewActions.scrollToPosition<RecyclerView\n.ViewHolder>(10))\n```", "```swift\nonView(withText(\"myText\")).check(matches(isDisplayed()))\n```", "```swift\nandroidTestImplementation \"androidx.compose.ui:\nui-test-junit4:1.1.1\"\n```", "```swift\ndebugImplementation \"androidx.compose.ui:\nui-test-manifest:1.1.1\"\n```", "```swift\nclass MyTest {\n    @get:Rule\n    var composeTestRuleForActivity =\n        createAndroidComposeRule(MyActivity::class.java)\n    @get:Rule\n    var composeTestRuleForNoActivity = createComposeRule()\n    @Test\n    fun testNoActivityFunction(){\n        composeTestRuleForNoActivity.setContent {\n            // Set method you want to test here\n        }\n    }\n}\n```", "```swift\n        composeTestRule.onNodeWithText(\"My text\")\n        composeTestRule.onNodeWithContentDescription(\n            \"My content description\")\n        composeTestRule.onNodeWithTag(\"My test tag\")\n```", "```swift\n        composeTestRule.onNodeWithText(\"My text\")\n            .performClick()\n            .performScrollTo()\n            .performTextInput(\"My new text\")\n            .performGesture {\n            }\n```", "```swift\n        composeTestRule.onNodeWithText(\"My text\")\n            .assertIsDisplayed()\n            .assertIsNotDisplayed()\n            .assertIsEnabled()\n            .assertIsNotEnabled()\n            .assertIsSelected()\n            .assertIsNotSelected()\n```", "```swift\n        composeTestRule.onAllNodesWithText(\"My text\")\n        composeTestRule.onAllNodesWithContentDescription(\n            \"My content description\")\n        composeTestRule.onAllNodesWithTag(\"My test tag\")\n```", "```swift\n        composeTestRule.onAllNodesWithText(\"My text\")[0]\n            .assertIsDisplayed()\n```", "```swift\n        composeTestRule.onAllNodesWithText(\"My text\")\n            .assertCountEquals(3)\n            .assertAll(SemanticsMatcher.expectValue(\n            SemanticsProperties.Selected, true))\n            .assertAny(SemanticsMatcher.expectValue(\n            SemanticsProperties.Selected, true))\n```", "```swift\n    @Before\n    fun setUp() {\n        composeTestRule.registerIdlingResource(\n        idlingResource)\n    }\n    @After\n    fun tearDown() {\n        composeTestRule.unregisterIdlingResource(\n        idlingResource)\n    }\n```", "```swift\n        implementation 'androidx.test.espresso:\n            espresso-idling-resource:3.5.1'\n        testImplementation 'junit:junit:4.13.2'\n        androidTestImplementation\n            'androidx.test.espresso:espresso-core:3.5.1'\n        androidTestImplementation\n            'androidx.test.ext:junit:1.1.5'\n        androidTestImplementation\n            'androidx.test:rules:1.5.0'\n    ```", "```swift\n    open class Randomizer(private val random: Random) {\n        open fun getTimeToWait(): Int {\n            return random.nextInt(5) + 1\n        }\n    }\n    ```", "```swift\n    class Synchronizer(\n        private val randomizer: Randomizer,\n        private val timer: Timer,\n        private val countingIdlingResource:\n            CountingIdlingResource\n    ) {\n        fun executeAfterDelay(callback: (Int) -> Unit) {\n            val timeToWait = randomizer.getTimeToWait()\n            countingIdlingResource.increment()\n            timer.schedule(CallbackTask(callback,\n                timeToWait), timeToWait * 1000L)\n        }\n        inner class CallbackTask(\n            private val callback: (Int) -> Unit,\n            private val time: Int\n        ) : TimerTask() {\n            override fun run() {\n                callback(time)\n                countingIdlingResource.decrement()\n            }\n        }\n    }\n    ```", "```swift\n    class MyApplication : Application() {\n        val countingIdlingResource =\n            CountingIdlingResource(\"Timer resource\")\n        val randomizer = Randomizer(Random())\n        val synchronizer =\n            Synchronizer(randomizer, Timer(),\n            countingIdlingResource)\n    }\n    ```", "```swift\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout\n    xmlns:android=\n      \"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <Button\n            android:id=\"@+id/activity_1_button\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\"\n            android:text=\"@string/press_me\" />\n    </LinearLayout>\n    ```", "```swift\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <LinearLayout\n    xmlns:android=\n      \"http://schemas.android.com/apk/res/android\"\n        android:layout_width=\"match_parent\"\n        android:layout_height=\"match_parent\"\n        android:orientation=\"vertical\">\n        <TextView\n            android:id=\"@+id/activity_2_text_view\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"wrap_content\"\n            android:layout_gravity=\"center\" />\n    </LinearLayout>\n    ```", "```swift\n    class Activity1 : AppCompatActivity() {\n        override fun onCreate(savedInstanceState: Bundle?)\n        {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.activity_1)\n            findViewById<Button>(R.id.activity_1_button)\n            .setOnClickListener {\n                (application as MyApplication)\n                .synchronizer.executeAfterDelay {\n                    startActivity(Activity2.newIntent(this\n                    , it))\n                }\n            }\n        }\n    }\n    ```", "```swift\n    class Activity2 : AppCompatActivity() {\n        companion object {\n            private const val EXTRA_SECONDS =\n                \"extra_seconds\"\n            fun newIntent(context: Context, seconds: Int)\n                = Intent(context, Activity2::class.java)\n                .putExtra(EXTRA_SECONDS, seconds)\n        }\n        override fun onCreate(savedInstanceState: Bundle?)\n        {\n            super.onCreate(savedInstanceState)\n            setContentView(R.layout.activity_2)\n            findViewById<TextView>(\n                R.id.activity_2_text_view).text =\n                getString(R.string.opened_after_x_seconds,\n                intent.getIntExtra(EXTRA_SECONDS, 0))\n        }\n    }\n    ```", "```swift\n        <string name=\"press_me\">Press Me</string>\n        <string name=\"opened_after_x_seconds\">Opened after\n        %d seconds</string>\n    ```", "```swift\n        <application\n            … >\n            <activity\n                android:name=\".Activity1\"\n                android:exported=\"true\">\n        </application>\n    ```", "```swift\n    @RunWith(AndroidJUnit4::class)\n    @LargeTest\n    class FlowTest {\n        @Test\n        fun verifyFlow() {\n            onView(withId(R.id.activity_1_button))\n                .perform(click())\n            onView(withId(R.id.activity_2_text_view))\n               .check(matches(withText(myApplication\n               .getString(R.string.opened_after_x_seconds,\n               1))))\n        }\n    }\n    ```", "```swift\n    class TestRandomizer(random: Random) :\n    Randomizer(random) {\n        override fun getTimeToWait(): Int {\n            return 1\n        }\n    }\n    ```", "```swift\n    open class MyApplication : Application() {\n        val countingIdlingResource =\n            CountingIdlingResource(\"Timer resource\")\n        lateinit var synchronizer: Synchronizer\n        override fun onCreate() {\n            super.onCreate()\n            synchronizer =\n                Synchronizer(createRandomizer(), Timer(),\n                countingIdlingResource)\n        }\n        open fun createRandomizer() = Randomizer(Random())\n    }\n    ```", "```swift\n    class TestMyApplication : MyApplication() {\n        override fun createRandomizer(): Randomizer {\n            return TestRandomizer(Random())\n        }\n    }\n    ```", "```swift\n    class MyApplicationTestRunner : AndroidJUnitRunner() {\n        @Throws(Exception::class)\n        override fun newApplication(\n            cl: ClassLoader?,\n            className: String?,\n            context: Context?\n        ): Application? {\n            return super.newApplication(cl,\n            TestMyApplication::class.java.name, context)\n        }\n    }\n    ```", "```swift\n    android {\n        ...\n        defaultConfig {\n            ...\n            testInstrumentationRunner\n                \"com.android.testable.myapplication\n                .MyApplicationTestRunner\"\n        }\n    }\n    ```", "```swift\n    interface Randomizer {\n        fun getTimeToWait(): Int\n    }\n    ```", "```swift\n    class RandomizerImpl(private val random: Random) :\n    Randomizer {\n        override fun getTimeToWait(): Int {\n            return random.nextInt(5) + 1\n        }\n    }\n    ```", "```swift\n    open class MyApplication : Application() {\n        …\n        open fun createRandomizer() : Randomizer =\n            RandomizerImpl(Random())\n    }\n    ```", "```swift\n    class TestRandomizer : Randomizer {\n        override fun getTimeToWait(): Int {\n            return 1\n        }\n    }\n    ```", "```swift\n    class TestMyApplication : MyApplication() {\n        override fun createRandomizer(): Randomizer {\n            return TestRandomizer()\n        }\n    }\n    ```", "```swift\n        androidTestImplementation 'androidx.test.espresso:\n        espresso-idling-resource:3.5.1'\n    ```", "```swift\n    interface Synchronizer {\n        fun executeAfterDelay(callback: (Int) -> Unit)\n    }\n    ```", "```swift\n    class SynchronizerImpl(\n        private val randomizer: Randomizer,\n        private val timer: Timer\n    ) : Synchronizer {\n        override fun executeAfterDelay(callback: (Int) ->\n        Unit) {\n            val timeToWait = randomizer.getTimeToWait()\n                timer.schedule(CallbackTask(callback,\n                timeToWait), timeToWait * 1000L)\n        }\n        inner class CallbackTask(\n            private val callback: (Int) -> Unit,\n            private val time: Int\n        ) : TimerTask() {\n            override fun run() {\n                callback(time)\n            }\n        }\n    }\n    ```", "```swift\n    open class MyApplication : Application() {\n        lateinit var synchronizer: Synchronizer\n        override fun onCreate() {\n            super.onCreate()\n            synchronizer = createSynchronizer()\n        }\n        open fun createRandomizer(): Randomizer =\n            RandomizerImpl(Random())\n        open fun createSynchronizer(): Synchronizer =\n            SynchronizerImpl(createRandomizer(), Timer())\n    }\n    ```", "```swift\n    class TestSynchronizer(\n        private val synchronizer: Synchronizer,\n        private val countingIdlingResource:\n            CountingIdlingResource\n    ) : Synchronizer {\n        override fun executeAfterDelay(callback: (Int) ->\n        Unit) {\n            countingIdlingResource.increment()\n            synchronizer.executeAfterDelay {\n                callback(it)\n                countingIdlingResource.decrement()\n            }\n        }\n    }\n    ```", "```swift\n    class TestMyApplication : MyApplication() {\n        val countingIdlingResource =\n            CountingIdlingResource(\"Timer resource\")\n        override fun createRandomizer(): Randomizer {\n            return TestRandomizer()\n        }\n        override fun createSynchronizer(): Synchronizer {\n            return\n              TestSynchronizer(super.createSynchronizer(),\n              countingIdlingResource)\n        }\n    }\n    ```", "```swift\n    private val myApplication =\n        getApplicationContext<TestMyApplication>()\n    ```", "```swift\n    testImplementation 'junit:junit:4.13.2'\n    ```", "```swift\n    class Adder {\n        fun sum(n: Int): Int = 0\n    }\n    ```", "```swift\n    class AdderTest {\n        private val adder = Adder()\n        @Test\n        fun sumSuccess() {\n            assertEquals(1, adder.sum(1))\n            assertEquals(3, adder.sum(2))\n            assertEquals(55, adder.sum(10))\n            assertEquals(210, adder.sum(20))\n            assertEquals(2305843008139952128L,\n                adder.sum(Int.MAX_VALUE))\n        }\n        @Test\n        fun sumError(){\n            assertEquals(-1, adder.sum(0))\n            assertEquals(-1, adder.sum(-1))\n        }\n    }\n    ```", "```swift\n    class Adder {\n        fun sum(n: Int): Long {\n            var result = 0L\n            for (i in 1..n) {\n                result += i\n            }\n            return result\n        }\n    }\n    ```", "```swift\n    class Adder {\n        fun sum(n: Int): Long {\n            return (n * (n.toLong() + 1)) / 2\n        }\n    }\n    ```", "```swift\n    class Adder {\n        fun sum(n: Int): Long {\n            return if (n > 0) (n * (n.toLong() + 1)) / 2\n    else -1\n        }\n    }\n    ```"]