<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Custom Subscripting</h1></div></div></div><p>Custom subscripts<a class="indexterm" id="id421"/> were added to Objective-C in 2012. At that time, Chris Lattner was already 2 years into developing Swift and like other good features of Objective-C, subscripts became a part of the Swift language. I did not frequently use custom subscripts in Objective-C, but I did know that they were a part of the language when I needed them. Subscripts in Swift seem, to me, to be a more natural part of the language, possibly because they were part of the language when it was released and not added in later.</p><p>In this chapter, you will learn the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What are custom subscripts</li><li class="listitem" style="list-style-type: disc">How to add custom subscripts to classes, structures, or enums</li><li class="listitem" style="list-style-type: disc">How to create read/write and read-only subscripts</li><li class="listitem" style="list-style-type: disc">How to use external names without custom subscripts</li><li class="listitem" style="list-style-type: disc">How to use multidimensional subscripts</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Introducing subscripts</h1></div></div></div><p>Subscripts are<a class="indexterm" id="id422"/> shortcuts for accessing elements of a collection, list, or sequence. They are used to set or retrieve the values by index rather than using getter and setter methods. Subscripts, if used correctly, can significantly enhance the usability and readability of our custom types.</p><p>We can define multiple subscripts for a single type, and the appropriate subscript will be chosen, based on the type of index passed into the subscript. We can also set external parameter names for our subscripts that can help distinguish between subscripts that have the same type.</p><p>Using a custom subscript<a class="indexterm" id="id423"/> is similar to using subscripts for arrays and dictionaries. For example, to access an element in an array, we will use the <code class="literal">anArray[index]</code> syntax, and to access an element of a dictionary, we will use the same syntax, that is, <code class="literal">aDictionary[key]</code>. When we define a custom subscript for our custom types, we also access them with the same syntax, <code class="literal">ourType[key]</code>.</p><p>When <a class="indexterm" id="id424"/>creating custom subscripts, we should try to make them feel like they are a natural part of the class, structure, or enum. As mentioned earlier, subscripts can significantly enhance the usability and readability of our code, but if we try to overuse subscripts, they will not feel natural and will be hard to use.</p><p>In this chapter, we will look at several examples of how we can create and use custom subscripts. We will also show an example of how not to use a subscript. Before we show how to use custom subscripts, let's review how subscripts are used with Swift arrays to see how subscripts are used within the Swift language. We should use subscripts in a similar manner to how Apple uses them within the language itself to make our custom subscripts easy to understand and use.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec57"/>Subscripts with Swift arrays</h1></div></div></div><p>The<a class="indexterm" id="id425"/> following example shows how to use subscripts to access and change the values of an array:</p><div><pre class="programlisting">var arrayOne = [1,2,3,4,5,6]
print(arrayOne[3])  //Displays '4'
arrayOne[3] = 10
print(arrayOne[3])  //Displays '10'</pre></div><p>In the preceding example, we create an array of integers and then use the subscript syntax to display and change the item of element number <code class="literal">3</code> in the array. Subscripts are mainly used to get or retrieve information from a collection. We generally do not use subscripts when specific logic needs to be applied to determine which item to select. As examples, we will not use subscripts to append an item to the end of the array or to retrieve the number of items in the array. To append an item to the end of an array, or to get the number of items in an array, we will use functions or properties like this:</p><div><pre class="programlisting">arrayOne.append(7)  //append 7 to the end of the array
arrayOne.count  //returns the number of items in an array</pre></div><p>Subscripts in our custom types should follow the same standard set by the Swift language itself, so other developers that use our types are not confused by the implementation. The key to knowing when to use subscripts, and when not to, is to understand how the subscript will be used.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec58"/>Read and write custom subscripts</h1></div></div></div><p>Let's see <a class="indexterm" id="id426"/>how to define a subscript that is used to read and write to a backend array. Reading <a class="indexterm" id="id427"/>and writing to a backend storage class is one of the most common uses of custom subscripts, but, as we will see in this<a class="indexterm" id="id428"/> chapter, we do not need to have a backend storage class. The following code is a subscript to read <a class="indexterm" id="id429"/>and write an array:</p><div><pre class="programlisting">class MyNames {
    private var names:[String] = ["Jon", "Kim", "Kailey", "Kara"]
    subscript(index: Int) -&gt; String {
        get {
            return names[index]
        }
        set {
            names[index] = newValue
        }
    }
}</pre></div><p>As we can see, the syntax is similar to how we can define properties within a class using the <code class="literal">get</code> and <code class="literal">set</code> keywords. The difference is that we declare the subscript using the <code class="literal">subscript</code> keyword. We then specify one or more inputs and the return type.</p><p>We can now use the custom subscript, just like we used subscripts with arrays and dictionaries. The following code shows how to use the subscript in the preceding example:</p><div><pre class="programlisting">var nam = MyNames()
print(nam[0])  //Displays 'Jon'
nam[0] = "Buddy"
print(nam[0])  //Displays 'Buddy'</pre></div><p>In the preceding code, we create an instance of the <code class="literal">MyNames</code> class. We then display the original name at index <code class="literal">0</code>, change the name at index <code class="literal">0</code>, and redisplay it. In this example, we use the subscript that we defined in the <code class="literal">MyNames</code> class to retrieve and set elements of the <code class="literal">names</code> array within the <code class="literal">MyNames</code> class.</p><p>While we could just make the <code class="literal">names</code> array property available for external code to read and write directly to, this would lock our code into using an array to store the data. If we ever want to change the backend storage mechanism to a dictionary object, or even an SQLite database, we will be unable to do so because all of the external code would also have to be changed. Subscripts are very good at hiding how we store information within our custom types; therefore, external code that uses our custom type does not rely on any specific storage implementations.</p><p>We would also be unable to verify that the external code was inserting valid information into the array if we gave direct access to it. With subscripts, we can add validation to our setters to verify that the data being passed in is correct before adding it to the array. This can be very useful whether we are creating a framework or a library.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec59"/>Read-only custom subscripts</h1></div></div></div><p>We can also<a class="indexterm" id="id430"/> make the subscript read-only by either not declaring a setter method within the subscript or by not implicitly declaring a getter or setter method. The following code shows how to declare a read-only property by not declaring a setter method:</p><div><pre class="programlisting">//No getter/setters implicitly declared
subscript(index: Int) -&gt;String {
  return names[index]
}</pre></div><p>The following example shows how to declare a read-only property by only declaring a getter method:</p><div><pre class="programlisting">//Declaring only a getter
subscript(index: Int) -&gt;String {
  get {
    return names[index]
  }
}</pre></div><p>In the first example, we do not define either a getter or setter method. So, Swift sets the subscript as read-only and the code acts as if it was in a getter definition. In the second example, we specifically set the code in a getter definition. Both examples are valid read-only subscripts.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Calculated subscripts</h1></div></div></div><p>While<a class="indexterm" id="id431"/> the preceding example is very similar to using the stored properties in a class or structure, we can also use subscripts in a similar manner to the <a class="indexterm" id="id432"/>computed properties. Let's see how to do this:</p><div><pre class="programlisting">struct MathTable {
    var num: Int
   
    subscript(index: Int) -&gt; Int {
        return num * index
    }
}</pre></div><p>In the preceding example, we used an array as the backend storage mechanism for the subscript. In this example, we use the value of the subscript to calculate the return value. We will use this subscript as follows:</p><div><pre class="programlisting">var table = MathTable(num: 5)
print(table[4])</pre></div><p>This example will display the calculated value of <code class="literal">5</code> (the number defined in the initialization) times <code class="literal">4</code> (the subscript value), which is equal to 20.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Subscript values</h1></div></div></div><p>In the <a class="indexterm" id="id433"/>preceding subscript examples, all of the subscripts accepted integers as the value for the subscript; however, we are not limited to integers. In the following example, we will use a string type as the value for the subscript. The subscript will also return a string type:</p><div><pre class="programlisting">struct Hello {
  subscript (name: String) -&gt;String {
    return "Hello \(name)"
  }
}</pre></div><p>In this example, the subscript takes a string as the value within the subscript and returns a message, saying <code class="literal">Hello</code>. Let's see how to use this subscript:</p><div><pre class="programlisting">var hello = Hello()
print(hello["Jon"])</pre></div><p>This example will display the message, <code class="literal">Hello Jon</code>, to the console.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Subscripts with ranges</h1></div></div></div><p>Similar<a class="indexterm" id="id434"/> to how we use <code class="literal">range</code> operators with arrays, we can also let our custom subscripts use the <code class="literal">range</code> operator. Let's expand the <code class="literal">MathTable</code> structure that we created earlier to include a second subscript that will take a range operator and see how it works:</p><div><pre class="programlisting">struct MathTable {
  var num: Int
  subscript(index: Int) -&gt; Int {
    return num * index
  }
  subscript(aRange: Range&lt;Int&gt;) -&gt; [Int] {
    var retArray: [Int] = []
    for i in aRange {
      retArray.append(self[i])
    }
      return retArray

  }
}</pre></div><p>The new subscript in our example takes a range as the value for the subscript and then returns an array of integers. Within the subscript, we generate an array, which will be returned to <a class="indexterm" id="id435"/>the calling code by using the other subscript method that we previously created to multiply each value of the range by the <code class="literal">num</code> property.</p><p>The following example shows how to use this new subscript:</p><div><pre class="programlisting">var table = MathTable(num: 5)
print(table[2...5])</pre></div><p>If we run the example, we will see an array that contains the value, <code class="literal">10</code>, <code class="literal">15</code>, <code class="literal">20</code>, and <code class="literal">25</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec63"/>External names for subscripts</h1></div></div></div><p>As we <a class="indexterm" id="id436"/>mentioned earlier in this chapter, we can have multiple subscript signatures for our custom types. The appropriate subscript will be chosen, based on the type of index passed into the subscript. There are times when we may wish to define multiple subscripts that have the same type. For this, we could use external names similar to how we define external names for the parameters of a function.</p><p>Let's rewrite the original <code class="literal">MathTable</code> structure to include two subscripts that each accept an integer as the subscript type; however, one will perform a multiplication operation, and the other will perform an addition operation:</p><div><pre class="programlisting">struct MathTable {
  var num: Int
  subscript(multiply index: Int) -&gt; Int {
    return num * index
  }
  subscript(addition index: Int) -&gt; Int {
    return num + index
  }
}</pre></div><p>As we can see, in this example we define two subscripts and each subscript is an integer type. The difference between the two subscripts is the external name within the definition. In the first subscript, we define an external name of <code class="literal">multiply</code> because we multiply the value of the subscript by the <code class="literal">num</code> property within this subscript. In the second subscript, we define an external name of <code class="literal">addition</code> because we add the value of the subscript to the <code class="literal">num</code> property within the subscript.</p><p>Let's see how to use these two subscripts:</p><div><pre class="programlisting">var table = MathTable(num: 5)
print(table[multiply: 4])  //Displays 20 because 5*4=20
print(table[addition: 4])  //Displays 9 because 5+4=9</pre></div><p>If we run this example, we will see that the correct subscript is used, based on the external name within the subscript.</p><p>Using<a class="indexterm" id="id437"/> external names within our subscript is very useful if we need multiple subscripts of the same type; I would not recommend using external names unless they are needed to distinguish between multiple subscripts.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec64"/>Multidimensional subscripts</h1></div></div></div><p>While<a class="indexterm" id="id438"/> the most common subscripts are the ones <a class="indexterm" id="id439"/>that take a single parameter, subscripts are not limited to single parameters. They can take any number of input parameters, and these parameters can be of any type.</p><p>Let's see how we could use a multidimensional subscript to implement a Tic-Tac-Toe board. A Tic-Tac-Toe board looks similar to this:</p><div><img alt="Multidimensional subscripts" src="img/B05115_09_01.jpg"/></div><p>The board can be represented by a two-dimensional array where each dimension has three elements. Each player will then take a turn placing his/her pieces (typically, X or O) within the board until one player has three pieces in a row or the board is full.</p><p>Let's see how we could implement a Tic-Tac-Toe board using a multidimensional array and multidimensional subscripts:</p><div><pre class="programlisting">struct TicTacToe {
  var board = [["","",""],["","",""],["","",""]]
  subscript(x: Int, y: Int) -&gt; String {
    get {
      return board[x][y]
    }
    set {
      board[x][y] = newValue
    }
  }
}</pre></div><p>We start the<a class="indexterm" id="id440"/> Tic-Tac-Toe structure by defining a 3x3 array that will represent the game board. We then define a subscript that can be used to set and retrieve player pieces on the board. The subscript will accept two integer values. Multiple types<a class="indexterm" id="id441"/> are defined by putting the value types between parentheses. In our example, we are defining the subscript with the parameters, <code class="literal">(x: Int, y: Int)</code>. We can then use the <code class="literal">x</code> and <code class="literal">y</code> variable names within our subscripts to access the values that are passed in.</p><p>Let's see how to use this subscript to set the user's pieces on the board:</p><div><pre class="programlisting">var board = TicTacToe()
board[1,1] = "x"
board[0,0] = "o"</pre></div><p>If we run this code, we will see that we added the player <code class="literal">x</code> piece to the center square and player <code class="literal">o</code> piece to the upper-left square, so our game board will look similar to this:</p><div><img alt="Multidimensional subscripts" src="img/B05115_09_02.jpg"/></div><p>We are not limited to using only one type in our multidimensional subscripts, so we can use multiple types. For example, we could have a subscript of the <code class="literal">(x: Int, y:Double, z: String)</code> type.</p><p>We can also add external names for our multidimensional subscript types to help identify what values are used for and to distinguish between the subscripts that have the same types. Let's take a look at how to use multiple types and external names with subscripts by creating a subscript that will return an array of string instances, based on the values of the subscript:</p><div><pre class="programlisting">struct SayHello {
  subscript(messageText message:String, messageName name:String, number number:Int) -&gt; [String]{
  var retArray: [String] = []
    for var i=0; i &lt; number; i++ {
      retArray.append("\(message) \(name)")
    }
    return retArray
  }
}</pre></div><p>In the <code class="literal">SayHello</code> structure, we define our subscript like this:</p><div><pre class="programlisting">subscript(messageText message:String,messageName name:String, number number:Int) -&gt; [String]</pre></div><p>This <a class="indexterm" id="id442"/>defines <a class="indexterm" id="id443"/>a subscript with three elements. Each element has an external name (<code class="literal">message</code>, <code class="literal">name</code>, and <code class="literal">number</code>) and an internal name (<code class="literal">message</code>, <code class="literal">name</code>, and <code class="literal">number</code>). The first two elements are of the string type and the last one is an int type. We use the first two elements to create a message for the user that will repeat the number of times defined by the last (<code class="literal">number</code>) element. We will use this subscript as follows:</p><div><pre class="programlisting">var message = SayHello()
var ret = message[messageText:"Bonjour",messageName:"Jon",number:5]</pre></div><p>If we run this code, we will see that the <code class="literal">ret</code> variable contains an array of five strings, where each string equals <code class="literal">Bonjour Jon</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec65"/>When not to use a custom subscript</h1></div></div></div><p>As we have <a class="indexterm" id="id444"/>seen in this chapter, creating custom subscripts can really enhance our code; however, we should avoid overusing them or using them in a way that is not consistent with the standard subscript usage. The way to avoid overusing subscripts is to examine how subscripts are used in Swift's standard libraries. </p><p>Let's take a look at the following example:</p><div><pre class="programlisting">class MyNames {
  private var names:[String] = ["Jon", "Kim", "Kailey", "Kara"]
  var number: Int {
    get {
      return names.count
    }
  }
  subscript(add name: String) -&gt; String {
    names.append(name)
    return name
  }
  subscript(index: Int) -&gt; String {
    get {
      return names[index]
    }
    set {
      names[index] = newValue
    }
  }
}</pre></div><p>In the preceding<a class="indexterm" id="id445"/> example, within the <code class="literal">MyNames</code> class, we define an array of names that is used within our application. As an example, let's say that within our application, we display this list of names and allow users to add names to it. Within the <code class="literal">MyNames</code> class, we then define the following subscript that allows us to append a new name to the array:</p><div><pre class="programlisting">subscript(add name: String) -&gt; String {
  names.append(name)
  return name
}</pre></div><p>This will be a poor use of subscript syntax because its usage is not consistent with how subscripts are used within the Swift language. This might cause confusion when the class is used in the future. It will be more appropriate to rewrite this subscript as a function like this:</p><div><pre class="programlisting">func append(name: String) {
  names.append(name)
}</pre></div><p>Remember, when you are using custom subscripts make sure that you are using them appropriately.</p></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec66"/>Summary</h1></div></div></div><p>As we saw in this chapter, adding support for subscripts to our custom types can greatly enhance their readability and usability. We saw that subscripts can be used to add an abstraction layer between our backend storage class and external code. Subscripts can also be used in a similar manner to computed properties where the subscript is used to calculate a value. As we noted, the key with subscripts is to use them appropriately and in a manner that is consistent with subscripts in the Swift language.</p></div></body></html>