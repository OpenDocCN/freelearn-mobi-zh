- en: '*Chapter 6*: Assembling a Repository'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 6 章*：组装仓库'
- en: In this chapter, we will begin by discussing the application's data layer and
    the components that make up this layer, including repositories and data sources.
    We will then move on to the topic of repositories, one of the application layer's
    components, and the role they play in managing the data of an application. In
    this chapter's exercise, we will continue the project started in the previous
    chapter by providing the repository implementations for the abstractions defined
    there and also introducing new abstractions for the different types of data sources.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论应用程序的数据层以及构成这一层的组件，包括仓库和数据源。然后，我们将继续讨论仓库这一应用程序层的组件及其在管理应用程序数据中的作用。在本章的练习中，我们将继续上一章开始的项目，提供上一章中定义的抽象的仓库实现，并引入针对不同类型数据源的新抽象。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating the data layer
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建数据层
- en: Creating repositories
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建仓库
- en: By the end of the chapter, you will have learned what the data layer is and
    how we can create repositories for an Android application.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解数据层是什么以及我们如何为 Android 应用程序创建仓库。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The hardware and software requirements are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件要求如下：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 补丁 3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter6).
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3NpAhNs](https://bit.ly/3NpAhNs)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/3NpAhNs](https://bit.ly/3NpAhNs)
- en: Creating the data layer
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据层
- en: In this section, we will look at the data layer of an Android application and
    the components that typically form part of the data layer.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨 Android 应用程序的数据层以及通常构成数据层的组件。
- en: The data layer is the layer in which data is created and managed. This means
    that this layer is responsible for creating, reading, updating, and deleting data,
    as well as for managing and ensuring that data from the internet is synced with
    persistent data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 数据层是数据创建和管理的层。这意味着这一层负责创建、读取、更新和删除数据，以及管理和确保来自互联网的数据与持久数据同步。
- en: In the previous chapter, we have seen that use cases depend on an abstraction
    of a repository class, and there can be multiple repositories for different data
    types. Repositories represent the entry point into the data layer and are responsible
    for managing multiple data sources and centralizing the data. The data sources
    represent the other component of the data layer and are responsible for managing
    the data of a particular source (internet, Room, data store, and suchlike).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们了解到用例依赖于仓库类的抽象，并且可以为不同数据类型存在多个仓库。仓库代表数据层的入口点，并负责管理多个数据源并集中数据。数据源代表数据层的另一个组件，并负责管理特定来源的数据（互联网、Room、数据存储等）。
- en: 'An example of what the data layer for a particular set of data, which uses
    two data sources, might look like is shown in the following figure:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 下图展示了特定数据集的数据层示例，该数据集使用两个数据源：
- en: '![Figure 6.1 – Data layer example'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.1 – 数据层示例'
- en: '](img/Figure_6.1_B18320.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.1_B18320.jpg)'
- en: Figure 6.1 – Data layer example
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.1 – 数据层示例
- en: 'In the preceding diagram, we have an example of what a data layer would look
    like when it is connected to the domain layer. We can observe that the `UseCase`
    class depends on a `Repository` abstraction, which represents the domain layer.
    The data layer is represented by `RepositoryImpl`, which is the implementation
    of the `Repository` abstraction. The `RepositoryImpl` class depends on the two
    data source implementations: `RemoteDataSourceImpl` and `LocalDataSourceImpl`.
    Each data source then depends on a particular implementation for managing data
    from the internet using Retrofit in the case of `RetrofitService`, or using a
    particular data access class that uses Room in the case of `DbDao`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们有一个数据层连接到领域层的示例。我们可以观察到 `UseCase` 类依赖于一个 `Repository` 抽象，它代表领域层。数据层由
    `RepositoryImpl` 表示，它是 `Repository` 抽象的实现。`RepositoryImpl` 类依赖于两个数据源实现：`RemoteDataSourceImpl`
    和 `LocalDataSourceImpl`。每个数据源随后依赖于特定实现来管理来自互联网的数据，在 `RetrofitService` 的情况下使用 Retrofit，或者在
    `DbDao` 的情况下使用特定的数据访问类。
- en: 'This approach poses a problem owing to the direct dependency between `RepositoryImpl`
    and `RemoteDataSourceImpl`, and the problem arises when we might want to swap
    out Retrofit or Room for alternatives. If we might want to swap out these libraries
    for others, we risk changes in the `RepositoryImpl` class, which violates the
    single-responsibility principle. The solution for this is like the solution we
    had for solving the dependencies between the use cases and the repositories, and
    that is to invert the dependencies between the repository and the data sources.
    This would look like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法由于 `RepositoryImpl` 和 `RemoteDataSourceImpl` 之间的直接依赖而存在问题，问题出现在我们可能想要用替代品替换
    Retrofit 或 Room 时。如果我们可能想要用其他库替换这些库，我们可能会在 `RepositoryImpl` 类中引起变化，这违反了单一职责原则。解决方案类似于我们解决用例和仓库之间依赖关系的解决方案，即反转仓库和数据源之间的依赖关系。这看起来将如下所示：
- en: '![Figure 6.2 – Data layer with inverted dependencies'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.2 – 倒置依赖的数据层'
- en: '](img/Figure_6.2_B18320.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.2_B18320.jpg)'
- en: Figure 6.2 – Data layer with inverted dependencies
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.2 – 倒置依赖的数据层
- en: 'In the preceding diagram, we have introduced two abstractions for each data
    source, named `RemoteDataSource` and `LocalDataSource`. `RepositoryImpl` now depends
    on these two abstractions and all the conversions between Retrofit- or Room-related
    objects and domain entities should now be placed in `RemoteDataSourceImpl` or
    `LocalDataSourceImpl`, which inherit the new abstractions and will continue to
    handle the data from Retrofit or Room. If we want to split the data layer into
    different Gradle modules, we will have the following:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图示中，我们为每个数据源引入了两个抽象，分别命名为 `RemoteDataSource` 和 `LocalDataSource`。`RepositoryImpl`
    现在依赖于这两个抽象，并且所有 Retrofit 或 Room 相关对象与领域实体之间的转换现在应放置在 `RemoteDataSourceImpl` 或
    `LocalDataSourceImpl` 中，这些实现继承新的抽象并将继续处理 Retrofit 或 Room 的数据。如果我们想将数据层拆分为不同的 Gradle
    模块，我们将有以下情况：
- en: '![Figure 6.3 – Data layer modules'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 6.3 – 数据层模块'
- en: '](img/Figure_6.3_B18320.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.3_B18320.jpg)'
- en: Figure 6.3 – Data layer modules
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.3 – 数据层模块
- en: The preceding diagram shows the Gradle module dependencies between the repository
    and local and remote data sources. Here we can see the benefit of dependency inversion,
    which allows us to have a separate repository module without depending on Retrofit
    or Room.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示展示了仓库与本地和远程数据源之间的 Gradle 模块依赖关系。在这里，我们可以看到依赖反转的好处，它允许我们拥有一个独立的仓库模块，而不依赖于
    Retrofit 或 Room。
- en: In this section, we have discussed the data layer and the components inside
    it and how to manage the dependencies between all the components. In the following
    section, we will take a closer look at repositories and how to implement them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们讨论了数据层及其内部组件，以及如何管理所有组件之间的依赖关系。在下一节中，我们将更详细地探讨仓库及其实现方法。
- en: Creating repositories
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建仓库
- en: In this section, we will look at what a repository is and the role it plays
    in the data layer of an application, and how we can create repositories with various
    data sources.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨仓库是什么以及它在应用程序数据层中扮演的角色，以及我们如何使用各种数据源创建仓库。
- en: The repository represents an abstraction for the data than an application uses,
    and it is responsible for managing and centralizing the data from one or multiple
    data sources.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仓库代表应用程序使用的数据的抽象，它负责管理和集中化来自一个或多个数据源的数据。
- en: 'In the previous chapter, we defined the following entity:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们定义了以下实体：
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here we have a simple `User` data class with a few relevant fields. The repository
    abstraction for the `User` data is as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个简单的`User`数据类，包含一些相关字段。`User`数据的仓库抽象如下：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here we have an interface named `UserRepository` that is responsible for fetching
    the user information in a Kotlin flow.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个名为`UserRepository`的接口，它负责在Kotlin流中获取用户信息。
- en: 'If we want to fetch data from the internet, we must first define a `UserRemoteDataSource`
    abstraction:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从互联网上获取数据，我们必须首先定义一个`UserRemoteDataSource`抽象：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In this case, we have an interface similar to how `UserRepository` is defined
    with a simple method to retrieve a `User` object. We can now implement `UserRepository`
    to use this data source:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们有一个类似于`UserRepository`定义的接口，它有一个简单的`User`对象检索方法。现在我们可以实现`UserRepository`以使用此数据源：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here we have a dependency on `UserRemoteDataSource` and invoke the `getUser`
    method. If we want to persist the remote user data locally, we will need to define
    a `UserLocalDataSource` abstraction, which will be responsible for inserting the
    user:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个对`UserRemoteDataSource`的依赖，并调用`getUser`方法。如果我们想将远程用户数据本地持久化，我们需要定义一个`UserLocalDataSource`抽象，它将负责插入用户：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here we have a method for inserting a user into the local store. We can now
    update `UserRepositoryImpl` to connect the data sources and insert a user after
    it was retrieved:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个将用户插入本地存储的方法。现在我们可以更新`UserRepositoryImpl`以连接数据源，并在检索后插入用户：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This represents a simple use case for data sources, but we can use repositories
    to improve the user experience for the user. For instance, we can change the repository
    implementation to return the saved data and have a separate method for fetching
    the data remotely. We can take advantage of flows, which can emit multiple users
    in a stream:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这代表了一个简单的数据源使用案例，但我们可以使用仓库来提升用户体验。例如，我们可以更改仓库实现以返回保存的数据，并为远程获取数据提供一个单独的方法。我们可以利用流，它可以在流中发射多个用户：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we have added the `getUser` method to retrieve a
    `User` object, which was persisted locally. We will need to modify the repository
    abstraction as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了`getUser`方法来检索本地持久化的`User`对象。我们需要修改仓库抽象如下：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have added the `refreshUser` method, which, when implemented, will
    be responsible for fetching a new user from the internet. The implementation will
    be as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了`refreshUser`方法，当实现时，将负责从互联网上获取新用户。实现如下：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we return the persisted user in the `getUser` method and, in the `refreshUser`
    method, we now fetch the remote data and insert it locally. If we are using libraries
    such as Room, this will trigger the emission of a new `User` object, which will
    come from `UserLocalDataSource`. This means that all subscribers of the `getUser`
    method will be notified of a change and receive a new `User` object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在`getUser`方法中返回持久化的用户，在`refreshUser`方法中，我们现在获取远程数据并将其本地插入。如果我们使用Room等库，这将触发新的`User`对象的发射，该对象将来自`UserLocalDataSource`。这意味着所有`getUser`方法的订阅者都将收到更改通知并接收一个新的`User`对象。
- en: 'We can also use repositories for caching data in the memory. An example of
    this would be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用仓库在内存中缓存数据。以下是一个例子：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we have added a new `MutableStateFlow` object, which will hold a map in
    which the keys are represented by the user IDs and the values are the users. In
    the `getUser` method, we check whether the user is stored in memory and return
    the memory value if present, otherwise we get the persisted data, which we will
    store in memory after. In the `refreshUser` method, we persist the value in memory
    and persist the data locally.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个新的`MutableStateFlow`对象，它将持有一个映射，其中键由用户ID表示，值是用户。在`getUser`方法中，我们检查用户是否存储在内存中，如果存在则返回内存值，否则我们获取持久化数据，之后将其存储在内存中。在`refreshUser`方法中，我们将值持久化并本地持久化数据。
- en: Because we defined the repository abstraction to return entities, we should
    try as much as possible to use entities across the repository and the data source
    abstractions. However, we might need specific object definitions to handle processing
    the data from the data sources. We can define these specific classes in this layer
    and then convert them to entities in the repository implementation.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们定义了仓库抽象以返回实体，我们应该尽可能在仓库和数据源抽象中使用实体。然而，我们可能需要特定的对象定义来处理从数据源获取的数据。我们可以在这一层定义这些特定的类，然后将其转换为仓库实现中的实体。
- en: In this section, we have seen how we can create repositories and how they can
    be used to manage data in an application. In the section that follows, we will
    look at an exercise in which we will create repositories for an application.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何创建仓库以及它们如何被用来管理应用程序中的数据。在接下来的章节中，我们将查看一个练习，我们将为应用程序创建仓库。
- en: Exercise 06.01 – Creating repositories
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 06.01 – 创建仓库
- en: 'Modify *Exercise 05.01: Building a domain layer*, so that a new library module
    is created in Android Studio. The module will be named `data-repository` and will
    have a dependency on the `domain` module. In this module, we will implement the
    repository classes from the domain module as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *练习 05.01：构建领域层*，以便在 Android Studio 中创建一个新的库模块。该模块将命名为 `data-repository`，并将依赖于
    `domain` 模块。在此模块中，我们将实现领域模块中的仓库类，如下所示：
- en: '`UserRepositoryImpl` will have dependencies on the following data sources:
    `UserRemoteDataSource`, which will fetch a list and a user by ID, and `UserLocalDataSource`,
    which will have methods for inserting a list of users and obtaining a list of
    the same. `UserRepositoryImpl` will always load the remote users and insert them
    locally.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UserRepositoryImpl` 将依赖于以下数据源：`UserRemoteDataSource`，它将获取列表和按 ID 获取用户，以及 `UserLocalDataSource`，它将包含插入用户列表和获取相同列表的方法。`UserRepositoryImpl`
    将始终加载远程用户并将它们本地化。'
- en: '`PostRepositoryImpl` will have dependencies on the following data sources:
    `PostRemoteDataSource`, which will fetch a list of users and a user by ID, and
    `PostLocalDataSource`, which will have methods for inserting a list of posts and
    obtaining a list of the same. `PostRepositoryImpl` will always load the remote
    posts and insert them locally.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PostRepositoryImpl` 将依赖于以下数据源：`PostRemoteDataSource`，它将获取用户列表和按 ID 获取用户，以及
    `PostLocalDataSource`，它将包含插入帖子列表和获取相同列表的方法。`PostRepositoryImpl` 将始终加载远程帖子并将它们本地化。'
- en: '`InteractionRepositoryImpl` will have a dependency on a single data source,
    `LocalInteractionDataSource`, which will be responsible for loading an interaction
    and saving it. `InteractionRepositoryImpl` will load the interaction and save
    a new interaction.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InteractionRepositoryImpl` 将依赖于单一的数据源 `LocalInteractionDataSource`，它将负责加载交互并保存。`InteractionRepositoryImpl`
    将加载交互并保存一个新的交互。'
- en: 'To complete this exercise, you will need to do the following:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此练习，你需要执行以下操作：
- en: Create the data repository module in Android Studio
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建数据仓库模块
- en: Create the user's data sources and repository
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用户的数据源和仓库
- en: Create the post's data sources and repository
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建帖子的数据源和仓库
- en: Create the interaction data source and repository
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建交互数据源和仓库
- en: 'Follow these steps to complete the exercise:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create a new module named `data-repository`, which will be an Android Library
    module.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `data-repository` 的新模块，它将是一个 Android 库模块。
- en: 'Make sure that in the top-level `build.gradle` file, the following dependencies
    are set:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在顶级 `build.gradle` 文件中，以下依赖项已设置：
- en: '[PRE10]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `build.gradle` file of the `data-repository` module, make sure that
    the following plugins are present:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `data-repository` 模块的 `build.gradle` 文件中，确保以下插件存在：
- en: '[PRE11]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the same file, change the configurations to the ones defined in the top-level
    `build.gradle` file:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，将配置更改为顶级 `build.gradle` 文件中定义的配置：
- en: '[PRE12]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the same file, make sure that the following dependencies are specified:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，确保以下依赖项已指定：
- en: '[PRE13]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we are using the `implementation` method to add a dependency to the `:domain`
    module, in the same way as other libraries are referenced. In Gradle we also have
    the option of using the `api` method. This makes a module's dependencies public
    to other modules. This, in turn, might have potential side effects, such as leaking
    dependencies that should be kept private. In this example, we might be better
    served by using the `api` method for the `:domain` module because of the close
    relationship between the two modules (which would make all modules that depend
    on `:data-repository` not have to add the dependency to `:domain`). However, dependencies
    such as Hilt and Coroutines should be kept with the implementation method because
    we would want to avoid exposing these libraries in modules that do not use them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`implementation`方法向`:domain`模块添加依赖，就像其他库被引用一样。在Gradle中，我们也有使用`api`方法的选项。这使得模块的依赖对其他模块是公开的。这反过来可能会产生潜在的副作用，例如泄露应该保持私有的依赖。在这个例子中，由于两个模块之间关系紧密（这将使得所有依赖于`:data-repository`的模块不必添加对`:domain`的依赖），使用`api`方法对`:domain`模块可能更有帮助。然而，像Hilt和Coroutines这样的依赖应该使用`implementation`方法，因为我们希望避免在未使用这些库的模块中暴露这些库。
- en: In the `data-repository` module, create a new package named `data_source`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data-repository`模块中，创建一个名为`data_source`的新包。
- en: In the `data_source` package, create a new package named `remote`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data_source`包内，创建一个名为`remote`的新包。
- en: 'In the `remote` package, create the `RemoteUserDataSource` interface:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`remote`包内，创建`RemoteUserDataSource`接口：
- en: '[PRE14]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the `remote` package, create the `RemotePostDataSource` interface:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`remote`包内，创建`RemotePostDataSource`接口：
- en: '[PRE15]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the `data_source` package, create a new package called `local`.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data_source`包内，创建一个名为`local`的新包。
- en: 'In the `local` package, create the `LocalUserDataSource` interface:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local`包内，创建`LocalUserDataSource`接口：
- en: '[PRE16]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the `local` package, create the `LocalPostDataSource` interface:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local`包内，创建`LocalPostDataSource`接口：
- en: '[PRE17]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the `local` package, create the `LocalInteractionDataSource` package:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`local`包内，创建`LocalInteractionDataSource`包：
- en: '[PRE18]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Next to the `data_source` package, create a new package named `repository`.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`data_source`包旁边，创建一个名为`repository`的新包。
- en: 'In the `repository` package, create the `UserRepositoryImpl` class:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`repository`包内，创建`UserRepositoryImpl`类：
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we fetch the user data from the remote data source and store it locally.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从远程数据源获取用户数据并将其存储在本地。
- en: 'In the same package, create the `PostRepositoryImpl` class:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包内，创建`PostRepositoryImpl`类：
- en: '[PRE20]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here, we are fetching the post data from the remote data source and using the
    local data source to persist the data.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们从远程数据源获取帖子数据，并使用本地数据源来持久化数据。
- en: 'In the same package, create the `InteractionRepositoryImpl` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一个包内，创建`InteractionRepositoryImpl`类：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are just interacting with the local data source to read and store the
    data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是与本地数据源交互来读取和存储数据。
- en: We now want to use Hilt to bind the repository abstraction with the implementation,
    so we will need to create a package named `injection` next to the `data_source`
    and `repository` packages.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在想使用Hilt将仓库抽象与实现绑定，因此我们需要在`data_source`和`repository`包旁边创建一个名为`injection`的新包。
- en: 'Inside the `injection` package, create a class named `RepositoryModule`:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`injection`包内，创建一个名为`RepositoryModule`的类：
- en: '[PRE22]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using the `@Binds` Hilt annotation, which maps the implementation
    of a repository annotated with `@Inject` with the abstraction.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@Binds` Hilt注解，它将带有`@Inject`注解的仓库实现与抽象映射。
- en: To unit test the code, we will now need to create a new folder called `resources`
    in the test folder of the `data-repository` module.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了对代码进行单元测试，我们现在需要在`data-repository`模块的测试文件夹中创建一个名为`resources`的新文件夹。
- en: 'Inside the resources folder, create a folder called `mockito-extensions` and,
    inside this folder, create a file named `org.mockito.plugins.MockMaker`, and,
    inside this file, add the following text: `mock-maker-inline`.'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在资源文件夹内，创建一个名为`mockito-extensions`的文件夹，在这个文件夹内创建一个名为`org.mockito.plugins.MockMaker`的文件，并在该文件内添加以下文本：`mock-maker-inline`。
- en: 'Create a `UserRepositoryImplTest` class for unit testing the `UserRepositoryImpl`
    methods:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`UserRepositoryImpl`方法创建一个`UserRepositoryImplTest`类进行单元测试：
- en: '[PRE23]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'In the `UserRepositoryImplTest` class, add a test method for each repository
    method:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`UserRepositoryImplTest`类中，为每个仓库方法添加一个测试方法：
- en: '[PRE24]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this class, we unit test each of the methods in the `UserRepositoryImpl`
    class by mocking the local data and remote data sources and verifying that the
    data obtained from the remote data source is inserted into the local data source.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们通过模拟本地数据和远程数据源，并验证从远程数据源获取的数据是否被插入到本地数据源中，对`UserRepositoryImpl`类中的每个方法进行单元测试。
- en: 'Create a `PostRepositoryImplTest` class to test the `PostRepositoryImpl` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`PostRepositoryImplTest`类来测试`PostRepositoryImpl`类：
- en: '[PRE25]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create unit tests for each of the methods in the `PostRepositoryImpl` class:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`PostRepositoryImpl`类中的每个方法创建单元测试：
- en: '[PRE26]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this class, we perform the same tests that we did for `UserRepositoryImpl`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们执行了为`UserRepositoryImpl`执行的相同测试。
- en: 'Create an `InteractionRepositoryImplTest` class to test the `InteractionRepositoryImpl`
    class:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`InteractionRepositoryImplTest`类来测试`InteractionRepositoryImpl`类：
- en: '[PRE27]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Create unit tests for each of the methods in the `InteractionRepositoryImpl`
    class:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`InteractionRepositoryImpl`类中的每个方法创建单元测试：
- en: '[PRE28]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this class, we mock the local data source and then we verify that the repository
    has the appropriate invocations on the `LocalInteractionDataStore` mock.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们模拟本地数据源，然后验证仓库对`LocalInteractionDataStore`模拟的适当调用。
- en: 'If we run the tests, we should see something like the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，我们应该看到以下截图类似的内容：
- en: '![Figure 6.4 – Output of the repository unit tests'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '![图6.4 – 仓库单元测试的输出'
- en: '](img/Figure_6.4_B18320.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_6.4_B18320.jpg)'
- en: Figure 6.4 – Output of the repository unit tests
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.4 – 仓库单元测试的输出
- en: In this exercise, we have created a new module in which we implemented our repositories
    and defined new abstractions for the data sources that the repositories will use.
    Here, we have continued the integration with other libraries, such as Hilt for
    dependency injection, and Kotlin flows to handle the data in a reactive approach.
    The use of dependency injection made the unit tests simple to write because we
    could easily provide mocks.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们在一个新模块中实现了我们的仓库，并为仓库将使用的源定义了新的抽象。在这里，我们继续与其他库的集成，例如Hilt用于依赖注入，以及Kotlin
    flows以响应式方法处理数据。依赖注入的使用使得单元测试的编写变得简单，因为我们能够轻松提供模拟。
- en: Summary
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started looking into the data layer of an Android application
    and provided an overview of the components that are part of this layer. We also
    looked at the Repository component, which is responsible for managing the data
    provided by one or more data sources, and provided examples of how we could build
    different repositories. We also looked at the relationship between repositories
    and data sources and how we can further decouple the components with dependency
    inversion, to keep our repositories unaffected by changes in libraries used to
    fetch data. Finally, we looked at an exercise on how we can build repositories
    with local and remote data sources. In the following chapter, we will continue
    with the data layer and how we can integrate the remote and local data sources
    with libraries such as Room and Retrofit.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始探讨Android应用程序的数据层，并概述了该层包含的组件。我们还研究了负责管理一个或多个数据源提供的数据的仓库组件，并提供了构建不同仓库的示例。我们还探讨了仓库和数据源之间的关系，以及我们如何通过依赖倒置进一步解耦组件，以保持我们的仓库不受用于获取数据的库的变化影响。最后，我们查看了一个关于如何使用本地和远程数据源构建仓库的练习。在下一章中，我们将继续探讨数据层，以及我们如何使用Room和Retrofit等库集成远程和本地数据源。
