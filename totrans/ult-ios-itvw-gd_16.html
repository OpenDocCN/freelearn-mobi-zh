<html><head></head><body>
		<div><h1 id="_idParaDest-237" class="chapter-number"><a id="_idTextAnchor360" class="calibre6 pcalibre pcalibre1"/>12</h1>
			<h1 id="_idParaDest-238" class="calibre5"><a id="_idTextAnchor361" class="calibre6 pcalibre pcalibre1"/>Drilling into App Architecture</h1>
			<p class="calibre3">In the last chapter, we discussed an important topic – design patterns. We said that design patterns are repeatable solutions that solve common problems. We can also say that design patterns are the building blocks of our code. Before looking at design patterns in this book, we went over Swift, then built upon it with the design patterns. Now we are at the top level – the app architecture.</p>
			<p class="calibre3"><strong class="bold">App architecture</strong> is a critical <a id="_idIndexMarker919" class="calibre6 pcalibre pcalibre1"/>topic in interviews, not just in the architecture design interview. Architecture discussions can happen <em class="italic">earlier</em>, even in the first stage. For example, the interviewer can ask about our previous projects and how we built them. Understanding the basic terminology and having the skills to use them in our interview is essential.</p>
			<p class="calibre3">But don’t worry because in this chapter, we will go over the most fundamental principles of mobile architecture:</p>
			<ul class="calibre10">
				<li class="calibre11">We’ll go over the <strong class="bold">Separation of Concerns</strong> (<strong class="bold">SoC</strong>) principle</li>
				<li class="calibre11">We’ll cover some <em class="italic">great tips</em> for separation in our code</li>
				<li class="calibre11">We’ll learn how to <em class="italic">break our app into layers</em> and how data flows between them</li>
				<li class="calibre11">We’ll talk about the <em class="italic">design interview</em>, how to approach it, and how to communicate with the interviewer</li>
			</ul>
			<p class="calibre3">We’ve almost reached the end of the book, and as you’ll have learned by now, I like to start with the basics, as it helps me to explain complex topics much better. The basics of app architecture is the SoC principle.</p>
			<h1 id="_idParaDest-239" class="calibre5"><a id="_idTextAnchor362" class="calibre6 pcalibre pcalibre1"/>All about the Separation of Concerns principle</h1>
			<p class="calibre3">I have <a id="_idIndexMarker920" class="calibre6 pcalibre pcalibre1"/>mentioned the <strong class="bold">SoC principle</strong> in the book several times. In fact, I mentioned this principle many times in my previous books and articles as well. In a way, the SoC principle sits at the heart of many design patterns and architectural decisions, and for a pretty good reason. Before we dive into understanding why, let’s try to understand what SoC means.</p>
			<h2 id="_idParaDest-240" class="calibre7"><a id="_idTextAnchor363" class="calibre6 pcalibre pcalibre1"/>Defining the Separation of Concerns principle</h2>
			<p class="calibre3">We’ll begin with defining what SoC is. SoC refers to organizing code to separate different functionalities <a id="_idIndexMarker921" class="calibre6 pcalibre pcalibre1"/>into different objects and owners. It means that a class or a module must have one and only one responsibility.</p>
			<p class="calibre3">Look at the following example:</p>
			<pre class="source-code">
func processUserData(userData: [String: Any]) {        // Responsibility 1: Validate the data
        guard let name = userData["name"] as? String,
            !name.isEmpty,
              let age = userData["age"] as? Int, age &gt; 0,
              let email = userData["email"] as? String,
                  !email.isEmpty else {
            print("Invalid user data")
            return
        }
        // Responsibility 2: Save the data to a file
        let documentsDirectory = FileManager.
            default.urls(for: .documentDirectory, in:
                .userDomainMask).first!
        let fileURL = documentsDirectory.
            appendingPathComponent("userData.txt")
        let userDataString = "Name: \(name)\nAge:
            \(age)\nEmail: \(email)\n"
        do {
            try userDataString.write(to: fileURL,
                atomically: true, encoding: .utf8)
            print("User data saved to file.")
        } catch {
            print("Error saving user data to file: \(error)")
        }
        // Responsibility 3: Send a welcome email
        print("Sending welcome email to: \(email)")
    }
}</pre>
			<p class="calibre3">In our <a id="_idIndexMarker922" class="calibre6 pcalibre pcalibre1"/>code example, we can see that the <code>processUserData</code> function has three different responsibilities:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Validate</em> the user data</li>
				<li class="calibre11"><em class="italic">Save</em> the user data to a file</li>
				<li class="calibre11"><em class="italic">Send</em> a welcome email to the user</li>
			</ul>
			<p class="calibre3">Notice that the <a id="_idIndexMarker923" class="calibre6 pcalibre pcalibre1"/>problem starts earlier – the name <code>processUserData</code> indicates that the function has an unclear responsibility.</p>
			<p class="calibre3">Separating the function into three different functions – <code>validateUserData</code>, <code>saveUserDataToFile</code>, and <code>sendWelcomeEmail</code> – would be an excellent solution to fix the problem of unclearness.</p>
			<p class="calibre3">The SoC <a id="_idIndexMarker924" class="calibre6 pcalibre pcalibre1"/>principle applies to functions and variables – a variable should have its own responsibility, just like functions and classes.</p>
			<p class="calibre3">Take the following example:</p>
			<pre class="source-code">
class BadSoCExample {    var name: String
    init(name: String) {
        self.name = name
    }
    func printFullName(firstName: String, lastName: String) {
        name = firstName
        print("First name: \(name)")
        name = lastName
        print("Last name: \(name)")
        print("Full name: \(firstName) \(name)")
    }
}
let example = BadSoCExample(name: "John Doe")
example.printFullName(firstName: "John", lastName: "Doe")</pre>
			<p class="calibre3">In this example, we use <code>name</code> to store both first and last names instead of creating two dedicated variables – <code>firstName</code> and <code>lastName</code>. These bad practices often happen when trying to save time, but they are error-prone and can lead to issues.</p>
			<p class="calibre3">We can see <a id="_idIndexMarker925" class="calibre6 pcalibre pcalibre1"/>that the SoC principle is a relevant factor in all levels of development, from variables, functions, and classes up to modules.</p>
			<p class="calibre3">But…why is it so important? Let’s see.</p>
			<h2 id="_idParaDest-241" class="calibre7"><a id="_idTextAnchor364" class="calibre6 pcalibre pcalibre1"/>Explaining the importance of SoC</h2>
			<p class="calibre3">Now that <a id="_idIndexMarker926" class="calibre6 pcalibre pcalibre1"/>we know what the SoC principle is, it is time to understand why it is important when designing and writing code.</p>
			<p class="calibre3">There are a few reasons why we want to have a single responsibility for every part of our app and every variable. Let’s name some of them:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Making our code more explicit</em>: When each part focuses on a single task, it is easier for us (and others) to understand what’s happening. Clarity is also critical with debugging and code investigation – here’s a quote from Brian Kernighan: “<em class="italic">Debugging is twice as hard as writing the code in the first place. Therefore if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it</em>.” The only way to reduce the gap between writing and debugging is clarity.</li>
				<li class="calibre11"><em class="italic">Maintaining the code becomes easier</em>: We all know writing code is easier than maintaining it. One of the reasons is that every code modification we perform can create a new bug. Moreover, modifications often change the code structure to something we hadn’t planned when writing it. We are reducing both risks when isolating tasks to specific functions or classes.</li>
				<li class="calibre11"><em class="italic">Increase our code reusability</em>: This is another important benefit of the SoC principle. When a view, a controller, or a module has a specific task and responsibility, it makes it easier to reuse. Let’s take, for instance, a library that handles text manipulation. Adding more features and capabilities to that library may increase its dependencies and side effects. It also makes it bigger and more error-prone since it now handles more responsibilities irrelevant to what we need and may collide with another library we want to link. Separating part of the library from another is smarter and allows us to work with different libraries like LEGO pieces.</li>
				<li class="calibre11"><em class="italic">Improve our code testability</em>: One of the critical aspects of testing is ensuring that the outcomes are predictable. When a method is responsible for multiple tasks, it might reduce its predictability over time. Think of a function that returns a computed value and updates user defaults. Testing the function’s returned value can have side effects we don’t want in our test use case. It is better to separate that calculation into another function and test it separately.</li>
			</ul>
			<p class="calibre3">These benefits <a id="_idIndexMarker927" class="calibre6 pcalibre pcalibre1"/>are the foundation of any design pattern or architectural decision we make when working on our projects. Moreover, SoC is an essential principle to follow when approaching an architectural task in an interview. It is the basis for any professional discussion we may have during our interviews.</p>
			<p class="calibre3">Now, let’s dive a bit deeper and look at some practical tips for the SoC principle.</p>
			<h2 id="_idParaDest-242" class="calibre7"><a id="_idTextAnchor365" class="calibre6 pcalibre pcalibre1"/>Going practical with the Separation of Concerns principle</h2>
			<p class="calibre3">This chapter aims to prepare us for the architectural interview, which may contain whiteboard <a id="_idIndexMarker928" class="calibre6 pcalibre pcalibre1"/>tasks and professional discussions. We understand the SoC principle’s importance, but how do we transform it into practical tools?</p>
			<p class="calibre3">The good news is that we reviewed these tools in previous chapters. Let’s list them now and add some more.</p>
			<h3 class="calibre9">Having a clear understanding of using UI design patterns</h3>
			<p class="calibre3">I do not <a id="_idIndexMarker929" class="calibre6 pcalibre pcalibre1"/>doubt that the topic of MVVM or MVC will be central in your interviews. What’s important here is to really understand the different components and their responsibility. If we decide to use MVVM for our screen, we must ensure that we do it because we need to manage a complex state and not because “this is how things are done today.” We must ensure we use the right tool for the right job and that each component performs its role.</p>
			<p class="calibre3">To help understand this, look at <em class="italic">Figure 12</em><em class="italic">.1</em>:</p>
			<div><div><img src="img/Figure_12.01_B18653.jpg" alt="Figure 12.1 – The most popular UI design patterns in iOS" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The most popular UI design patterns in iOS</p>
			<p class="calibre3">In <em class="italic">Figure 12</em><em class="italic">.1</em>, we can see that our selection of design patterns is broader than just MVC and MVVM. Furthermore, there are no rules here, just best practices. Choosing the correct <a id="_idIndexMarker930" class="calibre6 pcalibre pcalibre1"/>design pattern while considering the different responsibilities and separations is essential to implementing the SoC principle.</p>
			<p class="calibre3">For example, VIPER can be incredible for screens that work with many services and data entities, and MVP is suitable for a UI that focuses on formatting and presentation tweaks.</p>
			<p class="callout-heading">VIPER and MVP?</p>
			<p class="callout">I won’t go over VIPER and MVP because they are less common design patterns in iOS development than MVC and MVVM. I recommended reading about these patterns and learning the pros and cons, so you have broader knowledge for your interview.</p>
			<p class="callout">Here are <a id="_idIndexMarker931" class="calibre6 pcalibre pcalibre1"/>some great <a id="_idIndexMarker932" class="calibre6 pcalibre pcalibre1"/>reads on VIPER and MVP:</p>
			<p class="callout">- VIPER: <a href="https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern" class="calibre6 pcalibre pcalibre1">https://www.kodeco.com/8440907-getting-started-with-the-viper-architecture-pattern</a></p>
			<p class="callout">- MVP: <a href="https://www.javatpoint.com/ios-model-view-presenter" class="calibre6 pcalibre pcalibre1">https://www.javatpoint.com/ios-model-view-presenter</a></p>
			<h3 class="calibre9">Using Clean Architecture</h3>
			<p class="calibre3">Later, in the <em class="italic">Designing app architecture</em> section, we will discuss app architecture, but for now, we are just laying the <a id="_idIndexMarker933" class="calibre6 pcalibre pcalibre1"/>groundwork, and <strong class="bold">Clean Architecture</strong> serves as a great foundation. So, what is Clean Architecture?</p>
			<p class="calibre3">Clean <a id="_idIndexMarker934" class="calibre6 pcalibre pcalibre1"/>Architecture is an architectural approach emphasizing the SoC principle when developing a full-blown app. It involves dividing our project into layers – the data layer, presentation layer, business logic layer, and network layer – and pushes for clean SoC between the different layers and components. If we take that even further, we’re discussing creating various libraries for other parts of the project and trying to make our app feel like a giant puzzle. Notice that breaking our app into modules has a price – maintaining different modules can be difficult and requires planning and sometimes complex interface decisions. We must always consider the trade-off between a stable structure and a complicated interface.</p>
			<h3 class="calibre9">Writing small functions</h3>
			<p class="calibre3">This is a <a id="_idIndexMarker935" class="calibre6 pcalibre pcalibre1"/>tip most of us have heard several times before. They say a function length should be “less than a screen,” but if we want to go extreme, we can say that functions should be <em class="italic">as small as possible</em>. Breaking a long function into two/three functions is a good idea to make our code cleaner, less error-prone, and easier to maintain.</p>
			<p class="calibre3">Look at the following code example:</p>
			<pre class="source-code">
func calculateTotalPrice(itemPrices: [Double],    itemQuantities: [Int]) -&gt; Double {
    var totalPrice = 0.0
    for i in 0..&lt;itemPrices.count {
        totalPrice += itemPrices[i] * Double (itemQuantities[i])
    }
    return totalPrice
}</pre>
			<p class="calibre3">While <a id="_idIndexMarker936" class="calibre6 pcalibre pcalibre1"/>this function works, it has multiple responsibilities – it iterates the list of items and calculates their prices. To improve the SoC, we can separate this code into another function that calculates a single item’s price:</p>
			<pre class="source-code">
func <strong class="bold1">calculateItemPrice</strong>(price: Double, quantity: Int) -&gt; Double {    return price * Double(quantity)
}
func calculateTotalPrice(itemPrices: [Double],
    itemQuantities: [Int]) -&gt; Double {
    var totalPrice = 0.0
    for i in 0..&lt;itemPrices.count {
        totalPrice += <strong class="bold1">calculateItemPrice</strong>(price:
            itemPrices[i], quantity: itemQuantities[i])
    }
    return totalPrice
}</pre>
			<p class="calibre3">Now we have a dedicated function to calculate a specific item price, and we use it in the original <code>calculateTotalPrice()</code> function. Small modification? Well, regarding code design, that’s a dramatic change – we can test the calculation separately and reuse it in other places in our code. Also, the code is more readable, and the <code>calculateItemPrice()</code> function name also saves us from explaining what <code>price*Double(quantity)</code> does and even avoids unneeded comments.</p>
			<p class="calibre3">It’s interesting to see that even though the original function was small and worked well, we can <a id="_idIndexMarker937" class="calibre6 pcalibre pcalibre1"/>still break it and improve our code in several aspects. That’s why the phrase “as small as possible” is much more accurate.</p>
			<h3 class="calibre9">Using descriptive names</h3>
			<p class="calibre3">Descriptive names are always a good idea, but how does naming help us have good, clean, and separated code?</p>
			<p class="calibre3">Naming has <a id="_idIndexMarker938" class="calibre6 pcalibre pcalibre1"/>a secret power – it forces us to think about the responsibility of our function and describe precisely what it does. The attention we give it can help us make the right design decisions.</p>
			<p class="calibre3">Here’s an example – look at the next function interface:</p>
			<pre class="source-code">
func getProducts() -&gt; [Product] {}</pre>			<p class="calibre3">It’s clear that <code>getProducts()</code> is supposed to fetch and return products. But what exactly does it do? Does it load the products from local data storage or use a network request?</p>
			<p class="calibre3">Let’s improve the function name:</p>
			<pre class="source-code">
func retrieveProductsFromServer() -&gt; [Product] {}</pre>			<p class="calibre3">Now, things have become more apparent. We understand exactly what the function does. But the issue is unclear – our question about the function’s job helped us think deeply about its responsibility. Maybe originally, we came up with the following name:</p>
			<pre class="source-code">
func retrieveProductsFromServerAndSaveThemToDB() -&gt; [Proudct] {}</pre>			<p class="calibre3">That’s a great indication we need to break the function since describing its responsibility becomes long and cumbersome.</p>
			<p class="calibre3">Here are some more examples of good naming:</p>
			<pre class="source-code">
fetchData() -&gt; fetchUserDataFromServer()calculate() -&gt; calculateAvrageSalary()
validate() -&gt; validatePasswordStrength()
add() -&gt; addItemToCart()
load() -&gt; loadDataFromCache()</pre>
			<p class="calibre3">Coming to <a id="_idIndexMarker939" class="calibre6 pcalibre pcalibre1"/>the interview process with naming conventions in mind is a good idea. And you know what? You’ll have written hundreds (if not more) functions in your life. You just need to think back and reflect on them. Maybe we’ll learn something using our code.</p>
			<p class="callout-heading">Here’s a disclaimer!</p>
			<p class="callout">I know some tips here are not about “architecture.” But these principles and recommendations are relevant at any level.</p>
			<p class="calibre3">SoC lays the groundwork for designing a scalable, modular, and maintainable app architecture. We can move on to designing app architecture now that we understand that.</p>
			<h1 id="_idParaDest-243" class="calibre5"><a id="_idTextAnchor366" class="calibre6 pcalibre pcalibre1"/>Designing app architecture</h1>
			<p class="calibre3">One of the <a id="_idIndexMarker940" class="calibre6 pcalibre pcalibre1"/>most common mistakes candidates make when asked about app architecture is replying, “MVVM, of course!”</p>
			<p class="calibre3">So, I want to remind you – MVVM is a design pattern, not an architecture, and I want to emphasize the difference.</p>
			<p class="calibre3">A design pattern is a reusable solution to a common problem. Dependency Injection, Singletons, and MVVM are examples of design patterns. On the other hand, architecture is the general structure of our project that represents our app idea.</p>
			<p class="calibre3">An excellent real-world example is a building. In this case, the architecture describes the number of floors, where the parking lot and the entry door are, or what type of roof we have. Design patterns describe <em class="italic">how each apartment is built</em> – the number of rooms in each apartment, the kitchen’s location, and the electrical wiring.</p>
			<p class="calibre3">We can say that each apartment and floor could be designed differently – meaning we can use different design patterns for various<a id="_idTextAnchor367" class="calibre6 pcalibre pcalibre1"/> problems and needs.</p>
			<p class="calibre3">Valuable insights <a id="_idIndexMarker941" class="calibre6 pcalibre pcalibre1"/>can be gained by drawing parallels with the building industry, as there are many similarities between constructing an application and building structures.</p>
			<p class="calibre3">Instead of apartments, we have application screens; instead of a roof and lobby, we have application layers.</p>
			<p class="calibre3">So, let’s talk about application layers for a second.</p>
			<h2 id="_idParaDest-244" class="calibre7"><a id="_idTextAnchor368" class="calibre6 pcalibre pcalibre1"/>Breaking the architecture into application layers</h2>
			<p class="calibre3">The different layers of an app can be a good starting point for describing an app architecture. But what are layers?</p>
			<p class="calibre3">Layers are <a id="_idIndexMarker942" class="calibre6 pcalibre pcalibre1"/>different components or sets of components that have different concerns and app responsibilities. Most apps work with three primary layers:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Presentation layer</strong>: Responsible for presenting information using a UI. We can find here <a id="_idIndexMarker943" class="calibre6 pcalibre pcalibre1"/>the different screens and UI components.</li>
				<li class="calibre11"><strong class="bold">Business logic layer</strong>: Responsible <a id="_idIndexMarker944" class="calibre6 pcalibre pcalibre1"/>for the app logic, rules, and calculations.</li>
				<li class="calibre11"><strong class="bold">Data layer</strong>: Responsible <a id="_idIndexMarker945" class="calibre6 pcalibre pcalibre1"/>for storing and retrieving data from local databases or other sources.</li>
			</ul>
			<p class="callout-heading">Layers or tiers?</p>
			<p class="callout">One common mistake people make when discussing layers is calling them “tiers.” The term “tiers” refer <a id="_idIndexMarker946" class="calibre6 pcalibre pcalibre1"/>to the physical component <a id="_idIndexMarker947" class="calibre6 pcalibre pcalibre1"/>of an application, while “layers” refers to the software component. For example, a tier can be a different computer or server responsible for a specific concern. In the case of an iOS app architecture, the term “tiers” is irrelevant unless we include the backend side.</p>
			<p class="calibre3">For a quick reminder, we’ll review design patterns – MVVM is an example of implementing <a id="_idIndexMarker948" class="calibre6 pcalibre pcalibre1"/>a screen as part of the presentation layer. A Singleton is a design pattern that can help us to implement a Core Data handler as part of the data layer.</p>
			<p class="calibre3">Let’s see a typical application architecture (<em class="italic">Figure 12</em><em class="italic">.2</em>):</p>
			<div><div><img src="img/Figure_12.02_B18653.jpg" alt="Figure 12.2 – A typical iOS app architecture" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.2 – A typical iOS app architecture</p>
			<p class="calibre3">Don’t be intimidated by the diagram in <em class="italic">Figure 12</em><em class="italic">.2</em> – remember, <em class="italic">we already know </em>that things need to be reorganized in our heads.</p>
			<p class="calibre3">We can see that the architecture in <em class="italic">Figure 12</em><em class="italic">.2</em> is separated into the three different layers we discussed earlier in this section:</p>
			<ul class="calibre10">
				<li class="calibre11">We can see <a id="_idIndexMarker949" class="calibre6 pcalibre pcalibre1"/>that the <em class="italic">presentation</em> layer has various technologies and design patterns.</li>
				<li class="calibre11">In the <em class="italic">business logic</em> layer, we have another design pattern – Façade, which is a design pattern <a id="_idIndexMarker950" class="calibre6 pcalibre pcalibre1"/>that provides a simplified interface to a complex and large code block. This is our entry point to the app logic. We can also see the different entities we work with in the business layer, the logic of the workflow, and the general app logic.</li>
				<li class="calibre11">In the <em class="italic">data layer</em>, we can <a id="_idIndexMarker951" class="calibre6 pcalibre pcalibre1"/>see different service agents (connectors) that can help us connect to various services. We can also see analytics and helper services.</li>
			</ul>
			<p class="calibre3">Underneath <a id="_idIndexMarker952" class="calibre6 pcalibre pcalibre1"/>the diagram, we have external services, such as the database, network, and configuration. These services are data sources for the data layer.</p>
			<p class="calibre3">The architecture diagram illustrates another aspect: how the data flows between the different layers, which we will see next.</p>
			<h2 id="_idParaDest-245" class="calibre7"><a id="_idTextAnchor369" class="calibre6 pcalibre pcalibre1"/>Learning about data flow</h2>
			<p class="calibre3">We understand that if the presentation layer needs to show information to the user, we need it to fetch <a id="_idIndexMarker953" class="calibre6 pcalibre pcalibre1"/>the information from the business layer all the way to the <a id="_idIndexMarker954" class="calibre6 pcalibre pcalibre1"/>data layer and the database. There are cases where we can have an app with more layers, such as notification, security, and persistence layers. In that case, the data flow gets a little more complex.</p>
			<p class="calibre3">One interesting question that may arise is whether it’s feasible for a layer to bypass another layer while retrieving data.</p>
			<p class="calibre3">Let’s try to answer that briefly.</p>
			<p class="calibre3">When designing a layered system, there are two terms that we need to learn – closed and open layers:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="bold">Closed layer</strong>: A closed layer <a id="_idIndexMarker955" class="calibre6 pcalibre pcalibre1"/>means the given layer cannot be bypassed to one of the layers below it</li>
				<li class="calibre11"><strong class="bold">Open layer</strong>: An open layer <a id="_idIndexMarker956" class="calibre6 pcalibre pcalibre1"/>means the given layer can be passed to any layer below it</li>
			</ul>
			<p class="calibre3">It is considered a best practice for a system to be fully closed or open, but in most cases, systems have <a id="_idIndexMarker957" class="calibre6 pcalibre pcalibre1"/>a mixture of open and closed layers.</p>
			<p class="calibre3">So, what are the benefits of having a closed or open layer?</p>
			<p class="calibre3">Look at <em class="italic">Figure 12</em><em class="italic">.3</em>:</p>
			<div><div><img src="img/Figure_12.03_B18653.jpg" alt="Figure 12.3 – Open and closed layers" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.3 – Open and closed layers</p>
			<p class="calibre3">In <em class="italic">Figure 12</em><em class="italic">.3</em>, we can see a system architecture with different layers and their dependencies. Layer B is closed, meaning layer A can’t access layers D and E. On the other hand, layer C is open, meaning that layer A can access layers F and G.</p>
			<p class="calibre3">The gray-filled layers are those layer A has access to, but it also means that these are dependencies.</p>
			<p class="calibre3">What the open layer does is increase coupling by exposing the top layers to more layers. On the other hand, closed layers are harder to maintain and require designing an excellent and flexible interface ahead of time. We already know that reducing the number of dependencies creates a loose and flexible system, but it doesn’t mean we need to create an overly complex design. This is an excellent example of a trade-off between simplicity and flexibility.</p>
			<p class="calibre3">What’s more important is to understand these terms when designing architecture and making decisions. Building a layered system without thinking at all is probably the worst thing we can do.</p>
			<p class="calibre3">Architecture <a id="_idIndexMarker958" class="calibre6 pcalibre pcalibre1"/>concepts combined with design patterns are the ground for designing good architecture for our projects.</p>
			<p class="calibre3">Let’s take a real-world example and review its design together.</p>
			<h2 id="_idParaDest-246" class="calibre7"><a id="_idTextAnchor370" class="calibre6 pcalibre pcalibre1"/>Designing an offline-first system architecture</h2>
			<p class="calibre3">An <strong class="bold">offline-first</strong> system <a id="_idIndexMarker959" class="calibre6 pcalibre pcalibre1"/>architecture is a typical design many interviewers like to discuss. The reason is that this use case involves working <a id="_idIndexMarker960" class="calibre6 pcalibre pcalibre1"/>with different data <a id="_idIndexMarker961" class="calibre6 pcalibre pcalibre1"/>sources and design patterns to achieve what seems to be an important advantage of having a mobile-native app instead of a web app.</p>
			<p class="calibre3">The way an offline-first system works is by having two data sources – a <em class="italic">persistent store</em> and <em class="italic">network</em> communication. On top of that, we have a <em class="italic">sync service</em> that is responsible for updating the persistent store with data from the network. The business logic layer that connects the UI to the data layer works directly with the persistent store, regardless of the network status.</p>
			<p class="calibre3">Let’s see a diagram of such a system (<em class="italic">Figure 12</em><em class="italic">.4</em>):</p>
			<div><div><img src="img/Figure_12.04_B18653.jpg" alt="Figure 12.4: Offline-first system architecture" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.4: Offline-first system architecture</p>
			<p class="calibre3">Looking at <em class="italic">Figure 12</em><em class="italic">.4</em>, we can see that <strong class="bold">Articles Handler</strong> on the business layer works directly with Core Data <em class="italic">without being aware</em> of the network layer. The sync service is the only component that links the Core Data store and the network.</p>
			<p class="calibre3">We provide <a id="_idIndexMarker962" class="calibre6 pcalibre pcalibre1"/>a superb user experience <a id="_idIndexMarker963" class="calibre6 pcalibre pcalibre1"/>to our users by adding offline loading. Besides that, we have an excellent implementation of the SoC principle with a decoupled system that makes its components totally disconnected.</p>
			<p class="calibre3">A typical implementation option candidates love to answer with in interviews is doing all the sync work in one class in the business logic or even as part of the view model. Sure, that option can work great, but this is a very narrow point of view when designing a system that can scale and be maintained over time. Having a dedicated service that can handle sync logic and maintain it separately is perfectly fine.</p>
			<p class="calibre3">It is always <a id="_idIndexMarker964" class="calibre6 pcalibre pcalibre1"/>important to remind ourselves <a id="_idIndexMarker965" class="calibre6 pcalibre pcalibre1"/>of the responsibility of every component in our system and how it communicates with other components. That can lead us to a better and clearer design.</p>
			<h1 id="_idParaDest-247" class="calibre5"><a id="_idTextAnchor371" class="calibre6 pcalibre pcalibre1"/>The architecture design interview</h1>
			<p class="calibre3">The architecture design interview is a crucial step toward our proposal, and it requires skills that are <a id="_idIndexMarker966" class="calibre6 pcalibre pcalibre1"/>much softer and communication oriented.</p>
			<p class="calibre3">Unlike Swift, Combine, and Core Data questions, the architecture design interview requires us to step forward and come up with a more holistic point of view – product requirements, backend, scale, analytics, and user experience are all factors we need to consider when trying to design a complete system.</p>
			<p class="calibre3">The architecture interview, perhaps even more than the other steps in the hiring process, is based on communication and meeting expectations. Therefore, we’ll start with understanding the interviewer’s point of view.</p>
			<h2 id="_idParaDest-248" class="calibre7"><a id="_idTextAnchor372" class="calibre6 pcalibre pcalibre1"/>Entering the head of our interviewer</h2>
			<p class="calibre3">So, what does our interviewer want from us? What are their expectations?</p>
			<p class="calibre3">The most important <a id="_idIndexMarker967" class="calibre6 pcalibre pcalibre1"/>thing to understand here is that the interviewer doesn’t care whether your answer is the most optimized solution, or even whether it’s right or wrong. The architecture design interview is definitely in another field, and the interviewer is looking for something else – they want to see how we <em class="italic">think</em>, approach problems, <em class="italic">manage trade-offs</em>, and find a path to a decent solution based on the product requirements.</p>
			<p class="calibre3">Let’s take, for<a id="_idTextAnchor373" class="calibre6 pcalibre pcalibre1"/> example, the following interview question:</p>
			<p class="author-quote">“Design the Messages app that comes with iOS.”</p>
			<p class="calibre3">Obviously, the top app feature would be the messaging screen (“chat”). Here is a list of issues we need to tackle when we approach that problem:</p>
			<ul class="calibre10">
				<li class="calibre11">What would the UI components we will use be?</li>
				<li class="calibre11">What is the data model? What will the properties of each message be?</li>
				<li class="calibre11">What endpoints do we need? Are we going to implement pagination? If not, how do we handle an endless number of messages?</li>
				<li class="calibre11">Do we support offline use? How are we going to do that?</li>
				<li class="calibre11">Do we support attachments? How is it going to work?</li>
				<li class="calibre11">What if we want to have a group chat?</li>
				<li class="calibre11">Are we going to support real-time updates?</li>
			</ul>
			<p class="calibre3">These are just some of the questions that arise when approaching this task, and none are straightforward. It’s our job to find the answers.</p>
			<p class="calibre3">So, how do we start?</p>
			<h2 id="_idParaDest-249" class="calibre7"><a id="_idTextAnchor374" class="calibre6 pcalibre pcalibre1"/>Approaching the mission</h2>
			<p class="calibre3">I’ve interviewed hundreds of candidates in my life, and many of them struggled to understand <a id="_idIndexMarker968" class="calibre6 pcalibre pcalibre1"/>how to approach an architecture interview.</p>
			<p class="calibre3">It’s not that they didn’t know how to design an app or explain their ideas – they didn’t know two things:</p>
			<ul class="calibre10">
				<li class="calibre11">What the starting point for the task was</li>
				<li class="calibre11">What their boundaries were</li>
			</ul>
			<p class="calibre3">These two topics are critical to understand for the interview to warm up and get on track to a great solution.</p>
			<p class="calibre3">Let’s begin with the starting point – understanding the problem and the scope.</p>
			<h3 class="calibre9">Understanding the problem and the scope</h3>
			<p class="calibre3">The first thing <a id="_idIndexMarker969" class="calibre6 pcalibre pcalibre1"/>we need to do when approaching a design question is to stop, breathe, and try to understand what the interviewer expects from us. Most candidates fail at this point because they know they have limited time to answer a question, so they rush up to scribble boxes on the whiteboard.</p>
			<p class="calibre3">But the design interview represents a real-life task. The interviewer expects us to understand the problem before describing what we do.</p>
			<p class="calibre3">Let’s return <a id="_idIndexMarker970" class="calibre6 pcalibre pcalibre1"/>to our problem – designing a messages app similar to the one that comes with iOS. Several questions we can ask the interviewer are as follows:</p>
			<ul class="calibre10">
				<li class="calibre11">Do we have a UI wireframe or must we produce it ourselves?</li>
				<li class="calibre11">How many screens do we have?</li>
				<li class="calibre11">Does the design need to contain the backend services as well?</li>
				<li class="calibre11">Is it cross-platform (including Android or web) or iOS only?</li>
				<li class="calibre11">Do we have a given database scheme, or do we need to plan it ourselves?</li>
			</ul>
			<p class="calibre3">These are just a few examples, but they can help us understand what we must do.</p>
			<p class="calibre3">Once we understand the problem and what to do, we can retrieve the product requirements.</p>
			<h3 class="calibre9">Getting the product requirements</h3>
			<p class="calibre3">Unlike <a id="_idIndexMarker971" class="calibre6 pcalibre pcalibre1"/>with conventional development tasks, we don’t have a <strong class="bold">Product Requirements Document</strong> (<strong class="bold">PRD</strong>) or a kickoff meeting <a id="_idIndexMarker972" class="calibre6 pcalibre pcalibre1"/>with our product manager in the architecture design interview. Instead, we must understand the product requirements and ask our interviewers for more information. In fact – this is what the interviewer is looking for!</p>
			<p class="calibre3">Imagine the interview is like a dark maze where we navigate with a flashlight and unveil more areas, rooms, and paths. Sometimes even the interviewer doesn’t know where we will take the interview!</p>
			<p class="calibre3">Going back to the messages app task, there are some questions we can think of when starting to design the app. Take the following examples:</p>
			<ul class="calibre10">
				<li class="calibre11">Do we support offline reading and writing?</li>
				<li class="calibre11">Do we have an integration with the device contacts?</li>
				<li class="calibre11">Do we need to support notifications and real-time chat?</li>
				<li class="calibre11">Can the user edit or delete messages?</li>
				<li class="calibre11">Do we need to support landscape mode?</li>
			</ul>
			<p class="calibre3">These questions weren’t posed out of curiosity. They impact the design and technical decisions we’ll need to make. For example, offline support is crucial to understand our data source’s behavior and sync mechanism. Integration with the device contacts influences <a id="_idIndexMarker973" class="calibre6 pcalibre pcalibre1"/>our data model. Real-time chat defines our network methods, and edit and delete features affect how we sync information back to the backend.</p>
			<p class="calibre3">It is perfectly fine not to ask all the questions at first – sometimes we just need to start designing to understand what we need to ask, but having a good start is a good idea.</p>
			<p class="calibre3">But how do we start the design? With wireframes? Or entities? That’s a good question, so let’s see.</p>
			<h2 id="_idParaDest-250" class="calibre7"><a id="_idTextAnchor375" class="calibre6 pcalibre pcalibre1"/>Starting the design</h2>
			<p class="calibre3">The design part is dynamic. No one expects us to have the final answers when we start to draw, and <a id="_idIndexMarker974" class="calibre6 pcalibre pcalibre1"/>we should expect things to change during the interview according to new findings and conclusions. Presenting things clearly and in detail can help us communicate better with the interviewer and express our thoughts better.</p>
			<h3 class="calibre9">Going to the whiteboard – wireframes</h3>
			<p class="calibre3">We are <a id="_idIndexMarker975" class="calibre6 pcalibre pcalibre1"/>not product designers, and no one expects us to be. But knowing how to present our ideas on a whiteboard is crucial for that process. We already discussed that in <em class="italic">Chapter 1</em> when we discussed technical preparations, and now, we understand exactly why.</p>
			<p class="calibre3">So, how do we start? Some developers like to start with basic UML that describes the different entities or classes. But in my opinion, it is better to start with wireframing the different screens when it comes to app architecture. Let’s start with the messages screen (<em class="italic">Figure 12</em><em class="italic">.5</em>):</p>
			<div><div><img src="img/Figure_12.05_B18653.jpg" alt="Figure 12.5 – The messages screen" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.5 – The messages screen</p>
			<p class="calibre3">Looking at <em class="italic">Figure 12</em><em class="italic">.5</em>, we can understand why starting from the UI is better. Ignoring the font <a id="_idIndexMarker976" class="calibre6 pcalibre pcalibre1"/>size and the layout (I’m not a good designer, I know), it looks like there are many things we can learn from this wireframe. Let’s list them:</p>
			<ul class="calibre10">
				<li class="calibre11">We’re starting to understand the <em class="italic">different entities</em>. For example, we see a full name and an avatar – that describes the <strong class="source-inline1">Contact</strong> entity. We can also see that the list shows the contact’s last message, which contains text property, so we have another entity here – <strong class="source-inline1">Message</strong>.</li>
				<li class="calibre11">We see that the list is being sorted by time. That’s maybe the place to dig a little bit deeper – do we want to sort it according to the most updated message for each contact, or do we want to have an <strong class="source-inline1">updatedTime</strong> property of the <strong class="source-inline1">Contact</strong> entity? This is a classic <em class="italic">trade-off between performance and simplicity</em>; we should discuss it with our interviewer.</li>
				<li class="calibre11">How about the <em class="italic">UI</em>? We know we are supposed to have some sort of <strong class="source-inline1">UITableView</strong> here. But do we want to load all the messages into the table view, or do we want to support pagination? What design pattern are we going to use here, MVC or MVVM? We should decide on the app’s scale, the first-time experience, and common user usage.</li>
			</ul>
			<p class="calibre3">Before we continue, I want you to notice something – there are no clear answers, just considerations and trade-offs. I asked questions but haven’t given you any answers because <a id="_idIndexMarker977" class="calibre6 pcalibre pcalibre1"/>the questions we ask ourselves and the interviewer are part of the process. That’s the place to show that we understand there are gray areas where we need to make the decisions.</p>
			<p class="calibre3">So, are we just using the whiteboard to draw a UI? Not necessarily – let’s continue.</p>
			<h3 class="calibre9">Adding entities and backend services</h3>
			<p class="calibre3">It’s <a href="B18653_12.xhtml#_idTextAnchor360" class="calibre6 pcalibre pcalibre1"><em class="italic">Chapter 12</em></a>, and we know that an app is more than just the UI. But is one screen enough to start <a id="_idIndexMarker978" class="calibre6 pcalibre pcalibre1"/>designing the other parts? Definitely, yes!</p>
			<p class="calibre3">Let’s add entities (<em class="italic">Figure 12</em><em class="italic">.6</em>):</p>
			<div><div><img src="img/Figure_12.06_B18653.jpg" alt="Figure 12.6 – Initial entities for the message’s app" class="calibre4"/>
				</div>
			</div>
			<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 12.6 – Initial entities for the message’s app</p>
			<p class="calibre3">Writing the entities on the whiteboard sounds like a technical task, but similar to wireframing, it can help us find more exciting things about our app.</p>
			<p class="calibre3">For example, we mentioned a URL for a contact avatar – this means we need to create some kind of image downloader service and a caching mechanism based on that URL. As a result, the <em class="italic">image downloader</em> can be added to our drawing on the whiteboard.</p>
			<p class="calibre3">Look what we’ve achieved based on a single entity’s property!</p>
			<p class="calibre3">But the actual value of drawing the entities is when we start thinking about their relationships. We have <code>Contact</code> and <code>Message</code>. But what describes a conversation with a contact? Maybe we need to create another entity named <code>MessagesThread</code>. And if we have a <code>MessagesThread</code> entity, what would its properties be?</p>
			<p class="calibre3">At this stage, things become a little bit more complex, because thinking about the connections brings up more questions – for example, do we support group messaging? The answer sets the relation type between <code>MessageThread</code> and <code>Contact</code>.</p>
			<p class="calibre3">Drawing <a id="_idIndexMarker979" class="calibre6 pcalibre pcalibre1"/>the entities next to our wireframes creates a back-and-forth process that helps us shape our design and make it more complete. Each decision leads to more questions, leading to more design decisions. It also sets the path to our next task: designing the interaction with our backend.</p>
			<h3 class="calibre9">Adding network calls</h3>
			<p class="calibre3">Now that we have the basic UI wireframes and entities, planning how we will work with our <a id="_idIndexMarker980" class="calibre6 pcalibre pcalibre1"/>backend service should be easier. Remember that the UI and entities are still part of our app learning stage – now we understand better what we need to do. The different endpoints define the user experience and the design patterns we will use, and that’s where we can really work on our app architecture, as we learned in this chapter.</p>
			<p class="calibre3">Let’s see what endpoints we need for the main screen:</p>
			<ul class="calibre10">
				<li class="calibre11"><strong class="source-inline1">GET/threads</strong>: To retrieve the list of all the threads</li>
				<li class="calibre11"><strong class="source-inline1">POST/thread</strong>: To create a new messages thread</li>
			</ul>
			<p class="calibre3">Generally, when working with a list of information, it is common to include these two endpoints as a part of our design. But there are more things to consider here:</p>
			<ul class="calibre10">
				<li class="calibre11">How are the threads sorted? Do we get them sorted from the server, or do we sort them by a specific property?</li>
				<li class="calibre11">Do we have a pagination mechanism? Or do we fetch all threads and use an incremental update sync?</li>
				<li class="calibre11">Do we need the <strong class="source-inline1">POST</strong> request at this stage? Or can we do that only after the first message we send?</li>
			</ul>
			<p class="calibre3">The endpoints also help us to define the app architecture. They answer important questions about the UI layer and its design patterns (MVC/MVVM). But they also help us understand <a id="_idIndexMarker981" class="calibre6 pcalibre pcalibre1"/>our data layer and the different services we will need. The following are examples:</p>
			<ul class="calibre10">
				<li class="calibre11">Core Data handler</li>
				<li class="calibre11">Image downloader</li>
				<li class="calibre11">Sync service</li>
				<li class="calibre11">Network service and real-time management</li>
			</ul>
			<p class="calibre3">If we continue adding more endpoints to the rest of the screens, we will learn more about our app and get more answers.</p>
			<p class="calibre3">Designing an app architecture is a discovery process. Nothing is clear at the beginning, and communicating the process to find the answers is essential. That’s why our next topic is extremely important – our communication with the interviewer.</p>
			<h2 id="_idParaDest-251" class="calibre7"><a id="_idTextAnchor376" class="calibre6 pcalibre pcalibre1"/>Communicating with the interviewer</h2>
			<p class="calibre3">As mentioned earlier in this section, many candidates believe their primary goal in the architecture <a id="_idIndexMarker982" class="calibre6 pcalibre pcalibre1"/>design interview is to provide the most optimal solution to the problem they just received. But the truth is that the goal is for the interviewer to see how we think and offer a decent solution to problems that might come up.</p>
			<p class="calibre3">Therefore, effective communication with the interviewer is crucial to be successful in this kind of interview. Some of our most critical soft skills are being tested here!</p>
			<p class="calibre3">Let’s go over some tips to help us focus on what matters:</p>
			<ul class="calibre10">
				<li class="calibre11"><em class="italic">Listen to the interviewer</em>: That’s obvious, right? Of course we are going to listen to the interviewer! But I mean, <em class="italic">really</em> listen to them. First, because the task requirements and the scope are very important to be precise on what we do. Moreover, there are valuable tips our interviewer will give us that can help us with our goal.</li>
				<li class="calibre11"><em class="italic">Clarify doubts</em>: If you are uncertain about your decision, you must communicate this to the interviewer. Interviewers need to see that candidates see things in shades of gray and not just black and white, but it is also a way to get clues or discuss things with the interviewer.</li>
				<li class="calibre11"><em class="italic">Be confident</em>: I know it sounds like it contradicts the previous point, but it doesn’t. It’s true that when we have doubts, we need to communicate them, but when we are <a id="_idIndexMarker983" class="calibre6 pcalibre pcalibre1"/>confident about something, we must show it. Self-confidence is an essential factor in these interviews.</li>
				<li class="calibre11"><em class="italic">Think out loud</em>: We know what we want to achieve with our design, and we even drew it on the whiteboard. But what is clear to us is not always apparent to the other person in the room. Thinking out loud can help us explain what we’re doing more clearly and help the interviewer understand the fantastic architecture we’ve just designed.</li>
				<li class="calibre11"><em class="italic">Use the correct terminology</em>: In this book, I have been strict about the different terms used – method versus function, design pattern versus architecture, and more. Using the correct terminology in these interviews is essential, not just to app<a id="_idTextAnchor377" class="calibre6 pcalibre pcalibre1"/>ear professional; it also makes our explanations much more evident to our interviewer. Not all interviewers are strict about it – but that doesn’t mean we shouldn’t be.</li>
				<li class="calibre11"><em class="italic">Be open to feedback</em>: The interviewer may provide feedback or suggestions during the interview. Sometimes it is a clue for the direction we can take, or sometimes it’s because we went out of scope. What happens many times, in this case, is that candidates lose their self-confidence and close themselves off, finding it difficult to accept that feedback. We should put our egos aside when we enter the design interview (actually, we should put our egos aside all the time) and use the interviewer’s feedback to improve our answers. Feedback during the interview doesn’t mean we failed – it means that we have a chance to provide a better solution.</li>
			</ul>
			<p class="calibre3">It seems like <a id="_idIndexMarker984" class="calibre6 pcalibre pcalibre1"/>we are being tested on how we communicate and express ourselves, but that’s the reality! The interviewer wants to see what it is like working with us, discussing design issues, and having architecture debates. That’s where our personality stands out.</p>
			<h1 id="_idParaDest-252" class="calibre5"><a id="_idTextAnchor378" class="calibre6 pcalibre pcalibre1"/>Summary</h1>
			<p class="calibre3">The architecture design interview is the highlight of the hiring process. It incorporates extensive knowledge of design patterns, architectures, iOS user experience, and critical soft skills such as planning, communication, and presentation.</p>
			<p class="calibre3">However, at this point, we should be in a position where we know how to crack the interview with several primary steps.</p>
			<p class="calibre3">In this chapter, we’ve learned about the SoC and how it applies to iOS architecture, including function size and naming. We’ve learned about application layers and data flows and even discussed an excellent example of an architecture for offline working. And finally, we discussed the architecture design interview – how to approach it and communicate with the interviewer.</p>
			<p class="calibre3">In the next (and final!) chapter, we will discuss the most practical step in the interview: the live coding interview and the home assessment. All hiring processes now include this step, and it’s our job to be ready for the unknown.</p>
		</div>
	</body></html>