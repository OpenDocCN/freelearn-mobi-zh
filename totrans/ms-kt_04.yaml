- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Design with Material Design 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Material Design is a design system developed by Google. It helps us create beautiful
    UIs. It provides a set of guidelines and components for us to use as we’re developing
    our Android apps.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll introduce ourselves to **Material 3**. We will also cover
    the features that Material 3 offers. Lastly, we will learn how to use Material
    3 in our Android apps and some of the components in Material 3.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Material Design 3 and its features
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Material Design 3 in our apps
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building for large screens and foldables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making our app accessible
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapterfour).
  prefs: []
  type: TYPE_NORMAL
- en: Material Design 3 and its features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The release of **Material Design 3** (**Material 3**) came with lots of new
    features to help us build UIs for our apps. Here are some of the features of Material
    Design 3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Dynamic color**: This is a color system that sets the color of our apps to
    the color of the user’s wallpaper. The System UI also adapts to this color. This
    enables users to have that personalized feel for their apps. Please note that
    dynamic color only works for Android 12 and above devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**More components**: Material 3 has a new set of improved components that are
    available for use. Some components have new UIs and others have been added to
    the APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified typography**: Material 3 has a much more simplified naming and
    grouping for typography. We have the following types: **display**, **headline**,
    **title**, **body**, and **label**, with each supporting *small*, *medium*, and
    *large* sizes. This makes it easier for us to define styles all across our apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved color scheme**: The color scheme has undergone a lot of improvements
    with the addition of more color schemes to fine-grain color customization. It’s
    also way easier for us to support both dark and light color schemes in our apps.
    In addition to that, they created a new tool, Material Theme Builder ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)),
    which allows us to generate and export dark and light theme colors for our apps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Simplified shapes**: Similar to typography, shapes have also been simplified
    to the following: **Extra Small**, **Small**, **Medium**, **Large**, and **Extra
    Large**. All these shapes come with default values, which we can always override
    to use our own.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good news for us is that from Android Studio Hedgehog onward, we have project
    templates that come set up with Material 3, which makes things easier for us.
    Even the project we created in [*Chapter 2*](B19779_02.xhtml#_idTextAnchor031)
    comes with Material 3 set up already.
  prefs: []
  type: TYPE_NORMAL
- en: Material 3 APIs and their predecessors offer a wide range of components for
    us to use in our apps. In the next subsection, we will be looking at some of the
    common ones.
  prefs: []
  type: TYPE_NORMAL
- en: Material components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Material library comes with prebuilt components that we can use to build
    common UI components. Let us look at some of the commonly used components and
    some of the updates they had in Material 3.
  prefs: []
  type: TYPE_NORMAL
- en: Top app bars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is a component displayed at the top of the screen. It has a title and
    can also have some actions that are related to the screen the user is on. Some
    of the common actions are the settings icon normally at the top right of the screen.
    In Material 3, we have four types of top app bars: **center-aligned**, **small**,
    **medium**, and **large**, as shown in the following figures.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Small top app bar](img/B19779_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.1 – Small top app bar
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2 – Center-aligned top app bar](img/B19779_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.2 – Center-aligned top app bar
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3 – Medium top app bar](img/B19779_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.3 – Medium top app bar
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4 – Large top app bar](img/B19779_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.4 – Large top app bar
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figures 4.1* to *4.4*, all the top bars have the same width and
    only differ in height and positioning of the title text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the sample code for one of these top app bars:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have our custom composable and, inside it, we are using the `CenterAlignedTopBar`
    composable from Material 3 and passing in `Text` to the `title` composable. The
    other three (`LargeTopAppBar`, `MediumTopAppBar`, and `TopAppBar`) are similar;
    the only difference is the composable that you will use. Notice that we have the
    `@OptIn` annotation as these components are still experimental.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us look at the `FloatingActionButton` component.
  prefs: []
  type: TYPE_NORMAL
- en: FloatingActionButton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Most apps use the component to represent a call to action that is frequently
    used in the app. For example, create a new chat in a chat app. It is normally
    positioned at the bottom right of the screen or elsewhere, depending on your use
    case. This is how we create the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `FloatingActionButton` component from the Material 3 library. We
    have the `onclick` argument on the composable and, inside the `content` lambda,
    we pass in an `Icon` composable that has an *add* icon. The preview should be
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5 – FloatingActionButton](img/B19779_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.5 – FloatingActionButton
  prefs: []
  type: TYPE_NORMAL
- en: 'The `FloatingActionButton` component has these sizes: large, normal, and small,
    and you can use whichever fits your purpose.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have another type of `FloatingActionButton` component known as `ExtendedFloatingActionButton`,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6 – ExtendedFloatingActionButton](img/B19779_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.6 – ExtendedFloatingActionButton
  prefs: []
  type: TYPE_NORMAL
- en: 'As seen in the preceding figure, an `ExtendedFloatingActionButton` component
    allows us to add more items to our FAB. They are wider than the normal `FloatActionButton`
    components. In this case, we have a `Text` composable with the text **New Chat**
    in addition to the icon. You can use it with or without the icon. The implementation
    for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the `ExtendedFloatingActionButton` component and still passed
    in the same parameters as before. The only difference is that inside the content,
    we pass in a text since the `content` lambda exposes `RowScope`, which means children
    composables will be arranged in a row.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us look at the bottom app bar components.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom app bars
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The bottom app bar components display navigation items at the bottom of the
    screen. They are normally useful for apps that have three to five primary destinations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at the code for a bottom app bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We use the `BottomAppBar` component and, inside the `actions` lambda, we pass
    in three `Icon` composables to represent the items we are supposed to show. This
    is how the preview of the composable will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7 – BottomAppBar](img/B19779_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.7 – BottomAppBar
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**,7*, we can see we have three icons arranged horizontally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Additionally, in `BottomAppBar`, we can also provision a `FloatingActionButton`
    component. We are going to use the `FloatingActionButton` component that we used
    early on. The updated component code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we have used the `floatingActionButton` parameter and
    passed in `PacktFloatingActionButton()` that we created earlier. The updated preview
    will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8 – BottomAppBar with FloatingActionButton](img/B19779_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.8 – BottomAppBar with FloatingActionButton
  prefs: []
  type: TYPE_NORMAL
- en: As seen in the preceding figure, our `BottomAppBar` now has a nice `FloatingActionButton`
    to its right. The FAB is automatically positioned for you to the right.
  prefs: []
  type: TYPE_NORMAL
- en: We have looked at the different components in isolation, but what happens when
    we want to place them on one screen together? Next, we are going to look at `Scaffold`,
    which is meant for this.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffold
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a layout provided by Material Design that helps place all components
    on your screen in their desired positions with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at a sample of `Scaffold` that has a top app bar, a floating action
    button, text center-aligned on the screen, and a bottom navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'A lot is happening here, so let us break it down:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Scaffold` composable is used to create a layout that implements the Material
    Design guidelines. It is a container that contains the top bar, bottom bar, floating
    action button, and the content.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `topBar` parameter is used to specify the top bar. In this case, we are
    using the `PacktSmallTopAppBar` composable that we created earlier.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `bottomBar` parameter is used to specify the bottom bar. In this case, we
    are using the `PacktBottomNavigationBar` composable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `floatingActionButton` parameter is used to specify the floating action
    button. In this case, we are using the `PacktFloatingActionButton` composable.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `content` parameter is used to specify the content of the screen. In this
    case, we are using a `Column` composable that contains a `Text` composable. The
    text is centered in the column using the `verticalArrangement` and `horizontalAlignment`
    parameters. Notice that inside `Column`, we are using the `paddingValues` parameter
    to add padding to the column. This is because the `Scaffold` composable passes
    the `padding` values to the `content` parameter.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With our `Scaffold` composable ready, let us see how its preview looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9 – Scaffold](img/B19779_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.9 – Scaffold
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 4**.9*, we can see that the `Scaffold` composable has added the top
    bar, bottom bar, and the floating action button to the screen. The components
    are also placed in the correct positions as per the Material Design guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned about a bunch of components so far; Material 3 still offers
    more components out of the box for us. We will be using some of these components
    in the upcoming chapters of this book. To view the full list of all the components,
    go to the Material 3 Components website (https://m3.material.io/components) to
    see them and their guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand Material 3 and its features, let us look at how to add
    it to our apps.
  prefs: []
  type: TYPE_NORMAL
- en: Using Material Design in our apps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To take advantage of the Material 3 features that we looked at in the previous
    section, we need to add it to our app. Luckily, with Android Studio Hedgehog,
    we have Material 3 templates. Even the sample apps we have been using already
    use Material 3\. So cool, right? Let us quickly scan the dependencies to understand
    what is happening:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This dependencies block sets up several for us, including the `compose` dependencies.
    The most important one is the `androidx.compose.material3:material3` dependency.
    This is the dependency that contains the Material 3 components. We are using the
    Compose **Bill of Materials** (**BOM**) to manage our dependencies. This means
    that we do not have to specify the version of each dependency. Instead, we specify
    the version of the BOM, and it will manage the versions of the dependencies for
    us. This is the recommended way of managing dependencies in Compose. That is why
    we have not specified the version of each dependency.
  prefs: []
  type: TYPE_NORMAL
- en: With that, our project is ready to take advantage of the Material 3 features.
    In the next subsection, we will be adding more color schemes to the app.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Material Design 3 color schemes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As mentioned earlier, Material 3 comes with a lot of fine-grained color schemes
    and introduces **dynamic color**. However, they are not set up with the templates
    that Android Studio generates. We will be setting them up in the next few steps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Head over to the `ui/theme` package and open the `Color.kt` file, which has
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: So far, this file only has a few colors defined. These colors do not cover all
    the color tokens provided by Material 3\. We will add more colors as we need them
    in the app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using the **Material Theme Builder** tool to generate these colors.
    Let us open our browser and go to the Material Theme Builder tool ([https://m3.material.io/theme-builder](https://m3.material.io/theme-builder)).
    We will be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10 – Material Theme Builder tool](img/B19779_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.10 – Material Theme Builder tool
  prefs: []
  type: TYPE_NORMAL
- en: 'This tool helps us visualize the color schemes for our apps and shows how different
    components will be themed. It makes it easier for us to customize and produce
    a consistent color scheme for our app. It has two tabs: **Dynamic** and **Custom**.
    In the **Dynamic** tab, we can select one of the preloaded colors or wallpapers
    to see how the color changes. One useful feature is that we can also add your
    own wallpaper and generate the colors based on the wallpaper.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the **Custom** tab, we can select a color and the tool generates all the
    complementary colors for us based on the color we select, ensuring a harmonious
    color palette:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11 – Material Theme Builder tool custom color](img/B19779_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.11 – Material Theme Builder tool custom color
  prefs: []
  type: TYPE_NORMAL
- en: On the left, we have the **Core colors** section where we can select either
    **Primary**, **Secondary**, **Tertiary**, or **Neutral** colors for our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to select the **Primary** color option, which opens a **Color**
    **Picker** dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12 – Color Picker](img/B19779_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.12 – Color Picker
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are changing the primary color, we will be able to see the visual preview
    change to match the color we have. Now we have our primary color ready, we are
    going to export the files so that we can use them in our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13 – Export option](img/B19779_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.13 – Export option
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 4**.13*, the visual preview has changed to the color we chose.
    Click on the `ui` folder that has a `theme` folder inside containing `Color.kt`
    and `Theme.kt` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us open the `Color.kt` file, which contains the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As you can now see, we have more color additions. Let us copy these colors to
    the `Color.kt` file in our project. Next, let us open the `Theme.kt` from the
    unzipped folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will notice it is similar to the `Theme.kt` file but it defines all the
    Material 3 color schemes. Copy the contents of this file and paste them into the
    `Theme.kt` file in our project. We are going to make minor edits to the code to
    make sure we maintain the `ChapterFourTheme` name and dynamic color logic that
    was in our theme. Next, we need to change the `DarkColorScheme` variable values
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are using the `DarkColorScheme` function to create
    a dark color scheme. We are passing the colors that we generated using the Material
    Theme Builder tool. We will use this color scheme to create a dark theme. The
    dark color scheme variable is defined in a similar manner, and we can copy the
    values from the `Theme.kt` file from the tool and add it there too. Let us now
    look at our theme composable in wholesome:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us break down the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ChapterFourTheme` composable is used to create a theme for our app. It
    takes three parameters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `darkTheme` parameter is used to specify whether the theme is dark or light.
    By default, we are using the system theme.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `dynamicColor` parameter is used to specify whether the theme should use
    dynamic colors. By default, we are using dynamic colors.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `content` parameter is used to specify the content of the theme. In this
    case, we are using the `MaterialTheme` composable to create a theme for our app.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The `colorScheme` variable is used to specify the color scheme to use. We are
    using a `when` expression to determine the color scheme to use. If the `dynamicColor`
    parameter is `true` and the device is running Android 12 or higher, we are using
    the `dynamicDarkColorScheme` or `dynamicLightColorScheme` function to create a
    dynamic color scheme. When not using dynamic colors, we fall back to the normal
    themes. If the `darkTheme` parameter is `true`, we are using the `DarkColorScheme`
    variable to create a dark color scheme. Otherwise, we are using the `LightColorScheme`
    variable to create a light color scheme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `view` variable is used to get the view that is using the theme.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `SideEffect` composable is used to execute a side effect. In this case,
    we are using it to set the status bar color and the status bar icons’ color. We
    are using the `WindowCompat` class to get `InsetsController` and set the status
    bar color and the status bar icons’ color. We are using the `colorScheme.primary`
    color to set the status bar color. We are using the `darkTheme` parameter to determine
    whether the status bar icons’ color should be light or dark.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MaterialTheme` composable is used to create a theme for our app. We are
    using the `colorScheme` parameter to specify the color scheme to use. We are using
    the `typography` variable to specify the typography to use.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To be able to see the changes we have made, we need to call `PacktScaffold`,
    which we created earlier inside the `MainActivity.kt` file in the `ChapterFourTheme`
    block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us build and run the app. We should be able to see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14 – Chapter 4 app](img/B19779_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.14 – Chapter 4 app
  prefs: []
  type: TYPE_NORMAL
- en: 'Like me, you might be wondering why the app does not have the greenish color
    we set on the Material Theme Builder tool. Remember the dynamic color logic in
    our `ChapterFourTheme` composable? It is responsible for the brownish color we
    see. Look at my wallpaper settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.15 – Wallpaper settings](img/B19779_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 4.15 – Wallpaper settings
  prefs: []
  type: TYPE_NORMAL
- en: As seen in *Figure 4**.15*, my wallpaper has a brown color set. This means our
    dynamic color logic is working, and our app can adapt well to my wallpaper settings!
  prefs: []
  type: TYPE_NORMAL
- en: We have seen how to use the Material 3 features in our app. In the next section,
    we will see how we can design UIs that work for large screens and foldables in
    Jetpack Compose.
  prefs: []
  type: TYPE_NORMAL
- en: Designing UIs for large screens and foldables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent years and with the release of Material 3, there has been an increased
    focus on tablets and foldable devices. As such, we, as developers, must make our
    apps work well on these devices. In this section, we will look at how we can make
    our apps work well on large screens and foldables. We need to ensure our apps
    adapt to the different screen sizes. Making our apps responsive provides a good
    user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Material 3 offers **canonical layouts** to serve as guidelines for creating
    UIs for large screens and foldables. These layouts are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**List-detail view**: Here, we place a list of items on the left and, on the
    right, we show the details of a single item.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feed**: Here, we arrange content elements such as cards in a customizable
    grid, which provides a good view of a large amount of content.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Supporting pane**: Here, we organize app content into primary and secondary
    display areas. The primary area shows the main content while the secondary area
    shows the supporting content. The primary area occupies most of the screen while
    the secondary area occupies a smaller portion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For us to show the different layouts, we must know the screen size of the device
    the user is using. Luckily for us, Jetpack Compose provides us with a way to get
    the screen size. We have the Material 3 **WindowSizeClass** to help us determine
    which layout to show in our app.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to learn how to use `WindowSizeClass` next.
  prefs: []
  type: TYPE_NORMAL
- en: Using WindowSizeClass
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For us to use `WindowSizeClass`, we must add the following dependency to our
    app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This is the Material 3 dependency that adds `WindowSizeClass` to our project.
    Notice we are not providing a version for this dependency. This is because we
    are using the Compose BOM to manage our dependencies. The BOM will manage the
    version of this dependency for us.
  prefs: []
  type: TYPE_NORMAL
- en: '`WindowSizeClass` classifies the available screen width into three categories:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Compact`: This is for devices whose width is less than 600 dp. Commonly, these
    are devices in portrait mode.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Medium`: This is for devices whose width is between 600 dp and 840 dp. Devices
    such as tablets and foldables in portrait mode fall into this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Expanded`: This is for devices whose width is greater than 840 dp. Devices
    such as tablets and foldables in landscape mode, phones in landscape mode, and
    desktops fall into this category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WindowSizeClass` uses `widthSizeClass` to get the width of the screen. In
    addition to `widthSizeClass`, it also has `heightSizeClass` to help us determine
    the height of the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at `widthSizeClass` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is an explanation of what the preceding code is doing:'
  prefs: []
  type: TYPE_NORMAL
- en: The `calculateWindowSizeClass` function is used to calculate `WindowSizeClass`.
    We are passing the activity as the parameter. The function is from the `WindowSizeClass`
    APIs. It has the `widthSizeClass` and `heightSizeClass` properties, which we can
    use to get the width and height of the screen, respectively.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use `widthSizeClass` to customize our display options:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `WindowWidthSizeClass.Compact` case, we are using `BottomNavigation`
    for navigation, and the UI should only show the list of characters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `WindowWidthSizeClass.Medium` case, we are using `NavigationRail` for
    navigation, and the UI should show the list of characters and the details of the
    selected character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: For the `WindowWidthSizeClass.Expanded` case, we are using `NavigationDrawer`
    for navigation. and the UI should show the list of characters and the details
    of the selected character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a default case where we are using `BottomNavigation` for navigation,
    and the UI should only show the list of characters
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At a glance, you can see how we take advantage of `WindowSizeClass` to customize
    our UI and navigation type based on the screen size. This is an immensely powerful
    feature that we can use to make our apps responsive. This makes sure we take advantage
    of the screen size and provide a good user experience.
  prefs: []
  type: TYPE_NORMAL
- en: The example shown in this section was a simple one. In [*Chapter 7*](B19779_07.xhtml#_idTextAnchor092)
    of this book, we will have a more detailed example where we will use `WindowSizeClass`
    to customize our UI based on the screen size.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to design and build apps for large screens and foldables,
    let us look at yet another important topic in this chapter, which is accessibility.
  prefs: []
  type: TYPE_NORMAL
- en: Making our app accessible
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making the apps that we develop accessible is extremely important. It ensures
    that our apps can be used by everyone. In this section, we will look at how we
    can make our apps accessible. Jetpack Compose uses **semantics** to make our apps
    accessible. Semantics are used to describe the UI elements in our apps. They are
    used by accessibility services to make our apps accessible. Semantics are also
    used by automated testing tools to test our apps. Some of the best practices for
    making our apps accessible are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: We should always ensure that all clickable or touchable elements or those that
    require user interaction are large enough to be easily tapped or clicked. Most
    Material components out of the box have a default size that is large enough to
    be easily tapped or clicked. If we must size by ourselves, we should ensure that
    the size is at least 48 dp by 48 dp.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We should add content descriptions to our composables. Components such as `Icon`
    and `Image` provide this argument to describe visual elements to accessibility
    services. We should always provide a content description for these components.
    The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can see in the preceding code that we are using the `contentDescription`
    parameter to provide a description for `Icon`. This is a good practice that we
    should always follow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We should label our clickable elements. We can pass a clickable label to the
    clickable modifiers. This enables us to add descriptions to our clickable elements.
    The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding example, we are using the `onClickLabel` parameter to add a
    description to the `Text` composable. This is a good practice that we should always
    follow.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'By using semantics, we can also describe headers. Headers are used to describe
    the content that follows them. We can use semantics to add a header to our composables.
    The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can additionally provide information about the state of our composables.
    For example, we can provide information about the state of a button. We can use
    semantics to provide this information. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This helps us inform our users about the state of our composables.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'For some groups of components, we can also use the `mergeDescendants` parameter
    to merge the semantics of the children composables. The following is an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Merging descendants is useful when we want to provide a description for a group
    of composables. In the preceding example, we are using the `mergeDescendants`
    parameter to merge the semantics of the `Text` composables. However, we should
    be careful when using this parameter. We should only use it when we want to provide
    a description for a group of composables. If we use it for a large group of composables,
    it can lead to performance issues and can also be confusing for the users.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To learn more about accessibility in Jetpack Compose, visit the official documentation
    ([https://developer.android.com/jetpack/compose/accessibility](https://developer.android.com/jetpack/compose/accessibility)).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we introduced Material 3\. We also covered the features that
    Material 3 offers. We saw how to use Material 3 in our apps. Additionally, we
    covered how to design and develop our apps for large screens and, finally, we
    saw how to make our Jetpack Compose UIs accessible.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue building upon the skills that we’ve gained
    from the previous chapters. We will be looking at how to architect our app and
    the different architectures available. We will learn how to use Jetpack libraries
    in our apps and how to tackle dependency injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Using Advanced Features'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building upon the foundational knowledge gained in *Part 1*, this part propels
    you into advanced concepts, providing a deeper understanding of Android development.
    Delving into diverse architectures, the focus shifts toward mastering the MVVM
    architecture for your applications. Furthermore, you will unravel the intricacies
    of making network calls by incorporating the Retrofit networking library. Taking
    it a step further, you will harness the power of Kotlin coroutines to seamlessly
    execute asynchronous network requests. Your navigational prowess will be honed
    using the Jetpack Navigation library, exploring techniques for efficient navigation
    on large screens and foldable devices. The journey continues with insights into
    handling long-running tasks in the background and leveraging Room for local data
    storage. Wrapping up, we will demystify runtime permissions, and you will comprehend
    their significance and master the art of requesting permissions dynamically within
    your app.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section contains the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19779_05.xhtml#_idTextAnchor067), *Architect Your App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19779_06.xhtml#_idTextAnchor084), *Network Calls with Kotlin
    Coroutines*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B19779_07.xhtml#_idTextAnchor092), *Navigating within Your App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B19779_08.xhtml#_idTextAnchor101), *Persisting Data Locally and
    Doing Background Work*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B19779_09.xhtml#_idTextAnchor112), *Runtime Permissions*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
