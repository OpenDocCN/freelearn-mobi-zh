- en: Chapter 7. Particle Effects and Shaders
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章。粒子效果和着色器
- en: In the previous chapter, we discussed in detail how to animate nodes, controls,
    the `SceneKit` method, and so on. We also discussed handling scene animations.
    We learned the `SKAction` class properties and methods along with learning about
    various controls by which a game can be played, such as gesture recognition or
    accelerometer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们详细讨论了如何动画节点、控制、`SceneKit` 方法等。我们还讨论了处理场景动画。我们学习了 `SKAction` 类的属性和方法，同时了解了各种控制方式，例如手势识别或加速度计，通过这些方式可以玩游戏。
- en: We added player animations, controls, and actions in our *Platformer* game,
    this has made the game pretty fun to play and interesting to learn.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在我们的*平台游戏*中添加了玩家动画、控制和动作，这使得游戏玩起来非常有趣，学习起来也很有趣。
- en: In this chapter, we will study particle effects and shaders in a Sprit Kit game.
    Particle effect is a very exciting ability provided by Sprite Kit. We can generate
    particles using the `SKEmitterNode` object; these particles create beautiful visual
    effects such as rain, fire, bokeh, spark, and so on. Shaders were introduced in
    Sprite Kit with iOS 8\. Shaders are used to give customized special effects to
    scenes. The `SKShader` class is used to include shaders in our Sprite Kit game.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究在 Sprit Kit 游戏中的粒子效果和着色器。粒子效果是 Sprite Kit 提供的非常令人兴奋的能力。我们可以使用 `SKEmitterNode`
    对象生成粒子；这些粒子可以创建如雨、火、景深、火花等美丽的视觉效果。着色器是在 iOS 8 中引入到 Sprite Kit 中的。着色器用于为场景提供定制的特殊效果。`SKShader`
    类用于在我们的 Sprite Kit 游戏中包含着色器。
- en: Particle effects
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子效果
- en: 'Particle effects in games is a technique in which small sprites or other graphical
    objects are used to simulate a diffused effect, for example, rendering of the
    following effects by the particle system is very common:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的粒子效果是一种技术，使用小精灵或其他图形对象来模拟扩散效果，例如，通过粒子系统渲染以下效果是非常常见的：
- en: Fire
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 火
- en: Explosion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 爆炸
- en: Smoke
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 烟雾
- en: Moving water
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流动的水
- en: Falling leaves
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 落叶
- en: Clouds
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云朵
- en: Fog
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雾
- en: Snow
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 雪
- en: Dust
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灰尘
- en: Meteors
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 流星
- en: Stars
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星星
- en: Galaxies
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 星系
- en: Trails
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 轨迹
- en: The entire behavior in particle effect is defined by the emitter node. A particle
    in Sprite Kit is similar to a `SKSpriteNode` object where it renders a textured
    or non-textured image that can be sized, colorized, or blended in the scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子效果中的整个行为都是由发射器节点定义的。Sprite Kit 中的粒子类似于 `SKSpriteNode` 对象，其中它渲染一个纹理或非纹理图像，该图像可以在场景中调整大小、着色或混合。
- en: '![Particle effects](img/4201_07_06.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![粒子效果](img/4201_07_06.jpg)'
- en: An example of different effects
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 不同效果的示例
- en: The SKEmitter node
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SKEmitter 节点
- en: The `SKEmitterNode` object is a node that automatically creates and renders
    small sprites. We can configure the emitter node properties from our Xcode itself.
    We use the particle emitter editor for this purpose.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKEmitterNode` 对象是一个节点，它可以自动创建和渲染小精灵。我们可以从我们的 Xcode 中配置发射器节点的属性。我们使用粒子发射器编辑器来完成这个目的。'
- en: We can use target nodes to change the destination of particles. Here is a sample
    code snippet to demonstrate how we can implement the same.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用目标节点来改变粒子的目的地。以下是一个示例代码片段，演示我们如何实现相同的功能。
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Let's discuss the properties and methods that are used while implementing Sprite
    Kit's emitter node.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论在实现 Sprite Kit 的发射器节点时使用的属性和方法。
- en: Creating the particle effect
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建粒子效果
- en: 'Sprite Kit provides properties and variables to customize particle effects
    as per their requirement in a game. Let''s discuss these properties and variables:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit 提供了属性和变量来根据游戏需求自定义粒子效果。让我们讨论这些属性和变量：
- en: '`var particleBirthRate`: In this property, you define the number of particles
    created by the emitter every second. The default value of this is `0.0`.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var particleBirthRate`: 在这个属性中，你定义了发射器每秒创建的粒子数量。默认值是 `0.0`。'
- en: '`func advanceSimulationTime( sec:NSTimeInterval )`: This method helps you advance
    the emitter particle simulation. It takes time in seconds as its parameter, which
    is the time required to simulate. Preferably, this method is used to preoccupy
    an emitter node with particles after its addition to scene.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func advanceSimulationTime(sec:NSTimeInterval)`: 这个方法帮助你推进发射器粒子的模拟。它以秒为单位接受参数，这是模拟所需的时间。最好在将发射器节点添加到场景后，使用此方法让发射器节点忙于粒子。'
- en: '`var numParticlesToEmit`: In this property, you define the number of particles
    the emitter has to emit. By default, its value is `0`, which means that the emitter
    creates infinite particles.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var numParticlesToEmit`: 在这个属性中，你定义了发射器必须发射的粒子数量。默认值是`0`，这意味着发射器创建无限数量的粒子。'
- en: '`func resetSimulation ()`: This method removes all the particles and restarts
    the simulation. Resetting the simulation clears its internal state.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func resetSimulation ()`: 这个方法会移除所有粒子并重新启动模拟。重置模拟会清除其内部状态。'
- en: '`var targetNode`: As discussed earlier, we can use `targetNode` to change the
    destination of the particles. If the property is `nil`, then the particles are
    treated to be children of the emitter node. When this property points to the target
    node, then new particles are treated as if they are children of the target node,
    but the previously generated particles are calculated based on the emitter node''s
    properties. Its default value is nil.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var targetNode`: 如前所述，我们可以使用 `targetNode` 来改变粒子的目标位置。如果该属性为 `nil`，则粒子被视为发射节点下的子节点。当此属性指向目标节点时，新粒子被视为目标节点的子节点，但先前生成的粒子将基于发射节点的属性进行计算。其默认值是
    `nil`。'
- en: Properties for determining a particle's lifetime
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于确定粒子寿命的属性
- en: This is the time for which the user-created particle will stay alive and functional.
    When the lifetime drains out and drops below zero, the particle will be killed.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这是用户创建的粒子保持存活和功能的时间。当寿命耗尽并降至零以下时，粒子将被销毁。
- en: '`var particleLifetime`: This property determines the average lifetime of a
    particle in seconds. Its default value is `0.0`.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var particleLifetime`: 这个属性决定了粒子在秒内的平均寿命。其默认值是 `0.0`。'
- en: '`var particleLifetimeRange`: We specify a range in this property, the lifetime
    of a particle is determined randomly within this range.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var particleLifetimeRange`: 我们在这个属性中指定一个范围，粒子的寿命将在该范围内随机确定。'
- en: It's now time to add a particle effect in our *Platformer* game.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候在我们的 *Platformer* 游戏中添加粒子效果了。
- en: Adding the particle effect in our Platformer game
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的平台游戏 `Platformer` 中添加粒子效果
- en: Let's integrate particle effect at player collision in our *Platformer* game.
    We will make a particle simulation at the time of collision between blocks and
    the player.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在 *Platformer* 游戏中集成粒子效果，在玩家碰撞时进行。我们将在方块和玩家碰撞时进行粒子模拟。
- en: As an initial step for implementation, lets create a particle effect. Go to
    the **Project Navigator** and add new **File** | **SpriteKit Particle File** |
    **Spark** | **Create**.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 作为实现的一个初始步骤，让我们创建一个粒子效果。转到 **项目导航器** 并添加新的 **文件** | **SpriteKit 粒子文件** | **Spark**
    | **创建**。
- en: '![Adding the particle effect in our Platformer game](img/4201_07_01.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的平台游戏 `Platformer` 中添加粒子效果](img/4201_07_01.jpg)'
- en: 'You can choose from a list of particle templates, such as **Snow**, **Bokeh**,
    **Fire**, **Rain**, **Spark**, and so on. Here we are using the **Spark** effect
    template:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从一系列粒子模板中选择，例如 **Snow**（雪），**Bokeh**（散景），**Fire**（火焰），**Rain**（雨），**Spark**（火花）等等。这里我们使用的是
    **Spark** 效果模板：
- en: '![Adding the particle effect in our Platformer game](img/4201_07_02.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的平台游戏 `Platformer` 中添加粒子效果](img/4201_07_02.jpg)'
- en: Open the `ParticleEffectPlayerCollide.sks` file we just created. Particle effect
    files are saved with the extension, `.sks`. You can change the different properties
    of selected particle effects using the particle emitter editor, which you can
    access on the right-hand side.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们刚刚创建的 `ParticleEffectPlayerCollide.sks` 文件。粒子效果文件以 `.sks` 扩展名保存。您可以使用粒子发射器编辑器更改所选粒子效果的不同属性，您可以在右侧访问该编辑器。
- en: '![Adding the particle effect in our Platformer game](img/4201_07_03.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![在我们的平台游戏 `Platformer` 中添加粒子效果](img/4201_07_03.jpg)'
- en: The particle emitter editor in Sprite Kit
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit 中的粒子发射器编辑器
- en: 'Let''s discuss some of the properties, which are displayed on the **SpriteKit
    Particle Emitter** panel:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些在 **SpriteKit 粒子发射器** 面板上显示的属性：
- en: '**Particle Texture**: You can select an image to be used for creating the particle.
    For particle texture, images related to the project can also be used. To assign
    the image, one must keep in mind that a complex and larger image will require
    excessive use of resources. A simple and small image is advisable.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粒子纹理（Particle Texture）**: 您可以选择用于创建粒子的图像。对于粒子纹理，也可以使用与项目相关的图像。要分配图像，必须记住，复杂且较大的图像将需要过度使用资源。建议使用简单且小的图像。'
- en: '**Birthrate**: This property is used to set the rate at which the emitter generates
    the particles. If the birthrate is more than the particle effect, it will look
    more intensive. So, it''s always recommended to follow the lower birthrate for
    an optimum frame rate.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**出生率（Birthrate）**: 这个属性用于设置发射器生成粒子的速率。如果出生率高于粒子效果，看起来会更加密集。因此，始终建议遵循较低的出生率以获得最佳帧率。'
- en: '**Lifetime**: This property will define the total lifetime of the particle
    on the screen. Here, **Range** refers to the random value from the first value
    **+** or **-** range.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生命周期**：此属性将定义粒子在屏幕上的总生命周期。这里的**范围**指的是从第一个值**+**或**-**范围内的随机值。'
- en: '**Position Range**: This property will tell you how far from the origin emitter
    node the effect should be, using **X** and **Y** co-ordinate values. Change in
    this property affects the size of the emitter.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置范围**：此属性将告诉您效果应距离原发射节点多远，使用**X**和**Y**坐标值。此属性的变化会影响发射器的大小。'
- en: '**Angle**: This property will tell the angle in which the particle effect should
    happen. This will also use the **Start** and **Range** values.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角度**：此属性将告诉粒子效果应发生的角度。这也会使用**起始**和**范围**值。'
- en: '**Speed**: This property will define the initial speed at which the effect
    should happen. This will also use the **Start** and **Range** values.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：此属性将定义效果应发生的初始速度。这也会使用**起始**和**范围**值。'
- en: '**Acceleration**: This property will take care of the acceleration at which
    the particles should appear from the source emitter using **X** and **Y** coordinates.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加速度**：此属性将负责粒子从源发射器使用**X**和**Y**坐标出现的加速度。'
- en: '**Alpha**: This property will take care of the transparency of the effect.
    This will also use the **Start** and **Range** values with a **Speed**.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**透明度**：此属性将负责效果的不透明度。这也会使用**起始**和**范围**值以及**速度**。'
- en: '**Scale**: This property will define the **Scale** position for the texture/image
    that is used for the effect. This will also use the **Start**, **Range**, and
    **Speed** values.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放**：此属性将定义用于效果的纹理/图像的**缩放**位置。这也会使用**起始**、**范围**和**速度**值。'
- en: '**Rotation**: This property is used to define the **Rotation** speed for the
    particle effect. This will also use the **Start**, **Range**, and **Speed** values.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转**：此属性用于定义粒子效果的**旋转**速度。这也会使用**起始**、**范围**和**速度**值。'
- en: 'The **Color Blend** factor: This property is used to define the color that
    is used in the particle effect lifetime. Where the particles may follow different
    colors in their particle lifetime. This will use the **Factor**, **Range**, and
    **Speed** values for defining the property.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**颜色混合**因子：此属性用于定义粒子效果生命周期中使用的颜色。粒子在其生命周期中可能遵循不同的颜色。这将使用**因子**、**范围**和**速度**值来定义属性。'
- en: Adding the code to facilitate the particle effect
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码以方便粒子效果
- en: 'Once you are done with setting up the desired properties, create a particle
    node object (the `SKEmitterNode` object) in the `GameScene.swift` file:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置完所需的属性后，在`GameScene.swift`文件中创建一个粒子节点对象（`SKEmitterNode`对象）：
- en: '[PRE1]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, set the position in the `didMoveToView()` method and also hide the particle
    node that is created. Finally, add the particle node into the player. Now the
    `didMoveToView()` method should look like the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`didMoveToView()`方法中设置位置，并隐藏创建的粒子节点。最后，将粒子节点添加到玩家中。现在`didMoveToView()`方法应如下代码所示：
- en: '[PRE2]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, let's define when this particle effect should happen, un-hiding the `particlePlayerNode`
    we created within the `didBeginContact()` method, as this method will be called
    whenever the collision happens.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义这个粒子效果应在何时发生，在`didBeginContact()`方法中取消隐藏我们创建的`particlePlayerNode`，因为这个方法将在发生碰撞时被调用。
- en: 'The `didBeginContact` method should look as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`didBeginContact`方法应如下所示：'
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This is how the collision will look with the particle effect:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是碰撞与粒子效果的外观：
- en: '![Adding the code to facilitate the particle effect](img/4201_07_08.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![添加代码以方便粒子效果](img/4201_07_08.jpg)'
- en: Now, we have successfully added the particle effect in our *Platformer* game,
    and it's time to discuss about shaders and how we can add them in our game.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经成功地将粒子效果添加到我们的*平台游戏*中，是时候讨论着色器和如何在我们的游戏中添加它们了。
- en: Shaders
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 着色器
- en: Shaders in Sprite Kit facilitate `SKScenenode` to appear with a special, customized,
    drawing behavior. This can be achieved by creating the `SKShader` objects and
    assigning a custom OpenGL ES fragment shader.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Sprite Kit中的着色器使`SKScenenode`能够以特殊、定制的绘制行为出现。这可以通过创建`SKShader`对象并分配自定义OpenGL
    ES片段着色器来实现。
- en: 'If a custom shader (the `SKShader` object) needs to provide a uniform shader,
    then you need to create one or more `SKUniform` objects and associate them with
    your shader objects. Shader programs are primarily divided into:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自定义着色器（`SKShader` 对象）需要提供一个统一着色器，那么您需要创建一个或多个 `SKUniform` 对象，并将它们与您的着色器对象关联起来。着色器程序主要分为：
- en: Vertex shaders
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顶点着色器
- en: Fragment shaders
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 片段着色器
- en: 'Let''s discuss about both of these in detail:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细讨论这两个方面：
- en: '**Vertex shaders**: These shaders work on each vertex and most of the calculation
    is done on the vertex part. They are set by Sprite Kit automatically. As the computation
    of these shaders are mostly done on the vertex part, not much of the CPU''s resources
    are consumed in the formation.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这些着色器作用于每个顶点，大部分计算都在顶点部分完成。它们由 Sprite Kit 自动设置。由于这些着色器的计算主要在顶点部分完成，因此在形成过程中不会消耗太多
    CPU 资源。'
- en: '**Fragment shaders**: These shaders are written in OpenGL Shading Language.
    As the name suggests, they work on each pixel. They use very heavy computation
    and hence are avoided when too many shaders are required.![Shaders](img/4201_07_07.jpg)'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这些着色器是用 OpenGL 着色语言编写的。正如其名所示，它们作用于每个像素。它们使用非常重的计算，因此在需要太多着色器时会被避免。![着色器](img/4201_07_07.jpg)'
- en: A graphical representation of the vertex and fragment shaders
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 顶点和片段着色器的图形表示
- en: A fact about using custom shaders
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用自定义着色器的注意事项
- en: Writing your own shaders is a complicated task if you have not done GLSL code
    before, but it makes sense to add shader scripts to an existing Sprite Kit.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前没有做过 GLSL 代码，编写自己的着色器是一项复杂的工作，但将着色器脚本添加到现有的 Sprite Kit 中是有意义的。
- en: You can easily procure shader files online from various websites and start working
    on them. From websites such as [https://www.shadertoy.com/](https://www.shadertoy.com/)
    or [www.glslsandbox.com](http://www.glslsandbox.com), and so on, you will get
    a simple text file with the extension, `.fsh`. Then you just have to add that
    shader code wherever you require.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从各种网站轻松获取着色器文件，并开始工作。例如，从 [https://www.shadertoy.com/](https://www.shadertoy.com/)
    或 [www.glslsandbox.com](http://www.glslsandbox.com) 等网站，您将获得一个具有 `.fsh` 扩展名的简单文本文件。然后您只需将着色器代码添加到您需要的地方即可。
- en: Now, let's discuss about initialization and creation of new shader objects in
    our game.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论一下在我们的游戏中初始化和创建新着色器对象。
- en: The creation and initialization of new shader objects
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新着色器对象的创建和初始化
- en: 'The methods are discussed as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 方法如下所述：
- en: '`Init! (name: string)`: This method initializes a new shader object by utilizing
    a fragment shader from a file present in the `app` bundle with a `.fsh` file extension.
    You pass the name of the file as a parameter and get a newly initialized shader
    object as the return value.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init! (name: string)`：此方法通过利用 `app` 包中具有 `.fsh` 文件扩展名的片段着色器文件来初始化一个新的着色器对象。您传递文件名作为参数，并返回一个新初始化的着色器对象。'
- en: '`Init (source: String!, uniforms: [AnyObject]!)`: This method also initializes
    a new shader object using the specified source. But along with that, we can also
    set a list of `uniforms` to be added to the shader object. Uniforms are the way
    to access the data in fragment shaders. Uniforms have the same value for each
    pixel, for example, the size of the resulting image. We get an initialized shader
    object with this initializer.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init (source: String!, uniforms: [AnyObject]!)`：此方法还使用指定的源初始化一个新的着色器对象。但除此之外，我们还可以设置一个要添加到着色器对象的
    `uniforms` 列表。Uniforms 是访问片段着色器中数据的方式。Uniforms 对每个像素具有相同的值，例如，结果的图像大小。我们通过这个初始化器获得一个初始化的着色器对象。'
- en: '`Init (source: string!)`: This method initializes a new shader object with
    the `string` that contains the initial `source` for the shader object.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Init (source: string!)`：此方法使用包含着色器对象初始 `source` 的 `string` 初始化一个新的着色器对象。'
- en: Let's discuss about properties and methods which can be used for uniform data
    with shader objects.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下可以用于着色器对象中统一数据的属性和方法。
- en: Uniform data in shaders
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 着色器中的统一数据
- en: 'The methods are detailed as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 方法如下所述：
- en: '`addUniform(uniform: SKUniform)`: This method adds a `uniform` object to the
    shader object. It takes the `uniform` object to be added as its parameter.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addUniform(uniform: SKUniform)`：此方法将一个 `uniform` 对象添加到着色器对象中。它接受要添加的 `uniform`
    对象作为其参数。'
- en: '`removeUniformNamed(name: String)`: This method removes a `uniform` object
    from the shader object.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeUniformNamed(name: String)`：此方法从着色器对象中删除一个 `uniform` 对象。'
- en: '`uniformNamed(name: String)`: This method returns the `uniform` object resembling
    a particular `uniform` variable. If the `uniform` object is not found, it returns
    `nil`.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`uniformNamed(name: String)`: 此方法返回类似于特定`uniform`变量的`uniform`对象。如果未找到`uniform`对象，则返回`nil`。'
- en: '`var uniforms: [AnyObject]`: This property has a list of all `uniforms` correlating
    with the shader.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`var uniforms: [AnyObject]`: 此属性包含与着色器相关联的所有`uniforms`列表。'
- en: To hold uniform data for a custom OpenGL SL shader, we use the `SKUniform` object.
    The uniform data is usable for all shaders that include the `uniform`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保存自定义OpenGL SL着色器的统一数据，我们使用`SKUniform`对象。统一数据对所有包含`uniform`的着色器都是可用的。
- en: Implementing shaders in the Platformer game
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在平台游戏中实现着色器
- en: Let's implement shaders in our *Platformer* game and understand the integration
    of shaders much more closely.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在*平台游戏*中实现着色器，并更深入地了解着色器的集成。
- en: Let's create a new `SKScene` in our game and load shaders there. We can have
    a button on the menu scene, which can take us to this scene.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在游戏中创建一个新的`SKScene`并在此处加载着色器。我们可以在菜单场景中放置一个按钮，它可以将我们带到这个场景。
- en: Now add a new `swift` file with the name, `ShaderDemo.swift`, into our project.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将一个名为`ShaderDemo.swift`的新`swift`文件添加到我们的项目中。
- en: 'Create a `SKSpriteKit` node with the name ,`box`, and import an image, `box.png`,
    of size 300 x 300 px. The box can be of any color but should only have one single
    color in it with no design of any kind. We are using this box image to add the
    shader effect inside the boundaries of the box. Also, set the position of the
    box image within the `didMoveToView()` method of `ShaderDemo.swift`:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`box`的`SKSpriteKit`节点，并导入一个300 x 300 px大小的图像`box.png`。盒子可以是任何颜色，但应该只有一个颜色，没有任何设计。我们使用这个盒子图像在盒子的边界内添加着色器效果。同时，在`ShaderDemo.swift`的`didMoveToView()`方法中设置盒子图像的位置：
- en: '[PRE4]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Next, we have to create the actual shader program, create a new empty file
    with the name, `blurShader.fsh`. We can get the code for this shader from any
    online resource. The following code has been fetched from [www.shadertoy.com](http://www.shadertoy.com).
    Thanks to the Shadertoy team and its contributors for such a concise resource
    for us all. The `blurShade.fsh` file should look like the following code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建实际的着色器程序，创建一个名为`blurShader.fsh`的新空文件。我们可以从任何在线资源获取此着色器的代码。以下代码是从[www.shadertoy.com](http://www.shadertoy.com)获取的。感谢Shadertoy团队及其贡献者为我们提供了如此简洁的资源。《blurShade.fsh》文件应如下所示：
- en: '[PRE5]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, we just need to create the `SKShader` object with the pattern. Give `blurshade.fsh`
    as a file name and add it to the sprite node in the `didMoveToView()` method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们只需要使用模式创建`SKShader`对象。将`blurshade.fsh`作为文件名，并在`didMoveToView()`方法中将它添加到精灵节点中：
- en: '[PRE6]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As `ShaderDemo.fsh` is ready to run, let''s also add a `BACK` button in the
    shader scene for the user to go back to the previous screen. `ShaderDemo.swift`
    should look like the following:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于`ShaderDemo.fsh`已经准备好运行，让我们也在着色器场景中添加一个`BACK`按钮，以便用户可以返回到上一个屏幕。`ShaderDemo.swift`应如下所示：
- en: '[PRE7]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following image shows how the code shader effect will look:'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下图像显示了代码着色器效果的外观：
- en: '![Implementing shaders in the Platformer game](img/4201_07_04.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![在平台游戏实现着色器](img/4201_07_04.jpg)'
- en: 'Let''s also set up a button in `MenuScene.swift` for the user to go to the
    `ShaderDemo` scene. Following is the code for adding this button:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也在`MenuScene.swift`中设置一个按钮，以便用户可以转到`ShaderDemo`场景。以下是为添加此按钮的代码：
- en: '[PRE8]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, the code is ready. For the sake of presentation, let''s also add a transition
    for the button to present a shader scene when it is clicked:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，代码已经准备好了。为了展示，让我们也为按钮添加一个过渡效果，以便在点击时呈现着色器场景：
- en: '[PRE9]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Call this method from the `touchesBegan()` method by checking a condition if
    the node name equal to `"SHADOWS"` as we want both, the **PLAY** button and the
    **SHADOW EFFECT** button on the menu screen:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查节点名称是否等于`"SHADOWS"`来从`touchesBegan()`方法中调用此方法，因为我们想在菜单屏幕上同时有**播放**按钮和**阴影效果**按钮：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now the file is ready to run as it should. The following screenshot shows how
    the main menu screen will look:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在文件已经准备好运行了。以下截图显示了主菜单屏幕的外观：
- en: '![Implementing shaders in the Platformer game](img/4201_07_05.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![在平台游戏实现着色器](img/4201_07_05.jpg)'
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the particle effect and shaders in detail.
    We discussed about the `SKEmitterNode` object and the `SKShader` object, and how
    we can implement them in our *Platformer* game. We have also discussed about adding
    OpenGL ES code in our Sprite Kit project and how we can utilize shaders in our
    game. Now, our *Platformer* game has a particle effect when the player collides
    with the block, and the shader scene is a separate screen to display shader effects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细学习了粒子效果和着色器。我们讨论了`SKEmitterNode`对象和`SKShader`对象，以及如何在我们的*平台游戏*中实现它们。我们还讨论了在Sprite
    Kit项目中添加OpenGL ES代码，以及我们如何在游戏中利用着色器。现在，当玩家与方块碰撞时，我们的*平台游戏*会有粒子效果，着色器场景是一个独立的屏幕，用于显示着色器效果。
- en: In the next chapter, we will add levels in our game, which will further enhance
    the gameplay experience for the user and help them understand the game concepts
    in more detail. We will also add a pause button that will pause the game when
    required.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将为游戏添加关卡，这将进一步提高用户的游戏体验，并帮助他们更详细地理解游戏概念。我们还将添加一个暂停按钮，以便在需要时暂停游戏。
