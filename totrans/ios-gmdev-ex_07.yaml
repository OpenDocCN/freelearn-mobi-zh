- en: Chapter 7. Particle Effects and Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed in detail how to animate nodes, controls,
    the `SceneKit` method, and so on. We also discussed handling scene animations.
    We learned the `SKAction` class properties and methods along with learning about
    various controls by which a game can be played, such as gesture recognition or
    accelerometer.
  prefs: []
  type: TYPE_NORMAL
- en: We added player animations, controls, and actions in our *Platformer* game,
    this has made the game pretty fun to play and interesting to learn.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will study particle effects and shaders in a Sprit Kit game.
    Particle effect is a very exciting ability provided by Sprite Kit. We can generate
    particles using the `SKEmitterNode` object; these particles create beautiful visual
    effects such as rain, fire, bokeh, spark, and so on. Shaders were introduced in
    Sprite Kit with iOS 8\. Shaders are used to give customized special effects to
    scenes. The `SKShader` class is used to include shaders in our Sprite Kit game.
  prefs: []
  type: TYPE_NORMAL
- en: Particle effects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Particle effects in games is a technique in which small sprites or other graphical
    objects are used to simulate a diffused effect, for example, rendering of the
    following effects by the particle system is very common:'
  prefs: []
  type: TYPE_NORMAL
- en: Fire
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explosion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Smoke
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moving water
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Falling leaves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clouds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fog
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Snow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dust
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Meteors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stars
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Galaxies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Trails
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The entire behavior in particle effect is defined by the emitter node. A particle
    in Sprite Kit is similar to a `SKSpriteNode` object where it renders a textured
    or non-textured image that can be sized, colorized, or blended in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle effects](img/4201_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An example of different effects
  prefs: []
  type: TYPE_NORMAL
- en: The SKEmitter node
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `SKEmitterNode` object is a node that automatically creates and renders
    small sprites. We can configure the emitter node properties from our Xcode itself.
    We use the particle emitter editor for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We can use target nodes to change the destination of particles. Here is a sample
    code snippet to demonstrate how we can implement the same.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Let's discuss the properties and methods that are used while implementing Sprite
    Kit's emitter node.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the particle effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sprite Kit provides properties and variables to customize particle effects
    as per their requirement in a game. Let''s discuss these properties and variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '`var particleBirthRate`: In this property, you define the number of particles
    created by the emitter every second. The default value of this is `0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func advanceSimulationTime( sec:NSTimeInterval )`: This method helps you advance
    the emitter particle simulation. It takes time in seconds as its parameter, which
    is the time required to simulate. Preferably, this method is used to preoccupy
    an emitter node with particles after its addition to scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var numParticlesToEmit`: In this property, you define the number of particles
    the emitter has to emit. By default, its value is `0`, which means that the emitter
    creates infinite particles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`func resetSimulation ()`: This method removes all the particles and restarts
    the simulation. Resetting the simulation clears its internal state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var targetNode`: As discussed earlier, we can use `targetNode` to change the
    destination of the particles. If the property is `nil`, then the particles are
    treated to be children of the emitter node. When this property points to the target
    node, then new particles are treated as if they are children of the target node,
    but the previously generated particles are calculated based on the emitter node''s
    properties. Its default value is nil.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Properties for determining a particle's lifetime
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is the time for which the user-created particle will stay alive and functional.
    When the lifetime drains out and drops below zero, the particle will be killed.
  prefs: []
  type: TYPE_NORMAL
- en: '`var particleLifetime`: This property determines the average lifetime of a
    particle in seconds. Its default value is `0.0`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var particleLifetimeRange`: We specify a range in this property, the lifetime
    of a particle is determined randomly within this range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's now time to add a particle effect in our *Platformer* game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the particle effect in our Platformer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's integrate particle effect at player collision in our *Platformer* game.
    We will make a particle simulation at the time of collision between blocks and
    the player.
  prefs: []
  type: TYPE_NORMAL
- en: As an initial step for implementation, lets create a particle effect. Go to
    the **Project Navigator** and add new **File** | **SpriteKit Particle File** |
    **Spark** | **Create**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the particle effect in our Platformer game](img/4201_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You can choose from a list of particle templates, such as **Snow**, **Bokeh**,
    **Fire**, **Rain**, **Spark**, and so on. Here we are using the **Spark** effect
    template:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the particle effect in our Platformer game](img/4201_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Open the `ParticleEffectPlayerCollide.sks` file we just created. Particle effect
    files are saved with the extension, `.sks`. You can change the different properties
    of selected particle effects using the particle emitter editor, which you can
    access on the right-hand side.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the particle effect in our Platformer game](img/4201_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The particle emitter editor in Sprite Kit
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s discuss some of the properties, which are displayed on the **SpriteKit
    Particle Emitter** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Particle Texture**: You can select an image to be used for creating the particle.
    For particle texture, images related to the project can also be used. To assign
    the image, one must keep in mind that a complex and larger image will require
    excessive use of resources. A simple and small image is advisable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Birthrate**: This property is used to set the rate at which the emitter generates
    the particles. If the birthrate is more than the particle effect, it will look
    more intensive. So, it''s always recommended to follow the lower birthrate for
    an optimum frame rate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lifetime**: This property will define the total lifetime of the particle
    on the screen. Here, **Range** refers to the random value from the first value
    **+** or **-** range.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Position Range**: This property will tell you how far from the origin emitter
    node the effect should be, using **X** and **Y** co-ordinate values. Change in
    this property affects the size of the emitter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Angle**: This property will tell the angle in which the particle effect should
    happen. This will also use the **Start** and **Range** values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Speed**: This property will define the initial speed at which the effect
    should happen. This will also use the **Start** and **Range** values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Acceleration**: This property will take care of the acceleration at which
    the particles should appear from the source emitter using **X** and **Y** coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alpha**: This property will take care of the transparency of the effect.
    This will also use the **Start** and **Range** values with a **Speed**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scale**: This property will define the **Scale** position for the texture/image
    that is used for the effect. This will also use the **Start**, **Range**, and
    **Speed** values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotation**: This property is used to define the **Rotation** speed for the
    particle effect. This will also use the **Start**, **Range**, and **Speed** values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **Color Blend** factor: This property is used to define the color that
    is used in the particle effect lifetime. Where the particles may follow different
    colors in their particle lifetime. This will use the **Factor**, **Range**, and
    **Speed** values for defining the property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the code to facilitate the particle effect
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once you are done with setting up the desired properties, create a particle
    node object (the `SKEmitterNode` object) in the `GameScene.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, set the position in the `didMoveToView()` method and also hide the particle
    node that is created. Finally, add the particle node into the player. Now the
    `didMoveToView()` method should look like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's define when this particle effect should happen, un-hiding the `particlePlayerNode`
    we created within the `didBeginContact()` method, as this method will be called
    whenever the collision happens.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `didBeginContact` method should look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the collision will look with the particle effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the code to facilitate the particle effect](img/4201_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have successfully added the particle effect in our *Platformer* game,
    and it's time to discuss about shaders and how we can add them in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shaders in Sprite Kit facilitate `SKScenenode` to appear with a special, customized,
    drawing behavior. This can be achieved by creating the `SKShader` objects and
    assigning a custom OpenGL ES fragment shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a custom shader (the `SKShader` object) needs to provide a uniform shader,
    then you need to create one or more `SKUniform` objects and associate them with
    your shader objects. Shader programs are primarily divided into:'
  prefs: []
  type: TYPE_NORMAL
- en: Vertex shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragment shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s discuss about both of these in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Vertex shaders**: These shaders work on each vertex and most of the calculation
    is done on the vertex part. They are set by Sprite Kit automatically. As the computation
    of these shaders are mostly done on the vertex part, not much of the CPU''s resources
    are consumed in the formation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fragment shaders**: These shaders are written in OpenGL Shading Language.
    As the name suggests, they work on each pixel. They use very heavy computation
    and hence are avoided when too many shaders are required.![Shaders](img/4201_07_07.jpg)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A graphical representation of the vertex and fragment shaders
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A fact about using custom shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Writing your own shaders is a complicated task if you have not done GLSL code
    before, but it makes sense to add shader scripts to an existing Sprite Kit.
  prefs: []
  type: TYPE_NORMAL
- en: You can easily procure shader files online from various websites and start working
    on them. From websites such as [https://www.shadertoy.com/](https://www.shadertoy.com/)
    or [www.glslsandbox.com](http://www.glslsandbox.com), and so on, you will get
    a simple text file with the extension, `.fsh`. Then you just have to add that
    shader code wherever you require.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's discuss about initialization and creation of new shader objects in
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: The creation and initialization of new shader objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The methods are discussed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Init! (name: string)`: This method initializes a new shader object by utilizing
    a fragment shader from a file present in the `app` bundle with a `.fsh` file extension.
    You pass the name of the file as a parameter and get a newly initialized shader
    object as the return value.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Init (source: String!, uniforms: [AnyObject]!)`: This method also initializes
    a new shader object using the specified source. But along with that, we can also
    set a list of `uniforms` to be added to the shader object. Uniforms are the way
    to access the data in fragment shaders. Uniforms have the same value for each
    pixel, for example, the size of the resulting image. We get an initialized shader
    object with this initializer.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Init (source: string!)`: This method initializes a new shader object with
    the `string` that contains the initial `source` for the shader object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss about properties and methods which can be used for uniform data
    with shader objects.
  prefs: []
  type: TYPE_NORMAL
- en: Uniform data in shaders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The methods are detailed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addUniform(uniform: SKUniform)`: This method adds a `uniform` object to the
    shader object. It takes the `uniform` object to be added as its parameter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeUniformNamed(name: String)`: This method removes a `uniform` object
    from the shader object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`uniformNamed(name: String)`: This method returns the `uniform` object resembling
    a particular `uniform` variable. If the `uniform` object is not found, it returns
    `nil`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`var uniforms: [AnyObject]`: This property has a list of all `uniforms` correlating
    with the shader.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To hold uniform data for a custom OpenGL SL shader, we use the `SKUniform` object.
    The uniform data is usable for all shaders that include the `uniform`.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing shaders in the Platformer game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's implement shaders in our *Platformer* game and understand the integration
    of shaders much more closely.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new `SKScene` in our game and load shaders there. We can have
    a button on the menu scene, which can take us to this scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now add a new `swift` file with the name, `ShaderDemo.swift`, into our project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a `SKSpriteKit` node with the name ,`box`, and import an image, `box.png`,
    of size 300 x 300 px. The box can be of any color but should only have one single
    color in it with no design of any kind. We are using this box image to add the
    shader effect inside the boundaries of the box. Also, set the position of the
    box image within the `didMoveToView()` method of `ShaderDemo.swift`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we have to create the actual shader program, create a new empty file
    with the name, `blurShader.fsh`. We can get the code for this shader from any
    online resource. The following code has been fetched from [www.shadertoy.com](http://www.shadertoy.com).
    Thanks to the Shadertoy team and its contributors for such a concise resource
    for us all. The `blurShade.fsh` file should look like the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we just need to create the `SKShader` object with the pattern. Give `blurshade.fsh`
    as a file name and add it to the sprite node in the `didMoveToView()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As `ShaderDemo.fsh` is ready to run, let''s also add a `BACK` button in the
    shader scene for the user to go back to the previous screen. `ShaderDemo.swift`
    should look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following image shows how the code shader effect will look:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Implementing shaders in the Platformer game](img/4201_07_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Let''s also set up a button in `MenuScene.swift` for the user to go to the
    `ShaderDemo` scene. Following is the code for adding this button:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, the code is ready. For the sake of presentation, let''s also add a transition
    for the button to present a shader scene when it is clicked:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Call this method from the `touchesBegan()` method by checking a condition if
    the node name equal to `"SHADOWS"` as we want both, the **PLAY** button and the
    **SHADOW EFFECT** button on the menu screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the file is ready to run as it should. The following screenshot shows how
    the main menu screen will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing shaders in the Platformer game](img/4201_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about the particle effect and shaders in detail.
    We discussed about the `SKEmitterNode` object and the `SKShader` object, and how
    we can implement them in our *Platformer* game. We have also discussed about adding
    OpenGL ES code in our Sprite Kit project and how we can utilize shaders in our
    game. Now, our *Platformer* game has a particle effect when the player collides
    with the block, and the shader scene is a separate screen to display shader effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will add levels in our game, which will further enhance
    the gameplay experience for the user and help them understand the game concepts
    in more detail. We will also add a pause button that will pause the game when
    required.
  prefs: []
  type: TYPE_NORMAL
