- en: Chapter 6. Audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds and music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modifying audio properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fading sounds and music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using audio in a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using positional audio in a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metering background music
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Metering dialogue for animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recording audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Streaming audio
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the iPod music library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a MIDI synthesizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Speech recognition and text to speech
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Depending on what kind of game you're making, adding audio can be anything from
    a simple to a daunting task. In this chapter we will integrate sounds and music
    into game examples. We will also use advanced audio techniques like metering,
    recording, speech recognition, and more.
  prefs: []
  type: TYPE_NORMAL
- en: Playing sounds and music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most games use a variety of sound effects and at most a few different background
    music tracks. **CocosDenshion** is the audio library built into Cocos2d. It provides
    a number of features including the **SimpleAudioEngine** API. In this recipe,
    we will use this API to play sounds and music.
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing sounds and music](img/4002_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `SimpleAudioEngine` class provides the user with a very simple interface
    for basic audio playback. The `[SimpleAudioEngine sharedEngine]` singleton is
    merely a simplified wrapper over the `[CDAudioManager sharedManager]` singleton
    provided by CocosDenshion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initialization:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No initialization of `SimpleAudioEngine` is necessary. In this recipe we simply
    maintain a pointer to `[SimpleAudioEngine sharedEngine]` to shorten some code.
    We set **resign behavior** using the following line. This changes audio behavior
    when the application is suspended or otherwise interrupted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This overrides the `applicationWillResignActive` method specified under the
    `UIApplicationDelegate` implemented by `CDAudioManager`. Other resign types are
    defined in `CDAudioManager.h`. This one stops background music on resign (pressing
    the home button on an iOS device) and plays the background music when the application
    becomes active.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Playing sound effects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each sound effect that we''ll play is an instance of `CDSoundSource`. "Loading"
    a sound effect involves pre-loading it using `SimpleAudioEngine`. Playing a sound
    without pre-loading it will result in a delay and diminished sound quality. To
    pre-load a sound, use the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Initializing a `CDSoundSource` object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And finally, maintaining a reference to that object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To play a sound, we simply get the reference and call the play method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`SimpleAudioEngine` hides all the complex aspects of this process.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Playing background music:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Playing background music is similar to playing sound effects except that there
    can only be one piece of background music playing at a given time:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If necessary you can obtain a reference to the actual background music `CDLongAudioSource`
    object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This class is optimized for longer pieces of audio like music and narration.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Real time audio decoding and playback, especially on a mobile device, requires
    the use of specific audio formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'CDSoundSource formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The recommended encoding for sound effects is **16-bit Mono Wave** for uncompressed
    audio files and **IMA4** in a **CAF** container for lossy audio files.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Converting to IMA4 audio files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On a Unix-based system, you can use the **afconvert** tool to convert from
    a number of formats to IMA4:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'CDLongAudioSource formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the playback of music and other long audio, any format supported by Apple's
    `AVAudioPlayer` will work. The format typically used is **MP3**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Memory sizes:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Although compressing audio reduces disk space requirements, all sound effects
    are stored in memory as **16-bit uncompressed PCM**. So, compressing sound effects
    will not reduce your application's memory footprint. This becomes a factor for
    larger and more sound intensive games.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Modifying audio properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CocosDenshion provides functionality to change the **pitch, gain**, and **pan**
    properties of an audio source. Pitch is the frequency, gain is volume, and pan
    is a way to shift volume between left and right speakers. In this example, we
    will create a music-bending instrument to display these properties being dynamically
    modified.
  prefs: []
  type: TYPE_NORMAL
- en: '![Modifying audio properties](img/4002_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing needed for this recipe is a short, constant, mid-range synthesized
    tone. This was created in **GarageBand** and then modified using **Audacity**.
    When you touch the screen the note is played:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we need to set the `pitch` between 0 and 2 according to the X position
    of the touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We set the `gain` property between 0 and 1 according to the Y position of the
    touch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Tilting the device will set the `pan` property. Tilt to the left to hear all
    tones more in your left ear and to the right to hear them more in your right:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see (and hear), audio properties can be modified in real time, while
    a sound is playing, to create really cool effects.
  prefs: []
  type: TYPE_NORMAL
- en: There's More...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `@"synth_tone_mono.caf"` file used in this recipe is specifically encoded
    as a **mono** sound effect. This is because the **pan** property can only be set
    on a mono sound effect.
  prefs: []
  type: TYPE_NORMAL
- en: Fading sounds and music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Taking a queue from Cocos2d actions, CocosDenshion provides a few classes for
    fading sounds and music. These are `CDLongAudioSourceFader` and `CDXPropertyModifierAction`.
    In this example, we will see how to fade in/out all sounds, individual sounds,
    and music. We will also see how to crossfade two music sources.
  prefs: []
  type: TYPE_NORMAL
- en: '![Fading sounds and music](img/4002_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project RecipeCollection02 for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we use `CDLongAudioSource` directly as opposed to using the
    `backgroundMusic` source provided by `SimpleAudioEngine`. This allows us to have
    more than one long audio source playing at a given time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Crossfading long audio sources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Crossfading involves fading one source in and one source out at the same time.
    First, we initialize a `CDLongAudioSourceFader` object to specify fading values
    and an interpolation type:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, we want to fade out linearly starting from the source''s current
    volume. We then create a `CDXPropertyModifierAction` object with specified duration.
    We also release the fader object at this point:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After fading the track out, we want to stop it from playing. For this, we create
    a `CCCallFuncN` action:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we run these actions in sequence:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Running this action, along with the "fade in" action for the other track, will
    create the desired crossfading effect.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fading individual sound effects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `CDXPropertyModifierAction` class has a convenience method for fading individual
    sound effects:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the previous example, we fade out the specified sound source for 2 seconds
    and then stop the source from playing when we're finished.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fading out all sound effects:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All currently playing sound effects can be faded out as well using the following
    convenience method:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This applies the same "fade out" effect to all playing sound effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using audio in a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While `SimpleAudioEngine` may be simple, it is efficient enough to be used in
    any type of game. In this recipe, we will add sounds and music to the **Bullets**
    demo from [Chapter 4](ch04.html "Chapter 4. Physics"),
  prefs: []
  type: TYPE_NORMAL
- en: '![Using audio in a game](img/4002_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the techniques described in this chapter, we can breathe some life into
    our box-shooting demo by adding sounds and music.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sound buffers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, `CDAudioManager` allocates one sound buffer per sound source. So,
    every time we play the `@"bullet_fire_no_shell.caf"` sound effect we effectively
    stop that sound effect from playing if it was already in the process of playing.
    This is adequate for the majority of in-game sound effect use cases.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finding sound effects to use in your game can be a fun yet tedious process.
    Even though there exists a large number of royalty free sound effects floating
    around, it''s often difficult to find the right one for a given situation. Alternatively,
    a microphone and some audio generation and manipulation software can go a long
    way. For example, the effect `@"bullet_casing_tink.caf"` was created by playing
    the highest note on a piano using GarageBand. Another program, **sfxr**, can be
    used to generate simple 8-bit style sound effects. The Cocoa version, **cfxr**,
    can be downloaded here: [http://thirdcog.eu/apps/cfxr](http://thirdcog.eu/apps/cfxr).'
  prefs: []
  type: TYPE_NORMAL
- en: Using positional audio in a game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To increase the realism of the sounds we use in a game, we can modify audio
    properties based on in-game factors. In this example, we use **source distance,
    audible range**, and **object size** to determine **gain, pitch**, and **pan**.
    We'll demonstrate this by adding sounds to the **TopDownIsometric** demo from
    [Chapter 4](ch04.html "Chapter 4. Physics"),
  prefs: []
  type: TYPE_NORMAL
- en: '![Using positional audio in a game](img/4002_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating a realistic soundscape involves changing audio properties in creative
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'Forest ambience:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For this recipe, we have a 30 second looping clip of forest ambience playing
    in place of background music. We determine the `gain` property of this sound source
    based on the player''s distance from the closest tree:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If all trees are outside the audible range then we set the `gain` to zero.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Ball bounce sounds:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To create a compelling ball bounce sound effect, we modify all three audio
    properties. The `gain` property is determined by distance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `pan` property is determined by X plane distance:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, the `pitch` property is determined by the ball''s size:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Together, these modifications create a variety of unique sounds. This adds depth
    to the auditory experience.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using multiple sound buffers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we have multiple balls initiating bounce sound effects at the same
    time, a single buffer will no longer suffice. We now need the same sound to play
    over itself many times. To accomplish this we use a special **Source Group**.
    A source group is simply a way to group sounds together to manipulate how they
    get played. For example, you might want two sound sources to share a buffer. In
    this case, we specify a source group as being non-interruptible:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, all sounds played using this source group will be given an open buffer.
    To specify a source group when playing a sound we use the following line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, multiple ball bounce sound effects can be heard over each other with different
    audio properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Maximum number of buffers:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The maximum number of sound buffers available and the buffer increment is specified
    in `CDConfig.h`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the default case, after 64 buffers are filled up, another 16 are allocated.
    These can be customized for applications with specific audio requirements.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Metering background music
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `CDAudioManager` class wraps the `AVAudioPlayer` class. Using this class
    gives us access to lower level audio functions. In this recipe, we will dynamically
    read the **average level** and **peak level** of background music currently playing.
    We can use this information to sync or cue animations.
  prefs: []
  type: TYPE_NORMAL
- en: '![Metering background music](img/4002_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Accessing the dynamic metering functionality requires the use of the `audioSourcePlayer`
    reference inside a `CDLongAudioSource` object, in this case, `backgroundMusic`.
    Before we can begin, we enable metering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, every cycle we collect the **average** and **peak** decibel levels for
    all playing channels. We average these numbers out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: After that we convert our average and peak decibel levels to ratios between
    0 and 1\. This makes the numbers easier to apply to animations.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We also split the difference when setting the new `peakPower` and `avgPower`
    variables. This smooths out harsh changes in volume.
  prefs: []
  type: TYPE_NORMAL
- en: Metering dialogue for animation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `LongAudioSource` object can be any kind of audio, not just music. In this
    recipe, we will use the metering technique to animate the mouth of the gregarious
    Senator Beauregard Claghorn.
  prefs: []
  type: TYPE_NORMAL
- en: '![Metering dialogue for animation](img/4002_06_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Execute the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Like in the previous recipe, we use the information collected from `setPeakAndAveragePower`
    to run an animation. Unlike the previous recipe, we have a number of `CDLongAudioSource`
    objects to choose from. Here, we find the source that is currently playing and
    use it for metering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'After calculating `avgPower`, we then exaggerate the peaks and valleys of that
    number to help simulate the rapid opening and closing of Claghorn''s mouth:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In addition to this, we animate blinking, eye movement, and eyebrows. Put together,
    the linking of multiple animations with metering creates a nice mouth movement
    effect.
  prefs: []
  type: TYPE_NORMAL
- en: Streaming audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 1](ch01.html "Chapter 1. Graphics"), *Graphics*, we used the `MPMoviePlayerController`
    class to play full motion video. In this recipe, we will use a similar technique
    to create a streaming audio player.
  prefs: []
  type: TYPE_NORMAL
- en: '![Streaming audio](img/4002_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Link the `MediaPlayer` framework to your project. Now, execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This recipe works in a way similar to that of what we saw in [Chapter 1](ch01.html
    "Chapter 1. Graphics"), *Graphics*. One key difference is, here we specify the
    `mediaSourceType`, and we also hide the player from view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the player for audio streaming.
  prefs: []
  type: TYPE_NORMAL
- en: Reaching the `AppDelegate:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In **Cocos2d**, the `AppDelegate` class is the top-level class that implements
    the `UIApplicationDelegate` protocol. This protocol specifies the delegate to
    which the main `UIApplication` singleton points to. This delegate handles important
    application events. To add our `moviePlayer` object to our view, we access this
    delegate through the `UIApplication` singleton:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, this involves **casting** the `delegate` property into the `AppDelegate*`
    type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Switching stations:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Changing the streaming source involves stopping playback and changing the `contentURL`
    property:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This way the user can change channels seamlessly while maintaining playback.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Live streaming formats:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The stream source examples used in this recipe use Apple''s **HTTP Live Streaming**
    protocol. This allows elegant live streaming over **HTTP** with minimum hassle.
    You can read more about this protocol here: [http://developer.apple.com/resources/http-streaming/](http://developer.apple.com/resources/http-streaming/).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Streaming files:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single files, using formats like **MP3**, can also be streamed over a simple
    **HTTP** server using this technique.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Streaming video:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By combining this recipe with the video playback recipe in Chapter 1, Graphics,
    you can also stream video. Compatible formats and other requirements are detailed
    at the aforementioned site. As a good rule of thumb, any file type or URL that
    can be played using the iOS device's built in **Safari** web browser can usually
    also be played using `MPMoviePlayerController`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously, we mentioned the `UIApplication` **singleton**. A singleton is a
    top-level global object instantiated at runtime. Cocos2d largely embraces the
    singleton pattern. Any object accessed by executing a class method starting with
    the word "shared" ([Class `sharedClass])` is, by convention, a singleton. You
    can create your own custom singleton objects using the **macro** encapsulated
    in the `SynthesizeSingleton.h` file. For more information about this, please consult
    the *More Recipes* section of the **Cocos2d Cookbook website** at [http://cocos2dcookbook.com/more_recipes](http://cocos2dcookbook.com/more_recipes).
  prefs: []
  type: TYPE_NORMAL
- en: Recording audio
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A notable feature on most iOS devices is the ability to record audio. In this
    recipe, we will use the microphone to record audio and save it to a temporary
    location on the disk using the `AVAudioRecorder` class. We will then play it back
    with a modified pitch using the `CDSoundEngine` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Recording audio](img/4002_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Link the `CoreAudio` and `AVFoundation` frameworks to your project. Now, execute
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recording and playing back audio will introduce us to a few new classes and
    concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the audio session:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we want to record audio, we have to set up a specific **audio session**.
    An audio session is a way of configuring the settings we will currently use for
    audio input and output. The `AVAudioSession` singleton encapsulates this functionality.
    First, we need to set up the **session category** to allow recording and playback:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then we need to activate the session:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: CocosDenshion normally does these things, but in this recipe, we need more granular
    control over the audio system.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Initializing CDSoundEngine:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here we also initialize a `CDSoundEngine` object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will use this to play back our recorded audio.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Recording audio:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The crux of the recipe, recording the audio, requires a few steps. First, we
    initialize the `AVAudioRecorder` object with the audio recording format and where
    we want to store our recorded audio:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We specify our delegate object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we start recording:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Recording will last until we call the stop routine:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Recording will not stop until either the recorder receives a `stop` message
    or the delegate receives an error. For example, the disk could be full.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `AVAudioRecorderDelegate` protocol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By specifying our `Ch6_RecordingAudio` class as adhering to the `AVAudioRecorderDelegate`
    protocol, we agree to handle a number of method calls including errors. If we
    fail to do so, these errors are thrown. In this example, we bypass this step for
    the sake of brevity, but in a professional app it is recommended that you handle
    any messages the `AVAudioRecorder` class might want to pass on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Playing our recorded audio:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once the recorded audio is stored on the disk, we can play it back. On the
    iPhone the speaker output is re-routed to the earbud speaker when the audio session
    category is `AVAudioSessionCategoryPlayAndRecord`. So, before we can properly
    play back the recorded audio we must reroute playback to the speakers:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, using `CDSoundEngine`, we can load the recorded audio into a buffer and
    play it back:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the above line, the **pitch, pan,** and **gain** properties can be modified.
    In this example, you can modify the pitch. Try recording your voice and then bending
    the pitch.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using the iPod music library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes a user might want to substitute a musical track from his or her personal
    collection into the background of your game. In this example, we will create a
    simple music player that can load songs, albums, and playlists from the **iPod
    music library** on the device.
  prefs: []
  type: TYPE_NORMAL
- en: '![Using the iPod music library](img/4002_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Link the `MediaPlayer` framework to your project. Now, execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Pressing the green button opens the standard iPod media picker. Some games opt
    to create their own picker to better match their user interface. In this example,
    we chose the default media picker for the sake of simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Initializing `MPMusicPlayerController:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'First, we create our `MPMusicPlayerController` object:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We set our player to `MPMusicRepeatModeAll`, so our `nextSong` and `previousSong`methods
    can wrap playing songs.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Getting **Now Playing** audio information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Every time the **Now Playing** item changes, we would like to be notified so
    we can fetch media information. To do this, we set our recipe object as an observer
    of the `musicPlayer` object and allow this type of notification to be received:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As an observer, our class will be notified by a call to the `handleNowPlayingItemChanged`
    method. Here, we inspect the currently playing `MPMediaItem` object for information
    including song title, artist name, album name, and album art:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We then take this created `UIImage` object and place it into the scene using
    a technique described in Chapter 1, Graphics
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using `MPMediaPickerController:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When a user touches the green button, then we initialize a `MPMediaPickerController`
    object and specify its delegate:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We then add the picker to the screen presenting it as a ''modal view''. This
    lets us animate the picker sliding onto the screen:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With the picker open the user can choose from songs, playlists, albums, and
    so on.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `MPMediaPickerControllerDelegate:`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In accordance with this delegate, we implement the following methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These correspond to picking at least one item and picking none respectively.
    Upon picking an item or more we dismiss the modal view, add items to our player,
    and then play the first item:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the user did not pick an item, we simple dismiss the modal view controller.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `MPMusicPlayerController` class is actually accessing the iPod functionality
    of the device you''re currently using. Having your app access an external resource,
    adds a couple of extra conditions we need to account for:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Determining the current device type:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As you can see from the previous code, or if you tried running this recipe
    in the simulator, we disable this recipe entirely when not running on a real device.
    We do this because the iPod music player app is not installed on the simulator
    and this will cause errors to be thrown. Determining the device model is simple:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This string will tell you what model your app is running on. In our case we
    check for the string @"iPhone Simulator".
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `UIApplicationDelegate` protocol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Another side effect of using the iPod resource is that music will continue
    to play after suspending our application. Although you can switch to the iPod
    app itself to stop the playing music, we would like to stop it when we suspend
    our app and resume it when we bring the app back. In AppDelegate.mm, our application
    implements some methods specified by the UIApplicationDelegate protocol:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Normally, Cocos2d only calls pause and resume on the CCDirector singleton here.
    We will add code to pause the iPod music player upon suspension and play it upon
    activation:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Other code can go here as needed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Creating a MIDI synthesizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the release of iOS 4.0 the iPhone, iPad, and iPod Touch can now take advantage
    of the powerful **MIDI** protocol. For games that allow the user to generate their
    own sounds and music, or for a game that wants a cool retro sound without a large
    memory footprint, MIDI synthesization is the tool for the job. In this recipe,
    we will create a MIDI synthesizer using the great **MobileSynth** library.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a MIDI synthesizer](img/4002_06_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Please refer to the project *RecipeCollection02* for full working code of this
    recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Link the `AudioToolbox` framework to your project. Now, execute the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This recipe lets you play two **octaves** of synthesized sounds on a virtual
    keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `MIDISampleGenerator` class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `MIDISampleGenerator` class was created specifically for this recipe so
    as to obfuscate some of the grittier details of using MobileSynth. The MobileSynth
    library offers a dizzying array of sound synthesization options to generate sounds.
    These include, to name a few, Modulation, Oscillation, Filter, Arpeggio, and a
    few volume related effects. The **Randomize** button randomizes a number of these
    effects to quickly and easily allow the user to get a feel for the range of synthesization
    possibilities.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Extending the synthesizer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presumably, the synthesizer could be extended to record a song (a series of
    timed notes) to a data file that could then be fed into the synthesizer like a
    player piano. This acts as an easy solution for generating a large amount of retro
    sounding game music that doesn't take up much space (think Mega Man). The same
    thing goes for sound effects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more information about **MobileSynth** you can visit their website: [http://code.google.com/p/mobilesynth/](http://code.google.com/p/mobilesynth/)'
  prefs: []
  type: TYPE_NORMAL
- en: Speech recognition and text-to-speech
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until a fateful combination of machine learning, quantum computing, and 3D printing
    spawns tyrannical artificial lifeforms to rule over all mankind, we need to settle
    for semi-intelligent devices that we program by hand. An important piece of that
    puzzle is language processing. In this recipe, we will use the **OpenEars** library
    to have our iOS device speak and recognize some basic English dialogue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Speech recognition and text-to-speech](img/4002_06_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Due to the size of the libraries required to use **OpenEars**, this recipe has
    its own project. Please refer to the project *Ch6_SpeechRecognition* for full
    working code of this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **OpenEars** installation process is complex. Among other things it requires
    the configuration of four other libraries: **flite, pocketsphinx, sphinxbase**,
    and **wince**. The OpenEars library is itself an embedded XCode project that is
    statically linked to your project.'
  prefs: []
  type: TYPE_NORMAL
- en: It is recommended that you take a look at the `Ch6_SpeechRecognition` project
    first. From there, you can carefully follow the steps listed at [http://www.politepix.com/openears/](http://www.politepix.com/openears/)
    to set up and configure the sample project.
  prefs: []
  type: TYPE_NORMAL
- en: 'After following the steps listed on the "Getting Started" and "Configuring
    Your App For OpenEars" pages you can move on to the "Using OpenEars In Your App"
    page. Here you will be instructed to create a **corpus** file. This is a file
    with all the words and phrases we want OpenEars to recognize. Our corpus file
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We then upload this file to the **Sphinx** Knowledge Base creation tool hosted
    by Carnegie Mellon University at this URL: [http://www.speech.cs.cmu.edu/tools/lmtool-new.html](http://www.speech.cs.cmu.edu/tools/lmtool-new.html).
    The tool will generate a number of files for you. Take the `.lm` file and rename
    it to a `.languagemodel` file. Also download the `.dic` file. Add these files
    to your project as outlined here: [http://www.politepix.com/openears/yourapp/](http://www.politepix.com/openears/yourapp/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re now ready to start coding. Our main piece of code will give the user
    some self-assured HAL 9000 responses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Try saying a few of the lines from the corpus file into the demo app. In a quiet
    room the results can be startlingly accurate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instantiating the audio session, the controllers, and the observer:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we can do anything we need to instatiate the audio session as well as
    the three controllers that provide text to speech and speech recognition functionality:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `PocketsphinxController` object provides the speech recognition API. The
    `FliteController` object provides the text to speech API. Finally, the `OpenEarsEventsObserver`
    provides a protocol that delegates callbacks on behalf of both controllers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using FliteController:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `FliteController` API is very straightforward. Simply call the say method
    and Flite will produce computer-generated speech through the default audio channels.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Using PocketsphinxController:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `PocketsphinxController` API allows you to manage when Pocketsphinx is
    listening and when it is actively trying to recognize speech using the following
    four methods:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This basic level of control lets you manage when processor time is used to actually
    attempt to recognize a speech pattern.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `OpenEarsEventsObserverDelegate` protocol:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This protocol is in charge of calling a number of methods on behalf of `PocketsphinxController`
    and `FliteController`. The important method to take note of is the main Pocketsphinx
    speech recognition hypothesis method. This will tell you what Pocketsphinx heard
    and it will also give it a confidence score:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method will be triggered by any discrete sound as long as Pocketsphinx
    is listening and attempting recognition. However, you can use the `recognitionScore`
    to weed out background noises and other
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
