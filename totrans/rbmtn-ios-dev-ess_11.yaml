- en: Chapter 11. Extending RubyMotion
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。扩展RubyMotion
- en: 'The DRY principle states the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: DRY原则表述如下：
- en: '*"Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system."*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*"系统内每项知识都必须有一个单一、明确、权威的表示。"*'
- en: 'We are now approaching the end of this book. So far we have learned how to
    quickly make iOS applications with RubyMotion. To make this process even more
    rapid, RubyMotion lets us use special RubyMotion-flavored gems and wrappers. **Gems**
    and **wrappers** are Ruby programs that are wrapped into a self-contained format.
    These are generally open source projects, which other developers can use in their
    applications or can even contribute back to these projects. Fortunately, RubyMotion
    has a very enthusiastic community; within months of launching RubyMotion''s tool
    chain, plenty of gems were introduced that implement many laborious tasks fairly
    quickly. In this chapter, we will learn how to augment our application by using
    RubyMotion-flavored gems. The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在正接近本书的结尾。到目前为止，我们已经学习了如何快速使用RubyMotion制作iOS应用程序。为了使这个过程更加迅速，RubyMotion允许我们使用特殊的RubyMotion风格的gem和包装器。"gem"和"包装器"是封装成自包含格式的Ruby程序。这些通常是开源项目，其他开发者可以在他们的应用程序中使用，甚至可以向这些项目做出贡献。幸运的是，RubyMotion有一个非常热情的社区；在RubyMotion的工具链推出几个月后，就引入了许多gem，它们可以相当快速地实现许多繁琐的任务。在本章中，我们将学习如何通过使用RubyMotion风格的gem来增强我们的应用程序。本章将涵盖以下主题：
- en: RubyMotion gems
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion gems
- en: CocoaPods
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CocoaPods
- en: RubyMotion gems
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RubyMotion gems
- en: Use of gems is based on the programming practice of **Don't Repeat Yourself**
    (**DRY**), which states that when some piece of code is ready to use and is available,
    why bother working on it again. The RubyMotion community may be very young right
    now, but it already has some amazing gems that make a lot of tiring tasks pretty
    easy. Some gems even target challenging functionalities in a very simple manner.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: gem的使用基于编程实践**不要重复自己**（**DRY**），它指出，当某些代码准备好使用且可用时，为什么还要再次工作呢。RubyMotion社区可能目前还很年轻，但它已经有一些令人惊叹的gem，可以让许多繁琐的任务变得非常简单。一些gem甚至以非常简单的方式针对具有挑战性的功能。
- en: 'In this chapter we will cover the following RubyMotion-flavored gems:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下具有RubyMotion风格的gem：
- en: Teacup
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Teacup
- en: BubbleWrap
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BubbleWrap
- en: '`motion-addressbook`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion-addressbook`'
- en: Teacup – say goodbye to Xcode and XIB files!
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Teacup – 再见，Xcode和XIB文件！
- en: Designing a UI for iOS apps is a tough job, especially for developers who have
    worked previously on easy-to-learn-and-implement web technologies. **Teacup**
    is a gem that will make your life really easy. Teacup augments your ability to
    quickly design and style the views of your RubyMotion application; you can easily
    create layouts while keeping your code DRY.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为iOS应用程序设计UI是一项艰巨的任务，尤其是对于之前在易于学习和实现的网络技术方面工作的开发者来说。**Teacup**是一个可以使你的生活变得非常简单的gem。Teacup增强了你快速设计和样式RubyMotion应用程序视图的能力；你可以在保持代码DRY的同时轻松创建布局。
- en: 'Let''s create an application and learn how easy it is to use Teacup:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序，并学习使用Teacup有多简单：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We will be using **Bundler** (which is also a Ruby gem) to install all our gems.
    Bundler also helps us manage application dependencies, so that the exact version
    of the gems used are available for the application to run.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Bundler**（它也是一个Ruby gem）来安装所有我们的gem。Bundler还帮助我们管理应用程序依赖项，以确保应用程序运行所需的gem的确切版本可用。
- en: Tip
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Bundler comes as a default dependency manager for popular frameworks such as
    Ruby on Rails.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Bundler是Ruby on Rails等流行框架的默认依赖项管理器。
- en: 'Let''s add Bundler to our application:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将Bundler添加到我们的应用程序中：
- en: 'Update the `Rakefile` with the following lines of code:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行更新`Rakefile`：
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'With Bundler, we require a Gemfile in which we can mention details about the
    gems we will use with our application. Next, let''s create a Gemfile and add the
    following lines of code in it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Bundler，我们需要一个Gemfile，在其中我们可以提及我们将与我们的应用程序一起使用的gem的详细信息。接下来，让我们创建一个Gemfile，并在其中添加以下代码行：
- en: '[PRE2]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: So, in the future, if you want to add any new gem to your project, you can simply
    add it to this file.
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，在未来，如果你想向你的项目添加任何新的gem，你只需简单地将它添加到这个文件中。
- en: 'Next, let''s run `bundle install` and we''re good to go:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们运行`bundle install`，然后我们就可以开始了：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `bundle install` command adds a `Gemfile.lock` file to your repository.
    This ensures that other developers on your app, as well as your deployment environment,
    will all use the same third-party code that you are using now.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`bundle install`命令将一个`Gemfile.lock`文件添加到你的仓库中。这确保了你的应用程序上的其他开发者以及你的部署环境都将使用你现在使用的相同第三方代码。'
- en: 'Next, update the `app_delegate.rb` file with the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，更新`app_delegate.rb`文件，使用以下代码：
- en: '[PRE4]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In this code, we are only initializing an instance of `RootController`, just
    like we do with every application. As you may remember, the controller is where
    all our application logic resides.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们只初始化了一个`RootController`实例，就像我们在每个应用程序中做的那样。你可能还记得，控制器是我们所有应用程序逻辑所在的地方。
- en: So far, in various chapters we have made RubyMotion iOS applications in a traditional
    way. Let's use Teacup in our application this time, and add styles by making use
    of its Cascading Style Sheets (CSS) type syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在各个章节中都是用传统方式制作RubyMotion iOS应用程序。这次让我们在应用程序中使用Teacup，并通过使用其层叠样式表（CSS）类型的语法来添加样式。
- en: 'Let''s create a directory named `style` and add a new file with the name of
    `style.rb` in it. Add the following code to the `style.rb` file in the `style`
    folder:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`style`的目录，并在其中添加一个名为`style.rb`的新文件。将以下代码添加到`style`文件夹中的`style.rb`文件中：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s understand the preceding code:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解前面的代码：
- en: First, we have created a stylesheet named `style`.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个名为`style`的样式表。
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This convention is provided by Teacup to create a new stylesheet.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个约定是由Teacup提供的，用于创建一个新的样式表。
- en: Next, we have created a specific layout for your views, using CSS-based syntax.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用基于CSS的语法为你的视图创建了一个特定的布局。
- en: '[PRE7]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This will create a style named `your_layout` and will enable the landscape rotation
    (otherwise, only portrait orientation is enabled).
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个名为`your_layout`的样式，并启用横屏旋转（否则，只启用竖屏方向）。
- en: Next, we have added style for all `UILabel` instances.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为所有`UILabel`实例添加了样式。
- en: '[PRE8]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The preceding line of code gives text color to all `UILabel` instances that
    are defined inside the style. Since we apply a style to all the labels when using
    `UILabel`, if we want to style a specific element, we have to add the following
    commands:'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前一行代码给所有在样式内定义的`UILabel`实例设置了文本颜色。由于我们在使用`UILabel`时应用了样式，如果我们想对特定元素进行样式化，我们必须添加以下命令：
- en: '[PRE9]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, `label` is like a class. This will do the styling for the label.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`label`就像一个类。这将为标签进行样式化。
- en: 'To understand this better, let''s create a view. Perform the following steps
    to create a view:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，让我们创建一个视图。按照以下步骤创建视图：
- en: 'Create a file named `root_view_controller.rb` and add the following code to
    it:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`root_view_controller.rb`的文件，并将以下代码添加到其中：
- en: '[PRE10]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we have created a new controller file, we must make the corresponding changes
    to the `app_delegate.rb` file. Make these changes in your `app_delegate.rb` file
    as shown in the previous chapters.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们创建了一个新的控制器文件，我们必须对`app_delegate.rb`文件进行相应的更改。按照前几章所示，在`app_delegate.rb`文件中进行这些更改。
- en: 'In the preceding code snippet, first we have given the stylesheet a name, which
    is done using `stylesheet:style`, and then we have specified a layout named `your_layout`
    and passed `label : @label1 = subview(UILabel, :label)` to it.'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '在前面的代码片段中，我们首先给样式表起了一个名字，这是通过`stylesheet:style`完成的，然后我们指定了一个名为`your_layout`的布局，并将`label
    : @label1 = subview(UILabel, :label)`传递给它。'
- en: Let's fire up the terminal and test our application.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端并测试我们的应用程序。
- en: '[PRE11]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following is the output:'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![Teacup – say goodbye to Xcode and XIB files!](img/5220OT_11_01.jpg)'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![Teacup – say goodbye to Xcode and XIB files!](img/5220OT_11_01.jpg)'
- en: We can see the text **Awesome** appear on the simulator screen and it is styled
    as we have defined in the stylesheet.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以看到文本**Awesome**出现在模拟器屏幕上，并且它被格式化为我们在样式表中定义的那样。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Teacup implements the `viewDidLoad` method and instantiates any views. If you
    want to implement your own `viewDidLoad` method, make sure to call super.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Teacup实现了`viewDidLoad`方法并实例化了任何视图。如果你想实现自己的`viewDidLoad`方法，请确保调用super。
- en: We can also define different stylesheets for changing dimensions as we rotate
    the device, such as the landscape and portrait modes. Let's try this in our next
    example.
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还可以定义不同的样式表，以在旋转设备时更改尺寸，例如横屏和竖屏模式。让我们在下一个示例中尝试一下。
- en: 'Now update the stylesheet, that is, the `style.rb` file, with the following
    code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新样式表，即`style.rb`文件，使用以下代码：
- en: '[PRE12]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Run the application and rotate the screen from the simulator menu by navigating
    to **Hardware** | **Rotate Left**. You will see that as the screen rotates the
    background color of the label changes.![Teacup – say goodbye to Xcode and XIB
    files!](img/5220OT_11_02.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，并通过导航到 **硬件** | **向左旋转** 从模拟器菜单旋转屏幕。你会看到，随着屏幕的旋转，标签的背景颜色会改变。![茶杯 – 摆脱
    Xcode 和 XIB 文件！](img/5220OT_11_02.jpg)
- en: 'Now, let''s do a few more things in the same example. Add the following code
    in the `style.rb` file:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在同一个示例中做更多的事情。在 `style.rb` 文件中添加以下代码：
- en: '[PRE13]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here we have created two text field boxes.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里我们创建了两个文本框。
- en: Now, update the `root_controller.rb` file.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，更新 `root_controller.rb` 文件。
- en: '[PRE14]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Let's test our application in the simulator.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模拟器中测试我们的应用程序。
- en: '[PRE15]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The following is the output:'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是其输出：
- en: '![Teacup – say goodbye to Xcode and XIB files!](img/5220OT_11_03.jpg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![茶杯 – 摆脱 Xcode 和 XIB 文件！](img/5220OT_11_03.jpg)'
- en: With the preceding example, we can see how easy it is to design views with the
    Teacup gem; it has delivered a way to create interfaces programmatically with
    ease. We have shared a few of the features of this amazing gem; you can explore
    more at [https://github.com/rubymotion/teacup](https://github.com/rubymotion/teacup).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的示例，我们可以看到使用 Teacup 钩子设计视图是多么简单；它提供了一种轻松地以编程方式创建界面的方法。我们已经分享了这个神奇钩子的一些功能；你可以在
    [https://github.com/rubymotion/teacup](https://github.com/rubymotion/teacup) 上探索更多。
- en: BubbleWrap – making Cocoa APIs more Ruby-like
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BubbleWrap – 使 Cocoa API 更像 Ruby
- en: BubbleWrap is a collection of very well-tested helpers and wrappers used to
    wrap Cocoa SDK code and provide more Ruby-like APIs for RubyMotion. It provides
    wrappers for a lot of iOS Cocoa SDK code, such as camera, notification center,
    HTTP, and many more.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleWrap 是一组经过充分测试的辅助工具和包装器，用于包装 Cocoa SDK 代码，并为 RubyMotion 提供更多类似 Ruby 的
    API。它为许多 iOS Cocoa SDK 代码提供了包装器，例如相机、通知中心、HTTP 等。
- en: 'We can do a lot of things very easily. For example, to perform a `GET HTTP`
    request with BubbleWrap, we require the following simple code snippet:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非常容易地做很多事情。例如，要使用 BubbleWrap 执行 `GET HTTP` 请求，我们需要以下简单的代码片段：
- en: '[PRE16]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In [Chapter 6](ch06.html "Chapter 6. Device Capability – Power Unleashed"),
    *Device Capability – Power Unleashed*, we have learned about device capabilities—implementing
    camera functionalities in your app. We have written quite a lot of code there,
    but with BubbleWrap things get really simplified. We only require the following
    code snippet for using a camera in our application:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 6 章](ch06.html "第 6 章。设备能力 – 力量释放") 中，我们学习了设备能力——在您的应用程序中实现相机功能。我们在那里编写了相当多的代码，但有了
    BubbleWrap，事情变得非常简化。我们只需要以下代码片段来在我们的应用程序中使用相机：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'BubbleWrap also provides a module named `App` that can be used while running
    the application. To understand this, perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleWrap 还提供了一个名为 `App` 的模块，可以在运行应用程序时使用。要理解这一点，请执行以下步骤：
- en: First, create a small sample application.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个小型的示例应用程序。
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Update the `Rakefile` to include a Bundler that will help us install the BubbleWrap
    gem easily.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `Rakefile` 以包括 Bundler，这将帮助我们轻松安装 BubbleWrap 钩子。
- en: '[PRE19]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'As shown in the last section, let''s add a `Gemfile` to our project with the
    following code:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如上节所示，让我们将以下代码添加到我们的项目中作为 `Gemfile`：
- en: '[PRE20]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the following command to install the BubbleWrap gem:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下命令来安装 BubbleWrap 钩子：
- en: '[PRE21]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, let''s fire up the terminal to test the `App` module on the console:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们启动终端来在控制台中测试 `App` 模块：
- en: '[PRE22]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To use the `App` module, run the following commands in REPL:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用 `App` 模块，请在 REPL 中运行以下命令：
- en: '[PRE23]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'There is another module named `Device` that provides many options related to
    the current device. Let''s once again fire up REPL in our terminal and execute
    the following commands:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还有一个名为 `Device` 的模块，它提供了许多与当前设备相关的选项。让我们再次在终端中启动 REPL 并执行以下命令：
- en: '[PRE24]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: There are tons of helpers that come with the BubbleWrap gem. It will be helpful
    for your project if you have a look at the BubbleWrap documentation at [http://bubblewrap.io/](http://bubblewrap.io/).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: BubbleWrap 钩子附带了许多辅助工具。如果你查看 [http://bubblewrap.io/](http://bubblewrap.io/)
    上的 BubbleWrap 文档，这将对你项目有所帮助。
- en: motion-addressbook – access phonebook easily
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: motion-addressbook – 轻松访问电话簿
- en: In [Chapter 6](ch06.html "Chapter 6. Device Capability – Power Unleashed"),
    *Device Capability – Power Unleashed*, we had discussed in detail how to use the
    Address Book technology for iOS devices. In this section, we will use a special
    gem for RubyMotion named `motion-addressbook` that simplifies using the Address
    Book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第6章](ch06.html "第6章。设备能力 - 力量释放")中，*设备能力 - 力量释放*，我们详细讨论了如何使用iOS设备的通讯录技术。在本节中，我们将使用名为`motion-addressbook`的RubyMotion特殊gem，它简化了使用通讯录的过程。
- en: 'We will perform the following actions in this section:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将执行以下操作：
- en: Create a sample app with the `motion-addressbook` gem
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`motion-addressbook` gem创建一个示例应用
- en: Pull the data from the device's Address Book
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从设备的通讯录中提取数据
- en: Display it on the screen
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上显示它
- en: 'Let''s start by performing the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先执行以下步骤：
- en: Create a sample application.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个示例应用程序。
- en: '[PRE25]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, let's include the `motion-addressbook` gem in the `Gemfile`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`Gemfile`中包含`motion-addressbook` gem。
- en: '[PRE26]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Bundle install from the command line to include this gem in our project:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用命令行运行`bundle install`以将此gem包含到我们的项目中：
- en: '[PRE27]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s create a file named `addressbook_controller.rb` in which we will add
    a button and three labels. With the button, we will access our address book and
    choose the desired contact. In the labels, we will display the data of the user,
    which we have copied from the address book. Add the following code in your `addressbook_controller.rb`
    file:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在名为`addressbook_controller.rb`的文件中创建一个文件，我们将在此文件中添加一个按钮和三个标签。通过按钮，我们将访问我们的通讯录并选择所需的联系人。在标签中，我们将显示从通讯录复制的用户数据。在你的`addressbook_controller.rb`文件中添加以下代码：
- en: '[PRE28]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Add the following code in the `app_delegate.rb` file so that our delegate points
    to our address book controller:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app_delegate.rb`文件中添加以下代码，以便我们的代理指向我们的通讯录控制器：
- en: '[PRE29]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's fire up the terminal and run our app in a simulator to check if we are
    able to see our three labels and a button.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端并在模拟器中运行我们的应用，以检查我们是否能够看到三个标签和一个按钮。
- en: '[PRE30]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The following is the output:'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![motion-addressbook – access phonebook easily](img/5220OT_11_04.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![motion-addressbook – 简易访问通讯录](img/5220OT_11_04.jpg)'
- en: 'In the preceding code snippet, we have mentioned a method named `addressbook_access`.
    To access the Address Book, we need to use the `AddressBook` picker that lets
    us open the device''s Address Book in our application and pick data from it. With
    this method, we will be doing the same. Let''s create this method in our `addressbook_controller.rb`
    file and add the following code to it:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们提到了一个名为`addressbook_access`的方法。要访问通讯录，我们需要使用`AddressBook`选择器，它允许我们在应用程序中打开设备的通讯录并从中选择数据。使用此方法，我们将执行相同的操作。让我们在我们的`addressbook_controller.rb`文件中创建此方法，并添加以下代码：
- en: '[PRE31]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Let's fire up the terminal and run our app in a simulator to check if we are
    able to access the Address Book and import the desired contact details in our
    application.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们打开终端并在模拟器中运行我们的应用，以检查我们是否能够访问通讯录并将所需的联系人详细信息导入到我们的应用程序中。
- en: '[PRE32]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following is the output:'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下是输出结果：
- en: '![motion-addressbook – access phonebook easily](img/5220OT_11_05.jpg)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![motion-addressbook – 简易访问通讯录](img/5220OT_11_05.jpg)'
- en: Once we select any contact, we will get its details on our application, as shown
    in the following screenshot:![motion-addressbook – access phonebook easily](img/5220OT_11_06.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们选择任何联系人，我们将在应用程序中看到其详细信息，如下面的截图所示：![motion-addressbook – 简易访问通讯录](img/5220OT_11_06.jpg)
- en: That's it, we are done. It's the same application we had created in [Chapter
    6](ch06.html "Chapter 6. Device Capability – Power Unleashed"), *Device Capability
    – Power Unleashed*, but with `motion-addressbook`, we have substantially less
    code.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们完成了。这与我们在[第6章](ch06.html "第6章。设备能力 - 力量释放")中创建的应用程序相同，*设备能力 - 力量释放*，但使用`motion-addressbook`，我们的代码量大大减少。
- en: Let's understand what we have done here. The `motion-addressbook` gem gives
    us many options to easily use the device's Address Book. In the `addressbook_access`
    method, we have used the `AddressBook` picker by using `AddressBook.pick`, which
    opens up the device's Address Book for us. Once we select any contact, we get
    a `person` object that has a hash of all the attributes of the selected contact.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解我们在这里做了什么。`motion-addressbook` gem为我们提供了许多选项，使我们能够轻松地使用设备的通讯录。在`addressbook_access`方法中，我们通过使用`AddressBook.pick`调用了`AddressBook`选择器，为我们打开了设备的通讯录。一旦我们选择任何联系人，我们就会得到一个包含所选联系人所有属性哈希的`person`对象。
- en: 'In our example, we have used the `first_name`, `last_name`, and `organization`
    values from the selected `person` object. However, the `motion-addressbook` gem
    has many more options that make working with the Address Book framework faster
    and easier. A few of them are as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们使用了从选定的`person`对象中获取的`first_name`、`last_name`和`organization`值。然而，`motion-addressbook`
    gem有很多更多选项，可以让使用Address Book框架更快、更轻松。以下是一些：
- en: To create a new contact.
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的联系人。
- en: '[PRE33]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: To pull all the records from the address book.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从地址簿中拉取所有记录。
- en: '[PRE34]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: To get a list of records based on a specific attribute.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据特定属性获取记录列表。
- en: '[PRE35]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: To get a list of records based on many conditions.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据许多条件获取记录列表。
- en: '[PRE36]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: To create a new contact.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新的联系人。
- en: '[PRE37]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: CocoaPods – managing Objective-C libraries
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CocoaPods – 管理Objective-C库
- en: CocoaPods is the best way to manage library dependencies in Objective-C projects.
    CocoaPods was originally designed to be integrated in Objective-C Xcode projects,
    but it can readily be used in RubyMotion projects using the `motion-cocoapods`
    gem.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: CocoaPods是管理Objective-C项目中库依赖的最佳方式。CocoaPods最初是为集成到Objective-C Xcode项目中而设计的，但它可以通过使用`motion-cocoapods`
    gem轻松地在RubyMotion项目中使用。
- en: Installing CocoaPods with RubyMotion
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用RubyMotion安装CocoaPods
- en: 'Perform the following steps to install CocoaPods with RubyMotion:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使用RubyMotion安装CocoaPods：
- en: Install CocoaPods.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装CocoaPods。
- en: '[PRE38]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Set up CocoaPods.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置CocoaPods。
- en: '[PRE39]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Install `motion-cocoapods` to work with RubyMotion.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用RubyMotion安装`motion-cocoapods`以进行工作。
- en: '[PRE40]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we are all set to use CocoaPods in our RubyMotion project. Add the following
    code in the `Rakefile`:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在RubyMotion项目中使用CocoaPods了。在`Rakefile`中添加以下代码：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: So, next time when you build your code, it will automatically download the library
    for you. Then you can use the Objective-C CocoaPods in your project.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，下次当你构建代码时，它将自动为你下载库。然后你可以在项目中使用Objective-C CocoaPods。
- en: For detailed documentation on CocoaPods, visit [http://cocoapods.org/](http://cocoapods.org/).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于CocoaPods的详细文档，请访问[http://cocoapods.org/](http://cocoapods.org/)。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we have learned the following topics:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了以下主题：
- en: RubyMotion Gems
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RubyMotion Gems
- en: 'Teacup: A community-driven DSL for creating user interfaces on iOS.'
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Teacup：一个社区驱动的DSL，用于在iOS上创建用户界面。
- en: 'BubbleWrap: A collection of (tested) helpers and wrappers used to wrap CocoaTouch
    code and provide more Ruby-like APIs.'
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: BubbleWrap：一组（经过测试的）辅助工具和包装器，用于包装CocoaTouch代码并提供更多Ruby-like API。
- en: '`motion-addressbook`: A gem to perform different actions on the iOS Address
    Book.'
  id: totrans-155
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion-addressbook`：一个gem，可以在iOS地址簿上执行不同的操作。'
- en: 'CocoaPods: It is the best way to manage library dependencies in Objective-C
    and RubyMotion projects'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CocoaPods：它是管理Objective-C和RubyMotion项目中库依赖的最佳方式
- en: What next?
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接下来是什么？
- en: Congratulations, we have covered a lot in the last 11 chapters and we are sure
    you now know a lot more about RubyMotion than you did at the outset.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜，我们在过去的11章中已经涵盖了大量的内容，我们确信你现在对RubyMotion的了解比一开始要多得多。
- en: We have learned a lot of things during this journey—beginning with installing
    RubyMotion, understanding the RubyMotion folder structure, debugging our application,
    introducing RubyMotion objects, creating an MVC application, playing with the
    user interface, using device capabilities such as the camera, gestures, persistence
    storage, writing test cases, creating games, using RubyMotion-flavored gems, and
    submitting the application to App Store. That's a lot of stuff!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个过程中，我们学到了很多东西——从安装RubyMotion开始，理解RubyMotion文件夹结构，调试我们的应用程序，介绍RubyMotion对象，创建MVC应用程序，玩转用户界面，使用设备功能，如相机、手势、持久存储，编写测试用例，创建游戏，使用RubyMotion风格的gem，以及将应用程序提交到App
    Store。这些都是很多内容！
- en: So, what can be done next from here? The answer to this question is *plenty
    of things!* There is still a lot to discover in RubyMotion and the iOS SDK; so
    from here, the first thing we can do is grab a book that explores the iOS SDK
    in detail. The best source for anything related to iOS SDK is Apple's Developer
    Reference at [https://developer.apple.com/](https://developer.apple.com/). All
    things at Apple's Developer Reference are in Objective-C, but now we have the
    skills to translate verbose Objective-C code to learn and clean RubyMotion code.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，接下来可以做什么呢？这个问题的答案是*很多事情*！在RubyMotion和iOS SDK中还有很多东西可以探索；所以从这里开始，我们可以做的第一件事是找一本详细探讨iOS
    SDK的书籍。与iOS SDK相关的最佳资源是苹果的[开发者参考](https://developer.apple.com/)。苹果开发者参考中的所有内容都是用Objective-C编写的，但现在我们有了将冗长的Objective-C代码转换为学习并编写干净的RubyMotion代码的技能。
- en: Next, keep yourself updated with the latest happenings in the RubyMotion ecosystem
    with the RubyMotion blog ([http://blog.rubymotion.com](http://blog.rubymotion.com))
    and Developer Center ([http://www.rubymotion.com/developer-center/](http://www.rubymotion.com/developer-center/)).
    The RubyMotion blog keeps us updated with the RubyMotion world—what's new in this
    version or what's in store for the future of RubyMotion. Developer Center is a
    great source for API references, some quick tutorials, and the latest articles
    on technology. For RubyMotion wrappers and libraries, you can visit [http://rubymotion-wrappers.com/](http://rubymotion-wrappers.com/).
    This web page is a one-stop shop for details on available wrappers and is updated
    often.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过 RubyMotion 博客([http://blog.rubymotion.com](http://blog.rubymotion.com))和开发者中心([http://www.rubymotion.com/developer-center/](http://www.rubymotion.com/developer-center/))来了解
    RubyMotion 生态系统中的最新动态。RubyMotion 博客会及时更新 RubyMotion 世界的信息——这个版本有什么新功能，或者 RubyMotion
    的未来有哪些期待。开发者中心是 API 参考、一些快速教程和最新技术文章的绝佳来源。对于 RubyMotion 的封装器和库，您可以访问 [http://rubymotion-wrappers.com/](http://rubymotion-wrappers.com/)。这个网页是获取可用封装器详情的一站式商店，并且经常更新。
- en: To discuss any issue, you must join the RubyMotion community at its Google group
    ([https://groups.google.com/forum/?fromgroups#!forum/rubymotion](https://groups.google.com/forum/?fromgroups#!forum/rubymotion)).
    This group is a great place to interact with the vibrant RubyMotion community.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 要讨论任何问题，您必须加入 RubyMotion 社区在 Google 群组([https://groups.google.com/forum/?fromgroups#!forum/rubymotion](https://groups.google.com/forum/?fromgroups#!forum/rubymotion))。这个群组是和充满活力的
    RubyMotion 社区互动的绝佳场所。
- en: Finally, create apps! There is no better way to master a technology than learning
    on your own in a real-world scenario. You can contribute to the community by creating
    wrappers and gems—that's a great way to acquire expertise on a specific area of
    a technology. We hope you have enjoyed reading and learning with this book, and
    have now evolved as an iOS RubyMotion developer; we are very excited about RubyMotion,
    just like you, and look forward to seeing your work making a mark in the iOS and
    RubyMotion world.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，开始创建应用！没有比在实际场景中自学更好的掌握技术的方法了。您可以通过创建封装器和宝石来为社区做出贡献——这是在特定技术领域获得专业知识的好方法。我们希望您喜欢阅读和学习这本书，并且现在已经成为了一名
    iOS RubyMotion 开发者；我们和您一样对 RubyMotion 非常兴奋，期待看到您的工作在 iOS 和 RubyMotion 世界中留下印记。
