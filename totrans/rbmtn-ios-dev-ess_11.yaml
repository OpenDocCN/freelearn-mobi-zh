- en: Chapter 11. Extending RubyMotion
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The DRY principle states the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Every piece of knowledge must have a single, unambiguous, authoritative representation
    within a system."*'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now approaching the end of this book. So far we have learned how to
    quickly make iOS applications with RubyMotion. To make this process even more
    rapid, RubyMotion lets us use special RubyMotion-flavored gems and wrappers. **Gems**
    and **wrappers** are Ruby programs that are wrapped into a self-contained format.
    These are generally open source projects, which other developers can use in their
    applications or can even contribute back to these projects. Fortunately, RubyMotion
    has a very enthusiastic community; within months of launching RubyMotion''s tool
    chain, plenty of gems were introduced that implement many laborious tasks fairly
    quickly. In this chapter, we will learn how to augment our application by using
    RubyMotion-flavored gems. The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion gems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CocoaPods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: RubyMotion gems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Use of gems is based on the programming practice of **Don't Repeat Yourself**
    (**DRY**), which states that when some piece of code is ready to use and is available,
    why bother working on it again. The RubyMotion community may be very young right
    now, but it already has some amazing gems that make a lot of tiring tasks pretty
    easy. Some gems even target challenging functionalities in a very simple manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will cover the following RubyMotion-flavored gems:'
  prefs: []
  type: TYPE_NORMAL
- en: Teacup
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BubbleWrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion-addressbook`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Teacup – say goodbye to Xcode and XIB files!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Designing a UI for iOS apps is a tough job, especially for developers who have
    worked previously on easy-to-learn-and-implement web technologies. **Teacup**
    is a gem that will make your life really easy. Teacup augments your ability to
    quickly design and style the views of your RubyMotion application; you can easily
    create layouts while keeping your code DRY.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create an application and learn how easy it is to use Teacup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We will be using **Bundler** (which is also a Ruby gem) to install all our gems.
    Bundler also helps us manage application dependencies, so that the exact version
    of the gems used are available for the application to run.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Bundler comes as a default dependency manager for popular frameworks such as
    Ruby on Rails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add Bundler to our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Rakefile` with the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With Bundler, we require a Gemfile in which we can mention details about the
    gems we will use with our application. Next, let''s create a Gemfile and add the
    following lines of code in it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So, in the future, if you want to add any new gem to your project, you can simply
    add it to this file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, let''s run `bundle install` and we''re good to go:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `bundle install` command adds a `Gemfile.lock` file to your repository.
    This ensures that other developers on your app, as well as your deployment environment,
    will all use the same third-party code that you are using now.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, update the `app_delegate.rb` file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code, we are only initializing an instance of `RootController`, just
    like we do with every application. As you may remember, the controller is where
    all our application logic resides.
  prefs: []
  type: TYPE_NORMAL
- en: So far, in various chapters we have made RubyMotion iOS applications in a traditional
    way. Let's use Teacup in our application this time, and add styles by making use
    of its Cascading Style Sheets (CSS) type syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a directory named `style` and add a new file with the name of
    `style.rb` in it. Add the following code to the `style.rb` file in the `style`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s understand the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we have created a stylesheet named `style`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This convention is provided by Teacup to create a new stylesheet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have created a specific layout for your views, using CSS-based syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will create a style named `your_layout` and will enable the landscape rotation
    (otherwise, only portrait orientation is enabled).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next, we have added style for all `UILabel` instances.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The preceding line of code gives text color to all `UILabel` instances that
    are defined inside the style. Since we apply a style to all the labels when using
    `UILabel`, if we want to style a specific element, we have to add the following
    commands:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `label` is like a class. This will do the styling for the label.
  prefs: []
  type: TYPE_NORMAL
- en: 'To understand this better, let''s create a view. Perform the following steps
    to create a view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named `root_view_controller.rb` and add the following code to
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we have created a new controller file, we must make the corresponding changes
    to the `app_delegate.rb` file. Make these changes in your `app_delegate.rb` file
    as shown in the previous chapters.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the preceding code snippet, first we have given the stylesheet a name, which
    is done using `stylesheet:style`, and then we have specified a layout named `your_layout`
    and passed `label : @label1 = subview(UILabel, :label)` to it.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Let's fire up the terminal and test our application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Teacup – say goodbye to Xcode and XIB files!](img/5220OT_11_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: We can see the text **Awesome** appear on the simulator screen and it is styled
    as we have defined in the stylesheet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Teacup implements the `viewDidLoad` method and instantiates any views. If you
    want to implement your own `viewDidLoad` method, make sure to call super.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can also define different stylesheets for changing dimensions as we rotate
    the device, such as the landscape and portrait modes. Let's try this in our next
    example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now update the stylesheet, that is, the `style.rb` file, with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Run the application and rotate the screen from the simulator menu by navigating
    to **Hardware** | **Rotate Left**. You will see that as the screen rotates the
    background color of the label changes.![Teacup – say goodbye to Xcode and XIB
    files!](img/5220OT_11_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s do a few more things in the same example. Add the following code
    in the `style.rb` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here we have created two text field boxes.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, update the `root_controller.rb` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's test our application in the simulator.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Teacup – say goodbye to Xcode and XIB files!](img/5220OT_11_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: With the preceding example, we can see how easy it is to design views with the
    Teacup gem; it has delivered a way to create interfaces programmatically with
    ease. We have shared a few of the features of this amazing gem; you can explore
    more at [https://github.com/rubymotion/teacup](https://github.com/rubymotion/teacup).
  prefs: []
  type: TYPE_NORMAL
- en: BubbleWrap – making Cocoa APIs more Ruby-like
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: BubbleWrap is a collection of very well-tested helpers and wrappers used to
    wrap Cocoa SDK code and provide more Ruby-like APIs for RubyMotion. It provides
    wrappers for a lot of iOS Cocoa SDK code, such as camera, notification center,
    HTTP, and many more.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do a lot of things very easily. For example, to perform a `GET HTTP`
    request with BubbleWrap, we require the following simple code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 6](ch06.html "Chapter 6. Device Capability – Power Unleashed"),
    *Device Capability – Power Unleashed*, we have learned about device capabilities—implementing
    camera functionalities in your app. We have written quite a lot of code there,
    but with BubbleWrap things get really simplified. We only require the following
    code snippet for using a camera in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'BubbleWrap also provides a module named `App` that can be used while running
    the application. To understand this, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, create a small sample application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Update the `Rakefile` to include a Bundler that will help us install the BubbleWrap
    gem easily.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As shown in the last section, let''s add a `Gemfile` to our project with the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the following command to install the BubbleWrap gem:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s fire up the terminal to test the `App` module on the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To use the `App` module, run the following commands in REPL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'There is another module named `Device` that provides many options related to
    the current device. Let''s once again fire up REPL in our terminal and execute
    the following commands:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: There are tons of helpers that come with the BubbleWrap gem. It will be helpful
    for your project if you have a look at the BubbleWrap documentation at [http://bubblewrap.io/](http://bubblewrap.io/).
  prefs: []
  type: TYPE_NORMAL
- en: motion-addressbook – access phonebook easily
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In [Chapter 6](ch06.html "Chapter 6. Device Capability – Power Unleashed"),
    *Device Capability – Power Unleashed*, we had discussed in detail how to use the
    Address Book technology for iOS devices. In this section, we will use a special
    gem for RubyMotion named `motion-addressbook` that simplifies using the Address
    Book.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will perform the following actions in this section:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a sample app with the `motion-addressbook` gem
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pull the data from the device's Address Book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Display it on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a sample application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's include the `motion-addressbook` gem in the `Gemfile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Bundle install from the command line to include this gem in our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create a file named `addressbook_controller.rb` in which we will add
    a button and three labels. With the button, we will access our address book and
    choose the desired contact. In the labels, we will display the data of the user,
    which we have copied from the address book. Add the following code in your `addressbook_controller.rb`
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code in the `app_delegate.rb` file so that our delegate points
    to our address book controller:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's fire up the terminal and run our app in a simulator to check if we are
    able to see our three labels and a button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![motion-addressbook – access phonebook easily](img/5220OT_11_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'In the preceding code snippet, we have mentioned a method named `addressbook_access`.
    To access the Address Book, we need to use the `AddressBook` picker that lets
    us open the device''s Address Book in our application and pick data from it. With
    this method, we will be doing the same. Let''s create this method in our `addressbook_controller.rb`
    file and add the following code to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's fire up the terminal and run our app in a simulator to check if we are
    able to access the Address Book and import the desired contact details in our
    application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following is the output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![motion-addressbook – access phonebook easily](img/5220OT_11_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Once we select any contact, we will get its details on our application, as shown
    in the following screenshot:![motion-addressbook – access phonebook easily](img/5220OT_11_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's it, we are done. It's the same application we had created in [Chapter
    6](ch06.html "Chapter 6. Device Capability – Power Unleashed"), *Device Capability
    – Power Unleashed*, but with `motion-addressbook`, we have substantially less
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand what we have done here. The `motion-addressbook` gem gives
    us many options to easily use the device's Address Book. In the `addressbook_access`
    method, we have used the `AddressBook` picker by using `AddressBook.pick`, which
    opens up the device's Address Book for us. Once we select any contact, we get
    a `person` object that has a hash of all the attributes of the selected contact.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we have used the `first_name`, `last_name`, and `organization`
    values from the selected `person` object. However, the `motion-addressbook` gem
    has many more options that make working with the Address Book framework faster
    and easier. A few of them are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To create a new contact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To pull all the records from the address book.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To get a list of records based on a specific attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To get a list of records based on many conditions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: To create a new contact.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: CocoaPods – managing Objective-C libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CocoaPods is the best way to manage library dependencies in Objective-C projects.
    CocoaPods was originally designed to be integrated in Objective-C Xcode projects,
    but it can readily be used in RubyMotion projects using the `motion-cocoapods`
    gem.
  prefs: []
  type: TYPE_NORMAL
- en: Installing CocoaPods with RubyMotion
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Perform the following steps to install CocoaPods with RubyMotion:'
  prefs: []
  type: TYPE_NORMAL
- en: Install CocoaPods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Set up CocoaPods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Install `motion-cocoapods` to work with RubyMotion.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we are all set to use CocoaPods in our RubyMotion project. Add the following
    code in the `Rakefile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: So, next time when you build your code, it will automatically download the library
    for you. Then you can use the Objective-C CocoaPods in your project.
  prefs: []
  type: TYPE_NORMAL
- en: For detailed documentation on CocoaPods, visit [http://cocoapods.org/](http://cocoapods.org/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we have learned the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: RubyMotion Gems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Teacup: A community-driven DSL for creating user interfaces on iOS.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'BubbleWrap: A collection of (tested) helpers and wrappers used to wrap CocoaTouch
    code and provide more Ruby-like APIs.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`motion-addressbook`: A gem to perform different actions on the iOS Address
    Book.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'CocoaPods: It is the best way to manage library dependencies in Objective-C
    and RubyMotion projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What next?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations, we have covered a lot in the last 11 chapters and we are sure
    you now know a lot more about RubyMotion than you did at the outset.
  prefs: []
  type: TYPE_NORMAL
- en: We have learned a lot of things during this journey—beginning with installing
    RubyMotion, understanding the RubyMotion folder structure, debugging our application,
    introducing RubyMotion objects, creating an MVC application, playing with the
    user interface, using device capabilities such as the camera, gestures, persistence
    storage, writing test cases, creating games, using RubyMotion-flavored gems, and
    submitting the application to App Store. That's a lot of stuff!
  prefs: []
  type: TYPE_NORMAL
- en: So, what can be done next from here? The answer to this question is *plenty
    of things!* There is still a lot to discover in RubyMotion and the iOS SDK; so
    from here, the first thing we can do is grab a book that explores the iOS SDK
    in detail. The best source for anything related to iOS SDK is Apple's Developer
    Reference at [https://developer.apple.com/](https://developer.apple.com/). All
    things at Apple's Developer Reference are in Objective-C, but now we have the
    skills to translate verbose Objective-C code to learn and clean RubyMotion code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, keep yourself updated with the latest happenings in the RubyMotion ecosystem
    with the RubyMotion blog ([http://blog.rubymotion.com](http://blog.rubymotion.com))
    and Developer Center ([http://www.rubymotion.com/developer-center/](http://www.rubymotion.com/developer-center/)).
    The RubyMotion blog keeps us updated with the RubyMotion world—what's new in this
    version or what's in store for the future of RubyMotion. Developer Center is a
    great source for API references, some quick tutorials, and the latest articles
    on technology. For RubyMotion wrappers and libraries, you can visit [http://rubymotion-wrappers.com/](http://rubymotion-wrappers.com/).
    This web page is a one-stop shop for details on available wrappers and is updated
    often.
  prefs: []
  type: TYPE_NORMAL
- en: To discuss any issue, you must join the RubyMotion community at its Google group
    ([https://groups.google.com/forum/?fromgroups#!forum/rubymotion](https://groups.google.com/forum/?fromgroups#!forum/rubymotion)).
    This group is a great place to interact with the vibrant RubyMotion community.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, create apps! There is no better way to master a technology than learning
    on your own in a real-world scenario. You can contribute to the community by creating
    wrappers and gems—that's a great way to acquire expertise on a specific area of
    a technology. We hope you have enjoyed reading and learning with this book, and
    have now evolved as an iOS RubyMotion developer; we are very excited about RubyMotion,
    just like you, and look forward to seeing your work making a mark in the iOS and
    RubyMotion world.
  prefs: []
  type: TYPE_NORMAL
