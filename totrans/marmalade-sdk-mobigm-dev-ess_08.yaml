- en: Chapter 8. Supporting a Wide Range of Devices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's really great that the Marmalade SDK allows us to target so many different
    devices and platforms. However, a certain degree of care and awareness is required
    in order to optimize your application fully for all of these varying device types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we''ll be covering the following subjects:'
  prefs: []
  type: TYPE_NORMAL
- en: A general overview of the kinds of things to be wary of when trying to support
    a wide range of different devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A more advanced look at the ICF filesystem we encountered back in the first
    chapter of this book
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Marmalade's built-in systems to allow multiple different data sets to
    be used and to process those data sets in different ways (for example, allowing
    the final texture format used on the device to be specified)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring the deployment system to make different types of builds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Derbh archiver to reduce the size of our assets in the install package
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accommodating a wide range of device types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mobile operating systems such as iOS or Android are capable of running on a
    widely varying range of devices. Before we get on to discussing the ways in which
    Marmalade makes it easy for us to target multiple device types, we'll first highlight
    some of the things to keep in mind when developing a game so that it will look
    and run its best on as many different devices as possible.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade also ships with a whitepaper that covers some of the things to be
    careful about when developing a game destined to run on more than one device specification.
    You can find it in the Marmalade documentation at **Whitepapers** | **Device Independent
    Code**.
  prefs: []
  type: TYPE_NORMAL
- en: Dealing with different screen resolutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Probably the most immediately notable difference between different devices will
    be the screen resolution. Taking iOS as an example, you may find yourself having
    to support screen resolutions ranging from 320 x 480 at the low end through the
    two different iPhone Retina screen resolutions (640 x 960 and 640 x 1136) and
    iPad at 1024 x 768, right up to the frankly crazy resolution of 2048 x 1536 of
    the most recent iPad (you'll be hard pressed to find a PC monitor capable of displaying
    that resolution!).
  prefs: []
  type: TYPE_NORMAL
- en: We've already touched on this subject in [Chapter 6](ch06.html "Chapter 6. Implementing
    Fonts, User Interfaces, and Localization"), *Implementing Fonts, User Interfaces,
    and Localization*, when we discussed the best way of implementing a user interface.
    We should never hardcode our game to work at a fixed screen resolution as it will
    be much harder to port it across to other screen resolutions later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we should query Marmalade for the screen dimensions and then use these
    values to position and size everything we want to draw, whether that be through
    using percentages of the screen size, by clamping objects to the edges of the
    screen, or indeed some other method of your own choosing. We can find the screen
    width and height as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: These functions will also automatically take care of device orientation. The
    returned values will change when the player rotates the device, unless we have
    disabled this functionality using the `DispFixRot` ICF file setting (more on this
    setting shortly).
  prefs: []
  type: TYPE_NORMAL
- en: Using different resources for different screen resolutions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using the screen dimensions to position and size the elements we wish to draw
    works well, but it does lead to a further problem. We may find that any images
    used to render items on screen start to look blurry or blocky if they have to
    be scaled up in size too much.
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, fonts that work well at a low resolution may become impossible to
    read because they are too small when used on a higher-resolution device. While
    we could just apply a scale to the font when rendering, a more aesthetically pleasing
    solution is to use a different version of the font created at a bigger point size.
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, as we'll see later in this chapter, Marmalade has a very easy-to-use
    solution for this problem that allows us to provide alternate sets of resources
    that can be used when targeting different sets of screen resolutions.
  prefs: []
  type: TYPE_NORMAL
- en: Checking device capabilities
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing to be vigilant of when targeting a large number of different devices
    is that some devices may not include support for certain Marmalade SDK features.
  prefs: []
  type: TYPE_NORMAL
- en: Some devices may feature a multi-touch display while others only have single
    touch or indeed no touch screen at all. Some may not feature accelerometer inputs
    or keypads. It is therefore a good idea to ensure that we call the various Marmalade
    functions that enquire whether these and other features are available for use
    and what capabilities are provided, so that we can then provide the user with
    options tailored to their device.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring your game using ICF file settings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you cast your mind back to the "Hello World" project in the very first chapter
    of this book, you will recall that we used the ICF file to display a different
    welcome message depending on which platform the code was being executed on. Don't
    worry if you've forgotten how all this works, as we'll be covering it again shortly.
  prefs: []
  type: TYPE_NORMAL
- en: This functionality proves extremely useful when we are trying to target as many
    different devices as possible, as there are built-in parameters that allow us
    to apply different settings for a range of things including memory usage, OpenGL
    ES graphics performance, splash screens, and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Built-in ICF settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'ICF file settings are assigned to a section identifier which is defined by
    placing the name of the section in square brackets. When specifying a value for
    an ICF setting you must ensure that it appears after the correct section identifier,
    otherwise it will not be found at runtime and an assert will be raised. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are far too many ICF settings to be able to cover all of them in this
    book, so instead we'll be taking a look at some of the more immediately useful
    ones. If you want to see a complete list, take a look in the Marmalade documentation,
    by going to **Marmalade** | **Marmalade Development Tools Reference** | **ICF
    File Settings**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following table shows a few of the settings that control Marmalade at its
    lowest level. The section identifier for these settings is `[S3E]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Value type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `MemSize` | Integer | The size, in bytes, of the main memory heap available
    to an application. A Marmalade application can actually have up to ten memory
    heaps available, so there are also settings called `MemSize0` through `MemSize9`,
    which allow the sizes of these heaps to be declared. `MemSize0` is actually equivalent
    to using `MemSize`. For more information on memory heaps take a look at the s3eMemory
    API in the Marmalade documentation. |'
  prefs: []
  type: TYPE_TB
- en: '| `MemSizeDebug` | Integer | The size, in bytes, of the debug memory heap when
    a Windows debug build is executed. This is a special block of memory that is used
    for tasks such as processing 3D models and converting textures to different formats
    during the resource building process. |'
  prefs: []
  type: TYPE_TB
- en: '| `SysAppVersion` | String | Allows an application to access its version number.
    While this value can be set in the ICF file, it can also be set using the MKB
    deployment''s `version` setting. |'
  prefs: []
  type: TYPE_TB
- en: '| `SysGlesVersion` | Integer | Identifies whether the application should attempt
    to initialize an OpenGL ES 1.x or 2.x interface. Only the major version number
    (that is, 1 or 2) can be specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `SysStackSize` | Integer | The size of the stack available to the program,
    in bytes. It is useful, for example, when an application requires extra stack
    space (due to heavily recursive algorithms). |'
  prefs: []
  type: TYPE_TB
- en: '| `SplashScreenFile` | String | The name of an image file that will be displayed
    while an application is loading. The filename is relative to the `data` directory.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `SplashScreenBkR` `,``SplashScreenBkG` , and`SplashScreenBkB` | Byte | A
    value from `0` through `255` to specify the red, green, and blue component values
    of the splash screen background color. This is the color that will be used to
    clear the screen before displaying the specified splash screen image, assuming
    the image is smaller than the screen size. |'
  prefs: []
  type: TYPE_TB
- en: '| `SplashScreenWidth` and`SplashScreenHeight` | Integer | The width and height
    that the splash screen image should be drawn at. If smaller than the screen size,
    the image will be centered. |'
  prefs: []
  type: TYPE_TB
- en: '| `AudioAllowBackground` | `0` or `1` | When set to `1` this allows any audio
    track a user may have started (for example, through the iPod application on an
    iOS device) to continue playing when our application starts. |'
  prefs: []
  type: TYPE_TB
- en: '| `DispFixRot` | String | Allows the screen to be locked to a particular orientation,
    rather than rotating when the user rotates the device. Can be set to one of the
    following values: `Free`, `Portrait`, `Landscape`, `FixedPortrait`, or `FixedLandscape`.
    The `Free` setting allows any device orientation, while `FixedPortrait` and `FixedLandscape`
    keep the screen orientation locked to a default portrait or landscape aspect,
    which can be very important to prevent unwanted screen rotations when using the
    accelerometer to control a game! |'
  prefs: []
  type: TYPE_TB
- en: 'The following table lists some useful parameters for altering the initialization
    of OpenGL ES. These settings must occur after the section identifier `[GL]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Value type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `AlphaInFrameBuffer` | `0` or `1` | When set to `1`, this setting indicates
    that the frame buffer also includes the destination alpha channel. |'
  prefs: []
  type: TYPE_TB
- en: '| `EGL_RED_SIZE` ,`EGL_GREEN_SIZE` ,`EGL_BLUE_SIZE` ,`EGL_ALPHA_SIZE` | Integer
    | Indicates the number of bits to be used to store each of the red, green, blue,
    and alpha channels in the frame buffer. For best render quality, all of these
    settings would normally be given the value `8`, yielding an RGBA8888 display.
    Most hardware can also support formats such as RGBA5551 and RGB565, which will
    use less video memory and may render faster at the expense of a drop in visual
    quality. |'
  prefs: []
  type: TYPE_TB
- en: '| `EGL_DEPTH_SIZE` | Integer | The number of bits to use for the depth buffer.
    Valid values are `16`, `24`, and `32`, with the latter giving the most precision
    and therefore least chance of Z-buffer clashes when rendering, at the expense
    of slower rendering and more memory usage. |'
  prefs: []
  type: TYPE_TB
- en: 'We''ll finish off with some settings related to resource management that we''ll
    be looking at in more depth later in this chapter. They have been included here
    for easy reference. The settings reside in the ICF section `[RESMANAGER]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Setting | Value type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `ResBuild` | `0` or `1` | When set to `1`, the Windows debug build will load
    resources by parsing the original GROUP files and loading the source models, textures,
    and other resources. Once the data has been processed, it is saved to the `data-ram`
    directory in a binary format. If this setting is set to `0`, the source assets
    will not be loaded and any existing binary-formatted data will be loaded directly.
    This can speed up testing when there have been no changes made to game data. |'
  prefs: []
  type: TYPE_TB
- en: '| `ResBuildStyle` | String | Specifies the resource building style to use when
    the Windows debug build is processing the original source assets. As we will learn
    later in this chapter, this parameter allows us to provide different sets of resources
    to cater for devices of varying abilities. |'
  prefs: []
  type: TYPE_TB
- en: Defining new ICF settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the best things about ICF files is that we are able to make use of them
    ourselves by creating our own custom settings. To define new settings we just
    need to add them to the file `app.config.txt`, which is automatically generated
    for us when creating a new project using an MKB file.
  prefs: []
  type: TYPE_NORMAL
- en: When defining new settings, we can also provide a string of text that explains
    what this setting is for. While this description isn't actually used or needed
    by the Marmalade SDK, it's a good way of documenting what a setting is supposed
    to do!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is, however, important to add definitions for all our settings to the `app.config.txt`
    file because it will prevent the application generating lots of asserts when it
    is executed. In a Windows Debug build, Marmalade checks to see if an ICF setting
    has been declared both when loading the ICF file at the start of execution and
    also whenever we try to access a setting from within our own code.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also define our own section identifiers in the `app.config.txt` file
    simply by listing the name of the section in square brackets and following it
    with the new setting definitions. Here''s an example illustrating how to create
    new section identifiers and settings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Defining our own section identifiers can be extremely useful when creating library
    modules, such as the GUI and `Localise` modules created in [Chapter 6](ch06.html
    "Chapter 6. Implementing Fonts, User Interfaces, and Localization"), *Implementing
    Fonts, User Interfaces, and Localization*. The only difference when creating a
    module is that the `app.config.txt` file changes to `modulename.config.txt` and
    it should reside in a subdirectory called `docs` in the module's main directory.
    As an example, if we were to add our own settings to the GUI module we would create
    a directory called `GUI\docs`, and the file that lists the settings would be called
    `GUI.config.txt`.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing ICF settings in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's very little use to be able to provide settings in the ICF files without
    some way of accessing them. This is where the s3eConfig API comes into play and
    we can use it by just including the `s3eConfig.h` header file.
  prefs: []
  type: TYPE_NORMAL
- en: The first function we will look at is `s3eConfigGetString`, which takes the
    section identifier and setting name we want to access and also a pointer to an
    array of `char` that will be used to return the value of the setting when the
    function completes. Since the `app.icf` file is really little more than an ASCII
    text file, all this function does is return the string of text following the equals
    sign for the specified ICF setting.
  prefs: []
  type: TYPE_NORMAL
- en: The `char` array supplied to `s3eConfigGetString` should be at least of length
    `S3E_CONFIG_STRING_MAX`, as this is the largest string size the function can return.
    If the requested setting can't be found in the ICF file this buffer will not be
    changed, which is very useful as it allows us to set up a default value for the
    parameter in our code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Quite often we will want to specify ICF settings, which just need a numeric
    value. To make this easier for us, Marmalade provides another function called
    `s3eConfigGetInt`, which, instead of a pointer to a `char` array, takes a pointer
    to an `int` variable.
  prefs: []
  type: TYPE_NORMAL
- en: This function will read the setting string from the ICF file and then attempt
    to convert it into an integer value. If this fails (for example, the string contains
    non-numeric characters or is out of the range of an `int`) or the setting does
    not exist in the ICF file, the variable's current value will not be changed, thus
    allowing default values to be specified in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both functions will return `S3E_RESULT_SUCCESS` if the setting value could
    be retrieved, or `S3E_RESULT_ERROR` if there was a problem. The function `s3eConfigGetError`
    will let us discover what the problem was by returning one of the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_CONFIG_ERR_NONE` | No error occurred. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_CONFIG_ERR_PARAM` | One of the parameters to `s3eConfigGetInt` or `s3eConfigGetString`
    was not valid. For example, a `NULL` value passed in. |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_CONFIG_ERR_NOT_FOUND` | The requested ICF setting could not be found.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `S3E_CONFIG_ERR_PARSE` | There was a problem converting the ICF setting value
    to an integer when using `s3eConfigGetInt`. |'
  prefs: []
  type: TYPE_TB
- en: Limiting ICF settings by platform and device
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When targeting a large number of different devices, it is not uncommon to have
    a situation where we want to be able to do different things depending on the device
    the application is running on.
  prefs: []
  type: TYPE_NORMAL
- en: The ICF filesystem makes handling this incredibly easy by allowing us to provide
    different values for parameters based on both the operating system of the device
    and even by individual device type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we can provide different settings on a platform-wide basis.
    The "Hello World" project from [Chapter 1](ch01.html "Chapter 1. Getting Started
    with Marmalade"), *Getting Started with Marmalade*, has already demonstrated this,
    but to recap, we limit the settings to a particular operating system using the
    `OS` conditional. This is best illustrated by an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This example sets a default value for the `FrameRate` setting of `20`. It then
    overrides this value for Bada devices with a value of `15` and for iOS devices
    with a value of `30`. Note that for legacy reasons the value `IPHONE` refers to
    all iOS devices (all versions of iPad and iPod touch as well as all iPhones).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The earlier example ends with open and close braces. This returns all settings
    made after this point to being global settings that apply to all devices and platforms.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also possible to make settings that will only apply to a particular subset
    of devices on a particular platform. This is done using the `ID` conditional that
    first specifies the platform type and then has a comma-separated list of device
    identifiers that the setting should apply to. Here''s another example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here we set a default value for the `FrameRate` setting of `30`, then limit
    the value to just `20` if the game is running on either of the listed Android
    devices. Quote marks are only required on device names that contain spaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wondering how to discover the device name? Often it is the name of the device,
    but this is not always the case. The easiest way to discover the device name for
    a particular device is to create a short test program that makes a call to `s3eDeviceGetString`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `s3eDeviceGetString` function and its sibling `s3eDeviceGetInt` allow us
    to determine an awful lot of information about the device we're running on, including
    the operating system, processor type, phone number, current language settings,
    and much more. Take a look at the `s3eDevice.h` header file or the Marmalade documentation
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Creating multiple resource sets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since Marmalade allows us to target so many different devices, it seems a shame
    to limit ourselves to a subset of them just because our graphics are too low or
    too high resolution for certain devices, or some devices have less memory and
    therefore can't handle lots of high resolution textures.
  prefs: []
  type: TYPE_NORMAL
- en: Another issue we might face is that different devices support different file
    formats for audio or video clips. To improve render speed and memory usage we
    might also consider using hardware texture compression, which of course varies
    depending on the type of graphics processor a particular device has.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade provides a couple of solutions to these problems. The first, more
    global approach is to make use of **build styles** , which allow us to both load
    different sets of resource files when loading a GROUP file and specify the type
    of hardware texture compression to apply.
  prefs: []
  type: TYPE_NORMAL
- en: Build styles are then enhanced by the concept of **resource templates**, which
    allow us to more finely control the configuration of resources. Resource templates
    can be used to affect the final format of a texture or to modify the way a 3D
    model is converted for use in the game, among other things.
  prefs: []
  type: TYPE_NORMAL
- en: Using build styles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Marmalade comes with a number of built-in build styles that allow us to build
    resources for all the common GPU formats used across mobile devices. The build
    styles available are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Build style | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `sw` | Build resources optimized for use with Marmalade''s legacy software
    renderer. Resources built in this way cannot be rendered using hardware acceleration.
    This format is now only of use if we are using the `IW_USE_LEGACY_MODULES` define
    in our MKB file in order to make the software renderer available for use. |'
  prefs: []
  type: TYPE_TB
- en: '| `gles1` | Builds resources without any form of texture compression. This
    is the default if no build style is specified. |'
  prefs: []
  type: TYPE_TB
- en: '| `gles1-pvrtc` | Same as `gles1`, but uses the PVRTC format for texture compression
    on images where this type of compression works well. Typically this just means
    images with no alpha channel, as PVRTC tends to perform badly on such textures.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gles-atitc` | Same as `gles1`, but uses the ATITC texture compression format
    where possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `gles1-dxt` | Same as `gles1`, but uses the DXT format for texture compression.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `gles2-etc` | Intended for use on devices that make use of OpenGL ES 2.x
    and support the ETC texture compression format. |'
  prefs: []
  type: TYPE_TB
- en: We can also define our own custom build styles should the default ones not suffice.
    To do this we create a file in the `data` directory called `resbuildstyles.itx`.
    This file is automatically loaded by the resource manager when it is initialized
    in the call to `IwResManagerInit` and it contains one or more instances of the
    `CIwResBuildStyle` class.
  prefs: []
  type: TYPE_NORMAL
- en: To declare a build style instance we must give it a name so that it can be selected
    for use, an optional list of directories in which resource files can reside, and
    an indication of the platform this build style is targeting. Note that in the
    case of build styles, the platform does not refer to any particular operating
    system; instead it refers to the type of GPU the style targets, which for the
    most part means the type of hardware texture compression to be used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of a `resbuildstyles.itx` file that will be used for discussion
    in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Adding extra resource directories
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `addReadPrefix` parameter allows us to add a new search path that will be
    checked whenever we attempt to load a file of any kind. A directory name is specified;
    this must be a subdirectory within the project's `data` directory. If you want
    to add more than one extra search directory, just include further `addReadPrefix`
    entries.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we try to open a file, Marmalade will first look in the list of extra
    directories specified by the build style in the order they were specified. If
    the requested file is found in one of these directories, it will be loaded from
    there; otherwise the resource manager will revert to looking in the `data` directory.
  prefs: []
  type: TYPE_NORMAL
- en: Supported build style platforms
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `platform` field of a `CIwResBuildStyle` instance can take one of the following
    values:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `SW` | Build resources optimized for use with Marmalade''s legacy software
    renderer. Again, we must be using the `IW_USE_LEGACY_MODULES` define in our MKB
    in order to use this. |'
  prefs: []
  type: TYPE_TB
- en: '| `GLES1` | This is the default option if none is specified and builds resources
    that can be rendered efficiently using OpenGL ES. |'
  prefs: []
  type: TYPE_TB
- en: '| `IMG_MBX` | Same as `GLES1`, but uses the PVRTC format for texture compression
    on images where this type of compression works well. |'
  prefs: []
  type: TYPE_TB
- en: '| `IMG_MBX_VGP` | Currently the same as `IMG_MBX`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ATI_IMAGEON` | Same as `GLES1`, but uses the ATITC format for texture compression
    where possible. |'
  prefs: []
  type: TYPE_TB
- en: '| `NVIDIA_GOFORCE` | Currently performs the same as `GLES1`. |'
  prefs: []
  type: TYPE_TB
- en: '| `ARM_MALI` | Currently performs the same as `GLES1`. |'
  prefs: []
  type: TYPE_TB
- en: 'While the platform identifier makes it easy to create resources for different
    types of GPU, it is also possible to be a little more specific about the type
    of texture compression to use. This can be done by specifying the platform as
    `GLES1` and adding a `textureFormat` setting. For example, the `atitc` entry from
    the earlier example could be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following values can be used for the `textureFormat` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Value | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `PVRTC_2` | Uses 2-bit PVR texture compression. Not normally recommended,
    as it tends to produce poor-quality results. Can be used on devices featuring
    an Imagination-produced chipset, such as iOS devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `PVRTC_4` | Uses 4-bit PVR texture compression. This type generally yields
    good results for textures with no alpha channel, but can be quite poor when compressing
    transparent textures. By default Marmalade will not perform this type of compression
    on any source texture with an alpha component. This type of compression is supported
    by devices using an Imagination GPU, for example iOS devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `ATITC` | Will compress textures using ATI compression. Automatically uses
    4-bit compression on textures with no alpha channel, or 8-bit compression on textures
    with transparency. Supported on ATI/Qualcomm chipsets typically used in many Android
    devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `ETC` | Uses 4-bit Ericsson texture compression on textures with no alpha
    channel. Transparent textures cannot be compressed. Supported on ATI/Qualcomm
    chipsets and most chipsets that support OpenGL ES 2.x. |'
  prefs: []
  type: TYPE_TB
- en: '| `DXT1`,`DXT3`, and`DXT5` | `DXT1` compression is a 4-bit format used for
    non-transparent textures. `DXT3` is an 8-bit format that allows transparent textures
    to be compressed. `DXT5` is another 8-bit format that has better support for gradients
    in the alpha channel. If `DXT3` or `DXT5` is specified and an opaque texture is
    encountered, Marmalade will automatically use `DXT1` compression instead. Available
    on NVidia Tegra2 chipset devices. |'
  prefs: []
  type: TYPE_TB
- en: Specifying which build style to use
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With our build styles declared, we now just need to let Marmalade know which
    of them to use when loading resources. The easiest way of doing this is to use
    the `ResBuildStyle` ICF setting, which we do by adding the following to our ICF
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also switch between build styles at runtime as the resource manager
    provides methods for us to set and get the current build style. The following
    code snippets illustrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Bear in mind, however, that while it is easy to switch between build styles,
    this behavior is only supported in Windows debug builds. When we create a release
    build for devices, we will generally only provide the resources required for that
    device type in order to reduce the size of the installation package. We'll be
    looking at how to achieve this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Using resource templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Build styles allow us to make decisions on how the resources for our game are
    processed on a global level; but sometimes we want a little more fine-grained
    control so we can treat different types of resources in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: This is where resource templates come into play. Put simply, all a resource
    template allows us to do is alter the default settings that are applied when processing
    textures, materials, 3D models, animations, and GROUP files.
  prefs: []
  type: TYPE_NORMAL
- en: Resource templates can be defined in an ITX file that we parse before attempting
    to load any resources. Since these are only required in Windows debug builds,
    we do not need to load this file if we won't be building resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Marmalade provides a handy define, `IW_BUILD_RESOURCES`, which is only defined
    in Windows debug builds. Using this define, we can reduce the size of our compiled
    code by excluding any resource processing code. For example, if our resource template
    definitions are contained in a file called `restemplates.itx`, we could use the
    following code snippet to load the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The following code provides an example of what the `restemplates.itx` file might
    look like. We'll discuss the different resource template types in greater detail
    in the coming sections; but notice how a template called `default` is defined
    for each type. This is so we can revert to normal loading behavior should we want
    to.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a resource template has been defined, it can be invoked from within a
    GROUP file by using the `useTemplate` parameter. This parameter takes the type
    and name of a resource template, searches for it and, if found, applies any settings
    defined in the template to any resource of the type that is loaded from then on.
    Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Defining material templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A material resource template is declared by an instance of the `CIwResTemplateMTL`
    class and is used to provide a starting configuration for all instances of `CIwMaterial`
    that are created while the template is in use.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can specify any parameter in a material template that can be applied to
    a `CIwMaterial` instance when processed from an ITX file. In the following table,
    a few of the more useful ones for template purposes are listed, but for a complete
    list take a look at the Marmalade documentation for `CIwMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `colAmbient` ,`colDiffuse` ,`colEmissive` , and`colSpecular` | Allows a default
    RGBA color to be specified for the ambient, diffuse, emissive, and specular lighting
    components. For example: `colAmbient { 255, 255, 255, 255 }`. |'
  prefs: []
  type: TYPE_TB
- en: '| `cullMode` | Specifies the back-face culling method to use for the material.
    Can be one of `BACK`, `FRONT`, or `NONE`. |'
  prefs: []
  type: TYPE_TB
- en: '| `alphaMode` | Specifies a default transparency mode. Can be one of `NONE`,
    `ADD`, `SUB`, `HALF`, or `BLEND`. |'
  prefs: []
  type: TYPE_TB
- en: '| `blendMode` | Specifies the blending type that will be used when drawing.
    Possible values are `MODULATE`, `MODULATE_2X`, `MODULATE_4X`, `DECAL`, `ADD`,
    `REPLACE`, and `BLEND`. |'
  prefs: []
  type: TYPE_TB
- en: '| `alphaTest` | Specifies the type of alpha test to use when drawing pixels.
    Consists of a test type followed by an alpha value. Valid test types are `DISABLED`,
    `NEVER`, `LESS`, `EQUAL`, `LEQUAL`, `GREATER`, `GEQUAL`, `NOTEQUAL`, and `ALWAYS`.
    For example: `alphaTest GEQUAL 128`. |'
  prefs: []
  type: TYPE_TB
- en: '| `zDepthOfs` and`zDepthOfsHW` | Allows this material to have an offset added
    to the z component of vertices when they are rendered, to force drawing backwards
    or forwards. Useful for drawing glowing effects so they can be forced to appear
    behind or in front of a 3D model. `zDepthOfs` is used in the software renderer
    and `zDepthOfsHW` is used when rendering with OpenGL ES. |'
  prefs: []
  type: TYPE_TB
- en: '| `filtering` | Set to `true` to use bilinear filtering when rendering. |'
  prefs: []
  type: TYPE_TB
- en: '| `clampUV` | If `true`, the UV coordinates are clamped within the bounds of
    the texture. This helps avoid the problems caused by bilinear filtering when rendering
    the edges of a texture, as bilinear filtering will attempt to blend between texels
    on the left and right or top and bottom of the image as it will assume the texture
    can be tiled otherwise. |'
  prefs: []
  type: TYPE_TB
- en: Defining image templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can also use the resource template system to specify how we want images
    to be processed, which includes the ability to specify what texture format is
    used. To define a resource template for images we have to declare an instance
    of `CIwResTemplateImage`, which can be configured using the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `formatSW` and`formatHW` | Converts any image to the requested format. The
    two versions of this parameter allow a format to be defined for the software renderer
    and another format for OpenGL ES rendering.For a complete list of texture formats,
    take a look at the Marmalade documentation for the `CIwImage` class, but bear
    in mind that some of these formats apply only to software or hardware rendering.
    For example, OpenGL ES does not support any of the palette-based formats, while
    the software renderer does not support compressed formats such as PVRTC or ATITC.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `compressForDiskSpace` | When `true`, converting textures using the `formatSW`
    and `formatHW` parameters will only store the converted version in the binary
    version of the GROUP file if it is smaller (in memory terms) than the image in
    its original format. Defaults to `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `mipMapping` | When `true`, mipmaps will automatically be generated for the
    image. It can be very useful to set this to `false` for images that will form
    part of the UI, since these generally want to be drawn at their native size and
    mipmaps will not be needed. |'
  prefs: []
  type: TYPE_TB
- en: '| `allowLowQualityCompression` | If using a hardware compressed format, Marmalade
    will not use the requested compression if the resulting texture is likely to be
    of low quality, for example, when using PVRTC on an image with an alpha channel.
    Setting this parameter to `true` allows you to force Marmalade to perform the
    requested compression. |'
  prefs: []
  type: TYPE_TB
- en: '| `ignoreImages` | If set to `true`, images will be ignored and a 2 x 2 checkerboard
    texture will be used instead. Can be useful when debugging to speed up loading
    time. |'
  prefs: []
  type: TYPE_TB
- en: Defining model templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When loading a 3D model from a GEO file, we can use an instance of the `CIwResTemplateGEO`
    resource template to control how the model is processed. Many of the options available
    allow us to increase rendering performance when we know that a particular model
    will be used under certain conditions; for example, it will only ever be rendered
    using OpenGL ES or it may have been exported with normals, which are not required
    as the model will never be rendered with lighting enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the more useful settings are shown in the following table, but there
    are a great many more, so check out the Marmalade documentation for `CIwResTemplateGEO`
    for more details:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `scale` | Allows a floating point value that will be used to scale all the
    vertices of the model, to be specified. Can be useful to allow 3D models to be
    created in a modeling package with one scale and used at a different scale in
    the game. |'
  prefs: []
  type: TYPE_TB
- en: '| `buildCols` ,`buildNorms` ,`buildUVs` , and`buildUV1s` | If set to `true`,
    the processed model data will include vertex colors, normals, and UV information,
    assuming it exists in the exported model. This can be useful to save memory in
    the game if lighting or textures are not required on the model. |'
  prefs: []
  type: TYPE_TB
- en: '| `triStrip` | If set to `true`, a model will be conditioned for rendering
    using triangle strips. The default is `false`, which will cause triangle lists
    to be generated. Only takes effect if the model is being conditioned for rendering
    with OpenGL ES. |'
  prefs: []
  type: TYPE_TB
- en: '| `calculateNorms` | If set to `true`, the model builder will attempt to generate
    vertex normals for lighting purposes. Useful if the source model was exported
    without normals for any reason. |'
  prefs: []
  type: TYPE_TB
- en: '| `chunked` | If set to `true`, the model will be subdivided into smaller "chunks"
    for rendering using binary space partitioning. This can be useful when rendering
    a model much larger than screen size, as it allows whole sections of the model
    which are off-screen to be ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `maxPrimsPerChunk` | Used in conjunction with the `chunked` parameter to
    specify the maximum number of polygons each chunk of the model should contain.
    |'
  prefs: []
  type: TYPE_TB
- en: Defining animation templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `CIwResTemplateANIM` class allows ANIM file data to be adjusted when being
    processed. It only provides a couple of options, which are listed in the following
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `zeroMotionTolerance` | Allows a floating point value to be specified that
    will be used to filter the translation part of any key frame data. When animating
    a model it is possible that the artist may accidentally include some small movements
    to the bone positions, which yields a larger output data set. This value allows
    movements up to the specified value to be ignored, which can mean fewer key frames
    have to be output. |'
  prefs: []
  type: TYPE_TB
- en: '| `transformPrecision` | Another floating point value that specifies the precision
    to be used when animating. The default value is `4.0`, meaning that the animation
    mathematics are calculated at four times the world space resolution. If you have
    an animation with lots of subtle movements, you may want to consider increasing
    this value so that those movements are not lost. |'
  prefs: []
  type: TYPE_TB
- en: Defining GROUP file templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, there is the `CIwResTemplateGROUP` class that is used for creating
    a **texture atlas**. A texture atlas is simply a collection of several smaller
    textures that are laid out within a much larger texture. This can improve rendering
    speed since fewer texture swaps are required when rendering.
  prefs: []
  type: TYPE_NORMAL
- en: We won't be looking at texture atlases in detail in this book, so if you want
    further information take a look at the Marmalade documentation page for the `CIwResTemplateGROUP`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Producing binary versions of resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Previously in this book we've seen references to the fact that Marmalade produces
    binary versions of our resources, which are normally both smaller in size and
    quicker to load compared to the source assets.
  prefs: []
  type: TYPE_NORMAL
- en: Until now we've kind of glossed over this a little, but now that we know about
    build styles it's worth taking a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: The binary versions of resources are generated automatically for us whenever
    we load a GROUP file, assuming we have the ICF setting `ResBuild` set to `1` and
    we're running a Windows debug build of our game. These files are written out with
    the file extension `.group.bin` into a directory called `data-ram`, which lives
    alongside the regular `data` directory where our source assets reside.
  prefs: []
  type: TYPE_NORMAL
- en: If we look inside the `data-ram` directory for any project, we'll discover another
    set of subdirectories and these are what contain the binary versions of our resources.
    These subdirectories correspond to the extra prefix directories that we specify
    in our build styles.
  prefs: []
  type: TYPE_NORMAL
- en: When the `.group.bin` files are written out, they will always be written to
    the prefix directory specified by the currently active build style, regardless
    of whether the source file was read from the standard `data` directory or from
    the extra prefix directory.
  prefs: []
  type: TYPE_NORMAL
- en: The relative directory path from the `data` directory will also be created in
    the output directory when writing out the binary versions of the files.
  prefs: []
  type: TYPE_NORMAL
- en: This makes it very easy for us to deploy different sets of resources to different
    platforms as we just need to include all the `.group.bin` files from one of the
    subdirectories of `data-ram`.
  prefs: []
  type: TYPE_NORMAL
- en: Let's illustrate this with a quick example. Suppose we have a file `data/images/images.group`
    that loads in a number of textures. If no build style is specified, the default
    is the Marmalade-defined `GLES1` style, which specifies a prefix directory called
    `data-gles1`. The binary version of the file will be written to the file path
    `data-ram/data-gles1/images/images.group.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: If we now run our program again, with the `pvrtc` build style selected (as defined
    in the section on build styles earlier in this chapter), the images will be converted
    to PVRTC format and instead written to the file path `data-ram/data-pvrtc/images/images.group.bin`.
  prefs: []
  type: TYPE_NORMAL
- en: As it happens, Marmalade does not just write out the binary versions of the
    GROUP files, it also creates a number of other files that can be useful for debugging
    purposes. We won't look at these in detail in this book, but you might find them
    useful to take a look at if you're having problems with some resource not being
    processed as expected. In particular, there is a file with the extension `.group.bin.txt`
    that details all the classes encountered while processing a particular GROUP file.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is one drawback to this approach, that is, you must load every single
    GROUP file that your game makes reference to in order to generate all the binary
    versions of them. This can particularly be a problem if your game has a large
    number of levels and you have a GROUP file for each level. A good way of solving
    this issue is to create a special mode for your game that can be given a list
    of all the required GROUP files (and potentially any dependencies between them)
    and will then load each file in turn to generate the binary version.
  prefs: []
  type: TYPE_NORMAL
- en: Compressing resources using the Derbh archiver
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Game resources can soon grow very large in size, so it would be great if we
    could somehow compress these files so that they take up less space in our installation
    package, particularly if there are any restrictions on the maximum size an install
    package can have.
  prefs: []
  type: TYPE_NORMAL
- en: Marmalade provides just such a feature in the form of Derbh archives, which
    is very similar to compression systems such as ZIP that you will no doubt be familiar
    with. Derbh supports multiple compression algorithms, including the standard LZMA
    and also its own proprietary algorithm, which can achieve improved compression
    by operating over multiple files simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: The Marmalade SDK provides an API which allows us to load compressed files as
    easily as if they were provided as individual uncompressed files. A command-line
    utility called DZip is also provided to generate the archives in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Derbh archive
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a Derbh archive, the first thing we have to do is create a **DZip
    Configuration File** (**DCL**). This file is passed to the DZip utility to specify
    the source files and how they should be compressed. Here is a simple example of
    a DCL file taken from the Skiing example project for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first line uses the `archive` keyword to specify the name of the Derbh archive
    to be created, which is normally given the extension `.dz`. It is possible to
    create several archives at once by simply adding further `archive` entries.
  prefs: []
  type: TYPE_NORMAL
- en: The `basedir` keyword allows us to specify a directory in which to search for
    the files that will make up the archive. In the previous example we specify the
    directories `data` and `data-ram\data-gles1`.
  prefs: []
  type: TYPE_NORMAL
- en: Next we list all the files that will be added to the archive using the `file`
    keyword. The first parameter is the name of the file to include, which should
    be relative to one of the directories specified by the `basedir` keyword. This
    is followed by a number and a compression type. The number refers to which archive
    the file should be added to, with zero being the first archive specified in the
    DCL file.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of compression types available, although note that not all
    of them actually compress the source file! We can use a different compression
    type for each file if we so wish. The following table shows the types available:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Type | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `lzma` | Uses lzma compression, which generally gives the best compression
    ratio and has a reasonable decompression speed. |'
  prefs: []
  type: TYPE_TB
- en: '| `dz` | Marmalade''s own compression format, which gives a good compression
    ratio and decompression speed. |'
  prefs: []
  type: TYPE_TB
- en: '| `zlib` | Uses zlib compression, which provides a less optimal compression
    ratio but has a very good decompression speed. |'
  prefs: []
  type: TYPE_TB
- en: '| `zero` | A block of zeros the same size as the file will be added to the
    archive. Can be used for debugging purposes, for example, if we need to detect
    corrupted files. |'
  prefs: []
  type: TYPE_TB
- en: '| `copy` | The file is included uncompressed in the archive. In the case of
    a file type that is already compressed, this can produce a smaller end file size
    for the archive than trying to compress the file. |'
  prefs: []
  type: TYPE_TB
- en: With the DCL file constructed, we can then build the archive file using the
    DZip utility. This utility can be found as the file `tools\dzip\dzip.exe` in the
    Marmalade SDK install directory.
  prefs: []
  type: TYPE_NORMAL
- en: To create the archive, simply pass the name of the DCL file into the DZip utility,
    ensuring you run the command from within a directory where the `archive` and `basedir`
    entries can be located.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Derbh archive in code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With a Derbh archive created, it is then really easy to make use of it in our
    game. Firstly we need to add support for the Derbh API by adding `derbh` to the
    list of `subprojects` in the MKB file. We also need to include the `derbh.h` file
    to provide access to the API functions.
  prefs: []
  type: TYPE_NORMAL
- en: To make use of our archive file we just need to add a call to the function `dzArchiveAttach`,
    which takes a single parameter—the filename of the Derbh archive itself. From
    then on any call to open a file will first check to see if it exists in the Derbh
    archive, and if it does the data will automatically be decompressed and returned
    whenever we try to read from the file. It really is that simple!
  prefs: []
  type: TYPE_NORMAL
- en: We can attach more than one archive at a time as well by simply calling `dzArchiveAttach`
    for each archive we wish to use.
  prefs: []
  type: TYPE_NORMAL
- en: If a request is made for a file that doesn't appear in the archive, Marmalade
    will then look in the `data` and `data-ram` directories.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to stop using a Derbh archive for any reason, we can either call
    `dzArchiveDetach` to remove the last archive that was attached or we can specify
    the archive to detach using the `dzArchiveDetachNamed` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that only files loaded from within the application code
    will be accessible from an attached Derbh archive. If you are trying to start
    a music track with s3eAudio or a video clip with s3eVideo, these files must exist
    as separate files as they are loaded by the operating system native methods, which
    obviously will have no way of accessing a Derbh file's contents.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic Derbh method
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For most projects there is actually an even easier way of making use of Derbh
    archives, which doesn't require us to create a DCL file or build a Derbh file
    ourselves. We don't even have to attach the archive in our code! To make use of
    this feature, all we need to do is add the following to the `deployments` section
    of our MKB file (we'll be covering this section of the MKB file in greater detail
    in just a moment).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: With this in place, the Marmalade Deployment Tool will automatically build us
    a Derbh archive from the relevant files in the `assets` section of the MKB file
    (again, the `assets` section will be discussed shortly) and will attach it before
    our application code starts executing.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be wary of using the automatic Derbh facility if you ever deploy files that
    need to be modified by your code after installation. You will not be able to modify
    a file once it is contained within an archive, so you would instead need to make
    a copy of any such files in a new location the first time your application runs.
  prefs: []
  type: TYPE_NORMAL
- en: Creating different deployment types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's now time to take a deeper look at how Marmalade handles the deployment
    process. If you've been following the sample code, you may be wondering how we
    are able to make a deployment package that contains all the necessary resource
    files in order to function. Or, if we're creating multiple resource sets, how
    do we choose which one to pair with our code when creating the installer package?
  prefs: []
  type: TYPE_NORMAL
- en: We also need a way of including icons and captions that will be used to represent
    our application when installed on a device.
  prefs: []
  type: TYPE_NORMAL
- en: All of this magic occurs in the MKB file, and the following sections aim to
    explain exactly what you have to do.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying icons, application names, and other details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `deployments` section of the MKB file is where we can set all manner of
    attributes that will be applied to the final installation package of our application.
    There are a huge number of deployment options that can be specified, some of which
    are global to all supported platforms and some that are operating system specific.
  prefs: []
  type: TYPE_NORMAL
- en: The following table lists several of the more immediately useful attributes,
    but you should go to **Marmalade** | **Marmalade Development Tools Reference**
    | **MKB File Settings** | **Deployment Options** in the Marmalade documentation
    for full details.
  prefs: []
  type: TYPE_NORMAL
- en: '| Attribute | Description |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `assets` | Specifies which asset group to use in a deployment. This will
    be explained in greater detail in the following sections. |'
  prefs: []
  type: TYPE_TB
- en: '| `name` | Specifies the name of the deployment. This name will be used for
    the name of the installation directory, the executable file, and the installation
    package file. If this value is not specified, the filename of the MKB file will
    be used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `caption` | This is the name that will be used to identify the application
    once installed on the device—for example, the text that appears underneath a program
    icon. If no caption is specified, the `name` value will be used instead. |'
  prefs: []
  type: TYPE_TB
- en: '| `app-icf` | Allows an alternative file to be specified for use instead of
    the default `app.icf` file. |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | Specifies the version number of the application. It should be
    provided in the form `major.minor.revision`. |'
  prefs: []
  type: TYPE_TB
- en: '| `version-major`,`version-minor`, and`version-revision` | An alternative way
    of specifying the version number. Each of these attributes should be followed
    by a number representing the respective part of the version number. |'
  prefs: []
  type: TYPE_TB
- en: '| `iphone-icon`,`iphone-icon-ipad`,`iphone-icon-high-res`, and`iphone-icon-ipad-high-res`
    | Sets the icons for use in iOS deployment. These settings specify a filename
    to an icon of suitable format and dimension to be used as the specified icon type.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `android-icon`,`android-icon-hdpi`, and`android-icon-ldpi` | Sets the filenames
    containing the icons for use on Android deployments. |'
  prefs: []
  type: TYPE_TB
- en: '| `bada-icon` | Specifies the file to be used for the icon on Bada deployments.
    |'
  prefs: []
  type: TYPE_TB
- en: As you can see, there are options for specifying the icon files for most platforms
    and indeed there are further platform-specific attributes for specifying information
    such as application signing keys.
  prefs: []
  type: TYPE_NORMAL
- en: You should check out the aforementioned page of the Marmalade documentation
    for further details on this, as you will be unable to produce final deployment
    packages for submission purposes without this information.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying asset lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need some way of listing all the resource files that have to be included
    in the deployment package so our game can run. Marmalade allows us to do this
    by way of the `assets` section of the MKB file. Here''s an example from this chapter''s
    version of the Skiing project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This small example demonstrates most of the functionality available in the `assets`
    section. First, you will notice the use of square brackets to create named groups
    of assets. In the example we have asset groups called `common`, `normal`, and
    `highres`.
  prefs: []
  type: TYPE_NORMAL
- en: Normal brackets are used to specify a directory, relative to the directory containing
    the MKB file, where files that need to be included in the deployment package can
    be located. This is then followed by the files themselves. You can have any number
    of these blocks of files in an asset group.
  prefs: []
  type: TYPE_NORMAL
- en: The important thing to remember about how directories and files are specified
    in an asset group is that the directory in brackets becomes the root path of the
    application's installation directory on the device. Let's illustrate this by looking
    at an example.
  prefs: []
  type: TYPE_NORMAL
- en: First we have the `common` asset group, which specifies that the file called
    `sound/music.mp3` can be found in the `data` directory. When installed on the
    device, the `music.mp3` file will be written into a subdirectory called `sound`
    in the application's installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's consider the asset group called `normal`. Here the path to the file
    is completely enclosed in the brackets and just the name of the file, `skiing.dz`,
    is specified. This will result in the `skiing.dz` file being written into the
    application's installation directory.
  prefs: []
  type: TYPE_NORMAL
- en: There is one final feature of the assets section demonstrated by the example,
    which is the ability to include an asset group from within another asset group.
    This is done using the `include` keyword, which is enclosed in angle brackets
    along with the name of the asset group to be included.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the example we can see that both the `normal` and `highres` asset
    groups include the `common` asset group.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and using deployment types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can now look at creating different configurations for different devices.
    The `deployments` sections of the MKB file also allows us to create different
    deployment types by specifying a name in square brackets. All settings that are
    made after this will only apply to that deployment type. Settings can be applied
    globally across all deployment types by specifying them with square brackets before
    defining a deployment type.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to limit a deployment type to a certain set of mobile platforms
    by following the name in square brackets with a platform identifier or a comma-separated
    list of platforms in quote marks.
  prefs: []
  type: TYPE_NORMAL
- en: 'A full list of all the platforms supported by Marmalade at the time of this
    writing is provided in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Platform | Notes |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `android` | Specifies the Android operating system. |'
  prefs: []
  type: TYPE_TB
- en: '| `iphone` | Any iOS-based device—iPhone, iPod touch, or iPad. |'
  prefs: []
  type: TYPE_TB
- en: '| `bada` | Targets the Samsung Bada platform. |'
  prefs: []
  type: TYPE_TB
- en: '| `lgtv` | Specifies the LG Smart TV system. |'
  prefs: []
  type: TYPE_TB
- en: '| `playbook` | For targeting the Blackberry Playbook tablet. |'
  prefs: []
  type: TYPE_TB
- en: '| `symbian9` | Builds an application that runs on Symbian 9 S60 or Symbian
    ^3 devices. |'
  prefs: []
  type: TYPE_TB
- en: '| `webos` | Targets the webOS platform, the best known device being the now
    discontinued HP TouchPad. |'
  prefs: []
  type: TYPE_TB
- en: '| `winmobile` | Allows for Windows Mobile 6 device support. Note that Marmalade
    cannot target Windows Phone 7. |'
  prefs: []
  type: TYPE_TB
- en: '| `win32` | For x86 Windows builds. |'
  prefs: []
  type: TYPE_TB
- en: '| `osx` | For x86 Apple Mac builds (when using the Mac version of Marmalade).
    |'
  prefs: []
  type: TYPE_TB
- en: It is not mandatory to specify a platform list in a deployment type. If no list
    is given, it is assumed that any platform is a valid target.
  prefs: []
  type: TYPE_NORMAL
- en: Once a deployment type has been specified, any attributes will only apply to
    that deployment type. This is particularly useful to us for being able to specify
    different sets of resources. By using the `assets` attribute we can specify the
    asset group that we want to be included in the final deployment package. The following
    example of the `deployments` section is taken from the Skiing project for this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To create an installation package for a particular deployment type, all we
    have to do is follow the same deployment instructions provided in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Marmalade"), *Getting Started with Marmalade*,
    of this book to start up the **Marmalade System Deployment Tool**. The second
    page of this application allows us to choose the deployment types that we want
    to create by clicking on checkboxes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating and using deployment types](img/3363_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This page does allow you to create and modify deployment types by way of the
    **Add <config>**, **Copy <config>**, and **Remove <config>** buttons, but I personally
    prefer specifying them by hand in the MKB file. Using these buttons modifies the
    MKB file accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have progressed through all the pages of the deployment tool and made
    the deployment packages, they can be found in the folder `build_projectname_vcxx\deployments`,
    where `projectname` is the name of the MKB file and `vcxx` refers to the version
    of Microsoft Visual C++ that you are using for development.
  prefs: []
  type: TYPE_NORMAL
- en: Example code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two example projects that accompany this chapter, and they are described
    in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The build styles project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is a very simple example demonstrating the use of build styles, resource
    templates, and deployment types. It is based on the Graphics2D example from [Chapter
    2](ch02.html "Chapter 2. Resource Management and 2D Graphics Rendering"), *Resource
    Management and 2D Graphics Rendering*.
  prefs: []
  type: TYPE_NORMAL
- en: The `resbuildstyles.itx` file defines a build style called `highres` that specifies
    a prefix directory called `data-highres`. If you look inside the `data` directory,
    you will see that the jar of the marmalade image in `data\images\textures\marmalade.png`
    is 256 x 256 pixels in size. A new directory for the `highres` build style has
    also been added, containing a 512 x 512 version of this image. This file is called
    `data\data-highres\images\textures\marmalade.png`.
  prefs: []
  type: TYPE_NORMAL
- en: If you now look at the `app.icf` file, you will see the new entry `ResBuildStyle=highres`.
    If you run the program with this line in place, the 512 x 512 version of the image
    will be loaded. Comment out or remove this line, and the 256 x 256 image will
    be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: The `restemplates.itx` file shows a simple example of a resource template that
    will force the images to be converted into RGBA4444 format and also disables mipmapping.
    This resource template is used in the `data\images\images.group` file to reduce
    the size of the `images.group.bin` file as no mipmap images need to be stored
    in it.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `BuildStyles.mkb` file declares two deployment types called `normal`
    and `highres`. When making an install package using the **Marmalade System Deployment
    Tool**, we can select either of these options to include the low or high resolution
    images. Note that the deployment tool will also list the default deployment type
    as this is always defined automatically by the deployment tool. Using the default
    type will not include any resources and so will not work on the device.
  prefs: []
  type: TYPE_NORMAL
- en: The Skiing project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this chapter the Skiing project has been updated to use build styles, resource
    templates, and deployment types. It also makes use of Derbh archives to reduce
    the size of the install package.
  prefs: []
  type: TYPE_NORMAL
- en: In this instance the build styles system has been used to allow a larger size
    of font to be used on devices with a higher screen resolution. The `data\data-highres\ui\fonts`
    directory contains alternative versions of the font files `skiing.gxfont` and
    `skiing.tga` that will be loaded when the `highres` build style has been selected
    in the `app.icf` file.
  prefs: []
  type: TYPE_NORMAL
- en: No changes were necessary to any of the UI layout configuration since we used
    the approach of sizing controls based on the screen dimensions of the device.
    We just need a slightly bigger sized font to fill the larger screen area better.
  prefs: []
  type: TYPE_NORMAL
- en: To make deployments easier and to reduce the overall memory size of install
    packages, the Derbh API has also been used. If you look in the root project directory,
    you will see two new files called `skiing.dcl` and `skiing-highres.dcl`. These
    files list all the resources needed by the game and are used as input to the DZip
    tool to create the archive files. A batch file called `MakeDerbh.bat` has also
    been included to demonstrate use of the DZip tool.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the Derbh archives can obviously not be created until the various
    `.group.bin` files have been generated. In order to do this you will need to run
    the game twice, once with the `ResBuildStyle=highres` setting set in the `app.icf`
    file and again with this line commented out.
  prefs: []
  type: TYPE_NORMAL
- en: The two DCL files create the target archives inside the `data-ram\data-gles1`
    and `data-ram\data-highres` directories, but both generate an archive called `skiing.dz`.
    The deployment types in the `Skiing.mkb` file include the relevant version of
    this file so our code becomes independent of the deployment type. At the start
    of the program we just have to attach the `skiing.dz` archive with the `dzArchiveAttach`
    function in order to access the correct resource files.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we have learnt how Marmalade makes it easy to organize our resource
    files so that we can create different versions of them for devices of different
    specifications. We only need to provide alternative versions of resources that
    must be different, for example higher resolution textures. Any common files, such
    as configuration and GROUP files, can generally stay the same.
  prefs: []
  type: TYPE_NORMAL
- en: We've also covered the use of resource templates to allow us finer control over
    how our resources will be used in the game (for example, by specifying a particular
    type of texture compression to be used) and we've seen how to make different deployment
    types that include the same core code but different resource files.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we've also looked at the Derbh API to allow us to compress our resource
    files to save space in the installation package.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter we'll be looking at how we can make use of social media
    to allow our players to share information about our game with their Facebook friends.
  prefs: []
  type: TYPE_NORMAL
