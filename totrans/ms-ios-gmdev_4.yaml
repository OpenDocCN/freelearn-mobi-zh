- en: Chapter 4. Let's Keep Going! Adding More Functionality
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We got a lot accomplished in the last chapter! We figured out level creation,
    importing our levels into Xcode and getting them and our player all showing up
    in our game. Are you well rested and ready to tackle even more programming awesomeness?
    Let''s see what we will do in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Adding awesome sound effects
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Character animations
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Playing with particles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Menus
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding some enemies
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our game looks pretty awesome, but there's still tons of work to be completed
    before we can even remotely consider releasing it!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Let's get into it, shall we?
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
- en: 'First things first, we ended the last chapter we had just discussed winning
    the level, and dying during the level, however if you tested it and you died or
    beat the level and clicked on the replay button, did the game crash? That''s because
    we need to add one final method:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This block of code simply removes the button from the screen and resets the
    game. Let's proceed!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Adding awesome sound effects
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Yes! We will give our little guy some sound, specifically, when jumping and
    dying. That's not all though! No no! We will also get some groovy tunes playing
    in our levels.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open up our `GameLevelScene.m` file and import the SpriteKit Audio framework
    to play sounds! At the top of the file where all our import methods are, add the
    following line:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'I''ve included some audio for our use as well, so if you haven''t imported
    them into your project, go ahead and do that now, or you can use your own music
    if you like. Once your file has been imported into the project, back in our `GameLevelScene.m`
    file, within our `-(id)initWithSize` method, we will add the following line of
    code to get our music playing:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Test the project and now you should have some rocking tunes playing in the background!
    So cool!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: I think we should now create a sound effect for the jump movement, shouldn't
    we?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: 'Hopping (no pun intended) on to our `Player.m` file, we will locate the block
    of code where we make our player dance. That method is found in the `update` method,
    and in that method, we will locate the ''`if (self.jumping && self.onGround)`
    statement. In the `if` statement, we will add the following code just after the
    open braces of the `if` statement (That is, `{`):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Let's break this function down a little bit. We tell **self** to run an action,
    which self in this case is the player class inherited from SKNode, which is where
    that `runAction` method comes from. Then, we declare that action as a SpriteKit
    action, which is used to play a sound file. We declare the sound file, then we
    tell SpriteKit not to wait for completion.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Now the character will emit a little blip noise every time the player
    taps the jump button. You can apply these methods to anywhere you want to play
    a sound, be it dying, shooting, walking—you name it!
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we used a different method to play the background music then we did
    to play the jumping sound effect? Do you know why we did this?
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: When you play the game, there will be a bunch of sound effects playing at one
    a time. If we play the sound effects using the same method that we use to play
    our music, it would potentially stop playing the music in order to play a new
    sound effect that has been called, as we can only play one background music file
    at a time. So when we play a sound effect, we will not interfere with our background
    music as it plays on a different channel.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: This way, the music will be played without any interruption, unless you get
    a call while playing it, as there's nothing we can do about that.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Our game is now coming together, but I don't like how our player just stays
    still when he's walking or jumping. Let's add in some animations!
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Character animations
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Almost all games contain character or object animations. They add life to the
    objects or characters, and they make the game look way more appealing. Take the
    game we are making as an example. Say we pushed the game for sale, and the player
    just remained in his idle pose all the time, dying, walking, or jumping—there
    he was just standing as he is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Doesn't look proper, does it? We need to change that!
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: We've already imported the Sprite atlas file that contains all the images required
    to create our character animations, so that saves a lot of the work. The Sprite
    atlas is where all the sprites will go for SpriteKit to access. Instead of having
    images randomly imported all over the place in our project, the Sprite atlas organizes
    them all nicely.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: 'We will go into our `Player.m` class, and just below our `@implementation Player`
    line, add the following line of code so that our implementation looks like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We need to add an array of images that will make up our walking animations or
    any other animations that you would like to create.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `initWithImageNamed` method, we need to create the array, locate
    the walking images within the atlas, and then add them to our array. To do this,
    add the following code directly under the opening bracket for our `init` method:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's discuss what just happened here because it's a lot of confusing jargon!
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: In the first line, we added sets to an array to hold all the walking images
    within the atlas. Next, we load the texture atlas that contains all our images.
    What's great is that the SpriteKit automatically loads the correct resolution
    for the device we are using, hence the @2x images to make up for the higher resolution
    images used for retina displays.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Next, we tell Xcode to search through the atlas for images named `P1Walking`;
    the `%d` automatically searches through all the images named `P1Walking`. So,
    this will start at image `0`, then `1`, `2`, `3`, and so forth. Finally, we add
    the images into our walking animation array.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to add an action that will fire the animation and stop it when
    called. We need to add the following methods into our `Player.m` file:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We add an action key, `PlayerWalking` to be able to stop the animation when
    needed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'We call this method once when the player is touching the walking zones we created
    in the previous chapter. Let''s go over to our `Player.h` file and create another
    property. With all our other properties, add the following:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, to get our little guy actually animated, we need to jump on to `GameLevelScene.m`
    file. In our `touchesBegan` method, where we call the `walking` and `goingBackwards`
    Booleans, we need to add the following code:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So, now our `touchesBegan` method will look like this (with the new code highlighted):'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This will now set our Boolean `true` whenever the player touches these walking
    zones. We also need to set them `false` when the touches end, so we will scroll
    down to our `touchesEnded` method and add the following where we turn our walking
    and `goingBackwards` method to `no`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now let''s go back to our `Player.m` file, and we are going to add the following
    lines of code to our `update` section:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Now when the player touches a walking zone, it will set the `animateWalking`
    Boolean to `true`, which will call the `PlayerWalking` action. When that action
    is called, we will then animate the character with a walking animation, and when
    the player removes their fingers from the walking zone, it will stop animating.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Whew! That's a lot of code for something so simple, but the results look great!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '![Character animations](img/B03553_04_01.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
- en: Bit by bit, our little game is coming together! Let's make this level look a
    little dark and dreary. Let's play with some particles to add depth!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Playing with particles
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: SpriteKit makes particles super easy, so easy that, in fact, a lot of common
    particle effects, such as flames, smoke, and rain are premade templates available
    when creating our particle file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: 'In Xcode, to create a new particle emitter, simply navigate to **File** | **New**
    | **File**. Under the template creator in the **iOS** section (ignore the fact
    that I have OS X selected in the previous screenshot) and under **Resource**,
    select **SpriteKit Particle File**, as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with particles](img/B03553_04_02.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: This is where creating the effects are super easy, simply select **Rain** from
    the particle template.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with particles](img/B03553_04_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: Yes, it's that easy to create particles!
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, all that we have to do is save it, which I just did in the `ADESA` project
    folder. Now, you will see our new particle emitter file in the project explorer
    in Xcode. Click on it and you should see something similar to the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with particles](img/B03553_04_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
- en: Don't worry if you don't exactly like the look of the particle effect, we can
    do a whole bunch of adjustments to it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: At the top of the right-hand side bar, click on the **Show SK Node inspector**
    button to see all the adjustments we can make. The only thing I changed here is
    the position range, I changed the value of **X** to **1500** so that it will stretch
    across the whole screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: '![Playing with particles](img/B03553_04_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
- en: If you want to make other adjustments, let me tell you what all these options
    do.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Background
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The background option is provided so you can test the visibility of the particles
    against various colored backgrounds. Changing this option will have no effect
    on the particles.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Particle texture
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle texture is the image file that the emitter will use for the particles.
    The standard provided image is simply a soft white sphere, so you get a nice smooth
    and soft particle. This image is great because it can be used for pretty much
    all types of particles.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: Particle birthrate
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle birthrate is the rate at which new particles are emitted by the
    emitter. The higher the value, the faster the new particles are spat out. (Be
    warned, less particles give better performance). The total number of particles
    to be emitted may also be specified. If you set the value to **0**, this will
    cause particles to be emitted indefinitely. If you specify a maximum value, the
    emitter will stop when particles in the scene reach that value.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Particle life cycle
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle life cycle controls the length of time in seconds for which a particle
    remains alive. The range property can be used to vary the duration of the life
    of particles, for example, if you create an explosion, you can use a larger range
    so you have some particles visible for longer than the others.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Particle position range
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle position range option defines the location from which particles
    are created (self-explanatory, right?). The **X** and **Y** values can be used
    to declare an area around the center of the node location from which particles
    will be created randomly.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Angle
  id: totrans-80
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The angle option relates to the angle at which a newly emitted particle will
    travel away from the creation point in counterclockwise degrees, where a value
    of **0** degrees equates to rightward movement. When we set a range value, it
    will vary the direction in which the particles are emitted.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: Particle speed
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Again, the particle speed option is pretty self-explanatory. It deals with the
    speed at which particles move when they are created. When we set a range value,
    it will vary the direction in which the particles are emitted.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: Particle acceleration
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The acceleration properties control the speed at which a particle accelerates
    or decelerates after emission. I'll use explosions for an example again, with
    this option, you can have them fly out fast but have the shrapnels slow down.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Particle scale
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle scale option obviously refers to the size of the particles, which
    again can be varied with the range setting.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Particle rotation
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particle rotation controls the speed at which a particle rotates. Again,
    you can have a shrapnel rotating as it flies from the explosion.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Particle color
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The particles created by an emitter can change colors during their life. To
    add a new color in the life cycle timeline, click on the color ramp at the location
    where the color is to change and select a new color (think of creating a gradient
    in Photoshop or Illustrator). You can also change an existing color by double-clicking
    on the marker to display the color selection.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: To remove a color from the gradient, click and drag it downward.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: The color blend option controls how many colors in the particles texture image,
    and how they blend with the main color in the color gradient.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: The greater the **Factor** option, the more the colors blend, where **0** causes
    no blending.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Particle blend mode
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The blend mode option controls the way in which the particle image blends with
    the scene. The available options are as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Alpha**: This blends transparent backgrounds in the particle image.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Add**: This adds the particle pixels to the corresponding background image
    pixels.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subtract**: This subtracts the particle pixels from the corresponding background
    image pixels.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multiply**: This multiplies the particle pixels by the corresponding background
    image pixels. This results in a darker particle effect.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**MultiplyX2**: This creates a darker particle effect than the standard multiply
    mode.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Screen**: This inverts pixels, then multiplies and inverts them a second
    time. This results in lighter particle effects (great for flame effects or sparks).'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Replace**: This results in no blending with the background. Only the particle''s
    colors are used.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To implement our particles into the scene, let''s go on over to our `GameLevelScene.m`
    file, and in the `initWithSize` method inside the `if (self = [super initWithSize:size])`
    parentheses, add the following block of code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Build and run to see the great results!
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle blend mode](img/B03553_04_07.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
- en: It looks great, but now that we have it in the scene, I don't quite like the
    look of the rain; I want to tweak it so that it looks a little more realistic.
    Let's go to the particle editor (again, by clicking on the particle file in our
    project explorer) and increase the birthrate of the particles.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Currently, the birthrate is at 150, but I want it to be pouring, so I will increase
    it to 2500\. I will also change the scale down from 0.1 to 0.02 because I think
    the raindrops look way too big. I'll also change the speed to 500 so that it looks
    a little more torrential.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle blend mode](img/B03553_04_08.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
- en: That does look a lot better! It's tough to tell on paper but the effect looks
    great on screen.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the rain looking awesome, let's add in some flames and smoke
    effects to our wrecked ship. Create a new particle file, and instead of selecting
    rain in the template creator, select fire, then save it.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Our fire effect will be implemented differently as we want it to scroll with
    the map. With the rain, we added it to the current screen so that it doesn't move
    with the scene but with the fire. If we were to add it to the scene the same way
    we did the rain, the particles would stay in the same position according to the
    screen, not the whole map.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: 'Back in our `GameLevelScene.m` file, in the same location where we added our
    rain emitter code, add in the following method:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See the difference in code? Instead of adding the `fireEmitter` as a child to
    `self` or `GameLevelScene` class, we add it directly to the map at `25x` and `50y`,
    so now when the player begins to scroll through the scene, the fire stays put,
    burning away the poor crashed ship.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: '![Particle blend mode](img/B03553_04_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
- en: Ignore the extreme drop in frame rate in the screenshot here; whenever I take
    a screenshot, the frame rate plummets, as I am running a slightly older iMac.
    The fire looks good though!
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: I did, however, notice that the frame rate stuck at an almost constant 30fps
    with the flames on the screen. This is where the performance and battery drainage
    comes into play.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: I'm running the iPhone 4S simulator in Xcode because it fits properly on my
    screen, which means people with older devices will have difficulty running this
    game, especially when graphic-intensive elements come onto screen like the particle
    effects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: However, running it on my iPhone 5S, the game hit an average of 60fps. These
    are all the things we have to take into consideration before we publish our game.
    We will discuss this later on in this book.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create a menu system!
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Creating menus and multiple levels
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our game is looking really good, but instead of simply throwing the player into
    the gameplay, let's talk about menus.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: Menus are pretty important (obviously). It's the stepping stone into the gameplay,
    and its absence can leave the players dazed and confused. We don't want that now,
    do we?
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: As we've been going crazy with our level development, we haven't focused on
    the structure of the game; namely, we've done everything without taking menus
    or any other functionality into consideration.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: First off, I've included some more images for your use that need to be imported
    into the project for the following code to work. If you have your own images,
    simply change the name of the button image accordingly.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we have to make some substantial modifications to our `GameLevelScene.m`
    file. First things first, we need to create a new integer variable. This will
    count our levels, with level `0` being our main menu. So, in the `@interface GameLevelScene
    ()` method where we begin our declarations, let''s add in one more declaration:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, let's do some editing!
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start off with the `initWithSize` method. We will edit it so that it
    looks as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: All the init code we had in there originally is now gone. We have placed a nice
    little label and a button. We also changed the background to black but that part
    isn't important. Notice how we name the `playButton`? This comes in handy when
    we detect player touches, which you'll see in a moment.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s scroll on down to our `touchesBegan` method and add the following
    code inside the `for` method:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Here, we add a new SpriteKit node that is created at the location of your touch.
    We then detect whether that node is touching our play button, and then we set
    up all our level 1 stuff.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: I will also change how the game over is handled. As of this moment, when the
    player dies, the screen pops up saying **You have died**, followed by the big
    `replay` button. If we were to leave it as it is, that `replay` button method
    resets the entire game, and I don't think people want to lose their progress when
    they die in a level.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: 'Make the following changes to the code. We will delete the highlighted code
    and replace it with this text:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Now, when you test it and the player dies, he simply teleports to the beginning
    of the level instead of having the `replay` button pop up, which could prove to
    be intrusive after a while.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'With our menu built, when you build and run the project, the main menu should
    look like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating menus and multiple levels](img/B03553_04_10.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: We will now implement multiple levels, as I'm pretty sure players would get
    bored of playing the same level over and over again. I created a new level for
    you in the resources section of this book. For this level, our player will locate
    his lost equipment, but in order to find it, the player needs to work around a
    little trap in the level.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve imported the `level2.tmx` file into your project, hop on to `GameLevelScene.m`
    file and scroll down to our `didHeWin` method and edit it to look as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This new method still detects the player's position, but now we set up a secondary
    `if` statement that detects the level the player is on. In this case, if the level
    is equal to 1, we then remove the current map from the view, and we add the `level2.tmx`
    file to the view as a child. After this, we relocate the player to the beginning
    position in the level and check again for the map layers. Fairly easy, right?
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Don't forget to reimport the `tileSet.png` and `tileSet@2x.png` files with the
    ones provided for this chapter, as they contain the new tiles. If you don't reimport
    these, Xcode will either throw an error or our new tiles just won't appear!
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: You can now build and run our project; now, when the player reaches the end
    of the level, it should switch over to the next level, which as you can see by
    the following image, looks pretty awesome!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating menus and multiple levels](img/B03553_04_11.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
- en: Yes! Our game is coming together more and more! However, as awesome as our game
    looks, it's pretty darn boring without any enemies! Let's give our little spaceman
    some competition.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Creating enemies
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This game isn't simply an exploration game! We need to make this game intense
    and exciting!
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and import the Squiggy set of images that I've included, or again you
    can use your own.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating enemies](img/B03553_04_12.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
- en: In our `GameLevelScene.m` file, we will add a new method to begin spawning random
    enemies. These ones will start off easy, but we will get into some baddies that
    will actually try to kill you!
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyways, anywhere within the `GameLevelScene.m` file, add the following method:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This method creates the Squiggy sprite node. Then, we create a random *y* axis
    coordinate to spawn our Squiggy. Why a random *y* axis? *y* you ask? (ah, pun
    intended). Our Squiggy is a flying creature, of course! We also spawn him a little
    past the visible edge of the screen so that it looks like he's flying into the
    scene, hence we will add the Squiggy 1000px beyond the position of the player.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: We will add him as a child of the map because we want him to scroll with the
    map, as well as give him a name so that we can do our collision detection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Then, we set a random speed range for our Squiggies to be flying at. Then we
    create the actions for SpriteKit to get them flying.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to implement two new properties in our `GameLevelScene.m` class.
    These new classes will control the spawn rate of our Squiggies. So, at the top
    of the class file, add the following implementations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will use the `lastSpawnTimeInterval` method to keep track of the elapsed
    time since we spawned a Squiggy and the `lastUpdateTimeInterval` method to detect
    the time elapsed since the last update.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now going to create a new update method, but don''t worry, it won''t
    interfere with our main `update` method. Go ahead and add this method anywhere
    in the `GameLevelScene.m` file:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Build, run, and forecast calls for scattered showers and Squiggies! The result
    looks pretty cool! We need to make our player get hurt when he touches a Squiggy.
    Hey, they look cute, but they're dangerous!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating enemies](img/B03553_04_13.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
- en: We need to do some work with physics here, so bare with me.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of our `GameLevelScene.m` class, between the `@interface` and the
    `#import` section, add the following two lines of code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: These lines set up two categories, one for the enemies and one for the players.
    We will later add another category for player and enemy projectiles when we incorporate
    shooting.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'We now need to set up the physics of the world, so inside of our `initWithSize`
    method, we need to add the following lines of code:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code sets up the world gravity and sets the scene as the delegate
    that will be notified when two objects collide (or physics bodies).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
- en: Physic body is anything within the level, such as the character, objects, or
    enemies that are controlled by physics.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of our `addSquiggy` method, we need to add the following lines of code,
    just after we create the actual Squiggy sprite:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: What does this code do, you ask? Well, let me explain!
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The first line creates a physics body for our Squiggy sprite. The body is the
    rectangle surrounding the sprite. The next line sets the sprite to be dynamic,
    meaning that the SpriteKit physics engine will have no bearing over the movement
    of our Squiggy. The only thing that controls it is our code. The third line puts
    our Squiggy into the `enemyCategory` method.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: We then tell the engine which category method, if a collision occurs between
    the two objects, should notify us. Obviously, we selected the `playerCategory`
    method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: The next and final line we added is a bit of a doozy to understand, we set the
    `collisionBitMask` value to `0`. The collision bit mask defines the response of
    each object when a collision occurs. In our case, we set it to `0`, meaning that
    they won't react to each other as far as a ricochet or bounce is concerned.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add similar code for our player when we create it, so let''s create
    a new method that we will call each time our player is created (that is, just
    after he dies, or spawns a new level, and so on):'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This is the same method that we used to set up our enemy's physics; we just
    switched around the categories.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, at the bottom of the `didHeWin` method, as well as in the `touchesBegan`
    method where we set up our player after we touch the button, add this line of
    code:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Super duper easy peasy! Now we need to actually detect the collisions between
    the two objects.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add the following method anywhere in our `GameLevelScene.m` class
    file:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We still have to add the `bulletCategory` function, so if you were to build
    the project right now, it would show you an error. Don''t worry, we will add it
    in just a few moments. Finally, we will make some slight adjustments to our `GameOver`
    method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, we changed our code so every time our player is killed, he is removed
    from the scene, and a new player is created at the beginning of the level. Also,
    the physics is set up yet again.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: After testing a few methods, the above method is the one that worked the best.
    I simply teleported our player about 100px ahead of the normal beginning position.
    No idea why. This works though!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Now let's get shooting!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, we will add another category like we did earlier; this will
    be as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We will now use this for our player''s bullets. Also, we want to add a new
    definition, so just under the `#import` section, add the following line of code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This definition will assist in creating an array for all our bullets, which
    we will do a little further in just a bit.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'Just above the `@implementation` line and just before the `@end` line of our
    property declarations, add the following two lines of code:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We created the player bullet array that will allow us to create multiple bullets
    at once. We then defined the number of the next bullet within the array.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside our `setUpPlayerPhysics` method, add the following block of code (don''t
    forget to import all the images located in the resource section of this book):'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Welcome to arrays! What does all this mean? Easy! We take the `_playerBullets`
    array, initialize it with a predefined number of bullets in the array; the `kNumBullets`
    variable which was `20`. So now the array has a value of `20`. Then, for every
    entry in the array, from `0`-`20`, add a bullet. It really is that easy.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a new method, which will be as follows:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We will call the preceding method when the player presses the play button,
    so in our `touchesBegan` method, at the bottom of the `if ([node.name isEqualToString:@"playButton"])
    {` statement, add the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Now, we need to create a new touch zone. So, in our `touchesBegan` method,
    we need to edit our `if (touchLocation.x > self.size.width / 2.0) {` statement
    to the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we selected one of the bullets within the array. We then set the position
    of that bullet at the player's position. Next, we set the bullet's final position
    off the screen, which is why we added two methods, one if the player presses the
    button when walking backward, and the other going forward.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, when you test it you will see the following output:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating enemies](img/B03553_04_14.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
- en: Lots of pew pew! And it shoots according to the direction you're facing too,
    so that's pretty awesome.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in our `setUpPlayerPhysics` method, where we set up the bullets,
    we need to set the `physicsBody` value for each bullet. In the `for` loop, just
    before we add the bullet to the map as a child, add the following code:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is the same as our previous `physicsBody` setup, except we changed the
    bullet's category to the `bulletCategory`.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: Now, when you test your project, you should be shooting, dying, and killing
    without a care in the world! Isn't it great?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating enemies](img/B03553_04_15.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
- en: If it is working for you, great! I'm happy for you! We've done a lot of work
    in this chapter and our game really isn't even close to finishing. Why not try
    to take what you've learned in this chapter and create your own levels? Spawn
    some new enemies, and maybe try having some shooting baddies? If not, I'll cover
    some crazier baddies later on in this book. For now let's go take a break!
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'Our game is running efficiently, running at an almost constant 60 fps! Awesome!
    In case you don''t have things working just right, the following is the complete
    source code you should have up until now:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Summary
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's recall all that we covered in this chapter. We added some music and cool
    sound effects to our game. Then, we gave our player a proper walking animation
    so that he doesn't look like he's floating in the air! However, if that's not
    an effect you're looking for, you can save yourself a bunch of typing. Next, we
    made some really awesome looking particles! We made it rain, and we made the wrecked
    ship burn in flames!
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: We briefly discussed menus, and how we can create a simple main menu. We will
    polish this up later when preparing for publishing.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Then, the enemies! We made our Squiggies, those cute yet dangerous enemies in
    our game. Things are going to get scary, so buckle up and enjoy the ride.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，敌人！我们创造了我们的Squiggies，那些既可爱又危险的敌人。事情将会变得可怕，所以系好安全带，享受这段旅程吧。
- en: 'Note: It will only get scary for our player, and not for us because we are
    the ones creating the madness.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：只有我们的玩家会感到可怕，而我们不会，因为我们才是创造混乱的人。
