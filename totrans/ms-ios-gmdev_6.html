<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Making Our Game More Efficient</h1></div></div></div><p>We have discussed quite a few debugging techniques, and there are a lot of them. Not all of them, however, help us when it comes to efficiency. What do we mean by efficiency? Your app can run great, but that doesn't mean it's going to cause the device to run great. Overheating, extreme battery drain, and other such things can ruin the gameplay experience.</p><p>With that in mind, let's get an idea of what we will cover in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Optimizing our game</li><li class="listitem" style="list-style-type: disc">Preventing extreme battery drain</li><li class="listitem" style="list-style-type: disc">Preventing lag (or at least minimizing it)</li></ul></div><p>This is a critical step in your game development, as you don't want people to complain and delete your app because it's too laggy (or causes the app to stutter because the device is having issues rendering the current scene) or it kills the battery.</p><p>I know you may have never experienced such an issue, but it happens more often than not.</p><p>What would happen if you had downloaded a game that was extremely laggy and killed your battery after an hour of gameplay? You'd, no doubt, delete it off your phone or request a refund.</p><p>So, let's dive into how we can optimize things!</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec27"/>Managing effects</h1></div></div></div><p>As we've been programming our <a id="id232" class="indexterm"/>game so far, we have been haphazardly creating without thinking about how our effects will run on older devices.</p><p>Have no fear! Because we can detect which device the player is using and adjust our particle effects and the number of enemies that will spawn on the screen at a time.</p><p>To begin, in our <code class="literal">GameLevelScene.m</code> file, we will add the following line of code at the top:</p><div><pre class="programlisting">#import &lt;sys/utsname.h&gt;</pre></div><p>This framework will allow us access to detecting the exact device we are working on.</p><p>Just under the <code class="literal">@implementation</code> line, add the following function:</p><div><pre class="programlisting">NSString* deviceName()
{
    struct utsname systemInfo;
    uname(&amp;systemInfo);

    return [NSString stringWithCString:systemInfo.machine
                              encoding:NSUTF8StringEncoding];
}</pre></div><p>Now, if you want to see <a id="id233" class="indexterm"/>which device appears, you can add the <code class="literal">deviceName()</code> function to the <code class="literal">NSLog</code> function in our init section, which would look like this:</p><div><pre class="programlisting">NSLog(deviceName());</pre></div><p>So, your log will now display the device on which you are running, as shown in the following figure:</p><div><img src="img/B03553_06_01.jpg" alt="Managing effects"/></div><p>Not sure what <strong>x86_64</strong> means? In this case, because I am running off the simulator, <strong>x86_64</strong> will be displayed on a 64-bit iMac, or if you are running a 32-bit machine (for older Macs), you will see <strong>i386</strong>.</p><p>Here's a breakdown of what will appear for each device:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>i386</strong> on 32-bit Machine</li><li class="listitem" style="list-style-type: disc"><strong>x86_64</strong> on 64-bit Machine</li><li class="listitem" style="list-style-type: disc"><strong>iPod1,1</strong> on iPod Touch</li><li class="listitem" style="list-style-type: disc"><strong>iPod2,1</strong> on iPod Touch Second Generation</li><li class="listitem" style="list-style-type: disc"><strong>iPod3,1</strong> on iPod Touch Third Generation</li><li class="listitem" style="list-style-type: disc"><strong>iPod4,1</strong> on iPod Touch Fourth Generation</li><li class="listitem" style="list-style-type: disc"><strong>iPhone1,1</strong> on iPhone</li><li class="listitem" style="list-style-type: disc"><strong>iPhone1,2</strong> on iPhone 3G</li><li class="listitem" style="list-style-type: disc"><strong>iPhone2,1</strong> on iPhone 3GS</li><li class="listitem" style="list-style-type: disc"><strong>iPad1,1</strong> on iPad</li><li class="listitem" style="list-style-type: disc"><strong>iPad2,1</strong> on iPad 2</li><li class="listitem" style="list-style-type: disc"><strong>iPad3,1</strong> on 3rd Generation iPad</li><li class="listitem" style="list-style-type: disc"><strong>iPhone3,1</strong> on iPhone 4 (GSM)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone3,3</strong> on iPhone 4 (CDMA/Verizon/Sprint)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone4,1</strong> on iPhone 4s</li><li class="listitem" style="list-style-type: disc"><strong>iPhone5,1</strong> on iPhone 5 (model A1428, AT&amp;T/Canada)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone5,2</strong> on iPhone 5 (model A1429, everything else)</li><li class="listitem" style="list-style-type: disc"><strong>iPad3,4</strong> on 4th Generation iPad</li><li class="listitem" style="list-style-type: disc"><strong>iPad2,5</strong> on iPad Mini</li><li class="listitem" style="list-style-type: disc"><strong>iPhone5,3</strong> on iPhone 5c (model A1456, A1532 | GSM)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone5,4</strong> on iPhone 5c (model A1507, A1516, A1526 (China), A1529 | Global)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone6,1</strong> on iPhone 5s (model A1433, A1533 | GSM)</li><li class="listitem" style="list-style-type: disc"><strong>iPhone6,2</strong> on iPhone 5s (model A1457, A1518, A1528 (China), A1530 | Global)</li><li class="listitem" style="list-style-type: disc"><strong>iPad4,1</strong> on 5th Generation iPad (iPad Air) - Wifi</li><li class="listitem" style="list-style-type: disc"><strong>iPad4,2</strong> on 5th Generation iPad (iPad Air) - Cellular</li><li class="listitem" style="list-style-type: disc"><strong>iPad4,4</strong> on 2nd Generation iPad Mini - Wifi</li><li class="listitem" style="list-style-type: disc"><strong>iPad4,5</strong> on 2nd Generation iPad Mini - Cellular</li><li class="listitem" style="list-style-type: disc"><strong>iPhone7,1</strong> on iPhone 6 Plus</li><li class="listitem" style="list-style-type: disc"><strong>iPhone7,2</strong> on iPhone 6</li></ul></div><p>Pretty extensive, isn't it? However, it<a id="id234" class="indexterm"/> will help when it comes to developing for all devices.</p><p>Now, we can begin setting up the functions to change our particle emission according to the device we are running. For example, as we saw in the previous screenshot, we are running <strong>x86_64</strong>, or in other words, a Mac computer. So, to test this function (while running our game via the simulator), in our <code class="literal">GameLevelScene.m</code> file, scroll down to the <code class="literal">- (void)touchesBegan:(NSSet *)touches withEvent:(UIEvent *)event</code> function and add this block of code just before the <code class="literal">[self addChild:rainEmitter];</code> function where we create our rain emitter:</p><div><pre class="programlisting"> if ([deviceName()  isEqual: @"x86_64"]) 
{
  rainEmitter.particleBirthRate = 150;
}</pre></div><p>You can now play with the<a id="id235" class="indexterm"/> birthrate number to see what looks good and performs well. If you adjust the birthrate and test your project, you will see the particles adjust accordingly, as shown in the following screenshot:</p><div><img src="img/B03553_06_02.jpg" alt="Managing effects"/></div><p>For example, in the preceding image, the birth rate is set to <code class="literal">15,000</code>. While it does look like torrential downpours, the frame rate suffers considerably. Keep in mind that when I take a screenshot, the framerate does plummet quite a bit, but you get the idea that it was averaging about 25fps, because there was such an immense amount for the device to render.</p><p>Now if we drop it down to <code class="literal">1500</code>, we see quite a different result:</p><div><img src="img/B03553_06_03.jpg" alt="Managing effects"/></div><p>It doesn't look as<a id="id236" class="indexterm"/> torrential as it did previously, but we see a major increase in the framerate.</p><p>Don't want to crank down the rain? Let's try adjusting the fire effects on the screen in the same way that we reduced the rain by adding the following code:</p><div><pre class="programlisting">if ([deviceName()  isEqual: @"x86_64"]) 
{
  fireEmitter.particleBirthRate = 100;
}</pre></div><p>This drops the original birthrate that was set to <code class="literal">200</code> down to <code class="literal">100</code>. While a difference of 100 may seem like a huge number, and our particles won't look as good; it's just enough to reduce the lag and not affect the visual appeal of the flames themselves.</p><p>Nice! A solid 60 fps <em>while</em> taking the screenshot! It looks pretty good too!</p><div><img src="img/B03553_06_04.jpg" alt="Managing effects"/></div><p>Now, let's keep in mind<a id="id237" class="indexterm"/> that this is set for the iOS simulator on our Mac, so you can even expect the app to run a little differently, but it does give you a great idea of how it will perform.</p><p>Hoping that we have already decided which devices we will support on our game, we will now add the functions to test the supported devices. For this example, I will only support the iPhone 4S and up, including the iPad 4th generation and up.</p><p>The code that would be added to test these devices is as follows:</p><div><pre class="programlisting">if ([deviceName()  isEqual: @"x86_64"]) {//ios sim
                rainEmitter.particleBirthRate = 1500;
            }
            else if ([deviceName()  isEqual: @"iPhone4,1"]) {//4s
                rainEmitter.particleBirthRate = 1000;
            }
            else if ([deviceName()  isEqual: @"iPad3,4"]) {//4th gen ipad
                rainEmitter.particleBirthRate = 1000;
            }
            else if ([deviceName()  isEqual: @"iPad2,5"]) {//ipad mini
                rainEmitter.particleBirthRate = 1000;
            }
            else if ([deviceName()  isEqual: @"iPad4,1"]) {//ipad air
                rainEmitter.particleBirthRate = 1200;
            }
            else if ([deviceName()  isEqual: @"iPad4,2"]) {//ipad air cellular
                rainEmitter.particleBirthRate = 1200;
            }
            else if ([deviceName()  isEqual: @"iPad4,4"]) {//ipad mini w. retina
                rainEmitter.particleBirthRate = 1300;
            }
            else if ([deviceName()  isEqual: @"iPad4,5"]) {//ipad mini w. retina cellular
                rainEmitter.particleBirthRate = 1300;
            }
            else if ([deviceName()  isEqual: @"iPhone5,1"]) {//iphone 5 at&amp;t/canada
                rainEmitter.particleBirthRate = 1200;
            }
            else if ([deviceName()  isEqual: @"iPhone5,2"]) {//iphone 5 world-wide
                rainEmitter.particleBirthRate = 1200;
            }
            else if ([deviceName()  isEqual: @"iPhone5,3"]) {//iphone 5c gsm
                rainEmitter.particleBirthRate = 1300;
            }
            else if ([deviceName()  isEqual: @"iPhone5,4"]) {//iphone 5c china/global
                rainEmitter.particleBirthRate = 1300;
            }

            else if ([deviceName()  isEqual: @"iPhone6,1"]) {//iphone 5s gsm
                rainEmitter.particleBirthRate = 1500;
            }
            else if ([deviceName()  isEqual: @"iPhone6,2"]) {//iphone 5s china/global
                rainEmitter.particleBirthRate = 1500;
            }
            else if ([deviceName()  isEqual: @"iPhone7,1"]) {//iphone 6 plus
               rainEmitter.particleBirthRate = 2500;
           }
            else if ([deviceName()  isEqual: @"iPhone7,1"]) {//iphone 6
               rainEmitter.particleBirthRate = 2500;
           }</pre></div><p>I know it's a lot to <a id="id238" class="indexterm"/>have to write and test as well. These numbers were all guesstimated, as I don't own all these devices. However, I did run test them on each simulator and all of them seemed to run at a solid framerate.</p><p>We begin with an <code class="literal">if</code> statement to check which device we are running. If we do not detect the device checked, we use an <code class="literal">else if</code> statement. This will cause the code to check the next line for the device. When it finds the running device, it will adjust the birth rate accordingly.</p><p>You can do the same when it comes to the fire effects or any other effect that you have running in your game.</p><p>You can also limit the amount of enemies being spawned simply by changing your update timer function, as shown in the following code:</p><div><pre class="programlisting">- (void)updateWithTimeSinceLastUpdate:(CFTimeInterval)timeSinceLast {

    self.lastSpawnTimeInterval += timeSinceLast;
    if (self.lastSpawnTimeInterval &gt; 2) {
        self.lastSpawnTimeInterval = 0;
        [self addSquiggy];

    }
}</pre></div><p>Simply adjusting the <code class="literal">if (self.lastSpawnTimeInterval &gt; 2)</code> statement to a higher number will reduce the amount of enemies being spawned at a time, as we are increasing the time we will spawn a new enemy. So, the higher the interval, the longer it takes to spawn enemies.</p><p>By reducing these simple things, we will greatly improve the performance of the device, especially older ones that are getting tired and are unable to perform as they used to.</p><p>Remember, better performance (the device not running so hard) equals extended battery life, extended play time, and happier customers.</p><p>There are a plethora of other ways in which we can optimize things; for example, as we mentioned earlier in this book, we can look at the sprites we created, and if they are large files, we can try saving other formats to save space and make it easier for the device to render them.</p><p>You've come here to master iOS development, and you want to learn everything! So, let me explain everything.</p><p>The first thing we <a id="id239" class="indexterm"/>will discuss is how to prevent, or at least how to limit the amount our app runs in the background.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec24"/>Battery management – doing less in the background</h2></div></div></div><p>When the user isn't actively<a id="id240" class="indexterm"/> using your game/app, the device will place it into a background state. The device may eventually suspend the app if it's not performing important tasks, such as finishing a task the user initiated (for example, sending photos or updating a newsfeed) or running in a specially declared background execution mode.</p><p>To save further battery life, your app shouldn't wait to be suspended by the device. It should begin pausing activity immediately once the app has notified that the state has changed (refer to the following image).</p><p>When your app completes any queued tasks, it should notify the device that the background activity is complete. Failing to do so causes the app to remain active and draw energy unnecessarily, unnecessarily, as can be summed up perfectly in the following image:.</p><div><img src="img/B03553_06_05.jpg" alt="Battery management – doing less in the background"/></div><p>Why don't the batteries last longer? It plagues us all...Well, yes, they are improving the battery usage with each new iPhone released, but they are adding more things in the OS that drains the battery, so you're <a id="id241" class="indexterm"/>not really getting anywhere.</p><p>The <em>Common Causes of Energy Wasted by Background Apps</em> section of <em>The Energy Efficiency Guide for iOS App</em> states:</p><div><blockquote class="blockquote"><p><em>Apps performing unnecessary background activity (like music, Facebook or news apps constantly working in the background) waste energy. The following are the common causes of wasted energy in background refreshing apps:</em></p></blockquote></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Not notifying the system when background activity is complete</li><li class="listitem" style="list-style-type: disc">Playing silent audio</li><li class="listitem" style="list-style-type: disc">Performing location updates</li><li class="listitem" style="list-style-type: disc">Interacting with Bluetooth accessories</li></ul></div><p>These are all things, regardless of whether you are creating a game or an app, that you should keep in mind when developing:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Notifying the system when background activity is complete</strong>: For apps, if you are pulling information from a website, you will need to either pause it until the app resumes or set a refresh interval.</li><li class="listitem" style="list-style-type: disc"><strong>Playing silent audio</strong>: For our games, again, when the app enters the background, the sounds and music need to be paused.</li><li class="listitem" style="list-style-type: disc"><strong>Performing location updates</strong>: Have you noticed that annoying arrow icon on the status bar? That equals battery drainage. When the app enters the background, turn location services off.</li><li class="listitem" style="list-style-type: disc"><strong>Interacting with Bluetooth accessories</strong>: This applies for apps and games, especially for something as intensive as Bluetooth speakers or even a Bluetooth keyboard or gamepad. Ensure that Bluetooth disconnects and goes into a rest mode when the app goes into the background. Don't forget to resume once the app reenters the foreground!</li></ul></div><p>Firstly, you can to scan for peripherals, such as bluetooth controllers, or other devices only when needed. To do this, use the following block of code:</p><div><pre class="programlisting">-(void)scanForDevice {

myCentralManager = [[CBCentralManager alloc] initWithDelegate:self queue:nil options:nil]; //this creates the Bluetooth Manager
    
[myCentralManager scanForPeripheralsWithServices:nil options:nil];
//this will scan for a broadcasting device
}
    
- (void)centralManager:(CBCentralManager *)central
     didDiscoverPeripheral:(CBPeripheral *)peripheral
     advertisementData:(NSDictionary *)advertisementData
     RSSI:(NSNumber *)RSSI {       
// Connect to the newly discovered device
    
      // Stop scanning for devices
      [myCentralManager stopScan];
    }</pre></div><p>Pretty easy stuff, eh? I know, this is a lot to take in. Trust me, though, this is all super important stuff.</p><p>Then, when you are finished with the Bluetooth device, simply use the following two methods to disconnect:</p><div><pre class="programlisting">//This will Unsubscribe you from a characteristic value
[peripheral setNotifyValue:NO forCharacteristic:interestingCharacteristic];
    
// Disconnect from the device
[myCentralManager cancelPeripheralConnection:peripheral];</pre></div><p>How do you suspend <a id="id242" class="indexterm"/>activity when your app becomes inactive or moves to the background? Implementing the <code class="literal">UIApplicationDelegate</code> methods in your app delegate (if it hasn't been already, since our app already has this method in the <code class="literal">AppDelegate.m</code> file) will allow the device to receive notifications and suspend activity when your app becomes inactive or transitions from the foreground to the background.</p><p>The <code class="literal">applicationWillResignActive</code> method is called when the app enters an inactive state, such as when a telemarketer calls you to clean your ducts, a text comes in, or the player switches to another app and your app begins the transition to a background state.</p><p>This is where you want to pause any activity, save data, and prepare for any suspension:</p><div><pre class="programlisting">- (void)applicationWillResignActive:(UIApplication *)application {

}</pre></div><p>Now, one big thing to keep in mind, is you don't want to rely strictly on saving data when the application enters the background. You always want to save data at proper points during the gameplay, such as at the end of the level. If you rely strictly on saving data during a state change, such as a level change, or the player pausing or exiting the game, the game won't save as reliably and the poor player could lose some information. For example, let's say you're playing your favourite game, but the game only saves when you finish 3 levels, you could lose important high score, or collected items. Plus the player wouldn't want to have to replay those completed levels.</p><p>Another state, <code class="literal">applicationDidEnterBackground:</code> is called as soon as your app enters the background. With this method, you can stop operations, animations, and update methods immediately, using the following code:</p><div><pre class="programlisting">- (void)applicationDidEnterBackground:(UIApplication *)application {

}</pre></div><p>This method is only <a id="id243" class="indexterm"/>called for a few seconds, so if the app requires more time to complete called requests, you would have to request more execution time using the <code class="literal">beginBackgroundTaskWithExpirationHandler:</code> method, which is to be called if extra time is required.</p><p>When the background tasks are completed, you will be required to call the <code class="literal">endBackgroundTask:</code> method to let the device know the tasks are finished. If you don't call the method, iOS will allow the app a little more time to complete any additional functions. If any saving or unloading methods don't complete in the additional time iOS provides, the app will be suspended.</p><p>To expand, if your app is still wrapping up any methods by the time your app enters the background and the app becomes suspended, all the important performance tweaks, save game, will not occur. Potentially ruining the user's experience.</p><p>Now that we have talked about what to do when the app enters the background, it's time to talk about what to do (or how to do it) when the app resumes.</p><p>We have two methods that will allow us to call any reconnection methods that we may have disconnected, such as Bluetooth devices, location services, and many more:</p><div><pre class="programlisting">- (void)applicationWillEnterForeground:(UIApplication *)application {
    // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.
}</pre></div><a id="id244" class="indexterm"/><p>This method is called immediately before the app transitions from the background to active. Start resuming operations, loading data, reinitializing the User Interface, and getting your app ready for the user:</p><div><pre class="programlisting">- (void)applicationDidBecomeActive:(UIApplication *)application {
    // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.
}</pre></div><p>The <code class="literal">ApplicationDidBecomeActive</code> function is called immediately after the app becomes an active app after being launched by the device or transitioning from a background or inactive state. Essentially, we are fully resuming any operations that were halted.</p><p>These functions are a few great things to keep in mind when developing timers, Bluetooth connections, and so on.</p><p>Another thing to keep in mind, is avoiding extreme graphics and animations. As you have seen in our game, we haven't used any intensive animations. Instead, a majority of our characters have two to four images per animation.</p><p>If your app uses only the standard windows and controls, such as an app like notes, you don't really need to worry about updates to your content, as the system APIs are created with maximum efficiency in mind.</p><p>If you have custom windows and controls, let's say <strong>Shazam</strong>
<a id="id245" class="indexterm"/> for example, you really have to ensure that the code in which you draw everything is efficient.</p><p>For example, you don't want to be refreshing everything on the screen all the time, especially items that are hidden, or even by going overkill on your animations. I know they look good, but they do waste battery life.</p><p>Keep in mind that every time an app draws images and text to the screen, it requires CPU usage, GPU usage, and the screen needs to be active. Ergo, the more you are displaying and refreshing, the more the battery will drain, hence why certain apps murder battery life.</p><p>So you should be mindful of over updating or even inefficient content drawing, as it will draw significant power from the battery.</p><p>Here are some more things to keep in mind. You should always reduce the number of views that are in the app (all of which will be drawing power from the battery).</p><p>If you can help it at all, which I know isn't always possible, you should tune down the number of onscreen effects you use, such as opacity, transparency, and so on. If effects are needed, you should avoid using them on items that refresh frequently, as this will again draw battery power because both the opacity objects and the content underneath need to be updated.</p><p>In regards to animations, use<a id="id246" class="indexterm"/> a maximum of 60fps per animation, anything faster will be troublesome when rendering, as it will require more CPU/GPU to boost the framerate. Also, try to keep all your animation speeds at the same frame rate so the engine isn't struggling to render your character at 60fps and an enemy at 30fps, for example. While having extra frames in the animation may look great, those extra frames are inefficient and will require extra computing, which you guessed it, equals more battery drainage.</p><p>It's even recommended to only use SpriteKit, SceneKit, and Metal when developing games, as these frameworks are made to give you the best performance and efficiency.</p><p>This doesn't mean that you can't use a framework, such as Cocos2d. Cocos2D is actually built on top of the SpriteKit framework and is just as easy to use and just as powerful.</p><p>When testing your app, keep a keen eye set on the debugging tools we discussed in the previous chapter.</p><p>Watch out for these signs:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Battery drain</li><li class="listitem" style="list-style-type: disc">Activity when you expect your app to be idle</li><li class="listitem" style="list-style-type: disc">An unresponsive or slow user interface</li><li class="listitem" style="list-style-type: disc">Large amounts of work on the main thread</li><li class="listitem" style="list-style-type: disc">High use of animations</li><li class="listitem" style="list-style-type: disc">High use of view opacity</li><li class="listitem" style="list-style-type: disc">Swapping</li><li class="listitem" style="list-style-type: disc">Memory stalls and cache misses</li><li class="listitem" style="list-style-type: disc">Memory warnings</li><li class="listitem" style="list-style-type: disc">Lock contention</li><li class="listitem" style="list-style-type: disc">Excessive context switches</li><li class="listitem" style="list-style-type: disc">Excessive use of timers</li><li class="listitem" style="list-style-type: disc">Excessive drawing to screen</li><li class="listitem" style="list-style-type: disc">Excessive or repeated small disk I/O</li><li class="listitem" style="list-style-type: disc">High-overhead communication, such as network activity with small packets and buffers</li><li class="listitem" style="list-style-type: disc">Preventing device sleep</li></ul></div><p>In the previous chapter, we didn't look at measuring the energy usage with Instruments in Xcode.</p><p>Instruments <a id="id247" class="indexterm"/>provide us with a graphical timeline of the usage on our device. You will be able to gather info about the app's CPU usage, network usage, disk usage, and the graphic usage.</p><p>By viewing this timeline, you will be able to analyze the performance of your app, and glean certain points in your app which may be causing lag, slow downs, or potential drops in frame rate so you can make adjustments at those exact moments.</p><p>To access these energy diagnostics, launch Instruments, connect it to your app, and then click on the <strong>Energy Diagnostics</strong> template.</p><p>The <strong>Energy Diagnostics</strong> template monitors factors that affect energy usage on an iOS device, as mentioned earlier, including the CPU and network activity, screen brightness, and much more. Then, you can see the areas in which the usage is highest, and check whether you can reduce the impact in those areas. For example, you might find an opportunity to defer certain Bluetooth tasks until more energy-efficient times, such as when the device is plugged in or connected to Wi-Fi.</p><p>It's all discretionary; as you start to play with the debugging Instruments, you will see what works for you and when is the best time to use certain methods. As you can see by the following image, there are so many excellent tools at your disposal to make your app the most efficient app possible:</p><div><img src="img/B03553_06_07.jpg" alt="Battery management – doing less in the background"/></div><p>With our fantastic game running, click on <strong>Choose a profiling template for</strong> and select the device you are running on (which is the only way you can test battery usage), then select your app.</p><p>Double-click on <a id="id248" class="indexterm"/>the <strong>Energy Diagnostics</strong> profile template. Then, at the top of the new window that pops up, click on the red record button to begin recording our energy usage. Play your game as you normally would. Don't worry, <strong>Instruments</strong> will be recording all your data as you play, so you can focus on looking for bugs while recording your energy usage.</p><p>Awesome!</p><p>When you have completed testing, simply click on the <strong>Stop</strong> button or press <em>Command</em> + <em>R</em> to stop recording.</p><p>Now, you will have a complete log of all the data that was recorded. Scroll through and check whether there are any spikes in the log. If so, go back and check the code in those areas where there was a spike to check whether there is an issue causing the spike.</p><p>As a side note, the energy usage template shows readings from 0-20 which will indicate how much your app is using the energy at that time:</p><div><img src="img/B03553_06_08.jpg" alt="Battery management – doing less in the background"/></div><p>If, let's say you have some awesome particles flying around, and you are connected to a Bluetooth device during gameplay, you will no doubt see that your energy usage is high all the time. This doesn't mean that your app has an issue. It just means your app requires more power to run everything you've implemented.</p><p>I'll take a certain app I use on a regular basis as an example. The app is from a website loaded with some cool and funny photos. Anyways, when I use this app, my phone heats up within minutes and the battery level starts to plummet. Does this mean something is wrong with the app? No! Especially not when you start to figure what the app is doing as you are using it.</p><p>Not only does the <a id="id249" class="indexterm"/>app need to load photos from the server, but it uses your Wi-Fi and location services and shows ads—all this while keeping you logged in to their website so that you can make comments on the photos.</p><p>Now, this does not equate to the ideal user experience, but if you want access photos, you need to expect this type of performance. So don't worry if your device gets warm or the battery drains a little bit—this is a normal byproduct of device usage.</p><p>Don't have access to your computer and need to log energy? Log the usage right on your device!</p><p>If you have already connected your device to Xcode, you will now have access to developer options on your device, as shown in the following screenshot:</p><div><img src="img/B03553_06_09.jpg" alt="Battery management – doing less in the background"/></div><p>From this option, you <a id="id250" class="indexterm"/>can select <strong>Logging</strong> under the <strong>Instruments</strong> section, then click on <strong>Energy</strong> to enable logging, and then click on the <strong>Start Recording</strong> button to begin logging your energy usage, as shown in the following screenshot:</p><div><img src="img/B03553_06_10.jpg" alt="Battery management – doing less in the background"/></div><p>Again, use your app the<a id="id251" class="indexterm"/> same way you normally would, and <strong>Instruments</strong> will log the data for you as your play.</p><p>To finish, go back to this setting. You will see that the <strong>Start Recording</strong> button has now changed to <strong>Stop Recording</strong>. Simply click on <strong>Stop Recording</strong>.</p><p>Now, back in Xcode Instruments, in the <strong>Energy Diagnostics</strong> option, navigate to <strong>File</strong> | <strong>Import Logged Data from Device</strong>.</p><p>Now, you will be greeted with the same data log as you would if you ran the test directly in Xcode.</p><p>Whew! That's a lot to consider!</p><p>I know I've been talking a lot, it's all extremely important information.</p><p>As I've been testing the app, everything ran just perfectly. In fact, the only issued that seemed to bog the device down at all were the particles! And we managed to fix that programmatically by<a id="id252" class="indexterm"/> checking what device we are running and then adjusting our crazy particles accordingly.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec28"/>Summary</h1></div></div></div><p>We've discussed a lot in this chapter, a lot of which was best practices on how to manage your device's performance and battery drainage.</p><p>You are now well prepared to tackle the testing process and ensure that your device is running as efficiently as possible so that no customers return your app or give you low ratings because of how terribly your app affects their device.</p><p>Get excited for the next chapter boys and girls! We will talk about the awesomeness that is deploying your app and monetizing it so that you can make bajillions of dollars! Well, maybe not, but at least enough to pay for your developer cost would be OK.</p><p>Get ready because now is the time when it gets fun, and you get to see all your hard work come together.</p><p>I'll see you in the next chapter my friends!</p></div></body></html>