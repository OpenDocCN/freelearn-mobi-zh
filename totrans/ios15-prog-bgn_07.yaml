- en: '*Chapter 6*: Functions and Closures'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you can write reasonably complex programs that can make decisions
    and repeat instruction sequences. You can also store data for your programs using
    collection types. As the programs you write grow in size and complexity, it will
    become harder to comprehend what they do.
  prefs: []
  type: TYPE_NORMAL
- en: To make large programs easier to understand, Swift allows you to create **functions**,
    which lets you combine a number of instructions together and execute them by calling
    a single name. You can also create **closures**, which lets you combine a number
    of instructions together without a name and assign it to a constant or variable.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you'll have learned about functions, nested functions,
    functions as return types, functions as arguments and the `guard` statement. You'll
    also have learned how to create and use closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Xcode playground for this chapter is in the `Chapter06` folder of the code
    bundle for this book, which can be downloaded here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition](https://github.com/PacktPublishing/iOS-15-Programming-for-Beginners-Sixth-Edition)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Check out the following video to see the code in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://bit.ly/3o2MYTs](https://bit.ly/3o2MYTs)'
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to start from scratch, create a new playground and name it `FunctionsAndClosures`.
  prefs: []
  type: TYPE_NORMAL
- en: You can type in and run all of the code in this chapter as you go along. Let's
    start by learning about functions.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Functions are useful for encapsulating a number of instructions that collectively
    perform a specific task, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: Calculating the 10% service charge for a meal at a restaurant.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating the monthly payment for a car that you wish to purchase.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s what a function looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Every function has a descriptive name. You can define one or more values that
    the function takes as input, known as **parameters**. You can also define what
    the function will output when done, known as its **return type**. Both parameters
    and return types are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'You "call" a function''s name to execute it. This is what a function call looks
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: You provide input values (known as **arguments**) that match the type of the
    function's parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Important Information
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about functions, visit [https://docs.swift.org/swift-book/LanguageGuide/Functions.html](https://docs.swift.org/swift-book/LanguageGuide/Functions.html).
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how you can create a function to calculate a service charge in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a function
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In its simplest form, a function just executes some instructions, and does not
    have any parameters or return types. You'll see how this works by writing a function
    to calculate the service charge for a meal. The service charge should be 10% of
    the meal cost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your playground to create and call this function
    and click the **Play/Stop** button to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You've just created a very simple function named `serviceCharge()`. All it does
    is calculate the 10% service charge for a meal costing $50, which is `50 / 10`,
    returning `5`. You then call this function using its name. You'll see `Service
    charge is 5` displayed in the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: This function is not very useful because `mealCost` is always `50` every time
    you call this function, and the result, `5`, is only printed in the Debug area
    and can't be used elsewhere in your program. Let's add some parameters and a return
    type to this function to make it more useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This is much better. Now, you can set the meal cost when you call the `serviceCharge(mealCost:)`
    function, and the result can be assigned to a variable or constant. It looks a
    bit awkward, though. You should try to make function signatures in Swift read
    like an English sentence, as this is considered best practice. Let's see how to
    do that in the next section, where you'll use **custom labels** to make your function
    more English-like and easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: Using custom argument labels
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Note that the `serviceCharge(mealCost:)` function is not very English-like.
    You can add a custom label to the parameter to make the function easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify your code as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The function works exactly the same as before, but to call it, you use `serviceCharge(forMealPrice:)`.
    This sounds more like English and makes it easier to figure out what the function
    does.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll learn how to use several smaller functions within
    the bodies of other functions, and these are known as **nested functions**.
  prefs: []
  type: TYPE_NORMAL
- en: Using nested functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's possible to have a function within the body of another function, and these
    are called nested functions. A nested function can use the variables of the enclosing
    function. Let's see how nested functions work by writing a function to calculate
    monthly payments for a loan.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, there are three functions within `calculateMonthlyPayments (carPrice:downPayment:interestRate:paymentTerm:)`.
    Let''s take a look at them:'
  prefs: []
  type: TYPE_NORMAL
- en: The first nested function, `loanAmount()`, calculates the total loan amount
    by subtracting `downPayment` from `carPrice`. It returns `50000 - 5000` = `45000`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second nested function, `totalInterest()`, calculates the total interest
    amount incurred for the payment term by multiplying `interestRate` with `paymentTerm`.
    It returns `3.5 * 7` = `24.5`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third nested function, `numberOfMonths()`, calculates the total number of
    months in the payment term by multiplying `paymentTerm` with `12`. It returns
    `7 * 12` = `84`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the three nested functions all use the variables of the enclosing
    function. The value returned is `( 45000 + ( 45000 * 24.5 / 100 ) ) / 84` = `666.96`,
    which is the amount you have to pay monthly for 7 years to buy this car.
  prefs: []
  type: TYPE_NORMAL
- en: As you have seen, functions in Swift are similar to functions in other languages,
    but they have a cool feature. Functions are **first-class types** in Swift, so
    they can be used as parameters and return types. Let's see how that is done in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions as return types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function can return another function as its return type. Type in and run
    the following code to create a function that generates a value for Pi:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `makePi()` function's return type is a function that has no parameters and
    the return type is `Double`. `generatePi()` is a function that has no parameters
    and the return type is `Double`, and will be the function that is returned. So,
    `pi` will be assigned `generatePi()` and will return `22.0/7.0` when called. `3.142857142857143`
    will be printed in the Debug area.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how a function can be used as a parameter for another function in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Using functions as parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A function can take a function as a parameter. Type in and run the following
    code to create a function that determines if a number meeting a certain condition
    exists within a list of numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`isThereAMatch(listOfNumbers:condition:)` has two parameters; an array of integers
    and a function. The function provided as an argument must take an integer value
    and return a Boolean value. `oddNumber(number:)` takes an integer and returns
    `true` if the number is an odd number, which means it can be an argument for the
    second parameter. `numbersList`, an array containing an odd number, is used as
    the argument for the first parameter. Since `numbersList` contains an odd number,
    `isThereAMatch(listOfNumbers:condition:)` will return `true` when called.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, you'll see how you can perform an early exit on a function
    if the arguments used are not suitable.
  prefs: []
  type: TYPE_NORMAL
- en: Using a guard statement to exit a function early
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If there is something wrong with the input data, it is useful to be able to
    exit a function early. Let's say you need a function to be used in an online purchasing
    terminal. This function will calculate the remaining balance of a debit or credit
    card when you buy something. The price of the item that you want to buy is entered
    in a text field. The value in the text field is converted into an integer so that
    you can calculate the remaining card balance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Type in and run the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see this result in the Debug area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Let's see how this function works. The first line in the function body is a
    `guard` statement. This checks to see whether a condition is `true`; if not, it
    exits the function. Here, it is used to check and see whether the user entered
    a valid price in the online purchasing terminal. If so, the value can be converted
    successfully into an integer, and you can calculate the remaining card balance.
    Otherwise, the `else` clause in the `guard` statement is executed. An error message
    is printed to the Debug area and the unchanged card balance is returned.
  prefs: []
  type: TYPE_NORMAL
- en: 'For `print(buySomething(itemValueEntered: "10", cardBalance: 50))`, the item
    price is deducted successfully from the card balance, and `40` is returned.'
  prefs: []
  type: TYPE_NORMAL
- en: 'For `print(buySomething(itemValueEntered: "blue", cardBalance: 50))`, the `guard`
    statement''s condition fails and its `else` clause is executed, resulting in an
    error message being printed to the Debug area and `50` being returned.'
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to create and use functions. You have also seen how to use
    custom argument labels, nested functions, functions as parameters or return types,
    and the `guard` statement.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at closures. Like functions, closures allow you to combine a
    number of instructions together, but closures do not have names and can be assigned
    to a constant or a variable. You'll see how they work in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A closure, like a function, contains a sequence of instructions and can take
    arguments and return values. However, closures don't have names. The sequence
    of instructions in a closure is surrounded by curly braces (`{ }`), and the `in`
    keyword separates the arguments and return type from the closure body.
  prefs: []
  type: TYPE_NORMAL
- en: Closures can be assigned to a constant or variable, so they're handy if you
    need to pass them around inside your program. For instance, let's say you have
    an app that downloads a file from the internet, and you need to do something to
    the file once it has finished downloading. You can put a list of instructions
    to process the file inside a closure and have your program execute it once the
    file finishes downloading. You'll see how closures are used in [*Chapter 16*](B17469_16_Final_VK_ePub.xhtml#_idTextAnchor223),
    *Getting Started with MapKit*.
  prefs: []
  type: TYPE_NORMAL
- en: Important Information
  prefs: []
  type: TYPE_NORMAL
- en: To learn more about closures, visit [https://docs.swift.org/swift-book/LanguageGuide/Closures.html](https://docs.swift.org/swift-book/LanguageGuide/Closures.html).
  prefs: []
  type: TYPE_NORMAL
- en: 'You''ll now write a closure that applies a calculation on each element of an
    array of numbers. Add the following code to your playground and click the **Play/Stop**
    button to run it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This assigns a closure that calculates a number's power of two to `myClosure`.
    The `map()` function then applies this closure to every element in `numbersArray`.
    Each element is multiplied by itself, and `[4, 16, 36, 49]` appears in the Results
    area.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to write closures in a more concise fashion, and you'll see how
    to do that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Simplifying closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the things that new developers have trouble with is the very concise
    way experienced Swift programmers use to write closures. Consider the code shown
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Here, you have `testNumbers`, an array of numbers, and you use the `map(_:)`
    function to map a closure to each element of the array in turn. The code in the
    closure multiplies the number by itself, generating the square of that number.
    The result, `[4, 16, 36, 49]`, is then printed to the Debug area. As you will
    see, the closure code can be written more concisely.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a closure''s type is already known, you can remove the parameter type,
    return type, or both. Single statement closures implicitly return the value of
    their only statement, which means you can remove the `return` statement as well.
    So, you can write the closure as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When a closure is the only argument to a function, you can omit the parentheses
    enclosing the closure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'You can refer to parameters by a number expressing their relative position
    in the list of arguments instead of by name, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: So, the closure now is very concise indeed, but will be challenging for new
    developers to understand. Feel free to write closures in a way that you are comfortable
    with.
  prefs: []
  type: TYPE_NORMAL
- en: You now know how to create and use closures, and how to write them more concisely.
    Great!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you studied how to group statements together into functions.
    You learned how to use custom argument labels, functions inside other functions,
    functions as return types, and functions as parameters. This will be useful later
    when you need to accomplish the same task at different points in your program.
  prefs: []
  type: TYPE_NORMAL
- en: You also learned how to create closures. This will be useful when you need to
    pass around blocks of code within your program.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will study classes, structures, and enumerations. Classes
    and structures allow for the creation of complex objects that can store state
    and behavior, and enumerations can be used to limit the values that can be assigned
    to a variable or constant, reducing the chances for error.
  prefs: []
  type: TYPE_NORMAL
