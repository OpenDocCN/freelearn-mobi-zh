- en: Chapter 10. Creating a HUD
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章 创建HUD
- en: The **Heads-Up Display** (**HUD**) is a key technique that game designers use
    in order to provide information to the user. It's basically a set of graphics
    or text that are detached from the world itself and that are used to tell the
    player things such as how much life or *mana* they have left, or what their score
    is.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**抬头显示（HUD**）是游戏设计师用来向用户提供信息的关键技术。它基本上是一组与世界本身分离的图形或文本，用于告诉玩家他们剩余的生命值或*魔法值*，或他们的得分是多少。'
- en: We're going to create a simple HUD that will give us really useful information
    such as the direction in which the character is going and its position in world
    coordinates. This will be enough to illustrate how to create a HUD. You will want
    to display more useful information in your own game. So let's go!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的HUD，它将提供非常有用的信息，例如角色移动的方向和其在世界坐标中的位置。这将足以说明如何创建一个HUD。你可能会想在你的游戏中显示更多有用的信息。那么，让我们开始吧！
- en: The basics
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基础知识
- en: Create a file called `hud.lua`, require it from `game.lua`, and let's start
    our module.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`hud.lua`的文件，从`game.lua`中调用它，然后开始我们的模块。
- en: Our HUD implementation will be based on the idea that we don't want world coordinates
    to position objects that are not inside the world. Also, we're more used to designing
    layouts for UIs thinking about (0, 0) on the top-left corner and the `Y` axis
    growing downward.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的HUD实现将基于我们不希望将不在世界内的对象定位在世界坐标上的想法。此外，我们更习惯于在设计UI布局时考虑(0, 0)位于左上角，`Y`轴向下增长。
- en: 'So that''s what we''re going to do:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 所以这就是我们要做的：
- en: '[PRE0]'
  id: totrans-7
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It can be done as follows:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样做：
- en: In order to use a different coordinate system, we'll create a new viewport.
  id: totrans-9
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用不同的坐标系，我们将创建一个新的视口。
- en: '[PRE1]'
  id: totrans-10
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This viewport will have the same size as the screen:'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个视口将与屏幕大小相同：
- en: '[PRE2]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It won't use world coordinates. Instead, it will use screen coordinates, but
    we'll invert the `Y` axis so that it grows downward.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它不会使用世界坐标。相反，它将使用屏幕坐标，但我们将反转`Y`轴，使其向下增长。
- en: '[PRE3]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now here's something new. The `setOffset` method is used to move the viewport
    using the projection space. The projection space is a 2 x 2 rectangle with its
    `Y` axis pointing upwards. Passing `-1` as the `X` value to `setOffset` moves
    this projection space half a screen to the left, and passing `1` as the `Y` value
    moves it half a screen to the top, achieving our goal of having the (0, 0) coordinate
    on the top-left corner.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有一些新内容。`setOffset`方法用于使用投影空间移动视口。投影空间是一个2 x 2的矩形，其`Y`轴向上。将`-1`作为`X`值传递给`setOffset`将此投影空间向左移动半个屏幕，将`1`作为`Y`值传递将移动它半个屏幕到顶部，达到我们的目标，即(0,
    0)坐标位于左上角。
- en: Tip
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can see here that this is pretty useful; you could move the (0, 0) to wherever
    you want and the positions will be calculated based on that.
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以看到这里非常实用；你可以将(0, 0)移动到任何你想要的位置，位置将基于此进行计算。
- en: 'After this, we create a layer and load it into the render table like we''re
    used to:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此之后，我们创建一个层并将其加载到渲染表中，就像我们习惯的那样：
- en: '[PRE4]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add a call to `HUD:initialize ()` at the bottom of `Game:initialize` and you
    should be good to go.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game:initialize`的底部添加对`HUD:initialize ()`的调用，你应该就可以开始了。
- en: Now, we're ready to start creating our `HUD` elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好开始创建我们的`HUD`元素。
- en: Left or right, that's the question
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 左边还是右边，这是个问题
- en: 'Now we''re going to display our information on the screen:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在屏幕上显示我们的信息：
- en: First of all, we need to define a font in `game.lua` inside the `resource_definitions`
    table.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在`game.lua`文件中的`resource_definitions`表中定义一个字体。
- en: 'We provided one with the source code for this chapter, but you can use whatever
    font you like:'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们为这一章提供了源代码，但你可以使用你喜欢的任何字体：
- en: '[PRE5]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This should be familiar, since we talked about it in [Chapter 6](ch06.html "Chapter 6. Resource
    Manager"), *Resource Manager*.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这应该很熟悉，因为我们已经在[第6章](ch06.html "第6章 资源管理器")中讨论过，*资源管理器*。
- en: Now we know `hudFont` will reference our font.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在我们知道`hudFont`将引用我们的字体。
- en: 'Let''s go back to `hud.lua`, create a method called `initializeDebugHud`, and
    call it from `HUD:initialize`:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`hud.lua`，创建一个名为`initializeDebugHud`的方法，并在`HUD:initialize`中调用它：
- en: '[PRE6]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We use the font resource that we''ve just created as the font for our textboxes:'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用我们刚刚创建的字体资源作为文本框的字体：
- en: '[PRE7]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then we call an auxiliary method that we will create in a moment. It will receive
    the font size and a rectangle where the text will be placed. The rectangle consists
    of the coordinates for the upper-left and bottom-right corners of the box:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们调用一个辅助方法，我们将在稍后创建它。它将接收字体大小和文本将放置的矩形。矩形由盒子的左上角和右下角的坐标组成：
- en: 'First of all, we create `MOAITextBox`. This is the class that will be used
    to display text. It inherits from `MOAIProp`, so you''ll be able to move it, insert
    it into a layer, and do everything else you can do with `MOAIProp`:'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建 `MOAITextBox`。这是将用于显示文本的类。它继承自 `MOAIProp`，因此你可以移动它、将其插入到层中，以及执行所有其他可以与
    `MOAIProp` 做的事情：
- en: '[PRE8]'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We set the font we loaded previously:'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们设置了之前加载的字体：
- en: '[PRE9]'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then we set the size using the `size` parameter:'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们使用 `size` 参数设置大小：
- en: '[PRE10]'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Tip
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: You can use multiple text styles in `MOAITextBox`; take a look at `setStyle`
    and `MOAITextStyle` in the documents.
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 `MOAITextBox` 中使用多种文本样式；请参阅文档中的 `setStyle` 和 `MOAITextStyle`。
- en: 'We split the `rectangle` table into parameters using `unpack`:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `unpack` 将 `rectangle` 表格拆分为参数：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The rectangle defines a box on the screen to which the text is confined. Text
    won't render outside the rectangle defined using `setRect`.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 矩形定义了一个屏幕上的框，文本被限制在这个框内。文本不会渲染在 `setRect` 定义的矩形之外。
- en: We insert the textbox in the HUD's layer.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将文本框插入到 `HUD` 的层中。
- en: '[PRE12]'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: And finally return the textbox, so it can be referenced later.
  id: totrans-47
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后返回文本框，以便稍后可以引用。
- en: '[PRE13]'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now we have our `HUD` layer populated with the textboxes, but there is one more
    thing we need in order to finish our goal.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将 `HUD` 层填充了文本框，但为了完成我们的目标，我们还需要一件事情。
- en: Updating information
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新信息
- en: 'We need to write something into those textboxes. What we''ll do in this case
    is call an `update` method in `HUD` periodically, so that it can refresh the data
    and print it on the screen:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在那些文本框中写入一些内容。在这种情况下，我们将定期在 `HUD` 中调用一个 `update` 方法，以便它可以刷新数据并在屏幕上打印：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We get the scale that we used to set the character''s direction, and store
    it in a local variable `x`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们获取用于设置角色方向的缩放比例，并将其存储在局部变量 `x` 中：
- en: '[PRE15]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: If you remember what we did before, this should be pretty clear. In order to
    turn right we scaled the character's `prop` to `-1` in the `x` axis, and to `1`
    to turn the character to the left. So that's what we're doing here. If the `x`
    value of the scale is positive, then we're facing left. Otherwise, if it is `-1`,
    we're facing right. Then, depending on the case, we use `MOAITextBox:setString`
    to update the string with the correct direction.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你记得我们之前做了什么，这应该很清楚。为了向右转，我们在 `x` 轴上将角色的 `prop` 缩放为 `-1`，要向左转则将其缩放为 `1`。所以这就是我们在这里所做的事情。如果缩放的
    `x` 值为正，那么我们面向左边。否则，如果它是 `-1`，那么我们面向右边。然后，根据情况，我们使用 `MOAITextBox:setString` 来更新带有正确方向的字符串。
- en: '[PRE16]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Finally we update the textbox; we get the position from the physics body. Using
    the `..` operator to concatenate strings, we generate the correct string formatted
    as `(x, y)`. We then use `math.floor` to round down the position, since it's a
    decimal number.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后我们更新文本框；我们从物理体中获取位置。使用 `..` 操作符连接字符串，生成格式为 `(x, y)` 的正确字符串。然后我们使用 `math.floor`
    向下取整位置，因为它是一个小数。
- en: The only thing we need to do now is add a call to `HUD:update ()` on the `while`
    loop inside `Game:start` and we should see both debug strings on the screen.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要做的唯一一件事是在 `Game:start` 中的 `while` 循环中添加对 `HUD:update ()` 的调用，我们应该能在屏幕上看到两个调试字符串。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: If you are uncertain about the size and layout of the boxes, you can use `MOAIDebugLines.setStyle(MOAIDebugLines.TEXT_BOX)`
    in order to debug them. This will display a line around each textbox.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不确定框的大小和布局，可以使用 `MOAIDebugLines.setStyle(MOAIDebugLines.TEXT_BOX)` 来调试它们。这将围绕每个文本框显示一条线。
- en: Summary
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we learned the basics about how to implement a `HUD` with Moai
    SDK. We dug deeper into the `MOAIViewport` configuration in order to create a
    special viewport that used a different coordinate system than the one we've been
    using so far. We also displayed text for the first time using `MOAITextBox`.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何使用 Moai SDK 实现一个 `HUD` 的基础知识。我们深入研究了 `MOAIViewport` 的配置，以便创建一个使用与之前不同的坐标系统的特殊视口。我们还首次使用
    `MOAITextBox` 显示文本。
- en: 'In the next chapter, we''ll dive into another important aspect of games: sound
    and music.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨游戏的重要方面之一：声音和音乐。
