<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Managing Multimodule Builds"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Managing Multimodule Builds</h1></div></div></div><p>Android Studio<a id="id191" class="indexterm"/> allows you to create modules for not just apps and libraries, but also for Android Wear, Android TV, Google App Engine, and more. All of these modules can be used together in a single project. For example, you might want to create an app that uses Google Cloud Endpoints for the backend and includes integration with Android Wear. In that case, you could have a project with three different modules: one for the app, one for the backend, and one for the Android Wear integration. Knowing how multimodule projects are structured and built can speed up your development cycle significantly.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note15"/>Note</h3><p>The documentation for Gradle and the Gradle Android plugin both use the term multiproject builds. In Android Studio, however, there is a distinction between a <span class="emphasis"><em>module</em></span> and a <span class="emphasis"><em>project</em></span>. A module<a id="id192" class="indexterm"/> can be an Android app or a Google App Engine backend, for example. A <a id="id193" class="indexterm"/>project, on the other hand, is a collection of modules. In this book, we use the terms module and project in the same way the IDE does, to avoid confusion. Keep this in mind when you browse through the documentation.</p></div></div><p>In this chapter, we will cover the theory of multimodule builds, and then show some examples that can be useful in real-life projects:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Anatomy of a multimodule build</li><li class="listitem" style="list-style-type: disc">Adding modules to a project</li><li class="listitem" style="list-style-type: disc">Tips and best practices</li></ul></div><div class="section" title="The anatomy of a multimodule build"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec28"/>The anatomy of a multimodule build</h1></div></div></div><p>Usually, a <a id="id194" class="indexterm"/>multimodule project works by having a root directory that contains all modules in subdirectories. To tell Gradle how the project is structured, and which directories contain modules, you need to provide a <code class="literal">settings.gradle</code> file in the root of the project. Each module can then provide its own <code class="literal">build.gradle</code> file. We already learned how <code class="literal">settings.gradle</code> and the <code class="literal">build.gradle</code> files work in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <span class="emphasis"><em>Basic Build Customization</em></span>, so here we will just focus on how to use them for multimodule projects.</p><p>This is what a multimodule project could look like:</p><div class="informalexample"><pre class="programlisting">project
├─── setting.gradle
├─── build.gradle
├─── app
│    └─── build.gradle
└─── library
     └─── build.gradle</pre></div><p>This is the simplest and most straightforward way to set up a project with multiple modules. The <code class="literal">settings.gradle</code> file declares all the modules in the project and looks like this:</p><div class="informalexample"><pre class="programlisting">include ':app', ':library'</pre></div><p>This makes sure that the app and library modules are included in the build configuration. All you need to do is to add the name of the directory of the module.</p><p>To add the library module as a dependency to the app module, you need to add this to the <code class="literal">build.gradle</code> file of the app module:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(':library')
}</pre></div><p>In order to add a<a id="id195" class="indexterm"/> dependency on a module, you need to use the <code class="literal">project()</code> method, with the module path as the parameter.</p><p>If you want to use subdirectories to organize your modules, Gradle can be configured to suit your needs. For example, you could have a directory structure that looks like this:</p><div class="informalexample"><pre class="programlisting">project
├─── setting.gradle
├─── build.gradle
├─── app
│    └─── build.gradle
└─── libraries
     ├─── library1
     │    └─── build.gradle
     └─── library2
          └─── build.gradle</pre></div><p>The app module is still located in the root as it was earlier, but the project now has two different libraries. These library modules are not located in the project root directory, but in a specific libraries directory. With this directory structure, you can declare the app and library modules in <code class="literal">settings.gradle</code> like this:</p><div class="informalexample"><pre class="programlisting">include ':app', ':libraries:library1', ':libraries:library2'</pre></div><p>Notice how easy it is to declare modules within a subdirectory. All paths are relative to the root directory (where the <code class="literal">settings.gradle</code> file is). The colon is used as a replacement for the forward slash in the path.</p><p>When adding a<a id="id196" class="indexterm"/> module in a subdirectory as a dependency to another module, you should always reference it from the root. This means that if the app module in the previous example depends on <code class="literal">library1</code>, the <code class="literal">build.gradle</code> file for the app module should look like this:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(':libraries:library1')
}</pre></div><p>If you declare dependencies in a subdirectory, all paths should still be relative to the root directory. The reason for this is that Gradle constructs your project's dependency model starting at the root of the project.</p><div class="section" title="The build lifecycle revisited"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec46"/>The build lifecycle revisited</h2></div></div></div><p>Knowing how the build process model is constructed makes it easier to understand how multimodule projects are composed. We already talked about the build lifecycle in <a class="link" href="ch01.html" title="Chapter 1. Getting Started with Gradle and Android Studio">Chapter 1</a>, <span class="emphasis"><em>Getting Starting with Gradle and Android Studio</em></span>, so you already know the basics, but some details are <a id="id197" class="indexterm"/>important specifically for multimodule builds.</p><p>In the first phase, the initialization phase, Gradle looks for a <code class="literal">settings.gradle</code> file. If this file does not exist, Gradle assumes that you have a single module build. If you have multiple modules though, the settings file is where you can define the subdirectories that contain the individual modules. If those subdirectories contain their own <code class="literal">build.gradle</code> files, Gradle will process those, and merge them into the build process model. This explains why you should always declare dependencies on a module with a path relative to the root directory. Gradle will always try to figure out dependencies from the root.</p><p>Once you understand how the build process model is put together, it becomes clear that there are several strategies to configure multimodule project builds. You could configure the settings for all the modules in a <code class="literal">build.gradle</code> file in the root directory. This makes it easy to get an overview of the entire build configuration for a project, but it could get very messy, especially when you have modules that require different plugins that each have their own DSL. Another way is to have <code class="literal">build.gradle</code> files separately for every module. This strategy makes sure that the modules are not tightly coupled to each other. It also makes it easier to track build changes, because you do not need to figure out which change applies to which module.</p><p>The last strategy is the hybrid approach. You can have a build file in the root of the project to define common properties for all modules, and a build file per module to configure settings that <a id="id198" class="indexterm"/>apply only to that specific module. Android Studio follows this approach. It creates a <code class="literal">build.gradle</code> file in the root directory, and another <code class="literal">build.gradle</code> file for the module.</p></div><div class="section" title="Module tasks"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec47"/>Module tasks</h2></div></div></div><p>As soon as you have multiple <a id="id199" class="indexterm"/>modules in your project, you need to think twice before running tasks. When you run a task from the root of the project in the command-line interface, Gradle will figure out which modules have a task with that name and execute it for every module. For example, if you have one mobile app module and one Android Wear module, running <code class="literal">gradlew assembleDebug</code> will build the debug version of both the mobile app module and the Android Wear module. When you change the directory to one of the modules, however, Gradle will only run the tasks for that particular module, even when you use the Gradle wrapper in the root of the project. For example, running <code class="literal">../gradlew assembleDebug</code> from the Android Wear module directory will only build the Android Wear module.</p><p>Switching directories to run module-specific tasks can get annoying. Luckily, there is another way. You can prepend a task name with the module name to run the task only on that specific module. For example, to build the Android Wear module only, you can use the <code class="literal">gradlew :wear:assembleDebug </code>command.</p></div></div></div>
<div class="section" title="Adding modules to a project"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Adding modules to a project</h1></div></div></div><p>Adding a new <a id="id200" class="indexterm"/>module is as simple as going through a wizard in Android <a id="id201" class="indexterm"/>Studio. The wizard also sets up the basics of the build file. In some cases, adding a module will even cause Android Studio to edit the build file of your app module. For example, when adding an Android Wear module, the IDE assumes that you want to use it for your Android app, and add a line in the build file to reference the Android Wear module.</p><p>This is what the <span class="strong"><strong>New Module</strong></span> dialog in Android Studio looks like:</p><div class="mediaobject"><img src="graphics/B01061_05_01.jpg" alt="Adding modules to a project"/></div><p>In the following <a id="id202" class="indexterm"/>sections, we will show different modules that can be<a id="id203" class="indexterm"/> added to an Android project with Android Studio, explain their custom properties, and specify how they alter the build process.</p><div class="section" title="Adding a Java library"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec48"/>Adding a Java library</h2></div></div></div><p>When you add a new <a id="id204" class="indexterm"/>Java library module, the <code class="literal">build.gradle</code> file generated by Android Studio looks like this:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'

dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
}</pre></div><p>Java library modules use the Java plugin instead of the Android plugins we are used to seeing. This means that a lot of Android-specific properties and tasks are not available, but you do not need those for a Java library anyway.</p><p>The build file also has basic dependency management set up, so you can add JAR files to your <code class="literal">libs</code> folder without needing any special configuration. You can add more dependencies, using what you learned in <a class="link" href="ch03.html" title="Chapter 3. Managing Dependencies">Chapter 3</a>, <span class="emphasis"><em>Managing Dependencies</em></span>. The dependency configuration does not depend on the Android plugin.</p><p>To add a Java library module named <code class="literal">javalib</code> as a dependency to your app module, for example, simply add this line to the build configuration file for the app module:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(':javalib')
}</pre></div><p>This tells Gradle to import a module named <code class="literal">javalib</code> in the build. If you add this dependency in your app module, the <code class="literal">javalib</code> module will always be built before the build for the app module itself is started.</p></div><div class="section" title="Adding an Android library"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Adding an Android library</h2></div></div></div><p>We briefly mentioned <a id="id205" class="indexterm"/>Android libraries in <a class="link" href="ch03.html" title="Chapter 3. Managing Dependencies">Chapter 3</a>, <span class="emphasis"><em>Managing Dependencies</em></span>, where we called them library projects. Both names are used throughout the documentation and in various tutorials. In this section, we will use the name <code class="literal">Androidlibrary</code> because that is the name used in the <span class="strong"><strong>New Module</strong></span> dialog in Android Studio.</p><p>The default <code class="literal">build.gradle</code> file for an Android library starts with this line:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'com.android.library'</pre></div><p>Adding a dependency on an Android library module is done in the exact same way as with Java libraries:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(':androidlib')
}</pre></div><p>An Android library contains not only the Java code of the library, but also all Android resources, such as the manifest, strings, and layouts. After referencing an Android library in your app, you can use all of the library's classes and resources in the app.</p></div><div class="section" title="Integrating Android Wear"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Integrating Android Wear</h2></div></div></div><p>If you are looking to<a id="id206" class="indexterm"/> add deep integration of your app to Android Wear, you<a id="id207" class="indexterm"/> will need to add an Android Wear module. It is interesting to note that Android Wear modules also use the Android application plugin. This means that all build properties and tasks are available.</p><p>The only part of the <code class="literal">build.gradle</code> file that is different from a regular Android app module is the dependency configuration:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile fileTree(dir: 'libs', include: ['*.jar'])
    compile 'com.google.android.support:wearable:1.1.0'
    compile 'com.google.android.gms:play-services-wearable:6.5.87'
}</pre></div><p>Every Android <a id="id208" class="indexterm"/>Wear app depends on a few Android Wear–specific libraries provided by Google. In order to use an Android Wear app with your Android app, you need to package it with the app. You can do this by adding a dependency in the Android app:</p><div class="informalexample"><pre class="programlisting">dependencies {
    wearApp project(':wear')
}</pre></div><p>The <code class="literal">wearApp</code> configuration <a id="id209" class="indexterm"/>makes sure that the APK of the Wear module is added to the final APK of the Android app and does the necessary configuration for you.</p></div><div class="section" title="Using Google App Engine"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Using Google App Engine</h2></div></div></div><p>
<span class="strong"><strong>Google App Engine</strong></span><a id="id210" class="indexterm"/> is a cloud computing platform that you can use to host web applications, without having to set up your own server. It is free to use up to a certain usage level, which makes it a good environment for experimentation. Google App Engine also provides a service called Cloud Endpoints, which is used to create RESTful services. Using Google App Engine with Cloud Endpoints makes it easy to build a backend for your apps. The App Engine Gradle plugin makes it even easier by generating a client library for your Android app, meaning you do not need to write any of the API-related code yourself. This makes Google App Engine an interesting option for an app backend, so in the following section we will look at how the App Engine Gradle plugin works, and how we can make use of Cloud Endpoints.</p><p>To create a new <a id="id211" class="indexterm"/>Google App Engine module with Cloud Endpoints, open the <span class="strong"><strong>New Module</strong></span> dialog from <span class="strong"><strong>File</strong></span> | <span class="strong"><strong>New Module…</strong></span> and select <span class="strong"><strong>Google Cloud Module</strong></span>. When setting up the module, you can change the type to include Cloud Endpoints. Then, select the client module that will be using this backend.</p><div class="mediaobject"><img src="graphics/B01061_05_02.jpg" alt="Using Google App Engine"/></div><p>A thorough <a id="id212" class="indexterm"/>explanation of Google App Engine and Cloud Endpoints is beyond the scope of this book; we will only look at the Gradle integration in both the App Engine module and the client app module.</p><div class="section" title="Analyzing the build file"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Analyzing the build file</h3></div></div></div><p>The <code class="literal">build.gradle</code> file for this<a id="id213" class="indexterm"/> module becomes quite big, so we will only look at the most interesting parts, beginning with the new build script dependency:</p><div class="informalexample"><pre class="programlisting">buildscript {
    dependencies {
        classpath 'com.google.appengine:gradle-appengine-plugin:1.9.18'
    }
}</pre></div><p>The App Engine plugin needs to be defined in <code class="literal">classpath</code> of the build script. We have seen this earlier when adding the Android plugin. When that is in place, we can apply the App Engine plugin along with two other plugins:</p><div class="informalexample"><pre class="programlisting">apply plugin: 'java'
apply plugin: 'war'
apply plugin: 'appengine'</pre></div><p>The Java plugin is primarily used to generate JAR files for Cloud Endpoints. The WAR plugin is necessary to run and distribute the entire backend. The WAR plugin generates a WAR file, which is how Java web applications are distributed. Finally, the App Engine plugin adds a number of tasks to build, run, and deploy the entire backend.</p><p>The next important block defines the dependencies of the App Engine module:</p><div class="informalexample"><pre class="programlisting">dependencies {
    appengineSdk 'com.google.appengine:appengine-java-sdk:1.9.18'
    compile 'com.google.appengine:appengine-endpoints:1.9.18'
    compile 'com.google.appengine:appengine-endpoints-deps:1.9.18'
    compile 'javax.servlet:servlet-api:2.5'
}</pre></div><p>The first dependency uses <code class="literal">appengineSdk</code> to specify which SDK should be used in this module. The <code class="literal">endpoints</code> dependencies are necessary for Cloud Endpoints to work. These are only added if you choose to use Cloud Endpoints in your module. The servlet dependency is a requirement for any Google App Engine module.</p><p>Configure any App Engine–specific settings in the <code class="literal">appengine</code> block:</p><div class="informalexample"><pre class="programlisting">appengine {
    downloadSdk = true
    appcfg {
        oauth2 = true
    }
    endpoints {
        getClientLibsOnBuild = true
        getDiscoveryDocsOnBuild = true
    }
}</pre></div><p>Setting the <code class="literal">downloadSdk</code> property<a id="id214" class="indexterm"/> to true makes it easy to run a local development server, because it automatically downloads the SDK if it is not present. If you already set up the Google App Engine SDK on your device, you can set the <code class="literal">downloadSdk</code> property to <code class="literal">false</code>.</p><p>The <code class="literal">appcfg</code> block is used to configure the App Engine SDK. In a typical Google App Engine installation, you can manually configure some settings by using the <code class="literal">appcfg</code> command-line tool. Using the <code class="literal">appcfg</code> block, instead of the command-line tool, makes the configuration a lot more portable, as anyone who ever builds the module will have the same configuration without needing to execute any external commands.</p><p>The endpoints block contains some Cloud Endpoints–specific settings.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note16"/>Note</h3><p>A detailed explanation of Google App Engine and Cloud Endpoints configurations is out of the scope of this book. If you wish to know more, look at the documentation at <a class="ulink" href="https://cloud.google.com/appengine/docs">https://cloud.google.com/appengine/docs</a>.</p></div></div></div><div class="section" title="Using the backend in an app"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec11"/>Using the backend in an app</h3></div></div></div><p>When you create the <a id="id215" class="indexterm"/>App Engine module, Android Studio <a id="id216" class="indexterm"/>automatically adds a dependency to the build file of the Android app module. This dependency looks like this:</p><div class="informalexample"><pre class="programlisting">dependencies {
    compile project(path: ':backend', configuration: 'android-endpoints')
}</pre></div><p>We saw syntax like this earlier (when referencing Java and Android libraries), using <code class="literal">project</code> to define the dependency, but with two parameters instead of just one. The <code class="literal">path</code> parameter is the default parameter. We used it earlier, but without specifying its name. A Google App Engine module can have different types of output. You can specify the output you want with the <code class="literal">configuration</code> parameter. We need the App Engine module to generate Cloud Endpoints, so we use the <code class="literal">android-endpoints</code> configuration. Internally, this configuration runs the <code class="literal">_appengineEndpointsAndroidArtifact </code>task. This task generates a JAR file that contains classes that you can use in your Android app module. This JAR file contains not only the models used in the Cloud Endpoints, but also API methods. Integration like this is what makes multimodule projects nice to work with because it speeds up development time. The Gradle tasks in the App Engine module also make it easy to run and deploy your backend.</p></div><div class="section" title="Custom tasks"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec12"/>Custom tasks</h3></div></div></div><p>The App Engine<a id="id217" class="indexterm"/> plugin adds a lot of tasks, but the ones you will use<a id="id218" class="indexterm"/> the most are <code class="literal">appengineRun</code> and <code class="literal">appengineUpdate</code>.</p><p>The <code class="literal">appengineRun</code> task is used to start a local development server that you can use to test your entire backend locally before uploading it to Google App Engine. The first time you run this task, the build may take a while because Gradle needs to download the App Engine SDK. We set this behavior earlier with <code class="literal">downloadSdk = true</code>. To stop the server, you can use <code class="literal">appengineStop</code>.</p><p>Once you are ready to deploy your backend to Google App Engine and start using it in production, you can use <code class="literal">appengineUpdate</code>. This task handles all the deployment details. If you have set <code class="literal">oauth2 = true</code> in the <code class="literal">appengine</code> configuration block, this task will open a browser window, so you can log in to your Google account and get an authentication token. If you prefer not having to do this every time you need to deploy, you can log in to Android Studio with your Google account and use the IDE to deploy the backend. Android Studio runs the same Gradle task, but it will take care of the authentication for you.</p></div></div></div>
<div class="section" title="Tips and best practices"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Tips and best practices</h1></div></div></div><p>There are a few ways<a id="id219" class="indexterm"/> to make it easier to deal with multimodule projects, and<a id="id220" class="indexterm"/> there are a few things to keep in mind when working with several modules. Being aware of these can save you time and frustration.</p><div class="section" title="Running module tasks from Android Studio"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Running module tasks from Android Studio</h2></div></div></div><p>As we saw<a id="id221" class="indexterm"/> in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <span class="emphasis"><em>Basic Build Customization</em></span>, it is <a id="id222" class="indexterm"/>possible to run Gradle tasks straight from Android Studio. When you have multiple modules, Android Studio recognizes them, and shows a grouped overview of all available tasks.</p><div class="mediaobject"><img src="graphics/B01061_05_03.jpg" alt="Running module tasks from Android Studio"/></div><p>The Gradle tool window makes it easier to run module-specific tasks. There <a id="id223" class="indexterm"/>is no option to run a task for all modules at the same time, so if you wish to do that, the command-line interface is still faster.</p></div><div class="section" title="Speeding up multimodule builds"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Speeding up multimodule builds</h2></div></div></div><p>When you build a multimodule project, Gradle processes all modules sequentially. With more and more cores available in computers, we can make the build process a lot faster by building the modules in parallel. This feature already exists in Gradle, but is not enabled by default.</p><p>If you want to apply parallel build execution to your project, you need to configure the <code class="literal">parallel</code> property in the <code class="literal">gradle.properties</code> file on the root of the project:</p><div class="informalexample"><pre class="programlisting">org.gradle.parallel=true</pre></div><p>Gradle attempts to choose the right number of threads, based on available CPU cores. To prevent issues that may arise from executing two tasks from the same module in parallel, each thread <span class="emphasis"><em>owns</em></span> an entire module.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note17"/>Note</h3><p>Parallel build execution is an incubating feature. This means that it is under active development and the implementation may change at any time. This feature has been a part of Gradle for a while now, though, and is already widely used. It is, therefore, safe to assume that the implementation will not disappear or change drastically.</p></div></div><p>Your mileage <a id="id224" class="indexterm"/>may vary, but you might be able to shave off a <a id="id225" class="indexterm"/>significant amount of time from your builds by simply<a id="id226" class="indexterm"/> enabling parallel build execution. There is one caveat, however. For this to work efficiently, you will need to make sure your modules are decoupled.</p></div><div class="section" title="Module coupling"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Module coupling</h2></div></div></div><p>As we saw in <a class="link" href="ch02.html" title="Chapter 2. Basic Build Customization">Chapter 2</a>, <span class="emphasis"><em>Basic Build Customization</em></span>, it is possible to define properties for all modules in a project, using <code class="literal">allprojects</code> in the <code class="literal">build.gradle</code> file. When you have a project with multiple<a id="id227" class="indexterm"/> modules, you can use <code class="literal">allprojects</code> in any module to apply properties to all the modules in the project. Gradle even makes it possible for one module to reference properties from another module. These powerful features can make maintenance for multimodule builds a lot easier. The downside, though, is that your modules become coupled.</p><p>Two modules are considered to be coupled as soon as they access each other's tasks or properties. This has several consequences. For example, you give up portability. If you ever decide to extract a library out of the project, you will not be able to build the library before copying all project-wide settings first. Module coupling also has an effect on parallel builds. Using the <code class="literal">allprojects</code> block in any of the modules will render parallel build execution useless. Be aware of this when you add project-wide properties to any of the modules.</p><p>You can avoid coupling by not directly accessing tasks or properties from other modules. If you need this behavior, you can use the root module as an intermediary so that modules are coupled only to the root module and not to each other.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>We started the chapter by looking at the structure of multimodule builds. Then, we looked at how to set up multiple modules in a single project. We also saw that adding new modules affects how build tasks are run.</p><p>We then looked at some practical examples of new modules, and how each of them can be integrated into a project. Finally, we mentioned some tips and tricks that make it easier to work with multiple modules in one project.</p><p>In the next chapter, we will set up various kinds of tests, and see how to use Gradle to make it easier to run these tests. We will look at running unit tests directly on the Java Virtual Machine, but also at running tests on a real device or an emulator.</p></div></body></html>