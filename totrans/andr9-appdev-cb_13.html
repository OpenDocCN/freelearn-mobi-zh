<html><head></head><body>
        

                            
                    <h1 class="header-title">Telephony, Networks, and the Web</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>How to make a phone call</li>
<li>Monitoring phone call events</li>
<li>How to send SMS (text) messages</li>
<li>Receiving SMS messages</li>
<li>Displaying a web page in your application</li>
<li>Checking online status and connection type</li>
<li>Phone number blocking API</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>We'll start this chapter by looking at telephony functionality with <em>How to make a phone call</em>. After exploring how to make a call, we'll look at how to monitor a phone call with monitoring phone call events. We'll move on to SMS messaging in the How to send SMS messages section, and then we'll cover receiving SMS messages in the Receiving SMS messages section.</p>
<p>We'll then explore <kbd>WebView</kbd> for adding browser functionality to your app. At its basic level, <kbd>WebView</kbd> is a basic HTML viewer. We'll show how you can extend a <kbd>WebViewClient</kbd> class and modify the settings through <kbd>WebSettings</kbd> to create full browser functionality, including JavaScript and Zoom features.</p>
<p>The last recipe of this chapter will explore a new API (added in Android 7.0 Nougat) for blocking phone numbers at the OS level.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to make a phone call</h1>
                
            
            
                
<p>As we've seen in previous recipes, we can call the default applications simply by using an Intent. There are two Intents for phone calls:</p>
<ul>
<li><kbd>ACTION_DIAL</kbd>: Uses the default phone application to make the phone call (no permission required)</li>
<li><kbd>CALL_PHONE</kbd>: Bypasses the UI to directly dial the number (requires permission)</li>
</ul>
<p>Here's the code to set and call the Intent for using the default Phone app:</p>
<pre>Intent intent = new Intent(Intent.ACTION_DIAL); 
intent.setData(Uri.parse("tel:" + number)); 
startActivity(intent); </pre>
<p>Since your application is not doing the dialing and the user must press the Dial button, your app does not need any dialing permissions. The recipe that follows will show you how to place a call directly, bypassing the Dialer app.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>DialPhone</kbd>. Use the default Phone &amp; Tablet option and select Empty Activity when prompted for Activity Type.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we need to add the appropriate permission to make the call. Then, we need to add a button to call our Dial method. Start by opening the Android Manifest and follow these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.CALL_PHONE"/&gt;</pre>
<ol start="2">
<li>Open <kbd>activity_main.xml</kbd> and replace the existing <kbd>TextView</kbd> with the following button:</li>
</ol>
<pre style="padding-left: 60px">&lt;Button<br/>    android:id="@+id/button"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    android:text="Dial"<br/>    android:onClick="dialPhone"<br/>    app:layout_constraintBottom_toBottomOf="parent"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintRight_toRightOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="3">
<li>Add this method, which will check whether your app has been granted the <kbd>CALL_PHONE</kbd> permission:</li>
</ol>
<pre style="padding-left: 60px">private boolean checkPermission(String permission) {<br/>    int permissionCheck = ContextCompat.checkSelfPermission(this, permission);<br/>    return (permissionCheck == PackageManager.PERMISSION_GRANTED);<br/>}</pre>
<ol start="4">
<li>Add the code to dial the number:</li>
</ol>
<pre style="padding-left: 60px">public void dialPhone(View view){<br/>    if (checkPermission(Manifest.permission.CALL_PHONE)) {<br/>        Intent intent = new Intent(Intent.ACTION_CALL);<br/>        intent.setData(Uri.parse("tel:0123456789"));<br/>        startActivity(intent);<br/>    } else {<br/>        ActivityCompat.requestPermissions(this, new String[] {Manifest.permission.CALL_PHONE},1);<br/>    }<br/>}</pre>
<ol start="5">
<li>Before running this on your device, be sure to replace 0123456789 with a valid number.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>As we discussed in the introduction, using the <kbd>CALL_PHONE</kbd> Intent requires the appropriate permission. We add the required permission to the manifest in step 1 and use the method in step 3 to verify the permission before actually calling the Intent in step 4. Starting with Android 6.0 Marshmallow (API 23), permissions are no longer granted during installation. Therefore, we check whether the application has permission before attempting to dial.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to <em>The Android 6.0 Runtime Permission Model</em> recipe in <a href="98c7bc7b-43e2-43de-aed4-fe2fb6dc72f3.xhtml" target="_blank">Chapter 15</a>, <em>Getting Your App Ready for the Play Store</em>, for more information on the new runtime permissions </li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Monitoring phone call events</h1>
                
            
            
                
<p>In the previous recipe, we demonstrated how to make a phone call, both with an Intent to call the default application, as well as by directly dialing the number with no UI.</p>
<p>What if you want to be notified when the calls ends? This is where it gets a bit more complicated, as you'll need to monitor the Telephony events and track the phone state. In this recipe, we'll demonstrate how to create a <kbd>PhoneStateListener</kbd> to read phone state events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>PhoneStateListener</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.</p>
<p>Although it's not required, you can use the previous recipe to initiate a phone call. Otherwise, use the default dialer and/or watch the events from an incoming call. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We only need a single <kbd>TextView</kbd> on the layout to display the event information. Open the <kbd>activity_main.xml</kbd> file and follow these steps:</p>
<ol>
<li>Add or modify the <kbd>TextView</kbd> as follows:</li>
</ol>
<pre style="padding-left: 60px">&lt;TextView<br/>    android:id="@+id/textView"<br/>    android:layout_width="wrap_content"<br/>    android:layout_height="wrap_content"<br/>    app:layout_constraintLeft_toLeftOf="parent"<br/>    app:layout_constraintTop_toTopOf="parent" /&gt;</pre>
<ol start="2">
<li>Add the following permission to the Android Manifest:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.READ_PHONE_STATE"/&gt;</pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following <kbd>PhoneStateListener</kbd> class to the <kbd>MainActivity</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">PhoneStateListener mPhoneStateListener = new PhoneStateListener() {<br/>    @Override<br/>    public void onCallStateChanged(int state, String number) {<br/>        String phoneState = number;<br/>        switch (state) {<br/>            case TelephonyManager.CALL_STATE_IDLE:<br/>                phoneState += "CALL_STATE_IDLE\n";<br/>                break;<br/>            case TelephonyManager.CALL_STATE_RINGING:<br/>                phoneState += "CALL_STATE_RINGING\n";<br/>                break;<br/>            case TelephonyManager.CALL_STATE_OFFHOOK:<br/>                phoneState += "CALL_STATE_OFFHOOK\n";<br/>                break;<br/>        }<br/>        TextView textView = findViewById(R.id.textView);<br/>        textView.append(phoneState);<br/>    }<br/>};</pre>
<ol start="4">
<li>Modify <kbd>onCreate()</kbd> to set up the listener:</li>
</ol>
<pre style="padding-left: 60px">final TelephonyManager telephonyManager = <br/>        (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);<br/>telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);</pre>
<ol start="5">
<li>Run the application on a device and initiate and/or receive phone calls. Upon returning to this app, you'll see the list of events.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>To demonstrate using the listener, we create the Telephony listener in the <kbd>onCreate()</kbd> method with this code:</p>
<pre>final TelephonyManager telephonyManager =<br/>        (TelephonyManager) getSystemService(Context.TELEPHONY_SERVICE);<br/>telephonyManager.listen(mPhoneStateListener, PhoneStateListener.LISTEN_CALL_STATE);</pre>
<p>When a <kbd>PhoneState</kbd> event occurs, it is sent to our <kbd>PhoneStateListener</kbd> class.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In this recipe, we are monitoring the Call State events, as indicated with this constant: <kbd>LISTEN_CALL_STATE</kbd>. The other interesting options include the following:</p>
<ul>
<li><kbd>LISTEN_CALL_FORWARDING_INDICATOR</kbd></li>
<li><kbd>LISTEN_DATA_CONNECTION_STATE</kbd></li>
<li><kbd>LISTEN_SIGNAL_STRENGTHS</kbd></li>
</ul>
<p>Take a look at the <kbd>PhoneStateListener</kbd> link in <em>See also</em> for a complete list.</p>
<p>When we're done listening for events, call the <kbd>listen()</kbd> method and pass <kbd>LISTEN_NONE</kbd>, as shown here:</p>
<pre>telephonyManager.listen(mPhoneStateListener,PhoneStateListener.LISTEN_NONE); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Developer Docs: <kbd>PhoneStateListener</kbd> at <a href="https://developer.android.com/reference/android/telephony/PhoneStateListener.html">https://developer.android.com/reference/android/telephony/PhoneStateListener.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">How to send SMS (text) messages</h1>
                
            
            
                
<p>Since you're probably already familiar with SMS (or text) messages, we won't spend time explaining what they are or why they are important. (If you're not familiar with SMS or want more information, see the link provided in the See also section of this recipe.) This recipe will demonstrate how to send an SMS message. (The next recipe will demonstrate how to receive notifications of new messages and how to read existing messages.)</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>SendSMS</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we need to add the necessary permissions for sending an SMS. Then, we'll create a layout with phone number and message fields and a Send button. When the Send button is clicked, we'll create and send the SMS. Here are the steps:</p>
<ol>
<li>Open the Android Manifest and add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.SEND_SMS"/&gt;</pre>
<ol start="2">
<li>Open <kbd>activity_main.xml</kbd> and replace the existing layout with the following XML:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout <br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" &gt;<br/>    &lt;EditText<br/>        android:id="@+id/editTextNumber"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:inputType="number"<br/>        android:ems="10"<br/>        android:layout_alignParentTop="true"<br/>        android:layout_centerHorizontal="true"<br/>        android:hint="Number"/&gt;<br/>    &lt;EditText<br/>        android:id="@+id/editTextMsg"<br/>        android:layout_width="match_parent"<br/>        android:layout_height="wrap_content"<br/>        android:layout_below="@+id/editTextNumber"<br/>        android:layout_centerHorizontal="true"<br/>        android:hint="Message"/&gt;<br/>    &lt;Button<br/>        android:id="@+id/buttonSend"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Send"<br/>        android:layout_below="@+id/editTextMsg"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="send"/&gt;<br/>&lt;/RelativeLayout&gt;</pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following global variables:</li>
</ol>
<pre style="padding-left: 60px">final int SEND_SMS_PERMISSION_REQUEST_CODE=1; 
Button mButtonSend; </pre>
<ol start="4">
<li>Add the following code to the existing <kbd>onCreate()</kbd> callback:</li>
</ol>
<pre style="padding-left: 60px">mButtonSend = findViewById(R.id.buttonSend);<br/>mButtonSend.setEnabled(false);<br/><br/>if (checkPermission(Manifest.permission.SEND_SMS)) {<br/>    mButtonSend.setEnabled(true);<br/>} else {<br/>    ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.SEND_SMS}, <br/>            SEND_SMS_PERMISSION_REQUEST_CODE);<br/>}</pre>
<ol start="5">
<li>Add the following method to check the permissions:</li>
</ol>
<pre style="padding-left: 60px">private boolean checkPermission(String permission) {<br/>    int permissionCheck = ContextCompat.checkSelfPermission(this,permission);<br/>    return (permissionCheck == PackageManager.PERMISSION_GRANTED);<br/>}</pre>
<ol start="6">
<li>Override <kbd>onRequestPermissionsResult()</kbd> to handle the permission<br/>
request response:</li>
</ol>
<pre style="padding-left: 60px">@Override<br/>public void onRequestPermissionsResult(int requestCode, String permissions[], int[] grantResults) {<br/>    switch (requestCode) {<br/>        case SEND_SMS_PERMISSION_REQUEST_CODE: {<br/>            if (grantResults.length &gt; 0<br/>                    &amp;&amp; grantResults[0] ==<br/>                    PackageManager.PERMISSION_GRANTED) {<br/>                mButtonSend.setEnabled(true);<br/>            }<br/>            return;<br/>        }<br/>    }<br/>}</pre>
<ol start="7">
<li>And finally, add the method to actually send the SMS:</li>
</ol>
<pre style="padding-left: 60px">public void send(View view) {<br/>    String phoneNumber = ((EditText)findViewById(R.id.editTextNumber)).getText().toString();<br/>    String msg = ((EditText)findViewById(R.id.editTextMsg)).getText().toString();<br/><br/>    if (phoneNumber==null || phoneNumber.length()==0 || msg==null || msg.length()==0 ) {<br/>        return;<br/>    }<br/><br/>    if (checkPermission(Manifest.permission.SEND_SMS)) {<br/>        SmsManager smsManager = SmsManager.getDefault();<br/>        smsManager.sendTextMessage(phoneNumber, null, msg, null, null);<br/>    } else {<br/>        Toast.makeText(MainActivity.this, "No Permission", Toast.LENGTH_SHORT).show();<br/>    }<br/>}</pre>
<ol start="8">
<li>You're ready to run the application on a device or emulator. (Use the emulator device number when sending to another emulator. The first emulator is 5554; the second is 5556, and it continues incrementing by two for each additional emulator.)</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The code for sending an SMS is only two lines, as shown here:</p>
<pre>SmsManager smsManager = SmsManager.getDefault(); 
smsManager.sendTextMessage(phoneNumber, null, msg, null, null); </pre>
<p>The <kbd>sendTextMessage()</kbd> method does the actual sending. Most of the code for this recipe is for checking and obtaining the required permissions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>As simple as it is to send SMS messages, we still have a few more options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Multipart messages</h1>
                
            
            
                
<p>Although it can vary depending on the carrier, 160 is typically the maximum characters allowed per text message. You could modify the preceding code to check whether the message exceeds 160 characters, and if so, you can call the SMSManager divideMessage() method. The method returns <kbd>ArrayList</kbd>, which you can send to <kbd>sendMultipartTextMessage()</kbd>. Here's an example:</p>
<pre>ArrayList&lt;String&gt; messages=smsManager.divideMessage(msg);<br/>smsManager.sendMultipartTextMessage(phoneNumber, null, messages, null, null);</pre>
<p>Note that messages sent with <kbd>sendMultipartTextMessage()</kbd> may not work correctly when using an emulator, so be sure to test on a real device.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Delivery status notification</h1>
                
            
            
                
<p>If you'd like to be notified of the status of the messages, there are two optional fields you can use. Here's the <kbd>sendTextMessage()</kbd> method as defined in the SMSManager documentation:</p>
<pre>sendTextMessage(String destinationAddress, String scAddress, String text, <br/>        PendingIntent sentIntent, PendingIntent deliveryIntent)</pre>
<p>You can include a pending Intent to be notified of the send status and/or delivery status. Upon receipt of your pending Intent, it will include a result code with either Activity. <kbd>RESULT_OK</kbd>, if it sent successfully, or an error code as defined in the SMSManager documentation (see the following links):</p>
<ul>
<li><kbd>RESULT_ERROR_GENERIC_FAILURE</kbd>: Generic failure cause</li>
<li><kbd>RESULT_ERROR_NO_SERVICE</kbd>: Failed because service is currently unavailable</li>
<li><kbd>RESULT_ERROR_NULL_PDU</kbd>: Failed because no PDU was provided</li>
<li><kbd>RESULT_ERROR_RADIO_OFF</kbd>: Failed because radio was explicitly turned off</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Short Message Service on Wikipedia at <a href="https://en.wikipedia.org/wiki/Short_Message_Service">https://en.wikipedia.org/wiki/Short_Message_Service</a></li>
<li>Developer Docs: SMSManager at <a href="https://developer.android.com/reference/android/telephony/SmsManager.html">https://developer.android.com/reference/android/telephony/SmsManager.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Receiving SMS messages</h1>
                
            
            
                
<p>This recipe will demonstrate how to set up a broadcast receiver to notify you of new SMS messages. It's useful to note that your app does not need to be running to receive the SMS Intent. Android will start your service to process the SMS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>ReceiveSMS</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We won't be using a layout in this demonstration as all the work will be in the Broadcast Receiver. We'll use Toasts to display incoming SMS messages. Open the Android Manifest and follow these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.RECEIVE_SMS" /&gt;</pre>
<ol start="2">
<li>Add the following declaration for the broadcast receiver to the application element:</li>
</ol>
<pre style="padding-left: 60px">&lt;receiver android:name=".SMSBroadcastReceiver"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/receiver&gt;</pre>
<ol start="3">
<li>Open <kbd>MainActivity.java</kbd> and add the following method:</li>
</ol>
<pre style="padding-left: 60px">private boolean checkPermission(String permission) {<br/>    int permissionCheck = ContextCompat.checkSelfPermission(this, permission);<br/>    return (permissionCheck == PackageManager.PERMISSION_GRANTED);<br/>}</pre>
<ol start="4">
<li>Modify the existing <kbd>onCreate()</kbd> callback to check the permission:</li>
</ol>
<pre style="padding-left: 60px">if (!checkPermission(Manifest.permission.RECEIVE_SMS)) {<br/>    ActivityCompat.requestPermissions(this, new String[]{Manifest.permission.RECEIVE_SMS}, 0);<br/>}</pre>
<ol start="5">
<li>Add a new Java class to the project, called <kbd>SMSBroadcastReceiver</kbd>, using the following code:</li>
</ol>
<pre style="padding-left: 60px">public class SMSBroadcastReceiver extends BroadcastReceiver {<br/>    final String SMS_RECEIVED = "android.provider.Telephony.SMS_RECEIVED";<br/><br/>    @Override<br/>    public void onReceive(Context context, Intent intent) {<br/>        if (SMS_RECEIVED.equals(intent.getAction())) {<br/>            Bundle bundle = intent.getExtras();<br/>            if (bundle != null) {<br/>                Object[] pdus = (Object[]) bundle.get("pdus");<br/>                String format = bundle.getString("format");<br/>                final SmsMessage[] messages = new SmsMessage[pdus.length];<br/>                for (int i = 0; i &lt; pdus.length; i++) {<br/>                    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) {<br/>                        messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i], format);<br/>                    } else {<br/>                        messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]);<br/>                    }<br/>                    Toast.makeText(context, messages[0].getMessageBody(), Toast.LENGTH_SHORT)<br/>                            .show();<br/>                }<br/>            }<br/>        }<br/>    }<br/>}</pre>
<p style="padding-left: 60px">6. You're ready to run the application on a device or emulator.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Just like in the previous recipe on sending SMS messages, we first need to check whether the app has permission. (On pre-Android 6.0 devices, the manifest declaration will automatically provide the permission, but for Marshmallow and later, we'll need to prompt the user as we do here.)</p>
<p>As you can see, the Broadcast receiver receives the notification of new SMS messages. We tell the system we want to receive the new SMS Received Broadcasts using this code in the Android Manifest:</p>
<pre>&lt;receiver android:name=".SMSBroadcastReceiver"&gt;<br/>    &lt;intent-filter&gt;<br/>        &lt;action android:name="android.provider.Telephony.SMS_RECEIVED"/&gt;<br/>    &lt;/intent-filter&gt;<br/>&lt;/receiver&gt;</pre>
<p>The notification comes in through the standard <kbd>onRecieve()</kbd> callback so we check the action using this code:</p>
<pre>if (SMS_RECEIVED.equals(intent.getAction())) {} </pre>
<p>This is probably the most complicated line of code in this recipe:</p>
<pre>messages[i] = SmsMessage.createFromPdu((byte[]) pdus[i]); </pre>
<p>Basically, it calls the SmsMessage library to create an SMSMessage object from the PDU. (The PDU, short for Protocol Data Unit, is the binary data format for SMS messages.) If you're not familiar with the PDU formation, you don't need to be. The SmsMessage library will take care of it for you and return an SMSMessage object.</p>
<p>If your app is not receiving SMS broadcast messages, an existing application may be blocking your app. You can try increasing the priority value in intent-filter as shown here, or disabling/uninstalling the other app(s):<br/>
<pre>&lt;intent-filter   android:priority="100"&gt;   
    &lt;action android:name=<br/>           "android.provider.Telephony.SMS_RECEIVED" /&gt;   
&lt;/intent-filter&gt;   </pre></p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>This recipe demonstrates displaying SMS messages as they are received, but what about reading existing messages?</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Reading existing SMS messages</h1>
                
            
            
                
<p>First, to read existing messages, you'll need the following permission:</p>
<pre>&lt;uses-permission android:name="android.permission.READ_SMS" /&gt; </pre>
<p>Here's an example of getting a cursor using the SMS content provider:</p>
<pre>Cursor cursor = getContentResolver().query(<br/>        Uri.parse("content://sms/"), null, null, null, null);<br/>while (cursor.moveToNext()) {<br/>    textView.append("From :" + cursor.getString(1) + " : " + cursor.getString(11)+"\n");<br/>}</pre>
<p>At the time of writing, the SMS content provider has over 30 columns. Here are the first 12, which are the most useful (remember, the column count starts at zero):</p>
<ol start="0">
<li><kbd>_id</kbd></li>
<li><kbd>thread_id</kbd></li>
<li><kbd>address</kbd></li>
<li><kbd>person</kbd></li>
<li><kbd>date</kbd></li>
<li><kbd>protocol</kbd></li>
<li><kbd>read</kbd></li>
<li><kbd>status</kbd></li>
<li><kbd>type</kbd></li>
<li><kbd>reply_path_present</kbd></li>
<li><kbd>subject</kbd></li>
<li><kbd>body</kbd></li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Developer Docs: <kbd>SmsManager</kbd> at <a href="https://developer.android.com/reference/android/telephony/SmsManager.html">https://developer.android.com/reference/android/telephony/SmsManager.html</a></li>
<li><strong>Protocol Data Unit</strong> (<strong>PDU</strong>) at <a href="https://en.wikipedia.org/wiki/Protocol_data_unit">https://en.wikipedia.org/wiki/Protocol_data_unit</a></li>
<li>Developer Docs: <kbd>Telephony.Sms.Intents</kbd> at <a href="https://developer.android.com/reference/android/provider/Telephony.Sms.Intents.html">https://developer.android.com/reference/android/provider/Telephony.Sms.Intents.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Displaying a web page in your application</h1>
                
            
            
                
<p>When you want to show a web page, you have two choices: call the default browser or display the content in your app. If you just want to call the default browser, use an Intent as follows:</p>
<pre>Uri uri = Uri.parse("https://www.packtpub.com/"); 
Intent intent = new Intent(Intent.ACTION_VIEW, uri); 
startActivity(intent); </pre>
<p>If you need to display the content in your own application, you can use <kbd>WebView</kbd>. This recipe will show how to display a web page in your application, as can be seen in this screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/bac4a050-ddd1-431b-adfa-0c824a1b451c.png" style="width:14.83em;height:29.83em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>WebView</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We're going to create the WebView through code so we won't be modifying the layout. We'll start by opening the Android Manifest and following these steps:</p>
<ol>
<li>Add the following permission:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;</pre>
<ol start="2">
<li>Modify the existing <kbd>onCreate()</kbd> to include the following code:</li>
</ol>
<pre style="padding-left: 60px">WebView webview = new WebView(this);<br/>setContentView(webview);<br/>webview.loadUrl("https://www.packtpub.com/");</pre>
<ol start="3">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We create a WebView to use as our layout and load our webpage with <kbd>loadUrl()</kbd>. The preceding code works, but, at this level, it is very basic and only displays the first page. If you click on any links, the default browser will handle the request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>What if you want full web browsing functionality so any link the user clicks on still loads in your <kbd>WebView</kbd>? Create <kbd>WebViewClient</kbd> as shown in this code:</p>
<pre>webview.setWebViewClient(new WebViewClient()); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Controlling page navigation</h1>
                
            
            
                
<p>If you want more control over the page navigation, you can create your own <kbd>WebViewClient</kbd> class. If you want to only allow links within your own website, override the <kbd>shouldOverrideUrlLoading()</kbd> callback as shown here:</p>
<pre>private class mWebViewClient extends WebViewClient {<br/>    @Override<br/>    public boolean shouldOverrideUrlLoading(WebView view, String url) {<br/>        if (Uri.parse(url).getHost().equals("www.packtpub.com")) {<br/>            return false;  //Don't override since it's the same host <br/>        } else {<br/>            return true; //Stop the navigation since it's a different <br/>            //site <br/>        }<br/>    }<br/>}</pre>
<p>Then, use the following code to set the client:</p>
<pre>webview.setWebViewClient(new mWebViewClient());</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">How to enable JavaScript</h1>
                
            
            
                
<p>There are many other WebView options we can customize through WebSetting. If you want to enable JavaScript, get <kbd>webSettings</kbd> from the WebView and call <kbd>setJavaScriptEnabled()</kbd>, as shown here:</p>
<pre>WebSettings webSettings = webview.getSettings(); 
webSettings.setJavaScriptEnabled(true); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Enable built-in zoom</h1>
                
            
            
                
<p>Another <kbd>webSettings</kbd> option is <kbd>setBuiltInZoomControls()</kbd>. Continuing from the preceding code, just add this:</p>
<pre>webSettings.setBuiltInZoomControls(true); </pre>
<p>Check the webSettings link in the next section for a large list of additional options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Developer Docs: <kbd>WebView</kbd> at <a href="https://developer.android.com/reference/android/webkit/WebView.html">https://developer.android.com/reference/android/webkit/WebView.html</a></li>
<li>Developer Docs: <kbd>webSettings</kbd> at <a href="https://developer.android.com/reference/android/webkit/WebSettings.html">https://developer.android.com/reference/android/webkit/WebSettings.html</a></li>
<li>Developer Docs: <kbd>android.webkit</kbd> at <a href="https://developer.android.com/reference/android/webkit/package-summary.html">https://developer.android.com/reference/android/webkit/package-summary.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Checking online status and connection type</h1>
                
            
            
                
<p>This is a simple recipe, but one that is very common and will probably be included in every internet application you build: checking online status. While checking online status, we can also check the connection type: <kbd>WIFI</kbd> or <kbd>MOBILE</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>isOnline</kbd>. Use the default Phone &amp; Tablet options and select Empty Activity in the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>First, we need to add the necessary permissions to access the network. Then, we'll create a simple layout with <kbd>Button</kbd> and <kbd>TextView</kbd>. To get started, open the Android Manifest and follow these steps:</p>
<ol>
<li>Add the following permissions:</li>
</ol>
<pre style="padding-left: 60px">&lt;uses-permission android:name="android.permission.INTERNET"/&gt;<br/>&lt;uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" /&gt;</pre>
<ol start="2">
<li>Open the <kbd>activity_main.xml</kbd> file and replace the existing layout with the following:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent" &gt;<br/>    &lt;TextView<br/>        android:id="@+id/textView"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="" /&gt;<br/>    &lt;Button<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Check"<br/>        android:layout_centerInParent="true"<br/>        android:onClick="getStatus"/&gt;<br/>&lt;/RelativeLayout&gt;</pre>
<ol start="3">
<li>Add this method to check the connection status:</li>
</ol>
<pre style="padding-left: 60px">private boolean isOnline() {<br/>    ConnectivityManager connectivityManager = (ConnectivityManager)<br/>                    getSystemService(Context.CONNECTIVITY_SERVICE);<br/>    NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();<br/>    return (networkInfo != null &amp;&amp; networkInfo.isConnected());<br/>}</pre>
<ol start="4">
<li>Add the following method to handle the button click:</li>
</ol>
<pre style="padding-left: 60px">public void getStatus(View view) {<br/>    TextView textView = findViewById(R.id.textView);<br/>    if (isOnline()) {<br/>        ConnectivityManager connectivityManager =<br/>                (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);<br/>        NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();<br/>        textView.setText(networkInfo.getTypeName());<br/>    } else {<br/>        textView.setText("Offline");<br/>    }<br/>}</pre>
<ol start="5">
<li>You're ready to run the application on a device or emulator.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We created the <kbd>isOnline()</kbd> method to make it easy to reuse this code.</p>
<p>To check the status, we get an instance of <kbd>ConnectivityManager</kbd> to read the <kbd>NetworkInfo</kbd> state. If it reports we are connected, we get the name of the active network by calling <kbd>getType()</kbd>, which returns one of the following constants:</p>
<ul>
<li><kbd>TYPE_MOBILE</kbd></li>
<li><kbd>TYPE_WIFI</kbd></li>
<li><kbd>TYPE_WIMAX</kbd></li>
<li><kbd>TYPE_ETHERNET</kbd></li>
<li><kbd>TYPE_BLUETOOTH</kbd></li>
</ul>
<p>Also, see the <kbd>ConnectivityManager</kbd> link later for additional constants. For display purposes, we call <kbd>getTypeName()</kbd>. We could call <kbd>getType()</kbd> to get a numeric constant instead.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>We can also set it up so our app will be notified when the network status changes.  </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Monitoring network state changes</h1>
                
            
            
                
<p>If your application needs to respond to changes in the network status, take a look at <kbd>CONNECTIVITY_ACTION</kbd> in <kbd>ConnectivityManager</kbd>.  There are two ways to set up the filters to be notified of connectivity change events:</p>
<ul>
<li>Through the Android Manifest</li>
<li>Through code</li>
</ul>
<p>Here's an example of how to include the action in the receiver's intent filter through the Android Manifest:</p>
<pre>&lt;receiver android:name=".MyBroadcastReceiver"&gt; 
    &lt;intent-filter&gt; 
        &lt;action android:name="android.net.conn.CONNECTIVITY_CHANGE" /&gt; 
    &lt;/intent-filter&gt; 
&lt;/receiver&gt; </pre>
<p>Be careful using the Android Manifest as it will notify your app every time the network state changes, even if your app isn't being used. This can cause unnecessary drain on the battery.   </p>
<p>Apps targeting Android 7.0 and later will no longer receive <kbd>CONNECTIVITY_CHANGE</kbd> when declared in the Manifest. (This is to prevent unnecessary battery drain). Instead, register the Intent Filter through code as shown next.</p>
<p>The better solution (and required for Android 7.0 and later) is to register your intent filter through code. Here is an example:</p>
<pre>registerReceiver(mReceiver, new IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION));</pre>
<p>Take a look at the recipe in the file downloads for an example of logging <kbd>CONNECTIVITY_CHANGE</kbd> events.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Developer Docs: <kbd>ConnectivityManager</kbd> at <a href="https://developer.android.com/reference/android/net/ConnectivityManager.html">https://developer.android.com/reference/android/net/ConnectivityManager.html</a></li>
<li>Developer Docs: <kbd>NetworkInfo</kbd> at <a href="https://developer.android.com/reference/android/net/NetworkInfo.html">https://developer.android.com/reference/android/net/NetworkInfo.html</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Phone number blocking API</h1>
                
            
            
                
<p>A new feature introduced in Android Nougat (API 24) is the ability to handle blocking phone numbers at the OS level. This provides a consistent experience for the user across multiple devices with the following:</p>
<ul>
<li>Blocked Numbers block both incoming calls and text messages</li>
<li>Blocked Numbers can be backed up using the Backup &amp; Restore feature</li>
<li>All apps on the device share the same Blocked Numbers list</li>
</ul>
<p>In this recipe, we will look at the code to add a number to block, remove the number, and how to check whether the number is already blocked.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>Create a new project in Android Studio and call it <kbd>BlockedCallList</kbd>. In the Target Android Devices dialog, select the Phone &amp; Tablet option and choose API 24: Android 7.0 Nougat (or higher) for the Minimum SDK. Select Empty Activity in the Add an Activity to Mobile dialog.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>We will start by creating a UI with an <kbd>EditText</kbd> to enter a phone number and three buttons: <kbd>Block</kbd>, <kbd>Unblock</kbd>, and <kbd>isBlocked</kbd>. To start, open <kbd>activity_main.xml</kbd> and follow these steps:</p>
<ol>
<li>Replace the existing layout with the following XML code:</li>
</ol>
<pre style="padding-left: 60px">&lt;?xml version="1.0" encoding="utf-8"?&gt;<br/>&lt;RelativeLayout<br/>    xmlns:android="http://schemas.android.com/apk/res/android"<br/>    xmlns:app="http://schemas.android.com/apk/res-auto"<br/>    xmlns:tools="http://schemas.android.com/tools"<br/>    android:layout_width="match_parent"<br/>    android:layout_height="match_parent"<br/>    tools:context=".MainActivity"&gt;<br/>    &lt;EditText<br/>        android:id="@+id/editTextNumber"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:inputType="phone"<br/>        android:ems="10"<br/>        android:layout_alignParentTop="true"<br/>        android:layout_centerHorizontal="true"<br/>        android:layout_marginTop="36dp" /&gt;<br/>    &lt;Button<br/>        android:id="@+id/buttonblock"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Block"<br/>        android:layout_above="@+id/buttonUnblock"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="onClickBlock"/&gt;<br/>    &lt;Button<br/>        android:id="@+id/buttonUnblock"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="Block"<br/>        android:layout_centerVertical="true"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="onClickUnblock"/&gt;<br/>    &lt;Button<br/>        android:id="@+id/buttonIsBlocked"<br/>        android:layout_width="wrap_content"<br/>        android:layout_height="wrap_content"<br/>        android:text="isBlocked"<br/>        android:layout_below="@+id/buttonUnblock"<br/>        android:layout_centerHorizontal="true"<br/>        android:onClick="onClickIsBlocked"/&gt;<br/>&lt;/RelativeLayout&gt;</pre>
<ol start="2">
<li>Open <kbd>MainActivity.java</kbd> and add the following code to the class declaration:</li>
</ol>
<pre style="padding-left: 60px">private EditText mEditTextNumber;</pre>
<ol start="3">
<li>Add the following line of code to the end of the <kbd>onCreate()</kbd> method:</li>
</ol>
<pre style="padding-left: 60px">mEditTextNumber=findViewById(R.id.editTextNumber);</pre>
<ol start="4">
<li>Add the three methods to handle the button clicks:</li>
</ol>
<pre style="padding-left: 60px">public void onClickBlock(View view) {<br/>    String number = mEditTextNumber.getText().toString();<br/>    if (number!=null &amp;&amp; number.length()&gt;0) {<br/>        blockNumber(number);<br/>    }<br/>}<br/>public void onClickUnblock(View view) {<br/>    String number = mEditTextNumber.getText().toString();<br/>    if (number!=null &amp;&amp; number.length()&gt;0) {<br/>        unblockNumber(number);<br/>    }<br/>}<br/>public void onClickIsBlocked(View view) {<br/>    String number = mEditTextNumber.getText().toString();<br/>    if (number!=null &amp;&amp; number.length()&gt;0) {<br/>        isBlocked(number);<br/>    }<br/>}</pre>
<ol start="5">
<li>Add the following function to block the number:</li>
</ol>
<pre style="padding-left: 60px">private void blockNumber(String number) {<br/>    if (BlockedNumberContract.canCurrentUserBlockNumbers(this)) {<br/>        ContentValues values = new ContentValues();<br/>        values.put(BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER, number);<br/>        getContentResolver().insert(BlockedNumberContract.BlockedNumbers.CONTENT_URI, values);<br/>    }<br/>}</pre>
<ol start="6">
<li>Add the following function to unblock the number:</li>
</ol>
<pre style="padding-left: 60px">private void unblockNumber(String number) {<br/>    if (BlockedNumberContract.canCurrentUserBlockNumbers(this)) {<br/>        ContentValues values = new ContentValues();<br/>        values.put(BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER, number);<br/>        Uri uri = getContentResolver()<br/>                .insert(BlockedNumberContract.BlockedNumbers.CONTENT_URI, values);<br/>        getContentResolver().delete(uri, null, null);<br/>    }<br/>}</pre>
<ol start="7">
<li>Add the following function to check whether the number is blocked:</li>
</ol>
<pre style="padding-left: 60px">public void isBlocked(String number) {<br/>    if (BlockedNumberContract.canCurrentUserBlockNumbers(this)) {<br/>        boolean blocked = BlockedNumberContract.isBlocked(this,number);<br/>        Toast.makeText(MainActivity.this, number + "blocked: " + blocked, <br/>                Toast.LENGTH_SHORT).show();<br/>    } else {<br/>        Toast.makeText(MainActivity.this, "User cannot perform this operation", <br/>                Toast.LENGTH_SHORT).show();<br/>    }<br/>}</pre>
<ol start="8">
<li>You're ready to run the application on a device or emulator running at least Android 7.0.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Before we call the <kbd>BlockedNumberContract</kbd> APIs, we check to make sure we have permission by calling <kbd>canCurrentUserBlockNumbers()</kbd>, as shown in this code:</p>
<pre>if (BlockedNumberContract.canCurrentUserBlockNumbers(this)) {</pre>
<p>If true, we make the actual API call.</p>
<p>Important: Only the following apps can read and write to the <kbd>BlockedNumber</kbd> provider: the default SMS application, the default phone app, and carrier apps. The user can choose their default SMS and Phone app.</p>
<p>Adding and deleting numbers from the <kbd>BlockedNumber</kbd> list uses the standard Service Provider format. </p>
<div><p>The Update method is not supported; use the <kbd>Add</kbd> and <kbd>Delete</kbd> methods instead.</p>
</div>
<p>To check whether a number is already in the block list, call the <kbd>isBlocked()</kbd> method, passing in the current context and the number to check, as we do in this code:</p>
<pre>boolean blocked = BlockedNumberContract.isBlocked(this,number);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>To get the list of all currently blocked numbers, use the following code to create a cursor with the list:</p>
<pre>Cursor cursor = getContentResolver().query(<br/>        BlockedNumberContract.BlockedNumbers.CONTENT_URI,<br/>        new String[]{BlockedNumberContract.BlockedNumbers.COLUMN_ID,<br/>                BlockedNumberContract.BlockedNumbers.COLUMN_ORIGINAL_NUMBER,<br/>                BlockedNumberContract.BlockedNumbers.COLUMN_E164_NUMBER},<br/>        null, null, null);</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>For more information, see the <kbd>BlockedNumberContract</kbd> reference documentation: <a href="https://developer.android.com/reference/android/provider/BlockedNumberContract">https://developer.android.com/reference/android/provider/BlockedNumberContract</a></p>


            

            
        
    </body></html>