<html><head></head><body><div><div><h1 id="_idParaDest-46"><a id="_idTextAnchor054"/>Chapter 3: Exploring the Key Principles of Compose</h1>
			<p>In the first chapter of this book, we built and run our first Jetpack Compose app. Then, in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, we explained the imperative nature of Android's traditional UI toolkit, illustrated some of its weaknesses, and saw how a declarative approach can overcome them.</p>
			<p>In this chapter, we build upon these foundations by examining a few key principles Jetpack Compose relies on. This knowledge is essential for writing well-behaving Compose apps. This chapter introduces these key principles. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Looking closer at composable functions</li>
				<li>Composing and recomposing the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>)</li>
				<li>Modifying the behavior of composable functions</li>
			</ul>
			<p>We will start by revisiting composable functions, the building blocks of a composable UI. This time, we will dig much deeper into their underlying ideas and concepts. By the end of the first main section, you will have established a thorough understanding of what composable functions are, how they are written, and how they are used.</p>
			<p>The following section focuses on creating and updating the UI. You will learn how Jetpack Compose achieves what other UI frameworks<a id="_idIndexMarker082"/> call repainting. This mechanism, which is called <strong class="bold">recomposition</strong> in Compose, takes place automatically whenever something relevant to the UI changes. To keep this process fluent, your composable functions must adhere to a few best practices. I will explain them to you in this section.</p>
			<p>We will close this chapter by expanding our knowledge of the concept of modifiers. We will take a close look at how modifier chains work and what you need to keep in mind to always get the intended results. You will also learn how to implement custom modifiers. They allow you to amend any composable function to look or behave in precisely the way you want them to.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor055"/>Technical requirements</h1>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information on how to install and set up Android Studio, as well as how to get the sample apps. If you want to try the <code>ShortColoredTextDemo()</code> and <code>ColoredTextDemo()</code> composables from the <em class="italic">Looking closer at composable functions</em> section, you can use the <code>Sandbox</code> app project in the top-level directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose</a>. Open <code>SandboxActivity</code> and copy the composable functions from <code>code_snippets.txt</code>, which will be located in the <code>/chapter_03</code> folder.<a id="_idTextAnchor056"/><a id="_idTextAnchor057"/></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor058"/>Looking closer at composable functions</h1>
			<p>The UI of a Compose app is built by writing and calling composable functions. We have already done both in the previous chapters, but my explanations regarding the structure of a composable, as well as its internals, have been quite basic – it's time to fix that.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor059"/>Building blocks of composable functions</h2>
			<p>A <code>@Composable</code>. All composables <em class="italic">must</em> be marked this way because the annotation informs the Compose compiler that the function converts data into UI elements.</p>
			<p>The signature of a Kotlin function<a id="_idIndexMarker084"/> consists of the following parts or building blocks:</p>
			<ul>
				<li>An optional visibility modifier (<code>private</code>, <code>protected</code>, <code>internal</code>, or <code>public</code>)</li>
				<li>The <code>fun</code> keyword</li>
				<li>A name</li>
				<li>A list of parameters (can be empty) or, optionally, a default value</li>
				<li>An optional return type</li>
				<li>A block<a id="_idIndexMarker085"/> of code</li>
			</ul>
			<p>Let's explore these parts in greater detail.</p>
			<p>The default visibility (if you omit the modifier) is <code>public</code>. This means that the (composable) function can be called from anywhere. If a function is meant to be reused (for example, a text styled to match your brand), it should be publicly available. On the other hand, if a function is tied to a particular <strong class="bold">context</strong> (the region of code, such as a class), it may make sense to restrict its access. There is an open debate on how rigid the visibility of functions should be restrained. In the end, you and your team need to agree on a point of view and stick to it. For the sake of simplicity, my examples are usually public.</p>
			<p>The name of a composable function uses the <em class="italic">PascalCase</em> notation: it starts with an uppercase letter, whereas the remaining characters are lowercase. If the name<a id="_idIndexMarker086"/> consists of more than one word, each word follows this rule. The name should be a noun (<code>Demo</code>), or a noun that has been prefixed with a descriptive adjective (<code>FancyDemo</code>). Unlike other (ordinary) Kotlin functions, it should <em class="italic">not</em> be a verb or a verb phrase (<code>getDataFromServer</code>). The <em class="italic">API Guidelines for Jetpack Compose</em> file, which is available at <a href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md">https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md</a>, details these naming conventions.</p>
			<p>All the data you want to pass to a composable function<a id="_idIndexMarker087"/> is provided through a comma-separated list, which is enclosed in parenthesis. If a composable does not require values, the list remains empty. Here's a composable function that can receive two parameters:</p>
			<pre>@Composable
fun ColoredTextDemo(
  text: String = "",
  color: Color = Color.Black
) {
  Text(
    text = text,
    style = TextStyle(color = color)
  )
}</pre>
			<p>In Kotlin, function parameters are defined as <code>name: type</code>. Parameters are separated by a comma. You can specify a default value by adding <code>= ...</code>. This is used if no value is provided for a particular parameter when the function is being invocated.</p>
			<p>The return type of a function is optional. In this case, the function returns <code>Unit</code>. <code>Unit</code> is a type with only one value: <code>Unit</code>. If, like in this example, it is omitted, the function body follows immediately after the list of arguments. Most composable functions you will be writing do not need to return anything, so do not need a return type. Situations that require it will be covered in the <em class="italic">Returning values</em> section.</p>
			<p>If the code of a function contains more than one statement or expression, it will be enclosed in curly braces. Kotlin<a id="_idIndexMarker088"/> offers a nice abbreviation for if just one expression needs to be executed – Jetpack Compose itself uses this quite frequently.</p>
			<pre>@Composable
fun ShortColoredTextDemo(
    text: String = "",
    color: Color = Color.Black
) = Text(
    text = text,
    style = TextStyle(color = color)
)</pre>
			<p>As you can see, the expression follows an equals sign. This means that <code>ShortColoredTextDemo()</code> returns whatever <code>Text()</code> is returning.</p>
			<p>Unlike Java, Kotlin<a id="_idIndexMarker089"/> does not know about the <code>void</code> keyword, so all the functions must return <em class="italic">something</em>. By omitting the return type, we implicitly tell Kotlin that the return type of a function is <code>kotlin.Unit</code>. This type has only one value: the <code>Unit</code> object. So, <code>Unit</code> corresponds to <code>void</code> in Java.</p>
			<p>Let's test this by printing the result of invoking a composable function:</p>
			<pre>class SandboxActivity : ComponentActivity() {
  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContent {
      println(ColoredTextDemo(
        text = "Hello Compose",
        color = Color.Blue
      ))
    }
  }
}</pre>
			<p>If you run the app, the following line will be printed:</p>
			<pre>I/System.out: kotlin.Unit</pre>
			<p>While this may not look too exciting, its implications are profound. Think of it: although the <code>ColoredTextDemo()</code> composable function returns nothing interesting, some text is shown on the screen. This happens because it invokes another composable, called <code>Text()</code>. So, whatever may be needed to show text must happen inside <code>Text()</code>, and it cannot have anything to do with the return value of a composable.</p>
			<p>In the previous chapter, I said that composable functions <em class="italic">emit</em> UI elements. I will explain what this means in the next section.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor060"/>Emitting UI elements</h2>
			<p>A Compose UI is created<a id="_idIndexMarker090"/> by nesting calls to composable functions, which can be provided by the Jetpack Compose libraries, code of other developers, or your app.</p>
			<p>Let's find out what happens once <code>ColoredTextDemo()</code> has called <code>androidx.compose.material.Text()</code>. To see the source code of (among others) composable functions in Android Studio, you can click on their names while holding down the <em class="italic">Ctrl</em> key (on a Mac, it's the <em class="italic">cmd</em> key).</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">I will only show you the important steps because otherwise, I would need to copy too much code. To get the best learning experience, please follow the call chain directly in your IDE.</p>
			<p><code>Text()</code> defines two variables, <code>textColor</code> and <code>mergedStyle</code>, and passes them to <code>androidx.compose.foundation.text.BasicText()</code>. Although you can use <code>BasicText()</code> in your code, you should choose <code>androidx.compose.material.Text()</code> if possible, because it consumes style information from a theme. Please refer to <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>, for more information about themes.</p>
			<p><code>BasicText()</code> immediately delegates to <code>CoreText()</code>, which belongs to the <code>androidx.compose.foundation.text</code> package too. It is an internal composable function, meaning you can't use it in your apps.</p>
			<p><code>CoreText()</code> initializes and remembers quite a few variables. There is no need to explain them all here, but the most important piece is the invocation of another composable function: <code>Layout()</code>.</p>
			<p><code>Layout()</code> belongs to the <code>androidx.compose.ui.layout</code> package. It is the core composable function for the layout, with its purpose being to size and position children. <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>, covers this in great detail. Right now, we still need to find out what <em class="italic">emitting UI elements</em> means. So, let's see what <code>Layout()</code> does: </p>
			<div><div><img src="img/B17505_03_1.jpg" alt="Figure 3.1 – Source code of Layout()&#13;&#10;" width="767" height="505"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Source code of Layout()</p>
			<p><code>Layout()</code> invokes <code>ReusableComposeNode()</code>, which belongs to the <code>androidx.compose.runtime</code> package. This composable function <em class="italic">emits</em> a so-called <code>factory</code> argument. The <code>update</code> and <code>skippableUpdate</code> parameters receive code that performs<a id="_idIndexMarker092"/> updates on the node, with the latter one handling modifiers (we will be taking a closer look at them at the end of this chapter). Finally, <code>content</code> contains composable functions that become the children of the node.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">When we speak of composable functions <em class="italic">emitting</em> UI elements, we mean that <strong class="bold">nodes</strong> are<a id="_idIndexMarker093"/> added to data structures that are internal to Jetpack Compose. This will eventually lead to UI elements being visible.</p>
			<p>To complete<a id="_idIndexMarker094"/> the call chain, let's briefly look at <code>ReusableComposeNode()</code>:</p>
			<div><div><img src="img/B17505_03_2.jpg" alt="Figure 3.2 – Source code of ReusableComposeNode()&#13;&#10;" width="824" height="607"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Source code of ReusableComposeNode()</p>
			<p><code>currentComposer</code> is a top-level variable inside <code>androidx.compose.runtime.Composables.kt</code>. Its type is <code>Composer</code>, which is an interface. <code>Composer</code> is targeted by the Jetpack Compose Kotlin compiler plugin and used by code generation helpers; your code should not call it directly. <code>ReusableComposeNode</code> determines if a new node should be created or whether an existing one should be reused. It then performs updates and finally emits the content to the node by invoking <code>content()</code>.</p>
			<p>Based on what you know<a id="_idIndexMarker095"/> by now, let me elaborate a little more on nodes. <code>Layout()</code> passes <code>ComposeUiNode.Constructor</code> to <code>ReusableComposeNode</code> as the <code>factory</code> argument, which is used to create a node (<code>currentComposer.createNode(factory)</code>). So, the features of a node are defined by the <code>ComposeUiNode</code> interface:</p>
			<div><div><img src="img/B17505_03_3.jpg" alt="Figure 3.3 – Source code of ComposeUiNode&#13;&#10;" width="919" height="534"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Source code of ComposeUiNode</p>
			<p>A node has four<a id="_idIndexMarker096"/> properties, as defined by the following classes or interfaces: </p>
			<ul>
				<li><code>MeasurePolicy</code></li>
				<li><code>LayoutDirection</code></li>
				<li><code>Density</code></li>
				<li><code>Modifier</code> </li>
			</ul>
			<p>In essence, a node is an element in a Compose hierarchy. You will not be dealing with them in your code because nodes are part of the inner workings of Jetpack Compose that are not exposed to apps. However, you will see <code>MeasurePolicy</code>, <code>LayoutDirection</code>, <code>Density</code>, and <code>Modifier</code> throughout this book. They represent important data structures and concepts that are relevant to apps.</p>
			<p>This concludes<a id="_idIndexMarker097"/> our investigation of how UI elements are emitted (nodes are added to data structures that are internal to Jetpack Compose). In the next section, we will look at composable functions that return values.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor061"/>Returning values</h2>
			<p>Most of your composable functions<a id="_idIndexMarker098"/> will not need to return something, so they will not specify a return type. This is because the main purpose of a composable is to compose the UI. As you saw in the previous section, this is done by emitting UI elements or element hierarchies. But when do we need to return something different than <code>Unit</code>?</p>
			<p>Some of my examples invoke <code>remember {}</code> to retain state for future use and <code>stringResource()</code> to access strings that are stored in the <code>strings.xml</code> file. To be able to perform their tasks, both must be composable functions.</p>
			<p>Let's look at <code>stringResource()</code> to see why. Remember that you can press Ctrl + click on a name to see its source code. The function is pretty short; it does just two things:</p>
			<pre>val resources = resources()
return resources.getString(id)</pre>
			<p><code>resources()</code> is a composable too. It returns <code>LocalContext.current.resources</code>. <code>LocalContext</code> is a top-level variable in <code>AndroidCompositionLocals.android.kt</code> that belongs to the  <code>androidx.compose.ui.platform</code> package. It returns an instance of <code>StaticProvidableCompositionLocal</code>, which holds <code>android.content.Context</code>. This object provides access to resources.</p>
			<p>Even though the returned data has nothing to do with Jetpack Compose, the code that obtains it must conform to Jetpack Compose mechanics because, in the end, it will be called from a composable<a id="_idIndexMarker099"/> function. The important thing to remember is that if you need to return something that is part of the composition and recomposition mechanic, you must make your function composable by annotating it with <code>@Composable</code>. Also, such functions do not follow the naming conventions for composable functions but follow a <em class="italic">camelCase</em> style (they begin with a small letter, with the subsequent word starting in uppercase) and consist of verb phrases (<code>rememberScrollState</code>).</p>
			<p>In the next section, we will return to composing UIs at the app level. You will learn more about the terms <strong class="bold">composition</strong> and <strong class="bold">recomposition</strong>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor062"/>Composing and recomposing the UI</h1>
			<p>Unlike imperative UI frameworks, Jetpack Compose does not depend on the developer proactively modifying<a id="_idIndexMarker100"/> a component tree when changes in the app data require<a id="_idIndexMarker101"/> changes to be made to the UI. Instead, Jetpack Compose detects such changes on its own and updates only the affected parts.</p>
			<p>As you know by now, a Compose UI is declared <em class="italic">based on</em> the current app data. In my previous examples, you have seen quite a few conditional expressions (such as <code>if</code> or <code>when</code>) that determine which composable function is called or which parameters it receives. So, we are describing the <em class="italic">complete</em> UI in our code. The branch that will be executed depends on the app data (state) during runtime. The Web framework that React<a id="_idIndexMarker102"/> has a similar concept called Virtual DOM. But doesn't this contradict with me saying <em class="italic">Compose detects such changes on its own and updates only the affected parts</em>?</p>
			<p>Conceptually, Jetpack Compose regenerates the entire UI when changes need to be applied. This, of course, would waste time, battery, and processing power. And it might be noticeable by the user as screen flickering. Therefore, the framework puts a lot of effort into making sure only those parts of the UI element tree requiring an update are regenerated.</p>
			<p>You saw some of these efforts in the previous section, where I briefly mentioned <code>update</code> and <code>skippableUpdate</code>. To ensure<a id="_idIndexMarker103"/> fast and reliable <code>ColorPickerDemo</code>:</p>
			<div><div><img src="img/B17505_03_4.jpg" alt="Figure 3.4 – The ColorPickerDemo app&#13;&#10;" width="1078" height="499"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The ColorPickerDemo app</p>
			<p>The app aims to set a color by specifying its <strong class="bold">red, green, and blue</strong> (<strong class="bold">RGB</strong>) portions. This color is used as the background color of a text (which displays the value of the color as a hexadecimal string). The foreground color is complementary to the selected one.</p>
			<p>In the next few sections, we look at its code. You will learn how sliders communicate changes in their values.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor063"/>Sharing state among composable functions</h2>
			<p>Sometimes, you may want<a id="_idIndexMarker106"/> to use a state in more than<a id="_idIndexMarker107"/> one composable function. For example, you may wish to use the color portion that's been set by one slider to create the<a id="_idIndexMarker108"/> full color, which, in turn, becomes the background<a id="_idIndexMarker109"/> color of a text. So, how can you share state? Let's start by looking at <code>ColorPicker()</code> – it groups three sliders vertically in a <code>Column()</code>:</p>
			<pre>@Composable
fun ColorPicker(color: MutableState&lt;Color&gt;) {
  val red = color.value.red
  val green = color.value.green
  val blue = color.value.blue
  Column {
    Slider(
      value = red,
      onValueChange = { color.value = Color(it, green, 
                                            blue) 
})
    Slide<a id="_idTextAnchor064"/>r(
      value = green,
      onValueChange = { color.value = Color(red, it, blue) })
    Slider(
      value = blue,
      onValueChange = { color.value = Color(red, green, it) })
  }
}</pre>
			<p>The composable receives one parameter: <code>MutableState&lt;Color&gt;</code>. The <code>value</code> property of <code>color</code> contains an instance of <code>androidx.compose.ui.graphics.Color</code>. Its <code>red</code>, <code>green</code>, and <code>blue</code> properties return a <code>Float</code> based on the so-called <code>ColorSpaces.Srgb</code>.</p>
			<p>My code does not set<a id="_idIndexMarker111"/> a particular color space, so it defaults to <code>ColorSpaces.Srgb</code>. This causes the value being returned to be between <code>0F</code> and <code>1F</code>. The first three<a id="_idIndexMarker112"/> lines assign the red, green, and blue portions of the color to local variables named <code>red</code>, <code>green</code>, and <code>blue</code>. They are used for the <code>Slider()</code> functions; let's see how.</p>
			<p>Each slider in my example receives two parameters: <code>value</code> and <code>onValueChange</code>. The first specifies the value that the slider will display. It must be between <code>0F</code> and <code>1F</code> (which fits nicely with <code>red</code>, <code>green</code>, and <code>blue</code>). If needed, you can supply an alternative range through the optional <code>valueRange</code> parameter. <code>onValueChange</code> is invoked when the user drags the slider handle or clicks on the thin line underneath. The code of the three lambda expressions is quite similar: a new <code>Color</code> object is created and assigned to <code>color.value</code>. Color portions that are being controlled by other sliders are taken from the corresponding local variables. They have not been changed. The new color portion of the current slider can be obtained from <code>it</code> because it is the new slider value, which is passed to <code>onValueChange</code>.</p>
			<p>By now, you may be wondering why <code>ColorPicker()</code> receives the color wrapped inside a <code>MutableState&lt;Color&gt;</code>. Wouldn't it suffice to pass it directly, using <code>color: Color</code>? As shown in <em class="italic">Figure 3.4</em>, the app shows the selected color as a text with complementary background and foreground colors. But <code>ColorPicker()</code> does not emit text. This happens somewhere else (as you will see shortly, inside a <code>Column()</code>). To show the correct color, the text must receive it too. As the color change takes place inside <code>ColorPicker()</code>, we must inform the caller about it. An ordinary <code>Color</code> instance being passed as a parameter can't do that because Kotlin function parameters are immutable.</p>
			<p>We can achieve changeability using global properties. But this is not recommended for Jetpack Compose. Composables should not use global variables at all. It is a best practice to pass all the data that influences the look or behavior of a composable function as parameters. If that data is modified inside the composable, you should use <code>MutableState</code>. Moving state<a id="_idIndexMarker113"/> to a composable's caller by receiving a state is called <code>MutableState</code> and applying changes inside a composable is to pass the change logic<a id="_idIndexMarker114"/> as a lambda expression. In my example, <code>onValueChange</code> would just provide<a id="_idIndexMarker115"/> the new slider value to the lambda expression.</p>
			<p class="callout-heading">Important</p>
			<p class="callout">Try to make your composables side effect-free. Having no side effects means calling a function repeatedly with the same set of arguments that will always produce the same result. Besides getting all the relevant data from the caller, being free of side effects also requires not relying on global properties or calling functions that return unpredictable values. There are a few scenarios where you want side effects. I will cover these in <a href="B17505_07_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Tips, Tricks, and Best Practices</em>.</p>
			<p>Now, let's learn how the color is passed to the text:</p>
			<pre>Column(
  modifier = Modifier.width(min(400.dp, maxWidth)),
  horizontalAlignment = Ali<a id="_idTextAnchor065"/>gn<a id="_idTextAnchor066"/>ment.CenterHorizontally
) {
  val color = remember { mutableStateOf(Color.Magenta) }
  ColorPicker(color)
  Text(
    modifier = Modifier
      .fillMaxWidth()
      .background(color.value),
    text =
    "#${color.value.toArgb().toUInt().toString(16)}",
    textAlign = TextAlign.Center,
    style = MaterialTheme.typography.h4.merge(
      TextStyle(
        color = color.value.complementary()
      )
    )
  )
}</pre>
			<p><code>ColorPicker()</code> and <code>Text()</code> are laid out vertically (being centered horizontally) inside a <code>Column()</code>. The width<a id="_idIndexMarker116"/> of the column is either <code>400</code> density-independent <a id="_idIndexMarker117"/>pixels or <code>maxWidth</code>, depending on which value is smaller. <code>maxWidth</code> is defined by the predefined <code>BoxWithConstraints()</code> composable (you will learn more about it in the <em class="italic">Controlling size</em> section). The color for both <code>ColorPicker()</code> and <code>Text()</code> is defined like this:</p>
			<pre>val color = remember { mutableStateOf(Color.Magenta) }</pre>
			<p>When <code>Column()</code> is composed for the first time, <code>mutableStateOf(Color.Magenta)</code> is executed. This creates <code>color</code>.</p>
			<p>But what does <code>remember</code> mean? Any subsequent composition, which is called <code>color</code> receiving<a id="_idIndexMarker119"/> the value created by <code>mutableStateOf</code> – that is, a reference to a <code>MutableState&lt;Color&gt;</code> (state hoisting). The lambda expression that's passed to <code>remember</code> is called a <strong class="bold">calculation</strong>. It will only be<a id="_idIndexMarker120"/> evaluated once. Recompositions always return the same value.</p>
			<p>If the reference remains the same, how can the color be changed? The actual color is accessed through the <code>value</code> property. You saw this in the code of <code>ColorPicker()</code>. <code>Text()</code> does not modify the color – it only works with it. Therefore, we pass <code>color.value</code> (which is the color), not the mutable state (<code>color</code>), to some of its parameters, such as <code>background</code>. Note that this is a modifier. You will learn more about them in the <em class="italic">Modifying behavior</em> section. It sets the background color of a UI element that's emitted by a composable function.</p>
			<p>Also, have you noticed the call of <code>complementary()</code> inside <code>TextStyle()</code>? Here's what it does:</p>
			<pre>fun Color.complementary() = Color(
  red = 1F - red,
  green = 1F - green,
  blue = 1F - blue
)</pre>
			<p><code>complementary()</code> is an extension function of <code>Color</code>. It computes the complementary color to the one<a id="_idIndexMarker121"/> it receives. This is done to make the text (the hexadecimal RGB value<a id="_idIndexMarker122"/> of the color that was selected using the three sliders) readable, regardless of the currently selected color (which is used as the background of the text).</p>
			<p>In this section, I talked about some very important Jetpack Compose concepts. Let's recap what we've learned so far:</p>
			<ul>
				<li>A compose UI is defined by nesting calls to composable functions</li>
				<li>Composable functions emit UI elements or UI element hierarchies</li>
				<li>Building<a id="_idIndexMarker123"/> the UI for the first time is called <strong class="bold">composition</strong></li>
				<li>Rebuilding the UI upon<a id="_idIndexMarker124"/> changes being made to app data is called <strong class="bold">recomposition</strong></li>
				<li>Recomposition happens automatically<p class="callout-heading">Important</p><p class="callout">There is no way for your app to predict when or how often recomposition<a id="_idIndexMarker125"/> will take place. If animations are involved, this may happen each frame. Therefore, it is of utmost importance to make your composables as fast as possible. You may never do time-consuming calculations, load or save data, or access the network. Any such code must be executed outside of composable functions. They only receive ready data. Also, please note that the order of recomposition is unspecified. This means that the first child of, say, a <code>Column()</code>, might be recomposed later than a sibling that appears after it in the source code. Recomposition can occur in parallel and it may be skipped. Therefore, never rely on a particular order of recomposition, and never compute something in a composable that is needed somewhere else.</p></li>
			</ul>
			<p>In the next section, we will finish our walkthrough of the <code>ColorPickerDemo</code> app. I will show you how to specify and limit the dimensions of composable functions.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor067"/>Controlling size</h2>
			<p>Most of my examples<a id="_idIndexMarker126"/> contain code such as <code>fillMaxSize()</code> or <code>fillMaxWidth()</code>. Both modifiers control the size of a composable. <code>fillMaxSize()</code> uses all the available horizontal and vertical space, while <code>fillMaxWidth()</code> maximizes only the horizontal expansion.</p>
			<p>However, <code>fillMaxWidth()</code> may not be the right choice for sliders. In my opinion, large sliders are awkward to use due to the distance you would need to drag their handles to reach the minimum or maximum value. So, the question is, how can we limit its width? The most straightforward solution is to use the <code>width()</code> modifier. It sets the preferred width of a composable to a particular size. I want sliders to be 400 density-independent pixels wide at most. If the screen is smaller, its width should be used instead. Here's how you achieve this:</p>
			<pre>modifier = Modifier.width(min(400.dp, maxWidth)),</pre>
			<p>The modifier belongs to the <code>Column()</code> property that contains both <code>ColorPicker()</code> and <code>Text()</code>.</p>
			<p><code>maxWidth</code> is provided by the <code>BoxWithConstraints()</code> composable:</p>
			<pre>BoxWithConstraints(
  contentAlignment = Alignment.Center,
  modifier = Modifier.fillMaxSize()
) {
  Column ...
}</pre>
			<p>Its content receives<a id="_idIndexMarker127"/> an instance of a <code>BoxWithConstraintsScope</code> scope, which provides access to <code>constraints</code>, <code>minWidth</code>, <code>minHeight</code>, <code>maxWidth</code>, and <code>maxHeight</code>. <code>BoxWithConstraints()</code> defines its content according to the available space, based on incoming constraints. You will learn more about this in <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>.</p>
			<p>This concludes our walkthrough of the <code>ColorPickerDemo</code> app. In the next section, we take a closer look at how a composable hierarchy is displayed in an <code>Activity</code>.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor068"/>Displaying a composable hierarchy inside an Activity</h2>
			<p>In the previous section, we built<a id="_idIndexMarker128"/> a UI element hierarchy consisting of three sliders<a id="_idIndexMarker129"/> and some text. We embedded it in an <code>Activity</code> using <code>setContent</code>, an extension function of <code>androidx.activity.ComponentActivity</code>. This implies that you cannot invoke <code>setContent</code> on <em class="italic">any</em> activity, but only ones that extend <code>ComponentActivty</code>. This is the case for <code>androidx.appcompat.app.AppCompatActivity</code>.</p>
			<p>However, this class inherits quite a lot of functionality that is relevant for the old View-based world, such as support for toolbars and the options menu. Jetpack Compose handles these differently. You will learn more about this in <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>. Therefore, you should avoid using <code>AppCompatActivity</code>, and instead extend <code>ComponentActivity</code> if possible. For combining View-based and Compose UIs, please refer to <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>Let's return to <code>setContent</code>. It expects two parameters:</p>
			<ul>
				<li><code>parent</code>, an optional <code>CompositionContext</code></li>
				<li><code>content</code>, a composable function for declaring the UI</li>
			</ul>
			<p>You will likely omit <code>parent</code> most of the time. <code>CompositionContext</code> is an abstract class that belongs to the <code>androidx.compose.runtime</code> package. It is used to logically connect<a id="_idIndexMarker130"/> two compositions. This refers<a id="_idIndexMarker131"/> to the inner workings of Jetpack Compose that you do not need to worry about in your app code. Yet, to get an idea of what this means, let's look at the source code of <code>setContent</code>:</p>
			<div><div><img src="img/B17505_03_5.jpg" alt="Figure 3.5 – The source code of setContent&#13;&#10;" width="1059" height="577"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The source code of setContent</p>
			<p>First, <code>findViewById()</code> is used to find out if the activity already contains content that is an instance of <code>androidx.compose.ui.platform.ComposeView</code>. If so, the <code>setParentCompositionContext()</code> and <code>setContent()</code> methods of this view will be invoked.</p>
			<p>Let's look at <code>setParentCompositionContext()</code> first. It belongs to <code>AbstractComposeView</code>, the immediate parent of <code>ComposeView</code>. It sets a <code>CompositionContext</code> that should be the parent of the view's composition. If that context is <code>null</code>, it will be determined automatically: <code>AbstractComposeView</code> contains a private function called <code>ensureCompositionCreated()</code>. It invokes another implementation of <code>setContent</code> (an internal extension function of <code>ViewGroup</code> that's defined in <code>Wrapper.android.kt</code>) and passes the result of a call to <code>resolveParentCompositionContext()</code> as a <code>parent</code>.</p>
			<p>Now, let's return to the version of <code>setContent()</code> that's shown in the preceding screenshot. Once <code>setParentCompositionContext()</code> has been called, it invokes yet another version of <code>setContent()</code>. This implementation belongs to <code>ComposeView</code>. It sets the content of the view.</p>
			<p>If <code>findViewById()</code> does not return a <code>ComposeView</code>, a new instance is created and passed to <code>setContentView</code>, after <code>setParentCompositionContext()</code> and <code>setContent()</code> have been invoked.</p>
			<p>In this section, we continued<a id="_idIndexMarker132"/> looking at some of the inner<a id="_idIndexMarker133"/> workings of Jetpack Compose. You now know that <code>ComposeView</code> is the missing link to the old-fashioned View-based world. We will revisit this class in <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>In the next section, we will return modifiers; you will learn how they work under the hood and how you can write your own.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor069"/>Modifying the behavior of composable functions</h1>
			<p>Unlike components<a id="_idIndexMarker134"/> in traditional imperative UI frameworks, composable functions do not share a basic set of properties. They also do not automatically (in the sense of inheriting) reuse functionality. This must be done explicitly by calling other composables. Their visual appearance and behavior can be controlled through parameters, modifiers, or both. In a way, modifiers pick up the idea of properties in a component but enhance it – unlike properties of components, modifiers can be used completely at the discretion of the developer.</p>
			<p>You have already seen quite a few modifiers in my examples, such as the following:</p>
			<ul>
				<li><code>width()</code></li>
				<li><code>fillMaxWidth()</code></li>
				<li><code>fillMaxSize()</code> </li>
			</ul>
			<p>These control the width and size of the corresponding UI element; <code>background()</code> can set a background color and shape, while <code>clickable {}</code> allows the user to interact with the composable function<a id="_idIndexMarker135"/> by clicking on the UI element. Jetpack Compose provides an extensive list of modifiers, so it may take some time to make yourself familiar with most of them. Conceptually, these modifiers can be assigned to one of several categories, such as <em class="italic">Actions</em> (<code>draggable()</code>), <em class="italic">Alignment</em> (<code>alignByBaseline()</code>), or <em class="italic">Drawing</em> (<code>paint()</code>). You can find a list of modifiers<a id="_idIndexMarker136"/> grouped by category at <a href="https://developer.android.com/jetpack/compose/modifiers-list">https://developer.android.com/jetpack/compose/modifiers-list</a>.</p>
			<p>To further familiarize yourself with modifiers, let's look at the <code>ModifierDemo</code> example. It contains several composable functions. The following<a id="_idTextAnchor070"/><a id="_idTextAnchor071"/> screenshot shows the app running <code>OrderDemo()</code>:</p>
			<div><div><img src="img/B17505_03_6.jpg" alt="Figure 3.6 – The ModifierDemo app&#13;&#10;" width="1650" height="764"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The ModifierDemo app</p>
			<p>The composable produces a gap of 32 density-independent<a id="_idIndexMarker137"/> pixels on all its sides, followed by a 2 density-independent pixels wide blue border. The inner rectangle is painted in light gray.</p>
			<p>Here's what the code looks like:</p>
			<pre>@Composable
fun OrderDemo() {
  var color by remember { mutableStateOf(Color.Blue) }
  Box(
    modifier = Modifier
      .fillMaxSize()
      .padding(32.dp)
      .border(BorderStroke(width = 2.dp, color = color))
      .background(Color.LightGray)
      .clickable {
        color = if (color == Color.Blue)
          Color.Red
        else
          Color.Blue
      }
  )
}</pre>
			<p><code>Box()</code> is clickable – doing so changes the border color from blue to red and back. If you click inside the gaps, nothing will happen. If, however, you move<code>.clickable { }</code> before <code>.padding(32.dp)</code>, clicks work inside the gaps too. This is intentional. Here's what happens: you define a modifier chain by combining several modifiers with <code>.</code>. In doing so, you specify the order in which the modifiers are used. The location of a modifier in the chain determines<a id="_idIndexMarker138"/> when it is executed. As <code>clickable {}</code> only reacts to clicks inside the bounds of a composable, the padding is not considered for clicks when it occurs before <code>clickable {}</code>.</p>
			<p>In the next section, I will show you how Jetpack Compose handles modifiers and modifier chains internally.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor072"/>Understanding how modifiers work</h2>
			<p>Composable functions that accept modifiers should receive them via the <code>modifier</code> parameter and assign it a default value of <code>Modifier</code>. <code>modifier</code> should be the first optional parameter and thus<a id="_idIndexMarker139"/> appear after all the required ones, except for trailing lambda parameters.</p>
			<p>Let's see how a composable can receive a <code>modifier</code> parameter:</p>
			<pre>@Composable
fun TextWithYellowBackground(
  text: String,
  modifier: Modifier = Modifier
) {
  Text(
    text = text,
    modifier = modifier.background(Color.Yellow)
  )
}</pre>
			<p>This way, the composable can receive a modifier chain from the caller. If none are provided, <code>Modifier</code> acts as a new, empty chain. In both cases, the composable can add additional modifiers, such as <code>background()</code> in the previous code snippet.</p>
			<p>If a composable function<a id="_idIndexMarker140"/> accepts a modifier that will be applied to a specific part or child of its corresponding UI element, the name of this part or child should be used as a prefix, such as <code>titleModifier</code>. Such modifiers follow the rules I mentioned previously. They should be grouped<a id="_idIndexMarker141"/> and appear after the parent's modifier. Please refer to <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier">https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier</a> for additional information regarding the definition of modifier parameters.</p>
			<p>Now that you know how to define a <code>modifier</code> parameter in a composable function, let's focus a little more on the idea of chaining. <code>Modifier</code> is both an interface and a companion object. The interface belongs to the <code>androidx.compose.ui</code> package. It defines several functions, such as <code>foldIn()</code> and <code>foldOut()</code>. You won't need them, though. The important one is <code>then()</code>. It concatenates two modifiers. As you will see shortly, you need to invoke it in your modifiers. The <code>Element</code> interface extends <code>Modifier</code>. It defines a single element contained within a <code>Modifier</code> chain. Finally, the <code>Modifier</code> companion object is the empty, default modifier, which contains no elements.</p>
			<p class="callout-heading">To Summarize</p>
			<p class="callout">A modifier is an ordered, immutable collection of modifier elements.</p>
			<p>Next, let's see how the <code>background()</code> modifier<a id="_idIndexMarker142"/> is implemented:</p>
			<div><div><img src="img/B17505_03_7.jpg" alt="Figure 3.7 – Source code of the background() modifier&#13;&#10;" width="733" height="527"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Source code of the background() modifier</p>
			<p><code>background()</code> is an extension function of <code>Modifier</code>. It receives a <code>Modifier</code> instance. It invokes <code>then()</code> and returns the result (a concatenated modifier). <code>then()</code> expects just one parameter: the <em class="italic">other</em> modifier that should be concatenated with the current one. In the case of <code>background()</code>, <em class="italic">other</em> is an instance of <code>Background</code>. This class extends <code>InspectorValueInfo</code> and implements the <code>DrawModifier</code> interface, which, in turn, extends <code>Modifier.Element</code>. As <code>InspectorValueInfo</code> is primarily used for debugging purposes, I will not elaborate on it any further. <code>DrawModifier</code>, on the other hand, is very interesting. Implementations can draw into the space of a UI element. We will make use of this in the final section.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor073"/>Implementing custom modifiers</h2>
			<p>Although Jetpack Compose contains<a id="_idIndexMarker143"/> an extensive list of modifiers, you may want to implement your own. Let me show you how to do this. My example, <code>drawYellowCross()</code>, draws two thick yellow lines behind the content, which is some <code>Text()</code> here:</p>
			<div><div><img src="img/B17505_03_8.jpg" alt="Figure 3.8 – A custom modifier&#13;&#10;" width="1329" height="615"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – A custom modifier</p>
			<p>The modifier is invoked like this:</p>
			<pre>Text(
  text = "Hello Compose",
  modifier = Modifier
    .fillMaxSize()
    <strong class="bold">.drawYellowCross()</strong>,
  textAlign = TextAlign.Center,
  style = MaterialTheme.typography.h1
)</pre>
			<p>As you can see, the modifier integrates<a id="_idIndexMarker144"/> nicely into an existing modifier chain. Now, let's look at the source code:</p>
			<pre>fun Modifier.drawYellowCross() = then(
  object : DrawModifier {
    override fun ContentDrawScope.draw() {
      drawLine(
        color = Color.Yellow,
        start = Offset(0F, 0F),
        end = Offset(size.width - 1, size.height - 1),
        strokeWidth = 10F
      )
      drawLine(
        color = Color.Yellow,
        start = Offset(0F, size.height - 1),
        end = Offset(size.width - 1, 0F),
        strokeWidth = 10F
      )
      drawContent()
    }
  }
)</pre>
			<p><code>drawYellowCross()</code> is an extension function of <code>Modifier</code>. This means we can invoke <code>then()</code> and simply return the result. <code>then()</code> receives an instance of <code>DrawModifier</code>. After that, we need to implement only one function, called <code>draw()</code>, which is an extension function of <code>ContentDrawScope</code>. This interface defines one function (<code>drawContent()</code>) and extends <code>DrawScope</code>; this way, we gain access to quite a few drawing primitives, such as <code>drawLine()</code>, <code>drawRect()</code>, and <code>drawImage()</code>. <code>drawContent()</code> draws the UI element, so depending on when it is invoked, the element appears in front of, or behind, the other drawing primitives. In my example, it is the last instruction, so the UI element (for example, <code>Text()</code>) is the topmost one.</p>
			<p>Jetpack Compose<a id="_idIndexMarker145"/> also includes a modifier called <code>drawBehind {}</code>. It receives a lambda expression that can contain drawing primitives, just like in my example. To learn even more about the internals of Jetpack Compose, you may want to take a look at its source code. To see it, just click on <code>drawBehind()</code> in your code while pressing the <em class="italic">Ctrl</em> key.</p>
			<p>This concludes my explanations of modifiers. As you have seen, they are a very elegant way to control both the visual appearance and behavior of composable functions.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor074"/>Summary</h1>
			<p>This chapter introduced you to the key principles of Jetpack Compose. We closely looked at the underlying ideas and concepts of composable functions, and you now know how they are written and used. We also focused on how to create and update the UI, as well as how Jetpack Compose achieves what other frameworks call repainting or updating the screen. When relevant app data changes, the UI changes, or so-called recomposition takes place automatically, this is one of the advantages over the traditional View-based approach, where the developer must imperatively change the component tree.</p>
			<p>We then expanded our knowledge of the concept of modifiers. We looked at how modifier chains work and what you need to keep in mind to always get the intended results. For example, to receive clicks inside padding, <code>padding {}</code> must occur after <code>clickable {}</code> in the <code>modifier</code> chain. Finally, you learned how to implement custom modifiers.</p>
			<p>In <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>, we will examine how to lay out UI elements and introduce you to the <strong class="bold">single measure pass</strong>. We will explore built-in layouts, but also write a custom Compose layout.</p>
		</div>
	</div></body></html>