<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer028">
			<h1 id="_idParaDest-46"><a id="_idTextAnchor054"/>Chapter 3: Exploring the Key Principles of Compose</h1>
			<p>In the first chapter of this book, we built and run our first Jetpack Compose app. Then, in <a href="B17505_02_ePub.xhtml#_idTextAnchor040"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding the Declarative Paradigm</em>, we explained the imperative nature of Android's traditional UI toolkit, illustrated some of its weaknesses, and saw how a declarative approach can overcome them.</p>
			<p>In this chapter, we build upon these foundations by examining a few key principles Jetpack Compose relies on. This knowledge is essential for writing well-behaving Compose apps. This chapter introduces these key principles. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Looking closer at composable functions</li>
				<li>Composing and recomposing the <strong class="bold">user interface</strong> (<strong class="bold">UI</strong>)</li>
				<li>Modifying the behavior of composable functions</li>
			</ul>
			<p>We will start by revisiting composable functions, the building blocks of a composable UI. This time, we will dig much deeper into their underlying ideas and concepts. By the end of the first main section, you will have established a thorough understanding of what composable functions are, how they are written, and how they are used.</p>
			<p>The following section focuses on creating and updating the UI. You will learn how Jetpack Compose achieves what other UI frameworks<a id="_idIndexMarker082"/> call repainting. This mechanism, which is called <strong class="bold">recomposition</strong> in Compose, takes place automatically whenever something relevant to the UI changes. To keep this process fluent, your composable functions must adhere to a few best practices. I will explain them to you in this section.</p>
			<p>We will close this chapter by expanding our knowledge of the concept of modifiers. We will take a close look at how modifier chains work and what you need to keep in mind to always get the intended results. You will also learn how to implement custom modifiers. They allow you to amend any composable function to look or behave in precisely the way you want them to.</p>
			<p>Now, let's get started!</p>
			<h1 id="_idParaDest-47"><a id="_idTextAnchor055"/>Technical requirements</h1>
			<p>Please refer to the <em class="italic">Technical requirements</em> section of <a href="B17505_01_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Building Your First Compose App</em>, for information on how to install and set up Android Studio, as well as how to get the sample apps. If you want to try the <strong class="source-inline">ShortColoredTextDemo()</strong> and <strong class="source-inline">ColoredTextDemo()</strong> composables from the <em class="italic">Looking closer at composable functions</em> section, you can use the <strong class="source-inline">Sandbox</strong> app project in the top-level directory of this book's GitHub repository at <a href="https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose">https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose</a>. Open <strong class="source-inline">SandboxActivity</strong> and copy the composable functions from <strong class="source-inline">code_snippets.txt</strong>, which will be located in the <strong class="source-inline">/chapter_03</strong> folder.<a id="_idTextAnchor056"/><a id="_idTextAnchor057"/></p>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor058"/>Looking closer at composable functions</h1>
			<p>The UI of a Compose app is built by writing and calling composable functions. We have already done both in the previous chapters, but my explanations regarding the structure of a composable, as well as its internals, have been quite basic – it's time to fix that.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor059"/>Building blocks of composable functions</h2>
			<p>A <strong class="bold">composable function</strong> is a Kotlin function that has been annotated<a id="_idIndexMarker083"/> with <strong class="source-inline">@Composable</strong>. All composables <em class="italic">must</em> be marked this way because the annotation informs the Compose compiler that the function converts data into UI elements.</p>
			<p>The signature of a Kotlin function<a id="_idIndexMarker084"/> consists of the following parts or building blocks:</p>
			<ul>
				<li>An optional visibility modifier (<strong class="source-inline">private</strong>, <strong class="source-inline">protected</strong>, <strong class="source-inline">internal</strong>, or <strong class="source-inline">public</strong>)</li>
				<li>The <strong class="source-inline">fun</strong> keyword</li>
				<li>A name</li>
				<li>A list of parameters (can be empty) or, optionally, a default value</li>
				<li>An optional return type</li>
				<li>A block<a id="_idIndexMarker085"/> of code</li>
			</ul>
			<p>Let's explore these parts in greater detail.</p>
			<p>The default visibility (if you omit the modifier) is <strong class="source-inline">public</strong>. This means that the (composable) function can be called from anywhere. If a function is meant to be reused (for example, a text styled to match your brand), it should be publicly available. On the other hand, if a function is tied to a particular <strong class="bold">context</strong> (the region of code, such as a class), it may make sense to restrict its access. There is an open debate on how rigid the visibility of functions should be restrained. In the end, you and your team need to agree on a point of view and stick to it. For the sake of simplicity, my examples are usually public.</p>
			<p>The name of a composable function uses the <em class="italic">PascalCase</em> notation: it starts with an uppercase letter, whereas the remaining characters are lowercase. If the name<a id="_idIndexMarker086"/> consists of more than one word, each word follows this rule. The name should be a noun (<strong class="source-inline">Demo</strong>), or a noun that has been prefixed with a descriptive adjective (<strong class="source-inline">FancyDemo</strong>). Unlike other (ordinary) Kotlin functions, it should <em class="italic">not</em> be a verb or a verb phrase (<strong class="source-inline">getDataFromServer</strong>). The <em class="italic">API Guidelines for Jetpack Compose</em> file, which is available at <a href="https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md">https://github.com/androidx/androidx/blob/androidx-main/compose/docs/compose-api-guidelines.md</a>, details these naming conventions.</p>
			<p>All the data you want to pass to a composable function<a id="_idIndexMarker087"/> is provided through a comma-separated list, which is enclosed in parenthesis. If a composable does not require values, the list remains empty. Here's a composable function that can receive two parameters:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ColoredTextDemo(</p>
			<p class="source-code">  text: String = "",</p>
			<p class="source-code">  color: Color = Color.Black</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    text = text,</p>
			<p class="source-code">    style = TextStyle(color = color)</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>In Kotlin, function parameters are defined as <strong class="source-inline">name: type</strong>. Parameters are separated by a comma. You can specify a default value by adding <strong class="source-inline">= ...</strong>. This is used if no value is provided for a particular parameter when the function is being invocated.</p>
			<p>The return type of a function is optional. In this case, the function returns <strong class="source-inline">Unit</strong>. <strong class="source-inline">Unit</strong> is a type with only one value: <strong class="source-inline">Unit</strong>. If, like in this example, it is omitted, the function body follows immediately after the list of arguments. Most composable functions you will be writing do not need to return anything, so do not need a return type. Situations that require it will be covered in the <em class="italic">Returning values</em> section.</p>
			<p>If the code of a function contains more than one statement or expression, it will be enclosed in curly braces. Kotlin<a id="_idIndexMarker088"/> offers a nice abbreviation for if just one expression needs to be executed – Jetpack Compose itself uses this quite frequently.</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ShortColoredTextDemo(</p>
			<p class="source-code">    text: String = "",</p>
			<p class="source-code">    color: Color = Color.Black</p>
			<p class="source-code">) = Text(</p>
			<p class="source-code">    text = text,</p>
			<p class="source-code">    style = TextStyle(color = color)</p>
			<p class="source-code">)</p>
			<p>As you can see, the expression follows an equals sign. This means that <strong class="source-inline">ShortColoredTextDemo()</strong> returns whatever <strong class="source-inline">Text()</strong> is returning.</p>
			<p>Unlike Java, Kotlin<a id="_idIndexMarker089"/> does not know about the <strong class="source-inline">void</strong> keyword, so all the functions must return <em class="italic">something</em>. By omitting the return type, we implicitly tell Kotlin that the return type of a function is <strong class="source-inline">kotlin.Unit</strong>. This type has only one value: the <strong class="source-inline">Unit</strong> object. So, <strong class="source-inline">Unit</strong> corresponds to <strong class="source-inline">void</strong> in Java.</p>
			<p>Let's test this by printing the result of invoking a composable function:</p>
			<p class="source-code">class SandboxActivity : ComponentActivity() {</p>
			<p class="source-code">  override fun onCreate(savedInstanceState: Bundle?) {</p>
			<p class="source-code">    super.onCreate(savedInstanceState)</p>
			<p class="source-code">    setContent {</p>
			<p class="source-code">      println(ColoredTextDemo(</p>
			<p class="source-code">        text = "Hello Compose",</p>
			<p class="source-code">        color = Color.Blue</p>
			<p class="source-code">      ))</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>If you run the app, the following line will be printed:</p>
			<p class="source-code">I/System.out: kotlin.Unit</p>
			<p>While this may not look too exciting, its implications are profound. Think of it: although the <strong class="source-inline">ColoredTextDemo()</strong> composable function returns nothing interesting, some text is shown on the screen. This happens because it invokes another composable, called <strong class="source-inline">Text()</strong>. So, whatever may be needed to show text must happen inside <strong class="source-inline">Text()</strong>, and it cannot have anything to do with the return value of a composable.</p>
			<p>In the previous chapter, I said that composable functions <em class="italic">emit</em> UI elements. I will explain what this means in the next section.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor060"/>Emitting UI elements</h2>
			<p>A Compose UI is created<a id="_idIndexMarker090"/> by nesting calls to composable functions, which can be provided by the Jetpack Compose libraries, code of other developers, or your app.</p>
			<p>Let's find out what happens once <strong class="source-inline">ColoredTextDemo()</strong> has called <strong class="source-inline">androidx.compose.material.Text()</strong>. To see the source code of (among others) composable functions in Android Studio, you can click on their names while holding down the <em class="italic">Ctrl</em> key (on a Mac, it's the <em class="italic">cmd</em> key).</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">I will only show you the important steps because otherwise, I would need to copy too much code. To get the best learning experience, please follow the call chain directly in your IDE.</p>
			<p><strong class="source-inline">Text()</strong> defines two variables, <strong class="source-inline">textColor</strong> and <strong class="source-inline">mergedStyle</strong>, and passes them to <strong class="source-inline">androidx.compose.foundation.text.BasicText()</strong>. Although you can use <strong class="source-inline">BasicText()</strong> in your code, you should choose <strong class="source-inline">androidx.compose.material.Text()</strong> if possible, because it consumes style information from a theme. Please refer to <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>, for more information about themes.</p>
			<p><strong class="source-inline">BasicText()</strong> immediately delegates to <strong class="source-inline">CoreText()</strong>, which belongs to the <strong class="source-inline">androidx.compose.foundation.text</strong> package too. It is an internal composable function, meaning you can't use it in your apps.</p>
			<p><strong class="source-inline">CoreText()</strong> initializes and remembers quite a few variables. There is no need to explain them all here, but the most important piece is the invocation of another composable function: <strong class="source-inline">Layout()</strong>.</p>
			<p><strong class="source-inline">Layout()</strong> belongs to the <strong class="source-inline">androidx.compose.ui.layout</strong> package. It is the core composable function for the layout, with its purpose being to size and position children. <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>, covers this in great detail. Right now, we still need to find out what <em class="italic">emitting UI elements</em> means. So, let's see what <strong class="source-inline">Layout()</strong> does: </p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="Images/B17505_03_1.jpg" alt="Figure 3.1 – Source code of Layout()&#13;&#10;" width="767" height="505"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.1 – Source code of Layout()</p>
			<p><strong class="source-inline">Layout()</strong> invokes <strong class="source-inline">ReusableComposeNode()</strong>, which belongs to the <strong class="source-inline">androidx.compose.runtime</strong> package. This composable function <em class="italic">emits</em> a so-called <strong class="bold">node</strong>, a UI element hierarchy. Nodes<a id="_idIndexMarker091"/> are created using a factory, which is passed through the <strong class="source-inline">factory</strong> argument. The <strong class="source-inline">update</strong> and <strong class="source-inline">skippableUpdate</strong> parameters receive code that performs<a id="_idIndexMarker092"/> updates on the node, with the latter one handling modifiers (we will be taking a closer look at them at the end of this chapter). Finally, <strong class="source-inline">content</strong> contains composable functions that become the children of the node.</p>
			<p class="callout-heading">Please Note</p>
			<p class="callout">When we speak of composable functions <em class="italic">emitting</em> UI elements, we mean that <strong class="bold">nodes</strong> are<a id="_idIndexMarker093"/> added to data structures that are internal to Jetpack Compose. This will eventually lead to UI elements being visible.</p>
			<p>To complete<a id="_idIndexMarker094"/> the call chain, let's briefly look at <strong class="source-inline">ReusableComposeNode()</strong>:</p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="Images/B17505_03_2.jpg" alt="Figure 3.2 – Source code of ReusableComposeNode()&#13;&#10;" width="824" height="607"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.2 – Source code of ReusableComposeNode()</p>
			<p><strong class="source-inline">currentComposer</strong> is a top-level variable inside <strong class="source-inline">androidx.compose.runtime.Composables.kt</strong>. Its type is <strong class="source-inline">Composer</strong>, which is an interface. <strong class="source-inline">Composer</strong> is targeted by the Jetpack Compose Kotlin compiler plugin and used by code generation helpers; your code should not call it directly. <strong class="source-inline">ReusableComposeNode</strong> determines if a new node should be created or whether an existing one should be reused. It then performs updates and finally emits the content to the node by invoking <strong class="source-inline">content()</strong>.</p>
			<p>Based on what you know<a id="_idIndexMarker095"/> by now, let me elaborate a little more on nodes. <strong class="source-inline">Layout()</strong> passes <strong class="source-inline">ComposeUiNode.Constructor</strong> to <strong class="source-inline">ReusableComposeNode</strong> as the <strong class="source-inline">factory</strong> argument, which is used to create a node (<strong class="source-inline">currentComposer.createNode(factory)</strong>). So, the features of a node are defined by the <strong class="source-inline">ComposeUiNode</strong> interface:</p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="Images/B17505_03_3.jpg" alt="Figure 3.3 – Source code of ComposeUiNode&#13;&#10;" width="919" height="534"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.3 – Source code of ComposeUiNode</p>
			<p>A node has four<a id="_idIndexMarker096"/> properties, as defined by the following classes or interfaces: </p>
			<ul>
				<li><strong class="source-inline">MeasurePolicy</strong></li>
				<li><strong class="source-inline">LayoutDirection</strong></li>
				<li><strong class="source-inline">Density</strong></li>
				<li><strong class="source-inline">Modifier</strong> </li>
			</ul>
			<p>In essence, a node is an element in a Compose hierarchy. You will not be dealing with them in your code because nodes are part of the inner workings of Jetpack Compose that are not exposed to apps. However, you will see <strong class="source-inline">MeasurePolicy</strong>, <strong class="source-inline">LayoutDirection</strong>, <strong class="source-inline">Density</strong>, and <strong class="source-inline">Modifier</strong> throughout this book. They represent important data structures and concepts that are relevant to apps.</p>
			<p>This concludes<a id="_idIndexMarker097"/> our investigation of how UI elements are emitted (nodes are added to data structures that are internal to Jetpack Compose). In the next section, we will look at composable functions that return values.</p>
			<h2 id="_idParaDest-51"><a id="_idTextAnchor061"/>Returning values</h2>
			<p>Most of your composable functions<a id="_idIndexMarker098"/> will not need to return something, so they will not specify a return type. This is because the main purpose of a composable is to compose the UI. As you saw in the previous section, this is done by emitting UI elements or element hierarchies. But when do we need to return something different than <strong class="source-inline">Unit</strong>?</p>
			<p>Some of my examples invoke <strong class="source-inline">remember {}</strong> to retain state for future use and <strong class="source-inline">stringResource()</strong> to access strings that are stored in the <strong class="source-inline">strings.xml</strong> file. To be able to perform their tasks, both must be composable functions.</p>
			<p>Let's look at <strong class="source-inline">stringResource()</strong> to see why. Remember that you can press Ctrl + click on a name to see its source code. The function is pretty short; it does just two things:</p>
			<p class="source-code">val resources = resources()</p>
			<p class="source-code">return resources.getString(id)</p>
			<p><strong class="source-inline">resources()</strong> is a composable too. It returns <strong class="source-inline">LocalContext.current.resources</strong>. <strong class="source-inline">LocalContext</strong> is a top-level variable in <strong class="source-inline">AndroidCompositionLocals.android.kt</strong> that belongs to the  <strong class="source-inline">androidx.compose.ui.platform</strong> package. It returns an instance of <strong class="source-inline">StaticProvidableCompositionLocal</strong>, which holds <strong class="source-inline">android.content.Context</strong>. This object provides access to resources.</p>
			<p>Even though the returned data has nothing to do with Jetpack Compose, the code that obtains it must conform to Jetpack Compose mechanics because, in the end, it will be called from a composable<a id="_idIndexMarker099"/> function. The important thing to remember is that if you need to return something that is part of the composition and recomposition mechanic, you must make your function composable by annotating it with <strong class="source-inline">@Composable</strong>. Also, such functions do not follow the naming conventions for composable functions but follow a <em class="italic">camelCase</em> style (they begin with a small letter, with the subsequent word starting in uppercase) and consist of verb phrases (<strong class="source-inline">rememberScrollState</strong>).</p>
			<p>In the next section, we will return to composing UIs at the app level. You will learn more about the terms <strong class="bold">composition</strong> and <strong class="bold">recomposition</strong>.</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor062"/>Composing and recomposing the UI</h1>
			<p>Unlike imperative UI frameworks, Jetpack Compose does not depend on the developer proactively modifying<a id="_idIndexMarker100"/> a component tree when changes in the app data require<a id="_idIndexMarker101"/> changes to be made to the UI. Instead, Jetpack Compose detects such changes on its own and updates only the affected parts.</p>
			<p>As you know by now, a Compose UI is declared <em class="italic">based on</em> the current app data. In my previous examples, you have seen quite a few conditional expressions (such as <strong class="source-inline">if</strong> or <strong class="source-inline">when</strong>) that determine which composable function is called or which parameters it receives. So, we are describing the <em class="italic">complete</em> UI in our code. The branch that will be executed depends on the app data (state) during runtime. The Web framework that React<a id="_idIndexMarker102"/> has a similar concept called Virtual DOM. But doesn't this contradict with me saying <em class="italic">Compose detects such changes on its own and updates only the affected parts</em>?</p>
			<p>Conceptually, Jetpack Compose regenerates the entire UI when changes need to be applied. This, of course, would waste time, battery, and processing power. And it might be noticeable by the user as screen flickering. Therefore, the framework puts a lot of effort into making sure only those parts of the UI element tree requiring an update are regenerated.</p>
			<p>You saw some of these efforts in the previous section, where I briefly mentioned <strong class="source-inline">update</strong> and <strong class="source-inline">skippableUpdate</strong>. To ensure<a id="_idIndexMarker103"/> fast and reliable <strong class="bold">recompositions</strong> (the Jetpack Compose<a id="_idIndexMarker104"/> term for updating, regenerating, or repainting), you need<a id="_idIndexMarker105"/> to make sure your composable functions follow a few simple rules. I will introduce them to you by walking you through the code of an app called <strong class="source-inline">ColorPickerDemo</strong>:</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/B17505_03_4.jpg" alt="Figure 3.4 – The ColorPickerDemo app&#13;&#10;" width="1078" height="499"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.4 – The ColorPickerDemo app</p>
			<p>The app aims to set a color by specifying its <strong class="bold">red, green, and blue</strong> (<strong class="bold">RGB</strong>) portions. This color is used as the background color of a text (which displays the value of the color as a hexadecimal string). The foreground color is complementary to the selected one.</p>
			<p>In the next few sections, we look at its code. You will learn how sliders communicate changes in their values.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor063"/>Sharing state among composable functions</h2>
			<p>Sometimes, you may want<a id="_idIndexMarker106"/> to use a state in more than<a id="_idIndexMarker107"/> one composable function. For example, you may wish to use the color portion that's been set by one slider to create the<a id="_idIndexMarker108"/> full color, which, in turn, becomes the background<a id="_idIndexMarker109"/> color of a text. So, how can you share state? Let's start by looking at <strong class="source-inline">ColorPicker()</strong> – it groups three sliders vertically in a <strong class="source-inline">Column()</strong>:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun ColorPicker(color: MutableState&lt;Color&gt;) {</p>
			<p class="source-code">  val red = color.value.red</p>
			<p class="source-code">  val green = color.value.green</p>
			<p class="source-code">  val blue = color.value.blue</p>
			<p class="source-code">  Column {</p>
			<p class="source-code">    Slider(</p>
			<p class="source-code">      value = red,</p>
			<p class="source-code">      onValueChange = { color.value = Color(it, green, </p>
			<p class="source-code">                                            blue) </p>
			<p class="source-code">})</p>
			<p class="source-code">    Slide<a id="_idTextAnchor064"/>r(</p>
			<p class="source-code">      value = green,</p>
			<p class="source-code">      onValueChange = { color.value = Color(red, it, blue) })</p>
			<p class="source-code">    Slider(</p>
			<p class="source-code">      value = blue,</p>
			<p class="source-code">      onValueChange = { color.value = Color(red, green, it) })</p>
			<p class="source-code">  }</p>
			<p class="source-code">}</p>
			<p>The composable receives one parameter: <strong class="source-inline">MutableState&lt;Color&gt;</strong>. The <strong class="source-inline">value</strong> property of <strong class="source-inline">color</strong> contains an instance of <strong class="source-inline">androidx.compose.ui.graphics.Color</strong>. Its <strong class="source-inline">red</strong>, <strong class="source-inline">green</strong>, and <strong class="source-inline">blue</strong> properties return a <strong class="source-inline">Float</strong> based on the so-called <strong class="bold">color space</strong>, which is used to identify a specific organization<a id="_idIndexMarker110"/> of colors. Each color space is characterized by a color model, which, in turn, defines how a color value is represented. If not specified otherwise, this is <strong class="source-inline">ColorSpaces.Srgb</strong>.</p>
			<p>My code does not set<a id="_idIndexMarker111"/> a particular color space, so it defaults to <strong class="source-inline">ColorSpaces.Srgb</strong>. This causes the value being returned to be between <strong class="source-inline">0F</strong> and <strong class="source-inline">1F</strong>. The first three<a id="_idIndexMarker112"/> lines assign the red, green, and blue portions of the color to local variables named <strong class="source-inline">red</strong>, <strong class="source-inline">green</strong>, and <strong class="source-inline">blue</strong>. They are used for the <strong class="source-inline">Slider()</strong> functions; let's see how.</p>
			<p>Each slider in my example receives two parameters: <strong class="source-inline">value</strong> and <strong class="source-inline">onValueChange</strong>. The first specifies the value that the slider will display. It must be between <strong class="source-inline">0F</strong> and <strong class="source-inline">1F</strong> (which fits nicely with <strong class="source-inline">red</strong>, <strong class="source-inline">green</strong>, and <strong class="source-inline">blue</strong>). If needed, you can supply an alternative range through the optional <strong class="source-inline">valueRange</strong> parameter. <strong class="source-inline">onValueChange</strong> is invoked when the user drags the slider handle or clicks on the thin line underneath. The code of the three lambda expressions is quite similar: a new <strong class="source-inline">Color</strong> object is created and assigned to <strong class="source-inline">color.value</strong>. Color portions that are being controlled by other sliders are taken from the corresponding local variables. They have not been changed. The new color portion of the current slider can be obtained from <strong class="source-inline">it</strong> because it is the new slider value, which is passed to <strong class="source-inline">onValueChange</strong>.</p>
			<p>By now, you may be wondering why <strong class="source-inline">ColorPicker()</strong> receives the color wrapped inside a <strong class="source-inline">MutableState&lt;Color&gt;</strong>. Wouldn't it suffice to pass it directly, using <strong class="source-inline">color: Color</strong>? As shown in <em class="italic">Figure 3.4</em>, the app shows the selected color as a text with complementary background and foreground colors. But <strong class="source-inline">ColorPicker()</strong> does not emit text. This happens somewhere else (as you will see shortly, inside a <strong class="source-inline">Column()</strong>). To show the correct color, the text must receive it too. As the color change takes place inside <strong class="source-inline">ColorPicker()</strong>, we must inform the caller about it. An ordinary <strong class="source-inline">Color</strong> instance being passed as a parameter can't do that because Kotlin function parameters are immutable.</p>
			<p>We can achieve changeability using global properties. But this is not recommended for Jetpack Compose. Composables should not use global variables at all. It is a best practice to pass all the data that influences the look or behavior of a composable function as parameters. If that data is modified inside the composable, you should use <strong class="source-inline">MutableState</strong>. Moving state<a id="_idIndexMarker113"/> to a composable's caller by receiving a state is called <strong class="bold">state hoisting</strong>. A good alternative to passing <strong class="source-inline">MutableState</strong> and applying changes inside a composable is to pass the change logic<a id="_idIndexMarker114"/> as a lambda expression. In my example, <strong class="source-inline">onValueChange</strong> would just provide<a id="_idIndexMarker115"/> the new slider value to the lambda expression.</p>
			<p class="callout-heading">Important</p>
			<p class="callout">Try to make your composables side effect-free. Having no side effects means calling a function repeatedly with the same set of arguments that will always produce the same result. Besides getting all the relevant data from the caller, being free of side effects also requires not relying on global properties or calling functions that return unpredictable values. There are a few scenarios where you want side effects. I will cover these in <a href="B17505_07_ePub.xhtml#_idTextAnchor119"><em class="italic">Chapter 7</em></a>, <em class="italic">Tips, Tricks, and Best Practices</em>.</p>
			<p>Now, let's learn how the color is passed to the text:</p>
			<p class="source-code">Column(</p>
			<p class="source-code">  modifier = Modifier.width(min(400.dp, maxWidth)),</p>
			<p class="source-code">  horizontalAlignment = Ali<a id="_idTextAnchor065"/>gn<a id="_idTextAnchor066"/>ment.CenterHorizontally</p>
			<p class="source-code">) {</p>
			<p class="source-code">  val color = remember { mutableStateOf(Color.Magenta) }</p>
			<p class="source-code">  ColorPicker(color)</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxWidth()</p>
			<p class="source-code">      .background(color.value),</p>
			<p class="source-code">    text =</p>
			<p class="source-code">    "#${color.value.toArgb().toUInt().toString(16)}",</p>
			<p class="source-code">    textAlign = TextAlign.Center,</p>
			<p class="source-code">    style = MaterialTheme.typography.h4.merge(</p>
			<p class="source-code">      TextStyle(</p>
			<p class="source-code">        color = color.value.complementary()</p>
			<p class="source-code">      )</p>
			<p class="source-code">    )</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">ColorPicker()</strong> and <strong class="source-inline">Text()</strong> are laid out vertically (being centered horizontally) inside a <strong class="source-inline">Column()</strong>. The width<a id="_idIndexMarker116"/> of the column is either <strong class="source-inline">400</strong> density-independent <a id="_idIndexMarker117"/>pixels or <strong class="source-inline">maxWidth</strong>, depending on which value is smaller. <strong class="source-inline">maxWidth</strong> is defined by the predefined <strong class="source-inline">BoxWithConstraints()</strong> composable (you will learn more about it in the <em class="italic">Controlling size</em> section). The color for both <strong class="source-inline">ColorPicker()</strong> and <strong class="source-inline">Text()</strong> is defined like this:</p>
			<p class="source-code">val color = remember { mutableStateOf(Color.Magenta) }</p>
			<p>When <strong class="source-inline">Column()</strong> is composed for the first time, <strong class="source-inline">mutableStateOf(Color.Magenta)</strong> is executed. This creates <strong class="bold">state</strong>. State represents app data (in this case, a color) that changes<a id="_idIndexMarker118"/> over time. You will learn more about state in <a href="B17505_05_ePub.xhtml#_idTextAnchor089"><em class="italic">Chapter 5</em></a>, <em class="italic">Managing the State of Your Composable Functions</em>. For now, it suffices to understand that the state is <em class="italic">remembered</em> and assigned to <strong class="source-inline">color</strong>.</p>
			<p>But what does <strong class="source-inline">remember</strong> mean? Any subsequent composition, which is called <strong class="bold">recomposition</strong>, will lead to <strong class="source-inline">color</strong> receiving<a id="_idIndexMarker119"/> the value created by <strong class="source-inline">mutableStateOf</strong> – that is, a reference to a <strong class="source-inline">MutableState&lt;Color&gt;</strong> (state hoisting). The lambda expression that's passed to <strong class="source-inline">remember</strong> is called a <strong class="bold">calculation</strong>. It will only be<a id="_idIndexMarker120"/> evaluated once. Recompositions always return the same value.</p>
			<p>If the reference remains the same, how can the color be changed? The actual color is accessed through the <strong class="source-inline">value</strong> property. You saw this in the code of <strong class="source-inline">ColorPicker()</strong>. <strong class="source-inline">Text()</strong> does not modify the color – it only works with it. Therefore, we pass <strong class="source-inline">color.value</strong> (which is the color), not the mutable state (<strong class="source-inline">color</strong>), to some of its parameters, such as <strong class="source-inline">background</strong>. Note that this is a modifier. You will learn more about them in the <em class="italic">Modifying behavior</em> section. It sets the background color of a UI element that's emitted by a composable function.</p>
			<p>Also, have you noticed the call of <strong class="source-inline">complementary()</strong> inside <strong class="source-inline">TextStyle()</strong>? Here's what it does:</p>
			<p class="source-code">fun Color.complementary() = Color(</p>
			<p class="source-code">  red = 1F - red,</p>
			<p class="source-code">  green = 1F - green,</p>
			<p class="source-code">  blue = 1F - blue</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">complementary()</strong> is an extension function of <strong class="source-inline">Color</strong>. It computes the complementary color to the one<a id="_idIndexMarker121"/> it receives. This is done to make the text (the hexadecimal RGB value<a id="_idIndexMarker122"/> of the color that was selected using the three sliders) readable, regardless of the currently selected color (which is used as the background of the text).</p>
			<p>In this section, I talked about some very important Jetpack Compose concepts. Let's recap what we've learned so far:</p>
			<ul>
				<li>A compose UI is defined by nesting calls to composable functions</li>
				<li>Composable functions emit UI elements or UI element hierarchies</li>
				<li>Building<a id="_idIndexMarker123"/> the UI for the first time is called <strong class="bold">composition</strong></li>
				<li>Rebuilding the UI upon<a id="_idIndexMarker124"/> changes being made to app data is called <strong class="bold">recomposition</strong></li>
				<li>Recomposition happens automatically<p class="callout-heading">Important</p><p class="callout">There is no way for your app to predict when or how often recomposition<a id="_idIndexMarker125"/> will take place. If animations are involved, this may happen each frame. Therefore, it is of utmost importance to make your composables as fast as possible. You may never do time-consuming calculations, load or save data, or access the network. Any such code must be executed outside of composable functions. They only receive ready data. Also, please note that the order of recomposition is unspecified. This means that the first child of, say, a <strong class="source-inline">Column()</strong>, might be recomposed later than a sibling that appears after it in the source code. Recomposition can occur in parallel and it may be skipped. Therefore, never rely on a particular order of recomposition, and never compute something in a composable that is needed somewhere else.</p></li>
			</ul>
			<p>In the next section, we will finish our walkthrough of the <strong class="source-inline">ColorPickerDemo</strong> app. I will show you how to specify and limit the dimensions of composable functions.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor067"/>Controlling size</h2>
			<p>Most of my examples<a id="_idIndexMarker126"/> contain code such as <strong class="source-inline">fillMaxSize()</strong> or <strong class="source-inline">fillMaxWidth()</strong>. Both modifiers control the size of a composable. <strong class="source-inline">fillMaxSize()</strong> uses all the available horizontal and vertical space, while <strong class="source-inline">fillMaxWidth()</strong> maximizes only the horizontal expansion.</p>
			<p>However, <strong class="source-inline">fillMaxWidth()</strong> may not be the right choice for sliders. In my opinion, large sliders are awkward to use due to the distance you would need to drag their handles to reach the minimum or maximum value. So, the question is, how can we limit its width? The most straightforward solution is to use the <strong class="source-inline">width()</strong> modifier. It sets the preferred width of a composable to a particular size. I want sliders to be 400 density-independent pixels wide at most. If the screen is smaller, its width should be used instead. Here's how you achieve this:</p>
			<p class="source-code">modifier = Modifier.width(min(400.dp, maxWidth)),</p>
			<p>The modifier belongs to the <strong class="source-inline">Column()</strong> property that contains both <strong class="source-inline">ColorPicker()</strong> and <strong class="source-inline">Text()</strong>.</p>
			<p><strong class="source-inline">maxWidth</strong> is provided by the <strong class="source-inline">BoxWithConstraints()</strong> composable:</p>
			<p class="source-code">BoxWithConstraints(</p>
			<p class="source-code">  contentAlignment = Alignment.Center,</p>
			<p class="source-code">  modifier = Modifier.fillMaxSize()</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Column ...</p>
			<p class="source-code">}</p>
			<p>Its content receives<a id="_idIndexMarker127"/> an instance of a <strong class="source-inline">BoxWithConstraintsScope</strong> scope, which provides access to <strong class="source-inline">constraints</strong>, <strong class="source-inline">minWidth</strong>, <strong class="source-inline">minHeight</strong>, <strong class="source-inline">maxWidth</strong>, and <strong class="source-inline">maxHeight</strong>. <strong class="source-inline">BoxWithConstraints()</strong> defines its content according to the available space, based on incoming constraints. You will learn more about this in <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>.</p>
			<p>This concludes our walkthrough of the <strong class="source-inline">ColorPickerDemo</strong> app. In the next section, we take a closer look at how a composable hierarchy is displayed in an <strong class="source-inline">Activity</strong>.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor068"/>Displaying a composable hierarchy inside an Activity</h2>
			<p>In the previous section, we built<a id="_idIndexMarker128"/> a UI element hierarchy consisting of three sliders<a id="_idIndexMarker129"/> and some text. We embedded it in an <strong class="source-inline">Activity</strong> using <strong class="source-inline">setContent</strong>, an extension function of <strong class="source-inline">androidx.activity.ComponentActivity</strong>. This implies that you cannot invoke <strong class="source-inline">setContent</strong> on <em class="italic">any</em> activity, but only ones that extend <strong class="source-inline">ComponentActivty</strong>. This is the case for <strong class="source-inline">androidx.appcompat.app.AppCompatActivity</strong>.</p>
			<p>However, this class inherits quite a lot of functionality that is relevant for the old View-based world, such as support for toolbars and the options menu. Jetpack Compose handles these differently. You will learn more about this in <a href="B17505_06_ePub.xhtml#_idTextAnchor105"><em class="italic">Chapter 6</em></a>, <em class="italic">Putting Pieces Together</em>. Therefore, you should avoid using <strong class="source-inline">AppCompatActivity</strong>, and instead extend <strong class="source-inline">ComponentActivity</strong> if possible. For combining View-based and Compose UIs, please refer to <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>Let's return to <strong class="source-inline">setContent</strong>. It expects two parameters:</p>
			<ul>
				<li><strong class="source-inline">parent</strong>, an optional <strong class="source-inline">CompositionContext</strong></li>
				<li><strong class="source-inline">content</strong>, a composable function for declaring the UI</li>
			</ul>
			<p>You will likely omit <strong class="source-inline">parent</strong> most of the time. <strong class="source-inline">CompositionContext</strong> is an abstract class that belongs to the <strong class="source-inline">androidx.compose.runtime</strong> package. It is used to logically connect<a id="_idIndexMarker130"/> two compositions. This refers<a id="_idIndexMarker131"/> to the inner workings of Jetpack Compose that you do not need to worry about in your app code. Yet, to get an idea of what this means, let's look at the source code of <strong class="source-inline">setContent</strong>:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="Images/B17505_03_5.jpg" alt="Figure 3.5 – The source code of setContent&#13;&#10;" width="1059" height="577"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.5 – The source code of setContent</p>
			<p>First, <strong class="source-inline">findViewById()</strong> is used to find out if the activity already contains content that is an instance of <strong class="source-inline">androidx.compose.ui.platform.ComposeView</strong>. If so, the <strong class="source-inline">setParentCompositionContext()</strong> and <strong class="source-inline">setContent()</strong> methods of this view will be invoked.</p>
			<p>Let's look at <strong class="source-inline">setParentCompositionContext()</strong> first. It belongs to <strong class="source-inline">AbstractComposeView</strong>, the immediate parent of <strong class="source-inline">ComposeView</strong>. It sets a <strong class="source-inline">CompositionContext</strong> that should be the parent of the view's composition. If that context is <strong class="source-inline">null</strong>, it will be determined automatically: <strong class="source-inline">AbstractComposeView</strong> contains a private function called <strong class="source-inline">ensureCompositionCreated()</strong>. It invokes another implementation of <strong class="source-inline">setContent</strong> (an internal extension function of <strong class="source-inline">ViewGroup</strong> that's defined in <strong class="source-inline">Wrapper.android.kt</strong>) and passes the result of a call to <strong class="source-inline">resolveParentCompositionContext()</strong> as a <strong class="source-inline">parent</strong>.</p>
			<p>Now, let's return to the version of <strong class="source-inline">setContent()</strong> that's shown in the preceding screenshot. Once <strong class="source-inline">setParentCompositionContext()</strong> has been called, it invokes yet another version of <strong class="source-inline">setContent()</strong>. This implementation belongs to <strong class="source-inline">ComposeView</strong>. It sets the content of the view.</p>
			<p>If <strong class="source-inline">findViewById()</strong> does not return a <strong class="source-inline">ComposeView</strong>, a new instance is created and passed to <strong class="source-inline">setContentView</strong>, after <strong class="source-inline">setParentCompositionContext()</strong> and <strong class="source-inline">setContent()</strong> have been invoked.</p>
			<p>In this section, we continued<a id="_idIndexMarker132"/> looking at some of the inner<a id="_idIndexMarker133"/> workings of Jetpack Compose. You now know that <strong class="source-inline">ComposeView</strong> is the missing link to the old-fashioned View-based world. We will revisit this class in <a href="B17505_09_ePub.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Exploring Interoperability APIs</em>.</p>
			<p>In the next section, we will return modifiers; you will learn how they work under the hood and how you can write your own.</p>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor069"/>Modifying the behavior of composable functions</h1>
			<p>Unlike components<a id="_idIndexMarker134"/> in traditional imperative UI frameworks, composable functions do not share a basic set of properties. They also do not automatically (in the sense of inheriting) reuse functionality. This must be done explicitly by calling other composables. Their visual appearance and behavior can be controlled through parameters, modifiers, or both. In a way, modifiers pick up the idea of properties in a component but enhance it – unlike properties of components, modifiers can be used completely at the discretion of the developer.</p>
			<p>You have already seen quite a few modifiers in my examples, such as the following:</p>
			<ul>
				<li><strong class="source-inline">width()</strong></li>
				<li><strong class="source-inline">fillMaxWidth()</strong></li>
				<li><strong class="source-inline">fillMaxSize()</strong> </li>
			</ul>
			<p>These control the width and size of the corresponding UI element; <strong class="source-inline">background()</strong> can set a background color and shape, while <strong class="source-inline">clickable {}</strong> allows the user to interact with the composable function<a id="_idIndexMarker135"/> by clicking on the UI element. Jetpack Compose provides an extensive list of modifiers, so it may take some time to make yourself familiar with most of them. Conceptually, these modifiers can be assigned to one of several categories, such as <em class="italic">Actions</em> (<strong class="source-inline">draggable()</strong>), <em class="italic">Alignment</em> (<strong class="source-inline">alignByBaseline()</strong>), or <em class="italic">Drawing</em> (<strong class="source-inline">paint()</strong>). You can find a list of modifiers<a id="_idIndexMarker136"/> grouped by category at <a href="https://developer.android.com/jetpack/compose/modifiers-list">https://developer.android.com/jetpack/compose/modifiers-list</a>.</p>
			<p>To further familiarize yourself with modifiers, let's look at the <strong class="source-inline">ModifierDemo</strong> example. It contains several composable functions. The following<a id="_idTextAnchor070"/><a id="_idTextAnchor071"/> screenshot shows the app running <strong class="source-inline">OrderDemo()</strong>:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="Images/B17505_03_6.jpg" alt="Figure 3.6 – The ModifierDemo app&#13;&#10;" width="1650" height="764"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.6 – The ModifierDemo app</p>
			<p>The composable produces a gap of 32 density-independent<a id="_idIndexMarker137"/> pixels on all its sides, followed by a 2 density-independent pixels wide blue border. The inner rectangle is painted in light gray.</p>
			<p>Here's what the code looks like:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun OrderDemo() {</p>
			<p class="source-code">  var color by remember { mutableStateOf(Color.Blue) }</p>
			<p class="source-code">  Box(</p>
			<p class="source-code">    modifier = Modifier</p>
			<p class="source-code">      .fillMaxSize()</p>
			<p class="source-code">      .padding(32.dp)</p>
			<p class="source-code">      .border(BorderStroke(width = 2.dp, color = color))</p>
			<p class="source-code">      .background(Color.LightGray)</p>
			<p class="source-code">      .clickable {</p>
			<p class="source-code">        color = if (color == Color.Blue)</p>
			<p class="source-code">          Color.Red</p>
			<p class="source-code">        else</p>
			<p class="source-code">          Color.Blue</p>
			<p class="source-code">      }</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p><strong class="source-inline">Box()</strong> is clickable – doing so changes the border color from blue to red and back. If you click inside the gaps, nothing will happen. If, however, you move<strong class="source-inline">.clickable { }</strong> before <strong class="source-inline">.padding(32.dp)</strong>, clicks work inside the gaps too. This is intentional. Here's what happens: you define a modifier chain by combining several modifiers with <strong class="source-inline">.</strong>. In doing so, you specify the order in which the modifiers are used. The location of a modifier in the chain determines<a id="_idIndexMarker138"/> when it is executed. As <strong class="source-inline">clickable {}</strong> only reacts to clicks inside the bounds of a composable, the padding is not considered for clicks when it occurs before <strong class="source-inline">clickable {}</strong>.</p>
			<p>In the next section, I will show you how Jetpack Compose handles modifiers and modifier chains internally.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor072"/>Understanding how modifiers work</h2>
			<p>Composable functions that accept modifiers should receive them via the <strong class="source-inline">modifier</strong> parameter and assign it a default value of <strong class="source-inline">Modifier</strong>. <strong class="source-inline">modifier</strong> should be the first optional parameter and thus<a id="_idIndexMarker139"/> appear after all the required ones, except for trailing lambda parameters.</p>
			<p>Let's see how a composable can receive a <strong class="source-inline">modifier</strong> parameter:</p>
			<p class="source-code">@Composable</p>
			<p class="source-code">fun TextWithYellowBackground(</p>
			<p class="source-code">  text: String,</p>
			<p class="source-code">  modifier: Modifier = Modifier</p>
			<p class="source-code">) {</p>
			<p class="source-code">  Text(</p>
			<p class="source-code">    text = text,</p>
			<p class="source-code">    modifier = modifier.background(Color.Yellow)</p>
			<p class="source-code">  )</p>
			<p class="source-code">}</p>
			<p>This way, the composable can receive a modifier chain from the caller. If none are provided, <strong class="source-inline">Modifier</strong> acts as a new, empty chain. In both cases, the composable can add additional modifiers, such as <strong class="source-inline">background()</strong> in the previous code snippet.</p>
			<p>If a composable function<a id="_idIndexMarker140"/> accepts a modifier that will be applied to a specific part or child of its corresponding UI element, the name of this part or child should be used as a prefix, such as <strong class="source-inline">titleModifier</strong>. Such modifiers follow the rules I mentioned previously. They should be grouped<a id="_idIndexMarker141"/> and appear after the parent's modifier. Please refer to <a href="https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier">https://developer.android.com/reference/kotlin/androidx/compose/ui/Modifier</a> for additional information regarding the definition of modifier parameters.</p>
			<p>Now that you know how to define a <strong class="source-inline">modifier</strong> parameter in a composable function, let's focus a little more on the idea of chaining. <strong class="source-inline">Modifier</strong> is both an interface and a companion object. The interface belongs to the <strong class="source-inline">androidx.compose.ui</strong> package. It defines several functions, such as <strong class="source-inline">foldIn()</strong> and <strong class="source-inline">foldOut()</strong>. You won't need them, though. The important one is <strong class="source-inline">then()</strong>. It concatenates two modifiers. As you will see shortly, you need to invoke it in your modifiers. The <strong class="source-inline">Element</strong> interface extends <strong class="source-inline">Modifier</strong>. It defines a single element contained within a <strong class="source-inline">Modifier</strong> chain. Finally, the <strong class="source-inline">Modifier</strong> companion object is the empty, default modifier, which contains no elements.</p>
			<p class="callout-heading">To Summarize</p>
			<p class="callout">A modifier is an ordered, immutable collection of modifier elements.</p>
			<p>Next, let's see how the <strong class="source-inline">background()</strong> modifier<a id="_idIndexMarker142"/> is implemented:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="Images/B17505_03_7.jpg" alt="Figure 3.7 – Source code of the background() modifier&#13;&#10;" width="733" height="527"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.7 – Source code of the background() modifier</p>
			<p><strong class="source-inline">background()</strong> is an extension function of <strong class="source-inline">Modifier</strong>. It receives a <strong class="source-inline">Modifier</strong> instance. It invokes <strong class="source-inline">then()</strong> and returns the result (a concatenated modifier). <strong class="source-inline">then()</strong> expects just one parameter: the <em class="italic">other</em> modifier that should be concatenated with the current one. In the case of <strong class="source-inline">background()</strong>, <em class="italic">other</em> is an instance of <strong class="source-inline">Background</strong>. This class extends <strong class="source-inline">InspectorValueInfo</strong> and implements the <strong class="source-inline">DrawModifier</strong> interface, which, in turn, extends <strong class="source-inline">Modifier.Element</strong>. As <strong class="source-inline">InspectorValueInfo</strong> is primarily used for debugging purposes, I will not elaborate on it any further. <strong class="source-inline">DrawModifier</strong>, on the other hand, is very interesting. Implementations can draw into the space of a UI element. We will make use of this in the final section.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor073"/>Implementing custom modifiers</h2>
			<p>Although Jetpack Compose contains<a id="_idIndexMarker143"/> an extensive list of modifiers, you may want to implement your own. Let me show you how to do this. My example, <strong class="source-inline">drawYellowCross()</strong>, draws two thick yellow lines behind the content, which is some <strong class="source-inline">Text()</strong> here:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/B17505_03_8.jpg" alt="Figure 3.8 – A custom modifier&#13;&#10;" width="1329" height="615"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.8 – A custom modifier</p>
			<p>The modifier is invoked like this:</p>
			<p class="source-code">Text(</p>
			<p class="source-code">  text = "Hello Compose",</p>
			<p class="source-code">  modifier = Modifier</p>
			<p class="source-code">    .fillMaxSize()</p>
			<p class="source-code">    <strong class="bold">.drawYellowCross()</strong>,</p>
			<p class="source-code">  textAlign = TextAlign.Center,</p>
			<p class="source-code">  style = MaterialTheme.typography.h1</p>
			<p class="source-code">)</p>
			<p>As you can see, the modifier integrates<a id="_idIndexMarker144"/> nicely into an existing modifier chain. Now, let's look at the source code:</p>
			<p class="source-code">fun Modifier.drawYellowCross() = then(</p>
			<p class="source-code">  object : DrawModifier {</p>
			<p class="source-code">    override fun ContentDrawScope.draw() {</p>
			<p class="source-code">      drawLine(</p>
			<p class="source-code">        color = Color.Yellow,</p>
			<p class="source-code">        start = Offset(0F, 0F),</p>
			<p class="source-code">        end = Offset(size.width - 1, size.height - 1),</p>
			<p class="source-code">        strokeWidth = 10F</p>
			<p class="source-code">      )</p>
			<p class="source-code">      drawLine(</p>
			<p class="source-code">        color = Color.Yellow,</p>
			<p class="source-code">        start = Offset(0F, size.height - 1),</p>
			<p class="source-code">        end = Offset(size.width - 1, 0F),</p>
			<p class="source-code">        strokeWidth = 10F</p>
			<p class="source-code">      )</p>
			<p class="source-code">      drawContent()</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }</p>
			<p class="source-code">)</p>
			<p><strong class="source-inline">drawYellowCross()</strong> is an extension function of <strong class="source-inline">Modifier</strong>. This means we can invoke <strong class="source-inline">then()</strong> and simply return the result. <strong class="source-inline">then()</strong> receives an instance of <strong class="source-inline">DrawModifier</strong>. After that, we need to implement only one function, called <strong class="source-inline">draw()</strong>, which is an extension function of <strong class="source-inline">ContentDrawScope</strong>. This interface defines one function (<strong class="source-inline">drawContent()</strong>) and extends <strong class="source-inline">DrawScope</strong>; this way, we gain access to quite a few drawing primitives, such as <strong class="source-inline">drawLine()</strong>, <strong class="source-inline">drawRect()</strong>, and <strong class="source-inline">drawImage()</strong>. <strong class="source-inline">drawContent()</strong> draws the UI element, so depending on when it is invoked, the element appears in front of, or behind, the other drawing primitives. In my example, it is the last instruction, so the UI element (for example, <strong class="source-inline">Text()</strong>) is the topmost one.</p>
			<p>Jetpack Compose<a id="_idIndexMarker145"/> also includes a modifier called <strong class="source-inline">drawBehind {}</strong>. It receives a lambda expression that can contain drawing primitives, just like in my example. To learn even more about the internals of Jetpack Compose, you may want to take a look at its source code. To see it, just click on <strong class="source-inline">drawBehind()</strong> in your code while pressing the <em class="italic">Ctrl</em> key.</p>
			<p>This concludes my explanations of modifiers. As you have seen, they are a very elegant way to control both the visual appearance and behavior of composable functions.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor074"/>Summary</h1>
			<p>This chapter introduced you to the key principles of Jetpack Compose. We closely looked at the underlying ideas and concepts of composable functions, and you now know how they are written and used. We also focused on how to create and update the UI, as well as how Jetpack Compose achieves what other frameworks call repainting or updating the screen. When relevant app data changes, the UI changes, or so-called recomposition takes place automatically, this is one of the advantages over the traditional View-based approach, where the developer must imperatively change the component tree.</p>
			<p>We then expanded our knowledge of the concept of modifiers. We looked at how modifier chains work and what you need to keep in mind to always get the intended results. For example, to receive clicks inside padding, <strong class="source-inline">padding {}</strong> must occur after <strong class="source-inline">clickable {}</strong> in the <strong class="source-inline">modifier</strong> chain. Finally, you learned how to implement custom modifiers.</p>
			<p>In <a href="B17505_04_ePub.xhtml#_idTextAnchor076"><em class="italic">Chapter 4</em></a>, <em class="italic">Laying Out UI Elements</em>, we will examine how to lay out UI elements and introduce you to the <strong class="bold">single measure pass</strong>. We will explore built-in layouts, but also write a custom Compose layout.</p>
		</div>
	</div></body></html>