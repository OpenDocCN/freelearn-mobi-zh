- en: Chapter 9. Memory Management and Debugging
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章：内存管理和调试
- en: 'Back in the good old days of iOS 3 and previous versions, the management of
    computer memory was a laborious affair as every pointer and memory allocation
    needed to be tracked precisely, lest you experienced the dreaded situation of
    memory leaks due to a missing `release` keycode in your code and so on. However,
    with the release of iOS 4 and higher, Apple introduced ARC and developers all
    over the world rejoiced as they thought that the days of memory management were
    over. However, sadly, this is not the case as Objective-C is not like other programming
    languages such as Java or C#, where there is a garbage collector that will do
    the memory management and garbage collection for you. ARC only serves as an enabler
    to simplify memory management for us so that we do not need to explicitly call
    the `release` method such as `[myArray release]`, since ARC handles these for
    us. So while there are less brain cells that we need to allocate for memory management
    when developing an iOS app, we must still do some basic memory management even
    with the introduction of ARC, and this chapter will help you along the way with
    that. So to get things off the ground, here are the topics that we will cover
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 回到iOS 3和之前版本的美好时光，计算机内存的管理是一项繁重的工作，因为每个指针和内存分配都需要精确跟踪，以免你遇到可怕的内存泄漏情况，这可能是由于你的代码中缺少`release`键码等原因。然而，随着iOS
    4及更高版本的发布，苹果引入了ARC，全世界的开发者都欢欣鼓舞，因为他们认为内存管理的日子已经结束了。然而，遗憾的是，情况并非如此，因为Objective-C不像Java或C#等其他编程语言那样，有一个垃圾回收器会为你进行内存管理和垃圾回收。ARC只是一种使内存管理简化的工具，这样我们就不需要显式地调用`release`方法，例如`[myArray
    release]`，因为ARC会为我们处理这些。所以，尽管在开发iOS应用时我们需要的用于内存管理的脑细胞减少了，但我们仍然需要在引入ARC后进行一些基本的内存管理，而这一章将帮助你在这个过程中。因此，为了开始，以下是本章我们将要涵盖的主题：
- en: Memory leaks
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: Strong/weak references
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强/弱引用
- en: Retain cycles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留周期
- en: Memory overuse
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存过度使用
- en: Using the debugger and breakpoints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调试器和断点
- en: Collecting data on your AppPlumbing leaks
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集AppPlumbing泄漏的数据
- en: Using the LLVM / Clang Static Analyzer
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LLVM / Clang静态分析器
- en: Using NSZombie
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用NSZombie
- en: Memory leaks
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内存泄漏
- en: 'If you are used to calling the `release` method after an `alloc`/`init` method
    or a `retain` statement, ARC allows you to forgo all that as you can still call
    your `alloc`/`init` methods or `retain` statements and not add in a `release`
    statement as ARC takes care of this for you. This introduces brevity and makes
    your code more concise. Here is an example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你习惯在`alloc`/`init`方法或`retain`语句之后调用`release`方法，ARC允许你省去这些步骤，因为即使你仍然可以调用你的`alloc`/`init`方法或`retain`语句，也不需要添加`release`语句，因为ARC会为你处理这一切。这引入了简洁性，并使你的代码更加简洁。以下是一个示例：
- en: 'Before ARC:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARC之前：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'After ARC:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在ARC之后：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: If you wrote the code without calling the `release` methods as seen under *After
    ARC*, you will have two memory leaks that will appear in your code due to you
    forgetting to put in the two `release` methods. You will notice that the number
    of lines has been reduced and the code is easier to understand, as there is no
    need to call any `release` statements. So with ARC, people will be fooled into
    thinking that their memory management woes are over, but actually, memory leaks
    can still happen with ARC and I will show you how.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你编写的代码没有调用如“在ARC之后”中看到的`release`方法，你将有两个内存泄漏出现在你的代码中，这是由于你忘记添加两个`release`方法。你会注意到行数已经减少，代码更容易理解，因为不需要调用任何`release`语句。所以，有了ARC，人们可能会误以为他们的内存管理问题已经解决，但实际上，即使有ARC，内存泄漏仍然可能发生，我将向你展示如何处理这种情况。
- en: ARC helps in that it automates the addition of `retain`/`release`/`autorelease`
    statements to your code, but memory leaks can still occur with ARC. It is not
    so obvious to spot because people think that with ARC, there will not be any memory
    leaks. However, that is not the case and memory leaks can still occur with the
    presence of ARC, but there are some methods that you can use to find memory leaks.
    However, first, let's go through some terms.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ARC有助于自动化添加`retain`/`release`/`autorelease`语句到你的代码中，但即使有ARC，内存泄漏仍然可能发生。这并不明显，因为人们认为有了ARC，就不会有任何内存泄漏。然而，情况并非如此，即使有ARC，内存泄漏仍然可能发生，但你可以使用一些方法来查找内存泄漏。然而，首先，让我们通过一些术语来了解一下。
- en: Strong/weak references
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 强/弱引用
- en: A strong reference is synonymous with the `retain` property where you increment
    the reference count of an object by 1\. In the world of ARC, the `retain` and
    `assign` properties are no longer used and are replaced with `strong` and `weak`
    respectively.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用与`retain`属性同义，即通过将对象的引用计数增加1。在ARC的世界里，`retain`和`assign`属性不再使用，分别被`strong`和`weak`所取代。
- en: A `strong` reference is the default property of objects as it means that you
    want to get ownership of an object while a `weak` reference means that another
    object is holding ownership to the object you want and then you can't stop it
    from being deallocated since ownership does not belong to you.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 强引用是对象的默认属性，因为它意味着你想要获得对象的拥有权，而弱引用意味着另一个对象正在持有你想要的对象的拥有权，然后你不能阻止它被释放，因为拥有权不属于你。
- en: 'The `strong` and `weak` references are denoted by the Objective-C `strong`
    and `weak` keyword respectively. Even with ARC, you can still have memory leaks
    appearing and some causes of memory leaks using ARC are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`强引用`和`弱引用`分别由Objective-C中的`strong`和`weak`关键字表示。即使在自动引用计数（ARC）的情况下，仍然可能出现内存泄漏，并且使用ARC的一些内存泄漏原因包括：'
- en: Retain cycles
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留周期
- en: Creating secondary threads and not providing it with its own autorelease pool
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建二级线程而不为其提供自己的自动释放池
- en: Using frameworks that have non-ARC code
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用具有非ARC代码的框架
- en: Referencing itself within a block, which creates a strong reference
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在块内部引用自身，这会创建一个强引用
- en: Retain cycles
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留周期
- en: 'A retain cycle occurs when two objects such as a parent and child object have
    strong references to each other. A simple example would be the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个对象，例如父对象和子对象，相互具有强引用时，就会发生保留周期。一个简单的例子如下代码：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'You can create an object of the type `MyParent` with the following code:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码创建`MyParent`类型的对象：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'A retain cycle is created with the preceding line of code and here is how it
    looks:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 保留周期是由前一行代码创建的，其外观如下：
- en: '![Retain cycles](img/00035.jpeg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![保留周期](img/00035.jpeg)'
- en: In the preceding diagram, you can quickly see what is called a retain cycle
    since **myParent** has a strong reference to **myChild**, and **myChild** has
    a strong reference to **myParent**. This is a form of memory leak where if an
    object tries to release an instance of the first object, it can't be released
    because the second object has a strong reference to the first object and a retain
    cycle is created. Do note that ARC will not fix all memory leaks for you, so you,
    the developer have to fix this type of memory leaks using some tools, which we
    will cover later on. As this type of memory leak is not very obvious, fixing it
    will require more effort and thinking, but thankfully, Apple has provided some
    tools that will aid us greatly in this.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，你可以快速看到所谓的保留周期，因为**myParent**对**myChild**有强引用，而**myChild**对**myParent**也有强引用。这是一种内存泄漏的形式，如果一个对象试图释放第一个对象的一个实例，由于第二个对象对第一个对象有强引用，因此无法释放，这样就创建了保留周期。请注意，ARC不会为你修复所有的内存泄漏，所以你必须，作为开发者，使用一些工具来修复这种类型的内存泄漏，我们将在后面介绍。由于这种类型的内存泄漏不是很明显，修复它需要更多的努力和思考，但幸运的是，苹果提供了一些工具，将极大地帮助我们。
- en: A general rule of thumb to avoid a situation where a retain cycle can occur
    is to remember this—if object A wants to retain object B indefinitely, then object
    A has to be higher up in the hierarchy tree than object B, where object A has
    to have a strong reference to object B. If you have objects that are on the same
    level in the hierarchy tree, then you should put a weak reference to avoid a retain
    cycle. So in the preceding diagram, to avoid a retain cycles, `mySecondObject`
    should not have a strong reference to `myFirstObject`. However, if you do need
    to let `mySecondObject` have a reference to `myFirstObject`, then make it a weak
    reference instead of a strong reference. Tree hierarchies are safe and do remember
    that putting weak references will avoid a retain cycle and memory leaks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 避免保留周期发生的一般规则是记住这一点——如果对象A想要无限期地保留对象B，那么对象A必须在层次结构树中位于对象B之上，对象A必须对对象B有强引用。如果你有在层次结构树中处于同一级别的对象，那么你应该使用弱引用来避免保留周期。所以，在前面的图中，为了避免保留周期，`mySecondObject`不应该对`myFirstObject`有强引用。然而，如果你确实需要让`mySecondObject`对`myFirstObject`有引用，那么应该将其设置为弱引用而不是强引用。树形层次结构是安全的，并且请记住，放置弱引用可以避免保留周期和内存泄漏。
- en: Memory overuse
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存过度使用
- en: If you used enough iOS apps, you will notice that some apps will just force
    close themselves after you innocuously tap on a button or do some action. This
    is an iOS way of handling memory issues as it basically just says, "this app has
    a memory leak and you do not have enough memory to handle it, so this app has
    to be closed."
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了足够的iOS应用，你将注意到一些应用在你无意识地点击按钮或执行某些操作后，会强制关闭自己。这是iOS处理内存问题的方法，它基本上就是这么说，“这个应用有内存泄漏，你没有足够的内存来处理它，所以这个应用必须关闭。”
- en: 'Altogether there are three memory warning levels for iOS. Level 1 and 2 will
    be displayed in your Xcode console when memory is running low, as shown in the
    following diagram. Level 3 occurs when your application crashes and goes back
    to Springboard, which is the term used to refer to the iOS home screen:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 总共有三个iOS内存警告级别。当内存不足时，级别1和2将在你的Xcode控制台中显示，如下所示。级别3发生在你的应用程序崩溃并返回Springboard时，这是指iOS主屏幕的术语：
- en: '![Memory overuse](img/00036.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![内存过度使用](img/00036.jpeg)'
- en: Using the debugger and breakpoints
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调试器和断点
- en: 'One of the most fundamental debugging concepts of using an IDE, such as Xcode,
    is the concept of breakpoints, where you can stop your running program at a particular
    point in time as denoted by the breakpoint where your code is. Using the breakpoint
    is very simple; you just open up your Xcode project and click on the left side
    of the window where you code it and a blue indicator will appear, as shown here:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 使用IDE，如Xcode，进行调试的最基本概念之一是断点概念，你可以通过断点在特定时间点停止你的运行程序。使用断点非常简单；你只需打开你的Xcode项目，点击窗口左侧的代码位置，就会出现一个蓝色指示器，如下所示：
- en: '![Using the debugger and breakpoints](img/00037.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![使用调试器和断点](img/00037.jpeg)'
- en: 'Next, when you run your application and when the program hits line number **26**
    at the `while(true)` statement, the program will halt and you can move your cursor
    over any variable before line number **26**, and Xcode will show you the value
    that the variable contains at that point in time. Breakpoints are useful in debugging
    memory leaks where you have an idea of where a leak appears and you want to see
    the value or memory address of that variable. You can put multiple breakpoints
    and use the Step Over command to step over each line of code to see how your program
    is executing. Here is a list of icons, that you will come across when debugging
    using breakpoints:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，当你运行你的应用程序，当程序在`while(true)`语句的行号**26**处遇到时，程序将停止，你可以在行号**26**之前将光标移到任何变量上，Xcode将显示该变量在该时间点包含的值。断点在调试内存泄漏时非常有用，其中你有一个关于泄漏出现位置的概念，并想查看该变量的值或内存地址。你可以设置多个断点，并使用“单步执行”命令来逐行执行代码，以查看程序的执行情况。以下是在使用断点调试时可能会遇到的图标列表：
- en: '![Using the debugger and breakpoints](img/00038.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![使用调试器和断点](img/00038.jpeg)'
- en: 'The four icons from the left to right in the preceding screenshot that you
    can use for breakpoint debugging are as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，从左到右的四个图标，你可以用于断点调试，如下所示：
- en: '| Icons | Description |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 图标 | 描述 |'
- en: '| --- | --- |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Continue program execution | This will let your program continue executing
    until it encounters the next breakpoint, or the program ends |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 继续程序执行 | 这将使你的程序继续执行，直到遇到下一个断点或程序结束 |'
- en: '| Step Over | This will let your program execute the next line of code in the
    current scope |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 单步执行 | 这将使你的程序在当前作用域中执行下一行代码 |'
- en: '| Step Into | This will let your program follow the method into its own code
    and view the code for the method |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 步入 | 这将使你的程序跟随方法进入其自身的代码并查看方法的代码 |'
- en: '| Step Out | This will take you out of the current context and into calling
    a method one step up into the program stack |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 跳出 | 这将带你从当前上下文退出，并调用程序堆栈中一个步骤向上的方法 |'
- en: Breakpoints are very useful for checking the values of your variables at a specific
    point in time when your program is halted due to the breakpoint and the four icons
    for breakpoint debugging will aid you in debugging memory-related and other logic
    bugs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 断点在检查程序由于断点而停止时变量在特定时间点的值时非常有用。当内存不足时，Xcode控制台将显示四个用于断点调试的图标，以帮助你调试与内存相关的和其他逻辑错误。
- en: Collecting data on your app
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 收集你的应用数据
- en: Do note that a memory warning level does not necessarily mean that your application
    is leaking memory. There could be a situation where your application is loading
    or performing operations on large resources such as data files, images, videos,
    and so on and this will trigger the memory warning. ARC will handle the cleaning
    up later. However, if you see a memory warning level 2, then you should start
    to look at your code as the next memory warning level will be the actual application
    crash.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，内存警告级别并不一定意味着你的应用程序正在泄漏内存。可能存在这样的情况，即你的应用程序正在加载或对大型资源（如数据文件、图像、视频等）执行操作，这将触发内存警告。ARC将在稍后处理清理工作。然而，如果你看到内存警告级别为2，那么你应该开始检查你的代码，因为下一个内存警告级别将是实际的应用程序崩溃。
- en: Debugging crashes and memory leaks are like the game of hide and seek or playing
    detective. There will be a lot of clues lying around, which will lead you to the
    culprit in your code that is causing a bothersome crash or memory leak. Apple
    has provided us with a lot of tools and logs, which will be useful for us in debugging
    our code. We will cover some of the commonly used methods here so that you can
    get cracking with regards to fixing those problems as soon as possible.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 调试崩溃和内存泄漏就像捉迷藏或扮演侦探的游戏。周围会有很多线索，这些线索将引导你找到代码中导致令人烦恼的崩溃或内存泄漏的罪魁祸首。苹果为我们提供了许多工具和日志，这些工具和日志将对我们调试代码非常有用。我们将在这里介绍一些常用的方法，以便你能够尽快开始修复这些问题。
- en: 'One of the easier ways is to plug your device into your machine via your cable,
    fire up Xcode, which will automatically detect your plugged-in device and then
    press *Shift* + *Command* + *C* to activate your debug console, which is a black
    screen on the bottom right of your Xcode screen. Or you can select **View** |
    **Debug Area** | **Activate Console** from your Xcode menu as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一种较简单的方法是通过你的电缆将你的设备连接到你的机器，启动Xcode，它将自动检测你连接的设备，然后按*Shift* + *Command* +
    *C*激活你的调试控制台，这是一个位于Xcode屏幕右下角的黑色屏幕。或者，你可以从Xcode菜单中选择**视图** | **调试区域** | **激活控制台**，如下所示：
- en: '![Collecting data on your app](img/00039.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![收集应用程序数据](img/00039.jpeg)'
- en: This will show all NSLog and crash output when you are running your app via
    a cable connection to Xcode.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示当你通过电缆连接到Xcode运行应用程序时所有的NSLog和崩溃输出。
- en: However, there are occasions when you are testing your application, when it
    is not connected to your Xcode and it crashes at that moment. The preceding method
    does not work in this case, so what can you do? Do not fret, as there is another
    way to get your crash log once you are at your table and have plugged your iOS
    device into your machine and fired up Xcode.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在测试你的应用程序时，有时它并未连接到你的Xcode，而在那一刻崩溃。在这种情况下，前面提到的方法不起作用，那么你该怎么办呢？不要担心，一旦你回到你的桌子前，将你的iOS设备连接到你的机器并启动Xcode，你就有另一种方法获取崩溃日志。
- en: 'Once you have started Xcode and plugged in your device where your app crashed,
    Xcode will actually be able to access your crash log on the device. To do so,
    all you need to do is click on the window and select **Organizer** from your Xcode
    menu, as shown in the following screenshot:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你启动了Xcode并将你的设备连接到应用程序崩溃的地方，Xcode实际上能够访问设备上的崩溃日志。为此，你只需要点击窗口并从Xcode菜单中选择**组织者**，如下面的截图所示：
- en: '![Collecting data on your app](img/00040.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![收集应用程序数据](img/00040.jpeg)'
- en: This will open your **Organizer**, which actually is a repository of all the
    devices that have been connected to Xcode and shows information such as the application's
    provisioning profile and screenshots. However, what we are really interested in
    is the crash logs.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开你的**组织者**，它实际上是一个所有连接到Xcode的设备的仓库，显示了有关应用程序的配置文件和截图等信息。然而，我们真正感兴趣的是崩溃日志。
- en: So, click on the **Devices** button at the top and you will be shown all the
    developer information about all the devices that have connected to your device
    so far.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，点击顶部的**设备**按钮，你将看到迄今为止连接到你的设备的所有设备开发者信息。
- en: 'Click on your currently connected device, which is denoted by a green circle.
    Then, select the **Device Logs** option, which will then open another list of
    apps that have crashed. There you can sort the results by **Process**, which is
    the application name, **Type**, or **Date/Time**. Clicking on an item will reveal
    the crash log on the right side of the screen. There you can see the backtrace,
    which is actually a listing of all the methods that were called leading up to
    your crash. The last section of the code that caused your crash will be at the
    top of the backtrace, and you should start by looking from the bottom up to see
    how your app works and see all the functions and methods that it traversed through
    leading up to the crash:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 点击你当前连接的设备，它由一个绿色圆圈表示。然后，选择**设备日志**选项，这将打开一个包含已崩溃应用程序的另一个列表。在那里，你可以按**进程**（应用程序名称）、**类型**或**日期/时间**对结果进行排序。点击一个项目将在屏幕右侧显示崩溃日志。在那里，你可以看到回溯，它实际上是所有在崩溃前被调用的方法的列表。导致你崩溃的代码的最后一部分将在回溯的顶部，你应该从底部开始查看，以了解你的应用程序是如何工作的，以及它穿越的所有函数和方法：
- en: '![Collecting data on your app](img/00041.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![收集应用程序数据](img/00041.jpeg)'
- en: Plumbing memory leaks
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道内存泄漏
- en: 'Next, we will look at a special tool present in Xcode to get in-depth information
    about your app while it is running. This special tool is actually a suite of tools
    that can perform the following functions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看 Xcode 中一个特殊的工具，在应用程序运行时获取有关应用程序的详细信息。这个特殊工具实际上是一套工具，可以执行以下功能：
- en: Examine and monitor one or more processes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查和监控一个或多个进程
- en: Record a sequence of user actions and replay them, just like a video recorder
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录一系列用户操作并回放它们，就像录像机一样
- en: Save user interface recordings and then access them from Xcode
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存用户界面录制并从 Xcode 中访问它们
- en: This set of tools is known collectively as Instruments and they are more useful
    than NSLogs when tracking down difficult-to-reproduce bugs, such as random crashes
    and debugging memory leaks
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这套工具统称为 Instruments，它们在追踪难以复现的bug（如随机崩溃和调试内存泄漏）时比NSLogs更有用。
- en: Analyze the performance of your app
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析你的应用程序性能
- en: Perform stress testing on your app
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对你的应用程序进行压力测试
- en: Gain a better understanding of how your application works
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更好地了解你的应用程序是如何工作的
- en: 'In this section, I will teach you the basics of Instruments and how to debug
    some code using it. So, to start off, you just need to follow these three simple
    steps:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将教你 Instruments 的基础知识以及如何使用它来调试一些代码。所以，为了开始，你只需要遵循这三个简单的步骤：
- en: Click the **Xcode** menu on the top left of your Xcode IDE.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 Xcode IDE 左上角的**Xcode**菜单。
- en: Select **Open Developer Tool** from the list that appears.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的列表中选择**打开开发者工具**。
- en: A submenu will appear with the **Instruments** item, which you should click
    on:![Plumbing memory leaks](img/00042.jpeg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会弹出一个子菜单，其中包含**Instruments**项，你应该点击它：![管道内存泄漏](img/00042.jpeg)
- en: Then, you should see a pop-up window with the following options:![Plumbing memory
    leaks](img/00043.jpeg)
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你应该会看到一个弹出窗口，其中包含以下选项：![管道内存泄漏](img/00043.jpeg)
- en: There are options such as **Leaks**, **Allocations**, and **Time Profiler**,
    which show all the various tools.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有如**泄漏**、**分配**和**时间分析器**等选项，它们显示了所有各种工具。
- en: To have a little test run, open the `Instruments.xcodeproj` file, which has
    very leaky code and we will see how to use the Xcode debugging tool called **Instruments**
    to understand how the memory allocation spikes up when the code is running. So,
    to start things off, let's use the Xcode profiling tool to see our memory spike
    by clicking on the **Product** | **Profile** menu option as shown here:![Plumbing
    memory leaks](img/00044.jpeg)
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了进行一个小测试运行，打开`Instruments.xcodeproj`文件，它有非常泄漏的代码，我们将看到如何使用 Xcode 调试工具**Instruments**来理解代码运行时内存分配峰值。所以，为了开始，让我们使用
    Xcode 性能分析工具通过点击**产品** | **分析**菜单选项来查看我们的内存峰值，如图所示：![管道内存泄漏](img/00044.jpeg)
- en: Then, Xcode will show the **Instruments** window and then you need to select
    **Allocations** options and click on the **Profile** button. Once you have clicked
    the **Profile** button, the leaky app will start executing and you will see the
    following screen. Keep an eye on the graph that you will see spiking up rapidly
    and also the **All Heap Allocations** row, which will show the amount of memory
    being consumed increasing in a very fast rate:![Plumbing memory leaks](img/00045.jpeg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，Xcode将显示**仪表**窗口，然后您需要选择**分配**选项并点击**分析**按钮。一旦点击了**分析**按钮，泄漏的应用程序将开始执行，您将看到以下屏幕。注意您将看到的快速上升的图表以及**所有堆分配**行，它将显示内存消耗以非常快的速度增加：![管道内存泄漏](img/00045.jpeg)
- en: 'So, to reiterate the steps, we need to do the following:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了重申步骤，我们需要做以下几件事：
- en: Open Xcode.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Xcode。
- en: Click on **Product** | **Profile**.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**产品** | **配置文件**。
- en: Click on **Allocations** | **Profile**.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**分配** | **配置文件**。
- en: Look at the **All Heap Allocations** section.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看**所有堆分配**部分。
- en: Look at the memory allocation on the graph.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 查看图上的内存分配。
- en: Check for retain cycles or usages of itself within blocks that can hint or create
    a retain cycle.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查块内部是否存在自身保留周期或使用，这可能会提示或创建一个保留周期。
- en: Using the LLVM / Clang Static Analyzer
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LLVM / Clang静态分析器
- en: The Instruments suite of tools is meant to be used when your app is running.
    However, sometimes, as the saying goes, *an ounce of prevention is worth a pound
    of cure*. So, before you pull up Instruments to debug your app during runtime,
    there is a good step that you should follow and which is performing a static analysis
    on your code base.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments工具套件旨在在您的应用程序运行时使用。然而，正如俗话所说，“预防胜于治疗”。因此，在您拉起Instruments以在运行时调试应用程序之前，有一个很好的步骤您应该遵循，那就是对您的代码库执行静态分析。
- en: Static analysis is a mechanism where a collection of algorithms and techniques
    are used to analyze your source code to find bugs. This may sound like what you
    do during the compilation stage, but there is an important difference. The act
    of compiling your code will tell Xcode to check your code base for syntax errors
    and flag out any errors or warnings that it detects. Static analysis goes one
    step deeper in that it analyzes your code to find potential bugs that will surface
    during runtime. Static analysis lets the program calculate all possible executions
    of a program, and the code is analyzed for quality, safety, and security so that
    you are alerted to bugs such as overflows, divide by zero, pointer errors, and
    so on. So, think of static analysis as runtime testing, but before your code has
    begun executing.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 静态分析是一种机制，其中使用一系列算法和技术来分析您的源代码以查找错误。这听起来可能像是您在编译阶段所做的事情，但这里有一个重要的区别。编译您的代码将告诉Xcode检查您的代码库中的语法错误，并标记出它检测到的任何错误或警告。静态分析更进一步，因为它分析您的代码以找到在运行时可能出现的潜在错误。静态分析允许程序计算程序的所有可能的执行情况，并对代码进行质量、安全性和安全性分析，以便您能够被提醒有关溢出、除以零、指针错误等问题。因此，将静态分析视为运行时测试，但是在您的代码开始执行之前。
- en: 'As static analysis goes deeper into your code, the amount of time Xcode takes
    to do the static analysis will be longer. So, use static analysis only for debugging
    hard-to-fix bugs or as a final step before submitting your app to the iTunes App
    Store. To activate static analysis of your app, click on **Product** | **Analyze**
    to let Xcode start its static analysis of your code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 随着静态分析深入到您的代码，Xcode进行静态分析所需的时间将会更长。因此，仅将静态分析用于调试难以修复的错误，或在将应用程序提交到iTunes App
    Store之前作为最终步骤。要激活应用程序的静态分析，请点击**产品** | **分析**，让Xcode开始对您的代码进行静态分析：
- en: '![Using the LLVM / Clang Static Analyzer](img/00046.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![使用LLVM / Clang静态分析器](img/00046.jpeg)'
- en: Depending on the size of your code base, static analysis can take seconds to
    even minutes while it dives deep into your code to ferret out any potential issues.
    A project that has only a few lines of code will take a few seconds to do the
    static analysis while a large project with thousands of lines of code will take
    a few minutes or more, depending on the size of the project. Then, click on the
    left side of your Xcode screen as shown in the preceding screenshot, to see the
    potential issues that Xcode found through static analysis.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的代码库的大小，静态分析可能需要几秒钟到几分钟，因为它深入到您的代码中，以挖掘出任何潜在的问题。只有几行代码的项目进行静态分析可能只需几秒钟，而拥有数千行代码的大型项目可能需要几分钟或更长时间，具体取决于项目的大小。然后，点击Xcode屏幕左侧，如图所示，以查看Xcode通过静态分析发现的潜在问题。
- en: 'By default, static analysis goes down to a deep level to analyze every corner
    of your code base. This consumes a lot of resources on your machine, and if you
    have a large code base or a slow machine, the amount of time used for static analysis
    can be quite big. Hence, you can adjust the level of static analysis that Xcode
    uses if you don''t want an in-depth analysis, which may not find as many issues
    as a deep static analysis, but can still help surface some issues. Static analysis
    is useful as it can surface errors such as overflows, divide by zero, and so on,
    which a compiler can''t detect. To change the level of static analysis, click
    on your project on the left, then select **Build Settings** and then look for
    the **Mode of analysis for ''Analyze''** option and set it to **Shallow (faster)**
    as shown here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，静态分析会深入到代码库的每个角落。这会在你的机器上消耗大量资源，如果你有一个大的代码库或者一个慢速的机器，静态分析所用的时间可能会相当长。因此，如果你不想进行深入分析，你可以调整
    Xcode 使用的静态分析级别，这样可能不会发现像深度静态分析那样多的问题，但仍然可以帮助暴露一些问题。静态分析很有用，因为它可以暴露出编译器无法检测到的错误，如溢出、除以零等。要更改静态分析的级别，请点击左侧的项目，然后选择
    **构建设置**，然后查找 **'分析' 的分析模式**选项，并将其设置为 **浅层（更快）**，如图所示：
- en: '![Using the LLVM / Clang Static Analyzer](img/00047.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![使用 LLVM / Clang 静态分析器](img/00047.jpeg)'
- en: Using NSZombie
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NSZombie
- en: Last but not least, let me introduce you to the concept of NSZombie. NSZombie
    is a memory debugging aid that helps you in debugging memory leaks. As you may
    know, when an object has a retain count of 0, that object will be deallocated
    and not exist anymore. However, if you enable NSZombie, the object with a retain
    count of 0 will turn into a NSZombie instance instead. Then, when this NSZombie
    receives a message from another place in your code, it will show a warning instead
    of crashing your app or exhibiting unpredictable behavior.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，让我向你介绍 NSZombie 的概念。NSZombie 是一种内存调试辅助工具，可以帮助你在调试内存泄漏时。正如你所知，当一个对象的保留计数为
    0 时，该对象将被释放并不再存在。然而，如果你启用了 NSZombie，保留计数为 0 的对象将变成 NSZombie 实例。然后，当这个 NSZombie
    从你的代码的另一个地方收到消息时，它将显示警告而不是使你的应用崩溃或表现出不可预测的行为。
- en: NSZombie is useful for debugging subtle overrelease or autorelease bugs as these
    types of bugs tend to manifest itself in crashes or weird behavior. NSZombie will
    show these crashes and weird behavior as a warning instead, which will help in
    your debugging.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: NSZombie 对于调试微妙的过度释放或 autorelease 错误很有用，因为这些类型的错误往往会表现为崩溃或奇怪的行为。NSZombie 将将这些崩溃和奇怪的行为显示为警告，这有助于你的调试。
- en: NSZombies exist in a strange half-alive/half-dead state as they are not deallocated
    when the retain count is 0, but they are not fully alive either. So, NSZombie
    is an apt term to use to describe these half-living/half-dead objects.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: NSZombies 处于一种奇怪的半存活/半死亡状态，因为当保留计数为 0 时，它们不会被释放，但它们也不是完全活着的。因此，NSZombie 是一个合适的术语，用来描述这些半活/半死的对象。
- en: 'However, an important point to note is that NSZombies are to be disabled once
    you have finished debugging. NSZombies consume memory like any object with a retain
    count of 0, which is turned into NSZombie, which still occupies memory instead
    of being deallocated. So, if you do not disable NSZombie it will occupy more memory.
    In order to harness the power of NSZombie where it will log a warning instead
    of crashing your app or exhibiting unpredictable behavior, just follow these simple
    steps to activate NSZombie:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个需要注意的重要点是，一旦你完成调试，就应该禁用 NSZombies。NSZombies 消耗内存，就像保留计数为 0 的任何对象一样，它们被转换成
    NSZombie，仍然占用内存而不是被释放。所以，如果你不禁用 NSZombie，它将占用更多的内存。为了利用 NSZombie 的力量，使其记录警告而不是使你的应用崩溃或表现出不可预测的行为，只需遵循以下简单步骤来激活
    NSZombie：
- en: Click on the **Product** menu in your Xcode IDE.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的 Xcode IDE 中点击 **产品** 菜单。
- en: Select the **Scheme** menu item.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **方案** 菜单项。
- en: Proceed to click on **Edit Scheme...** to open the popup to enable NSZombie:![Using
    NSZombie](img/00048.jpeg)
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 继续点击 **编辑方案...** 以打开弹出窗口启用 NSZombie：![使用 NSZombie](img/00048.jpeg)
- en: Then, you will see a popup appear with an **Enable Zombie Objects** option.
    Click on this checkbox and NSZombie will be enabled.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你会看到一个带有 **启用僵尸对象** 选项的弹出窗口出现。点击此复选框，NSZombie 将被启用。
- en: Finally, run your project and you will see NSZombie in action:![Using NSZombie](img/00049.jpeg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行你的项目，你将看到 NSZombie 在行动中：![使用 NSZombie](img/00049.jpeg)
- en: 'Finally, here is a table outlining which debugging tools should be used in
    which context so that you can use the right tool for the right situation:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一个表格概述了在哪种情况下应该使用哪种调试工具，以便你可以根据情况使用正确的工具：
- en: '| Debugging tool | Appropriate context |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 调试工具 | 适当的上下文 |'
- en: '| --- | --- |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Xcode Instruments | This is used to find memory leaks that cause crashes
    during runtime |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Xcode Instruments | 这用于在运行时找到导致崩溃的内存泄漏 |'
- en: '| Static Analyzer | This is used to analyze your code base for issues such
    as divide by 0, memory issues before the code is executed, and so on |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 静态分析器 | 这用于在代码执行前分析代码库中的问题，例如除以0、内存问题等 |'
- en: '| NSZombie | This is used to show warnings instead of crashing due to memory
    leaks |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| NSZombie | 这用于显示警告而不是因为内存泄漏而崩溃 |'
- en: Summary
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We covered some aspects of the theory of memory management, such as retain cycles
    and strong/weak references. Then, we moved to the repercussions of memory leaks
    and the various warning levels. Following this, we discovered how to get crash
    logs to help you get information about your app and code. We then looked at a
    list of the various tools that Xcode possesses, such as Instruments and NSZombies,
    which will help us to debug memory leaks that can be caused by a myriad of causes,
    such as not releasing objects or releasing objects prematurely. Finally, we closed
    off with a description of static analysis and enabling NSZombies and their uses.
    With all these tools and information at your fingertips, I hope debugging memory
    leaks and errors have been made much easier for you since you have the tools required
    to make this a less painful journey.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们讨论了内存管理理论的一些方面，例如保留循环和强/弱引用。然后，我们转向内存泄漏的后果和不同的警告级别。在此之后，我们发现了如何获取崩溃日志以帮助您获取有关您的应用程序和代码的信息。然后，我们查看了一系列Xcode拥有的各种工具列表，例如Instruments和NSZombies，这些工具将帮助我们调试由多种原因引起的内存泄漏，例如未释放对象或过早释放对象。最后，我们以静态分析、启用NSZombies及其用途的描述作为结束。有了所有这些工具和信息，我希望调试内存泄漏和错误对您来说已经变得更加容易，因为您拥有了完成这项任务所需的所有工具，使这个过程不再那么痛苦。
- en: In the next chapter, we will cover some developer tips for memory management,
    such as getters, setters, and other tips. So, let's head to the next chapter.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍一些关于内存管理的开发者技巧，例如获取器、设置器和其他技巧。那么，让我们进入下一章。
