["```swift\n    @IBOutlet weak var nameTextField: UITextField!\n    @IBOutlet weak var addressTextField: UITextField!\n    @IBOutlet weak var postCodeTextField: UITextField!\n    @IBOutlet weak var phoneTextField: UITextField!\n    ```", "```swift\n    class Card {\n        private let TEMPLATE = \"<div class=\\\"personalcard\\\">\" + \"<p class=\\\"name\\\">#name#</p>\" + \"<p class=\\\"address\\\">#address#</p>\" + \"<p class=\\\"postcode\\\">#postcode#</p>\" + \"<p class=\\\"phone\\\">#phone#</p>\" + \"</div\"\n\n        var name:String?\n        var address:String?\n        var postCode:String?\n        var phone:String?\n\n        init(){}\n    }\n    ```", "```swift\n    @IBAction func showHTML(sender: AnyObject) {\n      var card = Card()\n\n      card.name = nameTextField.text\n      card.address = addressTextField.text\n      card.postCode = postCodeTextField.text\n      card.phone = phoneTextField.text\n\n      let alert = UIAlertController(title: \"HTML\", message: card.toHtml(), preferredStyle:.Alert)\n      self.presentViewController(alert, animated: true, completion: nil)\n    }\n    ```", "```swift\n    func toHtml() -> String{\n      var html = TEMPLATE.stringByReplacingOccurrencesOfString(\"#name#\", withString: self.name!)\n      .stringByReplacingOccurrencesOfString(\"#address#\", withString: self.address!)\n      .stringByReplacingOccurrencesOfString(\"#postcode#\", withString: self.postCode!)\n      .stringByReplacingOccurrencesOfString(\"#phone#\", withString: self.phone!)\n      return html;\n    }\n    ```", "```swift\n    class Product: CustomStringConvertible{\n      var price:Double?\n      var name: String\n      var manufacturer: String\n\n      init(name: String, manufacturer: String){\n        self.name = name\n        self.manufacturer = manufacturer\n      }\n\n      var description:String {\n        return \"\\(self.name) (\\(self.manufacturer))\"\n      }\n    }\n    ```", "```swift\n      private let television = Product(name: \"Television\", manufacturer: \"Telefunken\")\n      private let gabion = Product(name: \"Gabion\", manufacturer: \"Maccaferri\")\n      private let locker = Product(name: \"Locker\", manufacturer: \"Danalockers\")\n    ```", "```swift\n    func doubleFormatter(value: Double) -> String{\n      return String(format: \"%.2f\", value)\n    ```", "```swift\n    @IBAction func showDescription(sender: UIButton) {\n      var message:String\n      var product: Product\n\n      if sender.titleLabel?.text == \"Television\"{\n        product = television\n      }else if sender.titleLabel?.text == \"Gabion\" {\n        product = gabion\n      }else if sender.titleLabel?.text == \"Locker\"{\n        product = locker\n      }else{\n        return\n      }\n      message = \"You've chosen \\(product)\"\n\n      if let price = product.price {\n        message += \" which costs \\(doubleFormatter(price * 1.20)))\"\n      }\n\n        let alert = UIAlertController(title: \"Product information\", message: message, preferredStyle:.Alert)\n                   self.presentViewController(alert, animated: true, completion: nil)\n    ```", "```swift\nextension Double {\n    func precision(numDigits: Int) -> String {\n        return NSString(format: \"%.\\(numDigits)f\", self)\n    }\n}\n```", "```swift\nmessage += \" which costs \\((price * 1.20).precision(2)))\"Adding different characters\n```", "```swift\n    class Quiz {\n        var question:String\n        // First possible answer\n        var ‚ë†:String\n        // second possible answer\n        var ‚ë°:String\n        // third possible answer\n        var ‚ë¢:String\n        // Right answer\n        var üëå:Int\n\n        init(question:String, ‚ë†:String, ‚ë°:String, ‚ë¢:String, üëå:Int){\n            self.question = question\n            self.‚ë† = ‚ë†\n            self.‚ë° = ‚ë°\n            self.‚ë¢ = ‚ë¢\n            self.üëå = üëå\n        }\n    }\n    ```", "```swift\n    class QuizManager {\n        private var quizzes:[Quiz] = []\n        private var currentQuestion = 0\n        // Total right answers\n        private var üëç = 0\n        // Total wrong answers\n        private var üëé = 0\n\n        func addQuiz(quiz:Quiz) {\n            self.quizzes.append(quiz)\n        }\n\n        func getCurrentQuestion() -> Quiz? {\n            if currentQuestion < quizzes.count {\n                return self.quizzes[currentQuestion]\n            }\n            return nil\n        }\n\n        // Answer to the current question.\n        // Returns true if it was the right answer\n        func answer(questionNumber:Int) -> Bool{\n            var rightAnswer:Bool\n            if getCurrentQuestion()!.üëå == questionNumber {\n                rightAnswer = true\n                üëç++\n            }else {\n                rightAnswer = false\n                üëé++\n            }\n            return rightAnswer\n        }\n\n        func getüëç() -> Int {\n            return üëç\n        }\n\n        func getüëé() -> Int {\n            return üëé\n        }\n    }\n    ```", "```swift\n        @IBOutlet var questionLabel: UILabel!\n        @IBOutlet var timerLabel: UILabel!\n        @IBOutlet var answer‚ë†Button: UIButton!\n        @IBOutlet var answer‚ë°Button: UIButton!\n        @IBOutlet var answer‚ë¢Button: UIButton!\n        var quizTimer: NSTimer?\n        var elapsedTime:Int\n        var quizManager:QuizManager\n    ```", "```swift\n        required init(coder: NSCoder) {\n            self.elapsedTime = 0\n            quizManager = QuizManager()\n            super.init(coder: coder)\n            setupQuizManager()\n\n        }\n    private func setupQuizManager(){\n            quizManager.addQuiz(Quiz(question: \"What's the capital of Australia?\", ‚ë†: \"Sidney\", ‚ë°: \"Melbourne\", ‚ë¢: \"Canberra\", üëå: 3))\n            quizManager.addQuiz(Quiz(question: \"What is the smallest planet in the solar system?\", ‚ë†: \"The moon\", ‚ë°: \"Mercury\", ‚ë¢: \"The sun\", üëå: 2))\n            quizManager.addQuiz(Quiz(question: \"In which year was Harley Davison founded?\", ‚ë†: \"1903\", ‚ë°: \"2013\", ‚ë¢: \"80BC\", üëå: 1))\n        }\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n            prepareNextQuestion()\n        }\n        private func prepareNextQuestion(){\n            if quizTimer != nil {\n                quizTimer!.invalidate()\n            }\n            guard let quiz = quizManager.getCurrentQuestion() else {\n                   let message = \"Total \\u{1F44D} \\(quizManager.getüëç())\\nTotal \\u{1F44E} \\(quizManager.getüëé())\"\n                    let alert = UIAlertController(title: \"Product information\", message: message, preferredStyle:.Alert)\n                    self.presentViewController(alert, animated: true, completion: nil)\n                    return\n                }\n\n                elapsedTime = 0\n                questionLabel.text = quiz.question\n                answer1Button.setTitle(quiz.1, forState:.Normal)\n                answer2Button.setTitle(quiz.2, forState:.Normal)\n                answer3Button.setTitle(quiz.3, forState:.Normal)\n        }\n    ```", "```swift\n        func tick(){\n            guard elapsedTime < 12 else {\n                    quizManager.answer(0)\n                    prepareNextQuestion()\n            return\n                }\n\n               let baseCharCode = 0x1F550\n               timerLabel.text = String(Character(UnicodeScalar(baseCharCode + elapsedTime)))\n               elapsedTime++\n        }\n    ```", "```swift\n        @IBAction func answer(sender: UIButton) {\n            var userAnswer:Int\n            switch(sender){\n            case answer‚ë†Button:\n                userAnswer = 1\n            case answer‚ë°Button:\n                userAnswer=2\n            case answer‚ë¢Button:\n                userAnswer=3\n            default:\n                userAnswer = 0\n            }\n            quizManager.answer(userAnswer)\n            prepareNextQuestion()   \n        }\n    ```", "```swift\n        @IBOutlet var startText: UITextField!\n        @IBOutlet var endText: UITextField!\n    ```", "```swift\n        func isPerfect(number:Int) -> Bool {\n            var sum = 0\n                  (1..<number).forEach { (i) -> () in\n              if number % i == 0 {\n                  sum += i\n              }\n           return sum == number\n        }\n\n        @IBAction func search(sender: UIButton) {\n            var rangeStart:Int = startText.text.toInt()!\n            var rangeEnd:Int = endText.text.toInt()!\n            for i in rangeStart ... rangeEnd {\n                if isPerfect(i){\n                  let alert = UIAlertController(title: \"Found\", message: \"\\(i) is a perfect number\"), preferredStyle:.Alert)\n     self.presentViewController(alert, animated: true, completion: nil)\n\n                  return\n                }\n            }\n\n            let message = \"No perfect  number found between \\(rangeStart) and \\(rangeEnd)\"\n     let alert = UIAlertController(title: \"HTML\", message: message, preferredStyle:.Alert)\n     self.presentViewController(alert, animated: true, completion: nil)\n        }\n    ```", "```swift\n    class Product: CustomStringConvertable {\n        var name:String\n        var price:Double\n        var available:Bool\n\n        init(name:String, price:Double, available:Bool){\n            self.name = name\n            self.price = price\n            self.available = available\n        }\n\n        var description: String {\n            return \"\\(self.name): \\(self.price)¬£ available: \\(self.available)\"\n        }\n    }\n    ```", "```swift\n        var products:[Product] = [] // this is our catalog\n        @IBOutlet var catalogLabel: UILabel!\n        @IBOutlet var availableLabel: UILabel!\n    ```", "```swift\n    required init(coder aDecoder: NSCoder) {\n        super.init(coder: aDecoder)\n        products.append(Product(name: \"Shirt\", price: 19, available: true))\n        products.append(Product(name: \"Socks\", price: 1.99, available: true))\n        products.append(Product(name: \"Trousers\", price: 22.50, available: false))\n        products.append(Product(name: \"T-Shirt\", price: 10, available: true))\n        products.append(Product(name: \"Shoes\", price: 32.20, available: false))\n        products.append(Product(name: \"Women shoes\", price: 54, available: true))\n        products.append(Product(name: \"Men underwear\", price: 9.99, available: true))\n        products.append(Product(name: \"Bra\", price: 12.5, available: true))\n        products.append(Product(name: \"Panty\", price: 4.45, available: true))\n        products.append(Product(name: \"Tennis shoes\", price: 27, available: false))\n    }\n    ```", "```swift\n        override func viewDidLoad() {\n            super.viewDidLoad()\n      let descriptions = products.map{$0.description}\n      let labelText = descriptions.joinWithSeperator(\"\")\n            catalogLabel.text = labelText\n        }\n    ```", "```swift\n        @IBAction func showAvailableProducts(sender: UIButton) {\n            var availableProducts = products.filter { (product:Product) -> Bool in\n                return product.available\n            }\n            availableProducts.sort(<) \n      let descriptions = availableProducts.map{$).description}\n      let labelText = descriptions.joinWithSeperator(\" \") \n\n            availableLabel.text = labelText\n        }\n    ```", "```swift\n    enum BlockType{\n        case AISLE,\n             WALL,\n             USED,\n             WAYOUT\n    }\n    ```", "```swift\n    typealias Position = (x: Int, y:Int)\n    typealias Way = (found: Bool, way: [Position])\n    ```", "```swift\n    class Maze{\n        private var maze:[[BlockType]] = []\n        private lazy var stack:[Position] = []\n        private var width: Int\n        private var height: Int\n    ```", "```swift\n        init(width: Int, height: Int){\n            self.width = width\n            self.height = height\n            for _ in 1...height{\n                var row:[BlockType] = []\n                for _ in 1...width{\n                    row.append(.AISLE)\n                }\n                maze.append(row)\n            }\n        }\n    ```", "```swift\n        func addWall(position: Position) {\n            maze[position.y][position.x] = .WALL\n        }\n\n        func setWayout(position: Position){\n            maze[position.y][position.x] = .WAYOUT\n        }\n    ```", "```swift\n        func findWayOut() -> Way{\n            self.initStack()\n            return self.next((0,0))\n        }\n\n        private func next(position: Position) -> Way {\n\n            stack.append(position)\n            if self.maze[position.y][position.x] == .WAYOUT {\n                return (true, self.stack)\n            }\n\n            maze[position.y][position.x] = .USED\n\n            // UP\n            if position.y > 0 && (maze[position.y-1][position.x] == .AISLE || maze[position.y-1][position.x] == .WAYOUT)\n            {\n                let result = next((position.x, position.y-1))\n                if result.found {\n                    maze[position.y][position.x] = .AISLE\n                    return result\n                }\n            }\n\n            // LEFT\n            if position.x > 0 && (maze[position.y][position.x-1] == .AISLE || maze[position.y][position.x-1] == .WAYOUT)\n            {\n                let result = next((position.x-1, position.y))\n                if result.found {\n                    maze[position.y][position.x] = .AISLE\n                    return result\n                }\n            }\n\n            // DOWN\n            if position.y+1 < self.height && (maze[position.y+1][position.x] == .AISLE || maze[position.y+1][position.x] == .WAYOUT)\n            {\n                let result = next((position.x, position.y+1))\n                if result.found {\n                    maze[position.y][position.x] = .AISLE\n                    return result\n                }\n            }\n\n            // RIGHT\n            if position.x+1 < self.width && (maze[position.y][position.x+1] == .AISLE || maze[position.y][position.x+1] == .WAYOUT)\n            {\n                let result = next((position.x+1, position.y))\n                if result.found {\n                    maze[position.y][position.x] = .AISLE\n                    return result\n                }\n            }\n\n            maze[position.y][position.x] = .AISLE\n            stack.removeLast()\n\n            return (false, [])\n        }\n\n        private func initStack(){\n            stack = []\n        }\n    }\n    ```", "```swift\n        @IBAction func findWayOut(sender: UIButton) {\n            var resultString = \"\"\n            var maze = Maze(width: 8, height: 5)\n            maze.setWayout((7,4))\n            maze.addWall((1,0))\n            maze.addWall((1,1))\n            maze.addWall((1,2))\n            maze.addWall((1,4))\n            maze.addWall((3,0))\n            maze.addWall((3,1))\n            maze.addWall((3,3))\n            maze.addWall((4,3))\n            maze.addWall((5,1))\n            maze.addWall((5,3))\n            maze.addWall((6,1))\n            maze.addWall((6,3))\n            maze.addWall((6,4))\n            maze.addWall((7,1))\n            let (found:Bool, way:[Position]) = maze.findWayOut()\n            if found {\n                for position in way {\n                    resultString+= \"(\\(position.x),\\(position.y)) \\n\"\n                }\n            }else{\n                resultString+=\"No path found\"\n            }\n            textView.text = resultString\n        }\n    ```", "```swift\nmaze = [[BlockType]](count: height, repeatedValue: [BlockType](count: width, repeatedValue: .AISLE))\n```", "```swift\n    class ShoppingList: CustomStringConvertable {\n        class Product: Comparable, CustomStringConvertable {\n            var name:String\n            lazy var quantity:Int = 1\n\n            init(_ name:String){\n                self.name = name\n            }\n\n            var description: String {\n                return \"\\(name): \\(quantity)\"\n            }\n        }\n    ```", "```swift\n    private var set:[Product] = []\n    ```", "```swift\n        func contains(product: Product)-> Bool{\n            for currentProduct in set {\n                if currentProduct == product {\n                    return true\n                }\n            }\n            return false\n        }\n\n        func add(product:Product){\n            for currentProduct in set {\n                if currentProduct == product {\n                    currentProduct += product.quantity\n                    return\n                }\n            }\n            set.append(product)\n        }\n\n        var description: String {\n      let descriptions = set.map{$0.description}\n      return descriptions.joinWithString(\" \")\n        }\n    }\n    ```", "```swift\n    func ==(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -> Bool{\n      return leftProduct.name.lowercaseString == rightProduct.name.lowercaseString\n    }\n    ```", "```swift\n    func <=(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -> Bool{\n        return leftProduct.name <= rightProduct.name\n    }\n    func >=(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -> Bool{\n        return leftProduct.name >= rightProduct.name\n    }\n    func >(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -> Bool{\n        return leftProduct.name > rightProduct.name\n    }\n    func <(leftProduct: ShoppingList.Product, rightProduct: ShoppingList.Product) -> Bool{\n        return leftProduct.name < rightProduct.name\n    }\n    ```", "```swift\n    func +=(shoppingList: ShoppingList, product: ShoppingList.Product) -> ShoppingList{\n        shoppingList.add(product)\n        return shoppingList\n    }\n\n    func +=(product: ShoppingList.Product, quantity: Int) -> ShoppingList.Product{\n        product.quantity += quantity\n        return product\n    }\n    ```", "```swift\n    infix operator => { associativity left precedence 140 }\n    infix operator !=> { associativity left precedence 140 }\n\n    func =>(product:ShoppingList.Product, shoppingList:ShoppingList)->Bool {\n        return shoppingList.contains(product)\n    }\n\n    func !=>(product:ShoppingList.Product, shoppingList:ShoppingList)->Bool {\n        return !shoppingList.contains(product)\n    }\n    ```", "```swift\n        @IBOutlet var fieldQuantity: UITextField!\n        @IBOutlet var fieldProduct: UITextField!\n        @IBOutlet var appendSwitch: UISwitch!\n        @IBOutlet var textResult: UITextView!\n    ```", "```swift\n    var shoppingList: ShoppingList = ShoppingList()\n    ```", "```swift\n        @IBAction func showList(sender: UIButton) {\n            textResult.text = shoppingList.description\n        }\n    ```", "```swift\n        @IBAction func addToList(sender: UIButton) {\n            var product = ShoppingList.Product(fieldProduct.text)\n            if  let quantity = Int(fieldQuantity.text) {\n                product.quantity = quantity\n                if appendSwitch.on || product !=> shoppingList{\n                    shoppingList += product\n                }else {\n                  let alert = UIAlertController(title: \"Wrong Product\", message: \"This product is already on your list\"), preferredStyle:.Alert)\n                  self.presentViewController(alert, animated: true, completion: nil)\n                }\n              }else {\n\n                let alert = UIAlertController(title: \"Wrong Value\", message: \"Oops! I need a number on the quantity field\"), preferredStyle:.Alert)\n                self.presentViewController(alert, animated: true, completion: nil)\n\n                fieldQuantity.text = \"\"\n            }\n            clear()\n        }\n    ```", "```swift\n        private func clear(){\n            fieldQuantity.text = \"\"\n            fieldProduct.text = \"\"\n            fieldQuantity.becomeFirstResponder()\n        }\n    ```", "```swift\nfunc  + (i:Int, j:Int) -> Int {\n    return 10\n}\n```", "```swift\nfunc  + (i:Int, j:Int) -> Int {\n    if i == 1 && j == 1 {\n    return 10\n    }else {\n        return i + j\n    }\n}\n```", "```swift\n    class Person: Equatable {\n        var name: String\n        var group:Group?\n        init(_ name: String){\n            self.name = name\n        }\n    }\n    ```", "```swift\n    func ==(person1:Person, person2:Person)->Bool{\n        return person1.name == person2.name\n    }\n    ```", "```swift\n    class Group {\n        unowned var table:Table\n        var rangeStart: Int\n        var rangeEnd:Int\n        var size:Int {\n            return rangeEnd - rangeStart + 1\n        }\n\n        init (table:Table, entryPoint:Int){\n            self.table = table\n            rangeStart = entryPoint\n            rangeEnd = entryPoint\n        }\n\n        func shift(){\n            rangeStart++\n            rangeEnd++\n        }\n\n        func increase(){\n            rangeEnd++\n        }\n    }\n    ```", "```swift\n    class Room: CustomStringConvertable {\n        let STANDARD_TABLE_SIZE = 3\n        var guests:[String: Person] = [String: Person] ()\n        var tables = [Table]()\n\n        func add(table:Table){\n            tables.append(table)\n        }\n\n        func add(person:Person){\n            guests[person.name] = person\n        }\n\n        var description:String {\n      let descriptions = tables.map{$0.description}\n      return descriptions.joinWithSeperator(\"Table: \")\n        }\n    ```", "```swift\n        subscript(name:String)->Bool{\n            get{\n                if let guest = guests[name] {\n                    return true\n                }\n                return false\n            }\n            // No setter\n        }\n    ```", "```swift\n        subscript(name:String?)->Person{\n            get{\n                assertionFailure(\"Sorry, no subscript getter\")\n            }\n\n            set(newValue){\n                guests[newValue.name] = newValue\n                // if the key is nil we will have to look for\n                // the first table that is not null. If we\n                // are not able to find it we have to create a new table\n                if let personName = name {\n                    if let guest = guests[personName]{\n                        // now we need to find its table\n                        var guestGroup = guest.group!\n                        newValue.group = guestGroup\n                        // now we have to check the group table is full\n                        if guestGroup.table.full {\n                        // the table is full, if we have only 1 group it is not possible to add\n                        // any one to this table, otherwise the last group should move to another table\n                          if guestGroup.table.size == guestGroup.size {\n                            // The group is bigger than the supported size\n                            assertionFailure(\"Group too big\")\n                            }else{\n                              // the last table group should go to a new table\n\n                              var lastGroup = guestGroup.table.getLastGroup()!\n                              tables.append( guestGroup.table.transferGroup(lastGroup))\n                              // now the guestGroup table has free space\n                            }\n                        }\n                        guestGroup.table.add(newValue)\n                        guestGroup.increase()\n                    }else\n                    {\n                        assertionFailure(\"This guest should exists\")\n                    }\n\n                }else {\n                    // this person belongs to a new group\n                    var table = freeTable()\n                    var index = table.add(newValue)\n                    var group = Group(table: table, entryPoint: index)\n                    newValue.group = group\n                }\n            }\n        }\n\n        private func freeTable() -> Table {\n            for table in tables {\n                if !table.full {\n                    return table\n                }\n            }\n            var newTable = Table(STANDARD_TABLE_SIZE)\n            tables.append(newTable)\n            return newTable\n        }\n    ```", "```swift\n    enum TableSeat {\n        case FREE,\n        OCCUPIED(Person)\n    }\n    ```", "```swift\n    func == (seat1:TableSeat, seat2:TableSeat) -> Bool {\n        switch(seat1,seat2){\n        case (.FREE,.FREE):\n            return true\n        case (.OCCUPIED(let person1),.OCCUPIED(let person2)):\n            return person1 == person2\n        default:\n            return false\n        }\n    }\n\n    func != (seat1:TableSeat, seat2:TableSeat) -> Bool {\n        return !(seat1 == seat2)\n    }\n    ```", "```swift\n        private var seats:[TableSeat]\n\n        init (_ size: Int){\n            seats = [TableSeat](count: size, repeatedValue: TableSeat.FREE)\n        }\n\n        var full:Bool {\n            return seats.last! !=  .FREE\n        }\n\n        var freeSeats:Int {\n            var total = 0\n                for i in seats.reverse() {\n                    if i == TableSeat.FREE {\n                        ++total\n                    }else{\n                        break\n                    }\n                }\n                return total\n        }\n\n        var nextFreeSeat:Int {\n            return seats.count - self.freeSeats\n        }\n\n        var description:String {\n            let takenSeats = seats.filter({ (seat) -> Bool in\n            switch seat {\n                case .FREE:\n                    return false\n                case .OCCUPIED:\n                    return true\n                }\n            }).map({(seat) -> String in\n                switch seat {\n                    case .FREE:\n                        assertionFailure(\"???\")\n                    case .OCCUPIED(let person):\n                        return person.name\n                }\n            })\n\n        return takenSeats.joinWithString(\", \")\n\n        private func shift(group:Group){\n            seats[(group.rangeStart+1)...(group.rangeEnd+1)] = seats[group.rangeStart...group.rangeEnd]\n            seats[group.rangeStart] = .FREE\n            group.shift()\n        }\n\n        var size:Int {\n            return seats.count\n        }\n\n        func getLastGroup() -> Group? {\n            for seat in seats.reverse() {\n                switch seat {\n                case .OCCUPIED(let bySomeone):\n                    return bySomeone.group\n                case .FREE:\n                    continue\n                }\n            }\n            // no group\n            return nil\n        }\n\n        func  transferGroup(group: Group)->Table{\n            var newTable = Table(seats.count) // creating a new table with the same size\n            newTable.seats[0..<(group.size)] = seats[group.rangeStart...group.rangeEnd]\n            seats[group.rangeStart...group.rangeEnd] = [TableSeat](count: group.size, repeatedValue: .FREE)[0...(group.size-1)]\n            group.table = newTable\n            return newTable\n        }\n\n    func add(person:Person)->Int {\n            var lastAllocatedSeat = self.nextFreeSeat-1\n            // return -1 if it wasn't possible\n            if self.full {\n                return -1\n            }\n            var index = lastAllocatedSeat + 1\n            if let group = person.group {\n              // who we have to shift the groups until we find\n                // the new person's group and them we keep\n                // him (or her) on the array\n                searching:\n                    while lastAllocatedSeat>=0 {\n                      // in this case the seat should be always occupied\n                        // but as the compiler doesn't know we have to retrieve\n                        // its value\n                        switch seats[lastAllocatedSeat] {\n                        case .FREE:\n                            assertionFailure(\"shouldn't be any free seat here\")\n                        case .OCCUPIED(let groupPerson):\n                            if groupPerson.group !== person.group {\n                                // different groups, let's move the group to the right\n                                lastAllocatedSeat = groupPerson.group!.rangeStart-1\n                                shift(groupPerson.group!)\n\n                            }else{\n                                break searching\n                            }\n                        }\n                }\n                index = lastAllocatedSeat + 1\n\n            }else{\n                // if the person group is null means that it's a new group so\n                // can add him on the first available seat\n            }\n            self.seats[index] = .OCCUPIED(person)\n            return index\n        }\n    }\n    ```", "```swift\n        @IBOutlet var textView: UITextView!\n        var room:Room = Room()\n\n        override func viewDidLoad() {\n            super.viewDidLoad()\n\n            room[nil] = Person(\"Mr Peter File\")\n            room[nil] = Person(\"Ms Mary Simpson\")\n            room[\"Mr Peter File\"] = Person(\"Mr Taro Mashimoto\")\n            room[nil] = Person(\"Mr Stuart Johnson\")\n            room[\"Ms Mary Simpson\"] = Person(\"Mr Scott Chesterford\")\n\n            self.textView.text = room.description\n        }\n    ```"]