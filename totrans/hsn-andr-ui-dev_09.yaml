- en: Navigating Effectively
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Broadly speaking, navigation is how your user gets from one screen to another
    in your application. More specifically, however, it's what a user needs to do
    in order to reach a goal within your application. Navigation is an almost completely
    invisible part of your application's user interface design. It's an area that
    is often neglected, frequently done badly, and as a result, often leads users
    to frustration.
  prefs: []
  type: TYPE_NORMAL
- en: The problem is that the navigation design of an application is often a side
    effect of the user interface design, rather than something that has been planned.
    Navigation, just like a single screen, can and should be designed to center around
    the user rather than the designer or developer. Using the techniques you've already
    learned in this book, you should be able to make almost any navigation flow work
    easily, because the elements should not be tightly coupled to each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll look at navigation and navigation patterns within the
    Material Design language. You''ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Plan and design the navigation flow of an application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the standard navigation menu component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tabbed navigation applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Navigate using fragments instead of Activities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Planning navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before leaping into your latest app idea, it's a good idea to stop and consider
    what you are trying to allow the user to do, and figure out how they will actually
    do it. One of the best ways to do this is with the decision tree or navigation
    tree. These can be easily drawn on paper, or if you're collaborating with other
    people, index cards on a magnetic whiteboard (or even a pin-board) are very effective.
  prefs: []
  type: TYPE_NORMAL
- en: The idea is to not just draw out the possible screens in your app, but how the
    user will get to each one. Navigation diagrams don't just help to define what
    screens your application actually needs, but will help ensure that the user will
    never be "lost" in your application. If the navigation lines become too complex,
    then you need to simplify the navigation (possibly by adding or removing some
    of the screens). Overly complex navigation is often hidden in the use of an application,
    but when drawn on a diagram, the complex relationships between screens become
    obvious, and often, a solution will become apparent.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start drawing your diagram, create a box or card that represents the user''s
    main entry into the application. Then, branch from each possible action that the
    user might take from that screen. For each action, draw a simple icon or describe
    the type of action the user is expected to take. For example, a circle can represent
    a floating action button, three staggered lines can represent a swipe gesture,
    and so on. These icons will also help by ensuring that the gestures and actions
    on a screen remain obvious to the user, and will help you avoid navigation techniques
    that hide the behaviors from the user. Here''s an example navigation diagram for
    the current state of the travel claims app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/22634f22-61fc-49bf-beb8-66a457e2f70d.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'It''s immediately apparent from the diagram that everything flows deeply into
    the application, and that there are currently three distinct action areas: **New
    Item**, **Delete Item**, and **Add Attachment**. Larger applications should still
    have these logical groupings of action areas, and should not have navigation lines
    that have to crossover too much of the diagram. If they do, it''s a sign of an
    overcomplex navigation structure, and moving things around on the diagram will
    often help you produce a better and more intuitive application.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at various Android components built specifically for
    navigation.
  prefs: []
  type: TYPE_NORMAL
- en: Tabbed navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When applications are broken down into a small number of logical areas, tabs
    often become the most obvious and simplest method of navigation. Most application''s
    navigation is deeply hierarchical, and in these cases, tabs are not a good choice
    for a navigation mechanism. Tab navigation is best used when each tab will be
    used roughly as much as each of the other tabs (that is, they have roughly equal
    importance). There are two major types of tabbed layouts in Android: bottom tabs
    and top tabs (also known as action bar tabs or toolbar tabs).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Top tabs** are the classic method of adding tabs to an Android application,
    and are perfect when the application areas are not switched between often. This
    is because they are at the top of the screen and typically far away from where
    the user''s fingers are. Most typically, a user has their fingers near the bottom
    of the screen, close to the software keyboard and system navigation buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/627f73ff-f318-4271-8dfe-6a4ccfda6b1f.png)'
  prefs: []
  type: TYPE_IMG
- en: '**Bottom tabs**, on the other hand, are a far more subtle and challenging navigation
    technique to implement effectively. Bottom tabs take up significantly more vertical
    screen space than their top-bar cousins, and therefore need to *work* for the
    extra space they consume. Bottom tabs are good to implement if the user will switch
    between the spaces frequently and spend roughly the same amount of time in each.
    As they are at the bottom of the screen, they are typically more accessible to
    the user and therefore it''s easier for them to switch between the screens they
    offer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/777376e8-771e-40f0-a50b-17389a348828.png)'
  prefs: []
  type: TYPE_IMG
- en: With either of these tab-based navigation options, it's important to consider
    that the tabs should always be visible in the application and therefore your application
    will have several **root** nodes in your navigation tree (one for each tab). You
    should also avoid navigating the user between tabs too much, as this can be confusing.
    Instead, each tab should represent a distinct part of the application process,
    almost like a mini-app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The tab components provided by Android don''t actually perform any of the navigation
    themselves; instead, it''s assumed that you will encapsulate the actual navigation
    container and logic yourself. It''s normal to use the `ViewPager` class to manage
    the switching between different tab screens, and a single `Fragment` for each
    of the tabs. Android Studio also includes some simple templates for both of these
    navigation patterns. Let''s take a look at how you can build a simple Activity
    with tabs at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the File menu, and select New | New Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new project `Navigation`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select an appropriate Company Domain to determine the package:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/b0f08439-40dd-4f1f-9ca6-4890a06a00f6.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Phone and Tablet support, and at least API 16 lever support:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/30706e16-71e5-4575-8411-c6d854e4520f.png)'
  prefs: []
  type: TYPE_IMG
- en: Then, click Next.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Activity Gallery, scroll right to the bottom and select Tabbed Activity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/548e63f6-ca1b-4645-aaee-79cc397b7f97.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on the Next button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Activity` `TopTabsActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scroll down to the bottom of the wizard to Navigation Style.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the Navigation Style to Action Bar Tabs (with ViewPager):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/07860dea-c368-45a2-8a3f-0e1dee581ae4.png)'
  prefs: []
  type: TYPE_IMG
- en: Click Finish to complete the wizard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait for Android Studio to finish creating your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your project has compile errors in the IDE, you might need to add the support
    library to the new project. Open the build.gradle for app module, and add
  prefs: []
  type: TYPE_NORMAL
- en: '`implementation ''com.android.support:support-v4:26.0.0''`'
  prefs: []
  type: TYPE_NORMAL
- en: (with the correct version number) to the `dependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the project has been created, Android Studio will have built a new `Activity`
    with three tabs in its `AppBarLayout`. Open the res/layout directory, and open
    the `activity_tob_tabs.xml` layout file to edit the number and appearance of the
    tabs:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It's best to avoid having too many tabs in any sort of tabbed layout. If you
    are using text labels (as the template does), you should try and avoid having
    more than three tabs. If you require more than three, it's best to use the Material
    icons and remove the text descriptions.
  prefs: []
  type: TYPE_NORMAL
- en: To edit what appears in the tabs, you'll need to open the `TopTabsActivity`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `SectionsPagerAdapter` inner class at the bottom of the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this class, you can create a `switch` statement in the `getItem` method
    to create the `Fragment` instances for each tab. For example, the "Flight Search"
    images used earlier might have a `getItem` implementation looking like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using a `switch` statement or similar structure instead of populating an array
    ensures that the `Fragment` objects are only allocated when they are actually
    needed. If the user doesn't change tabs, only one will need to be instantiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `TopTabsActivity`, you''ll see in the `onCreate` method that Android
    Studio tethers the `TabLayout` in the `AppBarLayout` with the `ViewPager`, using
    two listener classes from the `TabLayout` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These listeners will keep the selected tab in the `TabLayout` and the current
    `Fragment` displayed by the `ViewPager` in sync. When a tab is selected, the appropriate
    page will be displayed and when the `ViewPager` is swiped, the appropriate tab
    will be selected.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom tabs navigation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the bottom navigation tabs is quite different in code structure to placing
    tabs in the toolbar of the application. Where the toolbar tabs use `TabItem` widgets
    to render their content, the `BottomNavigationView` uses a menu to decide how
    it should look. A menu, much like a layout file, is a specialized XML resource
    file in Android. They also compacted to binary XML during compilation of the project
    and can be inflated at runtime using a `MenuInflator` object. Unlike a layout
    resource, a menu specifies lists of menu items and submenus, and while these have
    text descriptions and optional icons, they have no other render logic of their
    own. As a result, they are perfect for representing navigation options to a variety
    of different widgets.
  prefs: []
  type: TYPE_NORMAL
- en: Bottom tabs are often used to present *alternative* views--different user interfaces
    on top of the same data; for example, search flights, upcoming bookings, and past
    reservations. All of them are flights for the user, but from different perspectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build an `Activity` to use the `BottomNavigationView` to navigate between
    different areas of an application:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the main package in the Navigation project and select New | Activity
    | Bottom Navigation Activity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Activity` as `BottomTabsActivity`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Finish to create the new structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Android Studio will create several new files: the `Activity` class, the new
    layout XML file, several new icon files, and the navigation menu resource.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the new `res/layout/activity_bottom_tabs.xml` layout resource.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure that the editor is in the Design mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the Component Tree panel, select the message (TextView) item and delete
    it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ed3671c-7b7a-4621-9b06-88ef77273c06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Palette panel, open the Containers and drag a `ViewPager` into the middle
    of the design canvas:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6ae6e009-403d-4db7-a605-6d70506b1eff.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Using the Attributes panel, add constraints to all sides of the new `ViewPager`
    and make them `0`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/832dfa61-6554-4616-afef-b14318682677.png)'
  prefs: []
  type: TYPE_IMG
- en: Change the layout_width and layout_height attributes to match_constraint.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the ID of the `ViewPager` widget to `container`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the res/drawable directory in the project view, and select New
    | Vector Asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the Icon selector to find the standard `search` icon, and leave the name
    as is (`ic_search_black_24dp`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select Next, and then Finish to import the icon into your project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import the `flight takeoff` and `bookmark` icons in the same way.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the res/menu/navigation.xml menu resource file. In the Design view, you
    should be presented with a menu editor, looking like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/8891eda9-9224-478b-9adf-f113b124421b.png)'
  prefs: []
  type: TYPE_IMG
- en: Select the Home menu item by clicking on it in the Design canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the item's ID to `navigation_search`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the string resource editor to change the title attribute to a new string
    resource called `title_search`, with the content `Search`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the icon resource selector to change the icon to the `ic_search_black_24dp`
    icon you imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Dashboard menu item in the Design canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the ID attribute in the Attributes panel to `navigation_upcoming`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the string resource editor to change the title attribute to a new string
    resource called `title_upcoming`, with the content `Upcoming Flights`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the icon resource selector to change the icon to the `ic_flight_takeoff_black_24dp`
    icon you imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the Notifications menu item in the Design canvas.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the ID attribute in the Attributes panel to `navigation_flown`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the string resource editor to change the title attribute to a new string
    resource called `title_flown`, with the content `Past Bookings`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the icon resource selector to change the icon to the `ic_bookmark_black_24dp`
    icon you imported.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the `BottomTabsActivity` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Remove the reference to the `TextView`, and replace it with a reference to
    the `ViewPager` and `BottomNavigationView`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `BottomNavigationView` (unlike the `TabLayout` used for top tabs) includes
    no listeners to automatically map between the selected tab and a `ViewPager`,
    so you''ll need to map the `MenuItem` ID values to the index of the pages that
    should be displayed. Create an `int` array with the `MenuItem` ID values in the
    same order as the pages:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The template created a `BottomNavigationView.OnNavigationItemSelectedListener`
    anonymous inner class to display the name of the selected tab in the `TextView`.
    You instead want the `ViewPager` to change to the selected tab `Fragment`, and
    you can do this using the array of ID values you just declared:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You''ll also need a listener for when the user swipes between the tabs on the
    `ViewPager`, so that the `BottomNavigationView` also highlights the correct tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `onCreate` method, remove the assignment to the `TextView`, and assign
    the new `ViewPager` field:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `BottomNavigationView` assignment and listeners to assign to the
    field in your `Activity`, and then correctly assign both the listeners:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can now assign a `ViewPagerAdapter` to the `ViewPager` with three tabs
    (such as the `SectionsPagerAdapter` generated in the `TopTabsActivity`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If the preceding line complains about `TopTabsActivity` not being an enclosing
    class, then change the `SectionsPagerAdapter` to be a static inner class--`public
    static class SectionsPagerAdapter extends FragmentPagerAdapter`.
  prefs: []
  type: TYPE_NORMAL
- en: The listeners in this example can be reused in any number of applications that
    require bottom-tabbed navigation. The only thing you'll need to change is the
    list of `pageIds` that are displayed to the user. You should avoid having more
    than three or four tabs in the `BottomNavigationView`; it normally implies that
    another form of navigation is more appropriate to your application.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation menus
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, you need to provide your user with a broad set of navigation options
    that won't fit into a set of tabs. This is where a hidden navigation menu, sometimes
    called a hamburger menu, becomes useful. This menu pattern was once popular to
    put as a sort of main menu, available on every screen in your application. However,
    navigation menus hide options, and they often encourage sloppy navigation design,
    because they provide a space where any navigation items can be *dumped*. It's
    better to try and avoid any form of hidden navigation until you're absolutely
    sure that you need it.
  prefs: []
  type: TYPE_NORMAL
- en: They can be useful when they augment other navigation patterns (such as tabs),
    and are used to offer seldom used or advanced functionality that the user is unlikely
    to access every day. For example, on a photo gallery screen, a hidden menu might
    be used to access the ability to create new labels, access photos that have been
    deleted, and to access settings and help.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a navigation menu to the example with the bottom tabs, to allow
    the user access to some other functionality that they might need:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the `res/menu` directory and select New | Menu resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new file `nav_menu`, and click OK to create the new resource file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the Text editor for the new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Copy the following menu structure into the new file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Now, open the `activity_bottom_tabs.xml` layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change to the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The root element should currently be a `ConstraintLayout`; you''ll need to
    wrap it inside a `DrawerLayout` widget that will manage the showing and hiding
    of the navigation drawer. You''ll also need to give the `ConstraintLayout` a top-margin
    the same size as the `ActionBar`; otherwise, it will be hidden behind the system
    `ActionBar` (another way around this is to use the `AppBarLayout` and `CoordinatorLayout`
    with no system `ActionBar`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the `ConstraintLayout` element is closed, you''ll need to add the `NavigationView`,
    which will contain the navigation menu you just wrote:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Open the `BottomTabActivity` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'By default, the `NavigationView` won''t respond to any form of tapping menu
    items, and won''t even close the navigation drawer when you select a menu item.
    You''ll need to add a listener and tell it what to do yourself. At the bottom
    of the `onCreate` method, look up the `NavigationView` and add a listener to at
    least close the navigation drawer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Users also expect to be able to close the navigation drawer using the back
    button. This requires you to override the default back-button behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Overriding the back button behavior like this is something you should be very
    careful with. The default behavior is strongly consistent across the entire platform
    and all well-behaved applications. Applications that have inconsistent back-button
    behavior are obvious to users, and are often very frustrating.
  prefs: []
  type: TYPE_NORMAL
- en: The navigation drawer here is a very good example of its use within an application
    context. The bottom tabs allow the user quick access to the most commonly used
    areas of the application, while the navigation drawer can be used to access the
    less frequently used features. Remember that navigation drawers hide features
    of your application and should only be used for features that are not required
    for the user, to make effective use of your application. It's sometimes worth
    forcibly opening the navigation drawer the first time the screen is opened by
    the user (you can use a `SharedPreferences` to remember that they have seen it).
    You can do this using the `DrawerLayout.openDrawer` method in `Activity.onCreate`.
  prefs: []
  type: TYPE_NORMAL
- en: Also, remember that while overriding the default back-button behavior is important
    for the user experience in this specific case, it's normally not a good idea.
    Inconsistent back-button behavior is something that users pick up on very easily,
    and it's one of the most common irritations. For some behaviors such as closing
    the navigation drawer, it's important because it's the most common pattern, but
    using the ability to ask whether the user is "Sure they want to exit" (and similar
    additional behaviors) is a waste of the user's time, and should be avoided.
  prefs: []
  type: TYPE_NORMAL
- en: Navigating using Fragments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in the book, you've mostly been navigating users from one `Activity`
    to another `Activity`, and this is in fact how most applications are built. However,
    there is another option, which is often much more flexible and allows you to build
    even more modular applications--navigation using `Fragment` instances. So far,
    we've only really looked at Fragments as little blocks of your application that
    can be assembled to form parts of a screen, but they can be so much more than
    that.
  prefs: []
  type: TYPE_NORMAL
- en: The tabbed `Activity` classes both provide a sort of navigation using the `ViewPager`
    class and the `FragmentPagerAdapter` class. In these cases, each of the pages
    that the user can swipe to is a complete `Fragment`, with its life cycle that
    is paused and resumed, stopped, and started as the user swipes the `Fragment`
    in or out of view.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look into the `FragmentPagerAdapter` class, you''ll find that it doesn''t
    add and remove the `Fragment` view instances directly to the `ViewPager` object.
    Instead, it uses a `FragmentTransaction` to add and remove the `Fragment` to the
    `ViewPager` using the `ViewPager` ID attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `FragmentTransaction` class allows you to define any number of actions that
    will all appear to happen at once. You can add, remove, attach, detach, and replace
    any number of `Fragment` instances on your user interface, and then trigger them
    all at once. The best part is that you can also add the transaction to the "back
    stack". This means that the user can undo the transaction by pressing the *back*
    button on their device.
  prefs: []
  type: TYPE_NORMAL
- en: So, by creating your main `Activity` with a content space (like the `ViewPager`
    in the tabs examples), and populating it with `Fragment` objects, you can simulate
    `Activity` to `Activity` navigation. This also means that your primary navigation
    controls, such as tabs or a hidden navigation menu, only need to be defined in
    your activity layout rather than on the layouts of each screen in the application.
    This also makes the navigation within your application slightly quicker, because
    the heavy-weight components of the screen are reused for each navigation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add some navigation behaviors to the bottom tabs example that we''ve
    started, so that the navigation menu options actually do something:'
  prefs: []
  type: TYPE_NORMAL
- en: First, you'll need a `Fragment` class that you can use for the various navigation
    actions you'll have in the example. Right-click on your default package (that
    is, `com.packtpub.navigation`) and select New| Fragment| Fragment (blank).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new `Fragment` class `PlaceholderFragment`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Deselect the Include fragment factory methods? and Include interface callbacks?
    checkboxes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d71c0193-4cda-48e2-b826-842324acec0a.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Finish to create the new fragment class and layout file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the `fragment_placeholder.xml` layout file in Design mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `FrameLayout` in the Component Tree panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, toggle to View all attributes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `background` attribute, and set it to `#ffffff` (white) so that the
    background of this `Fragment` is opaque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `TextView` in the Component Tree panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the Attributes panel, change the ID attribute to `placeholder_text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `textAppearance` attribute to `@style/TextAppearance.AppCompat.Display1`,
    which will appear in the drop-down as AppCompat.Display1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, open the new `PlaceholderFragment` Java source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Declare a `static` `String` constant to allow the `PlaceholderFragment` to
    hold its placeholder-text argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Change the `onCreateView` method so that it sets the text of the `TextView`
    to the placeholder-text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Create a convenience factory method to create the `PlaceholderFragment` with
    the placeholder-text specified as a method argument:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Open the `activity_bottom_tabs.xml` layout resource in the Text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the `ViewPager` below the `BottomNavigationView` widget.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `ViewPager` so that it is wrapped in a full-size `FrameLayout` with
    an ID of `host`; this will be used to contain the `Fragment` instances used to
    navigate the user around the app:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Open the `BottomTabsActivity` source file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When the user taps on one of the bottom navigation items, you want to ensure
    that any navigation they have done is cleared so that the back button doesn''t
    navigate them back into their previous stack, and ensure that there are no residual
    `Fragment` instances on the screen. In the `OnNavigationItemSelectedListener.onNavigationItemSelected`
    method in your anonymous class, you''ll want to pop the backstack, before telling
    the `ViewPager` to change tab:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'At the bottom of the `onCreate` method, you need to add a new listener to the
    `NavigationView` to listen for the taps in the menu. These will trigger the navigation
    using the `FragmentManager`, and will also close the navigation drawer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As a bonus, the preceding code will also produce a lovely transition navigation
    between each of the navigation actions. It's also possible that you might want
    to clear the backstack each time the user takes one of these navigation actions.
    On top of that, you may also want to select specific tabs in the `BottomNavigationView`
    to indicate which part of the app the user is in, or you may want the `FrameLayout`
    to wrap the entire `ConstaintLayout` so that the bottom tabs vanish when the user
    is navigated using the `FragmentManager`.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that in this structure, the other layouts and `Fragment`
    instances are still in the layout. They're just hidden by the `Fragment` instances
    being placed over them as the user navigates using the menu. To avoid this, you
    can wrap the `ViewPager` in a dedicated `Fragment` class, but it's important to
    add it to the layout through the `FragmentManager` in the `Activity.onCreate`
    method and not by using the `<fragment>` tag in the layout XML. The `FragmentManager`
    will only remove a `Fragment` from the layout if it was added via a `FragmentTransaction`
    in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: Test your knowledge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When using bottom tabs for navigation, which of these is important?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They all have single color icons
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The tabs are of roughly equal importance
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: There are always exactly three tabs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Top tabs are preferred to bottom tabs in which of these situations?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the user won't need to navigate as frequently
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the tabs don't have icons
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When there are more than three tabs
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Fragments can be used for navigation in which of these cases?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Only when a navigation drawer is used as well
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Any time the user navigates within the application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When they can be nested in a `FrameLayout`
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user selects an item in a navigation drawer, which of these is true?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The drawer needs to be closed by the user
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawer should be closed programmatically
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The drawer is closed automatically after a short delay
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Navigation is a critical part of a user's experience, and should be carefully
    thought out and designed. Material design has various different design structures
    and widgets to help you implement more effective navigation, but it's important
    to use them carefully and in the right place. As with any screen design, it's
    important to consider what the user will want to do most often, and to rank each
    possible action and navigation from the most important to the least on every screen
    they are available in.
  prefs: []
  type: TYPE_NORMAL
- en: In many applications, dedicated navigation components won't even be needed,
    and navigation will be achieved purely through goal-oriented actions from an overview
    screen or dashboard. In all instances, it's a good idea to draw up a navigation
    map ahead of time (even if it's incomplete or overly simplified). They will often
    tell you what sort of navigation structure and components your application will
    require.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation achieved using the `FragmentManager` instead of always launching
    a new `Activity` is an extremely powerful pattern. It offers a large number of
    additional options and significantly more control over the backstack, and even
    the animations played during each transition. It's also possible to change more
    than one onscreen `Fragment` in a single `FragmentTransaction`, which can be used
    to produce some amazing effects.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll go back to the travel claim example and explore some
    more of the `RecyclerView`. The chapter will take a look at some of the more advanced
    capabilities of the `RecyclerView` and how to integrate it with the `LiveData`
    class and Room using some powerful classes from the support API to achieve some
    exciting effects.
  prefs: []
  type: TYPE_NORMAL
