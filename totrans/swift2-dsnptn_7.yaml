- en: Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents you with three other behavioral patterns, which support
    communication between objects. Objects keep their independence and sometimes their
    anonymity. The iterator pattern is often used with array, collection, and dictionary
    objects. The mediator allows communication between two objects without knowing
    each other's identities and the observer patterns mirror the publish/subscribe
    methodologies that are well known in distributed systems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is divided in three sections:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: The iterator pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator pattern
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is commonly used in many languages with an array or a collection
    of objects. It allows iteration over a list of objects contained in a collection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator pattern allows you to iterate sequentially over an aggregated object
    of objects without having to know how the collection is structured.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Design
  id: totrans-10
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, you'll find the generic UML class diagram of the pattern, but note that
    we will not implement it using this way.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Swift provides some types that will simplify the implementation of the
    iterator pattern, without having to produce all of the needed requirements by
    hand.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'Why reinvent the wheel? The following figure represents the generic UML class
    diagram:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_07_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with every pattern described up to now, I will tell you what the participants
    in this pattern are even if we will not see all of them in our implementation
    of the pattern:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection`: This is an abstract class that implements the association of
    the collection with items and the `CreateIterator()` method'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteCollection`: This is concrete collection subclass that link the `CurrentItem`
    object to a `ConcreteItem` object and the `Iterator` interface to the `ConcreteIterator`
    objec`t`'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterator`: This is the abstract class, which implements the association of
    the iterator and the collection items and methods'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteIterator`: This is a concrete subclass that links our `currentItem`
    to the `ConcreteItem` object'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Item`: This is the abstract class of the collection items'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteItem`: This is a concrete `Item` subclass used by `ConcreteIterator`
    and `ConcreteCollection`'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator keeps in memory the current item in the collection. It can also
    calculate and predict the next object of the iteration.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are developing a game in which you can have up to say, four players. You
    want to be able to iterate over all the four players to do something. In our sample,
    we will display the name of each player.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation provided here comes from ideas discovered on the Lilly Labs
    website at [http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/](http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: Well, given our illustration what we want to be able to do is to iterate using
    a `for…in` loop construct.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，根据我们的说明，我们想要能够使用 `for…in` 循环结构来迭代。
- en: All thanks to Swift, we have some elements that will simplify the implementation
    of this pattern.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 全靠 Swift，我们有一些元素将简化此模式的实现。
- en: Indeed, Swift proposes a `SequenceType` protocol and an `AnyGeneratorType<T>`
    class, which implements the `GeneratorType` protocol.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Swift 提出了一个 `SequenceType` 协议和一个 `AnyGeneratorType<T>` 类，该类实现了 `GeneratorType`
    协议。
- en: The `SequenceType` protocol defines a protocol that allows us to iterate over
    elements of a collection using the `for…in` loop construct. It requires that the
    class implements the `generate()` method, which returns an object conforming to
    the `GeneratorType` protocol.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`SequenceType` 协议定义了一个协议，允许我们使用 `for…in` 循环结构迭代集合中的元素。它要求类实现 `generate()` 方法，该方法返回一个符合
    `GeneratorType` 协议的对象。'
- en: '`AnyGenerator<T>` is a class that conforms to the `GeneratorType` protocol,
    where `<T>` means `Item` of any type.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`<T>` 表示任何类型的 `Item`。'
- en: 'Having said this, how do we use all of the preceding functions to easily iterate
    over a collection of any type? Let''s say, we have the following class:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 说了这么多，我们如何使用所有前面的函数轻松地迭代任何类型的集合？比如说，我们有一个以下类：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Therefore, we define a simple `Player` class where we pass a string in the constructor,
    which corresponds to the name of the player.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个简单的 `Player` 类，我们在构造函数中传递一个字符串，它对应于玩家的名字。
- en: We suppose that we have four players in our game and want to be able to iterate
    over each of them to display their name.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设我们的游戏中我们有四个玩家，并希望能够迭代每个玩家以显示他们的名字。
- en: 'Therefore, the final code to test will be something like the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终的测试代码将类似于以下内容：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, how to complete our code with a bonus, something that will works with
    any class that we want to iterate over? Well, we will use another concept provided
    by Swift: **extension**.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如何用奖金来完善我们的代码，一些可以与任何我们想要迭代的类一起工作的东西？嗯，我们将使用 Swift 提供的另一个概念：**扩展**。
- en: 'The first thing to be done is to create an object or struct that we will let
    us iterate over any class type:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要做的事情是创建一个对象或结构体，它将允许我们迭代任何类类型：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Therefore, we define a struct that we call `OurCollection`, where items are
    of type `T`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们定义了一个我们称之为 `OurCollection` 的结构体，其中项目类型为 `T`。
- en: 'Now, we will be able to write the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将能够写出以下内容：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'However, the `for…in` loop will still not work, as shown in the following screenshot:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`for…in` 循环仍然不会工作，如下面的截图所示：
- en: '![Implementation](img/4852_07_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_07_02.jpg)'
- en: 'Even though, the players don''t implement the `SequenceType` protocol. Here
    is the magic:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 即使玩家没有实现 `SequenceType` 协议。这里就是魔法：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Wow! Lot of new things here:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这里有很多新东西：
- en: First, we create an extension of the `OurCollection` struct by telling that
    we want to implement the `SequenceType` protocol.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过告诉我们要实现 `SequenceType` 协议来创建 `OurCollection` 结构体的一个扩展。
- en: 'So we implement the `generate()` method, which will return the next type `T`
    object in the iteration. Also, note the line:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们实现了 `generate()` 方法，该方法将返回迭代中的下一个类型 `T` 对象。注意以下行：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Generator is an alias of `AnyGenerator<T>`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器是 `AnyGenerator<T>` 的别名：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We use this to simplify the writing. We can remove the type alias statement
    and write:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个来简化编写。我们可以移除类型别名声明并写：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Another function is the `anyGenerator` function tha you see here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数是这里看到的 `anyGenerator` 函数：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The Swift 2.0 documentation says that the `anyGenerator` function has the following
    signature:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 2.0 文档说明，`anyGenerator` 函数具有以下签名：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The purpose of this function is to return a `GeneratorType` instance whose `next`
    method invokes `body` and returns the result.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的目的是返回一个 `GeneratorType` 实例，其 `next` 方法调用 `body` 并返回结果。
- en: So here, we start from index `0` to index `self.items.count` value and add the
    `sel.items[i++]` in the new `GeneratorType` instance. The new `GeneratorType`
    instance is returned when `i` is superior to a number of elements in the items
    array.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从索引 `0` 开始到 `self.items.count` 值的索引，并在新的 `GeneratorType` 实例中添加 `sel.items[i++]`。当
    `i` 大于项目数组中的元素数量时，返回新的 `GeneratorType` 实例。
- en: 'We can also write the function such as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以写出如下函数：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And also like this:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，还有这样的：
- en: '[PRE11]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we use a closure with the `anyGenerator` function to return a new sequence
    of elements that we can iterate over. Our final code is as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们使用一个带有 `anyGenerator` 函数的闭包来返回一个我们可以迭代的新的元素序列。我们的最终代码如下：
- en: '[PRE12]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open the `iteratorPattern` project, build and run it. You will now see the
    following result:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `iteratorPattern` 项目，构建并运行它。你现在将看到以下结果：
- en: '![Implementation](img/4852_07_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_07_03.jpg)'
- en: The mediator pattern
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中介者模式
- en: The mediator pattern is used to reduce the coupling between classes that communicate
    with each other.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式用于减少相互通信的类之间的耦合。
- en: Roles
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: This pattern constructs an object, which manages the communication between two
    or more classes.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此模式构建了一个对象，该对象管理两个或更多类之间的通信。
- en: These classes don't know each other's implementation. The message is sent from
    the class to the mediator object.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这些类不知道彼此的实现。消息是从类发送到中介器对象的。
- en: The mediator pattern defines an object that encapsulates how a set of objects
    will communicate with each other. Mediator promotes loose coupling by keeping
    objects from referring to each other explicitly and it also lets you vary their
    interaction independently.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 中介者模式定义了一个对象，该对象封装了一组对象如何相互通信的方式。中介者通过保持对象不显式地相互引用来促进松散耦合，它还允许你独立地改变它们的交互。
- en: The mediator is an intermediary used to decouple many peers. This pattern can
    be used when we want to design reusable components but dependencies between the
    potentially reusable pieces demonstrate the "spaghetti code" phenomenon.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 中介器是一个用于解耦许多对等的中间人。当我们想要设计可重用组件，但潜在可重用部分的依赖关系表现出“意大利面代码”现象时，可以使用此模式。
- en: Design
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计
- en: 'The following class diagram presents the generic structure of the mediator
    pattern:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下类图展示了中介者模式的通用结构：
- en: '![Design](img/4852_07_04.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![设计](img/4852_07_04.jpg)'
- en: Participants
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参与者
- en: 'In this pattern, we find the following participants:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在此模式中，我们发现以下参与者：
- en: '`Mediator`: This defines the mediator interface to communicate with elements'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mediator`：这定义了与元素通信的中介器接口'
- en: '`ConcreteMediator`: This implements the coordination between elements and manages
    associations with elements'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteMediator`：这实现了元素之间的协调并管理与元素的联系'
- en: '`Elements`: This is the element abstract class, which introduces common attributes,
    properties, and methods'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Elements`：这是一个元素抽象类，它引入了常见的属性、属性和方法'
- en: '`ConcreteElement1` and `ConcreteElement2`: These are concretes element classes,
    which communicate with the mediator instead of communicating with the other elements'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ConcreteElement1` 和 `ConcreteElement2`：这些是混凝土元素类，它们与中介器通信而不是与其他元素通信'
- en: Collaboration
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 协作
- en: The elements send messages to the mediator and receive message from it. The
    mediator implements the collaboration and coordination between the elements.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 元素向中介器发送消息并从中接收消息。中介器实现了元素之间的协作和协调。
- en: Illustration
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 插图
- en: You are writing a system that allows users to communicate with each other. Communication
    is not sent directly from a peer to another. We will use some mediators that will
    manage all users and the communication between them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在编写一个允许用户相互通信的系统。通信不是直接从对等方发送到另一个对等方。我们将使用一些中介器来管理所有用户及其之间的通信。
- en: For this, each user managed by the mediator will be registered (added) to the
    mediator. Then, when a user sends a message, we will pass the mediator object
    as an argument informing the system that this is the message that will broadcast
    that message to all other users managed by the mediator calling the `receiveMessage`
    function.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此，每个由中介器管理的用户都将被注册（添加）到中介器中。然后，当用户发送消息时，我们将中介器对象作为参数传递，通知系统这是将要广播给由中介器管理的所有其他用户的消息，调用
    `receiveMessage` 函数。
- en: Implementation
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: 'Open the `MediatorPattern` Xcode project. This is a command line project that
    is organized as the following screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 `MediatorPattern` Xcode 项目。这是一个命令行项目，其组织结构如下截图所示：
- en: '![Implementation](img/4852_07_05.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_07_05.jpg)'
- en: The organization of our project is not more than what we have already described
    with the participants in the class diagram. We retrieve, the `MediatorProtocol`
    and `ConcreteMediator` object in the `Mediator` folder, our `Elements` and concrete
    elements `UserProtocol` and `User` are in the `Elements` folder and last, the
    `main.swift` file contains our client code to simulate the project.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目的组织结构不超过我们在类图中描述的参与者。我们在 `Mediator` 文件夹中检索 `MediatorProtocol` 和 `ConcreteMediator`
    对象，我们的 `Elements` 和具体元素 `UserProtocol` 和 `User` 在 `Elements` 文件夹中，最后，`main.swift`
    文件包含我们的客户端代码以模拟项目。
- en: 'First, we define `userProtocol`, in the `UserProtocol.swift` file:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在 `UserProtocol.swift` 文件中定义 `userProtocol`：
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `sendMessage` method will be used to tell the mediator passed in an argument
    what the message of the current `concreteUser` is. The `receiveMessage` method
    will be raised when the mediator broadcasts the message to all users.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`sendMessage` 方法将被用来告诉传入的中介参数当前 `concreteUser` 的消息内容。当中介向所有用户广播消息时，将触发 `receiveMessage`
    方法。'
- en: 'Then, in the `User.swift` file, we implement our protocol, as shown:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `User.swift` 文件中，我们实现我们的协议，如下所示：
- en: '[PRE14]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we add an argument in the constructor to pass the name of the user.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们在构造函数中添加一个参数来传递用户的名称。
- en: In the `sendMessage` method, we see that we are calling the `broadcastMessage`
    method of the mediator passed in the argument.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `sendMessage` 方法中，我们看到我们正在调用传入参数的中介的 `broadcastMessage` 方法。
- en: When raised, the `receiveMessage` method will display the name of the current
    user and also the message that was received.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `receiveMessage` 方法被触发时，它将显示当前用户的名称以及接收到的消息。
- en: 'Next, lets see how `MediatorProtocol` is defined:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `MediatorProtocol` 是如何定义的：
- en: '[PRE15]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `MediatorProtocol` manages the collection of elements; here, it is `Users`.
    It can also broadcast a particular message to a user.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`MediatorProtocol` 管理元素集合；这里，它是 `Users`。它还可以向特定用户广播特定消息。'
- en: To add a user to the collection of users managed by the mediator, we add a `Register`
    method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将用户添加到中介管理的用户集合中，我们添加了一个 `Register` 方法。
- en: 'Let''s see how we have implemented all of this in the `Mediator.swift` file:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何在 `Mediator.swift` 文件中实现所有这些的：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, we initialize a `User` array that is ready to manage a collection of
    user.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个 `User` 数组，它准备好管理用户集合。
- en: In the `register` method, we receive a user argument, which is added to the
    collection managed by the mediator.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `register` 方法中，我们接收一个用户参数，该参数被添加到中介管理的集合中。
- en: 'Then, the `broadcastMessage` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`broadcastMessage` 方法：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to make sure that the `user` array has not a `nil` value, if this is
    the case we then do nothing by leaving the method invoking the `return` keyword.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保 `user` 数组没有 `nil` 值，如果是这种情况，我们就不做任何事情，通过留下方法调用 `return` 关键字。
- en: Then, we iterate over all the users in the collection and if the current user
    of the iteration is different from the user sending the message (sender), then
    we call the `receiveMessage` method of the current user, along with the message
    to be transmitted.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历集合中的所有用户，如果迭代中的当前用户与发送消息的用户（sender）不同，则我们调用当前用户的 `receiveMessage` 方法，以及要传输的消息。
- en: Note
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Concurrency protection**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发保护**'
- en: 'You probably have seen the following line:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经看到了以下这一行：
- en: '[PRE18]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We need to create concurrency protection in this pattern when various users
    try to access the same user at the same time, so we use a technology developed
    by Apple: Grand Central Dispatch which allow specific tasks in a program that
    can be run in parallel to be queued up for execution and, depending on availability
    of processing resources, scheduling them to execute on any of the available processor
    cores.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当多个用户同时尝试访问同一个用户时，我们需要在这个模式中创建并发保护，因此我们使用了苹果开发的一项技术：Grand Central Dispatch，它允许程序中可以并行运行的任务被排队执行，并且根据处理资源的可用性，将它们调度到任何可用的处理器核心上。
- en: With this line, we initialize `queue` as a concurrent queue using `dispatch_queue_create`.
    The first parameter simply describes what our queue is (it could be helpful when
    you are debugging your code) and the second parameter specifies that we want our
    queue to be concurrent.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这一行，我们使用 `dispatch_queue_create` 初始化 `queue` 为一个并发队列。第一个参数简单地描述了我们的队列是什么（在调试代码时可能很有帮助），第二个参数指定我们希望我们的队列是并发的。
- en: 'Next, we want to protect the access to our code where arrays are read and written.
    For this, GCD provides an elegant solution of creating read/write lock using dispatch
    barrier. So we use `dispatch_barrier_sync` to pass our queue and the statement
    to execute by the queue. Since, the code we have written is a barrier closure,
    this will never run simultaneously with any other closure in queue . To see more
    about Grand Central Dispatch : [http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1](http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们想要保护我们的代码的访问，这些代码是读取和写入数组的。为此，GCD 提供了一个创建读写锁的优雅解决方案，使用 dispatch barrier。因此，我们使用
    `dispatch_barrier_sync` 来传递我们的队列和队列要执行的语句。由于我们编写的代码是一个屏障闭包，它将永远不会与队列中的任何其他闭包同时运行。有关
    Grand Central Dispatch 的更多信息：[http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1](http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1)
- en: 'All our participants are now in place. We will now try all of this in the `main.swift`
    file. We create four users, each with a name:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we instantiate our first mediator and add the first three users we have
    just created to the collection of users managed by `mediator1`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, we want to test that `user1` can send a message to `user2` and `user3`.
    We only need to invoke the `sendMessage` method of `user1` passing the `mediator1`
    and the message to be sent:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So, in this case only `user2` (Helmi) and `user3` (Adrien) should receive the
    message from `user1` (Julien).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to try the pattern with another mediator but with only two users: `user2`
    and `user4`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, only `user4` (Raphael) should receive the message from `user2` (Helmi).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the project. You should now be able to see the following result
    in the console dialog:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: The observer pattern
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is another behavioral pattern that is often used in networked
    system where a subject (the server) will notify some client. The iOS makes large
    use of this pattern through `NSNotificationCenter` object.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The observer pattern creates dependence between a subject and observer so that
    the observer is notified in order to update their state each time the subject
    is modified.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: This composition means that observer does not need to ask the current state
    of the subject. They only need to register to its notifications.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: A state modification inside the object needs to update other objects dynamically
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object wants to prevent other objects without the need to know the type (without
    having to be high coupled with them)
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not want to merge two objects into one
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram represents the UML class diagram of the observer pattern:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_07_07.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
- en: Participants
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is composed of the following participants:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '`Subject`: This defines the methods needed to add, remove, and notify observers.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteSubject`: This implements the `Subject` methods. It sends a notification
    when its state is modified.'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer`: This is a common interface having an `update()` method, which will
    be invoked by the subject when the observer needs to be notified about the modification
    of the subject.'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteObserver1` and `ConcreteObserver2`: This implements the `update()`
    method.'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ConcreteSubject` class notifies the observers when its internal state is
    modified. When a concrete observer receives this notification, it is updated consequently.
    To complete the update, it can invoke some subject methods that give access to
    its state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a new website where you want to allow internet users to communicate
    each other through a chat system. Your first job will be to provide a room, the
    entry point of all Internet users. Each time a new user joins the room, every
    user is notified.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern is fully appropriated to implement the code, which solves
    this problem.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `ObserverPattern` Xcode project to see the current structure of our
    code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
- en: We will retrieve the `Subject` folder and `Observers` folder, where we will
    find the participants of our pattern. The `Helpers` folder contains a class that
    we will use later when sending a message.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: The `Extension` folder contains an array extension that is required to make
    it possible for us to remove a particular object from the collection of users
    managed by the subject.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we find the `main.swift` file used to simulate interactions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us begin our code by defining our observer in the `UserProtocol.Swift`
    file:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We simply define an update method with an object as an argument. The implementation
    of the `UserProtocol` will be like this:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We pass a name in the constructor of the `User` object.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `update` method, we prepare a message that will be displayed on
    the console. We downcast our object of type `AnyObject` to an `Info` object; this
    object is a helper. You will find its code in the `Helper` folder in the `Info.swift`
    file:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `Info` object contains three values: a date, message, and status.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'The date is the current date and is defined when the `Info` object is initialized.
    The message is a string received in argument during initialization of the info
    object and the status is an enumeration passed in an argument during the initialization
    of the object and it can have the following value:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we only have to define our Subject protocol, and implement it in our concrete
    Subject. The Subject represents the object that need to be observed.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Subject definition is available in the `RoomProtocol.swift` file in the
    `Subject` folder:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: These three methods are the minimum necessary to any subject in an observer
    pattern.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: The `addObserver` function lets you register an observer in the collection of
    observers managed by the subject.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: The `removeObserver` method is used to remove an observer from the collection
    managed by the subject.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Last, the `notifyObserver` method is used to notify all our observers.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation will be found in the `Room.swift` file, as shown:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, you retrieve the three methods, in the two first one; you see a call to
    the `notifyObserver` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: All the users will be notified each time the `addObserver` or `removeObserver`
    method is called because the `addObserver` method is called when a new user joins
    the room and we display the `Join` status in the `Info` message. With the same
    principle, we display the `Leave` status when the `removeObserver` method is called.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
- en: The `notifiyObserver` method receives an object of type `AnyObject` as an argument
    that will be propagated over the update method of each user object available in
    the collection managed by the `Room` method.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Time for us to now write our demo code, open the `main.swift` file, and write
    the code.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our `Room` method and four internet users:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化我们的`Room`方法和四个互联网用户：
- en: '[PRE29]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we register each user to the room:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将每个用户注册到房间中：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Note
  id: totrans-192
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Each time the `addObserver` method is called, all the currently registered users
    will be notified that the current registered user has joined.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 每次调用`addObserver`方法时，所有当前注册的用户都会收到通知，表明当前注册的用户已加入。
- en: So, when `room.addObserver(user1)` is called, only `user1` will be notified,
    but when `user2` is registered, `user1` and `user2` will be notified and so on.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当调用`room.addObserver(user1)`时，只有`user1`会被通知，但当注册`user2`时，`user1`和`user2`都会被通知，依此类推。
- en: 'Now, we remove `user2`, `user3`, and `user1` in this order:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们按顺序移除`user2`、`user3`和`user1`：
- en: '[PRE31]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'To complete our sample, we register `user2` once more:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的示例，我们再次注册`user2`：
- en: '[PRE32]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let us now build and run the project. You will get the following result:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行项目。你将得到以下结果：
- en: '![Implementation](img/4852_07_09.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![实现](img/4852_07_09.jpg)'
- en: Here, we see all the notifications. The first line corresponds to the first
    `addObserver` called. The next two lines correspond to the second `addObserver`
    called, and so on.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们看到了所有的通知。第一行对应于第一次调用的`addObserver`。接下来的两行对应于第二次调用的`addObserver`，依此类推。
- en: Summary
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: A comparison between the mediator pattern and the observer pattern shows some
    of the similarities and differences. Both patterns facilitate the communication
    between the objects and both decouple the link between the sender and the receiver.
    The main difference is that in the mediator pattern, there is a notion of the
    participants and they communicate with each other using the mediator as a central
    hub, whereas in the observer pattern, there is a clear distinction between the
    sender and the receiver, and the receiver merely listens to the changes in the
    sender.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 中介模式与观察者模式之间的比较显示了它们的一些相似之处和不同之处。两种模式都促进了对象之间的通信，并且都解耦了发送者和接收者之间的链接。主要区别在于，在中介模式中，存在参与者概念，并且它们通过中介作为中心枢纽相互通信，而在观察者模式中，发送者和接收者之间有一个清晰的区分，接收者只是监听发送者的变化。
- en: The communication in the mediator pattern is easier to understand. Elements
    send messages to a mediator and the transmission of the information further to
    whoever is currently in the group is handled there, in one place.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 中介模式中的通信更容易理解。元素向中介发送消息，并将信息的进一步传输处理在当前组中的某个地方。
- en: In the observer pattern, observers wait to be invoked with information from
    more than one subject. The coupling is closer in the mediator than in the observer.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在观察者模式中，观察者等待从多个主题接收信息而被调用。在中介模式中，耦合比在观察者模式中更紧密。
- en: 'This concludes this chapter. In the last chapter, we will talk about the last
    three behavioral patterns the: visitor pattern, the interpreter pattern, and the
    memento pattern.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了本章的内容。在下一章，我们将讨论最后三个行为模式：访问者模式、解释器模式和备忘录模式。
