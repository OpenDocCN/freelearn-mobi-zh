- en: Chapter 7. Behavioral Patterns – Iterator, Mediator, and Observer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter presents you with three other behavioral patterns, which support
    communication between objects. Objects keep their independence and sometimes their
    anonymity. The iterator pattern is often used with array, collection, and dictionary
    objects. The mediator allows communication between two objects without knowing
    each other's identities and the observer patterns mirror the publish/subscribe
    methodologies that are well known in distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter is divided in three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: The iterator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The mediator pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The observer pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The iterator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This pattern is commonly used in many languages with an array or a collection
    of objects. It allows iteration over a list of objects contained in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator pattern allows you to iterate sequentially over an aggregated object
    of objects without having to know how the collection is structured.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here, you'll find the generic UML class diagram of the pattern, but note that
    we will not implement it using this way.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Swift provides some types that will simplify the implementation of the
    iterator pattern, without having to produce all of the needed requirements by
    hand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Why reinvent the wheel? The following figure represents the generic UML class
    diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As with every pattern described up to now, I will tell you what the participants
    in this pattern are even if we will not see all of them in our implementation
    of the pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Collection`: This is an abstract class that implements the association of
    the collection with items and the `CreateIterator()` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteCollection`: This is concrete collection subclass that link the `CurrentItem`
    object to a `ConcreteItem` object and the `Iterator` interface to the `ConcreteIterator`
    objec`t`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Iterator`: This is the abstract class, which implements the association of
    the iterator and the collection items and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteIterator`: This is a concrete subclass that links our `currentItem`
    to the `ConcreteItem` object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Item`: This is the abstract class of the collection items'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteItem`: This is a concrete `Item` subclass used by `ConcreteIterator`
    and `ConcreteCollection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The iterator keeps in memory the current item in the collection. It can also
    calculate and predict the next object of the iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are developing a game in which you can have up to say, four players. You
    want to be able to iterate over all the four players to do something. In our sample,
    we will display the name of each player.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The implementation provided here comes from ideas discovered on the Lilly Labs
    website at [http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/](http://lillylabs.no/2014/09/30/make-iterable-swift-collection-type-sequencetype/).
  prefs: []
  type: TYPE_NORMAL
- en: Well, given our illustration what we want to be able to do is to iterate using
    a `for…in` loop construct.
  prefs: []
  type: TYPE_NORMAL
- en: All thanks to Swift, we have some elements that will simplify the implementation
    of this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Indeed, Swift proposes a `SequenceType` protocol and an `AnyGeneratorType<T>`
    class, which implements the `GeneratorType` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: The `SequenceType` protocol defines a protocol that allows us to iterate over
    elements of a collection using the `for…in` loop construct. It requires that the
    class implements the `generate()` method, which returns an object conforming to
    the `GeneratorType` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: '`AnyGenerator<T>` is a class that conforms to the `GeneratorType` protocol,
    where `<T>` means `Item` of any type.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said this, how do we use all of the preceding functions to easily iterate
    over a collection of any type? Let''s say, we have the following class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we define a simple `Player` class where we pass a string in the constructor,
    which corresponds to the name of the player.
  prefs: []
  type: TYPE_NORMAL
- en: We suppose that we have four players in our game and want to be able to iterate
    over each of them to display their name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the final code to test will be something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, how to complete our code with a bonus, something that will works with
    any class that we want to iterate over? Well, we will use another concept provided
    by Swift: **extension**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing to be done is to create an object or struct that we will let
    us iterate over any class type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, we define a struct that we call `OurCollection`, where items are
    of type `T`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will be able to write the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the `for…in` loop will still not work, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even though, the players don''t implement the `SequenceType` protocol. Here
    is the magic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Wow! Lot of new things here:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we create an extension of the `OurCollection` struct by telling that
    we want to implement the `SequenceType` protocol.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we implement the `generate()` method, which will return the next type `T`
    object in the iteration. Also, note the line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Generator is an alias of `AnyGenerator<T>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We use this to simplify the writing. We can remove the type alias statement
    and write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Another function is the `anyGenerator` function tha you see here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The Swift 2.0 documentation says that the `anyGenerator` function has the following
    signature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The purpose of this function is to return a `GeneratorType` instance whose `next`
    method invokes `body` and returns the result.
  prefs: []
  type: TYPE_NORMAL
- en: So here, we start from index `0` to index `self.items.count` value and add the
    `sel.items[i++]` in the new `GeneratorType` instance. The new `GeneratorType`
    instance is returned when `i` is superior to a number of elements in the items
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also write the function such as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And also like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use a closure with the `anyGenerator` function to return a new sequence
    of elements that we can iterate over. Our final code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `iteratorPattern` project, build and run it. You will now see the
    following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The mediator pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The mediator pattern is used to reduce the coupling between classes that communicate
    with each other.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This pattern constructs an object, which manages the communication between two
    or more classes.
  prefs: []
  type: TYPE_NORMAL
- en: These classes don't know each other's implementation. The message is sent from
    the class to the mediator object.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator pattern defines an object that encapsulates how a set of objects
    will communicate with each other. Mediator promotes loose coupling by keeping
    objects from referring to each other explicitly and it also lets you vary their
    interaction independently.
  prefs: []
  type: TYPE_NORMAL
- en: The mediator is an intermediary used to decouple many peers. This pattern can
    be used when we want to design reusable components but dependencies between the
    potentially reusable pieces demonstrate the "spaghetti code" phenomenon.
  prefs: []
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following class diagram presents the generic structure of the mediator
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this pattern, we find the following participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Mediator`: This defines the mediator interface to communicate with elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteMediator`: This implements the coordination between elements and manages
    associations with elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Elements`: This is the element abstract class, which introduces common attributes,
    properties, and methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteElement1` and `ConcreteElement2`: These are concretes element classes,
    which communicate with the mediator instead of communicating with the other elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The elements send messages to the mediator and receive message from it. The
    mediator implements the collaboration and coordination between the elements.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are writing a system that allows users to communicate with each other. Communication
    is not sent directly from a peer to another. We will use some mediators that will
    manage all users and the communication between them.
  prefs: []
  type: TYPE_NORMAL
- en: For this, each user managed by the mediator will be registered (added) to the
    mediator. Then, when a user sends a message, we will pass the mediator object
    as an argument informing the system that this is the message that will broadcast
    that message to all other users managed by the mediator calling the `receiveMessage`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `MediatorPattern` Xcode project. This is a command line project that
    is organized as the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The organization of our project is not more than what we have already described
    with the participants in the class diagram. We retrieve, the `MediatorProtocol`
    and `ConcreteMediator` object in the `Mediator` folder, our `Elements` and concrete
    elements `UserProtocol` and `User` are in the `Elements` folder and last, the
    `main.swift` file contains our client code to simulate the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we define `userProtocol`, in the `UserProtocol.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `sendMessage` method will be used to tell the mediator passed in an argument
    what the message of the current `concreteUser` is. The `receiveMessage` method
    will be raised when the mediator broadcasts the message to all users.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `User.swift` file, we implement our protocol, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we add an argument in the constructor to pass the name of the user.
  prefs: []
  type: TYPE_NORMAL
- en: In the `sendMessage` method, we see that we are calling the `broadcastMessage`
    method of the mediator passed in the argument.
  prefs: []
  type: TYPE_NORMAL
- en: When raised, the `receiveMessage` method will display the name of the current
    user and also the message that was received.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, lets see how `MediatorProtocol` is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `MediatorProtocol` manages the collection of elements; here, it is `Users`.
    It can also broadcast a particular message to a user.
  prefs: []
  type: TYPE_NORMAL
- en: To add a user to the collection of users managed by the mediator, we add a `Register`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how we have implemented all of this in the `Mediator.swift` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: First, we initialize a `User` array that is ready to manage a collection of
    user.
  prefs: []
  type: TYPE_NORMAL
- en: In the `register` method, we receive a user argument, which is added to the
    collection managed by the mediator.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the `broadcastMessage` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: We need to make sure that the `user` array has not a `nil` value, if this is
    the case we then do nothing by leaving the method invoking the `return` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we iterate over all the users in the collection and if the current user
    of the iteration is different from the user sending the message (sender), then
    we call the `receiveMessage` method of the current user, along with the message
    to be transmitted.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Concurrency protection**'
  prefs: []
  type: TYPE_NORMAL
- en: 'You probably have seen the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to create concurrency protection in this pattern when various users
    try to access the same user at the same time, so we use a technology developed
    by Apple: Grand Central Dispatch which allow specific tasks in a program that
    can be run in parallel to be queued up for execution and, depending on availability
    of processing resources, scheduling them to execute on any of the available processor
    cores.'
  prefs: []
  type: TYPE_NORMAL
- en: With this line, we initialize `queue` as a concurrent queue using `dispatch_queue_create`.
    The first parameter simply describes what our queue is (it could be helpful when
    you are debugging your code) and the second parameter specifies that we want our
    queue to be concurrent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we want to protect the access to our code where arrays are read and written.
    For this, GCD provides an elegant solution of creating read/write lock using dispatch
    barrier. So we use `dispatch_barrier_sync` to pass our queue and the statement
    to execute by the queue. Since, the code we have written is a barrier closure,
    this will never run simultaneously with any other closure in queue . To see more
    about Grand Central Dispatch : [http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1](http://www.raywenderlich.com/79149/grand-central-dispatch-tutorial-swift-part-1)'
  prefs: []
  type: TYPE_NORMAL
- en: 'All our participants are now in place. We will now try all of this in the `main.swift`
    file. We create four users, each with a name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we instantiate our first mediator and add the first three users we have
    just created to the collection of users managed by `mediator1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we want to test that `user1` can send a message to `user2` and `user3`.
    We only need to invoke the `sendMessage` method of `user1` passing the `mediator1`
    and the message to be sent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: So, in this case only `user2` (Helmi) and `user3` (Adrien) should receive the
    message from `user1` (Julien).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to try the pattern with another mediator but with only two users: `user2`
    and `user4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, only `user4` (Raphael) should receive the message from `user2` (Helmi).
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run the project. You should now be able to see the following result
    in the console dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The observer pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The observer pattern is another behavioral pattern that is often used in networked
    system where a subject (the server) will notify some client. The iOS makes large
    use of this pattern through `NSNotificationCenter` object.
  prefs: []
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The observer pattern creates dependence between a subject and observer so that
    the observer is notified in order to update their state each time the subject
    is modified.
  prefs: []
  type: TYPE_NORMAL
- en: This composition means that observer does not need to ask the current state
    of the subject. They only need to register to its notifications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This pattern can be used when:'
  prefs: []
  type: TYPE_NORMAL
- en: A state modification inside the object needs to update other objects dynamically
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An object wants to prevent other objects without the need to know the type (without
    having to be high coupled with them)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We do not want to merge two objects into one
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following diagram represents the UML class diagram of the observer pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Design](img/4852_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Participants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This pattern is composed of the following participants:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Subject`: This defines the methods needed to add, remove, and notify observers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteSubject`: This implements the `Subject` methods. It sends a notification
    when its state is modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observer`: This is a common interface having an `update()` method, which will
    be invoked by the subject when the observer needs to be notified about the modification
    of the subject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ConcreteObserver1` and `ConcreteObserver2`: This implements the `update()`
    method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collaboration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `ConcreteSubject` class notifies the observers when its internal state is
    modified. When a concrete observer receives this notification, it is updated consequently.
    To complete the update, it can invoke some subject methods that give access to
    its state.
  prefs: []
  type: TYPE_NORMAL
- en: Illustration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are working on a new website where you want to allow internet users to communicate
    each other through a chat system. Your first job will be to provide a room, the
    entry point of all Internet users. Each time a new user joins the room, every
    user is notified.
  prefs: []
  type: TYPE_NORMAL
- en: The observer pattern is fully appropriated to implement the code, which solves
    this problem.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Open the `ObserverPattern` Xcode project to see the current structure of our
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We will retrieve the `Subject` folder and `Observers` folder, where we will
    find the participants of our pattern. The `Helpers` folder contains a class that
    we will use later when sending a message.
  prefs: []
  type: TYPE_NORMAL
- en: The `Extension` folder contains an array extension that is required to make
    it possible for us to remove a particular object from the collection of users
    managed by the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we find the `main.swift` file used to simulate interactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let us begin our code by defining our observer in the `UserProtocol.Swift`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We simply define an update method with an object as an argument. The implementation
    of the `UserProtocol` will be like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We pass a name in the constructor of the `User` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `update` method, we prepare a message that will be displayed on
    the console. We downcast our object of type `AnyObject` to an `Info` object; this
    object is a helper. You will find its code in the `Helper` folder in the `Info.swift`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Info` object contains three values: a date, message, and status.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The date is the current date and is defined when the `Info` object is initialized.
    The message is a string received in argument during initialization of the info
    object and the status is an enumeration passed in an argument during the initialization
    of the object and it can have the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Now, we only have to define our Subject protocol, and implement it in our concrete
    Subject. The Subject represents the object that need to be observed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our Subject definition is available in the `RoomProtocol.swift` file in the
    `Subject` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: These three methods are the minimum necessary to any subject in an observer
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: The `addObserver` function lets you register an observer in the collection of
    observers managed by the subject.
  prefs: []
  type: TYPE_NORMAL
- en: The `removeObserver` method is used to remove an observer from the collection
    managed by the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Last, the `notifyObserver` method is used to notify all our observers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation will be found in the `Room.swift` file, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, you retrieve the three methods, in the two first one; you see a call to
    the `notifyObserver` method.
  prefs: []
  type: TYPE_NORMAL
- en: All the users will be notified each time the `addObserver` or `removeObserver`
    method is called because the `addObserver` method is called when a new user joins
    the room and we display the `Join` status in the `Info` message. With the same
    principle, we display the `Leave` status when the `removeObserver` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: The `notifiyObserver` method receives an object of type `AnyObject` as an argument
    that will be propagated over the update method of each user object available in
    the collection managed by the `Room` method.
  prefs: []
  type: TYPE_NORMAL
- en: Time for us to now write our demo code, open the `main.swift` file, and write
    the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we initialize our `Room` method and four internet users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we register each user to the room:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time the `addObserver` method is called, all the currently registered users
    will be notified that the current registered user has joined.
  prefs: []
  type: TYPE_NORMAL
- en: So, when `room.addObserver(user1)` is called, only `user1` will be notified,
    but when `user2` is registered, `user1` and `user2` will be notified and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we remove `user2`, `user3`, and `user1` in this order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'To complete our sample, we register `user2` once more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Let us now build and run the project. You will get the following result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementation](img/4852_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see all the notifications. The first line corresponds to the first
    `addObserver` called. The next two lines correspond to the second `addObserver`
    called, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A comparison between the mediator pattern and the observer pattern shows some
    of the similarities and differences. Both patterns facilitate the communication
    between the objects and both decouple the link between the sender and the receiver.
    The main difference is that in the mediator pattern, there is a notion of the
    participants and they communicate with each other using the mediator as a central
    hub, whereas in the observer pattern, there is a clear distinction between the
    sender and the receiver, and the receiver merely listens to the changes in the
    sender.
  prefs: []
  type: TYPE_NORMAL
- en: The communication in the mediator pattern is easier to understand. Elements
    send messages to a mediator and the transmission of the information further to
    whoever is currently in the group is handled there, in one place.
  prefs: []
  type: TYPE_NORMAL
- en: In the observer pattern, observers wait to be invoked with information from
    more than one subject. The coupling is closer in the mediator than in the observer.
  prefs: []
  type: TYPE_NORMAL
- en: 'This concludes this chapter. In the last chapter, we will talk about the last
    three behavioral patterns the: visitor pattern, the interpreter pattern, and the
    memento pattern.'
  prefs: []
  type: TYPE_NORMAL
