- en: Adding Animation to Your Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have learned how to create sprites on screen as well as made our background
    image scroll continuously. Sprites are basically just images, which are used for
    game assets. Now, it is time to add a bit more spice to it and make it interesting.
    In this chapter, we will make our player character appear on screen on top of
    our background and add an animation that will make the player run. In this chapter,
    you will learn the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating sprite animations based on sprite sheets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running basic animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an abstract class to serve as a foundation for our future game objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have a running character on screen. So
    let's begin!
  prefs: []
  type: TYPE_NORMAL
- en: Adding animations to make your game more awesome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To start this chapter, we will need a collection of images, which we call sprites.
    We saw in the previous chapter how we had used  `image_1` and `image_2` as examples,
    but we will expand on them and make this more interesting. We will try and make
    a proper run cycle of our player character in a sprite sheet. To understand this
    in a better way, let''s take a look at the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_05_01.png)'
  prefs: []
  type: TYPE_IMG
- en: Our run cycle animation sprites
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding image, you can observe we have a set of images that are prefixed
    with the text `Run` followed by a set of numbers that represent frames. So, basically,
    we will loop from frame `Run_000` to `Run_009`, which will give us a continuous
    running effect. However, for the sake of simplicity, we will be merging these
    frames into one single image and read pixel data from it. Also, to keep it simple,
    we will only make the run cycle animation to three frames. If you want, you can
    add more frames for better animation quality. So, we will be using the following
    sprite sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is what an actual sprite sheet looks like; we will name this sprite sheet
    as player_run.png
  prefs: []
  type: TYPE_NORMAL
- en: We will be dealing with pixels to run our animation, so it is extremely important
    for us to know the dimensions of this image. In simple terms, we need to know
    the width and height of this image in pixels. The dimensions of one frame of our
    image are 200 x 82 pixels, where 200 represents the width and 82 represents the
    height of our image. In our sprite sheet, we have three such sprites. Thus, we
    simply multiply our width by the number of images in our sprite sheet, which is
    three in this case. So, the overall width of our image is 600 pixels. As you can
    see, we are using an image that has a landscape orientation, which means that
    our image's width is more than the height, so our height dimension remains the
    same. So, basically to run our animation, we only need to scan through our frames
    horizontally. The final resolution of our sprite sheet is 200 x 82.
  prefs: []
  type: TYPE_NORMAL
- en: The resolution of your image might differ from the ones in this book, so make
    sure that you calculate the numbers properly before proceeding with writing them
    in the code.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s dive into the art of animating our player character; however, before
    we do that, we also need to create our player character on screen. Here''s our
    task list for now:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a player on screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make Run animation play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once we are done with these two objectives, we will take touch input in order
    to make our player jump.
  prefs: []
  type: TYPE_NORMAL
- en: Making our player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We saw in the previous chapter how to create our background image. In theory,
    it is almost similar to the previous chapter to create our player character, but
    since we are going to deal with animations in the further part of this chapter,
    we will need to modify our code a bit. Let's get started with that first.
  prefs: []
  type: TYPE_NORMAL
- en: Now, as a programmer, you have to keep in mind that there are many ways to do
    one particular thing; therefore, just as a demonstration to get a clearer understanding,
    we will modify our background image code a little. Open up your `BackgroundImage.java`
    file and remove the `setVector` method. Now, you will see that there will be an
    error in our `GameView.java` file since our `setVector` method does not exist;
    let's fix that. Make a static final variable, which will be accessible from any
    class. We will then set it as a speed variable. Then, in our `BackgroundImage.java`
    file's constructor, we will set the displacement variable as the speed for this.
    Here's how we will modify our code blocks. Code changes are marked in bold.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the code for `BackgroundImage.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let''s take a look at the code for `GameView.java`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, we haven't done anything really here. We have just modified a logic with
    different variables. In a similar fashion, you can also apply your own logic to
    come up with different ways to do one particular thing. Let's now move on to actually
    make our player character appear on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Try tweaking the code with your own logic and keeping the output same as a challenge
    to test your skills.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will now create an abstract class for our future game objects, such as our
    player character, missiles, and everything else. We are doing this because there
    are some sets of data, which are required in almost every object we will be creating
    in future for our game. So, for the purpose of reusability and persistence, we
    will create this class. We will call it `GameObj.java`. Go ahead and create your
    new class with the steps that we learned from our previous chapters and write
    the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: So, here we have our abstract `GameObj.java` class file, which has the variables
    and get set methods for them. Observe here that we have also used a `getRectangle()`
    method. This method will be used in the next chapter when we will be working with
    collisions. In theory, to detect collisions on any object, we need to get its
    rectangular bounds. Anyway, moving ahead, let's now create our `Player` class
    with the help of this new abstract class we made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new class and name it `PlayerCharacter.java`, and write the following
    code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now understand what we have done in our `PlayerCharacter` code in further
    detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We created our class and extended it to our abstract class, `GameObj`, to get
    access to all the default variables needed for our `PlayerCharacter`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created the default constructor for our `PlayerCharacter` in which we pass
    the required data to draw `PlayerCharacter` on screen just like the image component
    is passed in the `res` variable along with the width and height of our image with
    the number of frames we need in our animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our constructor, we created a `for` loop, which will run through our sprite
    sheet and give us the animation effect followed by a 10-millisecond delay to play
    our animations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then created our `setUp()` function, which will take care of the jumping
    functionality of our player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our `update()` function, we created a loop of events that assign a `score`
    to the player as well as keep the player between upper and lower bounds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this, we created the `draw()` method, which gets the animation from our
    `ac` variable and drew it onto our canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is then followed by simple get and set methods for rest of the variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our player character is ready; however, we still have to write our `AnimationClass`.
    As you can clearly observe, you must be getting an error on the `AnimationClass`
    line. So, let''s go ahead and create our `AnimationClass.java` file and write
    the following code in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This `AnimationClass.java` file is important to run our character''s animations.
    Our `AnimationClass` has three main functions, namely `setFrames()`, `update()`,
    and `getImage()`. Let''s take a look at what we have done in this class:'
  prefs: []
  type: TYPE_NORMAL
- en: We created variables that are needed to access our frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created variables that will control the start time and delay between animation
    frames
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We created a Boolean, which will trigger the animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we created a `setFrames()` function, to set frames and set the current
    frame to `0` at start
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After that, a `setDelay()` function, was created in order to tell the animation
    to run at short intervals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We then created a `setFrame()` function to set the current frame in the running
    animation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our `update()` function, we started calculating the delay in terms of milliseconds
    using some simple math calculations, and upon certain intervals, switched the
    frame of the image
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We added a condition that if our last frame has elapsed then we will reset our
    current frame to 0 in order to give a continuous looping effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In our `getImage()` function, we simply return the value of the image that is
    currently being drawn on the screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `getFrame()` function returns us the integer value of the current frame
    that is being displayed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the last function, `playedOnce()`, as a placeholder for our further gameplay
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`setFrames()` and `setFrame()` are two different functions. `setFrames()` is
    used to initialize our frames from 0, whereas `setFrame()` is used to set frames
    individually while running.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, before moving on to the next part, ensure that you have your image in
    your drawable folder that you want to use for our player character. Once you have
    it, it''s now time to move on to the next step and instantiate our player on screen.
    The procedure for this is the same as we did with our background image. Modify
    your `GameView.java` file code to look like this; changes from the preceding code
    have been highlighted in bold:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a breakdown of what we did here:'
  prefs: []
  type: TYPE_NORMAL
- en: We created a reference variable for our `PlayerCharacter` using the variable
    `playerCharacter`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, in our `surfaceCreated()` method, we gave the `playerCharacter` class
    constructor all the values that it requires. We passed the `player_run` image
    into this code for it to fetch our player's sprite sheet. In the parameters for
    the constructor of `PlayerCharacter(BitmapFactory.decodeResource(getResources(),R.drawable.player_run),w/3,h,3);`,
    the 'w' corresponds to the width of the image and 'h' corresponds to the height
    of the image. The parameter 3 here will depend on the number of frames of your
    sprite. If you have six frames in your sprite, then the parameters would be `(w/6,h,6)`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After that, in our `update()` method, which is after `bgImg.update()`, we called
    the `playerCharacter.update()` method that gives a call to the update function
    of our `PlayerCharacter` and thereby plays the animation from the `AnimationClass.java`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, we then drew our player character onto our canvas using the `playerCharacter.draw(canvas);`
    code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After you are done with these steps, build and run your game on an emulator
    or your Android phone device; you will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B05066_05_03.png)'
  prefs: []
  type: TYPE_IMG
- en: Hurray! Our player character is running on the screen (literally)
  prefs: []
  type: TYPE_NORMAL
- en: If you have done everything correctly, then you will have your player character
    running on the screen on the spot while your background is scrolling continuously;
    almost half of our game is done here.
  prefs: []
  type: TYPE_NORMAL
- en: Since we have created our `GameObj` class, we will be relying on it heavily
    for our further game objects, such as missiles, particle effects, and everything
    else.
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! You just created your first animation!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to effectively create animations from your
    sprite sheet as well as create an abstract class to create a foundation for your
    future game objects. In the next chapter, we will learn how to create our game
    even more interesting by controlling our animation based on touch inputs. We will
    learn about collision detection along with creating a missile AI that will spawn
    from the extreme right of the screen, and our objective will be to dodge the missile.
  prefs: []
  type: TYPE_NORMAL
- en: We will learn about different collision techniques as well as create interactive
    objects, where we will also add a score on collecting them instead of just incrementing
    the score with time.
  prefs: []
  type: TYPE_NORMAL
