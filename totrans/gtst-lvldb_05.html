<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Using Objective-C</h1></div></div></div><p>As we've seen, the native C++ interface of LevelDB is fairly simple. However, most OS X and iOS programmers want to be able to use their familiar <code class="literal">NSData</code> and <code class="literal">NSString</code> data types with a database. The use of <a id="id98" class="indexterm"/>
<strong>blocks</strong> is steadily increasing in Cocoa APIs, as a way to apply small pieces of logic to collections of data. Some people also have a strong aversion to using C++ and will avoid anything that lacks an Objective-C interface.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec22"/>Open source wrappers for LevelDB in Objective-C</h1></div></div></div><p>There are three <a id="id99" class="indexterm"/>significant Objective-C wrappers for LevelDB, all started in 2011 when it was announced. They are the top hits and links if searching for <a id="id100" class="indexterm"/>Objective-C LevelDB.</p><p>Two come with their own projects to build a library or framework, but as of June 2013, these didn't work with Xcode 4.6 or higher. These two include a valuable suite of unit tests in each but not examples for iOS. Their relative popularity is hard to judge.</p><p>Instead of trying to fix their builds, our downloadable <code class="literal">Sample05</code> has OS X and iOS projects with all three wrappers' source included and a common set of tests. It uses the LevelDB libraries we created earlier. This approach of copying the wrapper classes is more likely to survive changes in Xcode and lets you debug by stepping into source.</p><p>
<code class="literal">Sample05</code> is a very important sample to explore the code in its entirety as it includes demo code in Objective-C of all the data updating and iteration concepts we have seen so far, rewritten from C++ for each of the three wrappers. This lets you see the stylistic differences side-by-side. The code samples in this chapter use all three, for contrast.</p><p>
<strong>LevelDB-ObjC</strong>, from <a class="ulink" href="https://github.com/hoisie/LevelDB-ObjC">https://github.com/hoisie/LevelDB-ObjC</a>, was the earliest and simplest wrapper, <a id="id101" class="indexterm"/>providing the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A way to call the basic <code class="literal">Put</code>, <code class="literal">Get</code>, and <code class="literal">Delete</code> operations with <code class="literal">NSString</code></li><li class="listitem" style="list-style-type: disc">Storing objects and dictionaries or arrays of objects using <code class="literal">NSKeyedArchiver</code> to encode them into the value</li><li class="listitem" style="list-style-type: disc">Iteration through all keys with a block that can stop the iteration</li></ul></div><p>
<strong>APLevelDB</strong> from <a class="ulink" href="https://github.com/preble/APLevelDB">https://github.com/preble/APLevelDB</a> is partly based on LevelDB-ObjC, trying to be a <a id="id102" class="indexterm"/>cleaner Objective-C wrapper, and:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Adds separate iterators and direct array-like access with subscripting: <code class="literal">db[@"key"] = @"value"</code></li><li class="listitem" style="list-style-type: disc">Adds <code class="literal">WriteBatch</code> support as a separate protocol</li><li class="listitem" style="list-style-type: disc">Cleanly separates out different concepts into different protocols</li><li class="listitem" style="list-style-type: disc">Rather than burying an encoding implementation, gets and sets <code class="literal">NSData</code> so you can do your own encoding and pass it via <code class="literal">NSData*</code></li></ul></div><p>
<strong>NuLevelDB</strong>, from <a class="ulink" href="https://github.com/nulayer/NULevelDB">https://github.com/nulayer/NULevelDB</a>, is a very ambitious layer with many classes, <a id="id103" class="indexterm"/>featuring the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">NSData</code> is used for keys as well as values, making it easy to compose complex keys, as well as the <code class="literal">NSString</code> keys and values like the others</li><li class="listitem" style="list-style-type: disc">Separate optimized 64 bit integer keys and a lot of enumerate (iteration) methods for ranges and arbitrary sets of integer keys</li><li class="listitem" style="list-style-type: disc">Consistent use of the <code class="literal">NSError**</code> parameters to get errors back</li><li class="listitem" style="list-style-type: disc">Easy copying an entire database or a specific list of keys, to/from <code class="literal">NSDictionary</code> and <code class="literal">NSArray</code>, in the file <code class="literal">NULDBDB+BulkAccess.m</code>;</li><li class="listitem" style="list-style-type: disc">Its own <code class="literal">NULDBSerializable</code> protocol for exploding an object into a set of individual key/value pairs.</li></ul></div><p>Some of the following listed issues may not be issues for everyone. Remember these wrappers are open source and easy to extend, if you lack a feature. The following are the most serious issues with the different wrappers, or points most likely to dissuade you from using a particular one. I found APLevelDB easier to extend with minor changes. The issues are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">LevelDB-ObjC and <a id="id104" class="indexterm"/>NuLevelDB are not ARC-compliant.</li><li class="listitem" style="list-style-type: disc">LevelDB-ObjC <a id="id105" class="indexterm"/>exposes the <code class="literal">leveldb/db.h</code> header so you have to make any files using it into <code class="literal">.mm</code> Objective-C++ source.</li><li class="listitem" style="list-style-type: disc">LevelDB-ObjC <a id="id106" class="indexterm"/>and <a id="id107" class="indexterm"/>APLevelDB's iteration methods lack any way to specify ranges so you lose most of the power of LevelDB. Their blocks can end the iteration but you can't start from a given key or part-key.</li><li class="listitem" style="list-style-type: disc">NuLevelDB has a <a id="id108" class="indexterm"/>very rich iteration support but ignores any database's custom comparator and uses just the LevelDB's <code class="literal">BytewiseComparator</code> class method.</li><li class="listitem" style="list-style-type: disc">None of them expose the full read and write options of LevelDB. NuLevelDB is best with properties for write <code class="literal">sync</code> and read <code class="literal">fill_cache</code>.</li></ul></div><div><div><h3 class="title"><a id="tip08"/>Tip</h3><p>
<strong>ARC</strong> (<strong>Automatic Reference Counting</strong>) <a id="id109" class="indexterm"/>was introduced in OS X Lion and iOS 5 and by now is used in most new Objective-C code. However, much older source has not been converted to ARC. To use non-ARC source files in an ARC project, use the <strong>Build Phases</strong> tab, <strong>Compile Sources</strong> section, and add the flag <code class="literal">–fno-objc-arc</code> on each file as needed. You will know this is necessary because of an <strong>ARC Restrictions</strong> compiler error.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec23"/>Using Objective-C for simple data access</h1></div></div></div><p>The core data creation, finding <a id="id110" class="indexterm"/>and deleting we saw in <a class="link" href="ch03.html" title="Chapter 3. Basic Key-value Operations – Creating and Deleting Data">Chapter 3</a>, <em>Basic Key-value Operations–Creating and Deleting Data</em>, looks like this with the LevelDB-ObjC wrapper.</p><p>Create a database object and open a file:</p><div><pre class="programlisting">LevelDB* db = [[LevelDB alloc]
  initWithPath:pathToSampleDB(sampleDBname) ];</pre></div><p>Check to be sure a key doesn't exist, and then add a couple of records, checking that the <code class="literal">Packt</code> key works but lowercase <code class="literal">packt</code> still fails:</p><div><pre class="programlisting">assert( [db getString:@"Packt"] == nil );
[db putObject:@"Getting Started" forKey:@"Packt"];
[db putObject:@"with Leveldb" forKey:@"Packt2"];
assert( [[db getString:@"Packt"]
  isEqualToString:@"Getting Started"] );
assert( [db getString:@"packt"] == nil );</pre></div><p>Write an existing key again, changing its value, and check to make sure that it has changed:</p><div><pre class="programlisting">[db putObject:@"Is Started" forKey:@"Packt"];
assert( [[db getString:@"Packt"] isEqualToString:@"Is Started"] );</pre></div><p>Compose a key with an embedded null, using a different way to create an <code class="literal">NSString</code> object from arbitrary characters, and prove we can read it back by that key:</p><div><pre class="programlisting">const char enBuf[] = {"APrefix\0Packt in a string"};
NSString* keyWithNull = [NSString stringWithCharacters:(const
  unichar*)enBuf length:25];
[db putObject:@"Part Key with embedded null" forKey:keyWithNull];
assert( [[db getString:keyWithNull]
  isEqualToString:@"Part Key with embedded null"] );</pre></div><p>Delete a record and check to be sure it can no longer be read:</p><div><pre class="programlisting">[db deleteObject:@"Packt"];
assert( [db getString:@"Packt"] == nil );</pre></div><p>We can print out all the keys that were just added, like <code class="literal">Sample04</code>, but will use a block to stop after the first three records. A typical use of a block is to process data from a collection, either just the keys or <a id="id111" class="indexterm"/>both keys and values. Most of the iterators using blocks also allow the block to stop iteration by returning <code class="literal">NO</code>:</p><div><pre class="programlisting">  __block int count = 0; // updateable counter outside the block
  [db iterateKeys:^(NSString* key) {
    printStr( key );
    return (++count &lt; 3) ? YES : NO;  // block returns a BOOL
  }];</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec24"/>Extending APLevelDB to expose the C++ API</h1></div></div></div><p>If we want to add our <a id="id112" class="indexterm"/>own extensions to APLevelDB or the other wrappers, the internal <code class="literal">leveldb::DB*</code> has to be exposed. Just getting that <a id="id113" class="indexterm"/>pointer is enough to be able use all the C++ logic we saw in earlier chapters. This requires a minor change to <code class="literal">APLevelDB.h</code>.</p><p>Firstly declare a return type for <code class="literal">getDB</code> which can be safely included in pure Objective-C so we don't force people to move to Objective-C++ with <code class="literal">.mm</code> files:</p><div><pre class="programlisting">#ifdef __cplusplus // forward declaration
  namespace leveldb { class DB; }
  typedef leveldb::DB* leveldbDBPtr;
#else
  typedef void* leveldbDBPtr;
#endif</pre></div><p>Then inside <code class="literal">@interface APLevelDB : NSObject</code> add a public getter:</p><div><pre class="programlisting">- (leveldbDBPtr) getDB;</pre></div><p>This is simply implemented in <code class="literal">ApLevelDB.mm</code>:</p><div><pre class="programlisting">- (leveldbDBPtr) getDB   {  return _db; }</pre></div><p>Now we can add a <a id="id114" class="indexterm"/>
<strong>class category</strong> to extend <code class="literal">APLevelDB</code> with other methods. Just one is shown here. We declare a <a id="id115" class="indexterm"/>method taking a prefix string and applying a block to the keys which match that prefix, passing a <code class="literal">BOOL</code> parameter so the block can stop enumerating:</p><div><pre class="programlisting">@interface APLevelDB (APLevelDB_ADSearches)
- (void)enumerateKeysWithPrefix:(NSString*)prefix
  block:(void (^)(NSString *key, BOOL *stop))block;
@end

@implementation APLevelDB (APLevelDB_ADSearches)
- (void) enumerateKeysWithPrefix:(NSString*)prefix
  Keys:(void (^)(NSString* key, BOOL* stop))block
{
  BOOL stop = NO;
  leveldb::Slice prefixSlice = SliceFromString(prefix);
  std::unique_ptr&lt;leveldb::Iterator&gt; iter(
    [self getDB]-&gt;NewIterator(leveldb::ReadOptions()) );
  for (iter-&gt;Seek(prefixSlice);
    iter-&gt;Valid() &amp;&amp; iter-&gt;key().starts_with(prefixSlice);
    iter-&gt;Next()) {
  NSString *k = StringFromSlice( iter-&gt;key() );
  block(k, &amp;stop);
  if (stop)
    break;
  } 
}</pre></div><p>That's a simple example of how being able to get the database pointer allows writing some Objective-C++ code to add methods to APLevelDB. A similar technique can be used to extend the <a id="id116" class="indexterm"/>other frameworks. It also shows how Objective-C++ allows us to mix languages. The method <code class="literal">enumerateKeysWithPrefix:block</code> is an extension to APLevelDB with a pure <a id="id117" class="indexterm"/>Objective-C interface. It takes a block which can be pure Objective-C. The bits of C++ are the call to <code class="literal">NewIterator</code> and loop through the <a id="id118" class="indexterm"/>records calling the block. However, you could also just pass the <code class="literal">leveldb::DB*</code> to pure C++ .</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec25"/>Importing text data to load a database</h1></div></div></div><p>The following function shows a <a id="id119" class="indexterm"/>complete loop for importing a tab-delimited text file and generating records using the APLevelDB database. The <code class="literal">Sample500.txt</code> <a id="id120" class="indexterm"/>file is bundled with both the OS X and iOS projects. We use a little helper function in <code class="literal">main06ios.m</code> or <code class="literal">main06osx.m</code>, to find the data file relative to the application. This finds a file bundled into an app package of Cocoa iOS or OS X app, a common way to include demos:</p><div><pre class="programlisting">NSString* pathToBundledData(NSString* filename)
{
  return [[NSBundle mainBundle]
    pathForResource:filename ofType:@""];
}</pre></div><p>Command-line OS X tools such as <code class="literal">Sample05</code> don't automatically bundle files. To get the sample copied relative to the app, it was added to the <strong>Build Phases</strong> tab's <strong>Copy Files</strong> setting the relative path <code class="literal">./SampleData</code> as used in the helper function:</p><div><pre class="programlisting">NSString* pathToBundledData(NSString* filename)
{
  return [@"./SampleData/" stringByAppendingString:filename];
}</pre></div><p>Here's the function void <code class="literal">testAPLevelDBImportStrings</code> in its entirety. Open the text file, reading it into a single string <a id="id121" class="indexterm"/>then splitting into an array of lines:</p><div><pre class="programlisting">NSString* tabSepStr = [NSString
  stringWithContentsOfFile:pathToBundledData(@"Sample500.txt")
  encoding:NSUTF8StringEncoding error:&amp;openError];
NSArray* tabbedLines = [tabSepStr
  componentsSeparatedByCharactersInSet:
    [NSCharacterSet newlineCharacterSet]];</pre></div><p>Create a database, using another helper function <code class="literal">pathToSampleDB</code>:</p><div><pre class="programlisting">NSError* openError;
APLevelDB* db = [APLevelDB
  levelDBWithPath:pathToSampleDB(@"testImportAPLeveldb05")
  error:&amp;openError];</pre></div><p>In one <code class="literal">WriteBatch</code>, for speed and safety, loop through the array of lines, separating each at a tab and writing two records per line. The first key is a combination of last and first name and contains a JSON-encoded array. The second record is keyed by the phone number field and its value is the first key, <a id="id122" class="indexterm"/>so it's like a secondary index. This is shown in the following code:</p><div><pre class="programlisting">id tabSep = [NSCharacterSet   
  characterSetWithCharactersInString:@"\t"];
id&lt;APLevelDBWriteBatch&gt; wb = [db beginWriteBatch];  
for (NSString* line in tabbedLines) {
  NSArray* fields = [line
    componentsSeparatedByCharactersInSet:tabSep];
  NSString* nameKey = [NSString stringWithFormat:@"%@|%@",
    fields[1], fields[0]];
  NSError* encErr;
  NSData* enc = [NSJSONSerialization dataWithJSONObject:fields
    options:0 error:&amp;encErr];
  [wb setData:enc forKey:nameKey];  // main record
  if ([fields[5] length] &gt; 0)
    [wb setString:nameKey forKey:fields[5];
}
[db commitWriteBatch:wb];</pre></div><p>This uses Apple's standard <code class="literal">NSJSONSerialization</code> to pack a record, which does simple quoting to store an array as a <a id="id123" class="indexterm"/>string, for example:</p><div><pre class="programlisting">["Prince","Kauk","Mckesson Drug Co","AZ","85027","623-581-7435","prince@kauk.com"]</pre></div><p>To unpack the record, we get the data back with <code class="literal">dataForKey</code> and then recreate an array with the method <code class="literal">JSONObjectWithData</code>:</p><div><pre class="programlisting">NSData* jsonRec = [db2 dataForKey:@"Bayer|Reva"];
NSError* decErr;
NSArray* ja = [NSJSONSerialization
  JSONObjectWithData:jsonRec options:0 error:&amp;decErr];</pre></div><p>This approach can serialize dictionaries and arrays of simple types such as <code class="literal">NSString</code>, including nested arrays and dictionaries. If your data is mostly text, it is reasonably compact and efficient. Using other variants of <code class="literal">NSCoder</code> lets you store and recreate your own objects, but you have to write <a id="id124" class="indexterm"/>overrides for encoding and decoding methods.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Summary</h1></div></div></div><p>A quick look at the Objective-C wrappers for LevelDB showed us how they are used for the same tasks we mastered in C++. You also learned a general technique for loading text data bundled with your app. The text data loader showed a new way to encode the data values for a key and build a secondary index of phone numbers. We will now move on to putting a Cocoa user interface on top of this to see the data in something more exciting than a console output window.</p></div></body></html>