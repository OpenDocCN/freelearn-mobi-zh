["```swift\nprotocol PersonProtocol {\n    var firstName: String { get set } \n    var lastName: String { get set } \n    var birthDate: Date { get set } \n    var profession: String { get }\ninit(firstName: String,lastName: String, birthDate: Date)\n} \n```", "```swift\nfunc updatePerson(person: PersonProtocol) -> PersonProtocol {\n    // Code to update person goes here \nreturn person\n} \n```", "```swift\nvar myPerson: PersonProtocol \n```", "```swift\nvar people: [PersonProtocol] = [] \n```", "```swift\nvar test = PersonProtocol(firstName: \"Jon\", lastName: \"Hoffman\", birthDate:bDateProgrammer) \n```", "```swift\nvar myPerson: PersonProtocol\nmyPerson = SwiftProgrammer(firstName: \"Jon\", lastName: \"Hoffman\", birthDate: bDateProgrammer)\nprint(\"\\(myPerson.firstName) \\(myPerson.lastName)\")\nmyPerson = FootballPlayer(firstName: \"Dan\", lastName: \"Marino\", birthDate:bDatePlayer)\nprint(\"\\(myPerson.firstName) \\(myPerson.lastName)\") \n```", "```swift\nfor person in people { \n    print(\"\\(person.firstName)\\(person.lastName):\\(person.profession)\")\n} \n```", "```swift\nfor person in people {\n    if let p = person as? SwiftProgrammer { \n        print(\"\\(person.firstName) is a Swift Programmer\")\n    }\n} \n```", "```swift\nfor person in people {\n    switch person {\n        case is SwiftProgrammer:\n            print(\"\\(person.firstName) is a Swift Programmer\") \n        case is FootballPlayer:\n            print(\"\\(person.firstName) is a Football Player\") \n        default:\n            print(\"\\(person.firstName) is an unknown type\")\n    }\n} \n```", "```swift\nfor person in people where person is SwiftProgrammer { \n    print(\"\\(person.firstName) is a Swift Programmer\")\n} \n```", "```swift\nfor person in people {\n    if let p = person as? SwiftProgrammer { \n        print(\"\\(person.firstName) is a Swift Programmer\")\n    }\n} \n```", "```swift\nprotocol Dog {\n    var name: String { get set } \n    var color: String { get set }\n} \n```", "```swift\nstruct JackRussel: Dog{ \n    var name: String\n    var color: String\n}\nclass WhiteLab: Dog{\n    var name: String\n    var color: String\n    init(name: String, color: String) {\n        self.name = name\n        self.color = color\n    }\n}\nstruct Mutt: Dog{ \n    var name: String \n    var color: String\n} \n```", "```swift\nprotocol Dog{\n    var name: String { get set } \n    var color: String { get set } \n    func speak() -> String\n} \n```", "```swift\nstruct JackRussel: Dog{ \n    var name: String\n    var color: String\n    func speak() -> String { \n        return \"Woof\"\n    }\n}\nclass WhiteLab: Dog{ \n    var name: String \n    var color: String\n    init(name: String, color: String) { \n        self.name = nameself.color = color}\n    func speak() -> String { \n        return \"Woof\"\n    }\n}\nstruct Mutt: Dog{ \n    var name: String \n    var color: String\n    func speak() -> String { \n        return \"Woof Woof\"\n    }\n} \n```", "```swift\nprotocol Dog{\n    var name: String { get set } \n    var color: String { get set }\n}\nextension Dog{\n    func speak() -> String { \n      return \"Woof Woof\"\n    }\n  } \n```", "```swift\nstruct JackRussel: Dog{\n    var name: String\n    var color: String\n}\nclass WhiteLab: Dog{\n    var name: String\n    var color: String\n    init(name: String, color: String) {\n        self.name = name\n        self.color = color\n    }\n}\nstruct Mutt: Dog{ \n    var name: String \n    var color: String\n} \n```", "```swift\nlet dash = JackRussel(name: \"Dash\", color: \"Brown and White\")\nlet lily = WhiteLab(name: \"Lily\", color: \"White\")\nlet maple = Mutt(name: \"Buddy\", color: \"Brown\")\nlet dSpeak = dash.speak() // returns \"woof woof\" \nlet lSpeak = lily.speak() // returns \"woof woof\" \nlet bSpeak = maple.speak() // returns \"woof woof\" \n```", "```swift\nstruct Mutt: Dog{ \n    var name: String \n    var color: String\n    func speak() -> String {\n        return \"I am hungry\"\n    }\n} \n```", "```swift\nprotocol TextValidating {\n    var regExMatchingString: String { get } \n    var regExFindMatchString: String { get } \n    var validationMessage: String { get }\n    func validateString(str: String) -> Bool\n    func getMatchingString(str: String) -> String?\n} \n```", "```swift\nstruct AlphaValidation1: TextValidating {\n    static let sharedInstance = AlphaValidation1()\n    private init(){}\n    let regExFindMatchString = \"^[a-zA-Z]{0,10}\"\n    let validationMessage = \"Can only contain Alpha characters\" \n    var regExMatchingString: String {\n        get {\n            return regExFindMatchString + \"$\"\n        }\n    }\n    func validateString(str: String) -> Bool {\n        if let _ = str.range(of: regExMatchingString, options:                   .regularExpression) {\n        return true\n    } else {\n        return false\n        }\n    }\n    func getMatchingString(str: String) -> String? {\n        if let newMatch = str.range(of: regExFindMatchString,\n                          options:.regularExpression) {\n        return String(str[newMatch])\n    } else {\n        return nil\n        }\n    }\n} \n```", "```swift\nprotocol TextValidating {\n    var regExFindMatchString: String { get } \n    var validationMessage: String { get }\n} \n```", "```swift\nextension TextValidating {\n    var regExMatchingString: String { \n        get {\n            return regExFindMatchString + \"$\"\n        }\n    }\n    func validateString(str: String) -> Bool {\n        if let _ = str.range(of:regExMatchingString,                   options:.regularExpression){\n        return true\n    } else {\n        return false\n        }\n    }\n    func getMatchingString(str: String) -> String? {\n        if let newMatch = str.range(of:regExFindMatchString,                          options:.regularExpression) {\n        return str.substring(with: newMatch)\n    } else {\n        return nil\n        }\n    }\n} \n```", "```swift\nstruct AlphaValidation: TextValidating {\n    static let sharedInstance = AlphaValidation()\n    private init(){}\n    let regExFindMatchString = \"^[a-zA-Z]{0,10}\"\n    let validationMessage = \"Can only contain Alpha characters\"\n}\nstruct AlphaNumericValidation: TextValidating {\n    static let sharedInstance = AlphaNumericValidation() \n    private init(){}\n    let regExFindMatchString = \"^[a-zA-Z0-9]{0,15}\"\n    let validationMessage = \"Can only contain Alpha Numeric characters\"\n}\nstruct DisplayNameValidation: TextValidating {\n    static let sharedInstance = DisplayNameValidation() \n    private init(){}\n    let regExFindMatchString = \"^[\\\\s?[a-zA-Z0-9\\\\-_\\\\s]]{0,15}\"\n    let validationMessage = \"Can only contain Alphanumeric Characters\"\n} \n```", "```swift\nvar testString = \"abc123\"\nvar alpha = AlphaValidation.sharedInstance alpha.getMatchingString(str:testString) \nalpha.validateString(str: testString) \nAlphaValidation type. Then getMatchingString() is used to retrieve the longest matching prefix of the test string, which will be abc. Then, the validateString() method is used to validate the test string, but since the test string contains numbers, the method will return false.\n```", "```swift\nstruct Name {\n    var firstName = \"\"\n    var lastName = \"\"\n} \n```", "```swift\nlet name1 = Name(firstName: \"Jon\", lastName: \"Hoffman\")\nlet name2 = Name(firstName: \"John\", lastName: \"Hoffman\")\nlet name3 = Name(firstName: \"Jon\", lastName: \"Hoffman\") \n```", "```swift\nname1 == name2\nname1 == name3 \n```", "```swift\nstruct Name: Equatable {\n    var firstName = \"\"\n    var lastName = \"\"\n} \n```"]