<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/>3</h1>
<h1 id="_idParaDest-61" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/>Backing Up Your WhatsPackt Messages</h1>
<p class="calibre3">In any chat application, data handling is a significant concern – we need to ensure that messages sent and received are stored correctly, quickly retrieved when needed, and resilient to potential losses due to unforeseen circumstances such as device failures or accidental deletions. This requires a robust data persistence strategy. We also need to consider performance and user experience, which calls for effective caching mechanisms, as well as making sure that we have backups in the event of data loss or when the user changes devices.</p>
<p class="calibre3">In this chapter, we will start by introducing you to Room, a persistence library that provides an abstraction layer over SQLite and makes it easier to work with databases in Android. You’ll learn about its architecture and components and how to use it to store and retrieve chat conversations and messages.</p>
<p class="calibre3">Next, we will tackle the creation of a cache mechanism orchestrating the use of Room locally and the use of the API to gather data from the backend.</p>
<p class="calibre3">Moving forward, we’ll get you up to speed with Firebase Storage. You’ll learn to set it up, understand its benefits, and how to secure data stored in it. We’ll then use Firebase Storage to create a backup of our chat conversations, an essential feature for any chat application.</p>
<p class="calibre3">Finally, we’ll explore how to use <code>WorkManager</code>, an API that makes it easy to schedule deferrable, asynchronous tasks even if the app exits or the device restarts. You’ll learn how it can be used to schedule chat backups and how to upload these backups to <strong class="bold">Amazon Simple Storage Service</strong> (<strong class="bold">Amazon S3</strong>), ensuring data safety.</p>
<p class="calibre3">So, in this chapter, we will be covering the following topics:</p>
<ul class="calibre15">
<li class="calibre14">Understanding Room</li>
<li class="calibre14">Implementing Room in WhatsPackt</li>
<li class="calibre14">Getting to know Firebase Storage</li>
<li class="calibre14">Scheduling <strong class="source-inline1">WorkManager</strong> to send backups</li>
<li class="calibre14">Using Amazon S3 for storage</li>
</ul>
<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">As in the previous chapter, you will need to have installed Android Studio (or another editor of your preference).</p>
<p class="calibre3">We are also going to assume that you followed along with the previous chapter. You can download this chapter’s complete code from here: <a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3</a>.</p>
<h1 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/>Understanding Room</h1>
<p class="calibre3">When it comes to <a id="_idIndexMarker287" class="calibre6 pcalibre1 pcalibre"/>Android development, one of the most essential tasks is managing your application’s data in a local database. The <strong class="bold">Room</strong> persistence library, part of Android Jetpack, is an abstraction layer over SQLite, a popular database that comes with Android. Room offers more robust database access while harnessing SQLite’s full power.</p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/>Key features of Room</h2>
<p class="calibre3">Before Room, developers primarily<a id="_idIndexMarker288" class="calibre6 pcalibre1 pcalibre"/> used <strong class="bold">SQLite</strong> directly or other <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) libraries. While SQLite is<a id="_idIndexMarker289" class="calibre6 pcalibre1 pcalibre"/> powerful, it can be cumbersome to work with because it requires writing a lot <a id="_idIndexMarker290" class="calibre6 pcalibre1 pcalibre"/>of boilerplate code. Additionally, errors in SQL queries often aren’t detected until runtime, which can lead to crashes.</p>
<p class="calibre3">Room solves these issues by providing a simpler and more robust API over the standard SQLite for managing local data storage. Here are some of its key features:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Compile-time verification of SQL queries</strong>: Room verifies your SQL queries at compile time, not at runtime. This means if there’s an error in one of your queries, you’ll know as soon as you compile your app, not after you’ve shipped it to users. This leads to more robust and reliable code.</li>
<li class="calibre14"><strong class="bold">Reduced boilerplate code</strong>: With Room, you don’t need to write as much code to perform simple database operations. This leads to cleaner, more readable code.</li>
<li class="calibre14"><strong class="bold">Integration with other architecture components</strong>: Room is designed to integrate seamlessly <a id="_idIndexMarker291" class="calibre6 pcalibre1 pcalibre"/>with other <strong class="bold">Android Architecture Components</strong> (<strong class="bold">AAC</strong>) library components, such as <strong class="source-inline1">LiveData</strong> and <strong class="source-inline1">ViewModel</strong>. This means you can create a well-architected, robust <a id="_idIndexMarker292" class="calibre6 pcalibre1 pcalibre"/>app that follows best practices for Android development.</li>
<li class="calibre14"><strong class="bold">Easy migration paths</strong>: Room offers robust migration support, including migration paths and testing. As your app’s data needs evolve, Room makes it easy to adapt your database structure to meet those needs.</li>
<li class="calibre14"><strong class="bold">Supports complex queries</strong>: Despite simplifying interaction with SQLite, Room still allows you to perform complex SQL queries when you need more flexibility and power.</li>
</ul>
<p class="calibre3">As you can see, Room offers an efficient and streamlined approach to managing your app’s local data. It’s a powerful tool that can make your Android development experience much more pleasant and productive.</p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/>Room’s architecture and components</h2>
<p class="calibre3">Room’s architecture is based <a id="_idIndexMarker293" class="calibre6 pcalibre1 pcalibre"/>on three main components:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Database</strong></li>
<li class="calibre14"><strong class="source-inline1">Entity</strong></li>
<li class="calibre14"><strong class="bold">Data Access </strong><strong class="bold">Object</strong> (<strong class="bold">DAO</strong>)</li>
</ul>
<p class="calibre3">Here, you can see how every <a id="_idIndexMarker294" class="calibre6 pcalibre1 pcalibre"/>Room component interacts with the rest of the app:</p>
<div><div><img alt="Figure 3.1: Diagram of Room architecture" src="img/B19443_03_001.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.1: Diagram of Room architecture</p>
<p class="calibre3">Understanding these <a id="_idIndexMarker295" class="calibre6 pcalibre1 pcalibre"/>components is crucial when using Room effectively, so let’s dive into them deeper.</p>
<h3 class="calibre9">Database</h3>
<p class="calibre3">The <code>Database</code> class in Room is a high-level class that works as the main access point to your app’s persisted data. It’s an <a id="_idIndexMarker296" class="calibre6 pcalibre1 pcalibre"/>abstract class where you define an abstract method for each <code>@Dao</code> annotation in your app. When you create an instance of the <code>Database</code> class, Room generates the implementation code of these DAO methods (DAO will be explored in more detail in a moment).</p>
<p class="calibre3">The <code>Database</code> class is annotated with <code>@Database</code>, specifying the entities it comprises and the database version. If you modify the database schema, you need to update the version number and define a migration strategy, as in the following example:</p>
<pre class="source-code">
@Database(entities = [Message::class, Conversation::class],
    version = 1)
abstract class ChatAppDatabase : RoomDatabase() {
    abstract fun messageDao(): MessageDao
    abstract fun conversationDao(): ConversationDao
}</pre> <p class="calibre3">Here, we’ve defined a <code>ChatAppDatabase</code> Room <code>Database</code> class with two entities, <code>Message</code> and <code>Conversation</code>. We’ve also defined abstract methods to access our DAOs – <code>messageDao()</code> and <code>conversationDao()</code>. The <code>entities</code> parameter in the <code>@Database</code> annotation<a id="_idIndexMarker297" class="calibre6 pcalibre1 pcalibre"/> takes an array of all entities in the database, while the <code>version</code> parameter is used for database migration purposes.</p>
<h3 class="calibre9">Entity</h3>
<p class="calibre3"><strong class="bold">Entities</strong> in Room represent the tables in a database. Each entity corresponds to a table, and each instance of an entity<a id="_idIndexMarker298" class="calibre6 pcalibre1 pcalibre"/> represents a row in the table. Room uses the class fields in an entity to define the columns in a table.</p>
<p class="calibre3">You declare an entity by annotating a data class with <code>@Entity</code>. Each <code>@Entity</code> class represents a table in your database, and you can define the table name. If you don’t define a table name, Room uses the class name as the table name, as in the following example:</p>
<pre class="source-code">
@Entity(tableName = "messages")
data class Message(
    @PrimaryKey val id: String,
    @ColumnInfo(name = "conversation_id") val
        conversationId: String,
    // ...
)</pre> <p class="calibre3">Here, <code>Message</code> is an entity that represents a <code>"messages"</code> table in our database. Each instance of <code>Message</code> will represent a row within the <code>"messages"</code> table. Each property in the <code>Message</code> class represents a column in the table. The <code>@PrimaryKey</code> annotation is used to denote a primary key, and the <code>@ColumnInfo</code> annotation is used to specify the column name in the database. If not specified, Room uses the variable name as the column name.</p>
<h3 class="calibre9">DAO</h3>
<p class="calibre3">DAOs are interfaces that define all the database operations that you want to perform. For each DAO, you can <a id="_idIndexMarker299" class="calibre6 pcalibre1 pcalibre"/>define methods for different operations such as insertion, deletion, and querying.</p>
<p class="calibre3">You should annotate an interface with <code>@Dao</code>, and then annotate each method with the corresponding operation you want to perform, such as <code>@Insert</code>, <code>@Delete</code>, <code>@Update</code>, or <code>@Query</code> for custom queries. Then, Room will autogenerate the necessary code to perform these operations at compile time. Here’s an example:</p>
<pre class="source-code">
@Dao
interface MessageDao {
    @Insert
    fun insert(message: Message)
    @Query("SELECT * FROM messages WHERE conversation_id =
        :conversationId")
    fun getMessagesForConversation(conversationId: String):
        List&lt;Message&gt;
}</pre> <p class="calibre3">In this <code>MessageDao</code> interface, we’ve defined two methods – <code>insert()</code> for inserting a <code>Message</code> object into our database and <code>getMessagesForConversation()</code> to retrieve all messages related to a specific conversation from our database. The <code>@Insert</code> annotation is a convenience annotation for inserting an entity into a table. The <code>@Query</code> annotation allows us to write SQL queries to perform complex reads and writes.</p>
<p class="calibre3">Understanding these components will allow us to leverage the power of Room effectively. The following sections will guide you through the process of implementing Room in our WhatsPackt application, starting from setting it up in Android Studio to creating entities and <a id="_idIndexMarker300" class="calibre6 pcalibre1 pcalibre"/>DAOs.</p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/>Implementing Room in WhatsPackt</h1>
<p class="calibre3">In this section, you will be guided through the practical steps of implementing Room in our chat application. We will<a id="_idIndexMarker301" class="calibre6 pcalibre1 pcalibre"/> begin by setting up Room in Android Studio, followed by<a id="_idIndexMarker302" class="calibre6 pcalibre1 pcalibre"/> creating entities and DAOs and eventually using these components to interact with our database.</p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/>Adding dependencies</h2>
<p class="calibre3">To start using Room, we first need to<a id="_idIndexMarker303" class="calibre6 pcalibre1 pcalibre"/> include the necessary dependencies in our project. Open your <code>build.gradle</code> file and add the following dependencies under <code>dependencies</code>:</p>
<pre class="source-code">
dependencies {
    implementation "androidx.room:room-runtime:2.3.0"
    kapt "androidx.room:room-compiler:2.3.0"
    implementation "androidx.room:room-ktx:2.3.0"
    // optional - Test helpers
    testImplementation "androidx.room:room-testing:2.3.0"
}</pre> <p class="calibre3">The <code>room-runtime</code> dependency includes the core Room library, while the <code>room-compiler</code> dependency is required for Room’s annotation-processing capabilities. Room’s Kotlin extensions and coroutines support are provided by <code>room-ktx</code>, while <code>room-testing</code> provides useful classes for testing your Room setup.</p>
<p class="calibre3">After adding these lines, sync your project. You can do it using the <code>build.gradle</code> file:</p>
<div><div><img alt="Figure 3.2: The Sync Now option that appears in Android Studio when it detects any changes to Gradle files" src="img/B19443_03_002.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.2: The Sync Now option that appears in Android Studio when it detects any changes to Gradle files</p>
<p class="calibre3">We are ready now to<a id="_idIndexMarker304" class="calibre6 pcalibre1 pcalibre"/> create our database.</p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/>Creating the database</h2>
<p class="calibre3">As discussed before, the <code>Database</code> component is the<a id="_idIndexMarker305" class="calibre6 pcalibre1 pcalibre"/> main access point for our app’s data. So, let’s create a <code>ChatAppDatabase</code> class:</p>
<pre class="source-code">
@Database(entities = [Message::class, Conversation::class],
version = 1)
abstract class ChatAppDatabase : RoomDatabase() {
    abstract fun messageDao(): MessageDao
    abstract fun conversationDao(): ConversationDao
    companion object {
        @Volatile
        private var INSTANCE: ChatAppDatabase? = null
        fun getDatabase(context: Context): ChatAppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    ChatAppDatabase::class.java,
                    "chat_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}</pre> <p class="calibre3">The <code>@Database</code> annotation marks this class as a Room database. It takes two parameters:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">entities</strong> is an array <a id="_idIndexMarker306" class="calibre6 pcalibre1 pcalibre"/>of classes that are annotated with <strong class="source-inline1">@Entity</strong>, representing the tables within the database. In this case, the <strong class="source-inline1">Message</strong> and <strong class="source-inline1">Conversation</strong> classes are entities of <strong class="source-inline1">ChatAppDatabase</strong>.</li>
<li class="calibre14"><strong class="source-inline1">version</strong> is the database version. If you make changes to the database schema, you’ll need to increment this version number and define a migration strategy.</li>
</ul>
<p class="calibre3">Next, <code>abstract fun messageDao(): MessageDao</code> and <code>abstract fun conversationDao(): ConversationDao</code> are abstract methods that return the respective DAOs. They do not have method bodies because Room generates their implementations.</p>
<p class="calibre3">Then, we declare a companion object to hold a singleton instance of <code>ChatAppDatabase</code>, by using the <code>@Volatile</code> annotation. This annotation means <code>INSTANCE</code> can be accessed by multiple threads at once but always in a consistent state, meaning a change made by one thread to <code>INSTANCE</code> is immediately visible to all other threads. <code>INSTANCE</code> is marked as nullable because it might not be initialized immediately.</p>
<p class="calibre3">In the <code>getDatabase()</code> function, we’re implementing a common pattern for creating a singleton instance of a class in a thread-safe way. This pattern ensures that only one instance of <code>ChatAppDatabase</code> is ever created.</p>
<p class="calibre3">We use the <code>?:</code> operator to check whether <code>INSTANCE</code> is not <code>null</code>, and if it is, we enter the synchronized block. This block ensures that only one thread can enter this block of code at a time, preventing the creation of multiple instances of <code>ChatAppDatabase</code> if the function is called concurrently from multiple threads.</p>
<p class="calibre3">Within the synchronized block, we’re calling <code>Room.databaseBuilder()</code> to create a new instance of <code>ChatAppDatabase</code>. We provide the application context to avoid memory leaks, the class of the database, and the name of the database.</p>
<p class="calibre3">Finally, we call <code>build()</code> to create the <code>ChatAppDatabase</code> instance.</p>
<p class="calibre3">After creating the new instance, we assign it to <code>INSTANCE</code> to cache it and then return the instance. The next time <code>getDatabase</code> is called, it will return the cached database instance instead of creating a<a id="_idIndexMarker307" class="calibre6 pcalibre1 pcalibre"/> new one. This is important because creating a Room database instance is an expensive operation, and having multiple instances would be a waste of resources.</p>
<p class="calibre3">This structure is essential for creating a database instance that will allow us to store messages and conversations.</p>
<p class="calibre3">The next step is to create entity classes.</p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/>Creating entity classes</h2>
<p class="calibre3">The first entity class <a id="_idIndexMarker308" class="calibre6 pcalibre1 pcalibre"/>we are going to create is the <code>Message</code> class:</p>
<pre class="source-code">
@Entity(
    tableName = "messages",
    foreignKeys = [
        ForeignKey(
            entity = Conversation::class,
            parentColumns = arrayOf("id"),
            childColumns = arrayOf("conversation_id"),
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["conversation_id"])
    ]
)
data class Message(
    @PrimaryKey(name = "id") val id: Int,
    @ColumnInfo(name = "conversation_id") val
        conversationId: Int,
    @ColumnInfo(name = "sender") val sender: String,
    @ColumnInfo(name = "content") val content: String,
    @ColumnInfo(name = "timestamp") val timestamp: Long
)</pre> <p class="calibre3">In this code, we are including <a id="_idIndexMarker309" class="calibre6 pcalibre1 pcalibre"/>quite a lot of instructions in the annotations, so let’s go through them.</p>
<p class="calibre3">The <code>@Entity</code> annotation tells Room to treat this class as a table in the database. It comes with optional arguments, some of which are used here:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">tableName</strong>: This sets the name of the table as it will appear in the database. In this case, our table will be named <strong class="source-inline1">"messages"</strong>.</li>
<li class="calibre14"><strong class="source-inline1">foreignKeys</strong>: This sets up a foreign key relationship with another table. A <strong class="source-inline1">ForeignKey</strong> instance takes four main arguments:<ul class="calibre16"><li class="calibre14"><strong class="source-inline1">entity</strong>: This represents the class of the parent table that this entity has a relationship with. In this case, it’s <strong class="source-inline1">Conversation::class</strong>.</li><li class="calibre14"><strong class="source-inline1">parentColumns</strong>: This specifies the column(s) in the parent entity that the foreign key references. Here, it’s the <strong class="source-inline1">id</strong> field of <strong class="source-inline1">Conversation</strong>.</li><li class="calibre14"><strong class="source-inline1">childColumns</strong>: This specifies the column(s) in the child entity that holds the foreign key. Here, it’s the <strong class="source-inline1">conversation_id</strong> field in <strong class="source-inline1">Message</strong>.</li><li class="calibre14"><strong class="source-inline1">onDelete</strong>: This represents the action that will be taken if the referenced row in the parent table is deleted. Here, <strong class="source-inline1">ForeignKey.CASCADE</strong> is used, which means that if a <strong class="source-inline1">Conversation</strong> instance is deleted, all messages that have a <strong class="source-inline1">conversation_id</strong> value referencing the conversation’s ID will be deleted as well.</li></ul></li>
<li class="calibre14"><strong class="source-inline1">indices</strong>: This is used to create an index on <strong class="source-inline1">conversation_id</strong> to speed up your queries. An index makes data retrieval faster at the cost of additional disk space and slower write<a id="_idIndexMarker310" class="calibre6 pcalibre1 pcalibre"/> speed. An index is particularly useful here because we will often perform operations related to a specific conversation, and indexing <strong class="source-inline1">conversation_id</strong> will make these operations more efficient.</li>
</ul>
<p class="calibre3">Then, we have also added annotations to the properties of the class:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">@PrimaryKey</strong>: This annotation indicates that the <strong class="source-inline1">id</strong> field is the primary key for the <strong class="source-inline1">Message</strong> table. A primary key uniquely identifies each row in the table. We could use here <strong class="source-inline1">autoGenerate = true</strong>, which means that this field will be automatically filled with an incrementing integer for each new row.</li>
<li class="calibre14"><strong class="source-inline1">@ColumnInfo(name = "column_name")</strong>: This annotation lets you specify a custom column name in the database. If not specified, Room will use the variable name as the column name.</li>
</ul>
<p class="calibre3">Now, let’s create a <code>Conversation</code> entity:</p>
<pre class="source-code">
@Entity(
    tableName = "conversations",
)
class Conversation(
    @PrimaryKey
    @ColumnInfo(name = "id") val id: String,
    @ColumnInfo(name = "last_message_time") val
        lastMessageTime: Long
)</pre> <p class="calibre3">The <code>Conversation</code> entity is very simple – we will just store the <code>Conversation</code> ID and the time of the last message in the conversation.</p>
<p class="calibre3">Now that we have<a id="_idIndexMarker311" class="calibre6 pcalibre1 pcalibre"/> created and defined our entities, it’s time to create DAOs in order to obtain and update data.</p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/>Creating DAOs</h2>
<p class="calibre3">A DAO is an interface that serves as a<a id="_idIndexMarker312" class="calibre6 pcalibre1 pcalibre"/> communication layer<a id="_idIndexMarker313" class="calibre6 pcalibre1 pcalibre"/> between the application code and the database. It defines methods for each operation we might perform on the entities in our database.</p>
<p class="calibre3">Let’s start with the DAO for the <code>Message</code> entity:</p>
<pre class="source-code">
@Dao
interface MessageDao {
    @Query("SELECT * FROM messages WHERE conversation_id =
        :conversationId ORDER BY timestamp ASC")
    fun getMessagesInConversation(conversationId: Int):
        Flow&lt;List&lt;Message&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMessage(message: Message): Long
    @Delete
    suspend fun deleteMessage(message: Message)
}</pre> <p class="calibre3">Breaking down the code, we have the following:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">@Dao</strong>: This annotation identifies the interface as a DAO.</li>
<li class="calibre14"><strong class="source-inline1">@Query</strong>: This annotation is used to specify SQL statements for complex data retrieval tasks.</li>
<li class="calibre14"><strong class="source-inline1">@Insert</strong>: This annotation is used to define a method that inserts its argument into the database. <strong class="source-inline1">OnConflictStrategy.REPLACE</strong> means that if a message with the same primary key<a id="_idIndexMarker314" class="calibre6 pcalibre1 pcalibre"/> already exists, it will be replaced by a new one.</li>
<li class="calibre14"><strong class="source-inline1">@Delete</strong>: This<a id="_idIndexMarker315" class="calibre6 pcalibre1 pcalibre"/> annotation is used to define a method that deletes its argument from the database.</li>
</ul>
<p class="calibre3">Now, let’s create a DAO for the <code>Conversation</code> entity:</p>
<pre class="source-code">
@Dao
interface ConversationDao {
    @Query("SELECT * FROM conversations ORDER BY
        last_message_time DESC")
    fun getAllConversations(): Flow&lt;List&lt;Conversation&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertConversation(conversation:
        Conversation): Long
    @Delete
    suspend fun deleteConversation(conversation:
        Conversation)
}</pre> <p class="calibre3">The annotations function the same way as they did in <code>MessageDao</code>. Here, we’re retrieving all conversations ordered by the time of their last message, and we have methods for inserting and deleting conversations.</p>
<p class="calibre3">We now need to provide<a id="_idIndexMarker316" class="calibre6 pcalibre1 pcalibre"/> these DAOs for other app<a id="_idIndexMarker317" class="calibre6 pcalibre1 pcalibre"/> components so that they can be injected. With that in mind, we will create the following module:</p>
<pre class="source-code">
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext appContext:
    Context): ChatAppDatabase {
        return ChatAppDatabase.getDatabase(appContext)
    }
    @Provides
    fun provideMessageDao(database: ChatAppDatabase):
    MessageDao {
        return database.messageDao()
    }
    @Provides
    fun provideConversationDao(database: ChatAppDatabase):
    ConversationDao {
        return database.conversationDao()
    }
}</pre> <p class="calibre3">As we have previously covered the creation of Hilt modules in the previous chapters, we won’t go over all the code again. Instead, here<a id="_idIndexMarker318" class="calibre6 pcalibre1 pcalibre"/> are the key parts of the code:</p>
<ul class="calibre15">
<li class="calibre14">We are using <strong class="source-inline1">@Singleton</strong> to<a id="_idIndexMarker319" class="calibre6 pcalibre1 pcalibre"/> indicate that only a single instance of the object should be created and provided as a dependency.</li>
<li class="calibre14">The <code>Context</code> we want to use, we can get confused or provide one that is not suitable for this situation. Using the <code>@ApplicationContext</code> qualifier will assure us that the <code>Context</code> injected will be the expected one (the <code>Application Context</code>, in this case).</p></li>
</ul>
<p class="calibre3">Now, as we already did in the previous chapter for the API or WebSocket, we are going to create a data source to connect with the database:  <code>LocalMessagesDataSource</code>.</p>
<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/>Creating a LocalMessagesDataSource data source</h2>
<p class="calibre3">We need to create a <code>LocalMessagesDataSource</code> data source that will wrap the DAO and expose the specific<a id="_idIndexMarker320" class="calibre6 pcalibre1 pcalibre"/> database operations our app needs. This way, if we decide to change the database in the future, we will only have to change it here (not in the rest of consumers). This class will serve as a DAO at a higher level of abstraction, simplifying the API for the rest of our app and making it easier to mock the database in tests.</p>
<p class="calibre3">In the following code, we are just calling the functions we already defined in the DAO:</p>
<pre class="source-code">
class MessagesLocalDataSource @Inject constructor(private
val messageDao: MessageDao) {
    fun getMessagesInConversation(conversationId: Int):
    Flow&lt;List&lt;Message&gt;&gt; {
        return
            messageDao.getMessagesInConversation(
                conversationId)
    }
    suspend fun insertMessage(message: Message): Long {
        return messageDao.insertMessage(message)
    }
    suspend fun deleteMessage(message: Message) {
        messageDao.deleteMessage(message)
    }
}</pre> <p class="calibre3">As we said before, we will use this data source to wrap the database and provide an additional abstraction layer.</p>
<p class="calibre3">Now, it’s time to combine <a id="_idIndexMarker321" class="calibre6 pcalibre1 pcalibre"/>this local data source with the remote one. This will force us to think about a caching strategy.</p>
<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/>Handling two data sources in the MessagesRepository component</h2>
<p class="calibre3">Up until now, we only had one data source (the WebSocket one), but we would like our users to be able to retrieve their messages <a id="_idIndexMarker322" class="calibre6 pcalibre1 pcalibre"/>even if they have no connection for a short time. That’s the reason why we have just created a database and have it ready to be populated.</p>
<p class="calibre3">As our use case is to provide a fallback for the WebSocket so that the user can continue checking their messages, we will follow a strategy where the main source of truth will continue being the WebSocket, but we will store a copy of the messages in the app database. Also, we don’t want the records of this database to grow infinitely, so we are setting a cap of <code>100</code> messages per conversation.</p>
<p class="calibre3">The component responsible for combining both data sources is <code>MessagesRepository</code>, which we already implemented to be connected to <code>WebsocketDataSource</code> in the previous chapter. Let’s now modify it to include both data sources and to orchestrate the data retrieval and local storage:</p>
<pre class="source-code">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource,
    private val localDataSource: DatabaseDataSource
): IMessagesRepository {</pre> <p class="calibre3">Next, we will modify the <code>getMessages()</code> method to include the logic to store the information retrieved from <code>MessagesSocketDataSource</code> (remote data source) in <code>DatabaseDataSource</code> (local data source):</p>
<pre class="source-code">
override suspend fun getMessages(chatId: String, userId:
String): Flow&lt;Message&gt; {
        return flow {
            try {
                dataSource.connect().collect { message -&gt;
                    localDataSource.insertMessage(message)
                    emit(message)
                    manageDatabaseSize()
                }
            } catch (e: Exception) {
                localDataSource.getMessagesInConversation(
                chatId.toInt()).collect {
                    it.forEach { message -&gt; emit(message) }
                }
            }
        }
    }</pre> <p class="calibre3">As can be seen, we have connected to the socket data source, but we have wrapped this action in a <code>try</code>-<code>catch</code> block. So, if everything goes correctly, we will store in our database every new message and then emit it in the flow.</p>
<p class="calibre3">At the same time, we call <code>manageDatabaseSize()</code>, which will check and keep the size of the database under the limit<a id="_idIndexMarker323" class="calibre6 pcalibre1 pcalibre"/> we have set (100 maximum messages per conversation). If the socket fails, we will retrieve messages from the database directly.</p>
<p class="calibre3">Now, we will also modify the <code>sendMessage</code> method, where we will also store every new message sent:</p>
<pre class="source-code">
    override suspend fun sendMessage(chatId: String,
    message: Message) {
        dataSource.sendMessage(message)
        localDataSource.insertMessage(message)
    }</pre> <p class="calibre3">The disconnect will be kept the same as we don’t need to do anything related to the new data source:</p>
<pre class="source-code">
    override suspend fun disconnect() {
        dataSource.disconnect()
    }</pre> <p class="calibre3">Finally, here is the mechanism that we will implement to keep the size of the database under the agreed number of<a id="_idIndexMarker324" class="calibre6 pcalibre1 pcalibre"/> messages per conversation:</p>
<pre class="source-code">
    private suspend fun manageDatabaseSize() {
        val messages =
            localDataSource.getMessagesInConversation(
                chatId.toInt()).first()
        if (messages.size &gt; 100) {
            // Delete the oldest messages until we have 100
               left
            messages.sortedBy { it.timestamp
            }.take(messages.size - 100).forEach {
                localDataSource.deleteMessage(it)
            }
        }
    }
}</pre> <p class="calibre3">We will obtain all messages related to the conversation and check if the size is more than 100. Then, we will order them based on their timestamp and remove the oldest ones.</p>
<p class="calibre3">Now, we have the Room database integrated into our app. Our last messages will be available even if we lose the connection. In the following section, let’s see how we can also send a backup of those messages to be stored in the cloud. For that, we will use Firebase Storage.</p>
<h1 id="_idParaDest-73" class="calibre5"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/>Getting to know Firebase Storage</h1>
<p class="calibre3"><strong class="bold">Firebase Storage</strong>, also known as Cloud Storage for Firebase, is a powerful object storage service built for Google scale. It <a id="_idIndexMarker325" class="calibre6 pcalibre1 pcalibre"/>enables developers to store and retrieve user-generated content, such as photos, videos, or other<a id="_idIndexMarker326" class="calibre6 pcalibre1 pcalibre"/> forms of user data. Firebase <a id="_idIndexMarker327" class="calibre6 pcalibre1 pcalibre"/>Storage is backed by <strong class="bold">Google Cloud Storage</strong> (<strong class="bold">GCS</strong>), making it robust and scalable for any size of data, from small text files to large video files.</p>
<p class="calibre3">Here are some of the key features and capabilities of Firebase Storage:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">User-generated content</strong>: Firebase Storage allows your users to upload their own content directly from their devices. This could include anything from profile pictures to blog posts.</li>
<li class="calibre14"><strong class="bold">Integration with Firebase and Google Cloud</strong>: Firebase Storage integrates smoothly with the rest of the Firebase ecosystem, including Firebase Authentication and Firebase Security Rules. It’s also a part of the larger Google Cloud ecosystem, which opens up possibilities for using Google Cloud’s advanced features, such as Cloud Functions.</li>
<li class="calibre14"><strong class="bold">Security</strong>: Firebase Storage provides robust security features. Using Firebase Security Rules, you can control who has access to what data. You can restrict access based on a user’s authentication state, identity, and claims, as well as data patterns and metadata.</li>
<li class="calibre14"><strong class="bold">Scalability</strong>: Firebase Storage is designed to handle a large number of uploads, downloads, and storage of data. It automatically scales with your user base and traffic, meaning you don’t need to worry about capacity planning.</li>
<li class="calibre14"><strong class="bold">Offline capabilities</strong>: Firebase <strong class="bold">software development kits</strong> (<strong class="bold">SDKs</strong>) for Cloud Storage add Google security to file <a id="_idIndexMarker328" class="calibre6 pcalibre1 pcalibre"/>uploads and downloads for your Firebase apps, regardless of network quality. You can use it to pause, resume, and cancel transfers.</li>
<li class="calibre14"><strong class="bold">Rich media</strong>: Firebase Storage supports rich media content. This means you can use it to store images, audio, video, or even other binary data.</li>
<li class="calibre14"><strong class="bold">Strong consistency</strong>: Firebase Storage guarantees strong consistency, meaning that once an upload or download is completed, the data is immediately available from all Google Cloud Storage locations, and any subsequent reads will return the latest updated data.</li>
</ul>
<p class="calibre3">In our context, a messaging <a id="_idIndexMarker329" class="calibre6 pcalibre1 pcalibre"/>application, Firebase Storage could be used to store and retrieve message history or backups, shared files, or even multimedia content within conversations. This could serve as a reliable backup solution or a means of synchronizing chat history across multiple devices. However, you need to ensure you handle privacy and security concerns, especially since chat conversations can contain sensitive data.</p>
<h2 id="_idParaDest-74" class="calibre7"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/>How Firebase Storage works</h2>
<p class="calibre3">In Firebase Storage, data is stored as<a id="_idIndexMarker330" class="calibre6 pcalibre1 pcalibre"/> objects within a hierarchical structure. The full path to an object in Firebase Storage includes the project ID and the object’s location within the storage bucket.</p>
<p class="callout-heading">Note</p>
<p class="callout">In the context of cloud storage, a <strong class="bold">bucket</strong> is a basic container that holds data. It’s the primary parent in the hierarchy<a id="_idIndexMarker331" class="calibre6 pcalibre1 pcalibre"/> of data organization. All data in cloud storage is stored in buckets. The concept of a bucket is used by many cloud storage systems, including GCS, Amazon S3, and Firebase Storage. These systems typically allow you to create one or more buckets in your storage space and then upload data as objects or files to these buckets. Each bucket has a unique name within the cloud storage system, and it contains data objects, or files, each of which is identified by a key or a name.</p>
<p class="calibre3">The object’s location is defined by a path that you specify. This path is similar to a filesystem path and includes both the directories and the filename. For example, in the <code>images/profiles/user123.jpg</code> path, <code>images</code> and <code>profiles</code> are directories, and <code>user123.jpg</code> is the filename.</p>
<p class="calibre3">When you upload a file to Firebase Storage, you create a reference to the location where you’re going to store the file. This reference is represented by a <code>StorageReference</code> object, which you create by calling the <code>child()</code> method on a reference to your Firebase Storage bucket and passing the path as<a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/> an argument, as in the following example:</p>
<pre class="source-code">
val storageRef = Firebase.storage.reference
val fileRef =
storageRef.child("images/profiles/user123.jpg")</pre> <p class="calibre3">Here, <code>fileRef</code> is a reference to the <code>user123.jpg</code> file in the profile’s directory within the <code>images</code> directory.</p>
<p class="calibre3">You can use this reference to perform various operations, such as uploading a file, downloading a file, or getting a URL to the file. Each of these operations returns a <code>Task</code> object that you can use to monitor<a id="_idIndexMarker332" class="calibre6 pcalibre1 pcalibre"/> the operation’s progress or get its result.</p>
<p class="calibre3">The paths in Firebase Storage are flexible, and you can structure them in a way that makes sense for your application. For instance, in a messaging application, you might store conversation logs in a <code>chat_logs</code> directory, with each log’s filename being the chat’s ID. The path to a chat log might look like this: <code>chat_logs/chat123.txt</code>.</p>
<p class="calibre3">Finally, it’s worth noting that Firebase Storage uses rules to control who can read and write to your storage bucket. By default, only authenticated users can read and write data. You can customize these rules to suit your application’s needs.</p>
<p class="calibre3">Let’s start setting up Firebase Storage in our project.</p>
<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/>Setting up Firebase Storage</h2>
<p class="calibre3">To start using Firebase Storage, we’ll first need to add the Cloud Storage for Firebase Android library to our app. This can be done<a id="_idIndexMarker333" class="calibre6 pcalibre1 pcalibre"/> by adding the following line to our module’s <code>build.gradle</code> file:</p>
<pre class="console">
implementation 'com.google.firebase:firebase-storage-ktx'</pre> <p class="calibre3">As for the chat messages, one approach would be to save the chat logs as text files in Firebase Storage. Each conversation could have its own text file, and each message would be a line in that file. So, we are going to create a data source to upload those files:</p>
<pre class="source-code">
class StorageDataSource @Inject constructor(private val
firebaseStorage: FirebaseStorage) {
    suspend fun uploadFile(localFile: File, remotePath:
    String) {
        val storageRef =
            firebaseStorage.reference.child(remotePath)
        storageRef.putFile(localFile.toUri()).await()
    }
    suspend fun downloadFile(remotePath: String, localFile:
    File) {
        val storageRef =
            firebaseStorage.reference.child(remotePath)
        storageRef.getFile(localFile).await()
    }
}</pre> <p class="calibre3">Here, we’ve added the Firebase storage instance as a parameter to the constructor, allowing it to be injected when<a id="_idIndexMarker334" class="calibre6 pcalibre1 pcalibre"/> the class is instantiated using Hilt. The <code>uploadFile</code> and <code>downloadFile</code> methods suspend the coroutine until the upload or download operation completes, using the <code>await()</code> extension function.</p>
<p class="calibre3">To be able to use the Firebase storage instance, we would need to provide the <code>FirebaseStorage</code> dependency. For that, we will need to create the following module so that Hilt is aware of how it can obtain it:</p>
<pre class="source-code">
@Module
@InstallIn(SingletonComponent::class)
object StorageModule {
    @Singleton
    @Provides
    fun provideFirebaseStorage(): FirebaseStorage =
        FirebaseStorage.getInstance()
}</pre> <p class="calibre3">Now, we need to create those files, to then be uploaded using this data source. We are going to do it in a newly created repository: <code>BackupRepository</code>.</p>
<p class="calibre3">The <code>BackupRepository</code> repository will serve as an intermediary between different data sources (such as local databases via DAOs and remote data sources such as Firebase Storage) and the rest<a id="_idIndexMarker335" class="calibre6 pcalibre1 pcalibre"/> of the application. It retrieves data from the sources, processes it if necessary, and provides it to the calling code in a convenient form.</p>
<p class="calibre3">Here is the code for this repository:</p>
<pre class="source-code">
class BackupRepository @Inject constructor(
    private val messageDao: MessageDao,
    private val conversationDao: ConversationDao,
    private val storageDataSource: StorageDataSource
) {
    private val gson = Gson()
    suspend fun backupAllConversations() {
        // Get all the conversations
        val conversations =
            conversationDao.getAllConversations()
        // Backup each conversation
        for (conversation in conversations) {
            val messages =
                messageDao.getMessagesForConversation(
                    conversation.conversationId)
            // create a JSON representation of the messages
            val messagesJson = gson.toJson(messages)
            // create a temporary file and write the JSON
               to it
            val tempFile = createTempFile("messages",
                ".json")
            tempFile.writeText(messagesJson)
            // upload the file to Firebase Storage
            val remotePath =
               "conversations/${conversation.conversationId
               }/messages.json"
            storageDataSource.uploadFile(tempFile,
               remotePath)
            // delete the local file
            tempFile.delete()
        }
    }
    private fun createTempFile(prefix: String, suffix:
    String): File {
        // specify the directory where the temporary file
           will be created
        val tempDir =
            File(System.getProperty("java.io.tmpdir"))
        // create a temporary file with the specified
           prefix and suffix
        return File.createTempFile(prefix, suffix, tempDir)
    }
}</pre> <p class="calibre3">As can be seen in the code, it uses <code>ConversationDao</code> to fetch all conversations in the local database. Each conversation represents a distinct chat thread.</p>
<p class="calibre3">Then, for each conversation, it fetches the associated messages using <code>MessageDao</code>, converts the messages to a JSON string using the Gson library, writes this JSON string to a temporary file, and then uploads the<a id="_idIndexMarker336" class="calibre6 pcalibre1 pcalibre"/> file to Firebase Storage through <code>StorageDataSource</code>.</p>
<p class="calibre3">Once the upload to Firebase Storage is complete, it deletes the local temporary file to clean up the storage space on the device.</p>
<p class="calibre3"><code>BackupRepository</code> handles all the details of data retrieval, processing, and storage. Other parts of the application don’t need to know how the data is stored or retrieved. They only interact with <code>BackupRepository</code>, which provides a simple interface for these operations. This makes the code easier to maintain, understand, and test.</p>
<p class="calibre3">Finally, we will create <code>UploadMessagesUseCase</code>, which will be the use case or domain interactor responsible for executing the upload action.</p>
<h2 id="_idParaDest-76" class="calibre7"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/>Creating UploadMessagesUseCase</h2>
<p class="calibre3">The responsibility of <code>UploadMessagesUseCase</code> will be to execute the backup using <code>BackupRepository</code>. As most of the<a id="_idIndexMarker337" class="calibre6 pcalibre1 pcalibre"/> logic is already in the repository, the code will be simpler and will look like this:</p>
<pre class="source-code">
class UploadMessagesUseCase @Inject constructor(
    private val backupRepository: BackupRepository
) {
    suspend operator fun invoke() {
        backupRepository.backupAllConversations()
    }
}</pre> <p class="calibre3">Now, we are ready to retrieve and upload these backups. As it can be a time- and resource-consuming task, the idea will be <a id="_idIndexMarker338" class="calibre6 pcalibre1 pcalibre"/>to do it periodically, once per week or once per day. This is where <code>WorkManager</code> comes in handy.</p>
<h1 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/>Scheduling WorkManager to send backups</h1>
<p class="calibre3"><code>WorkManager</code> is the recommended tool for tasks that require guaranteed and efficient execution.</p>
<p class="calibre3"><code>WorkManager</code> uses an underlying job dispatching service based on the following criteria:</p>
<ul class="calibre15">
<li class="calibre14">It uses <strong class="source-inline1">JobScheduler</strong> for devices<a id="_idIndexMarker340" class="calibre6 pcalibre1 pcalibre"/> with API 23 and above</li>
<li class="calibre14">For devices with API 14 to 22, it uses a combination of <strong class="source-inline1">BroadcastReceiver</strong> (for system broadcasts) and <strong class="source-inline1">AlarmManager</strong></li>
<li class="calibre14">If the app includes the optional <strong class="source-inline1">WorkManager</strong> dependency on Firebase <strong class="source-inline1">JobDispatcher</strong> and Google Play services are available on the device, <strong class="source-inline1">WorkManager</strong> uses Firebase <strong class="source-inline1">JobDispatcher</strong></li>
</ul>
<p class="calibre3"><code>WorkManager</code> chooses the appropriate way to schedule a background task, depending on the device API level and included dependencies. To use <code>WorkManager</code>, we need first to understand how we<a id="_idIndexMarker341" class="calibre6 pcalibre1 pcalibre"/> can create <code>Worker</code> and <code>WorkRequest</code> instances.</p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/>Introducing the Worker class</h2>
<p class="calibre3">A <code>Worker</code> class (or <code>CoroutineWorker</code> if you’re using Kotlin coroutines) and override the <code>doWork()</code> method to define what the task should do.</p>
<p class="calibre3">The <code>doWork()</code> method is where you put the <a id="_idIndexMarker344" class="calibre6 pcalibre1 pcalibre"/>code that needs to be executed in the background. This is where you define the operation that needs to be performed, such as fetching data from the server, uploading a file, processing an image, and so on.</p>
<p class="calibre3">Each <code>Worker</code> instance is given a maximum of 10 minutes to finish its execution and return a <code>Result</code> instance. The <code>Result</code> instance can be one of three types:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">Result.success()</strong>: Indicates that the work completed successfully. You can optionally return a <strong class="source-inline1">Data</strong> object that can be used as the output data of this work.</li>
<li class="calibre14"><strong class="source-inline1">Result.failure()</strong>: Indicates that the work failed. You can optionally return a <strong class="source-inline1">Data</strong> object that can describe the failure.</li>
<li class="calibre14"><strong class="source-inline1">Result.retry()</strong>: Indicates that the work failed and should be tried at another time according to its retry policy.</li>
</ul>
<p class="calibre3">A unique feature of <code>Worker</code> is that it’s <code>Worker </code>instance is running and the app goes to the background, the <code>Worker</code> instance can continue to run, whereas if the device restarts while the <code>Worker</code> instance is running, the task can resume when the device is back up. This ensures that the work will be performed under the constraints specified when creating a <code>WorkRequest</code> instance, even if your app process is not around.</p>
<p class="calibre3">Here is an example of<a id="_idIndexMarker345" class="calibre6 pcalibre1 pcalibre"/> a basic <code>Worker</code> class:</p>
<pre class="source-code">
class ExampleWorker(appContext: Context, workerParams:
WorkerParameters)
    : Worker(appContext, workerParams) {
    override fun doWork(): Result {
        // Code to execute in the background
        return Result.success()
    }
}</pre> <p class="calibre3">In the example, we extend the <code>Worker</code> class and override the <code>doWork()</code> method to specify the task to be performed. In this case, we are just returning the result as successful, but the code to do the actual work would be where the <code>// Code to execute in the background</code> comment is placed.</p>
<p class="calibre3">To make our <code>Worker</code> instances work, we need another component: <code>WorkRequest</code>. Let’s see how we can configure and use it.</p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/>Configuring the WorkRequest component</h2>
<p class="calibre3"><code>WorkRequest</code> is the class that defines an individual unit of work. It encapsulates your <code>Worker</code> class, along with any <a id="_idIndexMarker346" class="calibre6 pcalibre1 pcalibre"/>constraints that must be satisfied for the work to run and any input data it needs.</p>
<p class="calibre3">There are two concrete implementations of <code>WorkRequest</code> that you can use:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1">OneTimeWorkRequest</strong>: As the name suggests, this represents a one-off job. It will only be executed once.</li>
<li class="calibre14"><strong class="source-inline1">PeriodicWorkRequest</strong>: This is used for repeating jobs that run periodically. The minimum repeat interval that can be defined is 15 minutes. This constraint is discussed further in the official documentation: <a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" class="calibre6 pcalibre1 pcalibre">https://developer.android.com/reference/androidx/work/PeriodicWorkRequest</a>.</li>
</ul>
<p class="calibre3"><code>WorkRequest</code> has several options for setting conditions for the execution of work and for scheduling multiple pieces of work to run in a particular order:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Constraints</strong>: A <strong class="source-inline1">WorkRequest</strong> instance can have a <strong class="source-inline1">Constraints</strong> object set on it, which allows you to specify conditions that must be met for the work to be eligible to run. For example, you might require that the device is idle or charging, or that it has a certain type of network connectivity. We will learn about these conditions in<a id="_idIndexMarker347" class="calibre6 pcalibre1 pcalibre"/> detail in a few paragraphs.</li>
<li class="calibre14"><strong class="bold">Input data</strong>: You can attach input data to a <strong class="source-inline1">WorkRequest</strong> instance using the <strong class="source-inline1">setInputData()</strong> method, providing your <strong class="source-inline1">Worker</strong> instance with all the information it needs to do its work.</li>
<li class="calibre14"><strong class="bold">Backoff criteria</strong>: You can set backoff criteria for the <strong class="source-inline1">WorkRequest</strong> instance to control retry timing when the work fails.</li>
<li class="calibre14"><strong class="bold">Tags</strong>: You can also add tags to your <strong class="source-inline1">WorkRequest</strong> instance, which will make it easier to track, observe, or cancel specific groups of work.</li>
<li class="calibre14"><strong class="bold">Chaining work</strong>: <strong class="source-inline1">WorkManager</strong> allows you to create dependent chains of work. This means that you can ensure certain pieces of work are executed in a certain order. You can create complex chains that run a series of <strong class="source-inline1">WorkRequest</strong> objects in a specific order.</li>
</ul>
<p class="calibre3"><code>WorkManager</code> offers several types of constraints that you can set on a <code>WorkRequest</code> object to specify when your task should run. This is done using the <code>Constraints.Builder</code> class. Here are the available constraints you can set:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Network type</strong> (<strong class="source-inline1">setRequiredNetworkType</strong>): This constraint specifies the type of network that must be available for the work to run. Options include <strong class="source-inline1">NetworkType.NOT_REQUIRED</strong>, <strong class="source-inline1">NetworkType.CONNECTED</strong>, <strong class="source-inline1">NetworkType.UNMETERED</strong>, <strong class="source-inline1">NetworkType.NOT_ROAMING</strong>, and <strong class="source-inline1">NetworkType.METERED</strong>.</li>
<li class="calibre14"><strong class="bold">Battery not low</strong> (<strong class="source-inline1">setRequiresBatteryNotLow</strong>): If this constraint is set to <strong class="source-inline1">true</strong>, the work will only run when the battery isn’t low.</li>
<li class="calibre14"><strong class="bold">Device idle</strong> (<strong class="source-inline1">setRequiresDeviceIdle</strong>): If this constraint is set to <strong class="source-inline1">true</strong>, the work will only run when the device is in idle mode. This is usually when the user hasn’t interacted with the device for a period of time.</li>
<li class="calibre14"><strong class="bold">Storage not low</strong> (<strong class="source-inline1">setRequiresStorageNotLow</strong>): If set to <strong class="source-inline1">true</strong>, the work will only run when the storage isn’t low.</li>
<li class="calibre14"><strong class="bold">Device charging</strong> (<strong class="source-inline1">setRequiresCharging</strong>): If set to <strong class="source-inline1">true</strong>, the work will only run when the device is charging.</li>
</ul>
<p class="calibre3">Here is an example of how we can<a id="_idIndexMarker348" class="calibre6 pcalibre1 pcalibre"/> configure a <code>WorkRequest</code> instance:</p>
<pre class="source-code">
val constraints = Constraints.Builder()
    .setRequiresCharging(true)
    .setRequiredNetworkType(NetworkType.CONNECTED)
    .setRequiresBatteryNotLow(true)
    .build()
val workRequest = OneTimeWorkRequestBuilder&lt;MyWorker&gt;()
    .setConstraints(constraints)
    .addTag("myWorkTag")
    .build()</pre> <p class="calibre3">In this example, <code>MyWorker</code> will only run when the device is charging, connected to a network, and the battery level is not low. It will also have a tag, which will allow us to identify it easily.</p>
<p class="calibre3">Here is a diagram with the flow followed for the <code>Worker</code> and <code>WorkRequest</code> instances to be executed:</p>
<div><div><img alt="Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance" src="img/B19443_03_003.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance</p>
<p class="calibre3">We now have the tools to build our own <code>Worker</code> instance and configure the <code>WorkRequest</code> instance to<a id="_idIndexMarker349" class="calibre6 pcalibre1 pcalibre"/> retrieve and upload the backup. So, let’s actually create them.</p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/>Creating our Worker instance</h2>
<p class="calibre3">First, to support the <code>WorkManager</code> API, we need to<a id="_idIndexMarker350" class="calibre6 pcalibre1 pcalibre"/> include the related dependencies in our code:</p>
<pre class="source-code">
dependencies {
    implementation "androidx.work:work-runtime-ktx:$2.9.0"
    // Hilt AndroidX WorkManager integration
    implementation 'androidx.hilt:hilt-work:$2.44
    ...
}</pre> <p class="calibre3">As we have seen before, the <code>Worker</code> class will execute the task that can run in the background even when the app is not being used. In other words, it’s a unit of work that can be scheduled to run under certain conditions. In our case, we have just created the logic for that (in <code>UploadMessagesUseCase</code>), so our <code>Worker</code> class will need to have access to that class.</p>
<p class="calibre3">That’s the reason we will start adding <code>HiltWorker</code> is an annotation provided<a id="_idIndexMarker351" class="calibre6 pcalibre1 pcalibre"/> by Hilt’s <code>androidx.hilt</code> extension library. This annotation tells Hilt that it should create an injectable Worker instance (that is, Hilt should manage the <a id="_idIndexMarker352" class="calibre6 pcalibre1 pcalibre"/>dependencies of this <code>Worker</code> instance).</p>
<p class="calibre3">Here’s the complete code for our <code>Worker</code> class:</p>
<pre class="source-code">
@HiltWorker
class UploadMessagesWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val uploadMessagesUseCase:
        UploadMessagesUseCase
) : CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result = coroutineScope
    {
        try {
            uploadMessagesUseCase.execute()
            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount &lt; MAX_RETRIES) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }
    companion object {
        private const val MAX_RETRIES = 3
    }
}</pre> <p class="calibre3">We are also using a new annotation: <code>AssistedInject</code>. Now, <code>AssistedInject</code> is a Dagger Hilt feature that helps with scenarios where you need to inject some dependencies but also need to provide some arguments at runtime. Here, the <code>appContext</code> and <code>workerParams</code> arguments to the constructor are provided at runtime (when the <code>Worker</code> instance is created by <code>WorkManager</code>), while <code>uploadMessagesUseCase</code> is a dependency that should be injected.</p>
<p class="calibre3">The <code>doWork()</code> function is where the work that this <code>Worker</code> instance should perform is defined. This function is a suspend function and runs within a coroutine scope. This means it can perform<a id="_idIndexMarker353" class="calibre6 pcalibre1 pcalibre"/> long-running operations such as network requests or database operations without blocking the main thread.</p>
<p class="calibre3">In <code>doWork()</code>, <code>uploadMessagesUseCase.execute()</code> is called to perform the actual work of uploading messages. If this operation is successful, <code>Result.success()</code> is returned. If an <code>Exception</code> error is thrown, <code>Result.retry()</code> is returned if <code>runAttemptCount</code> is less than <code>MAX_RETRIES</code>, which means the work should be retried. If <code>runAttemptCount</code> equals or exceeds <code>MAX_RETRIES</code>, <code>Result.failure()</code> is returned, which means the work should not be retried.</p>
<p class="calibre3">As we want it to only retry three times, we are using <code>runAttemptCount</code>, which is a property provided by <code>ListenableWorker</code> (the superclass of <code>CoroutineWorker</code>) that keeps track of how many times the work has been attempted.</p>
<p class="calibre3">Finally, <code>MAX_RETRIES</code> is a constant that defines the maximum number of retries. It is set to <code>3</code> in this example.</p>
<p class="calibre3">To summarize, this <code>Worker</code> instance uploads messages by calling <code>uploadMessagesUseCase.execute()</code>, and it can retry the operation up to three times in case of failure. The actual dependencies of this <code>Worker</code> instance (<code>UploadMessagesUseCase</code>) are provided <a id="_idIndexMarker354" class="calibre6 pcalibre1 pcalibre"/>via <code>WorkRequest</code> class.</p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/>Setting up the WorkRequest class</h2>
<p class="calibre3">In the case of the <code>WorkRequest</code> class, we will have to think about how frequently we want our messages to be backed up; for example, we can do a backup once per week. Also, we are going to <a id="_idIndexMarker356" class="calibre6 pcalibre1 pcalibre"/>configure the <code>WorkRequest</code> class to be only called when the user has a Wi-Fi connection. Here is how we do it:</p>
<pre class="source-code">
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.UNMETERED)
    .build()
val uploadMessagesRequest =
PeriodicWorkRequestBuilder&lt;UploadMessagesWorker&gt;(7,
TimeUnit.DAYS)
    .setConstraints(constraints)
    .setBackoffCriteria(BackoffPolicy.LINEAR,
        PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS,
        TimeUnit.MILLISECONDS)
    .build()
WorkManager.getInstance(this).enqueue(
    uploadMessagesRequest)</pre> <p class="calibre3">We use <code>PeriodicWorkRequestBuilder</code> to create a <code>WorkRequest</code> instance that runs <code>UploadMessagesWorker</code> once every week. The <code>WorkRequest</code> instance has a constraint that requires an unmetered network connection (Wi-Fi). It also specifies a linear backoff policy for retries – this means that each retry attempt is delayed by a fixed amount of time, increasing linearly with each subsequent retry.</p>
<p class="calibre3">The <code>enqueue()</code> method schedules the <code>WorkRequest</code> instance to run. If the constraints are met and there’s no<a id="_idIndexMarker357" class="calibre6 pcalibre1 pcalibre"/> other work ahead of it in the queue, it will start running immediately. Otherwise, it will wait until the constraints are met and it’s the <code>WorkRequest</code> instance’s turn in the queue.</p>
<p class="calibre3">Please note that due to OS restrictions, a <code>PeriodicWorkRequest</code> instance may not run exactly when the period elapses; it may have some delay, but it will run at least once within that time period.</p>
<p class="calibre3">We can call this code and enqueue the <code>WorkRequest</code> instance from any place in our app, but to ensure it gets scheduled, the most convenient place is when we start up the app, in the <code>WhatsPacktApplication.onCreate</code> method:</p>
<pre class="source-code">
@HiltAndroidApp
class WhatsPacktApp: Application() {
    override fun onCreate() {
        super.onCreate()
        //Include WorkRequest initialization here
}
}</pre> <p class="calibre3">With all this, we would have our app ready to periodically back up messages, and our work well could have finished here. However, to explore a different approach, let’s see what happens if we need to integrate another storage provider – for example, Amazon S3.</p>
<h1 id="_idParaDest-82" class="calibre5"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/>Using Amazon S3 for storage</h1>
<p class="calibre3"><strong class="bold">Amazon S3</strong> is a scalable, high-speed, web-based cloud storage service designed for online backup and archiving of data and applications on <strong class="bold">Amazon Web Services </strong>(<strong class="bold">AWS</strong>). It’s a well-known alternative to<a id="_idIndexMarker358" class="calibre6 pcalibre1 pcalibre"/> Firebase Storage.</p>
<p class="calibre3">Here’s a brief overview of some key features and capabilities of Amazon S3:</p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold">Storage</strong>: Amazon S3 can store any amount of data and access it from anywhere on the web. It provides virtually limitless storage.</li>
<li class="calibre14"><strong class="bold">Durability and availability</strong>: Amazon <a id="_idIndexMarker359" class="calibre6 pcalibre1 pcalibre"/>S3 is designed for 99.999999999% (11 9s) of durability, and it stores redundant copies of data across multiple geographically separated data centers. It also provides 99.99% availability of objects over a given year.</li>
<li class="calibre14"><strong class="bold">Security</strong>: Amazon S3 provides advanced security features such as encryption for data at rest and in transit, and <a id="_idIndexMarker360" class="calibre6 pcalibre1 pcalibre"/>fine-grained access controls to resources using AWS <strong class="bold">Identity and Access Management </strong>(<strong class="bold">IAM</strong>), <strong class="bold">access control lists</strong> (<strong class="bold">ACLs</strong>), and bucket<a id="_idIndexMarker361" class="calibre6 pcalibre1 pcalibre"/> policies.</li>
<li class="calibre14"><strong class="bold">Scalability</strong>: Amazon S3 is designed to scale storage, requests, and users to support an unlimited number of web-scale applications.</li>
<li class="calibre14"><strong class="bold">Performance</strong>: AWS storage makes sure that when you add or delete files, you can immediately read the latest version of your files. If you overwrite a file or delete it, there might be a short delay before these changes are fully updated everywhere.</li>
<li class="calibre14"><strong class="bold">Integration</strong>: Amazon S3 integrates well with other AWS services, such as AWS CloudTrail for logging and monitoring, Amazon CloudFront for content delivery, AWS Lambda for serverless compute, and many more.</li>
<li class="calibre14"><strong class="bold">Management features</strong>: S3 provides functionalities for management tasks such as organizing data and configuring finely-tuned access controls to meet specific business, organizational, and compliance requirements.</li>
<li class="calibre14"><strong class="bold">Data transfer</strong>: S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and your Amazon S3 bucket.</li>
<li class="calibre14"><strong class="bold">Storage classes</strong>: Amazon S3 provides several storage classes for different types of data storage needs, such as S3 Standard for general-purpose storage of frequently accessed data, S3 Intelligent-Tiering for data with unknown or changing access patterns, S3<a id="_idIndexMarker362" class="calibre6 pcalibre1 pcalibre"/> Standard-IA for long-lived but infrequently accessed data, and S3 Glacier for long-term archive and digital preservation.</li>
<li class="calibre14"><strong class="bold">Query-in-place functionality</strong>: S3 Select enables applications to retrieve only a subset of data from an object by using simple SQL expressions.</li>
</ul>
<p class="calibre3">These features make Amazon S3 a robust and versatile choice for various use cases, ranging from web applications to backup and restore, archive, enterprise applications, IoT devices, and big data analytics.</p>
<p class="calibre3">To implement our storage solution based on Amazon S3, we first need to integrate the AWS SDK into our app.</p>
<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/>Integrating the AWS S3 SDK</h2>
<p class="calibre3">We can<a id="_idIndexMarker363" class="calibre6 pcalibre1 pcalibre"/> integrate the AWS S3 SDK into our Android project by adding the following dependencies in our <code>build.gradle</code> file:</p>
<pre class="source-code">
implementation 'com.amazonaws:aws-android-sdk-s3:
$latest_version'
implementation 'com.amazonaws:aws-android-sdk-
cognitoidentityprovider:$latest_version'</pre> <p class="calibre3">We have added here dependencies for the AWS SDK and the dependency needed to use Amazon Cognito.</p>
<p class="calibre3">We’ll also need to provide our AWS credentials (access key ID and secret access key) to the SDK. For mobile applications, it is recommended to use Amazon Cognito for credential management.</p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/>Setting up Amazon Cognito</h2>
<p class="calibre3"><strong class="bold">Amazon Cognito</strong> is a service that provides <a id="_idIndexMarker364" class="calibre6 pcalibre1 pcalibre"/>user sign-up and sign-in services, as well as access control for mobile and web applications. When you use Amazon Cognito for your user pool, you have the option to secure your data in AWS services (such as<a id="_idIndexMarker365" class="calibre6 pcalibre1 pcalibre"/> Amazon S3 for file storage) without having to embed AWS keys in your application code, which is a significant security risk.</p>
<p class="calibre3">Here are the instructions to set up Amazon Cognito in our Android application:</p>
<ol class="calibre13">
<li class="calibre14">First, go to the Amazon Cognito console: <a href="https://console.aws.amazon.com/cognito/home" class="calibre6 pcalibre1 pcalibre">https://console.aws.amazon.com/cognito/home</a>.</li>
<li class="calibre14">From there, click <strong class="bold">Identity Pools</strong>, then <strong class="bold">Create new </strong><strong class="bold">identity pool</strong>.</li>
<li class="calibre14">Check <strong class="bold">Guest Access</strong> under the <strong class="bold">Authentication</strong> section, and click <strong class="bold">Next</strong>.</li>
<li class="calibre14">Select <strong class="bold">Create a New IAM Role</strong>, create a name for it, and click <strong class="bold">Next</strong>.</li>
<li class="calibre14">Then create a new <a id="_idIndexMarker366" class="calibre6 pcalibre1 pcalibre"/>name for the identity pool and click <strong class="bold">Next</strong>.</li>
<li class="calibre14">Review the summary (as in <em class="italic">Figure 3</em><em class="italic">.4</em>), then click <strong class="bold">Create </strong><strong class="bold">identity pool</strong>:</li>
</ol>
<div><div><img alt="Figure 3.4: New identity pool configuration" src="img/B19443_03_004.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.4: New identity pool configuration</p>
<p class="callout-heading">Note</p>
<p class="callout">Here, we are enabling access to unauthenticated <a id="_idIndexMarker367" class="calibre6 pcalibre1 pcalibre"/>identities. You<a id="_idIndexMarker368" class="calibre6 pcalibre1 pcalibre"/> also have the option to give access only to authenticated identities, but note that you will have to create every user in Amazon Cognito. Nevertheless, this approach is more secure than using the S3 SDK to store keys in our app code.</p>
<ol class="calibre13">
<li value="7" class="calibre14">Next, in our app, we’ll need to obtain the AWS credentials provider. For that, we will initialize <strong class="source-inline1">CognitoCachingCredentialsProvider</strong> with our <strong class="source-inline1">IdentityPoolId</strong> class, in the region we configured it:<pre class="source-code">
val credentialsProvider =
CognitoCachingCredentialsProvider(
    applicationContext,
    "IdentityPoolId", // Identity Pool ID
    Regions.US_EAST_1 // Region
)</pre></li> <li class="calibre14">Now, we can use the <a id="_idIndexMarker369" class="calibre6 pcalibre1 pcalibre"/>credentials provider instance while creating a client for the AWS service. For example, to use it with Amazon S3, use this code:<pre class="source-code">
val s3 = AmazonS3Client(credentialsProvider)</pre></li> </ol>
<p class="calibre3">Now, it is time to create a <a id="_idIndexMarker370" class="calibre6 pcalibre1 pcalibre"/>new storage provider.</p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/>Creating an AWS S3 Storage provider and integrating it into our code</h2>
<p class="calibre3">Now, we need to do the same thing we did for Firebase Storage but with the AWS SDK: create a provider. This provider <a id="_idIndexMarker371" class="calibre6 pcalibre1 pcalibre"/>will be <code>AWSS3Provider</code> and will be <a id="_idIndexMarker372" class="calibre6 pcalibre1 pcalibre"/>used to handle the upload of files to AWS S3. It will take a <code>Context</code> object and a <code>CognitoCachingCredentialsProvider</code> object as constructor parameters.</p>
<p class="calibre3">This is how we can implement it:</p>
<pre class="source-code">
class AWSS3Provider(
    private val context: Context,
    private val credentialsProvider:
        CognitoCachingCredentialsProvider
) {
    suspend fun uploadFile(bucketName: String, objectKey:
    String, filePath: String) {
        withContext(Dispatchers.IO) {
            val transferUtility = TransferUtility.builder()
                .context(context)
                .awsConfiguration(AWSMobileClient
                    .getInstance().configuration)
                .s3Client(AmazonS3Client(
                    credentialsProvider))
                .build()
            val uploadObserver = transferUtility.upload(
                bucketName,
                objectKey,
                File(filePath)
            )
            uploadObserver.setTransferListener(object :
            TransferListener {
                override fun onStateChanged(id: Int, state:
                TransferState) {
                    if (TransferState.COMPLETED == state) {
                        // The file has been uploaded
                           successfully
                    }
                }
                override fun onProgressChanged(id: Int,
                bytesCurrent: Long, bytesTotal: Long) {
                    val progress = (bytesCurrent.toDouble()
                        / bytesTotal.toDouble() * 100.0)
                    Log.d("Upload Progress", "$progress%")
                }
                override fun onError(id: Int, ex:
                Exception) {
                    throw ex
                }
            })
        }
    }
}</pre> <p class="calibre3">The <code>uploadFile</code> function is a suspending function, meaning it can be called from any coroutine scope. The <code>withContext(Dispatchers.IO)</code> function is used to switch the coroutine context to the I/O <a id="_idIndexMarker373" class="calibre6 pcalibre1 pcalibre"/>dispatcher, which is optimized<a id="_idIndexMarker374" class="calibre6 pcalibre1 pcalibre"/> for I/O-related tasks, such as network calls or disk operations.</p>
<p class="calibre3">Let’s delve into the <code>uploadFile</code> function, which is the core of this class.</p>
<p class="calibre3">The <code>TransferUtility</code> class simplifies the process of uploading and downloading files to/from Amazon S3. Here, we’re building a <code>TransferUtility</code> instance, providing it with the Android context, AWS configuration, and an <code>AmazonS3Client</code> instance initialized with the provided <code>CognitoCachingCredentialsProvider</code> class.</p>
<p class="calibre3">The <code>transferUtility.upload()</code> method is used to upload a file to the specified bucket in S3. We provide the name of the bucket (<code>bucketName</code>), the key under which to store the new object (<code>objectKey</code>), and the file we want to upload (<code>File(filePath)</code>). This function returns a <code>UploadObserver</code> instance.</p>
<p class="calibre3"><code>UploadObserver</code> is used to monitor the progress of the upload.</p>
<p class="calibre3">We attach<code>TransferListener</code> to the<a id="_idIndexMarker375" class="calibre6 pcalibre1 pcalibre"/> observer to get callbacks when the upload state changes, the upload makes <a id="_idIndexMarker376" class="calibre6 pcalibre1 pcalibre"/>progress, or an error occurs.</p>
<p class="calibre3">The <code>onStateChanged()</code> method is called when the state of the transfer changes. If the state is <code>TransferState.COMPLETED</code>, it means the file has been uploaded successfully.</p>
<p class="calibre3">The <code>onProgressChanged()</code> method is called when more bytes have been transferred. Here, we calculate the progress as a percentage and log it.</p>
<p class="calibre3">The <code>onError()</code> method is called if an error occurs during the transfer. We will throw an error when it happens, to be handled by the consumers or this provider.</p>
<p class="calibre3">The <code>uploadFile</code> function is called from within a coroutine, and since the actual upload operation is a network I/O operation, it’s wrapped in <code>withContext(Dispatchers.IO)</code>. This ensures the operation doesn’t block the main thread, as the I/O dispatcher uses a separate thread pool that’s optimized for disk and network I/O.</p>
<p class="calibre3">Now, we will need to create a data source to connect our <code>BackupRepository</code> instance to this new provider. The best way to do it is by implementing <code>IStorageDataSource,</code> a common interface for both data sources. This way, you’re able to swap the underlying implementation (Firebase Storage, AWS S3, and so on) without changing the rest of your code. (This is an application of the <strong class="bold">Dependency Inversion Principle</strong> (<strong class="bold">DIP</strong>), one of the SOLID<a id="_idIndexMarker377" class="calibre6 pcalibre1 pcalibre"/> principles of <strong class="bold">object-oriented</strong> (<strong class="bold">OO</strong>) design, which helps make your code more flexible and easier to<a id="_idIndexMarker378" class="calibre6 pcalibre1 pcalibre"/> maintain.)</p>
<p class="calibre3">This is how we will implement <code>S3StorageDataSource</code>:</p>
<pre class="source-code">
class S3StorageDataSource @Inject constructor(
    private val awsS3Provider: AWSS3Provider
) : IStorageDataSource {
    override suspend fun uploadFile(remotePath: String,
    file: File) {
        awsS3Provider.uploadFile(BUCKET_NAME, remotePath,
        file.absolutePath)
    }
    companion object {
        private const val BUCKET_NAME = "our-bucket-name"
    }
}</pre> <p class="calibre3">In this code, we are implementing the <code>uploadFile</code> function calling the <code>awsProvider.uploadFile</code> function, which<a id="_idIndexMarker379" class="calibre6 pcalibre1 pcalibre"/> will upload the file to the bucket with the <code>our-bucket-name</code> name.</p>
<p class="calibre3">This new <code>S3StorageDataSource</code> class can <a id="_idIndexMarker380" class="calibre6 pcalibre1 pcalibre"/>be provided via Hilt in a similar way to the previous <code>FirebaseStorageDataSource</code> class:</p>
<pre class="source-code">
@Module
@InstallIn(SingletonComponent::class)
object StorageModule {
    @Provides
    @Singleton
    fun provideStorageDataSource(awsS3Provider:
    AWSS3Provider): IStorageDataSource {
        return S3StorageDataSource(awsS3Provider)
    }
}</pre> <p class="calibre3">Here, we create a <code>@Module</code> annotation that includes a <code>@Provides</code> or <code>@Binds</code> method for <code>IStorageDataSource</code>, and Hilt will take care of injecting the right implementation based on your configuration. If <a id="_idIndexMarker381" class="calibre6 pcalibre1 pcalibre"/>you want to switch from Firebase Storage to AWS S3, you’d modify<a id="_idIndexMarker382" class="calibre6 pcalibre1 pcalibre"/> this module to provide <code>S3StorageDataSource</code> instead of <code>FirebaseStorageDataSource</code>.</p>
<p class="calibre3">Finally, we need to integrate it into our <code>BackupRepository</code> class. It is as easy as replacing the <code>StorageDataSource</code> dependency for the <code>IStorageDataSource</code> dependency:</p>
<pre class="source-code">
class BackupRepository @Inject constructor(
    private val messageDao: MessageDao,
    private val conversationDao: ConversationDao,
    private val storageDataSource: IStorageDataSource
) {
    // The rest of the class as it was before
...
}</pre> <p class="calibre3">And that’s all. Depending on what we are providing in our Hilt module to satisfy the <code>IStorageDataSource</code> dependency, it will use the Firebase Storage one or the AWS S3 one.</p>
<p class="calibre3">And with this change, we finish this chapter and also our work in the WhatsPackt application!</p>
<div><div><img alt="Figure 3.5: WhatsPackt’s final appearance" src="img/B19443_03_005.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 3.5: WhatsPackt’s final appearance</p>
<h1 id="_idParaDest-86" class="calibre5"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we centered our efforts on creating a good offline experience for our user (storing the messages in a local database using Room) and providing a mechanism to store the messages backup, in case something fails. We have also learned how to use different providers to store our files in the cloud using Firebase Firestore and AWS S3.</p>
<p class="calibre3">Now, we have finished our work in the WhatsPackt app. In the next chapter, we will start building a new app: Packtagram. It will be an app to share photos and videos with our friends that will provide new and different challenges when creating it, such as capturing video. These are challenges that we will learn to overcome.</p>
</div>
</body></html>