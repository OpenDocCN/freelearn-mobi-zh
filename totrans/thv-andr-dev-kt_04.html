<html><head></head><body>
<div id="_idContainer030" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-60"><a id="_idTextAnchor060" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-61" class="calibre5"><a id="_idTextAnchor061" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.2.1">Backing Up Your WhatsPackt Messages</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">In any chat application, data handling is a significant concern – we need to ensure that messages sent and received are stored correctly, quickly retrieved when needed, and resilient to potential losses due to unforeseen circumstances such as device failures or accidental deletions. </span><span class="kobospan" id="kobo.3.2">This requires a robust data persistence strategy. </span><span class="kobospan" id="kobo.3.3">We also need to consider performance and user experience, which calls for effective caching mechanisms, as well as making sure that we have backups in the event of data loss or when the user </span><span><span class="kobospan" id="kobo.4.1">changes devices.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.5.1">In this chapter, we will start by introducing you to Room, a persistence library that provides an abstraction layer over SQLite and makes it easier to work with databases in Android. </span><span class="kobospan" id="kobo.5.2">You’ll learn about its architecture and components and how to use it to store and retrieve chat conversations </span><span><span class="kobospan" id="kobo.6.1">and messages.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.7.1">Next, we will tackle the creation of a cache mechanism orchestrating the use of Room locally and the use of the API to gather data from </span><span><span class="kobospan" id="kobo.8.1">the backend.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.9.1">Moving forward, we’ll get you up to speed with Firebase Storage. </span><span class="kobospan" id="kobo.9.2">You’ll learn to set it up, understand its benefits, and how to secure data stored in it. </span><span class="kobospan" id="kobo.9.3">We’ll then use Firebase Storage to create a backup of our chat conversations, an essential feature for any </span><span><span class="kobospan" id="kobo.10.1">chat application.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.11.1">Finally, we’ll explore how to use </span><strong class="source-inline"><span class="kobospan" id="kobo.12.1">WorkManager</span></strong><span class="kobospan" id="kobo.13.1">, an API that makes it easy to schedule deferrable, asynchronous tasks even if the app exits or the device restarts. </span><span class="kobospan" id="kobo.13.2">You’ll learn how it can be used to schedule chat backups and how to upload these backups to </span><strong class="bold"><span class="kobospan" id="kobo.14.1">Amazon Simple Storage Service</span></strong><span class="kobospan" id="kobo.15.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.16.1">Amazon S3</span></strong><span class="kobospan" id="kobo.17.1">), ensuring </span><span><span class="kobospan" id="kobo.18.1">data safety.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.19.1">So, in this chapter, we will be covering the </span><span><span class="kobospan" id="kobo.20.1">following topics:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><span class="kobospan" id="kobo.21.1">Understanding Room</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.22.1">Implementing Room </span><span><span class="kobospan" id="kobo.23.1">in WhatsPackt</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.24.1">Getting to know </span><span><span class="kobospan" id="kobo.25.1">Firebase Storage</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.26.1">Scheduling </span><strong class="source-inline1"><span class="kobospan" id="kobo.27.1">WorkManager</span></strong><span class="kobospan" id="kobo.28.1"> to </span><span><span class="kobospan" id="kobo.29.1">send backups</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.30.1">Using Amazon S3 </span><span><span class="kobospan" id="kobo.31.1">for storage</span></span></li>
</ul>
<h1 id="_idParaDest-62" class="calibre5"><a id="_idTextAnchor062" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.32.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.33.1">As in the previous chapter, you will need to have installed Android Studio (or another editor of </span><span><span class="kobospan" id="kobo.34.1">your preference).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.35.1">We are also going to assume that you followed along with the previous chapter. </span><span class="kobospan" id="kobo.35.2">You can download this chapter’s complete code from </span><span><span class="kobospan" id="kobo.36.1">here: </span></span><a href="https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.37.1">https://github.com/PacktPublishing/Thriving-in-Android-Development-using-Kotlin/tree/main/Chapter-3</span></span></a><span><span class="kobospan" id="kobo.38.1">.</span></span></p>
<h1 id="_idParaDest-63" class="calibre5"><a id="_idTextAnchor063" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.39.1">Understanding Room</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.40.1">When it comes to </span><a id="_idIndexMarker287" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.41.1">Android development, one of the most essential tasks is managing your application’s data in a local database. </span><span class="kobospan" id="kobo.41.2">The </span><strong class="bold"><span class="kobospan" id="kobo.42.1">Room</span></strong><span class="kobospan" id="kobo.43.1"> persistence library, part of Android Jetpack, is an abstraction layer over SQLite, a popular database that comes with Android. </span><span class="kobospan" id="kobo.43.2">Room offers more robust database access while harnessing SQLite’s </span><span><span class="kobospan" id="kobo.44.1">full power.</span></span></p>
<h2 id="_idParaDest-64" class="calibre7"><a id="_idTextAnchor064" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.45.1">Key features of Room</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.46.1">Before Room, developers primarily</span><a id="_idIndexMarker288" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.47.1"> used </span><strong class="bold"><span class="kobospan" id="kobo.48.1">SQLite</span></strong><span class="kobospan" id="kobo.49.1"> directly or other </span><strong class="bold"><span class="kobospan" id="kobo.50.1">object-relational mapping</span></strong><span class="kobospan" id="kobo.51.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.52.1">ORM</span></strong><span class="kobospan" id="kobo.53.1">) libraries. </span><span class="kobospan" id="kobo.53.2">While SQLite is</span><a id="_idIndexMarker289" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.54.1"> powerful, it can be cumbersome to work with because it requires writing a lot </span><a id="_idIndexMarker290" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.55.1">of boilerplate code. </span><span class="kobospan" id="kobo.55.2">Additionally, errors in SQL queries often aren’t detected until runtime, which can lead </span><span><span class="kobospan" id="kobo.56.1">to crashes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.57.1">Room solves these issues by providing a simpler and more robust API over the standard SQLite for managing local data storage. </span><span class="kobospan" id="kobo.57.2">Here are some of its </span><span><span class="kobospan" id="kobo.58.1">key features:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.59.1">Compile-time verification of SQL queries</span></strong><span class="kobospan" id="kobo.60.1">: Room verifies your SQL queries at compile time, not at runtime. </span><span class="kobospan" id="kobo.60.2">This means if there’s an error in one of your queries, you’ll know as soon as you compile your app, not after you’ve shipped it to users. </span><span class="kobospan" id="kobo.60.3">This leads to more robust and </span><span><span class="kobospan" id="kobo.61.1">reliable code.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.62.1">Reduced boilerplate code</span></strong><span class="kobospan" id="kobo.63.1">: With Room, you don’t need to write as much code to perform simple database operations. </span><span class="kobospan" id="kobo.63.2">This leads to cleaner, more </span><span><span class="kobospan" id="kobo.64.1">readable code.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.65.1">Integration with other architecture components</span></strong><span class="kobospan" id="kobo.66.1">: Room is designed to integrate seamlessly </span><a id="_idIndexMarker291" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.67.1">with other </span><strong class="bold"><span class="kobospan" id="kobo.68.1">Android Architecture Components</span></strong><span class="kobospan" id="kobo.69.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.70.1">AAC</span></strong><span class="kobospan" id="kobo.71.1">) library components, such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.72.1">LiveData</span></strong><span class="kobospan" id="kobo.73.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.74.1">ViewModel</span></strong><span class="kobospan" id="kobo.75.1">. </span><span class="kobospan" id="kobo.75.2">This means you can create a well-architected, robust </span><a id="_idIndexMarker292" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.76.1">app that follows best practices for </span><span><span class="kobospan" id="kobo.77.1">Android development.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.78.1">Easy migration paths</span></strong><span class="kobospan" id="kobo.79.1">: Room offers robust migration support, including migration paths and testing. </span><span class="kobospan" id="kobo.79.2">As your app’s data needs evolve, Room makes it easy to adapt your database structure to meet </span><span><span class="kobospan" id="kobo.80.1">those needs.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.81.1">Supports complex queries</span></strong><span class="kobospan" id="kobo.82.1">: Despite simplifying interaction with SQLite, Room still allows you to perform complex SQL queries when you need more flexibility </span><span><span class="kobospan" id="kobo.83.1">and power.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.84.1">As you can see, Room offers an efficient and streamlined approach to managing your app’s local data. </span><span class="kobospan" id="kobo.84.2">It’s a powerful tool that can make your Android development experience much more pleasant </span><span><span class="kobospan" id="kobo.85.1">and productive.</span></span></p>
<h2 id="_idParaDest-65" class="calibre7"><a id="_idTextAnchor065" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.86.1">Room’s architecture and components</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.87.1">Room’s architecture is based </span><a id="_idIndexMarker293" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.88.1">on three </span><span><span class="kobospan" id="kobo.89.1">main components:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span><strong class="source-inline1"><span class="kobospan" id="kobo.90.1">Database</span></strong></span></li>
<li class="calibre14"><span><strong class="source-inline1"><span class="kobospan" id="kobo.91.1">Entity</span></strong></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.92.1">Data Access </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.93.1">Object</span></strong></span><span><span class="kobospan" id="kobo.94.1"> (</span></span><span><strong class="bold"><span class="kobospan" id="kobo.95.1">DAO</span></strong></span><span><span class="kobospan" id="kobo.96.1">)</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.97.1">Here, you can see how every </span><a id="_idIndexMarker294" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.98.1">Room component interacts with the rest of </span><span><span class="kobospan" id="kobo.99.1">the app:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer025">
<span class="kobospan" id="kobo.100.1"><img alt="Figure 3.1: Diagram of Room architecture" src="image/B19443_03_001.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.101.1">Figure 3.1: Diagram of Room architecture</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.102.1">Understanding these </span><a id="_idIndexMarker295" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.103.1">components is crucial when using Room effectively, so let’s dive into </span><span><span class="kobospan" id="kobo.104.1">them deeper.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.105.1">Database</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.106.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.107.1">Database</span></strong><span class="kobospan" id="kobo.108.1"> class in Room is a high-level class that works as the main access point to your app’s persisted data. </span><span class="kobospan" id="kobo.108.2">It’s an </span><a id="_idIndexMarker296" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.109.1">abstract class where you define an abstract method for each </span><strong class="source-inline"><span class="kobospan" id="kobo.110.1">@Dao</span></strong><span class="kobospan" id="kobo.111.1"> annotation in your app. </span><span class="kobospan" id="kobo.111.2">When you create an instance of the </span><strong class="source-inline"><span class="kobospan" id="kobo.112.1">Database</span></strong><span class="kobospan" id="kobo.113.1"> class, Room generates the implementation code of these DAO methods (DAO will be explored in more detail in </span><span><span class="kobospan" id="kobo.114.1">a moment).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.115.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.116.1">Database</span></strong><span class="kobospan" id="kobo.117.1"> class is annotated with </span><strong class="source-inline"><span class="kobospan" id="kobo.118.1">@Database</span></strong><span class="kobospan" id="kobo.119.1">, specifying the entities it comprises and the database version. </span><span class="kobospan" id="kobo.119.2">If you modify the database schema, you need to update the version number and define a migration strategy, as in the </span><span><span class="kobospan" id="kobo.120.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.121.1">
@Database(entities = [Message::class, Conversation::class],
    version = 1)
abstract class ChatAppDatabase : RoomDatabase() {
    abstract fun messageDao(): MessageDao
    abstract fun conversationDao(): ConversationDao
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.122.1">Here, we’ve defined a </span><strong class="source-inline"><span class="kobospan" id="kobo.123.1">ChatAppDatabase</span></strong><span class="kobospan" id="kobo.124.1"> Room </span><strong class="source-inline"><span class="kobospan" id="kobo.125.1">Database</span></strong><span class="kobospan" id="kobo.126.1"> class with two entities, </span><strong class="source-inline"><span class="kobospan" id="kobo.127.1">Message</span></strong><span class="kobospan" id="kobo.128.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">Conversation</span></strong><span class="kobospan" id="kobo.130.1">. </span><span class="kobospan" id="kobo.130.2">We’ve also defined abstract methods to access our DAOs – </span><strong class="source-inline"><span class="kobospan" id="kobo.131.1">messageDao()</span></strong><span class="kobospan" id="kobo.132.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.133.1">conversationDao()</span></strong><span class="kobospan" id="kobo.134.1">. </span><span class="kobospan" id="kobo.134.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.135.1">entities</span></strong><span class="kobospan" id="kobo.136.1"> parameter in the </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">@Database</span></strong><span class="kobospan" id="kobo.138.1"> annotation</span><a id="_idIndexMarker297" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.139.1"> takes an array of all entities in the database, while the </span><strong class="source-inline"><span class="kobospan" id="kobo.140.1">version</span></strong><span class="kobospan" id="kobo.141.1"> parameter is used for database </span><span><span class="kobospan" id="kobo.142.1">migration purposes.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.143.1">Entity</span></h3>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.144.1">Entities</span></strong><span class="kobospan" id="kobo.145.1"> in Room represent the tables in a database. </span><span class="kobospan" id="kobo.145.2">Each entity corresponds to a table, and each instance of an entity</span><a id="_idIndexMarker298" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.146.1"> represents a row in the table. </span><span class="kobospan" id="kobo.146.2">Room uses the class fields in an entity to define the columns in </span><span><span class="kobospan" id="kobo.147.1">a table.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.148.1">You declare an entity by annotating a data class with </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">@Entity</span></strong><span class="kobospan" id="kobo.150.1">. </span><span class="kobospan" id="kobo.150.2">Each </span><strong class="source-inline"><span class="kobospan" id="kobo.151.1">@Entity</span></strong><span class="kobospan" id="kobo.152.1"> class represents a table in your database, and you can define the table name. </span><span class="kobospan" id="kobo.152.2">If you don’t define a table name, Room uses the class name as the table name, as in the </span><span><span class="kobospan" id="kobo.153.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.154.1">
@Entity(tableName = "messages")
data class Message(
    @PrimaryKey val id: String,
    @ColumnInfo(name = "conversation_id") val
        conversationId: String,
    // ...
</span><span class="kobospan1" id="kobo.154.2">)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.155.1">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">Message</span></strong><span class="kobospan" id="kobo.157.1"> is an entity that represents a </span><strong class="source-inline"><span class="kobospan" id="kobo.158.1">"messages"</span></strong><span class="kobospan" id="kobo.159.1"> table in our database. </span><span class="kobospan" id="kobo.159.2">Each instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.160.1">Message</span></strong><span class="kobospan" id="kobo.161.1"> will represent a row within the </span><strong class="source-inline"><span class="kobospan" id="kobo.162.1">"messages"</span></strong><span class="kobospan" id="kobo.163.1"> table. </span><span class="kobospan" id="kobo.163.2">Each property in the </span><strong class="source-inline"><span class="kobospan" id="kobo.164.1">Message</span></strong><span class="kobospan" id="kobo.165.1"> class represents a column in the table. </span><span class="kobospan" id="kobo.165.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.166.1">@PrimaryKey</span></strong><span class="kobospan" id="kobo.167.1"> annotation is used to denote a primary key, and the </span><strong class="source-inline"><span class="kobospan" id="kobo.168.1">@ColumnInfo</span></strong><span class="kobospan" id="kobo.169.1"> annotation is used to specify the column name in the database. </span><span class="kobospan" id="kobo.169.2">If not specified, Room uses the variable name as the </span><span><span class="kobospan" id="kobo.170.1">column name.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.171.1">DAO</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.172.1">DAOs are interfaces that define all the database operations that you want to perform. </span><span class="kobospan" id="kobo.172.2">For each DAO, you can </span><a id="_idIndexMarker299" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.173.1">define methods for different operations such as insertion, deletion, </span><span><span class="kobospan" id="kobo.174.1">and querying.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.175.1">You should annotate an interface with </span><strong class="source-inline"><span class="kobospan" id="kobo.176.1">@Dao</span></strong><span class="kobospan" id="kobo.177.1">, and then annotate each method with the corresponding operation you want to perform, such as </span><strong class="source-inline"><span class="kobospan" id="kobo.178.1">@Insert</span></strong><span class="kobospan" id="kobo.179.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.180.1">@Delete</span></strong><span class="kobospan" id="kobo.181.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.182.1">@Update</span></strong><span class="kobospan" id="kobo.183.1">, or </span><strong class="source-inline"><span class="kobospan" id="kobo.184.1">@Query</span></strong><span class="kobospan" id="kobo.185.1"> for custom queries. </span><span class="kobospan" id="kobo.185.2">Then, Room will autogenerate the necessary code to perform these operations at compile time. </span><span class="kobospan" id="kobo.185.3">Here’s </span><span><span class="kobospan" id="kobo.186.1">an example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.187.1">
@Dao
interface MessageDao {
    @Insert
    fun insert(message: Message)
    @Query("SELECT * FROM messages WHERE conversation_id =
        :conversationId")
    fun getMessagesForConversation(conversationId: String):
        List&lt;Message&gt;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.188.1">In this </span><strong class="source-inline"><span class="kobospan" id="kobo.189.1">MessageDao</span></strong><span class="kobospan" id="kobo.190.1"> interface, we’ve defined two methods – </span><strong class="source-inline"><span class="kobospan" id="kobo.191.1">insert()</span></strong><span class="kobospan" id="kobo.192.1"> for inserting a </span><strong class="source-inline"><span class="kobospan" id="kobo.193.1">Message</span></strong><span class="kobospan" id="kobo.194.1"> object into our database and </span><strong class="source-inline"><span class="kobospan" id="kobo.195.1">getMessagesForConversation()</span></strong><span class="kobospan" id="kobo.196.1"> to retrieve all messages related to a specific conversation from our database. </span><span class="kobospan" id="kobo.196.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.197.1">@Insert</span></strong><span class="kobospan" id="kobo.198.1"> annotation is a convenience annotation for inserting an entity into a table. </span><span class="kobospan" id="kobo.198.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.199.1">@Query</span></strong><span class="kobospan" id="kobo.200.1"> annotation allows us to write SQL queries to perform complex reads </span><span><span class="kobospan" id="kobo.201.1">and writes.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.202.1">Understanding these components will allow us to leverage the power of Room effectively. </span><span class="kobospan" id="kobo.202.2">The following sections will guide you through the process of implementing Room in our WhatsPackt application, starting from setting it up in Android Studio to creating entities </span><span><span class="kobospan" id="kobo.203.1">and </span></span><span><a id="_idIndexMarker300" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.204.1">DAOs.</span></span></p>
<h1 id="_idParaDest-66" class="calibre5"><a id="_idTextAnchor066" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.205.1">Implementing Room in WhatsPackt</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.206.1">In this section, you will be guided through the practical steps of implementing Room in our chat application. </span><span class="kobospan" id="kobo.206.2">We will</span><a id="_idIndexMarker301" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.207.1"> begin by setting up Room in Android Studio, followed by</span><a id="_idIndexMarker302" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.208.1"> creating entities and DAOs and eventually using these components to interact with </span><span><span class="kobospan" id="kobo.209.1">our database.</span></span></p>
<h2 id="_idParaDest-67" class="calibre7"><a id="_idTextAnchor067" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.210.1">Adding dependencies</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.211.1">To start using Room, we first need to</span><a id="_idIndexMarker303" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.212.1"> include the necessary dependencies in our project. </span><span class="kobospan" id="kobo.212.2">Open your </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">build.gradle</span></strong><span class="kobospan" id="kobo.214.1"> file and add the following dependencies </span><span><span class="kobospan" id="kobo.215.1">under </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.216.1">dependencies</span></strong></span><span><span class="kobospan" id="kobo.217.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.218.1">
dependencies {
    implementation "androidx.room:room-runtime:2.3.0"
    kapt "androidx.room:room-compiler:2.3.0"
    implementation "androidx.room:room-ktx:2.3.0"
    // optional - Test helpers
    testImplementation "androidx.room:room-testing:2.3.0"
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.219.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.220.1">room-runtime</span></strong><span class="kobospan" id="kobo.221.1"> dependency includes the core Room library, while the </span><strong class="source-inline"><span class="kobospan" id="kobo.222.1">room-compiler</span></strong><span class="kobospan" id="kobo.223.1"> dependency is required for Room’s annotation-processing capabilities. </span><span class="kobospan" id="kobo.223.2">Room’s Kotlin extensions and coroutines support are provided by </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">room-ktx</span></strong><span class="kobospan" id="kobo.225.1">, while </span><strong class="source-inline"><span class="kobospan" id="kobo.226.1">room-testing</span></strong><span class="kobospan" id="kobo.227.1"> provides useful classes for testing your </span><span><span class="kobospan" id="kobo.228.1">Room setup.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.229.1">After adding these lines, sync your project. </span><span class="kobospan" id="kobo.229.2">You can do it using the </span><strong class="bold"><span class="kobospan" id="kobo.230.1">File</span></strong><span class="kobospan" id="kobo.231.1"> | </span><strong class="bold"><span class="kobospan" id="kobo.232.1">Sync Project with Gradle Files</span></strong><span class="kobospan" id="kobo.233.1"> option from the Android Studio menu or by selecting </span><strong class="bold"><span class="kobospan" id="kobo.234.1">Sync Now</span></strong><span class="kobospan" id="kobo.235.1"> in the automatic message that appears in the editor after adding the dependencies to the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.236.1">build.gradle</span></strong></span><span><span class="kobospan" id="kobo.237.1"> file:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer026">
<span class="kobospan" id="kobo.238.1"><img alt="Figure 3.2: The Sync Now option that appears in Android Studio when it detects any changes to Gradle files" src="image/B19443_03_002.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.239.1">Figure 3.2: The Sync Now option that appears in Android Studio when it detects any changes to Gradle files</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.240.1">We are ready now to</span><a id="_idIndexMarker304" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.241.1"> create </span><span><span class="kobospan" id="kobo.242.1">our database.</span></span></p>
<h2 id="_idParaDest-68" class="calibre7"><a id="_idTextAnchor068" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.243.1">Creating the database</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.244.1">As discussed before, the </span><strong class="source-inline"><span class="kobospan" id="kobo.245.1">Database</span></strong><span class="kobospan" id="kobo.246.1"> component is the</span><a id="_idIndexMarker305" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.247.1"> main access point for our app’s data. </span><span class="kobospan" id="kobo.247.2">So, let’s create a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.248.1">ChatAppDatabase</span></strong></span><span><span class="kobospan" id="kobo.249.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.250.1">
@Database(entities = [Message::class, Conversation::class],
version = 1)
abstract class ChatAppDatabase : RoomDatabase() {
    abstract fun messageDao(): MessageDao
    abstract fun conversationDao(): ConversationDao
    companion object {
        @Volatile
        private var INSTANCE: ChatAppDatabase? </span><span class="kobospan1" id="kobo.250.2">= null
        fun getDatabase(context: Context): ChatAppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    ChatAppDatabase::class.java,
                    "chat_database"
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.251.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.252.1">@Database</span></strong><span class="kobospan" id="kobo.253.1"> annotation marks this class as a Room database. </span><span class="kobospan" id="kobo.253.2">It takes </span><span><span class="kobospan" id="kobo.254.1">two parameters:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.255.1">entities</span></strong><span class="kobospan" id="kobo.256.1"> is an array </span><a id="_idIndexMarker306" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.257.1">of classes that are annotated with </span><strong class="source-inline1"><span class="kobospan" id="kobo.258.1">@Entity</span></strong><span class="kobospan" id="kobo.259.1">, representing the tables within the database. </span><span class="kobospan" id="kobo.259.2">In this case, the </span><strong class="source-inline1"><span class="kobospan" id="kobo.260.1">Message</span></strong><span class="kobospan" id="kobo.261.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.262.1">Conversation</span></strong><span class="kobospan" id="kobo.263.1"> classes are entities </span><span><span class="kobospan" id="kobo.264.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.265.1">ChatAppDatabase</span></strong></span><span><span class="kobospan" id="kobo.266.1">.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.267.1">version</span></strong><span class="kobospan" id="kobo.268.1"> is the database version. </span><span class="kobospan" id="kobo.268.2">If you make changes to the database schema, you’ll need to increment this version number and define a </span><span><span class="kobospan" id="kobo.269.1">migration strategy.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.270.1">Next, </span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">abstract fun messageDao(): MessageDao</span></strong><span class="kobospan" id="kobo.272.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.273.1">abstract fun conversationDao(): ConversationDao</span></strong><span class="kobospan" id="kobo.274.1"> are abstract methods that return the respective DAOs. </span><span class="kobospan" id="kobo.274.2">They do not have method bodies because Room generates </span><span><span class="kobospan" id="kobo.275.1">their implementations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.276.1">Then, we declare a companion object to hold a singleton instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.277.1">ChatAppDatabase</span></strong><span class="kobospan" id="kobo.278.1">, by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.279.1">@Volatile</span></strong><span class="kobospan" id="kobo.280.1"> annotation. </span><span class="kobospan" id="kobo.280.2">This annotation means </span><strong class="source-inline"><span class="kobospan" id="kobo.281.1">INSTANCE</span></strong><span class="kobospan" id="kobo.282.1"> can be accessed by multiple threads at once but always in a consistent state, meaning a change made by one thread to </span><strong class="source-inline"><span class="kobospan" id="kobo.283.1">INSTANCE</span></strong><span class="kobospan" id="kobo.284.1"> is immediately visible to all other threads. </span><strong class="source-inline"><span class="kobospan" id="kobo.285.1">INSTANCE</span></strong><span class="kobospan" id="kobo.286.1"> is marked as nullable because it might not be </span><span><span class="kobospan" id="kobo.287.1">initialized immediately.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.288.1">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">getDatabase()</span></strong><span class="kobospan" id="kobo.290.1"> function, we’re implementing a common pattern for creating a singleton instance of a class in a thread-safe way. </span><span class="kobospan" id="kobo.290.2">This pattern ensures that only one instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">ChatAppDatabase</span></strong><span class="kobospan" id="kobo.292.1"> is </span><span><span class="kobospan" id="kobo.293.1">ever created.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.294.1">We use the </span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">?:</span></strong><span class="kobospan" id="kobo.296.1"> operator to check whether </span><strong class="source-inline"><span class="kobospan" id="kobo.297.1">INSTANCE</span></strong><span class="kobospan" id="kobo.298.1"> is not </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">null</span></strong><span class="kobospan" id="kobo.300.1">, and if it is, we enter the synchronized block. </span><span class="kobospan" id="kobo.300.2">This block ensures that only one thread can enter this block of code at a time, preventing the creation of multiple instances of </span><strong class="source-inline"><span class="kobospan" id="kobo.301.1">ChatAppDatabase</span></strong><span class="kobospan" id="kobo.302.1"> if the function is called concurrently from </span><span><span class="kobospan" id="kobo.303.1">multiple threads.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.304.1">Within the synchronized block, we’re calling </span><strong class="source-inline"><span class="kobospan" id="kobo.305.1">Room.databaseBuilder()</span></strong><span class="kobospan" id="kobo.306.1"> to create a new instance of </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">ChatAppDatabase</span></strong><span class="kobospan" id="kobo.308.1">. </span><span class="kobospan" id="kobo.308.2">We provide the application context to avoid memory leaks, the class of the database, and the name of </span><span><span class="kobospan" id="kobo.309.1">the database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.310.1">Finally, we call </span><strong class="source-inline"><span class="kobospan" id="kobo.311.1">build()</span></strong><span class="kobospan" id="kobo.312.1"> to create the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.313.1">ChatAppDatabase</span></strong></span><span><span class="kobospan" id="kobo.314.1"> instance.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.315.1">After creating the new instance, we assign it to </span><strong class="source-inline"><span class="kobospan" id="kobo.316.1">INSTANCE</span></strong><span class="kobospan" id="kobo.317.1"> to cache it and then return the instance. </span><span class="kobospan" id="kobo.317.2">The next time </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">getDatabase</span></strong><span class="kobospan" id="kobo.319.1"> is called, it will return the cached database instance instead of creating a</span><a id="_idIndexMarker307" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.320.1"> new one. </span><span class="kobospan" id="kobo.320.2">This is important because creating a Room database instance is an expensive operation, and having multiple instances would be a waste </span><span><span class="kobospan" id="kobo.321.1">of resources.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.322.1">This structure is essential for creating a database instance that will allow us to store messages </span><span><span class="kobospan" id="kobo.323.1">and conversations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.324.1">The next step is to create </span><span><span class="kobospan" id="kobo.325.1">entity classes.</span></span></p>
<h2 id="_idParaDest-69" class="calibre7"><a id="_idTextAnchor069" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.326.1">Creating entity classes</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">The first entity class </span><a id="_idIndexMarker308" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.328.1">we are going to create is the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.329.1">Message</span></strong></span><span><span class="kobospan" id="kobo.330.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.331.1">
@Entity(
    tableName = "messages",
    foreignKeys = [
        ForeignKey(
            entity = Conversation::class,
            parentColumns = arrayOf("id"),
            childColumns = arrayOf("conversation_id"),
            onDelete = ForeignKey.CASCADE
        )
    ],
    indices = [
        Index(value = ["conversation_id"])
    ]
)
data class Message(
    @PrimaryKey(name = "id") val id: Int,
    @ColumnInfo(name = "conversation_id") val
        conversationId: Int,
    @ColumnInfo(name = "sender") val sender: String,
    @ColumnInfo(name = "content") val content: String,
    @ColumnInfo(name = "timestamp") val timestamp: Long
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.332.1">In this code, we are including </span><a id="_idIndexMarker309" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.333.1">quite a lot of instructions in the annotations, so let’s go </span><span><span class="kobospan" id="kobo.334.1">through them.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.335.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.336.1">@Entity</span></strong><span class="kobospan" id="kobo.337.1"> annotation tells Room to treat this class as a table in the database. </span><span class="kobospan" id="kobo.337.2">It comes with optional arguments, some of which are </span><span><span class="kobospan" id="kobo.338.1">used here:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.339.1">tableName</span></strong><span class="kobospan" id="kobo.340.1">: This sets the name of the table as it will appear in the database. </span><span class="kobospan" id="kobo.340.2">In this case, our table will be </span><span><span class="kobospan" id="kobo.341.1">named </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.342.1">"messages"</span></strong></span><span><span class="kobospan" id="kobo.343.1">.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.344.1">foreignKeys</span></strong><span class="kobospan" id="kobo.345.1">: This sets up a foreign key relationship with another table. </span><span class="kobospan" id="kobo.345.2">A </span><strong class="source-inline1"><span class="kobospan" id="kobo.346.1">ForeignKey</span></strong><span class="kobospan" id="kobo.347.1"> instance takes four </span><span><span class="kobospan" id="kobo.348.1">main arguments:</span></span><ul class="calibre16"><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.349.1">entity</span></strong><span class="kobospan" id="kobo.350.1">: This represents the class of the parent table that this entity has a relationship with. </span><span class="kobospan" id="kobo.350.2">In this case, </span><span><span class="kobospan" id="kobo.351.1">it’s </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.352.1">Conversation::class</span></strong></span><span><span class="kobospan" id="kobo.353.1">.</span></span></li><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.354.1">parentColumns</span></strong><span class="kobospan" id="kobo.355.1">: This specifies the column(s) in the parent entity that the foreign key references. </span><span class="kobospan" id="kobo.355.2">Here, it’s the </span><strong class="source-inline1"><span class="kobospan" id="kobo.356.1">id</span></strong><span class="kobospan" id="kobo.357.1"> field </span><span><span class="kobospan" id="kobo.358.1">of </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.359.1">Conversation</span></strong></span><span><span class="kobospan" id="kobo.360.1">.</span></span></li><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.361.1">childColumns</span></strong><span class="kobospan" id="kobo.362.1">: This specifies the column(s) in the child entity that holds the foreign key. </span><span class="kobospan" id="kobo.362.2">Here, it’s the </span><strong class="source-inline1"><span class="kobospan" id="kobo.363.1">conversation_id</span></strong><span class="kobospan" id="kobo.364.1"> field </span><span><span class="kobospan" id="kobo.365.1">in </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.366.1">Message</span></strong></span><span><span class="kobospan" id="kobo.367.1">.</span></span></li><li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.368.1">onDelete</span></strong><span class="kobospan" id="kobo.369.1">: This represents the action that will be taken if the referenced row in the parent table is deleted. </span><span class="kobospan" id="kobo.369.2">Here, </span><strong class="source-inline1"><span class="kobospan" id="kobo.370.1">ForeignKey.CASCADE</span></strong><span class="kobospan" id="kobo.371.1"> is used, which means that if a </span><strong class="source-inline1"><span class="kobospan" id="kobo.372.1">Conversation</span></strong><span class="kobospan" id="kobo.373.1"> instance is deleted, all messages that have a </span><strong class="source-inline1"><span class="kobospan" id="kobo.374.1">conversation_id</span></strong><span class="kobospan" id="kobo.375.1"> value referencing the conversation’s ID will be deleted </span><span><span class="kobospan" id="kobo.376.1">as well.</span></span></li></ul></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.377.1">indices</span></strong><span class="kobospan" id="kobo.378.1">: This is used to create an index on </span><strong class="source-inline1"><span class="kobospan" id="kobo.379.1">conversation_id</span></strong><span class="kobospan" id="kobo.380.1"> to speed up your queries. </span><span class="kobospan" id="kobo.380.2">An index makes data retrieval faster at the cost of additional disk space and slower write</span><a id="_idIndexMarker310" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.381.1"> speed. </span><span class="kobospan" id="kobo.381.2">An index is particularly useful here because we will often perform operations related to a specific conversation, and indexing </span><strong class="source-inline1"><span class="kobospan" id="kobo.382.1">conversation_id</span></strong><span class="kobospan" id="kobo.383.1"> will make these operations </span><span><span class="kobospan" id="kobo.384.1">more efficient.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.385.1">Then, we have also added annotations to the properties of </span><span><span class="kobospan" id="kobo.386.1">the class:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.387.1">@PrimaryKey</span></strong><span class="kobospan" id="kobo.388.1">: This annotation indicates that the </span><strong class="source-inline1"><span class="kobospan" id="kobo.389.1">id</span></strong><span class="kobospan" id="kobo.390.1"> field is the primary key for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.391.1">Message</span></strong><span class="kobospan" id="kobo.392.1"> table. </span><span class="kobospan" id="kobo.392.2">A primary key uniquely identifies each row in the table. </span><span class="kobospan" id="kobo.392.3">We could use here </span><strong class="source-inline1"><span class="kobospan" id="kobo.393.1">autoGenerate = true</span></strong><span class="kobospan" id="kobo.394.1">, which means that this field will be automatically filled with an incrementing integer for each </span><span><span class="kobospan" id="kobo.395.1">new row.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.396.1">@ColumnInfo(name = "column_name")</span></strong><span class="kobospan" id="kobo.397.1">: This annotation lets you specify a custom column name in the database. </span><span class="kobospan" id="kobo.397.2">If not specified, Room will use the variable name as the </span><span><span class="kobospan" id="kobo.398.1">column name.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.399.1">Now, let’s create a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.400.1">Conversation</span></strong></span><span><span class="kobospan" id="kobo.401.1"> entity:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.402.1">
@Entity(
    tableName = "conversations",
)
class Conversation(
    @PrimaryKey
    @ColumnInfo(name = "id") val id: String,
    @ColumnInfo(name = "last_message_time") val
        lastMessageTime: Long
)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.403.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.404.1">Conversation</span></strong><span class="kobospan" id="kobo.405.1"> entity is very simple – we will just store the </span><strong class="source-inline"><span class="kobospan" id="kobo.406.1">Conversation</span></strong><span class="kobospan" id="kobo.407.1"> ID and the time of the last message in </span><span><span class="kobospan" id="kobo.408.1">the conversation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.409.1">Now that we have</span><a id="_idIndexMarker311" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.410.1"> created and defined our entities, it’s time to create DAOs in order to obtain and </span><span><span class="kobospan" id="kobo.411.1">update data.</span></span></p>
<h2 id="_idParaDest-70" class="calibre7"><a id="_idTextAnchor070" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.412.1">Creating DAOs</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.413.1">A DAO is an interface that serves as a</span><a id="_idIndexMarker312" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.414.1"> communication layer</span><a id="_idIndexMarker313" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.415.1"> between the application code and the database. </span><span class="kobospan" id="kobo.415.2">It defines methods for each operation we might perform on the entities in </span><span><span class="kobospan" id="kobo.416.1">our database.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.417.1">Let’s start with the DAO for the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.418.1">Message</span></strong></span><span><span class="kobospan" id="kobo.419.1"> entity:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.420.1">
@Dao
interface MessageDao {
    @Query("SELECT * FROM messages WHERE conversation_id =
        :conversationId ORDER BY timestamp ASC")
    fun getMessagesInConversation(conversationId: Int):
        Flow&lt;List&lt;Message&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertMessage(message: Message): Long
    @Delete
    suspend fun deleteMessage(message: Message)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.421.1">Breaking down the code, we have </span><span><span class="kobospan" id="kobo.422.1">the following:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.423.1">@Dao</span></strong><span class="kobospan" id="kobo.424.1">: This annotation identifies the interface as </span><span><span class="kobospan" id="kobo.425.1">a DAO.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.426.1">@Query</span></strong><span class="kobospan" id="kobo.427.1">: This annotation is used to specify SQL statements for complex data </span><span><span class="kobospan" id="kobo.428.1">retrieval tasks.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.429.1">@Insert</span></strong><span class="kobospan" id="kobo.430.1">: This annotation is used to define a method that inserts its argument into the database. </span><strong class="source-inline1"><span class="kobospan" id="kobo.431.1">OnConflictStrategy.REPLACE</span></strong><span class="kobospan" id="kobo.432.1"> means that if a message with the same primary key</span><a id="_idIndexMarker314" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.433.1"> already exists, it will be replaced by a </span><span><span class="kobospan" id="kobo.434.1">new one.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.435.1">@Delete</span></strong><span class="kobospan" id="kobo.436.1">: This</span><a id="_idIndexMarker315" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.437.1"> annotation is used to define a method that deletes its argument from </span><span><span class="kobospan" id="kobo.438.1">the database.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.439.1">Now, let’s create a DAO for the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.440.1">Conversation</span></strong></span><span><span class="kobospan" id="kobo.441.1"> entity:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.442.1">
@Dao
interface ConversationDao {
    @Query("SELECT * FROM conversations ORDER BY
        last_message_time DESC")
    fun getAllConversations(): Flow&lt;List&lt;Conversation&gt;&gt;
    @Insert(onConflict = OnConflictStrategy.REPLACE)
    suspend fun insertConversation(conversation:
        Conversation): Long
    @Delete
    suspend fun deleteConversation(conversation:
        Conversation)
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.443.1">The annotations function the same way as they did in </span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">MessageDao</span></strong><span class="kobospan" id="kobo.445.1">. </span><span class="kobospan" id="kobo.445.2">Here, we’re retrieving all conversations ordered by the time of their last message, and we have methods for inserting and </span><span><span class="kobospan" id="kobo.446.1">deleting conversations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.447.1">We now need to provide</span><a id="_idIndexMarker316" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.448.1"> these DAOs for other app</span><a id="_idIndexMarker317" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.449.1"> components so that they can be injected. </span><span class="kobospan" id="kobo.449.2">With that in mind, we will create the </span><span><span class="kobospan" id="kobo.450.1">following module:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.451.1">
@Module
@InstallIn(SingletonComponent::class)
object DatabaseModule {
    @Provides
    @Singleton
    fun provideDatabase(@ApplicationContext appContext:
    Context): ChatAppDatabase {
        return ChatAppDatabase.getDatabase(appContext)
    }
    @Provides
    fun provideMessageDao(database: ChatAppDatabase):
    MessageDao {
        return database.messageDao()
    }
    @Provides
    fun provideConversationDao(database: ChatAppDatabase):
    ConversationDao {
        return database.conversationDao()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.452.1">As we have previously covered the creation of Hilt modules in the previous chapters, we won’t go over all the code again. </span><span class="kobospan" id="kobo.452.2">Instead, here</span><a id="_idIndexMarker318" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.453.1"> are the key parts of </span><span><span class="kobospan" id="kobo.454.1">the code:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.455.1">We are using </span><strong class="source-inline1"><span class="kobospan" id="kobo.456.1">@Singleton</span></strong><span class="kobospan" id="kobo.457.1"> to</span><a id="_idIndexMarker319" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.458.1"> indicate that only a single instance of the object should be created and provided as </span><span><span class="kobospan" id="kobo.459.1">a dependency.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.460.1">The </span><strong class="source-inline1"><span class="kobospan" id="kobo.461.1">@ApplicationContext</span></strong><span class="kobospan" id="kobo.462.1"> qualifier tells Hilt that we want to inject the </span><strong class="source-inline1"><span class="kobospan" id="kobo.463.1">Application Context </span></strong><span class="kobospan" id="kobo.464.1">into the method. </span><span class="kobospan" id="kobo.464.2">This is quite useful as, in Android, we have </span><strong class="source-inline1"><span class="kobospan" id="kobo.465.1">Application Context</span></strong><span class="kobospan" id="kobo.466.1"> and </span><strong class="source-inline1"><span class="kobospan" id="kobo.467.1">Activity Context</span></strong><span class="kobospan" id="kobo.468.1">which have different lifecycles. </span><span class="kobospan" id="kobo.468.2">Remember that a </span><strong class="source-inline1"><span class="kobospan" id="kobo.469.1">Context</span></strong><span class="kobospan" id="kobo.470.1"> in Android is an interface to global information about an application environment, offering access to resources and system services and existing in various scopes such as </span><strong class="source-inline1"><span class="kobospan" id="kobo.471.1">Application Context</span></strong><span class="kobospan" id="kobo.472.1">, which is tied to the lifecycle of the application, and </span><strong class="source-inline1"><span class="kobospan" id="kobo.473.1">Activity Context</span></strong><span class="kobospan" id="kobo.474.1">, which is associated with the lifecycle of an activity, </span><span><span class="kobospan" id="kobo.475.1">among others.</span></span><p class="calibre3"><span class="kobospan" id="kobo.476.1">If we don’t specify which </span><strong class="source-inline"><span class="kobospan" id="kobo.477.1">Context</span></strong><span class="kobospan" id="kobo.478.1"> we want to use, we can get confused or provide one that is not suitable for this situation. </span><span class="kobospan" id="kobo.478.2">Using the </span><strong class="source-inline"><span class="kobospan" id="kobo.479.1">@ApplicationContext</span></strong><span class="kobospan" id="kobo.480.1"> qualifier will assure us that the </span><strong class="source-inline"><span class="kobospan" id="kobo.481.1">Context</span></strong><span class="kobospan" id="kobo.482.1"> injected will be the expected one (the </span><strong class="source-inline"><span class="kobospan" id="kobo.483.1">Application Context</span></strong><span class="kobospan" id="kobo.484.1">, in </span><span><span class="kobospan" id="kobo.485.1">this case).</span></span></p></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.486.1">Now, as we already did in the previous chapter for the API or WebSocket, we are going to create a data source to connect with the database:  </span><span><strong class="source-inline"><span class="kobospan" id="kobo.487.1">LocalMessagesDataSource</span></strong></span><span><span class="kobospan" id="kobo.488.1">.</span></span></p>
<h2 id="_idParaDest-71" class="calibre7"><a id="_idTextAnchor071" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.489.1">Creating a LocalMessagesDataSource data source</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.490.1">We need to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.491.1">LocalMessagesDataSource</span></strong><span class="kobospan" id="kobo.492.1"> data source that will wrap the DAO and expose the specific</span><a id="_idIndexMarker320" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.493.1"> database operations our app needs. </span><span class="kobospan" id="kobo.493.2">This way, if we decide to change the database in the future, we will only have to change it here (not in the rest of consumers). </span><span class="kobospan" id="kobo.493.3">This class will serve as a DAO at a higher level of abstraction, simplifying the API for the rest of our app and making it easier to mock the database </span><span><span class="kobospan" id="kobo.494.1">in tests.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.495.1">In the following code, we are just calling the functions we already defined in </span><span><span class="kobospan" id="kobo.496.1">the DAO:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.497.1">
class MessagesLocalDataSource @Inject constructor(private
val messageDao: MessageDao) {
    fun getMessagesInConversation(conversationId: Int):
    Flow&lt;List&lt;Message&gt;&gt; {
        return
            messageDao.getMessagesInConversation(
                conversationId)
    }
    suspend fun insertMessage(message: Message): Long {
        return messageDao.insertMessage(message)
    }
    suspend fun deleteMessage(message: Message) {
        messageDao.deleteMessage(message)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.498.1">As we said before, we will use this data source to wrap the database and provide an additional </span><span><span class="kobospan" id="kobo.499.1">abstraction layer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.500.1">Now, it’s time to combine </span><a id="_idIndexMarker321" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.501.1">this local data source with the remote one. </span><span class="kobospan" id="kobo.501.2">This will force us to think about a </span><span><span class="kobospan" id="kobo.502.1">caching strategy.</span></span></p>
<h2 id="_idParaDest-72" class="calibre7"><a id="_idTextAnchor072" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.503.1">Handling two data sources in the MessagesRepository component</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.504.1">Up until now, we only had one data source (the WebSocket one), but we would like our users to be able to retrieve their messages </span><a id="_idIndexMarker322" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.505.1">even if they have no connection for a short time. </span><span class="kobospan" id="kobo.505.2">That’s the reason why we have just created a database and have it ready to </span><span><span class="kobospan" id="kobo.506.1">be populated.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.507.1">As our use case is to provide a fallback for the WebSocket so that the user can continue checking their messages, we will follow a strategy where the main source of truth will continue being the WebSocket, but we will store a copy of the messages in the app database. </span><span class="kobospan" id="kobo.507.2">Also, we don’t want the records of this database to grow infinitely, so we are setting a cap of </span><strong class="source-inline"><span class="kobospan" id="kobo.508.1">100</span></strong><span class="kobospan" id="kobo.509.1"> messages </span><span><span class="kobospan" id="kobo.510.1">per conversation.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.511.1">The component responsible for combining both data sources is </span><strong class="source-inline"><span class="kobospan" id="kobo.512.1">MessagesRepository</span></strong><span class="kobospan" id="kobo.513.1">, which we already implemented to be connected to </span><strong class="source-inline"><span class="kobospan" id="kobo.514.1">WebsocketDataSource</span></strong><span class="kobospan" id="kobo.515.1"> in the previous chapter. </span><span class="kobospan" id="kobo.515.2">Let’s now modify it to include both data sources and to orchestrate the data retrieval and </span><span><span class="kobospan" id="kobo.516.1">local storage:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.517.1">
class MessagesRepository @Inject constructor(
    private val dataSource: MessagesSocketDataSource,
    private val localDataSource: DatabaseDataSource
): IMessagesRepository {</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.518.1">Next, we will modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.519.1">getMessages()</span></strong><span class="kobospan" id="kobo.520.1"> method to include the logic to store the information retrieved from </span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">MessagesSocketDataSource</span></strong><span class="kobospan" id="kobo.522.1"> (remote data source) in </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">DatabaseDataSource</span></strong><span class="kobospan" id="kobo.524.1"> (local </span><span><span class="kobospan" id="kobo.525.1">data source):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.526.1">
override suspend fun getMessages(chatId: String, userId:
String): Flow&lt;Message&gt; {
        return flow {
            try {
                dataSource.connect().collect { message -&gt;
                    localDataSource.insertMessage(message)
                    emit(message)
                    manageDatabaseSize()
                }
            } catch (e: Exception) {
                localDataSource.getMessagesInConversation(
                chatId.toInt()).collect {
                    it.forEach { message -&gt; emit(message) }
                }
            }
        }
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.527.1">As can be seen, we have connected to the socket data source, but we have wrapped this action in a </span><strong class="source-inline"><span class="kobospan" id="kobo.528.1">try</span></strong><span class="kobospan" id="kobo.529.1">-</span><strong class="source-inline"><span class="kobospan" id="kobo.530.1">catch</span></strong><span class="kobospan" id="kobo.531.1"> block. </span><span class="kobospan" id="kobo.531.2">So, if everything goes correctly, we will store in our database every new message and then emit it in </span><span><span class="kobospan" id="kobo.532.1">the flow.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.533.1">At the same time, we call </span><strong class="source-inline"><span class="kobospan" id="kobo.534.1">manageDatabaseSize()</span></strong><span class="kobospan" id="kobo.535.1">, which will check and keep the size of the database under the limit</span><a id="_idIndexMarker323" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.536.1"> we have set (100 maximum messages per conversation). </span><span class="kobospan" id="kobo.536.2">If the socket fails, we will retrieve messages from the </span><span><span class="kobospan" id="kobo.537.1">database directly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.538.1">Now, we will also modify the </span><strong class="source-inline"><span class="kobospan" id="kobo.539.1">sendMessage</span></strong><span class="kobospan" id="kobo.540.1"> method, where we will also store every new </span><span><span class="kobospan" id="kobo.541.1">message sent:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.542.1">
    override suspend fun sendMessage(chatId: String,
    message: Message) {
        dataSource.sendMessage(message)
        localDataSource.insertMessage(message)
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.543.1">The disconnect will be kept the same as we don’t need to do anything related to the new </span><span><span class="kobospan" id="kobo.544.1">data source:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.545.1">
    override suspend fun disconnect() {
        dataSource.disconnect()
    }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.546.1">Finally, here is the mechanism that we will implement to keep the size of the database under the agreed number of</span><a id="_idIndexMarker324" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.547.1"> messages </span><span><span class="kobospan" id="kobo.548.1">per conversation:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.549.1">
    private suspend fun manageDatabaseSize() {
        val messages =
            localDataSource.getMessagesInConversation(
                chatId.toInt()).first()
        if (messages.size &gt; 100) {
            // Delete the oldest messages until we have 100
               left
            messages.sortedBy { it.timestamp
            }.take(messages.size - 100).forEach {
                localDataSource.deleteMessage(it)
            }
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.550.1">We will obtain all messages related to the conversation and check if the size is more than 100. </span><span class="kobospan" id="kobo.550.2">Then, we will order them based on their timestamp and remove the </span><span><span class="kobospan" id="kobo.551.1">oldest ones.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.552.1">Now, we have the Room database integrated into our app. </span><span class="kobospan" id="kobo.552.2">Our last messages will be available even if we lose the connection. </span><span class="kobospan" id="kobo.552.3">In the following section, let’s see how we can also send a backup of those messages to be stored in the cloud. </span><span class="kobospan" id="kobo.552.4">For that, we will use </span><span><span class="kobospan" id="kobo.553.1">Firebase Storage.</span></span></p>
<h1 id="_idParaDest-73" class="calibre5"><a id="_idTextAnchor073" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.554.1">Getting to know Firebase Storage</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.555.1">Firebase Storage</span></strong><span class="kobospan" id="kobo.556.1">, also known as Cloud Storage for Firebase, is a powerful object storage service built for Google scale. </span><span class="kobospan" id="kobo.556.2">It </span><a id="_idIndexMarker325" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.557.1">enables developers to store and retrieve user-generated content, such as photos, videos, or other</span><a id="_idIndexMarker326" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.558.1"> forms of user data. </span><span class="kobospan" id="kobo.558.2">Firebase </span><a id="_idIndexMarker327" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.559.1">Storage is backed by </span><strong class="bold"><span class="kobospan" id="kobo.560.1">Google Cloud Storage</span></strong><span class="kobospan" id="kobo.561.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.562.1">GCS</span></strong><span class="kobospan" id="kobo.563.1">), making it robust and scalable for any size of data, from small text files to large </span><span><span class="kobospan" id="kobo.564.1">video files.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.565.1">Here are some of the key features and capabilities of </span><span><span class="kobospan" id="kobo.566.1">Firebase Storage:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.567.1">User-generated content</span></strong><span class="kobospan" id="kobo.568.1">: Firebase Storage allows your users to upload their own content directly from their devices. </span><span class="kobospan" id="kobo.568.2">This could include anything from profile pictures to </span><span><span class="kobospan" id="kobo.569.1">blog posts.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.570.1">Integration with Firebase and Google Cloud</span></strong><span class="kobospan" id="kobo.571.1">: Firebase Storage integrates smoothly with the rest of the Firebase ecosystem, including Firebase Authentication and Firebase Security Rules. </span><span class="kobospan" id="kobo.571.2">It’s also a part of the larger Google Cloud ecosystem, which opens up possibilities for using Google Cloud’s advanced features, such as </span><span><span class="kobospan" id="kobo.572.1">Cloud Functions.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.573.1">Security</span></strong><span class="kobospan" id="kobo.574.1">: Firebase Storage provides robust security features. </span><span class="kobospan" id="kobo.574.2">Using Firebase Security Rules, you can control who has access to what data. </span><span class="kobospan" id="kobo.574.3">You can restrict access based on a user’s authentication state, identity, and claims, as well as data patterns </span><span><span class="kobospan" id="kobo.575.1">and metadata.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.576.1">Scalability</span></strong><span class="kobospan" id="kobo.577.1">: Firebase Storage is designed to handle a large number of uploads, downloads, and storage of data. </span><span class="kobospan" id="kobo.577.2">It automatically scales with your user base and traffic, meaning you don’t need to worry about </span><span><span class="kobospan" id="kobo.578.1">capacity planning.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.579.1">Offline capabilities</span></strong><span class="kobospan" id="kobo.580.1">: Firebase </span><strong class="bold"><span class="kobospan" id="kobo.581.1">software development kits</span></strong><span class="kobospan" id="kobo.582.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.583.1">SDKs</span></strong><span class="kobospan" id="kobo.584.1">) for Cloud Storage add Google security to file </span><a id="_idIndexMarker328" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.585.1">uploads and downloads for your Firebase apps, regardless of network quality. </span><span class="kobospan" id="kobo.585.2">You can use it to pause, resume, and </span><span><span class="kobospan" id="kobo.586.1">cancel transfers.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.587.1">Rich media</span></strong><span class="kobospan" id="kobo.588.1">: Firebase Storage supports rich media content. </span><span class="kobospan" id="kobo.588.2">This means you can use it to store images, audio, video, or even other </span><span><span class="kobospan" id="kobo.589.1">binary data.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.590.1">Strong consistency</span></strong><span class="kobospan" id="kobo.591.1">: Firebase Storage guarantees strong consistency, meaning that once an upload or download is completed, the data is immediately available from all Google Cloud Storage locations, and any subsequent reads will return the latest </span><span><span class="kobospan" id="kobo.592.1">updated data.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.593.1">In our context, a messaging </span><a id="_idIndexMarker329" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.594.1">application, Firebase Storage could be used to store and retrieve message history or backups, shared files, or even multimedia content within conversations. </span><span class="kobospan" id="kobo.594.2">This could serve as a reliable backup solution or a means of synchronizing chat history across multiple devices. </span><span class="kobospan" id="kobo.594.3">However, you need to ensure you handle privacy and security concerns, especially since chat conversations can contain </span><span><span class="kobospan" id="kobo.595.1">sensitive data.</span></span></p>
<h2 id="_idParaDest-74" class="calibre7"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.596.1">How Firebase Storage works</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.597.1">In Firebase Storage, data is stored as</span><a id="_idIndexMarker330" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.598.1"> objects within a hierarchical structure. </span><span class="kobospan" id="kobo.598.2">The full path to an object in Firebase Storage includes the project ID and the object’s location within the </span><span><span class="kobospan" id="kobo.599.1">storage bucket.</span></span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.600.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.601.1">In the context of cloud storage, a </span><strong class="bold"><span class="kobospan" id="kobo.602.1">bucket</span></strong><span class="kobospan" id="kobo.603.1"> is a basic container that holds data. </span><span class="kobospan" id="kobo.603.2">It’s the primary parent in the hierarchy</span><a id="_idIndexMarker331" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.604.1"> of data organization. </span><span class="kobospan" id="kobo.604.2">All data in cloud storage is stored in buckets. </span><span class="kobospan" id="kobo.604.3">The concept of a bucket is used by many cloud storage systems, including GCS, Amazon S3, and Firebase Storage. </span><span class="kobospan" id="kobo.604.4">These systems typically allow you to create one or more buckets in your storage space and then upload data as objects or files to these buckets. </span><span class="kobospan" id="kobo.604.5">Each bucket has a unique name within the cloud storage system, and it contains data objects, or files, each of which is identified by a key or </span><span><span class="kobospan" id="kobo.605.1">a name.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.606.1">The object’s location is defined by a path that you specify. </span><span class="kobospan" id="kobo.606.2">This path is similar to a filesystem path and includes both the directories and the filename. </span><span class="kobospan" id="kobo.606.3">For example, in the </span><strong class="source-inline"><span class="kobospan" id="kobo.607.1">images/profiles/user123.jpg</span></strong><span class="kobospan" id="kobo.608.1"> path, </span><strong class="source-inline"><span class="kobospan" id="kobo.609.1">images</span></strong><span class="kobospan" id="kobo.610.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">profiles</span></strong><span class="kobospan" id="kobo.612.1"> are directories, and </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">user123.jpg</span></strong><span class="kobospan" id="kobo.614.1"> is </span><span><span class="kobospan" id="kobo.615.1">the filename.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.616.1">When you upload a file to Firebase Storage, you create a reference to the location where you’re going to store the file. </span><span class="kobospan" id="kobo.616.2">This reference is represented by a </span><strong class="source-inline"><span class="kobospan" id="kobo.617.1">StorageReference</span></strong><span class="kobospan" id="kobo.618.1"> object, which you create by calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.619.1">child()</span></strong><span class="kobospan" id="kobo.620.1"> method on a reference to your Firebase Storage bucket and passing the path as</span><a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.621.1"> an argument, as in the </span><span><span class="kobospan" id="kobo.622.1">following example:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.623.1">
val storageRef = Firebase.storage.reference
val fileRef =
storageRef.child("images/profiles/user123.jpg")</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.624.1">Here, </span><strong class="source-inline"><span class="kobospan" id="kobo.625.1">fileRef</span></strong><span class="kobospan" id="kobo.626.1"> is a reference to the </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">user123.jpg</span></strong><span class="kobospan" id="kobo.628.1"> file in the profile’s directory within the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.629.1">images</span></strong></span><span><span class="kobospan" id="kobo.630.1"> directory.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.631.1">You can use this reference to perform various operations, such as uploading a file, downloading a file, or getting a URL to the file. </span><span class="kobospan" id="kobo.631.2">Each of these operations returns a </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">Task</span></strong><span class="kobospan" id="kobo.633.1"> object that you can use to monitor</span><a id="_idIndexMarker332" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.634.1"> the operation’s progress or get </span><span><span class="kobospan" id="kobo.635.1">its result.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.636.1">The paths in Firebase Storage are flexible, and you can structure them in a way that makes sense for your application. </span><span class="kobospan" id="kobo.636.2">For instance, in a messaging application, you might store conversation logs in a </span><strong class="source-inline"><span class="kobospan" id="kobo.637.1">chat_logs</span></strong><span class="kobospan" id="kobo.638.1"> directory, with each log’s filename being the chat’s ID. </span><span class="kobospan" id="kobo.638.2">The path to a chat log might look like </span><span><span class="kobospan" id="kobo.639.1">this: </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.640.1">chat_logs/chat123.txt</span></strong></span><span><span class="kobospan" id="kobo.641.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.642.1">Finally, it’s worth noting that Firebase Storage uses rules to control who can read and write to your storage bucket. </span><span class="kobospan" id="kobo.642.2">By default, only authenticated users can read and write data. </span><span class="kobospan" id="kobo.642.3">You can customize these rules to suit your </span><span><span class="kobospan" id="kobo.643.1">application’s needs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.644.1">Let’s start setting up Firebase Storage in </span><span><span class="kobospan" id="kobo.645.1">our project.</span></span></p>
<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.646.1">Setting up Firebase Storage</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.647.1">To start using Firebase Storage, we’ll first need to add the Cloud Storage for Firebase Android library to our app. </span><span class="kobospan" id="kobo.647.2">This can be done</span><a id="_idIndexMarker333" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.648.1"> by adding the following line to our module’s </span><span><strong class="source-inline"><span class="kobospan" id="kobo.649.1">build.gradle</span></strong></span><span><span class="kobospan" id="kobo.650.1"> file:</span></span></p>
<pre class="console"><span class="kobospan1" id="kobo.651.1">
implementation 'com.google.firebase:firebase-storage-ktx'</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.652.1">As for the chat messages, one approach would be to save the chat logs as text files in Firebase Storage. </span><span class="kobospan" id="kobo.652.2">Each conversation could have its own text file, and each message would be a line in that file. </span><span class="kobospan" id="kobo.652.3">So, we are going to create a data source to upload </span><span><span class="kobospan" id="kobo.653.1">those files:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.654.1">
class StorageDataSource @Inject constructor(private val
firebaseStorage: FirebaseStorage) {
    suspend fun uploadFile(localFile: File, remotePath:
    String) {
        val storageRef =
            firebaseStorage.reference.child(remotePath)
        storageRef.putFile(localFile.toUri()).await()
    }
    suspend fun downloadFile(remotePath: String, localFile:
    File) {
        val storageRef =
            firebaseStorage.reference.child(remotePath)
        storageRef.getFile(localFile).await()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.655.1">Here, we’ve added the Firebase storage instance as a parameter to the constructor, allowing it to be injected when</span><a id="_idIndexMarker334" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.656.1"> the class is instantiated using Hilt. </span><span class="kobospan" id="kobo.656.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.657.1">uploadFile</span></strong><span class="kobospan" id="kobo.658.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.659.1">downloadFile</span></strong><span class="kobospan" id="kobo.660.1"> methods suspend the coroutine until the upload or download operation completes, using the </span><strong class="source-inline"><span class="kobospan" id="kobo.661.1">await()</span></strong> <span><span class="kobospan" id="kobo.662.1">extension function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.663.1">To be able to use the Firebase storage instance, we would need to provide the </span><strong class="source-inline"><span class="kobospan" id="kobo.664.1">FirebaseStorage</span></strong><span class="kobospan" id="kobo.665.1"> dependency. </span><span class="kobospan" id="kobo.665.2">For that, we will need to create the following module so that Hilt is aware of how it can </span><span><span class="kobospan" id="kobo.666.1">obtain it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.667.1">
@Module
@InstallIn(SingletonComponent::class)
object StorageModule {
    @Singleton
    @Provides
    fun provideFirebaseStorage(): FirebaseStorage =
        FirebaseStorage.getInstance()
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.668.1">Now, we need to create those files, to then be uploaded using this data source. </span><span class="kobospan" id="kobo.668.2">We are going to do it in a newly created </span><span><span class="kobospan" id="kobo.669.1">repository: </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.670.1">BackupRepository</span></strong></span><span><span class="kobospan" id="kobo.671.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.672.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.673.1">BackupRepository</span></strong><span class="kobospan" id="kobo.674.1"> repository will serve as an intermediary between different data sources (such as local databases via DAOs and remote data sources such as Firebase Storage) and the rest</span><a id="_idIndexMarker335" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.675.1"> of the application. </span><span class="kobospan" id="kobo.675.2">It retrieves data from the sources, processes it if necessary, and provides it to the calling code in a </span><span><span class="kobospan" id="kobo.676.1">convenient form.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.677.1">Here is the code for </span><span><span class="kobospan" id="kobo.678.1">this repository:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.679.1">
class BackupRepository @Inject constructor(
    private val messageDao: MessageDao,
    private val conversationDao: ConversationDao,
    private val storageDataSource: StorageDataSource
) {
    private val gson = Gson()
    suspend fun backupAllConversations() {
        // Get all the conversations
        val conversations =
            conversationDao.getAllConversations()
        // Backup each conversation
        for (conversation in conversations) {
            val messages =
                messageDao.getMessagesForConversation(
                    conversation.conversationId)
            // create a JSON representation of the messages
            val messagesJson = gson.toJson(messages)
            // create a temporary file and write the JSON
               to it
            val tempFile = createTempFile("messages",
                ".json")
            tempFile.writeText(messagesJson)
            // upload the file to Firebase Storage
            val remotePath =
               "conversations/${conversation.conversationId
               }/messages.json"
            storageDataSource.uploadFile(tempFile,
               remotePath)
            // delete the local file
            tempFile.delete()
        }
    }
    private fun createTempFile(prefix: String, suffix:
    String): File {
        // specify the directory where the temporary file
           will be created
        val tempDir =
            File(System.getProperty("java.io.tmpdir"))
        // create a temporary file with the specified
           prefix and suffix
        return File.createTempFile(prefix, suffix, tempDir)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.680.1">As can be seen in the code, it uses </span><strong class="source-inline"><span class="kobospan" id="kobo.681.1">ConversationDao</span></strong><span class="kobospan" id="kobo.682.1"> to fetch all conversations in the local database. </span><span class="kobospan" id="kobo.682.2">Each conversation represents a distinct </span><span><span class="kobospan" id="kobo.683.1">chat thread.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.684.1">Then, for each conversation, it fetches the associated messages using </span><strong class="source-inline"><span class="kobospan" id="kobo.685.1">MessageDao</span></strong><span class="kobospan" id="kobo.686.1">, converts the messages to a JSON string using the Gson library, writes this JSON string to a temporary file, and then uploads the</span><a id="_idIndexMarker336" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.687.1"> file to Firebase Storage </span><span><span class="kobospan" id="kobo.688.1">through </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.689.1">StorageDataSource</span></strong></span><span><span class="kobospan" id="kobo.690.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.691.1">Once the upload to Firebase Storage is complete, it deletes the local temporary file to clean up the storage space on </span><span><span class="kobospan" id="kobo.692.1">the device.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.693.1">BackupRepository</span></strong><span class="kobospan" id="kobo.694.1"> handles all the details of data retrieval, processing, and storage. </span><span class="kobospan" id="kobo.694.2">Other parts of the application don’t need to know how the data is stored or retrieved. </span><span class="kobospan" id="kobo.694.3">They only interact with </span><strong class="source-inline"><span class="kobospan" id="kobo.695.1">BackupRepository</span></strong><span class="kobospan" id="kobo.696.1">, which provides a simple interface for these operations. </span><span class="kobospan" id="kobo.696.2">This makes the code easier to maintain, understand, </span><span><span class="kobospan" id="kobo.697.1">and test.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.698.1">Finally, we will create </span><strong class="source-inline"><span class="kobospan" id="kobo.699.1">UploadMessagesUseCase</span></strong><span class="kobospan" id="kobo.700.1">, which will be the use case or domain interactor responsible for executing the </span><span><span class="kobospan" id="kobo.701.1">upload action.</span></span></p>
<h2 id="_idParaDest-76" class="calibre7"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.702.1">Creating UploadMessagesUseCase</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.703.1">The responsibility of </span><strong class="source-inline"><span class="kobospan" id="kobo.704.1">UploadMessagesUseCase</span></strong><span class="kobospan" id="kobo.705.1"> will be to execute the backup using </span><strong class="source-inline"><span class="kobospan" id="kobo.706.1">BackupRepository</span></strong><span class="kobospan" id="kobo.707.1">. </span><span class="kobospan" id="kobo.707.2">As most of the</span><a id="_idIndexMarker337" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.708.1"> logic is already in the repository, the code will be simpler and will look </span><span><span class="kobospan" id="kobo.709.1">like this:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.710.1">
class UploadMessagesUseCase @Inject constructor(
    private val backupRepository: BackupRepository
) {
    suspend operator fun invoke() {
        backupRepository.backupAllConversations()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.711.1">Now, we are ready to retrieve and upload these backups. </span><span class="kobospan" id="kobo.711.2">As it can be a time- and resource-consuming task, the idea will be </span><a id="_idIndexMarker338" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.712.1">to do it periodically, once per week or once per day. </span><span class="kobospan" id="kobo.712.2">This is where </span><strong class="source-inline"><span class="kobospan" id="kobo.713.1">WorkManager</span></strong><span class="kobospan" id="kobo.714.1"> comes </span><span><span class="kobospan" id="kobo.715.1">in handy.</span></span></p>
<h1 id="_idParaDest-77" class="calibre5"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.716.1">Scheduling WorkManager to send backups</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.717.1">WorkManager</span></strong><span class="kobospan" id="kobo.718.1"> is a component of Android Jetpack</span><a id="_idIndexMarker339" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.719.1"> designed to manage and schedule deferrable background tasks. </span><span class="kobospan" id="kobo.719.2">It ensures these tasks run even if the app exits or the device restarts, and effectively handles retries and backoff strategies. </span><span class="kobospan" id="kobo.719.3">As it also takes care of compatibility issues, alongside upholding best practices for battery and system health, </span><strong class="source-inline"><span class="kobospan" id="kobo.720.1">WorkManager</span></strong><span class="kobospan" id="kobo.721.1"> is the recommended tool for tasks that require guaranteed and </span><span><span class="kobospan" id="kobo.722.1">efficient execution.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.723.1">WorkManager</span></strong><span class="kobospan" id="kobo.724.1"> uses an underlying job dispatching service based on the </span><span><span class="kobospan" id="kobo.725.1">following criteria:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><span class="kobospan" id="kobo.726.1">It uses </span><strong class="source-inline1"><span class="kobospan" id="kobo.727.1">JobScheduler</span></strong><span class="kobospan" id="kobo.728.1"> for devices</span><a id="_idIndexMarker340" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.729.1"> with API 23 </span><span><span class="kobospan" id="kobo.730.1">and above</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.731.1">For devices with API 14 to 22, it uses a combination of </span><strong class="source-inline1"><span class="kobospan" id="kobo.732.1">BroadcastReceiver</span></strong><span class="kobospan" id="kobo.733.1"> (for system broadcasts) </span><span><span class="kobospan" id="kobo.734.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.735.1">AlarmManager</span></strong></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.736.1">If the app includes the optional </span><strong class="source-inline1"><span class="kobospan" id="kobo.737.1">WorkManager</span></strong><span class="kobospan" id="kobo.738.1"> dependency on Firebase </span><strong class="source-inline1"><span class="kobospan" id="kobo.739.1">JobDispatcher</span></strong><span class="kobospan" id="kobo.740.1"> and Google Play services are available on the device, </span><strong class="source-inline1"><span class="kobospan" id="kobo.741.1">WorkManager</span></strong><span class="kobospan" id="kobo.742.1"> uses </span><span><span class="kobospan" id="kobo.743.1">Firebase </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.744.1">JobDispatcher</span></strong></span></li>
</ul>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.745.1">WorkManager</span></strong><span class="kobospan" id="kobo.746.1"> chooses the appropriate way to schedule a background task, depending on the device API level and included dependencies. </span><span class="kobospan" id="kobo.746.2">To use </span><strong class="source-inline"><span class="kobospan" id="kobo.747.1">WorkManager</span></strong><span class="kobospan" id="kobo.748.1">, we need first to understand how we</span><a id="_idIndexMarker341" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.749.1"> can create </span><strong class="source-inline"><span class="kobospan" id="kobo.750.1">Worker</span></strong><span class="kobospan" id="kobo.751.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.752.1">WorkRequest</span></strong></span><span><span class="kobospan" id="kobo.753.1"> instances.</span></span></p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.754.1">Introducing the Worker class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.755.1">A </span><strong class="bold"><span class="kobospan" id="kobo.756.1">Worker</span></strong><span class="kobospan" id="kobo.757.1"> is a class where</span><a id="_idIndexMarker342" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.758.1"> you define the task or</span><a id="_idIndexMarker343" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.759.1"> job that needs to be executed. </span><span class="kobospan" id="kobo.759.2">It is the core class that defines the work that needs to be performed and how to perform that work. </span><span class="kobospan" id="kobo.759.3">You extend the </span><strong class="source-inline"><span class="kobospan" id="kobo.760.1">Worker</span></strong><span class="kobospan" id="kobo.761.1"> class (or </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">CoroutineWorker</span></strong><span class="kobospan" id="kobo.763.1"> if you’re using Kotlin coroutines) and override the </span><strong class="source-inline"><span class="kobospan" id="kobo.764.1">doWork()</span></strong><span class="kobospan" id="kobo.765.1"> method to define what the task </span><span><span class="kobospan" id="kobo.766.1">should do.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.767.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.768.1">doWork()</span></strong><span class="kobospan" id="kobo.769.1"> method is where you put the </span><a id="_idIndexMarker344" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.770.1">code that needs to be executed in the background. </span><span class="kobospan" id="kobo.770.2">This is where you define the operation that needs to be performed, such as fetching data from the server, uploading a file, processing an image, and </span><span><span class="kobospan" id="kobo.771.1">so on.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.772.1">Each </span><strong class="source-inline"><span class="kobospan" id="kobo.773.1">Worker</span></strong><span class="kobospan" id="kobo.774.1"> instance is given a maximum of 10 minutes to finish its execution and return a </span><strong class="source-inline"><span class="kobospan" id="kobo.775.1">Result</span></strong><span class="kobospan" id="kobo.776.1"> instance. </span><span class="kobospan" id="kobo.776.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.777.1">Result</span></strong><span class="kobospan" id="kobo.778.1"> instance can be one of </span><span><span class="kobospan" id="kobo.779.1">three types:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.780.1">Result.success()</span></strong><span class="kobospan" id="kobo.781.1">: Indicates that the work completed successfully. </span><span class="kobospan" id="kobo.781.2">You can optionally return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.782.1">Data</span></strong><span class="kobospan" id="kobo.783.1"> object that can be used as the output data of </span><span><span class="kobospan" id="kobo.784.1">this work.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.785.1">Result.failure()</span></strong><span class="kobospan" id="kobo.786.1">: Indicates that the work failed. </span><span class="kobospan" id="kobo.786.2">You can optionally return a </span><strong class="source-inline1"><span class="kobospan" id="kobo.787.1">Data</span></strong><span class="kobospan" id="kobo.788.1"> object that can describe </span><span><span class="kobospan" id="kobo.789.1">the failure.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.790.1">Result.retry()</span></strong><span class="kobospan" id="kobo.791.1">: Indicates that the work failed and should be tried at another time according to its </span><span><span class="kobospan" id="kobo.792.1">retry policy.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.793.1">A unique feature of </span><strong class="source-inline"><span class="kobospan" id="kobo.794.1">Worker</span></strong><span class="kobospan" id="kobo.795.1"> is that it’s </span><strong class="bold"><span class="kobospan" id="kobo.796.1">lifecycle-aware</span></strong><span class="kobospan" id="kobo.797.1">. </span><span class="kobospan" id="kobo.797.2">If the task in a </span><strong class="source-inline"><span class="kobospan" id="kobo.798.1">Worker </span></strong><span class="kobospan" id="kobo.799.1">instance is running and the app goes to the background, the </span><strong class="source-inline"><span class="kobospan" id="kobo.800.1">Worker</span></strong><span class="kobospan" id="kobo.801.1"> instance can continue to run, whereas if the device restarts while the </span><strong class="source-inline"><span class="kobospan" id="kobo.802.1">Worker</span></strong><span class="kobospan" id="kobo.803.1"> instance is running, the task can resume when the device is back up. </span><span class="kobospan" id="kobo.803.2">This ensures that the work will be performed under the constraints specified when creating a </span><strong class="source-inline"><span class="kobospan" id="kobo.804.1">WorkRequest</span></strong><span class="kobospan" id="kobo.805.1"> instance, even if your app process is </span><span><span class="kobospan" id="kobo.806.1">not around.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.807.1">Here is an example of</span><a id="_idIndexMarker345" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.808.1"> a basic </span><span><strong class="source-inline"><span class="kobospan" id="kobo.809.1">Worker</span></strong></span><span><span class="kobospan" id="kobo.810.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.811.1">
class ExampleWorker(appContext: Context, workerParams:
WorkerParameters)
    : Worker(appContext, workerParams) {
    override fun doWork(): Result {
        // Code to execute in the background
        return Result.success()
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.812.1">In the example, we extend the </span><strong class="source-inline"><span class="kobospan" id="kobo.813.1">Worker</span></strong><span class="kobospan" id="kobo.814.1"> class and override the </span><strong class="source-inline"><span class="kobospan" id="kobo.815.1">doWork()</span></strong><span class="kobospan" id="kobo.816.1"> method to specify the task to be performed. </span><span class="kobospan" id="kobo.816.2">In this case, we are just returning the result as successful, but the code to do the actual work would be where the </span><strong class="source-inline"><span class="kobospan" id="kobo.817.1">// Code to execute in the background</span></strong><span class="kobospan" id="kobo.818.1"> comment </span><span><span class="kobospan" id="kobo.819.1">is placed.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.820.1">To make our </span><strong class="source-inline"><span class="kobospan" id="kobo.821.1">Worker</span></strong><span class="kobospan" id="kobo.822.1"> instances work, we need another component: </span><strong class="source-inline"><span class="kobospan" id="kobo.823.1">WorkRequest</span></strong><span class="kobospan" id="kobo.824.1">. </span><span class="kobospan" id="kobo.824.2">Let’s see how we can configure and </span><span><span class="kobospan" id="kobo.825.1">use it.</span></span></p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.826.1">Configuring the WorkRequest component</span></h2>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.827.1">WorkRequest</span></strong><span class="kobospan" id="kobo.828.1"> is the class that defines an individual unit of work. </span><span class="kobospan" id="kobo.828.2">It encapsulates your </span><strong class="source-inline"><span class="kobospan" id="kobo.829.1">Worker</span></strong><span class="kobospan" id="kobo.830.1"> class, along with any </span><a id="_idIndexMarker346" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.831.1">constraints that must be satisfied for the work to run and any input data </span><span><span class="kobospan" id="kobo.832.1">it needs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.833.1">There are two concrete implementations of </span><strong class="source-inline"><span class="kobospan" id="kobo.834.1">WorkRequest</span></strong><span class="kobospan" id="kobo.835.1"> that you </span><span><span class="kobospan" id="kobo.836.1">can use:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.837.1">OneTimeWorkRequest</span></strong><span class="kobospan" id="kobo.838.1">: As the name suggests, this represents a one-off job. </span><span class="kobospan" id="kobo.838.2">It will only be </span><span><span class="kobospan" id="kobo.839.1">executed once.</span></span></li>
<li class="calibre14"><strong class="source-inline1"><span class="kobospan" id="kobo.840.1">PeriodicWorkRequest</span></strong><span class="kobospan" id="kobo.841.1">: This is used for repeating jobs that run periodically. </span><span class="kobospan" id="kobo.841.2">The minimum repeat interval that can be defined is 15 minutes. </span><span class="kobospan" id="kobo.841.3">This constraint is discussed further in the official </span><span><span class="kobospan" id="kobo.842.1">documentation: </span></span><a href="https://developer.android.com/reference/androidx/work/PeriodicWorkRequest" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.843.1">https://developer.android.com/reference/androidx/work/PeriodicWorkRequest</span></span></a><span><span class="kobospan" id="kobo.844.1">.</span></span></li>
</ul>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.845.1">WorkRequest</span></strong><span class="kobospan" id="kobo.846.1"> has several options for setting conditions for the execution of work and for scheduling multiple pieces of work to run in a </span><span><span class="kobospan" id="kobo.847.1">particular order:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.848.1">Constraints</span></strong><span class="kobospan" id="kobo.849.1">: A </span><strong class="source-inline1"><span class="kobospan" id="kobo.850.1">WorkRequest</span></strong><span class="kobospan" id="kobo.851.1"> instance can have a </span><strong class="source-inline1"><span class="kobospan" id="kobo.852.1">Constraints</span></strong><span class="kobospan" id="kobo.853.1"> object set on it, which allows you to specify conditions that must be met for the work to be eligible to run. </span><span class="kobospan" id="kobo.853.2">For example, you might require that the device is idle or charging, or that it has a certain type of network connectivity. </span><span class="kobospan" id="kobo.853.3">We will learn about these conditions in</span><a id="_idIndexMarker347" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.854.1"> detail in a </span><span><span class="kobospan" id="kobo.855.1">few paragraphs.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.856.1">Input data</span></strong><span class="kobospan" id="kobo.857.1">: You can attach input data to a </span><strong class="source-inline1"><span class="kobospan" id="kobo.858.1">WorkRequest</span></strong><span class="kobospan" id="kobo.859.1"> instance using the </span><strong class="source-inline1"><span class="kobospan" id="kobo.860.1">setInputData()</span></strong><span class="kobospan" id="kobo.861.1"> method, providing your </span><strong class="source-inline1"><span class="kobospan" id="kobo.862.1">Worker</span></strong><span class="kobospan" id="kobo.863.1"> instance with all the information it needs to do </span><span><span class="kobospan" id="kobo.864.1">its work.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.865.1">Backoff criteria</span></strong><span class="kobospan" id="kobo.866.1">: You can set backoff criteria for the </span><strong class="source-inline1"><span class="kobospan" id="kobo.867.1">WorkRequest</span></strong><span class="kobospan" id="kobo.868.1"> instance to control retry timing when the </span><span><span class="kobospan" id="kobo.869.1">work fails.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.870.1">Tags</span></strong><span class="kobospan" id="kobo.871.1">: You can also add tags to your </span><strong class="source-inline1"><span class="kobospan" id="kobo.872.1">WorkRequest</span></strong><span class="kobospan" id="kobo.873.1"> instance, which will make it easier to track, observe, or cancel specific groups </span><span><span class="kobospan" id="kobo.874.1">of work.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.875.1">Chaining work</span></strong><span class="kobospan" id="kobo.876.1">: </span><strong class="source-inline1"><span class="kobospan" id="kobo.877.1">WorkManager</span></strong><span class="kobospan" id="kobo.878.1"> allows you to create dependent chains of work. </span><span class="kobospan" id="kobo.878.2">This means that you can ensure certain pieces of work are executed in a certain order. </span><span class="kobospan" id="kobo.878.3">You can create complex chains that run a series of </span><strong class="source-inline1"><span class="kobospan" id="kobo.879.1">WorkRequest</span></strong><span class="kobospan" id="kobo.880.1"> objects in a </span><span><span class="kobospan" id="kobo.881.1">specific order.</span></span></li>
</ul>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.882.1">WorkManager</span></strong><span class="kobospan" id="kobo.883.1"> offers several types of constraints that you can set on a </span><strong class="source-inline"><span class="kobospan" id="kobo.884.1">WorkRequest</span></strong><span class="kobospan" id="kobo.885.1"> object to specify when your task should run. </span><span class="kobospan" id="kobo.885.2">This is done using the </span><strong class="source-inline"><span class="kobospan" id="kobo.886.1">Constraints.Builder</span></strong><span class="kobospan" id="kobo.887.1"> class. </span><span class="kobospan" id="kobo.887.2">Here are the available constraints you </span><span><span class="kobospan" id="kobo.888.1">can set:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.889.1">Network type</span></strong><span class="kobospan" id="kobo.890.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.891.1">setRequiredNetworkType</span></strong><span class="kobospan" id="kobo.892.1">): This constraint specifies the type of network that must be available for the work to run. </span><span class="kobospan" id="kobo.892.2">Options include </span><strong class="source-inline1"><span class="kobospan" id="kobo.893.1">NetworkType.NOT_REQUIRED</span></strong><span class="kobospan" id="kobo.894.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.895.1">NetworkType.CONNECTED</span></strong><span class="kobospan" id="kobo.896.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.897.1">NetworkType.UNMETERED</span></strong><span class="kobospan" id="kobo.898.1">, </span><strong class="source-inline1"><span class="kobospan" id="kobo.899.1">NetworkType.NOT_ROAMING</span></strong><span class="kobospan" id="kobo.900.1">, </span><span><span class="kobospan" id="kobo.901.1">and </span></span><span><strong class="source-inline1"><span class="kobospan" id="kobo.902.1">NetworkType.METERED</span></strong></span><span><span class="kobospan" id="kobo.903.1">.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.904.1">Battery not low</span></strong><span class="kobospan" id="kobo.905.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.906.1">setRequiresBatteryNotLow</span></strong><span class="kobospan" id="kobo.907.1">): If this constraint is set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.908.1">true</span></strong><span class="kobospan" id="kobo.909.1">, the work will only run when the battery </span><span><span class="kobospan" id="kobo.910.1">isn’t low.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.911.1">Device idle</span></strong><span class="kobospan" id="kobo.912.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.913.1">setRequiresDeviceIdle</span></strong><span class="kobospan" id="kobo.914.1">): If this constraint is set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.915.1">true</span></strong><span class="kobospan" id="kobo.916.1">, the work will only run when the device is in idle mode. </span><span class="kobospan" id="kobo.916.2">This is usually when the user hasn’t interacted with the device for a period </span><span><span class="kobospan" id="kobo.917.1">of time.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.918.1">Storage not low</span></strong><span class="kobospan" id="kobo.919.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.920.1">setRequiresStorageNotLow</span></strong><span class="kobospan" id="kobo.921.1">): If set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.922.1">true</span></strong><span class="kobospan" id="kobo.923.1">, the work will only run when the storage </span><span><span class="kobospan" id="kobo.924.1">isn’t low.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.925.1">Device charging</span></strong><span class="kobospan" id="kobo.926.1"> (</span><strong class="source-inline1"><span class="kobospan" id="kobo.927.1">setRequiresCharging</span></strong><span class="kobospan" id="kobo.928.1">): If set to </span><strong class="source-inline1"><span class="kobospan" id="kobo.929.1">true</span></strong><span class="kobospan" id="kobo.930.1">, the work will only run when the device </span><span><span class="kobospan" id="kobo.931.1">is charging.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.932.1">Here is an example of how we can</span><a id="_idIndexMarker348" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.933.1"> configure a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.934.1">WorkRequest</span></strong></span><span><span class="kobospan" id="kobo.935.1"> instance:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.936.1">
val constraints = Constraints.Builder()
    .setRequiresCharging(true)
    .setRequiredNetworkType(NetworkType.CONNECTED)
    .setRequiresBatteryNotLow(true)
    .build()
val workRequest = OneTimeWorkRequestBuilder&lt;MyWorker&gt;()
    .setConstraints(constraints)
    .addTag("myWorkTag")
    .build()</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.937.1">In this example, </span><strong class="source-inline"><span class="kobospan" id="kobo.938.1">MyWorker</span></strong><span class="kobospan" id="kobo.939.1"> will only run when the device is charging, connected to a network, and the battery level is not low. </span><span class="kobospan" id="kobo.939.2">It will also have a tag, which will allow us to identify </span><span><span class="kobospan" id="kobo.940.1">it easily.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.941.1">Here is a diagram with the flow followed for the </span><strong class="source-inline"><span class="kobospan" id="kobo.942.1">Worker</span></strong><span class="kobospan" id="kobo.943.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.944.1">WorkRequest</span></strong><span class="kobospan" id="kobo.945.1"> instances to </span><span><span class="kobospan" id="kobo.946.1">be executed:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer027">
<span class="kobospan" id="kobo.947.1"><img alt="Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance" src="image/B19443_03_003.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.948.1">Figure 3.3: Diagram of WorkManager flow to execute a WorkRequest instance</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.949.1">We now have the tools to build our own </span><strong class="source-inline"><span class="kobospan" id="kobo.950.1">Worker</span></strong><span class="kobospan" id="kobo.951.1"> instance and configure the </span><strong class="source-inline"><span class="kobospan" id="kobo.952.1">WorkRequest</span></strong><span class="kobospan" id="kobo.953.1"> instance to</span><a id="_idIndexMarker349" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.954.1"> retrieve and upload the backup. </span><span class="kobospan" id="kobo.954.2">So, let’s actually </span><span><span class="kobospan" id="kobo.955.1">create them.</span></span></p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.956.1">Creating our Worker instance</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.957.1">First, to support the </span><strong class="source-inline"><span class="kobospan" id="kobo.958.1">WorkManager</span></strong><span class="kobospan" id="kobo.959.1"> API, we need to</span><a id="_idIndexMarker350" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.960.1"> include the related dependencies in </span><span><span class="kobospan" id="kobo.961.1">our code:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.962.1">
dependencies {
    implementation "androidx.work:work-runtime-ktx:$2.9.0"
    // Hilt AndroidX WorkManager integration
    implementation 'androidx.hilt:hilt-work:$2.44
    ...
</span><span class="kobospan1" id="kobo.962.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.963.1">As we have seen before, the </span><strong class="source-inline"><span class="kobospan" id="kobo.964.1">Worker</span></strong><span class="kobospan" id="kobo.965.1"> class will execute the task that can run in the background even when the app is not being used. </span><span class="kobospan" id="kobo.965.2">In other words, it’s a unit of work that can be scheduled to run under certain conditions. </span><span class="kobospan" id="kobo.965.3">In our case, we have just created the logic for that (in </span><strong class="source-inline"><span class="kobospan" id="kobo.966.1">UploadMessagesUseCase</span></strong><span class="kobospan" id="kobo.967.1">), so our </span><strong class="source-inline"><span class="kobospan" id="kobo.968.1">Worker</span></strong><span class="kobospan" id="kobo.969.1"> class will need to have access to </span><span><span class="kobospan" id="kobo.970.1">that class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.971.1">That’s the reason we will start adding </span><strong class="bold"><span class="kobospan" id="kobo.972.1">HiltWorker</span></strong><span class="kobospan" id="kobo.973.1"> annotation to our worker. </span><strong class="source-inline"><span class="kobospan" id="kobo.974.1">HiltWorker</span></strong><span class="kobospan" id="kobo.975.1"> is an annotation provided</span><a id="_idIndexMarker351" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.976.1"> by Hilt’s </span><strong class="source-inline"><span class="kobospan" id="kobo.977.1">androidx.hilt</span></strong><span class="kobospan" id="kobo.978.1"> extension library. </span><span class="kobospan" id="kobo.978.2">This annotation tells Hilt that it should create an injectable Worker instance (that is, Hilt should manage the </span><a id="_idIndexMarker352" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.979.1">dependencies of this </span><span><strong class="source-inline"><span class="kobospan" id="kobo.980.1">Worker</span></strong></span><span><span class="kobospan" id="kobo.981.1"> instance).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.982.1">Here’s the complete code for our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.983.1">Worker</span></strong></span><span><span class="kobospan" id="kobo.984.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.985.1">
@HiltWorker
class UploadMessagesWorker @AssistedInject constructor(
    @Assisted appContext: Context,
    @Assisted workerParams: WorkerParameters,
    private val uploadMessagesUseCase:
        UploadMessagesUseCase
) : CoroutineWorker(appContext, workerParams) {
    override suspend fun doWork(): Result = coroutineScope
    {
        try {
            uploadMessagesUseCase.execute()
            Result.success()
        } catch (e: Exception) {
            if (runAttemptCount &lt; MAX_RETRIES) {
                Result.retry()
            } else {
                Result.failure()
            }
        }
    }
    companion object {
        private const val MAX_RETRIES = 3
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.986.1">We are also using a new annotation: </span><strong class="source-inline"><span class="kobospan" id="kobo.987.1">AssistedInject</span></strong><span class="kobospan" id="kobo.988.1">. </span><span class="kobospan" id="kobo.988.2">Now, </span><strong class="source-inline"><span class="kobospan" id="kobo.989.1">AssistedInject</span></strong><span class="kobospan" id="kobo.990.1"> is a Dagger Hilt feature that helps with scenarios where you need to inject some dependencies but also need to provide some arguments at runtime. </span><span class="kobospan" id="kobo.990.2">Here, the </span><strong class="source-inline"><span class="kobospan" id="kobo.991.1">appContext</span></strong><span class="kobospan" id="kobo.992.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.993.1">workerParams</span></strong><span class="kobospan" id="kobo.994.1"> arguments to the constructor are provided at runtime (when the </span><strong class="source-inline"><span class="kobospan" id="kobo.995.1">Worker</span></strong><span class="kobospan" id="kobo.996.1"> instance is created by </span><strong class="source-inline"><span class="kobospan" id="kobo.997.1">WorkManager</span></strong><span class="kobospan" id="kobo.998.1">), while </span><strong class="source-inline"><span class="kobospan" id="kobo.999.1">uploadMessagesUseCase</span></strong><span class="kobospan" id="kobo.1000.1"> is a dependency that should </span><span><span class="kobospan" id="kobo.1001.1">be injected.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1002.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1003.1">doWork()</span></strong><span class="kobospan" id="kobo.1004.1"> function is where the work that this </span><strong class="source-inline"><span class="kobospan" id="kobo.1005.1">Worker</span></strong><span class="kobospan" id="kobo.1006.1"> instance should perform is defined. </span><span class="kobospan" id="kobo.1006.2">This function is a suspend function and runs within a coroutine scope. </span><span class="kobospan" id="kobo.1006.3">This means it can perform</span><a id="_idIndexMarker353" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1007.1"> long-running operations such as network requests or database operations without blocking the </span><span><span class="kobospan" id="kobo.1008.1">main thread.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1009.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.1010.1">doWork()</span></strong><span class="kobospan" id="kobo.1011.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1012.1">uploadMessagesUseCase.execute()</span></strong><span class="kobospan" id="kobo.1013.1"> is called to perform the actual work of uploading messages. </span><span class="kobospan" id="kobo.1013.2">If this operation is successful, </span><strong class="source-inline"><span class="kobospan" id="kobo.1014.1">Result.success()</span></strong><span class="kobospan" id="kobo.1015.1"> is returned. </span><span class="kobospan" id="kobo.1015.2">If an </span><strong class="source-inline"><span class="kobospan" id="kobo.1016.1">Exception</span></strong><span class="kobospan" id="kobo.1017.1"> error is thrown, </span><strong class="source-inline"><span class="kobospan" id="kobo.1018.1">Result.retry()</span></strong><span class="kobospan" id="kobo.1019.1"> is returned if </span><strong class="source-inline"><span class="kobospan" id="kobo.1020.1">runAttemptCount</span></strong><span class="kobospan" id="kobo.1021.1"> is less than </span><strong class="source-inline"><span class="kobospan" id="kobo.1022.1">MAX_RETRIES</span></strong><span class="kobospan" id="kobo.1023.1">, which means the work should be retried. </span><span class="kobospan" id="kobo.1023.2">If </span><strong class="source-inline"><span class="kobospan" id="kobo.1024.1">runAttemptCount</span></strong><span class="kobospan" id="kobo.1025.1"> equals or exceeds </span><strong class="source-inline"><span class="kobospan" id="kobo.1026.1">MAX_RETRIES</span></strong><span class="kobospan" id="kobo.1027.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.1028.1">Result.failure()</span></strong><span class="kobospan" id="kobo.1029.1"> is returned, which means the work should not </span><span><span class="kobospan" id="kobo.1030.1">be retried.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1031.1">As we want it to only retry three times, we are using </span><strong class="source-inline"><span class="kobospan" id="kobo.1032.1">runAttemptCount</span></strong><span class="kobospan" id="kobo.1033.1">, which is a property provided by </span><strong class="source-inline"><span class="kobospan" id="kobo.1034.1">ListenableWorker</span></strong><span class="kobospan" id="kobo.1035.1"> (the superclass of </span><strong class="source-inline"><span class="kobospan" id="kobo.1036.1">CoroutineWorker</span></strong><span class="kobospan" id="kobo.1037.1">) that keeps track of how many times the work has </span><span><span class="kobospan" id="kobo.1038.1">been attempted.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1039.1">Finally, </span><strong class="source-inline"><span class="kobospan" id="kobo.1040.1">MAX_RETRIES</span></strong><span class="kobospan" id="kobo.1041.1"> is a constant that defines the maximum number of retries. </span><span class="kobospan" id="kobo.1041.2">It is set to </span><strong class="source-inline"><span class="kobospan" id="kobo.1042.1">3</span></strong><span class="kobospan" id="kobo.1043.1"> in </span><span><span class="kobospan" id="kobo.1044.1">this example.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1045.1">To summarize, this </span><strong class="source-inline"><span class="kobospan" id="kobo.1046.1">Worker</span></strong><span class="kobospan" id="kobo.1047.1"> instance uploads messages by calling </span><strong class="source-inline"><span class="kobospan" id="kobo.1048.1">uploadMessagesUseCase.execute()</span></strong><span class="kobospan" id="kobo.1049.1">, and it can retry the operation up to three times in case of failure. </span><span class="kobospan" id="kobo.1049.2">The actual dependencies of this </span><strong class="source-inline"><span class="kobospan" id="kobo.1050.1">Worker</span></strong><span class="kobospan" id="kobo.1051.1"> instance (</span><strong class="source-inline"><span class="kobospan" id="kobo.1052.1">UploadMessagesUseCase</span></strong><span class="kobospan" id="kobo.1053.1">) are provided </span><a id="_idIndexMarker354" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1054.1">via </span><strong class="bold"><span class="kobospan" id="kobo.1055.1">dependency injection</span></strong><span class="kobospan" id="kobo.1056.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1057.1">DI</span></strong><span class="kobospan" id="kobo.1058.1">) using Dagger Hilt. </span><span class="kobospan" id="kobo.1058.2">Now, we need to set </span><a id="_idIndexMarker355" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1059.1">up the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1060.1">WorkRequest</span></strong></span><span><span class="kobospan" id="kobo.1061.1"> class.</span></span></p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1062.1">Setting up the WorkRequest class</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1063.1">In the case of the </span><strong class="source-inline"><span class="kobospan" id="kobo.1064.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1065.1"> class, we will have to think about how frequently we want our messages to be backed up; for example, we can do a backup once per week. </span><span class="kobospan" id="kobo.1065.2">Also, we are going to </span><a id="_idIndexMarker356" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1066.1">configure the </span><strong class="source-inline"><span class="kobospan" id="kobo.1067.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1068.1"> class to be only called when the user has a Wi-Fi connection. </span><span class="kobospan" id="kobo.1068.2">Here is how we </span><span><span class="kobospan" id="kobo.1069.1">do it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1070.1">
val constraints = Constraints.Builder()
    .setRequiredNetworkType(NetworkType.UNMETERED)
    .build()
val uploadMessagesRequest =
PeriodicWorkRequestBuilder&lt;UploadMessagesWorker&gt;(7,
TimeUnit.DAYS)
    .setConstraints(constraints)
    .setBackoffCriteria(BackoffPolicy.LINEAR,
        PeriodicWorkRequest.MIN_PERIODIC_INTERVAL_MILLIS,
        TimeUnit.MILLISECONDS)
    .build()
WorkManager.getInstance(this).enqueue(
    uploadMessagesRequest)</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1071.1">We use </span><strong class="source-inline"><span class="kobospan" id="kobo.1072.1">PeriodicWorkRequestBuilder</span></strong><span class="kobospan" id="kobo.1073.1"> to create a </span><strong class="source-inline"><span class="kobospan" id="kobo.1074.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1075.1"> instance that runs </span><strong class="source-inline"><span class="kobospan" id="kobo.1076.1">UploadMessagesWorker</span></strong><span class="kobospan" id="kobo.1077.1"> once every week. </span><span class="kobospan" id="kobo.1077.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1078.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1079.1"> instance has a constraint that requires an unmetered network connection (Wi-Fi). </span><span class="kobospan" id="kobo.1079.2">It also specifies a linear backoff policy for retries – this means that each retry attempt is delayed by a fixed amount of time, increasing linearly with each </span><span><span class="kobospan" id="kobo.1080.1">subsequent retry.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1081.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1082.1">enqueue()</span></strong><span class="kobospan" id="kobo.1083.1"> method schedules the </span><strong class="source-inline"><span class="kobospan" id="kobo.1084.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1085.1"> instance to run. </span><span class="kobospan" id="kobo.1085.2">If the constraints are met and there’s no</span><a id="_idIndexMarker357" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1086.1"> other work ahead of it in the queue, it will start running immediately. </span><span class="kobospan" id="kobo.1086.2">Otherwise, it will wait until the constraints are met and it’s the </span><strong class="source-inline"><span class="kobospan" id="kobo.1087.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1088.1"> instance’s turn in </span><span><span class="kobospan" id="kobo.1089.1">the queue.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1090.1">Please note that due to OS restrictions, a </span><strong class="source-inline"><span class="kobospan" id="kobo.1091.1">PeriodicWorkRequest</span></strong><span class="kobospan" id="kobo.1092.1"> instance may not run exactly when the period elapses; it may have some delay, but it will run at least once within that </span><span><span class="kobospan" id="kobo.1093.1">time period.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1094.1">We can call this code and enqueue the </span><strong class="source-inline"><span class="kobospan" id="kobo.1095.1">WorkRequest</span></strong><span class="kobospan" id="kobo.1096.1"> instance from any place in our app, but to ensure it gets scheduled, the most convenient place is when we start up the app, in the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1097.1">WhatsPacktApplication.onCreate</span></strong></span><span><span class="kobospan" id="kobo.1098.1"> method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1099.1">
@HiltAndroidApp
class WhatsPacktApp: Application() {
    override fun onCreate() {
        super.onCreate()
        //Include WorkRequest initialization here
}
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1100.1">With all this, we would have our app ready to periodically back up messages, and our work well could have finished here. </span><span class="kobospan" id="kobo.1100.2">However, to explore a different approach, let’s see what happens if we need to integrate another storage provider – for example, </span><span><span class="kobospan" id="kobo.1101.1">Amazon S3.</span></span></p>
<h1 id="_idParaDest-82" class="calibre5"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1102.1">Using Amazon S3 for storage</span></h1>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1103.1">Amazon S3</span></strong><span class="kobospan" id="kobo.1104.1"> is a scalable, high-speed, web-based cloud storage service designed for online backup and archiving of data and applications on </span><strong class="bold"><span class="kobospan" id="kobo.1105.1">Amazon Web Services </span></strong><span class="kobospan" id="kobo.1106.1">(</span><strong class="bold"><span class="kobospan" id="kobo.1107.1">AWS</span></strong><span class="kobospan" id="kobo.1108.1">). </span><span class="kobospan" id="kobo.1108.2">It’s a well-known alternative to</span><a id="_idIndexMarker358" class="calibre6 pcalibre1 pcalibre"/> <span><span class="kobospan" id="kobo.1109.1">Firebase Storage.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1110.1">Here’s a brief overview of some key features and capabilities of </span><span><span class="kobospan" id="kobo.1111.1">Amazon S3:</span></span></p>
<ul class="calibre15">
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1112.1">Storage</span></strong><span class="kobospan" id="kobo.1113.1">: Amazon S3 can store any amount of data and access it from anywhere on the web. </span><span class="kobospan" id="kobo.1113.2">It provides virtually </span><span><span class="kobospan" id="kobo.1114.1">limitless storage.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1115.1">Durability and availability</span></strong><span class="kobospan" id="kobo.1116.1">: Amazon </span><a id="_idIndexMarker359" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1117.1">S3 is designed for 99.999999999% (11 9s) of durability, and it stores redundant copies of data across multiple geographically separated data centers. </span><span class="kobospan" id="kobo.1117.2">It also provides 99.99% availability of objects over a </span><span><span class="kobospan" id="kobo.1118.1">given year.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1119.1">Security</span></strong><span class="kobospan" id="kobo.1120.1">: Amazon S3 provides advanced security features such as encryption for data at rest and in transit, and </span><a id="_idIndexMarker360" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1121.1">fine-grained access controls to resources using AWS </span><strong class="bold"><span class="kobospan" id="kobo.1122.1">Identity and Access Management </span></strong><span class="kobospan" id="kobo.1123.1">(</span><strong class="bold"><span class="kobospan" id="kobo.1124.1">IAM</span></strong><span class="kobospan" id="kobo.1125.1">), </span><strong class="bold"><span class="kobospan" id="kobo.1126.1">access control lists</span></strong><span class="kobospan" id="kobo.1127.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1128.1">ACLs</span></strong><span class="kobospan" id="kobo.1129.1">), and </span><span><span class="kobospan" id="kobo.1130.1">bucket</span></span><span><a id="_idIndexMarker361" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.1131.1"> policies.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1132.1">Scalability</span></strong><span class="kobospan" id="kobo.1133.1">: Amazon S3 is designed to scale storage, requests, and users to support an unlimited number of </span><span><span class="kobospan" id="kobo.1134.1">web-scale applications.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1135.1">Performance</span></strong><span class="kobospan" id="kobo.1136.1">: AWS storage makes sure that when you add or delete files, you can immediately read the latest version of your files. </span><span class="kobospan" id="kobo.1136.2">If you overwrite a file or delete it, there might be a short delay before these changes are fully </span><span><span class="kobospan" id="kobo.1137.1">updated everywhere.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1138.1">Integration</span></strong><span class="kobospan" id="kobo.1139.1">: Amazon S3 integrates well with other AWS services, such as AWS CloudTrail for logging and monitoring, Amazon CloudFront for content delivery, AWS Lambda for serverless compute, and </span><span><span class="kobospan" id="kobo.1140.1">many more.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1141.1">Management features</span></strong><span class="kobospan" id="kobo.1142.1">: S3 provides functionalities for management tasks such as organizing data and configuring finely-tuned access controls to meet specific business, organizational, and </span><span><span class="kobospan" id="kobo.1143.1">compliance requirements.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1144.1">Data transfer</span></strong><span class="kobospan" id="kobo.1145.1">: S3 Transfer Acceleration enables fast, easy, and secure transfers of files over long distances between your client and your Amazon </span><span><span class="kobospan" id="kobo.1146.1">S3 bucket.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1147.1">Storage classes</span></strong><span class="kobospan" id="kobo.1148.1">: Amazon S3 provides several storage classes for different types of data storage needs, such as S3 Standard for general-purpose storage of frequently accessed data, S3 Intelligent-Tiering for data with unknown or changing access patterns, S3</span><a id="_idIndexMarker362" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1149.1"> Standard-IA for long-lived but infrequently accessed data, and S3 Glacier for long-term archive and </span><span><span class="kobospan" id="kobo.1150.1">digital preservation.</span></span></li>
<li class="calibre14"><strong class="bold"><span class="kobospan" id="kobo.1151.1">Query-in-place functionality</span></strong><span class="kobospan" id="kobo.1152.1">: S3 Select enables applications to retrieve only a subset of data from an object by using simple </span><span><span class="kobospan" id="kobo.1153.1">SQL expressions.</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.1154.1">These features make Amazon S3 a robust and versatile choice for various use cases, ranging from web applications to backup and restore, archive, enterprise applications, IoT devices, and big </span><span><span class="kobospan" id="kobo.1155.1">data analytics.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1156.1">To implement our storage solution based on Amazon S3, we first need to integrate the AWS SDK into </span><span><span class="kobospan" id="kobo.1157.1">our app.</span></span></p>
<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1158.1">Integrating the AWS S3 SDK</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1159.1">We can</span><a id="_idIndexMarker363" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1160.1"> integrate the AWS S3 SDK into our Android project by adding the following dependencies in our </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1161.1">build.gradle</span></strong></span><span><span class="kobospan" id="kobo.1162.1"> file:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1163.1">
implementation 'com.amazonaws:aws-android-sdk-s3:
$latest_version'
implementation 'com.amazonaws:aws-android-sdk-
cognitoidentityprovider:$latest_version'</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1164.1">We have added here dependencies for the AWS SDK and the dependency needed to use </span><span><span class="kobospan" id="kobo.1165.1">Amazon Cognito.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1166.1">We’ll also need to provide our AWS credentials (access key ID and secret access key) to the SDK. </span><span class="kobospan" id="kobo.1166.2">For mobile applications, it is recommended to use Amazon Cognito for </span><span><span class="kobospan" id="kobo.1167.1">credential management.</span></span></p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1168.1">Setting up Amazon Cognito</span></h2>
<p class="calibre3"><strong class="bold"><span class="kobospan" id="kobo.1169.1">Amazon Cognito</span></strong><span class="kobospan" id="kobo.1170.1"> is a service that provides </span><a id="_idIndexMarker364" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1171.1">user sign-up and sign-in services, as well as access control for mobile and web applications. </span><span class="kobospan" id="kobo.1171.2">When you use Amazon Cognito for your user pool, you have the option to secure your data in AWS services (such as</span><a id="_idIndexMarker365" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1172.1"> Amazon S3 for file storage) without having to embed AWS keys in your application code, which is a significant </span><span><span class="kobospan" id="kobo.1173.1">security risk.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1174.1">Here are the instructions to set up Amazon Cognito in our </span><span><span class="kobospan" id="kobo.1175.1">Android application:</span></span></p>
<ol class="calibre13">
<li class="calibre14"><span class="kobospan" id="kobo.1176.1">First, go to the Amazon Cognito </span><span><span class="kobospan" id="kobo.1177.1">console: </span></span><a href="https://console.aws.amazon.com/cognito/home" class="calibre6 pcalibre1 pcalibre"><span><span class="kobospan" id="kobo.1178.1">https://console.aws.amazon.com/cognito/home</span></span></a><span><span class="kobospan" id="kobo.1179.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1180.1">From there, click </span><strong class="bold"><span class="kobospan" id="kobo.1181.1">Identity Pools</span></strong><span class="kobospan" id="kobo.1182.1">, then </span><strong class="bold"><span class="kobospan" id="kobo.1183.1">Create new </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1184.1">identity pool</span></strong></span><span><span class="kobospan" id="kobo.1185.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1186.1">Check </span><strong class="bold"><span class="kobospan" id="kobo.1187.1">Guest Access</span></strong><span class="kobospan" id="kobo.1188.1"> under the </span><strong class="bold"><span class="kobospan" id="kobo.1189.1">Authentication</span></strong><span class="kobospan" id="kobo.1190.1"> section, and </span><span><span class="kobospan" id="kobo.1191.1">click </span></span><span><strong class="bold"><span class="kobospan" id="kobo.1192.1">Next</span></strong></span><span><span class="kobospan" id="kobo.1193.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1194.1">Select </span><strong class="bold"><span class="kobospan" id="kobo.1195.1">Create a New IAM Role</span></strong><span class="kobospan" id="kobo.1196.1">, create a name for it, and </span><span><span class="kobospan" id="kobo.1197.1">click </span></span><span><strong class="bold"><span class="kobospan" id="kobo.1198.1">Next</span></strong></span><span><span class="kobospan" id="kobo.1199.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1200.1">Then create a new </span><a id="_idIndexMarker366" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1201.1">name for the identity pool and </span><span><span class="kobospan" id="kobo.1202.1">click </span></span><span><strong class="bold"><span class="kobospan" id="kobo.1203.1">Next</span></strong></span><span><span class="kobospan" id="kobo.1204.1">.</span></span></li>
<li class="calibre14"><span class="kobospan" id="kobo.1205.1">Review the summary (as in </span><span><em class="italic"><span class="kobospan" id="kobo.1206.1">Figure 3</span></em></span><em class="italic"><span class="kobospan" id="kobo.1207.1">.4</span></em><span class="kobospan" id="kobo.1208.1">), then click </span><strong class="bold"><span class="kobospan" id="kobo.1209.1">Create </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.1210.1">identity pool</span></strong></span><span><span class="kobospan" id="kobo.1211.1">:</span></span></li>
</ol>
<div class="calibre2">
<div class="img---figure" id="_idContainer028">
<span class="kobospan" id="kobo.1212.1"><img alt="Figure 3.4: New identity pool configuration" src="image/B19443_03_004.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1213.1">Figure 3.4: New identity pool configuration</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.1214.1">Note</span></p>
<p class="callout"><span class="kobospan" id="kobo.1215.1">Here, we are enabling access to unauthenticated </span><a id="_idIndexMarker367" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1216.1">identities. </span><span class="kobospan" id="kobo.1216.2">You</span><a id="_idIndexMarker368" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1217.1"> also have the option to give access only to authenticated identities, but note that you will have to create every user in Amazon Cognito. </span><span class="kobospan" id="kobo.1217.2">Nevertheless, this approach is more secure than using the S3 SDK to store keys in our </span><span><span class="kobospan" id="kobo.1218.1">app code.</span></span></p>
<ol class="calibre13">
<li value="7" class="calibre14"><span class="kobospan" id="kobo.1219.1">Next, in our app, we’ll need to obtain the AWS credentials provider. </span><span class="kobospan" id="kobo.1219.2">For that, we will initialize </span><strong class="source-inline1"><span class="kobospan" id="kobo.1220.1">CognitoCachingCredentialsProvider</span></strong><span class="kobospan" id="kobo.1221.1"> with our </span><strong class="source-inline1"><span class="kobospan" id="kobo.1222.1">IdentityPoolId</span></strong><span class="kobospan" id="kobo.1223.1"> class, in the region we </span><span><span class="kobospan" id="kobo.1224.1">configured it:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1225.1">
val credentialsProvider =
CognitoCachingCredentialsProvider(
    applicationContext,
    "IdentityPoolId", // Identity Pool ID
    Regions.US_EAST_1 // Region
)</span></pre></li> <li class="calibre14"><span class="kobospan" id="kobo.1226.1">Now, we can use the </span><a id="_idIndexMarker369" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1227.1">credentials provider instance while creating a client for the AWS service. </span><span class="kobospan" id="kobo.1227.2">For example, to use it with Amazon S3, use </span><span><span class="kobospan" id="kobo.1228.1">this code:</span></span><pre class="source-code"><span class="kobospan1" id="kobo.1229.1">
val s3 = AmazonS3Client(credentialsProvider)</span></pre></li> </ol>
<p class="calibre3"><span class="kobospan" id="kobo.1230.1">Now, it is time to create a </span><a id="_idIndexMarker370" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1231.1">new </span><span><span class="kobospan" id="kobo.1232.1">storage provider.</span></span></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1233.1">Creating an AWS S3 Storage provider and integrating it into our code</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.1234.1">Now, we need to do the same thing we did for Firebase Storage but with the AWS SDK: create a provider. </span><span class="kobospan" id="kobo.1234.2">This provider </span><a id="_idIndexMarker371" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1235.1">will be </span><strong class="source-inline"><span class="kobospan" id="kobo.1236.1">AWSS3Provider</span></strong><span class="kobospan" id="kobo.1237.1"> and will be </span><a id="_idIndexMarker372" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1238.1">used to handle the upload of files to AWS S3. </span><span class="kobospan" id="kobo.1238.2">It will take a </span><strong class="source-inline"><span class="kobospan" id="kobo.1239.1">Context</span></strong><span class="kobospan" id="kobo.1240.1"> object and a </span><strong class="source-inline"><span class="kobospan" id="kobo.1241.1">CognitoCachingCredentialsProvider</span></strong><span class="kobospan" id="kobo.1242.1"> object as </span><span><span class="kobospan" id="kobo.1243.1">constructor parameters.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1244.1">This is how we can </span><span><span class="kobospan" id="kobo.1245.1">implement it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1246.1">
class AWSS3Provider(
    private val context: Context,
    private val credentialsProvider:
        CognitoCachingCredentialsProvider
) {
    suspend fun uploadFile(bucketName: String, objectKey:
    String, filePath: String) {
        withContext(Dispatchers.IO) {
            val transferUtility = TransferUtility.builder()
                .context(context)
                .awsConfiguration(AWSMobileClient
                    .getInstance().configuration)
                .s3Client(AmazonS3Client(
                    credentialsProvider))
                .build()
            val uploadObserver = transferUtility.upload(
                bucketName,
                objectKey,
                File(filePath)
            )
            uploadObserver.setTransferListener(object :
            TransferListener {
                override fun onStateChanged(id: Int, state:
                TransferState) {
                    if (TransferState.COMPLETED == state) {
                        // The file has been uploaded
                           successfully
                    }
                }
                override fun onProgressChanged(id: Int,
                bytesCurrent: Long, bytesTotal: Long) {
                    val progress = (bytesCurrent.toDouble()
                        / bytesTotal.toDouble() * 100.0)
                    Log.d("Upload Progress", "$progress%")
                }
                override fun onError(id: Int, ex:
                Exception) {
                    throw ex
                }
            })
        }
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1247.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1248.1">uploadFile</span></strong><span class="kobospan" id="kobo.1249.1"> function is a suspending function, meaning it can be called from any coroutine scope. </span><span class="kobospan" id="kobo.1249.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1250.1">withContext(Dispatchers.IO)</span></strong><span class="kobospan" id="kobo.1251.1"> function is used to switch the coroutine context to the I/O </span><a id="_idIndexMarker373" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1252.1">dispatcher, which is optimized</span><a id="_idIndexMarker374" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1253.1"> for I/O-related tasks, such as network calls or </span><span><span class="kobospan" id="kobo.1254.1">disk operations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1255.1">Let’s delve into the </span><strong class="source-inline"><span class="kobospan" id="kobo.1256.1">uploadFile</span></strong><span class="kobospan" id="kobo.1257.1"> function, which is the core of </span><span><span class="kobospan" id="kobo.1258.1">this class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1259.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1260.1">TransferUtility</span></strong><span class="kobospan" id="kobo.1261.1"> class simplifies the process of uploading and downloading files to/from Amazon S3. </span><span class="kobospan" id="kobo.1261.2">Here, we’re building a </span><strong class="source-inline"><span class="kobospan" id="kobo.1262.1">TransferUtility</span></strong><span class="kobospan" id="kobo.1263.1"> instance, providing it with the Android context, AWS configuration, and an </span><strong class="source-inline"><span class="kobospan" id="kobo.1264.1">AmazonS3Client</span></strong><span class="kobospan" id="kobo.1265.1"> instance initialized with the provided </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1266.1">CognitoCachingCredentialsProvider</span></strong></span><span><span class="kobospan" id="kobo.1267.1"> class.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1268.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1269.1">transferUtility.upload()</span></strong><span class="kobospan" id="kobo.1270.1"> method is used to upload a file to the specified bucket in S3. </span><span class="kobospan" id="kobo.1270.2">We provide the name of the bucket (</span><strong class="source-inline"><span class="kobospan" id="kobo.1271.1">bucketName</span></strong><span class="kobospan" id="kobo.1272.1">), the key under which to store the new object (</span><strong class="source-inline"><span class="kobospan" id="kobo.1273.1">objectKey</span></strong><span class="kobospan" id="kobo.1274.1">), and the file we want to upload (</span><strong class="source-inline"><span class="kobospan" id="kobo.1275.1">File(filePath)</span></strong><span class="kobospan" id="kobo.1276.1">). </span><span class="kobospan" id="kobo.1276.2">This function returns a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1277.1">UploadObserver</span></strong></span><span><span class="kobospan" id="kobo.1278.1"> instance.</span></span></p>
<p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.1279.1">UploadObserver</span></strong><span class="kobospan" id="kobo.1280.1"> is used to monitor the progress of </span><span><span class="kobospan" id="kobo.1281.1">the upload.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1282.1">We attach</span><strong class="source-inline"><span class="kobospan" id="kobo.1283.1">TransferListener</span></strong><span class="kobospan" id="kobo.1284.1"> to the</span><a id="_idIndexMarker375" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1285.1"> observer to get callbacks when the upload state changes, the upload makes </span><a id="_idIndexMarker376" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1286.1">progress, or an </span><span><span class="kobospan" id="kobo.1287.1">error occurs.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1288.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1289.1">onStateChanged()</span></strong><span class="kobospan" id="kobo.1290.1"> method is called when the state of the transfer changes. </span><span class="kobospan" id="kobo.1290.2">If the state is </span><strong class="source-inline"><span class="kobospan" id="kobo.1291.1">TransferState.COMPLETED</span></strong><span class="kobospan" id="kobo.1292.1">, it means the file has been </span><span><span class="kobospan" id="kobo.1293.1">uploaded successfully.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1294.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1295.1">onProgressChanged()</span></strong><span class="kobospan" id="kobo.1296.1"> method is called when more bytes have been transferred. </span><span class="kobospan" id="kobo.1296.2">Here, we calculate the progress as a percentage and </span><span><span class="kobospan" id="kobo.1297.1">log it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1298.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1299.1">onError()</span></strong><span class="kobospan" id="kobo.1300.1"> method is called if an error occurs during the transfer. </span><span class="kobospan" id="kobo.1300.2">We will throw an error when it happens, to be handled by the consumers or </span><span><span class="kobospan" id="kobo.1301.1">this provider.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1302.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.1303.1">uploadFile</span></strong><span class="kobospan" id="kobo.1304.1"> function is called from within a coroutine, and since the actual upload operation is a network I/O operation, it’s wrapped in </span><strong class="source-inline"><span class="kobospan" id="kobo.1305.1">withContext(Dispatchers.IO)</span></strong><span class="kobospan" id="kobo.1306.1">. </span><span class="kobospan" id="kobo.1306.2">This ensures the operation doesn’t block the main thread, as the I/O dispatcher uses a separate thread pool that’s optimized for disk and </span><span><span class="kobospan" id="kobo.1307.1">network I/O.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1308.1">Now, we will need to create a data source to connect our </span><strong class="source-inline"><span class="kobospan" id="kobo.1309.1">BackupRepository</span></strong><span class="kobospan" id="kobo.1310.1"> instance to this new provider. </span><span class="kobospan" id="kobo.1310.2">The best way to do it is by implementing </span><strong class="source-inline"><span class="kobospan" id="kobo.1311.1">IStorageDataSource,</span></strong><span class="kobospan" id="kobo.1312.1"> a common interface for both data sources. </span><span class="kobospan" id="kobo.1312.2">This way, you’re able to swap the underlying implementation (Firebase Storage, AWS S3, and so on) without changing the rest of your code. </span><span class="kobospan" id="kobo.1312.3">(This is an application of the </span><strong class="bold"><span class="kobospan" id="kobo.1313.1">Dependency Inversion Principle</span></strong><span class="kobospan" id="kobo.1314.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1315.1">DIP</span></strong><span class="kobospan" id="kobo.1316.1">), one of the SOLID</span><a id="_idIndexMarker377" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1317.1"> principles of </span><strong class="bold"><span class="kobospan" id="kobo.1318.1">object-oriented</span></strong><span class="kobospan" id="kobo.1319.1"> (</span><strong class="bold"><span class="kobospan" id="kobo.1320.1">OO</span></strong><span class="kobospan" id="kobo.1321.1">) design, which helps make your code more flexible and easier </span><span><span class="kobospan" id="kobo.1322.1">to</span></span><span><a id="_idIndexMarker378" class="calibre6 pcalibre1 pcalibre"/></span><span><span class="kobospan" id="kobo.1323.1"> maintain.)</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1324.1">This is how we will </span><span><span class="kobospan" id="kobo.1325.1">implement </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1326.1">S3StorageDataSource</span></strong></span><span><span class="kobospan" id="kobo.1327.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1328.1">
class S3StorageDataSource @Inject constructor(
    private val awsS3Provider: AWSS3Provider
) : IStorageDataSource {
    override suspend fun uploadFile(remotePath: String,
    file: File) {
        awsS3Provider.uploadFile(BUCKET_NAME, remotePath,
        file.absolutePath)
    }
    companion object {
        private const val BUCKET_NAME = "our-bucket-name"
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1329.1">In this code, we are implementing the </span><strong class="source-inline"><span class="kobospan" id="kobo.1330.1">uploadFile</span></strong><span class="kobospan" id="kobo.1331.1"> function calling the </span><strong class="source-inline"><span class="kobospan" id="kobo.1332.1">awsProvider.uploadFile</span></strong><span class="kobospan" id="kobo.1333.1"> function, which</span><a id="_idIndexMarker379" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1334.1"> will upload the file to the bucket with the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1335.1">our-bucket-name</span></strong></span><span><span class="kobospan" id="kobo.1336.1"> name.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1337.1">This new </span><strong class="source-inline"><span class="kobospan" id="kobo.1338.1">S3StorageDataSource</span></strong><span class="kobospan" id="kobo.1339.1"> class can </span><a id="_idIndexMarker380" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1340.1">be provided via Hilt in a similar way to the previous </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1341.1">FirebaseStorageDataSource</span></strong></span><span><span class="kobospan" id="kobo.1342.1"> class:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1343.1">
@Module
@InstallIn(SingletonComponent::class)
object StorageModule {
    @Provides
    @Singleton
    fun provideStorageDataSource(awsS3Provider:
    AWSS3Provider): IStorageDataSource {
        return S3StorageDataSource(awsS3Provider)
    }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1344.1">Here, we create a </span><strong class="source-inline"><span class="kobospan" id="kobo.1345.1">@Module</span></strong><span class="kobospan" id="kobo.1346.1"> annotation that includes a </span><strong class="source-inline"><span class="kobospan" id="kobo.1347.1">@Provides</span></strong><span class="kobospan" id="kobo.1348.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.1349.1">@Binds</span></strong><span class="kobospan" id="kobo.1350.1"> method for </span><strong class="source-inline"><span class="kobospan" id="kobo.1351.1">IStorageDataSource</span></strong><span class="kobospan" id="kobo.1352.1">, and Hilt will take care of injecting the right implementation based on your configuration. </span><span class="kobospan" id="kobo.1352.2">If </span><a id="_idIndexMarker381" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1353.1">you want to switch from Firebase Storage to AWS S3, you’d modify</span><a id="_idIndexMarker382" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1354.1"> this module to provide </span><strong class="source-inline"><span class="kobospan" id="kobo.1355.1">S3StorageDataSource</span></strong><span class="kobospan" id="kobo.1356.1"> instead </span><span><span class="kobospan" id="kobo.1357.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.1358.1">FirebaseStorageDataSource</span></strong></span><span><span class="kobospan" id="kobo.1359.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1360.1">Finally, we need to integrate it into our </span><strong class="source-inline"><span class="kobospan" id="kobo.1361.1">BackupRepository</span></strong><span class="kobospan" id="kobo.1362.1"> class. </span><span class="kobospan" id="kobo.1362.2">It is as easy as replacing the </span><strong class="source-inline"><span class="kobospan" id="kobo.1363.1">StorageDataSource</span></strong><span class="kobospan" id="kobo.1364.1"> dependency for the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.1365.1">IStorageDataSource</span></strong></span><span><span class="kobospan" id="kobo.1366.1"> dependency:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.1367.1">
class BackupRepository @Inject constructor(
    private val messageDao: MessageDao,
    private val conversationDao: ConversationDao,
    private val storageDataSource: IStorageDataSource
) {
    // The rest of the class as it was before
...
</span><span class="kobospan1" id="kobo.1367.2">}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.1368.1">And that’s all. </span><span class="kobospan" id="kobo.1368.2">Depending on what we are providing in our Hilt module to satisfy the </span><strong class="source-inline"><span class="kobospan" id="kobo.1369.1">IStorageDataSource</span></strong><span class="kobospan" id="kobo.1370.1"> dependency, it will use the Firebase Storage one or the AWS </span><span><span class="kobospan" id="kobo.1371.1">S3 one.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1372.1">And with this change, we finish this chapter and also our work in the </span><span><span class="kobospan" id="kobo.1373.1">WhatsPackt application!</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer029">
<span class="kobospan" id="kobo.1374.1"><img alt="Figure 3.5: WhatsPackt’s final appearance" src="image/B19443_03_005.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.1375.1">Figure 3.5: WhatsPackt’s final appearance</span></p>
<h1 id="_idParaDest-86" class="calibre5"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/><span class="kobospan" id="kobo.1376.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.1377.1">In this chapter, we centered our efforts on creating a good offline experience for our user (storing the messages in a local database using Room) and providing a mechanism to store the messages backup, in case something fails. </span><span class="kobospan" id="kobo.1377.2">We have also learned how to use different providers to store our files in the cloud using Firebase Firestore and </span><span><span class="kobospan" id="kobo.1378.1">AWS S3.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.1379.1">Now, we have finished our work in the WhatsPackt app. </span><span class="kobospan" id="kobo.1379.2">In the next chapter, we will start building a new app: Packtagram. </span><span class="kobospan" id="kobo.1379.3">It will be an app to share photos and videos with our friends that will provide new and different challenges when creating it, such as capturing video. </span><span class="kobospan" id="kobo.1379.4">These are challenges that we will learn </span><span><span class="kobospan" id="kobo.1380.1">to overcome.</span></span></p>
</div>
</body></html>