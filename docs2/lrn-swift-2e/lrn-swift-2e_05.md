# 第五章. 现代范式 – 闭包和函数式编程

到目前为止，我们一直在使用被称为**面向对象编程**的范式进行编程，其中程序中的所有内容都表示为可以操作并传递给其他对象的实体。这是创建应用程序最流行的方式，因为它是一种非常直观的思考软件的方式，并且与苹果设计的框架非常契合。然而，这种技术有一些缺点。最大的缺点是数据的状态可能非常难以跟踪和推理。如果我们有成千上万的不同的对象在我们的应用程序中漂浮，每个对象都有不同的信息，那么找到错误发生的地方可能很困难，理解整个系统如何结合在一起也可能很困难。另一种可以帮助解决这个问题的编程范式被称为**函数式编程**。

一些编程语言被设计为仅使用函数式编程，但 Swift 主要被设计为一种面向对象的语言，具有使用函数式编程概念的能力。在本章中，我们将探讨如何在 Swift 中实现这些函数式编程概念以及它们的应用。为此，我们将涵盖以下主题：

+   函数式编程哲学

+   闭包

+   Swift 中函数式编程的构建块

+   惰性求值

+   示例

# 函数式编程哲学

在我们开始编写代码之前，让我们讨论一下函数式编程背后的思想和动机。

## 状态和副作用

函数式编程使得单独思考每个组件变得容易得多。这包括类型、函数和方法等。如果我们能够理解输入到这些代码组件中的所有内容以及从它们返回的所有内容，我们就可以轻松地分析代码，以确保没有错误并且性能良好。每个类型都使用一定数量的参数创建，程序中的每个方法和函数都有一定数量的参数和返回值。通常，我们认为这些是唯一的输入和输出，但现实情况是，往往还有更多。我们将这些额外的输入和输出称为**状态**。

在更广泛的意义上，状态是任何可以更改的存储信息，无论其是暂时的。让我们考虑一个简单的`double`函数：

```swift
func double(input: Int) -> Int {
    return input * 2
}
```

这是一个**无状态**函数的绝佳例子。无论程序中的整个宇宙发生什么，只要提供相同的输入，这个方法总是会返回相同的值。输入`2`总是会返回`4`。

现在，让我们看看一个有状态的方法：

```swift
struct Ball {
    var radius: Double

    mutating func growByAmount(amount: Double) -> Double {
        self.radius = self.radius + amount
        return self.radius
    }
}
```

如果你反复调用这个方法，在同一个`Ball`实例上使用相同的输入，每次都会得到不同的结果。这是因为这个方法中有一个额外的输入，即它被调用的实例。它通常被称为`self`。实际上，`self`既是这个方法的输入也是输出，因为原始的半径值会影响输出，而`radius`在方法结束时会被改变。只要记住`self`总是另一个输入和输出，这仍然不是很难理解。然而，你可以想象，对于一个更复杂的数据结构，跟踪代码中每一个可能的输入和输出可能会很困难。一旦这种情况开始发生，就更容易产生错误，因为我们几乎肯定会遇到意外的输入导致意外的输出。

**副作用**是更糟糕的一种额外输入或输出的类型。它们是对状态的意外更改，看似与正在运行的代码无关。如果我们简单地将前面的方法重命名为一个稍微不那么清晰的名字，它对实例的影响就会变得意外：

```swift
mutating func currentRadiusPlusAmount(amount: Double) -> Double {
    self.radius = self.radius + amount
    return self.radius
}
```

根据其名称，你不会期望这个方法会改变`radius`的实际值。这意味着，如果你没有看到实际的实现，你会期望这个方法在同一个实例上以相同的数量调用时保持返回相同的值。不可预测性对于程序员来说是一件可怕的事情。

在其最严格的形式中，函数式编程消除了所有状态和副作用。我们永远不会在 Swift 中走那么远，但我们会经常使用函数式编程技术来减少状态和副作用，以极大地提高代码的可预测性。

## 声明式代码与命令式代码

除了可预测性之外，函数式编程对我们代码的另一个影响是它变得更加**声明式**。这意味着代码向我们展示了我们期望信息如何通过我们的应用程序流动。这与我们使用面向对象编程所做的是相反的，我们称之为**命令式代码**。这是编写一个循环遍历数组以将某些元素添加到新数组中的代码与在数组上运行过滤器的区别。前者可能看起来像这样：

```swift
var originalArray = [1,2,3,4,5]
var greaterThanThree = [Int]()
for num in originalArray {
    if num > 3 {
        greaterThanThree.append(num)
    }
}
print(greaterThanThree) // [4,5]
```

在数组上运行过滤器看起来可能像这样：

```swift
var originalArray = [1,2,3,4,5]
var greaterThanThree = originalArray.filter {$0 > 3}
print(greaterThanThree) // [4,5]
```

如果你现在还不理解第二个例子，不要担心。这是我们将在本章的其余部分中要涵盖的内容。一般想法是，在命令式代码中，我们将发出一系列命令，其中代码的意图是次要的、微妙的想法。为了理解我们正在创建一个只包含大于`3`的元素的`originalArray`的副本，我们必须阅读代码并在心理上逐步通过正在发生的事情。在第二个例子中，我们在代码本身中声明我们正在过滤原始数组。最终，这些想法存在于一个光谱上，很难有 100%的声明式或命令式，但每个原则都很重要。

到目前为止，在我们的命令式代码中，大部分只是定义了我们的数据应该看起来像什么以及如何操作它。即使有高质量的抽象，理解一段代码通常也涉及到在许多方法之间跳转，追踪执行过程。在声明式代码中，逻辑可以更加集中，并且通常更容易阅读，基于命名良好的方法。

你也可以将命令式代码想象成一个工厂，其中每个人都在思考着如何完整地制作一辆车，而将声明式代码想象成一个拥有装配线的工厂。为了理解在一个非装配线工厂中人们正在做什么，你必须一步一步地观察整个过程展开。他们可能会在不同时间拉入各种工具，这会很难跟上。在一个装配线工厂中，你可以通过观察装配线上的每一个步骤来确定正在发生什么。

现在我们已经了解了一些函数式编程的动机，让我们来看看使它成为可能的 Swift 特性。

# 闭包

在 Swift 中，函数被视为一等公民，这意味着它们可以像任何其他类型一样被对待。它们可以被分配给变量，并可以在其他函数之间传递。当这样处理时，我们称它们为**闭包**。这是编写更多声明式代码的一个极其关键的部分，因为它允许我们将功能视为对象。我们不再将函数视为要执行的代码集合，而是可以开始更多地将其视为完成某事的配方。就像你可以把几乎任何食谱交给厨师来烹饪一样，你可以创建接受闭包以执行某些可定制行为的类型和方法。

## 闭包作为变量

让我们来看看 Swift 中闭包是如何工作的。在变量中捕获闭包的最简单方法是在定义函数后，使用其名称将其分配给变量：

```swift
func double(input: Int) -> Int {
        return input * 2
}

var doubleClosure = double
print(doubleClosure(2)) // 4
```

正如你所见，`doubleClosure`在被分配后可以像普通函数名一样使用。实际上，使用`double`和使用`doubleClosure`之间没有区别。请注意，我们现在可以将这个闭包视为一个对象，它将加倍任何传递给它的东西。

如果你按住选项键并单击 `doubleClosure` 的名称，你会看到类型被定义为 `(Int) -> Int`。任何闭包的基本类型是 `(ParameterType1, ParameterType2, …) -> ReturnType`。

使用这种语法，我们还可以直接定义我们的闭包，例如：

```swift
var doubleClosure2 = { (input: Double) -> Double in
    return input * 2
}
```

我们以花括号 `{}` 开始和结束任何闭包。然后，我们在开括号后面跟闭包的类型，这将包括输入参数和返回值。最后，我们使用 `in` 关键字将类型定义与实际实现分开。

返回类型的不存在被定义为 `Void` 或 `()`。尽管你可能看到一些程序员使用括号，但 `Void` 更适合用于返回声明：

```swift
var printDouble = { (input: Double) -> Void in
    print(input * 2)
}
```

实际上，`()` 是一个空的元组，意味着它不包含任何值，它更常用于输入参数，以防闭包根本不接受任何参数：

```swift
var makeHelloWorld = { () -> String in
    return "Hello World!"
}
```

到目前为止，尽管我们可以通过将其转换为闭包来改变我们对代码块的想法，但这并不特别有用。要真正使闭包有用，我们需要开始将它们传递给其他函数。

## 闭包作为参数

我们可以使用之前看到的相同类型语法定义一个函数，以闭包作为参数：

```swift
func firstInNumbers(
    numbers: [Int],
    passingTest: (number: Int) -> Bool
    ) -> Int?
{
    for number in numbers {
        if passingTest(number: number) {
            return number
        }
    }
    return nil
}
```

在这里，我们有一个函数，它可以找到数组中通过某些任意测试的第一个数字。函数声明末尾的语法可能令人困惑，但如果你从内向外工作，它应该很清楚。`passingTest` 的类型是 `(number: Int) -> Bool`。这是整个 `firstInNumbers` 函数的第二个参数，它返回一个 `Int?`。如果我们想使用这个函数来找到大于三的第一个数字，我们可以创建一个自定义测试并将其传递给函数：

```swift
let numbers = [1,2,3,4,5]
func greaterThanThree(number: Int) -> Bool {
    return number > 3
}
var firstNumber = firstInNumbers(numbers, greaterThanThree)
print(firstNumber) // "Optional(4)"
```

在这里，我们实际上是将一小块功能传递给 `firstInNumbers:` 函数，这使我们能够极大地增强单个函数通常能做的事情。这是一个极其有用的技术。通过遍历数组来查找元素可能非常冗长。相反，我们可以使用这个函数来查找元素，只显示代码的重要部分：测试。

我们甚至可以直接在函数调用中定义我们的测试：

```swift
firstNumber = firstInNumbers(numbers, passingTest: { (number: Int) -> Bool in
    return number > 3
})
```

尽管这更简洁，但它相当复杂；因此，Swift 允许我们省略一些不必要的语法。

## 语法糖

首先，我们可以利用类型推断来推断 `number` 的类型。编译器知道根据 `firstInNumbers:passingTest:` 的定义，数字需要是 `Int`。它还知道闭包必须返回 `Bool`。现在，我们可以重写我们的调用，如下所示：

```swift
firstNumber = firstInNumbers(numbers, passingTest: { (number) in
    return number > 3
})
```

这样看起来更简洁，但括号围绕 `number` 的部分不是必需的；我们可以省略这些。此外，如果我们把闭包作为函数的最后一个参数，我们可以在函数调用外提供闭包：

```swift
firstNumber = firstInNumbers(numbers) { number in
    return number > 3
}
```

注意，函数参数的闭包括号从闭包之后移动到了闭包之前。这看起来相当不错，但我们还可以更进一步。对于单行闭包，我们甚至不需要写 `return` 关键字，因为它已经隐含了：

```swift
firstNumber = firstInNumbers(numbers) { number in
    number > 3
}
```

最后，我们并不总是需要给闭包的参数命名。如果你完全省略了名称，每个参数都可以使用语法 `$<ParameterIndex>` 来引用。就像数组一样，索引从 `0` 开始。这有助于我们非常简洁地在单行中编写这个调用：

```swift
firstNumber = firstInNumbers(numbers) { $0 > 3 }
```

这与我们的原始语法相去甚远。你可以混合使用所有这些不同的技术，以确保你的代码尽可能易于理解。正如我们之前讨论过的，可理解性是在简洁和清晰之间取得平衡。在每种情况下，都取决于你决定省略多少语法。对我来说，如果没有名称，闭包并不立即清晰。我首选的语法是在调用中使用参数名称：

```swift
firstNumber = firstInNumbers(numbers, passingTest: {$0 > 3})
```

这清楚地表明闭包是一个测试，看看我们想要从列表中提取哪个数字。

现在我们已经知道了闭包是什么以及如何使用它，我们可以讨论一些 Swift 的核心特性，这些特性允许我们编写函数式风格的代码。

# Swift 中函数式编程的构建块

首先要意识到的是，Swift 不是一个函数式编程语言。在其核心，它始终是一个面向对象编程语言。然而，由于 Swift 中的函数是一等公民，我们可以使用一些核心技术。Swift 提供了一些内置方法来帮助我们入门。

## 过滤

我们将要讨论的第一个方法被称为 **filter**。正如其名称所暗示的，这个方法用于过滤列表中的元素。例如，我们可以过滤 `numbers` 数组，只包含偶数：

```swift
var evenNumbers = numbers.filter({ element in
    element % 2 == 0
}) // [2, 4]
```

我们提供的用于过滤的闭包将对数组中的每个元素调用一次。它的任务是如果元素需要包含在结果中则返回 `true`，否则返回 `false`。前面的闭包利用了隐含的返回值，如果数字除以二有余数则简单地返回 `true`。

注意，过滤不会改变 `numbers` 变量；它只是返回一个过滤后的副本。改变值将修改状态，这是我们想要避免的。

这种方法为我们提供了一种简洁的方式来以我们想要的方式过滤列表。它也是构建一个可以应用于数据的转换词汇表的开始。有人可能会争论，所有应用只是将数据从一种形式转换为另一种形式，所以这个词汇表帮助我们实现任何应用中我们想要的最高功能。

## 减少

Swift 还提供了一个名为 **reduce** 的方法。reduce 的目的是将列表缩减为单个值。reduce 通过遍历每个值并将其与代表所有前元素的单一值组合来工作。这就像为食谱在碗中混合一堆配料一样。我们将一次取一个配料，并将其放入碗中，直到我们只剩下一个装有所有配料的碗。

让我们看看 reduce 函数在代码中的样子。我们可以使用它来计算数字数组中的值总和：

```swift
var sum = numbers.reduce(0, combine: { previousSum, element in
    previousSum + element
}) // 15
```

如你所见，reduce 函数接受两个参数。第一个参数是用于开始组合列表中每个项的值。第二个是一个闭包，它将执行组合。与 filter 类似，这个闭包对数组中的每个元素调用一次。闭包的第一个参数是在将每个前一个元素与初始值组合后的值。第二个参数是下一个元素。

因此，当闭包第一次被调用时，它使用的是 `0`（初始值）和 `1`（列表中的第一个元素）；然后返回 `1`。这意味着它随后再次使用 `1`（上一次调用的值）和 `2`（列表中的下一个元素）返回 `3`。这个过程会一直持续，直到它将运行总和 `10` 与最后一个元素 `5` 结合，得到最终结果 `15`。一旦我们将其分解，它就变得非常简单。

**Reduce** 是另一个可以添加到我们的技能集的优秀词汇。它可以通过分析数据将任何信息列表缩减为单个值，例如从图像列表生成文档等。

此外，我们还可以开始将我们的函数串联起来。如果我们想找到列表中所有偶数的总和，我们可以运行以下代码：

```swift
var evenSum = numbers.filter({$0 % 2 == 0}).reduce(0, combine: {$0 + $1}) // 6
```

现在，我们可以做一件事情来缩短这个过程。每个算术运算，包括加法（`+`），实际上只是另一个函数或闭包。加法是一个接受相同类型的两个值并返回它们的和的函数。这意味着我们可以简单地将加法函数作为我们的组合闭包传递：

```swift
evenSum = numbers.filter({$0 % 2 == 0}).reduce(0, combine: +) // 6
```

现在我们开始变得复杂了！

此外，请注意，组合的值不需要与原始列表中的类型相同。而不是求和值，我们可以将它们全部组合成一个字符串：

```swift
let string = numbers.reduce("", combine: {"\($0)\($1)"}) // "12345"
```

在这里，我使用字符串插值来创建一个以运行值开始并以下一个元素结束的字符串。

## Map

**Map** 是一个将列表中的每个元素转换成另一个值的方法。例如，我们可以给列表中的每个数字加一：

```swift
let plusOne = numbers.map({ element -> Int in
    return element + 1
}) // [2, 3, 4, 5, 6]
```

如你或许能猜到的，map 函数所采用的闭包对列表中的每个元素只调用一次。作为一个参数，它接受元素并期望返回要添加到结果数组中的新值。

就像 reduce 一样，转换后的类型不需要匹配。我们可以将所有的数字都转换为字符串：

```swift
let strings = numbers.map {String($0)}
```

`map` 非常灵活。它可以用来将数据列表转换为视图列表以显示数据，将图像路径列表转换为加载的图像，等等。

`map` 方法是一个对列表中的每个元素执行计算的绝佳选择，但它只应该在将计算结果放回列表中合理时使用。技术上，你可以用它来遍历列表并执行其他操作，但在那种情况下，for-in 循环更为合适。

## 排序

我们将要讨论的最后一个内置函数式方法是称为 `sorted`。正如其名所示，`sorted` 允许你改变列表的顺序。例如，如果我们想将我们的数字列表重新排序，从大到小：

```swift
numbers.sort({ element1, element2 in
    element1 > element2
}) // [5, 4, 3, 2, 1]
```

传递给 `sorted` 的闭包称为 `isOrderedBefore`。这意味着它接受列表中的两个元素作为输入，如果第一个元素应该在第二个元素之前排序，则应返回 `true`。我们无法依赖闭包被调用一定次数，也不能依赖它将被调用的元素，但它将一直被调用，直到排序算法有足够的信息来提出新的顺序。

在我们的情况下，当第一个参数大于第二个参数时，我们返回 `true`。这导致较大的元素始终出现在较小的元素之前。

这是一个很好的方法，因为排序是一个非常常见的任务，并且数据通常需要根据用户的交互以多种方式排序。使用这种方法，你可以设计多个排序闭包，并根据用户的交互更改正在使用的闭包。

## 这些如何影响代码的状态和本质

有更多内置的功能方法，我们将在下一章关于泛型的章节中学习如何编写自己的方法，但这些都是核心的几个方法，可以帮助你以函数式的方式思考某些问题。那么，这些方法是如何帮助我们避免状态的？

这些方法以及其他方法可以以无限的方式组合起来，以转换数据和执行操作。无论组合多么复杂，都无法干扰每个单独的步骤。因为没有副作用，唯一的输入是前一步的结果，唯一的输出是传递给下一步的内容。

你还可以看到，复杂的转换都可以在一个简洁且集中的地方声明。代码的读者不需要追踪许多变量的变化值；他们只需查看代码，就可以看到它将经历哪些过程。

# 延迟评估

Swift 的一个强大功能是能够使这些操作延迟评估。这意味着，就像一个懒惰的人会做的那样，只有在绝对必要且尽可能晚的时候才会计算值。

首先，重要的是要意识到这些方法的执行顺序。例如，如果我们只想将我们的数字列表的第一个元素映射到字符串：

```swift
var firstString = numbers.map({String($0)}).first
```

这工作得很好，但事实上我们实际上将每个数字都转换为字符串，只是为了得到第一个。这是因为链的每一步都必须在执行下一步之前完成。为了防止这种情况，Swift 有一个内置的名为**lazy**的方法。

懒加载创建了一个新的容器版本，它仅在特定请求时从其中提取特定值。这意味着懒加载本质上允许每个元素一次通过一系列函数，正如它所需的那样。你可以把它想象成一个懒版本的工人。如果你让一个懒人查找喀麦隆的首都，他们不会在得到答案之前编译所有国家的首都列表。他们只会做得到那个特定答案所必需的工作。这项工作可能涉及多个步骤，但他们只需为你要询问的特定国家做这些步骤。

现在，让我们看看代码中懒加载的样子。你使用它将普通列表转换为懒列表：

```swift
firstString = numbers.lazy.map({String($0)}).first
```

现在，我们不再直接在`numbers`上调用`map`，而是在`numbers`的懒加载版本上调用它。这使得每次从结果请求值时，它只处理输入数组中的一个元素。在我们的前一个例子中，`map`方法只执行了一次。

这甚至适用于遍历结果：

```swift
let lazyStrings = numbers.lazy.map({String($0)})
for string in lazyStrings {
    print(string)
}
```

每个数只有在 for-in 循环的下一个迭代中才会被转换为字符串。如果我们提前退出循环，其余的值将不会被计算。这是一种节省处理时间的好方法，尤其是在大型列表上。

# 示例

让我们看看在实践中这看起来是什么样子。我们可以使用本章学到的某些技术来编写不同的，可能更好的派对邀请者实现。

我们可以先定义相同的输入数据：

```swift
//: List of people to invite
let invitees = [
    "Sarah",
    "Jamison",
    "Marcos",
    "Roana",
    "Neena",
]

//: Dictionary of shows organized by genre
var showsByGenre = [
    "Comedy": "Modern Family",
    "Drama": "Breaking Bad",
    "Variety": "The Colbert Report",
]
```

在这个实现中，我们正在创建一个邀请者列表，它只是一个常量列表的名字和按类型分类的节目字典变量。这是因为我们将把我们的邀请者列表映射到邀请文本列表。当我们进行映射时，我们必须为当前受邀者选择一个随机类型，为了避免重复分配同一个类型，我们可以从字典中移除该类型。

因此，让我们编写随机的`genre`函数：

```swift
func pickAndRemoveRandomGenre() -> (genre: String, example: String)? {
    let genres = Array(showsByGenre.keys)
    guard genres.count > 0 else {
        return nil
    }

    let genre = genres[Int(rand()) % genres.count]
    let example = showsByGenre[genre]!
    showsByGenre[genre] = nil
    return (genre: genre, example: example)
}
```

我们首先创建一个只包含按类型分类的节目字典的键的数组。然后，如果没有剩余的类型，我们简单地返回 nil。否则，我们随机选择一个类型，从字典中移除它，并返回它和节目示例。

现在，我们可以使用这个函数将受邀者映射到邀请列表：

```swift
let invitations: [String] = invitees
.map({ name in
    guard let (genre, example) = pickAndRemoveRandomGenre() else {
        return "\(name), just bring yourself"
    }
    return "\(name), bring a \(genre) show"
        + "\n\(example) is a great \(genre)"
})
```

在这里，我们尝试随机选择一个流派。如果我们做不到，我们就返回一个邀请，告诉被邀请者只需带上自己。如果我们能做到，我们就返回一个邀请，告诉他们应该带上什么流派，以示例演出为例。这里需要注意的新事物是我们正在使用字符串中的序列 `"\n"`。这是一个换行符，它表示文本中应该开始新的一行。

最后一步是打印出邀请函。为了做到这一点，我们可以将邀请函作为由换行符连接的字符串打印出来：

```swift
print(invitations.joinWithSeparator("\n"))
```

这工作得相当好，但有一个问题。我们列出的第一个被邀请者总是会分配一个流派，因为它们被处理的顺序永远不会改变。为了解决这个问题，我们可以在开始映射函数之前编写一个函数来打乱被邀请者：

```swift
func shuffle(array: [String]) -> [String] {
    return array
        .map({ ($0, Int(rand())) })
        .sort({ $0.1 < $1.1 })
        .map({$0.0})
}
```

为了打乱一个数组，我们通过三个步骤进行：首先，我们将数组映射到一个元组中，包含原始元素和一个随机数。其次，我们根据这些随机数对元组进行排序。最后，我们将元组映射回它们的原始元素。

现在，我们只需要在我们的序列中添加对这个函数的调用：

```swift
let invitations: [String] = shuffle(invitees)
.map({ name in
    guard let (genre, example) = pickAndRemoveRandomGenre() else {
        return "\(name), just bring yourself"
    }
    return "\(name), bring a \(genre) show"
        + "\n\(example) is a great \(genre)"
})
```

这种实现方式并不一定比我们之前的实现更好，但它确实有其优势。我们通过将其实现为一系列数据转换来减少状态。其中的大问题是我们在流派字典中仍然维护状态。我们当然可以做更多来消除这一点，但这也给你一个很好的想法，了解我们如何开始以函数式方式思考问题。我们可以以更多方式思考一个问题，我们找到最佳解决方案的机会就越高。

# 摘要

在这一章中，我们不得不改变我们思考代码的方式。至少，这是一个很好的练习，这样我们就不会陷入编程习惯。我们已经涵盖了函数式编程背后的哲学以及它与面向对象编程的不同之处。我们探讨了闭包的具体内容以及它们如何在 Swift 中启用函数式编程技术。最后，我们探索了一些 Swift 内置的特定函数式方法。

一个真正伟大程序员的标志不是对一种工具了解很多，而是知道何时使用哪种工具。我们通过学习和练习使用大量不同的工具和技术来实现这一点，而从不过分依赖任何一种。

一旦你对闭包和函数式编程的概念感到舒适，你就可以继续学习我们的下一个主题，泛型。泛型是我们第一次有机会让 Swift 的强类型特性真正为我们所用。
