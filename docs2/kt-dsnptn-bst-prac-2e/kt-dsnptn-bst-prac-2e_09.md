# *第七章*：控制数据流

上一章介绍了重要的**Kotlin**并发原语：**协程**。在这一章中，我们将讨论 Kotlin 中的另外两个重要的并发原语：**通道**和**流**。我们还将简要介绍**集合**的**高阶函数**，因为它们的 API 与通道和流非常相似。

充分利用小型、可重用和可组合函数的想法直接来自我们在上一章讨论的**函数式编程**范式。这些函数允许我们用描述*我们想要做什么*而不是*我们想要如何做*的方式来编写代码。

在这一章中，我们将涵盖以下主题：

+   反应式原则

+   集合的高阶函数

+   并发数据结构

+   序列

+   通道

+   流

在阅读本章后，你将能够高效地在不同的协程之间进行通信，并轻松处理你的数据。

# 技术要求

除了前几章的技术要求外，你还需要一个启用了**Gradle**的**Kotlin**项目，以便能够添加所需的依赖项。

你可以在以下位置找到本章使用的源代码，位于**GitHub**上：

[`github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07`](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter07)

# 反应式原则

我们将从这个章节开始，简要地探讨**反应式编程**，因为它构成了**数据流**概念的基础。

反应式编程是一种基于函数式编程的范式，其中我们将我们的逻辑建模为数据流中的一系列操作。反应式编程的基本概念在*反应式宣言*（[`www.reactivemanifesto.org`](https://www.reactivemanifesto.org)）中得到了很好的总结。

根据这份宣言，反应式程序应该是以下所有内容：

+   响应式

+   弹性

+   弹性

+   消息驱动

要理解这四个原则，我们将使用一个例子。

让我们想象你正在给你的互联网服务提供商打电话，比如你的互联网速度很慢。*你脑海中有没有这样的画面？* 那我们就开始吧。

## 响应式原则

*你愿意花多少时间排队等待？* 这取决于情况的紧迫性和你拥有的时间。如果你很着急，你可能会早点挂断电话，因为你不知道在听那糟糕的音乐时你需要等待多长时间。

这就是系统对你**无响应**的情况。这种情况也发生在网络系统中。当等待其他请求被处理时，对网络服务器的请求可能会在队列中卡住。

另一方面，一个响应式的呼叫中心可能会偶尔用愉快的声音告诉你，在你之前有多少人在排队——甚至告诉你你需要等待多长时间。

在这两种情况下，结果都是一样的。你在等待在线上浪费了时间。但第二个系统对你的需求做出了响应，你可以据此做出决定。

## 弹性原则

让我们继续讨论**弹性**原则。想象一下，你在电话线上等了 10 分钟，然后线路断了。这就是系统对故障缺乏弹性的例子。

反应式宣言建议了实现弹性的几种方法：

+   **委派**：你可能听到，“*我们当前的代表无法解决你的慢速互联网问题；我们将把你转接到其他人。*”

+   **复制**：然后，你可能听到，“*我们意识到很多人都在线上；我们正在说话时增加更多代表。*”这也与*弹性*有关，我们将在下一节中介绍。

+   **限制**和**隔离**：最后，自动语音告诉你，“*如果你不想等待，请留下你的电话号码，我们会给你回电。*”**限制**意味着你现在与系统所面临的可扩展性问题（即系统代表不足）解耦了。相比之下，**隔离**意味着即使系统在电话线路不可靠方面存在问题，你也不关心。

## 弹性原则

在上一节中，我们讨论了复制。为了防止故障，我们的客服中心总是至少有三名代表在班上。也许他们都在接听电话，或者他们可能只是在耐心地等待。

*然而，如果某个狂热的鼹鼠咬断了互联网电缆会发生什么呢？*

突然，有大量愤怒的客户来电。

如果我们的客服中心只有三部电话，我们对此无能为力。但如果我们有一些额外的资源，我们可以增加代表来处理事件并安抚我们的客户。而且，当电缆最终修好时，我们可以让他们回去工作。这就是系统对工作量做出弹性的响应。

*弹性*建立在*可扩展性*的基础上。例如，如果我们每个代表都能通过拥有自己的电话独立工作，我们就可以管理所有 incoming calls。如果我们有比电话更多的代表，电话的数量就会成为*瓶颈*，一些代表将无法接听任何电话。

## 信息驱动原则

**信息驱动**原则也被称为**异步消息传递**。所以，在上一节中，我们看到了如果你可以为任何代表留下信息让他们回电，这可以使系统更具弹性。

*那么，如果所有客户都只留下信息怎么办？*

然后，每个代表都可以*优先处理*这些信息或*批量处理*它们。例如，一次性打印所有账单收据，而不是随机顺序处理信息。

使用消息还可以应用背压。如果一个代表收到太多的消息，他们可能会因为压力而崩溃。为了避免这种情况，他们可能会给你发短信说你需要等待更长一点时间才能收到你的回复。同样，我们在这里也在谈论 *委托*，因为所有这些原则都是重叠的。

消息也是 *非阻塞的*。在你发送消息后，你不需要在那里等待代表的回复。相反，你通常会回到你的常规任务。在等待时能够执行其他任务是 *并发* 的基石之一。

在本节中，我们学习了四个反应性原则。反应性应用是响应的、弹性的、可伸缩的，并且以消息驱动。在接下来的章节中，我们将看到这些原则如何在 Kotlin 中应用。我们将从 *集合* 开始，或者在反应式编程术语中，称为 *静态数据流*。

# 集合上的高阶函数

我们在 *第一章*，*Kotlin 入门* 中简要提到了这个话题，但在我们讨论流之前，让我们确保那些来自没有集合高阶函数的语言的人知道它们是什么，它们做什么，以及使用它们的优点是什么。

我们无法涵盖集合上所有可用的函数，但我们将涵盖最广泛使用的那些。

## 映射元素

`map()` 函数接受集合中的每个元素，并返回一个可能不同类型的新元素。为了更好地理解这个想法，让我们假设我们有一个字母列表，我们想要输出它们的 ASCII 值。

首先，让我们以命令式的方式实现它：

```kt
val letters = 'a'..'z'
```

```kt
val ascii = mutableListOf<Int>()
```

```kt
for (l in letters) {
```

```kt
    ascii.add(l.toInt())
```

```kt
}
```

注意，即使是这样一个简单的任务，我们也不得不编写相当多的代码。我们还必须将输出列表定义为可变的。

现在，使用 `map()` 函数的相同代码将看起来像这样：

```kt
val result: List<Int> = ('a'..'z').map { it.toInt() }
```

注意实现有多么简短。我们不需要定义一个可变列表，也不需要自己编写 `for-each` 循环。

## 过滤元素

另一个常见的任务是过滤集合。你知道该怎么做——你遍历它，只将符合你标准的值放入一个新的集合中。例如，如果给定一个介于 `1` 和 `100` 之间的数字范围，我们只想返回那些可以被 `3` 或 `5` 整除的数字。

在命令式方式中，这个函数可能看起来像这样：

```kt
val numbers = 1..100
```

```kt
val notFizzbuzz = mutableListOf<Int>()
```

```kt
for (n in numbers) {
```

```kt
    if (n % 3 == 0 || n % 5 == 0) {
```

```kt
        notFizzbuzz.add(n)
```

```kt
    }
```

```kt
}
```

在其函数式变体中，我们会使用 `filter()` 函数：

```kt
val filtered: List<Int> = (1..100).filter { it % 3 == 0 || 
```

```kt
  it % 5 == 0 }
```

再次注意，我们的代码变得更加简洁。我们只指定 *需要做什么*，过滤符合标准的元素，而不是 *如何做*（例如，使用 `if` 语句）。

## 查找元素

在集合中查找第一个元素是另一个常见任务。如果我们编写一个查找既能被 `3` 又能被 `5` 整除的数字的函数，我们可以这样实现它：

```kt
fun findFizzbuzz(numbers: List<Int>): Int? {
```

```kt
    for (n in numbers) {
```

```kt
        if (n % 3 == 0 && n % 5 == 0) {
```

```kt
            return n
```

```kt
        }
```

```kt
    }
```

```kt
    return null
```

```kt
}
```

同样的功能可以使用 `find` 函数实现：

```kt
val found: Int? = (1..100).find { it % 3 == 0 && it % 5 ==   0 }
```

与前面提到的命令式函数类似，如果没有任何元素符合我们的标准，`find` 函数将返回 `null`。

此外，还有一个配套的 `findLast()` 方法，它执行相同的操作，但以集合的最后一个元素开始。

## 为每个元素执行代码

所有之前的函数族都有一个共同的特点：它们都产生一个流。但并非所有的高阶函数都返回流。有些会返回单个值，例如 `Unit` 或，例如，一个数字。这些函数被称为 **终结函数**。

在本节中，我们将处理第一个终结函数。终结函数返回的不是新集合，因此你不能将此调用的结果链式调用到其他调用。因此，它们 *终结* 链式调用。

在 `forEach()` 的情况下，它返回 `Unit` 类型的结果。`Unit` 类型类似于 `forEach()` 函数中的 `void`。`forEach()` 函数就像普通的 `for` 循环：

```kt
val numbers = (0..5)
```

```kt
numbers.map { it * it}          // Can continue
```

```kt
       .filter { it < 20 }      // Can continue
```

```kt
       .forEach { println(it) } // Cannot continue
```

注意，与传统的 `for` 循环相比，`forEach()` 有一些轻微的性能影响。

此外，还有 `forEachIndexed()`，它提供了一个索引，与集合中的实际值一起：

```kt
numbers.map { it * it }
```

```kt
        .forEachIndexed { index, value ->
```

```kt
    print("$index:$value, ")
```

```kt
}
```

上述代码的输出将如下所示：

```kt
> 0:1, 1:4, 2:9, 3:16, 4:25, 
```

自 Kotlin 1.1 以来，还有一个 `onEach()` 函数，它更有用一些，因为它会返回集合本身：

```kt
numbers.map { it * it}         
```

```kt
       .filter { it < 20 }     
```

```kt
       .sortedDescending()     
```

```kt
       .onEach { println(it) } // Can continue now
```

```kt
       .filter { it > 5 }
```

正如你所见，这个函数不是终结的。

## 求和元素

与 `forEach()` 类似，`reduce()` 是一个终结函数。但它不是以 `Unit` 终结，`Unit` 不是很有用，而是以与操作集合相同类型的单个值终结。

为了看到 `reduce()` 在实际中的应用，让我们总结一下从 `1` 到 `100` 之间的所有数字：

```kt
val numbers = 1..100
```

```kt
var sum = 0
```

```kt
for (n in numbers) {
```

```kt
    sum += n
```

```kt
}
```

现在，让我们使用 `reduce` 来编写相同的代码：

```kt
val reduced: Int = (1..100).reduce { sum, n -> sum + n }
```

注意，这里它让我们避免了声明一个用于存储元素总和的可变变量。与之前我们看到的高阶函数不同，`reduce()` 接收的不是单个参数，而是两个参数。第一个参数是累加器。在命令式示例中，它是 `sum` 变量。第二个参数是下一个元素。我们使用了相同的参数名，所以应该相对容易比较这两种实现。

## 移除嵌套

有时在处理集合时，我们可能会得到一个 *集合的集合*。例如，考虑以下代码：

```kt
val listOfLists: List<List<Int>> = listOf(listOf(1, 2), listOf(3, 4, 5), listOf(6, 7, 8))
```

*但如果我们想将这个集合转换成一个包含所有嵌套元素的单一列表呢？*

然后，输出将如下所示：

```kt
> [1, 2, 3, 4, 5, 6, 7, 8]
```

一个选择是迭代我们的输入并使用可变集合的 `addAll` 方法：

```kt
val flattened = mutableListOf<Int>()
```

```kt
for (list in listOfLists) {
```

```kt
    flattened.addAll(list)
```

```kt
}
```

一个更好的选择是使用 `flatMap()` 函数，它将执行相同操作：

```kt
val flattened: List<Int> = listOfLists.flatMap { it }
```

通过使用 `flatten()` 函数，这个具体的例子可以进一步简化：

```kt
val flattened: List<Int> = listOfLists.flatten()
```

但 `flatMap()` 函数通常更有用，因为它允许你将其他函数应用于每个集合，以一种 **适配器** 模式。

在集合上声明了许多其他高阶函数，所以我们无法在这个简短的章节中涵盖所有这些。你必须浏览官方文档并了解它们。尽管如此，之前讨论的函数应该为我们将要讨论的下一个主题提供一个坚实的基础。

现在，当你熟悉了如何转换和迭代*静态数据流*时，让我们看看我们如何将这些相同的操作应用到*动态数据流*上。

# 探索并发数据结构

现在我们熟悉了集合上的一些最常见的高阶函数，让我们将这个知识与我们在上一章中关于 Kotlin 并发原语的知识结合起来，讨论 Kotlin 提供的**并发数据结构**。

最基本的并发数据结构是*通道*和*流*。然而，在我们可以讨论它们之前，我们需要看看另一个数据结构：**序列**。虽然这个数据结构本身不是并发的，但它将为我们提供进入并发世界的一个桥梁。

## 序列

在许多函数式编程语言中，集合上的高阶函数已经存在很长时间了。但对于 Java 开发者来说，集合上的高阶函数首次出现在 Java 8 中，随着**Stream API**的引入。

尽管 Stream API 为开发者提供了如`map()`、`filter()`等有价值的函数以及我们之前讨论的一些其他函数，但 Stream API 有两个主要的缺点。首先，为了使用这些函数，你必须迁移到 Java 8。其次，你的集合必须转换成称为**流**的东西，它上面定义了所有这些函数。如果你想在映射和过滤流之后再次返回一个集合，你可以将其收集回来。

流和集合之间还有一个重要的区别。与集合不同，流可以是无限的。由于 Kotlin 不仅限于**JVM**，并且向后兼容 Java 6，因此它需要提供另一个解决方案来处理无限集合的可能性。这个解决方案被命名为**序列**，以避免与 Java 流冲突，当 Java 流可用时。

我们可以使用`generateSequence()`函数创建一个新的序列。例如，下一个函数将创建一个无限数字序列：

```kt
val seq: Sequence<Long> = generateSequence(1L) { it + 1 }
```

作为第一个参数，我们指定初始值，而第二个参数是一个 lambda 表达式，它基于前一个值生成下一个值。如您所见，返回的类型是`Sequence`。

可以使用`asSequence()`函数将常规集合或范围转换为序列：

```kt
(1..100).asSequence()
```

如果我们需要使用更复杂的逻辑来构建序列，可以使用`sequence()`构建器：

```kt
val fibSeq = sequence {
```

```kt
    var a = 0
```

```kt
    var b = 1
```

```kt
    yield(a)
```

```kt
    yield(b)
```

```kt
    while (true) {
```

```kt
        yield(a + b)
```

```kt
        val t = a
```

```kt
        a = b
```

```kt
        b += t
```

```kt
    }
```

```kt
} 
```

在这个例子中，我们创建了一个斐波那契数列。然后，我们使用`yield()`函数来返回序列中的下一个值。每次使用序列时，代码将从最后一个调用的`yield()`函数处恢复。

虽然序列的概念本身似乎并不很有用，但序列和集合之间存在显著的差异。序列是**懒加载的**，而集合是**急加载的**。

这意味着在集合上使用高阶函数对于超过一定大小的集合来说有一个隐藏的成本。大多数情况下，它们会为了不可变性而复制整个集合。

为了理解这种差异，让我们看看以下代码。首先，我们将创建一个包含一百万个数字的列表，并测量平方列表中每个数字所需的时间——一次在操作**集合**时，另一次在操作**序列**时：

```kt
val numbers = (1..1_000_000).toList()
```

```kt
println(measureTimeMillis {
```

```kt
    numbers.map {
```

```kt
        it * it
```

```kt
    }.take(1).forEach { it }
```

```kt
}) // ~50ms
```

```kt
println(measureTimeMillis {
```

```kt
    numbers.asSequence().map {
```

```kt
        it * it
```

```kt
    }.take(1).forEach { it }
```

```kt
}) // ~5ms
```

我们使用`take()`函数，这是集合上的另一个高阶函数，用于仅获取计算的第一个元素。

您可以看到，使用序列的代码执行得更快。这是因为序列是懒加载的，它会为每个元素执行链式操作。这意味着整个列表中只有一个数字被平方。

另一方面，集合上的函数作用于整个集合。这意味着首先，所有的数字都被平方，然后放入一个新的集合中，然后只从结果中取出一个数字。

序列、通道和流程遵循**响应式原则**，因此在继续之前理解它们是至关重要的。请注意，响应式原则并不局限于函数式编程。在编写面向对象或过程式代码时，您也可以是响应式的。然而，在学习了函数式编程及其基础之后，讨论这些原则仍然更容易。

## 通道

在上一章中，我们学习了如何生成协程并控制它们。

**但是，如果两个协程需要相互通信怎么办？**

在 Java 中，线程通过使用`wait()`/`notify()`/`notifyAll()`模式或使用`java.util.concurrent`包中的一系列丰富的类（例如，`BlockingQueue`）进行通信。

在 Kotlin 中，如您所注意到的，没有`wait()`/`notify()`方法。相反，为了在协程之间进行通信，Kotlin 使用通道。`BlockingQueue`，但通道不会阻塞线程，而是挂起协程，这要便宜得多。我们将使用以下步骤来创建通道和协程：

1.  首先，让我们创建一个通道：

    ```kt
    val chan = Channel<Int>()
    ```

    通道是有类型的。这个通道只能接收整数。

1.  然后，让我们创建一个从该通道读取的协程：

    ```kt
    launch {
        for (c in chan) {
            println(c)
        }
    }
    ```

    从通道读取就像使用`for-each`循环一样简单。

1.  现在，让我们向这个通道发送一些值。这和使用`send()`函数一样简单：

    ```kt
    (1..10).forEach {
        chan.send(it)
    }
    chan.close()
    ```

1.  最后，我们关闭通道。一旦关闭，监听通道的协程也将退出`for-each`循环，如果没有其他事情要做，协程将终止。

这种通信方式被称为**通信顺序进程**，或者更简单地说，**CSP**。

如您所见，通道是在不同协程之间通信的一种方便且类型安全的途径。但我们必须手动定义通道。在接下来的两个部分中，我们将看到如何进一步简化这一点。

### 生产者

如果我们需要一个提供值流的协程，我们可以使用`produce()`函数。这个函数创建了一个由`ReceiveChannel<T>`支持的协程，其中`T`是协程生成的类型。

我们可以通过使用`produce()`函数重写上一节中的例子，如下所示：

```kt
val chan = produce {
```

```kt
    (1..10).forEach {
```

```kt
        send(it)
```

```kt
    }
```

```kt
}
```

```kt
launch {
```

```kt
    for (c in chan) {
```

```kt
        println(c)
```

```kt
    }
```

```kt
}
```

注意，在`produce()`块内部，`send()`函数随时可用，我们可以用它将新值推送到通道。

在我们的消费者协程中，我们不需要使用`for-each`循环，我们可以使用`consumeEach()`函数：

```kt
launch {
```

```kt
    chan.consumeEach {
```

```kt
        println(it)
```

```kt
    }
```

```kt
}
```

现在，是时候看看另一个例子，其中协程被绑定到通道上了。

### 演员

与`producer()`类似，`actor()`是一个与通道绑定的协程。但与通道从协程*出去*不同，这里有一个通道进入协程。

让我们看看以下例子：

```kt
val actor = actor<Int> {
```

```kt
    channel.consumeEach {
```

```kt
        println(it)
```

```kt
    }
```

```kt
}
```

```kt
(1..10).forEach {
```

```kt
    actor.send(it)
```

```kt
}
```

在这个例子中，我们的主函数再次生成值，并通过通道让演员消费它们。这与我们看到的第一个例子非常相似，但不同之处在于我们没有显式创建通道和单独的协程，而是将它们捆绑在一起。

如果你曾经使用过**Scala**或任何其他具有演员的编程语言，你可能对我们描述的演员模型略有不同。例如，在某些实现中，演员既有输入通道也有输出通道（通常称为**邮箱**）。但在 Kotlin 中，演员只有一个以通道形式存在的输入邮箱。

### 缓冲通道

在所有之前的例子中，无论是显式还是隐式地创建通道，我们实际上使用的是它们的*未缓冲*版本。

为了演示这意味着什么，让我们看看上一节中略微修改过的例子：

```kt
val actor = actor<Long> {
```

```kt
    var prev = 0L
```

```kt
    channel.consumeEach {
```

```kt
        println(it - prev)
```

```kt
        prev = it
```

```kt
        delay(100)
```

```kt
    }
```

```kt
}
```

这里，我们几乎有相同的`actor`对象，它接收时间戳并打印出它接收到的每个两个时间戳之间的差异。我们还在它能够读取下一个值之前引入了一个小延迟。

而不是发送一系列数字，我们将当前时间戳发送到这个`actor`对象：

```kt
repeat(10) {
```

```kt
    actor.send(System.currentTimeMillis())
```

```kt
}
```

```kt
actor.close().also { println("Done sending") }
```

现在，让我们看看我们代码的输出：

```kt
> ...
```

```kt
> 101
```

```kt
> 103
```

```kt
> 101
```

```kt
> Done sending
```

注意，我们的生产者在通道准备好接受下一个值之前是挂起的。因此，`actor`对象能够对生产者施加回压，告诉它不要发送下一个值，直到`actor`对象准备好。

现在，让我们对我们的`actor`对象的定义方式做一些小的改动：

```kt
val actor = actor<Long>(capacity = 10) {
```

```kt
...
```

```kt
}
```

每个通道都有一个*容量*，默认为零。这意味着在从通道消耗一个值之前，无法通过它发送其他值。

现在，如果我们再次运行我们的代码，我们将看到完全不同的输出：

```kt
> Done sending
```

```kt
> ...
```

```kt
> 0
```

```kt
> 0
```

由于通道现在缓冲消息，生产者不再需要等待消费者。因此，消息尽可能快地发送，而 actor 仍然可以以自己的节奏消费它们。

以类似的方式，`capacity`也可以定义在生产者通道上：

```kt
val chan = produce(capacity = 10) { 
```

```kt
    (1..10).forEach { 
```

```kt
        send(it) 
```

```kt
    } 
```

```kt
}
```

它也可以定义在原始通道上：

```kt
val chan = Channel<Int>(10)
```

缓冲通道是一个非常强大的概念，它允许我们将生产者与消费者*解耦*。不过，您应该谨慎使用它们，因为通道的容量越大，所需的内存就越多。

通道是一种相对底层的并发结构。因此，让我们看看另一种类型的流，它为我们提供了更高层次的抽象。

## 流

**流**是一个冷、异步的流，是我们在*第四章*，“熟悉行为模式”中介绍的**可观察设计模式**的实现。

作为快速提醒，可观察的设计模式有两个方法：`subscribe()`（允许消费者订阅消息）和`publish()`（向所有订阅者发送新消息）。

`Flow`对象的发布方法是`emit()`，而订阅方法是`collect()`。

我们可以使用`flow()`函数创建一个新的流：

```kt
val numbersFlow: Flow<Int> = flow {
```

```kt
    ...
```

```kt
}
```

在`flow`构造函数内部，我们可以使用`emit()`函数向所有监听器发布新的值。

例如，这里我们创建了一个使用`flow`构造函数发布十个数字的流：

```kt
flow {
```

```kt
    (0..10).forEach {
```

```kt
        println("Sending $it")
```

```kt
        emit(it)
```

```kt
    }
```

```kt
}
```

现在我们已经介绍了如何发布消息，让我们讨论如何订阅流。

为了做到这一点，我们可以使用`flow`对象上可用的`collect()`函数：

```kt
numbersFlow.collect { number ->
```

```kt
    println("Listener received $number")
```

```kt
}
```

如果现在运行此代码，您会看到监听器打印出它从流中接收到的所有数字。

与一些其他响应式框架和库不同，没有特殊的语法来向监听器抛出异常。相反，我们可以简单地使用标准的`throw`表达式来完成这个操作：

```kt
flow {
```

```kt
    (1..10).forEach {
```

```kt
    ...
```

```kt
        if (it == 9) {
```

```kt
            throw RuntimeException()
```

```kt
        }
```

```kt
    }
```

```kt
}
```

从监听器方面来看，处理异常就像将`collect()`函数包裹在`try`/`catch`块中一样简单：

```kt
try {
```

```kt
    numbersFlow.collect { number ->
```

```kt
        println("Listenerreceived $number")
```

```kt
    }
```

```kt
}
```

```kt
catch (e: Exception) {
```

```kt
    println("Got an error")
```

```kt
}
```

与通道一样，Kotlin 的流是挂起的，但它们不是并发的。流支持背压，尽管这对用户来说是完全透明的。为了了解这意味着什么，让我们为同一个流创建多个订阅者：

```kt
(1..4).forEach { coroutineId ->
```

```kt
    delay(5000)
```

```kt
    launch(Dispatchers.Default) {
```

```kt
        numbersFlow.collect { number -> 
```

```kt
            delay(1000)
```

```kt
            println("Coroutine $coroutineId received 
```

```kt
              $number") 
```

```kt
        }
```

```kt
    }
```

```kt
}
```

每个订阅者都在自己的协程中运行，每个新订阅之间有五秒的延迟。这允许我们看到它们并发运行。

现在，让我们看看输出结果：

```kt
> ...
```

```kt
> Sending 1
```

```kt
> Coroutine 1 received 5
```

```kt
> Sending 6
```

```kt
> Coroutine 2 received 1
```

```kt
> Sending 2
```

```kt
> Coroutine 1 received 6
```

```kt
> ...
```

从这个输出中，我们可以学习两个重要的教训：

+   `1`。

+   **流使用背压**：请注意，下一个数字只有在接收到前一个数字之后才会发送。这与未缓冲通道的行为相似，与缓冲通道不同，在缓冲通道中，生产者可以比消费者更快地发送数字。

接下来，让我们看看这些流的两个属性如何被修改（如果需要的话）。

### 缓冲流

在某些情况下，例如，当我们有足够的可用内存时，我们并不急于对生产者应用背压。为了做到这一点，每个消费者都可以指定使用`buffer()`函数来缓冲流程：

```kt
numbersFlow.buffer().collect { number ->
```

```kt
    delay(1000)
```

```kt
    println("Coroutine $coroutineId received $number")
```

```kt
}
```

如果我们再次查看上述代码的输出，我们会看到显著的变化：

```kt
> ...
```

```kt
> Sending 8
```

```kt
> Sending 9
```

```kt
> Sending 10
```

```kt
> Coroutine 1 received 1
```

```kt
> Coroutine 1 received 2
```

```kt
> ...
```

使用缓冲区，流程在缓冲区填满之前不会受到消费者任何背压的影响。然后，消费者仍然能够以自己的节奏收集值。这种行为类似于缓冲通道，实际上，实现使用了一个底层的通道。

缓冲流程在处理每条消息需要相当多的时间时非常有用。以从手机上传图片为例。当然，上传所需的时间会根据图片的大小而有所不同。你不想在上传图片之前阻止用户界面，因为这会是一个糟糕的用户体验，并且违反了响应式原则。

相反，你可以定义一个适合内存的缓冲区，以自己的节奏上传图片，并且只有在缓冲区充满任务时才阻止用户界面。

在图片的情况下，我们处理的是一系列我们不希望丢失的元素。所以，让我们考虑一个不同的例子，在这个例子中，我们可以允许在我们的流程中丢弃一些元素。

### 合并流程

想象一下，我们有一个以每秒十次的速度产生股价变化的流程，并且我们有一个需要显示最新股价的 UI。为此，我们只需使用一个每次滴答上升 1 的数字：

```kt
val stock: Flow<Int> = flow {
```

```kt
    var i = 0
```

```kt
    while (true) {
```

```kt
        emit(++i)
```

```kt
        delay(100)
```

```kt
    }
```

```kt
}
```

然而，UI 本身不需要每秒刷新十次。每秒一次就足够了。如果我们简单地尝试使用`collect()`，就像前面的例子一样，我们将会不断落后于生产者：

```kt
var seconds = 0
```

```kt
stock.collect { number ->
```

```kt
    delay(1000)
```

```kt
    seconds++
```

```kt
    println("$seconds seconds -> received $number")
```

```kt
}
```

上述代码输出以下内容：

```kt
> 1 seconds -> received 1
```

```kt
> 2 seconds -> received 2
```

```kt
> 3 seconds -> received 3
```

```kt
> ...
```

上述输出是不正确的。原因是我们对流程应用了背压，使其减慢。另一个选择是缓冲 10 个值，就像我们在前面的例子中看到的那样。但因为我们希望 UI 的刷新速度比流程本身快十倍，所以我们将不得不丢弃十个值中的九个。我们将把这个逻辑的实现留给读者去尝试。

一个更好的解决方案是*合并*流程。合并流程不会存储所有消息。相反，它只保留最新的值。我们在以下代码中实现了这一点：

```kt
stock.conflate().collect { number ->
```

```kt
    delay(1000)
```

```kt
    seconds++
```

```kt
    println("$seconds seconds -> received $number")
```

```kt
}
```

让我们先看看输出：

```kt
> ...
```

```kt
> 4 seconds -> received 30
```

```kt
> 5 seconds -> received 40
```

```kt
> 6 seconds -> received 49
```

```kt
> ...
```

你可以看到现在值是正确的。平均来说，我们的计数器每秒增加十次。

现在，我们的流程将永远不会中断，并且订阅者将只接收到流程计算出的最新值。

# 摘要

本章致力于练习使用响应式原则进行函数式编程，并学习 Kotlin 中函数式编程的构建块。我们还了解了响应式系统的主要好处。例如，这样的系统应该是响应的、弹性的、可伸缩的，并由消息驱动。

现在，你应该知道如何转换你的数据，过滤你的集合，并找到满足你标准的集合中的元素。

你也应该更好地理解冷流和热流的区别。冷流，例如*流*，只有当有人订阅它时才开始工作。新订阅者通常会接收到所有的事件。另一方面，热流，例如*通道*，会持续发出事件，即使没有人监听它们。新订阅者只会接收到订阅后发送的事件。

我们还讨论了背压的概念，这可以在流中实现。例如，如果消费者无法处理所有的事件，它可能会暂停生产者，缓冲事件以期望赶上，或者合并流，只处理一些事件。

下一章将介绍并发设计模式，这些模式允许我们以可扩展、可维护和可扩展的方式使用协程和响应式流作为构建块来构建并发系统。

# 问题

1.  集合上的高阶函数与并发数据结构上的高阶函数有什么区别？

1.  冷流和热流数据有什么区别？

1.  何时应该使用合并的通道或流？
