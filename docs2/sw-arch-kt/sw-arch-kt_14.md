

# 第十四章：安全

本章涵盖了与系统安全相关的根本原则和实践，重点关注影响软件架构和工程师日常生活的方面。

它首先定义了关键概念，如**机密性**、**完整性**和**可用性**（**CIA**三要素），这些构成了安全策略的基石。本章概述了几种威胁类型，包括恶意软件、钓鱼和内部攻击，强调了进行全面风险评估和管理的重要性。

接下来，它探讨了各种认证方面及其如何影响软件功能的工程设计，例如**多因素认证**（**MFA**）。然后，我们将讨论如何使用访问控制确保只有授权用户可以访问特定资源。

此外，本章还讨论了遵守法律和监管要求，如**通用数据保护条例**（**GDPR**）和**健康保险可携带性和问责法案**（**HIPAA**），并塑造安全实践。此外，我们将探讨一些处理系统中机密数据的方法。

我们将深入探讨网络安全如何塑造软件架构，例如安全层、加密和安全的 API 设计，这些设计可以保护系统免受恶意攻击。

最后，我们将通过一个真实案例进行威胁建模练习。

我们将涵盖以下主题：

+   认证

+   授权

+   处理敏感数据

+   网络安全

+   DevSecOps 和威胁建模

# 技术要求

您可以在 GitHub 上找到本章使用的所有代码文件：[`github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-14`](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-14)

# 软件架构中安全的重要性

**系统安全**指的是实施的过程、措施和实践，旨在保护信息系统免受未经授权的访问、滥用、损害或中断。它包括一系列旨在保护系统内数据和资源机密性、完整性和可用性的机制。

系统安全包括多个维度，包括硬件、软件、政策和人为因素，以对抗恶意威胁和漏洞。

软件系统通常处理敏感信息。敏感数据可以分成几个类别：

+   **个人身份信息（PII）**：全名、出生日期、地址、电话号码和个人电子邮件地址

+   **个人信息**：健康保险政策、医疗检测结果、治疗记录、处方、教育证书、成绩单、大学成绩和学号

+   **认证凭证**：密码、PIN 码、安全问题和答案以及指纹

+   **财务信息**：银行账户详情、信用卡号码、税务申报、财务报表和收入信息

+   **机密商业信息**：客户名单、商业计划、商业机密和内部通讯

+   **法律文件**：合同、诉讼文件和和解协议

+   **知识产权**：版权、专利、商标、源代码、用户活动历史、系统数据和专有算法

+   **政府和国家安全信息**：政府合同、情报报告和机密文件

确保软件架构的安全性可以保护敏感数据免受未经授权的访问、泄露和破坏，维护机密性和隐私。

安全措施在整个数据生命周期中保护数据的完整性，防止未经授权的修改。这可以保证用户接收到的信息准确可靠，这对于决策和信任至关重要。

一个安全的软件架构旨在抵御恶意攻击，并确保合法用户能够获得服务。这对于维持业务连续性、建立积极的声誉、培养用户满意度和信任以及提供竞争优势至关重要。

许多行业都受到关于数据保护和隐私的法规的约束，例如欧盟的 GDPR 和美国 HIPAA。符合这些法规的软件架构可以保护组织免受法律处罚和声誉损害。

安全应成为软件架构设计早期阶段的一部分。设计过程包括识别潜在威胁和漏洞。积极应对安全风险可以减少从第一天开始的安全事件发生的可能性。在发生漏洞之前实施安全措施也比之后更经济有效。与法律费用、补救措施和业务损失相关的财务损失可能非常巨大。

安全威胁不断演变，一个精心设计的软件架构能够灵活地融入新的安全技术和实践。这种适应性和可扩展性对于保持对潜在漏洞的领先地位和维持强大的安全态势至关重要。

以安全为重点的架构鼓励将安全编码实践整合到软件开发周期中，例如**DevSecOps**。这种文化转变增强了开发团队的整体安全意识。

一个安全系统依赖于日志记录、监控和警报机制，这些机制有助于快速检测和响应安全事件，正如在*第十一章*中讨论的那样。这对于减少损害和有效恢复漏洞至关重要。

通过从一开始就优先考虑安全性，组织可以构建具有弹性的系统，这些系统能够不仅防御当前威胁，还能适应未来挑战，从而培养信任并增强其整体商业成功。安全性的最被讨论的基础之一是 CIA 三要素，我们将在下一部分介绍。

# CIA 三要素

**CIA 三要素**是信息安全的基础模型，概述了信息安全三个核心原则：**机密性**、**完整性**和**可用性**。它最初在 1972 年的《计算机安全技术规划研究》中提及，也称为**安德森报告**，由威廉·安德森领导的团队撰写。该概念随后在 20 世纪 80 年代由弗雷德里克·科恩在其著作《计算机安全实践者的方法》中讨论。术语**CIA 三要素**后来由史蒂夫·利普纳在 1986 年左右提出。CIA 三要素在 1993 年由威利斯·沃尔从其在美国智库**研究与开发公司**（**RAND**）分发的研究中推广。从那时起，它在网络安全领域获得了普及。

CIA 三要素如图*14.1*所示：

![图 14.1 – CIA 三要素](img/B21737_14_1.jpg)

图 14.1 – CIA 三要素

我们将在以下部分简要介绍每个原则。

## 机密性

**机密性**确保敏感信息仅对授权的个人或系统可访问。这包括将数据远离具有恶意意图的恶意行为者。组织内的个人也受到数据访问的限制。

维护机密性的常见方法包括以下内容：

+   **身份验证**：确认用户、设备或系统的身份。主要目标是确保试图访问系统的实体是其声明的身份。

+   **授权**：授予或拒绝已验证身份对系统内特定资源、操作或数据的访问权限。

+   **加密**：将可读数据转换为编码数据以防止未经授权的访问。即使未经授权的个人获得了加密数据，他们也需要拥有密钥并知道解密算法才能解锁数据。

+   **编辑**：在不暴露敏感信息的情况下保留功能性和可用性。

其中一些方法将在接下来的部分中使用和讨论。

## 完整性

**完整性**指的是数据在其整个生命周期中的准确性和一致性。这一原则确保信息不会被未经授权的用户更改或篡改，并且保持准确、可靠和可信。

确保完整性的常见技术包括以下内容：

+   **校验和与哈希函数**：通过算法从数据计算出的固定长度字符串。校验和或哈希值通常与数据本身一起提供。任何对数据的篡改都会产生与原始校验和不同的校验和（或哈希值），因此系统会将其检测为损坏的数据。

+   **数字签名**：文档由发送者使用其私钥生成的哈希值进行签名。接收者收到文档及其数字签名。接收者使用相同的算法计算文档的哈希值。接收者使用发送者的公钥解密数字签名并检索原始哈希值。两个哈希值相同确认文档未被修改。发送者的私钥和公钥形成一对，其中私钥仅发送者知道，公钥对任何人都是可用的。

+   **版本控制**：版本控制系统维护对文档所做的更改的完整审计跟踪和历史记录。如果检测到错误或损坏，可以将文档回滚到先前的版本。

## 可用性

**可用性**确保在需要时信息资源对授权用户是可访问的。这一原则侧重于保持系统功能并最小化由于攻击、故障或其他中断造成的停机时间。

提高可用性的策略包括以下内容：

+   **冗余**：通过拥有额外的组件和替代路径来避免单点故障，以确保在发生故障时持续运行和保持数据完整性。

+   **负载均衡**：将传入流量分配到多个服务器，以确保处理传入请求。

+   **定期备份**：在多个服务器或位置维护数据库、文件存储和消息存储的副本，以确保数据可用性并从数据问题中恢复。

+   **灾难恢复计划和演练**：概述在灾难期间采取的具体步骤以恢复系统并使其运行。定期进行灾难恢复演练以验证计划并识别差距。在灾难期间建立清晰的沟通渠道，以保持工程师和利益相关者的信息。

## 重要性：CIA 三角模型

CIA 三边模型作为组织发展和实施有效安全政策和实践的指导框架。这三个原则帮助组织创建一个全面的信息安全方法，并保护业务免受各种威胁和漏洞的侵害。

我们将深入探讨基于 CIA 三边模型的选择性主题。

# 认证

**认证**是在授予资源访问权限之前验证用户或设备身份的过程。这是建立双方之间信任的第一步。一个简化的认证过程看起来像 *图 14.2*：

![图 14.2 – 认证交互的简化表示](img/B21737_14_2.jpg)

图 14.2 – 认证交互的简化表示

客户端（用户、设备或系统）与目标系统启动认证，并提供凭证以声明其身份。系统接收凭证并开始验证过程。如果系统能够识别客户端，则确认结果为阳性，否则将向实体发送拒绝。

这种交互仅仅是概念性的，因为实际的认证需要考虑很多方面。首先，传输层需要被保护以确保没有窃听，也称为**中间人攻击**（**MitM**）。

MitM 攻击

中间人攻击是一种网络攻击，攻击者秘密地拦截并转发两个当事人之间的通信。攻击者窃听并捕获可能包含敏感信息的通信。攻击可能会更改交换的消息或记录它们以进行进一步的恶意目的，例如身份盗窃和金融欺诈。中间人攻击可以以各种形式发生，例如拦截未加密的 Wi-Fi 流量、利用安全通信中的漏洞或诱骗用户连接到恶意网络。这种攻击威胁到个人和组织之间通信的机密性和完整性。

## 传输层安全（TLS）

**传输层安全**（**TLS**）在网络通信安全中发挥着重要作用，作为对如我们刚才提到的中间人攻击等威胁的防御。

TLS 是从其前身**安全套接字层**（**SSL**）演变而来的。SSL 最初由 Netscape 于 1994 年开发，旨在提供互联网上的安全通信协议。由于安全漏洞，它从未发布。随后，发布了 SSL 2.0 和 SSL 3.0，但它们仍然面临着需要进一步发展的漏洞。

TLS 首次于 1999 年发布。它基于 SSL 3.0，但解决了 SSL 的弱点，并提供了对现代加密算法的更好支持。TLS 的后续版本在安全性和性能方面带来了重大改进。TLS 广泛用于各种方式，以在互联网上确保通信安全，例如安全网页浏览、电子邮件内容加密、安全消息、**虚拟私人网络**（**VPNs**）和安全的系统间通信。

TLS 要求客户端和服务器交换几轮消息以建立安全的传输通信。TLS 建立在**传输控制协议**（**TCP**）之上。最初的几个步骤是交换消息以建立 TCP 连接。之后，有几轮消息交换以建立 TLS 通信：

1.  **客户端问候**：客户端通过向服务器发送一条消息来启动 TLS，该消息指定了支持的 TLS 版本、密码套件（称为加密算法）以及客户端生成的随机数。

1.  **服务器问候**：服务器通过选择 TLS 版本和密码套件以及服务器生成的随机数来响应。

1.  **服务器证书**：服务器发送其包含服务器公钥并由受信任的**证书机构**（**CA**）签名的 TLS 证书。某些加密套件要求服务器包含额外的密钥交换参数。

CA

CA 是一个受信任的实体，它向个人、组织或设备颁发数字证书，以验证在安全通信框架内的身份。CA 通过将公钥绑定到其所有者的身份，在**公钥基础设施**（**PKI**）中扮演着至关重要的角色，使 TLS/SSL 等安全协议能够进行加密通信。它们在颁发证书之前进行身份验证，通过根证书和中间证书维护信任链，并管理证书吊销以确保持续的安全性。通过提供这个信任基础，CA 使用户能够自信地在互联网上进行通信和交易。

1.  **服务器握手完成**：服务器确认其握手部分的完成。

1.  **客户端密钥交换**：客户端生成一个预主密钥，这是一个没有有意义数据的随机字符串，使用从服务器证书中接收到的服务器公钥对其进行加密，并将其发送到服务器。

1.  **会话密钥生成**：客户端和服务器使用预主密钥以及之前交换的随机数来生成会话密钥。这些密钥将用于会话期间的数据加密。

1.  `Finished`消息，表示握手已完成，他们现在将开始使用会话密钥进行安全通信。

交互过程如图*14**.3*所示：

![图 14.3 – TLS 握手](img/B21737_14_3.jpg)

图 14.3 – TLS 握手

在 TLS 握手过程中，客户端和服务器独立生成仅适用于该会话的会话密钥。任何会话外的消息重放都是无效的，并且将被检测到。会话密钥永远不会存在于交换的消息中。

此外，如果中间人攻击者想要解密应用程序数据的内容，它需要对称的会话密钥。会话密钥是由双方生成的随机数和预主密钥形成的。预主密钥只能由服务器的私钥解密，该私钥永远不会在任何消息中暴露。换句话说，中间人攻击者无法读取加密的应用程序数据。

此外，每个交换的消息都包含一个序列号。任何顺序错误的消息都将被检测到，并且不会进一步处理。每个消息还包含一个**消息认证码**（**MAC**），它就像一个校验和，用于确认数据在传输过程中是否被更改。

TLS 使用受信任的 CA 颁发的数字证书来验证服务器的身份。这防止了中间人攻击，其中攻击者冒充服务器。在双向 TLS 的情况下，客户端也可以出示证书以证明其身份，从而进一步增强安全性。

在这一点上，我们相信我们已经在客户端和服务器之间建立了安全的传输。然而，我们仍然需要验证客户端的身份以授权资源和允许的操作。我们将在下一节进一步讨论如何验证客户端。

## 多因素认证（MFA）

简单的身份验证只需要一个这样的证据（称为因素），通常是密码。这种方法有几个弱点，使其不足以保护敏感信息：

+   **弱密码**：容易被攻击者猜到

+   **钓鱼攻击**：攻击者诱骗用户泄露他们的密码（例如，伪造的登录页面）

+   **密码重用**：如果一个密码被泄露，攻击者可以使用相同的密码访问其他服务

+   **暴力破解**：自动化工具可以不断猜测一个密码

+   **社会工程学**：操纵用户共享密码

+   **无用户验证**：密码验证仅检查提供的凭据是否与记录中的凭据相同，而不是验证试图获取访问权限的人是否是实际用户

多因素认证旨在通过验证多个因素来强化身份验证过程，进一步验证用户是他们所声称的人。这些因素分为三个类别：

+   **知识因素**：密码、安全问题和答案、PIN 码或 ID

+   **持有因素**：智能手机、硬件令牌、身份验证应用程序和一次性密码

+   **生物识别因素**：指纹、面部和声音

至少，多因素认证需要来自不同类别的至少两个因素。攻击者从目标用户那里获取多个因素的可能性较小，因此它降低了未经授权访问的风险。此外，一些行业，如银行，有监管要求强制使用多因素认证来保护敏感数据。

值得指出的是，多因素认证不必要地需要 TLS，但强烈建议使用 TLS 进行多因素认证，以确保在多因素认证过程中没有窃听和拦截，尤其是在传输敏感信息（如生物识别数据和密码）时。

## 多因素认证对软件架构的影响

多因素认证（MFA）在日常生活中的普及，例如在线银行和电子商务，已经影响了现代软件架构。迫切需要专门的服务来专注于身份验证并从业务逻辑中分离出来。这是由于身份验证过程的高度复杂性和处理数据的敏感性。最好有一个专门从事身份验证的服务，将敏感数据保持在其边界范围内以降低风险。

与第六章中讨论的无服务器云计算的兴起一起，每个在云中运行其服务的组织都必须选择以下之一：

+   云提供商原生的 **身份提供者**（**IdP**）（例如，Azure 的 Active Directory，GCP 的 Google Identity，AWS 的 Cognito）

+   平台独立的 IdP，例如 Okta，Auth0 和 Duo Security

+   编写自己的 **身份和访问管理**（**IAM**）服务，可选地作为其他 IdP 的代理

+   无需认证

现在，很少看到系统跳过认证。有一些情况，例如公共网站、匿名调查以及低风险功能，如计算器，可能不需要认证。

根据组织的需要构建一个定制的 IAM 服务可能是合理的。除非组织本身专门从事安全解决方案，否则 IAM 服务属于通用的子域，如第 *第八章* 中所述。大多数第三方 IdP 提供了组织所需的足够认证能力。如果有任何特定于组织的理由，建议构建一个 IAM 服务作为第三方 IdP 的代理。如果第三方 IdP 提供了目前定制的全新功能，这种方法可以最小化功能迁移的影响。

### MFA 的示例交互

假设用户想要登录系统以从智能设备上的应用程序请求操作，消息交换可能看起来像 *图 14*。4：

![图 14.4 – 带有 MFA 的示例业务请求](img/B21737_14_4.jpg)

图 14.4 – 带有 MFA 的示例业务请求

这只是一个示例交互，因为通信因不同的 IdP 和认证中涉及的不同因素而异。在这个示例中，IdP 为组织提供了一个定制的白色标签页面。

白色标签页面

**白色标签页面**是一个可定制的网页或应用程序，可以被重新品牌化并由不同的组织使用。屏幕针对目标组织进行了主题设计，并隐藏了原始组织的品牌。这对于 SaaS 产品来说是一个常见功能，允许与任何组织无缝集成，同时保持一致的用户体验。

用户登录并使用 HTTPS over TLS 提供用户名和密码。用户名和密码由冒号连接成字符串：

```java
username:password
```

字符串随后被编码为 Base64 并作为 **HTTP 基本认证**的一部分传递到 HTTP 标头。由于它是 HTTPS，因此标头也是加密的。登录请求等同于以下命令：

```java
curl -i http://api.example.com/api/sign-in \
  -H "Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ="
```

这些数据构成了认证的知识因素。

IdP 确认用户名和密码确实存在且匹配，然后向客户端发出一个 **一次性密码**（**OTP**）的挑战。OTP 然后通过 **短信服务**（**SMS**）发送到用户的手机号码。拥有手机的用户会收到 OTP 并输入密码。密码从客户端发送到 IdP 以解决挑战。这是认证的占有因素。

身份提供者（IdP）验证 OTP 是否正确。如果错误，IdP 会向客户端响应并透露身份验证失败。如果正确，IdP 会生成一个**JSON Web Token**（**JWT**）作为访问令牌并发送给客户端作为响应。随后，IdP 还会通过 webhook 通知服务器用户已成功通过身份验证。

**JWT**是一个加密的 JSON 字符串，用于携带关于用户角色和权限的声明。它由三部分组成：

+   **标题**: 令牌的类型为“JWT”以及用于加密令牌的算法。

+   **有效载荷**: 注册的声明，如发行者、受众、过期时间和 ID。还包含公共声明，如应用程序用户角色，以及仅用于使用令牌的各方之间共享的私有声明。

+   **签名**: 发送者身份的证明以及整个 JSON 字符串未被修改的证据。

身份验证成功响应还会触发屏幕重定向到用户登录页面，以便用户开始进行业务请求。

经身份验证的用户发起业务请求。客户端将带有附加到 HTTP 头部的访问令牌作为`Bearer`令牌发送请求到服务器：

```java
curl -i http://api.example.com/api/business-request \
  -H "Authorization: Bearer mytoken123"
```

服务器从客户端接收请求以及`Bearer`令牌。服务器与身份提供者（IdP）验证令牌是否有效。身份提供者（IdP）确认令牌有效，因此服务器处理请求并向客户端响应。

客户端可以继续使用`Bearer`令牌进行其他操作，无需进一步身份验证，直到会话结束。在整个会话期间，身份提供者（IdP）控制令牌的有效性。根据请求，令牌也可以由身份提供者（IdP）刷新。

令牌交换和刷新流程是行业标准授权协议的一部分，**OAuth** ([`oauth.net/2/`](https://oauth.net/2/))。

OAuth

**OAuth**是一个授权框架，它允许第三方应用程序在不暴露凭证的情况下获取对资源的有限访问。用户通过各种授权类型（如授权代码、隐式和客户端凭证）从一种服务访问另一种服务的数据。用户向授权服务器提交身份验证请求，授权服务器随后为访问资源服务器上受保护的资源颁发访问令牌。OAuth 强调灵活性，并被广泛采用以实现现代应用程序中的安全委托访问。

此示例交互还允许使用`Bearer`令牌对使用相同身份提供者（IdP）的其他系统进行身份验证。由于用户已经通过身份提供者（IdP）进行了身份验证，因此使用相同身份提供者（IdP）的其他系统可以以相同的方式验证用户的身份。这种机制实现了**单点登录**（**SSO**）体验，用户只需进行一次身份验证即可访问共享相同身份提供者（IdP）的应用程序和系统集合。

### 步进式身份验证

有时，经过认证的用户需要执行超出其初始认证的额外验证。这一额外步骤被称为**提升认证**。

提升认证通常适用于故意选择的情况，当涉及访问敏感信息或高风险操作时，例如更新密码、进行银行转账或将账户数据移动到不熟悉的设备。

提升认证也可以根据访问请求的上下文动态应用，例如新的地理位置、新设备、新银行账户等。

最简单的提升认证方法是重复在 TLS 通信下相同的 MFA 过程。一些公司可能会故意增加更多的挑战，例如 CAPTCHA 或生物识别验证。

通过实施提升认证，组织可以显著降低未经授权访问的风险，同时保持低风险活动的无缝用户体验。

我们竭尽全力确保系统已验证进入系统的实体的身份。现在实体已登录系统，下一个问题是：实体可以在系统中访问和执行什么？我们将在下一节中探讨这个问题。

# 授权

**授权**决定了用户或实体可以访问哪些资源以及可以执行哪些操作。用户经过认证后，只能与明确授予权限的数据和功能进行交互。这限制了敏感信息只对系统已知并维护其完整性的个人。 

授权符合**最小权限原则**（**PoLP**），也称为**最小权限原则**（**PoMP**）或**最小权限原则**（**PoLA**）。PoLP 指出，用户、实体或系统应仅具有操作其功能所必需的权限。这最小化了风险并限制了可能来自意外或恶意行为（我们可能没有预料或了解）的潜在损害。

此外，有意识地授予特定资源和操作的权限可以提高问责制并符合安全策略。坚持已知信息可以促进更安全的感知。

正如我们简要提到的，授权有两个要素：数据和操作。它们在授权中是不同的概念，可以不同地管理：

+   **数据权限**：用户是否有权访问特定的数据或资源

+   **权限**：用户在资源或数据上允许执行的操作

例如，用户有权查看自己的用户账户。管理员角色的用户有权查看其他用户的账户。然而，用户必须首先被授予读取用户账户的权限。用户被授予写入权限以更新自己的用户账户。然而，管理员角色用户可能没有更新其他用户账户的写入权限。

实施授权有四种典型方法：

+   **基于角色的访问** **控制** （**RBAC**）

+   **基于属性的访问** **控制** （**ABAC**）

+   **访问控制** **列表** （**ACLs**）

+   **基于策略的访问** **控制** （**PBAC**）

我们将深入探讨这些方法。

## 基于角色的访问控制 (RBAC)

RBAC 方法将用户分配到角色，每个角色都分配了特定的权限。用户根据组织内分配的角色获得权限。这如图 *图 14**.5* 所示：

![图 14.5 – RBAC 的一个示例](img/B21737_14_5.jpg)

图 14.5 – RBAC 的一个示例

在前面的 RBAC 配置中，Alex 和 Taylor 被分配了 *客户服务支持* 角色，该角色被授予执行基本级别操作（如更新客户的订单）的权限。更高级的操作，如退款订单，只能由具有 *客户服务* *主管* 角色的人如 Sam 执行。

RBAC 在需要不同访问级别的不同工作职能的公司中普遍使用。它比逐个分配权限更有效。在员工休假而另一位员工临时接管职责，或新员工需要与队友相同级别的访问权限的情况下，它也很有效。

## 访问控制列表 (ACLs)

ACL 授予一组用户或用户组访问特定资源的权限，并定义允许哪些操作。这种方法适用于授予可以精确指定的资源权限，例如以下内容：

+   **文件系统**: 文件夹、读写操作和文件名

+   **HTTP 路径**: **统一资源标识符** （**URIs**） 和 HTTP 方法

+   **网络**: IP 地址、端口和传输层协议

+   **数据库**: 模式、表和操作

一些 ACLs 也支持通配符匹配，以实现更灵活的配置。这种方法适用于在细粒度级别管理资源权限。

## 基于策略的访问控制 (PBAC)

PBAC 基于预定义的策略授予权限，这些策略考虑了各种标准，例如用户角色、属性和上下文。

这些策略是预先定义的，但它们支持参数。它们通常由 GUI 工具管理或设置为声明性配置。授权工具本身可能是定制的，但策略的维护不需要代码更改。

策略可以是细粒度和高度可配置的。它们也可以在运行时更改，而无需部署或重启。在需要根据实时条件或合规性要求调整访问需求的环境中，它们非常有用。

PBAC 对于符合监管要求非常有效，因为定义良好的策略可以被视为合规政策的技术实现。

## 基于属性的访问控制（ABAC）

ABAC 授予与用户、资源和环境相关的属性权限。它提供了最灵活的方式来控制权限，这些权限可能对上下文敏感，例如时间和地理位置。

例如，只有客户服务主管可以更新完成的客户订单，但开放订单可以由客户服务支持和主管共同更新。

这种方法适用于复杂的环境，其中访问决策取决于多个、通常是动态的因素，例如用户属性（例如，部门、清查级别）、资源属性（例如，敏感性）、访问请求的时间、环境配置等。控制可以细粒度到所需的程度。

由于其高度灵活性，ABAC 通常被编写为代码而不是配置。其中一些 ABAC 策略甚至可能涉及权限继承的概念，无论是在用户级别还是资源级别。实现可能会变得复杂。

将 ABAC 编写为代码也带来了测试和维护的挑战。ABAC 代码中的错误可能导致资源泄露给未经授权的人员。

## 授权对软件架构的影响

授权对软件架构的影响有几个维度。微服务、纳米服务和 FaaS（如第六章所述*）本身需要访问基础设施资源，如数据库和文件系统。

如果它们经常在云提供商下运行，则 RBAC 和 ALCs 可以用于定义和限制组件可以访问哪些资源以及允许哪些操作。更常见的是，组织会使用云原生 IdP 来管理应用程序使用的基础设施权限和数据权益。

正如我们在讨论 PoLP 时提到的，应用程序应授予恰好足够的权限和数据权益来执行其操作，但不应更多。

如果需要将特定资源的写访问权限（例如，数据库模式）授予多个边界上下文，那么这可能是不明确或泄漏的边界上下文的迹象。对涉及的边界上下文进行架构审查将有助于了解需求并检查应用程序边界的改进是否可行。

最终用户、外部系统和其他设备需要访问基础设施和应用数据。有一些用例需要它们访问基础设施资源。

### 用例 – 提交报销请求和批准

在一个组织中，所有用户都有权提交报销请求以进行业务授权：“报销请求和批准”。财务操作团队负责审查这些请求并决定是否批准或拒绝请求。

在这个设置中，所有用户都有用户角色。该角色被授予访问以下端点的权限：

+   `POST /expense`：这是为了提交新的报销请求

+   `GET /expense/{id}`：这是为了查看给定 ID 的报销请求

一些用户被分配到财务操作角色。该角色被授予访问以下端点的权限：

+   `GET /expense/{id}`：这是为了查看给定 ID 的报销请求

+   `PATCH /expense/{id}/result`：这是为了批准或拒绝给定 ID 的报销请求

相应的权限控制可以使用 RBAC 和 ACL 进行配置。大多数身份提供者（IdP），包括云原生中间件，都可以支持此设置。

### 集中式或分布式授权逻辑？

工程师们经常问，当与应用程序数据相关时，授权逻辑应该是集中式还是分布式。

这不是一个简单的“是”或“否”的问题。它取决于授权逻辑的性质。在基本层面上，请求应用程序数据记录的用户应该被授予读取给定类型数据的权限。如果是 RBAC 或 ACL，有一个集中的服务来确认用户 X 可以读取类型为 Y 的应用程序数据是合理的。

或者，权限或角色可以作为 JWT 自定义声明的一部分进行编码。这种方法减少了处理权限所需的时间。然而，这也意味着授予的权限可能会持续到 JWT 过期，使得动态授权变得更加困难。

然而，当决定用户是否有权查看特定应用程序的数据时，事情变得复杂，这是关于用户 X 是否可以读取类型为 Y 和 ID 为 123 的应用程序数据的权益问题。回答这个问题通常需要特定领域的知识，这些知识应该保持在有限范围内，换句话说，是分布式的。

此外，对应用程序数据的其他操作意味着用户最初可以读取数据。权限、数据权益和业务逻辑的交织逻辑显著增加了操作复杂性。在与第三方 API 集成的情况下，数据授权分布在多个服务中，这更加复杂。

使用上一节中提到的报销请求和批准的相同示例，权限和数据权益业务流程的示例交互看起来像*图 14.6*中的图表：

![图 14.6 – 权限和数据权益业务流程的示例交互](img/B21737_14_6.jpg)

图 14.6 – 权限和数据权益业务流程的示例交互

担任财务操作角色的用户需要查看费用报销请求以决定是否批准或拒绝它。因此，客户端的第一个请求是按照给定的 ID 获取费用报销请求。

相应的服务，即费用服务，会对专门处理用户权限的授权服务进行同步调用，以检查给定用户是否有权限读取费用报销请求。

授权服务通过其角色解决用户的权限，并返回用户被授予的操作列表。费用服务接收被授予的操作列表，并且在此基础上，检查用户是否可以看到这个特定的费用报销请求。

可能存在特定领域的业务规则，例如，费用报销请求只能由同一地理管辖区的用户批准。费用服务还会进一步筛选可以对这笔费用报销请求执行哪些操作。例如，如果它已经被批准，那么批准或拒绝的操作将不再可用，这是由于业务逻辑，而不是由于权限。

结合权限和数据权益的结果，如果用户不允许查看费用报销请求，则向客户端返回 HTTP 状态码 403（禁止）。否则，返回 HTTP 状态码 200（OK），并附带用户在此费用报销请求上可用的操作列表的有效负载。

如果用户能否读取费用报销请求，这两个服务本可以只返回一个二进制答案。然而，返回一个授权操作列表允许该列表被填充到前端应用程序中。前端应用程序可以启用和禁用按钮，以给用户明确的预期。

费用报销请求在屏幕上展示给用户，用户已经决定批准。客户端发送一个`PATCH`请求来更新费用报销请求的结果。

费用服务会对授权服务进行同步调用，以检查给定用户是否有权限批准或拒绝费用报销请求。授权服务返回用户被授予的操作列表。费用服务进一步检查是否可以批准或拒绝这笔特定的费用报销请求。

如果费用报销请求已经被批准或拒绝，则向客户端返回 HTTP 状态码 403（禁止）。否则，费用服务更新费用报销请求的结果，并返回 HTTP 状态码 200（OK），同时附带更新后的费用报销请求的有效负载。

### 授权的扩展性问题

从这个示例交互中，我们可以预见授权服务会被频繁地同步调用。这引发了关于可扩展性的担忧。所有业务请求都需要授权，因此授权服务将承受所有面向业务的其他服务的总负载。

同时，本地缓存权限可能不可取，甚至是有风险的。建议通过设计高效且非冗余的 API 来保持对授权服务的请求简洁。考虑使用更小的有效负载大小，如二进制格式，也是值得考虑的。

扩展使用授权服务的任何面向业务的服务意味着也需要显著扩展授权服务。建议设置指标和监控，以了解每个 API 客户端对授权服务的使用情况，这样我们才能理解如果服务扩展以处理更多的请求，授权服务也需要相应地扩展。

在本章的这一部分，我们可以对用户进行身份验证，并使用允许的操作和可访问的资源列表对他们进行授权。在它们之上进行的业务操作会导致系统保留敏感数据。我们将在下一节探讨处理敏感数据的话题。

# 处理敏感数据

处理敏感数据需要仔细考虑和实施最佳实践，以确保其机密性、完整性、可用性和符合监管要求。在本节中，我们将探讨管理敏感数据的关键策略。

## 数据分类

我们在本章的开头讨论了哪些数据可以被识别为敏感数据。对于组织来说，明确分类和记录哪些字段是敏感的非常重要。至少有三种数据敏感度类别：

+   **机密**：仅指定人员或角色可以访问

+   **内部使用**：仅组织成员可以访问

+   **公开**：对所有可访问

文档应作为指南，供组织中的每个人，包括工程师，小心谨慎地处理。

## 传输中的数据

在 TLS 通信中传输的数据使用会话密钥加密。这确保了即使数据被拦截或未经授权访问，它仍然是不可读的。

### 如何防止意外记录敏感信息

然而，目前还不安全也不安全。无意中通过日志泄露敏感信息并不罕见：

+   请求、响应或消息的完整解密有效负载

+   递归包含敏感字段的聚合 Kotlin 对象

+   包含敏感字段的生成类的对象

+   包含敏感信息的故障排除或调试信息

+   敏感字段本身

这非常危险，因为相关的代码看起来无害，泄露通常是在事后发现的。有一些技术可以防止这种情况发生。

工程师采用的一种常见技术是重写 Kotlin 数据类的`toString`函数：

```java
data class UserAccount(
    val username: String,
    val password: String,
    val createdAt: Instant
) {
    override fun toString(): String {
        return "UserAccount(createdAt=$createdAt)"
    }
}
```

这种方法有效，但因为它需要编写大量的重写函数，所以不可扩展。作为替代，值包装器可以有效地工作，如下所示：

```java
data class Secret<T> (val value: T) {
    override fun toString(): String = "*"
}
```

`Secret`包装类作用于类或字段。`toString`重写函数也很简单。

此外，还有一些开源库旨在用最少的代码解决这个问题。例如，Redacted 编译器插件([`github.com/ZacSweers/redacted-compiler-plugin`](https://github.com/ZacSweers/redacted-compiler-plugin))允许工程师注解字段或类以进行红字，因此当调用`toString`时，值会被屏蔽。设置也很简单：

1.  设置的第一步是其 Gradle 插件：

    ```java
    plugins {
        id("dev.zacsweers.redacted") version "1.10.0"
    }
    ```

1.  其次，定义一个自定义的`Redacted`注解类：

    ```java
    @Retention(AnnotationRetention.SOURCE)
    @Target(AnnotationTarget.PROPERTY, AnnotationTarget.CLASS)
    annotation class Redacted
    ```

1.  然后，配置插件以使用此注解，并在`build.gradle.kts`中配置屏蔽字符：

    ```java
    redacted {
        redactedAnnotation = "redacted/Redacted"
        replacementString = "*"
    }
    ```

我们有以下用`Redacted`注解的数据类：

```java
@Redacted
data class BankAccount(
    val iban: String,
    val bic: String,
    val holderName: String
)
data class UserAccount(
    @Redacted val username: String,
    @Redacted val password: String,
    val createdAt: Instant
)
```

我们为每个类创建一个对象，并在主函数中将它们打印到控制台：

fun main() {

```java
    println("${BankAccount("Iban", "bic", "holderName")}")
    println("${UserAccount("username", "password", LocalDate.now())}")
    println(
        "Secret wrapper: ${Secret("email@address.com")}"
    )
}
```

我们有以下结果：

```java
BankAccount(*)
UserAccount(username=*, password=*, createdAt=2024-10-09)
Secret wrapper: *
```

因此，敏感信息作为`toString`函数结果的一部分被屏蔽。然而，如果程序使用带有此编译器插件的 IDE 运行，则不会屏蔽值。如果从命令行或 Gradle 任务执行程序，则显示屏蔽的值。

有一些替代方法使用反射作为红字或隐藏敏感字段的手段。由于使用反射的开销，它们不建议使用。编译时红字是最高效的方法。

对于生成的类的负载和对象，一个防止敏感信息泄露的合理方式是在生产环境中避免记录它们。

## 静态数据

静态数据指的是存储在设备、文件系统、数据库和云环境中的数据。在基础设施中坐着的通常由 MFA、RBAC 和 ALCs 保护，如前几节所述。然而，对于敏感信息，需要采取额外的步骤。

### 加密

敏感数据需要以加密状态存储；差异在于*如何*。以下是常见的技巧：

+   **加密数据库**：数据库中存储的所有数据都以加密和不可读的格式存储。数据在检索时自动解密，无需应用代码。这些数据库通常支持授权，以确保只有授权用户才能与加密数据交互。它们还天生支持加密密钥的生成、存储和轮换，以提供额外的安全性。一些数据库还支持在数据进出数据库时进行加密。然而，对所有数据进行加密和解密，无论敏感与否，都会增加延迟。

+   **加密字段**：只有被标识为敏感数据的字段才会被加密。这种方法适用于所有类型的存储，如数据库列、消息基础设施中的事件和文件。与加密数据库相比，这种方法具有更小的性能开销。然而，在字段级别执行意味着应用程序需要处理加密数据库自动处理的方面，如下所示：

    +   加密和解密算法

    +   对称或非对称加密密钥

    +   密钥生成和密钥管理

    +   密钥轮换和重新加密

+   **混合**：由于加密数据库的性能开销以及处理应用程序代码中加密的额外工作，可能有必要采用混合方法，其中仅将敏感数据存储在加密数据库中，其余数据则保存在任何类型的存储中。

+   **加密备份**：敏感数据应定期以加密格式备份，以确保在数据丢失或泄露的情况下可以安全地恢复数据。

## 数据保留和匿名化

地方当局和法规对数据应保留多长时间有明确的指导方针，包括敏感数据。在保留期内，组织有责任确保它们的安全和保密。保留期过后，敏感数据可以被删除。

此外，还有一些法规（例如，GDPR）规定个人有权要求从系统中删除隐私数据。

然而，单独删除敏感数据可能会出现一些复杂情况。其中一些数据具有引用约束，并包含有用的业务洞察，这些洞察不需要识别个人。

有几种技术可以使敏感数据匿名化，并使其不再敏感：

+   `anonymized@data.com`)

+   **泛化**：降低敏感值的精度，以便无法识别特定个人或记录（例如，将出生日期缩减到出生月份，地址裁剪到城市等）。

+   **聚合**：将数据汇总成统计数据，以便没有针对个人或记录的引用。

+   **丢失解密密钥**：删除解密密钥，以便无法追踪数据到个人。

+   **定期匿名化**：积极扫描已过保留期的数据，并将其匿名化。

+   **断链**：一个预先设计的数据库模式，将敏感数据和非敏感数据分别存储在不同的表中，且没有任何表引用敏感数据表。这些敏感数据记录可以随时删除而不会出现问题（参见*图* *14**.7*）。

![图 14.7 – 敏感和非敏感数据的分离以实现匿名化](img/B21737_14_7.jpg)

图 14.7 – 敏感和非敏感数据的分离以实现匿名化

用户记录表有一个主键用户 ID，该字段可以被其他表用作参考。敏感个人信息记录表仅是一个补充表，仅保留 PII 字段。

积极使用这些技术有助于组织管理敏感数据，并保护其免受未经授权的访问和潜在的安全漏洞。它们有助于与客户建立信任并符合监管要求。

接下来，我们将简要介绍一些确保网络安全的实践。

# 网络安全

在本章前面，我们讨论了 TLS 的工作原理以及它是如何防止网络通信窃听的。然而，还有其他不需要渗透认证和授权过程的恶意攻击。

例如，**分布式拒绝服务**（**DDoS**）是一种网络攻击类型，其中系统被多个源系统（通常为机器人或自动化脚本）所淹没，以至于合法用户无法访问系统。攻击会生成大量流量以饱和和耗尽系统的资源，如 CPU、内存和网络。

以下是一些关键策略，用于保护系统免受这些网络级攻击。

## 网络应用防火墙（WAF）

**网络应用防火墙**（**WAF**）是一种专门用于保护互联网上系统的安全解决方案。WAF 可以在云中、数据中心中运行，或两者兼而有之，作为互联网流量到达系统内部更深层次之前的前端。它提供了一些关键功能：

+   **地理封锁和 IP 黑名单**：阻止来自和前往与恶意活动相关的 IP 地址列表的流量，并阻止来自某些地理区域的流量。

+   **速率限制**：防止服务器请求的数量达到配置的持续时间阈值。

+   **防止外部脚本执行**：防止攻击者执行不属于系统的脚本，例如未经授权的数据库命令、来自网页的**跨站脚本**（**XSS**）和特洛伊木马。

+   **基于策略或基于规则的访问策略**：高度可配置和可定制的规则，以在细粒度级别设置每个应用程序的需求。

+   **频繁更新**：WAF 频繁更新以适应不断变化的网络安全威胁环境。WAF 解决了**开放网络应用安全项目**（**OWASP**）Top 10 中概述的漏洞，该漏洞定期更新。

开放网络应用安全项目（OWASP）

OWASP 是一个开源项目，其使命是使软件安全对工程师和组织可见和可访问。它是一个全球性的工程师、安全专家和组织社区，致力于提供免费工具和知识，以增强数字环境的安全性。OWASP Top 10 是全球公认的十大最关键安全风险列表。该列表定期更新，以反映安全威胁的发展。

WAF 是全面网络安全策略的关键部分，为 Web 应用提供对各种攻击的基本保护。对持续存在担忧的组织应该拥有 WAF。基于云的系统可以选择来自本地云提供商的 WAF，或者选择可以在云中运行的 WAF。WAF 帮助组织保护其应用，保护敏感数据，并保持符合安全标准。

## **流量路由和网络分段**

与流量黑名单和阻止相反，应该有明确的流量路由，作为 API 网关或代理到应用的接口。明确的配置充当了外部世界允许的流量路由的白名单，有助于符合 PoLP。

明确配置的流量路由允许应用以下功能：

+   **分布式跟踪**：将作为整体流通过多个组件传递的请求链接起来

+   **指标**：收集如数据包丢失、响应时间、连接时间和错误率等指标

+   **重试**：允许应用程序在面临间歇性故障时重试操作

+   **断路器**：不允许应用程序重复执行失败的操作

+   **速率限制**：与 WAF 的功能重叠，限制一定时间内的请求数量

到目前为止，我们在这里讨论的交通路由都是针对入站流量，即从外部世界到内部应用的流量。出站流量，即从内部应用到外部世界的流量，同样重要。例如，攻击者可能已经安装了木马，悄无声息地将敏感数据传输到未知的目的地。这可以通过路由器、网络交换机、网络 ACL 和 WAF 配置来实现。云服务提供商也提供通过规则和政策管理入站和出站路由的服务。

**服务网格**是另一种配置和控制网络通信的方法，但它专注于服务间的通信。它提供了一个专门的底层基础设施，定义了服务之间如何通信，确保服务之间的所有路由都是明确定义的。除了 HTTP 请求路由外，服务网格还可以扩展到其他类型的传输，如消息传递、文件和数据库。它自动检测并注册服务的新实例，因此工程师可以专注于业务逻辑而不是网络通信。服务网格通常使用**边车模式**，其中在后台服务旁边部署了一个代理，代理拦截服务的所有入站和出站流量。

**边车模式**

**边车模式**是一种架构设计方法，其中部署了一个称为边车的辅助服务，以扩展主要服务的功能，但与其代码库解耦。这个边车通常在同一个容器或虚拟机中运行。边车处理跨切面关注点，如日志记录、监控、安全和通信。这种模式增强了服务的弹性和可维护性，但不会与其耦合，从而便于更有效地管理复杂的应用程序。

**网络分段**是另一种技术，它将网络划分为更小、更易于管理的部分，以限制访问并降低被攻击的风险。这有助于限制违规行为并提高整体安全性。可以通过设置**虚拟局域网**（**VLANs**）或子网络来实现。

## 防病毒和反恶意软件解决方案

最后，在基础设施中应运行防病毒和反恶意软件解决方案，以扫描、检测和移除恶意软件。它们监控运行中的进程，扫描存储的文件，并发现可疑行为，而无需人工干预。这些解决方案也会自动更新以保持最新的威胁定义。

大多数网络安全策略都涉及涉及特定应用程序配置的基础设施解决方案。在下一节中，我们将介绍 DevSecOps，其中应用程序工程师会积极参与。

# DevSecOps

**DevSecOps**是一种软件开发方法，它将安全最佳实践整合到开发过程中。它强调软件安全责任应由团队中的所有成员共同承担，安全是开发过程中的一个不可分割的元素。

在组织内仍将存在安全专家和潜在的安全团队。他们为开发提供专业知识、知识、工具和指导。DevSecOps 拥抱以下原则：

+   **左移**：安全考虑因素在开发过程的早期就整合为需求的一部分。这使在应用程序达到生产之前就能发现、识别和修复漏洞。

+   **合规性作为代码**：将监管要求纳入代码中，并使用自动化测试以持续验证合规性。

+   **协作与沟通**：这鼓励开发、安全和运维团队之间的协作，培养一种对软件安全共享责任的文化。

+   **自动化**：将安全流程自动化，例如代码漏洞扫描，作为**持续集成/持续部署**（**CI/CD**）管道的一部分，以提供对安全问题的快速反馈，并允许团队在开发早期阶段解决这些问题。例如，**OWASP Dependency-Check**是一个静态分析工具，用于识别项目依赖中的已知漏洞。此工具与构建工具（如 Maven、Gradle 和 Jenkins）集成。

+   **持续监控**：在所有环境中运行时，持续监控应用程序和基础设施中的安全威胁、漏洞和异常行为。

+   **威胁建模**：在开发的早期阶段发现和识别潜在威胁和漏洞，使团队能够主动解决安全问题。

## DevSecOps 的好处

通过在整个软件开发周期中集成安全，组织可以早期识别和缓解漏洞。它降低了安全漏洞的风险、修复安全问题的成本和补救成本。

在 CI/CD 管道内集成的自动化和协作有助于在流程早期发现漏洞。它节省了交付安全应用的时间，并缩短了上市时间。

持续监控和自动合规性检查有助于组织积极有效地满足监管要求。

DevSecOps 是一种文化和技术转变，它改变了组织对待软件开发和安全的做法。DevSecOps 流程中的实践培养了一种提供弹性应用和有效应对威胁的文化，从而导致了更安全的生态系统。

## 威胁建模练习

我们将进行一次威胁建模练习（[`owasp.org/www-project-threat-model/`](https://owasp.org/www-project-threat-model/）），以展示团队中的每个人如何参与这项活动。产品经理、安全团队和开发团队应参与所有步骤。

威胁建模从业务场景开始。我们将在整个书中使用相同的真实生活示例。这是一个允许家庭通过约定的合同相互交换服务的软件系统。这次威胁建模练习的目标是识别系统中的潜在安全威胁和漏洞。

### 第 1 步 – 可视化架构并识别资产

威胁建模的第一步是定义威胁建模发生的范围。这包括架构图来展示以下内容：

+   系统内部组件

+   系统边界、入口点和出口点

+   需要保护的资产

对于此目的，有几个图表格式可供选择，例如结构分析中的**数据流图**（**DFD**）或**C4 模型**中的容器图（第 2 级），如*第一章*所述。系统的容器图显示在*图 14.8*中：

![图 14.8 – 来自实际威胁建模示例的系统容器图](img/B21737_14_8.jpg)

图 14.8 – 来自实际威胁建模示例的系统容器图

虚线矩形定义了系统和其内部网络的边界。我们可以假设系统运行在云环境中，并打算使用云原生服务来实现跨功能。此图中有几个组件：

+   **移动应用程序**：家庭在移动设备上的用户界面。

+   **WAF**：一个基于云的防火墙中间件，阻止恶意 IP 地址，限制传入请求的数量，并防止**XSS**。

+   **API 网关/路由器**：一个基于云的中间件，将来自移动应用程序的请求路由到适当的服务。

+   **家庭服务**：一个后端服务，负责家庭记录的 CRUD 操作。

+   **合同服务**：一个后端服务，负责管理从起草到执行合同的生命周期。

+   **通知服务**：一个后端服务，负责通过电子邮件向外部用户发送通知。

+   **电子邮件服务**：一个基于云的中间件，将电子邮件内容发送到指定的地址。

+   **IdP**：一个基于云的中间件，使用来自移动应用程序的多因素认证（MFA）验证用户的身份，并确认携带令牌是否有效。由家庭服务和合同服务使用。

+   **数据库**：一个基于云的数据库，允许应用程序从中读取数据并向其写入数据。由家庭服务和合同服务使用。

+   **消息代理**：一个基于云的中间件，接收家庭更新、合同更新和通知请求。它允许感兴趣的服务消费消息以进行进一步处理。例如，通知服务消费通知消息并将它们转换为电子邮件请求发送给电子邮件服务。

从架构图中，我们确定了系统中的入口点。请求从移动应用程序进入，通过 WAF，然后被路由到相应的服务。

我们还在系统中确定了两个出口点：

+   后端服务请求 IdP 验证访问令牌

+   通知服务请求电子邮件服务发送电子邮件

此外，我们还确定了以下资产：

+   **家庭数据**：包含地址和姓名等 PIIs

+   **合同数据**：仅限于两个相关家庭之间的私人信息

+   **通知请求**：包含电子邮件内容和电子邮件地址（PIIs）

+   **应用程序代码**：所有后端服务和移动应用程序的源代码

+   **基础设施**：服务器、数据库、网络组件、基础设施配置代码

在架构图、入口点、出口点和已识别的资产的基础上，团队现在可以检查信息并发现系统中的威胁和漏洞。

### 第 2 步 – 识别威胁

团队应用**STRIDE**框架根据已识别的资产对潜在威胁进行分类。STRIDE 是以下六个方面的首字母缩写组合：

+   **欺骗**：未经授权的用户可能冒充合法用户

+   **篡改**：在传输过程中恶意修改家庭或合同数据

+   **否认**：家庭用户可能否认与另一家庭签订合同

+   **信息泄露**：PII（个人身份信息），如姓名、地址和电子邮件地址，通过漏洞暴露

+   **拒绝服务**：攻击者可能通过流量使系统过载和耗尽

+   **特权提升**：用户访问未经授权的功能

在确定威胁后，团队需要评估风险并确定如何应对它们。

### 第 3 步 – 评估风险并确定反应

风险可以通过两个因素进行评估：可能性和影响。这两个因素相乘得到风险等级，从而确定反应的优先级。

一种简单的方法是为每个因素设置三个级别，每个级别都与一个整数相关联。整数的乘积是风险等级。组织可以根据需要自定义级别和整数。在这个例子中，整数分配给每个级别如下：

+   **可能性**：1 – 不太可能，2 – 可能，3 – 很可能

+   **影响**：1 – 低，2 – 中等，3 – 高

这两个因素的数值构成了风险评估表，如*表 14.1*所示：

| **威胁** | **可能性** | **影响** | **风险等级** |
| --- | --- | --- | --- |
| **欺骗**：用户冒充 | 2 | 3 | 6 |
| **篡改**：恶意数据修改 | 2 | 3 | 6 |
| **否认**：家庭否认行为 | 1 | 2 | 2 |
| **信息**：PII 泄露 | 2 | 3 | 6 |
| 拒绝服务 | 2 | 2 | 4 |
| **特权提升**：未经授权的用户行为 | 1 | 3 | 3 |

表 14.1 – 风险评估表示例

风险等级实际上是团队需要响应和解决的安全威胁的优先级，最高数字代表最高优先级，最低数字代表最低优先级。

面对风险有四种一般性反应，团队必须为每个安全风险选择一种反应：

+   **缓解**：减少威胁的负面影响

+   **转移**：将风险转移到另一方，通常是通过使用第三方软件

+   **规避**：通过开发新的策略或解决方案消除风险

+   **接受**：接受并承认风险，但不再采取进一步行动

根据 STRIDE 框架确定的每个威胁，应概述以下反应：

+   **欺骗 – 转移**：使用基于云的 IdP 实现多因素认证并保护密码

+   **篡改 – 避免措施**：使用 TLS 之上的 HTTPS

+   **否认 – 缓解**：确保有足够的审计跟踪和记录所有与家庭和合同记录相关的用户操作

+   **信息泄露 – 避免措施**：使用加密数据库，在消息有效负载中加密敏感数据，将代码漏洞扫描集成到 CI/CD 管道中，并定期进行安全审计

+   **拒绝服务 – 转移**：配置 WAF 以保护网络免受 DDoS 攻击

+   **提升权限 – 缓解**：定期审查访问控制设置，并与内部用户进行安全培训

到目前为止，我们已经从安全的角度讨论了架构。已经确定了威胁及其风险等级。每个风险都已得到响应。完成一轮威胁建模只需要几个步骤，这些步骤将在下一步介绍。

### 第 4 步 – 记录、审查和更新

在完成前一步的所有活动后，所有活动都应得到记录，最好是作为单页文档，并标注威胁建模的大致日期。该文档作为团队学习记录和后续行动清单。

安全团队应审查文档，并建议是否有任何其他主题需要讨论。否则，安全团队应作为审阅者签署威胁建模文档。

团队应将风险响应转换为待办事项中的工作项，以确保决定采取的行动得到执行。

团队还应定期审查此文档，并决定是否需要进行另一轮威胁建模。或者，如果发生重要功能变更或架构变更，则团队应考虑是否需要更新威胁模型。

威胁建模是一种工具和流程，用于帮助团队在开发初期交付安全的软件。它通过早期解决安全问题，使工程师、安全团队、产品经理和客户受益，开发出高效的软件产品。

# 摘要

我们讨论了在软件架构中安全的重要性以及敏感信息的分类。之后，我们介绍了保密性、完整性和可用性的安全原则——CIA 三要素。

我们讨论了身份验证，重点关注 TLS 的工作原理及其如何防止中间人监听等网络攻击。我们深入探讨了多因素认证的工作原理及其对软件架构的影响。

然后，我们转向授权主题，并介绍了四种主要的访问控制方法（基于角色的、基于策略的、基于属性的以及 ACLs）。我们讨论了授权如何影响软件架构。

我们提到了处理敏感数据的基本实践，包括数据分类，以及在传输和静止状态下保护数据。本章突出了一些 Kotlin 工程师可以避免意外记录敏感数据的方法。还包括了一些匿名化数据的策略。

我们简要介绍了 DevSecOps 的原则及其通过将安全集成到开发过程中对软件开发周期的益处。

最后，我们使用实际示例系统进行了威胁建模练习。我们详细探讨了每个步骤的细节，强调了如何结束一个循环，以及何时应该重新审视威胁模型。

仍然有一些工程方面的内容超出了仅仅架构的范畴。在下一章和最后一章中，我们将讨论一些特定于 Kotlin 工程师的相关杂项主题。我们希望您会发现它们在支持更好的软件架构方面很有用。
