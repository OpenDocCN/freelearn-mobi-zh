# 第十章. 两全其美 – 结合函数式编程范式与面向对象编程

|   | *"对象是具有多个方法的闭包，闭包是具有单个方法的对象。所以是的[面向对象编程（OOP）和函数式编程（FP）可以一起使用。]"* |   |
| --- | --- | --- |
|   | --*埃里克·梅耶尔* |

在前面的章节中，我们大多数时候都在谈论**函数式编程（FP**）。你学习了 FP 的各种技术和范式。相比之下，我们几乎没有触及到**面向对象编程（OOP**）。我们主要讨论了命令式编程的缺点。在实践中，我们中的大多数人都必须处理由面向对象编程原则设计的应用程序。现实是，即使我们不喜欢面向对象编程，我们也必须接受它。例如，在 iOS 和 macOS 开发中，我们必须处理由面向对象编程原则设计的 Cocoa 和**Cocoa Touch**框架。

另一方面，我们熟悉面向对象编程（OOP），因为大多数人在某个时候都学过它，有些人发现用它来模拟现实世界问题是很自然的。

关于一种范式相对于另一种范式的益处有着大量的讨论。有些人声称它们可以统一；有些人声称它们是互斥的，我们应该选择一种范式而不是另一种。此外，不同的编程语言及其社区遵循不同的方法。例如，Haskell 是一种纯函数式编程语言，几乎不可能用它来做面向对象编程。事实上，用它来做面向对象编程是荒谬的。另一方面，像 Java、Ruby、Python 和 C#这样的语言是具有有限 FP 能力的面向对象编程语言。还有像 Scala 这样的语言，它混合了面向对象编程和函数式编程，并拥抱了这两个世界。

我们如何想象 Swift 在这些环境中呢？我们知道 Swift 不是一种纯函数式编程语言，但它具有 FP 能力，但我们需要进一步评估它在这一点上的表现。

此外，Swift 编程社区还介绍了一种新的范式：**协议导向编程（POP**）。此外，**函数式响应式编程（FRP**）变得非常流行，受到许多开发者的喜爱。

与其他范式相比，这种范式的优点和缺点是什么？我们如何设计我们的应用程序以利用所有这些范式？这些问题是我们将在本章中尝试回答的。因此，我们将首先介绍面向对象编程（OOP）、过程式编程（POP）和函数式响应式编程（FRP），然后我们将混合面向对象范式和函数式编程（FP）。

本章将涵盖以下主题，并附上代码示例：

+   面向对象编程（OOP）范式的简要介绍

+   面向对象编程（OOP）设计模式/原则

+   过程式编程（POP）的简要介绍

+   函数式响应式编程（FRP）

+   混合面向对象编程（OOP）和函数式编程（FP）

# 面向对象编程（OOP）范式

在本节中，我们将检查面向对象编程（OOP）中的通用范式。我们从对象开始，因为它们是面向对象编程中最基本的构件。接下来，我们将探讨类，它们是创建对象的蓝图。然后我们将继续讨论诸如继承、多态和动态绑定等范式。

## 对象

在面向对象的应用程序中，对象是运行时实体或实例，它们在内存中（更具体地说，在堆中）占用空间。对象有一个关联的/分配的内存地址来存储其状态，以及一组定义在对象状态上的合适操作或方法。简而言之，在面向对象编程中，对象封装状态和行为。

创建对象需要一个蓝图或脚本，这在面向对象编程（OOP）中被称为类。下一节将更详细地探讨类概念。现在，我们将定义一个非常简单的类，以便能够讨论对象：

```swift
class User { 
  let name = "Constant name" 
  var age: Int = 0 

  func incrementUserAgeByOne() { 
    self.age += 1 
  } 
}

```

在这个示例中，`name` 和 `age` 是可以用来存储对象状态的常量和变量。`incrementUserAgeByOne` 方法是一个行为定义，它改变对象的状态。我们必须创建这个类的实例/对象才能使用它：

```swift
let object1 = User() 
object1.age = 2 
object1.incrementUserAgeByOne()

```

在我们前面的示例的第一行中，我们使用我们的 `User` 脚本创建了一个对象。同时，我们为我们的对象分配了一个内存地址并初始化了它。这个对象，作为 `User` 的实例，可以被使用；我们可以改变其状态并使用其方法进行操作或改变其状态。

从设计角度来看，对象模型了应用域中的实体。在我们的示例中，对象代表 `User`。

理解以下关于类的内容非常重要：

+   类是引用类型

+   类封装了可变的状态

假设我们按照以下方式创建类的新实例：

```swift
let object2 = object1

```

这个赋值不会复制 `object1`，而是会使 `object2` 指向同一个实例。让我们来检查以下内容：

```swift
print(object2.age) 
object2.incrementUserAgeByOne() 
print(object1.age)

```

在这里，当我们打印 `object2.age` 时，它会产生与 `object1.age` 相同的结果；当我们调用 `incrementUserAgeByOne` 时，它会改变实例的年龄；因此，它也会改变 `object1` 和 `object2`。

这种行为在某些情况下可能很有用，例如，如果我们需要在不同的对象之间共享实例。例如，可以是数据库或文件管理系统操作，以及 iOS 和 macOS 应用程序中的 `AppDelegate`。

另一方面，它可能会使代码的推理变得复杂。例如，如果我们有很多对同一实例的引用，并且更改其中一个会更改所有实例，我们就需要对所有实例做出反应。

如果我们不需要共享实例，那么我们可以创建一个新的对象并使用它：

```swift
let object3 = User() 
object3.age = 5 

object3.incrementUserAgeByOne() 
print(object3.age) 
print(object1.age)

```

在前面的示例中，当我们为我们的 `object3` 分配和初始化新的内存空间时，它并不与 `object1` 和 `object2` 指向相同的实例。对 `object3` 的任何更改都不会影响 `object1` 和 `object2`。

## 类

类定义了一组属性和合适的操作。从类型安全的编程语言角度来看，类是实现用户定义类型（如前面示例中的 `User` 类）的结构。

最好，一个类应该是一个 **抽象数据类型**（**ADT**）的实现，它隐藏了实现细节。

一个 ADT 的类实现可以由两种方法组成：

+   返回有关实例状态的有意义抽象的方法

+   将有效实例状态转换为另一个有效状态的方法转换

为了隐藏实现细节和抽象的目的，一个类中的所有数据都应该对该类是私有的。

让我们改进我们的 `User` 类示例中的抽象：

```swift
class User { 
  private let name: String 
  private var age: Int 

  init(name: String, age: Int) { 
    self.name = name 
    self.age = age 
  } 

  func incrementUserAgeByOne() { 
    self.age += 1 
  } 
}

```

我们将属性设置为 `private`，这样其他对象就无法访问/修改它们，除非它们位于同一个 Swift 文件中。此外，我们还添加了一个 `init` 方法，用于从我们的 `User` 类初始化对象。类客户端将使用 `init` 方法来初始化对象，并带有初始的 `name` 和 `age` 信息：

```swift
let object1 = User(name: "John Doe", age: 34)

```

最后，我们将 `incrementUserAgeByOne` 的访问级别留为内部（默认为内部）；因此，同一模块中的任何其他对象都将能够使用它。

`incrementUserAgeByOne` 方法改变了我们对象的状态，这种变化将影响所有引用同一实例的对象。我们可以这样改变它：

```swift
func incrementUserAge(n: Int) -> Int { 
  return self.age + n 
}

```

我们的 `incrementUserAge` 方法返回新的 `age` 而不会修改对象的当前状态。我们需要初始化一个新的对象并使用这个 `age`。

最后，由于我们不需要修改 `age`，我们可以将其设置为不可变。我们的 `User` 类有两个不可变属性和一个不修改其属性的方法。因此，尽管它是一个非常简单的类，但它是有功能的。

## 继承

继承是类之间的一种关系，使得基于其他现有类定义和实现一个类成为可能。

此外，继承有助于代码重用，并允许通过公共类和接口独立扩展原始类（即 `super` 类）。通过继承建立起来的类之间的关系导致了一个层次结构。

继承在需要向现有类添加额外信息和功能时不可避免地会最小化重工作业量，因为我们可以使用该类作为 `super` 类，并从它派生出一个子类来添加新的状态信息和行为。

此外，当与多态和动态绑定结合使用时，继承最小化了在扩展类时需要更改的现有代码量。

在像 C++ 这样的编程语言中，可以从多个类中继承，但在 Swift 中，一个类只能从另一个类中派生。以下是一个 `UIViewController` 派生的示例：

```swift
class BaseViewController: UIViewController { 

}

```

我们的 `BaseViewController` 将继承 `UIViewController` 类的所有行为和属性，我们还将能够向它添加新的属性和行为。这样，我们就不需要从头开始重写一切，可以在 `UIViewController` 中重用属性和行为。

### 覆盖

Swift 允许一个类或对象替换它继承的行为/属性的实现。这个过程称为重写。`override`关键字用于在子类中指定重写的方法。

我们可以重写继承的实例或类属性，以提供我们自己的自定义/计算属性获取器和设置器，或者添加属性观察器，以便当底层属性值发生变化时，重写的属性可以观察。

我们可以将属性或行为标记为`final`以防止在子类中重写它。

重写带来了需要处理的复杂性。我们需要确保子类实例应该使用哪个版本的行为/属性：它自己类的一部分（`self`）还是父类（`super`）的一部分？

在 Swift 中，可以使用`self`和`super`关键字作为前缀来指定所需行为/属性的版本。

### 设计约束

在设计应用程序时广泛使用继承会施加某些约束。

例如，假设我们定义了一个名为`WebAppUser`的`User`子类，它包含额外的可接受行为，以及另一个名为`MobileAppUser`的`User`子类，它包含`User`的移动应用模块。

在定义这个继承层次结构时，我们已经定义了某些限制，并非所有这些限制都是可取的。

#### 单一性

在 Swift 中，子类只能从单个超类继承。从前面的例子中，`User`可以是`WebAppUser`或`MobileAppUser`，但不能同时是两者。

#### 静态

对象的继承层次结构在初始化时是固定的，而对象类型的选择不会随时间改变。例如，继承图不允许一个`MobileAppUser`对象在保留其`User`超类状态的同时成为`WebAppUser`对象（这可以通过装饰器模式实现）。

#### 可见性

当客户端代码可以访问一个对象时，它通常也可以访问该对象的所有父类数据。即使父类没有被声明为 public，客户端仍然可以将对象转换为它的父类类型。

#### 组合复用

组合复用原则是继承的替代方案。这种技术通过将行为从主要类层次结构中分离出来，并在任何类中按需包含特定的行为类，支持多态和代码复用。这种方法通过允许在运行时改变行为并允许子类有选择地实现行为，而不是仅限于其超类的行为，避免了类层次结构的静态性质。

### 问题与替代方案

实现继承在面向对象程序设计和理论家中是有争议的。例如，《设计模式：可复用面向对象软件元素》一书的作者，*Erich Gamma, John Vlissides, Ralph Johnson, 和 Richard Helm*，提倡接口继承而不是实现继承，并建议优先考虑组合而不是继承。

例如，装饰器模式（如前所述）已被提出以克服类之间继承的静态性质。

此外，面向对象编程社区普遍认为继承引入了不必要的耦合并破坏了封装，因此对超类的修改可能导致子类中出现不希望的行为变化。

在 Swift 中，鼓励使用协议和扩展。使用协议可以避免耦合问题，因为没有任何实现被共享。我们将在本章的 *POP* 部分中更多地讨论协议和协议扩展。

### 何时继承

有时候，我们没有其他选择，只能进行子类化。以下是一些需要子类化的例子：

+   当 API 需要时：例如，许多 Cocoa API 需要使用类，并且不建议有争议。例如，`UIViewController` 必须被子类化。

+   当我们需要在其它类的实例之间管理和传递我们的值类型时：例如，当我们需要在另一个绘图类提供的 Cocoa 类中绘制自定义视图时，我们将在它们之间进行通信。在这种情况下使用值类型是不利的。

+   当我们需要在多个所有者之间共享一个实例时：Core Data 持久化是一个例子。在使用 Core Data 时，拥有一个跨多个所有者的同步机制非常有用。这可能会引起并发问题，但我们必须处理它们，因为我们需要可变数据。

+   当实例的生命周期与外部效应相关联或我们需要一个稳定的身份时：单例和 AppDelegate 是一些例子。

## 多态

多态意味着多种形式。一般来说，能够采取多种形式的能力被称为多态。在面向对象的编程语言如 Swift 中，多态引用是指随着时间的推移，可以引用多个类的实例。让我们考察一个 iOS SDK 的例子，`UIView`。有大量的 `UIView` 子类，包括以下内容：

+   `UILabel`

+   `UITextField`

+   `UIButton`

我们可以声明一个可以采取多种形式的视图，如下所示：

```swift
var view: UIView 

view = UIButton() 
view = UILabel() 
view = UITextField()

```

多态允许我们编写更通用的代码，这些代码可以与对象家族一起工作，而不是为特定类编写代码。在这个例子中，无论我们启动哪个类，我们都可以访问所有继承自 `UIView` 类的所有子类中声明的属性和方法。例如，我们可以检查任何一个的边界和原点，如下所示：

```swift
view.bounds 
view.frame.origin

```

我们能够引用多种类型的对象；因此，多态引用既有静态类型，也有动态类型相关联。

静态类型是由代码中对对象的声明确定的。它在编译时已知，并决定了对象在运行时可以接受的有效类型集合。这种确定是通过分析系统中的继承图来进行的。

在应用程序执行过程中，引用的动态类型可能会随时间改变。在 Swift 中，运行时系统自动将所有多态引用标记为它们的动态类型。

## 动态绑定

将方法调用与要执行的代码关联起来称为绑定。与在编译时绑定与方法调用相关联的代码的静态绑定相反，动态绑定意味着与给定方法调用相关联的代码在编译时是未知的，将在运行时确定。

动态绑定与多态和继承相关联，因为与多态引用相关联的方法调用可能依赖于该引用的动态类型。

例如，我们视图的静态类型是`UIView`，其动态类型可能是`UILabel`、`UITextField`或`UIButton`。假设`UIView`中的一些方法被`UIButton`重写。当我们调用这些方法时，运行时会动态绑定需要调用的方法。

# 面向对象设计原则

在本节中，我们将探讨面向对象（OOP）方法及其解决方案以及针对这些问题的函数式编程（FP）解决方案中的一些问题。

通常，面向对象（OOP）被以下方式批评：

+   将数据结构绑定到行为是状态封装的一种机制，它隐藏了底层问题而不是解决问题。

+   为了使继承成为可能，投入了大量的努力。讽刺的是，面向对象的模式本身更倾向于组合而不是继承。最终，在处理两个职责——子类型化和重用——时，继承在子类型化或重用方面都不是很好。

解决这些问题的面向对象解决方案包括 SOLID 原则和领域驱动设计（DDD）原则。以下为 SOLID 原则：

+   **单一职责原则**（SRP）

+   **开闭原则**（OCP）

+   **Liskov 替换原则**（LSP）

+   **接口隔离原则**（ISP）

+   **依赖倒置原则**（DIP）

**领域驱动设计**（DDD）原则被提出以解决面向对象（OOP）问题。

此外，函数式编程（FP）通过以下区分特征来解决这些问题：

+   通过**不可变性**避免显式管理状态。

+   更倾向于**显式返回值**而不是隐式副作用。

+   强大的**组合**功能在不损害封装性的情况下促进重用。

+   这些特征的最终结果是更**声明式**的范式。

## SRP

SRP 指出，每个类都应该有一个单一职责，其中职责被定义为改变的理由。

这个原则支持反模式，其中大型类扮演多个角色。类可以因为几个原因而变得很大。面向对象编程（OOP）的一个核心原则是将数据结构绑定到行为上。问题是，优化数据结构封装不仅会削弱组合特性，还会隐藏显式状态的根本问题。因此，OOP 代码通常包含许多数据结构，每个数据结构中的函数相对较少。向类中添加方法会给 SRP（单一职责原则）带来压力，而减少方法数量可能会使数据结构难以组合，或者完全无用。此外，声明类的简单语法成本经常迫使程序员将其边缘化。

### 函数式编程的对应原则

在函数式编程中，抽象的基本单位是函数。鉴于函数只有一个输出，函数自然只有一个职责。当然可以定义一个任意通用的函数，但这并不直观。此外，函数在语法上更节省资源。

## OCP（开闭原则）

OCP 指出，软件实体应该对扩展开放，但对修改封闭。

这个陈述的不确定性可以通过该原则的两个变体来解决：

+   应仅修改现有类以纠正错误。这种限制提供了原则的封闭方面。开放方面是通过实现继承或换句话说，通过重用而不是子类型化的目标来实现的。

+   通过多态实现开放性，这根据定义也提供了封闭性，因为可扩展性是通过替换而不是修改来支持的。不幸的是，替换往往会导致意外的复杂性，这必须通过另一个原则——LSP 来解决。

OCP 的主要效用是在提供可扩展性的同时限制级联变化。这是通过为可扩展性进行设计和禁止对现有实体进行更改来实现的。通过使用抽象类和虚拟函数的巧妙技巧来实现可扩展性。通过封装或更确切地说，通过隐藏移动部分来实现封闭性。

### 函数式编程的对应原则

在函数式编程（FP）中，函数可以随意替换，因此无需为可扩展性进行设计。需要参数化的功能自然地被声明为这样的功能。而不是发明一个虚拟方法和继承的概念，可以依赖一个现有的、基本的概念——高阶函数。

## LSP（里氏替换原则）

LSP 指出，程序中的对象应该可以用其子类型实例替换，而不会改变该程序的正确性。

LSP 本质上是一种受限的子类型实例，旨在保证跨类层次结构的语义可移植性。可移植性是通过确保对基类型的所有断言对所有子类型都成立来实现的。子类不得加强前置条件。它们必须接受基类接受的所有输入和初始状态，并且子类不得弱化后置条件。超类声明的行为期望必须由子类满足。这些特性不能仅通过类型系统强制执行。

作为继承关系的一部分，LSP 因此具有误导性，因此需要补偿原则。因此，这一原则的需要证明了子类型（基于包含的）多态的一个陷阱。通过类层次结构隐式分解强加不必要的限制，并需要复杂的原则来对偶然复杂性设置边界。

### FP 对应原则

函数式语言倾向于使用有界量词的参数多态，从而避免了继承的一些陷阱。非正式地说，函数式语言强调可替换性，并淡化实现重用，因为重用通过组合实现得更好。在函数式语言中，LSP 的大多数雄心壮志实际上都是微不足道的。

## ISP

ISP 原则指出，许多针对特定客户端的接口比一个通用接口更好。换句话说，不应该强迫任何客户端依赖它不使用的功能。

从本质上讲，ISP 是对 SRP（单一职责原则）在接口上的重申，反映了相同的潜在问题——在面向对象设计中平衡职责分配、组合和封装的困难。一方面，封装是可取的；另一方面，组合也是可取的。此外，仅采用 ISP 的问题在于它并不能直接保护大型类，并且在某些方面掩盖了问题。

### FP 对应原则

函数式编程通过摒弃状态来减少封装的需求，并在核心处培育组合。没有基于角色的接口增强概念，因为函数角色从一开始就是明确的。函数默认是隔离的。

## DIP

DIP 原则指出，应该依赖于抽象，而不是具体实现。换句话说，高级模块应该通过抽象与低级模块解耦。这一原则表明代码应该围绕问题域进行结构化，而领域应该通过协议声明对所需基础设施的依赖。因此，依赖指向领域模型。

这个原则之所以是倒置的，是因为典型的 OOP（通过分层架构）推广的架构表现出依赖图，其中高级模块直接消耗低级模块。最初，这个依赖图看起来很自然，因为在用代码表达领域模型时，不可避免地依赖于语言的构造。过程式编程允许通过过程封装依赖关系。

子类型多态推迟了过程实现。不幸的是，在 OOP 实现中，经常忽视使用协议来表示领域依赖。鉴于基础设施代码通常更为庞大，代码的关注点会偏离领域。DDD 部分是为了平衡这种偏离而设计的。

### FP 的对应物

函数式编程（FP）的声明性和无副作用特性提供了依赖倒置。在面向对象编程（OOP）中，高级模块主要依赖于基础设施模块来调用副作用。在 FP 中，副作用更自然地是在响应领域行为时触发的，而不是直接由领域行为触发的。因此，依赖关系不仅被倒置，而且完全推到了外部层。

## DDD

DDD 是一种通过将实现与不断发展的模型连接起来，针对复杂需求进行软件开发的方法。

### 概念

模型的概念包括以下内容：

+   **上下文**：一个词或陈述出现的背景，决定了其含义。

+   **领域**：一个本体、影响或活动。用户将程序应用于的主题领域是软件的领域。

+   **模型**：一个抽象系统，描述了领域的选定方面，并可用于解决与该领域相关的问题。

+   **通用语言**：一种围绕领域模型构建的语言，并由所有团队成员使用，以将团队的所有活动与软件联系起来。

### 前提

DDD 的前提如下：

+   将项目的重点放在核心领域和领域逻辑上

+   在领域模型的基础上构建复杂设计

+   在技术专家和领域专家之间启动创造性合作，以迭代地完善一个解决特定领域问题的概念模型。

### 构建模块

在 DDD 中，有一些用于表达、创建和检索领域模型的工件，以下几节将从 FP 的角度进行探讨。

#### 聚合

一组由根实体绑定在一起的对象，也称为聚合根。聚合根通过禁止外部对象持有其成员的引用，确保了在聚合内进行的更改的一致性。

聚合的概念在 FP 中仍然存在；然而，它不是用类来表示的。相反，它可以表示为一个结构，包括一组聚合状态、初始状态、一组命令、一组事件以及将一组命令映射到给定状态的一组事件的功能。模块机制提供了内聚性。

#### 不可变值对象

不可变值对象是包含属性但没有概念身份的对象。它们应该被视为不可变的。

在前一章中，我们看到了 Swift 提供了具有自动实现的结构相等性的不可变产品类型和求和类型，这可以简单地解决这个问题。在面向对象编程中，对状态的过度依赖使得引用成为一等公民，而不是数据结构本身的结构。

#### 领域事件

领域事件是定义事件的领域对象。

领域事件是保持领域模型封装的强大机制。这可以通过允许外部层中的各种观察者注册领域事件（“信号”）来实现。

面向对象编程中领域事件的问题在于，典型的实现复杂且依赖于副作用。事件观察通常在组合根中声明，因此，从生产者的角度来看，并不立即明显哪些观察者将被调用。在函数式编程（FP）中，领域事件是聚合中函数返回的一个值。观察者可以显式注册为过滤器。

此外，函数式响应编程（FRP）可以非常有效地处理领域事件。另一方面，由于缺乏联合类型和模式匹配，在面向对象编程（OOP）中从聚合方法返回领域事件是受限制的。

#### 意图揭示接口

在命令式面向对象代码中，意图通过副作用泄露，并关注“如何”而不是“什么”。总是需要将行为绑定到数据结构也可能有问题。

由于函数式编程更声明式，函数名称和接口往往更多地关注意图而不是底层机制。此外，无副作用函数的接口本质上更具有揭示性，因为行为通过返回值被明确表达。因此，除了命名具有意图的纯粹语言优势外，意图还通过类型系统进行编码。这并不是说在函数式编程中表达意图是不费力的——只是说它得到了函数式范式的更好支持。

#### 无副作用函数

副作用与封装直接对立，但它们往往是最有用的工具。

与命令式编程不同，函数式编程避免了副作用。这个模式又是另一个例子，说明了精心设计的面向对象设计如何收敛到函数式风格。

#### 断言

与许多根植于命令式面向对象设计的模式一样，断言声称使用隐式副作用。

与意图揭示接口一样，函数式编程语言中的断言除了函数名称外，还自动编码在函数的返回类型中。

#### 概念轮廓

当领域知识在代码中传播到一定程度时，概念轮廓就会出现。在面向对象编程中，这可以通过仔细遵循领域驱动设计（DDD）的原则来实现。

在 FP 中，概念轮廓更容易出现，这再次归因于范式声明性和无副作用的特点。具体来说，领域模型客户端可以依赖通过组合获得的内聚功能，同时仍然可以访问组成部分而不破坏封装。

#### 操作的关闭

操作的关闭说明了将组合和结构强加于面向对象设计的另一个例子。

从本质上讲，关闭操作通过限制讨论的范围来简化对问题的推理。一个领域实现的函数示例在基本层面上展示了这一特征。应用领域事件的操作在领域状态集合下是封闭的。在持久性的方面，这自然地转化为事件源，但也支持在无需修改的情况下使用键值存储或 ORM 进行持久化。

### 声明式设计

上文提到的模式的整体意图是培养声明式设计。如所见，FP 天生更具声明性，因此在这方面更具适应性。通过声明式设计，我们可以更好地提炼领域的区分特征，并减少或消除对基础设施正交关注点的耦合。因此，可重用性、可测试性、正确性、可维护性和生产力得到了极大的提升。

# 面向协议编程（POP）

POP 鼓励我们开发协议并扩展它们，而不是类和继承。在 Objective-C 和 Swift 开发社区中，POP 是一个新的概念，但它提供的内容与 Java 和 C#等语言中的`Abstract`类概念以及 C++中的`pure-virtual`函数并没有太大的区别。

在 Swift 中，类、结构和枚举可以符合协议。这使得协议更加可用，因为继承对结构和枚举不起作用。

## POP 范式

在本节中，我们将探讨 POP 范式。首先，我们将查看一个示例：

```swift
protocol UserProtocol { 
    func greet(name: String) -> String 
    func login(username: String, password:String) -> Bool 
}

```

此协议定义了两个需要由符合此协议的结构、枚举或类实现的功能。

### 协议组合

协议组合允许类型符合多个协议。这是 POP 相对于 OOP 的许多优点之一。在 OOP 中，一个类只能有一个超类，这可能导致非常单调的超类。在 POP 中，我们被鼓励创建多个具有非常具体要求的小型协议。

### 协议扩展

协议扩展是 POP 范式最重要的部分之一。它们允许我们向所有符合给定协议的类型添加功能。如果没有协议扩展，如果我们有对所有符合特定协议的类型都必要的通用功能，那么我们就需要将此功能添加到每个类型中。这将导致大量代码重复。以下示例通过添加一个`logout`方法和其实现来扩展我们的协议；因此，任何符合`UserProtocol`的 struct、enum 或 class 都将具有`logout`功能：

```swift
extension UserProtocol { 
    func logout(userName: String) -> Bool { 
      return true 
  } 
}

```

### 协议继承

协议继承是其中一个协议可以继承一个或多个其他协议的要求，如下面的代码所示：

```swift
protocol MobileAppUserProtocol: UserProtocol { 

}

```

`MobileAppUserProtocol`从`UserProtocol`继承，因此它将具有所有定义和扩展的方法。

### 关联类型

关联类型可用于使我们的协议与泛型类型一起工作：

```swift
protocol MobileAppUserProtocol: UserProtocol { 
  associatedtype applicationModuleList 
  func listSelectedModules() -> [applicationModuleList] 
}

```

### 符合协议

以下代码展示了与关联类型使用相关的协议符合性的示例：

```swift
enum MobileAppUserType: MobileAppUserProtocol { 
    case admin 
    case endUser 

    func greet(name: String) -> String { 
        switch self { 
        case .admin: 
          return "Welcome \(name) - You are Admin" 
        case .endUser: 
          return "Welcome \(name)!" 
      } 
    } 
    func login(username: String, password:String) -> Bool { 
      return true 
    } 
    func listSelectedModules() -> [String] { 
      return ["Accounting", "CRM"] 
    }   
  }

```

然后，我们可以创建一个新的移动用户如下：

```swift
let mobileUser: MobileAppUserType = MobileAppUserType.Admin 
mobileUser.logout("cindy") 

mobileUser.listSelectedModules()

```

POP 通过使我们能够符合协议并使用默认实现来扩展它们，从而最小化了继承和子类化的必要性。

# 函数式响应式编程（FRP）

函数式编程避免使用不可变性和副作用。在某些情况下，应用程序应该对动态值/数据变化做出反应。例如，我们可能需要更改 iOS 应用程序的用户界面以反映从后端或数据库系统接收到的数据。在没有状态和可变值的情况下，我们该如何做到这一点？

命令式编程仅通过状态和突变间接捕获这些动态值。完整的（过去、现在和未来）历史没有一等表示。此外，只有离散演变的值可以作为一等表示被（间接）捕获，因为命令式范式在时间上是离散的。

FRP 提供了一种处理动态值变化的同时仍保留 FP 风格的方法。正如其名称所暗示的，FRP 是 FP 和响应式编程的结合。响应式编程使得处理表示随时间变化的值的某些数据类型成为可能。这些数据类型在不同的函数式编程语言中被称为时间流或事件流。涉及这些随时间变化的值的计算本身也将具有随时间变化的值。FRP 直接捕获这些演变值，并且对持续演变的值没有困难。

此外，FRP 还可以表示为以下一组原则/规则：

+   数据类型或随时间动态/演变的值应该是第一类公民。我们应该能够定义、组合并将它们传递给函数，并从函数中返回它们。

+   数据类型应该由一些原始类型如常量/静态值和时间通过顺序和并行组合构建。n 个行为通过在时间上连续应用一个 n 元函数到静态值来组合。

+   为了考虑离散现象，我们应该有额外的事件类型，每种类型都有一个（有限或无限）发生流。每个发生都与一个相关的时间和值相关联。

+   为了构建所有行为和事件都可以组成的组合词汇，可以通过一些示例进行尝试。持续将它们分解成更通用/简单的部分。

+   我们应该能够使用指称语义技术来构建整个模型：

    +   每种类型都有一个对应简单且精确的数学类型意义

    +   每个原始类型和操作符作为构成元素意义的函数具有简单且精确的意义

## FRP 的构建块

理解 FRP 构建块对于理解 FRP 至关重要。以下章节将使用 GitHub 上为 Cocoa 框架开发的优秀 FRP 库 ReactiveCocoa 来解释这些构建块。ReactiveCocoa 是为 Objective-C 开发的，截至版本 3.0，所有主要功能开发都集中在 Swift API 上。

### 信号

信号是事件流，在时间上发送已经进行中的值。我们可以想象它们为发送值而不了解它们之前发送的值或将要发送的值的管道。信号可以声明性地组合、合并和链式连接。信号可以统一所有 Cocoa 的异步和事件处理常见模式：

+   委托方法

+   回调块

+   通知

+   控制动作和响应链事件

+   未来和承诺

+   **键值观察**（**KVO**）

由于所有这些机制都可以以相同的方式表示，因此它们很容易声明性地链式连接和组合在一起。

ReactiveCocoa 将信号表示为`Signal`。信号可以用来表示通知、用户输入等。随着工作的进行或数据的接收，事件被发送到信号上，并将它们推送到任何观察者。所有观察者同时看到这些事件。

用户必须观察一个信号才能访问其事件。观察信号不会触发任何副作用。换句话说，信号完全是生产者驱动和基于推送的，观察者不能对信号的生命周期有任何影响。在观察信号时，用户只能以与信号上发送的顺序相同的顺序评估事件。信号值没有随机访问。

可以通过以下操作来操作信号：

+   使用`map`、`filter`和`reduce`来操作单个信号

+   使用`zip`同时操作多个信号

这些操作只能应用于信号的下一个事件。

信号的生命周期可能由多个后续事件组成，之后跟随一个终止事件，该事件可能是以下之一：

+   失败

+   完成

+   中断

终止事件不包括在信号的值中，并且应该特别处理。

### 管道

可以手动控制的`signal`称为`pipe`。在 ReactiveCocoa 中，我们可以通过调用`Signal.pipe()`来创建`pipe`。

`pipe`方法返回`signal`和`observer`。`signal`可以通过向`observer`发送事件来控制。

### 信号生产者

信号生产者创建信号并执行副作用。`SignalProducer`可用于表示操作或任务，例如网络请求，每次调用`start()`都会创建一个新的底层操作，并允许调用者观察结果。与信号不同，直到附加观察者，并且为每个额外的观察者重新启动工作之前，不会开始工作（因此不会生成事件）。

启动信号生产者返回一个可丢弃的对象，可以用来中断/取消与产生的信号相关的工作。

信号生产者也可以通过诸如 map、filter 和 reduce 之类的操作进行操作。每个信号操作都可以通过`lift`方法提升为操作信号生产者。

### 缓冲区

缓冲区是一个可选有界的事件队列。当从`SignalProducer`创建新的信号时，缓冲区会回放这些事件。通过调用`SignalProducer.buffer()`创建`buffer`。类似于`pipe`，该方法返回`observer`。发送到此观察者的事件将被添加到队列中。如果缓冲区在新的值到达时已满，则最旧的价值将被丢弃以腾出空间。

### 观察者

观察者是指观察或能够从`signal`中观察`events`的任何东西。可以使用基于回调的`Signal.observe()`或`SignalProducer.start()`方法的版本隐式创建观察者。

### 动作

当与输入执行时，动作将执行一些工作。动作在执行副作用工作方面很有用，例如当按钮被点击时。动作还可以根据属性自动禁用，并且这种禁用状态可以通过禁用与动作相关的任何控件在用户界面中表示。

### 属性

属性存储一个值，并通知观察者该值的未来更改。可以从值获取器中获取属性的当前值。生产者获取器返回一个信号生产者，该生产者将发送属性的当前值，然后是随时间的变化。

### 可丢弃的

可丢弃的是一种内存管理和取消的机制。在启动信号生产者时，将返回一个可丢弃的对象。调用者可以使用此可丢弃对象来取消已启动的工作，清理所有临时资源，然后针对创建的特定信号发送一个最终的 Interrupted 事件。

### 调度器

调度器是一个串行执行队列，用于执行工作或交付结果。`Signals`和`signal producers`可以按顺序在特定调度器上交付事件。`Signal producers`还可以按顺序在特定调度器上开始工作。

调度器与**Grand Central Dispatch**（**GCD**）队列类似，但调度器支持通过可处置对象进行取消，并且始终按顺序执行。除了`ImmediateScheduler`之外，调度器不提供同步执行。这有助于避免死锁，并鼓励使用`signal`和`signal producer`操作而不是阻塞工作。

调度器也与`NSOperationQueue`有些类似，但调度器不允许任务重新排序或相互依赖。

## 一个例子

假设我们有一个输出端口，我们想观察其变化：

```swift
@IBOutlet weak var textFieldUserName: UITextField!

```

我们可以创建`SignalProducer`如下：

```swift
let userNameSignalProducer = 
  textFieldUserName.rac_textSignal().toSignalProducer.map { 
  text in text as! String }
```

`rac_textSignal`方法是一个用于`UITextField`的 ReactiveCocoa 扩展，可以用来创建信号生产者。

然后，我们可以这样开始我们的`SignalProducer`：

```swift
userNameSignalProducer.startWithNext { results in 
      print("User name:\(results)") 
}

```

这会将`textField`中的任何更改打印到控制台。

此外，我们可以在这个信号生产者上执行诸如`map`、`flatMap`、`filter`和`reduce`等操作，这些我们在第六章中介绍过，即*Map、Filter 和 Reduce*。

# 混合面向对象编程与函数式编程

到目前为止，我们已经看到，将函数式编程能力添加到面向对象语言中，会在面向对象设计中带来好处。

总结来说，当我们的对象尽可能不可变时，面向对象编程与函数式编程完美匹配。为了使我们的对象尽可能不可变，我们可以考虑以下原则：

+   对象应该是封装相关数据片段的类型

+   对象可以有方法；然而，这些方法不应该改变对象，而应该返回一个适当类型的新对象

+   所有必需的状态数据都应该在类的初始化中注入，以便它可以立即使用

+   静态方法可以自由使用，而静态变量应避免使用

+   应该使用协议和泛型来避免代码重复

这些原则不仅使我们能够使用函数式设计模式，还丰富了我们的面向对象代码。

## 问题

在统一和混合面向对象编程与函数式编程时，存在一些问题，我们将在以下章节中介绍。

### 粒度不匹配

函数式编程和面向对象编程在不同的设计粒度级别上操作：

+   函数式编程：在小型级别上的函数/方法编程

+   面向对象编程：在大型级别上的类/对象/模块编程

为了克服这种粒度不匹配，我们需要找到以下问题的答案：

+   我们如何在面向对象架构中定位单个函数的来源？

+   我们如何在面向对象架构中将这样的单个函数与对象相关联？

在 Swift 中，我们可以在源文件内部和外部放置函数，或者将它们作为静态或类方法放置。

## 函数式编程范式可用性

到目前为止，我们在 Swift 中探索了许多不同的 FP 模式。在这里，我们概念上检查 Swift 是否是一个适合 FP 的语言。我们将在以下章节中探索这些模式。

### 首类值

在 FP 语言中，函数/方法应该是首类公民。如果首类公民函数满足以下规则，它们将使我们能够使用大多数 FP 模式：

+   函数/方法应可作为函数/方法参数和参数使用

+   函数/方法可以作为函数/方法的返回结果

+   函数可以存在于数据结构中

到目前为止，我们已经看到了所有这些规则的一个示例实现。

### 闭包

首类函数/方法应作为闭包实现。例如，它们应与特定的私有环境相关联。

Swift 函数作为闭包实现。

### FP-OOP 交互工具

独立函数/方法应明确与类/对象级别相关联。

Swift 扩展使我们能够在不创建新派生类的情况下向现有类添加方法。

## FP 支持

FP 模式应由相关构造、预定义定义、标准库中的出现等加强。

它们应满足以下规则：

+   泛型函数类型的重载

+   首类多次调用和多播

+   函数打包和序列化（闭包作为数据结构）

Swift 支持上述 FP 模式。

## 在 OOP 中具有 FP 功能的影响

在 OOP 语言中具有 FP 功能会导致习惯性和架构效应，这些将在以下章节中探讨。

### 习惯性效应

+   函数/方法粒度级别的代码重构（抽象）

+   泛型迭代器和循环操作（映射）

+   操作组合和序列理解（链式函数调用）

+   函数部分应用和柯里化

### 架构效应

+   减少对象/类定义的数量：避免用新类弄乱 OOP 架构

+   函数/方法级别的命名抽象：使用首类方法允许任何满足其声明类型的任何方法实例化参数

+   操作组合（以及序列理解）

+   函数部分应用和柯里化

## OOP 设计模式 - FP 视角

设计模式描述了面向对象软件设计中常见问题的重复解决方案。模式分为三种类型：

+   创建型

+   结构

+   行为

本节从非常高的层次介绍了 OOP 设计模式，并介绍了 FP 对应模式：

+   策略

+   命令

+   观察者

+   代理

+   访问者

### 策略模式

策略模式是一种行为模式，它允许算法独立于使用它的客户端变化。换句话说，它允许在运行时动态选择算法家族中的一个。

从 FP 视角来看，策略只是方法级别抽象代码的一个例子。

### 命令模式

命令模式是一种行为模式，它将请求（方法调用）封装为对象，以便它们可以轻松地传输、存储和应用。

FP 提供了闭包和一等函数。

### 观察者模式

观察者模式是一种行为模式，它允许对象之间存在一对一的依赖关系，这样当一个对象的状态发生变化时，所有依赖它的对象都会收到通知并更新。

FRP 以非常有效和声明性的方式处理此模式。

### 虚拟代理模式

虚拟代理模式是一种结构模式，它以这种方式提供其他对象的占位符，即只有在需要时才创建/计算其数据。

FP 提供了延迟实例化和评估。

### 访问者模式

访问者模式是一种行为模式，它允许我们在不改变操作元素所属的类的情况下定义新的操作。

FP 使函数独立于对象变化。

# 概述

在本章中，我们介绍了面向对象编程的原则和范式。然后我们讨论了协议导向编程。接下来，我们介绍了 FRP。最后，我们探讨了如何将 FP 与 OOP 范式混合。

在下一章中，我们将开发一个 Todo 后端和一个 iOS 应用，这些应用将采用我们迄今为止所涵盖的概念。

我们将使用函数式编程技术来解析和映射数据，并使用 FRP 来反应性地管理应用中的事件。此外，我们还将采用协议导向编程和面向对象编程技术。
