# *第六章*：理解 Swift 类型系统

前几章已经为你打下了坚实的基础，你可以用它来构建出色的、适应性强的应用程序。在这个时候，退一步审视你编写的代码，以更深入地理解 Swift 及其工作方式是个好主意。本节侧重于教你更多关于 Swift 作为一门语言的知识，无论你打算构建什么。

在本章中，你将了解 Swift 的出色类型系统。Swift 的类型系统是其最强大的特性之一，因为它允许开发者安全且可预测地表达复杂和灵活的原则。

本章将涵盖以下主题：

+   理解 Swift 中可用的类型

+   理解类型之间的差异

+   决定使用哪种类型

# 技术要求

对于本章，你需要从 Apple 的 App Store 下载 11.4 或更高版本的 Xcode。

你还需要运行最新的 macOS 版本（Catalina 或更高）。只需在 App Store 中搜索`Xcode`，选择并下载最新版本。启动 Xcode，并遵循系统可能提示的任何附加安装说明。一旦 Xcode 完全启动，你就可以开始了。

从以下 GitHub 链接下载示例代码：

[`github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition`](https://github.com/PacktPublishing/Mastering-iOS-14-Programming-4th-Edition)

# 理解 Swift 中可用的类型

要编写优秀的代码，你需要了解你的工具箱中都有哪些工具。这适用于构建应用程序和理解 UIKit 所能提供的功能，但也适用于你用来编写软件的语言。不同的语言都有各自的特点、最佳实践、优点和缺点。你对所使用语言的了解越深入，你就能做出越好的关于你编写代码的决定。正如之前提到的，Swift 的类型系统是使 Swift 成为专家和初学者开发中都如此出色的语言的一个特性。

在你深入研究 Swift 的类型细节以及它们如何相互比较之前，了解 Swift 提供哪些类型是至关重要的。从高层次上讲，你可以争辩说 Swift 有两种类型：

+   引用类型

+   值类型

让我们更仔细地看看每种类型，了解它们代表什么，如何工作，以及如何使用它们。

## 使用引用类型

在本书中你看到的类型大多是，如果不是全部都是引用类型。两种类型的对象被归类为引用类型：

+   类

+   闭包

你在这本书中已经看到了这两种对象类型。例如，你创建的所有`UIViewController`子类都是引用类型。你用作回调或执行动画的所有闭包也是引用类型。

那么，如果某物是引用类型，这意味着什么？为什么这对你很重要？嗯，引用类型具有可以既方便又非常令人沮丧的行为，这取决于你试图在代码中实现什么。

引用类型和类独有的一个特性是能够进行子类化。唯一可以从另一个对象继承功能的是类。当你学习到类型之间的区别时，这将会被更深入地探讨，但了解这些信息已经很好了。让我们通过在游乐场中编写一些代码来近距离考察引用类型。

在 Xcode 中创建一个新的游乐场项目，并给它起任何你喜欢的名字。然后，添加以下代码：

```swift
class Pet {
    var name: String

    init(name: String) {
        self.name = name
    }
}
func printName(for pet: Pet) {
    print(pet.name)
}
let cat = Pet(name: "Jesse")
printName(for: cat)
```

很可能，你对这段小代码并不太兴奋。它所做的只是定义一个新的 `Pet` 类，创建一个实例，然后将该实例传递给 `printName(for:)`。然而，这段代码非常适合说明引用类型是什么。

当你调用 `printName(for: cat)` 时，你将你的 `cat` 实例的 *引用* 传递给 `printName(for:)`。这意味着任何获得这个引用的人都可以修改被引用的对象。如果这听起来很困惑，那没关系。

将以下代码添加到你所创建的游乐场中，然后运行它：

```swift
func printName2(for pet: Pet) {
    print(pet.name)
    pet.name = "Pugwash"
}
let dog = Pet(name: "Astro")
printName2(for: dog)
print(dog.name)
```

运行这段代码后，你在控制台里注意到什么？

如果你注意到狗的名字从 `Astro` 变成了 `Pugwash`，你刚刚观察到了传递引用的含义。

由于 `printName2(for:)` 接收了你的 `Pet` 实例的引用，它能够改变它的名字。如果你在其他语言中编程过，这对你来说可能很显然。如果没有，这可能会让你感到非常惊讶。

还有一点你应该注意，`dog` 被声明为常量。尽管如此，你仍然能够将你的实例的名字从 `Astro` 改成 `Pugwash`。

如果你认为这是显而易见的，请在你的游乐场中添加以下代码并运行它：

```swift
let point = CGPoint(x: 10, y: 10)
point.x = 10
```

这段代码与你之前对 `Pet` 实例所做的是非常相似的。你创建了一个常量实例，然后改变它的一个属性。然而，这次，当你尝试运行你的游乐场时，你应该会看到以下错误：

```swift
Cannot assign to property: 'point' is a 'let' constant
```

尽管你到目前为止实现的代码相当短，但它很好地展示了引用类型。你目前看到了引用类型的两个特性在行动：

+   任何接收引用类型实例的人都可以修改它。

+   你可以在引用类型上更改属性，即使持有引用类型的属性被声明为常量。

这两个特性是引用类型的典型特征。引用类型之所以这样工作，是因为被分配引用类型的变量或常量 *不包含或拥有* 对象。常量或变量只指向内存中存储实例的地址。

任何时候你创建引用类型的实例，它都会写入 RAM，在那里它将在特定的地址存在。RAM 是一种计算机使用的特殊内存类型，例如 iPhone，用于临时存储某个程序使用的数据。

当你将引用类型的实例分配给属性时，该属性将有一个 **指针** 指向该实例的内存地址。让我们再次看看以下代码行：

```swift
let dog = Pet(name: "Astro")
```

现在 `dog` 常量指向内存中存储 `Pet` 实例的特定地址。只要基本内存地址没有改变，你就可以更改 `Pet` 实例上的属性。

实际上，理论上你可以在那个内存地址处放置完全不同的内容，而 `let dog` 不会在意，因为它仍然指向相同的地址。

由于同样的原因，`printName2(for:)` 可以更改宠物的名称。你不需要传递 `Pet` 的实例，而是传递实例预期存在的内存地址。`printName2(for:)` 对 `Pet` 实例进行更改是可以的，因为它不会更改内存中的基本地址。

如果你尝试通过以下方式将新实例分配给 `dog`，你会得到一个错误：

```swift
dog = Pet(name: "Iro")
```

这种错误发生的原因是你不能更改 `dog` 指向的内存地址，因为它是常量。

现在你已经知道了引用类型是什么以及它是如何工作的，你可能已经得出结论，前面例子中看到的 `CGPoint` 必须是值类型。接下来，让我们看看值类型究竟是什么。

## 与值类型一起工作

在引用类型的例子中，你看到了以下代码片段：

```swift
let point = CGPoint(x: 10, y: 10)
point.x = 10
```

乍一看，你可能会期望值类型是一种特殊的类，因为这段代码看起来像创建了名为 `CGPoint` 的类的实例。你的观察是正确的，但你的结论是错误的。`CGPoint` 实际上根本不是类。

类本质上是引用类型，它们永远不会变成其他类型。那么，值类型是什么呢？

被视为值类型的对象有两种：

+   结构体

+   枚举

这两种类型都大不相同，所以让我们确保你首先理解值类型的基本知识，然后你将学习这两种类型各自是什么。

让我们再次看看 `Pet` 的例子，但使用结构体而不是类。

在 Xcode 中创建一个新的游乐场页面，再次将其命名为你喜欢的任何名称。

一旦创建，请添加以下代码：

```swift
struct Pet {
    var name: String
}
func printName(for pet: Pet) {
    print(pet.name)
    pet.name = "Jesse"
}
let dog = Pet(name: "Astro")
printName(for: dog) 
print(dog.name)
```

你会立即注意到 Xcode 会报错。

控制台中应该看到的错误告诉你 `pet` 是一个 `let` 常量，你不允许更改它的名称。你可以通过更新 `printName` 将 `pet` 转换为变量，如下所示：

```swift
func printName(for pet: Pet) {
    var pet = pet
    print(pet.name)
    pet.name = "Jesse"
}
```

如果你现在运行你的游乐场，请确保仔细查看控制台。你会注意到在第二次打印中宠物的名字保持不变。

这展示了值类型的一个关键特性。不是传递内存地址的引用，而是传递对象的副本。这也解释了为什么不允许在赋值给常量的值类型上更改属性。

改变那个属性会改变值类型的值，因此也会改变常量的值。这也意味着当你将`dog`传递给`printName`时，你传递的是`Pet`实例的副本给`printName`，这意味着对该实例所做的任何更改都是局部的，并且不会应用到`dog`上，在这种情况下。

这种行为使得使用值类型极其安全，因为其他对象或函数很难对值类型进行不希望的改变。此外，如果你将某个东西定义为常量，它确实就是一个常量。值类型的另一个特点是它们通常非常快速且轻量，因为它们可以存在于栈上，而引用类型存在于堆上。当你我们比较引用类型和值类型时，你将了解更多关于这方面的内容。

现在你对值类型有了基本的了解，让我们来看看具体的值类型。

## 理解结构体

结构体的定义方式与类相似。如果你看看你之前定义的`Pet`类，可能会忽略它实际上是一个结构体的事实。如果你仔细观察，你会注意到一个很大的不同：你不需要为结构体编写初始化器！Swift 可以自动为结构体生成初始化器。这非常方便，并且可以为你节省大量的输入，特别是对于较大的结构体。

结构体也不能从其他对象继承功能。这意味着结构体始终有一组非常平坦且透明的属性和方法。这允许编译器对你的代码进行优化，使得结构体非常轻量且快速。

然而，结构体可以遵循协议。Swift 标准库充满了定义许多内置类型功能的协议，例如`Array`、`Dictionary`和`Collection`。这些内置类型中的大多数都是作为采用一个或多个协议的结构体实现的。

关于结构体，你需要了解的最后一件事是它们对是否可以被修改非常严格。考虑一个如下所示的结构体：

```swift
struct Car {
    var fuelRemaining: Double

    func fillFuelTank() {
        fuelRemaining = 1
    }
}
```

这个结构体会导致编译器抛出错误。

结构体默认是不可变的，这意味着你不能改变它的任何值。当方法可以修改或改变结构体时，你需要让编译器明确这一点。你可以通过在函数中添加`mutating`关键字来实现，如下所示：

```swift
mutating func fillFuelTank() {
    fuelRemaining = 1
}
```

当你创建一个`Car`常量实例并在其上调用`fillFuelTank()`时，编译器将再次报错。如果你在`let`实例上调用一个修改函数，你将修改实例，这意味着属性的值会改变。因此，你只能对变量属性调用修改函数。

## 理解枚举

枚举是一种包含有限预定义值的类型。枚举通常用于表示特定状态或操作的特定结果。了解这意味着什么最好的方式是查看一个表示交通灯状态的枚举示例：

```swift
struct TrafficLight {
    var state: TrafficLightState
}
enum TrafficLightState {
    case green
    case yellow
    case red
}
```

这个示例展示了一个具有`state`属性的`TrafficLight`结构体。这个属性的类型是`TrafficLightState`，它是一个枚举。

`TrafficLightState` 定义了交通灯的三个可能状态。这非常方便，因为这样的枚举可以消除错误状态的可能性，因为编译器现在可以强制你不会得到一个无效的值。

枚举也可以包含属性和方法，就像结构体一样。然而，枚举还可以有一个*关联值*。这意味着每个可能的案例都可以在不同的类型中有表示，例如字符串。

如果你像这里所示修改`TrafficLightState`，它将为`rawValue`具有`String`：

```swift
enum TrafficLightState: String {
    case green
    case yellow
    case red
}
```

如果你 Swift 可以推断出原始值，你不需要做任何更多的事情，只需将原始值的类型添加到枚举的类型声明中即可。在这个示例中，`green`枚举情况的原始值将是`green`字符串。如果你需要将枚举映射到不同的类型，这可能很有用——例如，将其设置为标签的文本。

就像结构体一样，枚举不能从其他对象继承功能，但它们可以遵循协议。你通过扩展使枚举遵循协议，就像你为类和结构体做的那样。

这总结了值类型的探索。现在你了解了值类型和引用类型是什么，让我们探索它们之间的一些差异！

# 理解类型之间的差异

了解 Swift 中可用的类型——了解它们的相似之处和，更重要的是，它们的差异——将帮助你做出更好的决策，关于你编写代码的方式。前面的部分已经列出了值类型和引用类型的几个属性。更具体地说，你学到了很多关于类、结构体和枚举的知识。闭包也是引用类型，因为它们是通过它们在内存中的位置而不是它们的值来传递的，但在这个上下文中没有太多可说的。

你能做的最明显的比较可能是结构体和类之间的比较。它们看起来非常相似，但它们具有非常不同的特性，正如你之前所看到的。枚举是另一种特殊类型；它们代表一组固定可能值的值，但在其他方面与结构体非常相似。

你需要理解的最重要区别是值类型和引用类型的一般区别，以及结构体和类之间的具体区别。让我们首先看看值类型和引用类型，这样你就能有一个大致的了解。然后，你将学习结构体和类之间的具体区别。

## 比较值类型和引用类型

当比较值类型和引用类型时，区分作为开发者可见的差异以及 Swift 内部差异以及你的应用最终的工作方式是至关重要的。了解这些细节将确保你可以做出考虑所有影响的明智决策，而不仅仅是关注内存使用或开发者便利性。

让我们先检查更明显和可见的差异。之后，你将了解每种类型的内存影响。

## 使用差异

创建一个新的游乐场，再次给它起一个你喜欢的名字，并添加以下代码：

```swift
protocol PetProtocol {
    var name: String { get }
    var ownerName: String { get set }

}
class Animal {
    let name: String
    init(name: String) {
        self.name = name
    }
}
class Pet: Animal, PetProtocol {
    var ownerName: String

    init(name: String, ownerName: String) {
        self.ownerName = ownerName
        super.init(name: name)
    }
}
```

此代码定义了一个 `PetProtocol`，该协议要求所有符合此协议的对象都必须存在两个属性。`name` 属性被定义为常量，因为它只需要可获取性，而 `ownerName` 是变量，因为它需要 `get` 和 `set`。代码还定义了 `Animal` 和 `Pet` 类。`Pet` 是 `Animal` 的子类，并且它符合 `PetProtocol`，因为 `Animal` 满足 `name` 常量要求，而 `Pet` 本身满足 `ownerName` 变量要求。

尝试将 `class` 声明更改为 `struct`。现在你的游乐场将无法编译，因为结构体不能像类一样继承其他对象。这是一个有时会令人沮丧的限制，因为你可能会遇到大量的代码重复。想象一下，除了 `Pet` 之外，你还想创建更多类型的动物，比如 `WildAnimal` 或 `SeaCreature`。这可以通过类来实现，因为你可以从 `Animal` 继承。对于结构体来说，这是不可能的，所以你必须将这些类型作为结构体实现，它们需要复制它们的 `Animal` 逻辑。

值类型和引用类型之间的另一个区别是它们在传递时的行为。将以下代码添加到你的游乐场中：

```swift
class ImageInformation {
    var name: String
    var width: Int
    var height: Int

    init(name: String, width: Int, height: Int) {
        self.name = name
        self.width = width
        self.height = height
    }
}
struct ImageLocation {
    let location: String
    let isRemote: Bool
    var isLoaded: Bool
}
let info = ImageInformation(name: "ImageName", width: 100, height: 100)
let location = ImageLocation(location: "ImageLocation", isRemote: false, isLoaded: false)
```

`info` 和 `location` 的声明看起来非常相似，但它们的底层类型完全不同。尝试编写一个函数，该函数接受 `ImageLocation` 和 `ImageInformation` 作为参数。然后，尝试更新 `location` 的 `isLoaded` 属性和 `info` 的 `name` 属性。当你尝试设置 `isLoaded` 时，编译器会报错，因为 `ImageLocation` 的参数是一个 `let` 常量。这个原因在关于值类型的讨论中已经描述过。

值类型是通过值传递的，这意味着改变参数的属性将完全改变值。函数的参数始终是常量。然而，当你使用引用类型时，这可能并不明显，因为改变函数内部`ImageInformation`上的`name`属性是完全可行的。这是因为当你将引用类型传递给函数时，你并没有传递整个值；你传递的是内存地址的引用。这意味着，而不是值是常量，底层的内存地址是常量。这反过来意味着你可以随意更改内存中的任何内容；你只是不能改变常量所指向的地址。

想象一下，你需要开车去某人的家，他们给你他们住址。这就是传递引用类型的感觉。他们不会给你整个房子，而是给你他们家的地址。在你开车去他们家的路上，房子可能会以许多方式改变。房主可能会粉刷它，或者更换窗户或门，任何事都可能。最后，你仍然能找到房子，因为你收到了这个房子的地址，而且只要房主不搬到一个不同的地址，你就能找到正确的房子。

如果你将这个类比改为使用值类型，那么你要找的那个人会直接给你他们房子的完整副本。所以，你不会根据地址开车去他们的家；他们不会给你地址；他们只会给你他们的整个房子。如果房主对其房子的副本进行了更改，除非他们给你一个新的副本，否则你将无法在你的房子副本上看到这些更改的反映。这也适用于你对房子副本所做的任何修改。

你可以想象，在某些情况下，发送某物的副本而不是地址可能非常高效。房子的例子可能有点极端，但我很确定，如果你订购一个包裹，你更愿意收到包裹本身而不是收到一个去取包裹的地址。这种效率就是你在接下来通过比较值类型和引用类型在内存分配方面的行为时将要了解的内容。

# 决定使用哪种类型

在你的应用程序中使用错误类型的对象可能会对你的应用程序产生多方面的不良影响。例如，如果你的应用程序中某个意外的位置修改了引用类型，你的应用程序可能会遭受不想要的副作用。或者，如果你在某些地方使用结构体而不是类，你可能会遇到大量的重复逻辑。如果你的应用程序选择了慢速引用类型而不是更好的值类型，你的应用程序甚至可能在性能方面受到影响。

你应该始终评估哪种类型的对象最适合你的当前用例，以确保你的代码在可维护性和性能之间达到平衡的权衡。

## 何时应该使用引用类型？

使用引用类型的绝佳时机是当你正在继承内置类，例如`UIViewController`时。在这些情况下，与系统作斗争是没有意义的，因为这肯定会造成更多的伤害而不是好处。另一个使用引用类型的时机是当你创建自己的代理协议时。

代理最好实现为弱引用类型。这意味着充当代理的对象被对象弱引用，以避免内存泄漏。

由于值类型是通过复制来传递的，因此对它们有弱引用是没有意义的。在这种情况下，你唯一的选择是使用引用类型。

如果你认为传递某个对象的副本没有意义，你也需要一个引用类型。如果你回想起开车去别人家的例子，传递房子的地址比给每个人提供房子的完整副本更有意义。你可能会认为房子有一个身份。

这意味着每一栋房子都是**独特**的；只有一个房子拥有那个确切的地址，复制它也没有意义。如果你正在处理一个复制它没有意义的对象，你很可能希望将其实现为引用类型，这样所有接收该类型实例的人都在查看同一个实例。

选择引用类型的最后一个原因是，如果它可以通过继承来节省大量代码。很多人认为继承是糟糕的，你通常可以避免它，但有时使用类层次结构工作会更有意义。

缺点是，许多子类可能导致功能混乱的类，这些类包含为节省几个子类中的打字而保存的功能，尽管这些功能并不适用于所有子类。但就像许多工具一样，如果正确使用，继承可以非常方便；使用它本身并不是固有的坏处。

## 何时使用值类型

人们常说，你应该始终从结构体开始，并在需要时更改到其他类型。这在很多情况下都是很好的建议，因为结构体通常适用于大多数情况。然而，结构体并不是唯一的价值类型，始终避免盲目使用某些东西总是好的。

如果你需要一个表示有限可能状态或结果的对象，例如网络连接状态、交通灯状态或应用的有效配置选项的有限集，你很可能需要一个枚举。

尽管值类型的价值语义使它们很棒，但枚举是避免拼写错误和表示状态的好方法。由于其本质，通常很清楚何时应该使用枚举。

结构体用于没有身份的对象。换句话说，传递它的副本是有意义的。一个很好的例子是当你创建一个可以与网络或数据库通信的结构体时。这个结构体将没有身份，因为它主要是一组属性和方法，这些属性和方法与结构体的单个版本没有关联。

一个结构体的好例子是你在本节开头读到的 `CGPoint` 结构体。`CGPoint` 表示二维网格中的一个位置。它没有身份，传递它的副本是有意义的。它只包含两个属性，因此不需要任何继承。这些特性使它成为实现为值类型的绝佳候选者。

如果你遵循始终从结构体开始的建议，试着找出你的新对象为什么不应该是一个结构体的原因。如果你找到一个不使用结构体的好理由，那么就将其改为类。通常，你不会找到使用类而不是结构体的好理由。如果是这种情况，将你的新对象改为结构体；你总是可以在以后切换到使用类。由于结构体对可变性的严格规则以及缺乏子类化，从类切换到结构体通常更困难。

# 摘要

在本章中，你学习了关于值类型和引用类型的大量知识。你学习了每种类型是什么以及如何使用它们。你了解到你可以在 Swift 中使用类、闭包、结构体和枚举，并且每种对象类型都有其自身的优缺点。

在了解了所有类型之后，你看到了值类型和引用类型是如何相互比较的，这为每种类型的有时微妙有时明显的使用案例提供了一些启示。你了解到结构体不能作为子类，而类可以。你还了解到传递值类型会传递每个实例的副本，而传递引用类型则不会复制每个实例，而是传递指向内存地址的指针。然后，你学习了每种类型在内存中的存储方式以及这对你创建的对象的性能意味着什么。

最后，你了解到如何通过使用一些经验法则来选择值类型和引用类型，这些法则应该可以使选择结构体、类和枚举变得相当直接，而无需盲目选择。下一章将通过展示如何使用 Swift 的泛型编写超灵活的代码，将你的 Swift 知识提升到一个新的层次。
