- en: Kotlin – Data Types, Objects, and Classes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin – 数据类型、对象和类
- en: In this chapter, we'll cover Kotlin's type system, **object-oriented programming** (**OOP**)
    with Kotlin, modifiers, destructuring declarations, and more.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍Kotlin的类型系统、**面向对象编程**（OOP）与Kotlin、修饰符、解构声明等。
- en: Kotlin is, primarily, an OOP language with some functional features. When we
    use OOP languages to resolve problems, we try to model the objects that are a
    part of our problem in an abstract way with the information that is relevant to
    the problem.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin主要是一种面向对象（OOP）语言，同时具有一些函数式特性。当我们使用面向对象的语言来解决问题时，我们试图以与问题相关的信息以抽象的方式模拟问题中的一部分对象。
- en: If we're designing an HR module for our company, we'll model employees with
    state or data (name, date of birth, social security number, and others) and behavior
    (pay salary, transfer to another division, and others). Because a person can be
    very complex, there is information that isn't relevant for our problem or domain.
    For example, the employee's favorite style of bicycle isn't relevant for our HR
    system, but it is very relevant for an online cycling shop.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为公司设计一个HR模块，我们将用状态或数据（姓名、出生日期、社会保险号等）和行为（支付薪水、调到另一个部门等）来模拟员工。因为一个人可能非常复杂，有些信息对于我们的问题或领域并不相关。例如，员工的自行车喜好风格对于我们的HR系统并不相关，但对于在线自行车店来说却非常相关。
- en: Once we identify the objects (with data and behavior) and the relationship with
    other objects of our domain, we can start developing and writing the code that
    we'll make a part of our software solution. We'll use language constructs (construct
    is a fancy way to say allowed syntax) to write the objects, categories, relationships,
    and so on.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们确定了对象（包括数据和行为）以及它们与我们领域其他对象的关系，我们就可以开始开发和编写代码，这些代码将成为我们软件解决方案的一部分。我们将使用语言结构（结构是一种说法，指的是允许的语法）来编写对象、类别、关系等等。
- en: 'Kotlin has many constructs that we can use to write our programs and, in this
    chapter, we''ll cover many of those constructs, such as:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有许多我们可以用来编写程序的构造，在本章中，我们将介绍其中许多构造，例如：
- en: Classes
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类
- en: Inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 继承
- en: Abstract classes
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象类
- en: Interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口
- en: Objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象
- en: Generics
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型
- en: Type alias
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型别名
- en: Null types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 空类型
- en: Kotlin's type system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin的类型系统
- en: Other types
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他类型
- en: Classes
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: '**Classes** are the foundational type in Kotlin. In Kotlin, a class is a template
    that provides a state, a behavior, and a type to instances (more on that later).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**类**是Kotlin中的基础类型。在Kotlin中，类是一个模板，它为实例提供状态、行为和类型（稍后会有更多介绍）。'
- en: 'To define a class, only a name is required:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 定义一个类只需要一个名称：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '`VeryBasic` is not very useful, but is still a valid Kotlin syntax.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`VeryBasic`不是非常有用，但仍然是一个有效的Kotlin语法。'
- en: 'The `VeryBasic` class doesn''t have any state or behavior; nonetheless, you
    can declare values of type `VeryBasic`, as shown in the following code:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`VeryBasic`类没有任何状态或行为；尽管如此，你仍然可以声明`VeryBasic`类型的值，如下面的代码所示：'
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As you can see, the `basic` value has a `VeryBasic` type. To express it differently,
    `basic` is an instance of `VeryBasic`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，`basic`值具有`VeryBasic`类型。用不同的方式表达，`basic`是`VeryBasic`的一个实例。
- en: 'In Kotlin, types can be inferred; so, the previous example is equivalent to
    the following code:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，类型可以被推断；因此，前面的例子等同于以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By being a `VeryBasic` instance, `basic` has a copy of the `VeryBasic` type's
    state and behavior, namely, none. So sad.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`basic`是一个`VeryBasic`实例，它具有`VeryBasic`类型的副本状态和行为，即没有。真是太遗憾了。
- en: Properties
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性
- en: 'As discussed previously, classes can have a state. In Kotlin, a class''s state
    is represented by **properties**. Let''s have a look at the blueberry cupcake
    example:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，类可以有状态。在Kotlin中，类状态由**属性**表示。让我们看看蓝莓纸杯蛋糕的例子：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The  `BlueberryCupcake` class has an *has-a* property `flavour` of type `String`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlueberryCupcake`类有一个`has-a`属性`flavour`，其类型为`String`。'
- en: 'Of course, we can have instances of the `BlueberryCupcake` class:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以有`BlueberryCupcake`类的实例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, because we declare the `flavour` property as a variable, its internal
    value can be changed at runtime:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，因为我们声明了`flavour`属性为变量，它的内部值可以在运行时被改变：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'That is impossible in real life. Cupcakes do not change their flavor (unless
    they become stale). If we change the `flavour` property to a value, it cannot
    be modified:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中这是不可能的。纸杯蛋糕不会改变它们的味道（除非它们变陈了）。如果我们将`flavour`属性更改为一个值，它就不能被修改：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s declare a new class for almond cupcakes:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个新的类来表示杏仁纸杯蛋糕：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is something fishy here. `BlueberryCupcake` and `AlmondCupcake` are identical
    in structure; only an internal value is changed.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有些奇怪。`BlueberryCupcake`和`AlmondCupcake`在结构上相同；只是内部值发生了变化。
- en: 'In real life, you don''t have different baking tins for different cupcake flavors.
    The same good quality baking tin can be used for various flavors. In the same
    way, a well-designed `Cupcake` class can be used for different instances:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实生活中，你不需要为不同的纸杯蛋糕风味准备不同的烤盘。同一个高质量的烤盘可以用于各种风味。同样，一个设计良好的`Cupcake`类可以用于不同的实例：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Cupcake` class has a constructor with a parameter, `flavour`, that is assigned
    to a `flavour` value.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cupcake`类有一个带有参数`flavour`的构造函数，该参数被分配给`flavour`值。'
- en: 'Because this is a very common idiom, Kotlin has a little syntactic sugar to
    define it more succinctly:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个非常常见的习语，Kotlin 有一些语法糖来更简洁地定义它：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, we can define several instances with different flavors:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以定义具有不同风味的几个实例：
- en: '[PRE10]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Methods
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 方法
- en: 'In Kotlin, a class''s behavior is defined by methods. Technically, a **method**
    is a member function, so, anything that we learn about functions in the following
    chapters also applies to the methods:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，一个类的行为由方法定义。技术上，**方法**是一个成员函数，因此，我们在以下章节中学到的关于函数的知识也适用于方法：
- en: '[PRE11]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `eat()` method returns a `String` value. Now, let''s call the `eat()` method,
    as shown in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`eat()`方法返回一个`String`值。现在，让我们调用`eat()`方法，如下面的代码所示：'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following expression is the output of the preceding code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表达式是前面代码的输出：
- en: '![](img/bb269540-7a2c-44fa-806b-ddf52f7597cf.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb269540-7a2c-44fa-806b-ddf52f7597cf.png)'
- en: Nothing mind-blowing, but this is our first method. Later on, we'll do more
    interesting stuff.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 没有什么令人震惊的，但这是我们第一个方法。稍后，我们会做更多有趣的事情。
- en: Inheritance
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承
- en: As we continue modelling our domain in Kotlin, we realize that specific objects
    are quite similar. If we go back to our HR example, an employee and a contractor
    are quite similar; both have a name, a date of birth, and so on; they also have
    some differences. For example, a contractor has a daily rate, while an employee
    has a monthly salary. It is obvious that they are similar—both of them are people;
    people is a superset where both contractor and employee belong. As such, both
    have their own specific features that make them different enough to be classified
    into different subsets.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续在 Kotlin 中建模我们的领域，我们发现具体对象相当相似。如果我们回到我们的人力资源示例，员工和承包商相当相似；他们都有名字、出生日期等；他们也有一些差异。例如，承包商有日工资，而员工有月薪。很明显，他们是相似的——他们都是人；人是包含承包商和员工的超集。因此，他们都有自己独特的特征，使他们足够不同，可以分类到不同的子集中。
- en: This is what inheritance is all about, there are groups and subgroups and there
    are relationships between them. In an inheritance hierarchy, if you go up in the
    hierarchy, you will see more general features and behaviors, and if you go down,
    you will see more specific ones. A burrito and a microprocessor are both objects,
    but they have very different purposes and uses.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是继承的全部内容，有组和子组，它们之间有联系。在继承层次结构中，如果你向上移动层次结构，你会看到更多通用特性和行为，如果你向下移动，你会看到更具体的行为。玉米卷和微处理器都是对象，但它们有不同的用途和用途。
- en: 'Let''s introduce a new `Biscuit` class:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个新的`Biscuit`类：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, this class looks almost exactly same as `Cupcake`. We could refactor
    these classes to reduce code duplication:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，这个类看起来几乎与`Cupcake`完全相同。我们可以重构这些类以减少代码重复：
- en: '[PRE14]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We introduced a new `BakeryGood` class, with the shared behavior and state of
    both `Cupcake` and `Biscuit` classes and we made both classes extend `BakeryGood`.
    By doing so, `Cupcake` (and `Biscuit`) has an *is-a* relationship with `BakeryGood`
    now; on the other hand, `BakeryGood` is the `Cupcake` class's super or parent
    class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们引入了一个新的`BakeryGood`类，它具有`Cupcake`和`Biscuit`类的共享行为和状态，并且我们让这两个类都扩展了`BakeryGood`。通过这样做，`Cupcake`（和`Biscuit`）现在与`BakeryGood`有了一个*是*关系；另一方面，`BakeryGood`是`Cupcake`类的超类或父类。
- en: Note that `BakeryGood` is marked as `open`. This means that we specifically
    design this class to be extended. In Kotlin, you can't extend a class that isn't `open`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`BakeryGood`被标记为`open`。这意味着我们特别设计了这个类以便扩展。在 Kotlin 中，你不能扩展一个不是`open`的类。
- en: 'The process of moving common behaviors and states to a parent class is called
    **generalisation**. Let''s have a look at the following code:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 将常见的行为和状态移动到父类的过程称为**泛化**。让我们看一下下面的代码：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let''s try out our new code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试我们的新代码：
- en: '![](img/068015b9-405f-4a9d-b1a6-77986d9fbfd4.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/068015b9-405f-4a9d-b1a6-77986d9fbfd4.png)'
- en: 'Bummer, not what we were expecting. We need to refract it more:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 唉，这不是我们预期的。我们需要进一步折射它：
- en: '[PRE16]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'It works! Let''s have a look at the output:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 它工作了！让我们看看输出结果：
- en: '![](img/b658a569-6f48-4c67-8ddb-d491338b4481.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b658a569-6f48-4c67-8ddb-d491338b4481.png)'
- en: We declared a new method, `name()`; it should be marked as `open`, because we
    designed it to be optionally altered in its subclasses.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个新的方法，`name()`；它应该被标记为 `open`，因为我们设计它可以在其子类中可选地修改。
- en: Modifying a method's definition on a subclass is called **override** and that
    is why the `name()` method in both subclasses is marked as `override`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在子类中修改方法定义称为 **重写**，这就是为什么两个子类中的 `name()` 方法都被标记为 `override`。
- en: The process of extending classes and overriding behavior in a hierarchy is called
    **specialisation**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中扩展类和重写行为的过程称为 **特殊化**。
- en: Rule of thumb
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 经验法则
- en: Put general states and behaviors at the top of the hierarchy (generalisation),
    and specific states and behaviors in subclasses (specialisation).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将一般状态和行为放在层次结构的顶部（泛化），将特定状态和行为放在子类中（特殊化）。
- en: 'Now, we can have more bakery goods! Let''s have a look at the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以有更多的面包店商品了！让我们看看下面的代码：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Subclasses can be extended too. They just need to be marked as `open`:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 子类也可以被扩展。它们只需要被标记为 `open`：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We can also create classes with more properties and methods.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建具有更多属性和方法的方法。
- en: Abstract classes
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象类
- en: 'So far, so good. Our bakery looks good. However, we have a problem with our
    current model. Let''s look at the following code:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们的面包店看起来不错。然而，我们当前模型有一个问题。让我们看看下面的代码：
- en: '[PRE19]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We can instantiate the `BakeryGood` class directly, which is too generic. To
    correct this situation, we can mark `BakeryGood` as `abstract`:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以直接实例化 `BakeryGood` 类，这太通用。为了纠正这种情况，我们可以将 `BakeryGood` 标记为 `abstract`：
- en: '[PRE20]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: An **abstract class** is a class designed solely to be extended. An abstract
    class can't be instantiated, which fixes our problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象类** 是一个专为扩展而设计的类。抽象类不能被实例化，这解决了我们的问题。'
- en: What makes `abstract` different from `open`?
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是 `abstract` 与 `open` 的不同之处？
- en: Both modifiers let us extend a class, but `open` lets us instantiate while `abstract`
    does not.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个修饰符都允许我们扩展一个类，但 `open` 允许我们实例化，而 `abstract` 不允许。
- en: 'Now that we can''t instantiate, our `name()` method in the `BakeryGood` class
    isn''t that useful anymore, and all our subclasses, except for `CinnamonRoll`,
    override it anyway (`CinnamonRoll` relays on the `Roll` implementation):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们不能实例化，`BakeryGood` 类中的 `name()` 方法就不再那么有用，而且除了 `CinnamonRoll` 之外的所有子类都重写了它（`CinnamonRoll`
    依赖于 `Roll` 的实现）：
- en: '[PRE21]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: A method marked as `abstract` doesn't have a body, just the signature declaration
    (a method signature is a way to identify a method). In Kotlin, a signature is
    composed of the method's name, its number, the type of parameters, and the return
    type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 被标记为 `abstract` 的方法没有主体，只有签名声明（方法签名是识别方法的一种方式）。在 Kotlin 中，签名由方法名、参数数量、参数类型和返回类型组成。
- en: Any class that extends `BakeryGood` directly must override the `name()` method.
    The technical term for overriding an abstract method is **implement** and, from
    now on, we will use it. So, the `Cupcake` class implements the `name()` method
    (Kotlin doesn't have a keyword for method implementation; both cases, method implementation,
    and method overriding, use the keyword `override`).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 任何直接扩展 `BakeryGood` 的类都必须重写 `name()` 方法。重写抽象方法的术语是 **实现**，从现在起，我们将使用它。所以，`Cupcake`
    类实现了 `name()` 方法（Kotlin 没有用于方法实现的关键字；方法实现和方法重写都使用关键字 `override`）。
- en: 'Let''s introduce a new class, `Customer`; a bakery needs customers anyway:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们引入一个新的类，`Customer`；面包店总是需要顾客的：
- en: '[PRE22]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `eats(food: BakeryGood)` method takes a `BakeryGood` parameter, so any
    instance of any class that extends the `BakeryGood` parameter, it doesn''t matter
    how many hierarchy levels. Just remember that we can instantiate `BakeryGood`
    directly.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`eats(food: BakeryGood)` 方法接受一个 `BakeryGood` 参数，因此任何扩展 `BakeryGood` 参数的类的实例，无论有多少层等级。只需记住，我们可以直接实例化
    `BakeryGood`。'
- en: What happens if we want a simple `BakeryGood`? For example, testing.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要一个简单的 `BakeryGood` 呢？例如，进行测试。
- en: 'There is an alternative, an anonymous subclass:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个替代方案，一个匿名子类：
- en: '[PRE23]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: A new keyword is introduced here, `object`. Later on, we'll cover `object` in
    more detail, but for now, it is enough to know that this is an **object expression**.
    An object expression defines an instance of an anonymous class that extends a
    type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这里引入了一个新关键字，`object`。稍后我们将更详细地介绍 `object`，但就目前而言，只需知道这是一个 **对象表达式**。对象表达式定义了一个匿名类的实例，该类扩展了一个类型。
- en: In our example, the object expression (technically, the **anonymous class**)
    must override the `name()` method and pass a value as the parameter for the `BakeryGood`
    constructor, exactly as a standard class would do.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，对象表达式（技术上，是 **匿名类**）必须重写 `name()` 方法，并将值作为参数传递给 `BakeryGood` 构造函数，就像标准类一样。
- en: 'Remember that an `object` expression is an instance, so it can be used to declare
    values:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个 `object` 表达式是一个实例，因此它可以用来声明值：
- en: '[PRE24]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Interfaces
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口
- en: The open and abstract classes are great for creating hierarchies, but sometimes
    they aren't enough. Some subsets can span between apparently unrelated hierarchies,
    for example, birds and great apes are bipedal, and both are animals and vertebrates,
    but they not directly related. That is why we need a different construct and Kotlin
    gives us interfaces (other languages deal with this problem differently).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 公开和抽象类非常适合创建层次结构，但有时它们不够用。一些子集可能跨越看似无关的层次结构，例如，鸟类和大型灵长类动物都是两足动物，它们都是动物和脊椎动物，但它们并不直接相关。这就是为什么我们需要不同的结构，Kotlin
    给我们提供了接口（其他语言以不同的方式处理这个问题）。
- en: 'Our bakery goods are great, but we need to cook them first:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的面包店产品很棒，但我们需要先烹饪它们：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: With our new `bake()` method , it will cook all our amazing products, but wait,
    donuts aren't baked, but fried.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新的 `bake()` 方法将烹饪我们所有惊人的产品，但是等等，甜甜圈不是烘焙的，而是油炸的。
- en: 'What if we could move the  `bake()` method to a second abstract class, `Bakeable`?
    Let''s try it in the following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能把 `bake()` 方法移动到第二个抽象类 `Bakeable` 中会怎样？让我们在下面的代码中尝试一下：
- en: '[PRE26]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Wrong! In Kotlin, a class can''t extend two classes at the same time. Let''s
    have a look at the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 错误！在 Kotlin 中，一个类不能同时扩展两个类。让我们看看下面的代码：
- en: '[PRE27]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: However, it can extend many interfaces. An **interface** is a type that defines
    a behavior; in the `Bakeable` interface's case, that is the `bake()` method.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它可以扩展多个接口。一个 **接口** 是一个定义行为的类型；在 `Bakeable` 接口的情况下，那就是 `bake()` 方法。
- en: So, what are the differences between an open/abstract class and an interface?
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，公开/抽象类和接口之间的区别是什么？
- en: 'Let''s start with the following similarities:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下相似之处开始：
- en: Both are types. In our example, `Cupcake` has an *is-a* relationship with `BakeryGood`
    and has an *is-a* relationship with `Bakeable`.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都是类型。在我们的例子中，`Cupcake` 与 `BakeryGood` 有一个 *is-a* 关系，并且与 `Bakeable` 也有一个 *is-a*
    关系。
- en: Both define behaviors as methods.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们都通过方法定义行为。
- en: Although open classes can be instantiated directly, neither abstract classes
    nor interfaces can.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然公开类可以直接实例化，但抽象类和接口不行。
- en: 'Now, let''s look at the following differences:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下的不同之处：
- en: A class can extend just one class (open or abstract), but can extend many interfaces.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个类可以扩展一个类（公开或抽象），但不能扩展多个接口。
- en: An open/abstract class can have constructors.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开/抽象类可以有构造函数。
- en: An open/abstract class can initialize its own values. An interface's values
    must be initialized in the classes that extend the interface.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开/抽象类可以初始化自己的值。接口的值必须在扩展接口的类中初始化。
- en: An open class must declare the methods that can be overridden as open. An abstract
    class could have both open and abstract methods.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 公开类必须声明可以重写的公开方法。抽象类可以同时有公开和抽象方法。
- en: 'In an interface, all methods are open and a method with no implementation doesn''t
    need an abstract modifier:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在接口中，所有方法都是公开的，没有实现的方法不需要抽象修饰符：
- en: '[PRE28]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When should you use one or the other?:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 何时使用其中一个或另一个？：
- en: 'Use open class when:'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当使用公开/抽象类时：
- en: The class should be extended and instantiated
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类应该被扩展和实例化
- en: 'Use abstract class when:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要应用多重继承时使用抽象类：
- en: The class can't be instantiated
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类不能被实例化
- en: A constructor is needed it
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个构造函数
- en: There is initialization logic (using `init` blocks)
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存在初始化逻辑（使用 `init` 块）
- en: 'Let''s have a look at the following code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下代码：
- en: '[PRE29]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Use interface when:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要使用接口时：
- en: Multiple inheritances must be applied
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用公开类：
- en: No initialized logic is needed
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不需要初始化逻辑
- en: My recommendation is that you should always start with an interface. Interfaces
    are more straightforward and cleaner; they also allow a more modular design. In
    the case that data initialization/constructors are needed, move to abstract/open.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我的建议是，你应该始终从接口开始。接口更直接、更简洁；它们还允许更模块化的设计。如果需要数据初始化/构造函数，则可以转向抽象/开放的。
- en: 'As with abstract classes, object expressions can be used with interfaces:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 与抽象类一样，对象表达式可以与接口一起使用：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Objects
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象
- en: We already covered object expressions, but there is more on objects. **Objects**
    are natural singletons (by natural, I mean to come as language features and not
    as behavior pattern implementations, as in other languages). A **singleton** is
    a type that has just one and only one instance and every object in Kotlin is a
    singleton. That opens a lot of interesting patterns (and also some bad practices).
    Objects as singletons are useful for coordinating actions across the system, but
    can also be dangerous if they are used to keep global state.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了对象表达式，但关于对象还有更多内容。**对象**是自然的单例（这里的“自然”是指作为语言特性出现，而不是作为行为模式实现，如其他语言中的情况）。单例是一种只有一个实例的类型，并且
    Kotlin 中的每个对象都是单例。这打开了许多有趣的模式（以及一些不良实践）。作为单例的对象对于协调系统中的操作很有用，但如果不小心使用来保持全局状态，也可能很危险。
- en: 'Object expressions don''t need to extend any type:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对象表达式不需要扩展任何类型：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this case, the `expression` value is an object that doesn't have any specific
    type. We can access its properties and functions.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`expression` 值是一个没有特定类型的对象。我们可以访问其属性和函数。
- en: 'There is one restriction—object expressions without type can be used only locally,
    inside a method, or privately, inside a class:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个限制——没有类型的对象表达式只能在本地使用，即在方法内部，或者私有地，在类内部：
- en: '[PRE32]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this case, the `property` value can't be accessed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`property` 值无法访问。
- en: Object declarations
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 对象声明
- en: 'An object can also have a name. This kind of object is called an **object declaration**:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 对象也可以有一个名称。这种对象被称为 **对象声明**：
- en: '[PRE33]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Objects are singletons; you don''t need to instantiate `Oven` to use it. Objects
    also can extend other types:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 对象是单例；你不需要实例化 `Oven` 来使用它。对象还可以扩展其他类型：
- en: '[PRE34]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Companion objects
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 伴随对象
- en: 'Objects declared inside a class/interface can be marked as companion objects.
    Observe the use of companion objects in the following code:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在类/接口内部声明的对象可以被标记为伴随对象。观察以下代码中伴随对象的使用：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, methods inside the companion object can be used directly, using the class
    name without instantiating it:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，可以直接使用类名来使用伴随对象中的方法，而不需要实例化它：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Companion object''s methods can''t be used from instances:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象的方法不能从实例中使用：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Companion objects can be used outside the class as values with the name `Companion`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象可以作为具有名称 `Companion` 的值在类外部使用：
- en: '[PRE38]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Alternatively, a `Companion` object can have a name:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，`Companion` 对象也可以有一个名称：
- en: '[PRE39]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'They can also be used without a name, as shown in the following code:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也可以不命名使用，如下面的代码所示：
- en: '[PRE40]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Don't be confused by this syntax. The `Cupcake` value without parenthesis is
    the companion object; `Cupcake()` is an instance.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 不要被这种语法弄混淆。没有括号的 `Cupcake` 值是伴随对象；`Cupcake()` 是一个实例。
- en: Generics
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型
- en: This section is just a short introduction to generics; later, we'll cover it
    in detail.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这一部分只是泛型的一个简要介绍；稍后我们将详细讨论。
- en: '**Generic programming** is a style programming that focuses on creating algorithms
    (and collaterally, data structures) that work on general problems.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**泛型编程**是一种编程风格，它侧重于创建适用于一般问题的算法（以及相关数据结构）。'
- en: The Kotlin way to support generic programming is using type parameters. In a
    few words, we wrote our code with type parameters and, later on, we pass those
    types as parameters when we use them.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 支持泛型编程的方式是使用类型参数。简而言之，我们用类型参数编写代码，然后在需要使用时，将这些类型作为参数传递。
- en: 'Let''s take, for example, our `Oven` interface:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以我们的 `Oven` 接口为例：
- en: '[PRE41]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'An oven is a machine, so we could generalize it more:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 烤箱是一种机器，因此我们可以更广泛地推广它：
- en: '[PRE42]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `Machine<T>` interface defines a type parameter `T` and a method `process(T)`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Machine<T>` 接口定义了一个类型参数 `T` 和一个 `process(T)` 方法。'
- en: 'Now, we can extend it with `Oven`:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以用 `Oven` 来扩展它：
- en: '[PRE43]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now, `Oven` is extending `Machine` with the `Bakeable` type parameter, so the
    `process` method now takes `Bakeable` as a parameter.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`Oven` 使用 `Bakeable` 类型参数扩展了 `Machine`，因此 `process` 方法现在接受 `Bakeable` 作为参数。
- en: Type alias
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型别名
- en: '**Type alias** provides a way to define names of types that already exist.
    Type alias can help to make complex types easier to read, and can also provide
    other hints.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型别名**提供了一种定义已存在类型名称的方法。类型别名可以帮助使复杂类型更容易阅读，并且还可以提供其他提示。'
- en: 'The `Oven` interface is, in some sense, just a name, for a `Machine<Bakeable>`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在某种意义上，`Oven` 接口只是一个名称，代表一个 `Machine<Bakeable>`：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Our new type alias, `Oven`, is exactly like our good old `Oven` interface. It
    can be extended and have the values of the type `Oven`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们新的类型别名 `Oven` 与我们熟悉的 `Oven` 接口完全一样。它可以被扩展，并具有 `Oven` 类型的值。
- en: 'Types alias also can be used to enhance information on types, providing meaningful
    names related to your domain:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 类型别名也可以用来增强类型信息，提供与你的领域相关的有意义的名称：
- en: '[PRE45]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It can also be used on collections:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以用于集合：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'It can also be used with objects:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以与对象一起使用：
- en: '[PRE47]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Nullable types
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可空类型
- en: 'One of the main features of Kotlin is nullable types. **Nullable types** allow
    us to define if a value can contain or being null explicitly:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的一个主要特性是可空类型。**可空类型**允许我们显式地定义一个值是否可以包含或为空：
- en: '[PRE48]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'This isn''t valid in Kotlin; the `Cupcake` type doesn''t allow null values.
    To allow null values, `myBlueberryCupcake` must have a different type:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中这并不有效；`Cupcake` 类型不允许空值。要允许空值，`myBlueberryCupcake` 必须有不同的类型：
- en: '[PRE49]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In essence, `Cupcake` is a non-null type and `Cupcake?` is a nullable type.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，`Cupcake` 是一个非空类型，而 `Cupcake?` 是一个可空类型。
- en: 'In the hierarchical structure, `Cupcake` is a subtype of `Cupcake?`. So, in
    any situation where `Cupcake?` is defined, `Cupcake` can be used, but not the
    other way around:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在层次结构中，`Cupcake` 是 `Cupcake?` 的子类型。因此，在任何 `Cupcake?` 被定义的情况下，`Cupcake` 可以被使用，但反之则不行：
- en: '[PRE50]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Kotlin's compiler makes a distinction between instances of nullable and non-null
    types.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器在可空类型和非空类型实例之间做出区分。
- en: 'Let''s take these values, for example:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以这些值为例：
- en: '[PRE51]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Next, we will invoke the `eat()` method on both nullable and non-null types:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将对可空类型和非空类型都调用 `eat()` 方法：
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Calling the `eat()` method on `cupcake` is easy as pie; calling `eat()` on `nullableCupcake`
    is a compilation error.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `cupcake` 上调用 `eat()` 方法就像吃馅饼一样简单；在 `nullableCupcake` 上调用 `eat()` 会产生编译错误。
- en: Why? For Kotlin, calling a method from a nullable value is dangerous, a potential
    `NullPointerException` (**NPE** from now on) could be thrown. So, to be safe,
    Kotlin marks this as a compilation error.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么？对于 Kotlin 来说，从一个可空值中调用方法是有风险的，可能会抛出一个潜在的 `NullPointerException`（以下简称 **NPE**）。因此，为了安全起见，Kotlin
    将其标记为编译错误。
- en: What happens if we really want to invoke a method or access a property from
    a nullable value?
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们真的想从一个可空值中调用一个方法或访问一个属性，会发生什么？
- en: Well, Kotlin provides you options to deal with nullable values, with a catch—all
    are explicit. In some sense, Kotlin is telling you, *Show me that you know what
    you are doing*.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，Kotlin 提供了处理可空值的选择，所有这些都是显式的。在某种程度上，Kotlin 在告诉你，“*展示给我，你知道你在做什么*”。
- en: Let's review some options (there are more options that we'll cover in the following
    chapters).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一些选项（在接下来的章节中我们还将介绍更多选项）。
- en: Checking for null
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查空值
- en: 'Check for null as a condition in the `if` block:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `if` 块中将空值检查作为一个条件：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Kotlin will do a smart cast. Inside the `if` block, `nullableCupcake` is a `Cupcake`,
    not a `Cupcake?`; so, any method or property can be accessed.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 将执行智能转换。在 `if` 块内部，`nullableCupcake` 是 `Cupcake`，而不是 `Cupcake?`；因此，可以访问任何方法或属性。
- en: Checking for non-null types
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查非空类型
- en: 'This is similar to the previous one, but it checks directly for the type:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个类似，但它直接检查类型：
- en: '[PRE54]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It also works with `when`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 它也可以与 `when` 一起使用：
- en: '[PRE55]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Both options, checking for null and non-null types, are a little bit verbose.
    Let's check other options.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 两种选项，检查空值和非空类型，都有些冗长。让我们看看其他选项。
- en: Safe calls
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全调用
- en: '**Safe calls** let you access methods and properties of nullable values if
    the value isn''t null (under the hood, at the bytecode level, a safe call is transformed
    into `if(x != null)`):'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**安全调用**允许在值非空时访问可空值的属性和方法（在底层，在字节码级别，安全调用被转换为 `if(x != null)`）：'
- en: '[PRE56]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: But, what if you use it in an expression?
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，如果你在表达式中使用它呢？
- en: '[PRE57]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: It will return null if our value is null, so `result` must have a `String?`
    type.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的值是空，它将返回空，所以 `result` 必须有 `String?` 类型。
- en: 'That opens up the chance to use safe calls on a chain, as follows:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就打开了在链上使用安全调用的机会，如下所示：
- en: '[PRE58]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The Elvis (?:) operator
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Elvis (?:) 操作符
- en: 'The Elvis operator (`?:`) returns an alternative value if a null value is used
    in an expression:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Elvis 操作符（`?:`）在表达式中使用空值时返回一个替代值：
- en: '[PRE59]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: If `nullabluCupcake?.eat()` is `null`, the `?:` operator will return the alternative
    value `""`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nullabluCupcake?.eat()`是`null`，则`?:`运算符将返回替代值`""`。
- en: 'Obviously, the Elvis operator can be used with a chain of safe calls:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，Elvis运算符可以与一系列安全调用一起使用：
- en: '[PRE60]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The (!!) operator
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`!!!`运算符'
- en: 'Instead of a `null` value, the `!!` operator will throw an NPE:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是`null`值，`!!`运算符将抛出一个NPE：
- en: '[PRE61]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If you can deal with an NPE, the `!!` operator gives you a pretty convenient
    feature, a free smart cast:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你能够处理NPE，则`!!`运算符提供了一个相当方便的功能，即免费智能转换：
- en: '[PRE62]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: If `nullableCupcake!!.eat()` doesn't throw an NPE, Kotlin will change its type
    from `Cupcake?` to `Cupcake` from the next line and onwards.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`nullableCupcake!!.eat()`没有抛出NPE，Kotlin将从下一行开始将其类型从`Cupcake?`更改为`Cupcake`。
- en: Kotlin's type system
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin的类型系统
- en: '**Type systems** are a set of rules that determine the type of a language construct.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型系统**是一组规则，用于确定语言构造的类型。'
- en: 'A (good) type system will help you with:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一个（好的）类型系统将帮助你：
- en: Making sure that the constituent parts of your program are connected in a consistent
    way
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保程序组成部分以一致的方式连接
- en: Understanding your program (by reducing your cognitive load)
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解你的程序（通过减少你的认知负荷）
- en: Expressing business rules
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达业务规则
- en: Automatic low-level optimizations
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动低级优化
- en: We have already covered enough ground to understand Kotlin's type system.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经覆盖了足够的内容来理解Kotlin的类型系统。
- en: The Any type
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Any`类型'
- en: All types in Kotlin extend from the `Any` type (hold on a second, actually this
    isn't true but for the sake of the explanation, bear with me).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin中的所有类型都扩展自`Any`类型（等等，实际上这不是真的，但为了解释的目的，请耐心等待）。
- en: 'Every class and interface that we create implicitly extends `Any`. So, if we
    write a method that takes `Any` as a parameter, it will receive any value:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的每个类和接口都隐式扩展了`Any`。因此，如果我们编写一个接受`Any`作为参数的方法，它将接收任何值：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'What about a nullable value? Let''s have a look at it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 可空值呢？让我们看看它：
- en: '[PRE64]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Any` is the same as any other type and also has a nullable counterpart, `Any?`. 
    `Any` extends from `Any?`. So, in the end, `Any?` is the top class of Kotlin''s
    type system hierarchy.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`Any`与任何其他类型相同，并且也有一个可空对应物，`Any?`。`Any`扩展自`Any?`。因此，最终，`Any?`是Kotlin类型系统层次结构中的顶级类。'
- en: Minimum common types
  id: totrans-254
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小公共类型
- en: Due to its type inference and expression evaluation, sometimes there are expressions
    in Kotlin where it is not clear which type is being returned. Most languages resolve
    this problem by returning the minimum common type between the possible type options.
    Kotlin takes a different route.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 由于类型推断和表达式评估，有时在Kotlin中存在一些表达式，其中不清楚返回哪种类型。大多数语言通过返回可能类型选项之间的最小公共类型来解决这个问题。Kotlin采取了不同的路线。
- en: 'Let''s take a look at an example of an ambiguous expression:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个模糊表达式的例子：
- en: '[PRE65]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'What type does `length` have? `Int` or `String`? No, `length` value''s type
    is `Any`. Pretty logical. The minimum common type between `Int` and `String` is
    `Any`. So far, so good. Let''s look at the following code now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '`length`的类型是什么？`Int`还是`String`？不，`length`值的类型是`Any`。这很合理。`Int`和`String`之间的最小公共类型是`Any`。到目前为止，一切顺利。现在让我们看看以下代码：'
- en: '[PRE66]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Following that logic, in this case, `length` should have the `Number` type (the
    common type between `Int` and `Double`), shouldn't it?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这个逻辑，在这种情况下，`length`应该有`Number`类型（`Int`和`Double`之间的公共类型），对吧？
- en: 'Wrong, `length` is still `Any`. Kotlin doesn''t search for the minimum common
    type in these situations. If you want a specific type, it must be explicitly declared:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 错误的，`length`仍然是`Any`。Kotlin在这些情况下不会搜索最小公共类型。如果你想得到一个特定的类型，它必须被显式声明：
- en: '[PRE67]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The Unit type
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Unit`类型'
- en: Kotlin doesn't have methods with `void` return (as Java or C do). Instead, a
    method (or, to be precise, an expression) could have a `Unit` type.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin没有`void`返回值的方法（就像Java或C那样）。相反，一个方法（或更准确地说，一个表达式）可以有一个`Unit`类型。
- en: A `Unit` type means that the expression is called for its side effects, rather
    than its return. The classic example of a `Unit` expression is `println()`, a
    method invoked just for its side effects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`类型表示表达式被调用是为了其副作用，而不是其返回值。`Unit`表达式的经典例子是`println()`，这是一个仅为了其副作用而被调用的方法。'
- en: '`Unit`, like any other Kotlin type, extends from `Any` and could be nullable.
    `Unit?` looks strange and unnecessary, but is needed to keep consistency with
    the type system. Having a consistent type system have several advantages, including
    better compilation times and tooling:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '`Unit`，就像任何其他Kotlin类型一样，从`Any`扩展而来，并且可以是可空的。`Unit?`看起来很奇怪且不必要，但这是为了与类型系统保持一致性。拥有一致的类型系统有多个优点，包括更好的编译时间和工具支持：'
- en: '[PRE68]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: The Nothing type
  id: totrans-268
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Nothing` 类型'
- en: '`Nothing` is the type that sits at the bottom of the entire Kotlin hierarchy.
    `Nothing` extends all Kotlin types, including `Nothing?`.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 是位于整个 Kotlin 层次结构底部的类型。`Nothing` 继承了所有 Kotlin 类型，包括 `Nothing?`。'
- en: But, why do we need a `Nothing` and `Nothing?` types?
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，为什么我们需要 `Nothing` 和 `Nothing?` 类型？
- en: '`Nothing` represents an expression that can''t be executed (basically throwing
    exceptions):'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 代表一个无法执行的表达式（基本上是抛出异常）：'
- en: '[PRE69]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: On one hand of the Elvis operator, we have a `String`. On the other hand, we
    have `Nothing`. Because the common type between `String` and `Nothing` is `String`
    (instead of `Any`), the value `result` is a `String`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Elvis 操作符的一侧，我们有 `String`。在另一侧，我们有 `Nothing`。因为 `String` 和 `Nothing` 之间的公共类型是
    `String`（而不是 `Any`），所以 `result` 的值是 `String`。
- en: '`Nothing` also has a special meaning for the compiler. Once a `Nothing` type
    is returned on an expression, the lines after that are marked as unreachable.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing` 对于编译器也有特殊的意义。一旦在表达式中返回 `Nothing` 类型，之后的行就会被标记为不可达。'
- en: '`Nothing?` is the type of a null value:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '`Nothing?` 是空值的类型：'
- en: '[PRE70]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Other types
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他类型
- en: Classes, interfaces, and objects are a good starting point for an OOP type system,
    but Kotlin offers more constructs, such as data classes, annotations, and enums
    (there is an additional type, named sealed class, that we'll cover later).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 类、接口和对象是面向对象类型系统的良好起点，但 Kotlin 提供了更多构造，例如数据类、注解和枚举（还有一个额外的类型，称为密封类，我们将在后面介绍）。
- en: Data classes
  id: totrans-279
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类
- en: Creating classes whose primary purpose is to hold data is a common pattern in
    Kotlin (is a common pattern in other languages too, think of JSON or Protobuff).
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建主要目的是持有数据的类是一种常见模式（在其他语言中也是一种常见模式，例如 JSON 或 Protobuff）。
- en: 'Kotlin has a particular kind of class for this purpose:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 有一种特定的类用于此目的：
- en: '[PRE71]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To declare `data class`, there are some restrictions:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明数据类，有一些限制：
- en: The primary constructor should have at least one parameter
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要构造函数应至少有一个参数
- en: The primary constructor's parameters must be `val` or `var`
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主要构造函数的参数必须是 `val` 或 `var`
- en: Data classes can't be abstract, open, sealed, or inner
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据类不能是抽象的、开放的、密封的或内部的
- en: With these restrictions, data classes give a lot of benefits.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些限制下，数据类提供了很多好处。
- en: Canonical methods
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规范方法
- en: '**Canonical methods** are the methods declared in `Any`. Therefore, all instances
    in Kotlin have them.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**规范方法**是在 `Any` 中声明的。因此，Kotlin 中的所有实例都有这些方法。'
- en: For data classes, Kotlin creates correct implementations of all canonical methods.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 对于数据类，Kotlin 会为所有规范方法创建正确的实现。
- en: 'The methods are as follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 方法如下：
- en: '`equals(other: Any?): Boolean`: This method compares value equivalence, rather
    than reference.'
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`equals(other: Any?): Boolean`: 此方法比较值等价性，而不是引用。'
- en: '`hashCode(): Int`: A hash code is a numerical representation of an instance.
    When `hashCode()` is invoked several times in the same instance, it should always
    return the same value. Two instances that return true when they are compared with
    `equals` must have the same `hashCode()`.'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`hashCode(): Int`: 哈希码是实例的数值表示。当在同一个实例上多次调用 `hashCode()` 时，它应该始终返回相同的值。当两个实例在
    `equals` 中返回 true 时，它们必须具有相同的 `hashCode()`。'
- en: '`toString(): String`: A `String` representation of an instance. This method
    will be invoked when an instance is concatenated to a `String`.'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`toString(): String`: 实例的字符串表示。当实例被连接到字符串时，将调用此方法。'
- en: The copy() method
  id: totrans-295
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`copy()` 方法'
- en: 'Sometimes, we want to reuse values from an existing instance. The `copy()`
    method lets us create new instances of a data class, overriding the parameters
    that we want:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望重用现有实例的值。`copy()` 方法允许我们创建数据类的新实例，并覆盖我们想要的参数：
- en: '[PRE72]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In this case, `mySecondItem` copies `unitPrice` and `quantity` from `myItem`,
    and replaces the `product` property.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`mySecondItem` 从 `myItem` 复制 `unitPrice` 和 `quantity`，并替换 `product` 属性。
- en: Destructuring methods
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 析构方法
- en: By convention, any instance of a class that has a series of methods named `component1()`,
    `component2()` and so on can be used in a destructuring declaration.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，任何具有一系列名为 `component1()`、`component2()` 等方法的类实例都可以用于析构声明。
- en: 'Kotlin will generate these methods for any data class:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 将为任何数据类生成这些方法：
- en: '[PRE73]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'The `prod` value is initialized with the return of `component1()`, `price`
    with the return of `component2()` , and so on. Although the preceding example
    use explicit types, those aren''t needed:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '`prod` 值使用 `component1()` 的返回值初始化，`price` 使用 `component2()` 的返回值，依此类推。尽管前面的示例使用了显式类型，但这些类型不是必需的：'
- en: '[PRE74]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In some circumstances, not all values are needed. All unused values can be
    replaced by (`_`):'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，并不需要所有值。所有未使用的值都可以用（`_`）替换：
- en: '[PRE75]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Annotations
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注解
- en: Annotations are a way to attach meta info to your code (such as documentation,
    configuration, and others).
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 注解是一种将元信息附加到您的代码上的方式（例如文档、配置等）。
- en: 'Let''s look at the following example code:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'An `annotation` itself can be annotated to modify its behavior:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`注解`本身可以被注解来修改其行为：
- en: '[PRE77]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: In this case, the `Tasty` annotation can be set on classes, interfaces, and
    objects, and it can be queried at runtime.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Tasty`注解可以应用于类、接口和对象，并且可以在运行时查询。
- en: For a complete list of options, check the Kotlin documentation.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取完整的选项列表，请查看 Kotlin 文档。
- en: 'Annotations can have parameters with one limitation, they can''t be nullable:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 注解可以有参数，但有一个限制，它们不能为空：
- en: '[PRE78]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'To query annotation values at runtime, we must use the reflection API (`kotlin-reflect.jar`
    must be in your classpath):'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 要在运行时查询注解值，我们必须使用反射API（`kotlin-reflect.jar`必须位于您的类路径中）：
- en: '[PRE79]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Enum
  id: totrans-319
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枚举
- en: 'Enum in Kotlin is a way to define a set of constant values. Enums are very
    useful, but not limited, as configuration values:'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的枚举是一种定义一组常量值的方式。枚举非常有用，但不仅限于配置值：
- en: '[PRE80]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: Each element is an object that extends the `Flour` class.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 每个元素都是一个扩展了`Flour`类的对象。
- en: 'Like any object, they can extend interfaces:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 就像任何对象一样，它们可以扩展接口：
- en: '[PRE81]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Enum can also have abstract methods:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举也可以有抽象方法：
- en: '[PRE82]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Any method definition must be declared after the (`;`) separating the last element.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 任何方法定义都必须在分隔最后一个元素的分号（`;`）之后声明。
- en: 'When enums are used with `when` expressions, Kotlin''s compiler checks that
    all cases are covered (individually or with an `else`):'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当枚举与`when`表达式一起使用时，Kotlin 编译器会检查所有情况是否都已覆盖（单独或使用`else`）：
- en: '[PRE83]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'In this case, we''re only checking for `CASSAVA` and not the other elements;
    therefore, it fails:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只检查了`CASSAVA`，而没有检查其他元素；因此，它失败了：
- en: '[PRE84]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: Summary
  id: totrans-332
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basics of OOP and how Kotlin supports it. We
    learned how to use classes, interfaces, objects, data classes, annotations, and
    enums. We also explored the Kotlin type system and saw how it helps us to write
    better and safer code.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了面向对象编程的基础以及 Kotlin 如何支持它。我们学习了如何使用类、接口、对象、数据类、注解和枚举。我们还探讨了 Kotlin
    类型系统，并看到了它是如何帮助我们编写更好、更安全的代码的。
- en: In the next chapter, we will start with an introduction to functional programming.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从函数式编程的介绍开始。
