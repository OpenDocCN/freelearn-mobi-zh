- en: '*Chapter 2*: Deep Diving into Data Sources'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：深入数据源'
- en: In this chapter, we will study some of the popular libraries and frameworks
    used for retrieving and managing data on Android and how to do this without blocking
    the main thread of an application. We will start by going over how multithreading
    should be handled in an Android application and the available technologies we
    now have to easily handle this. We will then move on to implement loading data
    from the internet using libraries such as Retrofit and OkHttp, after which we
    will look at how we can persist data on a device using libraries such as Room
    and DataStore.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将研究一些用于在Android上检索和管理数据的流行库和框架，以及如何在不阻塞应用程序主线程的情况下完成这些操作。我们将首先概述在Android应用程序中如何处理多线程以及我们现在有哪些易于处理这项技术的技术。然后，我们将继续实现使用Retrofit和OkHttp等库从互联网加载数据，之后我们将探讨如何使用Room和DataStore等库在设备上持久化数据。
- en: 'In this chapter, we will cover the following main topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主要内容：
- en: Understanding Kotlin coroutines and flows
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Kotlin协程和流
- en: Using OkHttp and Retrofit for networking
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用OkHttp和Retrofit进行网络操作
- en: Using the Room library for data persistence
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Room库进行数据持久化
- en: Understanding and using the DataStore library
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解和使用DataStore库
- en: By the end of this chapter, you will have become familiar with how we can load,
    manage, and persist data in an Android application.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章结束时，你将熟悉如何在Android应用程序中加载数据、管理数据和持久化数据。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This chapter has the following hardware and software requirements:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章有以下硬件和软件要求：
- en: Android Studio Arctic Fox 2020.3.1 Patch 3
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1 Patch 3
- en: 'The code files for this chapter can be found here:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在此处找到：
- en: '[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter2)'
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/38uecPi](https://bit.ly/38uecPi)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/38uecPi](https://bit.ly/38uecPi)
- en: Understanding Kotlin coroutines and Flows
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Kotlin协程和Flows
- en: In this section, we will look at how threading works in the Android ecosystem
    and what applications must do to ensure that long-running operations do not block
    the user from using an application. We will then look at what available options
    we have available to execute operations in the background, with a focus on coroutines.
    Finally, we will look over Kotlin flows, which we can use to handle asynchronous
    work using a reactive and functional approach.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨在Android生态系统中线程的工作方式以及应用程序必须做什么以确保长时间运行的操作不会阻止用户使用应用程序。然后，我们将探讨我们有哪些可用的选项来在后台执行操作，重点关注协程。最后，我们将回顾Kotlin流，我们可以使用它以响应式和函数式方法处理异步工作。
- en: 'Android applications normally run in a single process on a user''s device.
    When the operating system starts the application''s process, it will allocate
    memory resources for the process to be executed. This process, when started, will
    have one thread of execution running within. This thread is referred to as the
    "main thread" or "**user interface** (**UI**) thread". In Android, this concept
    is very important because it is the thread that deals with user interaction. This
    imposes certain limitations for developers when dealing with it, as outlined here:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序通常在用户的设备上以单个进程运行。当操作系统启动应用程序的进程时，它将为执行进程分配内存资源。此进程启动时，将有一个执行线程在其中运行。这个线程被称为“主线程”或“**用户界面**（**UI**）线程”。在Android中，这个概念非常重要，因为它处理用户交互的线程。这给开发者带来了一些限制，如下所述：
- en: The main thread must not be blocked by long-running or **input/output** (**I/O**)
    operations.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 主线程不得被长时间运行或**输入/输出**（**I/O**）操作阻塞。
- en: All updates to the UI must be done on the main thread.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有UI更新都必须在主线程上完成。
- en: The idea is that the user should still be able to interact with an application
    as much as possible even if the application is doing some work. Every time we
    want to load and save data from or to the internet, local storage, content providers,
    and so on, we should use another thread or use multiple threads. The way the device's
    processor deals with multiple threads is by assigning a core for each thread.
    When there are more threads than cores, it will jump back and forth between every
    single instruction from each thread. Having too many threads being executed simultaneously
    will end up creating a bad **user experience** (**UX**) because the processor
    will now need to jump between the main thread and the rest of the threads being
    executed at the same time, so we will need to be mindful of how many threads are
    being executed concurrently.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是，即使应用程序在进行一些工作，用户仍然应该尽可能多地与应用程序交互。每次我们想要从或向互联网、本地存储、内容提供者等加载数据或保存数据时，我们应该使用另一个线程或使用多个线程。设备处理器处理多个线程的方式是为每个线程分配一个核心。当线程数量多于核心数量时，它将在每个线程的每条指令之间跳来跳去。同时执行太多线程最终会创建一个糟糕的**用户体验**（UX），因为处理器现在需要在主线程和其他同时执行的线程之间跳转，因此我们需要注意同时执行多少个线程。
- en: 'In Java, a thread can be created using the `Thread` class; however, creating
    a new thread for every asynchronous operation is a very resource-expensive operation.
    Java also offers the concept of `ThreadPool` or `Executor`. These typically manage
    fixed a collection of threads that will be reused for different operations. Because
    of the Android restriction regarding updating the UI on the main thread, classes
    such as `Handler` and `Looper` were introduced, whereby you can submit the result
    of an operation performed on a background thread back on the main thread. An example
    of this is provided here:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，可以使用`Thread`类创建线程；然而，为每个异步操作创建一个新的线程是一个非常资源密集的操作。Java还提供了`ThreadPool`或`Executor`的概念。这些通常管理一组固定数量的线程，这些线程将被重用于不同的操作。由于Android对在主线程上更新UI的限制，引入了`Handler`和`Looper`类，通过这些类，你可以将后台线程上执行的操作的结果提交回主线程。这里提供了一个例子：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In the preceding code snippet, the sum of two numbers will be performed on a
    new thread, and the result will then be posted back using the `Handler` object
    that is connected to the main `Looper` object, which itself will loop the main
    thread.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，两个数字的求和将在一个新的线程上执行，然后使用连接到主`Looper`对象的`Handler`对象将结果发送回去，主`Looper`对象本身将循环主线程。
- en: 'The repeated usage of `Handler` and `Looper` gave birth to `AsyncTask`, which
    offers the possibility of moving the necessary operations on a background thread
    and receiving the result on the main thread. `AsyncTask` worked with the same
    principle as the preceding example, only instead of creating a new thread for
    every new operation, it would by default use the same thread (although this later
    became configurable), which means that if two `AsyncTask` instances were executed
    at the same time, one would wait after the other. An example of the same sum operations
    might look like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '`Handler`和`Looper`的重复使用催生了`AsyncTask`，它提供了在后台线程上移动必要操作并在主线程上接收结果的可能性。`AsyncTask`与前面的例子工作原理相同，只是它不是为每个新操作创建一个新的线程，而是默认使用相同的线程（尽管这后来变得可配置），这意味着如果有两个`AsyncTask`实例同时执行，一个会在另一个之后等待。相同的求和操作的例子可能看起来像这样：'
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding example, the sum is done in the `doInBackground` method, which
    is executed on a separate thread, and the `onPostExecute` method would be executed
    on the main thread.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，求和操作是在`doInBackground`方法中完成的，这个方法在一个单独的线程上执行，而`onPostExecute`方法将在主线程上执行。
- en: 'Let''s now imagine that we want to chain these sums and apply them multiple
    times, as follows:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们想象一下，我们想要将这些求和操作串联起来并多次应用，如下所示：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding example, we try to sum two numbers and add the result to number
    `c`. As you can see, we need to use the callback and wait for `a` and `b` to finish
    and then apply the same function to the result of `a+b` and the number `c`.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试将两个数字相加，并将结果加到数字`c`上。正如你所看到的，我们需要使用回调并等待`a`和`b`完成，然后对`a+b`的结果和数字`c`应用相同的函数。
- en: 'Let''s imagine what an application might look like when having to deal with
    loading data from multiple data sources, merging them together, handling errors,
    and stopping the asynchronous execution if the user leaves the current activity
    or fragment. The RxJava library tries to tackle all these problems through an
    event-driven approach. It introduces the concepts of streams and flows of data
    that can be observed, transformed, merged with other data streams, and executed
    on different threads. The sum of two numbers in RxJava might look something like
    this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，当需要处理从多个数据源加载数据、合并它们、处理错误以及如果用户离开当前活动或片段则停止异步执行时，一个应用程序可能看起来像什么。RxJava库试图通过事件驱动的方法来解决所有这些问题。它引入了可以观察、转换、与其他数据流合并并在不同线程上执行的数据流和流的概念。在RxJava中，两个数字的和可能看起来像这样：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding example, we create a `Single` instance, which is a stream that
    emits only one value (for emitting multiple values, we have the `Flowable` and
    `Observable` options). The value emitted is the sum of the two numbers. The usage
    of `subscribeOn` is for executing the upstream (the sum) on an I/O thread managed
    by RxJava internally, and the usage of `observeOn` is to have everything downstream
    (all the commands that will follow) to get the result on the main thread.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们创建了一个`Single`实例，这是一个只发射一个值（对于发射多个值，我们有`Flowable`和`Observable`选项）的流。发射的值是两个数字的和。使用`subscribeOn`是为了在RxJava内部管理的I/O线程上执行上游（求和），而使用`observeOn`是为了让所有下游（所有后续的命令）在主线程上获取结果。
- en: 'If we want to chain multiple sums, then we would have something like this:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要链式多个求和，那么我们会有如下所示的内容：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding example, the sum of `a` and `b` is executed, then through the
    `flatMap` operator, we add `c` to that result. The usage of `subscribe` method
    is for triggering sums and listening for the results. This is because the `Single`
    instance used is a cold observable; it will only be executed only when `subscribe`
    is called. There is also the concept of hot observables, which will emit whether
    there are subscribers or not. The result of the `subscribe` operator will return
    a `Disposable` instance that offers a `dispose` method that can be called when
    we want to stop listening for data from the stream. This is useful in situations
    where our activities and fragments are destroyed, and we don't want to update
    our UI to avoid context leaks.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，执行了`a`和`b`的和，然后通过`flatMap`操作符，我们将`c`添加到这个结果中。使用`subscribe`方法是为了触发求和并监听结果。这是因为使用的`Single`实例是一个冷观察者；它只有在调用`subscribe`时才会执行。还有热观察者的概念，无论是否有订阅者都会发射。`subscribe`操作符的结果将返回一个`Disposable`实例，它提供了一个`dispose`方法，可以在我们想要停止监听流中的数据时调用。这在我们的活动和片段被销毁，我们不想更新UI以避免上下文泄露的情况下非常有用。
- en: Kotlin coroutines
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin协程
- en: 'So far, we have analyzed technologies that revolve around the Java and Android
    frameworks. With the adoption of Kotlin, other technologies have emerged that
    deal with multithreading and are Kotlin-specific. One of these is the concept
    of coroutines. Coroutines simplify the way we write asynchronous code. Instead
    of dealing with callbacks, coroutines introduce the concept of scopes where we
    can specify which threads our blocks of code will execute in. The scopes can also
    connect to lifecycle-aware components that help us unsubscribe from the results
    of asynchronous work when our lifecycle-aware components terminate. Let''s look
    at the following example of coroutines for the same sum:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经分析了围绕Java和Android框架的技术。随着Kotlin的采用，出现了其他处理多线程且特定于Kotlin的技术。其中之一是协程的概念。协程简化了我们编写异步代码的方式。我们不需要处理回调，协程引入了作用域的概念，我们可以指定代码块将在哪个线程上执行。作用域还可以连接到生命周期感知组件，帮助我们在我们生命周期感知组件终止时取消订阅异步工作的结果。让我们看看以下关于相同求和的协程示例：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding example, the `withContext` method will execute the block of
    code inside it in the threads managed by the I/O dispatcher. The number of threads
    associated with this dispatcher is managed internally by the Kotlin framework
    and is associated with the number of cores the processor of the device has. This
    often means that we don't have to worry about the performance of our applications
    when multiple asynchronous operations are executed concurrently. Another interesting
    thing to note in the example is the usage of the `suspend` keyword. This is to
    alert the caller of this method that it will be executed using coroutines on a
    separate thread.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`withContext` 方法将在 I/O 分发器管理的线程中执行其内部的代码块。与此分发器相关联的线程数量由 Kotlin 框架内部管理，并与设备处理器的核心数相关联。这通常意味着当多个异步操作同时执行时，我们不必担心应用程序的性能。在示例中还有另一个有趣的事情需要注意，那就是
    `suspend` 关键字的使用。这是为了提醒调用此方法的调用者，它将在单独的线程上使用协程执行。
- en: 'Now, let''s see what things will look like when we want to invoke this method.
    Have a look at the following code snippet:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看当我们想要调用此方法时，事情会是什么样子。看一下以下代码片段：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In `asyncComplicatedSum`, we use the `launch` method. This method is associated
    with the `CoroutineContext` object defined in this class. The context is defined
    using the `Main` dispatcher combined with the `Job` object that will be associated
    with the lifecycle of this object. If the `destroy` method is called while we
    are waiting for the result of the sum, then the execution of the sum will stop
    and we will stop getting the result of the sum. The code will execute each of
    the sums on the I/O thread and then execute log statements on the main thread
    if the job is still alive.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `asyncComplicatedSum` 中，我们使用了 `launch` 方法。此方法与在此类中定义的 `CoroutineContext` 对象相关联。上下文是通过使用
    `Main` 分发器结合与该对象的生命周期相关联的 `Job` 对象来定义的。如果在等待求和结果时调用 `destroy` 方法，则求和的执行将停止，我们将停止获取求和的结果。代码将在
    I/O 线程上执行每个求和，如果作业仍然存活，则将在主线程上执行日志语句。
- en: 'In Android, we already have a few `CoroutineScope` objects already defined
    and associated with our lifecycle-aware classes. One that will be relevant to
    us is the one defined for `ViewModels`. This can be found in the `org.jetbrains.kotlinx:kotlinx-coroutines-android`
    library and will look something like this:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 中，我们已经有几个 `CoroutineScope` 对象已经定义并关联到我们的生命周期感知类。其中一个与我们相关的是为 `ViewModels`
    定义的。这可以在 `org.jetbrains.kotlinx:kotlinx-coroutines-android` 库中找到，看起来可能如下所示：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`viewModelScope` is a Kotlin extension created for `ViewModel` instances that
    will execute if the `ViewModel` instance is alive. If `onCleared` is called on
    the `ViewModel` instance, then it will stop listening to the remaining code to
    be executed in the `launch` block.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewModelScope` 是为 `ViewModel` 实例创建的 Kotlin 扩展，如果 `ViewModel` 实例处于活动状态，则将执行。如果在
    `ViewModel` 实例上调用 `onCleared`，则它将停止监听 `launch` 块中剩余要执行的代码。'
- en: In this section, we've analyzed how Kotlin coroutines work and how we can use
    them to handle asynchronous operations in an Android application. In the next
    section, we will create an Android application that will use Kotlin coroutines
    for a simple asynchronous operation.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了 Kotlin 协程的工作原理以及我们如何使用它们在 Android 应用程序中处理异步操作。在下一节中，我们将创建一个 Android
    应用程序，该程序将使用 Kotlin 协程进行简单的异步操作。
- en: Exercise 02.01 – Using Kotlin coroutines
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 02.01 – 使用 Kotlin 协程
- en: Create an application that will display two input fields, one text field, and
    a button. The input fields will be limited to numbers only, and when the user
    presses the button, then the text field will display the sum of the two numbers
    after 5 seconds. The sum and waiting will be implemented using coroutines.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个应用程序，该程序将显示两个输入字段、一个文本字段和一个按钮。输入字段仅限于数字，当用户按下按钮时，文本字段将在5秒后显示两个数字的和。求和和等待将使用协程实现。
- en: 'To complete the exercise, you will need to build the following:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要构建以下内容：
- en: A class that will perform the addition of the two numbers
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将执行两个数字加法的类
- en: A `ViewModel` class that will invoke the addition
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个将调用加法的 `ViewModel` 类
- en: 'The UI using Compose that will use the following function:'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Compose 的 UI 将使用以下函数：
- en: '[PRE8]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Follow these steps to complete the exercise:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create a new project in Android Studio using an **Empty Compose Activity**.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中使用 **Empty Compose Activity** 创建一个新的项目。
- en: 'At the top level of the `build.gradle` file, define the Compose library version
    as follows:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`build.gradle`文件的顶层，定义Compose库版本如下：
- en: '[PRE9]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the `app/build.gradle` file, we need to add the following dependencies:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`文件中，我们需要添加以下依赖项：
- en: '[PRE10]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Start by creating a `NumberAdder` class and define an `add` operation and a
    delay, as follows:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个`NumberAdder`类，并定义一个`add`操作和一个延迟，如下所示：
- en: '[PRE11]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this class, we will add our 5-second delay before performing the sum of the
    two numbers. This is to highlight the asynchronous operation more. `CoroutineDispatcher`
    and the amount we want to delay by will be injected through the constructor. This
    is because we want to unit-test this class.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们将在执行两个数字的求和之前添加一个5秒的延迟。这是为了更突出异步操作。`CoroutineDispatcher`和我们要延迟的量将通过构造函数注入。这是因为我们想要对这个类进行单元测试。
- en: 'Next, we will need to unit-test this class. Before we write the test, create
    a test rule so that we can reuse it for coroutines, as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要对这个类进行单元测试。在我们编写测试之前，创建一个测试规则，以便我们可以为协程重用它，如下所示：
- en: '[PRE12]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this class, we create a `TestCoroutineDispatcher` instance that will later
    be injected into the unit test so that the test can execute the sum in a synchronous
    way. `@ExperimentalCoroutinesApi` suggests that the usage of `TestCoroutineDispatcher`
    is still in an experimental state and will be moved to a stable version in the
    future.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个类中，我们创建了一个`TestCoroutineDispatcher`实例，稍后将其注入到单元测试中，以便测试可以以同步方式执行求和操作。`@ExperimentalCoroutinesApi`表明`TestCoroutineDispatcher`的使用仍然处于实验状态，将来将被移至稳定版本。
- en: 'Now, write the unit test for the class, in the form of `NumberAdderTest`, as
    follows:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，以`NumberAdderTest`的形式编写类的单元测试，如下所示：
- en: '[PRE13]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, we inject the `testDispatcher` object we created in `DispatcherTestRule`
    into `NumberAdder`, and we then invoke the `add` function. The entire test is
    executed in a special `CoroutineScope` block called `runBlockingTest`, that will
    ensure all the coroutines launched must complete.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们在`DispatcherTestRule`中创建的`testDispatcher`对象注入到`NumberAdder`中，然后调用`add`函数。整个测试是在一个特殊的`CoroutineScope`块`runBlockingTest`中执行的，这将确保所有启动的协程必须完成。
- en: 'Next, go ahead and create a `ViewModel` class, like this:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，继续创建一个`ViewModel`类，如下所示：
- en: '[PRE14]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we use a Compose state that will retain the result of the addition, and
    a method that will trigger the addition into `viewModelScope`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个Compose状态来保留加法的结果，以及一个将触发加法操作到`viewModelScope`的方法。
- en: 'After the `ViewModel` class has been created, go ahead and create an activity
    class, as follows:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建完`ViewModel`类之后，继续创建一个活动类，如下所示：
- en: '[PRE15]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, we initialize our activity with the content. `Exercise201Theme` should
    be replaced with the theme generated by Android Studio when the project was created.
    Typically, this should be in a `Theme` file and should be a `@Composable` function
    that has the application name followed by the `Theme` suffix. If that is not available,
    you can use `MaterialTheme` instead for the purpose of the exercise.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内容初始化我们的活动。`Exercise201Theme`应替换为Android Studio在创建项目时生成的主题。通常，这应该在一个`Theme`文件中，并且应该是一个带有应用名称后跟`Theme`后缀的`@Composable`函数。如果不可用，可以为了练习的目的使用`MaterialTheme`。
- en: 'Next, create a `Screen` function, as follows:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`Screen`函数，如下所示：
- en: '[PRE16]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this method, we define variables for our text fields, then we pass the result
    of the addition of the numbers from the ViewModel, and finally, we invoke the
    ViewModel to perform the addition.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们为文本字段定义变量，然后传递从ViewModel得到的数字相加的结果，最后调用ViewModel执行加法操作。
- en: And finally, add the `Calculator` function from the exercise definition to the
    `MainActivity` file.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将练习定义中的`Calculator`函数添加到`MainActivity`文件中。
- en: If we run the preceding example, we should see our UI elements, and after inserting
    the numbers and clicking the button, we will get our result. One thing to notice
    is that the user will be able to interact with the UI while the `add` method is
    executed, and clicking multiple times for different numbers will get the results
    5 seconds after each button press.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的示例，我们应该看到我们的UI元素，在输入数字并点击按钮后，我们将得到结果。需要注意的是，当`add`方法执行时，用户将能够与UI交互，并且点击不同的数字将分别在每次按钮按下后5秒后得到结果。
- en: Using coroutines can improve the quality of an Android application, especially
    when combined with Android extensions for the `ViewModel` class and lifecycle-aware
    components. Coroutines simplify the code we write for asynchronous operations,
    and the addition of the `suspend` keyword can enforce more rigor when dealing
    with these operations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用协程可以提高Android应用程序的质量，尤其是在与`ViewModel`类和生命周期感知组件的Android扩展结合使用时。协程简化了我们编写的异步操作代码，并且添加`suspend`关键字可以增强处理这些操作时的严谨性。
- en: Kotlin Flows
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Kotlin流
- en: 'Coroutines offer a good solution for dealing with asynchronous operations;
    however, they do not offer a good ability to handle multiple streams of data in
    the same way RxJava does. Flows represent an extension to coroutines, which is
    meant to solve this problem. When dealing with flows, there are three entities
    to consider, as outlined here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 协程为处理异步操作提供了一个很好的解决方案；然而，它们并没有像RxJava那样提供处理多个数据流的好能力。Flows是协程的扩展，旨在解决这个问题。在处理流时，需要考虑三个实体，如下所述：
- en: '**Producer**: This entity is responsible for emitting the data.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生产者**：这个实体负责发出数据。'
- en: '**Intermediary**: This entity deals with the transformation or manipulation
    of the data.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间者**：这个实体负责数据的转换或操作。'
- en: '**Consumer**: This entity consumes the data in the stream.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消费者**：这个实体消费流中的数据。'
- en: 'Let''s look at the following example of adding two numbers and how it might
    look like using Kotlin flows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例，如何使用Kotlin流来添加两个数字，以及它可能的样子：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Here, we create a `Flow` object that will emit the result of `a + b` on a stream.
    The `flowOn` method will move the execution of the upstream on an I/O thread.
    Here, we note the similarity to RxJava in the concept of how `Flows` work, but
    we also notice that it''s an extension of coroutines because of the use of `Dispatchers`.
    Let''s now look at how flows look on the consumer side, as follows:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个`Flow`对象，它将在流上发出`a + b`的结果。`flowOn`方法将上游的执行移动到I/O线程。在这里，我们注意到与RxJava在`Flows`工作概念上的相似性，但我们还注意到它因为使用了`Dispatchers`而是一个协程的扩展。现在让我们看看消费者侧的流是如何看的，如下所示：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here, we also notice similarities to RxJava—that is, when we try to manipulate
    the stream to perform the addition to number `c` and when it comes to error handling
    due to the `catch` method. The `collect` method, however, is closer to coroutines,
    and it requires a `CoroutineScope` to be used or to declare the calling method
    as a suspend one.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们也注意到它与RxJava的相似之处——即当我们尝试通过`catch`方法操纵流以执行对数字`c`的加法操作时，以及当处理由于`catch`方法引起的错误时。然而，`collect`方法更接近协程，并且需要使用`CoroutineScope`或声明调用方法为挂起方法。
- en: 'Flows offer a couple of specialized classes for particular use cases: `StateFlow`
    and `SharedFlow`. The `StateFlow` class is useful because it will offer subscribers
    the last value stored when they subscribe, like how `LiveData` works. Flows can
    also be cold and hot, and `SharedFlow` is a specialized implementation of a hot
    flow. `SharedFlow` will emit items if it is kept in memory if there are any consumers
    or not. When a consumer subscribes to `SharedFlow`, it will also emit the last
    value stored to the consumer, as with `StateFlow`.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Flows为特定用例提供了一些专门的类：`StateFlow`和`SharedFlow`。`StateFlow`类很有用，因为它会在订阅者订阅时提供存储的最后一个值，就像`LiveData`的工作方式一样。Flows也可以是冷流和热流，而`SharedFlow`是热流的专门实现。如果内存中有任何消费者，`SharedFlow`将发出项目。当消费者订阅`SharedFlow`时，它也会向消费者发出存储的最后一个值，就像`StateFlow`一样。
- en: In this section, we have looked at Kotlin flows and the benefits they provide
    when it comes to handling asynchronous operations. Next, we will look at how we
    can use Kotlin flows in an Android application through a simple exercise.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了Kotlin流及其在处理异步操作时提供的优势。接下来，我们将通过一个简单的练习来看看如何在Android应用程序中使用Kotlin流。
- en: Exercise 02.02 – Using Kotlin Flows
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习02.02 – 使用Kotlin流
- en: Modify the application from *Exercise 02.01* so that the addition of the two
    numbers will return a Flow instead of a suspended function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 修改应用程序，使其从*练习02.01*开始，将两个数字的加法返回一个Flow而不是挂起函数。
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要做以下事情：
- en: Rewrite the `add` function in `NumberAdder` to return a Flow.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`NumberAdder`中的`add`函数重写为返回一个Flow。
- en: Change how the `ViewModel` invokes the `add` function.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`ViewModel`调用`add`函数的方式。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Modify the `add` function in `NumberAdder` to return a Flow, as follows:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`NumberAdder`中的`add`函数修改为返回一个Flow，如下所示：
- en: '[PRE19]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we create a new Flow where we emit the sum of `a` and `b`, after which
    we put a delay on each item emitted in the stream, and finally, we specify the
    `CoroutineDispatcher` instance we wish to execute the sum on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建一个新的Flow，其中发出`a`和`b`的和，然后对流中发出的每个项目进行延迟，最后，我们指定我们希望在它上执行求和的`CoroutineDispatcher`实例。
- en: 'Next, let''s modify the unit test for the sum, as follows:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们修改求和的单元测试，如下所示：
- en: '[PRE20]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because the `add` method returns a `Flow` object, we must now find the first
    item emitted in the flow and assert the value of that item against our expected
    result.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`add`方法返回一个`Flow`对象，我们现在必须找到流中发出的第一个项目，并将该项目的值与我们的预期结果进行断言。
- en: 'Modify the `MainViewModel` class to consume the `add` operation, as follows:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainViewModel`类以消费`add`操作，如下所示：
- en: '[PRE21]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, the `add` method will still use the same `CoroutineScope` instance to
    launch the `add` method, which will now use the `collect` method to get the result
    of the sum.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`add`方法仍然将使用相同的`CoroutineScope`实例来启动`add`方法，该方法现在将使用`collect`方法来获取求和的结果。
- en: If we launch the application after following the steps from the exercise, the
    behavior will be the same as for *Exercise 02.01*, and we can see how Kotlin flows
    extend the functionality of coroutines by introducing concepts from RxJava to
    simplify how we can handle multiple streams of data.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照练习中的步骤启动应用程序，其行为将与*练习02.01*相同，我们可以看到Kotlin流如何通过引入来自RxJava的概念来扩展协程的功能，从而简化我们处理多个数据流的方式。
- en: In this section, we've seen how handling asynchronous operations has evolved
    over time and how much our applications benefit from concepts such as coroutines
    and flows that provide management for background threads, simplify how we execute
    asynchronous operations, manage multiple streams of data, and can connect to the
    lifecycle of Android components. In the following section, we will look at tools
    we can use to fetch data from the network and how they can be integrated with
    Kotlin coroutines and flows.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了异步操作是如何随着时间的推移而演变的，以及我们的应用程序从诸如协程和流等概念中获得了多少好处，这些概念提供了对后台线程的管理，简化了执行异步操作的方式，管理多个数据流，并且可以连接到Android组件的生命周期。在下一节中，我们将探讨我们可以用来从网络获取数据的工具，以及它们如何与Kotlin协程和流集成。
- en: Using OkHttp and Retrofit for networking
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用OkHttp和Retrofit进行网络操作
- en: In this section, we will look at how we can use the Retrofit library to perform
    networking operations and the benefits it provides.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Retrofit库执行网络操作以及它提供的优势。
- en: Many Android applications require the internet to access data stored on various
    servers. Often, this is done through the `HttpURLConnection` or Apache HttpClient.
    Working with either of these components meant that developers would need to manually
    handle the conversion from **plain old Java objects** (**POJOs**) to JSON, handle
    various network configurations, and deal with backward compatibility.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 许多安卓应用程序需要互联网来访问存储在各种服务器上的数据。通常，这通过`HttpURLConnection`或Apache HttpClient来实现。使用这些组件中的任何一个意味着开发者需要手动处理从**普通的Java对象**（**POJOs**）到JSON的转换，处理各种网络配置，以及处理向后兼容性问题。
- en: The OkHttp library will address some of these issues through an `OkHttpClient`
    class that will handle various network configurations and that provides other
    features such as caching. The Retrofit library, which can be placed on top of
    the OkHttp library, is meant to ensure type safety when dealing with various data
    formats. It's very configurable and allows the possibility to plug in various
    converter libraries for POJO-to-JSON conversion or **Extensible Markup Language**
    (**XML**) or other types of formats.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: OkHttp库将通过`OkHttpClient`类来解决这些问题，该类将处理各种网络配置并提供其他功能，如缓存。Retrofit库可以放在OkHttp库之上，旨在确保处理各种数据格式时的类型安全。它非常可配置，并允许插入各种转换库以进行POJO到JSON的转换或**可扩展标记语言**（**XML**）或其他类型的格式。
- en: 'In order to add Retrofit and OkHttp to the project, we will add the following
    dependencies to the `build.gradle` file:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将Retrofit和OkHttp添加到项目中，我们将向`build.gradle`文件中添加以下依赖项：
- en: '[PRE22]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we will need to determine which converters we will need to use for the
    data. Because JSON is a common format, we will use a JSON converter and the Moshi
    library to do so, so we will need to add dependencies to these two libraries,
    as follows:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定需要使用哪些转换器来处理数据。由于JSON是一种常见的格式，我们将使用JSON转换器和Moshi库来完成此操作，因此我们需要添加这两个库的依赖项，如下所示：
- en: '[PRE23]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here, the Moshi library will be responsible for converting POJOs into JSON,
    and the converter library will plug into the Retrofit library and trigger this
    conversion when data is exchanged between the Android application and the server.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，Moshi库将负责将POJO转换为JSON，转换库将连接到Retrofit库，并在Android应用程序和服务器之间交换数据时触发此转换。
- en: 'Let''s assume we will need to fetch data from a server in a JSON format. We
    can use the [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    service as an example. If we want to fetch a list of users, we can use the [https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    **Uniform Resource Locator** (**URL**). A user''s JSON representation looks like
    this:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要从服务器以JSON格式获取数据。我们可以使用[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)服务作为示例。如果我们想获取用户列表，我们可以使用[https://jsonplaceholder.typicode.com/users](https://jsonplaceholder.typicode.com/users)
    **统一资源定位符**（**URL**）。一个用户的JSON表示如下：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can see in the JSON representation that the user has an `id`, a `username`,
    an `email` value, and so on. In Kotlin, we can create a representation of this,
    and we can exclude properties that the application doesn''t need, such as `email`,
    `address`, `phone`, `website`, and `company`, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在JSON表示中看到，用户有一个`id`，一个`username`，一个`email`值等等。在Kotlin中，我们可以创建一个表示，并且可以排除应用程序不需要的属性，例如`email`、`address`、`phone`、`website`和`company`，如下所示：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here, we are using Moshi to map the property from a JSON to a Kotlin type,
    and we only kept three of the fields present in the initial JSON. Now, let''s
    look at how we can initialize our networking libraries. The code to accomplish
    this is shown in the following snippet:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用Moshi将JSON属性映射到Kotlin类型，并且只保留了初始JSON中存在的三个字段。现在，让我们看看我们如何初始化我们的网络库。完成此操作的代码如下所示：
- en: '[PRE26]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For OkHttp, we use a `Builder` method to create a new `OkHttpClient` instance,
    and we can provide certain configurations for it. We will now use the `OkHttpClient`
    instance created previously to create a `Retrofit` instance, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于OkHttp，我们使用`Builder`方法创建一个新的`OkHttpClient`实例，并且我们可以为其提供某些配置。现在，我们将使用之前创建的`OkHttpClient`实例来创建一个`Retrofit`实例，如下所示：
- en: '[PRE27]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we create a new `Retrofit` instance that will have the base URL set to
    [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/).
    Changing the base URL comes in handy during development. Many teams will have
    a development URL used internally to test the development and integration of features
    and will have a production URL where the actual user data is set. Now, we will
    need to connect the Moshi JSON serialization to the `Retrofit` instance, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个新的`Retrofit`实例，其基本URL设置为[https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)。在开发过程中更改基本URL非常有用。许多团队将有一个内部使用的开发URL，用于测试功能和集成，并将有一个生产URL，其中设置了实际的用户数据。现在，我们需要将Moshi
    JSON序列化连接到`Retrofit`实例，如下所示：
- en: '[PRE28]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here, we create `MoshiConverterFactory`, which is a Retrofit converter designed
    to connect `Retrofit` to the JSON serialization done by Moshi. We will now need
    to change our `Retrofit` initialization to what follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建`MoshiConverterFactory`，这是一个Retrofit转换器，旨在将`Retrofit`连接到Moshi执行的JSON序列化。现在，我们需要将我们的`Retrofit`初始化更改为以下内容：
- en: '[PRE29]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Here, we add the `MoshiConverterFactory` converter to the Retrofit `Builder`
    method to allow the two components to work together. Finally, we can create a
    Retrofit interface that will have templates for the HTTP request, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`MoshiConverterFactory`转换器添加到Retrofit的`Builder`方法中，以允许这两个组件协同工作。最后，我们可以创建一个Retrofit接口，其中包含HTTP请求的模板，如下所示：
- en: '[PRE30]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This interface contains an example of various methods for getting, creating,
    updating, and deleting data on servers. Note that the return type of these methods
    is a `Call` object that offers the ability to execute HTTP requests synchronously
    or asynchronously. One of the things that makes Retrofit more appealing to developers
    is the fact that it can be integrated with other asynchronous libraries such as
    RxJava and coroutines. Translating the preceding example to coroutines will look
    something like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口包含在服务器上获取、创建、更新和删除数据的各种方法的示例。请注意，这些方法的返回类型是`Call`对象，它提供了执行HTTP请求同步或异步的能力。使Retrofit对开发者更具吸引力的事情之一是它可以与其他异步库（如RxJava和协程）集成。将前面的示例转换为协程将看起来像这样：
- en: '[PRE31]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the preceding example, we add the `suspend` keyword to each method and we
    remove the dependency to the `Call` class. This allows us to execute these methods
    using coroutines. To create an instance of this class, we need to do the following:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们为每个方法添加了 `suspend` 关键字，并移除了对 `Call` 类的依赖。这允许我们使用协程执行这些方法。要创建此类的实例，我们需要执行以下操作：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Here, we use the `Retrofit` instance created previously to create a new instance
    of `UserService`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用之前创建的 `Retrofit` 实例来创建一个新的 `UserService` 实例。
- en: In this section, we have analyzed how we can use OkHttp and Retrofit to load
    data from the internet and the benefits these libraries provide, especially when
    combined with Kotlin coroutines and flows. In the next section, we will create
    an Android application that will use these libraries to fetch and display data
    on the UI.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了如何使用 OkHttp 和 Retrofit 从互联网加载数据以及这些库提供的优势，特别是当与 Kotlin 协程和流结合使用时。在下一节中，我们将创建一个
    Android 应用程序，该应用程序将使用这些库从 UI 中获取和显示数据。
- en: Exercise 02.03 – Using OkHttp and Retrofit
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 02.03 – 使用 OkHttp 和 Retrofit
- en: Create an Android application that connects to [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    and displays a list of users using OkHttp, Retrofit, and Moshi. For each user,
    we will display the name, username, and email.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个连接到 [https://jsonplaceholder.typicode.com/](https://jsonplaceholder.typicode.com/)
    并使用 OkHttp、Retrofit 和 Moshi 显示用户列表的 Android 应用程序。对于每个用户，我们将显示姓名、用户名和电子邮件。
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要执行以下操作：
- en: Create a `User` data class that will map the JSON representation of the user.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将映射用户 JSON 表示的 `User` 数据类。
- en: Create a `UserService` class that will have a method to retrieve a list of users.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个具有获取用户列表方法 `UserService` 类。
- en: Create a `ViewModel` class that will use `UserService` to retrieve a list of
    users.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个将使用 `UserService` 获取用户列表的 `ViewModel` 类。
- en: Implement an `Activity` class that will display a list of users.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现一个将显示用户列表的 `Activity` 类。
- en: 'A UI list will be created using the following method:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 将使用以下方法创建一个 UI 列表：
- en: '[PRE33]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Follow these steps to complete the exercise:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: Create an Android application with an **Empty Compose Activity**.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 **Empty Compose Activity** 的 Android 应用程序。
- en: 'At the top level of the `build.gradle` file, define the Compose library version,
    as follows:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `build.gradle` 文件的顶层，定义 Compose 库版本，如下所示：
- en: '[PRE34]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `app/build.gradle` file, add the following dependencies:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/build.gradle` 文件中，添加以下依赖项：
- en: '[PRE35]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, add a permission for internet access to the `AndroidManifest.xml` file,
    as follows:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将互联网访问权限添加到 `AndroidManifest.xml` 文件中，如下所示：
- en: '[PRE36]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now move on and create a class that will hold the user information, as follows:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在继续并创建一个将包含用户信息的类，如下所示：
- en: '[PRE37]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Here, we will hold the `id` field, which is generally a relevant field for distinguishing
    between different users and fields that we are required to display.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将保存 `id` 字段，这通常是一个用于区分不同用户和我们需要显示的字段的关联字段。
- en: 'Next, create a `UserService` class that will fetch the user data, as follows:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个将获取用户数据的 `UserService` 类，如下所示：
- en: '[PRE38]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we will only have one method that will get a list of users from the `/users`
    path.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只有一个方法，它将从 `/users` 路径获取用户列表。
- en: 'Now, we initialize the networking objects. Because we aren''t using any `MainApplication`
    class, as follows:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们初始化网络对象。因为我们没有使用任何 `MainApplication` 类，如下所示：
- en: '[PRE39]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are initializing our networking libraries and the `UserService` object.
    Currently, we are holding a static reference to this object, which is not a good
    idea in general. Normally, we would rely on DI frameworks to manage these networking
    dependencies.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在初始化我们的网络库和 `UserService` 对象。目前，我们持有对这个对象的静态引用，这在一般情况下不是一个好主意。通常，我们会依赖
    DI 框架来管理这些网络依赖项。
- en: 'In the `AndroidManifest.xml` file, add the following code:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AndroidManifest.xml` 文件中，添加以下代码：
- en: '[PRE40]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Given that we are inheriting from the `Application` class, we will need to add
    this class to the manifest.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在继承 `Application` 类，我们需要将此类添加到清单中。
- en: 'Next, go ahead and create a `MainViewModel` class, as follows:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，继续创建一个 `MainViewModel` 类，如下所示：
- en: '[PRE41]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: The `MainViewModel` class will depend on the `UserService` class to get a list
    of `Users` and store them in a Compose state that will be used in the UI. Here,
    we are also creating a `MainViewModelFactory` class that will be responsible for
    injecting the `UserService` class into the `MainViewModel` class.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel` 类将依赖于 `UserService` 类来获取 `Users` 列表并将它们存储在用于 UI 的 Compose 状态中。在这里，我们还在创建一个
    `MainViewModelFactory` 类，该类将负责将 `UserService` 类注入到 `MainViewModel` 类中。'
- en: 'Now, we move on and create a `MainActivity` class, as follows:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们继续创建一个 `MainActivity` 类，如下所示：
- en: '[PRE42]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Here, we initialize our activity with the content. The `Exercise203Theme` theme
    should be replaced with the theme generated by Android Studio when the project
    was created. Typically, this should be in a `Theme` file and should be a `@Composable`
    function that has the application name followed by the `Theme` suffix. If that
    is not available, you can use `MaterialTheme` instead for the purpose of the exercise.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用内容初始化我们的活动。应将 `Exercise203Theme` 主题替换为 Android Studio 在创建项目时生成的主题。通常，这应该在一个
    `Theme` 文件中，并且应该是一个 `@Composable` 函数，该函数以应用程序名称结尾并带有 `Theme` 后缀。如果不可用，可以为了练习的目的使用
    `MaterialTheme`。
- en: 'Create a `Screen` method in which we will grab a list of users from the `MainViewModel`
    class and draw a list of items, as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Screen` 方法，我们将从 `MainViewModel` 类中获取用户列表并绘制一个项目列表，如下所示：
- en: '[PRE43]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: And finally, add the `UserList` function from the exercise definition into the
    `MainActivity` file.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将练习定义中的 `UserList` 函数添加到 `MainActivity` 文件中。
- en: If we launch the application after following the steps from the exercise, we
    should be able to see a list of users being loaded if the device has internet
    access.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照练习中的步骤启动应用程序，如果设备有互联网访问，我们应该能够看到用户列表正在加载。
- en: In this section, we have seen how we can typically retrieve data from the internet
    in an Android application. We have looked at libraries such as OkHttp and Retrofit
    and seen how straightforward it is to make HTTP calls in a type-safe way without
    converting JSON files to data classes manually. We have also observed the potential
    of these libraries due to their integration with asynchronous technologies such
    as RxJava and coroutines. In the following section, we will look at libraries
    used for persisting data and how we can integrate them with networking libraries
    as well as coroutines and flows.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们看到了如何在 Android 应用程序中通常从互联网检索数据。我们探讨了 OkHttp 和 Retrofit 等库，并看到了如何以类型安全的方式直接进行
    HTTP 调用，而无需手动将 JSON 文件转换为数据类。我们还观察了这些库的潜力，因为它们与异步技术如 RxJava 和协程的集成。在下一节中，我们将探讨用于持久化数据的库以及如何将它们与网络库以及协程和流集成。
- en: Using the Room library for data persistence
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Room 库进行数据持久化
- en: In this section, we will discuss how to persist data in Android applications
    and how we can use the Room library to do this.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何在 Android 应用程序中持久化数据，以及我们如何使用 Room 库来实现这一点。
- en: Android offers many ways for persisting data on an Android device, mostly involving
    files. Some of these files have a specialized approach to persisting data. One
    of these approaches is in the form of SQLite. SQLite is a special type of file
    in which structured data can be stored using **Structured Query Language** (**SQL**)
    queries, as with other types of databases such as MySQL and Oracle.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了许多在 Android 设备上持久化数据的方法，大多数涉及文件。其中一些文件采用了专门的数据持久化方法。其中一种方法是以 SQLite
    的形式。SQLite 是一种特殊类型的文件，可以使用 **结构化查询语言**（**SQL**）查询在其中存储结构化数据，就像 MySQL 和 Oracle
    等其他类型的数据库一样。
- en: In the past, if developers wanted to persist data in SQLite, they were required
    to manually define tables, write queries, and transform objects containing this
    data into the appropriate formats for performing **create, read, update, and delete**
    (**CRUD**) operations. This type of work involved a load of boilerplate code that
    was susceptible to bugs. Room is the answer to that by providing an abstraction
    layer on top of the SQLite operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，如果开发人员想在 SQLite 中持久化数据，他们需要手动定义表、编写查询，并将包含此数据的对象转换为执行 **创建、读取、更新和删除**（**CRUD**）操作的正确格式。这类工作涉及大量样板代码，容易出错。Room
    通过在 SQLite 操作之上提供抽象层来解决这个问题。
- en: 'In order to add Room to an application, we will need to add the following libraries
    in `build.gradle`:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将 Room 添加到应用程序中，我们将在 `build.gradle` 中添加以下库：
- en: '[PRE44]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The reason for the `kapt` usage is that Room uses annotations that will generate
    the code required for the interaction with the SQLite layer. In order to use the
    `kapt` feature, we will need to add the plugin to the `build.gradle` file, as
    follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `kapt` 的原因是 Room 使用会生成与 SQLite 层交互所需代码的注解。为了使用 `kapt` 功能，我们需要将插件添加到 `build.gradle`
    文件中，如下所示：
- en: '[PRE45]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This will allow the build system to analyze annotations across the project that
    require code generation and generate the necessary classes based on the provided
    annotations.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将允许构建系统分析项目中需要代码生成的注解，并根据提供的注解生成必要的类。
- en: 'The data we want to store is annotated with the `@Entity` annotation, as illustrated
    in the following code snippet:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要存储的数据被 `@Entity` 注解标记，如下面的代码片段所示：
- en: '[PRE46]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here, we have defined a Room entity named `UserEntity` that will represent a
    table named `user` and has the `@ColumnInfo` annotation is for the name the column
    will have in the database.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个名为 `UserEntity` 的 Room 实体，它将代表一个名为 `user` 的表，并且 `@ColumnInfo` 注解用于指定列在数据库中的名称。
- en: 'A typical set of CRUD operations might look like this:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 一组典型的 CRUD 操作可能看起来像这样：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Just as how we defined in Retrofit a service interface to communicate with the
    server, we also define a similar interface for Room that we annotate with `@Dao`,
    for **data access object** (**DAO**). In this example, we have defined a set of
    functions for getting all users stored in a table, finding users, inserting new
    users, updating a user, and deleting a user.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 Retrofit 中定义了一个用于与服务器通信的服务接口一样，我们也为 Room 定义了一个类似的接口，并使用 `@Dao` 注解，用于 **数据访问对象**（**DAO**）。在这个例子中，我们定义了一系列函数，用于获取存储在表中的所有用户，查找用户，插入新用户，更新用户和删除用户。
- en: 'As with Retrofit, Room also provides integrations with coroutines, as illustrated
    in the following code snippet:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Retrofit 一样，Room 也提供了与协程的集成，如下面的代码片段所示：
- en: '[PRE48]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the preceding example, we add the `suspend` keyword, which makes the Room
    library easy to integrate and execute as part of a coroutine.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们添加了 `suspend` 关键字，这使得 Room 库易于集成并在协程中执行。
- en: 'On top of coroutines, the Room library also can integrate with Kotlin flows.
    This is useful for queries that will emit events every time a particular table
    has changed. This integration will look something like this:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程之上，Room 库还可以与 Kotlin flows 集成。这对于每次特定表发生变化时都会发出事件的查询非常有用。这种集成看起来可能如下所示：
- en: '[PRE49]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding example, we have changed the `@Query` functions to return a
    `Flow` object. If a change occurs in the user table, then the queries will be
    re-triggered and a new list of users will be emitted.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们将 `@Query` 函数更改为返回一个 `Flow` 对象。如果用户表发生变化，则查询将被重新触发，并发出新的用户列表。
- en: 'We will now need to set up the database, as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要设置数据库，如下所示：
- en: '[PRE50]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In the preceding snippet, we define a new class that extends from the `RoomDatabase`
    class and use the `@Database` annotation to declare our entities and the current
    version. This version is used to keep track of migrations when the structure of
    the database changes in between new releases of our application.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们定义了一个新的类，该类从 `RoomDatabase` 类扩展，并使用 `@Database` 注解声明我们的实体和当前版本。这个版本用于跟踪在应用程序新版本发布之间数据库结构变化时的迁移。
- en: 'To initialize the database, we will need to execute the following code:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 为了初始化数据库，我们需要执行以下代码：
- en: '[PRE51]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This will create our SQLite database and will return an instance of `AppDatabase`
    where we can access the DAO objects we have defined and invoke their methods to
    process the data.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建我们的 SQLite 数据库，并返回一个 `AppDatabase` 实例，我们可以通过它访问我们定义的 DAO 对象并调用它们的方法来处理数据。
- en: In this section, we have looked at how we can persist data using Room and how
    it can be integrated with coroutines and flows. In the next section, we will create
    an Android application that will use Room to persist data and look at how it can
    be integrated with Retrofit and OkHttp.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何使用 Room 持久化数据以及如何将其与协程和 flows 集成。在下一节中，我们将创建一个 Android 应用程序，该应用程序将使用
    Room 持久化数据，并探讨如何将其与 Retrofit 和 OkHttp 集成。
- en: Exercise 02.04 – Using Room to persist data
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 02.04 – 使用 Room 持久化数据
- en: Integrate Room into *Exercise 02.03* so that when the users are loaded from
    Retrofit, they will be stored in the database and then displayed on the UI.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Room 集成到 *练习 02.03* 中，以便当用户从 Retrofit 加载时，它们将被存储在数据库中，然后显示在 UI 上。
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要做以下事情：
- en: Create a `UserEntity` class that will be a Room entity.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`UserEntity`类，它将成为Room实体。
- en: Create a `UserDao` class that will contain methods for inserting users and querying
    all the users as flows.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`UserDao`类，其中将包含插入用户和查询所有用户作为流的函数。
- en: Create an `AppDatabase` class that will represent the application's database.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个将代表应用程序数据库的`AppDatabase`类。
- en: Modify the `MainViewModel` class to fetch users from the `UserService` class
    and then insert them into the `UserDao` class.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainViewModel`类，从`UserService`类获取用户，然后将其插入到`UserDao`类中。
- en: Modify the `MainActivity` class to use a list of `UserEntity` objects instead
    of `User` objects.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainActivity`类，使用`UserEntity`对象列表而不是`User`对象。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Add the `kapt` plugin to the `app/build.gradle` file, as follows:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`kapt`插件添加到`app/build.gradle`文件中，如下所示：
- en: '[PRE52]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Add Room dependencies to `app/build.gradle`, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将Room依赖项添加到`app/build.gradle`中，如下所示：
- en: '[PRE53]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Create a `UserEntity` class, as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`UserEntity`类，如下所示：
- en: '[PRE54]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: The `UserEntity` class has the same fields as the `User` class, and it contains
    the Room annotations for the table name and the names of each column.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserEntity`类与`User`类具有相同的字段，并且包含Room注解，用于表名和每列的名称。'
- en: 'Next, create a `UserDao` class, as follows:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`UserDao`类，如下所示：
- en: '[PRE55]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Here, we are using flows to return a list of users, and we use the `OnConflictStrategy.REPLACE`
    option so that if the same user is inserted multiple times, then it will be replaced
    with the one that will be inserted. Other options include `OnConflictStrategy.ABORT`,
    which will drop the entire transaction if a conflict occurs, or `OnConflictStrategy.IGNORE`,
    which will skip inserting rows where a conflict occurs.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用flows返回用户列表，并使用`OnConflictStrategy.REPLACE`选项，如果插入相同用户多次，则将其替换为将要插入的那个。其他选项包括`OnConflictStrategy.ABORT`，如果发生冲突，将丢弃整个事务，或者`OnConflictStrategy.IGNORE`，如果发生冲突，将跳过插入行。
- en: 'Now, go ahead and create an `AppDatabase` class, as follows:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，继续创建一个`AppDatabase`类，如下所示：
- en: '[PRE56]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In `AppDatabase`, we provide the `UserDao` class to be accessed and we use the
    `UserEntity` class for the users' table.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AppDatabase`中，我们提供`UserDao`类以供访问，并使用`UserEntity`类作为用户表。
- en: 'Next, we will need to initialize the `AppDatabase` object, as follows:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要初始化`AppDatabase`对象，如下所示：
- en: '[PRE57]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Here, we are having the same issues that we had for Retrofit, so we will follow
    the same approach and use the `Application` class. Just as with Retrofit, a DI
    framework will help us solve this problem.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遇到了与Retrofit相同的问题，因此我们将采取相同的方法并使用`Application`类。就像Retrofit一样，一个依赖注入框架将帮助我们解决这个问题。
- en: 'Now, let''s integrate Room into the `MainViewModel` class, as follows:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们将Room集成到`MainViewModel`类中，如下所示：
- en: '[PRE58]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `MainViewModel` class now has a new dependency on the `UserDao` class. In
    the `init` block, we now create a flow in which we emit a list of users obtained
    from Retrofit that is then converted into `UserEntity` and inserted into the database.
    After this, we will query the `UserEntities` instances and return them in a stream
    that will be the result. If we have an error, we will return the current stored
    users.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainViewModel`类现在有一个新的依赖项`UserDao`类。在`init`块中，我们现在创建一个流，其中发出从Retrofit获取的用户列表，然后将其转换为`UserEntity`并插入到数据库中。之后，我们将查询`UserEntities`实例，并以流的形式返回它们，这将作为结果。如果发生错误，我们将返回当前存储的用户。'
- en: 'Finally, update the type of users in the `MainActivity` class, as follows:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更新`MainActivity`类中用户的类型，如下所示：
- en: '[PRE59]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Here, we just change the dependency to now rely on the `UserEntity` class.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是将依赖项更改为现在依赖于`UserEntity`类。
- en: If we run the application after following the steps from the exercise, we will
    see the same output as for *Exercise 02.03*. However, if we close the application,
    turn on Airplane mode on the device, and reopen the app, we will still see the
    previously displayed information.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们按照练习中的步骤运行应用程序，我们将看到与*练习02.03*相同的输出。然而，如果我们关闭应用程序，在设备上开启飞行模式，然后重新打开应用程序，我们仍然会看到之前显示的信息。
- en: In this section, we have analyzed how we can persist structured data on a device
    and used the Room library to do so. We have also observed the interaction between
    Room and other libraries such as Retrofit and flows and how we can use flows to
    combine data streams from Room and Retrofit in a very straightforward way. In
    the next section, we will look at how we can persist simple data in key-value
    pairs.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了如何在设备上持久化结构化数据，并使用了 Room 库来实现这一点。我们还观察了 Room 与其他库（如 Retrofit 和流）之间的交互，以及我们如何使用流以非常直接的方式结合
    Room 和 Retrofit 的数据流。在下一节中，我们将探讨如何以键值对的形式持久化简单数据。
- en: Understanding and using the DataStore library
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解和使用 DataStore 库
- en: In this section, we will discuss how we can persist key-value pairs of data
    and how we can use the DataStore library for this. In Android, we have the possibility
    of persisting primitives and strings in key-value pairs. In the past, this was
    done through the `SharedPreferences` class, which was part of the Android framework.
    The keys and values would ultimately be saved inside an XML file on the device.
    Because this deals with I/O operations, it evolved over time to give the possibility
    to save data asynchronously and to keep an in-memory cache for quick access to
    data. There were, however, some inconsistencies with this, especially when the
    `SharedPreferences` object was initialized. DataStore is designed to address these
    issues because it's integrated with coroutines and flows.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论如何持久化数据的键值对，以及如何使用 DataStore 库来实现这一点。在 Android 中，我们有在键值对中持久化基本类型和字符串的可能性。在过去，这是通过
    `SharedPreferences` 类来完成的，它是 Android 框架的一部分。键和值最终会被保存在设备上的一个 XML 文件中。由于这涉及到 I/O
    操作，随着时间的推移，它演变为提供异步保存数据的能力，并保持内存缓存以快速访问数据。然而，这存在一些不一致性，尤其是在初始化 `SharedPreferences`
    对象时。DataStore 的设计是为了解决这些问题，因为它与协程和流集成。
- en: 'To add DataStore to a project, we will need the following dependency:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 DataStore 添加到项目中，我们需要以下依赖项：
- en: '[PRE60]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Using DataStore will look something like this:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 DataStore 的样子如下：
- en: '[PRE61]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The `KEY_TEXT` field will represent a key that will be used to store some text.
    `DataStore<Preferences>` is responsible for obtaining and writing the data to
    `SharedPreferences`. The `savedText` field will monitor changes in the preferences
    and will emit a new value for each change in a `Flow` object. To write data in
    an asynchronous way, we will need to edit the current data store and set the value
    associated with the key.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`KEY_TEXT` 字段将代表一个用于存储文本的键。`DataStore<Preferences>` 负责获取和将数据写入 `SharedPreferences`。`savedText`
    字段将监控首选项的变化，并为每个变化在 `Flow` 对象中发出一个新值。要异步写入数据，我们需要编辑当前的数据存储并设置与键关联的值。'
- en: 'To initialize the DataStore library, we will need to declare the following
    as a top-level declaration:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 要初始化 DataStore 库，我们需要将以下内容声明为顶级声明：
- en: '[PRE62]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: This will allow us to access the DataStore library in the rest of the application.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够访问应用程序其余部分的 DataStore 库。
- en: 'When we want to initialize `AppDataStore`, we can use the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要初始化 `AppDataStore` 时，我们可以使用以下代码：
- en: '[PRE63]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: This allows us to wrap the `DataStore` class and avoid exposing the dependencies
    to other places in the application.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们包装 `DataStore` 类，避免将依赖项暴露给应用程序的其他地方。
- en: In this section, we have looked at how we can persist data in key-value pairs
    and how we can use the DataStore library to do this. In the next section, we will
    create an Android application that will use DataStore and integrate it with Kotlin
    flows and coroutines.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何以键值对的形式持久化数据，以及如何使用 DataStore 库来实现这一点。在下一节中，我们将创建一个 Android 应用程序，该程序将使用
    DataStore 并将其与 Kotlin 流和协程集成。
- en: Exercise 02.05 – Using DataStore to persist data
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 02.05 – 使用 DataStore 持久化数据
- en: Modify *Exercise 02.04* and introduce the DataStore library, which will persist
    the number of executed requests to get the user and display this number above
    the list of items.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *练习 02.04* 并引入 DataStore 库，该库将持久化获取用户时执行的请求数量，并在项目列表上方显示此数量。
- en: 'To complete the exercise, you will need to do the following:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成练习，你需要做以下事情：
- en: Create a class named `AppDataStore` that will manage interaction with the DataStore
    library.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个名为 `AppDataStore` 的类，该类将管理与 DataStore 库的交互。
- en: Modify the `MainViewModel` class so that the `AppDataStore` dependency is injected
    and used to retrieve the current number of requests and increment the number of
    requests.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改 `MainViewModel` 类，以便注入并使用 `AppDataStore` 依赖项来检索当前请求数量并增加请求数量。
- en: Modify the `MainActivity` class to add a new `Text` object that will display
    the count of requests.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改`MainActivity`类，添加一个新的`Text`对象，用于显示请求的计数。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'Add the following dependency to the `app/build.gradle` file:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下依赖项添加到`app/build.gradle`文件中：
- en: '[PRE64]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Create an `AppDataStore` class, as follows:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`AppDataStore`类，如下所示：
- en: '[PRE65]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Here, `KEY_COUNT` represents the key used by the DataStore library to store
    the number of requests. The `saveCount` field will emit a new count value every
    time it changes, and `incrementCount` will be increment the current saved number
    by 1.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`KEY_COUNT`代表DataStore库用于存储请求数量的键。每当`saveCount`字段发生变化时，它将发出一个新的计数值，而`incrementCount`将增加当前保存的数字1。
- en: 'Now, set up the `AppDataStore` dependency, just like how we handled the Retrofit
    and Room dependencies. The code is illustrated in the following snippet:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，设置`AppDataStore`依赖项，就像我们处理Retrofit和Room依赖项一样。代码如下所示：
- en: '[PRE66]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Here, we initialize the `DataStore` object and then inject it into the `AppDataStore`
    class.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们初始化`DataStore`对象，然后将其注入到`AppDataStore`类中。
- en: 'Next, modify the `MainViewModel` class, as follows:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式修改`MainViewModel`类：
- en: '[PRE67]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Here, we add a new dependency to `AppDataStore`, then we call `incrementCount`
    from `AppDataStore` after the users from Retrofit are inserted, and then we will
    insert `savedCount` from `AppDataStore` into the existing flow and create a new
    `UiState` object that contains a list of users and the count, which will be collected
    in the `resultState` object.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向`AppDataStore`添加一个新的依赖项，然后在将用户从Retrofit插入后，从`AppDataStore`调用`incrementCount`方法，然后我们将`AppDataStore`中的`savedCount`插入到现有的流程中，并创建一个新的`UiState`对象，该对象包含用户列表和计数，这些将被收集在`resultState`对象中。
- en: 'The `UiState` class will look something like this:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UiState`类看起来可能如下所示：'
- en: '[PRE68]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This class will hold information from both of our persistent data sources.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此类将保存来自我们两个持久数据源的信息。
- en: 'Next, change `MainViewModelFactory`, as follows:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式更改`MainViewModelFactory`：
- en: '[PRE69]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, we will inject a new dependency to `AppDataStore` into the `MainViewModel`
    class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将一个新的依赖项注入到`AppDataStore`中，并将其注入到`MainViewModel`类中。
- en: 'Finally, modify the `MainActivity` class, as follows:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，按照以下方式修改`MainActivity`类：
- en: '[PRE70]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Here, we replaced the list of `UserEntity` with the `UiState` dependency and
    added a new row in a list of items that will indicate the count of requests.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`UserEntity`列表替换为`UiState`依赖项，并在项目列表中添加一行新行，以指示请求的计数。
- en: If we run the application, we will see at the top the current count of requests
    made to the server. If we kill and reopen the application, then we will see that
    count increase, which shows how it will survive the application being stopped
    by the user or killed by the operating system.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将在顶部看到发送到服务器的当前请求计数。如果我们终止并重新打开应用程序，我们将看到计数增加，这显示了它如何在使用户停止应用程序或操作系统终止应用程序时存活下来。
- en: In this section, we have analyzed another common way of persisting data on an
    Android device through the DataStore library. We also observed how easy it is
    for the DataStore library to be integrated with flows and other libraries such
    as Room and Retrofit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们分析了在Android设备上通过DataStore库持久化数据的另一种常见方法。我们还观察到DataStore库与flows和其他库（如Room和Retrofit）集成的简便性。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at how we can load and persist data in Android
    and the rules we must follow for threading. We first analyzed how we can load
    data asynchronously and focused on coroutines and flows, for which we have done
    simple exercises for performing asynchronous operations on different threads and
    updating the UI on the main thread. We then studied how to load data from the
    internet using OkHttp and Retrofit, and followed this up with how to persist data
    using Room and DataStore and how we can integrate all of these with coroutines
    and flows. We highlighted the usage of these libraries in exercises, and we also
    showed how they can be integrated with coroutines and flows. The integration of
    different flows of data was combined in the `ViewModel` class, in which we loaded
    the network data and inserted it into the local database. This is generally not
    a good approach, and we will expand on how we can improve this in future chapters.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了如何在Android中加载数据和持久化数据，以及我们必须遵循的线程规则。我们首先分析了如何异步加载数据，并专注于协程和流，为此我们进行了简单的练习，以在不同的线程上执行异步操作并更新主线程上的UI。然后我们研究了如何使用OkHttp和Retrofit从互联网加载数据，接着探讨了如何使用Room和DataStore持久化数据，以及我们如何将这些与协程和流集成在一起。我们在练习中强调了这些库的使用，同时也展示了它们如何与协程和流集成。不同数据流的集成被组合在`ViewModel`类中，其中我们加载网络数据并将其插入到本地数据库中。这通常不是一个好的方法，我们将在未来的章节中进一步探讨如何改进这一点。
- en: In the next chapter, we will look at how we can present data to the user and
    the libraries and frameworks we can use to achieve this.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何向用户展示数据，以及我们可以使用的库和框架来实现这一点。
