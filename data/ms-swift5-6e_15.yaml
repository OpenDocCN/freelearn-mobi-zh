- en: '15'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '15'
- en: Advanced and Custom Operators
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级和自定义运算符
- en: When I started learning how to program computers, one of the first things I
    learned was how to use operators. These include basic operators like assignment
    and arithmetic operators, which were covered in *Chapter 3*, *Learning about Variables,
    Constants, Strings, and Operators*. It wasn't until much later, when I learned
    how to program in the C language, that I learned about advanced operators such
    as bitwise operators. While the advanced operators are not as popular as the basic
    operators, they can be very powerful when used correctly. Advanced operators are
    especially useful if you are planning on writing applications that use low-level
    C-based libraries.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习如何编程计算机时，我首先学到的就是如何使用运算符。这些包括基本的运算符，如赋值和算术运算符，这些在*第3章*，*了解变量、常量、字符串和运算符*中有所介绍。直到我后来学习C语言编程时，我才了解到高级运算符，如位运算符。虽然高级运算符不如基本运算符流行，但使用得当的话，它们可以非常强大。如果你打算编写使用基于C的低级库的应用程序，高级运算符特别有用。
- en: 'In this chapter, you will learn:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to use bitwise operators
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用位运算符
- en: What overflow operators are for
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 溢出运算符的作用
- en: How to write operator methods
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编写运算符方法
- en: How to create your own custom operator
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建自己的自定义运算符
- en: In *Chapter 3*, *Learning about Variables, Constants, Strings, and Operators*,
    we looked at the most common operators, like assignment, comparison, and arithmetic
    operators. While these operators are used in virtually every useful application,
    there are some additional operators that aren't used as often but can be very
    powerful when you know how to use them. We will look at some of these more advanced
    operators in this chapter, starting with bitwise operators, but first, we need
    to understand what bits and bytes are.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第3章*，*了解变量、常量、字符串和运算符*中，我们探讨了最常见的运算符，如赋值、比较和算术运算符。虽然这些运算符在几乎每个有用的应用程序中都会使用，但还有一些不太常用但当你知道如何使用时可以非常强大的运算符。在本章中，我们将探讨一些这些更高级的运算符，从位运算符开始，但首先，我们需要了解比特和字节是什么。
- en: Bits and bytes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 比特和字节
- en: 'A computer thinks in terms of binary digits. These digits are called **bits**
    and can have only two values: *0* or *1*, which represent *on* or *off* in electrical
    terms. Bits are very small and have limited usefulness on their own outside of
    using them for true/false flags. They are grouped together into groups of 4, 8,
    16, 32, or 64 to form data that a computer can use.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机以二进制位的形式思考。这些数字被称为**比特**，并且只能有两个值：*0*或*1*，在电气术语中代表*开*或*关*。比特非常小，单独使用时用途有限，除了用作真/假标志。它们被组合成4、8、16、32或64位的组合，以形成计算机可以使用的数据。
- en: 'A **byte** in computer terms is a group of 8 bits. If we think in terms of
    a byte, the number 42 is represented like this, where the least significant bit
    is to the right and the most significant bit is to the left:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机术语中，**字节**是一组8位。如果我们从字节的角度思考，数字42表示如下，其中最低有效位在右边，最高有效位在左边：
- en: '![A screen shot of a clock  Description automatically generated](img/B16683_15_01.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![时钟的屏幕截图  描述自动生成](img/B16683_15_01.png)'
- en: 'Figure 15.1: The number 42 represented in bits'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.1：以比特表示的数字42
- en: 'The top row in *Figure 15.1* shows the value, on or off, of each bit for an
    8-bit byte that equals the number **42**. The second row shows you the value represented
    by each bit in the byte. We can see that for the number **42**, the bits for the
    values of **32**, **8**, and **2** are set. We can then add up those values and
    see that they equal 42: 32+8+2 = 42\. This means that the value of the 8-bit byte
    is 42.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '*图15.1*的顶部行显示了8位字节中每个比特的值，即开或关，等于数字**42**。第二行显示了字节中每个比特所表示的值。我们可以看到，对于数字**42**，值为**32**、**8**和**2**的比特被设置。然后我们可以将这些值相加，看到它们等于42：32+8+2
    = 42。这意味着8位字节的值为42。'
- en: By default, Swift uses 64-bit numbers; as an example, the standard `Int` type
    is 64 bits. In this chapter we will mostly use the `UInt8` type, which is an unsigned
    integer that has only 8 bits or 1 byte. Keep in mind that the 64-bit types store
    bits in the same way as a byte; they just contain more bits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Swift使用64位数字；例如，标准的`Int`类型是64位。在本章中，我们将主要使用`UInt8`类型，它是一个无符号整数，只有8位或1字节。请注意，64位类型以与字节相同的方式存储比特；它们只是包含更多的比特。
- en: In the previous example, the least significant bit is to the right while the
    most significant is to the left. This is the way that bits are usually represented
    when shown in diagrams. However, in real-world computer architectures, the bits
    may be stored in memory, where either the most significant bit or the least significant
    bit is stored in the lowest memory address. Let's take a look at what this means.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个例子中，最低有效位在右边，而最高有效位在左边。这是位在图中通常表示的方式。然而，在现实世界的计算机架构中，位可能存储在内存中，其中最高有效位或最低有效位存储在最低的内存地址中。让我们看看这意味着什么。
- en: Endianness
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 端序
- en: In computer terms, the **endianness** of an architecture is the order in which
    bits are stored in the memory. Endianness is expressed as big-endian or little-endian.
    In an architecture that is considered little-endian, the least significant bit
    is stored in the lowest memory address, while in architectures that are considered
    big-endian, the most significant bit is stored in the lowest memory address.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机术语中，一个架构的 **端序** 是位在内存中存储的顺序。端序表示为大端序或小端序。在一个被认为是小端序的架构中，最低有效位存储在最低的内存地址中，而在被认为是大端序的架构中，最高有效位存储在最低的内存地址中。
- en: When working with the Swift standard library, and for the most part when working
    solely within the Swift language itself, you do not need to worry about how the
    bits are stored. If you need to work with low-level C libraries, across multiple
    architectures, then you may need to understand how information is stored within
    the system because you may be dealing with pointers to memory locations.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Swift 标准库，以及在大多数情况下仅使用 Swift 语言本身时，你不需要担心位是如何存储的。如果你需要与低级别的 C 库一起工作，跨多个架构，那么你可能需要了解信息在系统中的存储方式，因为你可能正在处理指向内存位置的指针。
- en: 'For the times when you need to worry about the endianness of the architecture,
    like when we need to interact with low-level C libraries, Swift does have built-in
    instance properties for integers named `littleEndian` and `bigEndian`. The following
    example shows how to use these properties:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要担心架构的端序时，比如当我们需要与低级别的 C 库交互时，Swift 确实为整数提供了内置的实例属性，名为 `littleEndian` 和 `bigEndian`。以下示例展示了如何使用这些属性：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `en.littleEndian` line would return the little-endian representation of
    the number 42, while the `en.bigEndian` line would return the big-endian representation
    of the number 42.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`en.littleEndian` 行将返回数字 42 的小端序表示，而 `en.bigEndian` 行将返回数字 42 的大端序表示。'
- en: The endianness of both Intel processors and Apple's own A processors is little-endian;
    therefore, in this chapter, we will assume that everything is little-endian.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 英特尔处理器和苹果自己的 A 处理器的端序都是小端序；因此，在本章中，我们将假设一切都是小端序。
- en: Let's look at what bitwise operators are and how we can use them.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看位运算符是什么以及我们如何使用它们。
- en: Bitwise operators
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 位运算符
- en: '**Bitwise operators** enable us to manipulate the individual bits of a value.
    One of the advantages of bitwise operators is that they are directly supported
    by the processor and so can be significantly faster than basic arithmetic operations
    like multiplication and division. We will see how to do basic multiplication and
    division using bitwise shift operators later in this chapter.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**位运算符**使我们能够操作值的单个位。位运算符的一个优点是它们直接由处理器支持，因此可以比基本的算术运算（如乘法和除法）快得多。我们将在本章后面看到如何使用位移运算符进行基本的乘法和除法。'
- en: Before we look at what we can do with bitwise operators, we will need to have
    the ability to show the binary representation of our variables in order to see
    what the operators are doing. Let's take a look at a couple of ways that we can
    do this.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看位运算符能做什么之前，我们需要有能力显示我们变量的二进制表示，以便看到运算符在做什么。让我们看看我们可以这样做的一些方法。
- en: Printing binary numbers
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 打印二进制数
- en: 'Apple provides us with a generic initializer for the `String` type that will
    provide us with the string representation of a given value. This initializer is
    `init(_:radix:uppercase:)`. By default `uppercase` is set to `false` and `radix`
    is set to `10`. The `radix` defines the number base that will be displayed, where
    the `10` stands for base 10\. In order to see the binary representation, we will
    need to set that to `2`. We can use this initializer to show the binary representation
    of a value like this:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为我们提供了`String`类型的通用初始化器，它将提供给定值的字符串表示。这个初始化器是`init(_:radix:uppercase:)`。默认情况下，`uppercase`设置为`false`，`radix`设置为`10`。`radix`定义了将要显示的数字基数，其中`10`代表十进制。为了看到二进制表示，我们需要将其设置为`2`。我们可以使用这个初始化器来显示类似以下这样的值的二进制表示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The previous code would display the following results:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将显示以下结果：
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here, `101010` is the binary representation of the number `42` and `110101`
    is the binary representation of the number `53`. This works really well; however,
    it does not show leading zeros. For example, if we are comparing the binary representation
    of `53` and `123456`, like the following code shows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，`101010`是数字`42`的二进制表示，`110101`是数字`53`的二进制表示。这工作得非常好；然而，它没有显示前导零。例如，如果我们比较`53`和`123456`的二进制表示，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We end up with results that look like this:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们得到的结果看起来像这样：
- en: '[PRE4]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This can be a lot harder to compare. When I need to easily see the binary representation
    of a number, I usually drop the following extension into my code base:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能比较难以比较。当我需要轻松地看到数字的二进制表示时，我通常将以下扩展放入我的代码库中：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: It is OK if you do not understand how this code works at this time since bitwise
    shift operators have not been explained yet. Once they have been explained later
    in this chapter, you will be able to understand how it works.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在还不理解这段代码是如何工作的，这是完全可以的，因为位移运算符还没有被解释。一旦在本章后面解释了它们，你将能够理解它是如何工作的。
- en: 'This extension will take an integer and return the binary representation of
    the number, with the appropriate number of nibbles. Earlier in the chapter we
    mentioned that a byte has 8 bits; a nibble is half a byte or 4 bits. Within the
    string that is returned, this code will put a space between each nibble to make
    it easier to read. We can use this extension as shown in the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展将接受一个整数，并返回该数字的二进制表示，带有适当数量的半字节。在本章前面提到，一个字节有8位；半字节是字节的一半或4位。在返回的字符串中，这段代码将在每个半字节之间放置一个空格，以便更容易阅读。我们可以像以下代码所示使用这个扩展：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'With this code we are displaying the binary representation of the numbers `53`
    and `230` in two nibbles. The following results show what would be printed to
    the console:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们显示了数字`53`和`230`在两个半字节中的二进制表示。以下结果显示了将打印到控制台的内容：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now that we have a very basic idea of what bits, bytes, nibbles, and endianness
    are, and we are able to display numbers in binary format, let's look at bitwise
    operators, starting with the bitwise AND operator.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对位、字节、半字节和字节序有了非常基本的了解，并且能够以二进制格式显示数字，让我们来看看位运算符，从位与运算符开始。
- en: The bitwise AND operator
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 位与运算符
- en: 'The bitwise AND operator (`&`) takes two values and returns a new value where
    the bits in the new value are set to 1 only if the corresponding bits of both
    input values are set to 1\. The AND operator can be read as: if the bit from the
    first value AND the bit of the second value are both 1, then set the corresponding
    bit of the resultant value to 1\. Let''s see how this works by seeing how we would
    do a bitwise AND operation on the numbers 42 and 11:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 位与运算符（`&`）接受两个值，并返回一个新值，其中新值中的位仅当两个输入值的对应位都设置为1时才设置为1。与运算符可以读作：如果第一个值的位与第二个值的位都是1，则将结果值的对应位设置为1。让我们通过看看如何对数字42和11进行位与运算来了解它是如何工作的：
- en: '![A close up of a keyboard  Description automatically generated](img/B16683_15_02.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![键盘的特写  描述自动生成](img/B16683_15_02.png)'
- en: 'Figure 15.2: The AND operator'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.2：AND运算符
- en: 'As this diagram shows, the second and fourth bit from the right are both set
    to **1**, therefore the results of the AND operation has those bits set, resulting
    in an output value of **10**. Now let''s see how this works in code:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图所示，从右数第二位和第四位都是1，因此AND运算的结果将那些位设置为1，得到输出值**10**。现在让我们看看代码中是如何实现的：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers, in two nibbles, using the `binaryFormat` extension
    to the console. It then performs a bitwise AND operation on the integers and prints
    the binary representation of the results to the console. The following results
    will be printed to the console:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将两个整数设置为`42`和`11`。然后它使用`binaryFormat`扩展在控制台打印数字的二进制表示，以两个十六进制位为单位。然后它对整数执行按位AND运算并将结果的二进制表示打印到控制台。以下结果将被打印到控制台：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: As we can see, the result from the code is the same as shown in the diagram,
    which has a result of `10`. Now let's look at the bitwise OR operator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码的结果与图表中显示的相同，结果为`10`。现在让我们看看按位OR运算符。
- en: The bitwise OR operator
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位OR运算符
- en: 'The bitwise OR operator (`|`) takes two values and returns a new value where
    the bits of the results are set to 1 only if the corresponding bits of either
    or both values are set to 1\. The OR operation reads as: if the bit from the first
    value OR the bit of the second value is 1, then set the bit in the results to
    1\. Let''s see how this works by seeing how we would do a bitwise OR operation
    on the numbers 42 and 11:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 按位OR运算符（`|`）接受两个值并返回一个新值，其中结果的位仅当任一或两个值的对应位设置为1时才设置为1。OR运算读作：如果第一个值的位或第二个值的位为1，则将结果中的位设置为1。让我们看看我们如何对数字42和11进行按位OR运算：
- en: '![A close up of a keyboard  Description automatically generated](img/B16683_15_03.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![键盘的特写 描述自动生成](img/B16683_15_03.png)'
- en: 'Figure 15.3: The OR operator'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.3：OR运算符
- en: 'As this diagram shows, the first, second, fourth, and sixth bits from the right
    are set in one or both of the values, therefore the results of the OR operation
    have all of those bits set. Now let''s see how this works in code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图表所示，从右数起的第一、第二、第四和第六位在其中一个或两个值中设置为1，因此OR运算的结果将所有这些位都设置为1。现在让我们看看这在代码中是如何工作的：
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers, in two nibbles, using the `binaryFormat` extension
    to the console. It then performs a bitwise OR operation on the integers and prints
    the binary representation of the results. The following results will be printed
    to the console:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将两个整数设置为`42`和`11`。然后它使用`binaryFormat`扩展在控制台打印数字的二进制表示，以两个十六进制位为单位。然后它对整数执行按位OR运算并打印结果的二进制表示。以下结果将被打印到控制台：
- en: '[PRE11]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: As we can see, the result from the code is the same as shown in *Figure 15.3*,
    which has a result of `43`. Now let's look at the bitwise XOR operator.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码的结果与*图15.3*中显示的相同，结果为`43`。现在让我们看看按位XOR运算符。
- en: The bitwise XOR operator
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位XOR运算符
- en: 'The bitwise XOR operator (`^`) takes two values and returns a new value where
    the bits of the new value are set to 1 only if the corresponding bits of either
    but not both input values are set to 1\. The XOR operator reads: if the bit from
    the first value OR the bit of the second value is 1, but not both, then set the
    bit of the results to 1\. Let''s see how this works by seeing how we would do
    a bitwise OR operation on the numbers 42 and 11:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 按位XOR运算符（`^`）接受两个值并返回一个新值，其中新值的位仅当任一但不是两个输入值的对应位设置为1时才设置为1。XOR运算符读作：如果第一个值的位或第二个值的位为1，但不是两个都为1，则将结果中的位设置为1。让我们看看我们如何对数字42和11进行按位XOR运算：
- en: '![Chart, box and whisker chart  Description automatically generated](img/B16683_15_04.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图表，箱线图 描述自动生成](img/B16683_15_04.png)'
- en: 'Figure 15.4: The XOR operator'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.4：XOR运算符
- en: 'As this diagram shows, the second and fourth bits from the right are set to
    **1** for both numbers, therefore in the results those bits are not set. However,
    the sixth bit in the number **42** is set to **1** and the first bit in the number
    **11** is set to **1**, therefore in the results those bits are set. Now let''s
    see how this works in code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如此图表所示，对于两个数，从右数起的第二和第四位都设置为**1**，因此在结果中这些位没有被设置。然而，数字**42**中的第六位被设置为**1**，而数字**11**中的第一位被设置为**1**，因此在这些结果中这些位被设置。现在让我们看看这在代码中是如何工作的：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The previous code sets two integers to `42` and `11`. It then prints the binary
    representation of the numbers to two nibbles using the `binaryFormat` extension.
    It then performs a bitwise XOR operation on the integers and prints the binary
    representation of the results. The following results will be printed to the console:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将两个整数设置为`42`和`11`。然后使用`binaryFormat`扩展将数字的二进制表示打印到两个四分位上。接着对整数执行按位异或操作，并打印结果的二进制表示。以下结果将被打印到控制台：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As we can see, the result from the code is the same as shown in the diagram,
    which has a result of `33`. Now let's look at the bitwise NOT operator.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，代码的结果与图表中显示的相同，结果为`33`。现在让我们看看按位非运算符。
- en: The bitwise NOT operator
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位非运算符
- en: 'The bitwise NOT operator (`~`) is different from the other logical operators
    because it only takes one value. The bitwise NOT operator will return a value
    where all of the bits are reversed. What this means is that any bit on the input
    value that is set to 1 will be set to 0 on the resulting value, and any bit that
    is set to 0 on the input value will be set to 1 on the resulting value. Let''s
    see how this would work given a value of 42:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按位非运算符（`~`）与其他逻辑运算符不同，因为它只接受一个值。按位非运算符将返回一个所有位都被反转的值。这意味着输入值中设置为1的任何位在结果值中将被设置为0，而输入值中设置为0的任何位在结果值中将被设置为1。让我们看看给定42这个值会如何：
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_05.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![时钟的特写  自动生成的描述](img/B16683_15_05.png)'
- en: 'Figure 15.5: The NOT operator'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.5：非运算符
- en: 'The diagram illustrates that when we perform the bitwise NOT operation, all
    of the bits in the result''s value will be the opposite of what they were in the
    original value. Let''s see what this looks like in code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图表说明了当我们执行按位非操作时，结果值中的所有位都将与原始值中的位相反。让我们看看代码中的样子：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The previous code performs the NOT operation on the value of the `numberOne`
    variable. The following results will be printed to the console:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码对`numberOne`变量的值执行了非操作。以下结果将被打印到控制台：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Notice the results are a negative number. The reason for this is an integer
    is a signed number. With signed numbers, the most significant bit designates whether
    the number is a positive number or a negative number. With all bits being reversed,
    with the NOT operation, a negative number will always turn into a positive number
    and a positive number will always turn into a negative number.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意结果是一个负数。这是因为整数是有符号数。在有符号数中，最高有效位表示该数是正数还是负数。通过所有位反转，非操作后，负数将始终变成正数，而正数将始终变成负数。
- en: Now that we have looked at the logical bitwise operators, let's look at the
    bitwise shifting operators.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了逻辑按位运算符，让我们来看看按位移位运算符。
- en: Bitwise shift operators
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 按位移位运算符
- en: 'Swift provides two bitwise shift operators, the bitwise left shift operator
    (`<<`) and the bitwise right shift operator (`>>`). These operators shift all
    bits to the left or right by the number of places specified. The shift operators
    have the effect of multiplying (left shift operator) or dividing (right shift
    operator) by factors of two. By shifting the bits to the left by one, you are
    doubling the value, and shifting them to the right by one will halve the value.
    Let''s see how these operators work, starting with the left shift operator:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Swift提供了两个按位移位运算符，即按位左移运算符（`<<`）和按位右移运算符（`>>`）。这些运算符将所有位向左或向右移动指定的位数。移位运算符的效果是乘以（左移运算符）或除以（右移运算符）2的因子。通过将位向左移动一位，你将值翻倍，而将位向右移动一位将值减半。让我们看看这些运算符是如何工作的，从左移运算符开始：
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_06.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![时钟的特写  自动生成的描述](img/B16683_15_06.png)'
- en: 'Figure 15.6: The left shift operator'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.6：左移运算符
- en: 'With the left shift operator, all bits in the original value are shifted to
    the left by one, with the most significant bit falling off and not factoring into
    the final result. The least significant bit in the result will always be set to
    zero. Now let''s look at the right shift operation:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用左移运算符，原始值中的所有位都向左移动一位，最高有效位掉落且不计入最终结果。结果中的最低有效位始终被设置为0。现在让我们看看右移操作：
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_07.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![时钟的特写  自动生成的描述](img/B16683_15_07.png)'
- en: 'Figure 15.7: The right shift operator'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.7：右移运算符
- en: With the right shift operator, all bits in the original value are shifted to
    the right one spot, with the least significant digit falling off. The most significant
    digit in the result will always be set to zero.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 使用右移运算符，原始值中的所有位都向右移动一个位置，最低有效位掉落。结果中的最高有效位始终被设置为0。
- en: 'Now let''s see what this looks like in code:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看这在代码中是什么样子：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this code, we start off by setting a variable to the number `24`. We then
    use the left shift operator to shift the bits one spot to the left. The number
    after the shift operator defines how many spots to shift the numbers. The next
    line shifts the bits one spot to the right, then the next line shifts the bits
    three spots to the left, and the next line shifts the bits four spots to the right.
    The final five lines print out the results to the console. If you run this code,
    you should see the following results:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先将一个变量设置为数字`24`。然后我们使用左移运算符将位向左移动一个位置。移位运算符后面的数字定义了移动的位置数。下一行将位向右移动一个位置，下一行将位向左移动三个位置，下一行将位向右移动四个位置。最后的五行将结果打印到控制台。如果你运行这段代码，你应该看到以下结果：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Looking at the results, we can see that the bits are shifted to the left or
    right depending on the shifting operator used. In the last line, we can see that
    when we shifted to the right four spaces, only one bit was set to `1` rather than
    two. This is because the bit in the fourth spot from the right in the original
    number actually fell off. If we would have shifted to the right five spots, both
    bits that were set to one in the original number would have fallen off and we
    would have been left with all zeros.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 观察结果，我们可以看到位根据所使用的移位运算符向左或向右移动。在最后一行，我们可以看到当我们向右移动四个位置时，只有一个位被设置为`1`而不是两个。这是因为原始数字从右数第四位的位实际上已经掉落了。如果我们向右移动五个位置，原始数字中设置为`1`的两个位都会掉落，我们就会剩下全部为零。
- en: Now let's look at overflow operators.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看溢出运算符。
- en: Overflow operators
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 溢出运算符
- en: 'Swift, at its core, is designed for safety. One of these safety mechanisms
    is the inability to insert a number into a variable when the variable type is
    too small to hold it. As an example, the following code will throw the following
    error: `arithmetic operation ''255 + 1'' (on type ''UInt8'') results in an overflow`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的核心设计是为了安全。这些安全机制之一是当变量的类型太小无法容纳时，无法将一个数插入到变量中。例如，以下代码将抛出以下错误：`算术运算 '255
    + 1'（在类型 'UInt8' 上）导致溢出`：
- en: '[PRE18]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The reason an error is thrown is we are trying to add one to the maximum number
    that a `UInt8` can hold. This error checking can help prevent unexpected and hard-to-trace
    issues in our applications. Let''s take a second and look at what would happen
    if Swift did not throw an error when an overflow occurs. In a `UInt8` variable,
    which is an 8-bit unsigned integer, the number 255 is stored like this, where
    all of the bits are set to 1:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 抛出错误的原因是我们试图将一个数加到`UInt8`能持有的最大数上。这种错误检查可以帮助防止我们应用程序中意外且难以追踪的问题。让我们花点时间看看如果Swift在溢出发生时不抛出错误会发生什么。在`UInt8`变量中，它是一个8位的无符号整数，数字255是这样存储的，其中所有的位都设置为1：
- en: '![A picture containing clock  Description automatically generated](img/B16683_15_08.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![包含时钟的图片 描述自动生成](img/B16683_15_08.png)'
- en: 'Figure 15.8: The binary representation of 255'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.8：255的二进制表示
- en: 'Now if we add 1 to this number, the new number will be stored like this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果我们给这个数加1，新的数字将这样存储：
- en: '![A close up of a clock  Description automatically generated](img/B16683_15_09.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![时钟的特写 描述自动生成](img/B16683_15_09.png)'
- en: 'Figure 15.9: Overflow when trying to represent 256'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图15.9：尝试表示256时的溢出
- en: Notice that the 8 bits that represent the `UInt8` number are all zeros, while
    the leading one falls off or overflows because we can only store 8 bits. In this
    case, when we add one to the number 255, the number stored in the results would
    be 0 if we did not have overflow error checking. This could lead to very unexpected
    behavior in our code that would be hard to track down.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，表示`UInt8`数字的8位都是零，而最高位的`1`掉落或溢出，因为我们只能存储8位。在这种情况下，当我们给数字255加1时，如果没有溢出错误检查，结果中存储的数字将是0。这可能导致我们代码中非常意外的行为，难以追踪。
- en: 'If this is the behavior that we want, Swift does offer three overflow operators
    that will allow us to opt into this behavior. These are the overflow addition
    operator (`&+`), the overflow subtraction operator (`&-`), and the overflow multiplication
    operator (`&*`). The following code shows how these operators work:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这是我们想要的行为，Swift确实提供了三个溢出操作符，允许我们选择这种行为。这些是溢出加法操作符（`&+`）、溢出减法操作符（`&-`）和溢出乘法操作符（`&*`）。以下代码显示了这些操作符的工作方式：
- en: '[PRE19]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In this code, we add one to the maximum value of the `UInt8` type, which is
    255, subtract one from the `UInt8` type minimum value, which is 0, and then multiply
    `42` by `10`, which has a result greater than the 255 maximum value of the `UInt8`
    type. The results that are printed to the console are:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们将1加到`UInt8`类型的最大值255上，从`UInt8`类型的最低值0减去1，然后将`42`乘以`10`，其结果大于`UInt8`类型的255最大值。打印到控制台的结果是：
- en: '[PRE20]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: As we can see from the results, when we add 1 to the maximum value of the `UInt8`
    type, the result is `0`. When we subtract 1 from the minimum value of the `UInt8`
    type, the result is `255` (the maximum value of the `UInt8` type). Finally, when
    we multiply `42` by `10`, which our arithmetic teachers would tell us is 420,
    we actually end up with `164` because of the overflow.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从结果中我们可以看出，当我们将1加到`UInt8`类型的最大值上时，结果是`0`。当我们从`UInt8`类型的最低值减去1时，结果是`255`（`UInt8`类型的最大值）。最后，当我们用`42`乘以`10`，这通常是我们的数学老师会告诉我们的结果是420，但实际上我们得到了`164`，因为发生了溢出。
- en: Now let's look at how we can use operator methods to add operators to our custom
    types.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看如何使用操作符方法将操作符添加到我们的自定义类型中。
- en: Operator methods
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作符方法
- en: 'Operator methods enable us to add implementations of standard Swift operators
    to classes and structures. This is also known as overloading operators. This is
    a very useful feature because it enables us to provide common functionality to
    our custom types using known operators. We''ll take a look at how to do this,
    but first, let''s create a custom type called `MyPoint`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 操作符方法使我们能够向类和结构体添加标准Swift操作符的实现。这也被称为操作符重载。这是一个非常有用的特性，因为它使我们能够使用已知的操作符为我们自定义类型提供常用功能。我们将看看如何做到这一点，但首先，让我们创建一个名为`MyPoint`的自定义类型：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `MyPoint` structure defines a two-dimensional point on a graph. Now let''s
    add three operator methods to this type. The operators that we will add are the
    addition operator (`+`), the addition assignment operator (`+=`), and the inverse
    operator (`-`). The addition operator and the addition assignment operator are
    infix operators because there is a left and right operand (value) to the operation,
    while the inverse operator is a prefix operator because it is used before a single
    value. We also have postfix operators, which are used at the end of a single value:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyPoint`结构体定义了一个图表上的二维点。现在让我们向这个类型添加三个操作符方法。我们将添加的操作符是加法操作符（`+`）、加法赋值操作符（`+=`）和逆操作符（`-`）。加法操作符和加法赋值操作符是中缀操作符，因为操作中有左操作数（值）和右操作数（值），而逆操作符是前缀操作符，因为它用于单个值之前。我们还有后缀操作符，它们用于单个值的末尾：'
- en: '[PRE22]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: When we add operator methods to our types, we add them as static functions using
    the operator symbols as the method names. When we add prefix or postfix operators,
    we also include the `prefix` or `postfix` keyword before the function declaration.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将操作符方法添加到我们的类型中时，我们使用操作符符号作为方法名称，将它们添加为静态函数。当我们添加前缀或后缀操作符时，我们还在函数声明之前包含`prefix`或`postfix`关键字。
- en: The addition operator is an infix operator; therefore, it takes two input parameters
    of the `MyPoint` type. One parameter is for the `MyPoint` instance that is to
    the left side of the addition operator and the other parameter is for the `MyPoint`
    instance that is to the right of the addition operator.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 加法操作符是一个中缀操作符；因此，它接受两个输入参数，都是`MyPoint`类型的。一个参数是为加法操作符左侧的`MyPoint`实例，另一个参数是为加法操作符右侧的`MyPoint`实例。
- en: The addition assignment operator is also an infix operator; therefore, it also
    takes two input parameters of the `MyPoint` type. The main difference from the
    addition operator is that the resulting value of the addition operation is assigned
    to the `MyPoint` instance that is to the left side of the addition assignment
    operator. Therefore, this parameter is designated as an `inout` parameter so the
    results can be returned within that instance.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 加法赋值运算符也是一个中缀运算符；因此，它也接受两个`MyPoint`类型的输入参数。与加法运算符的主要区别在于，加法运算的结果被赋值给加法赋值运算符左侧的`MyPoint`实例。因此，这个参数被指定为`inout`参数，以便可以在该实例内返回结果。
- en: 'The final operator method that we added is the inverse operator. This operator
    is a prefix operator and is used before an instance of the `MyPoint` type; therefore,
    it only takes a single parameter of the `MyPoint` type. Let''s see how these operators
    work:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的最后一个运算符方法是逆运算符。这是一个前缀运算符，用于`MyPoint`类型的实例之前；因此，它只接受一个`MyPoint`类型的参数。让我们看看这些运算符是如何工作的：
- en: '[PRE23]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this code, we begin by defining two points and then adding them together
    using the addition operator that we created. The results of this operator are
    put in the new `combined` instance of the `MyPoint` type. The `combined` instance
    will contain the values of `x` as 6 and `y` as 14.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段代码中，我们首先定义了两个点，然后使用我们创建的加法运算符将它们相加。这个运算符的结果被放入新的`combined`实例中，该实例是`MyPoint`类型。`combined`实例将包含`x`值为6和`y`值为14。
- en: We then use the addition assignment operator that we created to add the values
    in the `firstPoint` instance to the values in the `combined` instance. The result
    of this operation is put in the combined instance of the `MyPoint` type. The `combined`
    instance now contains the values of `x` as 7 and `y` as 14.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着使用我们创建的加法赋值运算符将`firstPoint`实例中的值添加到`combined`实例中的值。这个操作的结果被放入`MyPoint`类型的`combined`实例中。现在`combined`实例包含`x`值为7和`y`值为14。
- en: Finally, we use the inverse operator on the `combined` instance of the `MyPoint`
    type to reverse the values and save the new values in the `inverse` instance of
    the `MyPoint` type. The `inverse` instance contains the values of `x` as -7 and
    `y` as -18.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用`combined`实例的逆运算符来反转值，并将新值保存到`MyPoint`类型的`inverse`实例中。`inverse`实例包含`x`值为-7和`y`值为-18。
- en: We are not limited to using only current operators but can also create our own
    custom operators as well. Let's see how we can do this.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于使用当前运算符，还可以创建自己的自定义运算符。让我们看看我们如何做到这一点。
- en: Custom operators
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义运算符
- en: 'Custom operators enable us to declare and implement our own operators outside
    of the standard operators provided by the Swift language. New operators must be
    declared globally using the `operator` keyword. They must also be defined with
    the `infix`, `prefix`, or `postfix` keywords. Once an operator is defined globally,
    we are then able to add it to our types using the operator methods as shown in
    the previous section. Let''s take a look at this by adding two new operators:
    `•`, which we will use to multiply two points together, and `••`, which will be
    used to square a value. We will add these operators to the `MyPoint` type that
    we created in the last section.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义运算符使我们能够在Swift语言提供的标准运算符之外声明和实现自己的运算符。新的运算符必须使用`operator`关键字全局声明。它们还必须使用`infix`、`prefix`或`postfix`关键字进行定义。一旦一个运算符被全局定义，我们就可以使用前一个章节中展示的运算符方法将其添加到我们的类型中。让我们通过添加两个新的运算符来查看这一点：`•`，我们将用它来相乘两个点，以及`••`，它将用于平方一个值。我们将把这些运算符添加到我们在上一节中创建的`MyPoint`类型中。
- en: The `•` symbol can be typed by holding down the *option* key and pressing the
    number *8* on a computer running macOS.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`•`符号可以在运行macOS的计算机上通过按住*option*键并按下数字*8*来输入。'
- en: 'The first thing we need to do is to declare the operators globally. This can
    be done with the following code:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是全局声明运算符。这可以通过以下代码完成：
- en: '[PRE24]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Notice that we define what type of operator it is (`infix`, `prefix`, or `postfix`)
    followed by the `operator` keyword and then the symbol(s) that will be used for
    the operator. Now we can use them exactly like we do normal operators with our
    `MyPoint` type:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们定义了它是什么类型的运算符（`infix`、`prefix`或`postfix`），然后是`operator`关键字，然后是用于运算符的符号。现在我们可以像使用正常的运算符一样使用它们，针对我们的`MyPoint`类型：
- en: '[PRE25]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These new custom operators are added to the `MyPoint` type exactly as we added
    standard operators, using static functions. We are now able to use these operators
    exactly like we would use standard operators:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这些新的自定义操作符就像我们添加标准操作符一样，被添加到`MyPoint`类型中，使用静态函数。我们现在能够像使用标准操作符一样使用这些操作符：
- en: '[PRE26]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the first line we use the `•` operator to multiply two instances of the `MyPoint`
    type together. The results are put in the multiplied instance of the `MyPoint`
    type. The multiplied instance will now contain the values of `x` as 5 and `y`
    as 40\.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一行，我们使用`•`操作符将两个`MyPoint`类型的实例相乘。结果被放入`MyPoint`类型的乘积实例中。现在，乘积实例将包含`x`的值为5和`y`的值为40。
- en: We then use the `••` operator to square the value of the `secondPoint` instance
    and put the new value in the squared instance. The `squared` instance will now
    contain the values of `x` as 25 and `y` as 100.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`••`操作符平方`secondPoint`实例的值，并将新值放入平方实例中。现在，`squared`实例将包含`x`的值为25和`y`的值为100。
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we looked at how we can use the advanced bitwise AND, OR, XOR,
    and NOT operators to manipulate the bits of values stored in variables. We also
    looked at how we can use the left and right shift operators to shift bits to the
    left and right. We then saw how we can use overflow operators to change the default
    behavior for addition, subtraction, and multiplication so errors are not thrown
    if operations return values above the maximum or below the minimum values for
    a type.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用高级位与、或、异或和非操作符来操作存储在变量中的值的位。我们还探讨了如何使用左移和右移操作符将位向左和向右移动。然后我们看到如何使用溢出操作符来改变加法、减法和乘法的默认行为，以便在操作返回超出类型的最大值或小于最小值时不会抛出错误。
- en: In the second half of the chapter, we saw how we can add operator methods to
    types, which enables us to use the standard operators provided by Swift with our
    custom types. We also saw how we can create our own custom operators as well.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后半部分，我们看到了如何向类型添加操作符方法，这使得我们能够使用Swift提供的标准操作符与我们的自定义类型一起使用。我们还看到了如何创建我们自己的自定义操作符。
- en: In the next chapter, we will look at how we can use grand central dispatch and
    operation queues to add concurrency and parallelism to our applications' code.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何使用大中央调度和操作队列向我们的应用程序代码中添加并发性和并行性。
