- en: Chapter 8. Exploring Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 探索Swift
- en: In the final chapter of this book, if your heart so desires, you can start learning
    Swift, Apple's new programming language. Here, you'll get a brief overview of
    what Swift is, how the language works, and some various syntax differences between
    Objective-C and Swift. We'll also cover the creation of a few simple apps using
    Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的最后一章，如果你愿意，你可以开始学习Swift，苹果的新编程语言。在这里，你将简要了解Swift是什么，语言是如何工作的，以及Objective-C和Swift之间的一些各种语法差异。我们还将介绍使用Swift创建的一些简单应用程序。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: How Swift works
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift是如何工作的
- en: Learning Swift through Playgrounds
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过Playgrounds学习Swift
- en: Using Cocos2d-Swift to create a game in Swift instead of Objective-C
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Cocos2d-Swift在Swift中而不是Objective-C中创建游戏
- en: Tip
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This chapter will not cover most of Swift. It is instead intended as an introduction
    to coding in Swift through Cocos2d to create a game with this engine.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章不会涵盖Swift的大部分内容。相反，它旨在通过Cocos2d介绍在Swift中编码，使用这个引擎创建游戏。
- en: Also note that Swift, as a language, is only compatible with iOS 7 and above.
    If you intend to support iOS 6 or prior, you cannot use Swift in your project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，作为一门语言，Swift仅与iOS 7及以上版本兼容。如果你打算支持iOS 6或更早版本，你无法在你的项目中使用Swift。
- en: How Swift works
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift是如何工作的
- en: The main difference between Objective-C and Swift is in the way it looks. It
    still feels like Objective-C (in the sense that you can call all of the same methods),
    but the syntax is different.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C和Swift之间的主要区别在于外观。它仍然感觉像Objective-C（在这个意义上，你可以调用所有相同的方法），但语法不同。
- en: 'For example, suppose you want to call this in Objective-C:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你想要在Objective-C中调用以下内容：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Instead, you end up calling the following in Swift:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，你最终会在Swift中调用以下内容：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Also, instead of using a header and a main file as in Objective-C, there's only
    a `.swift` file that gets used for everything.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，与Objective-C中使用头文件和主文件不同，只有一个`.swift`文件被用于所有内容。
- en: There are obviously some syntax differences that you'll have to learn about
    when it comes to coding in Swift, but those who are familiar with Objective-C
    will pick up Swift quite easily. Don't worry, even if you aren't familiar with
    Objective-C. Swift is an easy-to-learn language, which makes picking it up much
    better.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在Swift中编码时，你将不得不学习一些语法差异，但熟悉Objective-C的人会很容易地掌握Swift。不用担心，即使你不熟悉Objective-C。Swift是一门易于学习的语言，这使得学习它变得更加容易。
- en: That being said, let's cover some syntax differences using Apple's new tool
    they created to help learn and debug Swift—Playgrounds.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们通过苹果新创建的工具来介绍一些语法差异，这个工具可以帮助学习和调试Swift——Playgrounds。
- en: Learning Swift through Playgrounds
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过Playgrounds学习Swift
- en: Playgrounds offer a way to test your Swift code quickly and easily without much
    baggage that usually comes when creating a test project in another language. They're
    intended as files used for prototyping and quick fiddling with code if you have
    problems with a small section. They're really easy to use and understand, so let's
    begin.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds提供了一种快速轻松地测试Swift代码的方法，而无需像在其他语言中创建测试项目时那样携带很多负担。它们旨在作为用于原型设计和快速调整代码的文件，如果你在某个小部分有问题的话。它们非常容易使用和理解，所以让我们开始吧。
- en: Note
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The first thing you'll notice about Swift is that there are no semicolons required
    (except when writing multiple statements on one line, which must be separated
    by semicolons). That's right—none! They're optional, but the preferred style of
    writing Swift code is without semicolons.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到Swift的一个特点是，不需要分号（除非在一行上写多个语句，这些语句必须由分号分隔）。没错——一个都不需要！它们是可选的，但编写Swift代码的首选风格是不使用分号。
- en: Also, when coding if statements, loops, switch statements, and so on, you must
    use curly braces around the block of code that will be run (even if there's only
    one line of code that will be executed).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在编写if语句、循环、switch语句等时，你必须使用花括号包围将要运行的代码块（即使只有一行代码将要执行）。
- en: Right now, go ahead and open the `SwiftSyntax.playground` file in the `Sample
    Projects` folder included with this book.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请打开这本书附带在“示例项目”文件夹中的`SwiftSyntax.playground`文件。
- en: Tip
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you cannot open the file within Xcode, update your version of Xcode to the
    newest version, as your version might be outdated.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你无法在Xcode中打开文件，请更新你的Xcode版本到最新版本，因为你的版本可能已经过时。
- en: When you open this file in Xcode, you'll see a lot of things happening. It's
    separated via comment lines (`// ------`). Each section represents a different
    set of syntax differences between Objective-C and Swift.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Xcode中打开此文件时，你会看到很多事情发生。它是通过注释行（`// ------`）分隔的。每个部分代表Objective-C和Swift之间不同的一组语法差异。
- en: Although it is not explicitly stated what the Objective-C equivalent is, you
    can see how to declare a variable, how to run loops, create and call functions,
    and so on. Also, not all the syntax differences with Swift are included here.
    Only the most common uses of the language appear here.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然没有明确说明Objective-C的等效语法是什么，但你可以看到如何声明变量，如何运行循环，创建和调用函数等等。此外，这里并没有包括Swift的所有语法差异。这里只列出了语言中最常见的用法。
- en: With the playground file opened, let's see how Playgrounds are organized so
    that you can better understand what's going on (and why Playgrounds are useful
    for purposes besides just being a place to hold code).
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开playground文件后，让我们看看Playgrounds是如何组织的，这样你可以更好地理解正在发生的事情（以及为什么Playgrounds除了作为一个存放代码的地方之外还有其他用途）。
- en: How Playgrounds are organized
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Playgrounds是如何组织的
- en: The left side obviously has the code. The right side has a description of the
    state of the code; for example, if it's a variable, it will show the variable's
    value. If it's a `println` statement (the standard way to print the console in
    Swift), it will display the output.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显然是代码。右侧是代码状态的描述；例如，如果是一个变量，它会显示变量的值。如果是一个`println`语句（Swift中打印控制台的标准方式），它会显示输出。
- en: If you type any new code in the Playground, you'll see the Playground's right-hand-side
    pane update as you type. If you copy and paste any code, you'll see all the lines
    updated with the final result of each line.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在Playground中输入任何新代码，你会看到Playground的右侧窗格随着你的输入而更新。如果你复制并粘贴任何代码，你会看到所有行都更新为每行的最终结果。
- en: Because this is a Playground, we don't have to worry about using a `println`
    or `NSLog` statement here. It will automatically show up on the right-hand side
    of the Playground.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因为这是一个Playground，我们不需要担心在这里使用`println`或`NSLog`语句。它将自动显示在Playground的右侧。
- en: Viewing the results over time
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看随时间推移的结果
- en: One of the cool things about using Playgrounds is that you can track the progress
    of your loops over time. For example, if you want to see each item that was printed
    in the names array, or what the value of a variable is in each iteration, you
    can see it visually with the Playground's **Value History** button.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Playgrounds的一个酷特点是你可以跟踪随时间推移的循环进度。例如，如果你想看到在names数组中打印的每个项目，或者每个迭代中变量的值，你可以通过Playground的**值历史**按钮直观地看到它。
- en: Also, if you want to debug your own Swift code in a project (and not just a
    Playground), you can bring it into a playground and observe the results over time.
    So if you have, say, an enemy patrolling back and forth with a loop, you can use
    the Playground's value history to see each value (in this case, position) at each
    iteration of the loop.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想在一个项目中调试自己的Swift代码（而不仅仅是Playground），你可以将其带入Playground中，并观察随时间推移的结果。所以，如果你有一个敌人用循环来回巡逻，你可以使用Playground的值历史记录来查看循环每次迭代的每个值（在这种情况下，位置）。
- en: 'So first, go to the `for` loop section (approximately line 90), and find the
    line that says total `+= x` within the `for` loop, as shown in the following screenshot:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，转到`for`循环部分（大约在第90行），找到循环中说的total `+= x`的行，如图所示：
- en: '![Viewing the results over time](img/image00300.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![查看随时间推移的结果](img/image00300.jpeg)'
- en: 'To view, move your mouse arrow onto the (100 times) line in the right-hand-side
    pane, and you should see two buttons appear on the right side of it. The first
    is an eyeball that will show you every value that a given object contains. For
    example, if you have a dictionary, you can view all the key/value pairs in that
    dictionary, as shown in this screenshot:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看，将鼠标箭头移至右侧窗格中的（100倍）行上，你应该会看到在其右侧出现两个按钮。第一个是一个眼球，它会显示给定对象包含的每个值。例如，如果你有一个字典，你可以查看该字典中所有的键/值对，如图所示：
- en: '![Viewing the results over time](img/image00301.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![查看随时间推移的结果](img/image00301.jpeg)'
- en: 'The second button is the **Value History** button. When your mouse arrow is
    on it, it will turn into a **+** button, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个按钮是**值历史**按钮。当你的鼠标箭头放在它上面时，它会变成一个**+**按钮，如图所示：
- en: '![Viewing the results over time](img/image00302.jpeg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![查看随时间推移的结果](img/image00302.jpeg)'
- en: 'When you click on this button, you''ll see a chart showing the values of that
    variable over time as the loop iterates (you''ll also see the output console,
    which displays the names being printed as expected, from the previous loop) as
    shown in this screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击这个按钮时，你会看到一个图表，显示了循环迭代时该变量随时间变化的值（你也会看到输出控制台，它显示了从上一个循环中按预期打印的名称）如图所示：
- en: '![Viewing the results over time](img/image00303.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![查看随时间变化的结果](img/image00303.jpeg)'
- en: 'If you want to get more details of how your variable changes over time, you
    can either drag the red scrubber to the bottom of the **Value History** section,
    or click on any data point along the chart to see its respective value, as shown
    in the following screenshot:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要获取更多关于变量随时间变化详情，你可以通过拖动红色刮擦器到**值历史**部分的底部，或者点击图表上的任何数据点来查看其相应的值，如图所示：
- en: '![Viewing the results over time](img/image00304.jpeg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![查看随时间变化的结果](img/image00304.jpeg)'
- en: Learning more about Swift
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 了解更多关于Swift
- en: There's a lot of content on Swift that wasn't covered here, such as lazy variables,
    the identity operator, the nil coalescing operator, class initializers, inheritance,
    and so on.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift方面，这里没有涵盖很多内容，例如懒变量、身份操作符、空合并操作符、类初始化器、继承等等。
- en: Some great places to learn more about Swift include [www.lynda.com](http://www.lynda.com)
    (a great course on Swift is at [www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html](http://www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html))
    and [www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials),
    which have many online courses and tutorials that go over the basic and advanced
    features of Swift. You can also look at Apple's developer videos; just search
    for Swift at [https://developer.apple.com/videos/wwdc/2014/.](https://developer.apple.com/videos/wwdc/2014/.)
    Then there are sample projects, the Swift developer blog at [https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/),
    as well as other websites such as Stack Overflow.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 了解更多关于Swift的绝佳地方包括[www.lynda.com](http://www.lynda.com)（有一个关于Swift的精彩课程在[www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html](http://www.lynda.com/Swift-tutorials/Swift-Essential-Training/180105-2.html)）和[www.raywenderlich.com/tutorials](http://www.raywenderlich.com/tutorials)，这些网站提供了许多关于Swift基本和高级功能的在线课程和教程。你还可以查看苹果的开发者视频；只需在[https://developer.apple.com/videos/wwdc/2014/](https://developer.apple.com/videos/wwdc/2014/)搜索Swift。然后还有示例项目、Swift开发者博客[https://developer.apple.com/swift/blog/](https://developer.apple.com/swift/blog/)，以及其他如Stack
    Overflow等网站。
- en: As mentioned earlier, Playgrounds can be very useful for developers who are
    just learning Swift, as well as those who are more experienced and wish to test
    their code for debugging purposes.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Playgrounds对于刚开始学习Swift的开发者以及那些经验更丰富并希望进行代码调试的开发者来说非常有用。
- en: But a Playground isn't an app all by itself, so let's make a simple game using
    Swift as our language for Cocos2d. Again, you'll notice that the code itself is
    fairly similar to Objective-C; only the syntax is slightly different, so you should
    pick it up fairly quickly.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，Playground本身并不是一个完整的App，所以让我们用Swift作为Cocos2d的语言来制作一个简单的游戏。再次提醒，你会发现代码本身与Objective-C非常相似；只是语法略有不同，所以你应该能很快掌握。
- en: Creating a game in Swift instead of Objective-C
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用Swift而不是Objective-C来创建游戏
- en: The idea behind using Cocos2d-Swift is to switch over to the new programming
    language, right? Even though the Swift version of Cocos2d is still relatively
    new, and everything might not be implemented by the time you read this book, it
    can still be used as the core language when creating a game. So let's make a very
    simple game here, building upon the core concepts you just learned and combining
    them with the knowledge you already have of how the Cocos2d engine works in general.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Cocos2d-Swift背后的想法是转向新的编程语言，对吧？尽管Cocos2d的Swift版本仍然相对较新，而且在你阅读这本书的时候可能并不是所有功能都已实现，但它仍然可以作为创建游戏时的核心语言。所以，让我们在这里制作一个非常简单的游戏，基于你刚刚学到的核心概念，并结合你对Cocos2d引擎一般工作方式的了解。
- en: Why use Swift instead of Objective-C? Because, you should be staying up to date
    with the latest technologies in the field, and Swift is just the next step in
    that direction. Also, as the years pass by, Apple may slowly deprecate and stop
    supporting Objective-C (but that's just a theory).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么使用Swift而不是Objective-C？因为，你应该跟上该领域最新技术的步伐，Swift只是这一方向上的下一步。此外，随着时间的推移，苹果可能会逐渐弃用并停止支持Objective-C（但这只是一个理论）。
- en: In general, it helps to know more languages if the opportunity calls for it.
    And if you're interested in web development, Swift feels very similar to JavaScript,
    so it's like learning two languages at once.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果有机会，了解更多的语言是有帮助的。如果你对网页开发感兴趣，Swift感觉与JavaScript非常相似，所以感觉像是同时学习两种语言。
- en: So why Cocos2d-Swift specifically? For the same reasons you just read. Also,
    typing code in Swift is generally faster than in Objective-C, and so, if you can
    create code faster, you can, in theory, create games faster, which is awesome!
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 那么为什么特别选择Cocos2d-Swift呢？原因和你刚才读到的相同。此外，用Swift编写代码通常比用Objective-C快，所以，如果你能更快地编写代码，理论上你也能更快地制作游戏，这真是太棒了！
- en: Goal of the game
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏目标
- en: The game we're going to make consists of a turret in the center that can shoot
    bullets, a score counter, and square-shaped enemies that come in from the left
    and the right. If the enemies make it to the center, it's game over! As the score
    increases, so will the spawn rate of enemies, eventually overwhelming the turret's
    fire rate.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要制作的游戏包括一个位于中心的可以射击子弹的炮塔，一个得分计数器，以及从左右两边进入的正方形敌人。如果敌人到达中心，游戏就结束了！随着得分的增加，敌人的出生率也会增加，最终会超过炮塔的射击速度。
- en: 'Here are a few screenshots of the game we''ll be making:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是我们将要制作的游戏的几个截图：
- en: '![Goal of the game](img/image00305.jpeg)![Goal of the game](img/image00306.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![游戏目标](img/image00305.jpeg)![游戏目标](img/image00306.jpeg)'
- en: Starting a new Swift project
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始一个新的Swift项目
- en: Remember, the way to start Cocos2d projects now is by going through SpriteBuilder.
    Even though we won't be using SpriteBuilder for any code, we still have to go
    through the process of creating a project there.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，现在开始Cocos2d项目的方式是通过SpriteBuilder。即使我们不会在SpriteBuilder中使用任何代码，我们仍然需要在那里创建项目的过程。
- en: 'So, in SpriteBuilder, go to **File** | **New** | **Project**. Select the location
    where you want to create the project, name it something like `TurretGame`, and
    make sure you select **Swift** as the language. This is also shown in the following
    screenshot for your reference:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在SpriteBuilder中，转到**文件** | **新建** | **项目**。选择你想要创建项目的位置，将其命名为例如`TurretGame`，并确保选择**Swift**作为语言。以下截图供你参考：
- en: '![Starting a new Swift project](img/image00307.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![开始一个新的Swift项目](img/image00307.jpeg)'
- en: 'Then, in `Turret Game`, go to the `Assets` folder of this book''s content,
    and drag the `Images` folder into the resources list on the left side of SpriteBuilder
    as shown in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`Turret Game`中，转到本书内容的`Assets`文件夹，并将`Images`文件夹拖到SpriteBuilder左侧的资源列表中，如下截图所示：
- en: '![Starting a new Swift project](img/image00308.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![开始一个新的Swift项目](img/image00308.jpeg)'
- en: After it has been imported to SpriteBuilder, right-click (or press *Ctrl* and
    click) on the `Images` folder in SpriteBuilder, and select **Make Smart Sprite
    Sheet**. This is what TexturePacker normally does for us. However, we can speed
    up the process using SpriteBuilder's auto sheet maker, since this is only going
    to be an example project.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在将其导入到SpriteBuilder后，在SpriteBuilder中的`Images`文件夹上右键单击（或按*Ctrl*并单击），然后选择**制作智能精灵图集**。这是TexturePacker通常为我们做的事情。然而，我们可以使用SpriteBuilder的自动图集制作器来加快这个过程，因为这个项目只是一个示例。
- en: '![Starting a new Swift project](img/image00309.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![开始一个新的Swift项目](img/image00309.jpeg)'
- en: Once it has turned into a sprite sheet, the folder icon should be of a pinkish
    color with a smiley on it. Now, go to **File** | **Publish** so that SpriteBuilder
    can generate the necessary files for our project and we can be on our way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它变成了精灵图集，文件夹图标应该是带有微笑的粉红色。现在，转到**文件** | **发布**，以便SpriteBuilder可以为我们生成所需的项目文件，我们就可以继续了。
- en: Adding the font files
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加字体文件
- en: Unfortunately, SpriteBuilder is lame at the time of writing this book and doesn't
    handle BMFonts very well. So, what we're going to do instead of having SpriteBuilder
    handle the sizing/exporting is create our own BMFont and manually add it to our
    list of files. This might not be the most efficient way, but it works, so we're
    going with it.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，截至本书编写时，SpriteBuilder的表现不佳，并且不太擅长处理BMFonts。因此，我们不会让SpriteBuilder处理尺寸/导出，而是创建我们自己的BMFont并将其手动添加到我们的文件列表中。这可能不是最有效的方法，但它有效，所以我们就这样做了。
- en: In this book's project folder, you should see a list of folders such as `resources-hd`
    and so on next to the `Images` folder you dragged into SpriteBuilder. Copy all
    four of these folders and paste them in the iOS `Resources` folder of your project
    files. When it asks you, make sure you click on **Merge** (as well as **Apply
    to All**).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的项目文件夹中，你应该在拖入 SpriteBuilder 的 `Images` 文件夹旁边看到一系列文件夹，如 `resources-hd` 等。将这四个文件夹全部复制并粘贴到你的项目文件的
    iOS `Resources` 文件夹中。当它询问你时，确保你点击 **Merge**（以及 **Apply to All**）。
- en: '![Adding the font files](img/image00310.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![添加字体文件](img/image00310.jpeg)'
- en: This will add the font files for each size type to the respective folder so
    that Cocos2d's directory search mode can find the correct size based on the device.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为每种尺寸类型添加字体文件到相应的文件夹，以便 Cocos2d 的目录搜索模式可以根据设备找到正确的尺寸。
- en: Importing Bridging-Header and loading MainScene
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导入 Bridging-Header 和加载 MainScene
- en: Objective-C, when working with Swift files, needs something called a `Bridging-Header`
    file. It's automatically created, so all we have to do is import the file. The
    format of the file is `ProjectName-Swift.h`, where `ProjectName` is the name of
    your project (for example, if the project is called `TurretGame`, we'll use `TurretGame-Swift.h`).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Objective-C 与 Swift 文件一起工作时，Objective-C 需要 一个名为 `Bridging-Header` 的文件。这个文件会自动创建，所以我们只需要导入这个文件。文件的格式是
    `ProjectName-Swift.h`，其中 `ProjectName` 是你的项目名称（例如，如果项目名为 `TurretGame`，我们将使用 `TurretGame-Swift.h`）。
- en: 'Now, feel free to open the Xcode project. Open `AppDelegate.m` and, at the
    top of the file, add the import statement to add the `Bridging-Header` file:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，请随意打开 Xcode 项目。打开 `AppDelegate.m` 文件，并在文件顶部添加导入语句以添加 `Bridging-Header` 文件：
- en: '[PRE2]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, in the `StartScene` method, we need to change the line of code that will
    transition to the main scene (as well as add a line that will read in our images
    sheet):'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `StartScene` 方法中，我们需要更改将过渡到主场景的代码行（以及添加读取我们的图像表的代码行）：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: We're using `node` here instead of `Scene` because we're calling a `Swift` class.
    In the previous examples in this book, the `Scene` method was a method we created,
    whereas `node` is a predefined function that does the same thing.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里使用 `node` 而不是 `Scene`，因为我们正在调用一个 `Swift` 类。在这本书的前几个例子中，`Scene` 方法是我们创建的方法，而
    `node` 是一个预定义的函数，它执行相同的功能。
- en: Creating the background, turret, and score label
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建背景、炮塔和得分标签
- en: 'Because Swift is intended to be short and to the point when it comes to readability,
    the following code is all that is required in the `MainScene.swift` file in order
    to get a white background, an image to display, and a label at the bottom of the
    screen (note the `CCScene` inheritance; the default is `CCNode`):'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 Swift 旨在在可读性方面简洁明了，所以在 `MainScene.swift` 文件中，以下代码就足以获得白色背景、要显示的图像和屏幕底部的标签（注意
    `CCScene` 继承；默认是 `CCNode`）：
- en: '[PRE4]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Run the project at this point, and you'll see exactly what we described as our
    result. If you're starting to appreciate how little code it takes to make stuff
    happen, then Swift just might be your language to learn.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行项目，你将看到我们描述的结果。如果你开始欣赏编写代码实现功能所需代码的简洁性，那么 Swift 可能正是你想要学习的语言。
- en: Now let's move on to getting the turret to rotate.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续让炮塔旋转。
- en: Rotating the turret with touchMoved
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 touchMoved 旋转炮塔
- en: Notice so far how just about all the classes and methods are named exactly the
    same, with minor syntax differences between Objective-C and Swift. It's going
    to be the same for our `touchBegan`, `touchMoved`, and `touchEnded` methods.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到目前为止，几乎所有类和方法都命名得非常相似，Objective-C 和 Swift 之间的语法差异很小。我们的 `touchBegan`、`touchMoved`
    和 `touchEnded` 方法也将如此。
- en: 'First, we need to add a variable to store the player''s touch position. So,
    at the top of `MainScene`, add the following variable:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要添加一个变量来存储玩家的触摸位置。因此，在 `MainScene` 的顶部添加以下变量：
- en: '[PRE5]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, in the `init()` method, set the user interaction Boolean to `true`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `init()` 方法中，将用户交互布尔值设置为 `true`：
- en: '[PRE6]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, add the following methods to `MainScene`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下方法添加到 `MainScene` 中：
- en: '[PRE7]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you run the game, you'll be able to drag your finger around and rotate the
    turret in the direction of your finger.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行游戏，你将能够用手指拖动并使炮塔按照手指的方向旋转。
- en: Shooting some bullets
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 射击一些子弹
- en: Ours is not a very useful turret unless it's shooting bullets, so let's write
    that code.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果炮塔不射击子弹，那么它就没什么用了，所以让我们编写那段代码。
- en: 'First, we want a method we can call (or schedule). We want to make it spawn
    a bullet and then launch it in the direction of our finger (where the turret is
    pointing). So go ahead and add the following method:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们想要一个可以调用（或安排）的方法。我们想要让它生成一个子弹，然后将其发射到我们的手指方向（炮塔所指的方向）。所以，请继续添加以下方法：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Although we now have this function that will create a bullet and launch it
    along a path, we have no way of testing it yet. So, in our `touchBegan` method,
    we add a call to schedule the selector:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有一个创建子弹并沿着路径发射它的函数，但我们还没有办法测试它。所以，在我们的`touchBegan`方法中，我们添加了对安排选择器的调用：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, in our `touchEnded` method, we add a call to `unschedule` the selector
    (as we don''t want the turret to shoot constantly):'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在我们的`touchEnded`方法中，我们添加了对`unschedule`选择器的调用（因为我们不希望炮塔持续射击）：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If you're wondering why the selector is in quotes, let me tell you that that's
    just the syntax of Swift. Instead of explicitly stating the function, you have
    to pass the function name as a string, and Swift handles the rest.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道为什么选择器被引号包围，让我告诉你，那只是Swift的语法。你不需要明确地声明函数，你只需要将函数名作为字符串传递，Swift会处理其余的部分。
- en: If you run the game at this point, you'll watch those bullets go rocketing out
    of the turret when you drag your finger across the screen.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在这个时候运行游戏，你会看到当你的手指在屏幕上滑动时，那些子弹会从炮塔中火箭般射出。
- en: Spawning enemies and sending them towards the center
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 生成敌人并将它们发送到中心
- en: 'We want some enemies to shoot at, so let''s create a method that will spawn
    an enemy along either the left or right wall, and send it to the center of the
    screen (where the turret is), over a period of 3 seconds:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要一些敌人来射击，所以让我们创建一个方法，它将在左墙或右墙上生成一个敌人，并在3秒内将其发送到屏幕中心（炮塔所在的位置）：
- en: '[PRE11]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: It's great that we have a method to spawn enemies, but there are none currently
    spawning. So, just like the `shootBullet` function we scheduled, we must schedule
    the `spawnEnemy` function.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个生成敌人的方法真是太好了，但目前还没有生成。所以，就像我们安排的`shootBullet`函数一样，我们必须安排`spawnEnemy`函数。
- en: 'In the `init()` method, add the following line of code to spawn the enemies:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init()`方法中，添加以下代码行来生成敌人：
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There we go! Now we have our enemies spawning. But even if they make it to their
    final position, nothing happens. Let's fix that.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 好的！现在我们有了敌人的生成。但是即使它们到达了最终位置，也没有发生任何事情。让我们来修复这个问题。
- en: Transitioning to GameOver
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡到GameOver
- en: When an enemy gets near the center (after the action completes), we want our
    game to be over, so let's create a `GameOverScene` class, and transition to it
    when an enemy reaches their end position.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当敌人接近中心（动作完成后），我们希望游戏结束，所以让我们创建一个`GameOverScene`类，并在敌人达到他们的最终位置时过渡到它。
- en: First, create a new file by hitting *Command* + *N* (or **File** | **New** |
    **File**). Select **Cocoa Touch Class** by navigating to **iOS** | **Source**.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过按*Command* + *N*（或**文件** | **新建** | **文件**）创建一个新文件。通过导航到**iOS** | **源**选择**Cocoa
    Touch Class**。
- en: '![Transitioning to GameOver](img/image00311.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![过渡到GameOver](img/image00311.jpeg)'
- en: Then name it `GameOverScene`, and make sure you choose **Swift** as the language.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将其命名为`GameOverScene`，并确保你选择**Swift**作为语言。
- en: '![Transitioning to GameOver](img/image00312.jpeg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![过渡到GameOver](img/image00312.jpeg)'
- en: Save it in the `Source` folder of your project, and it will automatically open
    up.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 将其保存在项目的`Source`文件夹中，它将自动打开。
- en: 'Replace your `GameOverScene` class with the following, which will set the background
    to white, create a label in the center of the screen, enable touches, and transition
    back to `MainScene` when the screen is tapped:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 用以下内容替换你的`GameOverScene`类，这将设置背景为白色，在屏幕中心创建一个标签，启用触摸，并在屏幕被点击时返回到`MainScene`：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, to test this scene, add the following `replaceScene` call to the closure
    (or code block) of the enemy''s move action in `MainScene.swift`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，为了测试这个场景，将以下`replaceScene`调用添加到`MainScene.swift`中敌人的移动动作的闭包（或代码块）中：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Hmmm! Except now that it transitions properly, it's not much of a game, since
    we can't stop the enemies with the bullets we're shooting. Let's fix that!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯！但是，现在虽然它正确地过渡了，但这不是一个很好的游戏，因为我们不能用我们射击的子弹阻止敌人。让我们来修复这个问题！
- en: Handling collisions
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理碰撞
- en: There's a ton of different ways to handle collisions, but the way we're going
    to handle them is by using the bounding box of our bullets and the enemies. To
    do that, we're going to set up two arrays (one for enemies and one for bullets)
    and a function to loop through the arrays and check for bounding box intersections.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 处理碰撞的方法有很多种，但我们将通过使用子弹和敌人的边界框来处理它们。为此，我们将设置两个数组（一个用于敌人，一个用于子弹）和一个函数来遍历数组并检查边界框交叉。
- en: 'First, we add two variables for the arrays. We''re going to use `NSMutableArray`
    instead of Swift''s arrays because Swift''s array allows us to remove an item
    only via its index, and not by passing the item itself. So, it will be easier
    with `NSMutableArray`:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为数组添加两个变量。我们将使用`NSMutableArray`而不是Swift的数组，因为Swift的数组只允许我们通过索引移除项，而不是通过传递项本身。因此，使用`NSMutableArray`将更容易：
- en: '[PRE15]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now we need to add our bullets and enemies to their respective array (as well
    as handle their removal from the array). So, in our `shootBullet` and `spawnEnemy`
    functions, we add the objects to the array, as well as remove the bullet from
    the array right before we remove it from the scene:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要将我们的子弹和敌人添加到它们各自的数组中（以及处理它们从数组中移除）。因此，在我们的`shootBullet`和`spawnEnemy`函数中，我们将对象添加到数组中，并在从场景中移除子弹之前将其从数组中移除：
- en: '[PRE16]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Next, we need to create a function that will loop through our arrays and check
    for collisions. If a collision is found, we will remove both objects from the
    arrays (and the screen) and break out of the loop so that we don't accidentally
    go out of bounds.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个函数，该函数将遍历我们的数组并检查碰撞。如果发现碰撞，我们将从数组（以及屏幕）中移除两个对象，并退出循环，以防止意外越界。
- en: 'Create the following function in the `MainScene.swift` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainScene.swift`文件中创建以下函数：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we need to schedule this function so that it will be called frequently
    enough when our bullets interact with the enemies, and the collision will get
    detected at the right time. To do that, simply schedule it in the `init()` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要安排这个函数，以便在子弹与敌人交互时频繁调用，并且能够在正确的时间检测到碰撞。为此，只需在`init()`函数中安排它即可：
- en: '[PRE18]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the game at this point, and you'll see the bullets colliding properly. But
    no! It's not much of a game without a score counter. So let's add that to this
    example game in Swift.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行游戏，你会看到子弹正确地发生碰撞。但是，没有分数计数器的话，这并不是一个真正的游戏。所以让我们把这个分数计数器添加到这个Swift示例游戏中。
- en: Counting the score
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算分数
- en: All we need is a variable that tracks our score and a label to display it. Arguably,
    you can also have this on the game over scene, but we're not going to worry about
    that in this example.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需要一个跟踪分数的变量和一个显示标签。可以说，你也可以在游戏结束场景中这样做，但在这个示例中我们不会担心这一点。
- en: 'So, at the top of our `MainScene` class, we create two variables as described,
    and then add the label to the screen in the `init()` method:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`MainScene`类的顶部，我们创建两个变量，如描述所述，然后在`init()`方法中将标签添加到屏幕上：
- en: '[PRE19]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then we implement the `update` function, which gets automatically called by
    Cocos2d:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们实现`update`函数，该函数由Cocos2d自动调用：
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We also want to increase the score by `100` for every enemy that dies, so in
    the `checkForCollisions` function, we simply add `100` to the score variable:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还希望每消灭一个敌人就增加`100`分，所以在`checkForCollisions`函数中，我们只需将`100`加到分数变量上：
- en: '[PRE21]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If you run the game at this point, you'll see the score increasing as time goes
    on, as well as when any enemy gets hit by a bullet. The only thing left to do
    is make the game harder over time (because it's rather boring at the moment).
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会看到随着时间的推移分数增加，以及当任何敌人被子弹击中时。唯一剩下要做的事情是随着时间的推移使游戏更难（因为目前来说相当无聊）。
- en: Increasing the difficulty
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高难度
- en: 'Finally (although it doesn''t entirely matter for the purpose of making the
    example work), we want our difficulty to increase over time so that only the best
    players can make it far. We''re going to do this by increasing the rate at which
    units spawn (every 2,000 points, to be exact). First, we want some variables to
    hold the current spawn rate as well as the amount of points accrued since the
    last increase in difficulty:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后（尽管对于使示例工作并不完全重要），我们希望难度随时间增加，这样只有最好的玩家才能走得更远。我们将通过增加单位生成的速率（确切地说，每2,000分）来实现这一点。首先，我们想要一些变量来保存当前的生成速率以及自上次难度增加以来累积的点数：
- en: '[PRE22]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, we must replace the hardcoded value of `0.35` with the `spawnRate` variable:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须将硬编码的`0.35`值替换为`spawnRate`变量：
- en: '[PRE23]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, every time we increase our `score` variable, we must also increase the
    `scoreSinceLastIncrease` variable. So in `update` as well as `checkForCollisions`,
    we need to add the same amount to both the variables:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，每次我们增加`score`变量时，也必须增加`scoreSinceLastIncrease`变量。因此，在`update`和`checkForCollisions`中，我们需要给这两个变量都加上相同的数值：
- en: '[PRE24]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Finally, we need to check inside our update: method whether the score since
    the last difficulty increase has crossed our limit (in this case, we''re going
    to increase it after every 2,000 points earned). To do this, we''ll just `unschedule`
    the `spawnEnemy` function, reduce `spawnRate` (only to a certain amount), and
    `re-schedule` the `spawnEnemy` function:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的`update`方法内部检查，自上次难度增加以来的分数是否已经超过了我们的限制（在这种情况下，我们将在每获得2,000分后增加）。为此，我们只需取消`spawnEnemy`函数的调度，减少`spawnRate`（只减少到一定量），然后重新调度`spawnEnemy`函数：
- en: '[PRE25]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the game at this point and watch as more and more units come flooding into
    the view, eventually overwhelming you.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段运行游戏，并观察越来越多的单位涌入视图，最终会压倒你。
- en: And that's it! We've just made a very simple game in Cocos2d but with the help
    of Swift this time. It's not the best or most fun game in the world but it counts.
    Plus, this example was more of a way to show you how to go ahead and make games
    using Swift as your core language instead of Objective-C.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们刚刚用Cocos2d制作了一个非常简单的游戏，但这次有了Swift的帮助。这并不是世界上最好或最有意思的游戏，但它是有意义的。此外，这个例子更多的是展示如何使用Swift作为核心语言而不是Objective-C来制作游戏。
- en: Summary
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to make use of playgrounds and create a basic
    game using Cocos2d and Swift.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用playgrounds，并使用Cocos2d和Swift创建一个基本游戏。
- en: As mentioned earlier, if you wish to learn more about Swift, there's a plethora
    of available online resources at your disposal—online courses, Apple-created content,
    as well as online communities that provide assistance as needed.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，如果你想要了解更多关于Swift的信息，有许多在线资源可供你使用——在线课程、苹果公司创建的内容，以及提供所需帮助的在线社区。
- en: Happy coding!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 开心编码！
