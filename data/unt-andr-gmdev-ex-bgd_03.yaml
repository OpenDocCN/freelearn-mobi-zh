- en: Chapter 3. The Backbone of Any Game – Meshes, Materials, and Animations
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章。任何游戏的骨架——网格、材质和动画
- en: '*In the previous chapter we learned about the GUI. We started by creating a
    simple Tic-tac-toe game to learn about the basic pieces. This was followed by
    styling the GUI to change the look of the game. Finally, we adjusted the game
    so it would expand automatically to fit a screen of any size.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了关于GUI的内容。我们从一个简单的井字棋游戏开始，以了解基本元素。然后，我们对GUI进行样式化以改变游戏的外观。最后，我们调整了游戏，使其能够自动扩展以适应任何大小的屏幕。*'
- en: '*This chapter is about the core of any game: meshes, materials, and animations.
    Without these blocks there is generally nothing to show players. You could, of
    course, just use flat images in the GUI. But, where is the fun in that? If you
    are going to choose a 3D game engine, you might as well make full use of its capabilities.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*本章是关于任何游戏的核心：网格、材质和动画。没有这些模块，通常没有什么可以展示给玩家。当然，你可以在GUI中使用平面图像。但那样有什么乐趣呢？如果你要选择一个3D游戏引擎，你最好充分利用其功能。*'
- en: '*To understand meshes, materials, and animations, we will be creating a Tank
    Battle game. This project will be used in a few other chapters. By the end of
    the book, it will be one of the two robust games we will create. For this chapter,
    the player will get to drive a tank around a small city, he/she will be able to
    shoot at animated targets, and we will add a counter to track the scores.*'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '*为了理解网格、材质和动画，我们将创建一个坦克战斗游戏。这个项目将在其他几个章节中使用。到本书结束时，它将是我们将创建的两个健壮游戏之一。对于本章，玩家将能够驾驶坦克在小型城市中行驶，他/她将能够射击动画目标，我们还将添加一个计数器来跟踪分数。*'
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了以下主题：
- en: Importing the meshes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入网格
- en: Creating the materials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建材料
- en: Animations
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动画
- en: Creating the prefabs
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建预制体
- en: Ray tracing
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线追踪
- en: We will be starting a new project for this chapter, so follow along in the first
    section to get it started.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为本章开始一个新的项目，所以请按照第一部分的内容进行操作。
- en: Setting up
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置
- en: Though this project will eventually grow to become much larger than the previous
    ones, the actual setup is similar and not overly complex. You will also need a
    number of starting assets for this project; they will be described during the
    setup process. Due to the complexity and specific nature of these assets, it is
    recommended to use the ones provided for now.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个项目最终会变得比之前的更大，但实际的设置是相似的，并不过于复杂。你还需要为这个项目准备一些起始资产；它们将在设置过程中进行描述。由于这些资产的复杂性和特定性质，建议现在使用提供的那些。
- en: Time for action – the setup
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间——设置
- en: As we have done in the previous two chapters, we will need to create a new project
    so that we can create our next game. Obviously, the first thing to do is to start
    a new Unity project. For organizational purposes, name it `Ch3_TankBattle_CS`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在前两章中所做的那样，我们需要创建一个新的项目，这样我们才能创建我们的下一个游戏。显然，首先要做的事情是启动一个新的Unity项目。为了组织目的，将其命名为`Ch3_TankBattle_CS`。
- en: This project will also grow to become much larger than our previous projects,
    so we should create some folders to keep things organized. For starters, create
    six folders. The top level folders will be the `Models`, `Scripts`, and `Prefabs`
    folders. Inside `Models`, create `Environment`, `Tanks`, and `Targets`. Having
    these folders makes the project significantly more manageable. Any complete model
    can consist of a mesh file, one or more textures, a material for every texture,
    and potentially dozens of animation files.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个项目也将变得比我们之前的项目更大，所以我们应该创建一些文件夹以保持组织有序。首先，创建六个文件夹。顶级文件夹将是`Models`、`Scripts`和`Prefabs`文件夹。在`Models`内部创建`Environment`、`Tanks`和`Targets`。拥有这些文件夹可以使项目显著更容易管理。任何完整的模型都可以由一个网格文件、一个或多个纹理、每个纹理的材质以及可能成百上千的动画文件组成。
- en: Before we go too far, it is a good idea to change your target platform to Android,
    if you haven't already done so. Every time the target platform is changed, all
    of the assets in the project need to be re-imported. This is an automatic step
    carried out by Unity, but will take an increasing amount of time as your project
    grows. By setting our target platform before there is anything in the project,
    we save loads of time later.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们走得太远之前，如果你还没有这样做，将你的目标平台更改为Android是一个好主意。每次更改目标平台时，项目中的所有资产都需要重新导入。这是Unity自动执行的一个步骤，但随着项目的增长，所需的时间会越来越多。在我们项目没有任何内容之前设置目标平台，我们可以在以后节省大量时间。
- en: We will also make use of a very powerful part of Unity. Prefabs are special
    objects that make the process of creating a game significantly easier. The name
    means prefabricated—created beforehand and replicated. What this means for us
    is, we can completely set up a target for our tank to shoot at and turn it into
    a prefab. Then, we can place instances of that prefab throughout the game world.
    If we ever need to make a change to the targets, all we need to do is modify the
    original prefab. Any change made to a prefab is also made on any instance of that
    prefab. Don't worry; it makes more sense when used.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还将利用Unity的一个非常强大的部分。预制件是特殊对象，可以显著简化创建游戏的过程。这个名字的意思是预制件——事先创建并复制的。对我们来说，这意味着我们可以完全设置一个坦克射击的目标，并将其转换为预制件。然后，我们可以在游戏世界中放置该预制件的实例。如果我们需要更改目标，我们只需修改原始预制件即可。对预制件所做的任何更改也会应用到该预制件的任何实例上。不用担心；使用时会更合理。
- en: We will also need to create some meshes and textures for this project. To start
    with, we will need a tank. It is kind of hard to have a battle of tanks without
    any tanks. The tank that is provided has a turret and cannon, which are separate
    pieces. We will also use a trick to make the tank's treads look like they are
    moving, so that each of them are separate pieces and also use a separate texture.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为这个项目创建一些网格和纹理。首先，我们需要一个坦克。没有坦克的坦克战似乎有点困难。提供的坦克有一个炮塔和大炮，它们是独立的部件。我们还将使用一个技巧使坦克的履带看起来像在移动，这样每个履带都是独立的部件，并且使用单独的纹理。
- en: For the location of our battle, a portion of a city was created. Instead of
    applying a specific texture to the city, some tile-able textures will be used.
    Also, there is a wall around the city to keep the player from falling out of the
    world.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的战场位置，创建了一个城市的一部分。我们不会为城市应用特定的纹理，而是使用可平铺的纹理。此外，城市周围有一堵墙，以防止玩家掉出世界。
- en: Finally, we will need an animated target. The one that is provided is rigged
    up like the human arm, with a bull's eye for the hand. It has four animations.
    The first starts in a curled position and goes to an extended position. The second
    is the reverse of the first one, going from the extended position to the curled
    position. The third starts in the extended position and is flung back, as if hit
    in the front, and returns to the curled position. The last is just like the third
    one, but it goes forward as if hit from behind. These are fairly simple animations,
    but they will serve us well in learning about Unity's animation system.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要一个动画目标。提供的这个目标像人的手臂一样装上了，手部有一个靶心。它有四个动画。第一个从蜷缩位置开始，延伸到伸展位置。第二个是第一个的相反，从伸展位置到蜷缩位置。第三个从伸展位置开始，被猛地甩回，好像被正面击中，然后回到蜷缩位置。最后一个和第三个一样，但它向前移动，好像被从后面击中。这些动画相当简单，但它们将很好地帮助我们了解Unity的动画系统。
- en: '*What just happened?*'
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Very little happened here, we simply created the project and added some folders.
    There was also a little discussion about the assets we would be using for this
    chapter's project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这里发生的事情非常少，我们只是创建了项目并添加了一些文件夹。还讨论了我们将在本章的项目中使用的资产。
- en: Importing the meshes
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 导入网格
- en: There are several ways to import assets to Unity. We will be going over perhaps
    the simplest and certainly the best ways for groups of assets.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 将资产导入Unity有多种方法。我们将介绍可能最简单且肯定是最适合资产组的方法。
- en: Time for action – importing the tank
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 导入坦克
- en: Let's get started.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: Inside the Unity Editor, start by right-clicking on your `Tanks` folder and
    selecting **Show in Explorer** from the menu.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器中，首先右键单击你的`Tanks`文件夹，从菜单中选择**在资源管理器中显示**。
- en: This opens the folder that contains the asset that was selected. In this case,
    the `Models` folder is opened in the Windows folder browser. We just need to put
    our tank and its textures into the `Tanks` folder.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开包含所选资产的文件夹。在这种情况下，Windows文件夹浏览器中打开了`Models`文件夹。我们只需将我们的坦克及其纹理放入`Tanks`文件夹中。
- en: Tip
  id: totrans-29
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The files provided for this chapter are `Tank.blend`, `Tanks_Type01.png`, and
    `TankTread.png` files. Also, utilizing `.blend` files in Unity requires Blender
    to be installed on your system. Blender is a free modeling program available at
    [http://www.blender.org](http://www.blender.org). Unity makes use of it in order
    to convert the previously mentioned files into ones that it can fully utilize.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为本章提供的文件是`Tank.blend`、`Tanks_Type01.png`和`TankTread.png`文件。此外，在Unity中使用`.blend`文件需要在你的系统上安装Blender。Blender是一个免费建模程序，可在[http://www.blender.org](http://www.blender.org)找到。Unity利用它将之前提到的文件转换为它能够完全利用的文件。
- en: When we return to Unity, the fact that we added files will be detected and they
    will be automatically imported. This is one of the best things about Unity. There
    is no need to explicitly tell Unity to import. If there are changes within the
    project's assets, it just does so.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们返回Unity时，我们添加的文件将被检测到，并且它们将被自动导入。这是Unity的最好之处之一。无需明确告诉Unity导入。如果项目资产中有所更改，它就会自动这样做。
- en: You might also notice that an extra folder and some files were created when
    Unity imported our tank. Whenever a new mesh is imported, by default Unity will
    try to pair it with the materials. We will go into more detail about what a material
    is in Unity in the next section. For now, it is an object that keeps track of
    how to display a texture on a mesh. Based on the information in the mesh, Unity
    looks in the project for a material with the correct name. If one cannot be found,
    a `Materials` folder is created next to the mesh and the missing materials are
    created inside it. When creating these materials, Unity also searches for the
    right textures. This is why it is important to add textures to the folder at the
    same time as the mesh, so that they all can be imported together. If you did not
    add the textures at the same time as the tank, the section about creating materials
    will describe how to add textures to materials.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还会注意到，当Unity导入我们的坦克时，创建了一个额外的文件夹和一些文件。每当导入一个新的网格时，默认情况下Unity都会尝试将其与材质配对。我们将在下一节中更详细地介绍Unity中的材质是什么。现在，它是一个跟踪如何在网格上显示纹理的对象。根据网格中的信息，Unity会在项目中查找具有正确名称的材质。如果找不到，将在网格旁边创建一个`Materials`文件夹，并在其中创建缺失的材质。在创建这些材质时，Unity也会搜索正确的纹理。这就是为什么在将网格添加到文件夹的同时添加纹理很重要，这样它们就可以一起导入。如果你没有在添加坦克的同时添加纹理，关于创建材质的部分将描述如何将纹理添加到材质中。
- en: '*What just happened?*'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just imported our tank into Unity. It is really quite simple. Changes made
    to any of the assets or folders of the project are automatically detected by Unity,
    and anything that needs to be is suitably imported.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将坦克导入Unity。这实际上非常简单。对项目中的任何资产或文件夹所做的更改都会被Unity自动检测，并且需要导入的内容都会被适当地导入。
- en: Tank import settings
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坦克导入设置
- en: When importing any asset into Unity, it is done by using a default group of
    settings. Any of these settings can be changed from the **Inspector** window.
    With your new tank selected, we will go over the import settings for a model here.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当将任何资产导入Unity时，都是通过使用一组默认设置来完成的。这些设置中的任何一个都可以从**检查器**窗口中更改。选择你的新坦克，我们将在这里介绍模型的导入设置。
- en: '![Tank import settings](img/2014OT_03_01.png.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![坦克导入设置](img/2014OT_03_01.png.jpg)'
- en: 'The top of the Unity Editor has three tabs: **Model**, **Rig**, and **Animations**.
    The **Model** page handles the mesh itself, while **Rig** and **Animations** are
    for importing animations. For now, we only care about the **Model** page, so select
    it if it is not already selected.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity编辑器的顶部有三个标签页：**模型**、**绑定**和**动画**。**模型**页面处理网格本身，而**绑定**和**动画**用于导入动画。目前，我们只关心**模型**页面，所以如果尚未选择，请选择它。
- en: The **Meshes** section of the **Import Settings** window starts with the **Scale
    Factor** attribute. This is a value that tells Unity how big the mesh is by default.
    One generic unit or one meter from your modeling program translates to one unit
    in Unity. This tank was made in generic units, so the tank's scale factor is one.
    If you were working in centimeters when making the tank, the scale factor would
    be 0.01, because a centimeter is a hundredth of a meter.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导入设置**窗口的**网格**部分从**缩放因子**属性开始。这是一个告诉Unity默认网格大小的值。从你的建模程序中，一个通用单位或一米的长度在Unity中对应一个单位。这个坦克是用通用单位制作的，所以坦克的缩放因子是1。如果你在制作坦克时使用的是厘米，缩放因子将是0.01，因为一厘米是米的百分之一。'
- en: The next option, **Mesh Compression**, will become important in the final chapter
    when we go over the optimization of our games. The higher the compression is set,
    the smaller the file is in the game. However, this will start to introduce weirdness
    to your mesh as Unity works to make it smaller. For now, leave it **Off**.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个选项，**网格压缩**，在最后章节中当我们讨论游戏优化时将变得重要。压缩设置得越高，游戏中的文件越小。然而，这可能会开始给您的网格引入一些奇怪的现象，因为Unity正在努力使其变小。目前，请将其保持**关闭**。
- en: '**Read/Write Enabled** is useful if you want to make changes to the mesh while
    the game is playing. This could allow you to do some really cool things such as
    destructible environments where your scripts break the meshes into pieces based
    on where they are being shot at. However, it also means that Unity has to keep
    a copy of the mesh in memory, which could really start to lag a system if it is
    complex. This is outside the scope of this book, so unchecking the option is a
    good idea.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写启用**如果您想在游戏运行时对网格进行更改，则非常有用。这可能允许您做一些非常酷的事情，例如可破坏的环境，其中您的脚本根据被射击的位置将网格分解成碎片。然而，这也意味着Unity需要在内存中保留网格的副本，如果它很复杂，这可能会真的开始拖慢系统。这超出了本书的范围，所以取消勾选此选项是个好主意。'
- en: '**Optimize Mesh** is a good one to leave on, unless you are doing something
    specific and fancy with the mesh. With it on, Unity does some special magic behind
    the scenes. In computer graphics and especially Unity, every mesh is ultimately
    a series of triangles being drawn on screen. This option allows Unity to reorder
    the triangles in the file so that the whole mesh will be drawn faster and more
    easily.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格**是一个很好的选项，除非您正在对网格进行某些特定且复杂的工作。开启此选项，Unity会在幕后进行一些特殊的操作。在计算机图形学，尤其是Unity中，每个网格最终都是一系列在屏幕上绘制的三角形。此选项允许Unity重新排列文件中的三角形，以便整个网格可以更快、更轻松地绘制。'
- en: The next option, **Generate Colliders**, is a useful one if doing complex things
    with **Physics**. Unity has a set of simple collider shapes that should be used
    whenever possible, because they are easier to process. However, there are situations
    where they won't quite get the job done, for example, rubble or a half-pipe where
    the collision shape is too complex to be made with a series of simple shapes.
    That is why Unity has a **Mesh Collider** component. With this option checked,
    a **Mesh Collider** component is added to every mesh in our model. We will be
    sticking with simple colliders in this chapter, so leave the **Generate Colliders**
    option off.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个选项，**生成碰撞器**，如果进行复杂的物理操作时非常有用。Unity有一组简单的碰撞器形状，应尽可能使用，因为它们更容易处理。然而，在某些情况下，它们可能无法完成工作，例如，对于由一系列简单形状难以构成的复杂碰撞形状，如碎石或半管道。这就是为什么Unity有一个**网格碰撞器**组件。勾选此选项后，每个模型中的网格都会添加一个**网格碰撞器**组件。在本章中，我们将坚持使用简单的碰撞器，所以请保持**生成碰撞器**选项关闭。
- en: '**Swap UVs** and **Generate Lightmap UVs** are primarily used when working
    with lighting, especially lightmaps. Unity can handle two sets of UV coordinates
    on a model. Normally, the first is used for the texture and the second for the
    lightmap or shadow texture. If they are in the wrong order, **Swap UVs** will
    change them, so that the second set now comes first. If you need an unwrap for
    a lightmap, but did not create one, **Generate Lightmap UVs** will create one
    for you. We are not working with lightmaps in this project, so both of these can
    remain off.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交换UV**和**生成光照贴图UV**主要用于处理光照，尤其是光照贴图。Unity可以处理模型上的两组UV坐标。通常，第一组用于纹理，第二组用于光照贴图或阴影纹理。如果顺序错误，**交换UV**将会调整它们，使得第二组现在排在第一位。如果您需要一个光照贴图的展开图，但尚未创建，**生成光照贴图UV**将为您创建一个。在这个项目中，我们不使用光照贴图，所以这两个选项都可以保持关闭。'
- en: The next section of options, **Normals & Tangents**, begins with the **Normals**
    option. This defines how Unity will get a hold of the normals of your mesh. By
    default, they are imported from the file; but there is also the option to make
    Unity calculate them based on the way the mesh is defined. Or, if we set this
    option to **None**, Unity will not import the normals. **Normals** are needed
    if we want our mesh to be affected by real-time lighting or make use of normal
    maps. We will be making use of real-time lighting in this project, so leave it
    set to **Import**.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一部分选项，**法线与切线**，从**法线**选项开始。这定义了Unity将如何获取网格的法线。默认情况下，它们是从文件中导入的；但也可以选择让Unity根据网格的定义方式计算它们。或者，如果我们将此选项设置为**无**，Unity将不会导入法线。如果我们希望网格受到实时光照的影响或使用法线贴图，则需要**法线**。我们将在本项目中使用实时光照，所以请将其设置为**导入**。
- en: '**Tangents**, **Smoothing Angle**, and **Split Tangents** are used if your
    mesh has a normal map. Tangents are needed to determine how lighting interacts
    with a normal-mapped surface. By default, Unity will calculate these for you.
    Importing tangents is only possible from a few file types. The smoothing angle
    dictates whether shading across an edge would be smooth or sharp, based on the
    angle between the two faces. The **Split Tangents** option is there to handle
    a few specific lighting quirks. If lighting is broken by seams, enabling this
    option will fix it. Normal maps are great for making a low-resolution game look
    like a high-resolution one. However, because of all the extra files and information
    needed to use them, they are not ideal for a mobile game. Therefore, we will not
    be using them in this book and all of these options can be turned off to save
    memory.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切线**、**平滑角度**和**分割切线**在您的网格具有法线贴图时使用。切线用于确定光照如何与法线贴图表面交互。默认情况下，Unity 将为您计算这些值。仅从少数文件类型中可以导入切线。平滑角度决定了两个面之间的角度，从而决定了边缘的着色是平滑还是尖锐。**分割切线**选项用于处理一些特定的光照问题。如果光照被接缝破坏，启用此选项将修复它。法线贴图非常适合使低分辨率游戏看起来像高分辨率游戏。然而，由于使用它们需要额外的文件和信息，它们并不适合移动游戏。因此，我们在这本书中不会使用它们，并且可以关闭所有这些选项以节省内存。'
- en: The last section, **Materials**, defines how Unity should look for materials.
    The first option, **Import Materials**, is to decide whether or not a material
    should be imported. If it is turned off, a default white material will be applied.
    This material will not show up anywhere in your project; it is a hidden default.
    For models that will not have any textures, such as collision meshes, this could
    be turned off. For our tank and nearly every other case, this should be left on.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个部分，**材质**，定义了Unity应该如何查找材质。第一个选项，**导入材质**，是决定是否导入材质。如果关闭，将应用默认的白色材质。这个材质不会出现在您的项目中；它是一个隐藏的默认材质。对于没有纹理的模型，例如碰撞网格，可以关闭此选项。对于我们的坦克和几乎所有其他情况，应该保持开启状态。
- en: The last two options, **Material Naming** and **Material Search**, work together
    to name and find the materials for the mesh. Directly below them, there is a text
    box that describes how Unity will go about searching for the material. The name
    of the material being searched for can be the name of the texture used in the
    modeling program, the name of the material created in the modeling program, or
    the name of the model plus the material. If a texture name cannot be found, the
    material name will be used instead. By default, Unity does a **Recursive-Up**
    search. This means that we start by looking in the `Materials` folder, followed
    by any materials that are in the same folder. We then check the parent folder
    for matching materials, followed by the folder above that. This continues until
    we either find the material that has the correct name or we reach the root assets
    folder. Alternatively we have the options of checking the entire project by only
    looking in the `Materials` folder that is next to our model. The defaults for
    these options are just fine. In general, they do not need to be changed. They
    are most easily changed with the Unity Editor scripting, which will not be covered
    in this book.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后两个选项，**材质命名**和**材质搜索**，共同用于命名和查找网格的材质。直接位于它们下方有一个文本框，描述了Unity将如何搜索材质。正在搜索的材质名称可以是建模程序中使用的纹理名称，建模程序中创建的材质名称，或者模型名称加上材质名称。如果找不到纹理名称，将使用材质名称代替。默认情况下，Unity执行**递归向上**搜索。这意味着我们首先在`Materials`文件夹中查找，然后是同一文件夹中的任何材质。然后检查父文件夹中的匹配材质，接着是上一级文件夹。这个过程会一直持续，直到我们找到具有正确名称的材质或者达到根资产文件夹。或者，我们还可以选择只检查紧邻模型的`Materials`文件夹来检查整个项目。这些选项的默认设置就很好。一般来说，它们不需要更改。它们最容易通过Unity编辑器脚本进行更改，而这本书不会涉及。
- en: 'Next, we have a pair of buttons: **Revert** and **Apply**. Whenever changes
    are made to the import settings, one of these two buttons must be chosen. The
    **Revert** button cancels the changes and switches the import settings back to
    what they were before changes were made. **Apply** confirms the changes and re-imports
    the model with the new settings. If these buttons are not selected, Unity will
    complain with a pop up and force a choice before letting you mess with anything
    else.![Tank import settings](img/2014OT_03_02.png.jpg)'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，我们有一对按钮：**还原**和**应用**。每次修改导入设置时，必须选择这两个按钮之一。**还原**按钮取消更改，并将导入设置切换回更改之前的状态。**应用**按钮确认更改，并使用新设置重新导入模型。如果不选择这些按钮，Unity将通过弹出窗口抱怨，并强制你做出选择，然后才能进行其他操作。![坦克导入设置](img/2014OT_03_02.png.jpg)
- en: Finally, we have two types of previews. The **Imported Object** section is a
    preview of what the object will look like in the **Inspector** window, if added
    to the **Scene** view and selected. The **Preview** window is what the model will
    look like in the **Scene** view. You can click-and-drag in this window to rotate
    the object and look at it from different angles. Also, there is a little blue
    button in this window. By clicking on this button, you will be able to add labels
    to the object. Then, these labels are also searchable in the **Project** window.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有两种预览方式。**导入对象**部分是当对象被添加到**场景视图**并选中时，在**检查器**窗口中对象预览的样子。**预览**窗口显示了模型在**场景视图**中的样子。你可以在该窗口中点击并拖动来旋转对象，从不同的角度观察它。此外，在这个窗口中还有一个蓝色的按钮。点击这个按钮，你可以为对象添加标签。然后，这些标签也可以在**项目**窗口中搜索到。
- en: Setting up the tank
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置坦克
- en: Now that we have the tank imported, we need to set it up. We will be adjusting
    the arrangement of the tank as well as creating a few scripts.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经导入了坦克，我们需要对其进行设置。我们将调整坦克的排列，并创建一些脚本。
- en: Time for action – creating the tank
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建坦克
- en: At this point, the creation of our tank will primarily consist of the creation
    and arrangement of the tank's components.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们坦克的创建主要将包括创建和排列坦克的组件。
- en: Start by dragging the tank from the **Project** window to the **Hierarchy**
    window. You will notice that the name of the tank appears in blue color in the
    **Hierarchy** window. This is because it is a prefab instance. Any model in your
    project largely acts like a prefab. But, we want our tank to do more than just
    sit there. So, being a prefab of a static mesh is not helpful. Therefore, select
    your tank in the **Hierarchy** window and we will start making it useful by removing
    the `Animator` component. To do this, select the gear to the right of the `Animator`
    component in the **Inspector** window. From the new drop-down list, select **Remove
    Component** and it will be removed.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将坦克从**Project**窗口拖动到**Hierarchy**窗口。你会在**Hierarchy**窗口中注意到坦克的名字以蓝色显示。这是因为它是一个预制实例。你项目中的任何模型在很大程度上都像是一个预制实例。但是，我们希望我们的坦克能做更多的事情，而不仅仅是坐在这里。因此，作为一个静态网格的预制实例是没有帮助的。因此，在**Hierarchy**窗口中选择你的坦克，我们将通过移除`Animator`组件来开始使其变得有用。为此，在**Inspector**窗口中，选择`Animator`组件右侧的齿轮。从新的下拉列表中选择**移除组件**，它将被移除。
- en: If you are using the tank provided by default, selecting the different parts
    of it will reveal that all the pivot points are at the base. This will not be
    useful for making our turret and cannon pivot properly. The easiest way to solve
    this is by adding new empty `GameObject` to act as pivot points.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你正在使用默认提供的坦克，选择它的不同部分将会显示所有枢轴点都在底部。这对于正确地使我们的炮塔和炮管旋转来说将没有用。解决这个问题最简单的方法是添加新的空`GameObject`作为枢轴点。
- en: Tip
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Any object in the scene is a `GameObject`. Any empty `GameObject` is one that
    only has a **Transform** component.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 场景中的任何对象都是一个`GameObject`。任何空`GameObject`都只包含一个**Transform**组件。
- en: At the top of the Unity Editor, **Create Empty** is the first option under the
    **GameObject** button. It creates the objects we need. Create two empty `GameObjects`,
    and position one at the base of the turret and the other at the base of the cannon.
    Also, rename them to `TurretPivot` and `CannonPivot` respectively. This can be
    done with the textbox at the very top of the **Inspector** window, if the object
    is selected.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，**创建空对象**是位于**GameObject**按钮下的第一个选项。它创建我们需要的对象。创建两个空`GameObject`，并将一个放置在炮塔的底部，另一个放置在炮管的底部。此外，分别将它们重命名为`TurretPivot`和`CannonPivot`。这可以通过**Inspector**窗口顶部的文本框来完成，如果对象已被选中。
- en: In the **Hierarchy** window, drag `TurretPivot` onto `Tank`. This changes the
    parent of `TurretPivot` to `Tank`. Then, drag the object, that is, the turret
    mesh, onto `TurretPivot`. In code, we will be rotating the pivot point, not the
    mesh directly. When a parent object moves or rotates, all of the children objects
    move with it. When you make this change, Unity will complain about the change
    to the original hierarchy of the object; just checking to make sure it is a change
    you want to do and not an accident.![Time for action – creating the tank](img/2014OT_03_03.png.jpg)
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**窗口中，将`TurretPivot`拖动到`Tank`上。这将`TurretPivot`的父对象更改为`Tank`。然后，将对象，即炮塔网格，拖动到`TurretPivot`上。在代码中，我们将旋转枢轴点，而不是直接旋转网格。当一个父对象移动或旋转时，所有子对象都会随之移动。当你进行这个更改时，Unity会抱怨对象原始层次结构的更改；只需确认这是一个你想要进行的更改，而不是一个意外。![行动时间
    – 创建坦克](img/2014OT_03_03.png.jpg)
- en: Because losing that connection to the prefab can potentially break a game, Unity
    just wants to be sure that we actually want it to happen. So, click on **Continue**
    and we can finish working with the tank without other complaints from Unity. We
    also need to make `CannonPivot` a child of `TurretPivot`, and the cannon a child
    of `CannonPivot`.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于失去与预制实例的连接可能会破坏游戏，Unity只是想确保我们确实想要这样做。因此，点击**继续**，我们可以完成与坦克的工作，而不会收到Unity的其他投诉。我们还需要将`CannonPivot`设置为`TurretPivot`的子对象，并将炮管设置为`CannonPivot`的子对象。
- en: To finish off our hierarchy changes, we need to place the camera. Because we
    want it to appear as if the player is actually in the tank, the camera should
    be placed behind and above the tank with a tilt slightly downward to focus on
    a spot a few tank lengths ahead. Once positioned, make it a child of `TurretPivot`
    as well.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成我们的层次结构更改，我们需要放置摄像机。因为我们希望它看起来像玩家实际上在坦克里，所以摄像机应该放置在坦克后面和上方，略微向下倾斜以聚焦在坦克前方几长度的位置。一旦定位好，将其也设置为`TurretPivot`的子对象。
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We set up the basic structure that our tank will use. By making use of multiple
    objects in this way, we can control their movements and actions independently
    from each other. At this point, instead of having a rigid tank that only points
    forward, we can tilt, rotate, and aim each piece independently.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了坦克将使用的基本结构。通过这种方式使用多个对象，我们可以独立控制它们的移动和动作。在这个阶段，我们不再有一个只能向前指的刚性坦克，我们可以独立倾斜、旋转和瞄准每个部件。
- en: Tip
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Also, the tank should be centered above the point that you want the whole thing
    to pivot around. If yours is not, you can select everything that is under the
    base tank object in the **Hierarchy** window and move it around.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，坦克应该位于你想要整个物体围绕旋转的点上方。如果你的不是，你可以在 **Hierarchy** 窗口中选择位于基础坦克对象下的所有内容并移动它。
- en: Time for action – keeping score
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 记录得分
- en: A short script for keeping track of the player's score will constitute the focus
    of this short section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用于跟踪玩家得分的简短脚本将是本节的重点。
- en: To make this tank work, we are going to need three scripts. The first is fairly
    simple. Create a new script and name it `ScoreCounter`. It will, as the name implies,
    track the score. Create it in the `Scripts` folder and clear out the default functions,
    just like every other script we have made so far.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使这个坦克工作，我们需要三个脚本。第一个相对简单。创建一个新的脚本并将其命名为 `ScoreCounter`。正如其名所示，它将跟踪得分。在 `Scripts`
    文件夹中创建它，并清除默认函数，就像我们迄今为止创建的每个脚本一样。
- en: 'Add the following line of code to the new script:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码行添加到新脚本中：
- en: '[PRE0]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: For the most part, this should look familiar from the previous chapter. First
    we define an integer counter. Because it is static, other scripts (such as the
    ones we will create for the targets) will be able to modify this number and give
    us the score.
  id: totrans-72
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于大部分内容，这应该看起来与上一章相似。首先我们定义一个整数计数器。因为它被定义为静态的，所以其他脚本（例如我们将为靶子创建的脚本）将能够修改这个数字并给出得分。
- en: We follow with an `OnGUI` function that defines a `Rect` class and displays
    the score using the `GUI.Box` function. A Box is just like a Label, but it has
    a black background by default. This will make it easier to see as we move around.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是一个 `OnGUI` 函数，它定义了一个 `Rect` 类并使用 `GUI.Box` 函数显示得分。一个框就像一个标签，但默认情况下有一个黑色背景。这将使得在移动时更容易看到。
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '*What just happened?*'
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a very simple script. It will track our score throughout the
    game. Also, instead of doing any of the score incrementation itself, other scripts
    will update the counter to give points to the player.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个非常简单的脚本。它将在整个游戏过程中跟踪我们的得分。此外，我们不会直接进行得分增加，其他脚本将更新计数器以给玩家加分。
- en: Time for action – controlling the chassis
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 控制底盘
- en: A normal tank rotates in place, and it can easily move forward and back. We
    will make our tank do this with the creation of a single script.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一个普通的坦克会在原地旋转，并且可以轻松地前进和后退。我们将通过创建单个脚本来实现我们的坦克这样做。
- en: The second script is called `ChassisControls`. It will make our tank move around.
    Create it in the `Scripts` folder as well.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个脚本被称为 `ChassisControls`。它将使我们的坦克移动。同样在 `Scripts` 文件夹中创建它。
- en: 'The first three lines of the script define the variables the tank will need
    to move around. We will also be able to change them in the **Inspector** window,
    in case our tank is too fast or too slow. The first line defines a variable that
    holds a connection to a `CharacterController` component. This component will easily
    move the tank around, but will allow it to be stopped by walls and other colliders.
    The next two lines of code define how fast we move and rotate:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的前三行定义了坦克移动所需的变量。我们还可以在 **Inspector** 窗口中更改它们，以防我们的坦克速度过快或过慢。第一行定义了一个变量，它包含对
    `CharacterController` 组件的连接。这个组件可以轻松地移动坦克，但允许它被墙壁和其他碰撞体阻止。接下来的两行代码定义了移动和旋转的速度：
- en: '[PRE2]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now let's add our good friend `OnGUI` to the mix. This should look mostly familiar.
    We are creating four buttons that will sit in the bottom-left corner of the screen.
    When the first two buttons are pressed, we make a call to a function that will
    move our tank and give it a value for how fast it can move. A positive value is
    going to move us forward and a negative value will move us backward. The last
    two buttons do the same thing, except with rotation instead of movement. A positive
    value will rotate to the right and a negative value will rotate the tank to the
    left. These buttons are also `RepeatButtons`. A normal button will only activate
    once for each time it is pressed. A repeat button is active as long as it is held
    down. The good side of this is that it will allow our tank to move every frame
    the button is held down. The down side is a quirk in how the `RepeatButton` and
    `OnGUI` functions work. If one of these buttons is active, nothing will be drawn
    after that button in the `OnGUI` function. It is a bit annoying, but suits our
    needs for now.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们把我们的好朋友 `OnGUI` 加入到混合中。这应该看起来很熟悉。我们正在创建四个按钮，它们将位于屏幕的左下角。当按下前两个按钮时，我们将调用一个函数来移动我们的坦克，并给它一个表示其移动速度的值。正值将使我们向前移动，而负值将使我们向后移动。最后两个按钮做的是同样的事情，只是用旋转代替了移动。正值将使坦克向右旋转，而负值将使坦克向左旋转。这些按钮也是
    `RepeatButtons`。一个普通的按钮在每次按下时只会激活一次。而重复按钮在按下时一直处于激活状态。这的好处是它将允许我们的坦克在按钮被按下的每一帧移动。坏处是
    `RepeatButton` 和 `OnGUI` 函数工作方式中的一个怪癖。如果这些按钮中的任何一个处于激活状态，那么在 `OnGUI` 函数中，该按钮之后的任何内容都不会被绘制。这有点烦人，但就目前而言，它符合我们的需求。
- en: '[PRE3]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Only two functions left to go. We start the following line of code by defining
    our `MoveTank` function. It needs to be passed with a speed value to dictate how
    far and in which direction to go. It was mentioned a moment ago; a positive value
    will go forward and a negative value will go backwards.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 剩下只有两个函数需要完成。我们通过定义 `MoveTank` 函数开始下一行代码。它需要一个速度值来指定移动的距离和方向。之前已经提到过；正值将前进，而负值将后退。
- en: '[PRE4]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In order to move in three-dimensional spaces, we need a vector—a value with
    both direction and magnitude. Therefore, we define a movement vector and set it
    to the tank''s forward direction, multiplied by the tank''s speed, and again multiplied
    by the amount of time since the last frame. If you remember from the geometry
    class, 3D space has three directions: x, y, and z. In Unity, the following convention
    applies: x is to the right, y is up, and z is forward. The **Transform** component
    holds an object''s position, rotation, and scale. We can access the **Transform**
    component of any object in Unity by calling upon the `.transform` value that Unity
    provides. The **Transform** component also provides a forward value that will
    give us a vector that points forward relative to the object. Also, we want to
    move at a regular pace, for example, a certain number of meters per second, hence
    we make use of `Time.deltaTime`. This is a value provided by Unity that holds
    how many seconds it has been since the last frame of the game was drawn on screen.
    Think of it like a flip book. In order to make it look like a guy is walking across
    the page, he needs to move slightly on each page. In the case of a game, the pages
    are not flipped regularly. So, we have to modify our movement by how long it has
    taken to flip to the new page. This helps us to maintain an even pace.'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在三维空间中移动，我们需要一个向量——一个既有方向又有大小的值。因此，我们定义了一个移动向量，并将其设置为坦克的前进方向，乘以坦克的速度，然后再乘以自上一帧以来经过的时间。如果你还记得几何课上的内容，三维空间有三个方向：x、y
    和 z。在 Unity 中，以下约定适用：x 是向右，y 是向上，z 是向前。**Transform** 组件包含一个对象的位置、旋转和缩放。我们可以通过调用
    Unity 提供的 `.transform` 值来访问任何对象在 Unity 中的 **Transform** 组件。**Transform** 组件还提供了一个前进值，它将给我们一个相对于对象的指向前进的向量。此外，我们希望以均匀的速度移动，例如，每秒移动一定数量的米，因此我们使用了
    `Time.deltaTime`。这是 Unity 提供的一个值，表示自游戏上一帧在屏幕上绘制以来经过的秒数。想象一下像翻书一样。为了使看起来像一个人在页面上走过，他需要在每一页上稍微移动一下。在游戏的情况下，页面不是定期翻动的。因此，我们必须根据翻到新页面所需的时间来修改我们的移动。这有助于我们保持均匀的速度。
- en: '[PRE5]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we want to stay on the ground. In general, any character you want to
    control in a game does not automatically receive all of the physics that a boulder
    would, such as gravity. For example, when jumping, you temporarily remove gravity
    so the character can go up. That is why the next line of code does a simple implementation
    of gravity by subtracting the normal speed of gravity and again keeps it in pace
    with our frame rate:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们想要保持在地面。一般来说，任何你想要在游戏中控制的角色都不会自动接收到像石头一样所有的物理属性，例如重力。例如，当跳跃时，你暂时移除重力，以便角色可以向上移动。这就是为什么下一行代码通过减去重力的正常速度并再次保持与帧率同步来简单地实现重力：
- en: '[PRE6]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Finally, for the `MoveTank` function, we actually do the moving. The `CharacterController`
    component has a special `Move` function that will move the character but constrain
    it by collisions. We just need to tell it how far and in which direction we want
    to move this frame by passing the `Move` vector to it. That final curly brace,
    of course, closes off the function.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，对于`MoveTank`函数，我们实际上执行移动。`CharacterController`组件有一个特殊的`Move`函数，它将移动角色但通过碰撞来限制它。我们只需要告诉它我们想要在这一帧移动多远以及朝哪个方向移动，通过传递`Move`向量给它。当然，最后的那个花括号关闭了函数。
- en: '[PRE7]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `RotateTank` function is the last one. This function also needs a speed
    value to dictate how fast and in which direction to rotate. We start by defining
    another vector; but, instead of defining which direction to move, this one will
    dictate which direction to rotate around. In this case, we will be rotating around
    our up direction. We then multiply that by our speed and `Time.deltaTime` to move
    fast enough and keep pace with our frame rate.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`RotateTank`函数是最后一个。这个函数也需要一个速度值来指定旋转的速度和方向。我们首先定义另一个向量；但是，与定义移动方向不同，这个向量将指定旋转的方向。在这种情况下，我们将围绕我们的向上方向旋转。然后我们将其乘以我们的速度和`Time.deltaTime`，以便移动得足够快，并保持与帧率的同步。'
- en: '[PRE8]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The last bit of the function actually does the rotation. The **Transform** component
    provides a `Rotate` function. Rotation, especially in 3D space, can become weird
    and difficult very quickly. The `Rotate` function handles all of that for us;
    we just need to supply it with the values to be applied for rotation. Also, don't
    forget the curly brace to close off the function.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 函数的最后部分实际上执行旋转。**Transform**组件提供了一个`Rotate`函数。旋转，尤其是在3D空间中，可以变得非常奇怪和困难。`Rotate`函数为我们处理所有这些；我们只需要提供要应用的旋转值。另外，别忘了用花括号关闭函数。
- en: '[PRE9]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '*What just happened?*'
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We created a script to control the movement of our tank. It will draw a group
    of buttons on the screen, so that our tank can move forward and back. This is
    done using a special `Move` function from the `CharacterController` component.
    We also used a special `Rotate` function provided by the **Transform** component
    to rotate our tank using another set of buttons.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本来控制坦克的移动。它将在屏幕上绘制一组按钮，以便我们的坦克可以向前和向后移动。这是通过使用`CharacterController`组件的特殊`Move`函数来完成的。我们还使用了**Transform**组件提供的特殊`Rotate`函数，通过另一组按钮来旋转我们的坦克。
- en: Time for action – controlling the turret
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 控制炮塔
- en: This script will allow the player to rotate their turret and aim the cannon.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这个脚本将允许玩家旋转他们的炮塔并瞄准大炮。
- en: The last script we need to create for our tank is `TurretControls`. This script
    will allow players to rotate the turret left and right and tilt the cannon up
    and down. As with all of the others, create it in the `Scripts` folder.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为我们的坦克创建的最后一段脚本是`TurretControls`。这个脚本将允许玩家左右旋转炮塔并上下倾斜大炮。与其他所有脚本一样，在`Scripts`文件夹中创建它。
- en: The first two variables we define will hold pointers to the turret and cannon
    pivots, the empty `GameObjects` that we created for our tank. The second set is
    the speed that our turret and cannon will rotate at. Finally we have some limit
    values. If we didn't limit how much our cannon could rotate, it would just spin
    around and around, passing through our tank. This isn't the most realistic behavior
    for a tank, so we must put some limits on it. The limits are in the range of 300
    because straight ahead is zero degree and down is 90 degree. We want it to be
    the upwards angle, so it is in the range of 300\. We also use 359.9 because Unity
    will change 360 to zero so it can continue to rotate.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义的前两个变量将持有炮塔和炮管枢轴的指针，这些是用于我们坦克的空`GameObjects`。第二个集合是我们炮塔和炮管旋转的速度。最后，我们还有一些限制值。如果我们不对炮管的旋转范围进行限制，它就会不断地旋转，穿过我们的坦克。这对坦克来说并不是最逼真的行为，因此我们必须对它进行一些限制。这些限制值在300的范围内，因为正前方是零度，向下是90度。我们希望它是向上的角度，所以它在300度的范围内。我们还使用359.9，因为Unity会将360度转换为零，以便它可以继续旋转。
- en: '[PRE10]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The next step is to create the `OnGUI` function to draw buttons and give the
    player control of the turret. This function is almost identical to the `OnGUI`
    function we made for the `ChassisControls` script. The differences are in the
    fact that the `Rects` class will move to the bottom-right corner of the screen,
    and that we are calling the `RotateCannon` and `RotateTurret` functions. When
    we send a speed to `RotateCannon`, we need a positive value to go up and a negative
    value to go down. `RotateTurret` will largely function like the `RotateTank` function;
    a positive speed will rotate to the right and a negative speed will rotate to
    the left.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建`OnGUI`函数来绘制按钮并让玩家控制炮塔。这个函数几乎与为`ChassisControls`脚本制作的`OnGUI`函数相同。不同之处在于`Rects`类将移动到屏幕的右下角，并且我们正在调用`RotateCannon`和`RotateTurret`函数。当我们向`RotateCannon`发送速度时，需要一个正值来上升，一个负值来下降。`RotateTurret`将主要像`RotateTank`函数一样工作；正值将向右旋转，负值将向左旋转。
- en: '[PRE11]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Next is the `RotateTurret` function. It works exactly in the same way as the
    `RotateTank` function. However, instead of looking at a `CharacterController`
    component 's `Transform` variable, we act upon the `turretPivot` variable that
    was defined at the beginning of the function.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是`RotateTurret`函数。它的工作方式与`RotateTank`函数完全相同。然而，我们不是查看`CharacterController`组件的`Transform`变量，而是作用于函数开头定义的`turretPivot`变量。
- en: '[PRE12]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last function, `RotateCannon`, gets a little more down-and-dirty with rotations.
    The fault completely lies with the need to put limits on the rotation of the cannon.
    After opening the function, the first step is to figure out how much we are going
    to be rotating this frame. We are using a float value instead of a vector because
    we have to set the rotation ourselves.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个函数`RotateCannon`在旋转方面变得更加复杂。错误完全在于需要对炮管的旋转进行限制的需要。在打开函数后，第一步是确定我们将在这个帧中旋转多少。我们使用浮点值而不是向量，因为我们必须自己设置旋转。
- en: '[PRE13]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we define a variable that holds our current rotation. We do this because
    Unity will not let us act on the rotation directly. Unity actually keeps track
    of rotation as a quaternion. This is a complex method of defining rotations that
    is beyond the scope of this book. Luckily, Unity gives us access to an x, y, z
    method of defining rotations called `EulerAngles`. It is a rotation around each
    of the three axes in 3D space. The `localEulerAngles` value of a **Transform**
    component is the rotation relative to the parent `GameObject`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们定义一个变量来保存我们的当前旋转。我们这样做是因为Unity不允许我们直接对旋转进行操作。实际上，Unity将旋转作为四元数来跟踪。这是一种定义旋转的复杂方法，超出了本书的范围。幸运的是，Unity为我们提供了一个名为`EulerAngles`的x、y、z方法来定义旋转。它是在3D空间中围绕每个轴的旋转。**Transform**组件的`localEulerAngles`值是相对于父`GameObject`的旋转。
- en: '[PRE14]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-111
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is called `EulerAngles` because of *Leonhard Euler*, a Swiss mathematician
    who defined this method of defining rotations.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 它被称为`EulerAngles`是因为*莱昂哈德·欧拉*，一位瑞士数学家，他定义了这种定义旋转的方法。
- en: 'Next, we adjust the rotation and apply the limits in one go through the use
    of the `Mathf.Clamp` function. `Mathf` is a group of useful math functions. The
    `Clamp` function takes a value and makes it no lower and no higher than the other
    two values passed to the function. So, we first send it our x axis rotation, which
    is the result of subtracting `rotate` from the current x rotation of `euler`.
    Because the positive rotation is clockwise around an axis, we have to subtract
    our rotation to go up instead of down with a positive value. Next, we pass our
    lower limit to the `Clamp` function, followed by our higher limit: the `lowCannonLimit`
    and `highCannonLimit` variables that we defined at the top of the script.'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们通过使用`Mathf.Clamp`函数一次性调整旋转并应用限制。`Mathf`是一组有用的数学函数。`Clamp`函数接受一个值，并使其不比传递给函数的其他两个值低或高。因此，我们首先发送我们的x轴旋转，这是从`euler`的当前x旋转中减去`rotate`的结果。因为正旋转是围绕轴顺时针的，所以我们必须减去我们的旋转，以便用正值向上而不是向下移动。接下来，我们将我们的下限传递给`Clamp`函数，然后是我们的上限：我们在脚本顶部定义的`lowCannonLimit`和`highCannonLimit`变量。
- en: '[PRE15]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, we have to actually apply the new rotation to our cannon's pivot point.
    This is simply setting the `localEulerAngles` value of the **Transform** component
    to the new value. And again, be sure to use the curly brace to close off the function.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们必须将新的旋转实际应用到炮管的旋转中心点上。这仅仅是设置**变换**组件的`localEulerAngles`值到新值。同样，务必使用花括号来关闭函数。
- en: '[PRE16]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*What just happened?*'
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a script that will control the turret of the tank. Through the use
    of buttons on the screen, the player is able to tilt the cannon and rotate the
    turret. This script functioned in a very similar manner to the `ChassisControls`
    script we created earlier. The difference came in limiting the amount the cannon
    can tilt.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本，用来控制坦克的炮塔。通过使用屏幕上的按钮，玩家能够倾斜炮管并旋转炮塔。这个脚本与之前创建的`ChassisControls`脚本非常相似。区别在于限制了炮管可以倾斜的程度。
- en: Time for action – putting the pieces together
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 组装零件
- en: That was the last of the scripts, for the moment. We have our tank and our scripts;
    the next step is to put them together.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是最后的脚本，目前是这样。我们有了我们的坦克和我们的脚本；下一步是将它们组合起来。
- en: Now, we need to add them to our tank. Remember how we added our `Tic-tac-toe`
    script to the camera in the last chapter? Start by selecting your tank in the
    **Hierarchy** window. Before they work, we will first need to add the `CharacterController`
    component to our tank. So, go to the top of the Unity Editor and select **Component**,
    then select **Physics**, and finally click on the **Character Controller** option.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将它们添加到我们的坦克上。记得我们在上一章中如何将我们的`Tic-tac-toe`脚本添加到相机上吗？首先，在**层次结构**窗口中选择你的坦克。在它们工作之前，我们首先需要将`CharacterController`组件添加到我们的坦克上。因此，转到Unity编辑器的顶部，选择**组件**，然后选择**物理**，最后点击**Character
    Controller**选项。
- en: You will notice that a green capsule also appears on the tank in the Scene view;
    at the same time the new component is added. This capsule represents the space
    that will collide and interact with other colliders. The values on the CharacterController
    component let us control how it interacts with other colliders. For most cases,
    the defaults for the first four are just fine.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你会注意到在场景视图中坦克上还出现了一个绿色的胶囊；同时新组件也被添加了。这个胶囊代表将与其他碰撞体发生碰撞和交互的空间。CharacterController组件上的值让我们可以控制它与其它碰撞体的交互方式。在大多数情况下，前四个属性的默认值就足够好了。
- en: '**Slope Limit**: This attribute shows us how steep an incline the controller
    can move up.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**斜坡限制**：这个属性显示了控制器可以移动的倾斜程度。'
- en: '**Step Offset**: This attribute shows us how high a step can be before it starts
    to block movement.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**步高偏移量**：这个属性显示了在开始阻止移动之前，台阶可以有多高。'
- en: '**Skin Width**: This defines how far another collider can penetrate this controller''s
    collider before it is completely stopped. This is mostly used for squeezing between
    objects.'
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**皮肤宽度**：这定义了另一个碰撞体在完全停止之前可以穿透这个控制器碰撞体的距离。这主要用于挤压在物体之间。'
- en: '**Min Move Distance**: This attribute is for limiting jitter. It is the minimum
    amount of movement that has to be applied in a frame before it will actually move.'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**最小移动距离**：这个属性用于限制抖动。这是在帧中实际移动之前必须应用的最小移动量。'
- en: '**Center**, **Radius**, and **Height**: These attributes define the size of
    the capsule that you see in the Scene view. They are used for the collision.'
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**中心点**, **半径**和**高度**：这些属性定义了你在场景视图中看到的胶囊的大小。它们用于碰撞检测。'
- en: '![Time for action – putting the pieces together](img/2014OT_03_04.png.jpg)'
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 – 组装部件](img/2014OT_03_04.png.jpg)'
- en: The last three values are what we care about right now. We need to adjust these
    values to match our tank's values as closely as possible. Admittedly the capsule
    is round and our tank is square, but a `CharacterController` component is the
    easiest way to move a character with collision and will be used most often. Use
    values of `2.3` for the **Radius** attribute and the **Y** portion of the **Center**
    attribute; everything else can be left at the default values.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后三个值是我们现在关心的。我们需要调整这些值，尽可能匹配坦克的值。诚然，胶囊是圆形的，而我们的坦克是方形的，但`CharacterController`组件是移动带有碰撞的角色的最简单方式，并且将被最频繁使用。将**半径**属性的值设为`2.3`，以及**中心**属性的**Y**部分的值；其他所有内容都可以保留默认值。
- en: It is now time to add the scripts to our tank. Do this by selecting the tank
    in the **Hierarchy** window and dragging the `ChassisControls`, `TurretControls`,
    and `ScoreCounter` scripts onto the **Inspector** window. This is just as we did
    it in the previous chapters.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将脚本添加到我们的坦克上了。通过在**层次结构**窗口中选择坦克，并将`ChassisControls`、`TurretControls`和`ScoreCounter`脚本拖动到**检查器**窗口中来实现。这就像我们在前面的章节中所做的那样。
- en: Before the tank will work, we need to finish creating the connections that we
    started in our scripts. Start by clicking the `CharacterController` component's
    name and dragging it to the **Character Control** value that is on our new `ChassisControls`
    script component. Unity lets us connect object variables in the Unity Editor,
    so that they do not have to be hard coded.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在坦克开始工作之前，我们需要完成在脚本中开始创建的连接。首先点击`CharacterController`组件的名称，并将其拖动到我们新的`ChassisControls`脚本组件上的**角色控制**值。Unity允许我们在Unity编辑器中连接对象变量，这样它们就不需要硬编码。
- en: We also need to connect our turret and cannon pivot points. So, click-and-drag
    the points from the **Hierarchy** window to the corresponding variable on the
    `TurretControls` script component.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要连接我们的炮塔和炮塔旋转点。因此，点击并拖动**层次结构**窗口中的点，到`TurretControls`脚本组件上的相应变量。
- en: Save the scene as `TankBattle` and try it out.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景保存为`TankBattle`并尝试运行。
- en: '*What just happened?*'
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just finished putting our tank together. Unless you look at the **Scene**
    view while using the movement controls, it is hard to tell that the tank is moving.
    The turret controls can be seen in the **Game** view, though. Other than not having
    a point of reference for whether or not our tank is moving, it runs pretty well.
    The next step and the next section will give us that reference point as we add
    our city.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了坦克的组装。除非你在使用移动控制时查看**场景**视图，否则很难看出坦克在移动。然而，在**游戏**视图中可以看到炮塔控制。除了没有我们的坦克是否在移动的参考点之外，它运行得相当好。下一步和下一节将随着我们添加城市而提供这个参考点。
- en: Have a go hero – cannon alignment
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 – 炮塔对准
- en: You might notice a quick jump when you first try to tilt the cannon. Such behavior
    is annoying and makes the game look broken. Try adjusting the cannon to fix it.
    If you are having trouble with it, take a look at the cannon's starting rotation.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到当第一次尝试倾斜炮塔时会有一个快速的跳跃。这种行为很烦人，并且让游戏看起来像是出了问题。尝试调整炮塔来修复它。如果你遇到困难，可以查看炮塔的初始旋转。
- en: Creating the materials
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建材质
- en: In Unity, the materials are the defining factor for how models are drawn on
    the screen. They can be as simple as coloring it all blue, or as complex as reflective
    water with waves. In this section, we will cover the details of the controls for
    a material. We will also create our city and some simple materials to texture
    it with.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，材质是决定模型如何在屏幕上绘制的关键因素。它们可以是简单的全部蓝色，也可以是复杂的带有波浪的反射水。在本节中，我们将介绍材质控制的细节。我们还将创建我们的城市和一些简单的材质来纹理化它。
- en: Time for action – creating the city
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 创建城市
- en: Creating a city gives our tanks and our players a good place to play.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个城市为我们的坦克和玩家提供了一个良好的游戏场所。
- en: For the purposes of this section, no part of the provided city was given a specific
    texture. It was just unwrapped and some tile-able textures were created. So, we
    need to start by importing the city and the textures to the `Environment` folder.
    Do it the same way that we imported the tank.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本节中，提供的城市没有分配特定的纹理。它只是被展开，并创建了一些可重复使用的纹理。因此，我们需要首先将城市和纹理导入到`Environment`文件夹中。就像我们导入坦克一样做。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The files are `TankBattleCity.blend`, `brick_001.png`, `brick_002.png`, `brick_003.png`,
    `dirt_001.png`, `dirt_003.png`, `pebbles_001.png`, `rocks_001.png`, `rubble_001.png`,
    and `water_002.png`.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文件包括 `TankBattleCity.blend`, `brick_001.png`, `brick_002.png`, `brick_003.png`,
    `dirt_001.png`, `dirt_003.png`, `pebbles_001.png`, `rocks_001.png`, `rubble_001.png`,
    和 `water_002.png`.
- en: Because the city was unwrapped, Unity still created a single material for it.
    However, textures were never applied in any modeling program. So, the material
    is plain white. We have several extra textures, so we are going to need more than
    that one material for the whole city. Creating a new material is simple; it is
    done just as with creating a new script. Right-click on the `Materials` folder
    inside the `Environment` folder, and select **Create** followed by **Material**,
    which is about halfway down the menu.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于城市已经被展开，Unity 仍然为它创建了一个单独的材质。然而，在任何建模程序中从未应用过纹理。因此，材质是纯白色的。我们有一些额外的纹理，所以整个城市将需要不止一个材质。创建一个新的材质很简单；就像创建一个新的脚本一样进行。在`环境`文件夹内的`材质`文件夹上右键点击，然后选择**创建**，接着选择**材质**，这在菜单中大约是中间位置。
- en: This will create a new material in the folder and immediately allow us to name
    it. Name the material, `Pebbles`.![Time for action – creating the city](img/2014OT_03_05.png.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将在文件夹中创建一个新的材质，并立即允许我们为其命名。将材质命名为，`Pebbles`。![创建城市的时间 - 创建材质](img/2014OT_03_05.png.jpg)
- en: With your new material selected, take a look at the **Inspector** window. When
    we have a material selected, we get the options needed to change its look.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择新的材质后，查看**检查器**窗口。当我们选择一个材质时，我们会得到改变其外观所需的选项。
- en: At the very top of the **Inspector** window, we have the material's name, followed
    by a **Shader** drop-down list. A shader is essentially a short script that tells
    the graphics card how to draw something on screen. You will use the **Diffuse**
    shader most often, so it is always selected by default. This is where you would
    select from your Bump-mapped shaders, specular, transparent, and a plethora of
    other options. If you were to create some custom shaders, they would also be found
    here.
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口的顶部，我们有材质的名称，后面跟着一个**着色器**下拉列表。着色器本质上是一个简短的脚本，告诉显卡如何在屏幕上绘制某个东西。你将最常使用**漫反射**着色器，所以它默认总是被选中。这里你可以从你的凹凸贴图着色器、高光、透明以及其他众多选项中进行选择。如果你要创建一些自定义着色器，它们也会在这里找到。
- en: The next little block will only be visible if Unity has something to warn you
    about. In this case, it is advising us to use a different shader for performance
    reasons. However, that is a discussion for [Chapter 9](ch09.html "Chapter 9. Optimization"),
    *Optimization*, so we will ignore it for now.
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个小块只有在 Unity 有警告信息时才会可见。在这种情况下，它建议我们出于性能原因使用不同的着色器。然而，这是一个关于[第 9 章](ch09.html
    "第 9 章。优化")，*优化*的讨论，所以我们现在忽略它。
- en: Then, we have the **Main Color** value with a colored square next to it. By
    clicking on that square, the **Color Picker** window will open and let us select
    any color we want. This color value changes the tinting on the texture being drawn
    by the material. Because we don't have a texture yet, you will notice that it
    just changes the color of the ball in the **Preview** window.
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有带有旁边彩色方块的**主颜色**值。点击该方块，将打开**颜色选择器**窗口，允许我们选择任何我们想要的颜色。这个颜色值会改变材质绘制的纹理的色调。因为我们还没有纹理，所以你会注意到它只是改变了**预览**窗口中球的颜色。
- en: The **Base (RGB)** value is under the **Main Color** value. This is the texture.
    The box on the right, with **None (Texture)** and a **Select** button in it, is
    a preview box for the texture being used by this material. To add a texture to
    the material, either drag one to this box from the **Project** window, or click
    on the **Select** button. The button opens a new window that holds the thumbnails
    of every texture that is currently in the project. You can scroll through or use
    the search bar to find the texture that you need and double-click to select it.
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础 (RGB)** 值位于**主颜色**值之下。这是纹理。右侧的带有**无 (纹理**)和**选择**按钮的框是一个用于预览当前材质使用的纹理的预览框。要向材质添加纹理，要么从**项目**窗口拖动一个到这个框中，要么点击**选择**按钮。按钮会打开一个新窗口，其中包含项目中所有纹理的缩略图。你可以滚动浏览或使用搜索栏找到所需的纹理，然后双击以选择它。'
- en: To the left of the box, we have our **Tiling** and **Offset** controls. The
    **Tiling** values dictate how many times the texture will repeat across the normalized
    UV space in the x and y directions. The **Offset** is how far off zero the texture
    starts in the normalized UV space. You can select the number fields and input
    values to modify them. Doing so, and paying attention to the **Preview** window
    below, you will see how they change the texture. Tiling textures are most commonly
    used for large surfaces where the texture is similar enough across the surface
    that it just repeats.
  id: totrans-152
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在框的左侧，我们有**平铺**和**偏移**控件。**平铺**值决定了纹理在x和y方向上在归一化UV空间中重复的次数。**偏移**是纹理在归一化UV空间中从零开始的距离。你可以选择数字字段并输入值来修改它们。这样做，并注意下方的**预览**窗口，你会看到它们如何改变纹理。平铺纹理最常用于大型表面，其中纹理在表面上的相似性足够高，以至于可以重复。
- en: Our **Preview** window is at the bottom of the **Inspector** window. It functions
    just as the one we saw for our tank mesh. What makes this one special, though,
    is the two buttons in the top-right corner of this window. The one to the left
    scrolls through a set of preview shapes. By clicking on it you'll be able to see
    how the texture looks on a sphere, cube, cylinder, or torus. The other button
    toggles between the two types of lighting.
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的**预览**窗口位于**检查器**窗口的底部。它的工作方式与我们之前看到的坦克网格的预览窗口相同。然而，这个窗口特别之处在于窗口右上角的两个按钮。左边的按钮可以滚动预览形状集。通过点击它，你可以看到纹理在球体、立方体、圆柱体或环面上的样子。另一个按钮在两种光照类型之间切换。
- en: Add the `pebbles_001` texture to this material by dragging it from the **Project**
    window and dropping it on the **Base (RGB)** preview box.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从**项目**窗口拖动并将其放置在**基础（RGB）**预览框上，将`pebbles_001`纹理添加到这种材料中。
- en: Use values of 30 for the material's **Tiling** and a light tan color for the
    **Main Color** option, so that the texture can be sized right and more pleasing
    to look at.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将材料的**平铺**值设为30，将**主颜色**选项设为浅米色，以便纹理可以正确缩放，看起来更令人愉悦。
- en: To see our new material in action, first drag your city to the **Hierarchy**
    window, so that it is added to the **Scene** view. By right-clicking-and-dragging,
    you can look around in your **Scene** view. Look over at the streets of the city.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看我们的新材料效果，首先将你的城市拖动到**层次结构**窗口中，使其添加到**场景**视图中。通过右键单击并拖动，你可以在你的**场景**视图中四处查看。看看城市的街道。
- en: Now, drag your new material from the **Project** window into your **Scene**
    view. While dragging the material around, you should see the meshes change to
    appear as if they are using the material. Once you are over the streets, let go
    of your left mouse button. The material is now applied to the mesh.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将你的新材料从**项目**窗口拖动到你的**场景**视图中。在拖动材料时，你应该看到网格发生变化，看起来就像它们正在使用这种材料。一旦你拖动到街道上，就松开你的左鼠标按钮。现在，材料已经应用到网格上了。
- en: However, we currently have a whole quarter of a city to texture. So, create
    more materials and use the remaining textures on the rest of the city. Create
    a new material for each extra texture, plus four extra of `brick_002`, so, we
    can have different colors for each building height.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，我们目前有整个城市四分之一的大小需要纹理化。因此，创建更多材料，并使用剩余的纹理来纹理化城市的其余部分。为每个额外的纹理创建一个新的材料，再加上四个额外的`brick_002`，这样我们就可以为每个建筑高度有不同的颜色。
- en: Apply your new materials to the city, either by comparison with the following
    figure or through your own artistic whim:![Time for action – creating the city](img/2014OT_03_06.png.jpg)
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过比较以下图示或根据你自己的艺术喜好，将你的新材料应用到城市上：![动手实践 – 创建城市](img/2014OT_03_06.png.jpg)
- en: Tip
  id: totrans-160
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When trying to get to the center fountain, if your tank is in the way, select
    your tank in the **Hierarchy** window and use the **Gizmo** option in the **Scene**
    view to drag it out of the way.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当试图到达中心喷泉时，如果你的坦克挡路，请在**层次结构**窗口中选择你的坦克，并在**场景**视图中使用** Gizmo**选项将其拖出障碍。
- en: If you were to try to play the game now, you might notice that we have a couple
    of problems. For starters, we only have a quarter of a city; perhaps you have
    more if you made your own city. There is still no collision on the city, so we
    fall right through it when moving. Also, the tank is a little large for this city,
    and it is too dark to see where we are going. Turning on the lights is the quickest
    solution to fix this problem.
  id: totrans-162
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你现在尝试玩游戏，可能会注意到我们有一些问题。首先，我们只有城市四分之一的大小；如果你自己制作了城市，可能更多。城市中仍然没有碰撞，所以我们在移动时会直接穿过它。此外，坦克对于这个城市来说有点大，而且太暗了，看不清我们想去哪里。打开灯光是解决这个问题最快的方法。
- en: At the top of the Unity Editor, select **GameObject**, followed by **Create
    Other**, and finally **Directional Light**. This creates an object that emits
    light in a single direction. The next chapter explains lights and how to control
    them, so the details will be left for later.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity编辑器的顶部，选择**游戏对象**，然后选择**创建其他**，最后选择**方向光**。这将创建一个以单一方向发射光线的对象。下一章将解释光线及其控制方法，所以细节将留待以后介绍。
- en: Changing the size of our tank is also pretty simple. Select it in the **Hierarchy**
    window and look for the **Scale** label in our **Transform** component. Changing
    the **X**, **Y**, and **Z** values under **Scale** will change the size of our
    tank. Be sure to change them evenly or some weirdness will occur when we start
    rotating the tank. Values of 0.5 make the tank small enough to fit through the
    small streets.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变我们的坦克大小也很简单。在**层次结构**窗口中选择它，并在我们的**变换**组件中查找**缩放**标签。在**缩放**下更改**X**、**Y**和**Z**值将改变坦克的大小。确保均匀地更改它们，否则当我们开始旋转坦克时会出现奇怪的现象。0.5的值可以使坦克足够小，以通过狭窄的街道。
- en: Next up is collision for the city. For the most part, we will be able to get
    away with simple collision shapes that are faster to process. However, the circular
    center of the city will require something special. Start by double-clicking on
    the walls of one of the square buildings in the **Scene** view.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来是城市的碰撞问题。大部分情况下，我们可以使用处理速度较快的简单碰撞形状。然而，城市圆形中心将需要特殊处理。首先在**场景**视图中双击其中一个方形建筑的墙壁。
- en: Tip
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: When dealing with prefabs, which the city still is, clicking on any object that
    makes up the prefab will select the root prefab object. Once a prefab is selected,
    clicking on any part of it will select that individual piece. Because this behavior
    is different from non-prefab objects, you need to be mindful of it when selecting
    objects in the **Scene** view.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当处理预制体时，城市仍然是一个预制体，点击构成预制体的任何对象都会选择根预制体对象。一旦选择了预制体，点击其任何部分都会选择那个单独的部分。因为这种行为与非预制体对象不同，所以在**场景**视图中选择对象时需要留心这一点。
- en: With a set of walls selected, go to the top of the Unity Editor and select **Component**,
    followed by **Physics**, and finally **Box Collider**.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择了一组墙壁后，转到Unity编辑器的顶部，选择**组件**，然后选择**物理**，最后选择**Box Collider**。
- en: Because we are adding the collider to a specific mesh, Unity does its best to
    automatically fit the collider to the shape. For us, this means that the new `BoxCollider`
    component is already sized to fit the building. Continue by adding `BoxColliders`
    to the rest of the square buildings and the outer wall. Our streets are essentially
    just a plain, so a `BoxCollider` component will work just fine for them as well.
    Though pointed at the top, the obelisk in the center of the fountain is essentially
    just a box; so, another `BoxCollider` will suit it fine.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在将碰撞器添加到特定的网格，Unity会尽力自动将碰撞器适配到形状。对我们来说，这意味着新的`BoxCollider`组件已经调整大小以适应建筑。继续添加`BoxColliders`到其余的方形建筑和外墙。我们的街道基本上是平的，所以`BoxCollider`组件对它们来说也适用。尽管尖顶指向顶部，但喷泉中央的方尖碑基本上也是一个盒子；因此，另一个`BoxCollider`也适用。
- en: We have one last building and the fountain ring to deal with. These are not
    boxes, spheres, or capsules. So, our simple colliders will not work. Select the
    walls of the last building, the one next to the center fountain. A few options
    down from where you were selecting **Box Collider**, there is a **Mesh Collider**
    option. This will add a `MeshCollider` component to our object. This component
    does what its name suggests; it takes a mesh and turns it into a collider. By
    adding it to a specific mesh, the `MeshCollider` component automatically selects
    that mesh to be collideable. You should also add `MeshColliders` to the short
    ledge around the center building and the ring wall around the fountain.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们最后要处理的是一座建筑和喷泉的环形区域。这些不是盒子、球体或胶囊。因此，我们的简单碰撞器将不起作用。选择最后一座建筑，即靠近中心喷泉的那座。在您选择**Box
    Collider**的选项下方几项，有一个**Mesh Collider**选项。这将为我们对象添加一个`MeshCollider`组件。这个组件的功能正如其名；它将网格转换为碰撞器。通过将其添加到特定的网格，`MeshCollider`组件会自动选择该网格以使其可碰撞。您还应该将`MeshColliders`添加到中心建筑周围的短边缘和喷泉周围的环形墙上。
- en: The last problem to solve is the duplication of our city quarter. Start by selecting
    the root `city` object in your hierarchy, `TankBattleCity`, and remove the `Animator`
    component from it. The city is not going to animate, so it does not need this
    component.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要解决的问题是我们城市四分之一的复制。首先，在您的层次结构中选择根`city`对象`TankBattleCity`，并从中移除`Animator`组件。城市不会进行动画处理，因此不需要这个组件。
- en: Now, right-click on the city in the **Hierarchy** window and select **Duplicate**.
    This creates a copy of the object that was selected.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在**层次结构**窗口中右键单击城市，并选择**复制**。这将创建所选对象的副本。
- en: Duplicate the city quarter twice more and we will have the four parts of our
    city. The only problem is that they are all in the exact same position.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将城市四分之一再复制两次，我们就会有我们城市的四个部分。唯一的问题是它们都在完全相同的位置。
- en: We need to rotate three of the pieces to make a full city. Select one and set
    the **Y Rotation** value in the **Transform** component to `90`. This will rotate
    it 90 degrees around the vertical axis and give us half of a city.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要旋转三个部件来构建一个完整的城市。选择一个部件，在**变换**组件中设置**Y旋转**值为`90`。这将使其围绕垂直轴旋转90度，从而得到城市的一半。
- en: We will complete the city by setting one of the remaining pieces to `180` and
    another to `270`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过将一个剩余部件设置为`180`，另一个设置为`270`来完成城市。
- en: That leaves one last thing to do. We have four center fountains. In three of
    the four city pieces, select the three meshes that make up the center fountain
    (the `Obelisk`, `Wall`, and `Water`) and click on the *Delete* key on your keyboard.
    Confirm that you want to break the prefab connection each time, and our city will
    be complete.![Time for action – creating the city](img/2014OT_03_07.png.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这样就剩下最后一件事要做。我们有四个中心喷泉。在四个城市部件中的三个中，选择组成中心喷泉的三个网格（`方尖碑`、`墙壁`和`水`），然后按键盘上的**删除**键。每次确认都要断开预制件连接，我们的城市就会完成。![行动时间
    – 创建城市](img/2014OT_03_07.png.jpg)
- en: '*What just happened?*'
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Try out the game now. We can drive around the city and rotate our turret. It
    is so much fun. We created materials and textured the city. After making it possible
    to collide with the buildings and road, we duplicated the section so that we could
    have a whole city.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试游戏。我们可以驾驶汽车在城市中行驶并旋转我们的炮塔。这真是太有趣了。我们创建了材质并为城市着色。在使建筑和道路能够碰撞后，我们复制了该部分，以便我们有一个完整的城市。
- en: Have a go hero – decorating the city
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼 – 装饰城市
- en: Now that you have all the skills needed to import meshes and create materials,
    the challenge is to decorate the city. Create some rubble and tank traps and practice
    importing them to Unity and setting them up in the scene. If you really want to
    go above and beyond, try your hand at creating your own city. Choose something
    from the world, or choose something from your imagination. Once it is created,
    we can release the tanks in it.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经拥有了导入网格和创建材质所需的所有技能，挑战就是装饰城市。创建一些废墟和坦克陷阱，并练习将它们导入Unity并在场景中设置。如果您真的想做得更好，尝试自己创建一个城市。选择世界上的某个东西，或者选择您想象中的某个东西。一旦创建，我们就可以在其中释放坦克。
- en: Time for action – moving treads
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 移动履带
- en: There is just one thing left to do, and then we will be done with materials
    and can go on to make the game even more fun. Remember the **Offset** value of
    the materials? It turns out that we can actually control that with a script. Start
    by opening up the `ChassisControls` script.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 只剩下最后一件事要做，然后我们就可以完成材质，并继续制作一个更有趣的游戏。还记得材质的**偏移**值吗？实际上，我们可以通过脚本来控制它。首先打开`ChassisControls`脚本。
- en: First, we need to add a few variables to the beginning of the script. The first
    two will hold references to our tank tread renderers, the part of the mesh object
    that keeps track of the material that is applied to the mesh and actually does
    the drawing. This is just like how the `characterControl` variable holds a reference
    to our `CharacterController` component.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在脚本的开头添加几个变量。前两个变量将保存对坦克履带渲染器的引用，这是网格对象中跟踪应用到的材质并实际进行绘制的那部分。这就像`characterControl`变量保存了对`CharacterController`组件的引用一样。
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The second two variables will keep track of the amount of offset applied to
    each tread. We store it here because it is a faster reference than trying to look
    it up from the thread's material each frame.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 后两个变量将跟踪每个履带应用的偏移量。我们在这里存储它，因为它比在每一帧从线程的材质中查找要快。
- en: '[PRE18]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: To make use of the new values, these lines need to be added to the end of the
    `MoveTank` function. The first line here adjusts the offset for the right tread
    as per our speed and keeps in time with our frame rate. The second line utilizes
    the material value of a `Renderer` component to find our tank tread material.
    The `mainTextureOffset` value of the material is the offset of the primary texture
    in the material. In the case of our diffuse materials, it is the only texture.
    Then, we have to set the offset to a new `Vector2` value that will contain our
    new offset value. `Vector2` is just like `Vector3` we used for moving, but works
    in 2D space instead of 3D space. A texture is flat, hence 2D space. The last two
    lines of the code do the same thing as the other two, but for the left tank tread.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用新值，需要将这些行添加到`MoveTank`函数的末尾。这里的第一行根据我们的速度调整右侧履带的偏移量，并保持与我们的帧率同步。第二行利用`Renderer`组件的材料值来找到我们的坦克履带材料。材料的主纹理偏移值是材料中主纹理的偏移量。在我们的漫反射材料中，它只有一个纹理。然后，我们必须将偏移量设置为一个新的`Vector2`值，该值将包含我们的新偏移量。`Vector2`就像我们用于移动的`Vector3`一样，但在2D空间中工作而不是3D空间。纹理是平面的，因此是2D空间。代码的最后两行与前面的两行做相同的事情，但针对左侧坦克履带。
- en: '[PRE19]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'To make the connections to the `Renderer` components of our treads, do the
    same thing that we did for the pivot points: drag the tread meshes from the **Hierarchy**
    window to the corresponding value in the **Inspector** window. Once done, be sure
    to save it and try it out.'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将连接到履带`Renderer`组件，做与我们为枢轴点所做相同的事情：将履带网格从**层次**窗口拖动到**检查器**窗口中的相应值。完成后，务必保存并尝试一下。
- en: '*What just happened?*'
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We updated our `ChassisControls` script to make the tank treads move. As the
    tank is driven around, the textures pan in the appropriate direction. This is
    the same type of functionality that is used to make waves in water and other textures
    that move.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更新了`ChassisControls`脚本以使坦克履带移动。当坦克被驾驶时，纹理在适当的方向上平移。这是用于制作水波和其他移动纹理的相同类型的功能。
- en: Have a go hero – turning with the treads
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄般的旋转——用履带旋转
- en: The movement of the material doesn't quite match the speed of the tank. Figure
    out how to add a speed value for the tank's treads. Also, it would be cool if
    they moved in opposite directions when the tank is rotating. Real tanks turn by
    making one tread go forward and the other back.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 材料移动的速度并不完全匹配坦克的速度。找出如何为坦克的履带添加一个速度值。如果坦克旋转时它们向相反方向移动那就更酷了。真实坦克通过让一个履带向前移动，另一个向后移动来转弯。
- en: Animations
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画
- en: The next topic we will be covering is animation. As we explore animations in
    Unity, we will be creating some targets for our tank to shoot at. Much of the
    power of Unity's animation system, Mecanim, lies in working with humanoid characters.
    But, setting up and animating human type characters is a book unto itself, so
    it will not be covered here. However, there is still much we can learn and do
    with Mecanim.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来要讨论的主题是动画。当我们探索Unity中的动画时，我们将为坦克创建一些射击目标。Unity动画系统Mecanim的大部分功能都在于处理人类角色。但是，设置和动画人类类型角色本身就是一本专著，所以这里不会涵盖。然而，我们仍然可以从Mecanim中学到很多并做很多事情。
- en: Before we continue with the explanation of the animation import settings, we
    need an animated model to work with. We have one last set of assets to import
    to our project. Import the `Target.blend` and `Target.png` files into the `Targets`
    folder of our project. Once imported, adjust the **Import Settings** window on
    the **Model** page for the target, just as we did for the tank. Now switch to
    the **Rig** tab.![Animations](img/2014OT_03_08.png.jpg)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们继续解释动画导入设置之前，我们需要一个动画模型来工作。我们还需要导入最后一组资源到我们的项目中。将`Target.blend`和`Target.png`文件导入到我们项目的`Targets`文件夹中。一旦导入，调整目标页面的**导入设置**窗口，就像我们为坦克所做的那样。现在切换到**绑定**选项卡。![动画](img/2014OT_03_08.png.jpg)
- en: The **Animation Type** attribute tells Unity what type of skeleton the current
    model is going to use when animating.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画类型**属性告诉Unity当前模型在动画时将使用哪种类型的骨架。'
- en: The **Humanoid** option adds many more buttons and switches to this page for
    working with human type characters. But again, it is too complex to cover here.
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**人类**选项为处理人类类型角色添加了许多更多按钮和开关到这个页面。但同样，这里过于复杂，无法涵盖。'
- en: A **Generic** rig still uses Mecanim and many of its features. Really, this
    is just any animation skeleton that does not resemble a human in structure.
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通用**绑定仍然使用Mecanim及其许多功能。实际上，这只是任何不类似于人类结构的动画骨架。'
- en: The third option, **Legacy**, utilizes Unity's old animation system. But, this
    system will be phased out over the next few versions of Unity, so it will not
    be covered either.
  id: totrans-200
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三种选项，**Legacy**，使用Unity的旧动画系统。但是，这个系统将在Unity的下一个几个版本中逐步淘汰，因此也不会被涵盖。
- en: The last option, **None**, indicates that the object will not be animating.
    You could select this option for both the tank and the city, because it also keeps
    Unity from adding that `Animator` component and saves space in the final project
    size.
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个选项，**None**，表示对象将不会进行动画。您可以为坦克和城市选择此选项，因为它也会防止Unity添加那个`Animator`组件，并在最终项目大小中节省空间。
- en: The **Root Node** value is a list of every object that is in the model file.
    Its purpose is to select the base object of your animation rig. For this target,
    select **Bone_Arm_Upper**, which is underneath the second **Armature** option.
  id: totrans-202
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**根节点**值是模型文件中每个对象的列表。其目的是选择动画绑定的基础对象。对于这个目标，选择**Bone_Arm_Upper**，它在第二个**绑定**选项下面。'
- en: '![Animations](img/2014OT_03_09.png.jpg)'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动画](img/2014OT_03_09.png.jpg)'
- en: The last page of the import settings, **Animations**, contains everything that
    we need to get the animations from our files into Unity. At the top of the **Target
    Import Settings** window, we have the **Import Animation** checkbox. If an object
    is not going to animate, it is a good idea to turn this option off. Doing so will
    also save space in your project.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导入设置的最后一页，**动画**，包含了我们将动画从文件导入Unity所需的所有内容。在**目标导入设置**窗口的顶部，我们有**导入动画**复选框。如果一个对象不会进行动画，关闭此选项是个好主意。这样做也会在项目中节省空间。
- en: The option below that, **Bake Animations**, is only used when your animations
    contain Kinematics and are from 3Ds Max or Maya. This target is from Blender,
    so the option is grayed out.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下方那个选项，**烘焙动画**，仅在您的动画包含运动学和来自3Ds Max或Maya时使用。这个目标是来自Blender的，所以选项被灰色显示。
- en: The next four options, **Anim. Compression**, **Rotation Error**, **Position
    Error**, and **Scale Error**, are primarily for smoothing jittery animations.
    Nearly all of the time, the defaults will suit just fine.
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的四个选项，**动画压缩**、**旋转错误**、**位置错误**和**缩放错误**，主要用于平滑抖动的动画。几乎所有的时候，默认值都适用得很好。
- en: The **Clips** section is what we are really concerned about. This will be a
    list of every animation clip that is currently being imported from the model.
    On the left-hand side of the list, we have the name of the clip. On the right-hand
    side, we can see the start and end frames of the clip.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剪辑**部分是我们真正关心的。这将是一个当前从模型中导入的每个动画剪辑的列表。在列表的左侧，我们有剪辑的名称。在右侧，我们可以看到剪辑的开始和结束帧。'
- en: Unity will add the **Default Take** animation clip to every new model. This
    is a clip generated from the default preview range of your modelling program,
    when the file was saved.
  id: totrans-208
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity将为每个新模型添加**默认取用**动画剪辑。这是从建模程序的默认预览范围生成的剪辑，当文件被保存时。
- en: In Blender, it is also possible to create a series of actions for each rig.
    By default, they are imported by Unity as animation clips. In this case, the **ArmatureAction**
    clip is created.
  id: totrans-209
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Blender中，也可以为每个绑定创建一系列动作。默认情况下，它们被Unity作为动画剪辑导入。在这种情况下，会创建**ArmatureAction**剪辑。
- en: Below and to the right-hand side of the clips, there is a little tab with **+**
    and **-** buttons. These two buttons add a clip to the end and remove the selected
    clip respectively.
  id: totrans-210
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在剪辑下方和右侧，有一个带有**+**和**-**按钮的小标签。这两个按钮分别将剪辑添加到末尾和移除选定的剪辑。
- en: '![Animations](img/2014OT_03_10.png.jpg)'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动画](img/2014OT_03_10.png.jpg)'
- en: When a clip is selected, the next section appears. It starts with a text field
    for changing the name of the clip.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当选择一个剪辑时，下一个部分就会出现。它从一个用于更改剪辑名称的文本字段开始。
- en: Below the text field, there is a **Source Take** drop-down list. This list is
    the same as the default animations. Most of the time, you will just use **Default
    Take**; but if your animation is ever appearing wrong or is missing, try changing
    the **Source Take** drop-down list first.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在文本字段下方，有一个**源取用**下拉列表。这个列表与默认动画相同。大多数时候，您只会使用**默认取用**；但如果您的动画看起来不正确或丢失，首先尝试更改**源取用**下拉列表。
- en: Then, we have a small timeline, followed by input fields for the start and end
    frames of the animation clip. Clicking-and-dragging on the two blue flags in the
    timeline will change the numbers in the input fields.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们有一个小的时间轴，后面跟着动画剪辑的开始和结束帧的输入字段。在时间轴上点击并拖动两个蓝色标志将改变输入字段中的数字。
- en: Next we have **Loop Pose** and **Cycle Offset**. If we want our animation to
    repeat, check the box next to **Loop Pose**. When an animation is looping, **Cycle
    Offset** will become available. This value lets us adjust the frame that the looping
    animation starts on.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是**循环姿态**和**循环偏移**。如果我们想让动画重复，请勾选**循环姿态**旁边的框。当动画循环时，**循环偏移**将变为可用。这个值让我们可以调整循环动画开始时的帧。
- en: The next three small sections, **Root Transform Rotation**, **Root Transform
    Position (Y)**, and **Root Transform Position (XZ)**, allow us to control the
    movement of a character through the animation.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来的三个小部分，**根变换旋转**、**根变换位置（Y）**和**根变换位置（XZ）**，允许我们通过动画控制角色的运动。
- en: 'All three of these sections have a **Bake into Pose** option. If these are
    left unchecked, the movement of the root node (we selected it under the **Rig**
    page) within the animation is translated into movement of the whole object. Think
    of it like this: say you were to animate a character running to the right and
    inside of the animation program, you actually move them, rather than animating
    in place as normal. With Unity''s old animation system, for the physical part
    of a character to move the collider, the `GameObject` had to be moved with code.
    So, if you were to use that animation, the character would appear as if it had
    moved, but it would have no collision. With this new system, the whole character
    will move when that animation is played. However, this requires a different and
    more complex setup to work completely. So, it was not chosen to be used on the
    tank, though we could have used it.'
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个部分都包含一个**将动画烘焙到姿态**选项。如果这些选项未被勾选，动画中根节点（我们在**绑定**页面下选中的节点）的运动将转化为整个物体的运动。可以这样理解：假设你要动画化一个向右跑的人物，在动画程序中，你实际上移动他们，而不是像通常那样原地动画化。在Unity旧版动画系统中，为了让角色的物理部分移动碰撞体，必须通过代码移动`GameObject`。因此，如果你使用那种动画，角色看起来像是移动了，但实际上没有碰撞。在新系统中，当播放该动画时，整个角色都会移动。然而，这需要一个不同且更复杂的设置才能完全工作。所以，我们没有选择在坦克上使用它，尽管我们可以使用它。
- en: Each of the three sections also has a **Based Upon** drop-down option. The choice
    of this option dictates the object's center for each of the sections. There are
    more choices if you are working with humanoid characters, but for now we only
    have two.
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这三个部分各自还有一个**基于**的下拉选项。这个选项的选择决定了每个部分的物体中心。如果你正在处理类人角色，会有更多选择，但目前为止我们只有两个。
- en: A choice of **Root Node** means the pivot point of the root node object is the
    center.
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**根节点**选项意味着根节点对象的旋转中心是中心点。'
- en: A choice of **Original** means the origin as defined by the animation program
    is the center of the object.
  id: totrans-220
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**原始**选项意味着动画程序定义的原点是物体的中心。'
- en: There is also an **Offset** option for the first two of these sections that
    works to correct errors in the motion. When animating a walk cycle for a character,
    if the character is pulling to the side slightly, adjusting the **Offset** option
    under **Root Transform Rotation** will correct it.
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于这些部分的前两个，还有一个**偏移**选项，用于纠正运动中的错误。当为一个角色动画化行走循环时，如果角色稍微向一侧拉，调整**根变换旋转**下的**偏移**选项可以纠正它。
- en: The last option for our animation clip is a **Transform Mask** option. By clicking
    on the arrow to the left, you can expand a list of all objects in the model. Each
    object has a checkbox next to it. The objects that are not checked will not be
    animated when this clip is played. This is useful in the case of a hand-waving
    animation. Such an animation would only need to move the arm and hand, so we would
    uncheck all of the objects that might make up the body of the character. We could
    then layer animations, making our character capable of waving while standing,
    walking, or running, without the need to create three extra animations.
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们动画剪辑的最后一个选项是**变换遮罩**选项。通过点击左侧的箭头，你可以展开一个包含模型中所有对象的列表。每个对象旁边都有一个复选框。当播放此剪辑时，未勾选的对象将不会动画化。这在挥手动画的情况下很有用。这样的动画只需要移动手臂和手，因此我们会取消勾选可能构成角色身体的所有对象。然后我们可以分层动画，使我们的角色能够在站立、行走或跑步时挥手，而无需创建额外的三个动画。
- en: Finally, we have our **Revert** button, **Apply** button, and the **Preview**
    window at the bottom. Just as with all of our other import settings, we have to
    hit one of these buttons when changes are made. This **Preview** window is made
    special by the speed slider in the top-right corner and the big **play** button
    in the top-left corner. By clicking on this button, we can preview the selected
    animation. This lets us detect those errors in motion that we talked about earlier,
    and just generally make sure that the animation is what we want.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们还有底部的**Revert**按钮、**Apply**按钮和**Preview**窗口。就像我们所有的其他导入设置一样，当进行更改时，我们必须点击其中一个按钮。这个**Preview**窗口通过右上角的速率滑块和左上角的大**play**按钮变得特别。通过点击这个按钮，我们可以预览选定的动画。这让我们能够检测到我们之前提到的运动错误，并确保动画是我们想要的。
- en: The target's animations
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 目标动画
- en: So, now that the description is all out of the way, let's actually make something
    with it. We start by setting up the animations for the target.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在描述都已经说完了，让我们实际做点什么。我们首先设置目标的动画。
- en: Time for action – setting up target's animations
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 设置目标动画
- en: Using the knowledge we just gained, we can now set up our target's animations.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 利用我们刚刚获得的知识，我们现在可以设置目标的动画。
- en: For starters, if you missed or skipped it earlier, be sure to import the `Target.blend`
    and `Target.png` files to the `Targets` folder. Also, on the **Rig** page of the
    import settings, set the **Animation Type** attribute to **Generic** and the **Root
    Node** attribute to **Bone_Arm_Upper**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果你之前错过了或跳过了，请确保将`Target.blend`和`Target.png`文件导入到`Targets`文件夹中。此外，在导入设置的**Rig**页面，将**Animation
    Type**属性设置为**Generic**，将**Root Node**属性设置为**Bone_Arm_Upper**。
- en: We need a total of six animations. By clicking on the **+** button in the **Clips**
    section, you can add four more animations. If you have added too many, click on
    the **-** button to remove the extra clips.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们总共需要六个动画。通过点击**Clips**部分中的**+**按钮，你可以添加另外四个动画。如果你添加了太多，点击**-**按钮来删除额外的剪辑。
- en: All of these clips should have a **Source Take** drop-down list of **Default
    Take** and all of the **Bake into Pose** options should be checked, because the
    target isn't going to be moving from its starting location.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有这些剪辑都应该有一个**Source Take**下拉列表，选择**Default Take**，并且所有**Bake into Pose**选项都应该被勾选，因为目标不会从其起始位置移动。
- en: First, let's create our idle animations. Select the first clip and rename it
    to `Idle_Retract`. Because it is a mechanical object, we can get away with a really
    short animation; so short that we are just going to use the first frame. Set the
    starting frame to `0.9` and the ending frame to `1`.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建我们的空闲动画。选择第一个剪辑并将其重命名为`Idle_Retract`。由于它是一个机械物体，我们可以用一个非常短的动画来应付；短到我们只需要使用第一帧。将起始帧设置为`0.9`，结束帧设置为`1`。
- en: We also need to turn on **Loop Pose** because idle animations are of course
    looping.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要打开**Loop Pose**，因为空闲动画当然是循环的。
- en: The extended idle animation is created in almost exactly the same manner. Select
    the second clip and rename it to `Idle_Extend`. The starting frame here is `14`
    and the ending frame is `14.1`. Also, this animation needs to loop.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展空闲动画几乎是以相同的方式创建的。选择第二个剪辑并将其重命名为`Idle_Extend`。这里的起始帧是`14`，结束帧是`14.1`。此外，这个动画需要循环。
- en: Our next two animations are for when the target extends and retracts. They are
    going to be called `Extend` and `Retract`, so rename the next two clips. The `Extend`
    animation will start at frame `1` and end at frame `13`. The `Retract` animation
    starts at frame `28` and ends at frame `40`. Neither of these will loop.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来的两个动画是针对目标展开和收缩的情况。它们将被命名为`Extend`和`Retract`，所以将接下来的两个剪辑重命名。`Extend`动画将从帧`1`开始，到帧`13`结束。`Retract`动画从帧`28`开始，到帧`40`结束。这两个动画都不会循环。
- en: The last two animations also will not loop. They are for when we shoot the targets.
    There is one for being shot in the front and one for being shot from behind. The
    `Hit_Front` animation will be from frame `57` to frame `87`. The `Hit_Back` animation
    will be from frame `98` to frame `128`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个动画也不会循环。它们是在射击目标时使用的。有一个是正面被射击，另一个是从后面被射击。`Hit_Front`动画将从帧`57`到帧`87`。`Hit_Back`动画将从帧`98`到帧`128`。
- en: Once all of the changes are made, be sure to click on **Apply** or they will
    not be saved.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦所有更改都完成，请确保点击**Apply**，否则它们将不会被保存。
- en: '*What just happened?*'
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We set up the animations that will be used by our targets. There were six in
    total. They may not seem like much now, but the next section would be lost without
    them.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置了目标将使用的动画。总共有六个。现在可能看起来不多，但下一节没有它们就无法进行。
- en: State machines
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态机
- en: In order for us to control these new animations in Unity, we need to set up
    a state machine. A state machine is just a fancy object that keeps track of what
    an object can do, and how to transition between those things. Think of it in terms
    of a builder from a Real Time Strategy game. The builder has a walk state that
    is used when moving to the next construction site. When it gets there, it switches
    to a build state. If an enemy shows up, the builder will enter a run away state
    until the enemy is gone. Finally, there is an idle state for when the builder
    is doing nothing. In Unity, these are called Animator Controllers when working
    with animations and Mecanim.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 为了我们在Unity中控制这些新的动画，我们需要设置一个状态机。状态机就是一个跟踪对象能做什么以及如何在这些事物之间转换的复杂对象。从实时策略游戏中的建筑者角度来想，建筑者有一个行走状态，用于移动到下一个建筑工地。到达那里后，它会切换到构建状态。如果有敌人出现，建筑者会进入逃跑状态，直到敌人消失。最后，当建筑者无所事事时，会有一个空闲状态。在Unity中，这些在处理动画和Mecanim时被称为Animator
    Controllers。
- en: Time for action – creating the target state machine
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 执行时间 – 创建目标状态机
- en: The use of a state machine allows us to focus more on what the target is doing,
    while letting Unity handle the *how it is going to do it* part.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态机可以让我们更多地关注目标正在做什么，同时让Unity处理*如何去做*的部分。
- en: Creating an Animator Controller is simple and done just as we have been doing
    for our scripts and materials. The option is second from the bottom of the **Create**
    menu. Create one in the `Targets` folder and name it `TargetController`.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建Animator Controller很简单，就像我们为脚本和材质所做的那样。选项位于**创建**菜单的倒数第二位。在`Targets`文件夹中创建一个，命名为`TargetController`。
- en: Double-click on `TargetController` to open a new window.![Time for action –
    creating the target state machine](img/2014OT_03_11.png.jpg)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`TargetController`以打开一个新窗口。![执行时间 – 创建目标状态机](img/2014OT_03_11.png.jpg)
- en: The **Animator** window is where we edit our state machines.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Animator**窗口是我们编辑状态机的地方。'
- en: At the top-left corner of the window, there is a breadcrumb trail as you might
    find on a website that lets us see where we are in the state machine at a glance.
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口的左上角，有一个类似于网站上的面包屑导航，让我们可以一眼看出我们在状态机中的位置。
- en: The **Auto Live Link** button in the top-right controls our ability to see the
    state machine's update in real time with the game. This is useful for debugging
    transitions and controls for the character.
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 右上角的**自动实时链接**按钮控制着我们是否能够实时看到状态机与游戏的更新。这对于调试角色过渡和控制非常有用。
- en: Underneath the breadcrumb trail, there are a list of layers and a button for
    adding new layers. Every state machine will have at least the **Base Layer**.
    Adding additional layers would allow us to blend state machines. Say we have a
    character that walks around normal when at full health. When his health drops
    below half, he starts to limp. If the character has only ten percent of his health
    left, he starts to crawl. This would be achieved through the use of layers.
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在面包屑导航下方，有一列层和添加新层的按钮。每个状态机至少会有一个**基础层**。添加额外的层可以让我们混合状态机。比如说，一个角色在健康满值时正常行走。当他的健康值低于一半时，他开始跛行。如果角色的健康值只剩下百分之十，他开始爬行。这可以通过使用层来实现。
- en: At the bottom-left corner of the window, there is the **Parameters** list. Clicking
    on the **+** button will add a new parameter to the list. These parameters can
    be Boolean, float, vector, and integer values. The transitions between states
    are most often triggered by changes in the parameters. Any scripts working with
    the state machine can modify these values.
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在窗口的左下角，有**参数**列表。点击**+**按钮将向列表中添加一个新参数。这些参数可以是布尔值、浮点数、向量或整数值。状态之间的转换通常是由参数的变化触发的。任何与状态机一起工作的脚本都可以修改这些值。
- en: Finally, that green box in the center with **Any State** on it that allows a
    character to transition from any action to a specific one. When a character's
    health drops below zero, we want them to go to the death state. The **Any State**
    box would hold this transition, and it would be able to pull the character out
    of any other state and put them in the death state.
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，中间那个带有**任何状态**的绿色框允许角色从任何动作转换到特定的状态。当角色的健康值降至零以下时，我们希望他们进入死亡状态。**任何状态**框将包含这个转换，并且它能够将角色从任何其他状态拉出来，并将他们放入死亡状态。
- en: To create a new state, right-click on the grid that is inside our **Animator**
    window. Mouse over **Create State** and select **Empty**. This creates a new empty
    state for our state machine. Normally new states are gray but, because this is
    the first state in our machine it is orange, which is the color of the default
    state.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新状态，右键单击**动画器**窗口内部的网格。将鼠标悬停在**创建状态**上，然后选择**空**。这为我们的状态机创建了一个新的空状态。通常新状态是灰色，但因为这个是我们机器中的第一个状态，所以它是橙色，这是默认状态的色彩。
- en: Every state machine will start in its default state. Click on the state to select
    it, and we can take a look at it in the **Inspector** window.![Time for action
    – creating the target state machine](img/2014OT_03_12.png.jpg)
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个状态机都将从其默认状态开始。点击状态以选择它，我们可以在**检查器**窗口中查看它。![执行时间 – 创建目标状态机](img/2014OT_03_12.png.jpg)
- en: At the top, there is a text field for changing the name of the state.
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在顶部，有一个文本框用于更改状态的名称。
- en: Below that, you can add a tag for organizational purposes.
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面，你可以添加一个标签以用于组织目的。
- en: Next, there is a **Speed** field. This field controls the speed of the animation.
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，有一个**速度**字段。这个字段控制动画的速度。
- en: The **Motion** field is where we will add connections to the animation clips
    that we created earlier.
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动**字段是我们将添加到之前创建的动画剪辑的连接的地方。'
- en: The **Foot IK** option lets us decide if we want to let part of the animation
    be calculated with IK. We did not set up any IK for these animations, so we do
    not need to worry about this option.
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**脚部逆运动学（Foot IK）**选项让我们决定是否希望部分动画使用逆运动学（IK）来计算。我们没有为这些动画设置任何IK，所以我们不需要担心这个选项。'
- en: The last option, **Mirror**, is used to flip the left and right (or x axis)
    of the animation. If you created a right-hand-waving animation, this option would
    let you change it to a left-hand-waving animation.
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后一个选项，**镜像**，用于翻转动画的左右（或x轴）。如果你创建了一个右手挥动的动画，这个选项将允许你将其更改为左手挥动的动画。
- en: Below that, there is the list of transitions that go from this state to another
    state. These are transitions out of the state, not into it. As you will soon see,
    a transition in this list appears as the name of the current state with an arrow
    to the right, followed by the name of the state it is connected to.
  id: totrans-259
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下面，是从这个状态到另一个状态的转换列表。这些是从状态中出来的转换，而不是进入状态。正如你很快就会看到的，列表中的转换会显示为当前状态的名称，右侧有一个箭头，后面跟着它连接到的状态的名称。
- en: Checkboxes also appear under the **Solo** and **Mute** labels on the right.
    These are for debugging transitions between states. Any number of the transitions
    can be muted at one time, but only one can be soloed at a time. When a transition
    has been muted, it means that the state machine will ignore it when deciding which
    transition to make. Checking the solo box is the same as muting all but one of
    the transitions. It is just a quick way of making it the only active transition.
  id: totrans-260
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在右侧的**独奏**和**静音**标签下也有复选框。这些用于调试状态之间的转换。一次可以有任意数量的转换被静音，但一次只能有一个被独奏。当一个转换被静音时，这意味着状态机在决定要执行哪个转换时会忽略它。勾选独奏框等同于静音除了一个以外的所有转换。这只是一个快速将其设置为唯一活动转换的方法。
- en: We are going to need one state for each of our target's animations. So, create
    five more states and rename all six to match the names of the animation clips
    we created earlier. The default state, the orange one, should be named `Idle_Retract`.
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为每个目标动画创建一个状态。因此，创建五个更多状态，并将所有六个状态重命名为与我们之前创建的动画剪辑名称相匹配。默认状态，即橙色状态，应命名为`Idle_Retract`。
- en: In the **Project** window, click on the little triangle to the left of the **Target**
    model.![Time for action – creating the target state machine](img/2014OT_03_13.png.jpg)
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，点击**目标**模型左侧的小三角形。![执行时间 – 创建目标状态机](img/2014OT_03_13.png.jpg)
- en: This expands the model, so that we can see all of the objects that make up that
    model in Unity. The first group, as indicated by the little thumbnails next to
    each object, is the raw mesh data. This is followed by an Avatar object; this
    is what keeps track of the **Rig** setup. Below that, there are the animation
    clip objects; these are what we are interested in right now. The objects that
    make up the model are at the bottom of the stack.
  id: totrans-263
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这扩展了模型，因此我们可以在Unity中看到构成该模型的所有对象。第一个组，如每个对象旁边的小缩略图所示，是原始网格数据。接下来是一个Avatar对象；这是跟踪**绑定**设置的地方。在其下方，是动画剪辑对象；这是我们目前感兴趣的对象。构成模型的对象位于堆栈底部。
- en: Select each state in your **Animator** window and pair it with the correct clip
    by dragging an animation clip from the **Project** window and dropping it on the
    **Motion** field in the **Inspector** window.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Animator**窗口中选择每个状态，并通过将动画剪辑从**Project**窗口拖动到**Inspector**窗口中的**Motion**字段来与之配对。
- en: Tip
  id: totrans-265
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The thumbnail for animation clips looks like a little play button.
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 动画剪辑的缩略图看起来像一个小播放按钮。
- en: '![Time for action – creating the target state machine](img/2014OT_03_14.png.jpg)'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行时间 – 创建目标状态机](img/2014OT_03_14.png.jpg)'
- en: Before we can create our transitions, we need a few parameters. Click on the
    **+** button next to **Parameters** in the bottom-left corner of the window and
    select **Float** from the menu that appears. A new parameter should now appear
    in the list.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以创建过渡之前，我们需要一些参数。单击窗口左下角的**Parameters**旁边的**+**按钮，并从出现的菜单中选择**Float**。现在列表中应该出现一个新的参数。
- en: The new field on the left is the name of the parameter; rename this one to `time`.
    The field on the right is the current value of this parameter. When debugging
    our state machine, we can modify these values here to trigger changes in the state
    machine. Any changes made by the scripts while the game is running will also appear
    here.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 左侧的新字段是参数的名称；将此重命名为`time`。右侧字段是此参数的当前值。在调试状态机时，我们可以在此处修改这些值以触发状态机中的变化。游戏运行期间脚本所做的任何更改也将显示在此处。
- en: We need two more parameters. Create two Boolean parameters and rename them to
    `wasHit` and `inTheFront`. These will trigger the machine to change to the getting
    hit states, while the `time` parameter will trigger the machine to utilize the
    `extend` and `retract` states.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要两个更多参数。创建两个布尔参数，并将它们重命名为`wasHit`和`inTheFront`。这些将触发机器改变到被击中的状态，而`time`参数将触发机器利用`extend`和`retract`状态。
- en: To create a new transition, right-click on a state and select **Make Transition**
    from the menu that pops up. A transition line is now connected from the state
    to your mouse. To complete the transition creation, click on the state that you
    wish to connect to. There is an arrow on the line, indicating the direction of
    the transition.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建新的过渡，右键单击一个状态，并从弹出的菜单中选择**Make Transition**。现在从状态到鼠标连接了一条过渡线。要完成过渡创建，请单击您希望连接到的状态。线上有一个箭头，指示过渡的方向。
- en: We need a transition from `Idle_Retract` to `Extend`.
  id: totrans-272
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个从`Idle_Retract`到`Extend`的过渡。
- en: We also need a transition from `Extend` to `Idle_Extend`.
  id: totrans-273
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要从`Extend`到`Idle_Extend`的过渡。
- en: '`Idle_Extend` needs three transitions, one each going to `Retract`, `Hit_Front`,
    and `Hit_Back`.'
  id: totrans-274
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Idle_Extend`需要三个过渡，每个分别过渡到`Retract`、`Hit_Front`和`Hit_Back`。'
- en: '`Retract`, `Hit_Front`, and `Hit_Back` need a transition going to `Idle_Retract`.'
  id: totrans-275
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Retract`、`Hit_Front`和`Hit_Back`需要过渡到`Idle_Retract`。'
- en: Tip
  id: totrans-276
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Use the following diagram for reference. If you create a transition or state
    that you do not want, select it and click on the *Delete* key on your keyboard
    to remove it.
  id: totrans-277
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下图表进行参考。如果您创建了一个不想要的过渡或状态，请选择它，然后按键盘上的*Delete*键将其删除。
- en: '![Time for action – creating the target state machine](img/2014OT_03_16.jpg)'
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![执行时间 – 创建目标状态机](img/2014OT_03_16.jpg)'
- en: If you click on one of the transition lines, then we can take a look at its
    settings.![Time for action – creating the target state machine](img/2014OT_03_17.png.jpg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您单击一条过渡线，那么我们可以查看其设置。![执行时间 – 创建目标状态机](img/2014OT_03_17.png.jpg)
- en: At the top of the **Inspector** window, we have the same indicators of which
    states we are transitioning between that we had in the state, the name of the
    state the transition starts in followed by an arrow, and finally the name of the
    state the transition ends in.
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**Inspector**窗口的顶部，我们有与状态中相同的指示器，显示我们正在过渡到哪个状态，过渡开始时的状态名称后面跟着一个箭头，最后是过渡结束时的状态名称。
- en: Underneath the familiar **Transitions** list, there is a text field where we
    can give our transitions specific names. This would be useful if we had several
    different types of transitions between the same two states.
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在熟悉的**转换**列表下方，有一个文本字段，我们可以为我们的转换指定特定的名称。如果我们有几种不同类型的转换在相同两个状态之间，这将很有用。
- en: Directly under the field, there is a more exact path-based indication of which
    states the transition is between.
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在字段直接下方，有一个更精确的基于路径的指示，显示转换涉及哪些状态。
- en: The **Atomic** checkbox allows us to decide whether or not a transition can
    be interrupted. If **Atomic** is checked, it cannot be interrupted.
  id: totrans-283
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子**复选框允许我们决定一个转换是否可以被中断。如果勾选了**原子**，则不能被中断。'
- en: In the example about the **Any State** option and the death state, perhaps we
    were shot while pulling out a sword, going from an idle state to an attack state.
    That transition cannot be atomic, if we are to avoid the weirdness of completing
    our sword draw before falling over dead.
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在关于**任何状态**选项和死亡状态的例子中，也许我们在拔剑时被击中，从空闲状态转换到攻击状态。如果我们想避免在倒下之前完成拔剑的奇怪情况，这个转换就不能是原子的。
- en: Next is a timeline block that lets us preview the transition between animations.
    Dragging the little flag left and right, we can watch the transition in the **Preview**
    window below. The top half of this block holds wave forms that indicate the movement
    contained in an animation. The bottom half shows the states as boxes that overlap
    where the transition actually occurs. Either of these boxes can be dragged to
    change the length of the transition.
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来是一个时间线块，它让我们可以预览动画之间的转换。通过左右拖动小旗，我们可以在下面的**预览**窗口中查看转换。这个块的上半部分包含波形，表示动画中包含的运动。下半部分以框的形式显示状态，表示转换实际发生的位置。这两个框中的任何一个都可以拖动以改变转换的长度。
- en: Tip
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Because our two idle animations are of negligible length, this can't be seen
    in our setup normally. If you temporarily create a transition between the `extend`
    and `retract` states, it would be visible.
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们的两个空闲动画长度可以忽略不计，这在我们正常的设置中是看不到的。如果你临时在`extend`和`retract`状态之间创建一个转换，它就会变得可见。
- en: Lastly, we have a **Conditions** list. Using the parameters we set up, we can
    create any number of conditions here that must be met before this transition can
    take place.
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们有一个**条件**列表。使用我们设置的参数，我们可以在其中创建任何数量的条件，这些条件必须满足才能进行此转换。
- en: The default condition is **Exit Time**. This means that, when the first state
    reaches a certain percentage of the way through its animation, as defined by the
    float field to the right, it will start transitioning into the next state. For
    half of our transitions, this is what we want. The other half, namely anything
    that exits our idle states, need to be based on our parameters.
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认条件是**退出时间**。这意味着，当第一个状态达到其动画的某个百分比时（由右侧的浮点字段定义），它将开始转换到下一个状态。对于我们的转换的一半，这是我们想要的。另一半，即任何退出空闲状态的情况，需要基于我们的参数。
- en: Tip
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: There is also another **Preview** window at the bottom of the **Inspector**
    panel. It functions just like the one for the animation import settings page,
    but this one plays the transition between the two relevant animations.
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**检查器**面板的底部还有一个另一个**预览**窗口。它的工作方式与动画导入设置页面上的窗口相同，但这个窗口播放两个相关动画之间的转换。
- en: Select the transition between the `Idle_Retract` state and `Extend` state. We
    want the targets to randomly pop up. This will be controlled by a script changing
    the `time` parameter.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Idle_Retract`状态和`Extend`状态之间的转换。我们希望目标随机弹出。这将由一个修改`time`参数的脚本控制。
- en: Click on `Exit Time` under the **Conditions** list to bring up the list of parameters
    and select time from the list.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**条件**列表下的`Exit Time`，以显示参数列表并从列表中选择时间。
- en: In order to turn a float value into a conditional statement, we need to compare
    it with another value. That is why we got a new drop-down button of comparison
    options when we selected the parameter. A float value will be either greater than
    or less than the value on the right. Our time will be counting down, so select
    **Less** from the list and leave the value at zero.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将浮点值转换为条件语句，我们需要将其与另一个值进行比较。这就是为什么当我们选择参数时，我们得到了一个新的比较选项下拉按钮。浮点值将大于或小于右侧的值。我们的时间将倒计时，因此从列表中选择**小于**，并将值保留为零。
- en: Change the conditions for the transition between the `Idle_Extend` and `Retract`
    states to be the same.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Idle_Extend`和`Retract`状态之间的转换条件改为相同。
- en: For the transition between the `Idle_Extend` state and `Hit_Front` state, we
    will use both of the Boolean parameters that were created. Select the transition
    and click on the **+** button under **Conditions** to add a second condition.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Idle_Extend`状态和`Hit_Front`状态之间的转换，我们将使用之前创建的两个布尔参数。选择转换，然后在**条件**下的**+**按钮上点击，添加第二个条件。
- en: For the first condition, select **wasHit** and select **inTheFront** for the
    second condition.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第一个条件，选择**wasHit**，对于第二个条件选择**inTheFront**。
- en: A Boolean is either true or false. In the case of the transitions, it needs
    to know which of those values it is waiting for. For this transition, both should
    be left as true.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布尔值要么是true，要么是false。在转换的情况下，它需要知道它正在等待哪个值。对于这个转换，两个都应该保持为true。
- en: Next, set up the conditions for the transition between `Idle_Extend` and `Hit_Back`,
    just as you did for the previous transition. The difference being that false needs
    to be selected from the drop-down list next to the `inTheFront` conditional.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置`Idle_Extend`和`Hit_Back`之间的转换条件，就像你为之前的转换所做的那样。区别在于，在`inTheFront`条件旁边的下拉列表中需要选择**false**。
- en: '*What just happened?*'
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a state machine that will be used by our targets. By linking each
    state to an animation and connecting them all with transitions, the target will
    be able to switch between animations. This transitioning is controlled through
    adding conditionals and parameters.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个状态机，它将被我们的目标使用。通过将每个状态链接到动画并将它们通过转换连接起来，目标将能够在动画之间切换。这种转换是通过添加条件和参数来控制的。
- en: Time for action – scripting the target
  id: totrans-302
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 编写目标脚本
- en: We only need one more piece before we can finish putting the target together.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成组装目标之前，我们只需要再添加一个部件。
- en: That piece is a script. Create a new script in our `Scripts` folder and name
    it `Target`.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 那个部件是一个脚本。在我们的`Scripts`文件夹中创建一个新的脚本，并将其命名为`Target`。
- en: First, in order to interact with our state machine, we need a reference to the
    `Animator` component. It is the component that you removed from the tank and the
    city. The `Animator` component is what ties all of the pieces of animation together.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为了与我们的状态机交互，我们需要一个对`Animator`组件的引用。这个组件是你从坦克和城市中移除的。`Animator`组件是将所有动画片段连接在一起的关键。
- en: '[PRE20]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is followed by two float values that will dictate the range of time, in seconds,
    that our targets will sit in their idle states.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 紧接着是两个浮点值，它们将决定我们的目标在空闲状态中停留的时间范围，单位是秒。
- en: '[PRE21]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Next, we have three values that will hold the ID numbers of the parameters that
    we need to change. It is technically possible to just use the names of the parameters
    to set them, but using the ID number is much faster.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有三个值将保存我们需要更改的参数的ID号。技术上讲，我们可以直接使用参数的名称来设置它们，但使用ID号要快得多。
- en: '[PRE22]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The last two variables will hold the ID numbers of the two idle states. We
    need these for checking which state we are in. All of the IDs are initially set
    to `-1` as a dummy value, we set them to their actual values with the following
    function:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后两个变量将保存两个空闲状态的ID号。我们需要这些来检查我们处于哪个状态。所有的ID最初都设置为`-1`作为占位符，我们使用以下函数将它们设置为实际值：
- en: '[PRE23]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Awake` function is a special function in Unity that is called on every
    script at the beginning of the game. Its purpose is initialization before the
    game gets underway, perfect for initially setting our ID values. For each ID,
    we make a call to the `Animator.StringToHash` function. This function calculates
    the ID number of the parameter or state that we give it the name of. The state
    names also need to be prefixed with `Base Layer`. This is because Unity wants
    us to be specific when it is possible to have several different layers with states
    that are named the same thing. It is also very important that the name here exactly
    matches the name in the **Animator** window. If it does not, IDs will not match,
    errors will occur, and the script will not function correctly.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Awake`函数是Unity中的一个特殊函数，它在游戏开始时对每个脚本进行调用。它的目的是在游戏开始之前进行初始化，非常适合最初设置我们的ID值。对于每个ID，我们调用`Animator.StringToHash`函数。这个函数计算我们给出的参数或状态的ID号。状态名称也需要以`Base
    Layer`为前缀。这是因为Unity希望我们在可能存在具有相同名称的多个不同层的状态时，能够具体指定。此外，这里的名字必须与**Animator**窗口中的名字完全匹配。如果不匹配，ID将不会匹配，将发生错误，脚本将无法正确运行。'
- en: '[PRE24]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To make use of all of these IDs, we turn to our very good friend—the `Update`
    function. At the beginning of the function, we use the `GetCurrentAnimatorStateInfo`
    function to figure out which state is the current one. We send it a zero because
    it wants to know the index of the layer we are inquiring about, of which we only
    have the one. The function returns an object with the info about the current state,
    and we grab the `nameHash` value (also known as the ID value) of this state right
    away and set our variable to it.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用所有这些ID，我们转向我们的好朋友——`Update`函数。在函数的开始部分，我们使用`GetCurrentAnimatorStateInfo`函数来确定当前是哪个状态。我们传递一个零，因为它想知道我们正在查询的层的索引，而我们只有一个。该函数返回一个包含当前状态信息的对象，我们立即抓取这个状态的`nameHash`值（也称为ID值），并将我们的变量设置为它。
- en: '[PRE25]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The next line of code is a comparison with our idle state IDs to figure out
    if we are in one of those states. If we are, we call upon the `SubtractTime` function
    (which we will write in a moment) to reduce the `time` parameter.
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一行代码是与空闲状态ID的比较，以确定我们是否处于这些状态之一。如果我们处于这些状态，我们将调用`SubtractTime`函数（我们将在稍后编写）来减少`time`参数。
- en: '[PRE26]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If the target is not currently in one of its idle states, we start by checking
    to see if we were hit. If so, the hit is cleared using the `ClearHit` function
    and the `time` parameter is reset using the `ResetTime` function. Both functions
    will also be written in a moment. Finally, we check to see if our timer had dropped
    below zero. If that is the case, we again reset the timer.
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果目标当前不在其空闲状态之一，我们首先检查是否被击中。如果是，我们使用`ClearHit`函数清除击中，并使用`ResetTime`函数重置`time`参数。这两个函数也将很快被编写。最后，我们检查计时器是否已经低于零。如果是这种情况，我们再次重置计时器。
- en: '[PRE27]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In the `SubtractTime` function we use the `GetFloat` function of our `Animator`
    component to retrieve the value of a float parameter. By sending it our `timeId`
    variable, we can receive the current value of the `time` parameter. Like we did
    with the tank, we then use `Time.deltaTime` to keep in pace with our frame rate
    and subtract time from the timer. Once done, we need to give the state machine
    the new value, which is done with the `SetFloat` function. We tell it which parameter
    to change by giving it an ID value, and we tell it what to change it to by giving
    it our new time value.
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SubtractTime`函数中，我们使用`Animator`组件的`GetFloat`函数来检索一个浮点参数的值。通过传递我们的`timeId`变量，我们可以接收到`time`参数的当前值。就像我们对坦克所做的那样，我们接着使用`Time.deltaTime`来与我们的帧率保持同步，并从计时器中减去时间。一旦完成，我们需要将新的值提供给状态机，这是通过`SetFloat`函数完成的。我们通过给它一个ID值来告诉它要更改哪个参数，并通过给它我们的新时间值来告诉它更改成什么。
- en: '[PRE28]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The next function to create is `ClearHit`. This function uses `SetBool` from
    the `Animator` component to set Boolean parameters. It functions just as the `SetFloat`
    function. We just give it an ID and a value. In this case, we are setting both
    of our Boolean parameters to false so that the state machine no longer thinks
    it has been hit.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要创建的函数是`ClearHit`。这个函数使用`Animator`组件的`SetBool`来设置布尔参数。它的工作方式与`SetFloat`函数相同。我们只需给它一个ID和一个值。在这种情况下，我们将两个布尔参数都设置为false，这样状态机就不再认为它被击中了。
- en: '[PRE29]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The last function for the script is `ResetTime`. This is another quick function.
    First, we use the `Random.Range` function to get a random value. By passing it
    a minimum and maximum value, our new random number will be between them. Finally
    we use the `SetFloat` function to give the state machine the new value.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本中的最后一个函数是`ResetTime`。这是一个快速函数。首先，我们使用`Random.Range`函数来获取一个随机值。通过传递一个最小值和一个最大值，我们的新随机数将在这两个值之间。最后，我们使用`SetFloat`函数给状态机提供新的值。
- en: '[PRE30]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '*What just happened?*'
  id: totrans-327
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a script to control the state machine of our target. For comparing
    states and setting parameters, we gathered and used IDs. For now, do not worry
    about when the hit states are activated. It will be made clear in the following
    section when we finally make the tank shoot.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本来控制目标的状态机。为了比较状态和设置参数，我们收集并使用了ID。现在，不要担心击中状态何时被激活。在接下来的章节中，当我们最终让坦克射击时，将会明确说明。
- en: Creating the prefab
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建预制体
- en: Now that we have the model, animations, state machine, and script, finally it
    is time to create the target and turn it into a prefab.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了模型、动画、状态机和脚本，最后是时候创建目标并将其转换为预制体了。
- en: Time for action – creating the target
  id: totrans-331
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建目标
- en: We have all the pieces; the next step is to put them together.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经拥有了所有部件；下一步是将它们组合起来。
- en: Start by dragging the **Target** model from the **Project** window to the **Hierarchy**
    window. This creates a new instance of the `target` object.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将**目标**模型从**项目**窗口拖动到**层次结构**窗口。这将在`target`对象中创建一个新的实例。
- en: By selecting the new `target` object, we can see that it already has an `Animator`
    component attached; we just need to add a reference to `AnimatorController` that
    we created. Do this by dragging `TargetController` from the **Project** window
    and dropping it on the Animator component's **Controller** field, just as with
    all the other object references we have set up so far.
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择新的`target`对象，我们可以看到它已经附加了一个`Animator`组件；我们只需要添加一个对`AnimatorController`的引用。这样做是通过从**项目**窗口将`TargetController`拖动到Animator组件的**控制器**字段，就像我们迄今为止设置的所有其他对象引用一样。
- en: Also, we need to add the `Target` script to the object and connect a reference
    to the `Animator` component in its relevant field.
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还需要将`Target`脚本添加到对象中，并将其相关字段中的`Animator`组件的引用连接起来。
- en: The last thing to do to the target object is to add a collider to actually receive
    our cannon shots. Unfortunately, because the `target` object uses bones and a
    rig to animate, it is not as simple as adding a collider directly to the mesh
    we will be shooting at. Instead, we need to create a new empty `GameObject`.
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对目标对象进行的最后一项操作是添加一个碰撞器以实际接收我们的炮弹射击。不幸的是，因为`target`对象使用骨骼和绑定进行动画，所以直接将碰撞器添加到我们将要射击的网格并不简单。相反，我们需要创建一个新的空`GameObject`。
- en: Rename it `TargetCollider`, and make it a child of the target's `Bone_Target`
    bone.
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其重命名为`TargetCollider`，并使其成为目标对象的`Bone_Target`骨骼的子对象。
- en: Add a `MeshCollider` component to the new `GameObject`.
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向新的`GameObject`添加一个`MeshCollider`组件。
- en: Now, we need to provide it with some mesh data. Find the `Target` mesh data
    in the **Project** window, underneath the **Target** model. Drag it to the **Mesh**
    value of the `MeshCollider` component. This causes a green cylinder to appear
    in the **Scene** view. This is our collision, but it is actually not on the target.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要提供一些网格数据。在**项目**窗口中找到`Target`网格数据，位于**目标**模型下方。将其拖动到`MeshCollider`组件的**网格**值。这将在**场景**视图中出现一个绿色的圆柱体。这是我们碰撞的，但实际上它不在目标上。
- en: Tip
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The many objects in the **Project** window can be easily told apart by the little
    symbol that sits next to each. The symbol for a mesh is a gray and blue grid.
  id: totrans-341
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**项目**窗口中的许多对象可以通过每个旁边的符号轻松区分。网格的符号是一个灰色和蓝色的网格。'
- en: '![Time for action – creating the target](img/1.jpg)'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![行动时间 - 创建目标](img/1.jpg)'
- en: Use the **Transform** component to set the GameObject's position to `4` for
    the **X** value and `0` for both **Y** and **Z**. The rotation needs to be changed
    to `0` for **X**, `-90` for **Y** and `90` for **Z**.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**变换**组件将GameObject的位置设置为**X**值为`4`，**Y**和**Z**值都为`0`。旋转需要更改为**X**值为`0`，**Y**值为`-90`，**Z**值为`90`。
- en: As we made the changes, you probably noticed that the font of everything that
    was new or changed became bold. This is to indicate that something is different
    with this prefab instance when compared to the original. Remember, models are
    essentially prefabs; their problem is that we cannot directly make changes such
    as adding scripts. To make this target into a new prefab, simply drag it from
    the **Hierarchy** window and drop it on the `Prefabs` folder in the **Project**
    window.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们进行更改时，你可能已经注意到所有新或更改的内容的字体都变成了粗体。这是为了表明与原始预制件实例相比，这个预制件实例有所不同。记住，模型本质上就是预制件；它们的问题是我们不能直接进行更改，例如添加脚本。要将这个目标变成一个新的预制件，只需将其从**层次结构**窗口拖动，并将其放在**项目**窗口中的`Prefabs`文件夹上即可。
- en: With this spiffy new prefab created, populate the city with it.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用这个新创建的预制件，用它在城市中填充。
- en: In placing all of these targets, you probably noticed that they are a little
    large. Instead of editing each target individually or even all of them as a group,
    we only have to make a change to the original prefab. Select the `Target` prefab
    in the **Project** window. The **Inspector** window displays the same information
    for a root prefab object as it does for any other object in the scene. With our
    prefab selected, half the scale and all of the instances already in the scene
    will automatically be updated to match. We can also make changes to the min and
    max idle times and have it affect the whole scene.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在放置所有这些目标时，你可能注意到它们有点大。我们不需要单独编辑每个目标，甚至作为一组编辑所有目标，我们只需要对原始预制进行更改。在 **Project**
    窗口中选择 `Target` 预制。**Inspector** 窗口显示与场景中任何其他对象相同的信息。选择我们的预制后，其一半的缩放和场景中所有已存在的实例将自动更新以匹配。我们还可以更改最小和最大空闲时间，并使其影响整个场景。
- en: '*What just happened?*'
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just finished creating the targets for our tank. By making use of Unity's
    prefab system, we are also able to duplicate the target throughout our game and
    easily make changes that affect them all.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了坦克的目标创建。通过使用 Unity 的预制系统，我们也能够在整个游戏中复制目标，并轻松地对它们进行影响所有实例的更改。
- en: If you wanted one of the targets to be larger than all of the others, you could
    change it in the scene. Any changes made to a prefab instance are saved, and they
    take precedence over changes made to the root prefab object. Also, when looking
    at an instance in the **Inspector** window, there will be three new buttons at
    the top of the window. The **Select** button selects the root prefab object in
    the **Project** window. **Revert** will remove any unique changes made to this
    instance, whereas the **Apply** button updates the root object with all the changes
    that were made in this instance.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让其中一个目标比其他所有目标都大，你可以在场景中更改它。对预制实例所做的任何更改都会被保存，并且它们会优先于对根预制对象所做的更改。此外，当在
    **Inspector** 窗口中查看实例时，窗口顶部将出现三个新按钮。**Select** 按钮在 **Project** 窗口中选择根预制对象。**Revert**
    将移除对此实例所做的任何独特更改，而 **Apply** 按钮将使用在此实例中做出的所有更改更新根对象。
- en: Have a go hero – more targets
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 英雄试炼 - 更多目标
- en: Using all that you have learned about animations and state machines, your challenge
    here is to create a second type of target. Play around with different movements
    and behaviors. Perhaps, create one that transitions from waving around to standing
    still.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 利用你所学的关于动画和状态机的知识，你的挑战是创建第二种目标类型。尝试不同的运动和行为。也许，创建一个从摇摆不定过渡到静止不动的目标。
- en: Ray tracing to shoot
  id: totrans-352
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 光线追踪射击
- en: 'Play the game now; it is pretty cool. We have our drivable tank and textured
    city. We even have fancy animated targets. We are just missing one thing: how
    do we shoot? We need to make one more script and we can shoot targets to our heart''s
    content.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在开始玩游戏；这相当酷。我们有可驾驶的坦克和纹理化的城市。我们甚至还有花哨的动画目标。我们只是缺少一件事：我们如何射击？我们需要再编写一个脚本，然后我们可以尽情射击目标。
- en: Time for action – simple shooting
  id: totrans-354
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 简单射击
- en: With the addition of one more object and a single script, we can start shooting
    at our targets.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 通过添加一个对象和单个脚本，我们可以开始射击目标。
- en: First, we need to add an empty `GameObject` to our tank. Rename it to `MuzzlePoint`
    and make it a child of the cannon's pivot point object. Once done, position it
    at the end of the cannon so the blue arrow points away from the tank, along the
    same direction as the cannon. This will be the point where our bullets will come
    from.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的坦克中添加一个空的 `GameObject`。将其重命名为 `MuzzlePoint` 并使其成为炮塔旋转点的子对象。完成后，将其放置在炮管末端，使蓝色箭头指向远离坦克的方向，与炮管方向一致。这将是我们子弹的发射点。
- en: We also need something to indicate where we are shooting. The explosions are
    covered in future chapters, so choose **Sphere** from the **Create Other** menu
    and rename it `TargetPoint`.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要一些东西来指示我们射击的位置。爆炸将在未来的章节中介绍，所以从 **Create Other** 菜单中选择 **Sphere** 并将其重命名为
    `TargetPoint`。
- en: Set the sphere's scale to `0.2` for each axis and give it a red material. This
    way it can be more easily seen, without being completely obtrusive.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体的缩放设置为每个轴的 `0.2` 并赋予它红色材质。这样它更容易被看到，同时又不会过于显眼。
- en: Remove the `SphereCollider` component from `TargetPoint`. The `SphereCollider`
    has to be removed because we don't want to shoot our own target indicator.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `TargetPoint` 中移除 `SphereCollider` 组件。必须移除 `SphereCollider` 组件，因为我们不想射击自己的目标指示器。
- en: Now, create a new script and call it `FireControls`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个新的脚本并将其命名为 `FireControls`。
- en: This should start to look familiar to you. We start with variables to hold references
    to our muzzle and targeting objects that we just created. They are followed by
    an `OnGUI` function that draws a button in the bottom-right corner of the screen,
    just above where we drew the turret control buttons. If the button is pressed,
    we call upon the `Fire` function that we will create next.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这应该开始让你感到熟悉。我们首先使用变量来保存对刚刚创建的枪口和目标对象的引用。随后是一个 `OnGUI` 函数，它在屏幕的右下角绘制一个按钮，就在我们绘制炮塔控制按钮的上方。如果按钮被按下，我们将调用我们接下来要创建的
    `Fire` 函数。
- en: '[PRE31]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `Fire` function starts by defining a variable that will hold the detailed
    information about what was shot. It is followed by an `if` statement that checks
    the `Physics.Raycast` function. The `Raycast` function works just like shooting
    a gun. We start with a position (the muzzle point's position) pointing in a specific
    direction (forward relative to the muzzle point) and get out what was hit. If
    we hit something, the `if` statement evaluates to true; otherwise it is false
    and we would skip ahead. When we do hit something, we first move our target point
    to the point that was hit. We then use the `SendMessage` function to tell what
    we hit that it was hit. The `SendMessage` function is only available for `GameObjects`
    and `MonoBehaviours`, and our `Target` script is on the root object for the target,
    hence the `hit.transform.root.gameObject` in order to get at the `GameObject`
    that was hit. The `SendMessage` function takes the name of a function and tries
    to find it on the `GameObject` to which the message was sent. We are also providing
    it with a value, `hit.point`, to give to the function that should be found. The
    `SendMessageOptions.DontRequireReceiver` part of the line keeps the function from
    throwing an error if it is unable to find the desired function. The last part
    of our `Fire` function occurs if we didn't hit anything. We send our target point
    back to the world origin, so the player can tell that they missed everything.
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Fire` 函数首先定义了一个变量，该变量将保存关于射击细节的详细信息。随后是一个 `if` 语句，用于检查 `Physics.Raycast` 函数。`Raycast`
    函数的工作原理就像开枪一样。我们从一个位置（枪口点的位置）开始，指向一个特定的方向（相对于枪口点的正向），然后获取被击中的物体。如果我们击中了某个物体，`if`
    语句的结果为真；否则为假，我们会跳过。当我们击中某个物体时，我们首先将我们的目标点移动到被击中的点。然后我们使用 `SendMessage` 函数通知被击中的物体它已被击中。`SendMessage`
    函数仅适用于 `GameObjects` 和 `MonoBehaviours`，而我们的 `Target` 脚本位于目标根对象上，因此使用 `hit.transform.root.gameObject`
    来获取被击中的 `GameObject`。`SendMessage` 函数接受一个函数的名称，并尝试在发送消息的 `GameObject` 上找到该函数。我们还提供了一个值，`hit.point`，以提供给应该找到的函数。`SendMessageOptions.DontRequireReceiver`
    这行代码的目的是防止函数在无法找到所需函数时抛出错误。我们 `Fire` 函数的最后一部分发生在我们没有击中任何物体的情况下。我们将目标点送回到世界原点，这样玩家就可以知道他们错过了所有物体。'
- en: '[PRE32]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The last thing to do is to add the `Hit` function to the end of our `Target`
    script. We start the function by getting the current state ID, just as we did
    earlier in the script. However, this time we check only against our extended idle
    ID. If they do not match, we use return to exit the function early. We do this
    because we don't want to let the player shoot any targets that are down or in
    mid transition. If our state is correct, we continue by telling the animation
    that we were hit using the `SetBool` function.
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要做的事情是将 `Hit` 函数添加到我们的 `Target` 脚本末尾。我们像在脚本中之前做的那样，首先获取当前状态 ID。然而，这次我们只检查扩展的空闲
    ID。如果它们不匹配，我们使用 `return` 退出函数。我们这样做是因为我们不希望让玩家射击任何倒下或处于过渡中的目标。如果我们的状态正确，我们继续通过使用
    `SetBool` 函数告诉动画我们被击中。
- en: '[PRE33]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The rest of the `Hit` function figures out which side the target was hit on.
    To do this, we first had to convert the point that we received from world space
    into local space. The `InverseTransformPoint` function from our **Transform**
    component does this nicely. We then do a check to see where the shot came from.
    Because of the way the target is constructed, if the shot was positive on the
    x axis, it came from behind. Otherwise, it came from the front. Either way, we
    set the `inTheFront` parameter from our state machine to the proper value. Then
    we give the player some points by incrementing the static variable that we created
    on our `ScoreCounter` script, way back at the beginning of the chapter.
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Hit`函数的其余部分负责确定目标被击中的哪一侧。为此，我们首先需要将我们从世界空间收到的点转换为局部空间。我们**Transform**组件中的`InverseTransformPoint`函数很好地完成了这项工作。然后我们检查射击的来源。由于目标的结构方式，如果射击在x轴上是正的，那么它来自后方。否则，它来自前方。无论哪种情况，我们都将状态机中的`inTheFront`参数设置为适当的值。然后我们通过增加我们在本章开头创建的`ScoreCounter`脚本中的静态变量来给玩家一些分数。'
- en: '[PRE34]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Finally, be sure to add the new `FireControls` script to the tank. Also, you
    need to connect the references to the `MuzzelPoint` and `TargetPoint` objects.
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，务必将新的`FireControls`脚本添加到坦克中。同时，你需要连接到`MuzzelPoint`和`TargetPoint`对象的引用。
- en: '*What just happened?*'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a script that allows us to fire the cannon of our tank. The method
    of using ray tracing is the simplest and most widely used. In general, bullets
    fly too fast for us to see them. Ray tracing is like this, that is; it is instant.
    However, this method does not take gravity, or anything else that might change
    the direction of a bullet, into account.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个脚本，允许我们发射坦克的大炮。使用光线追踪的方法是最简单也是最广泛使用的。一般来说，子弹飞得太快，我们看不到它们。光线追踪就是这样，即；它是瞬间的。然而，这种方法并没有考虑到重力，或者任何可能改变子弹方向的其它因素。
- en: Have a go hero – better GUI
  id: totrans-372
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄 - 更好的GUI
- en: Now that all of the buttons and components are in place, make them look better.
    Use the skills you gained from the previous chapter to style the GUI and make
    it great. Perhaps you could even manage to create a directional pad for the movement.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有的按钮和组件都已经就位，让它们看起来更好。使用你在上一章中学到的技能来设计GUI，使其变得出色。也许你甚至可以创建一个方向垫来控制移动。
- en: Summary
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: And, that is it! The chapter was long and we learned a lot. We imported meshes
    and set up a tank. We created materials so that color could be added to a city.
    We also animated some targets and learned how to shoot them down. It was a lot
    and it is time for a break. Play the game, shoot some targets, and gather those
    points. The project is all done and ready to be built to your device of choice.
    The build process is the same as both of the previous projects, so have fun!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！这一章很长，我们学到了很多。我们导入了网格并设置了一个坦克。我们创建了材质，以便为城市添加颜色。我们还对一些目标进行了动画处理，并学习了如何击落它们。内容很多，现在是休息的时候了。玩游戏，射击目标，并收集那些分数。项目已经全部完成，准备好构建到你的设备上了。构建过程与之前的两个项目相同，所以享受乐趣吧！
- en: The next chapter is about special camera effects and lighting. We will be learning
    about lights and their types. Our Tank Battle game will expand through the addition
    of a skybox and several lights. We will also take a look at distance fog. With
    the addition of shadows and lightmaps, the city we will battle in really starts
    to become interesting and dynamic.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍特殊相机效果和照明。我们将学习关于灯光及其类型的内容。我们的坦克战斗游戏将通过添加天空盒和几个灯光来扩展。我们还将查看距离雾。随着阴影和光照贴图的添加，我们将战斗的城市开始变得有趣和动态。
