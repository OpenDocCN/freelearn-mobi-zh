- en: '16'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '16'
- en: Concurrency and Parallelism in Swift
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 中的并发和并行
- en: When I first started learning Objective-C, I already had a good understanding
    of concurrency and multitasking with my background in other languages, such as
    C and Java. This background made it very easy for me to create multithreaded applications
    using threads. Then, Apple changed everything when they released **Grand Central
    Dispatch** (**GCD**) with OS X 10.6 and iOS 4\. At first, I went into denial;
    there was no way GCD could manage my application's threads better than I could.
    Then, I entered the anger phase; GCD was hard to use and understand. Next was
    the bargaining phase; maybe I could use GCD with my threading code, so I could
    still control how the threading worked. Then, there was the depression phase;
    maybe GCD does handle threading better than I could. Finally, I entered the wow
    phase; this GCD thing is really easy to use and works amazingly well.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当我刚开始学习 Objective-C 时，我已经对其他语言（如 C 和 Java）中的并发和多任务处理有了很好的理解。这个背景使我能够很容易地使用线程创建多线程应用程序。然后，当苹果在
    OS X 10.6 和 iOS 4 中发布 **Grand Central Dispatch** （**GCD**）时，一切发生了改变。起初，我陷入了否认；GCD
    根本不可能比我更好地管理我的应用程序的线程。然后，我进入了愤怒阶段；GCD 难以使用和理解。接下来是讨价还价阶段；也许我可以使用 GCD 和我的线程代码，这样我仍然可以控制线程的工作方式。然后，是抑郁阶段；也许
    GCD 确实比我更好地处理线程。最后，我进入了哇哦阶段；这个 GCD 真的很容易使用，并且工作得非常出色。
- en: After using GCD and operation queues with Objective-C, I do not see a reason
    for using manual threads with Swift.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 GCD 和操作队列进行 Objective-C 开发后，我看不到使用 Swift 中的手动线程的理由。
- en: 'In this chapter, we will learn about the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: The basics of concurrency and parallelism
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发和并行的基础知识
- en: How to use GCD to create and manage concurrent dispatch queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GCD 创建和管理并发调度队列
- en: How to use GCD to create and manage serial dispatch queues
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GCD 创建和管理串行调度队列
- en: How to use various GCD functions to add tasks to the dispatch queues
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用各种 GCD 函数将任务添加到调度队列中
- en: How to use `Operation` and `OperationQueues` to add concurrency to our applications
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `Operation` 和 `OperationQueues` 为我们的应用程序添加并发
- en: We have not seen a lot of improvement with regards to concurrency in the Swift
    language over the course of Swift 5.x. It does appear that this will change in
    the future as concurrency improvements are one of the main goals of Swift 6\.
    Let's start off by looking at the difference between concurrency and parallelism,
    one that is important to understand.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 5.x 的整个过程中，我们在 Swift 语言中的并发方面并没有看到太多的改进。但似乎这将在未来改变，因为并发改进是 Swift 6 的主要目标之一。让我们首先看看并发和并行之间的区别，这是理解的重要之处。
- en: Concurrency and parallelism
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发和并行
- en: '**Concurrency** is the concept of multiple tasks starting, running, and completing
    within the same time period. This does not necessarily mean that the tasks are
    executing simultaneously. In fact, in order for tasks to be run simultaneously,
    our application needs to be running on a multicore or multiprocessor system. Concurrency
    allows us to share the processor or cores for multiple tasks; however, a single
    core can only execute one task at a given time.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发** 是指在相同的时间段内，多个任务开始、运行和完成的概念。这并不一定意味着任务正在同时执行。实际上，为了使任务能够同时执行，我们的应用程序需要在多核或多处理器系统上运行。并发使我们能够为多个任务共享处理器或核心；然而，单个核心在任何给定时间只能执行一个任务。'
- en: '**Parallelism** is the concept of two or more tasks running simultaneously.
    Since each core of our processor can only execute one task at a time, the number
    of tasks executing simultaneously is limited to the number of cores within our
    processors and the number of processors that we have. As an example, if we have
    a four-core processor, then we are limited to running four tasks simultaneously.
    Today''s processors can execute tasks so quickly that it may appear that larger
    tasks are executing simultaneously. However, within the system, the larger tasks
    are actually taking turns executing subtasks on the cores.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**并行** 是指两个或更多任务同时运行的概念。由于我们的处理器的每个核心一次只能执行一个任务，因此同时执行的任务数量受限于处理器中的核心数量和我们拥有的处理器数量。例如，如果我们有一个四核处理器，那么我们同时运行的任务数量将受到限制为四个。今天的处理器可以如此快速地执行任务，以至于看起来更大的任务似乎是在同时执行。然而，在系统中，较大的任务实际上是在核心上轮流执行子任务。'
- en: In order to understand the difference between concurrency and parallelism, let's
    look at how a juggler juggles balls. If you watch a juggler, it seems they are
    catching and throwing multiple balls at any given time; however, a closer look
    reveals that they are, in fact, only catching and throwing one ball at a time.
    The other balls are in the air waiting to be caught and thrown. If we want to
    be able to catch and throw multiple balls simultaneously, we need to have multiple
    jugglers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解并发和并行之间的区别，让我们看看杂技演员是如何抛接球的。如果你观察一个杂技演员，他们似乎在任何时候都能同时接住和抛出多个球；然而，仔细观察会发现，他们实际上每次只接住和抛出一个球。其他球在空中等待被接住和抛出。如果我们想能够同时接住和抛出多个球，我们需要有多个杂技演员。
- en: This example is really good because we can think of jugglers as the cores of
    a processor. A system with a single-core processor (one juggler), regardless of
    how it seems, can only execute one task (catch or throw one ball) at a time. If
    we want to execute more than one task at a time, we need to use a multicore processor
    (more than one juggler).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常好，因为我们可以把杂技演员看作是处理器的核心。单核处理器的系统（一个杂技演员），无论看起来如何，一次只能执行一个任务（接住或抛出一个球）。如果我们想一次执行多个任务，我们需要使用多核处理器（多个杂技演员）。
- en: Back in the days when all of the processors were single-core, the only way to
    have a system that executed tasks simultaneously was to have multiple processors
    in the system. This also required specialized software to take advantage of the
    multiple processors. In today's world, just about every device has a processor
    that has multiple cores, and both iOS and macOS are designed to take advantage
    of these multiple cores to run tasks simultaneously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有处理器都是单核的时代，要有一个能够同时执行任务的系统，唯一的方法是在系统中拥有多个处理器。这也需要专门的软件来利用多个处理器。在当今世界，几乎每个设备都有一个拥有多个核心的处理器，iOS
    和 macOS 都被设计用来利用这些多个核心来同时运行任务。
- en: Traditionally, the way applications added concurrency was to create multiple
    threads; however, this model does not scale well to an arbitrary number of cores.
    The biggest problem with using threads was that our applications ran on a variety
    of systems (and processors), and in order to optimize our code, we needed to know
    how many cores/processors could be efficiently used at a given time, which is
    usually not known at the time of development.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序通过创建多个线程来添加并发性；然而，这种模型在任意数量的核心上扩展性不好。使用线程的最大问题是我们的应用程序运行在各种各样的系统（和处理器的）上，为了优化我们的代码，我们需要知道在给定时间可以高效使用多少核心/处理器，这通常在开发时是未知的。
- en: To solve this problem, many operating systems, including iOS and macOS, started
    relying on asynchronous functions. These functions are often used to initiate
    tasks that could possibly take a long time to complete, such as making an HTTP
    request or writing data to disk. An asynchronous function typically starts a long-running
    task and then returns prior to the task's completion. Usually, this task runs
    in the background and uses a callback function (such as a closure in Swift) when
    the task completes.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，许多操作系统，包括 iOS 和 macOS，开始依赖异步函数。这些函数通常用于启动可能需要很长时间才能完成的任务，例如发起 HTTP
    请求或写入磁盘数据。异步函数通常在任务完成之前启动一个长时间运行的任务，并返回。通常，这个任务在后台运行，并在任务完成时使用回调函数（例如 Swift 中的闭包）。
- en: 'These asynchronous functions work great for the tasks that the operating system
    provides them for, but what if we need to create our own asynchronous functions
    and do not want to manage the threads ourselves? For this, Apple provides a couple
    of technologies. In this chapter, we will be covering two of these: GCD and operation
    queues.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异步函数对于操作系统提供的任务来说效果很好，但如果我们需要创建自己的异步函数而不想自己管理线程怎么办？为此，Apple 提供了一些技术。在本章中，我们将介绍其中两种：GCD
    和操作队列。
- en: GCD is a low-level, C-based API that allows specific tasks to be queued up for
    execution and schedules the execution on any of the available processor cores.
    Operation queues are similar to GCD; however, they are Foundation objects and
    are internally implemented using GCD.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 是一个基于 C 的低级 API，它允许将特定任务排队以供执行，并在任何可用的处理器核心上调度执行。操作队列与 GCD 类似；然而，它们是 Foundation
    对象，并且内部使用 GCD 实现。
- en: Let's begin by looking at GCD.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看最大公约数（GCD）开始。
- en: Grand Central Dispatch (GCD)
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大中枢调度（Grand Central Dispatch, GCD）
- en: Prior to Swift 3, using GCD felt like writing low-level C code. The API was
    a little cumbersome and sometimes hard to understand because it did not use any
    of the Swift language design features. This all changed with Swift 3 because Apple
    took up the task of rewriting the API so it would meet the Swift 3 API guidelines.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 之前，使用 GCD 感觉像是编写低级 C 代码。API 有点笨拙，有时难以理解，因为它没有使用 Swift 语言设计中的任何特性。这一切都在
    Swift 3 中发生了变化，因为苹果承担了重写 API 的任务，以便它符合 Swift 3 API 指南。
- en: GCD provides what is known as dispatch queues to manage submitted tasks. The
    queues manage these submitted tasks and execute them in a **First-In, First-Out**
    (**FIFO**) order. This ensures that the tasks are started in the order they were
    submitted.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 提供了所谓的调度队列来管理提交的任务。队列管理这些提交的任务，并以**先进先出**（**FIFO**）的顺序执行它们。这确保了任务是以提交的顺序启动的。
- en: A task is simply some work that our application needs to perform. For example,
    we can create tasks that perform simple calculations, read/write data to disk,
    make an HTTP request, or anything else that our application needs to do. We define
    these tasks by placing the code inside either a function or a closure and adding
    it to a dispatch queue.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 任务只是我们应用程序需要执行的一些工作。例如，我们可以创建执行简单计算、读写磁盘数据、发起 HTTP 请求或我们应用程序需要做的任何其他任务的作业。我们通过将代码放在函数或闭包中并将它们添加到调度队列中来定义这些任务。
- en: 'GCD provides three types of dispatch queues:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 提供了三种类型的调度队列：
- en: '**Serial queues**: Tasks in a serial queue (also known as a **private queue**)
    are executed one at a time in the order they were submitted. Each task is started
    only after the preceding task is completed. Serial queues are often used to synchronize
    access to specific resources because we are guaranteed that no two tasks in a
    serial queue will ever run simultaneously. Therefore, if the only way to access
    the specific resource is through the tasks in the serial queue, then no two tasks
    will attempt to access the resource at the same time or out of order.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行队列**：串行队列中的任务（也称为**私有队列**）按提交的顺序一次执行一个。只有在前一个任务完成后，才会启动每个任务。串行队列通常用于同步访问特定资源，因为我们保证串行队列中的两个任务永远不会同时运行。因此，如果访问特定资源的唯一方式是通过串行队列中的任务，那么两个任务将不会同时或顺序错误地尝试访问资源。'
- en: '**Concurrent queues**: Tasks in a concurrent queue (also known as a **global
    dispatch queue**) execute concurrently; however, the tasks are still started in
    the order that they were added to the queue. The exact number of tasks that can
    be executed at any given instance is variable and is dependent on the system''s
    current conditions and resources. The decision of when to start a task is up to
    GCD and is not something that we can control within our application.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发队列**：并发队列中的任务（也称为**全局调度队列**）是并发执行的；然而，任务的启动顺序仍然是它们被添加到队列中的顺序。在任何给定时刻可以执行的任务的确切数量是可变的，并且取决于系统的当前条件和资源。何时启动任务的决定权在
    GCD，而不是我们可以在应用程序内部控制的事情。'
- en: '**Main dispatch queue**: The main dispatch queue is a globally available serial
    queue that executes tasks on the application''s main thread. Since tasks put into
    the main dispatch queue run on the main thread, it is usually called from a background
    queue when some background processing has finished and the user interface needs
    to be updated.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主调度队列**：主调度队列是一个全局可用的串行队列，它在应用程序的主线程上执行任务。由于放入主调度队列的任务在主线程上运行，因此它通常在后台处理完成并且用户界面需要更新时从后台队列中调用。'
- en: Dispatch queues offer several advantages over traditional threads. The first
    and foremost advantage is that, with dispatch queues, the system handles the creation
    and management of threads rather than the application itself. The system can scale
    the number of threads dynamically, based on the overall available resources of
    the system and the current system conditions. This means that dispatch queues
    can manage the threads with greater efficiency than we could.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 调度队列相对于传统线程提供了几个优势。首要的优势是，使用调度队列时，系统处理线程的创建和管理，而不是应用程序本身。系统可以根据系统的总体可用资源和当前系统条件动态地调整线程的数量。这意味着调度队列可以比我们更有效地管理线程。
- en: Another advantage of dispatch queues is that we are able to control the order
    in which the tasks are started. With serial queues, not only do we control the
    order in which tasks are started, but we also ensure that one task does not start
    before the preceding one is complete. With traditional threads, this can be very
    cumbersome and brittle to implement, but with dispatch queues, as we will see
    later in this chapter, it is quite easy.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 调度队列的另一个优点是我们能够控制任务启动的顺序。对于串行队列，我们不仅控制任务启动的顺序，而且还确保在先前的任务完成之前不会启动另一个任务。使用传统的线程，这可能会非常繁琐且难以实现，但正如我们将在本章后面看到的那样，使用调度队列则相当容易。
- en: Calculation types
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算类型
- en: 'Before we look at how to use dispatch queues, let''s create a class that will
    help us to demonstrate how the various types of queues work. This class will contain
    two basic functions and we will name the class `DoCalculations`. The first function
    will simply perform some basic calculations and then return a value. Here is the
    code for this function, which is named `doCalc()`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '在我们查看如何使用调度队列之前，让我们创建一个类来帮助我们演示各种队列类型的工作原理。这个类将包含两个基本函数，我们将这个类命名为 `DoCalculations`。第一个函数将简单地执行一些基本计算，然后返回一个值。以下是这个函数的代码，该函数名为
    `doCalc()`:'
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other function, which we will name `performCalculation()`, accepts two
    parameters. One is an integer named `iterations` and the other is a string named
    `tag`. The `performCalculation()` function calls the `doCalc()` function repeatedly
    until it calls the function the same number of times as defined by the `iterations`
    parameter. We also use the `CFAbsoluteTimeGetCurrent()` function to calculate
    the elapsed time it took to perform all of the iterations, and then we print the
    elapsed time with the `tag` string to the console. This will let us know when
    the function completes and how long it took to complete it. Here is the code for
    this function:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个函数，我们将命名为 `performCalculation()`，接受两个参数。一个是名为 `iterations` 的整数，另一个是名为 `tag`
    的字符串。`performCalculation()` 函数重复调用 `doCalc()` 函数，直到它调用的次数与 `iterations` 参数定义的次数相同。我们还使用
    `CFAbsoluteTimeGetCurrent()` 函数来计算执行所有迭代所需的时间，然后我们使用 `tag` 字符串将经过的时间打印到控制台。这将让我们知道函数何时完成以及完成它所需的时间。以下是这个函数的代码：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These functions will be used together to keep our queues busy, so we can see
    how they work. Let's begin by looking at how we would create a dispatch queue.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将一起使用，以使我们的队列保持忙碌，这样我们就可以看到它们是如何工作的。让我们首先看看我们如何创建一个调度队列。
- en: Creating queues
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建队列
- en: 'We use the `DispatchQueue` initializer to create a new dispatch queue. The
    following code shows how we would create a new dispatch queue:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `DispatchQueue` 初始化器来创建一个新的调度队列。以下代码展示了我们如何创建一个新的调度队列：
- en: '[PRE2]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The first line would create a concurrent queue with a label of `cqueue.hoffman.jon`,
    while the second line would create a serial queue with a label of `squeue.hoffman.jon`.
    The `ispatchQueue` initializer takes the following parameters:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将创建一个带有标签 `cqueue.hoffman.jon` 的并发队列，而第二行将创建一个带有标签 `squeue.hoffman.jon` 的串行队列。`DispatchQueue`
    初始化器接受以下参数：
- en: '`label`: This is a string label that is attached to the queue to uniquely identify
    it in debugging tools, such as instruments and crash reports. It is recommended
    that we use a reverse DNS naming convention. This parameter is optional and can
    be `nil`.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这是一个字符串标签，它附加到队列上，以在调试工具（如仪器和崩溃报告）中唯一标识它。建议我们使用反向DNS命名约定。此参数是可选的，可以是
    `nil`。'
- en: '`attributes`: This specifies the type of queue to make. This can be `DispatchQueue.Attributes.serial`,
    `DispatchQueue.Attributes.concurrent`, or `nil`. If this parameter is `nil`, a
    serial queue is created. You can use `.serial` or `.concurrent` as we showed in
    the sample code.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attributes`: 这指定了要创建的队列类型。这可以是 `DispatchQueue.Attributes.serial`、`DispatchQueue.Attributes.concurrent`
    或 `nil`。如果这个参数是 `nil`，则创建一个串行队列。您可以使用 `.serial` 或 `.concurrent`，就像我们在示例代码中所展示的那样。'
- en: Some programming languages use the reverse DNS naming convention to name certain
    components. This convention is based on a registered domain name that is reversed.
    As an example, if we worked for a company that had a domain name of `mycompany.com`
    with a product called widget, the reverse DNS name would be `com.mycompany.widget`.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用反向DNS命名约定来命名某些组件。这个约定基于一个注册的域名，并将其反转。例如，如果我们为一家名为 `mycompany.com` 的公司工作，该公司有一个名为
    widget 的产品，那么反向DNS名称将是 `com.mycompany.widget`。
- en: Let's now look at how we can create and use concurrent queues.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看我们如何创建和使用并发队列。
- en: Creating and using a concurrent queue
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用并发队列
- en: 'A concurrent queue will execute tasks in a FIFO order; however, the tasks will
    execute concurrently and finish in any order. Let''s see how we would create and
    use a concurrent queue. The following line will create the concurrent queue that
    we will be using for this section and will also create an instance of the `DoCalculations`
    type that will be used to test the queue:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 并发队列将按照FIFO顺序执行任务；然而，任务将并发执行并按任意顺序完成。让我们看看我们如何创建和使用一个并发队列。以下行将创建我们将用于本节的并发队列，并将创建一个`DoCalculations`类型的实例，该实例将用于测试队列：
- en: '[PRE3]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first line will create a new dispatch queue that we will name `cqueue`,
    and the second line creates an instance of the `DoCalculations` type. Now, let''s
    see how we would use our concurrent queue by using the `performCalculation()`
    method from the `DoCalculations` type to perform some calculations:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将创建一个新的调度队列，我们将命名为`cqueue`，第二行创建一个`DoCalculations`类型的实例。现在，让我们看看我们如何使用并发队列，通过使用`DoCalculations`类型的`performCalculation()`方法来执行一些计算：
- en: '[PRE4]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the preceding code, we created a closure, which represents our task and simply
    calls the `performCalculation()` function of the `DoCalculation` instance, requesting
    that it runs through 1,000 iterations of the `doCalc()` function. Finally, we
    use the `async(execute:)` method of our queue to execute it. This code will execute
    the task in a concurrent dispatch queue, which is separate from the main thread.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个闭包，它代表我们的任务，并简单地调用`DoCalculation`实例的`performCalculation()`函数，请求它运行`doCalc()`函数的1,000次迭代。最后，我们使用队列的`async(execute:)`方法来执行它。此代码将在并发调度队列中执行任务，该队列与主线程分开。
- en: 'While the preceding example works perfectly, we can actually shorten the code
    a little bit. The next example shows that we do not need to create a separate
    closure as we did in the preceding example. We can also submit the task to execute,
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然前面的例子工作得很好，但实际上我们可以稍微缩短代码。下一个例子显示，我们实际上不需要像前面例子中那样创建一个单独的闭包。我们也可以像下面这样提交任务来执行：
- en: '[PRE5]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This shorthand version is how we usually submit small code blocks to our queues.
    If we have larger tasks or tasks that we need to submit multiple times, we will
    generally want to create a closure and submit the closure to the queue as we showed
    in the first example.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写版本是我们通常向队列提交小代码块的方式。如果我们有更大的任务或需要多次提交的任务，我们通常希望创建一个闭包，并将闭包提交到队列中，就像我们在第一个例子中展示的那样。
- en: Let's see how a concurrent queue works by adding several items to the queue
    and looking at the order and time that they return. The following code will add
    three tasks to the queue. Each task will call the `performCalculation()` function
    with various iteration counts.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向队列中添加几个项目并查看它们的返回顺序和时间来了解并发队列的工作方式。以下代码将向队列中添加三个任务。每个任务将使用不同的迭代计数调用`performCalculation()`函数。
- en: 'Remember that the `performCalculation()` function will execute the calculation
    routine continuously until it is executed the number of times defined by the iteration
    count passed in. Therefore, the larger the iteration count we pass into the function,
    the longer it should take to execute. Let''s look at the following code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，`performCalculation()`函数将连续执行计算例程，直到执行了传入的迭代次数。因此，我们传入函数的迭代计数越大，它应该执行的时间就越长。让我们看看以下代码：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that each of the functions is called with a different value in the `tag`
    parameter. Since the `performCalculation()` function prints out the `tag` variable
    with the elapsed time, we can see the order in which the tasks complete and the
    time they took to execute. If we execute the preceding code, we should see results
    similar to this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个函数在`tag`参数中调用时都使用不同的值。由于`performCalculation()`函数会打印出带有经过时间的`tag`变量，我们可以看到任务完成的顺序以及它们执行所需的时间。如果我们执行前面的代码，我们应该看到类似以下的结果：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The elapsed time will vary from one run to the next and from system to system.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 经过的时间会因运行而异，也会因系统而异。
- en: Since the queues function in a FIFO order, the task that had the tag of `async1`
    was executed first. However, as we can see from the results, it was the last task
    to finish. Since this is a concurrent queue, if it is possible (if the system
    has the available resources), the blocks of code will execute concurrently. This
    is why tasks with the tags of `async2` and `async3` completed prior to the task
    that had the `async1` tag, even though the execution of the `async1` task began
    before the other two.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列按照FIFO（先进先出）的顺序工作，具有`async1`标签的任务首先被执行。然而，从结果中我们可以看到，它是最后一个完成的任务。由于这是一个并发队列，如果可能的话（如果系统有可用资源），代码块将并发执行。这就是为什么带有`async2`和`async3`标签的任务在带有`async1`标签的任务之前完成，尽管`async1`任务的执行在其他两个任务之前开始。
- en: Now, let's see how a serial queue executes tasks.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看一个串行队列是如何执行任务的。
- en: Creating and using a serial queue
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和使用串行队列
- en: 'A serial queue functions a little differently to a concurrent queue. A serial
    queue will only execute one task at a time and will wait for one task to complete
    before starting the next one. This queue, like the concurrent dispatch queue,
    follows the FIFO order. The following line of code will create a serial queue
    that we will be using for this section and will create an instance of the `DoCalculations`
    type:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 串行队列与并发队列的工作方式略有不同。串行队列一次只执行一个任务，并在开始下一个任务之前等待当前任务完成。这个队列，就像并发调度队列一样，遵循FIFO顺序。以下代码行将创建我们将用于本节的串行队列，并将创建一个`DoCalculations`类型的实例：
- en: '[PRE8]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The first line will create a new serial dispatch queue that we name `squeue`,
    and the second line creates an instance of the `DoCalculations` type. Now, let''s
    see how we would use our serial queue by using the `performCalculation()` method
    from the `DoCalculations` type to perform some calculations:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行将创建一个新的名为`squeue`的串行调度队列，第二行创建一个`DoCalculations`类型的实例。现在，让我们看看我们如何使用我们的串行队列，通过使用`DoCalculations`类型的`performCalculation()`方法来执行一些计算：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we created a closure, which represents our task, that
    simply calls the `performCalculation()` function of the `DoCalculation` instance,
    requesting that it runs through 1,000 iterations of the `doCalc()` function. Finally,
    we use the `async(execute:)` method of our queue to execute it. This code will
    execute the task in a serial dispatch queue, which is separate from the main thread.
    As we can see from this code, we use the serial queue exactly like we use the
    concurrent queue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个闭包，它代表我们的任务，简单地调用`DoCalculation`实例的`performCalculation()`函数，请求它运行`doCalc()`函数的1,000次迭代。最后，我们使用队列的`async(execute:)`方法来执行它。此代码将在一个串行调度队列中执行任务，该队列与主线程分开。从这段代码中我们可以看到，我们使用串行队列的方式与使用并发队列的方式完全相同。
- en: 'We can shorten this code a little bit, just like we did with the concurrent
    queue. The following example shows how we would do this with a serial queue:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以稍微缩短这段代码，就像我们处理并发队列时做的那样。以下示例展示了我们如何使用串行队列来完成这个操作：
- en: '[PRE10]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s see how the serial queue works by adding several items to the queue
    and looking at the order in which they complete. The following code will add three
    tasks, which will call the `performCalculation()` function with various iteration
    counts to the queue:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向队列中添加几个项目并查看它们完成的顺序来了解串行队列的工作方式。以下代码将添加三个任务到队列中，这些任务将使用不同的迭代次数调用`performCalculation()`函数：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Just as we did in the concurrent queue example, we call the `performCalculation()`
    function with various iteration counts and different values in the `tag` parameter.
    Since the `performCalculation()` function prints out the `tag` string with the
    elapsed time, we can see the order in which the tasks complete and the time it
    takes to execute. If we execute this code, we should see the following results:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在并发队列示例中所做的那样，我们使用不同的迭代次数和不同的`tag`参数值调用`performCalculation()`函数。由于`performCalculation()`函数会打印出带有经过时间的`tag`字符串，我们可以看到任务的完成顺序和执行所需的时间。如果我们执行此代码，我们应该看到以下结果：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The elapsed time will vary from one run to the next and from system to system.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时间会因运行次数和系统而异。
- en: Unlike the concurrent queues, we can see that the tasks completed in the same
    order that they were submitted in, even though the `sync2` and `sync3` tasks took
    considerably less time to complete. This demonstrates that a serial queue only
    executes one task at a time and that the queue waits for each task to complete
    before starting the next one.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 与并发队列不同，我们可以看到任务是以它们提交的顺序完成的，尽管`sync2`和`sync3`任务的完成时间明显更短。这表明串行队列一次只执行一个任务，并且队列在开始下一个任务之前会等待每个任务完成。
- en: In the previous examples, we used the `async` method to execute the code blocks.
    We could also use the `sync` method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了`async`方法来执行代码块。我们也可以使用`sync`方法。
- en: async versus sync
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异步与同步
- en: In the previous examples, we used the `async` method to execute the code blocks.
    When we use the `async` method, the call will not block the current thread. This
    means that the method returns and the code block is executed asynchronously.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的示例中，我们使用了`async`方法来执行代码块。当我们使用`async`方法时，调用将不会阻塞当前线程。这意味着该方法返回，并且代码块是异步执行的。
- en: Rather than using the `async` method, we could use the `sync` method to execute
    the code blocks. The `sync` method will block the current thread, which means
    it will not return until the execution of the code has completed. Generally, we
    use the `async` method, but there are use cases where the `sync` method is useful.
    These use cases are usually when we have a separate thread and we want that thread
    to wait for some work to finish.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是使用`async`方法，我们可以使用`sync`方法来执行代码块。`sync`方法将阻塞当前线程，这意味着它不会返回直到代码执行完成。通常，我们使用`async`方法，但有一些情况下`sync`方法是有用的。这些用例通常是我们有一个单独的线程，并且我们希望该线程等待某些工作完成。
- en: Executing code on the main queue function
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在主队列上执行代码
- en: The `DispatchQueue.main.async(execute:)` function will execute code on the application's
    main queue. We generally use this function when we want to update our code from
    another thread or queue.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatchQueue.main.async(execute:)`函数将在应用程序的主队列上执行代码。我们通常在想要从另一个线程或队列更新我们的代码时使用此函数。'
- en: The main queue is automatically created for the main thread when the application
    starts. This main queue is a serial queue; therefore, items in this queue are
    executed one at a time, in the order that they were submitted. We will generally
    want to avoid using this queue unless we have a need to update the user interface
    from a background thread.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序启动时，会自动为主线程创建主队列。这个主队列是一个串行队列；因此，队列中的项目将按它们提交的顺序一次执行一个。我们通常希望避免使用此队列，除非我们有必要从后台线程更新用户界面。
- en: 'The following code example shows how we would use this function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例显示了我们将如何使用此函数：
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the previous code, we assume that we have added a method to the `UIImage`
    type that will resize the image. In this code, we create a new serial queue and,
    in that queue, we resize an image. This is a good example of how to use a dispatch
    queue because we would not want to resize an image on the main queue since it
    would freeze the UI while the image is being resized. Once the image is resized,
    we then need to update `UIImageView` with the new image; however, all updates
    to the UI need to occur on the main thread. Therefore, we will use the `DispatchQueue.main.async`
    function to perform the update on the main queue.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，我们假设我们已经向`UIImage`类型添加了一个方法，该方法将调整图像大小。在这段代码中，我们创建了一个新的串行队列，并在该队列中调整图像大小。这是一个很好的使用调度队列的例子，因为我们不希望在主队列上调整图像大小，因为这会在调整图像大小时冻结UI。一旦图像调整大小，我们就需要使用新的图像更新`UIImageView`；然而，所有对UI的更新都需要在主线程上发生。因此，我们将使用`DispatchQueue.main.async`函数在主队列上执行更新。
- en: There will be times when we need to execute tasks after a delay. If we were
    using a threading model, we would need to create a new thread, perform some sort
    of `delay` or `sleep` function, and execute our task. With GCD, we can use the
    `asyncAfter` function.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 有时会需要延迟执行任务。如果我们使用线程模型，我们需要创建一个新的线程，执行某种`delay`或`sleep`函数，然后执行我们的任务。使用GCD，我们可以使用`asyncAfter`函数。
- en: Using asyncAfter
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用asyncAfter
- en: 'The `asyncAfter` function will execute a block of code asynchronously after
    a given delay. This is very useful when we need to pause the execution of our
    code. The following code sample shows how we would use the `asyncAfter` function:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`asyncAfter`函数将在给定延迟后异步执行代码块。当我们需要暂停代码执行时，这非常有用。以下代码示例显示了我们将如何使用`asyncAfter`函数：'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we begin by creating a serial dispatch queue. We then create an
    instance of the `DispatchTime` type and calculate the time to execute the block
    of code based on the current time. We then use the `asyncAfter` function to execute
    the code block after the delay.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建一个串行调度队列。然后创建一个`DispatchTime`类型的实例，并基于当前时间计算执行代码块所需的时间。接着，我们使用`asyncAfter`函数在延迟后执行代码块。
- en: Now, that we have looked at GCD, let's look at operation queues.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经了解了GCD，让我们来看看操作队列。
- en: Using the Operation and OperationQueue types
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`Operation`和`OperationQueue`类型
- en: The `Operation` and `OperationQueue` types, working together, provide us with
    an alternative to GCD for adding concurrency to our applications. Operation queues
    are part of the Foundation framework and function like dispatch queues as they
    are a higher level of abstraction over GCD.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operation`和`OperationQueue`类型协同工作，为我们提供了在应用程序中添加并发的GCD替代方案。操作队列是Foundation框架的一部分，它们作为GCD的高级抽象，其功能类似于调度队列。'
- en: We define the tasks (operations) that we wish to execute and then add the tasks
    to the operation queue. The operation queue will then handle the scheduling and
    execution of tasks. Operation queues are instances of the `OperationQueue` class
    and operations are instances of the `Operation` class.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义我们希望执行的作业（操作），然后将任务添加到操作队列中。操作队列将随后处理任务的调度和执行。操作队列是`OperationQueue`类的实例，而操作是`Operation`类的实例。
- en: An operation represents a single unit of work or a task. The `Operation` type
    is an abstract class that provides a thread-safe structure for modeling the state,
    priority, and dependencies. This class must be subclassed to perform any useful
    work; we will look at how to subclass this class in the *Subclassing the Operation
    class* section of this chapter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一个操作代表一个单独的工作单元或任务。`Operation`类型是一个抽象类，它提供了一个线程安全的结构来模拟状态、优先级和依赖关系。这个类必须被子类化以执行任何有用的操作；我们将在本章的“子类化`Operation`类”部分中查看如何子类化这个类。
- en: Apple provides a concrete implementation of the `Operation` type that we can
    use as-is for situations where it does not make sense to build a custom subclass.
    This subclass is `BlockOperation`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为我们提供了一个`Operation`类型的具体实现，我们可以直接使用它，在不需要构建自定义子类的情况下。这个子类是`BlockOperation`。
- en: More than one operation queue can exist at the same time, and, in fact, there
    is always at least one operation queue running. This operation queue is known
    as the **main queue**. The main queue is automatically created for the main thread
    when the application starts and is where all of the UI operations are performed.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同时可以存在多个操作队列，实际上，总是至少有一个操作队列在运行。这个操作队列被称为**主队列**。主队列在应用程序启动时自动为主线程创建，并且所有UI操作都在这里执行。
- en: One thing to keep in mind with operation queues is that they add additional
    overhead because they are Foundation objects. For the large majority of applications,
    this little extra overhead should not be an issue or even noticed; however, for
    some projects, such as games that need every last resource that they can get,
    this extra overhead might very well be an issue.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作队列中需要注意的一点是，由于它们是Foundation对象，因此会添加额外的开销。对于大多数应用程序来说，这微小的额外开销不应成为问题，甚至可能不会被注意到；然而，对于一些项目，例如需要尽可能多资源的游戏，这个额外的开销可能确实是一个问题。
- en: There are several ways that we can use the `Operation` and `OperationQueue`
    classes to add concurrency to our application. In this chapter, we will look at
    three of these ways. The first one we will look at is the use of the `BlockOperation`
    implementation of the `Operation` abstract class.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用多种方式将`Operation`和`OperationQueue`类用于向我们的应用程序添加并发。在本章中，我们将探讨这三种方式中的一种。我们将首先查看`Operation`抽象类的`BlockOperation`实现的使用。
- en: Using BlockOperation
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`BlockOperation`
- en: In this section, we will be using the same `DoCalculation` class that we used
    in the *Grand Central Dispatch (GCD)* section to keep our queues busy with work
    so that we can see how the `OperationQueue` class works.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用与*Grand Central Dispatch (GCD)*部分中相同的`DoCalculation`类，以保持我们的队列忙碌于工作，这样我们就可以看到`OperationQueue`类是如何工作的。
- en: The `BlockOperation` class is a concrete implementation of the `Operation` type
    that can manage the execution of one or more blocks. This class can be used to
    execute several tasks at once without the need to create separate operations for
    each task.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlockOperation`类是`Operation`类型的具体实现，它可以管理一个或多个代码块的执行。这个类可以用来同时执行多个任务，而无需为每个任务创建单独的操作。'
- en: 'Let''s see how we can use the `BlockOperation` class to add concurrency to
    our application. The following code shows how to add three tasks to an operation
    queue using a single `BlockOperation` instance:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`BlockOperation`类来为我们的应用程序添加并发性。以下代码展示了如何使用单个`BlockOperation`实例将三个任务添加到操作队列中：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this code, we begin by creating an instance of the `DoCalculation` class
    and an instance of the `OperationQueue` class. Next, we create an instance of
    the `BlockOperation` class using the `init` constructor. This constructor takes
    a single parameter, which is a block of code that represents one of the tasks
    we want to execute in the queue. Next, we add two additional tasks using the `addExecutionBlock()`
    method.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建`DoCalculation`类的一个实例和`OperationQueue`类的一个实例。接下来，我们使用`init`构造函数创建`BlockOperation`类的一个实例。此构造函数接受一个参数，它是一个代码块，代表我们想在队列中执行的任务之一。然后，我们使用`addExecutionBlock()`方法添加两个额外的任务。
- en: One of the differences between dispatch queues and operations is that, with
    dispatch queues, if resources are available, the tasks are executed as they are
    added to the queue. With operations, the individual tasks are not executed until
    the operation itself is submitted to an operation queue. This allows us to initiate
    all of the operations into a single block operation prior to executing them.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 分发队列和操作之间的一个区别是，在分发队列中，如果资源可用，任务将随着它们被添加到队列而执行。在操作中，各个任务不会执行，直到操作本身被提交到操作队列。这允许我们在执行之前将所有操作初始化到一个单独的操作中。
- en: Once we add all of the tasks to the `BlockOperation` instance, we then add the
    operation to the `OperationQueue` instance that we created at the beginning of
    the code. At this point, the individual tasks within the operation start to execute.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有任务添加到`BlockOperation`实例中，我们接着将操作添加到我们在代码开头创建的`OperationQueue`实例中。此时，操作内的各个任务开始执行。
- en: This example shows how to use `BlockOperation` to queue up multiple tasks and
    then pass the tasks to the operation queue. The tasks are executed in a FIFO order;
    therefore, the first task that is added will be the first task executed. However,
    the tasks can be executed concurrently if we have the available resources.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用`BlockOperation`来排队多个任务，然后将任务传递到操作队列。任务按照FIFO（先进先出）的顺序执行；因此，首先添加的任务将是第一个执行的任务。然而，如果我们有可用的资源，任务可以并发执行。
- en: 'The output from this code should look similar to this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出应类似于以下内容：
- en: '[PRE16]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What if we do not want the tasks to run concurrently? What if we wanted them
    to run serially like the serial dispatch queue? We can set a property in the operation
    queue that defines the number of tasks that can be run concurrently in the queue.
    The property is named `maxConcurrentOperationCount`, and is used like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想让任务并发运行呢？如果我们想像串行分发队列一样按顺序运行它们怎么办？我们可以在操作队列中设置一个属性，该属性定义了队列中可以并发运行的任务数量。该属性名为`maxConcurrentOperationCount`，使用方式如下：
- en: '[PRE17]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: However, if we add this line to our previous example, it will not work as expected.
    To see why this is, we need to understand what the property actually defines.
    If we look at Apple's `OperationQueue` class reference, the definition of the
    property is *the maximum number of queued operations that can execute at the same
    time*.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们将此行添加到我们之前的示例中，它将不会按预期工作。为了了解为什么，我们需要理解这个属性实际上定义了什么。如果我们查看苹果的`OperationQueue`类参考，这个属性的定义是*可以同时执行的最大排队操作数量*。
- en: What this tells us is that this property defines the number of operations (this
    is the keyword) that can be executed at the same time. The `BlockOperation` instance,
    which we added all of the tasks to, represents a single operation; therefore,
    no other `BlockOperation` added to the queue will execute until the first one
    is complete, but the individual tasks within the operation will execute concurrently.
    To run the tasks serially, we would need to create a separate instance of `BlockOperation`
    for each task.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，这个属性定义了可以同时执行的操作数量（这是关键词）。我们添加所有任务的`BlockOperation`实例代表一个单一的操作；因此，直到第一个操作完成，队列中不会执行其他添加的`BlockOperation`，但操作内的各个任务可以并发执行。如果我们想按顺序运行任务，我们需要为每个任务创建一个单独的`BlockOperation`实例。
- en: Using an instance of the `BlockOperation` class is good if we have several tasks
    that we want to execute concurrently, but they will not start executing until
    we add the operation to an operation queue. Let's look at a simpler way of adding
    tasks to an operation queue using the `addOperationWithBlock()` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有几个任务想要并发执行，使用`BlockOperation`类的实例是好的，但它们将不会开始执行，直到我们将操作添加到操作队列中。让我们看看如何使用`addOperationWithBlock()`方法以更简单的方式将任务添加到操作队列。
- en: Using the addOperation() method of the operation queue
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用操作队列的`addOperation()`方法
- en: 'The `OperationQueue` class has a method named `addOperation()`, which makes
    it easy to add a block of code to the queue. This method automatically wraps the
    block of code in an operation object and then passes that operation to the queue.
    Let''s see how to use this method to add tasks to a queue:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationQueue`类有一个名为`addOperation()`的方法，这使得将代码块添加到队列变得容易。此方法自动将代码块包装在操作对象中，然后将该操作传递到队列。让我们看看如何使用此方法将任务添加到队列：'
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In the `BlockOperation` example earlier in this chapter, we added the tasks
    that we wished to execute into a `BlockOperation` instance. In this example, we
    are adding the tasks directly to the operation queue, and each task represents
    one complete operation. Once we create the instance of the operation queue, we
    then use the `addOperation()` method to add the tasks to the queue.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面提到的`BlockOperation`例子中，我们将想要执行的任务添加到了`BlockOperation`实例中。在这个例子中，我们将任务直接添加到操作队列中，每个任务代表一个完整的操作。一旦我们创建了操作队列的实例，我们就使用`addOperation()`方法将任务添加到队列。
- en: Also, in the `BlockOperation` example, the individual tasks did not execute
    until all of the tasks were added, and then that operation was added to the queue.
    This example is similar to the GCD example where the tasks began executing as
    soon as they were added to the operation queue.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`BlockOperation`例子中，各个任务在所有任务都添加完毕并且该操作被添加到队列之前不会执行。这个例子与GCD例子相似，其中任务在添加到操作队列后立即开始执行。
- en: 'If we run the preceding code, the output should be similar to this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出应该类似于以下内容：
- en: '[PRE19]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'You will notice that the operations are executed concurrently. With this example,
    we can execute the tasks serially by using the `maxConcurrentOperationCount` property
    that we mentioned earlier. Let''s try this by initializing the `OperationQueue`
    instance as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到操作是并发执行的。通过这个例子，我们可以通过使用前面提到的`maxConcurrentOperationCount`属性来按顺序执行任务。让我们通过以下方式初始化`OperationQueue`实例来尝试这一点：
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, if we run the example, the output should be similar to this:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个例子，输出应该类似于以下内容：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this example, we can see that each task waited for the previous task to complete
    before starting.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们可以看到每个任务都在开始之前等待前一个任务完成。
- en: Using the `addOperation()` method to add tasks to the operation queue is generally
    easier than using the `BlockOperation` method; however, the tasks will begin as
    soon as they are added to the queue. This is usually the desired behavior, although
    there are use cases where we do not want the tasks executing until all operations
    are added to the queue, as we saw in the `BlockOperation` example.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addOperation()`方法将任务添加到操作队列通常比使用`BlockOperation`方法更容易；然而，任务将在它们被添加到队列后立即开始执行。这通常是期望的行为，尽管在某些情况下我们可能不希望任务在所有操作都添加到队列后才开始执行，就像我们在`BlockOperation`例子中看到的那样。
- en: Now, let's look at how we can subclass the `Operation` class to create an operation
    that we can add directly to an operation queue.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何可以继承`Operation`类来创建一个可以直接添加到操作队列的操作。
- en: Subclassing the Operation class
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承`Operation`类
- en: The previous two examples showed how to add small blocks of code to our operation
    queues. In these examples, we called the `performCalculations` method in the `DoCalculation`
    class to perform our tasks. These examples illustrate two really good ways to
    add concurrency for functionality that is already written, but what if, at design
    time, we want to design our `DoCalculation` class itself for concurrency? For
    this, we can subclass the `Operation` class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个例子展示了如何将小块代码添加到我们的操作队列中。在这些例子中，我们调用`DoCalculation`类中的`performCalculations`方法来执行我们的任务。这些例子说明了两种非常好的方法来为已经编写的功能添加并发性，但如果我们希望在设计时为`DoCalculation`类本身设计并发性怎么办？为此，我们可以继承`Operation`类。
- en: The `Operation` abstract class provides a significant amount of infrastructure.
    This allows us to very easily create a subclass without a lot of work. We will
    need to provide at least an initialization method and a `main` method. The `main`
    method will be called when the queue begins executing the operation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operation`抽象类提供了大量的基础设施。这使我们能够非常容易地创建一个子类而不需要做很多工作。我们需要提供一个初始化方法和一个`main`方法。当队列开始执行操作时，将调用`main`方法。'
- en: 'Let''s see how to implement the `DoCalculation` class as a subclass of the
    `Operation` class; we will call this new class `MyOperation`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将`DoCalculation`类作为`Operation`类的子类来实现；我们将这个新类称为`MyOperation`：
- en: '[PRE22]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We begin by defining that the `MyOperation` class is a subclass of the `Operation`
    class. Within the implementation of the class, we define two class constants,
    which represent the iteration count and the tag that the `performCalculations()`
    method uses. Keep in mind that when the operation queue begins executing the operation,
    it will call the `main()` method with no parameters; therefore, any parameters
    that we need to pass it must be passed through initializers.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义`MyOperation`类是`Operation`类的子类。在类的实现中，我们定义了两个类常量，它们代表了`performCalculations()`方法使用的迭代次数和标签。记住，当操作队列开始执行操作时，它将不带参数调用`main()`方法；因此，我们需要传递给它的任何参数都必须通过初始化器传递。
- en: In this example, our initializer takes two parameters that are used to set the
    `iterations` and `tag` class constants. Then, the `main()` method, which the operation
    queue is going to call to begin the execution of the operation, simply calls the
    `performCalculation()` method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的初始化器接受两个参数，用于设置`iterations`和`tag`类常量。然后，操作队列将要调用的`main()`方法，简单地调用`performCalculation()`方法。
- en: 'We can now very easily add instances of our `MyOperation` class to an operation
    queue, as follows:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以非常容易地将我们的`MyOperation`类实例添加到操作队列中，如下所示：
- en: '[PRE23]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'If we run this code, we will see the following results:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到以下结果：
- en: '[PRE24]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: As we saw earlier, we can also execute the tasks serially by setting the `maxConcurrentOperationCount`
    property of the operation queue to `1`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们也可以通过将操作队列的`maxConcurrentOperationCount`属性设置为`1`来串行执行任务。
- en: If we know that we need to execute some functionality concurrently prior to
    writing the code, I would recommend subclassing the `Operation` class, as shown
    in this example, rather than using the previous examples. This gives us the cleanest
    implementation; however, there is nothing wrong with using the `BlockOperation`
    class or the `addOperation()` methods described earlier in this section.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道在编写代码之前需要并发执行某些功能，我建议像这个示例中那样对`Operation`类进行子类化，而不是使用之前的示例。这给我们提供了最干净的实现；然而，使用本节前面描述的`BlockOperation`类或`addOperation()`方法并没有什么不妥。
- en: Before we consider adding concurrency to our application, we should make sure
    that we understand why we are adding it and ask ourselves whether it is necessary.
    While concurrency can make our application more responsive by offloading work
    from our main application thread to a background thread, it also adds extra overhead
    and complexity to our code. I have even seen numerous applications, in various
    languages, which actually ran better after we pulled out some of the concurrency
    code. This is because the concurrency was not well thought out or planned.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在考虑将并发添加到我们的应用程序之前，我们应该确保我们理解为什么要添加它，并问自己这是否必要。虽然并发可以通过将工作从主应用程序线程卸载到后台线程来使我们的应用程序更响应，但它也增加了代码的额外开销和复杂性。我甚至看到过许多在各种语言中运行得更好的应用程序，在移除一些并发代码之后。这是因为并发没有经过深思熟虑或计划。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of this chapter, we had a discussion about running tasks concurrently
    compared to running tasks in parallel. We also discussed the hardware limitations
    that restrict how many tasks can run in parallel on a given device. Having a good
    understanding of these concepts is very important to understanding how and when
    to add concurrency to our projects.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了并发运行任务与并行运行任务的区别。我们还讨论了限制在特定设备上可以并行运行多少任务的硬件限制。对这些概念有良好的理解对于理解何时以及如何将并发添加到我们的项目中非常重要。
- en: We learned about GCD and operation queues, two different ways of implementing
    concurrency. While GCD is not limited to system-level applications, before we
    use it in our application, we should consider whether operation queues would be
    easier and more appropriate for our needs. In general, we should use the highest
    level of abstraction that meets our needs. This will usually point us to using
    operation queues; however, there really is nothing preventing us from using GCD,
    and it may be more appropriate for our needs.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了GCD和操作队列，这两种实现并发的方式。虽然GCD并不局限于系统级应用，但在我们将其应用于我们的应用程序之前，我们应该考虑操作队列是否更容易且更适合我们的需求。一般来说，我们应该使用满足我们需求的最高级别的抽象。这通常会将我们引向使用操作队列；然而，实际上并没有什么阻止我们使用GCD，而且它可能更适合我们的需求。
- en: We should always consider whether it is necessary to add concurrency to our
    applications. It is a good idea to think and talk about concurrency when we are
    discussing an application's expected behavior.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该始终考虑是否需要在我们的应用程序中添加并发。在讨论应用程序的预期行为时思考并讨论并发是一个好主意。
- en: In the next chapter, we will look at some advanced topics and things to consider
    when we are creating our own custom types.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些高级主题以及在我们创建自己的自定义类型时需要考虑的事项。
