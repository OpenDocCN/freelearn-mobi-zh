- en: '*Chapter 9*: Test-Driven Input View in SwiftUI'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*: SwiftUI中的测试驱动输入视图'
- en: In 2019, Apple introduced **SwiftUI** as a new way to build user interfaces
    for apps on Apple platforms. In contrast to user interfaces built with UIKit,
    SwiftUI views are a function of some kind of state. As a result, testing such
    views can be very easy. In a test, we would have to set the state and assert that
    the expected user interface elements are present.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2019年，苹果公司推出了**SwiftUI**作为在苹果平台上构建应用用户界面的新方法。与使用UIKit构建的用户界面相比，SwiftUI视图是某种状态的功能。因此，测试此类视图可以非常简单。在测试中，我们必须设置状态并断言预期的用户界面元素是否存在。
- en: Unfortunately, the engineers in charge at Apple believe that there is no value
    in testing user interfaces. They believe that to prove the user interface looks
    and works as expected, it's enough to run the app and check with your eyes. This
    might be true for an app as simple as the one we are building in this book. But,
    if you have a look in the App Store, you will find most of the apps (if not all)
    are way more complicated. Usually, apps consist of many views and some of them
    are only visible in some rare cases. Ensuring that those views work for all input
    values and environment parameters is a lot of work.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，负责苹果公司的工程师们认为测试用户界面没有价值。他们认为，为了证明用户界面看起来和预期一样，运行应用并检查眼睛就足够了。这可能适用于我们在这本书中构建的如此简单的应用。但是，如果你看看App
    Store，你会发现大多数应用（如果不是所有应用）都要复杂得多。通常，应用由许多视图组成，其中一些只在某些罕见情况下可见。确保这些视图对所有输入值和环境参数都有效是一项大量工作。
- en: Also, think about refactoring. Apps are never finished. We need to change and
    add features all the time. How do engineers make sure that all previous features
    still work?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还要考虑重构。应用永远不会完成。我们总是需要改变和添加功能。工程师们如何确保所有以前的功能仍然有效？
- en: Automatic tests performed by a computer are faster than manual tests by several
    orders of magnitude. In my opinion, engineers not using automatic tests, even
    for user interfaces, wastes time and money.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 由计算机执行的自动测试比人工测试快几个数量级。在我看来，不使用自动测试的工程师，即使是对于用户界面，也是在浪费时间和金钱。
- en: So, what do we do when we want to build a user interface using SwiftUI and still
    rely on the advantages of test-driven development? Fortunately, there is a third-party
    library called **ViewInspector** on GitHub that fills this gap. In this chapter,
    we will add this library to our project and explore how we can write unit tests
    for SwiftUI code.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当我们想使用SwiftUI构建用户界面并仍然依赖测试驱动开发的优势时，我们该怎么办呢？幸运的是，GitHub上有一个名为**ViewInspector**的第三方库，可以填补这一空白。在本章中，我们将把这个库添加到我们的项目中，并探讨我们如何为SwiftUI代码编写单元测试。
- en: 'This chapter is structured into the following sections:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下几部分：
- en: Adding the ViewInspector package
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加ViewInspector包
- en: Using ViewInspector to test a simple view
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ViewInspector测试简单视图
- en: Testing button actions with ViewInspector
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ViewInspector测试按钮动作
- en: Let's start by adding ViewInspector to our test target.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先从将ViewInspector添加到我们的测试目标开始。
- en: Technical requirement
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The source code for this chapter is available here: [https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09).'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码在此处可用：[https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09](https://github.com/PacktPublishing/Test-Driven-iOS-Development-with-Swift-Fourth-Edition/tree/main/chapter09)。
- en: Adding the ViewInspector package
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加ViewInspector包
- en: 'ViewInspector is an open source library that you can find on GitHub: [https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector).
    To add it to our project, follow these steps:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: ViewInspector是一个开源库，你可以在GitHub上找到它：[https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector)。要将它添加到我们的项目中，请按照以下步骤操作：
- en: Select the **File** | **Add Packages** menu item in Xcode.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Xcode中选择**文件** | **添加包**菜单项。
- en: 'Type into the search field the URL of the package, `https://github.com/nalexn/ViewInspector`:'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索字段中输入包的URL，`https://github.com/nalexn/ViewInspector`：
- en: '![Figure 9.1 – Add the ViewInspector package'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 9.1 – 添加ViewInspector包'
- en: '](img/Figure_9.01_B18127.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B18127.jpg)'
- en: Figure 9.1 – Add the ViewInspector package
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 添加ViewInspector包
- en: Click **Add Package**.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**添加包**。
- en: Xcode presents a new window in which we can set the target to which the package
    should be added. Select the **ToDoTests** target. Then click **Add Package** again.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Xcode打开一个新窗口，我们可以设置要添加包的目标。选择**ToDoTests**目标。然后再次点击**添加包**。
- en: The package is now added to the **ToDoTests** target and we can use it in our
    unit tests.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在包已添加到 **ToDoTests** 目标中，我们可以在单元测试中使用它。
- en: Using ViewInspector to test a simple view
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ViewInspector 测试一个简单的视图
- en: The view we are going to build will be used to add new to-do items to the list
    of items. This means it needs input fields for all information a to-do item can
    hold. So, let's look into that aspect in the next subsections.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要构建的视图将用于向项目列表添加新的待办事项。这意味着它需要所有待办事项可以包含的信息的输入字段。因此，让我们在下一小节中查看这个方面。
- en: Adding a title text field
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加标题文本字段
- en: 'As always, we start with the test. Follow these steps to add a text field for
    the title of a to-do item to the input view:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，我们从测试开始。按照以下步骤向输入视图添加一个用于待办事项标题的文本字段：
- en: Select the `ToDoItemInputViewTests`. Remove the two template test methods.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ToDoItemInputViewTests`。删除两个模板测试方法。
- en: 'Import the `ViewInspector` library and the main target (`ToDo`) so that it
    is testable (`@testable`):'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 `ViewInspector` 库和主要目标（`ToDo`），以便它是可测试的（`@testable`）：
- en: '[PRE0]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Before we can write tests for a SwiftUI view, we first need to extend it with
    the `Inspectable` protocol from the `ViewInspector` library. Add the following
    line right above the test case class:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们可以为 SwiftUI 视图编写测试之前，我们首先需要使用来自 `ViewInspector` 库的 `Inspectable` 协议扩展它。在测试用例类上方添加以下行：
- en: '[PRE1]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, Xcode complains that it **Cannot find type 'ToDoItemInputView'
    in scope**. That was expected as we haven't added this type yet.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，Xcode 抱怨它 **在作用域中找不到类型 'ToDoItemInputView'**。这是预期的，因为我们还没有添加这个类型。
- en: 'Select the **ToDo** group in the project navigator and add a SwiftUI file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目导航器中选择 **ToDo** 组并添加一个 SwiftUI 文件：
- en: '![Figure 9.2 – Select the SwiftUI template'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 选择 SwiftUI 模板'
- en: '](img/Figure_9.02_B18127.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B18127.jpg)'
- en: Figure 9.2 – Select the SwiftUI template
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 选择 SwiftUI 模板
- en: 'Put `ToDoItemInputView.swift` in the **Save As** field:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ToDoItemInputView.swift` 放入 **另存为** 字段：
- en: '![Figure 9.3 – The name of the new file is ToDoItemInputView.swift'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.3 – 新文件的名称是 ToDoItemInputView.swift'
- en: '](img/Figure_9.03_B18127.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.03_B18127.jpg)'
- en: Figure 9.3 – The name of the new file is ToDoItemInputView.swift
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 新文件的名称是 ToDoItemInputView.swift
- en: Now, the error in the test code is gone and we can continue with the test.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试代码中的错误已经消失，我们可以继续进行测试。
- en: 'Add a property for the system under test and for the data object holding the
    information for the new to-do item:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为待测系统和包含新待办事项信息的数据对象添加一个属性：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will fill `toDoitemData` with the data the user puts into the view, and when
    they are finished, we will create a `ToDoItem` instance from that data.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将用用户输入到视图中的数据填充 `toDoitemData`，当他们完成时，我们将从该数据创建一个 `ToDoItem` 实例。
- en: Again, Xcode tells us that something is missing.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，Xcode 告诉我们某些东西缺失。
- en: Select the `ToDoItemData` as the name.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `ToDoItemData` 作为名称。
- en: 'Replace the contents of this file with the following code:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换此文件的内容：
- en: '[PRE3]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This new type needs to be the `ObservableObject` type because we want to use
    it as the state of our SwiftUI view.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新类型需要是 `ObservableObject` 类型，因为我们想将其用作我们 SwiftUI 视图的状态。
- en: 'Go back to the `ToDoItemInputViewTests` class and replace `setUpWithError()`
    and `tearDownWithError()` with the following code:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `ToDoItemInputViewTests` 类，将 `setUpWithError()` 和 `tearDownWithError()`
    替换为以下代码：
- en: '[PRE4]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code does not compile, as the initializer of `ToDoItemInputView`
    doesn''t take any arguments. To fix the compilation error, add the following property
    to `ToDoItemInputView`:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码无法编译，因为 `ToDoItemInputView` 的初始化器不接受任何参数。为了修复编译错误，向 `ToDoItemInputView`
    添加以下属性：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, Xcode shows an error in the `ToDoItemInputView_Previews` structure because
    the new property is missing in the initializer of `ToDoItemInputView`. Replace
    the contents of the `ToDoItemInputView_Previews` structure with the following
    code to fix this error:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Xcode 在 `ToDoItemInputView_Previews` 结构中显示了一个错误，因为 `ToDoItemInputView` 的初始化器中缺少新属性。用以下代码替换
    `ToDoItemInputView_Previews` 结构的内容以修复此错误：
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, let''s get back to the test case class. Add the following fragment of
    a test method to `ToDoItemInputViewTests`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们回到测试用例类。将以下测试方法的片段添加到 `ToDoItemInputViewTests` 中：
- en: '[PRE7]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `toDoItemData` type has no `title` property. We will fix this in the next
    step. But first, let's try to understand what is happening here.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`toDoItemData` 类型没有 `title` 属性。我们将在下一步修复它。但首先，让我们尝试理解这里发生了什么。'
- en: First, we call `inspect()` on the system under test (`sut`). This is possible
    because we extended the `ToDoItemInputView` call with conformance to the `Inspectable`
    protocol. On the returned type, we can call the `find` method that returns the
    first instance of the given type, in this case, the `TextField` type. On the value
    that is returned from the `find` call, we call `setInput(_:)` to simulate user
    input to that text field.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们在待测试的系统（`sut`）上调用 `inspect()`。这是因为我们扩展了 `ToDoItemInputView` 的调用以符合 `Inspectable`
    协议。在返回的类型上，我们可以调用 `find` 方法，该方法返回给定类型的第一个实例，在这种情况下，是 `TextField` 类型。在 `find` 调用返回的值上，我们调用
    `setInput(_:)` 来模拟用户对该文本框的输入。
- en: 'Add the following `title` property to `ToDoItemData`:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `ToDoItemData` 添加以下 `title` 属性：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finish the test with the following `Assert` function call:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 `Assert` 函数调用完成测试：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Run the tests to confirm that this new test fails. The test fails in the line
    where we try to find the `TextField` element.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。测试在尝试找到 `TextField` 元素的行中失败。
- en: 'Replace the content of the `body` property in `ToDoItemInputView` with the
    following code:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ToDoItemInputView` 中的 `body` 属性的内容替换为以下代码：
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the tests again. Now all tests pass but we haven't seen the assertion fail.
    The test failed previously because it could not find a `TextField` element in
    the body of the view. Is this a problem? It could be. If we are not careful, we
    could write an assertion that always passes. So, it is a good idea to change the
    code in a way that the assertion fails but the rest of the test passes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行测试。现在所有测试都通过了，但我们还没有看到断言失败。之前的测试失败是因为它无法在视图的主体中找到 `TextField` 元素。这是问题吗？可能是的。如果我们不小心，我们可能会编写一个总是通过的断言。因此，改变代码以使断言失败但其余测试通过是一个好主意。
- en: 'Replace the `ToDoItemInputView` structure with the following code:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `ToDoItemInputView` 结构替换为以下代码：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Here we have added a dummy variable to act as the binding for the text of `TextField`.
    Run the tests to confirm that the last added test now fails at the assertion.
    As we have checked that the assertion can fail, we can change the code so that
    the test passes again.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个虚拟变量来作为 `TextField` 文本的绑定。运行测试以确认最后添加的测试现在在断言处失败。因为我们已经检查了断言可以失败，所以我们可以更改代码，使测试再次通过。
- en: That was easy. With the help of `ViewInspector`, we were able to write a test
    for the input text field of the title for the to-do item.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。在 `ViewInspector` 的帮助下，我们能够为待办事项标题的输入文本字段编写测试。
- en: In the next section, we will add a `DatePicker` structure to allow the user
    to add due dates to to-do items.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加一个 `DatePicker` 结构，以允许用户为待办事项添加截止日期。
- en: Adding a DatePicker
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加日期选择器
- en: The title is the only required data of a to-do item. The date is optional. In
    the user interface of the input view, we want to use a `DatePicker` structure
    for the input of the date value. We will use a toggle to show the `DatePicker`
    structure when the user wants to add a date for that to-do item.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 标题是待办事项的唯一必需数据。日期是可选的。在输入视图的用户界面中，我们希望使用 `DatePicker` 结构来输入日期值。当用户想要为该待办事项添加日期时，我们将使用切换按钮来显示
    `DatePicker` 结构。
- en: 'This means we first need a test that asserts that the view initially doesn''t
    show a date picker. Add the following test method to `ToDoItemInputView`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们首先需要一个测试来断言视图最初不显示日期选择器。向 `ToDoItemInputView` 添加以下测试方法：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With this code, we assert that the code in the parameter of the `XCTAssertThrowsError`
    function throws an error. This means we test that there is no `DatePicker` in
    the view. The test fails if the `find` method finds a `DatePicker`.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们断言 `XCTAssertThrowsError` 函数的参数中的代码抛出错误。这意味着我们测试视图中没有 `DatePicker`。如果
    `find` 方法找到一个 `DatePicker`，则测试失败。
- en: We don't have to do anything to make this test pass. It already passes. We could
    add a `DatePicker` to see it failing. Actually, we will do that next.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要做任何事情来使这个测试通过。它已经通过了。我们可以添加一个 `DatePicker` 来看看它是否会失败。实际上，我们将在下一步做这件事。
- en: 'The toggle element to show and hide the date picker will be bound to a `@State`
    property with the `withDate` property defined in `ToDoItemInputView`. As a result,
    the state of the toggle element will be reflected in the value of the `withDate`
    property. Interacting with a `@State` property from a unit test needs some change
    of the view code. We will start the implementation of the date input with the
    following change:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 用于显示和隐藏日期选择器的切换元素将绑定到一个`@State`属性，该属性在`ToDoItemInputView`中定义了`withDate`属性。因此，切换元素的状态将反映在`withDate`属性的值中。从单元测试中与`@State`属性交互需要更改一些视图代码。我们将从以下更改开始实现日期输入：
- en: 'Replace the `ToDoItemInputView` structure with the following code:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换`ToDoItemInputView`结构：
- en: '[PRE13]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We added here a closure with a `didAppear` name that is called in the `onAppear`
    modifier of the `VStack` structure. We need a `VStack` structure or something
    similar here because, later in these steps, we will add more elements to the body
    of the view.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里添加了一个名为`didAppear`的闭包，它在`VStack`结构的`onAppear`修改器中被调用。我们需要一个`VStack`结构或类似的东西，因为在这些步骤的后面，我们将向视图的主体添加更多元素。
- en: 'With this preparation we can add the first fragment of the test:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这次准备，我们可以添加测试的第一个片段：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We start the test method with an expectation. It is needed here to make updating
    the `@State` property accessible in the test. The reason for that lies in the
    implementation details of view updates in SwiftUI.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以一个期望值开始测试方法。在这里，这是必要的，以便在测试中使`@State`属性的可更新性变得可行。原因在于SwiftUI中视图更新的实现细节。
- en: All the communication with the system under test has to be put into the closure
    of the expectation we define using `sut.on(\.didAppear) {}`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与被测试系统进行的所有通信都必须放入我们使用`sut.on(\.didAppear) {}`定义的期望值的闭包中。
- en: In the closure, we first switch the toggle to make the date picker appear. Next,
    we search for the `DatePicker` and we try to set its date. Then we access the
    date of the `toDoItemDate` property. The test is not finished, but we have to
    pause here because the `Date` property is missing.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭状态下，我们首先切换开关以使日期选择器出现。接下来，我们搜索`DatePicker`并尝试设置其日期。然后我们访问`toDoItemDate`属性的日期。测试尚未完成，但我们必须在这里暂停，因为`Date`属性缺失。
- en: Below the closure, we ask the `ViewInspector` library to host the system under
    test. This triggers the `onAppear` closure and makes working with `@State` properties
    possible. Finally, we have to wait for the expectation to be fulfilled. We don't
    have to call `fulfill()` on the expectation ourselves. This is managed by the
    `ViewInspector` library.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在闭包下方，我们要求`ViewInspector`库托管被测试系统。这触发了`onAppear`闭包，使得与`@State`属性一起工作成为可能。最后，我们必须等待期望得到满足。我们不必自己调用`fulfill()`在期望上。这是由`ViewInspector`库管理的。
- en: 'Go to `ToDoItemData` and add the `Date` property:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`ToDoItemData`并添加`Date`属性：
- en: '[PRE15]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can finish the test by adding the `Assert` function call:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过添加`Assert`函数调用来完成测试：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run all tests to confirm that this new test is failing. It fails because it
    can't find the toggle. Let's add the toggle in the next step.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认这个新测试失败。它失败了，因为它找不到开关。让我们在下一步添加开关。
- en: 'Add the following property for the state of the toggle we are about to add:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们即将添加的切换状态添加以下属性：
- en: '[PRE17]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, replace the contents of the computed `body` property with the following
    code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，用以下代码替换计算属性`body`的内容：
- en: '[PRE18]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now the test fails because it can't find the date picker.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在测试失败了，因为它找不到日期选择器。
- en: 'Add the date picker as follows:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式添加日期选择器：
- en: '[PRE19]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, `test_whenWithDate_shouldAllowDateInput` passes but `test_whenWithoutDate_shouldNotShowDateInput`
    fails. This is a good thing because we haven't seen this test fail until now.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`test_whenWithDate_shouldAllowDateInput`通过了，但`test_whenWithoutDate_shouldNotShowDateInput`失败了。这是好事，因为我们之前从未看到这个测试失败。
- en: 'To make both tests pass, replace the code of the computed `body` property with
    the following:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使两个测试都通过，用以下代码替换计算属性`body`的代码：
- en: '[PRE20]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run all tests to confirm that all tests pass again.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认所有测试再次通过。
- en: In making the last test pass, we learned what we have to do to test changes
    where a `@State` property is involved. This was shown here because you need to
    know this when you start writing tests for SwiftUI views.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在使最后一个测试通过的过程中，我们了解了在涉及`@State`属性更改时我们必须做什么。这是因为当你开始为SwiftUI视图编写测试时，你需要知道这一点。
- en: Now that we have seen how to test changes to `@State` properties, let's refactor
    the test code and the implementation to make both easier to understand.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何测试`@State`属性的更改，让我们重构测试代码和实现，以便两者更容易理解。
- en: Improving the test code and the implementation
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进测试代码和实现
- en: 'For our app, it would be better if we move the `withDate` property to `ToDoItemData`
    because we need this information when we try to create the to-do item. Follow
    these steps to move that property to `ToDoItemData`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，如果我们把 `withDate` 属性移动到 `ToDoItemData` 中会更好，因为当我们尝试创建待办事项时需要这个信息。按照以下步骤将这个属性移动到
    `ToDoItemData`：
- en: 'Go to `ToDoItemInputTests` and replace `test_whenWithDate_shouldAllowDateInput()`
    with the following implementation:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ToDoItemInputTests` 并将 `test_whenWithDate_shouldAllowDateInput()` 替换为以下实现：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run all tests. This test now fails because we can't interact with a `@State`
    property this way.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试。现在这个测试失败了，因为我们不能以这种方式与 `@State` 属性交互。
- en: Delete the `@State var withDate = false` line from `ToDoItemInputView`.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ToDoItemInputView` 中删除 `@State var withDate = false` 这一行。
- en: 'Go to `ToDoItemData` and add the following property:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ToDoItemData` 并添加以下属性：
- en: '[PRE22]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now in `ToDoItemInputView`, replace all occurrences of `withDate` with `data.withDate`:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在 `ToDoItemInputView` 中，将所有 `withDate` 的出现替换为 `data.withDate`：
- en: '[PRE23]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that we have removed the `.onAppear` call below the closing brace of `VStack`.
    As it is not needed anymore, you can also remove the `didAppear` property from
    `ToDoItemInputView`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经从 `VStack` 的闭合大括号下方移除了 `.onAppear` 调用。由于它不再需要，你也可以从 `ToDoItemInputView`
    中移除 `didAppear` 属性。
- en: Run all tests to confirm that all tests now pass again.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认所有测试现在又都通过了。
- en: We now have an input view for the title and the date of a to-do item. Next,
    we need a text field for the item description.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个用于待办事项标题和日期的输入视图。接下来，我们需要一个用于项目描述的文本字段。
- en: Adding another text field
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加另一个文本字段
- en: 'Follow these steps to add another text field to the input view:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤向输入视图添加另一个文本字段：
- en: 'Go to `ToDoItemInputViewTests` and add the following incomplete test method:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ToDoItemInputViewTests` 并添加以下不完整的测试方法：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This looks similar to the test we wrote for the `title` property, but this time
    we have to specify which `TextField` we are searching for. We added a `where`
    closure to find the text field with a `Description` label text. Within the `where`
    closure, we use the inspection capabilities of `ViewInspector` to find the string
    of the text of `labelView` of `TextField`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来与为我们编写的 `title` 属性的测试相似，但这次我们必须指定我们正在搜索哪个 `TextField`。我们添加了一个 `where` 闭包来找到带有
    `Description` 标签文本的文本字段。在 `where` 闭包中，我们使用 `ViewInspector` 的检查功能来找到 `TextField`
    的 `labelView` 的文本字符串。
- en: 'The test does not compile, because the `itemDescription` property is missing
    in `ToDoItemData`. Add the property as shown in the following code:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 测试无法编译，因为 `ToDoItemData` 中缺少 `itemDescription` 属性。按照以下代码添加该属性：
- en: '[PRE25]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we can finish the test. Add the following assertion to the test:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以完成测试。向测试中添加以下断言：
- en: '[PRE26]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Run the tests to confirm that this new test fails.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败了。
- en: 'Go to `ToDoItemInputView` and change the `body` property so that it looks as
    follows:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `ToDoItemInputView` 并更改 `body` 属性，使其看起来如下：
- en: '[PRE27]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Run the tests to confirm that all tests pass.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试都通过了。
- en: Here, we could again change the code to see the assertion of the test fail,
    as we did for the test of the `title` property. As the code and the test code
    look similar, I'm confident in the test without doing that. Think for yourself
    if you would like to see the assertion fail.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以再次修改代码以查看测试断言失败，就像我们对 `title` 属性的测试那样。由于代码和测试代码看起来很相似，我对没有这样做就进行测试很有信心。如果你希望看到断言失败，请自己思考。
- en: To make the test for the `title` property more robust against changes in the
    user interface, add a similar `where` closure to `test_shouldAllowTitleInput`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使对 `title` 属性的测试更加健壮，以抵御用户界面变化，向 `test_shouldAllowTitleInput` 添加一个类似的 `where`
    闭包。
- en: A to-do item can also have a location associated with it. This means we need
    another text field for the location name. You have already seen how to add a text
    field to the input view, so this is left to you as an exercise. Use the `locationName`
    property name in `ToDoItemData` and the `"Location name"` title for the title
    of `TextField`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 待办事项还可以有一个与之关联的位置。这意味着我们需要为位置名称添加另一个文本字段。你已经看到了如何向输入视图添加文本字段，所以这个练习留给你。使用 `ToDoItemData`
    中的 `locationName` 属性和 `"Location name"` 作为 `TextField` 的标题。
- en: Before we move on, let's make the user interface a bit nicer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们让用户界面看起来更美观一些。
- en: Improving the user interface
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 改进用户界面
- en: 'Right now, the text fields and the date picker are structured using a `VStack`
    structure. This is the easiest, but not the prettiest way to do it. The user interface
    of the input view looks like this at the moment:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，文本字段和日期选择器使用的是 `VStack` 结构。这是最简单的方法，但不是最漂亮的方法。输入视图的用户界面目前看起来如下：
- en: '![Figure 9.4 – The user interface of the input view when using a VStack'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.4 – 使用 VStack 时输入视图的用户界面](img/Figure_9.05_B18127.jpg)'
- en: '](img/Figure_9.04_B18127.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.04_B18127.jpg)'
- en: Figure 9.4 – The user interface of the input view when using a VStack
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 使用 VStack 时输入视图的用户界面
- en: 'We can improve the user interface by using `Form` and `Section` structures.
    Replace the `body` property code of `ToDoItemInput` with the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `Form` 和 `Section` 结构来改进用户界面。将 `ToDoItemInput` 的 `body` 属性代码替换为以下内容：
- en: '[PRE28]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We have to specify in this code that we want `Section` defined in SwiftUI because
    we already defined a section type. With this code, the user interface looks as
    follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们必须指定我们想要在 SwiftUI 中定义 `Section`，因为我们已经定义了一个部分类型。使用此代码，用户界面看起来如下：
- en: '![Figure 9.5 – An improved user interface with Form and Section'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 9.5 – 使用 Form 和 Section 改进的用户界面](img/Figure_9.05_B18127.jpg)'
- en: '](img/Figure_9.05_B18127.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.05_B18127.jpg)'
- en: Figure 9.5 – An improved user interface with Form and Section
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 使用 Form 和 Section 改进的用户界面
- en: This looks way better. Run the tests to confirm that we didn't break something.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来好多了。运行测试以确认我们没有破坏任何东西。
- en: In the next section, we will add another text field and a button.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将添加另一个文本字段和按钮。
- en: Adding an address text field and a button
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加地址文本字段和按钮
- en: We need another text field for the address of the to-do item. Use your gained
    experience to add it yourself to the location section of the input form. To make
    your code consistent with the code of the book on GitHub, name the property `addressString`
    in `ToDoItemData` and use the label `Address` in the `TextField` type.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个用于待办事项地址的另一个文本字段。利用你获得的经验，将其添加到输入表单的位置部分。为了使你的代码与 GitHub 上书籍的代码保持一致，在
    `ToDoItemData` 中将属性命名为 `addressString`，并在 `TextField` 类型中使用标签 `地址`。
- en: 'After entering the data for the to-do item, the user can add it to the list.
    For that task, we need a button in the user interface. Follow these steps to add
    the button:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在输入待办事项的数据后，用户可以将它添加到列表中。为此任务，我们需要用户界面中的一个按钮。按照以下步骤添加按钮：
- en: 'Add the following test to `ToDoItemInputViewTests`:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试添加到 `ToDoItemInputViewTests`：
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Run the tests to see this new test fail.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以查看这个新测试失败。
- en: 'Add the following code within the Form of the body property of `ToDoItemInputView`:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ToDoItemInputView` 的 `body` 属性的表单中添加以下代码：
- en: '[PRE30]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To make this code compile, we need to add the action. Add the following method
    to `ToDoItemInputView` below the `body` property:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使此代码编译，我们需要添加操作。在 `ToDoItemInputView` 中 `body` 属性下方添加以下方法：
- en: '[PRE31]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run all tests to confirm that all tests now pass.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认现在所有测试都通过。
- en: Now we have all the user interface elements needed to move on to implementing
    adding the to-do item to the list of items in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了所有需要的用户界面元素，可以继续到下一节实现将待办事项添加到项目列表中。
- en: Testing button actions with ViewInspector
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ViewInspector 测试按钮动作
- en: The user puts in the address for the to-do item. In the details view of an item,
    the app shows a map of that location. This means we need to convert the address
    of the item to a coordinate before we can add the item to the list. Apple provides
    a `GeoCoder` class for that task. We will write tests for fetching an address
    from a `GeoCoder` class in [*Chapter 10*](B18127_10_ePub.xhtml#_idTextAnchor444),
    *Testing Networking Code*.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入待办事项的地址。在项目的详细信息视图中，应用程序显示该位置的地图。这意味着在将项目添加到列表之前，我们需要将项目的地址转换为坐标。Apple 提供了一个
    `GeoCoder` 类来完成这项任务。我们将在 [*第 10 章*](B18127_10_ePub.xhtml#_idTextAnchor444)，*测试网络代码*
    中编写从 `GeoCoder` 类获取地址的测试。
- en: 'In this chapter, we assume that we already have a class called `APIClient`
    that uses `GeoCoder` (or some similar service) to translate an address into a
    coordinate. In the test, we are going to use a mock object for that `APIClient`
    class. Follow these steps to add a protocol for the `APIClient` class and a mock
    conforming to that protocol:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们假设我们已经有了一个名为 `APIClient` 的类，该类使用 `GeoCoder`（或类似的服务）将地址转换为坐标。在测试中，我们将使用该
    `APIClient` 类的模拟对象。按照以下步骤添加 `APIClient` 类的协议和一个符合该协议的模拟：
- en: Select the `APIClient.swift`.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `APIClient.swift`。
- en: 'Add the following protocol definition to that new file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下协议定义添加到新文件中：
- en: '[PRE32]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This protocol defines a function that takes a `String` instance and calls a
    `completion` handler with a `Coordinate` instance.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本协议定义了一个函数，该函数接受一个`String`实例，并使用一个`Coordinate`实例调用`completion`处理程序。
- en: Select the `APIClientMock.swift`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`APIClientMock.swift`。
- en: 'Replace the contents of that file with the following code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下代码替换该文件的内容：
- en: '[PRE33]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'With this mock in place, we can write a test that asserts that the `coordinate`
    instance is fetched when the user taps the **Save** button. Follow these steps
    to add that test and the implementation that makes the test pass:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于有了这个模拟，我们可以编写一个测试，断言当用户点击**保存**按钮时，会获取`coordinate`实例。按照以下步骤添加该测试和使测试通过的实现：
- en: 'Add a new property (`apiClientMock`) to the `ToDoItemInputViewTests` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToDoItemInputViewTests`类中添加一个新的属性（`apiClientMock`）：
- en: '[PRE34]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In `setUpWithError`, initialize an API client mock and pass it into the initializer
    of `ToDoItemInputView`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`setUpWithError`中，初始化一个API客户端模拟，并将其传递给`ToDoItemInputView`的初始化器：
- en: '[PRE35]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Don''t forget to set this property to `nil` in `tearDownWithError`:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 不要忘记在`tearDownWithError`中将此属性设置为`nil`：
- en: '[PRE36]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '`ToDoItemInputView` doesn''t have a property for the API client. We need to
    add it before we can continue with the test.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToDoItemInputView`没有API客户端的属性。我们需要在继续测试之前添加它。'
- en: 'Add the `apiClient` property to `ToDoItemInputView`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`apiClient`属性添加到`ToDoItemInputView`中：
- en: '[PRE37]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: As `ToDoItemInputView` is a structure, this new property changes the automatically
    generated initializer. We use this initializer in `ToDoItemInputView_Previews`
    in the same file.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`ToDoItemInputView`是一个结构体，这个新属性改变了自动生成的初始化器。我们在同一文件中的`ToDoItemInputView_Previews`中使用这个初始化器。
- en: 'Replace the `ToDoItemInputView_Previews` structure with the following implementation:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下实现替换`ToDoItemInputView_Previews`结构：
- en: '[PRE38]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: With this code, we replaced the error with another. The implementation of `APIClient`
    is missing.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，我们用另一个错误替换了错误。缺少`APIClient`的实现。
- en: 'Add the following minimal implementation to `APIClient.swift`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下最小实现添加到`APIClient.swift`中：
- en: '[PRE39]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we can add the test method:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以添加测试方法：
- en: '[PRE40]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this test, we set up the title and the address of the input data and tap
    the `coordinate` instances for the address.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在此测试中，我们设置了输入数据的标题和地址，并点击了地址的`coordinate`实例。
- en: Run the tests to confirm that this new test fails.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这个新测试失败。
- en: 'Replace the `addToDoItem()` method in `ToDoItemInputView` with the following
    implementation:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ToDoItemInputView`中的`addToDoItem()`方法替换为以下实现：
- en: '[PRE41]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In this implementation, we call the `coordinate(for:completion:)` method defined
    in `APIClientProtocol`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在此实现中，我们调用了在`APIClientProtocol`中定义的`coordinate(for:completion:)`方法。
- en: Run the tests to confirm that all tests now pass.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认所有测试现在都通过。
- en: 'But what if the user didn''t add an address to the input form? In this case,
    the `coordinate(for:completion:)` method should not be called because there is
    no coordinate to be fetched. We need a test for this case. Add the following test
    to `ToDoInputViewTests.swift`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果用户没有在输入表单中添加地址怎么办？在这种情况下，不应调用`coordinate(for:completion:)`方法，因为没有要获取的坐标。我们需要为此情况添加一个测试。将以下测试添加到`ToDoInputViewTests.swift`中：
- en: '[PRE42]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run all tests to confirm that this new test fails.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认这个新测试失败。
- en: 'To make it pass, change the code in `addToDoItem()` so that it looks like this:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使其通过，更改`addToDoItem()`中的代码，使其看起来像这样：
- en: '[PRE43]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Run all tests to confirm that all tests pass.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认所有测试都通过。
- en: After the `coordinate` has been fetched, the `addToDoItem()` method should call
    a delegate method to inform it that the input data is complete and the item can
    be constructed. Again, we will add a `delegate` protocol to define the interface
    of the `delegate` object. This helps when we create a mock object for the test.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在获取`coordinate`之后，`addToDoItem()`方法应调用一个代理方法来通知它输入数据已完整，可以构造项目。再次，我们将添加一个`delegate`协议来定义代理对象的接口。这有助于我们在测试中创建模拟对象。
- en: 'Follow these steps to add the tests and the implementation of calling the `delegate`
    protocol with the to-do item data:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤添加测试和调用带有待办事项数据的`delegate`协议的实现：
- en: 'Add the following protocol definition to `ToDoItemInputView.swift` outside
    of the `ToDoItemInputView` structure:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToDoItemInputView.swift`中`ToDoItemInputView`结构外部添加以下协议定义：
- en: '[PRE44]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'With this protocol in place, we can add a mock object to the test target. Select
    the `ToDoTests` group in the project navigator and add a Swift file with the name
    `ToDoItemInputViewDelegateMock.swift`. Add the following code to this new file:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于有了这个协议，我们可以在测试目标中添加一个模拟对象。在项目导航器中选择`ToDoTests`组，并添加一个名为`ToDoItemInputViewDelegateMock.swift`的Swift文件。将以下代码添加到这个新文件中：
- en: '[PRE45]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Now we can start with the test. Add the following test fragment to `ToDoItemInputViewTests`:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以开始测试了。将以下测试片段添加到 `ToDoItemInputViewTests`：
- en: '[PRE46]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Here we set up the `apiClientMock` property to return a dummy coordinate when
    `coordinate(for:completion:)` is called, and we create an instance of `ToDoItemInputViewDelegateMock`
    and set it to the `delegate` property of the system under test. This property
    is still missing and therefore, we have to pause writing the test and first add
    it to `ToDoItemInputView`.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们设置了 `apiClientMock` 属性，当调用 `coordinate(for:completion:)` 时返回一个虚拟坐标，并创建一个
    `ToDoItemInputViewDelegateMock` 实例，并将其设置为正在测试的系统中的 `delegate` 属性。这个属性仍然缺失，因此，我们必须暂停编写测试，首先将其添加到
    `ToDoItemInputView`。
- en: 'Add this `delegate` property to `ToDoItemInputView`:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `delegate` 属性添加到 `ToDoItemInputView`：
- en: '[PRE47]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This change makes the test compile and we can continue writing the test.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这次更改使得测试可以编译，我们可以继续编写测试。
- en: 'Complete the test method so that it looks as follows:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成测试方法，使其看起来如下：
- en: '[PRE48]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Usually, I try to keep all the relevant code in the test. But in this case,
    the test method is a bit messy. As an example, let's move the inspector code into
    a method.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我尽量将所有相关代码放在测试中。但在这个例子中，测试方法有点杂乱。作为一个例子，让我们将检查器代码移动到一个方法中。
- en: 'Add the following extension in `ToDoItemInputViewTests.swift` below the `ToDoItemInputViewTests`
    class:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ToDoItemInputViewTests.swift` 中 `ToDoItemInputViewTests` 类下方添加以下扩展：
- en: '[PRE49]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'With this extension we can write the last test as follows:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过这个扩展，我们可以将最后一个测试编写如下：
- en: '[PRE50]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this case, this is a bit better than the original version.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这比原始版本好一些。
- en: 'To make this test pass, replace the implementation of `addToDoItem()` with
    the following code:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，将 `addToDoItem()` 的实现替换为以下代码：
- en: '[PRE51]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: In the completion closure, we now call the `addToDoItem(with:coordinate:)` method.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成闭包中，我们现在调用 `addToDoItem(with:coordinate:)` 方法。
- en: Run the tests to confirm that this change makes all tests pass.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试以确认这次更改使所有测试通过。
- en: 'But what if the user didn''t add an address for the to-do item? Add the following
    test to make sure that, in this case, the `delegate` method also gets called:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 但如果用户没有为待办事项添加地址怎么办？添加以下测试以确保在这种情况下，`delegate` 方法也会被调用：
- en: '[PRE52]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Run all tests to confirm that this new test fails.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试以确认这个新测试失败。
- en: 'To make this test pass, replace `addToDoItem()` in `ToDoItemInputView` with
    the following code:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使这个测试通过，将 `ToDoItemInputView` 中的 `addToDoItem()` 替换为以下代码：
- en: '[PRE53]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If the `address` string is empty, we call the `delegate` method without a `coordinate`
    instance.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `address` 字符串为空，我们调用 `delegate` 方法而不传递 `coordinate` 实例。
- en: Run all tests. All tests pass again.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行所有测试。所有测试再次通过。
- en: The input view is now complete and we can move on to implementing some networking
    code.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 输入视图现在已完成，我们可以继续实现一些网络代码。
- en: Summary
  id: totrans-234
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing SwiftUI code works a bit differently from testing UIKit code. One reason
    for this is that SwiftUI itself works completely differently. In addition, Apple
    doesn't provide a testing framework for SwiftUI code because they believe that
    user interface code should be tested with UITest.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 测试 SwiftUI 代码的方式与测试 UIKit 代码略有不同。其中一个原因是 SwiftUI 本身的工作方式完全不同。此外，苹果没有为 SwiftUI
    代码提供测试框架，因为他们认为用户界面代码应该使用 UITest 进行测试。
- en: I don't think that's true. UITest solve a different problem. I believe you should
    have access to both kinds of tests, and you should choose the right tool for the
    problem at hand.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这不是真的。UITest 解决了不同的问题。我相信你应该能够访问这两种测试，并且你应该为手头的问题选择合适的工具。
- en: Fortunately, with ViewInspector we have a powerful third-party solution that
    fills this gap. In this chapter, we added it as a SwiftUI package to the unit
    test target. We used the package to write unit tests for SwiftUI code and build
    an input view for to-do items following test-driven development.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有了 ViewInspector，我们有一个强大的第三方解决方案来填补这个空白。在本章中，我们将它作为 SwiftUI 包添加到单元测试目标中。我们使用这个包为
    SwiftUI 代码编写单元测试，并按照测试驱动开发构建了一个待办事项的输入视图。
- en: This way, we learned how to add SwiftUI packages to test targets and how to
    use this specific SwiftUI package to write tests for things that aren't easily
    testable without it.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就学会了如何将 SwiftUI 包添加到测试目标中，以及如何使用这个特定的 SwiftUI 包来测试那些没有它难以测试的内容。
- en: In the next chapter, we will learn how to write unit tests for networking code.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何编写网络代码的单元测试。
- en: Exercises
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 练习
- en: Add more convenient methods in the extension of `ToDoItemInputView` in `ToDoItemInputViewTests.swift`
    to make the tests easier to read as we did for `test_save_shouldCallDelegate()`.
    What are the advantages of these helper methods? What are the disadvantages?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ToDoItemInputViewTests.swift`中`ToDoItemInputView`的扩展中添加更多方便的方法，使测试更容易阅读，就像我们对`test_save_shouldCallDelegate()`所做的那样。这些辅助方法的优势是什么？它们的缺点是什么？
- en: When the user provides an address, but `GeoCoder` cannot find the coordinate
    to that address, the app should show an alert and ask the user if they still want
    to save the item. Go to the GitHub repository of `ViewInspector` ([https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector))
    and find out how you can test the presentation of an alert. Then write the test
    that asserts that the alert is presented and implement that feature.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户提供一个地址，但`GeoCoder`无法找到该地址的坐标时，应用应显示一个警告并询问用户是否仍想保存该项目。前往`ViewInspector`的GitHub仓库([https://github.com/nalexn/ViewInspector](https://github.com/nalexn/ViewInspector))，了解如何测试警告的展示。然后编写断言警告已展示的测试，并实现该功能。
