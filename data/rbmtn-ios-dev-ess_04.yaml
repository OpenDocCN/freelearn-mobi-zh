- en: Chapter 4. Mastering MVC Paradigm
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 掌握MVC范式
- en: '*"Model-View-Controller is not an inescapable law of purity, but a pragmatic
    principle of effectiveness."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"模型-视图-控制器不是纯净的必然法则，而是一种有效的实用原则。"*'
- en: '*—Anonymous*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*—匿名*'
- en: 'In this chapter we will learn about Model-View-Controller, popularly abbreviated
    as MVC, which is a design principle based on the ideas of code reusability and
    **separation of concerns** (**SoC**). This architecture imposes serious constraints
    on the structure of an application, however, surprisingly these restrictions make
    it considerably easier to design and maintain the application. In this chapter
    we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习关于模型-视图-控制器（通常缩写为MVC）的内容，它是一种基于代码重用和**关注点分离**（**SoC**）理念的设计原则。这种架构对应用程序的结构施加了严格的限制，然而，令人惊讶的是，这些限制使得设计和维护应用程序变得更加容易。在本章中，我们将涵盖以下主题：
- en: Understanding the Model-View-Controller paradigm
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解模型-视图-控制器范式
- en: Creating a RubyMotion application using MVC
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用MVC创建RubyMotion应用程序
- en: Connecting to an external API
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到外部API
- en: Enhancing the application with search and images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过搜索和图像增强应用程序
- en: The do-it-yourself exercise
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DIY练习
- en: Model-View-Controller (MVC)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模型-视图-控制器（MVC）
- en: '**Model-View-Controller** (**MVC**) is a design principle that separates the
    representation of information from the user''s interaction. The main purpose of
    MVC is to make the code more modular and reusable, which increases the product
    quality.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-控制器**（**MVC**）是一种设计原则，它将信息表示与用户的交互分离。MVC的主要目的是使代码更加模块化和可重用，从而提高产品质量。'
- en: Most of the popular commercial and noncommercial application frameworks are
    created to enforce the MVC design pattern. However, RubyMotion does not force
    you to use MVC style, but this way of programming is central to a good design
    for application development. If we make use of MVC while developing our application,
    it will be beneficial for us later on, as we will be able to add new features
    more easily.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数流行的商业和非商业应用程序框架都是为了强制执行MVC设计模式而创建的。然而，RubyMotion并不强制你使用MVC风格，但这种方式是应用程序开发良好设计的关键。如果我们开发应用程序时使用MVC，那么这对我们来说将是有益的，因为我们将能够更容易地添加新功能。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Apple's Cocoa framework is also based on Model-View-Controller.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果的Cocoa框架也是基于模型-视图-控制器。
- en: 'As the name implies, the application is divided into three distinct parts:
    model, view, and controller, where model encapsulates application data, view displays
    and allows editing the data, and controller is the place where logic of the interaction
    between the two (model and view) resides. Let''s understand each of them individually.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，该应用程序被分为三个不同的部分：模型、视图和控制器，其中模型封装了应用程序数据，视图用于显示和编辑数据，而控制器是两个（模型和视图）之间交互逻辑所在的地方。让我们分别了解它们。
- en: Model
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模型
- en: The model contains the application data and business rules. The model could
    just be the actual data store, either in-memory (maybe as an `NSArray` or `NSDictionary`
    class) or to-and-from disk. In a more complex app, you may choose to use a SQLite
    database or Core Data, and your model would be a simple instance or one piece
    of data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 模型包含应用程序数据和业务规则。模型可能只是实际的数据存储，无论是内存中的（可能作为`NSArray`或`NSDictionary`类）还是从磁盘到磁盘。在更复杂的应用程序中，你可能选择使用SQLite数据库或Core
    Data，而你的模型将是一个简单的实例或数据的一部分。
- en: View
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: A view is that part of an application that outputs information from the model
    via the controller. The logic should never be written in the view; the sole purpose
    of the view is only to present information. In iOS, and also in RubyMotion, most
    views are subclasses of the `UIView` class that provide the capability for handling
    touch events and drawings. The `UIKit` framework contains classes to draw typical
    interface elements such as tables (lists), buttons, text fields, and sliders.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是应用程序中通过控制器从模型输出信息的那部分。逻辑永远不应该写在视图中；视图的唯一目的只是展示信息。在iOS和RubyMotion中，大多数视图都是`UIView`类的子类，提供了处理触摸事件和绘制的功能。《UIKit》框架包含用于绘制典型界面元素（如表格、按钮、文本字段和滑块）的类。
- en: Controller
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 控制器
- en: A controller is a link between the model and view. A controller acts as an intermediary
    between one or more application views, and one or more of its models. In iOS,
    the controller is generally a subclass of `UIViewController` that also manages
    a view; this class is also responsible for responding to delegation messages and
    target-action messages.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器是模型和视图之间的链接。控制器充当一个或多个应用程序视图与一个或多个模型之间的中介。在iOS中，控制器通常是一个`UIViewController`的子类，它还管理一个视图；这个类还负责响应用户代理消息和目标-动作消息。
- en: 'The Model-View-Controller layers are very closely coupled, as shown in the
    following diagram:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 模型-视图-控制器层之间耦合非常紧密，如下所示：
- en: '![Controller](img/5220OT_04_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![控制器](img/5220OT_04_01.jpg)'
- en: The **View** and **Controller** layers interact through **User Action** and
    **Update** as shown in the diagram. Whenever the **View** layer creates or modifies
    data, it is communicated to **Controller** through **User Action**. Similarly,
    whenever **Model** updates any change it will first **Notify** the **Controller**
    and will then be reflected on the **View** by an **Update** .
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**视图**和**控制器**层通过**用户操作**和**更新**进行交互，如图所示。每当**视图**层创建或修改数据时，它将通过**用户操作**传达给**控制器**。同样，每当**模型**更新任何更改时，它将首先**通知****控制器**，然后通过**更新**在**视图**上反映出来。'
- en: The restaurant application
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 餐厅应用程序
- en: Now to better understand MVC we will create a `restro` application. This application
    will search restaurants in a city. Does the world need another restaurant application?
    No, but that won't stop us from writing one. On a serious note, it will help us
    to explore many features of RubyMotion and will also help us learn and master
    MVC.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为了更好地理解MVC，我们将创建一个`restro`应用程序。这个应用程序将在一个城市中搜索餐厅。世界还需要另一个餐厅应用程序吗？不，但这不会阻止我们编写一个。认真地说，这将帮助我们探索RubyMotion的许多功能，也将帮助我们学习和掌握MVC。
- en: Let's understand what we are going to do in this application. A restaurant application
    will list out the eat outs, which we can search based on the city. The list of
    places will have a thumbnail image along with information related to the restaurant.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解在这个应用程序中我们将要做什么。餐厅应用程序将列出餐饮场所，我们可以根据城市进行搜索。场所列表将包含缩略图图像以及与餐厅相关的信息。
- en: It's good practice to imagine views of your application in the form of a mockup.
    The best way to do this is by using a white board with illustrations that you
    envision for your application.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 想象应用程序的视图形式为原型是一个好习惯。最好的方法是使用一个白板，在上面绘制出你为应用程序设想的概念图。
- en: '![The restaurant application](img/5220OT_04_02.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![餐厅应用程序](img/5220OT_04_02.jpg)'
- en: You must be wondering where all this data will come from. Do I need to hardcode
    it right into my application? That does not make sense! To begin with, we will
    hardcode the values; but later on, as we proceed and evolve, we will learn how
    to use an external API to fetch information, which is something often done in
    real-world applications. We have created a backend API exclusively for this book,
    having all the data available for practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定想知道所有这些数据从哪里来。我需要直接将它们硬编码到我的应用程序中吗？这没有意义！首先，我们将硬编码这些值；但随后，随着我们的进展和演变，我们将学习如何使用外部API来获取信息，这在现实世界的应用程序中是常见做法。我们为这本书专门创建了一个后端API，其中包含了所有用于练习的数据。
- en: 'Let''s now create a `restro` project with RubyMotion, using the magical `motion`
    command:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用神奇的`motion`命令用RubyMotion创建一个`restro`项目：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As discussed in earlier chapters, the `motion` command will create the basic
    structure for a RubyMotion project.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前几章所述，`motion`命令将为RubyMotion项目创建基本结构。
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Feel free to choose your IDE. If you are using RubyMine, you can also create
    and run the application from the IDE.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 随意选择你的IDE。如果你使用RubyMine，你也可以从IDE中创建和运行应用程序。
- en: Creating a model
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建模型
- en: 'For our `restro` application, let''s brainstorm what entities and attributes
    will be required. The first thing that comes to mind is a restaurant entity having
    the following attributes:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的`restro`应用程序，让我们头脑风暴一下所需的实体和属性。首先想到的是餐厅实体，具有以下属性：
- en: '`name`: This will contain the name of the application'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`：这将包含应用程序的名称'
- en: '`thumb_url_image`: This will contain the image URL for the restaurant'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`thumb_url_image`：这将包含餐厅的图片URL'
- en: '`food_type`: This will contain the type of food the restaurant serves'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`food_type`：这将包含餐厅提供的食物类型'
- en: '`desc`: This will contain a small description about the restaurant'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`desc`：这将包含关于餐厅的简要描述'
- en: Looks good! Let's create a model, `Restaurant`, that will store all the information
    related to restaurants.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来不错！让我们创建一个模型，`Restaurant`，它将存储所有与餐厅相关的信息。
- en: 'Create a ruby (`.rb`) file, which will be our model inside the `app` folder,
    and name it `restaurant.rb`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个ruby（`.rb`）文件，它将是`app`文件夹中的模型，并将其命名为`restaurant.rb`：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We have created a class called `Restaurant`. Generally we need to first create
    getter and setter methods for the variables. However, in Ruby we don't need to
    separately create getters and setters, instead we use a single method called `attr_accessor`
    to do that; this idea of syntactic sugar is commonly used in various trivial jobs
    in Ruby, which indeed saves a lot of time.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个名为`Restaurant`的类。通常我们首先需要为变量创建getter和setter方法。然而，在Ruby中，我们不需要单独创建getter和setter，而是使用一个名为`attr_accessor`的单个方法来完成这个任务；这种语法糖的概念在Ruby的各种琐碎工作中被广泛使用，这确实节省了很多时间。
- en: Note
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Syntactic sugar** is a syntax within a programming language that is designed
    to make things easier to read or express. An example of syntactic sugar is as
    follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法糖**是一种编程语言中的语法，旨在使事物更容易阅读或表达。以下是一个语法糖的例子：'
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After setting up `attr_accessor`, in order to assign values while creating an
    object of the `Restaurant` class, we have created an `initialize` method. This
    gives us a chance to write code that sets up our object's state.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置`attr_accessor`之后，为了在创建`Restaurant`类的对象时分配值，我们创建了一个`initialize`方法。这给了我们编写设置对象状态代码的机会。
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Whenever we create an object of the `Restaurant` class, it will call the `name`
    method, and initialize and execute it. We have to pass a hash of restaurants while
    creating the object. To test the model, let''s fire up our terminal in the `application`
    directory and run `rake`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建`Restaurant`类的对象时，它都会调用`name`方法，并初始化和执行它。在创建对象时，我们必须传递一个餐厅的哈希。为了测试模型，让我们在前一个章节中提到的`application`目录中启动我们的终端并运行`rake`：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great! Our `Restaurant` class is created and we can now create objects of this
    class.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！我们的`Restaurant`类已经创建，我们现在可以创建这个类的对象了。
- en: Writing more code
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写更多代码
- en: A lot of iOS applications use table structure to represent their information.
    This method of design is best for information-based applications, like the one
    we have in our example. So let's create a table view for our landing page, which
    will populate a list of restaurants.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 许多iOS应用程序使用表格结构来表示它们的信息。这种设计方法最适合信息类应用程序，就像我们例子中的那样。因此，让我们为我们的主页创建一个表格视图，它将填充一个餐厅列表。
- en: 'Let''s now update the `app_delegate.rb` file inside the `app` folder:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在更新`app`文件夹中的`app_delegate.rb`文件：
- en: '[PRE5]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `UIWindow` class defines an object known as `window`, which manages and
    coordinates different views of your application, and displays them on the device
    screen. A `UIScreen` object contains the bounding rectangle of the device''s entire
    screen. So `UIScreen.mainScreen.applicationFrame` returns the rectangle size according
    to the screen size and orientation of the device. Also we need to tell the `UIWindow`
    object which controller to load:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIWindow`类定义了一个名为`window`的对象，它管理和协调应用程序的不同视图，并在设备屏幕上显示它们。一个`UIScreen`对象包含设备整个屏幕的边界矩形。因此，`UIScreen.mainScreen.applicationFrame`返回根据设备屏幕大小和方向计算出的矩形大小。此外，我们还需要告诉`UIWindow`对象加载哪个控制器：'
- en: '[PRE6]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have assigned the `RestroController` class as the root controller for our
    application in `AppDelegate`. So let''s create `restro_controller.rb` in the `app`
    folder:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在`AppDelegate`中将`RestroController`类指定为应用程序的根控制器。因此，让我们在`app`文件夹中创建`restro_controller.rb`：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now let''s fire up our terminal again and see what we have done:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次启动我们的终端，看看我们做了什么：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![Writing more code](img/5220OT_04_03.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![编写更多代码](img/5220OT_04_03.jpg)'
- en: 'The previous screenshot shows a table structure with a list of restaurants.
    Now that''s some impressive work. Let''s now understand what we did in the previous
    section. Our code has three parts—model, view, and controller. We have already
    explained about the restaurant model. We first created an object for the model
    and assigned some value to it:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了一个包含餐厅列表的表格结构。现在，这是一项令人印象深刻的工作。让我们现在了解在前一节中我们做了什么。我们的代码有三个部分——模型、视图和控制器。我们已经解释了关于餐厅模型的内容。我们首先为模型创建了一个对象，并给它赋了一些值：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have created two objects and passed a hash to them, as we have explained
    in the previous section. The remaining code has two parts, a controller and a
    view; let's understand them one by one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了两个对象，并像前一个章节中解释的那样向它们传递了一个哈希。剩余的代码分为两部分，一个控制器和一个视图；让我们逐一了解它们。
- en: Restaurant controller
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 餐厅控制器
- en: In the previous example, the `Restaurant` controller inherits from `UITableViewController`,
    which is a subclass of `UIViewController`. The `UIViewController` class provides
    the fundamental view-management model for your apps.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，`Restaurant` 控制器继承自 `UITableViewController`，它是 `UIViewController` 的子类。`UIViewController`
    类为你的应用程序提供了基本的视图管理模型。
- en: 'We rarely instantiate the `UIViewController` objects directly. Instead, it
    is generally instantiated via a class that is a subclass of the `UIViewController`
    class, as we did in the previous example. It manages a set of views that make
    up a portion of your app''s user interface. The most important thing in an iOS
    controller is its lifecycle. There are various actions that are called at different
    phases of the application. The lifecycle includes actions such as `Initialize`,
    `ViewDidLoad`, `ViewWillAppear`, `ViewDidAppear`, `ViewWillDisappear`, `ViewDidDisappear`,
    `ViewDidUnload`, and `Dispose`. So these events are called automatically and dynamically.
    Whenever we create an object of the controller it calls `Initialize`, before loading
    the view for the controller, `ViewDidLoad` will be called. The complete lifecycle
    of a controller can be seen in the following diagram:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很少直接实例化 `UIViewController` 对象。相反，通常通过一个继承自 `UIViewController` 类的类来实例化，就像我们在前面的例子中所做的那样。它管理一组视图，这些视图构成了你应用程序用户界面的一部分。iOS
    控制器中最重要的是其生命周期。在应用程序的不同阶段会调用各种动作。生命周期包括如 `Initialize`、`ViewDidLoad`、`ViewWillAppear`、`ViewDidAppear`、`ViewWillDisappear`、`ViewDidDisappear`、`ViewDidUnload`
    和 `Dispose` 等动作。因此，这些事件是自动和动态调用的。每次我们创建控制器的对象时，它都会调用 `Initialize`，在为控制器加载视图之前，`ViewDidLoad`
    会被调用。控制器的完整生命周期可以在以下图中看到：
- en: '![Restaurant controller](img/5220OT_04_04.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![餐厅控制器](img/5220OT_04_04.jpg)'
- en: Note
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`viewDidUnload` and `viewWillUnload` are deprecated in iOS 6.0.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`viewDidUnload` 和 `viewWillUnload` 在 iOS 6.0 中已被弃用。'
- en: You can see in our restro controller that we have written a lot of logic in
    `ViewDidLoad`, so all the code written in this block will execute before the loading
    of the view.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在我们的餐厅控制器中看到，我们在 `ViewDidLoad` 中编写了很多逻辑，所以在这个块中编写的所有代码都会在视图加载之前执行。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that these methods are attached to `UIViewController`
    and not to `UIViews`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，这些方法绑定到 `UIViewController` 而不是 `UIViews`。
- en: Restaurant view
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 餐厅视图
- en: The `UITableView` class is used to create one of the most common types of views
    used in iOS applications, that is, the table view. We can see only one column
    in our application. This is because the `UITableView` instance is limited to a
    single column as it is designed for a device with a small screen. `UITableView`
    is a subclass of `UIScrollView`, which allows users to scroll through the table,
    although `UITableView` allows vertical scrolling only.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 类用于创建在 iOS 应用程序中最常见的视图类型之一，即表格视图。在我们的应用程序中，我们只能看到一个列。这是因为 `UITableView`
    实例被限制为单列，因为它是为小屏幕设备设计的。`UITableView` 是 `UIScrollView` 的子类，允许用户滚动表格，尽管 `UITableView`
    只允许垂直滚动。'
- en: Table views can have one of two styles, `UITableViewStylePlain` (for example,
    iOS contacts) or `UITableViewStyleGrouped` (for example, iOS settings). When you
    create a `UITableView` instance, you must specify the table style; this style
    cannot be changed. For our application, since we do not require to group the restaurants
    we will use `UITableViewStylePlain`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 表格视图可以有两种样式之一，`UITableViewStylePlain`（例如，iOS 联系人）或 `UITableViewStyleGrouped`（例如，iOS
    设置）。当你创建一个 `UITableView` 实例时，你必须指定表格样式；这个样式不能更改。对于我们的应用程序，由于我们不需要对餐厅进行分组，我们将使用
    `UITableViewStylePlain`。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A view is bound to return `CGRect` with an empty origin point. The `CGRect`
    class is very commonly used in iOS apps. Its data structure represents the location
    and dimensions of a rectangle, which is used to set the size of the table view.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 视图绑定需要返回一个具有空原点的 `CGRect`。`CGRect` 类在 iOS 应用程序中非常常用。它的数据结构表示一个矩形的定位和尺寸，用于设置表格视图的大小。
- en: 'The `UITableView` class provides a lot of options, but it needs to know what
    data we are trying to show and what to do when the user interacts with that data.
    This is where the `datasource` and `delegate` properties come in:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView` 类提供了很多选项，但它需要知道我们试图展示什么数据以及当用户与这些数据交互时应该做什么。这就是 `datasource`
    和 `delegate` 属性发挥作用的地方：'
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We have to return the number of rows to be created using `numberOfRowsInSection`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须使用 `numberOfRowsInSection` 返回要创建的行数：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `tableView:numberOfRowsInSection` property tells the `UITableview` datasource
    to return the number of rows in a given section of a table view. So in our example,
    the number of rows will be equal to the total restaurant count.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`tableView:numberOfRowsInSection`属性告诉`UITableView`数据源返回表格给定部分的行数。所以在我们这个例子中，行数将等于总餐厅数量。'
- en: 'Moving forward, let''s understand `UITableViewCell`, which is the subclass
    of `UIView`; using this class our rows are displayed in table form. To access
    the contents of the cell, we have properties, such as `textLabel` and `imageView`,
    to use them for setting their attributes such as text color, font, image, and
    highlighted image. You can also easily give a custom look to tables by using different
    iOS methods. Another property `cellForRowAtIndexPath` either creates a new cell
    or recycles an offscreen one and populates it with the data corresponding to `indexPath`,
    and returns the cell. The following code snippet shows how a more complete implementation
    looks:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解`UITableViewCell`，它是`UIView`的子类；使用这个类，我们的行以表格形式显示。为了访问单元格的内容，我们有`textLabel`和`imageView`等属性，用于设置它们的属性，如文本颜色、字体、图像和突出显示的图像。您还可以通过使用不同的iOS方法轻松地为表格提供自定义外观。另一个属性`cellForRowAtIndexPath`要么创建一个新的单元格，要么回收一个屏幕外的单元格，并用与`indexPath`对应的数据填充它，然后返回单元格。以下代码片段显示了更完整的实现方式：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `UITableView` class only displays enough data to fill the iPhone screen—it
    does not really matter how much data you might have in total. The `UITableView`
    class does this by reusing cells that scrolled off the screen. When cells scroll
    off the screen (either the top or the bottom) the table view will queue up cells
    that are no longer needed. When it asks the datasource for the cell of a particular
    row, you can check that queue of cells to see if there are any available for use:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableView`类只显示足够的数据来填充iPhone屏幕——您总共可能有多少数据实际上并不重要。`UITableView`类通过重用滚动出屏幕的单元格来实现这一点。当单元格滚动出屏幕（无论是顶部还是底部）时，表格视图将排队等待不再需要的单元格。当它请求数据源特定行的单元格时，您可以检查这个队列，看看是否有可用的单元格：'
- en: '![Restaurant view](img/5220OT_04_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![餐厅视图](img/5220OT_04_05.jpg)'
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The whole point of `dequeueReusableCell` is that the process of creating a new
    view hierarchy for `UITableViewCell` is rather expensive. If you recreated the
    cell each time you needed it, the scrolling behavior wouldn't be as nice as it
    is.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`dequeueReusableCell`的整个目的是创建`UITableViewCell`的新视图层次结构的过程相当昂贵。如果您每次需要时都重新创建单元格，那么滚动行为就不会像现在这样好了。'
- en: With `dequeueReusableCellWithIdentifier` for `tableView`, you can greatly speed
    things up. Instead of instantiating a lot of cells, you can just instantiate the
    ones that are needed, which means only those cells that are visible (this is handled
    automatically). When scrolling to an area in the list for which the cells are
    not yet visually represented, instead of instantiating new ones, you can reuse
    the already existing ones.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dequeueReusableCellWithIdentifier`为`tableView`，您可以大大加快速度。您不需要实例化很多单元格，只需实例化所需的单元格即可，这意味着只有那些可见的单元格（这是自动处理的）。当滚动到列表中的某个区域，而单元格尚未在视觉上表示时，您不需要实例化新的单元格，而是可以重用已经存在的单元格。
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next we have assigned a display value for each row in the following way:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们以以下方式为以下每一行分配了显示值：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Ruby, *a ||= b* means if *a* is nil/false, assign it the value of *b*.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ruby中，`a ||= b`意味着如果`a`是nil/false，则将其赋值为`b`。
- en: Connecting to an external API
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到外部API
- en: Right now we have hardcoded the object values, which usually never happens in
    a real-world application; let's get these values from an external API. For practicing
    purposes we have created an external API to get the data in JSON format.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 目前我们硬编码了对象值，这在实际应用中通常是不会发生的；让我们从外部API获取这些值。为了练习目的，我们创建了一个外部API来以JSON格式获取数据。
- en: If you visit [http://restro.nalwaya.com/restaurants/search.json?city=Chicago](http://
    http://restro.nalwaya.com/restaurants/search.json?city=Chicago) or use the `curl`
    command instead, it will return the restaurants we have seeded for Chicago in
    JSON format (note that this is fictitious data, you might not actually find them
    in Chicago city).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问[http://restro.nalwaya.com/restaurants/search.json?city=Chicago](http://restro.nalwaya.com/restaurants/search.json?city=Chicago)或使用`curl`命令，它将以JSON格式返回我们为芝加哥播种的餐厅（注意，这是虚构的数据，您可能实际上在芝加哥市找不到它们）。
- en: 'Let''s run the following `curl` command to get the data:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们运行以下`curl`命令来获取数据：
- en: '[PRE16]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`curl` is a command-line tool for transferring data using various protocols.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`curl` 是一个用于使用各种协议传输数据的命令行工具。'
- en: Now we will show the list of restaurants in Chicago city, which we are getting
    from our source in our `restro` application. Since we are getting data in JSON
    format, we need to convert this JSON object to a Ruby object.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将展示芝加哥市餐馆的列表，这是我们通过 `restro` 应用程序中的源获取的。由于我们获取的数据是 JSON 格式，我们需要将此 JSON
    对象转换为 Ruby 对象。
- en: 'Create a file by the name `json_parser.rb` in the `app` folder:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中创建一个名为 `json_parser.rb` 的文件：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `NSJSONSerialization` class converts JSON to Foundation objects and converts
    Foundation objects to JSON.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSJSONSerialization` 类将 JSON 转换为 Foundation 对象，并将 Foundation 对象转换为 JSON。'
- en: Note
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: RubyMotion has the `Pointer` class in order to create and manipulate pointers.
    The type of pointer to create must be provided in the new constructor. So `Pointer.new(:object)`
    will create a new pointer with the object class.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion 有 `Pointer` 类，用于创建和操作指针。必须在新构造函数中提供要创建的指针类型。因此，`Pointer.new(:object)`
    将创建一个新的具有对象类的指针。
- en: We need to fetch the JSON object by sending a request to the server; for that
    we will create a `DataParser` class.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要通过向服务器发送请求来获取 JSON 对象；为此，我们将创建一个 `DataParser` 类。
- en: 'Let''s create a file by the name `data_parser.rb` in the `app` folder:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `app` 文件夹中创建一个名为 `data_parser.rb` 的文件：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will fetch data using the `NSUrl` class that will pass this data to `NSData`.
    `NSData` and its mutable subclass `NSMutableData` provides the data objects with
    an object-oriented wrapping for byte buffers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 `NSUrl` 类来获取数据，该类会将数据传递给 `NSData`。`NSData` 及其可变子类 `NSMutableData` 为字节数据提供了面向对象的封装。
- en: Now let's refactor the logic in `restro_controller.rb`, which will fetch data
    from the API instead of the hardcoded `Restaurant` object we had created in the
    previous section.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们重构 `restro_controller.rb` 中的逻辑，该逻辑将从一个 API 获取数据，而不是我们在上一节中创建的硬编码的 `Restaurant`
    对象。
- en: 'Update the `viewDidLoad` section of `restro_controller.rb`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 `restro_controller.rb` 中的 `viewDidLoad` 部分：
- en: '[PRE19]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In case of an error, let''s face it gracefully by displaying the error message
    using a pop-up. So let''s create a `presentError` method in `restaurant_controller.rb`,
    and print the error on pop-up:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果出现错误，让我们优雅地面对它，通过弹出显示错误消息。因此，在 `restaurant_controller.rb` 中创建一个 `presentError`
    方法，并在弹出中打印错误：
- en: '[PRE20]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Go to the terminal and start the application with the `rake` command.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 打开终端并使用 `rake` 命令启动应用程序。
- en: '![Connecting to an external API](img/5220OT_04_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![连接到外部 API](img/5220OT_04_06.jpg)'
- en: We can see that the list of restaurants is shown dynamically from the JSON API.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到餐馆列表是动态地从 JSON API 中显示的。
- en: Search restaurant by city
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过城市搜索餐馆
- en: In the previous section we were only showing restaurants in Chicago. If you
    noticed, it was hardcoded in the URL itself and was not generic. In this section
    we will make the application more generic and allow the user to search data based
    on a parameter city.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们只显示了芝加哥的餐馆。如果你注意到，它硬编码在 URL 本身中，并且不是通用的。在本节中，我们将使应用程序更加通用，并允许用户根据参数城市搜索数据。
- en: 'Update `restro_controller.rb` as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `restro_controller.rb`：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Search restaurant by city](img/5220OT_04_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![通过城市搜索餐馆](img/5220OT_04_07.jpg)'
- en: Start the simulator by the `rake` command, and you can see that your toolbar
    is replaced with a search box with the default value **Chicago**.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `rake` 命令启动模拟器，你可以看到你的工具栏被一个带有默认值 **芝加哥** 的搜索框所替换。
- en: What just happened
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚才发生了什么
- en: The `UISearchBar` class implements a text field control for text-based searches.
    The `UISearchBar` object does not actually perform any search; it is just a view,
    which we can see on the device. To make the search work, we use a delegate, which
    is an object conforming to the `UISearchBarDelegate` protocol, to implement the
    actions when text is entered and buttons are clicked. The `UISearchBarDelegate`
    protocol defines the optional methods you implement to make a `UISearchBar` control
    functional.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISearchBar` 类实现了基于文本的搜索的文本字段控件。`UISearchBar` 对象实际上并不执行任何搜索；它只是一个视图，我们可以在设备上看到。为了使搜索工作，我们使用一个代理，它是一个符合
    `UISearchBarDelegate` 协议的对象，用于实现文本输入和按钮点击时的动作。`UISearchBarDelegate` 协议定义了你实现的可选方法，以使
    `UISearchBar` 控件功能化。'
- en: The `UISearchBar` object provides the user interface for a search field on a
    bar, but it's the application's responsibility to implement the actions when buttons
    are tapped. We can implement this using various methods available, which are explained
    next.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISearchBar` 对象为条上的搜索字段提供用户界面，但实现按钮点击时的动作是应用程序的责任。我们可以使用各种方法来实现，这些方法将在下面解释。'
- en: 'The methods used for editing text are as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 用于编辑文本的方法如下：
- en: '`searchBar:textDidChange`: This tells the delegate that the user changed the
    search text'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBar:textDidChange`: 这告诉代理用户改变了搜索文本'
- en: '`searchBar:shouldChangeTextInRange:replacementText`: This asks the delegate
    if text in a specified range should be replaced with the given text'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBar:shouldChangeTextInRange:replacementText`: 这询问代理是否应该用给定的文本替换指定范围内的文本'
- en: '`searchBarShouldBeginEditing`: This asks the delegate if editing should begin
    in the specified search bar'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarShouldBeginEditing`: 这询问代理是否应该在指定的搜索栏中开始编辑'
- en: '`searchBarTextDidBeginEditing`: This tells the delegate when the user begins
    editing the search text'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarTextDidBeginEditing`: 这告诉代理用户开始编辑搜索文本'
- en: '`searchBarShouldEndEditing`: This asks the delegate if editing should stop
    in the specified search bar'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarShouldEndEditing`: 这询问代理是否应该在指定的搜索栏中停止编辑'
- en: '`searchBarTextDidEndEditing`: This tells the delegate that the user finished
    editing the search text'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarTextDidEndEditing`: 这告诉代理用户完成了搜索文本的编辑'
- en: 'The methods used for different click events on various buttons in the search
    bar are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 用于搜索栏中各种按钮上不同点击事件的方法如下：
- en: '`searchBarBookmarkButtonClicked`: This tells the delegate that the bookmark
    button was tapped'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarBookmarkButtonClicked`: 这告诉代理书签按钮被点击了'
- en: '`searchBarCancelButtonClicked`: This tells the delegate that the cancel button
    was tapped'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarCancelButtonClicked`: 这告诉代理取消按钮被点击了'
- en: '`searchBarSearchButtonClicked`: This tells the delegate that the search results
    list button was tapped'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarSearchButtonClicked`: 这告诉代理搜索结果列表按钮被点击了'
- en: '`searchBarResultsListButtonClicked`: This tells the delegate that the search
    button was tapped'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBarResultsListButtonClicked`: 这告诉代理搜索按钮被点击了'
- en: 'The method used for the scope button is as follows:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 用于范围按钮的方法如下：
- en: '`searchBar:selectedScopeButtonIndexDidChange`: This tells the delegate that
    the scope button selection changed'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`searchBar:selectedScopeButtonIndexDidChange`: 这告诉代理范围按钮选择已更改'
- en: Tip
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As a minimum, the delegate needs to perform the actual search when the text
    is entered in the text field.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最低要求，当在文本字段中输入文本时，代理需要执行实际的搜索。
- en: 'We have implemented `searchBarSearchButtonClicked(searchBar)`, and whenever
    the search button is clicked this action will be called:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了 `searchBarSearchButtonClicked(searchBar)`，每次点击搜索按钮时，这个动作将被调用：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: So, all the results that we have fetched from our web service are stored in
    the `json` variable. We will loop through this object and store the information
    in our restaurant model, which we have created in the previous section.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们从我们的网络服务中获取的所有结果都存储在 `json` 变量中。我们将遍历此对象，并将信息存储在我们之前创建的餐厅模型中。
- en: We have to reload the view once we complete the entire task, and this can be
    done by using the `view.reloadData` class.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完成整个任务后，我们必须重新加载视图，这可以通过使用 `view.reloadData` 类来完成。
- en: Picture speaks louder than words
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图片胜于言语
- en: Let's now show a thumbnail image of a restaurant next to its name. In the JSON
    API call, we also see that we are getting the link for the restaurant image. So,
    we use this URL to display the image with the restaurant name in the table view.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们显示餐厅名称旁边的缩略图。在JSON API调用中，我们还可以看到我们正在获取餐厅图片的链接。因此，我们使用此URL在表格视图中显示带有餐厅名称的图片。
- en: 'Update `restaurant_controller.rb` as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式更新 `restaurant_controller.rb`：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`UIImage.alloc.initWithData` initializes and returns the image object with
    the specified data, and `NSData.alloc.initWithContentsOfURL` initializes a newly
    allocated data object initialized with the data from the location specified by
    a URL.'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImage.alloc.initWithData` 使用指定的数据初始化并返回图像对象，而 `NSData.alloc.initWithContentsOfURL`
    使用URL指定的位置的数据初始化一个新分配的数据对象。'
- en: Once again let's fire up our simulator to see the progress. Run `rake` from
    the `app` folder.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次启动我们的模拟器以查看进度。从 `app` 文件夹运行 `rake`。
- en: '![Picture speaks louder than words](img/5220OT_04_10.jpg)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![图片胜于言语](img/5220OT_04_10.jpg)'
- en: Isn't that simple! We can now see an image displayed next to the restaurant
    name.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 难道这不简单！我们现在可以看到餐厅名称旁边的图片显示出来了。
- en: Play time
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏时间
- en: It's time for a small do-it-yourself exercise. In the same application put some
    description about the restaurant in each row of the table.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候进行一个小型的 DIY 练习了。在同一个应用程序中，在表格的每一行中添加一些关于餐厅的描述。
- en: '![Play time](img/5220OT_04_09.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![玩耍时间](img/5220OT_04_09.jpg)'
- en: Tip
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We get the description in our API and it is already stored in the `Restaurant`
    object. To display this in the view you can use `detailTextLabel` on the cell
    object, as we have used in `textLabel`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在API中获取描述，并且它已经存储在`Restaurant`对象中。要在视图中显示这个信息，你可以在单元格对象上使用`detailTextLabel`，就像我们在`textLabel`中使用的那样。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let''s recap what we have learned in this iteration:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在本迭代中学到的内容：
- en: Model-View-Controller architecture
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型-视图-控制器架构
- en: Using an MVC design with RubyMotion
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RubyMotion进行MVC设计
- en: Connecting our application with an external API
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将我们的应用程序与外部API连接
- en: Augmenting our app with search and images
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的应用程序添加搜索和图片功能
- en: In the next chapter, we will turn our attention to user interface (UI) for mobile
    applications. UI is a key area in mobile application development, and we will
    learn about various Objective-C classes, which make user interface more interactive,
    and how they can be used in our RubyMotion application.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注移动应用程序的用户界面（UI）。UI是移动应用程序开发中的关键领域，我们将了解各种Objective-C类，它们使得用户界面更加互动，以及如何在我们的RubyMotion应用程序中使用它们。
