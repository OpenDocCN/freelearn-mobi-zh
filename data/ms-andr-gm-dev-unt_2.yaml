- en: Finishing the Perky Penguin 2D Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完成Perky Penguin 2D游戏
- en: The previous chapter was all about new and beginner developers interested in
    Unity and game development. As this book is focused on game development for the
    Android platform, so the previous chapter, which happens to be the very first
    chapter of the book, introduced the Android platform, its different versions,
    and its marketplace, Google Play. Then the chapter revised the concepts of game
    engines and then brought Unity 3D into light by comparing it with other major
    game engines such as Unreal, Adobe Flash, and Game Maker Studio. The chapter made
    a transition through the very basics of Unity game development, such as introducing
    Unity's interface, its panels, such as the inspector panel, the hierarchy panel,
    and so on. It also introduced the concepts of scene view and game view and how
    they interact with each other and how these views help developers to make it an
    easy and fun experience to create awesome games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章主要介绍了对Unity和游戏开发感兴趣的新手开发者。由于本书专注于Android平台的游戏开发，因此上一章，也就是本书的第一章，介绍了Android平台、其不同版本以及其市场，即Google
    Play。然后本章回顾了游戏引擎的概念，并通过与其他主要游戏引擎（如Unreal、Adobe Flash和Game Maker Studio）的比较，突出了Unity
    3D。本章通过介绍Unity游戏开发的基础知识，如Unity的界面、其面板（如检查器面板、层次结构面板等），以及场景视图和游戏视图的概念，以及它们如何相互作用以及这些视图如何帮助开发者使创建游戏变得简单而有趣。
- en: 'This chapter includes the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下主题：
- en: Adding particle systems to a game
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向游戏中添加粒子系统
- en: Camera management
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像机管理
- en: Prefabs and level management
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预制体和关卡管理
- en: Lasers and enemies in a game
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏中的激光和敌人
- en: 'After providing enough information on the theoretical side of unity game development
    for Android platforms, the previous chapter started practical examples from configuring
    empty game projects which are especially useful for 2D games. Configuring empty
    projects is the very first step in any game and we covered this in [Chapter 1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml),
    *Introduction to Android Game Development with Unity 3D*, in a very practical
    manner, and we also introduced a 2D game called **Perky Penguin**. The following
    is the screenshot of the game from the previous chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Android平台的游戏开发提供了足够的Unity游戏开发理论方面的信息之后，上一章从配置空游戏项目开始，这些项目对于2D游戏特别有用。配置空项目是任何游戏的第一个步骤，我们在[第1章](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml)，*使用Unity
    3D介绍Android游戏开发*中，以非常实用的方式进行了介绍，并且我们还介绍了一个名为**Perky Penguin**的2D游戏。以下是从上一章中截取的游戏截图：
- en: '![](img/image_02_001.png)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_001.png)'
- en: Figure 2.1 Perky Penguin game
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 Perky Penguin游戏
- en: We learned how a player, such as the penguin, is added in Unity and how the
    colliders and physics were applied on the penguin. Unity also supports scripting
    and programming in C# or JavaScript languages to define custom behaviors such
    as making the penguin jump, avoiding gravity while flying, stopping the penguin
    from leaving the screen during gameplay, and so on. The chapter finished by having
    a Perky Penguin game with a penguin jumping in it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何在Unity中添加玩家，例如企鹅，以及如何将碰撞体和物理效果应用于企鹅。Unity还支持使用C#或JavaScript语言进行脚本编写和编程，以定义自定义行为，例如让企鹅跳跃、在飞行时避免重力、在游戏过程中阻止企鹅离开屏幕等等。本章以一个包含跳跃企鹅的Perky
    Penguin游戏结束。
- en: If you are already familiar with the 2D concepts of Unity or have created 2D
    games already, then you can skip this chapter and move on to the third dimension.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉Unity的2D概念或者已经创建了2D游戏，那么你可以跳过这一章，直接进入第三维度的学习。
- en: In this chapter, we will finish this Penguin Perky game by learning some other
    advanced concepts of Unity 2D, such as adding particle effects, camera management,
    creating levels, using animations and controllers introduced in Unity 4.x versions,
    and so on. Until now, the Perky Penguin game has a cute penguin that can fly and
    jump on the screen but it can't walk forward and neither can it explore the game
    world. One thing to note here is that how the penguin is flying, whereas in real
    life, penguins don't fly. In our game, the penguin has got its hands on a red
    rocket which gives a boost of fire on the penguin to make it fly for a little
    instant. In the game, this boost is applied by a single tap on the screen of an
    Android device.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将通过学习Unity 2D的一些其他高级概念来完成Penguin Perky游戏，例如添加粒子效果、相机管理、创建关卡、使用Unity 4.x版本中引入的动画和控制器等。到目前为止，Perky
    Penguin游戏有一个可以飞和在屏幕上跳跃的可爱企鹅，但它不能向前行走，也不能探索游戏世界。在这里需要注意的是企鹅是如何飞行的，而在现实生活中，企鹅是不会飞的。在我们的游戏中，企鹅得到了一个红色火箭，它给企鹅提供了短暂的火焰助推，使其能够飞行。在游戏中，这个助推是通过在Android设备的屏幕上轻触一次来实现的。
- en: In the next section, we will start work on our game and bring the game to life
    by adding particle effects.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始制作我们的游戏，并通过添加粒子效果使游戏栩栩如生。
- en: Adding Particle Systems
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加粒子系统
- en: Before we delve into the details of particle systems, let's discuss what exactly
    these systems are and how they are used. Let's start with a discussion of what
    particle systems are.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨粒子系统的细节之前，让我们讨论一下这些系统究竟是什么以及它们是如何被使用的。让我们从讨论粒子系统是什么开始。
- en: What is a Particle System?
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是粒子系统？
- en: In any 3D complex game, characters, props, and environment elements are mostly
    created as 3D meshes and models, while in 2D games, sprites and images are used
    for these same purposes. Now, whether these objects are meshes or sprites, they
    mostly represent solid objects which contain a well-defined shape. But any game
    contains other entities such as fluids, liquids, smokes, clouds, flames, magic
    balls, and so on. These are some sort of special kinds of animations and objects,
    and are handled also with a special type of properties and behaviors, called particle
    systems in Unity.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何3D复杂游戏中，角色、道具和环境元素大多以3D网格和模型的形式创建，而在2D游戏中，则使用精灵和图像来达到相同的目的。现在，无论这些对象是网格还是精灵，它们大多代表具有明确形状的实体。但任何游戏都包含其他实体，如流体、液体、烟雾、云、火焰、魔法球等。这些都是某种特殊类型的动画和对象，并且使用特殊类型的属性和行为来处理，在Unity中称为粒子系统。
- en: 'The screenshot below shows some interesting magic spell particle systems created
    in Unity:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图展示了在Unity中创建的一些有趣的魔法法术粒子系统：
- en: '![](img/image_02_002.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_002.jpg)'
- en: 'Figure 2.2: Different Particle Effects or magic spells created in Unity'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2：在Unity中创建的不同粒子效果或魔法法术
- en: Particles are small and simple images, or even meshes, that are displayed and
    animated in a huge number by a full-fledged system known as a Particle System.
    In any particle system, each small particle contributes a minor role and, overall,
    it looks like some highly polished animation or effect. For example, a snowfall
    effect can be treated as a particle system. A single particle of snow doesn't
    represent any snowfall if it is animated singularly, but if those same single
    snow particles are animated in a huge quantity with random speed, random direction,
    and random size, all these particles will not look like some image animation;
    rather, they will look like a system of snowfall in the game. That's the main
    key power of using a Particle System in Unity--it allows batch operations of heavy
    code in a very light and optimized way, resulting in very beautiful effects for
    games.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子是小型且简单的图像，甚至是网格，它们通过一个称为粒子系统的完整系统以大量显示和动画化。在任何粒子系统中，每个小粒子都扮演着微小的角色，整体上看起来像一些高度抛光的动画或效果。例如，下雪效果可以被视为一个粒子系统。单个雪花粒子如果单独动画化，不代表任何下雪，但如果这些单个雪花粒子以大量、随机速度、随机方向和随机大小进行动画化，所有这些粒子看起来就不会像某种图像动画；相反，它们将看起来像游戏中下雪的系统。这就是在Unity中使用粒子系统的关键优势——它允许以非常轻量和优化的方式批量操作重代码，从而产生非常美丽的游戏效果。
- en: Basics of Particle System
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统的基础
- en: In Unity, a Particle System consists of all of the particles. Developers are
    only expected to manage the particles and the rest will be handled by Unity. Each
    particle has a predetermined lifetime through various changes, such as fading
    away for any snowfall effect, or getting scaled up and fading for any smoke effect,
    and so on. Like all other physical game objects, these particles have velocity
    to change the speed and direction throughout their lifetime duration, and these
    particles can be affected by forces and gravity applied by the environment's physics
    kinematics.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，粒子系统由所有粒子组成。开发者只需要管理粒子，其余的将由Unity处理。每个粒子都有预定的生命周期，通过各种变化，例如，任何雪落效果中的渐隐，或者烟雾效果中的放大和渐隐等。像所有其他物理游戏对象一样，这些粒子具有速度，可以在其生命周期内改变速度和方向，并且这些粒子可以受到环境物理动力学施加的力和重力的影响。
- en: The developers' end is to manage and control the particle's lifetime and its
    behavior, such as how many seconds will a particle last? How it will grow throughout
    its lifetime duration? Will it scale up or not? Will it fade away throughout its
    lifetime? All these questions are answered by developers and Unity will award
    them an amazing particle system in the form of an effect.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者的目标是管理和控制粒子的生命周期及其行为，例如，一个粒子会持续多少秒？它在其生命周期内会如何增长？它会放大还是不会？它在其生命周期内会逐渐消失吗？所有这些问题都由开发者回答，Unity将授予他们一个以效果形式出现的令人惊叹的粒子系统。
- en: The particles can be as simple as a sphere of white color or can be as complex
    as any mesh with high-resolution texture and normal maps.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子可以是简单的白色球体，也可以是具有高分辨率纹理和法线图的任何网格。
- en: The particle system's job is to manage all these particles from an abstract
    view. This system tells when to generate the next particle and where it should
    be, with what position, rotation, and scale. What should be the emission shape
    of the system, for example, hemisphere, code, or simple box? What should be the
    emission rate of the particles and how long should any particle effect take to
    execute one complete cycle of the system?
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 粒子系统的工作是从一个抽象的角度管理所有这些粒子。这个系统会告诉何时生成下一个粒子以及它应该在什么位置，以什么位置、旋转和缩放。例如，系统的发射形状应该是半球形、圆锥形还是简单的盒子？粒子的发射速率应该是多少，以及任何粒子效果应该持续多长时间来完成一个完整的循环？
- en: Creating a rocket fire Particle Effect for a game
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为游戏创建火箭火焰粒子效果
- en: 'So, after getting to grips with some basic knowledge of particle effects and
    particle systems in Unity, let''s put this knowledge into action by creating the
    first particle system for our Perky Penguin game. As we know, the penguin wears
    a rocket tied to its back which lets it fly and boost when tapped on screen by
    the player. Now, this rocket will create a small fire-like effect when it becomes
    active. The following screenshot shows the rocket with its fire effect of boost
    as the final result of this small particle system exercise:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在掌握了Unity中粒子效果和粒子系统的一些基本知识后，让我们通过为我们的Perky Penguin游戏创建第一个粒子系统来将这些知识付诸实践。正如我们所知，企鹅背着一个火箭，玩家在屏幕上点击时，它可以让企鹅飞行并加速。现在，这个火箭在激活时将产生一个类似火焰的小效果。以下屏幕截图显示了火箭及其火焰效果作为这个小粒子系统练习的最终结果：
- en: '![](img/image_02_003.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_003.png)'
- en: 'Figure 2.3: Rocket''s fire effect final result'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3：火箭火焰效果最终结果
- en: As shown in the preceding screenshot, you can observe how the fire starts from
    the edge of the rocket and how it disappears slowly with a fading effect, similar
    to real life. Now, let's create this simple particle effect for our penguin's
    rocket in our last created `PerkyPenguin_PenguinMovement` project from [Chapter
    1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml), *Introduction to Android Game
    Development with Unity 3D*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，你可以观察到火焰是如何从火箭边缘开始，并且如何以渐隐效果缓慢消失，这与现实生活相似。现在，让我们在我们的上一章创建的`PerkyPenguin_PenguinMovement`项目中创建这个简单的粒子效果，该项目来自[第1章](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml)，《使用Unity
    3D的Android游戏开发入门》。
- en: 'Let''s start creating a particle system object by selecting GameObject | Particle
    System as shown in the following figure:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从选择GameObject | 粒子系统开始创建一个粒子系统对象，如图下所示：
- en: '![](img/image_02_004.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_004.png)'
- en: Figure 2.4 Creating Particle System GameObject
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 创建粒子系统GameObject
- en: 'This will add a game object with the name Particle System in the Hierarchy
    panel immediately. But you might notice a strange thing here of the white spheres
    moving outward in the Scene View as soon the object is created and selected. The
    screenshot below shows a simple example of those white spheres in the Scene view
    below:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在层次结构面板中立即添加一个名为粒子系统的游戏对象。但你可能在这里注意到一个奇怪的现象，即对象创建并选择后，场景视图中白色球体向外移动。下面的截图显示了场景视图中这些白色球体的简单示例：
- en: '![](img/image_02_005.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_005.png)'
- en: Figure 2.5 A Particle System GameObject selected in Unity
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.5 在Unity中选中的粒子系统GameObject
- en: You can see that, as we created a Particle System object, a simple white sphere
    particle system started playing in the scene. A small control panel is shown in
    the scene, consisting of controls such as pause, stop, playback speed, and playback
    time. As you select any other game object or deselect the Particle System game
    object, the Particle System will stop automatically.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，当我们创建了一个粒子系统对象后，一个简单的白色球体粒子系统开始在场景中播放。场景中显示了一个小型控制面板，包括暂停、停止、播放速度和播放时间等控件。当你选择任何其他游戏对象或取消选择粒子系统游戏对象时，粒子系统会自动停止。
- en: One of feature of the interface of Unity is that developers don't need to play
    the game in order to test their particle systems. These can be checked directly
    within the scene view.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Unity界面的一项特性是，开发者无需玩游戏就可以测试他们的粒子系统。这些可以直接在场景视图中进行检查。
- en: 'Also, you should notice the Inspector panel of the selected Particle System
    and see how lots of different properties are shown in the Particle System component
    of the object, as shown in the following screenshot:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该注意所选粒子系统的检查器面板，并查看对象中的粒子系统组件如何显示许多不同的属性，如下面的截图所示：
- en: '![](img/image_02_006.png)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_006.png)'
- en: Figure 2.6 Particle System component in Inspector panel
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 检查器面板中的粒子系统组件
- en: 'It would be good to know that almost everything about the Unity''s Particle
    System is provided in this Particle System component, which is a set of a huge
    number of properties. On tweaking and changing the values of these properties,
    a snowfall can be converted into burning fire, or it can be converted into an
    explosion for any airplane games, or it can be converted in a magic ball or magic
    spell for any dungeon role-playing games, and so on. To learn about it, let''s
    continue our rocket fire particle system by following the steps given below:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Unity的粒子系统几乎所有的内容都包含在这个粒子系统组件中，这是一个包含大量属性的集合。通过调整和更改这些属性的值，可以将下雪转换为燃烧的火焰，或者将其转换为任何飞机游戏的爆炸效果，或者将其转换为任何地牢角色扮演游戏的魔法球或魔法咒语，等等。要了解这些，让我们继续通过以下步骤学习火箭火焰粒子系统：
- en: 'In order to put the particle system always below the rocket, it should be a
    child of the penguin object. So drag the Particle System object onto the penguin
    game object in the Hierarchy panel and you will see something like the following
    screenshot:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使粒子系统始终位于火箭下方，它应该是企鹅对象的子对象。因此，将粒子系统对象拖动到层次结构面板中的企鹅游戏对象上，你将看到如下截图所示的内容：
- en: '![](img/image_02_007.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_007.png)'
- en: Figure 2.7 Particle System GameObject as child of penguin object
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 粒子系统GameObject作为企鹅对象的子对象
- en: Rename the Particle System to rocketFire.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将粒子系统重命名为rocketFire。
- en: Set its Position to (-0.62, -0.33, 0) to move it to the nozzle of the rocket.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其位置设置为(-0.62, -0.33, 0)以将其移动到火箭的喷嘴处。
- en: Set its Rotation to (65, 270, 270) to set the direction of the particles in
    orientation with the rocket.
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将其旋转设置为(65, 270, 270)以设置粒子在火箭方向上的方向。
- en: 'The following screenshot highlights all the changes provided in the above steps
    of the Inspector panel:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图突出了在检查器面板上述步骤中提供的所有更改：
- en: '![](img/image_02_008.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/image_02_008.png)'
- en: Figure 2.8 The rocketFire Transform in Inspector panel
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.8 检查器面板中的rocketFire变换
- en: 'Still in the Inspector panel with the rocketFire particle system object selected,
    let''s alter the values of the Particle System component to create a beautiful
    type of fire for our penguin''s rocket to boost. Here are the steps to follow:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然在检查器面板中，选择了rocketFire粒子系统对象，让我们更改粒子系统组件的值，为我们的企鹅火箭创建一种美丽的火焰效果。以下是需要遵循的步骤：
- en: Set Start Lifetime to 0.5
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始生命周期为0.5
- en: Set Start Size to 0.3
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置起始大小为0.3
- en: Click on Start Color and set Red to 255, Green to 135, Blue to 40 and Alpha
    to 255, this will turn our white particles into orange ones
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击“起始颜色”，将红色设置为255，绿色设置为135，蓝色设置为40，Alpha设置为255，这将使我们的白色粒子变为橙色
- en: Expand the Emission section and set Rate to 300
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开发射部分，将速率设置为300
- en: Expand the Shape section and set Shape to Cone, Angle to 12 and Radius to 0.1
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展开形状部分，将形状设置为圆锥形，角度设置为12，半径设置为0.1
- en: Set the Random Direction checkbox to checked state to create randomness in fire
    particles
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将“随机方向”复选框设置为选中状态，以在火焰粒子中创建随机性
- en: 'The following screenshot shows the Particle System component''s previously
    set along with its result of rocket fire below the penguin in the Scene view:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了粒子系统组件之前设置的设置，以及场景视图中企鹅下面的火箭火焰效果：
- en: '![](img/image_02_009.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_009.png)'
- en: Figure 2.9 The rocketFire Particle System
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.9 火箭火焰粒子系统
- en: 'You can observe how the random white spheres being generated and moving in
    random directions have changed into a cone-shaped fire emission from a rocket
    tied on the back of the penguin. What we have done is to alter some values in
    the Particle System component in the Inspector panel. Let''s briefly look at what
    these properties actually do:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到随机生成的白色球体以随机方向移动，并从企鹅背部绑定的火箭中变成了锥形火焰发射。我们所做的是在检查器面板中更改粒子系统组件的一些值。让我们简要看看这些属性实际上做什么：
- en: '**Start Lifetime** is the total lifetime in seconds that particles will have
    when emitted'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始寿命**是发射时粒子的总寿命（以秒为单位）'
- en: '**Start Size** is the initial size of particles when emitted'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始大小**是发射时粒子的初始大小'
- en: '**Start Color** is the initial color of particles when emitted'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开始颜色**是发射时粒子的初始颜色'
- en: '**Emission Rate** is the number of particles emitted per unit of time or distance
    moved'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**发射率**是每单位时间或移动距离发射的粒子数量'
- en: '**Shape** is the shape of the emission volume: the options are *Sphere*, *Hemisphere*,
    *Cone*, *Box*, *Mesh*, *Circle* and *Edge*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**是发射体积的形状：选项有*球体*、*半球体*、*圆锥体*、*盒子*、*网格*、*圆形*和*边缘*'
- en: '**Angle** is the angle of the cone at its point (for cones only)'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角度**是圆锥在其顶点的角度（仅适用于圆锥）'
- en: '**Radius** is the radius of the circular aspect of the shape'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**是形状圆形部分的半径'
- en: '**Random Direction** enabled means that the particles'' initial direction will
    be chosen randomly'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**随机方向**启用意味着粒子的初始方向将被随机选择'
- en: You can see more of these properties and their purposes on Unity's manual or
    documentation website at [http://docs.unity3d.com/Manual/ParticleSystemModules.html](http://docs.unity3d.com/Manual/ParticleSystemModules.html).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Unity的官方手册或文档网站上找到更多这些属性及其用途的信息：[http://docs.unity3d.com/Manual/ParticleSystemModules.html](http://docs.unity3d.com/Manual/ParticleSystemModules.html)。
- en: So, our rocket fire Particle System is ready. But, in real life, fire never
    ends instantly, it always ends by getting faded over time. We can also add this
    property into our fire by enabling the Start Color property in the Particle System
    component. Then click on the Color box and select the top slider on the right,
    which is for alpha of the end color, and set its value to 0.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的火箭火焰粒子系统已经准备好了。但在现实生活中，火焰永远不会瞬间结束，它总是随着时间的推移逐渐消失。我们也可以通过在粒子系统组件中启用“开始颜色”属性来添加这个特性。然后点击颜色框，选择右侧顶部的滑块，这是用于结束颜色的alpha值，并将其设置为0。
- en: 'The whole setting is shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 整个设置在以下截图中显示：
- en: '![](img/image_02_010.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_010.png)'
- en: Figure 2.10 Adding fade effect in fire using Color over Lifetime
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 使用“颜色随时间变化”在火焰中添加渐变效果
- en: 'If you are not sure of what exactly Color over Lifetime changed in the fire
    effect, the following screenshot shows the difference in the fire particle system
    with and without the fading effect:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定“颜色随时间变化”在火焰效果中具体改变了什么，以下截图显示了带有和没有渐变效果的火焰粒子系统的差异：
- en: '![](img/image_02_011.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_011.png)'
- en: Figure 2.11 The fire effects with and without fade effects
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 带有和没有渐变效果的火焰效果
- en: So far, we have a penguin which flies on a tap of the screen and its rocket
    is exploding fire all the time. Now it's time to put some environment in the game
    to make the theme of the game. This environment will be for the penguin to move
    forward through and our game needs an endless room for the background. But, in
    order to test the penguin walking, we will only add background without any endless
    moving functionality.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个企鹅在屏幕上轻触时飞行的效果，它的火箭一直在爆炸出火焰。现在，是时候在游戏中添加一些环境来营造游戏的主题了。这个环境将让企鹅能够通过，而我们的游戏需要一个无尽的房间作为背景。但是，为了测试企鹅的行走，我们只会添加背景，而不添加任何无限移动的功能。
- en: Adding game-level backgrounds
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加游戏级别的背景
- en: A game with no background or theme is no game at all. So far, the penguin has
    got no reason to walk through the game, fly, or use its rocket to boost because
    it is in a void space of blue color. Let's bring this penguin into the snowy and
    hilly world where it actually belongs. And in order to survive melting ice due
    to global warming, it can also use its rocket to fly a little. In this section,
    we will learn how to add backgrounds and how the order of these backgrounds and
    sprites is managed in any 2D game where z-order is not used at all.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有背景或主题的游戏根本不是游戏。到目前为止，企鹅没有理由在游戏中行走、飞翔或使用它的火箭助推，因为它处于蓝色的虚空空间中。让我们把这个企鹅带到它真正属于的雪地和山丘世界中。为了生存全球变暖导致的融冰，它也可以使用它的火箭稍微飞一下。在本节中，我们将学习如何添加背景，以及在任何不使用
    z-顺序的 2D 游戏中如何管理这些背景和精灵的顺序。
- en: 'We will start by creating backgrounds for the levels of the game. These backgrounds
    can be created in your favorite graphics tools, such as Adobe Photoshop and so
    on. The following screenshot shows the background we created for the Perky Penguin
    game:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先为游戏的不同级别创建背景。这些背景可以用您喜欢的图形工具创建，例如 Adobe Photoshop 等。以下截图显示了为活泼企鹅游戏创建的背景：
- en: '![](img/image_02_012.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_012.png)'
- en: Fig 2.12 Background of the Penguin Perky Game
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.12 鹦鹉螺活泼游戏的背景
- en: 'We have already learned about how the images are imported as sprites in Unity.
    For backgrounds, we have to do exactly the same procedure again. We have prepared
    two repeatable images with the names `bg_snow1.png` and `bg_snow2.png` and imported
    these images into the Graphics folder of the Assets directory in the Project Browser
    panel. The following screenshot shows the Project Browser panel with background
    images in it:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何在 Unity 中将图像作为精灵导入。对于背景，我们必须再次执行完全相同的程序。我们已经准备了两个名为 `bg_snow1.png`
    和 `bg_snow2.png` 的可重复图像，并将这些图像导入到项目浏览器面板中资产目录的图形文件夹中。以下截图显示了包含背景图像的项目浏览器面板：
- en: '![](img/image_02_013.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_013.png)'
- en: Figure 2.13 Backgrounds in the Project browser panel
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 项目浏览器面板中的背景
- en: 'It must be noted that the backgrounds should be repeatable so that when these
    images are put together, they should merge and avoid players recognizing the repeating
    order. The following screenshot shows both the background images we have designed
    for the Penguin Perky game:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意的是，背景应该是可重复的，这样当这些图片放在一起时，它们应该合并并避免玩家识别出重复的顺序。以下截图显示了为鹦鹉螺活泼游戏设计的两个背景图片：
- en: '![](img/image_02_014.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_014.png)'
- en: Figure 2.14 Backgrounds of Penguin Perky game
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.14 鹦鹉螺活泼游戏的背景图
- en: You can see in the images that if we keep these two images repeating beside
    each other, it will create a very smooth background which will forever be repeating
    over and over again. We will do that with some scripting later in this chapter.
    For now, let's set up the scene background of the game.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从图片中看到，如果我们将这些两张图片并排重复，将创建一个非常平滑的背景，它将永远重复。我们将在本章后面通过一些脚本实现这一点。现在，让我们设置游戏场景的背景。
- en: 'After importing the background images in the Graphics folder of Assets, place
    two objects of `bg_snow1.png` and one object of `bg_snow2.png` in the Hierarchy
    panel. Set the first `bg_snow1.png` position to (0, 0, 0), then the `bg_snow2.png`
    position to (4.8, 0, 0), and finally another `bg_snow1.png` position to (9.6,
    0, 0), and you will get a small background in the scene. So, now you will observe
    that the penguin is hidden behind these backgrounds. As this is a 2D game, so
    there is no concept of a z-axis here. We can set the z-axis position and bring
    forward and backward the sprites and images but for 2D games it is not a good
    approach. Unity provides developers with an ordering mechanism for placing 2D
    images front and backward optimized for 2D games especially. This is done through
    the sorting layers. Select the `bg_snow1` object in the Hierarchy panel and look
    at the Inspector in the SpriteRenderer component, and you will see an option of
    Sorting Layer as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 Assets 文件夹中的图形背景图像导入后，在层次结构面板中放置两个 `bg_snow1.png` 对象和一个 `bg_snow2.png` 对象。将第一个
    `bg_snow1.png` 的位置设置为 (0, 0, 0)，然后 `bg_snow2.png` 的位置设置为 (4.8, 0, 0)，最后另一个 `bg_snow1.png`
    的位置设置为 (9.6, 0, 0)，你将在场景中得到一个小背景。因此，现在你会观察到企鹅隐藏在这些背景之后。由于这是一个2D游戏，所以这里没有z轴的概念。我们可以设置z轴位置并前后移动精灵和图像，但对于2D游戏来说，这不是一个好的方法。Unity为开发者提供了一个针对2D游戏优化的2D图像前后排序机制。这是通过排序图层来实现的。在层次结构面板中选择
    `bg_snow1` 对象，并查看精灵渲染器组件中的检查器，你将看到一个排序图层选项，如下面的截图所示：
- en: '![](img/image_02_015.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_015.png)'
- en: Figure 2.15 Sorting Layer in SpriteRenderer in Inspector panel
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.15 检查器面板中的精灵渲染器排序图层
- en: 'Initially, all the sprites you import in Unity have a default sorting layer.
    Click on the drop-down menu and you will see the list of all sorting layers in
    the project. At the moment, we only have one layer called Default and there is
    another option, Add Sorting Layer..., to add a new layer. Click on the Add Sorting
    Layer... option as shown in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，您在Unity中导入的所有精灵都有一个默认排序图层。点击下拉菜单，你将看到项目中所有排序图层的列表。目前，我们只有一个名为默认的图层，还有一个添加排序图层...选项来添加新图层。点击添加排序图层...选项，如下面的截图所示：
- en: '![](img/image_02_016.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_016.png)'
- en: Figure 2.16 Add Sorting Layer... option
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.16 添加排序图层...选项
- en: 'This will open a new Tags & Layers panel in place of the Inspector panel. Add
    four layers, namely Background, Surroundings, Objects, and Player in the order
    as explained. This is shown in the following screenshot:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在检查器面板的位置打开一个新的标签和图层面板。按照解释的顺序添加四个图层，即背景、周围环境、对象和玩家。如下面的截图所示：
- en: '![](img/image_02_017.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_017.png)'
- en: Figure 2.17 Sorting Layers panel
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.17 排序图层面板
- en: You can drag these layers up or down by pressing and dragging the two lines
    icon to the left of each layer row. Moving these layers up or down describes the
    order of layers. For example, currently the Default layer is the lowest layer
    and it will be behind everything, and the Player layer will be in front of everything that
    uses layers except the Player layer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过按住并拖动每个图层行左侧的两个线条图标来上下拖动这些图层。上下移动这些图层描述了图层的顺序。例如，当前默认图层是最低的图层，它将位于所有内容之后，而播放器图层将位于除播放器图层之外使用图层的所有内容之前。
- en: There is a huge difference between Sorting Layers and Layers. Sorting Layers
    are only used to arrange 2D sprites for 2D games but the Layers are not for arranging
    purposes. It's totally a different concept and you must be careful when using
    layers in order to avoid any conflict between layers and sorting layers.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 排序图层和图层之间有很大的区别。排序图层仅用于排列2D游戏中的2D精灵，而图层不是用于排列目的。这是一个完全不同的概念，你必须在使用图层时小心，以避免图层和排序图层之间发生任何冲突。
- en: 'Right now, we only need Player and Background sorting layers; we will use other
    layers later in this chapter. Now, select the penguin game object in the Hierarchy
    panel and choose the Player layer from the Sorting Layer option in Sprite Renderer,
    as shown in the following screenshot:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只需要玩家和背景排序图层；我们将在本章的后面使用其他图层。现在，在层次结构面板中选择企鹅游戏对象，并在精灵渲染器的排序图层选项中选择玩家图层，如下面的截图所示：
- en: '![](img/image_02_018.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_018.png)'
- en: Figure 2.18 Selecting Penguin's Sorting Layer
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.18 选择企鹅的排序图层
- en: Similarly, select the Background layer for all the snow background objects in
    the scene. And now you will observe that the penguin will be in front of these
    snow backgrounds.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，选择场景中所有雪背景对象的背景层。现在你会观察到企鹅将位于这些雪背景之前。
- en: Camera management
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机管理
- en: So now we have a game in which we have a penguin that can fly and jump with
    a rocket fire particle system effect. Also, we have a basic environment of snow
    backgrounds in the scene as well. In this section, we will learn about how we
    to make the penguin move throughout an endless generated level and how the camera
    will always be focused on the penguin.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有一个游戏，其中有一个可以飞行和跳跃的企鹅，带有火箭喷射粒子系统效果。此外，场景中还有一个基本的雪背景环境。在本节中，我们将了解如何使企鹅在无限生成的水平面上移动，以及摄像机将始终聚焦在企鹅上。
- en: Making the penguin move forward
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使企鹅向前移动
- en: 'Let''s start by making our penguin move in a forward direction. To do that,
    open the file `PenguinController.cs` created in [Chapter 1](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml),
    *Introduction to Android Game Development with Unity3D*. This file is contained
    in the Scripts folder of the Assets directory. Add the forward speed public field
    in the class, as shown in the following code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先让我们的企鹅向前移动。为此，打开在[第1章](ca00129d-f14f-4f32-9ceb-9d05d828b98b.xhtml)，“使用Unity3D开发Android游戏入门”中创建的文件`PenguinController.cs`。此文件位于Assets目录的Scripts文件夹中。在类中添加一个公共字段前进速度，如下面的代码所示：
- en: '[PRE0]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Recall that adding any public field results in the addition of a property in
    the script''s game object, as shown in the Inspector panel in the following screenshot:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，添加任何公共字段都会在脚本的游戏对象中添加一个属性，如下面截图中的Inspector面板所示：
- en: '![](img/image_02_020.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.20](img/image_02_020.png)'
- en: Figure 2.19 Forward Movement speed field in the Inspector panel
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.19 Inspector面板中的前进移动速度字段
- en: 'Now, in order to move the penguin with any speed, we have to update the speed
    of the penguin in the `Update()` or `FixedUpdate()` methods. Since we are using
    the `FixedUpdate()` method in order to utilize the physics behavior of the penguin,
    so add this code at end of the `FixedUpdate()` method:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了以任何速度移动企鹅，我们必须在`Update()`或`FixedUpdate()`方法中更新企鹅的速度。由于我们正在使用`FixedUpdate()`方法来利用企鹅的物理行为，所以将此代码添加到`FixedUpdate()`方法的末尾：
- en: '![](img/image_02_021.png)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.21](img/image_02_021.png)'
- en: Well, there is not much of anything new in this code snippet. As we updated
    the penguin's y-position in through jetpack force, we are updating only the x-axis
    of the penguin's object. See how we are assigning `forwardMovementSpeed` in each
    frame on the velocity of penguin's game object. When you run the project, the
    penguin will start moving in the right direction, and after a minute, it will
    leave the screen. Our next task is to make the camera follow the penguin so that
    the penguin always remains on screen and never gets out of bounds of the camera.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，这段代码中没有太多新内容。由于我们通过喷气背包力量更新了企鹅的y位置，所以我们只更新了企鹅对象的x轴。看看我们是如何在每一帧上分配`forwardMovementSpeed`到企鹅游戏对象的速率。当你运行项目时，企鹅将开始向右移动，一分钟后，它将离开屏幕。我们的下一个任务是使摄像机跟随企鹅，这样企鹅就可以始终保持在屏幕上，永远不会超出摄像机的边界。
- en: Making the camera follow the Penguin
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使摄像机跟随企鹅
- en: 'Object as a child of the penguin game object, as shown in the following screenshot:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 企鹅游戏对象中的对象，如下面截图所示：
- en: 'We have lots of methods to make the camera follow the penguin. The easiest
    is to put the Camera object as a child of the penguin game object, as shown in
    the following screenshot:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有很多方法可以使摄像机跟随企鹅。最简单的是将摄像机对象作为企鹅游戏对象的子对象，如下面截图所示：
- en: '![](img/image_02_022.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![图片2.22](img/image_02_022.png)'
- en: Figure 2.21 Camera as child of the Penguin object
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.21 企鹅对象中的摄像机作为子对象
- en: 'Well, you can do this, but there is a problem with this solution. When the
    penguin jumps or flies, the camera also moves up or down with it. We don''t need
    that in our game. We only need to move the camera horizontally and continuously
    move forward keeping the penguin in the bounds. So, we will do that by creating
    another C# script file in the Script folder of the Assets directory with the name
    `CameraFollow.cs`. Now, add a public `GameObject` field with a variable named
    `targetObject`. This field will tell the camera about which object to follow.
    We will keep a reference of the penguin''s game object in this field. And finally,
    to move the camera continuously forward, we will do code similar to the penguin''s
    moving forward code. The only difference here is that we put our code in the `Update()`
    method instead of `FixedUpdate()`. The reason for this is that `FixedUpdate()`
    should be used when the object has a rigid body and/or other physical behaviors.
    As our camera has no connection with the physics, we can do this by simply adding
    the moving code in the `Update()` method. The following is the whole code of the
    `CameraFollow.cs` file:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，你可以这样做，但这个解决方案有一个问题。当企鹅跳跃或飞行时，摄像机也会上下移动。我们不需要这个在我们的游戏中。我们只需要摄像机水平移动，并持续向前移动，保持企鹅在边界内。所以，我们将通过在资产目录的脚本文件夹中创建另一个名为`CameraFollow.cs`的C#脚本文件来实现这一点。现在，添加一个名为`targetObject`的公共`GameObject`字段。这个字段将告诉摄像机要跟随哪个对象。我们将在这个字段中保留企鹅游戏对象的引用。最后，为了使摄像机持续向前移动，我们将编写类似于企鹅向前移动的代码。这里唯一的区别是我们将代码放在`Update()`方法中而不是`FixedUpdate()`方法中。这样做的原因是`FixedUpdate()`应该在对象具有刚体和/或其他物理行为时使用。由于我们的摄像机与物理没有连接，我们可以通过在`Update()`方法中添加移动代码来实现这一点。以下是`CameraFollow.cs`文件的完整代码：
- en: '![](img/image_02_023.png)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_023.png)'
- en: 'After writing the code, let''s put this script on the Camera object. Select
    the Main Camera object in the Hierarchy panel, and click on the Add Component
    button in Inspector and choose Scripts - CameraFollow.cs, as shown in the following
    screenshot:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码后，让我们将这个脚本放在摄像机对象上。在层次结构面板中选择主摄像机对象，然后在检查器中点击添加组件按钮，选择脚本 - CameraFollow.cs，如图以下截图所示：
- en: '![](img/image_02_024.png)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_024.png)'
- en: Figure 2.22 Adding CameraFollow.cs on camera
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.22 在摄像机上添加CameraFollow.cs
- en: You can also apply scripts on the game objects by simply dragging the script
    files from the Project Browser panel directly onto game objects in the Hierarchy
    panel.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过简单地从项目浏览器面板中将脚本文件拖动到层次结构面板中的游戏对象上来对游戏对象应用脚本。
- en: 'When you run the project, although the Camera will move, you will a see an
    error in the Debug Log panel, as shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行项目时，尽管摄像机在移动，你会在调试日志面板中看到一个错误，如图以下截图所示：
- en: '![](img/image_02_025.png)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_025.png)'
- en: Figure 2.23 Camera error in Debug Log
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.23 调试日志中的摄像机错误
- en: 'The problem is that the variable `targetObject` in the `CameraFollow` script
    is not assigned to any value and we are accessing it the `Update()` method. Recall
    from earlier that we need to assign the penguin game object in the `targetObject`
    value to tell the camera about the target to follow. You can use Unity''s public
    inspector feature and directly assign the penguin object by dragging it into the
    camera''s `targetObject` field in the Inspector panel, as shown in the following
    screenshot:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于`CameraFollow`脚本中的变量`targetObject`没有被分配任何值，我们在`Update()`方法中访问它。回想一下，我们需要在`targetObject`值中分配企鹅游戏对象，以便告诉摄像机要跟随的目标。你可以使用Unity的公共检查器功能，通过将企鹅对象直接拖动到检查器面板中的摄像机`targetObject`字段来分配企鹅对象，如图以下截图所示：
- en: '![](img/image_02_026.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_026.png)'
- en: Figure 2.24 Assigning Penguin Object in Target Object
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.24 在目标对象中分配企鹅对象
- en: Now run the game and you will see the camera will never allow the penguin off
    the screen. However, after moving for a short time, the penguin will start falling
    since its floor has been left behind and the penguin has no physical support to
    oppose its gravity. To fix this and continue with the game, we will now work on
    creating endless levels in the next section.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏，你会看到摄像机永远不会让企鹅离开屏幕。然而，移动一段时间后，企鹅会开始下落，因为它的地板已经被留下，企鹅没有物理支撑来抵抗重力。为了解决这个问题并继续游戏，我们将在下一节中创建无限关卡。
- en: Prefabs and level management
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件和关卡管理
- en: There is not a single game which doesn't contain at least one level. Levels
    are what makes games feel like an experience and adventure. Levels come with different
    kinds of difficulties and players start to have feelings of accomplishing something
    and rewards. So, to put the soul in our Penguin Perky game, let's add levels to
    our game. But the question that arises here is what type of levels we should add
    to the game. Since the game is endless, so it would be a very suitable to add
    automatically generated levels with random obstacles and enemies in the game.
    In order to do that, we need a script that will take care of generating random
    environments and rooms along with putting enemies and barriers to balance the
    game difficulty.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 没有一款游戏不包含至少一个级别。级别是让游戏感觉像是一种体验和冒险的原因。级别带有不同类型的难度，玩家开始感受到完成某事的成就感和奖励。因此，为了给我们的企鹅活泼游戏注入灵魂，让我们在我们的游戏中添加级别。但这里出现的问题是我们应该添加什么类型的级别到游戏中。由于游戏是无尽的，因此添加带有随机障碍和敌人的自动生成级别将非常合适。为了做到这一点，我们需要一个脚本，该脚本将负责生成随机环境和房间，并放置敌人和障碍物以平衡游戏难度。
- en: Unity provides developers with the opportunity to instantiate the game objects
    at runtime and define behaviours in them, also at runtime. We can add rooms, levels,
    coins, enemies, and so on separately at runtime but Unity provides a better and
    organized way to handle these types of situations to manage reusable elements
    at runtime. This is done through the Prefab objects. Let's discuss Prefabs in
    the next section.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: Unity为开发者提供了在运行时实例化游戏对象并在其中定义行为的机会，这些行为也可以在运行时定义。我们可以在运行时单独添加房间、级别、金币、敌人等等，但Unity提供了一个更好、更有组织的处理这些类型情况的方法来管理运行时可重复使用的元素。这是通过预制件对象实现的。让我们在下一节中讨论预制件。
- en: Prefabs
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 预制件
- en: According to Unity's documentation, a Prefab is a type of asset--a reusable
    `GameObject` stored in Project View. Prefabs can be inserted into any number of
    scenes, multiple times per scene. When you add a Prefab to a scene, you create
    an instance of it. All Prefab instances are linked to the original Prefab and
    are essentially clones of it. No matter how many instances exist in your project,
    when you make any changes to the Prefab, you will see the change applied to all
    instances.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 根据Unity的文档，预制件是一种资产类型——一个存储在项目视图中的可重复使用的`GameObject`。预制件可以被插入到任意数量的场景中，每个场景可以多次插入。当你将预制件添加到场景中时，你创建了一个它的实例。所有预制件实例都与原始预制件链接，并且本质上都是它的克隆。无论你的项目中存在多少个实例，当你对预制件进行任何更改时，你将看到更改应用于所有实例。
- en: 'The following screenshot shows the empty Prefab in the Project browser view:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了项目浏览器视图中的空预制件：
- en: '![](img/image_02_027.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_027.png)'
- en: Figure 2.25 An empty BoxPrefab in the Project browser panel
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.25 项目浏览器面板中的空BoxPrefab
- en: You will notice that we have a folder called Prefabs in our Assets directory.
    We created this folder when configuring the project. We will store all the Prefabs
    used in the game in this directory.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到在我们的资产目录中有一个名为“预制件”的文件夹。我们在配置项目时创建了此文件夹。我们将把游戏中使用的所有预制件存储在这个目录中。
- en: Prefabs are exactly like game objects. They can have colliders, rigid body,
    scripts, other components, and so on. The only difference between Prefabs and
    game objects is that Prefabs can be instantiated at runtime and copy the same
    behavior at runtime, but game objects can be generated at runtime.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件与游戏对象完全一样。它们可以有碰撞器、刚体、脚本、其他组件等等。预制件和游戏对象之间的唯一区别是预制件可以在运行时实例化并在运行时复制相同的行为，但游戏对象可以在运行时生成。
- en: In order to create an endless level, we have to create a small block of levels
    for our game. This block will be continuously generated at runtime over and over
    again as the penguin keeps going through the level. Let's create the small level
    block in the next section and see how this Prefab theory goes into action.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建一个无尽级别，我们必须为我们的游戏创建一个小块级别的集合。这个块将在企鹅不断通过级别时在运行时不断地重复生成。让我们在下一节中创建这个小级别块，看看这个预制件理论是如何付诸实践的。
- en: Creating a Level Block Prefab
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建级别块预制件
- en: The Level Block Prefab will have a ground object and a ceiling object to avoid
    the penguin going out of the bounds from the screen and it will have an environment
    in the background for decoration and theme purposes.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 级别块预制件将包含一个地面物体和一个天花板物体，以防止企鹅从屏幕边界外跑出去，并且它将有一个背景环境用于装饰和主题目的。
- en: 'Let''s start by creating an empty game object in the Hierarchy by right-clicking
    in hierarchy view and clicking Create Empty, as shown in the following screenshot:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在层次结构中右键单击层次结构视图并单击创建空对象开始，如图以下截图所示：
- en: '![](img/image_02_028.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_028.png)'
- en: Figure 2.26 Creating an empty GameObject
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.26 创建空GameObject
- en: Now, put all the necessary game objects to be included in the Prefab as a child
    of this empty game object. We are adding `snow_bg1` and `snow_bg2` backgrounds,
    the `floor` object, and the `ceiling` object at the moment. We can update it later
    at any time and add new objects and components in the Prefabs. But you must remember
    that it would change all the existing Prefab objects as well, so you must be careful
    when you update the Prefab.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将所有必要的游戏对象作为此空游戏对象的子对象放入预制件中。目前，我们正在添加`snow_bg1`和`snow_bg2`背景，`floor`对象和`ceiling`对象。我们可以在任何时候更新它并添加新的对象和组件到预制件中。但您必须记住，这将更改所有现有的预制件对象，因此在更新预制件时必须小心。
- en: 'All these objects can be dragged onto the empty created game object to make
    these children and rename the empty game object `level_block` then. The following
    screenshot shows the game object hierarchy of the `level_block` object:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些对象都可以拖动到创建的空游戏对象上，使其成为子对象，然后将空游戏对象重命名为`level_block`。以下截图显示了`level_block`对象的游戏对象层次结构：
- en: '![](img/image_02_029.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_029.png)'
- en: Figure 2.27 The level_block game object
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.27 level_block游戏对象
- en: If you have decorated your level block with more objects, decorations, surroundings,
    and so on, then you should also add them to the level block empty game object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您用更多对象、装饰、环境等装饰了层级块，那么您也应该将它们添加到层级块空游戏对象中。
- en: 'We have created a level block game object. Now it''s time to put it into Prefab
    form. To do that, right-click on the Prefabs folder in the Assets directory, and
    choose Create - Prefab from the menu, as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个层级块游戏对象。现在，是时候将其转换为预制件形式了。为此，在资产目录中的预制件文件夹上右键单击，并从菜单中选择创建 - 预制件，如图以下截图所示：
- en: '![](img/image_02_030.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_030.png)'
- en: Figure 2.28 Creating a Prefab
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.28 创建预制件
- en: 'It will create an empty Prefab in the Prefabs folder. Now, drag the level_block
    game object from the hierarchy view onto the empty created Prefab and your Prefab
    will be ready. This is shown in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 它将在预制件文件夹中创建一个空预制件。现在，将层级块游戏对象从层次结构视图拖动到创建的空预制件上，您的预制件就准备好了。以下截图显示了这一过程：
- en: '![](img/image_02_031.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_031.png)'
- en: Figure 2.29 Adding an Object to a Prefab
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.29 向预制件添加对象
- en: 'Once the Prefab is created, it will show you a small preview of the game object
    contents in the Project Browser panel. You will also observe a small arrow in
    it, which will explore all the objects put into the Prefab as well. The following
    screenshot shows the preview of Level Block Prefab in the Project Browser panel:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件创建后，将在项目浏览器面板中显示游戏对象内容的小预览。您还会注意到其中有一个小箭头，它将探索放入预制件中的所有对象。以下截图显示了项目浏览器面板中层级块预制件的预览：
- en: '![](img/image_02_032.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_032.png)'
- en: Figure 2.30 Prefab in Project Browser Panel
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.30 项目浏览器面板中的预制件
- en: The Prefabs can be used in any scenes. These are reusable anywhere throughout
    the project.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 预制件可以在任何场景中使用。这些可以在整个项目中任何地方重复使用。
- en: 'In order to see how the Prefabs will work at runtime, just drag our Level Block
    Prefab object into the scene a few times in different positions and see how it
    comes in the view. The following screenshot shows a few level blocks placed in
    a scene:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 为了查看预制件在运行时的表现，只需将我们的层级块预制件对象拖入场景几次，在不同的位置，看看它在视图中是如何出现的。以下截图显示了几个放置在场景中的层级块：
- en: '![](img/image_02_033.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_02_033.png)'
- en: Figure 2.31 Level Block Prefabs placed randomly in the scene
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.31 随机放置在场景中的层级块预制件
- en: You can observe that whenever we drag any Prefab into the scene, it creates
    the whole block, consisting of all the functionality, child objects, behaviors,
    scripts, and so on. That is the main advantage of using Prefabs in Unity.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以观察到，无论何时我们将任何预制件拖入场景，它都会创建一个包含所有功能、子对象、行为、脚本等的整个块。这就是在Unity中使用预制件的主要优势。
- en: Our Level Block Prefab is ready. Now we have to tell Unity when to create the
    block at runtime and at what positions it should be instantiated. We will do this
    by adding a script called `BlockGenerator.cs` into the penguin object. Let's explain
    about this generator in the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的关卡方块预制件已经准备好了。现在我们必须告诉 Unity 在何时以及在什么位置创建方块。我们将通过将一个名为 `BlockGenerator.cs`
    的脚本添加到企鹅对象中来实现这一点。让我们在下一节中解释这个生成器。
- en: The level block generator concept
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 水平方块生成器概念
- en: The idea behind the generator script is quite simple. The script has an array
    of level blocks it can generate (for now, we have only one block created), a list
    of blocks currently generated, and two additional methods. One method checks to
    see whether another block needs to be added and the other method actually adds
    a block.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 生成器脚本背后的理念非常简单。脚本有一个可以生成的关卡方块数组（目前我们只创建了一个方块），一个当前已生成的方块列表，以及两个额外的方法。一个方法检查是否需要添加另一个方块，另一个方法实际上添加一个方块。
- en: 'To check whether a block needs to be added, the script will enumerate all existing
    rooms and see whether there is a room ahead, farther than the screen width, to
    guarantee that the player never sees the end of the level. To understand this
    more clearly, let''s look at the following screenshot:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检查是否需要添加方块，脚本将枚举所有现有房间并查看是否存在一个比屏幕宽度更远的房间，以确保玩家永远不会看到关卡结束。为了更清楚地理解这一点，让我们看看下面的截图：
- en: '![](img/image_02_034.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_034.png)'
- en: Figure 2.32 Level block generator idea
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.32 关卡方块生成器想法
- en: 'You can see in scenario 1, there is enough space or width yet to cover some
    distance in the block. But in scenario 2, there is not enough space to cover,
    because as the penguin moves forward, the empty space will start to show up. So
    before it shows any blank space, we need to add a new level block beside the current
    block so that the player never sees any empty spaces there. The figure only tries
    to clarify the rough concept of how the new block will be added and when. The
    following screenshot shows a sample generation of blocks and our penguin''s moving
    forward status:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在场景 1 中看到，还有足够的空间或宽度来覆盖方块的一些距离。但在场景 2 中，空间不足，因为随着企鹅向前移动，空隙将开始出现。所以在我们看到任何空白空间之前，我们需要在当前方块旁边添加一个新的关卡方块，以确保玩家永远不会在那里看到任何空隙。该图仅试图阐明新方块将如何添加以及何时添加。以下截图显示了方块的一个示例生成和我们的企鹅前进状态：
- en: '![](img/image_02_035.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_035.png)'
- en: Figure 2.33 Penguin Moving Forward and Level Blocks Generating
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.33 企鹅前进和关卡方块生成
- en: You can see that as the penguin keeps moving forward, new blocks will be generating
    over and over again. Once any block leaves the screen, it will be deleted to optimize
    the memory usage and increase game performance.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到，随着企鹅不断前进，新的方块会不断地生成。一旦任何方块离开屏幕，它将被删除以优化内存使用并提高游戏性能。
- en: Let's now bring this whole scenario into action by writing the `BlockGenerator.cs`
    code in the next section.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过在下一节中编写 `BlockGenerator.cs` 代码来将整个场景付诸实施。
- en: The BlockGenerator.cs code
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: BlockGenerator.cs 代码
- en: Let's start by creating an empty C# script file in the Scripts folder of the
    Assets directory with the name `BlockGenerator.cs`. Then drag this script onto
    the penguin object to apply on the penguin.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在资产目录的脚本文件夹中创建一个名为 `BlockGenerator.cs` 的空 C# 脚本文件开始。然后将此脚本拖放到企鹅对象上以应用于企鹅。
- en: Any game object can have many scripts applied to it. There is no restriction
    of scripts or components applied on the game objects.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏对象都可以应用多个脚本。对游戏对象上应用的脚本或组件没有限制。
- en: Open `BlockGenerator.cs` in `MonoDevelop` by double-clicking it in the Project
    view or in the Inspector panel.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在项目视图或检查器面板中双击 `BlockGenerator.cs` 在 `MonoDevelop` 中打开它。
- en: You have to add the `System.Collections.Generic` namespace if you're going to
    use the `List<T>` class.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算使用 `List<T>` 类，则必须添加 `System.Collections.Generic` 命名空间。
- en: 'Add the following field variables into the `BlockGenerator` class:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下字段变量添加到 `BlockGenerator` 类中：
- en: '[PRE1]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`availableBlocks` will contain an array of Prefabs which the script can generate.
    Currently, we have only one Prefab (`LevelBlockPrefab`). But we can create many
    different blocks types and add them all to this array, so that the script could
    randomly choose which block type to generate. The `currentBlocks` list will store
    instanced blocks, so that it can check where the last block ends and whether it
    needs to add more blocks. Once the block is behind the player character, it will
    remove it as well. The `screenWidthInPoints` variable is just required to cache
    screen size in points.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '`availableBlocks`将包含脚本可以生成的Prefab数组。目前，我们只有一个Prefab（`LevelBlockPrefab`）。但我们可以创建许多不同的方块类型并将它们全部添加到这个数组中，以便脚本可以随机选择要生成的方块类型。`currentBlocks`列表将存储实例化的方块，以便它可以检查最后一个方块在哪里结束以及是否需要添加更多方块。一旦方块在玩家角色后面，它也会将其移除。`screenWidthInPoints`变量只是用于缓存屏幕大小的点。'
- en: 'You can see these fields in the Inspector view of the penguin game object,
    as shown in the following screenshot:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在企鹅游戏对象的检查器视图中看到这些字段，如下面的截图所示：
- en: '![](img/image_02_037.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_037.png)'
- en: Figure 2.34 Block Generator Fields in Inspector
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.34 检查器中的方块生成器字段
- en: 'Now, add the following code in the `Start()` method of the `BlockGenerator.cs`
    file:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`BlockGenerator.cs`文件的`Start()`方法中添加以下代码：
- en: '![](img/image_02_038.png)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_038.png)'
- en: Here you calculate the size of the screen in points. The screen size will be
    used to determine whether you need to generate a new block, described previously.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你计算屏幕的大小（以点为单位）。屏幕大小将用于确定是否需要生成新的方块，如前所述。
- en: 'Add the following `AddBlock()` method to `BlockGenerator.cs`:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下`AddBlock()`方法添加到`BlockGenerator.cs`：
- en: '![](img/image_02_039.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_039.png)'
- en: 'This method adds a new block using the `farhtestBlockEndX` point, which is
    the rightmost point of the level so far. Here is description of every line of
    this method:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用`farthestBlockEndX`点添加一个新的方块，这是到目前为止关卡的最右端点。以下是此方法每一行的描述：
- en: Picks a random index of the block type (Prefab) to generate.
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从方块类型（Prefab）的随机索引中选择。
- en: Creates a block object from the array of available blocks using the random index
    above.
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用上面提到的随机索引从可用方块数组中创建一个方块对象。
- en: Since the block is empty containing all the block parts, you cannot simply take
    its size. Instead, you get the size of the floor inside the block, which is equal
    to the block's width.
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于方块是空的，包含所有方块部分，你不能简单地取其大小。相反，你得到方块内部地板的大小，这等于方块宽度。
- en: When you set the block position, you set the position of its center so you add
    the half block width to the position where the level ends. This way gets the point
    at which you should add the block, so that it starts straight after the last block.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你设置方块位置时，你设置其中心的位置，因此将方块宽度的一半加到关卡结束的位置上。这样可以得到你应该添加方块的位置，以便它紧接在最后一个方块之后开始。
- en: This sets the position of the block. You need to change only the x-coordinate
    since all blocks have the same y and z coordinates equal to zero.
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这设置了方块的位置。你只需要更改x坐标，因为所有方块都具有相同的y坐标和等于零的z坐标。
- en: Finally, you add the block to the list of current blocks. It will be cleared
    in the next method, which is why you need to maintain this list.
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你将方块添加到当前方块列表中。它将在下一个方法中被清除，这就是为什么你需要维护这个列表的原因。
- en: 'After the `AddBlock()` method, let''s go into the details of the `GenerateBlockIfRequired()`
    method:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在`AddBlock()`方法之后，让我们深入了解`GenerateBlockIfRequired()`方法的细节：
- en: '![](img/image_02_040.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_040.png)'
- en: 'This method is the implementation of the idea explained in the previous section:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法是前一小节中解释的想法的实现：
- en: Creates a new list to store blocks that need to be removed. Separate lists are
    required since you cannot remove items from the list while you are iterating through
    it.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的列表来存储需要移除的方块。由于在迭代列表时不能从中移除项目，因此需要单独的列表。
- en: This is a flag that shows whether you need to add more blocks. By default, it
    is set to true, but most of the time it will be set to false inside the `foreach`.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是一个标志，表示你是否需要添加更多方块。默认情况下，它被设置为true，但大多数情况下它将在`foreach`内部设置为false。
- en: Saves player position.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存玩家位置。
- en: This is the point after which the block should be removed. If a block's position
    is behind this point (to the left), it needs to be removed.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是方块应该被移除的点之后的位置。如果一个方块的位置在这个点（左侧）之后，它需要被移除。
- en: If there is no block after the `addBlockX`point, you need to add a block, since
    the end of the level is closer than the screen width.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在`addBlockX`点之后没有方块，你需要添加一个方块，因为关卡结束的位置比屏幕宽度更近。
- en: In `farthestBlockEndX`, you store the point where the level currently ends.
    You will use this variable to add a new block if required, since the new block
    should start at that point to make the level seamless.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`farthestBlockEndX`中，你存储当前关卡结束的点。如果你需要添加一个新方块，你会使用这个变量，因为新方块应该从那个点开始，以使关卡无缝。
- en: In `foreach`, you simply enumerate the current blocks. You use the floor to
    get the block width and calculate the `BlockStartX` (the point where the block
    starts, the leftmost point of the block) and `BlockEndX` (the point where the
    block ends, the rightmost point of the block).
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`foreach`中，你只需枚举当前方块。你使用地板来获取方块宽度并计算`BlockStartX`（方块开始的位置，方块的最左点）和`BlockEndX`（方块结束的位置，方块的最右点）。
- en: If there is a block that starts after `addBlockX` then you don't need to add
    blocks right now. However, there is no `break` instruction here, since you still
    need to check whether this block needs to be removed.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果有一个方块在`addBlockX`之后开始，那么你现在不需要添加方块。然而，这里没有`break`指令，因为你仍然需要检查这个方块是否需要被移除。
- en: If a block ends to the left of the `removeBlockX` point, then it is already
    off the screen and needs to be removed.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个方块在`removeBlockX`点的左侧结束，那么它已经不在屏幕上了，需要被移除。
- en: Here you simply find the rightmost point of the level. This will be the point
    where the level currently ends. It is used only if you need to add a block.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你只需找到关卡的最右点。这将是目前关卡结束的点。它仅在需要添加方块时使用。
- en: This removes blocks that are marked for removal. The mouse `GameObject` already
    flew through them and thus they are far behind, so you need to remove them.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这会移除标记为移除的方块。鼠标`GameObject`已经飞过了它们，因此它们在后面很远，所以你需要移除它们。
- en: If at this point `addBlocks` is still `true`, then the level end is near. `addBlocks`
    will be true if it didn't find a block starting farther than the screen width.
    This indicates that a new block needs to be added.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果此时`addBlocks`仍然是`true`，那么关卡结束就快了。如果它没有找到比屏幕宽度更远的方块开始，`addBlocks`将是`true`。这表明需要添加一个新的方块。
- en: 'So, after all this explanation, let''s add our final method, `FixedUpdate()` to
    the the `BlockGenerator.cs` files as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在所有这些解释之后，让我们将我们的最终方法`FixedUpdate()`添加到`BlockGenerator.cs`文件中，如下所示：
- en: '[PRE2]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Generating blocks in `FixedUpdate()` will continue to periodically make sure
    that the player never experiences blank space in the game. Now, return to Unity
    and select the *penguin* GameObject in the Hierarchy. In the Inspector, find the
    `BlockGenerator` component. Drag the LevelBlockPrefab from the Hierarchy to the
    Current Blocks list. Then open the Prefabs folder in Project Browser and drag
    LevelBlockPrefab from it to Available Blocks. The following screenshot shows the
    `BlockGenerator` component of the penguin object after adding Prefabs in the lists:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在`FixedUpdate()`中生成方块将继续定期确保玩家在游戏中不会遇到空白空间。现在，回到Unity，在层级中选择*penguin* GameObject。在检查器中，找到`BlockGenerator`组件。将层级中的LevelBlockPrefab拖到当前方块列表中。然后打开项目浏览器中的Prefab文件夹，将LevelBlockPrefab从其中拖到可用方块中。以下截图显示了添加Prefab到列表后企鹅对象的`BlockGenerator`组件：
- en: '![](img/image_02_042.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/image_02_042.png)'
- en: Figure 2.35 Block Generator Component with Prefabs
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.35 带有Prefab的方块生成器组件
- en: Now run the project and you will see that blocks will keep generating. Note
    that blocks are appearing and disappearing in the Hierarchy while you fly. And
    for even more fun, run the scene and switch to the *Scene View* without stopping
    the game. This way, you will see how blocks are added and removed in real time.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行项目，你会看到方块会持续生成。注意，当你飞行时，方块会在层级中不断出现和消失。为了增加更多乐趣，运行场景并切换到*场景视图*而不停止游戏。这样，你将看到方块是如何实时添加和移除的。
- en: So, after level generation, let's discuss how to add obstacles such as ice spikes
    in the game to make the penguin be little careful while going through the level
    in the next section.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在关卡生成后，让我们在下一节讨论如何在游戏中添加障碍物，如冰刺，使企鹅在通过关卡时更加小心。
- en: Adding ice spikes to the game
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加冰刺到游戏中
- en: The penguin flying through the level looks great but the game is all about the
    challenges and obstacles. So, this section is all about the obstacles which can
    be added to the game. We will add ice spikes, which will be generated randomly
    in a similar manner as you generate blocks. Let's create the ice spike first.
    You need two images for the spikes on and spikes off states.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 飞越关卡的小企鹅看起来很棒，但游戏的核心是挑战和障碍。因此，本节将详细介绍可以添加到游戏中的障碍。我们将添加冰尖刺，这些尖刺将以与生成方块类似的方式随机生成。让我们首先创建冰尖刺。你需要为尖刺的开启和关闭状态准备两张图片。
- en: 'The following screenshot shows the spikes on and spikes off states:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了尖刺的开启和关闭状态：
- en: '![](img/image_02_043.png)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.43](img/image_02_043.png)'
- en: Figure 2.36 Block generator fields in Inspector pane
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.36 检查器面板中的方块生成器字段
- en: 'Import these images into Unity with the names `spike_on.png` and `spike_off.png`
    in the Graphics folder of the Assets directory. And then we have to create a Prefab
    of the spike for it. So, here are the steps below:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些图片以 `spike_on.png` 和 `spike_off.png` 的名称导入 Unity，存放在 Assets 目录的 Graphics
    文件夹中。然后我们必须为尖刺创建一个 Prefab。以下是步骤：
- en: In the Project view, find the `spike_on` sprite and drag it to the scene.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目视图中，找到 `spike_on` 精灵，并将其拖到场景中。
- en: Select it in the Hierarchy and rename it `spike`.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择它，并将其重命名为 `spike`。
- en: Set its Sorting Layer to Objects*.*
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其排序层设置为 Objects*.*。
- en: Add a Box Collider 2D component.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个 Box Collider 2D 组件。
- en: Enable the Is Trigger property in the Box Collider 2D component.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Box Collider 2D 组件中启用 Is Trigger 属性。
- en: When the Is Trigger property is enabled, the collider will trigger collision
    events, but will be ignored by the physics engine.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 当启用 Is Trigger 属性时，碰撞器将触发碰撞事件，但将被物理引擎忽略。
- en: Set the Size of the collider, *X* to *0.18* and *Y* to *3.1*.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置碰撞器的尺寸，*X* 为 *0.18*，*Y* 为 *3.1*。
- en: Create a new C# script named `SpikeScript.cs` in the Scripts folder and attach
    it to the `spike` game object.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Scripts 文件夹中创建一个新的 C# 脚本，命名为 `SpikeScript.cs`，并将其附加到 `spike` 游戏对象上。
- en: 'The following screenshot shows all the steps done here to create a spike GameObject:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了创建尖刺 GameObject 的所有步骤：
- en: '![](img/image_02_044.png)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.44](img/image_02_044.png)'
- en: Fig 2.37 Adding a spike game object
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.37 添加尖刺游戏对象
- en: 'Now open `SpikeScript.cs` and add the following fields in the class:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开 `SpikeScript.cs` 文件，并在类中添加以下字段：
- en: '![](img/image_02_045.png)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.45](img/image_02_045.png)'
- en: 'Then add the following code in the `Start()` method like this:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在 `Start()` 方法中添加以下代码：
- en: '![](img/image_02_046.png)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.46](img/image_02_046.png)'
- en: 'This will set the time until the spike should toggle its state for the first
    time. Then, to toggle and rotate the spike, add `FixedUpdate()` with the following:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这将设置尖刺第一次切换状态的时间。然后，为了切换和旋转尖刺，添加 `FixedUpdate()` 并如下操作：
- en: '![](img/image_02_047.png)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.47](img/image_02_047.png)'
- en: Now, select `spike` in the Hierarchy. Drag the `spike_on` sprite from project
    browser to the Spike On Sprite property of the `SpikeScript` component in the
    inspector view. Also, do it for the `spike_off` sprite as well. Set Rotation speed
    to 30 and position to (2, 0.25, 0). Run the project and you will get a spike nicely
    rotating and finally turn into spike game object into a SpikePrefab in spikes
    folder as we did in the earlier section.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在层次结构中选择 `spike`。从项目浏览器中将 `spike_on` 精灵拖到检查器视图中 `SpikeScript` 组件的 Spike On
    Sprite 属性。同样，也为 `spike_off` 精灵做同样操作。将旋转速度设置为 30，位置设置为 (2, 0.25, 0)。运行项目，你将得到一个旋转的尖刺，最终将尖刺游戏对象转换为
    spikes 文件夹中的 SpikePrefab，就像我们在前面的章节中所做的那样。
- en: 'The following screenshot shows the spike running in the game:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了游戏中运行的尖刺：
- en: '![](img/image_02_048.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![图片 2.48](img/image_02_048.png)'
- en: Figure 2.38 Spike in the game
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.38 游戏中的尖刺
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we continued our Perky Penguin game and added particle systems
    to it. Then we learned about managing the camera, and we made the camera follow
    the penguin throughout the game. Then we worked on Prefabs and created a level
    block Prefab which we generated in the game from the code to make an endless level
    generating game. Then we created a Spike Prefab to create an obstacle for the
    penguin in the game which gets generated randomly and rotates with different speeds
    at runtime.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们继续开发我们的“活泼企鹅”游戏，并向其中添加了粒子系统。然后我们学习了如何管理摄像机，并在整个游戏中使摄像机跟随企鹅。然后我们处理 Prefab，并创建了一个关卡方块
    Prefab，我们在游戏中通过代码生成，以制作一个无限关卡生成游戏。然后我们创建了一个尖刺 Prefab，为游戏中的企鹅创建一个随机生成并具有不同运行时速度旋转的障碍。
- en: In the next chapter, we will move our concepts of making games to 3D and introduce
    you to the workflow and systems to create 3D complex games in Unity 3D.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把制作游戏的概念扩展到3D，并介绍如何在Unity 3D中创建3D复杂游戏的流程和系统。
