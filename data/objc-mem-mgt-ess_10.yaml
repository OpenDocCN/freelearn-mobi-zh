- en: Chapter 10. Tips and Tricks for Memory Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章. 内存管理的技巧和窍门
- en: 'Memory management is something that every programmer dealing with Objective-C
    will encounter although Apple introduces a lot of tools to assist in ferreting
    out memory-related issues such as Instruments and NSZombies. There are some more
    subtle techniques and tools that are present in Objective-C and Xcode, which we
    will be looking into in this chapter. Some are obvious and some will give you
    a new perspective with regards to Objective-C. We will also cover some important
    topics such as:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理是每个处理 Objective-C 的程序员都会遇到的问题，尽管苹果引入了许多工具来帮助查找与内存相关的问题，如 Instruments 和 NSZombies。在本章中，我们将探讨一些更微妙的技术和工具，有些是显而易见的，有些将为你提供关于
    Objective-C 的新视角。我们还将涵盖一些重要主题，例如：
- en: Using the @property keyword
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 @property 关键字
- en: Using the getter/setter methods
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用获取器/设置器方法
- en: Understand the property attribute in Objective-C
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Objective-C 中的属性属性
- en: When to avoid KVC and KVO
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时避免使用 KVC 和 KVO
- en: So, let's get started!
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们开始吧！
- en: Objective-C, C, and memory management
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C、C 和内存管理
- en: Objective-C and the C programming language are closely related as Objective-C
    is a proper superset of C, which means that anything that works in C will work
    with Objective-C. So inherently, it also means that memory management methods
    and protocols that you are familiar with in C or C++ will also apply to Objective-C.
    However, a good thing about Objective-C is that the compiler does a lot of this
    memory management for you under the hood. This means that you do not need to write
    too much code to handle memory management in Objective-C compared to C or C++.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 和 C 编程语言密切相关，因为 Objective-C 是 C 的一个真正的超集，这意味着在 C 中工作的一切都将与 Objective-C
    一起工作。因此，本质上这也意味着你在 C 或 C++ 中熟悉的内存管理方法和协议也将适用于 Objective-C。然而，Objective-C 的一个好处是编译器在幕后为你做了大量的内存管理工作。这意味着与
    C 或 C++ 相比，在 Objective-C 中处理内存管理不需要编写太多的代码。
- en: However, do note that although you can mix C++ and Objective-C together, Objective-C
    is not a superset of C++. This does not mean that you can be totally hands off
    with regards to memory management since Objective-C does not have a garbage collector
    like what you get in Java.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，尽管你可以混合使用 C++ 和 Objective-C，但 Objective-C 并不是 C++ 的超集。这并不意味着你可以完全放手内存管理，因为
    Objective-C 没有像 Java 那样的垃圾回收器。
- en: With the release of **Automatic Reference Counting** (**ARC**) support in Xcode
    4.2 and iOS 4 and 5 onwards, developers everywhere thought that their days of
    laborious memory management are over, but make no mistake as you need to keep
    in mind that ARC is a compile time memory management mechanism, where the compiler
    will examine the source code and then add the `retain` and `release` messages
    into the compiled code. ARC is not the traditional garbage collection mechanism
    that Java and C# programmers are familiar with where garbage collection is done
    during runtime by the garbage collector.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Xcode 4.2 和 iOS 4 及 5 及以后版本的 **自动引用计数（ARC**） 支持的发布，世界各地的开发者都认为他们繁琐的内存管理日子已经结束，但不要误解，你需要记住
    ARC 是一个编译时内存管理机制，编译器将检查源代码，然后在编译后的代码中添加 `retain` 和 `release` 消息。ARC 不是 Java 和
    C# 程序员熟悉的传统垃圾回收机制，垃圾回收是在运行时由垃圾回收器完成的。
- en: So, the introduction of ARC means that there is even less typing for you as
    a developer as you do not need to type in `retain` and `release` messages explicitly
    into your code, which makes your code more verbose. However, as we saw in the
    previous chapters where we introduced retain cycles and other types of memory
    leaks, using ARC means that you will still need to be aware of memory management
    principles and that is where Objective-C and Xcode shines compared to their C
    programming language counterparts. Its built-in mechanism helps programmers avoid
    leaking memory through a series of good practices. So, let's start by looking
    at these good practices in detail in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，ARC 的引入意味着作为开发者的你甚至需要更少的输入，因为你不需要在代码中显式地输入 `retain` 和 `release` 消息，这使得你的代码更加冗长。然而，正如我们在前几章中看到的，当我们介绍了保留周期和其他类型的内存泄漏时，使用
    ARC 意味着你仍然需要了解内存管理原则，这正是 Objective-C 和 Xcode 与其 C 编程语言对应物相比的优势所在。其内置机制帮助程序员通过一系列良好的实践避免内存泄漏。因此，让我们在本章中详细探讨这些良好实践。
- en: Getters and setters
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取器和设置器
- en: 'If you have done some Java and C# programming and come from a Java or C# background,
    you should be familiar with getter and setter methods or you may also know them
    as accessors and mutators, respectively. They are a fundamental pillar of good
    programming. Getters/setters or accessors/mutators, are also known as methods
    used in keeping the principle of encapsulation where member variables are made
    private to protect them from other code which could be potentially malicious,
    and the getter/setter acts as a gatekeeper or intermediary between the private
    member variable and other code. Take a look at the following lines of code:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经进行了一些 Java 和 C# 编程，并且来自 Java 或 C# 背景，您应该熟悉获取器和设置器方法，或者您可能也知道它们分别被称为访问器和修改器。它们是良好编程的基本支柱。获取器/设置器或访问器/修改器，也被称为用于保持封装原则的方法，其中成员变量被设置为私有以保护它们免受可能有害的其他代码的影响，而获取器/设置器充当私有成员变量和其他代码之间的守门人或中介。看看以下代码行：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The preceding two methods should not be unfamiliar to you from a Java or C#
    perspective. Getters and setters can be considered bad if used improperly. Making
    a variable public and yet writing a getter and setter method is a good example
    as this violates the concept of encapsulation. Now, getter and setter methods
    are a good foundation for recommended programming practices as they confer the
    following benefits and more:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Java 或 C# 的角度来看，前面的两种方法应该不会让您感到陌生。如果使用不当，获取器和设置器可能会被认为是糟糕的。将变量设置为公共的，同时编写获取器和设置器方法是一个很好的例子，因为这违反了封装的概念。现在，获取器和设置器方法是推荐编程实践的良好基础，因为它们提供了以下好处以及更多：
- en: Hiding the internal state of the objects
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏对象的内部状态
- en: Setting different access levels such as read only, write only, and so on
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置不同的访问级别，如只读、只写等
- en: Creating a public interface will make it easier for you to make code changes
    when you need to change the implementation layer, which will be apparent when
    you need to make changes across many files
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个公共接口将使您在需要更改实现层时更容易进行代码更改，这在您需要跨多个文件进行更改时将变得明显
- en: Allowing you to enforce strict rules on what can be done and not be done with
    your objects via these getter and setter methods
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许您通过这些获取器和设置器方法对您的对象执行的操作进行严格的规则约束
- en: Getter and setter methods generally start with the get and set prefix. This
    may come as a surprise to you, but Objective-C has very strong support for getter
    and setter methods. However, you may ask, "where are the getter and setter methods
    in Objective-C? I don't recall setting any methods or writing any code that start
    with `get` or `set`?" However, actually, they are present and are already in your
    code, but you just do not realize it yet since Objective-C has an abstraction
    layer for you so that you do not need to spend too much time writing getter and
    setter methods. This abstraction layer allows you to customize your getter and
    setter methods as we shall see later on. The way that Objective-C lets you define
    get and set methods and the various attributes such as `readonly`, `readwrite`,
    and so on is via the `@property` keyword in your code. Getters and setters go
    hand in hand with memory management as you can write code to clean up the memory
    in these methods if you need to.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 获取器和设置器方法通常以 get 和 set 前缀开头。这可能会让您感到惊讶，但 Objective-C 对获取器和设置器方法提供了非常强的支持。然而，您可能会问：“Objective-C
    中的获取器和设置器方法在哪里？我不记得设置过任何以 `get` 或 `set` 开头的方法或编写过任何代码？”然而，实际上，它们确实存在，并且已经存在于您的代码中，但您还没有意识到这一点，因为
    Objective-C 为您提供了一个抽象层，这样您就不需要花费太多时间编写获取器和设置器方法。这个抽象层允许我们稍后看到，您可以通过代码中的 `@property`
    关键字定义获取器和设置器方法以及各种属性，如 `readonly`、`readwrite` 等。获取器和设置器与内存管理密切相关，因为您可以在这些方法中编写代码来清理内存。
- en: The property attribute in Objective-C
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 中的属性属性
- en: 'If you have been doing some Objective-C programming, you would have come across
    the following syntax:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经进行了一些 Objective-C 编程，您可能会遇到以下语法：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, I would bet that you would generally have a foggy idea of what terms such
    as `nonatomic` or `retain` mean when you are assigning these properties such as
    `nonatomic` and so on to your objects. These keywords, such as `nonatomic` or
    `readonly`, actually define the properties of your objects, which are used in
    the getter and setter methods automatically created for you in Xcode. These terms
    are coding keywords related to memory management and access control and were not
    created just to baffle you or to give you additional typing to do (at least not
    as much typing as typing getter and setter methods themselves). Anyway, let''s
    go through what these terms mean so that you will get a better understanding of
    these keywords in relation to getter and setters:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我敢打赌，当你将这些属性如`nonatomic`等分配给对象时，你对诸如`nonatomic`或`retain`之类的术语的含义可能只有一个模糊的概念。这些关键字，如`nonatomic`或`readonly`，实际上定义了您的对象的属性，这些属性在Xcode为您自动创建的getter和setter方法中使用。这些术语是与内存管理和访问控制相关的编码关键字，并不是为了迷惑您或给您增加额外的输入（至少不会像输入getter和setter方法那样多）。无论如何，让我们来看看这些术语的含义，以便您更好地理解这些关键字与getter和setter的关系：
- en: '| Attribute name | Description |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 属性名称 | 描述 |'
- en: '| --- | --- |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `nonatomic` | This property is not thread safe, but it is faster than `atomic`.
    |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `nonatomic` | 这个属性不是线程安全的，但比`atomic`更快。 |'
- en: '| `atomic` | This property is used for completeness and will not allow bad
    things to happen if a different thread tries to access this object at some point
    in your code. However, it is slower than `nonatomic` due to additional bookkeeping
    overhead required. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `atomic` | 这个属性用于完整性，将不允许在您的代码中某个时刻有其他线程尝试访问此对象时发生不良情况。然而，由于需要额外的簿记开销，它比`nonatomic`慢。
    |'
- en: '| `strong` | This is used with ARC and helps by not letting you worry about
    the retain count of an object as it is autoreleased when you are done with it.
    In code that does not support ARC, it is a synonym for the retain property. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `strong` | 这与ARC一起使用，通过在您完成对象后自动释放对象，帮助您不必担心对象的retain计数。在不支持ARC的代码中，它是retain属性的同义词。
    |'
- en: '| `weak` | This means that the reference count is not increased by 1, and it
    does not become an owner of an object, but it does hold a reference to it. This
    is just another term for `unsafe_unretained` for the non-ARC code. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| `weak` | 这意味着引用计数不会增加1，它不会成为对象的所有者，但它确实持有对它的引用。这是非ARC代码中`unsafe_unretained`的另一个术语。
    |'
- en: '| `assign` | This property will generate a setter method, which will assign
    the value to the object instead of copying or retaining it. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| `assign` | 这个属性将生成一个setter方法，该方法将分配值给对象而不是复制或保留它。 |'
- en: '| `copy` | This is used for when the object is mutable where you create a copy
    of the object. Do note that copy cannot be used together with retain as the copy
    of the object will already have its retain count incremented by 1. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `copy` | 当对象是可变时使用，此时您会创建对象的副本。请注意，copy不能与retain一起使用，因为对象的副本其retain计数已经增加1。
    |'
- en: '| `readonly` | This property will make the object read-only and no setter method
    will be created in the `@implementation` section of the code. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `readonly` | 这个属性将使对象为只读，代码的`@implementation`部分将不会创建setter方法。 |'
- en: '| `readwrite` | This means that the `read` and `write` attribute properties
    are applicable and the getter and setter methods are automatically created for
    you. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `readwrite` | 这意味着`read`和`write`属性属性是可用的，并且会自动为您创建getter和setter方法。 |'
- en: So, `@property(nonatomic, retain) NSString *text` will tell the compiler, "I
    have a member variable of the type NSString named text, so I will need a pair
    of getter/setter methods, which will use the retain/release procedure."
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`@property(nonatomic, retain) NSString *text`将告诉编译器，“我有一个名为text的NSString类型的成员变量，所以我将需要一个getter/setter方法对，它们将使用retain/release过程。”
- en: Now that you have defined the attributes of your member variables such as which
    one has `readonly`, which one has `readwrite`, and so on, what next?
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你已经定义了成员变量的属性，比如哪个是`readonly`，哪个是`readwrite`等等，接下来是什么？
- en: Next, you will use the `@synthesize` keyword. The `@synthesize` keyword will
    tell the compiler, "Now that I have declared the property `nonatomic` and `retain`
    for my `NSString *text` object, please create the code now for the getter and
    setter pair of methods for my `NSString *text` object."
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您将使用`@synthesize`关键字。`@synthesize`关键字将告诉编译器，“既然我已经为我的`NSString *text`对象声明了`nonatomic`和`retain`属性，请现在为我的`NSString
    *text`对象创建getter和setter方法对。”
- en: So, with just these two lines of code, we can tell Objective-C to create our
    getter and setter methods for us and assign properties such as read-only, write-only,
    and so on for our objects or variables. This is much better than typing in verbose
    getter and setter code as you would do in Java or C#.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，仅用这两行代码，我们就可以告诉 Objective-C 为我们创建获取器和设置器方法，并为我们的对象或变量分配只读、只写等属性。这比在 Java
    或 C# 中输入冗长的获取器和设置器代码要好得多。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Do note that `@synthesize` is automatically provided to you by default in Xcode
    4.4 and onwards, but there may be cases where you need to add in the `@synthesize`
    keyword yourself explicitly, which we will go through later.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，从 Xcode 4.4 开始，`@synthesize` 关键字默认由 Xcode 自动提供，但可能存在需要您显式添加 `@synthesize`
    关键字的情况，我们将在后面进行说明。
- en: Now you know why `@synthesize` does what it does. `@property` and `@synthesize`
    helps to automate the creation of getter and setter methods along with ease of
    creation with regards to access rules and controls with only a few lines of code.
    The getter and setter methods do exist once you use `@property` and `@synthesize`,
    but you do not see them physically in your code as these methods do not show up
    in your code base, but you can actually have access to them.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您知道 `@synthesize` 为什么会这样做。`@property` 和 `@synthesize` 有助于自动化获取器和设置器方法的创建，以及通过仅几行代码轻松创建访问规则和控制。
- en: 'Take a look at my property declaration here:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 看看我的属性声明：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In your implementation file, you will find that the following code will compile
    perfectly fine, and this shows that `_myInt` is accessing the variable directly:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的实现文件中，您会发现以下代码可以完美编译，这表明 `_myInt` 正在直接访问变量：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Once the variable is synthesized, an instance variable (or iVar for short) is
    automatically created and prefaced with an underscore. The presence of this underscore
    in a variable name is a naming convention to indicate that this is an iVar, and
    this is done automatically for you within Objective-C.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦变量被合成，就会自动创建一个实例变量（或简称为 iVar），并在其前面加上下划线。变量名中下划线的存在是一种命名约定，表示这是一个 iVar，Objective-C
    会为您自动完成这项工作。
- en: So, this is why there is no compiler error when you call `_myInt` as `_myInt`
    is automatically created for you by the compiler when you tell the compiler the
    properties of what `myInt` will do.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您以 `_myInt` 的形式调用 `_myInt` 时，不会出现编译错误，因为当您告诉编译器 `myInt` 将执行哪些属性时，编译器会自动为您创建
    `_myInt`。
- en: '`@synthesize` will also create the validation rules, which you assign to a
    variable using your `@property` keyword. Validation rules such as `readonly` means
    that when you try to assign a value to your variable, you will get a compiler
    error **read only property cannot be reassigned**, and that is the validation
    rule of your automatically created setter (mutator) method at work without the
    writing of verbose code.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`@synthesize` 还会创建验证规则，您可以使用 `@property` 关键字将这些规则分配给变量。例如，`readonly` 验证规则意味着当您尝试为变量赋值时，您将收到编译错误“只读属性不能重新赋值”，这正是您自动创建的设置器（修改器）方法的工作原理，而无需编写冗长的代码。'
- en: Let's look at some code, shall we? Let's create an object called `UserObject`
    and assign a variable call `Age` to it.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码，好吗？让我们创建一个名为 `UserObject` 的对象，并将其变量命名为 `Age`。
- en: So, let's get started!
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧！
- en: We begin by clicking on **File** | **New** or by pressing *Command* + *N* on
    your keyboard, and select **Cocoa Touch** and **Objective-C class**, as shown
    here:![The property attribute in Objective-C](img/00050.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先点击 **文件** | **新建** 或按键盘上的 *Command* + *N*，然后选择 **Cocoa Touch** 和 **Objective-C
    类**，如图所示：![Objective-C 中的属性属性](img/00050.jpeg)
- en: Next, we put in the name of the class, which is `UserObject`, and leave it as
    a subclass of `NSObject`:![The property attribute in Objective-C](img/00051.jpeg)
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们输入类的名称，即 `UserObject`，并将其留为 `NSObject` 的子类：![Objective-C 中的属性属性](img/00051.jpeg)
- en: 'Then, click on **Next** followed by **Create** and your `UserObject` class
    will be created for you. Then, you should end up with this in your `UserObject.h`
    file. Add an integer called `age` and assign the `nonatomic` and `readonly` properties
    to it in your `UserObject` header file, as shown here:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击 **下一步**，然后点击 **创建**，您的 `UserObject` 类将为您创建。然后，您应该在您的 `UserObject.h` 文件中得到以下内容。在
    `UserObject` 头文件中添加一个名为 `age` 的整数，并将其 `nonatomic` 和 `readonly` 属性分配给它，如图所示：
- en: '[PRE4]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now if you try to build your code, you will get a warning, **Autosynthesized
    property 'age' will use synthesized instance variable '_age', not existing instance
    variable 'age',** because you have not explicitly added in the code `@synthesize
    age` in the `.m` implementation file of your `UserObject` class.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在如果你尝试构建你的代码，你会得到一个警告，**自动生成的属性 'age' 将使用自动生成的实例变量 '_age'，而不是现有的实例变量 'age'**，因为你没有在`UserObject`类的`.m`实现文件中显式添加`@synthesize
    age`代码。
- en: 'This warning is just a friendly reminder that since you did not add in the
    `@synthesize age` code, Xcode will create an instance variable called `_age` for
    all your setter and getter methods. This is a harmless warning, but for me, I
    prefer to keep my code as warning free as possible, so I will add the `@synthesize
    age;` line of code to my `.m` implementation file of `UserObject` and get something
    like this:'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个警告只是一个友好的提醒，因为你没有添加`@synthesize age`代码，Xcode将为你的所有setter和getter方法创建一个名为`_age`的实例变量。这是一个无害的警告，但对我来说，我更喜欢尽可能让我的代码没有警告，所以我会在`UserObject`的`.m`实现文件中添加`@synthesize
    age;`代码行，得到如下所示的内容：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we add `NSString *name` to our `UserObject` class and assign the `readwrite`,
    `nonatomic` property so that our code will now look as follows. The `readwrite`
    property as shown previously will tell the compiler that we want getter and setter
    methods to be automatically created for us and that the `nonatomic` property means
    that we are okay with the `age` variable being non-thread-safe:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们在`UserObject`类中添加`NSString *name`，并分配`readwrite`、`nonatomic`属性，这样我们的代码现在看起来如下。如前所述的`readwrite`属性将告诉编译器我们希望自动为我们创建getter和setter方法，而`nonatomic`属性意味着我们接受`age`变量不是线程安全的：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can now create an instance of the `UserObject` class using `UserObject *user
    = [[UserObject alloc] init]`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`UserObject *user = [[UserObject alloc] init]`创建`UserObject`类的一个实例。
- en: 'Next, we can see the magic of Xcode, where we put in the following code:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到Xcode的神奇之处，我们放入以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Notice that we did not create a getter or setter method for our `NSString *name`,
    but Xcode was smart enough to create it for us once we assigned the properties
    to `NSString *name`.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我们没有为`NSString *name`创建getter或setter方法，但Xcode足够聪明，一旦我们将属性分配给`NSString *name`，就会为我们创建它。
- en: 'However, in some specific cases, you may want to override the default getter
    and setter methods that Xcode provides. Doing so is very easy, and using our `int
    age` as an example, we just create the following methods in our `UserObject .h`
    header file:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，在某些特定情况下，你可能想覆盖Xcode提供的默认getter和setter方法。这样做非常简单，以我们的`int age`为例，我们只需在我们的`UserObject.h`头文件中创建以下方法：
- en: '[PRE8]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We put in our custom getter and setter methods in our `.m`, `UserObject` implementation
    file as follows:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`.m`、`UserObject`实现文件中放入自定义的getter和setter方法，如下所示：
- en: '[PRE9]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: So now, when you call the `setAge` method explicitly using the syntax such as
    `[self setAge];`, the code will call your custom setter method, since you have
    added your own getter and setter code to override the default getter and setter
    code that Xcode has created for you. This gives you efficiency and flexibility
    as Xcode will assume that you want the default getter and setter methods for your
    variables, and yet, you are free to override them if you need to which could occur
    in special cases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在当你显式地使用如`[self setAge];`这样的语法调用`setAge`方法时，代码将调用你的自定义setter方法，因为你已经添加了自己的getter和setter代码来覆盖Xcode为你创建的默认getter和setter代码。这为你提供了效率和灵活性，因为Xcode会假设你希望变量的默认getter和setter方法，而你又有权在需要时覆盖它们，这可能会在特殊情况下发生。
- en: Performance guidelines
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能指南
- en: Although iOS devices such as iPhones and iPads have a lot of memory compared
    to the early Nokia phones, it does not mean that you can be sloppy with regards
    to memory management. The iOS memory model and other mobile OSes do not include
    disk swap space, which are present on computer OSes, where persistent storage
    space is used as an extension of the memory space so that persistent storage can
    be used as a form of RAM for situations where low memory is encountered. So, the
    apps that you develop for iOS devices are more limited in the amount of memory
    that you can access.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管与早期的诺基亚手机相比，iOS设备如iPhone和iPad拥有更多的内存，但这并不意味着你可以对内存管理粗心大意。iOS内存模型和其他移动操作系统不包括计算机操作系统上存在的磁盘交换空间，在计算机操作系统上，持久存储空间被用作内存空间的扩展，以便持久存储可以作为低内存情况下的一种RAM使用。因此，为iOS设备开发的app在可访问的内存量上更加有限。
- en: Using large amounts of memory will lead to a serious degradation of system performance
    and triggering of the three memory warning levels, where the last warning level
    will lead to your application crashing. Plus, apps running under multitasking
    will share system memory with all other running apps that have higher priority
    such as the SMS application and phone application. So, you will never have 100
    percent of the phone memory available for your application under any circumstance
    and even a brand new iOS device will have background processes running. So, reducing
    the amount of memory used by your iOS app should be a high priority task and not
    something that should be filed under a low priority tag.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用大量内存会导致系统性能严重下降并触发三个内存警告级别，最后一个警告级别将导致您的应用程序崩溃。此外，在多任务模式下运行的应用程序将与所有其他具有更高优先级的应用程序（如短信应用程序和电话应用程序）共享系统内存。因此，在任何情况下，您都无法获得100%的手机内存供您的应用程序使用，即使是全新的iOS设备也会有后台进程在运行。因此，减少iOS应用程序使用的内存量应该是一个高优先级任务，而不是应该归档为低优先级标签的任务。
- en: If there is less free memory available in your device, that means the system
    will have a higher probability of being unable to fulfill future memory requests.
    If such a situation was to occur, the system will remove suspected apps and nonvolatile
    resources from memory. However, this is not a good solution as this is only temporary
    and those suspended apps and nonvolatile resources may be needed again a short
    while later.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的设备中可用的空闲内存较少，这意味着系统将有更高的概率无法满足未来的内存请求。如果出现这种情况，系统将移除被怀疑的应用程序和非易失性资源。然而，这并不是一个好的解决方案，因为这只是临时的，那些挂起的应用程序和非易失性资源可能很快又会被需要。
- en: 'The `UIViewController` class in `UIKit` in the iOS SDK provides useful ways
    to help you receive memory warnings in the console, which we saw in the previous
    chapters. I have listed three ways to implement memory warning notifications:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK中的`UIKit`中的`UIViewController`类提供了有用的方法来帮助您在控制台中接收内存警告，这在之前的章节中已经看到。我列出了三种实现内存警告通知的方法：
- en: You should implement the `applicationDidReceiveMemoryWarning` delegate method
    as this will be triggered when your application has some low memory warnings.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您应该实现`applicationDidReceiveMemoryWarning`代理方法，因为当您的应用程序有一些内存警告时，它将被触发。
- en: To get a more granular memory warning such as `Received memory warning. Level=1`
    or `Received memory warning. Level=2` in your debug console, specifically for
    your `UIViewController`, you can implement the `didReceiveMemoryWarning` method
    of your custom `UIViewController` subclass.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要在调试控制台中获取更细粒度的内存警告，例如`Received memory warning. Level=1`或`Received memory warning.
    Level=2`，特别是针对您的`UIViewController`，您可以实现您自定义的`UIViewController`子类的`didReceiveMemoryWarning`方法。
- en: 'To get down to a class level, you can register your object to receive the `UIApplicationDidReceiveMemoryWarningNotification`
    notification via the `addObserver` method to call a specific method once the memory
    is running low, as shown here:'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要达到类级别，您可以通过`addObserver`方法注册您的对象以接收`UIApplicationDidReceiveMemoryWarningNotification`通知，以便在内存不足时调用特定方法，如下所示：
- en: '[PRE10]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once you see any of these warnings triggered in your code, you should respond
    immediately by looking at how you can write the code to free up any unwanted memory.
    A few ways to do this can be:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您在代码中看到任何这些警告被触发，您应该立即响应，查看如何编写代码来释放任何不想要的内存。以下是一些实现此目的的方法：
- en: Removing any views that are not visible to the user but are still loaded in
    memory by calling the `removeFromSuperview` method such as `[myView removeFromSuperview];`
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`removeFromSuperview`方法（例如`[myView removeFromSuperview];`）移除对用户不可见但仍然被加载到内存中的任何视图。
- en: Releasing any images that are not on screen by setting them to `nil`
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将它们设置为`nil`释放不在屏幕上的任何图像。
- en: Purging any data structures that are not used by your code at this point in
    time by calling the `release` method
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过调用`release`方法清除当前代码未使用的任何数据结构。
- en: Imagine that you have a memory leak in your application and the leak causing
    the crash only appears after using the application for 2 hours. So, if you wish
    to replicate the memory leak and trigger the crash in your code, you need to run
    the application for 2 hours each time to see the crash. This can be a time consuming
    task as you need to leave your app running, but thankfully, Xcode provides a way
    to trigger the memory warning without actually producing a memory leak, and this
    feature comes courtesy of the iOS simulator. You can click on **Hardware** | **Simulate
    Memory Warning** in order to trigger a memory warning so that you can write and
    test your memory cleanup code under the relevant memory warning method handler.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的应用程序中存在内存泄漏，导致崩溃的泄漏只有在应用程序使用2小时后才会出现。因此，如果你想在代码中复现内存泄漏并触发崩溃，你需要每次运行应用程序2小时以看到崩溃。这可能会是一个耗时的任务，因为你需要让你的应用程序持续运行，但幸运的是，Xcode提供了一种在不实际产生内存泄漏的情况下触发内存警告的方法，这个功能归功于iOS模拟器。你可以点击**硬件**
    | **模拟内存警告**来触发内存警告，这样你就可以在相关的内存警告方法处理程序下编写和测试你的内存清理代码。
- en: 'The following diagram shows where you need to click to trigger a memory warning:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了你需要点击的位置来触发内存警告：
- en: '![Performance guidelines](img/00052.jpeg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![性能指南](img/00052.jpeg)'
- en: Doing so will allow you to test your iOS application under low memory conditions
    and then write the relevant code to reduce memory usage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做将允许你在低内存条件下测试你的iOS应用程序，然后编写相关代码以减少内存使用。
- en: Don't overthink about memory management
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要过度思考内存管理
- en: 'Memory management is not something that is overly complex or difficult to wrap
    your head around. So, in order to further aid you with memory management, here
    are a few handy tips:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内存管理并不是一件过于复杂或难以理解的事情。因此，为了进一步帮助你进行内存管理，这里有一些实用的技巧：
- en: You can try to make your resource files such as audio, images, and property
    lists as small as possible. To reduce the space occupied by property list files,
    you can use the `NSPropertyListSerialization` class while the free, open source
    command-line tool called Pngcrush can be used to compress PNG files as you can
    have savings of 20 percent or more depending on your PNG files.
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以尝试将你的资源文件，如音频、图像和属性列表，尽可能地缩小。为了减少属性列表文件占用的空间，你可以在使用`NSPropertyListSerialization`类的同时，使用名为Pngcrush的免费开源命令行工具来压缩PNG文件，这样你可以节省20%或更多的空间，具体取决于你的PNG文件。
- en: Core Data is more than just a persistent storage framework. Core Data provides
    a memory efficient way of managing large data sets, and if you manipulate large
    structured data, using the Core Data persistent store or SQLite database as a
    data store as opposed to NSData or NSUserDefault will ensure that you can have
    efficient memory usage provided by Apple's own Core Data framework.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Core Data不仅仅是一个持久化存储框架。Core Data提供了一种内存高效的方式来管理大型数据集，如果你操作大量结构化数据，使用Core Data持久存储或SQLite数据库作为数据存储，而不是使用NSData或NSUserDefault，将确保你可以利用Apple自己的Core
    Data框架提供的有效内存使用。
- en: Resources should always be loaded when you need it, such as when you only need
    to see it on the device screen. This is called lazy loading, which we have seen
    in the previous chapter. You could be tempted to load all resources much in advance
    before you actually use it. However, this will actually mean that your resource
    is occupying memory when it is actually not being used at the current moment.
    So to optimize memory usage, always practice lazy loading.
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源应该在需要时加载，例如，当你只需要在设备屏幕上看到它时。这被称为懒加载，我们在上一章中已经看到过。你可能会在真正使用之前提前加载所有资源。然而，这实际上意味着你的资源在当前时刻实际上没有被使用时却在占用内存。因此，为了优化内存使用，始终实践懒加载。
- en: 'Finally, this is a little-known tip that you can use in your **Build Settings**:
    you can add the `-mthumb` compiler flag to help reduce the size of your code by
    using 16-bit instructions instead of 32-bit instructions, which uses up less space
    and this can result in savings of up to 35 percent. However, one caveat is that
    if your iOS application floating point intensive code and your application needs
    to support ARMv6 such as older generation iPod Touches and older iPhones, then
    the `-mthumb` option should not be used for your application. However, if your
    code is for ARMv7, then you can enable the `-mthumb` option in your Xcode project,
    which is enabled by default.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，这是一个鲜为人知的技巧，你可以在你的 **构建设置** 中使用：你可以添加 `-mthumb` 编译器标志，通过使用 16 位指令而不是 32 位指令来帮助减小代码的大小，这会占用更少的空间，并且这可能导致高达
    35% 的节省。然而，有一个注意事项是，如果你的 iOS 应用程序包含浮点运算密集型代码，并且你的应用程序需要支持 ARMv6，例如旧一代的 iPod Touch
    和旧款 iPhone，那么不应该为你的应用程序使用 `-mthumb` 选项。然而，如果你的代码是为 ARMv7 编写的，那么你可以在你的 Xcode 项目中启用
    `-mthumb` 选项，这是默认启用的。
- en: When to avoid KVC and KVO
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时避免使用 KVC 和 KVO
- en: KVC and KVO, which we covered previously in [Chapter 7](part0056_split_000.html#page
    "Chapter 7. Key-value Programming Approaches"), *Key-value Programming Approaches*,
    seems like a great mechanism for notifications at a very granular level, but it
    is possible to go wrong with KVO if you use it incorrectly. The `removeObserver`
    method will crash if you are not the observer for that key path, so keeping an
    exact track of the properties that you are observing is a must.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在 [第 7 章](part0056_split_000.html#page "第 7 章。键值编程方法") 中讨论的 KVC 和 KVO，*键值编程方法*，看起来像是一个非常细粒度的通知机制，但如果使用不当，KVO
    是可能出现错误的。如果你不是该键路径的观察者，`removeObserver` 方法会导致崩溃，因此精确跟踪你正在观察的属性是必须的。
- en: 'KVO only has one callback method. If you have multiple notifications, you need
    to handle them within one callback method, which makes your code inelegant and
    clunky like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: KVO 只有一个回调方法。如果你有多个通知，你需要在同一个回调方法中处理它们，这使得你的代码显得不够优雅，就像这样：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With a few more notifications, you will write a lot of if-else statements and
    you will be able to see how unwieldy the code will be and many bad things such
    as crashes, bugs, and so on will appear, and this requires more debugging time.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 随着更多通知的出现，你将编写大量的 if-else 语句，你将能够看到代码将多么难以控制，并且会出现许多不良情况，如崩溃、错误等，这需要更多的调试时间。
- en: KVO registering can crash your app if you do it multiple times. If you have
    a superclass that is observing the same parameter on the same object, the `removeObserver`
    method will be called twice and it would lead to a crash on the second time.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果多次注册 KVO，可能会使你的应用程序崩溃。如果你有一个父类正在观察同一对象上的相同参数，`removeObserver` 方法将被调用两次，这会导致第二次调用时崩溃。
- en: KVO works in a wonderful and magical way in the same way as callbacks. Code
    utilizing callback can be painful to debug. So, I would recommend KVO usage if
    you have adequate experience with KVO and start with small projects as the API
    documentation is sparse and it can lead to debugging problems down the road if
    you are not well versed with KVO.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: KVO 以一种奇妙而神奇的方式工作，就像回调一样。使用回调的代码可能难以调试。所以，如果你对 KVO 有足够的经验，我建议从小型项目开始使用 KVO，因为
    API 文档很少，如果你不熟悉 KVO，这可能会导致未来的调试问题。
- en: Summary
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Finally, we reached the end of this chapter. This chapter covers some details
    of Objective-C, such as property attributes, which you have been typing in but
    do not have a clear idea of. We also covered memory management guidelines, where
    I have outlined some tips and tricks to add to your knowledge of memory management
    and debugging memory-related issues in your code. This chapter just covers a small
    subset of memory management and I hope that you have dived deep into the previous
    chapters, where the various memory management techniques are covered more in-depth.
    Finally, one more chapter lies ahead, where we will go through some of the new
    tools and functionalities of Xcode 6, which you can use in your projects. So,
    let's proceed, shall we?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了本章的结尾。本章涵盖了 Objective-C 的一些细节，例如属性属性，这些属性你可能一直在输入，但并没有一个清晰的概念。我们还讨论了内存管理指南，我在其中概述了一些可以添加到你对内存管理和调试代码中内存相关问题的知识的技巧和窍门。本章仅涵盖了内存管理的一小部分，我希望你已经深入研究了前面的章节，其中更深入地讨论了各种内存管理技术。最后，还有一个章节在前面，我们将探讨
    Xcode 6 的一些新工具和功能，你可以在你的项目中使用。那么，我们继续吧，好吗？
