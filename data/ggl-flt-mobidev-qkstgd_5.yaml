- en: Widening our Flutter Horizons
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展Flutter视野
- en: In this chapter, we will first discuss networking in Flutter by building a simple
    application that fetches data from the server using JSON. Every app is required
    to have accessibility features to cater to mass users, and we will cover this
    in the accessibility options. In the final section, we will talk about localization
    for having your app grow globally, supporting multiple languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先通过构建一个简单的应用程序来讨论Flutter中的网络，该应用程序使用JSON从服务器获取数据。每个应用程序都必须具备无障碍功能，以满足大量用户的需求，我们将在无障碍选项中介绍这一点。在最后一节中，我们将讨论本地化，以便您的应用程序在全球范围内增长，支持多种语言。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Networking in Flutter
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flutter中的网络
- en: Accessibility in Flutter
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Flutter中的无障碍功能
- en: Internation­alizing Flutter apps
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 国际化Flutter应用程序
- en: Networking in Flutter
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flutter中的网络
- en: Networking is the backbone of any app, and knowing how to make network calls
    is crucial. Working with networking calls in Flutter is simple and follows a streamline
    standard method. Flutter libraries and methods make it easier for developers to
    build apps with networking. This chapter will focus on making networking requests.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 网络是任何应用程序的骨架，了解如何进行网络调用至关重要。在Flutter中处理网络调用简单且遵循标准流程。Flutter库和方法使开发者更容易构建具有网络功能的应用程序。本章将重点介绍制作网络请求。
- en: Using packages
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用包
- en: 'Like many platforms, Flutter supports the use of shared packages that are contributed
    by the developers to the Flutter and Dart ecosystem. This facilitates development
    by making developers build apps quickly rather than worry about developing the
    code from scratch. Some of the most commonly used packages include, but are not
    limited to: making network requests (HTTP); using device APIs, such as device
    information (`device_info`); finding information and controlling the camera, including
    the support for previews of the camera feed and the captured image (camera); finding
    and using the location of the device using GPS coordinates (geolocator); and using
    third-party platform SDKs (such as Firebase). You can find the complete list of
    packages supported by Flutter at [https://pub.dartlang.org/packages](https://pub.dartlang.org/packages).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多平台一样，Flutter支持使用由开发者贡献给Flutter和Dart生态系统的共享包。这通过让开发者快速构建应用程序而不是担心从头开始编写代码来促进开发。一些最常用的包包括但不限于：进行网络请求（HTTP）；使用设备API，例如设备信息（`device_info`）；查找信息并控制摄像头，包括对摄像头流和捕获图像的预览支持（camera）；使用GPS坐标查找和使用设备位置（geolocator）；以及使用第三方平台SDK（如Firebase）。您可以在[https://pub.dartlang.org/packages](https://pub.dartlang.org/packages)找到Flutter支持的完整包列表。
- en: Adding existing package dependency to an app
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将现有包依赖项添加到应用程序中
- en: 'Once you have decided on the set of packages that you want to include, follow
    these steps to include the dependency. For the purpose of this example, we have
    chosen HTTP package to an app. This package contains a set of high-level functions
    and classes, which can help developers consume HTTP resources while working on
    the app, and it is platform independent. It supports both the command line and
    the browser:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您确定要包含的包集，请按照以下步骤添加依赖项。为了本例的目的，我们选择了HTTP包添加到应用程序中。此包包含一组高级函数和类，可以帮助开发者在应用程序开发过程中消费HTTP资源，并且它是平台无关的。它支持命令行和浏览器：
- en: 'Create the dependency: Open the `pubspec.yaml` file located inside your app
    folder, and add `http:` under dependencies.'
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建依赖项：打开位于您的应用程序文件夹内的`pubspec.yaml`文件，并在依赖项下添加`http:`。
- en: 'All packages have a version number, specified in their `pubspec.yaml` file.
    The current version of the package is displayed next to the package name. When
    you mention `Plugin_Name_1:`, it is interpreted as `Plugin_Name_1: any`. This
    indicates that any version of the package may be used. It is advisable to use
    a specific version to ensure that the app doesn''t break when it is updated.'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '所有包都有一个版本号，在它们的`pubspec.yaml`文件中指定。包的当前版本显示在包名称旁边。当您提到`Plugin_Name_1:`时，它被解释为`Plugin_Name_1:
    any`。这表示可以使用包的任何版本。建议使用特定版本，以确保在更新时应用程序不会崩溃。'
- en: Install the package where the dependency has been added. You can install it
    by running the `flutter packages get` command. If you are using Android Studio/IntelliJ,
    you can also click the Package Get option in the action ribbon at the top of `pubspecs.yaml`.
    If you are using VS code, click Get Packages located on the right-hand side of
    the action ribbon at the top of `pubspec.yaml`
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装已添加依赖的包。你可以通过运行`flutter packages get`命令来安装它。如果你使用Android Studio/IntelliJ，你还可以点击`pubspecs.yaml`顶部的操作栏中的Package
    Get选项。如果你使用VS code，请点击`pubspec.yaml`顶部操作栏右侧的Get Packages。
- en: Include the corresponding `import` statement in your Dart code. In this case,
    it is `import package:http/http.dart`. In case you have missed anything, you can
    always cross-check using the Installation tab option on the package page on `Pub`.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的Dart代码中包含相应的`import`语句。在这种情况下，是`import 'package:http/http.dart'`。如果你遗漏了任何内容，你总是可以在`Pub`上的包页面上的安装选项卡中进行交叉检查。
- en: At this point, it is better if you stop and restart the app to avoid errors
    such as `MissingPluginException` when using the package.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这一点上，最好停止并重新启动应用，以避免使用该包时出现`MissingPluginException`等错误。
- en: Upgrading existing package
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 升级现有包
- en: When you run `flutter packages get` (this will be `Packages Get` in IntelliJ)
    for the first time after adding a package in the `pubspec.yaml` file, Flutter
    will save the version found in the `pubspec.lock lockfile` file. To upgrade the
    package, you can run the Flutter packages upgrade (`Upgrade dependencies` in IntelliJ).
    Using this command, Flutter will retrieve the highest available version of the
    package. In case you have specified range constraint in `pubspec.yaml`, it will
    fetch the update as per the specification of the constraint.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在`pubspec.yaml`文件中添加了一个包后，第一次运行`flutter packages get`（在IntelliJ中将是`Packages
    Get`）时，Flutter会保存`pubspec.lock`锁文件中找到的版本。要升级包，你可以运行Flutter包升级（在IntelliJ中是`Upgrade
    dependencies`）。使用此命令，Flutter将检索包的最高可用版本。如果你在`pubspec.yaml`中指定了范围约束，它将根据约束的指定获取更新。
- en: Building a REST service
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建REST服务
- en: One of the most prominent tasks for developers is to build REST services for
    the project that help you gather data in JSON format, which you can reflect on
    the front-end of the application. Imagine working on an application, and you want
    to mock up a REST web service to get the demo data for you. You could certainly
    build your backend server using Node.js, MongoDB, or other platforms, but one
    of the easiest ways is to use a JSON server. A JSON server is a simple project
    that stimulates REST API with CRUD operation. This project hardly consumes time
    for the setup, and you can swiftly process the data to ensure that everything
    works as expected. It is ideal for developers who are learning to build REST APIs
    to understand how the data is processed with a backend for prototyping and mocking.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，最突出的任务之一是为项目构建REST服务，这些服务可以帮助你以JSON格式收集数据，你可以在应用的前端进行反映。想象一下你在开发一个应用，并想模拟一个REST
    web服务来获取你的演示数据。你当然可以使用Node.js、MongoDB或其他平台来构建后端服务器，但其中最简单的方法之一是使用JSON服务器。JSON服务器是一个简单的项目，它通过CRUD操作模拟REST
    API。这个项目几乎不需要设置时间，你可以快速处理数据以确保一切按预期工作。这对于学习构建REST API的开发者来说，了解数据如何通过后端进行原型设计和模拟处理是非常理想的。
- en: Setting up JSON Server
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置JSON服务器
- en: 'The setup of this project can be found at [https://github.com/typicode/json-server](https://github.com/typicode/json-server).
    Note that this project builds a full fake REST API for demo purposes only. Before
    we begin the setup, ensure that the following components are ready on your system:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的设置可以在[https://github.com/typicode/json-server](https://github.com/typicode/json-server)找到。请注意，此项目仅为了演示目的构建了一个完整的假REST
    API。在我们开始设置之前，请确保以下组件已准备好在你的系统上：
- en: '**Node.js**: JSON-Server is built on top of Node.js. If you already have it
    in place, please ensure to keep it updated. To find out the version of Node, run
    the `node -v` command.'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**Node.js**：JSON-Server建立在Node.js之上。如果你已经安装了它，请确保保持其更新。要查看Node的版本，请运行`node
    -v`命令。'
- en: '**NPM package**: NPM stands for Node Package Manager, and comes in handy to
    easily install, update, configure, and uninstall Node JS platform modules/packages.
    Ensure NPM is installed on the system. If not, refer to [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm).
    At this point, it would be ideal to quote that NPM is a separate project from
    the Node, and gets updated frequently. To update NPM, use the `sudo npm install
    npm@latest -g` command.'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**NPM 包**：NPM 代表 Node 包管理器，它便于轻松安装、更新、配置和卸载 Node JS 平台模块/包。确保系统上已安装 NPM。如果没有，请参考
    [https://www.npmjs.com/get-npm](https://www.npmjs.com/get-npm)。在此阶段，引用 NPM 是一个独立于
    Node 的项目，并且经常更新。要更新 NPM，请使用 `sudo npm install npm@latest -g` 命令。'
- en: '`cURL`: This open source command line enables the transfer of data with URL
    syntax. If you have `cURL` installed, use the `curl -V`  command (Note that `V`
    is upper case). In case you need to install `cURL`, run the `brew install curl`
    command.'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`cURL`：这是一个开源的命令行工具，它使用 URL 语法进行数据传输。如果你已经安装了 `cURL`，请使用 `curl -V` 命令（注意 `V`
    是大写）。如果你需要安装 `cURL`，请运行 `brew install curl` 命令。'
- en: 'The JSON server is available as an NPM package, so we could simply run the
    following command to install it:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: JSON 服务器作为一个 NPM 包提供，因此我们可以简单地运行以下命令来安装它：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `-g` option enables the package to be installed globally on your system.
    Once you have installed it successfully, run the command to cross check:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`-g` 选项使包能够在你的系统上全局安装。一旦安装成功，运行以下命令进行交叉检查：'
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Building a resource file
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建资源文件
- en: A resource is anything that has data associated with it. For example, if you
    are working on a movie review website, movies, reviewers, users, and so on, would
    be resources. You could have API endpoints based on these resources. The API endpoints
    help you to retrieve or update the data on the server. In this case, we will use
    the resources as a JSON file. This JSON file will act as a config and database
    file for the mock server you set up using `json-server`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 资源是与数据相关联的任何事物。例如，如果你正在制作一个电影评论网站，电影、评论者、用户等等，都是资源。你可以基于这些资源创建 API 端点。API 端点帮助你检索或更新服务器上的数据。在这种情况下，我们将使用资源作为
    JSON 文件。这个 JSON 文件将作为你使用 `json-server` 设置的模拟服务器的配置和数据库文件。
- en: '`Json-server` works in a JSON file, and creating a JSON file is simple. Create
    a new file as `Books.json`, populate the following content, and save it. Note
    that the name of the array we specified is `Movie`, so `json-server` will create
    the REST APIs based on this name:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`Json-server` 在 JSON 文件中工作，创建一个 JSON 文件很简单。创建一个新文件名为 `Books.json`，填充以下内容，并保存。注意，我们指定的数组名称是
    `Movie`，因此 `json-server` 将基于此名称创建 REST API：'
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the json-server
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行 json-server
- en: 'The final step is to run `json-server` to ensure we have the mock server running
    locally. Run the following command:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是运行 `json-server` 以确保本地正在运行模拟服务器。运行以下命令：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Congratulations! You have now successfully set up `json-server`. Open the `http://localhost:3000/` URL
    to check whether you can see the following. Under the resources tag, you will
    be able to see the Movies JSON file we created.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经成功设置了 `json-server`。打开 `http://localhost:3000/` URL 检查你是否能看到以下内容。在资源标签下，你将能够看到我们创建的
    Movies JSON 文件。
- en: Do not close the terminal, as that will kill `json-server`. In case your port
    `3000` is utilized, you can set options for the new port number in a `json-server.json`
    configuration file.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 不要关闭终端，因为这会杀死 `json-server`。如果你的端口 `3000` 被占用，你可以在 `json-server.json` 配置文件中设置新端口号的选项。
- en: Fetching data from the server
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从服务器获取数据
- en: 'Fetching data from the server is a commonly used feature. It is performed using
    the HTTP package that we covered earlier in this chapter. The steps to follow
    are as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 从服务器获取数据是一个常用的功能。它使用我们在本章前面覆盖的 HTTP 包执行。要遵循的步骤如下：
- en: Include the HTTP package and make the network request
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 包含 HTTP 包并执行网络请求
- en: Convert the response into a custom Dart object
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应转换为自定义 Dart 对象
- en: Fetch the data and display it using the Flutter
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 Flutter 获取数据并显示
- en: Since we have already learned about adding HTTP packages in the *Using packages*
    section, we will now proceed with making a network request. In our next step,
    we will fetch the sample JSON content using JSON-Server and the `http.get()` method.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在*使用包*部分学习了如何添加 HTTP 包，我们现在将继续进行网络请求的制作。在下一步中，我们将使用 JSON-Server 和 `http.get()`
    方法获取示例 JSON 内容。
- en: 'We use the `Future` function, which is a core Dart class for working with async
    tasks and, together with `http`, it returns the data from a successful `http`
    call:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Future` 函数，这是 Dart 的一个核心类，用于处理异步任务，并且与 `http` 一起使用可以返回成功的 `http` 调用的数据：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We now create a `Post` class that will contain the data from our network requests.
    To ensure that we create a proper `Post` from JSON, we will include a `factory`
    constructor. In our example, we have four categories of data for each array to
    fetch, namely, `id`, `movieName`, `year`, and the `category`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们创建一个 `Post` 类，它将包含我们网络请求的数据。为了确保我们能够从 JSON 正确创建 `Post` 对象，我们将包括一个 `factory`
    构造函数。在我们的示例中，我们为每个要获取的数组提供了四个数据类别，即 `id`、`movieName`、`year` 和 `category`：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, we will need to update the `fetchPost` function to return a `Future<Post>`,
    for which we will follow three steps:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 `fetchPost` 函数以返回一个 `Future<Post>`，我们将遵循以下三个步骤：
- en: 'First, convert the response body into a JSON Map using the `dart:convert` package.
    This package contains encoders and decoders for converting between different data
    representations. To use this, you will first have to add the dependency in your
    package''s `pubspec.yaml` file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用 `dart:convert` 包将响应体转换为 JSON Map。这个包包含用于在不同数据表示之间转换的编码器和解码器。为了使用它，你首先必须在你的包的
    `pubspec.yaml` 文件中添加依赖项：
- en: '[PRE6]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now, use the `package:convert/convert.dart` import in your dart code.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在你的 Dart 代码中使用 `package:convert/convert.dart` 导入。
- en: If we get an `OK` response from the server with a status code of `200`, it means
    the data is fetched, and you can convert the JSON Map into a `Post` using the `fromJSON`
    factory.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们从服务器收到一个状态码为 `200` 的 `OK` 响应，这意味着数据已被获取，你可以使用 `fromJSON` 工厂将 JSON Map 转换为
    `Post`。
- en: If the response is unexpected, you can flag an error.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果响应是意外的，你可以标记一个错误。
- en: 'Here is the piece of code that checks the previously-mentioned cases:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是检查之前提到的情况的代码片段：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In order to fetch the data and display it, we use the `FutureBuilder` widget
    that is built into Flutter, and helps in working easily with async data sources.
    To make this happen, we will need two parameters:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获取数据并显示它，我们使用 Flutter 内置的 `FutureBuilder` 小部件，它有助于轻松处理异步数据源。为了实现这一点，我们需要两个参数：
- en: The name of the future we want to work with. In our example, we call it the `fetchPost()`
    function.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们想要与之工作的未来的名称。在我们的示例中，我们称它为 `fetchPost()` 函数。
- en: 'A builder function that informs Flutter what to render, based on the state
    of the Flutter—loading, success, or error:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个构建函数，它根据 Flutter 的状态（加载、成功或错误）告诉 Flutter 应该渲染什么：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Building the code by putting a call to an API in your `build()` method is convenient,
    but it's not recommended. It will make Flutter call the `build()` method every
    time when it wants to change anything in the view, making your app slow due to
    it making unnecessary flooded API calls. A better way is to bit the API when the
    page is initially loaded, and use `StatelessWidget` for the same.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `build()` 方法中调用 API 来构建代码是方便的，但并不推荐。这会使 Flutter 每次想要在视图中更改任何内容时都调用 `build()`
    方法，这会导致你的应用因不必要的频繁 API 调用而变慢。更好的方法是，在页面最初加载时调用 API，并使用 `StatelessWidget`。
- en: 'Using this method, you will make the parent widget responsible for calling
    the fetch method, storing its result and then passing it to your widget:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种方法，你将使父级小部件负责调用获取方法，存储其结果，然后将它传递给你的小部件：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'This is the complete code that will fetch the JSON content using `json-server`
    by reading `Movies.json`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是完整的代码，它将使用 `json-server` 通过读取 `Movies.json` 来获取 JSON 内容：
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: At the start of the chapter, we discussed what packages are and how to use them.
    Once the packages were set up, we discussed how to build a JSON Server to fetch
    data for our tests. In the final section, we glanced through an example of how
    to fetch the JSON data to the app, displaying the content of the JSON file we
    created and ran using the JSON server.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了包是什么以及如何使用它们。一旦包设置好，我们就讨论了如何构建 JSON Server 以获取测试数据。在最后一节，我们简要地看了一下如何将
    JSON 数据获取到应用中，展示了我们创建并使用 JSON server 运行的 JSON 文件内容。
- en: Accessibility in Flutter
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Flutter 的可访问性
- en: Making your app accessible to many users could be a great initiative. That also
    includes people with disabilities, such as blindness, hearing, voice, or motor
    impairment. As per the reports on disability by the World Health Organization,
    there are over 100 million users across the globe who face physical challenges
    in their daily routine. Technology can be revolutionary in helping people, and
    that's when building apps catering to their specific needs can aid them well.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使您的应用对众多用户可访问可能是一个很好的举措。这也包括有残疾的人，如盲人、听力、语音或运动障碍。根据世界卫生组织关于残疾的报告，全球有超过一亿用户在日常生活中面临身体挑战。技术可以帮助人们实现革命性的变化，这就是当构建满足他们特定需求的应用程序时，可以很好地帮助他们的时候。
- en: Not all the users use the app in a specifically defined manner, so, a focus
    on accessibility will not only help users to download and use the app, but will
    also propagate to a new level of users.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有用户都以特定的方式使用应用程序，因此，关注可访问性不仅可以帮助用户下载和使用应用程序，而且还会传播到新的用户层面。
- en: Google provides an app to check for accessibility support that is available
    as accessibility scanner on Google Play at [https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor](https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor) This
    app enables you to find the accessibility provide that a developer can do within
    the app. For iOS, XCode provides Accessibility Inspector.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Google 提供了一个用于检查可访问性支持的应用程序，该应用程序作为 Google Play 上的可访问性扫描仪提供，网址为 [https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor](https://play.google.com/store/apps/details?id=com.google.android.apps.accessibility.auditor)。此应用程序使您能够找到开发者可以在应用程序中实现的可访问性提供。对于
    iOS，XCode 提供了可访问性检查器。
- en: 'Flutter supports three components for accessibility support:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter 支持三个用于可访问性支持的功能：
- en: Large font
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 大字体
- en: With age, not many can see the content the way they used to in their youth.
    Some face issues in reading the text clearly, especially when developers consider
    using thedefault size without taking into considering factors such as screen size
    and orientation. One of the quickest ways to do this is to ensure that the text
    scales in their accessibility options consider the device specifications of the
    consumers.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 随着年龄的增长，很多人无法像年轻时那样看到内容。有些人阅读文本时遇到问题，尤其是当开发者考虑使用默认大小而没有考虑屏幕大小和方向等因素时。最快的方法之一是确保文本在可访问性选项中缩放时考虑消费者的设备规格。
- en: 'Flutter has a feature that handles text size calculations automatically. For
    example, the `Text` widget has a `textScaleFactor` property that allows the scaling
    of the text. Font size is multiplied by the `textScaleFactor` value to determine
    the new font size that is rendered on the screen in logical pixels. For example,
    if the `textScaleFactor` is `1.5`, the text will be 50% larger than the specified
    font size, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Flutter 具有自动处理文本大小计算的特性。例如，`Text` 小部件有一个 `textScaleFactor` 属性，允许对文本进行缩放。字体大小通过乘以
    `textScaleFactor` 值来确定在屏幕上渲染的新字体大小，该大小以逻辑像素为单位。例如，如果 `textScaleFactor` 是 `1.5`，文本将比指定的字体大小大
    50%，如下所示：
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One point that needs to be kept in mind is that, if you manually set the scale
    value, the user’s accessibility settings will be overridden. You have to ensure
    that the scale-up value doesn't show up the text to a large extent leading to
    uninstall of the app. If you do not specify the value, it will check `textScaleFactor`
    for the nearest `MediaQuery` ancestor (`MediaQueryData.textScaleFactor`) or `1.0`,
    if no such ancestor exists. Ensure that you test the text displays properly at
    all accessibility settings.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要记住的一点是，如果您手动设置缩放值，用户的可访问性设置将被覆盖。您必须确保放大值不会导致文本过大，以至于用户会卸载应用程序。如果您没有指定值，它将检查最近的
    `MediaQuery` 祖先（`MediaQueryData.textScaleFactor`）的 `textScaleFactor` 或 `1.0`，如果不存在这样的祖先。确保您在所有可访问性设置中测试文本是否正确显示。
- en: Screen readers
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕阅读器
- en: 'For those who are visually impaired, this accessiblity option can come in handy.
    It enables users to receive spoken feedback about the content of the screen. You
    could turn on VoiceOver in iOS, or TalkBack in an Android application on your
    device to navigate around your app. For example, when using TalkBack, users perform
    actions using gestures, and each action is complimented with an audible output
    that allows users to know that their gesture trigger was successful. There are
    three types of gestures in TalkBack: basic gestures, back-and-forth gestures,
    and angle gestures. Note that the users should use single gestures, even finger
    pressure, and a steady speed to have a seamless experience.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于视力受损的用户，这个可访问性选项可能很有用。它使用户能够接收到关于屏幕内容的语音反馈。您可以在 iOS 中开启语音控制，或在您的设备上的 Android
    应用程序中开启 TalkBack 来导航您的应用程序。例如，当使用 TalkBack 时，用户通过手势执行操作，每个操作都会伴随着可听到的输出，使用户知道他们的手势触发是成功的。TalkBack
    有三种类型的手势：基本手势、往返手势和角度手势。请注意，用户应使用单一手势，即使是手指压力，以及稳定的速度，以获得无缝体验。
- en: Screen contrast
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 屏幕对比度
- en: Specifying background and foreground colors with sufficient color contrast enables
    better readability for the users. This ratio ranges from 1 to 21, where 21 means
    the highest.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用足够的颜色对比度指定背景和前景颜色，可以增强用户的可读性。此比率范围从 1 到 21，其中 21 表示最高。
- en: 'The W3C recommends the following:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: W3C 推荐以下内容：
- en: At least 4.5:1 for smaller text (below 18 point regular, or 14 point bold)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 4.5:1 的对比度用于较小的文本（小于 18 点常规字体，或 14 点粗体）
- en: At least 3.0:1 for larger text (18 point and above regular, or 14 point and
    above bold)
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 至少 3.0:1 的对比度用于较大的文本（18 点及以上常规字体，或 14 点及以上粗体）
- en: Accessibility is an important feature and should not be neglected. It ensures
    that the app is open to a larger audience, enabling the chances for better application
    usage. It is equally important to test the accessibility options before rolling
    out to the masses.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可访问性是一个重要的功能，不应被忽视。它确保应用程序对更广泛的受众开放，增加了更好的应用程序使用机会。在向大众推出之前测试可访问性选项同样重要。
- en: Internation­alizing Flutter apps
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 国际化 Flutter 应用
- en: As the name suggests, if your app will be by the international audience, you
    will have to think of providing **locale** support for the specific language of
    the target. That means you’ll need to write the app in a way that your app renders
    the values like text and layouts depending on each language or locale that the
    app supports. Flutter has made it simple by providing support by classes and widgets.
    Flutter supports the global localization classes for about 24 languages.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，如果您的应用程序将由国际受众使用，您将需要考虑为特定语言提供 **区域** 支持。这意味着您需要以这种方式编写应用程序，以便应用程序根据应用程序支持的每种语言或区域渲染值，如文本和布局。Flutter
    通过提供类和部件的支持使其变得简单。Flutter 支持 24 种语言的全球本地化类。
- en: 'Before you start the internationalization, dependencies must be added in** `pubspec.yaml`**:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始国际化之前，必须在 `pubspec.yaml` 中添加依赖项：
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The next step is to import the `flutter_localizations` library and specify
    `localizationsDelegates` and `supportedLocales` for `MaterialApp`. Also, import
    `package:flutter_localizations/flutter_localizations.dart`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是导入 `flutter_localizations` 库，并为 `MaterialApp` 指定 `localizationsDelegates`
    和 `supportedLocales`。同时，导入 `package:flutter_localizations/flutter_localizations.dart`：
- en: '[PRE13]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `localizationsDelegates` list contains the elements that are factories that
    produce collections of localized values. `GlobalMaterialLocalizations.delegate`
    provides strings that are localized and other values for the material components
    library. The default text direction for the widget library is defined by `GlobalWidgetsLocalizations.delegate`**. **
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`localizationsDelegates` 列表包含的是生产本地化值集合的工厂元素。`GlobalMaterialLocalizations.delegate`
    提供了用于材料组件库的本地化字符串和其他值。小部件库的默认文本方向由 `GlobalWidgetsLocalizations.delegate`**定义**。'
- en: 'There are three methods to keep an eye on:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种方法需要关注：
- en: '`.load`: This method must return an object that contains a collection of related
    resources'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.load`：此方法必须返回一个包含相关资源集合的对象'
- en: '`.isSupported`: If the support for the locale is found, it returns `True`.
    Otherwise it will return **`False`**'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`.isSupported`：如果找到对区域的支持，则返回 `True`。否则将返回 **`False`**'
- en: '`shouldReload`: If this method returns `True`, then all the app widgets will
    be rebuilt after a load of resources'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`shouldReload`：如果此方法返回 `True`，则在加载资源后，所有应用程序小部件都将被重建'
- en: 'The complete code for your reference is as follows:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是为您提供的完整代码：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'After you run the code successfully, you will see the output as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在成功运行代码后，你将看到以下输出：
- en: '![](img/0b813aea-4d78-4467-b286-b5e550fb8737.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b813aea-4d78-4467-b286-b5e550fb8737.png)'
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We first discussed how networking plays an important role in the apps, along
    with sample code for setting up and running a local server for fetching JSON code.
    This section was followed by understanding why accessibility is important, and
    what improvements developers can provide to support accessibility in the app.
    The next section showed how to make app support internationalization.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先讨论了网络在应用程序中扮演的重要角色，以及设置和运行用于获取JSON代码的本地服务器的示例代码。这一部分之后，我们了解了为什么可访问性很重要，以及开发者可以为支持应用程序的可访问性提供哪些改进。下一节展示了如何使应用程序支持国际化。
- en: In the next chapter, we will discuss how to use platform powers to build apps.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论如何使用平台功能来构建应用程序。
