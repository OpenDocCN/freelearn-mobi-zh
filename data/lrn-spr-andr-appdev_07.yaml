- en: Concurrency
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发
- en: '**Concurrency** is the ability of a program or algorithm to be divided into
    parts that can be executed out of order without affecting the results. This approach
    allows for parallel execution in a multi-core environment, which can significantly
    improve the performance. It''s important to understand the difference between
    *concurrency* and *parallelism*. Parallelism assumes that a program is implemented
    in a concurrent way, but concurrency doesn''t mean that the program is executed
    in parallel.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**并发**是程序或算法能够被划分为可以无序执行而不影响结果的部分的能力。这种方法允许在多核环境中进行并行执行，这可以显著提高性能。理解并发与并行之间的区别很重要。并行假设程序是以并发方式实现的，但并发并不意味着程序是并行执行的。'
- en: 'This chapter will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Coroutines
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程
- en: Sequential operations
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 顺序操作
- en: Callback hell
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调地狱
- en: Thread pools
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程池
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To run the code in this chapter, you will need to integrate the `coroutines-core`
    library. To do this, you should add the following line to the `repositories` block
    of the `build.gradle` file:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行本章中的代码，你需要集成`coroutines-core`库。为此，你应该将以下行添加到`build.gradle`文件的`repositories`块中：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should also add the following line to the `dependencies` block:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该在`dependencies`块中添加以下行：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following line to integrate the `kotlinx-coroutines-android` library:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下行以集成`kotlinx-coroutines-android`库：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you are using a Kotlin version lower than 1.3, you should also add the following
    lines to the `build.gradle` file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是低于1.3的Kotlin版本，你还应该在`build.gradle`文件中添加以下行：
- en: '[PRE3]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To integrate Spring for the Android library, you should add the following lines:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要集成Spring Android库，你应该添加以下行：
- en: '[PRE4]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You should also add the `repositories` block, as follows:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该添加`repositories`块，如下所示：
- en: '[PRE5]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This chapter will also work with the [JSON to Kotlin Class](https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-)
    plugin. To install this plugin, open the Preferences window and select the Plugins
    section.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章还将与[JSON to Kotlin Class](https://plugins.jetbrains.com/plugin/9960-json-to-kotlin-class-jsontokotlinclass-)插件一起工作。要安装此插件，请打开首选项窗口并选择插件部分。
- en: Press the Install button and restart Android Studio.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 点击安装按钮并重新启动Android Studio。
- en: The source code for this chapter, with examples, is available on GitHub, at
    the following link: [https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的源代码，包括示例，可在以下链接的GitHub上找到：[https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07](https://github.com/PacktPublishing/Learn-Spring-for-Android-Application-Development/tree/master/Chapter07)。
- en: Coroutines
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程
- en: A** coroutine** is a powerful feature of the Kotlin programming language. Its
    main objective is to allow for suspending a function while it waits for the result
    of another function that invokes a long-term operation. This feature allows us
    to write asynchronous code without callbacks in a sequential way.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程**是Kotlin编程语言的一个强大功能。其主要目标是允许在等待另一个函数调用的长期操作结果时挂起函数。这个功能允许我们以顺序方式编写异步代码，而不需要回调。'
- en: 'This section will cover the following topics:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下主题：
- en: Coroutine basics
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程基础
- en: Call stacks
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用栈
- en: Coroutine testing
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程测试
- en: Coroutine scope
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协程作用域
- en: Coroutine basics
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程基础
- en: If you are familiar with the concept of threads, you will know that each thread
    has its own call stack. We will cover the thread's call stack topic in the next
    section. The creation of a new thread is a complex operation that takes about
    two megabytes of memory. Coroutines use a thread pool under the hood, and only require
    the creation of several additional methods and classes. That is why you can consider
    coroutines as lightweight threads.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉线程的概念，你会知道每个线程都有自己的调用栈。我们将在下一节中介绍线程的调用栈。创建新线程是一个复杂的操作，大约需要两兆内存。协程在底层使用线程池，并且只需要创建几个额外的方法和类。这就是为什么你可以将协程视为轻量级线程。
- en: 'Let''s imagine that we have a long-term operation, as shown in the following
    code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们有一个长期操作，如下面的代码所示：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `loadImage` function takes three seconds and returns an instance of the
    `Image` class. We also have the `showImages` function that takes three instances
    of the `Image` class, and looks as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadImage` 函数需要三秒钟并返回 `Image` 类的实例。我们还有一个 `showImages` 函数，它接受三个 `Image` 类的实例，如下所示：'
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'So, we have three independent tasks that can be executed in parallel. We can
    create three coroutines here, each of which will execute the `loadImage` function.
    To create a new coroutine, we can use one of the functions called a **coroutine
    builder**, such as `async` or `launch`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有三个可以并行执行的独立任务。我们在这里可以创建三个协程，每个协程将执行 `loadImage` 函数。要创建一个新的协程，我们可以使用称为**协程构建器**的函数之一，例如
    `async` 或 `launch`：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `async` function returns an instance of `Deferred`. This class encapsulates
    a task that will return the result in the future. A `caller` function suspends
    when it invokes the `await` function of an instance of the `Deferred` class. This
    means that a thread that has a call stack with this function is not blocked, but
    is just suspended. The following snippet shows how this may look:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 函数返回一个 `Deferred` 类型的实例。这个类封装了一个将在未来返回结果的任务。当调用 `Deferred` 类实例的 `await`
    函数时，`caller` 函数会暂停。这意味着具有此函数调用栈的线程不会被阻塞，只是被挂起。以下代码片段显示了这可能看起来像什么：'
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: When we call the `await` function, we suspend invoking the current function.
    In addition, the `showImages` function will be called when all of the subtasks
    return the result.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用 `await` 函数时，我们挂起当前函数的调用。此外，当所有子任务返回结果时，将调用 `showImages` 函数。
- en: 'The following diagram shows how these functions can be executed:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这些函数的执行方式：
- en: '![](img/e1ced344-a7f6-459e-8c71-1b78d8e748a0.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e1ced344-a7f6-459e-8c71-1b78d8e748a0.png)'
- en: This diagram shows that three tasks can be executed almost in parallel, depending
    on whether the distribution of the load between cores and the `showImages` function
    is invoked when all three of the images are loaded.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 此图显示，根据核心之间的负载分配以及是否在所有三张图片都加载完毕时调用 `showImages` 函数，三个任务可以几乎并行执行。
- en: Call stacks
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用栈
- en: Each coroutine and thread has its own call stack. This means that a coroutine
    or a thread is created along with its call stack. A **call stack** contains something
    like blocks for each function that is invoked using a context of this thread or
    coroutine. This block represents a memory space that contains metadata, primitive
    local variables, and local references to objects in the heap. You can consider
    a call stack a part of the memory that is allocated for a thread or coroutine.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 每个协程和线程都有自己的调用栈。这意味着协程或线程创建时，会同时创建其调用栈。**调用栈**包含每个使用此线程或协程的上下文调用的函数的类似块。这个块代表一个包含元数据、原始局部变量和堆中对象的局部引用的内存空间。您可以将调用栈视为为线程或协程分配的内存的一部分。
- en: 'The following diagram shows how a **Call stack** looks when a thread or coroutine
    is created:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了线程或协程创建时**调用栈**的外观：
- en: '![](img/773c3374-c203-4743-b6ec-0c93eae00e7d.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/773c3374-c203-4743-b6ec-0c93eae00e7d.png)'
- en: 'If the `main()` function invokes another function, a new block is added to
    the call stack. This looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `main()` 函数调用另一个函数，则会在调用栈中添加一个新的块。这看起来如下：
- en: '![](img/69a8993c-a7d7-4d62-a1ff-f1c0c4f4b654.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/69a8993c-a7d7-4d62-a1ff-f1c0c4f4b654.png)'
- en: When the `loadImage` function returns a value to the `main` function, the block
    of the `loadImage` function is removed from the stack.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `loadImage` 函数向 `main` 函数返回一个值时，`loadImage` 函数的块将从栈中移除。
- en: Coroutine testing
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程测试
- en: 'The `runBlocking` coroutine builder can be used for testing. This creates a
    coroutine that uses a current thread. The test within the JUnit framework may
    look as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`runBlocking` 协程构建器可用于测试。它创建一个使用当前线程的协程。JUnit 框架中的测试可能如下所示：'
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This snippet loads an image using the `async` coroutine builder, and checks
    that the `image` is not null. The source code of the `runBlocking` function looks
    as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码片段使用 `async` 协程构建器加载图像，并检查 `image` 是否不为空。`runBlocking` 函数的源代码如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, the `runBlocking` coroutine builder uses the `currentThread`
    function to obtain an instance of the `Thread` class. When you run this test,
    you will see the following window:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`runBlocking` 协程构建器使用 `currentThread` 函数来获取 `Thread` 类的实例。当您运行此测试时，您将看到以下窗口：
- en: '![](img/5d9cb3cd-6dd4-4904-a018-691dcfe118e8.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d9cb3cd-6dd4-4904-a018-691dcfe118e8.png)'
- en: This window shows that the test has passed successfully.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口显示测试已成功通过。
- en: Coroutine scope
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 协程作用域
- en: With the release of version 0.26.0 of coroutines, a new, important feature was
    introduced—coroutine scope. All of the coroutine builders from the `coroutines-core`
    library are extension functions of the `CoroutineScope` interface.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在协程版本 0.26.0 的发布中，引入了一个新的、重要的功能——协程作用域。`coroutines-core` 库中的所有协程构建器都是 `CoroutineScope`
    接口的扩展函数。
- en: 'The `CoroutineScope` interface looks as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineScope` 接口如下所示：'
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We need the coroutine scope to provide a proper cancellation mechanism for the
    coroutines that we launch in our application. Modern frameworks, such as Android
    SDK or React Native, are built in such a way that all components, and the application
    itself, have a life cycle. In Android SDK, this can be an activity or a fragment,
    and in React Native, it can be a component.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要协程作用域为我们启动的应用程序中的协程提供适当的取消机制。现代框架，如 Android SDK 或 React Native，都是这样构建的，即所有组件以及应用程序本身都有生命周期。在
    Android SDK 中，这可以是活动或片段，在 React Native 中，这可以是组件。
- en: 'The coroutine scope represents a scope of an object that has a life cycle,
    such as an activity or a component. The `coroutines-core` library provides a scope
    for an entire application, and we can use it if we want to launch a coroutine
    that works as long as an application runs. The scope of the entire application
    is represented by the `GlobalScope` object, and looks as follows:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 协程作用域代表一个具有生命周期的对象的作用域，例如活动或组件。`coroutines-core` 库为整个应用程序提供了一个作用域，如果我们想启动一个与应用程序运行时间一样长的协程，我们可以使用它。整个应用程序的作用域由
    `GlobalScope` 对象表示，如下所示：
- en: '[PRE13]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Let''s create a new activity with its own coroutine scope. The easiest way
    to do this is to call the context menu of a package and choose the New section,
    which looks as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的活动，并为其创建一个自己的协程作用域。最简单的方法是调用包的上下文菜单并选择“新建”部分，如下所示：
- en: '![](img/5d113bb9-4172-43f7-bfcb-4d51ded36812.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5d113bb9-4172-43f7-bfcb-4d51ded36812.png)'
- en: 'Then, choose the Empty Activity option in the Activity subsection, as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在“活动”子部分中选择“空活动”选项，如下所示：
- en: '![](img/ecbe43be-f3ac-4252-9288-2ffb8221f3f1.png)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ecbe43be-f3ac-4252-9288-2ffb8221f3f1.png)'
- en: 'Android Studio will open the Configure Activity window, where you can change
    a configuration of Activity and press the Finish button:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Android Studio 将打开“配置活动”窗口，您可以在其中更改活动配置并按下“完成”按钮：
- en: '![](img/b2b48a4f-65d3-424e-9985-5b29100b93db.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2b48a4f-65d3-424e-9985-5b29100b93db.png)'
- en: 'A newly created `XKCDActivity` class will look as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的 `XKCDActivity` 类将如下所示：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If we want to launch a life cycle aware coroutine from this class, we should
    implement the `CoroutineScope` interface, as follows:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从这个类中启动一个生命周期感知的协程，我们应该实现 `CoroutineScope` 接口，如下所示：
- en: '[PRE15]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `CoroutineScope` interface looks as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`CoroutineScope` 接口如下所示：'
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `XKCDActivity` class implements the `CoroutineScope` interface and overrides
    the `coroutineContext` property. The overridden `coroutineContext` property contains
    a getter that returns `Dispatchers.Main`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`XKCDActivity` 类实现了 `CoroutineScope` 接口并重写了 `coroutineContext` 属性。重写的 `coroutineContext`
    属性包含一个返回 `Dispatchers.Main` 的获取器。'
- en: 'The `Dispatchers` is an object from the `coroutines-core` library, which contains
    the following dispatchers:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dispatchers` 是来自 `coroutines-core` 库的对象，其中包含以下调度器：'
- en: '`Default` is used by all standard coroutine builders, such as `launch` or `async`'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Default` 被所有标准协程构建器使用，例如 `launch` 或 `async`'
- en: '`Main` is used to run a coroutine on the main thread'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Main` 用于在主线程上运行协程'
- en: '`Unconfident` invokes a coroutine immediately, on the first available thread'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Unconfident` 立即在一个可用的线程上调用协程'
- en: '`IO` is used to run coroutines that perform input/output operations'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IO` 用于运行执行输入/输出操作的协程'
- en: Since a getter of the overridden `coroutineContext` property returns the `Main`
    dispatcher, all coroutine builders from this class will launch coroutines that
    work on the main thread.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重写的 `coroutineContext` 属性的获取器返回 `Main` 调度器，因此从这个类中所有协程构建器启动的协程都将运行在主线程上。
- en: 'The `XKCDActivity` has its own coroutine scope, but it is not life cycle aware.
    This means that a coroutine launched in a scope of this activity will not be destroyed
    if the activity is destroyed. We can fix this in the following way:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`XKCDActivity` 有自己的协程作用域，但它不是生命周期感知的。这意味着如果在活动的作用域中启动了一个协程，当活动被销毁时，该协程不会被销毁。我们可以通过以下方式修复这个问题：'
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `lifecycleAwareJob` will be used as a parent for all coroutines, and will
    cancel all child coroutines when an activity is destroyed. The following example
    code shows how to use this approach:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`lifecycleAwareJob`将被用作所有协程的父级，并在活动被销毁时取消所有子协程。以下示例代码显示了如何使用这种方法：'
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The launch coroutine builder creates a coroutine that works on the main thread,
    and the async coroutine builder creates a coroutine that works on the input/output
    thread. When the `image` is ready, it will be shown on the main thread of the
    application. If we press the back button, the coroutines will be destroyed, along
    with `XKCDActivity`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 协程启动构建器创建一个在主线程上工作的协程，而异步协程构建器创建一个在输入/输出线程上工作的协程。当`image`准备好时，它将在应用程序的主线程上显示。如果我们按下返回按钮，协程将被销毁，包括`XKCDActivity`。
- en: Channels
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通道
- en: The `async` function returns an instance of the `Deferred` class that allows
    us to compute a single value. If we need to transfer a sequence of values between
    coroutines, we can use channels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`async`函数返回一个`Deferred`类的实例，允许我们计算单个值。如果我们需要在协程之间传输一系列值，我们可以使用通道。'
- en: 'A channel is an interface that looks as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 通道是一个如下所示的接口：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `SendChannel` interface looks as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendChannel`接口如下所示：'
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `SendChannel` interface contains the `send` method that takes a parameter
    and adds it to this channel. The `isFull` property is `true` if this channel already
    contains a value. In this case, the `send` function suspends the caller until
    the contained value is not consumed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SendChannel`接口包含一个接受参数并将其添加到该通道的`send`方法。如果此通道已经包含一个值，则`isFull`属性为`true`。在这种情况下，`send`函数会暂停调用者，直到包含的值被消费。'
- en: A channel can be closed by invoking the `close` method. In this case, the `isClosedForSend`
    property is `true`, and the `send` method throws an exception.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一个通道可以通过调用`close`方法来关闭。在这种情况下，`isClosedForSend`属性为`true`，而`send`方法会抛出一个异常。
- en: 'While the `SendChannel` interface allows us to put a value into a channel,
    the `ReceiveChannel` interface allows us to get the value from the channel. The
    `ReceiveChannel` interface looks as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`SendChannel`接口允许我们将一个值放入通道中，但`ReceiveChannel`接口允许我们从通道中获取值。`ReceiveChannel`接口如下所示：
- en: '[PRE21]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `receiveOrNull()` method returns and removes an element from this channel,
    or returns null if the `isClosedForReceive` property is `true`. The `ReceiveChannel`
    contains the `iterator` method, and can be used in the `for` loop.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveOrNull()`方法从该通道返回并移除一个元素，或者如果`isClosedForReceive`属性为`true`，则返回null。`ReceiveChannel`包含`iterator`方法，可以在`for`循环中使用。'
- en: 'Let''s look at the following example code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例代码：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the preceding example, we sent two values by a channel and received those
    values. We also used the `delay` function to show that an operation takes some
    time.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们通过通道发送了两个值并接收了这些值。我们还使用了`delay`函数来显示操作需要一些时间。
- en: 'The output looks as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This output shows that the `send` function suspends a coroutine until a value
    is consumed.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示`send`函数会暂停协程，直到值被消费。
- en: 'We can use the `for` loop to receive values from a channel, as follows:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用`for`循环从通道接收值，如下所示：
- en: '[PRE24]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output looks as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE25]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The producer function
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成函数
- en: 'The `producer` function is called a **channel builder**, and it returns an
    instance of the `ReceiveChannel` class. This function looks as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`producer`函数被称为**通道构建器**，它返回一个`ReceiveChannel`类的实例。此函数如下所示：'
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'As you can see in the preceding snippet, the `produce` function contains a
    receiver parameter of the `ProducerScope` type. The `ProducerScope` interface
    looks as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的代码片段所示，`produce`函数包含一个`ProducerScope`类型的接收参数。`ProducerScope`接口如下所示：
- en: '[PRE27]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, the `ProducerScope` interface extends the `SendChannel` interface.
    This means that we can use the `send` method inside a lambda that we pass to the
    `producer` function.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`ProducerScope`接口扩展了`SendChannel`接口。这意味着我们可以在传递给`producer`函数的lambda表达式中使用`send`方法。
- en: 'An example of using the  `producer` function may look as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`producer`函数的一个示例可能如下所示：
- en: '[PRE28]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We can use the `numbersProduce` function in the following way:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样使用`numbersProduce`函数：
- en: '[PRE29]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The actor function
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 演员（actor）函数
- en: 'The `actor` function contains a receiver parameter of the `ActorScope` type.
    The source code of the `actor` function looks as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`actor`函数包含一个`ActorScope`类型的接收参数。`actor`函数的源代码如下所示：'
- en: '[PRE30]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The `ActorScope` interface looks similar to the `ProducerScope` interface,
    but implements the `ReceiveChannel` interface:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActorScope`接口看起来与`ProducerScope`接口相似，但它实现了`ReceiveChannel`接口：'
- en: '[PRE31]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'As you probably know, it is not a good idea to access mutable data from different
    coroutines. To deal with this, we can use channels and the `actor` function, in
    the following way:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，从不同的协程中访问可变数据并不是一个好主意。为了处理这个问题，我们可以使用通道和`actor`函数，如下所示：
- en: '[PRE32]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The preceding snippet contains a mutable variable named `counter`. We change
    the value of the `counter` variable when a channel receives a new value. Since
    a channel suspends the caller until a consumer finishes processing the current
    value, we can be sure that the `counter` variable will be modified in the right
    way.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段包含一个名为`counter`的可变变量。我们在通道接收到新值时更改`counter`变量的值。由于通道会挂起调用者直到消费者完成当前值的处理，我们可以确保`counter`变量将以正确的方式被修改。
- en: 'The `numbersCounter` function can be used as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 可以这样使用`numbersCounter`函数：
- en: '[PRE33]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The preceding snippet launches ten coroutines that send a value to an actor
    in parallel.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段启动了十个协程，它们并行地向一个actor发送一个值。
- en: 'The output looks as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下所示：
- en: '[PRE34]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The output shows that the `counter` variable is modified in the right way.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示`counter`变量被正确修改。
- en: Sequential operations
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 顺序操作
- en: One of the most important benefits of the coroutines approach is a guarantee
    that functions are invoked in the same order in which they are written. The order
    of the operations is a very important nuance when we execute concurrent code in
    a multithreaded environment.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 协程方法最重要的好处之一是保证函数的调用顺序与它们编写的顺序相同。在多线程环境中执行并发代码时，操作顺序是一个非常重要的细节。
- en: 'Let''s imagine that we have to load a user''s details, using the following
    function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们必须使用以下函数来加载用户的详细信息：
- en: '[PRE35]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The `loadUserDetails` function invokes the `delay` function from the `coroutines-core`
    library and returns an instance of the `User` class. The `delay` function suspends
    the invocation of the current coroutine. When a user is ready, we have to pass
    a value of the `avatar` property to the `loadImage` function:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadUserDetails`函数从`coroutines-core`库调用`delay`函数，并返回`User`类的一个实例。`delay`函数挂起当前协程的调用。当用户准备好时，我们必须将`avatar`属性的值传递给`loadImage`函数：'
- en: '[PRE36]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `loadImage` function also invokes the `delay` function, and returns an instance
    of the `Image` class. We should then pass the received instance of the `Image`
    class to the `showImage` function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadImage`函数还调用了`delay`函数，并返回`Image`类的一个实例。然后我们应该将接收到的`Image`类实例传递给`showImage`函数。'
- en: 'The following code shows how to execute these functions sequentially, using
    coroutines:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了如何使用协程依次执行这些函数：
- en: '[PRE37]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The preceding snippet invokes all three functions that use different coroutines,
    sequentially. The following diagram shows a sequence of functions invoking:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段依次调用了使用不同协程的三个函数。以下图显示了函数调用的顺序：
- en: '![](img/59bdd6ea-201a-4037-b020-8cd4eb7b0f1c.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![](img/59bdd6ea-201a-4037-b020-8cd4eb7b0f1c.png)'
- en: Callback hell
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调地狱
- en: One of the main reasons that you should use coroutines is to avoid callback
    hell.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该使用协程的主要原因之一是避免回调地狱。
- en: 'This section will cover the following topics:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将涵盖以下主题：
- en: What is a callback?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是回调？
- en: Wrapping callbacks
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包装回调
- en: What is a callback?
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是回调？
- en: A **callback** is a pattern that is used to retrieve the results of an asynchronous
    task. This approach assumes that we pass a reference to a function that should
    be invoked when an asynchronous operation is done.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**回调**是一种用于检索异步任务结果的模式。这种方法假设我们传递一个函数的引用，当异步操作完成时应该调用该函数。'
- en: By *synchronous operations*, we mean that the tasks are executed one after another.
    The asynchronous approach assumes that several tasks can be performed in parallel.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们所说的**同步操作**是指任务一个接一个地执行。异步方法假设可以并行执行多个任务。
- en: 'The `loadImage` function in the following example code uses a callback to return
    the result:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例代码中，`loadImage`函数使用回调来返回结果：
- en: '[PRE38]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The preceding code snippet shows the simplest example of how to create an asynchronous
    function that returns the results using the callback. In our case, the callback
    is a lambda that takes an instance of the `Image` class and returns `Unit`. The
    following diagram shows how this sequence works:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何创建一个异步函数的最简单示例，该函数使用回调返回结果。在我们的情况下，回调是一个接受`Image`类实例并返回`Unit`的lambda。以下图显示了这一序列是如何工作的：
- en: '![](img/acb5e395-a5e2-4e4d-9d5b-8870aa6d5e9b.png)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/acb5e395-a5e2-4e4d-9d5b-8870aa6d5e9b.png)'
- en: 'This function can be used as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数可以这样使用：
- en: '[PRE39]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The preceding snippet shows that it is easy to use a callback to deal with asynchronous
    code. We just implement and pass a lambda that is invoked when an image is ready.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段显示，使用回调处理异步代码非常简单。我们只需实现并传递一个在图像准备就绪时被调用的lambda。
- en: 'The following diagram shows how to implement this approach:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了如何实现这种方法：
- en: '![](img/038b56be-f66c-423a-b5e8-b1382b5b4889.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/038b56be-f66c-423a-b5e8-b1382b5b4889.png)'
- en: 'Let''s imagine that we are requesting a list of users from the server. After
    that, we send another request to get detailed information about a user, and then,
    we load an avatar. In code, this may look as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设我们正在从服务器请求用户列表。之后，我们发送另一个请求以获取关于用户的详细信息，然后加载一个头像。在代码中，这可能看起来如下：
- en: '[PRE40]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `loadListOfFriends` function takes a lambda that takes a list of instances
    of the `ShortUser` class, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadListOfFriends`函数接受一个lambda，该lambda接受`ShortUser`类实例的列表，如下所示：'
- en: '[PRE41]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `loadUserDetails` function takes a lambda and an identifier of a user,
    as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadUserDetails`函数接受一个lambda和一个用户的标识符，如下所示：'
- en: '[PRE42]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `loadImage` function takes a path to the avatar and lambda. The following
    example code demonstrates the most common problem that occurs when we use an approach
    with callbacks. We encounter the problem of code complexity and readability when
    concurrent tasks have to pass data to each other:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadImage`函数接受头像的路径和lambda。以下示例代码演示了当我们使用带有回调的方法时最常见的常见问题。当并发任务需要相互传递数据时，我们遇到了代码复杂性和可读性的问题：'
- en: '[PRE43]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The preceding snippet demonstrates what callback hell is. We have a lot of nested
    functions, and it is hard to maintain this code.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段演示了回调地狱。我们有很多嵌套的函数，维护这样的代码很困难。
- en: Thread pools
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程池
- en: The creation of a new thread is a complex operation that takes up a lot of resources.
    In the *Call stacks* section, we covered how memory is allocated for a new thread.
    When the lower block of a function is removed from a stack, the thread is destroyed.
    To avoid constantly creating new threads, we can use thread pools. There is no
    logic in creating a new thread for invoking each short-term operation, because
    this operation and switching the program flow to a created context can take more
    time than executing the task itself. The thread-pool pattern assumes a class that
    contains a set of threads that are waiting for a new task, and a queue that holds
    the tasks.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 创建新线程是一个复杂的操作，需要占用大量资源。在*调用栈*部分，我们介绍了为新线程分配内存的方法。当函数的较低部分从栈中移除时，线程将被销毁。为了避免不断创建新线程，我们可以使用线程池。为每个短期操作创建新线程没有逻辑，因为这种操作和将程序流程切换到创建的上下文可能比执行任务本身花费更多时间。线程池模式假设一个包含一组等待新任务的线程的类，以及一个包含任务的队列。
- en: 'The following diagram shows how this works:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图显示了这是如何工作的：
- en: '![](img/db9a7a3b-2431-4f93-800b-8fa72ef48a5c.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/db9a7a3b-2431-4f93-800b-8fa72ef48a5c.png)'
- en: The preceding diagram shows that a pool contains a queue that holds tasks submitted
    by producers. The threads from the pool take tasks from the queue and execute
    them.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示，池包含一个队列，该队列保存由生产者提交的任务。池中的线程从队列中取出任务并执行它们。
- en: 'Coroutines use thread pools under the hood. The `java.util.concurrent` package
    provides the functionality to create your own thread pools. The `Executers` class
    contains a lot of static factory functions to create a pool, as shown in the following
    screenshot:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 协程在底层使用线程池。`java.util.concurrent`包提供了创建自己的线程池的功能。`Executors`类包含许多静态工厂函数来创建一个池，如下面的截图所示：
- en: '![](img/effab500-87c7-40bb-a20d-81aadad70026.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/effab500-87c7-40bb-a20d-81aadad70026.png)'
- en: 'The following example code demonstrates how to create and use a single-threaded
    executor:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码演示了如何创建和使用单线程执行器：
- en: '[PRE44]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In the preceding snippet, we instantiated the `executor` variable and used the
    `submit` method to add a task to the queue.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们实例化了`executor`变量，并使用`submit`方法将任务添加到队列中。
- en: Summary
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at concurrency and the problems that can arise in
    a multithreaded environment. We introduced and looked at the most common examples
    of coroutine usage. We also familiarized ourselves with patterns, such as thread
    pools and callbacks, and how to use them. Furthermore, we covered synchronous
    and asynchronous programming, and the problems related to these topics.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了并发以及多线程环境中可能出现的问题。我们介绍了协程的常见用法示例。我们还熟悉了诸如线程池和回调等模式，以及如何使用它们。此外，我们还涵盖了同步和异步编程，以及与这些主题相关的问题。
- en: In the next chapter, we will look at an overview of reactive programming, which
    is useful when we want to process asynchronous actions.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将概述响应式编程，这在我们需要处理异步操作时非常有用。
- en: Questions
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is a call stack?
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是调用栈？
- en: What is a thread pool?
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是线程池？
- en: What is a callback?
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是回调？
- en: Why are coroutines called lightweight threads?
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么协程被称为轻量级线程？
- en: Further reading
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: '*Mastering High Performance with Kotlin* ([https://www.packtpub.com/application-development/mastering-high-performance-kotlin](https://www.packtpub.com/application-development/mastering-high-performance-kotlin))
    by Igor Kucherenko, published by Packt Publishing.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 由Igor Kucherenko所著，Packt Publishing出版的《*掌握Kotlin高性能编程*》([https://www.packtpub.com/application-development/mastering-high-performance-kotlin](https://www.packtpub.com/application-development/mastering-high-performance-kotlin))。
