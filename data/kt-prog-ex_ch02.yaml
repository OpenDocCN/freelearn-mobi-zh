- en: Building an Android Application – Tetris
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建Android应用程序 – 俄罗斯方块
- en: In the previous chapter, we took a concise look at crucial topics pertaining
    to the core Kotlin language. These topics took us through the fundamentals of
    Kotlin as well as the powerful object-oriented programming approach to software
    development it puts at our disposal. In this chapter, we will put the knowledge
    we gained from the previous chapter to good use by developing an Android application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们简要地回顾了与Kotlin核心语言相关的关键主题。这些主题带我们了解了Kotlin的基础知识，以及它为我们提供的强大的面向对象编程方法。在本章中，我们将通过开发一个Android应用程序来将上一章中获得的知识付诸实践。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: Android application components
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android应用程序组件
- en: Views
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图
- en: View groups
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 视图组
- en: Layout constraints
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局约束
- en: Implementing layouts with XML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用XML实现布局
- en: String and dimension resources
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 字符串和维度资源
- en: Handling input events
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理输入事件
- en: We will learn these topics through a hands-on approach by implementing the layouts
    and components of a classic game, Tetris, in the form of an Android application.
    As we are developing the game in the form of an Android application, before proceeding
    further, it is imperative that we do a brief overview of the Android operating
    system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过实际操作的方法，通过实现一个经典游戏——俄罗斯方块——的布局和组件，以Android应用程序的形式来学习这些主题。由于我们是以Android应用程序的形式开发游戏的，在继续之前，简要概述Android操作系统是至关重要的。
- en: Android – an overview
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android – 概述
- en: Android is a Linux-based mobile operating system developed and maintained by
    Google and created primarily to power smart mobile devices such as mobile phones
    and tablets. The primary interface to interact with the Android operating system
    is **Graphic User Interface** (**GUI**)-based. Users of devices powered by Android
    manipulate and interact with the operating system environment primarily via a
    visual touch-based interface by performing gestures such as taps and swipes on
    the display.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Android是由Google开发和维护的基于Linux的移动操作系统，主要用于为智能手机和平板电脑等智能移动设备提供动力。与Android操作系统交互的主要界面是基于**图形用户界面**（**GUI**）。由Android驱动的设备用户主要通过在显示屏上执行触摸操作，如点击和滑动，来操作和与操作系统环境进行交互。
- en: Software can be installed on the Android OS in the form of apps. An app is an
    application that runs within an environment and performs one or more tasks for
    the achievement of a goal or a collection of goals. The ability to install applications
    on mobile devices presented a huge opportunity to both users and application developers.
    Users take advantage of the features provided by apps to achieve day-to-day goals
    and developers take advantage of the demand for software applications by developing
    apps that meet user needs and perhaps make a profit.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 软件可以以应用的形式安装在Android操作系统上。应用是在环境中运行的应用程序，它执行一个或多个任务以实现目标或一系列目标。在移动设备上安装应用程序的能力为用户和应用程序开发者提供了巨大的机会。用户利用应用提供的功能来实现日常目标，开发者则利用对软件应用程序的需求，开发满足用户需求的应用程序，也许还能盈利。
- en: To developers, Android provides a vast array of tools and utilities for the
    development of high-performance applications. These applications can target different
    markets such as recreation, enterprise, and e-commerce. Applications can also
    come in the form of games.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 对于开发者来说，Android提供了一系列工具和实用程序，用于开发高性能应用程序。这些应用程序可以针对不同的市场，如娱乐、企业和电子商务。应用程序也可以以游戏的形式出现。
- en: Over the course of this chapter, we will explore a number of these tools and
    utilities, which are provided by the Android application framework, in more detail.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将更详细地探讨Android应用程序框架提供的一些工具和实用程序。
- en: Application components
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序组件
- en: 'The Android application framework provides us with a number of components we
    can utilize to build a user interface for the *Tetris* application. A component
    in Android is a reusable program template or object that can be used to define
    aspects of an application. Some important components provided by the Android application
    framework are:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序框架为我们提供了一系列组件，我们可以利用这些组件为*俄罗斯方块*应用程序构建用户界面。Android中的组件是一个可重用的程序模板或对象，可以用来定义应用程序的各个方面。Android应用程序框架提供的一些重要组件包括：
- en: Activities
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Intents
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图
- en: Intent filters
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 意图过滤器
- en: Fragments
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碎片
- en: Services
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务
- en: Loaders
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载器
- en: Content providers
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内容提供者
- en: Activities
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 活动
- en: An activity is an Android component that is central to the implementation of
    application flow and component-to-component interaction. Activities are implemented
    in the form of classes. An instance of an activity is used by the Android system
    for code initiation.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 活动是Android组件，对于应用程序流程和组件间交互的实现至关重要。活动以类的形式实现。活动实例由Android系统用于代码启动。
- en: An activity is important in the creation of applications' user interfaces. It
    provides a window upon which user interface elements can be drawn. Simply put,
    application screens are created with the use of activities in mind.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 活动在创建应用程序用户界面方面非常重要。它提供了一个可以绘制用户界面元素的窗口。简单来说，应用程序屏幕是通过考虑使用活动来创建的。
- en: Intents
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图
- en: An intent facilitates inter-activity communication. Intents can be considered
    messengers within an Android application. They are messaging objects that are
    used to request actions from application components. Intents can be used for actions,
    such as requesting the start of an activity and delivering broadcasts, within
    the Android system environment.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 意图促进了交互之间的通信。意图可以被视为Android应用程序中的信使。它们是用于从应用程序组件请求操作的消息对象。意图可以用于Android系统环境中的操作，例如请求启动活动或发送广播。
- en: 'There are two types of intents. These are:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种类型的意图。这些是：
- en: Implicit intents
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐式意图
- en: Explicit intents
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显式意图
- en: '**Implicit intents**: These are messenger objects that do not specifically
    identify an application component to perform an action, but specify an action
    to be performed and allow a component that may exist in another application to
    perform the action. The components that can handle an action requested implicitly
    are identified by the Android system.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**隐式意图**：这些是信使对象，它们不特别标识应用程序组件以执行操作，但指定要执行的操作，并允许可能存在于另一个应用程序中的组件执行该操作。可以处理隐式请求的操作的组件由Android系统识别。'
- en: '**Explicit intents**: These intents specify explicitly the application component
    that should perform an action. These can be used to perform actions, such as starting
    an activity, within your application:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**显式意图**：这些意图明确指定了应执行操作的应用程序组件。这些可以在您的应用程序中用于执行操作，例如启动活动：'
- en: '![](img/6f0e21b8-c0d5-40f4-967a-dbb1591fcf97.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6f0e21b8-c0d5-40f4-967a-dbb1591fcf97.jpg)'
- en: Intent filters
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 意图过滤器
- en: An intent filter is a declaration in the application manifest file that specifies
    the type of intent that a component would like to receive. This is useful in a
    number of cases, such as a scenario in which you want an activity in your application
    to handle a specific action requested by components in another application. For
    this case, an intent filter can be declared in the application manifest for the
    activity you want to handle the external request. If you do not want an activity
    to handle implicit intents, you simply do not declare an intent filter for it.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 意图过滤器是应用程序清单文件中的一个声明，它指定了组件希望接收的意图类型。这在许多情况下都很有用，例如，在您希望应用程序中的活动处理另一个应用程序中的组件请求的特定操作的场景中。为此，可以在希望处理外部请求的活动清单中声明意图过滤器。如果您不希望活动处理隐式意图，您只需不为其声明意图过滤器即可。
- en: Fragments
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段
- en: A fragment is an application component that represents a part of a user interface
    that exists within an activity. Similar to an activity, a fragment possesses a
    layout that can be modified and is drawn on the activity window.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是一个应用程序组件，它代表存在于活动中的用户界面的一部分。类似于活动，片段具有可以修改的布局，并且绘制在活动窗口上。
- en: Services
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 服务
- en: Unlike most other components, a service does not provide a user interface. Services
    are used to perform background processes in an application. A service does not
    need the application that created it to be in the foreground to run.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 与大多数其他组件不同，服务不提供用户界面。服务用于在应用程序中执行后台进程。服务不需要创建它的应用程序处于前台即可运行。
- en: Loaders
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载器
- en: A loader is a component that enables the loading of data from a data source,
    such as a content provider, for later display in an activity or fragment.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 加载器是一个组件，它使数据从数据源（如内容提供者）加载成为可能，以便稍后在活动或片段中显示。
- en: Content providers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内容提供者
- en: 'These components help an application control access to data resources stored
    either within the application or within another app. In addition, a content provider
    facilitates the sharing of data with another application via an exposed application
    programming interface:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件帮助应用程序控制对存储在应用程序内部或另一个应用程序中的数据资源的访问。此外，内容提供者通过公开的应用程序编程接口促进与其他应用程序的数据共享：
- en: '![](img/c0d35c91-ba13-4e6f-bb8e-258a71de14b5.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0d35c91-ba13-4e6f-bb8e-258a71de14b5.jpg)'
- en: Understanding Tetris
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解俄罗斯方块
- en: Before attempting to develop the *Tetris* game as an Android application, we
    need to understand the game, its rules, and its constraints.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试将俄罗斯方块游戏作为Android应用程序开发之前，我们需要了解这个游戏、它的规则和限制。
- en: 'Tetris is a matching puzzle video game that makes use of tiles. The name *Tetris* is
    derived from the words tetra – the Greek numerical prefix for four – and tennis.
    The tiles in Tetris combine to make up tetrominoes which are geometric shapes
    composed of four squares connected orthogonally:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯方块是一款使用拼图块的匹配拼图视频游戏。"俄罗斯方块"这个名字来源于单词tetra——希腊数字前缀四——和网球。俄罗斯方块中的拼图块组合成四连体，即由四个正方形组成的几何形状：
- en: '![](img/ab15a72f-e060-49d0-b916-5c009ee66f94.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ab15a72f-e060-49d0-b916-5c009ee66f94.jpg)'
- en: Tetris tetrominoes
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 俄罗斯方块四连体块
- en: In Tetris, a random sequence of tetrominoes fall down upon a playing field.
    These tetrominoes can be manipulated by the player. A number of motions can be
    performed on each tetromino piece. Pieces can be moved to the left, to the right,
    and rotated. In addition, the speed of descent of each piece can be sped up. The
    objective of the game is to create an uninterrupted horizontal line of ten cells
    with the descending pieces. When such a line is created, the line is cleared.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在俄罗斯方块中，一系列随机的四连体块会落在游戏场上。玩家可以操纵这些四连体块。每个四连体块可以执行多种动作。块可以左右移动，旋转。此外，每个块的下降速度可以加快。游戏的目标是用下降的块创建一个不间断的十单元格水平线。当创建这样的线时，该线就会被清除。
- en: Now that we have an understanding of how Tetris works, let's get into the specifics
    in order to build the user interface of the application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了俄罗斯方块的工作原理，让我们具体了解一下，以便构建应用程序的用户界面。
- en: Creating the user interface
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户界面
- en: 'As previously mentioned, the user interface is the means by which the user
    of an application interacts with the app. It cannot be overstated how important
    the user interface of an application is. Before embarking on the process of actually
    coding a user interface, it may be helpful to make a graphical representation
    of the UI to be implemented. This can be done with different tools, such as Photoshop,
    but for this case, a simple sketch is sufficient:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，用户界面是应用程序用户与应用程序交互的方式。应用程序的用户界面的重要性不容忽视。在实际编码用户界面之前，制作要实现的UI的图形表示可能是有帮助的。这可以用不同的工具完成，例如Photoshop，但在这个案例中，一个简单的草图就足够了：
- en: '![](img/616a3515-92ed-4bb0-9961-2dcf96290bed.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/616a3515-92ed-4bb0-9961-2dcf96290bed.png)'
- en: 'From the preceding sketch, we can see that we will need two distinct screens
    in this application: the landing screen and the game screen where the actual gameplay
    will happen. These two screens will require two separate activities. We''ll call
    these two activities `MainActivity` and `GameActivity`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的草图可以看出，在这个应用程序中，我们需要两个不同的屏幕：一个是着陆屏幕，另一个是游戏屏幕，实际的游戏将在这个屏幕上进行。这两个屏幕将需要两个独立的活动。我们将这两个活动称为`MainActivity`和`GameActivity`。
- en: '`MainActivity` will serve as the entry point of our application. It will contain
    the user interface and all logic pertaining to our landing screen. As we can observe
    in our sketch, the UI of the landing screen contains the application title, a
    view that shows the user their current high score, and three buttons performing
    different actions. The **NEW GAME** button, as the name implies, will lead the
    user to the activity in which the gaming takes place. **RESET SCORE** will reset
    the score of the user to zero and **EXIT** will close the application.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainActivity`将作为我们应用程序的入口点。它将包含用户界面以及与我们的着陆屏幕相关的所有逻辑。正如我们可以在我们的草图中所观察到的，着陆屏幕的UI包含应用程序标题、一个显示用户当前最高分的视图，以及执行不同操作的三个按钮。正如其名所示，**新游戏**按钮将引导用户进入游戏活动。**重置分数**将用户的分数重置为零，**退出**将关闭应用程序。'
- en: '`GameActivity` will be the programmatic template of the game screen. In this
    activity, we will create the views and logical interactions between the user and
    the game. The UI of this activity contains an action bar with the title of the
    application displayed on it, two text views that display the current score of
    the user and their high score, and a layout element in which the Tetris gameplay
    will happen.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameActivity` 将是游戏界面的程序模板。在这个活动中，我们将创建视图以及用户和游戏之间的逻辑交互。这个活动的用户界面包含一个标题栏，上面显示了应用程序的标题，两个文本视图，用于显示用户的当前得分和他们的最高分，以及一个布局元素，Tetris
    游戏将在其中进行。'
- en: Implementing the layouts
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现布局
- en: Now that we know the activities that are needed in this application and have
    a rough idea of how we want our user interface to look when viewed by the user,
    we can get into the actual implementation of the user interface.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了在这个应用程序中需要哪些活动，并且对用户界面在用户查看时的外观有一个大致的想法，我们可以进入用户界面的实际实现。
- en: Create a new Android project in Android Studio and give it the name `Tetris
    no activity`. Once the IDE window opens, you will notice that the project structure
    is similar to the one in [Chapter 1](kt-prog-ex_ch01.html), *The Fundamentals*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的 Android 项目，并将其命名为 `Tetris no activity`。一旦 IDE 窗口打开，您将注意到项目结构类似于
    [第 1 章](kt-prog-ex_ch01.html)，*基础*。
- en: 'The first thing we need to do is add `MainActivity` to our project. We want
    `MainActivity` to be an empty activity. We can add `MainActivity` to our project
    by right-clicking on our source package and selecting New | Activity | Empty Activity:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将 `MainActivity` 添加到我们的项目中。我们希望 `MainActivity` 是一个空活动。我们可以通过在源包上右键单击并选择“新建
    | 活动 | 空活动”来将 `MainActivity` 添加到我们的项目中：
- en: '![](img/660f01bc-7f6d-41b1-92f6-ed430a78bdab.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/660f01bc-7f6d-41b1-92f6-ed430a78bdab.png)'
- en: Name the activity `MainActivity`, and ensure the Generate Layout File, Launcher
    Activity, and Backwards Compatibility (AppCompat) checkboxes are ticked.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将活动命名为 `MainActivity`，并确保勾选了“生成布局文件”、“启动器活动”和“向后兼容性（AppCompat）”复选框。
- en: 'Upon the addition of the activity to your project, navigate to its layout resource
    file. It should look similar to the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在将活动添加到您的项目后，导航到其布局资源文件。它应该看起来类似于以下代码：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Line one of the resource file specifies the XML version utilized in the file
    as well as the character encoding used. `utf-8` is used for character encoding
    in this file. **UTF** stands for **Unicode Transformation Format**. It is an encoding
    format that can be as compact as **American Standard Code for Information Interchange**
    (**ASCII**)—the most common character format for text files—and can contain any
    Unicode character. The next eight lines define a `ConstraintLayout` to be rendered
    in the UI of `MainActivity`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 资源文件的第一行指定了文件中使用的 XML 版本以及使用的字符编码。此文件中使用的字符编码为 `utf-8`。**UTF** 代表 **Unicode
    Transformation Format**。它是一种编码格式，可以与 **American Standard Code for Information
    Interchange**（**ASCII**）一样紧凑——这是最常见的文本文件字符格式——并且可以包含任何 Unicode 字符。接下来的八行定义了一个要在
    `MainActivity` 的用户界面中渲染的 `ConstraintLayout`。
- en: Let's consider the `ConstraintLayout` in a bit more detail before moving forward.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，让我们更详细地考虑一下 `ConstraintLayout`。
- en: ConstraintLayout
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ConstraintLayout
- en: A `ConstraintLayout` is a type of view group that allows the flexible positioning
    and resizing of application widgets. Various types of constraints can be used
    on a `ConstraintLayout`. Some examples are.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`ConstraintLayout` 是一种视图组，允许灵活地定位和调整应用程序小部件的大小。在 `ConstraintLayout` 上可以使用各种类型的约束。一些例子包括。'
- en: Margins
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 边距
- en: 'A margin is a space that exists between two layout elements. When a side margin
    is set on an element, it is applied to its corresponding layout constraints, if
    one is available, by adding the margin as a space between the target side and
    the source side (the side of the element adding the margin):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 边距是两个布局元素之间的空间。当在元素上设置侧边距时，如果可用，它将应用于其相应的布局约束，通过在目标侧和源侧（添加边距的元素的一侧）之间添加边距作为空间来实现：
- en: '![](img/327b1c36-3ba4-442c-94ad-e1636cf52590.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/327b1c36-3ba4-442c-94ad-e1636cf52590.jpg)'
- en: Chains
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 链
- en: 'Chains are constraints that provide group-like behavior in a single axis. The
    axis may be either horizontal or vertical:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 链是提供单轴类似组行为的约束。轴可以是水平或垂直：
- en: '![](img/9b6ac711-a5da-410c-8181-940451fe853e.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9b6ac711-a5da-410c-8181-940451fe853e.jpg)'
- en: A collection of elements is a chain if they are all connected bidirectionally.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一组元素都是双向连接的，则它们构成一个链。
- en: Dimension constraints
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尺寸约束
- en: 'These constraints concern the sizes of widgets placed in a layout. Dimension
    constraints can be set on widgets, and using a `ConstraintLayout`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这些约束涉及布局中放置的小部件的大小。可以在小部件上设置尺寸约束，并使用`ConstraintLayout`：
- en: '![](img/afb8e12b-2dee-4c96-9ad3-b8a9eba807e9.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/afb8e12b-2dee-4c96-9ad3-b8a9eba807e9.jpg)'
- en: A dimension constraint
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尺寸约束
- en: 'The dimensions of a widget can be specified by the use of `android:layout_width`
    and `android:layout_height`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的尺寸可以通过使用`android:layout_width`和`android:layout_height`来指定：
- en: '[PRE1]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In a number of cases, you may want a widget to have the same dimension as its
    parent view group. This can be done by assigning the `match_parent` value to the
    dimension attribute:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，你可能希望小部件与其父视图组的尺寸相同。这可以通过将`match_parent`值分配给尺寸属性来完成：
- en: '[PRE2]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Alternatively, if you want a widget''s dimensions not to be fixed but rather
    to wrap the elements contained within it, the `wrap_content` value should be assigned
    to the dimension attribute:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果你想让小部件的尺寸不是固定的，而是包裹其内部包含的元素，则应将`wrap_content`值分配给尺寸属性：
- en: '[PRE3]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that we have a better understanding of the `ConstraintLayout`, as well
    as widget constraints, let''s take another look at our `activity_main.xml` file:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对`ConstraintLayout`以及小部件约束有了更好的理解，让我们再次查看我们的`activity_main.xml`文件：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Looking at the `ConstraintLayout` element, we can immediately notice that its
    width and height dimensions have been set to `match_parent`. This means that the
    `ConstraintLayout` dimensions are set to match those of the current window. The
    attributes that have the `xmlns: prefix` are used to define XML namespaces. Values
    set for all XML namespace attributes are namespace URIs. **URI** is short for
    **Uniform Resource Identifier** and, as the name suggests, it identifies a resource
    required by the namespace.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 观察到`ConstraintLayout`元素，我们可以立即注意到其宽度和高度尺寸已被设置为`match_parent`。这意味着`ConstraintLayout`的尺寸设置为与当前窗口匹配。具有`xmlns:`前缀的属性用于定义XML命名空间。为所有XML命名空间属性设置的值是命名空间URI。**URI**是**Uniform
    Resource Identifier**的缩写，正如其名，它标识了命名空间所需资源。
- en: The `tools:context` attribute is typically set to the root element in an XML
    layout file and specifies the activity that the layout is associated with—in this
    case, `MainActivity`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`tools:context`属性通常设置在XML布局文件的根元素上，并指定与布局关联的活动——在这种情况下，`MainActivity`。'
- en: 'Now that we understand what''s going on in the `activity_main.xml` layout,
    let''s add some layout elements to it. From our sketch, we can see that all layout
    elements are placed in a vertical arrangement. We can do this with the use of
    a `LinearLayout`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经理解了`activity_main.xml`布局中的情况，让我们向其中添加一些布局元素。从我们的草图可以看出，所有布局元素都是垂直排列的。我们可以使用`LinearLayout`来实现这一点：
- en: '[PRE5]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As we want the `LinearLayout` to have the same dimensions as its parent, we
    set both `android:layout_width` and `android:layout_height` to `match_parent`.
    Next, we specify the edge constraints of the `LinearLayout` using the `app:layout_constraintBottom_toBottomOf`,
    `app:layout_constraintLeft_toLeftOf`, `app:layout_constraintRight_toRightOff`,
    and `app:layout_constraintTop_toTopOf` attributes.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望`LinearLayout`的尺寸与其父级相同，我们将`android:layout_width`和`android:layout_height`都设置为`match_parent`。接下来，我们使用`app:layout_constraintBottom_toBottomOf`、`app:layout_constraintLeft_toLeftOf`、`app:layout_constraintRight_toRightOff`和`app:layout_constraintTop_toTopOf`属性指定`LinearLayout`的边缘约束。
- en: '`app:layout_constraintBottom_toBottomOf`: Aligns the bottom edge of the element
    to the bottom of another'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app:layout_constraintBottom_toBottomOf`：将一个元素的底部边缘与另一个元素的底部对齐'
- en: '`app:layout_constraintLeft_toLeftOf`: Aligns the left edge of an element to
    the left of another'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app:layout_constraintLeft_toLeftOf`：将一个元素的左边缘与另一个元素的左边缘对齐'
- en: '`app:layout_constraintRight_toRightOf`: Aligns the right edge of an element
    to the right of another'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app:layout_constraintRight_toRightOf`：将一个元素的右边缘与另一个元素的右边缘对齐'
- en: '`app:layout_constraintTop_toTopOf`: Aligns the top of an element to the top
    of another.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app:layout_constraintTop_toTopOf`：将一个元素的顶部与另一个元素的顶部对齐。'
- en: In this case, all edges of the `LinearLayout` are aligned to the edge of its
    parent—the `ConstraintLayout`. `android:layout_marginVertical` adds a margin of
    `16dp` to the top and bottom of the element.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`LinearLayout`的所有边缘都与父级——`ConstraintLayout`的边缘对齐。`android:layout_marginVertical`为元素的顶部和底部添加了`16dp`的边距。
- en: Defining dimension resources
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义尺寸资源
- en: 'Typically in a layout file, we can have numerous elements that specify the
    same constraint values to attributes. Such values should be added to a dimensions
    resource file. Let''s go ahead and create a dimensions resource file now. In your
    application project view, navigate to res | values and create a new value resource
    file in the directory with the name `dimens`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 通常在布局文件中，我们可以有多个元素指定相同的约束值给属性。这些值应添加到维度资源文件中。现在让我们创建一个维度资源文件。在应用程序项目视图中，导航到res
    | values并在目录中创建一个名为`dimens`的新值资源文件：
- en: '![](img/d00b3027-dcc5-4e87-b5dc-7ed1e81add26.png)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d00b3027-dcc5-4e87-b5dc-7ed1e81add26.png)'
- en: 'Leave all other file attributes at their default values:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 将所有其他文件属性保留在默认值：
- en: '![](img/d65e90ef-cba6-421f-b705-80e468e39fb0.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d65e90ef-cba6-421f-b705-80e468e39fb0.png)'
- en: 'Open the file upon its creation. Its content should be similar to the following
    code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建文件时打开它。其内容应类似于以下代码：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The first line of `dimens.xml` declares the XML version and character encoding
    used within the file. The second line contains a `<resources>` resources tag.
    Our dimensions will be declared within this tag. Add a few dimension values, as
    demonstrated in the following code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`dimens.xml`的第一行声明了文件中使用的XML版本和字符编码。第二行包含一个`<resources>`资源标签。我们的维度将在这个标签内声明。添加一些维度值，如下面的代码所示：'
- en: '[PRE7]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: New dimensions are declared using the `<dimen>` tag. Dimension names should
    typically be written in snake case. The value for a dimension is added within
    the opening `<dimen>` and closing `</dimens>` tags.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`<dimen>`标签声明新维度。维度名称通常应写成蛇形。维度的值添加在`<dimen>`和`</dimens>`标签之间。
- en: 'Now that we have added a few dimensions, we can use them in our linear layout:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经添加了一些维度，我们可以在线性布局中使用它们：
- en: '[PRE8]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We've gotten our `LinearLayout` view group set up and now we need to add the
    required layout views to it. Before we do that, we need to understand the concepts
    of views and view groups.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经设置了`LinearLayout`视图组，现在需要向其中添加所需的布局视图。在这样做之前，我们需要理解视图和视图组的概念。
- en: Views
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图
- en: A view is a layout element that occupies a set area of the screen and is responsible
    for drawing and event handling. View is the base class for UI elements or widgets
    such as text fields, input fields, and buttons. All views extend the View class.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是占据屏幕特定区域的布局元素，负责绘制和事件处理。视图是UI元素或小部件（如文本字段、输入字段和按钮）的基类。所有视图都扩展了View类。
- en: 'Views can be created within an XML layout in a source file. Consider the following
    code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 视图可以在源文件中的XML布局中创建。考虑以下代码：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Besides creating views directly in a layout file, they can also be created
    programmatically within program files. For example, a text view can be made by
    creating an instance of the `TextView` class and passing a `context` to its constructor.
    This is demonstrated in the following code snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在布局文件中直接创建视图外，它们还可以在程序文件中通过编程方式创建。例如，可以通过创建`TextView`类的实例并将`context`传递给其构造函数来创建一个文本视图。以下代码片段展示了这一点：
- en: '[PRE10]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: View groups
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图组
- en: A view group is a special kind of view that is capable of containing views.
    A view group that contains one or more views is commonly referred to as a parent
    view and the views contained as its children views. A view group is the parent
    class of several other view containers. Some examples of view groups are `LinearLayout`,
    `CoordinatorLayout`, `ConstriantLayout`, `RelativeLayout`, `AbsoluteLayout`, `GridLayout`,
    and `FrameLayout`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组是一种特殊的视图，能够包含其他视图。包含一个或多个视图的视图组通常被称为父视图，而包含的视图被称为子视图。视图组是其他几个视图容器的父类。视图组的例子包括`LinearLayout`、`CoordinatorLayout`、`ConstraintLayout`、`RelativeLayout`、`AbsoluteLayout`、`GridLayout`和`FrameLayout`。
- en: 'View groups can be created within an XML layout in a source file:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 视图组可以在源文件中的XML布局中创建：
- en: '[PRE11]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Similar to views, view groups can be created programmatically within component
    classes. In the following code snippet, a linear layout is made by creating an
    instance of the `LinearLayout` class and passing the `context` of `MainActivity`
    to its constructor:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与视图类似，视图组可以在组件类中通过编程方式创建。在下面的代码片段中，通过创建`LinearLayout`类的实例并将`MainActivity`的`context`传递给其构造函数来创建一个线性布局：
- en: '[PRE12]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Having understood the concepts of views and view groups, we can add a few more
    views to our layout. Text views are added to a layout with the `<TextView>` element
    and buttons are added with the `<Button>` element:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 理解了视图和视图组的概念后，我们可以在布局中添加更多视图。通过`<TextView>`元素添加文本视图，通过`<Button>`元素添加按钮：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As our sketch outlines, we have added two text views to hold the application
    title and the high score, as well as three buttons to execute the required actions.
    We have made use of two new attributes. These attributes are `android:id` and
    `android:layout_weight`. The `android:id` attribute is used to set a unique identifier
    for an element in a layout. No two elements in the same layout can have the same
    ID. The `android:layout_weight` attribute is used to specify a precedence value
    for how much space a view should take in its parent container:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们的草图所示，我们添加了两个文本视图来显示应用程序标题和最高分，以及三个按钮来执行所需操作。我们使用了两个新属性。这些属性是 `android:id`
    和 `android:layout_weight`。`android:id` 属性用于在布局中为元素设置一个唯一的标识符。同一布局中的两个元素不能有相同的
    ID。`android:layout_weight` 属性用于指定视图在其父容器中应占用的优先级值：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding code snippet, two child views are contained by a linear layout.
    The button explicitly sets both its dimensional constraints to `70dp` and `40dp`.
    The view, on the other hand, has its width explicitly set to `70dp` and has its
    height set to `0dp`. As a result of the presence of an `android:layout_weight`
    attribute set to `1`,  the view's height is set to cover all remaining space in
    the parent view.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，两个子视图被一个线性布局包含。按钮明确地将其尺寸约束设置为 `70dp` 和 `40dp`。另一方面，视图的宽度被明确设置为 `70dp`，高度设置为
    `0dp`。由于存在设置为 `1` 的 `android:layout_weight` 属性，视图的高度被设置为覆盖父视图中的所有剩余空间。
- en: 'Now that we understand fully what is going on in our layout, we can take a
    look at the layout design preview:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完全理解了布局中的情况，我们可以看看布局设计预览：
- en: '![](img/057ee4c5-fa77-4f91-b564-96a0ef0fa8cd.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![](img/057ee4c5-fa77-4f91-b564-96a0ef0fa8cd.jpg)'
- en: 'We can see that something seems off. Unlike our sketch, our layout items are
    not centered but aligned to the right. We can solve this by using the `android:gravity`
    attribute in our linear layout view groups. In the following code snippet, we
    make use of the `android:gravity` attribute to center layout widgets within both
    linear layouts:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到似乎有些不对劲。与我们的草图不同，我们的布局项不是居中，而是右对齐。我们可以通过在线性布局视图组中使用 `android:gravity`
    属性来解决此问题。在以下代码片段中，我们使用了 `android:gravity` 属性来在两个线性布局中居中布局小部件：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As a result of `android:gravity` being set to `center`, widgets are properly
    aligned as we would like. The effects of applying the `android:gravity` view groups
    to our layout view groups can be seen in the following screenshot:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `android:gravity` 被设置为 `center`，小部件被正确地排列，正如我们所期望的那样。将 `android:gravity`
    视图组应用于我们的布局视图组的效果可以在以下屏幕截图中看到：
- en: '![](img/de72ca44-34bf-4185-9b8a-9e977acb4fa4.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![](img/de72ca44-34bf-4185-9b8a-9e977acb4fa4.jpg)'
- en: Defining string resources
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义字符串资源
- en: Up till now, we have been passing hardcoded strings as values to element attributes
    that require text to be set. This is not best practice and generally should be
    avoided. Instead, string values should be added in a string resource file.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直将硬编码的字符串作为值传递给需要设置文本的元素属性。这不是最佳实践，通常应该避免。相反，应该在字符串资源文件中添加字符串值。
- en: 'The default file for string resources is `strings.xml` and this can be found
    in the `res` | `values` directory:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 字符串资源的默认文件是 `strings.xml`，它位于 `res` | `values` 目录中：
- en: '![](img/3e6592a2-1b40-4883-ad52-ff6e9dd2e3c5.png)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3e6592a2-1b40-4883-ad52-ff6e9dd2e3c5.png)'
- en: 'String values are added as string resources using the `<string>` XML tag. We
    need to add string resources for all string values we have used thus far. Add
    the following code to your string resource file:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `<string>` XML 标签添加字符串值作为字符串资源。我们需要为迄今为止使用的所有字符串值添加字符串资源。将以下代码添加到您的字符串资源文件中：
- en: '[PRE16]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Now it is necessary to edit our `MainActivity` layout file to exploit these
    created resources. A string resource can be referenced with `@strings/` prefixing
    the string resource name. Consider the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有必要编辑我们的 `MainActivity` 布局文件以利用这些创建的资源。字符串资源可以通过在字符串资源名称前加上 `@strings/` 前缀来引用。考虑以下代码：
- en: '[PRE17]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Handling input events
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理输入事件
- en: In the cycle of a user's interaction with an application, a means by which the
    user can provide some form of input for the execution of a process is by interacting
    with a widget. These inputs can be captured with events. In Android applications,
    events are captured from the specific view object that the user interacts with.
    The required structures and procedures necessary for input event handling are
    provided by the View class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户与应用程序交互的周期中，用户可以通过与小部件交互来提供某种形式的输入以执行一个过程。这些输入可以通过事件来捕获。在Android应用程序中，事件是从用户与之交互的特定视图对象中捕获的。处理输入事件所需的必要结构和程序由View类提供。
- en: Event listeners
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事件监听器
- en: An event listener is a procedure in an application program that waits for a
    UI event to occur. There are many types of events that can be emitted within an
    application. Some common events are click events, touch events, long click events,
    and text change events.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器是应用程序程序中的一个过程，它等待UI事件的发生。应用程序中可以发出许多类型的事件。一些常见的事件包括点击事件、触摸事件、长按事件和文本更改事件。
- en: In order to capture a widget event and perform an action upon its occurrence,
    a listener for the event must be set to the view. This can be achieved by invoking
    a view's set. `Listener()` method and passing either a lambda or a reference to
    a function to the method invocation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了捕获小部件事件并在其发生时执行操作，必须在视图中设置事件监听器。这可以通过调用视图的`setListener()`方法并传递lambda或函数引用到方法调用中来实现。
- en: 'The following example demonstrates the capturing of a click event done on a
    button. A lambda is passed to the `setOnClickListener` method of the view class:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例演示了在按钮上捕获点击事件。将lambda传递到视图类的`setOnClickListener`方法中：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'A reference to a function can be passed in place of a lambda:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 可以用一个函数的引用来代替lambda：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Many listener setter methods are available in the view class. Some examples
    are:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 视图类中提供了许多监听器设置方法。以下是一些示例：
- en: '`setOnClickListener()`: Sets a function to be invoked upon the click of a view'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnClickListener()`: 在视图被点击时设置要调用的函数'
- en: '`setOnContextClickListener()`: Sets a function to be invoked upon the context
    click of a view'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnContextClickListener()`: 在视图上发生上下文点击时设置要调用的函数'
- en: '`setOnCreateContextMenuListener()`: Sets a function to be invoked upon the
    creation of a view''s context menu'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnCreateContextMenuListener()`: 在创建视图的上下文菜单时设置要调用的函数'
- en: '`setOnDragListener()`: Sets a function to be invoked on the occurrence of a
    drag event on a view'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnDragListener()`: 在视图上发生拖动事件时设置要调用的函数'
- en: '`setOnFocusChangeListener()`: Sets a function to be called on the focus change
    of a view'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnFocusChangeListener()`: 在视图的焦点改变时设置要调用的函数'
- en: '`setOnHoverChangeListener()`: Sets a function to be called when a hover event
    occurs on a view'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnHoverChangeListener()`: 当视图上发生悬停事件时设置要调用的函数'
- en: '`setOnLongClickListener()`: Sets a function to be invoked on the occurrence
    of a long click event on a view'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnLongClickListener()`: 在视图上发生长按事件时设置要调用的函数'
- en: '`setOnScrollChangeListener()`: Sets a function to be invoked when the scroll
    positions (X or Y) of a view change'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setOnScrollChangeListener()`: 当视图的滚动位置（X或Y）改变时设置要调用的函数'
- en: An event listener is a procedure in an application program that waits for a
    UI event to occur.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 事件监听器是应用程序程序中的一个过程，它等待UI事件的发生。
- en: As we now have a good understanding of how to handle input events, we can go
    on to implement some logic in our `MainActivity`.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在已经很好地理解了如何处理输入事件，我们可以继续在`MainActivity`中实现一些逻辑。
- en: 'The main activity screen contains an app bar. We need to hide this layout element
    as our view does not require it:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 主活动屏幕包含一个应用栏。我们需要隐藏这个布局元素，因为我们的视图不需要它：
- en: '![](img/2ed808ff-d61d-46e1-92b6-a53c7eb037cf.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2ed808ff-d61d-46e1-92b6-a53c7eb037cf.jpg)'
- en: Appbar
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 应用栏
- en: 'An app bar is also referred to as an action bar. Action bars are instances
    of the `ActionBar` class. The instance of the action bar widget in a layout can
    be retrieved via the `supportActionBar` accessor variable. The following code
    retrieves the action bar, and hides it if a null reference is not returned:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 应用栏也被称为操作栏。操作栏是`ActionBar`类的实例。布局中操作栏小部件的实例可以通过`supportActionBar`访问器变量检索。以下代码检索操作栏，并在没有返回null引用的情况下将其隐藏：
- en: '[PRE20]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Though the preceding code performs what is necessary, its length can be reduced
    considerably by exploiting Kotlin''s type-safe system, which is as follows:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的代码执行了必要的操作，但通过利用Kotlin的类型安全系统，其长度可以大大缩短，如下所示：
- en: '[PRE21]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If `supportActionBar` is not a null object reference, the `hide()` method will
    be invoked if nothing else happens. This will prevent the raising of a null pointer
    exception.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `supportActionBar` 不是一个空对象引用，则如果没有其他操作发生，将调用 `hide()` 方法。这将防止抛出空指针异常。
- en: 'We need to create object references for the widgets that exist in our layouts.
    This is necessary for many reasons, such as listener registration. Object references
    of a view can be retrieved by passing the resource ID of the view to `findViewById()`.
    We add object references to `MainActivity` (existing in the `MainActivity.kt`
    file) in the following code snippet:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为布局中存在的小部件创建对象引用。这出于许多原因，例如监听器注册。可以通过将视图的资源 ID 传递给 `findViewById()` 来检索视图的对象引用。我们在以下代码片段中将对象引用添加到
    `MainActivity`（存在于 `MainActivity.kt` 文件中）：
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Now that we have object references to our user interface elements in place,
    we need to handle some of their events. We must set click listeners for all buttons
    in the layout (there's no point having a button that does nothing when clicked,
    after all).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为用户界面元素创建了对象引用，我们需要处理它们的一些事件。我们必须为布局中的所有按钮设置点击监听器（毕竟，点击后什么也不做的按钮是没有意义的）。
- en: 'As we stated earlier on, the New Game button has the sole task of navigating
    the user to the game activity (where game play takes place). In order to do this,
    we will need to utilize an explicit intent. Add a private function containing
    the logic to be executed on the click of the New Game button to `MainActivity` (in
    the `MainActivity.kt` file) and set a reference to the function via `setOnClickListener()`
    invocation:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所述，新游戏按钮的唯一任务是引导用户导航到游戏活动（游戏发生的地方）。为了做到这一点，我们需要使用一个显式意图。将包含在“新游戏”按钮点击时执行的逻辑的私有函数添加到
    `MainActivity`（在 `MainActivity.kt` 文件中），并通过 `setOnClickListener()` 调用设置函数的引用：
- en: '[PRE23]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Create a new empty activity and name it `GameActivity`. Once the activity is
    created, we can utilize an intent to launch the activity on the click of the New
    Game button, as shown in the following code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的空活动并将其命名为 `GameActivity`。一旦活动创建完成，我们就可以利用意图在点击“新游戏”按钮时启动该活动，如下面的代码所示：
- en: '[PRE24]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The first line of the function body creates a new instance of the Intent class
    and passes the current context and the required activity class to the constructor.
    Notice we passed `this` as the first argument to the constructor. The `this` keyword
    is used to refer to the current instance in which `this` is called. Hence, we
    are actually passing the current activity (`MainActivity`) as the first argument
    to the constructor.  At this point, you might be asking why we are passing an
    activity as the first argument of the `Intent` constructor when it requires a
    context as its first argument. This is because all activities are extensions of
    the `Context` abstract class. Hence, all activities are in their own rights contexts.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 函数体的第一行创建了一个新的 `Intent` 类实例，并将当前上下文和所需的活动类传递给构造函数。注意我们传递 `this` 作为构造函数的第一个参数。`this`
    关键字用于引用 `this` 被调用时的当前实例。因此，我们实际上是将当前活动（`MainActivity`）作为构造函数的第一个参数传递。此时，你可能会问为什么我们要将活动作为
    `Intent` 构造函数的第一个参数传递，因为它需要一个上下文作为其第一个参数。这是因为所有活动都是 `Context` 抽象类的扩展。因此，所有活动都是它们自己的上下文。
- en: The `startActivity()` method is called to launch an activity from which no result
    is expected. When an intent is passed as its only argument, it starts an activity
    from which it expects no result. Go ahead and run the application to observe the
    effect of the button click.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `startActivity()` 方法从不需要结果的活动启动。当传递一个意图作为其唯一参数时，它将从不需要结果的活动启动。运行应用程序以观察按钮点击的效果。
- en: '`Context` is an abstract class in the Android application framework. The implementation
    of a context is provided by the Android system. `Context` allows access to application-specific
    resources. `Context` also allows access to calls for application-level operations
    such as launching activities, sending broadcasts, and receiving intents.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`Context` 是 Android 应用程序框架中的一个抽象类。`Context` 的实现由 Android 系统提供。`Context` 允许访问应用程序特定的资源。`Context`
    还允许访问应用程序级操作，例如启动活动、发送广播和接收意图。'
- en: 'Now let''s implement the following functions for the clicks of the EXIT and
    RESET SCORE buttons:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们实现以下功能，用于处理“退出”和“重置分数”按钮的点击：
- en: '[PRE25]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The call to `System.exit()` in the `onBtnExitClick` function stops further execution
    of the program and exits it when the `0` integer is passed as its argument. The
    last thing we need to do concerning handling click events is to implement the
    logic to perform the reset of high scores. To do this, we need to implement some
    logic for data storage first to store the high score. We will do this using `SharedPreferences`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onBtnExitClick` 函数中的 `System.exit()` 调用停止了程序的进一步执行，并在传递 `0` 整数作为其参数时退出程序。关于处理点击事件，我们最后需要实现重置高分的逻辑。为此，我们需要首先实现一些数据存储逻辑来存储高分。我们将使用
    `SharedPreferences` 来完成这项工作。
- en: Working with SharedPreferences
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SharedPreferences
- en: '`SharedPreferences` is an interface for storing, accessing, and modifying data.
    The `SharedPreferences` APIs enable data storage in sets of key-value pairs.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`SharedPreferences` 是一个用于存储、访问和修改数据的接口。`SharedPreferences` API 允许以键值对集合的形式存储数据。'
- en: 'We will set up a simple utility to handle our data storage needs for this app
    utilizing the `SharedPreferences` interface. Create a package in the project''s
    source directory with the name `storage` (right-click the source directory and
    select New | Package):'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置一个简单的工具来处理此应用程序的数据存储需求，利用 `SharedPreferences` 接口。在项目的源目录中创建一个名为 `storage`
    的包（在源目录上右键单击并选择 New | Package）：
- en: '![](img/d2132e50-d9a0-46cf-b802-4643842164c7.png)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d2132e50-d9a0-46cf-b802-4643842164c7.png)'
- en: 'Next, create a new Kotlin class named `AppPreferences` within the `storage`
    package. Type the following code into the class file:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在 `storage` 包内创建一个名为 `AppPreferences` 的新 Kotlin 类。将以下代码输入到类文件中：
- en: '[PRE26]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code snippet, a `Context` is required to be passed to the class'
    constructor upon creation of an instance of the class. Context provides access
    to the `getSharedPreferences()` method, which retrieves a specified preference
    file. The preference file is identified by the name in the string passed as the
    `getSharedPreferences()` method's first argument.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，在创建类的实例时需要将 `Context` 传递给类的构造函数。`Context` 提供了对 `getSharedPreferences()`
    方法的访问，该方法检索指定的首选项文件。首选项文件由作为 `getSharedPreferences()` 方法第一个参数传递的字符串中的名称标识。
- en: The `saveHighScore()` function takes an integer – the high score to be saved
    – as its only argument. `data.edit()` returns an `Editor` object that permits
    the modification of a preference file. The editor's `putInt()` method is called
    in order to store an integer within the preference file. The first argument passed
    to `putInt()` is a string representing the key that will be used to access the
    stored value. The second argument to the method is the integer to be stored –
    in this case, the high score.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '`saveHighScore()` 函数接受一个整数——要保存的高分——作为其唯一参数。`data.edit()` 返回一个 `Editor` 对象，允许修改首选项文件。调用编辑器的
    `putInt()` 方法以在首选项文件中存储一个整数。传递给 `putInt()` 的第一个参数是一个表示将用于访问存储值的键的字符串。该方法的方法参数是存储的整数——在这种情况下，是高分。'
- en: '`getHighScore()` returns the high score by calling `data.getInt()`. `getInt()`
    is a function implemented by `SharedPreferences` that provides read access to
    a stored integer value. `HIGH_SCORE` is the unique identifier of the value to
    be retrieved. The `0` passed to the function''s second argument specifies a default
    value to be returned in the scenario that no value corresponding to the specified
    key exists.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`getHighScore()` 通过调用 `data.getInt()` 返回高分。`getInt()` 是 `SharedPreferences`
    实现的一个函数，它提供了对存储的整数值的读取访问。`HIGH_SCORE` 是要检索的值的唯一标识符。传递给函数第二个参数的 `0` 指定了在不存在对应于指定键的值时返回的默认值。'
- en: '`clearHighScore()` resets the high score to zero by simply overwriting the
    value corresponding to the `HIGH_SCORE` key with `0`.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`clearHighScore()` 通过简单地用 `0` 覆盖对应于 `HIGH_SCORE` 键的值来将高分重置为零。'
- en: 'Now that we have our `AppPreferences` utility class in place, we can finish
    up the `onBtnResetScoreClick()` function in `MainActivity`:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了 `AppPreferences` 工具类，我们可以在 `MainActivity` 中完成 `onBtnResetScoreClick()`
    函数：
- en: '[PRE27]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now when the high score reset button is clicked, the high score is reset to
    zero. You'll want to give the user some sort of feedback when such actions occur.
    We can utilize a `Snackbar` to provide this user feedback.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当点击高分重置按钮时，高分将被重置为零。当发生此类操作时，您可能希望给用户某种形式的反馈。我们可以使用 `Snackbar` 来提供这种用户反馈。
- en: 'In order to use the `Snackbar` class within an Android application, the Android
    design support library dependency must be added to the module-level Gradle build
    script. Do this by adding the following line of code under the dependencies closure
    of `build.gradle`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Android应用程序中使用`Snackbar`类，必须在模块级别的Gradle构建脚本中添加Android设计支持库依赖项。通过在`build.gradle`的依赖项闭包下添加以下行代码来完成此操作：
- en: '[PRE28]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'After you have added the line, your module-level `build.gradle` script should
    look similar to the following:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 添加该行后，您的模块级别`build.gradle`脚本应类似于以下内容：
- en: '[PRE29]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After making the alterations, sync your project by clicking Sync Now on the
    flash message that appears within the editor window, as shown in the following
    screenshot:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 修改完成后，通过在编辑器窗口中出现的闪消息中点击“立即同步”，同步您的项目，如图所示：
- en: '![](img/bb1ca54d-53b2-4534-9973-b61efe103f00.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bb1ca54d-53b2-4534-9973-b61efe103f00.jpg)'
- en: 'Without further ado, let''s modify our `onBtnResetClick()` to provide user
    feedback in the form of a `Snackbar` after a score reset has been performed by
    using the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 不再拖延，让我们修改`onBtnResetClick()`方法，以便在执行分数重置操作后以`Snackbar`的形式提供用户反馈，如下所示：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Clicking on RESET SCORE successfully resets the high score of the player as
    shown in the following screenshot:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 点击重置分数后，玩家的最高分如以下截图所示成功重置：
- en: '![](img/879f5463-2612-4e88-a174-5204c5e9092e.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/879f5463-2612-4e88-a174-5204c5e9092e.jpg)'
- en: 'Before moving further, you''ll want to update the text displayed in the high
    score text view of the `MainActivity` layout to reflect the reset score. This
    can be done by changing the text contained in the text view as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，您需要更新`MainActivity`布局中显示的最高分数文本视图中的文本，以反映重置的分数。这可以通过更改文本视图中的文本如下完成：
- en: '[PRE31]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Implementing the game activity layout
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现游戏活动布局
- en: 'So far, we have successfully created the layout for main activity. Before we
    conclude this chapter, it is imperative we create the layout for `GameActivity`
    as well. Go ahead and open `activity_game.xml` and add the following code to it:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经成功创建了主活动的布局。在我们结束这一章之前，我们必须创建`GameActivity`的布局也是至关重要的。打开`activity_game.xml`并添加以下代码到其中：
- en: '[PRE32]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Most view attributes used in this layout have already previously been used and
    as such do not need further explanation. The only exceptions are the `android:background`
    and `android:layout_weightSum` attributes.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在此布局中使用的多数视图属性之前已经使用过，因此不需要进一步解释。唯一的例外是`android:background`和`android:layout_weightSum`属性。
- en: The `android:background` attribute is used to set the background color of a
    view or view group. `#e8e8e8` and `#000` were passed as values in the two instances
    where `android:background` is used in the layout. `#e8e8e8` is the hex color code
    for gray and `#000` the hex code for black.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:background`属性用于设置视图或视图组的背景颜色。在布局中使用`android:background`的两次实例中，`#e8e8e8`和`#000`被用作值。`#e8e8e8`是灰色十六进制颜色代码，而`#000`是黑色十六进制代码。'
- en: '`android:layout_weightSum` defines the maximum weight sum in a view group and
    is calculated as the sum of the `layout_weight` values of all child views in a
    view group. The first linear layout in `activity_game.xml` declares the weight
    sum of all child views to be `10`. As such, the immediate children of the linear
    layout have layout weights of `1` and `9`, respectively.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`android:layout_weightSum`定义了视图组中的最大权重和，它是视图组中所有子视图的`layout_weight`值的总和。`activity_game.xml`中的第一个线性布局声明所有子视图的权重和为`10`。因此，线性布局的直接子视图具有布局权重`1`和`9`。'
- en: 'We made use of three string resources that we have not previously added to
    our string resources file. Go ahead and add the following string resources to
    `strings.xml`:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了三个之前未添加到我们的字符串资源文件中的字符串资源。请将以下字符串资源添加到`strings.xml`中：
- en: '[PRE33]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we have to add some simple logic to game activity for the population
    of the high score and current score text views, as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须为游戏活动添加一些简单的逻辑，以便填充最高分和当前分数文本视图，如下所示：
- en: '[PRE34]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In the preceding code snippet, object references to layout view elements are
    created. In addition, we declare the `updateHighScore()` and `updateCurrentScore()`
    functions. These two functions are invoked on the creation of the view. They set
    the default scores displayed in the current score and high score text views declared
    in the layout file.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，创建了布局视图元素的引用对象。此外，我们声明了`updateHighScore()`和`updateCurrentScore()`函数。这两个函数在视图创建时被调用。它们设置在布局文件中声明的当前分数和最高分数文本视图显示的默认分数。
- en: 'Save the changes made to the project and build and run the application. Click
    on the New Game button once the application starts to view the layout we just
    created:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 保存对项目的更改并构建和运行应用程序。在应用程序启动后，点击“新建游戏”按钮以查看我们刚刚创建的布局：
- en: '![](img/7e0507ef-a29d-4ca8-b038-8f7bf5e0280e.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7e0507ef-a29d-4ca8-b038-8f7bf5e0280e.jpg)'
- en: 'The right-hand side of the layout that contains no content is the area in which
    the Tetris game play will happen. We will implement this in chapter 3: Implementing
    Tetris Logic and Functionality. The final thing we must understand before moving
    to the next chapter is the app manifest.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 布局右侧不包含内容的部分是俄罗斯方块游戏发生的区域。我们将在第3章中实现这一功能：实现俄罗斯方块逻辑和功能。在进入下一章之前，我们必须理解的是应用程序清单。
- en: The app manifest
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序清单
- en: 'The app manifest is an XML file that is present in every Android application.
    It is located in the manifests of an application''s root folder. The `manifest`
    file holds crucial information pertaining to an application on the Android operating
    system. The information contained in an application''s `androidManifest.xml` must
    be read by the Android system before an application can be run. Some of the information
    that must be registered in the app manifest are:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序清单是一个存在于每个Android应用程序中的XML文件。它位于应用程序根文件夹的清单中。`manifest`文件包含有关Android操作系统中应用程序的关键信息。在应用程序可以运行之前，Android系统必须读取应用程序的`androidManifest.xml`文件中包含的信息。必须在应用程序清单中注册的一些信息包括：
- en: The Java package name for the application
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序的Java包名
- en: The activities present in the application
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中的活动
- en: Services that are used in the application
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中使用的服务
- en: Intent filters that direct implicit intents to an activity
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将隐式意图指向活动的意图过滤器
- en: Descriptions of the broadcast receivers used in the application
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中使用的广播接收器的描述
- en: Data pertaining to content providers present in the application
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序中存在的内容提供者的数据
- en: The classes that implement the various application components
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现各种应用程序组件的类
- en: The permissions that are required by an application
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序所需的权限
- en: Structure of the app manifest file
  id: totrans-235
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序清单文件的结构
- en: 'The general structure of the `androidManifest.xml` file is shown in the following
    code snippet. The snippet contains all possible elements and declarations that
    can exist in the `manifest` file:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '`androidManifest.xml`文件的总体结构如下所示。片段包含`manifest`文件中可能存在的所有可能元素和声明：'
- en: '[PRE35]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'As can be seen from the preceding code snippet, a vast array of elements can
    appear in the `manifest` file. Many of these elements will be covered in this
    book. As a matter of fact, a number of these manifest elements have already been
    used in our Tetris application. Go ahead and open the `androidManifest.xml` file
    of Tetris. The contents of the file should be similar to what is contained in
    the following code snippet:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码片段所示，`manifest`文件中可以出现大量元素。本书将涵盖许多这些元素。实际上，我们已经在俄罗斯方块应用程序中使用了一些这些清单元素。请打开俄罗斯方块应用程序的`androidManifest.xml`文件。文件内容应类似于以下代码片段：
- en: '[PRE36]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The elements used in the preceding `manifest` file – in alphabetical order
    – are as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的`manifest`文件中使用的元素（按字母顺序排列）如下：
- en: '`<action>`'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<action>`'
- en: '`<activity>`'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<activity>`'
- en: '`<application>`'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<application>`'
- en: '`<category>`'
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<category>`'
- en: '`<intent-filter>`'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<intent-filter>`'
- en: '`<manifest>`'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<manifest>`'
- en: <action>
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<action>`'
- en: 'This is used to add an action to an intent filter. The `<action>` element is
    always a child element to an `<intent-filter>` element. An intent filter should
    contain one or more of these elements. If no action element is declared for an
    intent filter, the filter accepts no `Intent` objects. Its syntax is as follows:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这用于向意图过滤器添加操作。`<action>`元素始终是`<intent-filter>`元素的子元素。意图过滤器应包含一个或多个这些元素。如果没有为意图过滤器声明操作元素，则过滤器不接受任何`Intent`对象。其语法如下：
- en: '[PRE37]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding `name` attribute is an attribute that specifies the name of the
    action being handled.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的`name`属性是一个指定正在处理的操作名称的属性。
- en: <activity>
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<activity>`'
- en: 'This element declares an activity existing in an application. All activities
    must be declared in the app manifest in order to be seen by the Android system.
    `<activity>` is always placed within a parent `<application>` element. The following
    code snippet shows the declaration of an activity within a manifest file using
    the `<activity>` element:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素声明了一个应用程序中存在的活动。所有活动都必须在应用程序清单中声明，以便被 Android 系统看到。`<activity>` 总是放置在父 `<application>`
    元素内。以下代码片段显示了使用 `<activity>` 元素在清单文件中声明活动的示例：
- en: '[PRE38]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `name` attribute in the preceding code snippet is an attribute that specifies
    the name of the class that implements the activity being declared.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的 `name` 属性是一个属性，用于指定实现所声明活动的类的名称。
- en: <application>
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<application>`'
- en: 'This element is the declaration of the application. It contains subelements
    that declare the components existing in the application. The following code demonstrates
    the use of `<application>`:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素是应用程序的声明。它包含子元素，用于声明应用程序中存在的组件。以下代码演示了 `<application>` 的使用：
- en: '[PRE39]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `<application>` element in the preceding snippet makes use of four attributes.
    These attributes are:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段中的 `<application>` 元素使用了四个属性。这些属性是：
- en: '`android:allowBackup`: It is used to specify whether the application is allowed
    to take part in the backup and restore infrastructure. When set to `true`, the
    application can be backed up by the Android system. Otherwise, if this attribute
    is set to `false`, no backup of the application will ever be created by the Android
    system.'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:allowBackup`: 它用于指定应用程序是否允许参与备份和恢复基础设施。当设置为 `true` 时，应用程序可以被 Android
    系统备份。否则，如果此属性设置为 `false`，Android 系统永远不会创建应用程序的备份。'
- en: '`android:icon`: It specifies the icon resource for the application. It can
    also be used to specify icon resources for application components.'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:icon`: 它指定了应用程序的图标资源。它也可以用来指定应用程序组件的图标资源。'
- en: '`android:label`: It specifies a default label for the application as a whole.
    It can also be used to specify default labels for application components.'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:label`: 它指定了整个应用程序的默认标签。它也可以用来指定应用程序组件的默认标签。'
- en: '`android:roundIcon`: It specifies an icon resource to be used when a circular
    icon resource is required. When an app icon is requested by a launcher, the Android
    framework returns either `android:icon` or `android:roundIcon`; which is returned
    depends on the device build configuration. As either can be returned, it is important
    to specify a resource for both attributes.'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:roundIcon`: 它指定了在需要圆形图标资源时使用的图标资源。当启动器请求应用程序图标时，Android 框架返回 `android:icon`
    或 `android:roundIcon`；返回哪个取决于设备的构建配置。由于两者都可能返回，因此为这两个属性指定资源是很重要的。'
- en: '`android:supportsRtl`: It specifies whether an application is willing to support
    **right-to-left** (**RTL**) layouts. The application is set to support it when
    this attribute is set to `true`. Otherwise, the application does not support RTL
    layouts.'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:supportsRtl`: 它指定了应用程序是否愿意支持 **从右到左**（**RTL**）布局。当此属性设置为 `true` 时，应用程序设置为支持它。否则，应用程序不支持
    RTL 布局。'
- en: '`android:theme`: It specifies a style resource defining a default theme for
    all activities in the application.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:theme`: 它指定了一个定义应用程序中所有活动默认主题的样式资源。'
- en: <category>
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<category>`'
- en: This element is a child element to `<intent-filter>`. It is used to specify
    a category name to its parent intent filter component.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 此元素是 `<intent-filter>` 的子元素。它用于指定一个类别名称给其父意图过滤器组件。
- en: <intent-filter>
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<intent-filter>`'
- en: Specifies the type of intent that activity, service, and broadcast receiver
    components can respond to. An intent filter is always declared within a parent
    component with the `<intent-filter>` element.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 指定活动、服务和广播接收器组件可以响应的意图类型。意图过滤器始终在具有 `<intent-filter>` 元素的父组件中声明。
- en: <manifest>
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`<manifest>`'
- en: This is the root element of the app manifest file. It contains a single `<application>`
    element and specifies the `xmlns:android` and `package` attributes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这是应用程序清单文件的根元素。它包含一个单独的 `<application>` 元素，并指定了 `xmlns:android` 和 `package`
    属性。
- en: Summary
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we took a closer look at the Android application framework.
    In the process, we learned about several things, such as the seven fundamental
    Android app components: activities, intents, intent filters, fragments, services,
    loaders, and content providers.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更深入地研究了 Android 应用程序框架。在这个过程中，我们了解了许多事情，例如七个基本的 Android 应用程序组件：活动、意图、意图过滤器、片段、服务、加载器和内容提供者。
- en: In addition, we took a close look at the process of creating a layout, the constraint
    layout, types of layout constraints that exist, string, dimension resources, views,
    view groups, and working with `SharedPreferences`. In the next chapter, we will
    delve further into the world of Tetris and implement the gameplay as well as critical
    application logic.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还仔细研究了创建布局的过程，包括约束布局、现有的布局约束类型、字符串、尺寸资源、视图、视图组以及如何使用`SharedPreferences`。在下一章中，我们将进一步深入到俄罗斯方块的世界，并实现游戏玩法以及关键的应用逻辑。
