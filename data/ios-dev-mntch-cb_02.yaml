- en: 'Chapter 2. User Interface: Views'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第2章 用户界面：视图
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Adding and customizing views
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加和自定义视图
- en: Receiving user input with buttons
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用按钮接收用户输入
- en: Using labels to display text
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用标签显示文本
- en: Displaying images
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示图像
- en: Displaying and editing text
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示和编辑文本
- en: Using the keyboard
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘
- en: Displaying progress
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示进度
- en: Displaying content larger than the screen
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示比屏幕更大的内容
- en: Navigating through content divided into pages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在分页的内容中导航
- en: Displaying a toolbar
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示工具栏
- en: Creating a custom view
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义视图
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: An application's user interface is essential for providing the user with an
    easy way of communicating with a device, be it a computer, a mobile phone, or
    a tablet. On a mobile device, the user interface is not only essential but the
    only way to interact with the user. Developers have to cope with various limitations
    and restrictions when developing for mobile devices. The processing power does
    not match desktop CPUs and the screens are smaller, making the process of choosing
    what sort of information will be displayed each time somewhat more difficult.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的用户界面对于为用户提供与设备（无论是计算机、移动电话还是平板电脑）进行简单通信的方式至关重要。在移动设备上，用户界面不仅至关重要，而且是与用户交互的唯一方式。开发者在为移动设备开发时必须应对各种限制和约束。处理能力不匹配桌面CPU，屏幕较小，这使得每次选择要显示的信息类型的过程变得更加困难。
- en: 'In this chapter, we will discuss the key components of an iOS application''s
    UI. We will see how to use and customize these components to create rich application
    user interfaces and discuss their similarities and differences they have with
    their desktop equivalents. Here is a list of these components:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论iOS应用程序UI的关键组件。我们将了解如何使用和自定义这些组件以创建丰富的应用程序用户界面，并讨论它们与桌面等价物的相似之处和不同之处。以下是这些组件的列表：
- en: '`UIView:` It is a customizable container, which is the base object of most
    iOS user interface controls'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIView:` 它是一个可定制的容器，是大多数iOS用户界面控件的基础对象'
- en: '`UIButton:` It is the equivalent of a `Button` in .NET world'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIButton:` 它是.NET世界中的`Button`的等价物'
- en: '`UILabel:` It is the equivalent of a `Label` in .NET world'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UILabel:` 它是.NET世界中的`Label`的等价物'
- en: '`UIImageView:` It is a view that allows us to display and create basic animations
    with images'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIImageView:` 它是一个允许我们使用图像显示和创建基本动画的视图'
- en: '`UITextView:` It is a view, which allows us to display editable text'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITextView:` 它是一个允许我们显示可编辑文本的视图'
- en: '`UITextField:` It is similar to .NET''s `TextBox` control'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITextField:` 它类似于.NET的`TextBox`控件'
- en: '`UIProgressView:` It displays known length progress'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIProgressView:` 它显示已知长度的进度'
- en: '`UIScrollView:` It provides the ability to display scrollable content'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIScrollView:` 它提供了显示可滚动内容的能力'
- en: '`UIPageControl:` It provides navigation functionality to content, divided into
    different pages or screens'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIPageControl:` 它为内容提供导航功能，内容分为不同的页面或屏幕'
- en: '`UIToolbar:` It provides a toolbar at the bottom of the screen that accepts
    customizable buttons'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIToolbar:` 它在屏幕底部提供一个接受可自定义按钮的工具栏'
- en: We will also talk about how to programmatically create instances of these components
    and use them efficiently.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将讨论如何以编程方式创建这些组件的实例并有效地使用它们。
- en: Adding and customizing views
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加和自定义视图
- en: In this task, we will discuss how to add and customize a `UIView` with **Interface
    Builder**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论如何使用**Interface Builder**添加和自定义`UIView`。
- en: Getting ready
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Adding views with Interface Builder is a simple task. Let's start by creating
    a new **iPhone Single View Application** project in MonoDevelop. Name the project
    `FirstViewApp`, and open the `FirstViewAppViewController.xib` file with Interface
    Builder.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Interface Builder添加视图是一个简单的任务。让我们首先在MonoDevelop中创建一个新的**iPhone单视图应用程序**项目。将项目命名为`FirstViewApp`，并使用Interface
    Builder打开`FirstViewAppViewController.xib`文件。
- en: How to do it...
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: To add a view to the project, drag-and-drop a `UIView` object from the **Library**
    pad onto the main view. Make sure it fits the entire window area.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要向项目中添加视图，请从**库**垫拖动一个`UIView`对象到主视图上。确保它适合整个窗口区域。
- en: To make the `UIView` accessible, create an outlet for it, and name it `subView`.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使`UIView`可访问，为其创建一个出口，并将其命名为`subView`。
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The concept of outlets and how to use them is discussed in detail in [Chapter
    1](ch01.html "Chapter 1. Development Tools"),Accessing the UI with Outlets.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 关于出口的概念及其使用方法将在[第1章](ch01.html "第1章 开发工具")中详细讨论，通过出口访问UI。
- en: Select the view that we just added and go to the **Inspector** pad. Select the
    **Attributes** tab, and in the **Background** drop-down list, select **Light Gray
    Color**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择我们刚刚添加的视图，并转到**检查器**面板。选择**属性**选项卡，并在**背景**下拉列表中选择**浅灰色**。
- en: Now, select the **Size** tab and reduce the view's height by `60` points.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，选择**大小**选项卡，并将视图的高度减少`60`点。
- en: Save the document.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Compile and run the application on the simulator. The result should look like
    the following image:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。结果应该看起来像以下图像：
- en: '![How to do it...](img/1468EXP_02_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_02_01.jpg)'
- en: The gray portion of the simulator's screen is the view that we have just added.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟器屏幕的灰色部分是我们刚刚添加的视图。
- en: How it works...
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: We have successfully created an application that contains one view. Of course,
    this application does not provide any functionality. It is only meant to show
    how to add a view and display it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个包含一个视图的应用程序。当然，这个应用程序不提供任何功能。它只是为了展示如何添加视图并显示它。
- en: Views are the essential components of an iOS application interface. Every visual
    UI object inherits from the `UIView` class. The concept is somewhat different
    than a `Form` in .NET. A view manages content drawing, accepts other views as
    subviews, provides auto-sizing features, can accept touch events for itself and
    its subviews, and many of its properties can even be animated. Even `UIWindow`
    inherits from `UIView`. It is this class or its inheritors that iOS developers
    will use most frequently.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 视图是iOS应用程序界面的基本组件。每个视觉UI对象都继承自`UIView`类。这个概念与.NET中的`Form`有所不同。视图管理内容绘制，接受其他视图作为子视图，提供自动调整大小功能，可以接受自身及其子视图的触摸事件，并且许多属性甚至可以动画化。甚至`UIWindow`也继承自`UIView`。iOS开发者将最频繁地使用这个类或其继承者。
- en: When a view, which is added with Interface Builder, is first instantiated at
    runtime, it sets its `Frame` property with values that are set through the **Inspector**
    window's **Size** tab. The `Frame` property is of type `RectangleF` and defines
    the location of the view in its superview's coordinate system, in our case the
    main window, and its size in points.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Interface Builder 添加的视图在运行时首次实例化时，它会通过**检查器**窗口的**大小**选项卡设置其`Frame`属性。`Frame`属性的类型是`RectangleF`，它定义了视图在其父视图的坐标系中的位置，在我们的例子中是主窗口，以及其大小以点为单位。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Objective-C, the `Frame` property of `UIView` is of the type `CGRect`. This
    type has not been bound in MonoTouch, and the more familiar `System.Drawing.RectangleF`
    was used instead.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Objective-C中，`UIView`的`Frame`属性是`CGRect`类型。这个类型在MonoTouch中没有绑定，而是使用了更熟悉的`System.Drawing.RectangleF`。
- en: A superview is a view's parent view, while subviews are its child views. Views
    that have the same superview are described as siblings.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 父视图是一个视图的父视图，而子视图是其子视图。具有相同父视图的视图被称为兄弟视图。
- en: The default coordinate system in iOS originates from the top-left corner and
    extends towards the bottom and the right. The coordinate origin is always the
    same and cannot be changed programmatically.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的默认坐标系起源于左上角，并向底部和右侧延伸。坐标系的原点始终相同，并且不能通过编程方式更改。
- en: 'The coordinate system of iOS is displayed in the following image:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: iOS的坐标系在以下图像中显示：
- en: '![How it works...](img/1468EXP_02_02.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_02_02.jpg)'
- en: When the `Frame` property is set, it adjusts the `Bounds` property. The `Bounds`
    property defines the location of the view in its own coordinate system and its
    size in points. It is also of the type `RectangleF`. The default location for
    the `Bounds` property is `(0,0)`, and its size is always the same as the view's
    `Frame` value. Both these properties' sizes are connected to each other, so when
    you change the size of the `Frame`, the size of the `Bounds` changes accordingly
    and vice versa. You can change the `Bounds` property to display different parts
    of the view. A view's `Frame` can exceed the screen in both location and position.
    That is to say that a view's frame with values (x = -50, y = -50, width = 1500,
    height = 1500) is perfectly acceptable.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当设置`Frame`属性时，它会调整`Bounds`属性。`Bounds`属性定义了视图在其自身坐标系中的位置以及其大小以点为单位。它也是`RectangleF`类型。`Bounds`属性的默认位置是`(0,0)`，其大小始终与视图的`Frame`值相同。这两个属性的尺寸相互关联，因此当您更改`Frame`的大小，`Bounds`的大小也会相应地更改，反之亦然。您可以将`Bounds`属性更改为显示视图的不同部分。视图的`Frame`可以在位置和位置上超出屏幕。也就是说，具有值（x
    = -50, y = -50, width = 1500, height = 1500）的视图框架是完全可接受的。
- en: There's more...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Another thing to note is that the `UIView` class inherits from `UIResponder`.
    The `UIResponder` class is responsible for responding to and handling events.
    When a view is added to another view, it becomes part of its responder chain.
    The `UIView` class exposes the properties and methods of `UIResponder`, and the
    ones we are interested in describing for now are the following two:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，`UIView` 类继承自 `UIResponder`。`UIResponder` 类负责响应用和处理事件。当一个视图被添加到另一个视图中时，它成为其响应链的一部分。`UIView`
    类公开了 `UIResponder` 的属性和方法，我们现在感兴趣描述的是以下两个：
- en: '`IsFirstResponder` **property:** It returns a boolean value indicating whether
    the view is the first responder. Basically, it indicates if the view has focus.'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`IsFirstResponder` **属性**：它返回一个布尔值，指示视图是否是第一个响应者。基本上，它表示视图是否有焦点。'
- en: '`ResignFirstResponder():` It causes the view to lose focus.'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ResignFirstResponder():` 它会导致视图失去焦点。'
- en: Adding views programmatically
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式添加视图
- en: 'If we would like to add a view programmatically, we would use the `UIView.AddSubview(UIView)`
    method:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想以编程方式添加视图，我们将使用 `UIView.AddSubview(UIView)` 方法：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `AddSubview()` method adds its parameter, which is of the type `UIView`,
    to the list of the caller's subviews and sets its `Superview` parameter to the
    caller. A view will not be displayed unless it is added to a parent view with
    the `AddSubview()` method. Also, if a view already has a superview and it is added
    to another view with its `AddSubview()` method, then its `Superview` is changed
    to that of the new caller. What this means is that a view can only have only one
    superview each time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddSubview()` 方法将其参数（类型为 `UIView`）添加到调用者的子视图列表中，并将其 `Superview` 参数设置为调用者。除非使用
    `AddSubview()` 方法将其添加到父视图中，否则视图将不会显示。此外，如果视图已经有一个父视图，并且使用其 `AddSubview()` 方法添加到另一个视图中，则其
    `Superview` 将更改为新调用者的 `Superview`。这意味着视图每次只能有一个父视图。'
- en: Note
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When adding a view as a subview with Interface Builder, it is not required to
    use the `AddSubview()` method to display the subview. It is required to call the
    `AddSubview()` method, however, when adding views programmatically.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Interface Builder 添加视图作为子视图时，不需要使用 `AddSubview()` 方法来显示子视图。但是，当以编程方式添加视图时，必须调用
    `AddSubview()` 方法。
- en: For removing a view from its superview programmatically, call its `RemoveFromSuperview()`
    method. Calling this method on a view, which has no superview, does nothing. Care
    must be taken when we want to reuse the view we want to remove. We must keep a
    reference to it, or it might be released after the method is called.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以编程方式从父视图中移除视图，请调用其 `RemoveFromSuperview()` 方法。如果对没有父视图的视图调用此方法，则没有任何作用。当我们想要重用要删除的视图时，必须注意。我们必须保留对其的引用，否则在方法调用后它可能会被释放。
- en: View content layout
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图内容布局
- en: Another important property of `UIView` is `ContentMode. ContentMode` accepts
    values of the enumeration type `UIViewContentMode`. This property sets how the
    `UIView` will display its content. The default value of this property is `UIViewContentMode.ScaleToFill`,
    which scales the content to fit the exact view's size, distorting it if necessary.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIView` 的另一个重要属性是 `ContentMode`。`ContentMode` 接受枚举类型 `UIViewContentMode` 的值。此属性设置
    `UIView` 如何显示其内容。此属性的默认值是 `UIViewContentMode.ScaleToFill`，它将内容缩放到与视图大小完全匹配，如果需要则进行扭曲。'
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating a custom view*'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义视图*'
- en: 'In this book:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), Accessing the UI with
    Outlets.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "Chapter 1. Development Tools")，通过输出口访问 UI。'
- en: '*Creating the UI*'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 UI*'
- en: '*Accessing the UI with outlets*'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过输出口访问 UI*'
- en: 'Chapter 3, *User Interface: View Controllers:*'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 第 3 章，*用户界面：视图控制器：*
- en: '*View controllers* and *views*'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图控制器* 和 *视图*'
- en: Receiving user input with buttons
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用按钮接收用户输入
- en: In this recipe, we will learn how to use buttons to receive and respond to user
    input.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用按钮接收和响应用户输入。
- en: Getting ready
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We used buttons in [Chapter 1](ch01.html "Chapter 1. Development Tools"), *Accessing
    the UI with Outlets* to discuss how to use Interface Builder to add controls to
    the user interface. In this task, we will describe the `UIButton` class in more
    detail. Open the project `FirstViewApp` that we created in the previous task in
    MonoDevelop. Increase the main view's height to cover the entire screen in Interface
    Builder, and save the document.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 1 章](ch01.html "第 1 章。使用接口访问 UI") 中使用了按钮，讨论了如何使用 Interface Builder 向用户界面添加控件。在这个任务中，我们将更详细地描述
    `UIButton` 类。在 MonoDevelop 中打开我们在上一个任务中创建的 `FirstViewApp` 项目。将主视图的高度增加到在 Interface
    Builder 中覆盖整个屏幕，并保存文档。
- en: How to do it...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will programmatically add a button in our interface that will change our
    view's background color when tapped.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在界面中程序化地添加一个按钮，当它被轻触时，将改变视图的背景颜色。
- en: 'Open the `FirstViewAppViewController.cs` file, and enter the following code
    in the class::'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `FirstViewAppViewController.cs` 文件，并在类中输入以下代码：
- en: '[PRE1]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And in the `ViewDidLoad()` method, add the following line:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad()` 方法中，添加以下行：
- en: '[PRE2]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Compile and run the application on the simulator. When the button is tapped,
    the result should be similar to the following screenshot:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。当按钮被轻触时，结果应类似于以下截图：
- en: '![How to do it...](img/1468EXP_02_03.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1468EXP_02_03.jpg)'
- en: How it works...
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this task, we have added a button to the user interface that changes the
    background color of the superview. Furthermore, we have accomplished this without
    using Interface Builder at all.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们向用户界面添加了一个按钮，该按钮会改变父视图的背景颜色。此外，我们没有使用任何 Interface Builder 就完成了这个任务。
- en: Let's now see what the code does.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码是如何工作的。
- en: 'We create a field that will hold the button object:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个将保存按钮对象的字段：
- en: '[PRE3]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the `CreateButton()` method, we create the button and set some properties.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreateButton()` 方法中，我们创建按钮并设置一些属性。
- en: '[PRE4]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'First, we assign the view''s `Frame` to a new variable named `viewFrame`. Then,
    we create a new `RectangleF` object named `buttonFrame`, which will be assigned
    to the button''s `Frame` property. Now that we have a frame for our button, we
    can initialize it, as shown in the following code snippet:'
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将视图的 `Frame` 分配给一个名为 `viewFrame` 的新变量。然后，我们创建一个名为 `buttonFrame` 的新 `RectangleF`
    对象，它将被分配给按钮的 `Frame` 属性。现在我们为按钮有了框架，我们可以初始化它，如下面的代码片段所示：
- en: '[PRE5]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The button is initialized with the static method `UIButton.FromType(UIButtonType)`.
    This method takes one parameter of the type `UIButtonType` and returns predefined
    types of buttons that are included in iOS SDK. The `UIButtonType.RoundedRect`
    button enumeration value, used here, is the default type of iOS button with rounded
    corners. After the `buttonChangeColor` object is initialized, we set its `Frame`
    to the `RectangleF` value we created previously.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按钮是通过静态方法 `UIButton.FromType(UIButtonType)` 初始化的。此方法接受一个 `UIButtonType` 类型的参数，并返回
    iOS SDK 中包含的预定义按钮类型。这里使用的 `UIButtonType.RoundedRect` 按钮枚举值是 iOS 按钮的默认类型，具有圆角。在
    `buttonChangeColor` 对象初始化后，我们将它的 `Frame` 设置为我们之前创建的 `RectangleF` 值。
- en: 'Now that we have provided initialization code for the button, we will set its
    titles (that''s right, more than one):'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经为按钮提供了初始化代码，我们将设置其标题（没错，不止一个）：
- en: '[PRE6]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We call the `UIButton.SetTitle(string, UIControlState)` method twice. This
    method is responsible for setting the button''s title for each given button state.
    The string parameter is the actual title that will be shown. The second parameter
    is an enumeration of the type UIControlState that indicates the different control
    states that apply to controls. These control states are:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们调用了 `UIButton.SetTitle(string, UIControlState)` 方法两次。此方法负责为每个给定的按钮状态设置按钮的标题。字符串参数是实际要显示的标题。第二个参数是表示应用于控件的不同控件状态的
    `UIControlState` 类型的枚举。这些控件状态是：
- en: '`Normal:` The default idle state of an enabled control'
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Normal:` 启用控件的默认空闲状态'
- en: '`Highlighted:` The state of the control when a touch-up event occurs'
  id: totrans-101
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Highlighted:` 控件在触摸事件发生时的状态'
- en: '`Disabled:` The control is disabled and does not accept any events'
  id: totrans-102
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Disabled:` 控件被禁用且不接受任何事件'
- en: '`Selected:` The control is selected. In most cases, this state does not apply.
    It is useful, however, when a selection state is required, such as in a `UISegmentedControl`
    object'
  id: totrans-103
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Selected:` 控件已被选中。在大多数情况下，此状态不适用。然而，当需要选择状态时，例如在 `UISegmentedControl` 对象中，它是有用的。'
- en: '`Application:` An additional control state values for application use'
  id: totrans-104
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Application:` 用于应用程序用途的附加控件状态值'
- en: '`Reserved:` For internal framework use'
  id: totrans-105
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Reserved:` 用于内部框架使用'
- en: So, with the method `UIButton.SetTitle(string, UIControlState)` , we have set
    the title that will be displayed when the button is in its default state and the
    title that will be displayed while it is being tapped.
  id: totrans-106
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，使用 `UIButton.SetTitle(string, UIControlState)` 方法，我们设置了按钮在其默认状态下显示的标题以及在被点击时显示的标题。
- en: After that, we set the button's handler for the `TouchUpInside` event, and add
    it as a subview to the `subView:`
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们设置按钮的 `TouchUpInside` 事件处理程序，并将其添加为 `subView:` 的子视图
- en: '[PRE7]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `buttonChangeColor_TouchUpInside` event, we change the background
    color of the view, according to the boolean field that we have declared:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `buttonChangeColor_TouchUpInside` 事件中，我们根据我们声明的布尔字段更改视图的背景颜色：
- en: '[PRE8]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This is done by setting the view's `BackgroundColor` property to the appropriate
    `UIColor` class instance we want, as shown in the highlighted code previously.
    The `UIColor` object is a class with many different static methods and properties
    that allow us to create different color objects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过将视图的 `BackgroundColor` 属性设置为所需的 `UIColor` 类实例来完成的，如之前突出显示的代码所示。`UIColor`
    对象是一个具有许多不同静态方法和属性的类，允许我们创建不同的颜色对象。
- en: When you compile and run the application on the simulator, notice not only the
    view's color change when you tap the button, but also how the button's title changes
    while the mouse cursor (or finger on the device) is touching the button.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在模拟器上编译并运行应用程序时，请注意当你点击按钮时视图的颜色变化，以及当鼠标光标（或设备上的手指）接触按钮时按钮标题的变化。
- en: There's more...
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: 'In this task, we used the `UIButton.FromType(UIButtonType)` static method to
    initialize the button. A brief description of each of the enumeration flags of
    `UIButtonType` is as follows:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们使用了 `UIButton.FromType(UIButtonType)` 静态方法来初始化按钮。以下是 `UIButtonType`
    枚举标志的简要描述：
- en: '`Custom:` It''s a borderless transparent button. Use this flag when creating
    custom buttons with images as backgrounds. The button''s title is not transparent.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Custom:` 它是一个无边框的透明按钮。在创建具有图像背景的自定义按钮时使用此标志。按钮的标题不是透明的。'
- en: '`RoundedRect:` It''s the default type of button with rounded corners.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RoundedRect:` 它是具有圆角按钮的默认类型。'
- en: '`DetailDisclosure:` It''s a round blue button that reveals additional information
    related to an item.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DetailDisclosure:` 它是一个圆形的蓝色按钮，用于显示与项目相关的附加信息。'
- en: '`InfoLight:` It''s a light-colored button with the letter (i), representing
    information display.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InfoLight:` 它是一个带有字母（i）的浅色按钮，代表信息显示。'
- en: '`InfoDark:` It''s the same as `InfoLight`, shown with dark color.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InfoDark:` 它与 `InfoLight` 相同，以深色显示。'
- en: '`ContactAdd:` It''s a round blue button with a white plus sign (+). Usually
    displayed to present contact information to add to an item.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContactAdd:` 它是一个带有白色加号（+）的圆形蓝色按钮。通常用于显示要添加到项目中的联系信息。'
- en: Creating custom buttons
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义按钮
- en: For creating custom buttons with the type `UIButtonType.Custom`, use the `UIButton`
    class' `SetBackgroundImage()` and `SetImage()` methods. They both accept one `UIImage`
    and one `UIControlState` parameters, so that different images for different control
    states can be set. When setting images for buttons, whether creating a custom
    button or not, be sure to set the `UIButton.ContentMode` property accordingly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建具有类型 `UIButtonType.Custom` 的自定义按钮，请使用 `UIButton` 类的 `SetBackgroundImage()`
    和 `SetImage()` 方法。它们都接受一个 `UIImage` 和一个 `UIControlState` 参数，因此可以为不同的控件状态设置不同的图像。在设置按钮的图像时，无论是创建自定义按钮还是不是，务必相应地设置
    `UIButton.ContentMode` 属性。
- en: 'The functionality provided by the methods `SetImage` and `SetBackgroundImage`
    can also be accomplished in the corresponding **Image** and **Background** fields
    in the **Attributes** tab of the **Inspector** pad in Interface Builder. Select
    the state for which to set the desired image(s) from the drop-down list box, and
    set the path to the image file, as shown in the following screenshot:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetImage` 和 `SetBackgroundImage` 方法提供的功能也可以在 Interface Builder 中 **Inspector**
    面板的 **Attributes** 选项卡的 **Image** 和 **Background** 字段中完成。从下拉列表框中选择要设置所需图像的状态，并设置图像文件的路径，如下面的屏幕截图所示：'
- en: '![Creating custom buttons](img/1468EXP_02_04.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![创建自定义按钮](img/1468EXP_02_04.jpg)'
- en: See also
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Adding and customizing views*'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: '*Displaying images*'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像*'
- en: '*Creating a custom view*'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建自定义视图*'
- en: 'In this book:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), *Development Tools:*'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。开发工具"), *开发工具:*'
- en: '*Creating the UI*,'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建UI*,'
- en: '*Accessing the UI with Outlets*'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过Outlets访问UI*'
- en: Using labels to display text
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用标签显示文本
- en: In this recipe, we will learn how to display informative text to the user with
    labels.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用标签向用户显示信息文本。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will describe the `UILabel` class in more detail. Once again,
    all of the work will be done without the help of Interface Builder. Open the project
    `FirstViewApp` that we modified in the previous recipe in MonoDevelop.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将更详细地描述`UILabel`类。再次强调，所有的工作都将在没有Interface Builder的帮助下完成。打开我们在上一个菜谱中修改的`FirstViewApp`项目。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We will programmatically create a label, which will display some static guidance
    text.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将程序化地创建一个标签，该标签将显示一些静态的指导文本。
- en: 'Open the file `FirstViewAppViewcontroller.cs`, and enter the following code
    in the class:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开文件`FirstViewAppViewcontroller.cs`，并在类中输入以下代码：
- en: '[PRE9]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And in the `FinishedLaunching()` method, add the following line:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`FinishedLaunching()`方法中添加以下行：
- en: '[PRE10]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compile and run the application on the simulator. The output should look like
    the following screenshot:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。输出应该看起来像以下截图：
- en: '![How to do it...](img/1468EXP_02_05.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到这一点...](img/1468EXP_02_05.jpg)'
- en: How it works...
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have successfully created a label and put some information text in it. Let's
    step through the code and see what actually goes on.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个标签，并在其中放入了一些信息文本。让我们逐步查看代码，看看实际上发生了什么。
- en: We first create the `labelInfo` field that will hold our `UILabel` object in
    the `FirstViewAppViewController` class.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先在`FirstViewAppViewController`类中创建一个`labelInfo`字段，用于存储我们的`UILabel`对象。
- en: '[PRE11]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We then create the method `CreateLabel()`, which will instantiate and customize
    the label. Like the button we created in the previous task, our label needs a
    frame. So, we create one, again depending on the view''s `Frame` property:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建了一个名为`CreateLabel()`的方法，该方法将实例化和定制标签。就像我们在上一个任务中创建的按钮一样，我们的标签需要一个框架。因此，我们再次创建一个，这取决于视图的`Frame`属性：
- en: '[PRE12]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We just set its height to be higher than the button''s, to `100` points. Now
    that we have a `Frame` for the label, we initialize it:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们只需将其高度设置为高于按钮的高度，即`100`点。现在我们已经为标签有了`Frame`，我们初始化它：
- en: '[PRE13]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The constructor is used, so that the Frame property will be set immediately
    upon initialization. The Lines property determines the total number of lines the
    text on the label text will be divided to. The TextAlignment property accepts
    values of the enumeration type UITextAlignment, which contains the usual text
    alignment flags: Center, Left, and Right. To make the Frame of the label completely
    invisible, so that only our text will be visible, we set the BackgroundColor property
    to the color UIColor.Clear.'
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构造函数被使用，这样框架属性将在初始化时立即设置。行属性决定了标签文本上的文本将被分成多少行。文本对齐属性接受枚举类型`UITextAlignment`的值，它包含常用的文本对齐标志：居中、左对齐和右对齐。为了使标签的框架完全不可见，以便只有我们的文本可见，我们将`BackgroundColor`属性设置为`UIColor.Clear`颜色。
- en: 'The next part is quite interesting. Apart from being able to set the font color
    of the `label`, we can also set a shadow at the displayed text:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个部分非常有趣。除了能够设置`label`的字体颜色外，我们还可以为显示的文本设置阴影：
- en: '[PRE14]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The TextColor property accepts `UIColor` values. To set a shadow for the text
    of the label, set a UIColor to the ShadowColor property. Then, set a SizeF structure
    to the ShadowOffset property. This property determines the exact location of the
    shadow. The width parameter of SizeF defines the horizontal placement of the shadow,
    and the height parameter defines the vertical placement. Negative values are acceptable.
    A negative value for width means that the shadow will be positioned towards the
    left, while a negative value for the height means that the shadow will be positioned
    above the text. The value we have set in the previous code means that the shadow
    will be displayed 1 point to the right and 1 point below the text.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TextColor`属性接受`UIColor`值。要为标签的文本设置阴影，将`UIColor`设置到`ShadowColor`属性。然后，将`SizeF`结构设置到`ShadowOffset`属性。此属性决定了阴影的确切位置。`SizeF`的宽度参数定义了阴影的水平位置，而高度参数定义了垂直位置。负值是可以接受的。宽度参数的负值意味着阴影将定位在文本的左侧，而高度参数的负值意味着阴影将定位在文本上方。我们在前面的代码中设置的值意味着阴影将显示在文本右侧1点，下方1点。'
- en: 'We have prepared how the `label` will render its text. To assign the text the
    `label` will display, set its `Text` property:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经准备好了`label`如何渲染其文本。要分配`label`将显示的文本，设置其`Text`属性：
- en: '[PRE15]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'As you can see, we have defined quite a long string for the `label` to display.
    Finally, add the `label` to the view to be displayed:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们为 `label` 定义了一个相当长的字符串以供显示。最后，将 `label` 添加到要显示的视图中：
- en: '[PRE16]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code gives the result shown in the *How to do it* section of this task.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码给出了本任务 *如何做* 部分所示的结果。
- en: There's more...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In the previous code, there is also one more line of code, which is commented
    out:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，还有一行注释掉的代码：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `AdjustsFontSizeToFitWidth` property accepts a boolean value. If set to
    `true`, it instructs the `label` to automatically change the font size so that
    it can fit inside the width of the `label`. Setting this property to `true` has
    absolutely no effect if the `label` supports more than one line. So, just to see
    how this property works, uncomment it and set the `Lines` property to `1`. The
    result will look similar to the following:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AdjustsFontSizeToFitWidth` 属性接受一个布尔值。如果设置为 `true`，则指示 `label` 自动更改字体大小，以便它能够适应
    `label` 的宽度。如果 `label` 支持多行，则将此属性设置为 `true` 完全没有效果。所以，为了看看这个属性是如何工作的，取消注释它并将 `Lines`
    属性设置为 `1`。结果将类似于以下内容：'
- en: '![There''s more...](img/1468EXP_02_06.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/1468EXP_02_06.jpg)'
- en: As you can see, the text on the `label` needs a magnifying glass to read, so
    it does not work for us properly here. The `AdjustsFontSizeToFitWidth` property,
    however, is very useful when there is limited space for the width of the `label`
    on the screen and we want our text to fit that space. To prevent a situation like
    this, set the `MinimumFontSize` property to the desired value. Just as its name
    suggests, the size of the font will not be smaller than this property's value.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`label` 上的文本需要放大镜才能阅读，所以在这里它不能正常工作。然而，当屏幕上 `label` 的宽度有限且我们希望文本适应该空间时，`AdjustsFontSizeToFitWidth`
    属性非常有用。为了防止这种情况，将 `MinimumFontSize` 属性设置为所需的值。正如其名称所暗示的，字体的大小不会小于此属性的值。
- en: UILabel fonts
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UILabel` 字体'
- en: 'Setting the font of the displayed text in a `label` is easy. Set its `Font`
    property with the `UIFont.FromName(string, float)` static method. The `string`
    parameter represents the name of the font to set and can include both the font
    family and style, while the `float` parameter determines its size. For example,
    to set the font of the `label` to `Helvetica Bold`, call the following method:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `label` 中设置显示文本的字体很简单。使用 `UIFont.FromName(string, float)` 静态方法设置其 `Font` 属性。`string`
    参数表示要设置的字体名称，可以包括字体家族和样式，而 `float` 参数确定其大小。例如，要将 `label` 的字体设置为 `Helvetica Bold`，请调用以下方法：
- en: '[PRE18]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'If the font name is not found, the `FromName` static method returns `null`.
    Care must be taken for this, since when the `UILabel.Font` property is set to
    `null`, an exception will occur. The available styles for a font family can be
    determined by calling the `UIFont.FontNamesForFamilyName(string)` method, which
    returns a `string[]` containing all the available font styles. If the `Helvetica`
    font family is passed to this method, it will return a `string[]` with the following
    items:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 如果找不到字体名称，`FromName` 静态方法将返回 `null`。对此必须小心，因为当 `UILabel.Font` 属性被设置为 `null`
    时，将会抛出异常。可以通过调用 `UIFont.FontNamesForFamilyName(string)` 方法来确定字体家族的可用样式，该方法返回一个包含所有可用字体的
    `string[]` 数组。如果将 `Helvetica` 字体家族传递给此方法，它将返回一个包含以下项的 `string[]` 数组：
- en: Helvetica-BoldOblique
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Helvetica-BoldOblique
- en: Helvetica
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Helvetica
- en: Helvetica-Bold
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Helvetica-Bold
- en: Helvetica-Oblique
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Helvetica-Oblique
- en: See also
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying and editing text*'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本*'
- en: 'In this book:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"), Accessing the UI with
    Outlets:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具"), 使用连接访问 UI：'
- en: '*Creating the UI*'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 UI*'
- en: '*Chapter 11, Graphics and Animation:*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*第 11 章，图形和动画：*'
- en: '*Display blinking text*'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示闪烁的文本*'
- en: Displaying images
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示图片
- en: In this recipe, we will learn how to use the `UIImageView` class to display
    images on screen.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 `UIImageView` 类在屏幕上显示图片。
- en: Getting ready
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will see how to bundle and display images in a project. An
    image file will be needed for display. The image file used here is named `Toroni.jpg`.
    Create a new **iPhone Single View Application** project in MonoDevelop, and name
    it `ImageViewerApp`.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将了解如何在项目中打包和显示图片。显示需要使用一个图片文件。这里使用的图片文件名为 `Toroni.jpg`。在 MonoDevelop
    中创建一个新的 **iPhone 单视图应用程序** 项目，并将其命名为 `ImageViewerApp`。
- en: How to do it...
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Open the `ImageViewerAppViewController.xib` file in Interface Builder.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `ImageViewerAppViewController.xib` 文件。
- en: Add a `UIImageView` object on its view. Connect the `UIImageView` object with
    an outlet named `imageDisplay`.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图中添加一个`UIImageView`对象。将`UIImageView`对象与名为`imageDisplay`的出口连接。
- en: Save the document.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in MonoDevelop, in the `ImageViewerAppViewController` class, enter the
    following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到MonoDevelop，在`ImageViewerAppViewController`类中，输入以下代码：
- en: '[PRE19]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Right-click on the project in the **Solution** pad and select **Add | Add Files**.
    Select the image file you want to display, and click on **Open**.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中右键单击项目，然后选择**添加 | 添加文件**。选择要显示的图像文件，然后单击**打开**。
- en: Right-click on the image file you have just added, and click on **Build Action
    | Content**.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击您刚刚添加的图像文件，然后单击**构建操作 | 内容**。
- en: 'Finally, compile and run the application on the simulator. The image you added
    to the project should be displayed on the screen, as shown in the following Image:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在模拟器上编译并运行应用程序。您添加到项目中的图像应显示在屏幕上，如下面的图像所示：
- en: '![How to do it...](img/1468EXP_02_07.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/1468EXP_02_07.jpg)'
- en: How it works...
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The `UIImageView` class is basically a view customized for displaying images.
    When adding an image in a project, its **Build Action** must be set to **Content**
    in the **Solution** pad, otherwise the image will not be copied into the application
    bundle.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView`类基本上是一个用于显示图像的自定义视图。在项目中添加图像时，其**构建操作**必须在**解决方案**面板中设置为**内容**，否则图像将不会复制到应用程序包中。'
- en: 'The `ContentMode` property is very important when displaying images. It sets
    the way the `UIView` (UIImageView, in this case) object will display the image.
    We have set it to `UIViewContentMode.ScaleAspectFit`, so that it will be resized
    to fit the area of `UIImageView`, keeping the aspect ratio intact at the same
    time. If the `ContentMode` field was left at its default `Scale To Fill` value,
    the output would be something like the following Image:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当显示图像时，`ContentMode`属性非常重要。它设置`UIView`（在这种情况下为`UIImageView`）对象显示图像的方式。我们将其设置为`UIViewContentMode.ScaleAspectFit`，这样它将被调整大小以适应`UIImageView`的区域，同时保持宽高比不变。如果`ContentMode`字段保留为默认的`Scale
    To Fill`值，输出将类似于以下图像：
- en: '![How it works...](img/1468EXP_02_08.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1468EXP_02_08.jpg)'
- en: 'To set the image that the `UIImageView` should display, we set its `Image`
    property with a `UIImage` object:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置`UIImageView`应显示的图像，我们使用`UIImage`对象设置其`Image`属性：
- en: '[PRE20]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `ContentMode` property accepts an enumeration type named `UIViewContentMode`.
    The values provided are:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentMode`属性接受一个名为`UIViewContentMode`的枚举类型。提供的值如下：'
- en: '**ScaleToFill:** This is the default value of the base **UIView** object. It
    scales the content to fit the size of the view, changing the aspect ratio as necessary.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充以适应**：这是基本**UIView**对象的默认值。它将内容缩放到适合视图的大小，必要时更改宽高比。'
- en: '**ScaleAspectFit:** It scales the content to fit the size of the view, maintaining
    its aspect ratio. The remaining area of the view''s content becomes transparent.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放以适应视图**：将内容缩放到适合视图的大小，同时保持其宽高比。视图内容剩余区域变为透明。'
- en: '**ScaleAspectFill:** Scales the content to fill the size of the view, maintaining
    its aspect ratio. Some part of the content may be left out.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充以适应视图**：将内容缩放到填充视图的大小，同时保持其宽高比。内容的一些部分可能被省略。'
- en: '**Redraw:** When a view''s bounds are changed, its content is not redrawn.
    This value causes the content to be redrawn. Drawing content is an expensive operation
    in terms of CPU cycles, so think twice before using this value with large contents.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重绘**：当视图的边界发生变化时，其内容不会被重绘。此值会导致内容被重绘。在CPU周期方面，绘制内容是一项昂贵的操作，因此在使用此值之前请三思，特别是对于大量内容。'
- en: '**Center:** Places the content at the center of the view, keeping its aspect
    ratio.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中心**：将内容放置在视图的中心，保持其宽高比。'
- en: '**Top, Bottom, Left, Right, TopLeft, TopRight, BottomLeft**, and **BottomRight:**
    Aligns the content in the view, with the corresponding value.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶部、底部、左侧、右侧、左上角、右上角、左下角**和**右下角**：根据相应的值在视图中对齐内容。'
- en: There's more...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The `UIImage` class is the object that represents image information. The file
    formats it supports are listed in the following table:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImage`类是表示图像信息的对象。它支持的文件格式列在以下表中：'
- en: '| File Format | File Extension |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 文件格式 | 文件扩展名 |'
- en: '| --- | --- |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Portable Network Graphics (PNG) | .png |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '| 可移植网络图形 (PNG) | .png |'
- en: '| Joint Photographic Experts Group (JPEG) | .jpg, .jpeg |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| 联合图像专家小组 (JPEG) | .jpg, .jpeg |'
- en: '| Tagged Image File Format (TIFF) | .tiff, .tif |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| 标记图像文件格式 (TIFF) | .tiff, .tif |'
- en: '| Graphic Interchange Format | .gif |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 图像交换格式 | .gif |'
- en: '| Windows Bitmap Format | .bmp |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| Windows 位图格式 | .bmp |'
- en: '| Windows Icon Format | .ico |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| Windows 图标格式 | .ico |'
- en: '| Windows Cursor | .cur |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| Windows 光标 | .cur |'
- en: '| XWindow bitmap | .xbm |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '| XWindow 位图 | .xbm |'
- en: Note
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Animated GIF image files are not supported by the `UIImageView` class. When
    an animated GIF is set to the `Image` property of a `UIImageView`, only its first
    frame will be displayed.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImageView` 类不支持动画 GIF 图像文件。当动画 GIF 设置为 `UIImageView` 的 `Image` 属性时，只会显示其第一帧。'
- en: Using images for different screen sizes
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用不同屏幕尺寸的图像
- en: Creating images for backgrounds provides developers with the ability to produce
    rich and elegant user interfaces for their applications. The preferred image file
    format for creating backgrounds for views is `PNG`. But, since the iPhone 4 was
    released, the screen resolution was increased. To support both screen resolutions
    in an application, the iOS SDK provides an easy solution. Just save the image
    in the higher resolution and add a `@2x` suffix to the filename, just before the
    extension. For example, the name of a higher resolution version of a file named
    `Default.png` would be `Default@2x.png`. Also, no extra code is required to use
    both files.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 为背景创建图像为开发者提供了制作丰富和优雅的用户界面的能力。创建视图背景的首选图像文件格式是 `PNG`。但是，自从 iPhone 4 发布以来，屏幕分辨率提高了。为了在应用程序中支持两种屏幕分辨率，iOS
    SDK 提供了一个简单的解决方案。只需将图像保存为高分辨率，并在扩展名之前添加一个 `@2x` 后缀到文件名，例如，名为 `Default.png` 的文件的高分辨率版本将被命名为
    `Default@2x.png`。另外，使用这两个文件不需要额外的代码。
- en: Just use the `UIImage.FromBundle(string)` static method, passing the filename
    without extension, and iOS takes care of loading the appropriate file, depending
    on the device the application is running on.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 只需使用 `UIImage.FromBundle(string)` 静态方法，传递不带扩展名的文件名，iOS 会根据应用程序运行的设备加载适当的文件。
- en: '[PRE21]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The preceding only applies to PNG image files.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容仅适用于 PNG 图像文件。
- en: See also
  id: totrans-232
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章：
- en: '*Adding and customizing views*'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: 'In this book:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 7](ch07.html "Chapter 7. Multimedia Resources"),Multimedia Resources:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 7 章](ch07.html "第 7 章。多媒体资源")，多媒体资源：'
- en: '*Loading an Image*'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*加载图像*'
- en: Displaying and editing text
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示和编辑文本
- en: In this recipe, we will learn how to display simple text blocks with editing
    functionality.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何显示具有编辑功能的简单文本块。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will discuss the usage of `UITextView` and how to display editable
    text with it. Create a new **iPhone Single View Application** project in MonoDevelop,
    and name it `TextViewApp`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论 `UITextView` 的用法以及如何使用它显示可编辑文本。在 MonoDevelop 中创建一个新的 **iPhone 单视图应用程序**
    项目，并将其命名为 `TextViewApp`。
- en: How to do it...
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open `TextViewAppViewController.xib` in Interface Builder.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `TextViewAppViewController.xib`。
- en: Add a UIButton near the top of its view and a UITextView below it. Connect both
    objects to their outlets.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图的顶部附近添加一个 UIButton，在其下方添加一个 UITextView。将这两个对象连接到它们的出口。
- en: Save the document.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in MonoDevelop, enter the following `ViewDidLoad` method in the `TextViewAppViewController`
    class:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中，在 `TextViewAppViewController` 类中输入以下 `ViewDidLoad` 方法：
- en: '[PRE22]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Compile and run the application on the simulator.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap somewhere in the text view and the keyboard will appear. Type some text
    and then tap on the **Finished** button to hide the keyboard.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本视图中轻触某处，键盘就会出现。输入一些文本，然后轻触 **完成** 按钮以隐藏键盘。
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UITextView` class provides an object that displays editable blocks of
    text. To respond to the events of our text view, we have implemented a class that
    inherits from `UITextViewDelegate` that will act as the text view''s delegate:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITextView` 类提供了一个显示可编辑文本块的对象。为了响应用户文本视图中的事件，我们实现了一个继承自 `UITextViewDelegate`
    的类，该类将充当文本视图的代理：'
- en: '[PRE23]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We declared a constructor that accepts a `TextViewAppViewController` object,
    so that we can have an instance of our controller available to access our controls.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明了一个接受 `TextViewAppViewController` 对象的构造函数，这样我们就可以有一个控制器实例来访问我们的控件。
- en: 'Then, we override three methods of the `UITextViewDelegate` class:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们重写了 `UITextViewDelegate` 类的三个方法：
- en: '[PRE24]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: These methods are the handlers that will get called whenever a corresponding
    event is triggered. When tapping on the text, the `EditingStarted()` method gets
    called. We enable the **Finished** button in it. When we type some text in the
    text view, the `Changed()` method gets called, and we can see the output of the
    `Console.WriteLine()` method in MonoDevelop's **Application Output** pad. Finally,
    when we tap on the **Finished** button, the keyboard hides and the `EditingEnded()`
    method gets called that allows us to disable the button.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方法是在触发相应事件时将被调用的处理程序。当点击文本时，`EditingStarted()` 方法被调用。我们在其中启用 **完成** 按钮。当我们向文本视图中输入一些文本时，`Changed()`
    方法被调用，我们可以在 MonoDevelop 的 **应用程序输出** 面板中看到 `Console.WriteLine()` 方法的输出。最后，当我们点击
    **完成** 按钮时，键盘隐藏，并调用允许我们禁用按钮的 `EditingEnded()` 方法。
- en: 'In the `ViewDidLoad` method, we assign a handler to the `TouchUpInside` event
    of the button:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中，我们为按钮的 `TouchUpInside` 事件分配一个处理程序：
- en: '[PRE25]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We call the text view''s `ResignFirstResponder()` method in it so that when
    the button is tapped, the text view will lose focus, causing the keyboard to hide.
    Then, we assign a new instance of the delegate that we created to the text view''s
    `Delegate` property, passing the instance of the `TextViewAppViewController` object:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在它里面调用文本视图的 `ResignFirstResponder()` 方法，这样当按钮被点击时，文本视图将失去焦点，导致键盘隐藏。然后，我们将我们创建的委托的新实例分配给文本视图的
    `Delegate` 属性，传递 `TextViewAppViewController` 对象的实例：
- en: '[PRE26]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: There's more...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Delegates in Objective-C are somewhat different than delegates in C#. Although
    in both worlds their most common usage is to provide access to some form of event
    notification mechanism, in Objective-C this mechanism is a bit more complex. A
    C# delegate is much like a function pointer in C or C++ programming languages.
    It is an object that holds a reference to a method of a specific signature. On
    the other hand, an Objective-C delegate is a certain type of object that conforms
    to a specific protocol. It is basically an object that wraps one or more methods
    (and/or other members) that act as event handlers.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 中的委托与 C# 中的委托有所不同。尽管在两个世界中它们最常用的用途都是提供对某种形式的事件通知机制的访问，但在 Objective-C
    中，这种机制要复杂一些。C# 委托类似于 C 或 C++ 编程语言中的函数指针。它是一个包含对特定签名方法引用的对象。另一方面，Objective-C 委托是一种符合特定协议的对象。它基本上是一个封装了一个或多个方法（以及/或其它成员）作为事件处理器的对象。
- en: Note
  id: totrans-263
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An Objective-C protocol is similar to an interface in C#.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 协议类似于 C# 中的接口。
- en: The concept of Delegate objects might seem confusing at first, but it is not
    difficult to comprehend. Regarding the event notification mechanism, MonoTouch
    simplifies things for .NET developers by providing events for most objects.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 代理对象的概念一开始可能看起来有些复杂，但并不难理解。关于事件通知机制，MonoTouch 通过为大多数对象提供事件来简化了 .NET 开发者的工作。
- en: Note
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UITextView` class is suitable for displaying simple blocks of text, without
    formatting. For displaying formatted text, use the `UIWebView` class instead.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITextView` 类适合显示不带格式的简单文本块。对于显示格式化文本，请使用 `UIWebView` 类。'
- en: See also
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using the keyboard*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用键盘*'
- en: 'In this book:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 5](ch05.html "Chapter 5. Displaying Data"), Displaying Data:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](ch05.html "第 5 章。显示数据"), 显示数据：'
- en: '*Displaying and formatting text*'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '*显示和格式化文本*'
- en: Using the keyboard
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘
- en: In this recipe, we will discuss some important aspects of the virtual keyboard
    usage.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将讨论虚拟键盘使用的一些重要方面。
- en: Getting ready
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In the previous two tasks, we discussed the types of text input available. In
    this task, we will discuss some of the things we can, or even must, do to use
    the keyboard effectively. Create a new **iPhone Single View Application** project
    in MonoDevelop, and name it `KeyboardApp`.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两个任务中，我们讨论了可用的文本输入类型。在这个任务中，我们将讨论我们可以做的一些事情，甚至必须做的事情，以有效地使用键盘。在 MonoDevelop
    中创建一个新的 **iPhone 单视图应用程序** 项目，并将其命名为 `KeyboardApp`。
- en: How to do it...
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Follow these steps to create the project:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建项目：
- en: Open the `KeyboardAppViewController.xib` file in Interface Builder.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `KeyboardAppViewController.xib` 文件。
- en: Add a `UITextField` object in the bottom-half portion of the view and connect
    it to an outlet.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图的下半部分添加一个 `UITextField` 对象，并将其连接到一个出口。
- en: Save the document.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in MonoDevelop, enter the following code in the `KeyboardAppViewController`
    class:'
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 MonoDevelop，在 `KeyboardAppViewController` 类中输入以下代码：
- en: '[PRE27]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Compile and run the application on the simulator.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the text field and watch it moving upwards to avoid being hidden from
    the keyboard.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文本字段，并观察它向上移动以避免被键盘遮挡。
- en: Tap the **Done** button on the keyboard and watch the text field returning to
    its original position when the keyboard hides.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击键盘上的**完成**按钮，并观察当键盘隐藏时文本字段返回到其原始位置。
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: There are various types of keyboards in iOS. Since not all keys can be displayed
    at once due to the restricted screen size, it is good practice to set the appropriate
    type of keyboard, according to the text input we need the user to provide. In
    this project, we have set the keyboard to the **Email Address** type. We have
    also customized the type of the **Return** key by setting it to **Done**.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: iOS中有各种类型的键盘。由于屏幕尺寸有限，不能一次性显示所有键，因此根据我们需要用户提供的文本输入设置适当的键盘类型是一种良好的做法。在这个项目中，我们将键盘设置为**电子邮件地址**类型。我们还通过将其设置为**完成**来定制了**返回**键的类型。
- en: '[PRE28]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: When the keyboard is displayed, it is the developer's responsibility to make
    sure it does not obstruct essential UI elements. In this case, since we provide
    the user with the ability to enter some text input, we have to make sure that
    the text field is visible so the user will be able to see what is being typed.
    For this, we add two observers in the default notification center.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 当键盘显示时，开发者的责任是确保它不会遮挡必要的UI元素。在这种情况下，因为我们为用户提供了一些文本输入的能力，我们必须确保文本字段是可见的，以便用户可以看到正在输入的内容。为此，我们在默认的通知中心添加了两个观察者。
- en: '[PRE29]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: An `NSNotificationCenter` provides a notification mechanism for various notifications.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSNotificationCenter`为各种通知提供了一个通知机制。'
- en: 'We access the runtime''s default notification center through the `NSNotificationCenter.DefaultCenter`
    static property. An observer is added with the `AddObserver()` method, which accepts
    two parameters. The first parameter represents an `NSString` value, which informs
    the notification center of what type of notification to watch. The `UIKeyboard`
    class contains pre-defined static properties with the types of keyboard notifications
    we need. The `UIKeyboard.WillShowNotification` is passed, stating that the observer
    will observe and inform when the keyboard will be ready to appear. The second
    parameter is of the type `Action<NSNotification>` and represents the handler that
    will be executed when the notification occurs. Inside the `anonymous()` method,
    we call the `UIKeyboard.FrameEndNotification(NSNotification)` method that returns
    the keyboard''s bounds:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过`NSNotificationCenter.DefaultCenter`静态属性访问运行时的默认通知中心。使用`AddObserver()`方法添加了一个观察者，它接受两个参数。第一个参数是一个`NSString`值，它通知通知中心要观察哪种类型的通知。`UIKeyboard`类包含预定义的静态属性，具有我们需要的键盘通知类型。`UIKeyboard.WillShowNotification`被传递，表示观察者将在键盘准备好出现时进行观察并通知。第二个参数是`Action<NSNotification>`类型，表示当通知发生时将被执行的处理程序。在`anonymous()`方法内部，我们调用`UIKeyboard.FrameEndNotification(NSNotification)`方法，该方法返回键盘的边界：
- en: '[PRE30]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, we store the text field''s frame in a variable and reduce its `Y` position
    value so that the text field will move upwards:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将文本字段的框架存储在一个变量中，并减少其`Y`位置值，以便文本字段向上移动：
- en: '[PRE31]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the new frame is set to the `emailField`, it will move to the new position:'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 当新的框架设置为`emailField`时，它将移动到新的位置：
- en: '[PRE32]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The second observer is needed for moving the text field back to its original
    position. It is almost the same as the first observer, except for two differences.
    The `UIKeyboard.DidHideNotification NSString` is passed, instructing the observer
    to trigger the handler after the keyboard has been dismissed, and the `Y` value
    of the text field's frame is increased to make the text field return to its original
    position.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个观察者是为了将文本字段移回其原始位置。它与第一个观察者几乎相同，除了两个区别。传递了`UIKeyboard.DidHideNotification`字符串，指示观察者在键盘关闭后触发处理程序，并将文本字段框架的`Y`值增加，使文本字段返回到其原始位置。
- en: There's more...
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'The two fields of the type `NSObject` in the class hold information about the
    observers we added. For removing the two observers we have added here, add the
    following code:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 类中`NSObject`类型的两个字段包含有关我们添加的观察者的信息。为了移除我们在此处添加的两个观察者，请添加以下代码：
- en: '[PRE33]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-304
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Care must be taken when developing an application that uses the keyboard and
    supports multiple interface orientations. If, for example, the keyboard appears
    in portrait orientation and the user changes to landscape orientation, both the
    keyboard's bounds and the text field's frame will be different and must be adjusted
    accordingly.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发使用键盘并支持多种界面方向的应用程序时，必须小心。例如，如果键盘以纵向模式出现，而用户切换到横向模式，则键盘的边界和文本字段的框架都将不同，必须相应地进行调整。
- en: See also
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying and editing text*'
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本*'
- en: 'In this book:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 9](ch09.html "Chapter 9. Interacting with Device Hardware"),Interacting
    with Device Hardware:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 9 章](ch09.html "第 9 章。与设备硬件交互"),与设备硬件交互：'
- en: '*Rotating the device*'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旋转设备*'
- en: '*Adjusting the UI*'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调整用户界面*'
- en: Displaying progress
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示进度
- en: In this recipe, we will discuss how to display progress of a known length.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何显示已知长度的进度。
- en: Getting ready
  id: totrans-315
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this task, we will talk about the `UIProgressView` control. This control
    provides similar functionality to the **ProgressBar** in .NET. Create a **iPhone
    Single View Application** project in MonoDevelop, and name it `ProgressApp`.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论 `UIProgressView` 控件。此控件提供的功能类似于 .NET 中的 **ProgressBar**。在 MonoDevelop
    中创建一个 **iPhone 单视图应用程序** 项目，并将其命名为 `ProgressApp`。
- en: How to do it...
  id: totrans-317
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps for using the `UIProgressView` class. Note that in this
    recipe, we will add all controls programmatically, without the use of Interface
    Builder:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UIProgressView` 类的步骤如下。请注意，在本食谱中，我们将以编程方式添加所有控件，而不使用 Interface Builder：
- en: 'Add the following `using` directives in the `ProgressAppViewController` class
    file:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ProgressAppViewController` 类文件中添加以下 `using` 指令：
- en: '[PRE34]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following fields:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下字段：
- en: '[PRE35]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Enter the following code in the `ViewDidLoad` override:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 覆盖中输入以下代码：
- en: '[PRE36]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the following method in the class:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE37]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Compile and run the application on the simulator.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the button and watch the progress bar fill.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮并观察进度条填充。
- en: How it works...
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The current value of `UIProgressView` is represented by its `Progress` property.
    Its acceptable value range is always from `0` to `1`. So, when initializing it,
    we set it to `0` to make sure that the bar is not filled at all:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIProgressView` 的当前值由其 `Progress` 属性表示。其可接受值范围始终是从 `0` 到 `1`。因此，在初始化时，我们将它设置为
    `0` 以确保条形不会填充任何内容：'
- en: '[PRE38]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Since the `UIProgressView` has a specific range, we need to assign the value
    we want it to be incremented by, depending on the number of items we need to process,
    in this case `10:`
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UIProgressView` 有一个特定的范围，我们需要根据我们需要处理的项的数量分配我们想要增加的值，在这种情况下是 `10:`。
- en: '[PRE39]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the button''s `TouchUpInside` handler, we disable the button and start our
    progress by asynchronously invoking a method:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 在按钮的 `TouchUpInside` 处理程序中，我们禁用按钮并通过异步调用一个方法来开始我们的进度：
- en: '[PRE40]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the `StartProgress()` method, we start a loop that will process the work
    that needs to be done. Since the work executes in an asynchronous method, when
    we want to make changes to the controls, it must be done on the main UI thread
    by calling the `BeginInvokeOnMainThread()` method of `UIApplicationDelegate`,
    which accepts a parameter of the type `NSAction`. An `NSAction` can accept anonymous
    methods as well:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `StartProgress()` 方法中，我们启动一个循环，该循环将处理需要完成的工作。由于工作在异步方法中执行，当我们想要更改控件时，必须在主
    UI 线程上通过调用 `UIApplicationDelegate` 的 `BeginInvokeOnMainThread()` 方法来完成，该方法接受 `NSAction`
    类型的参数。`NSAction` 可以接受匿名方法：
- en: '[PRE41]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: There's more...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: The `UIProgressView` supports one more style other than the default. Set its
    `Style` property to `UIProgressViewStyle.Bar` so that the bar will look like the
    one in the Mail application when receiving new e-mails.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIProgressView` 支持除了默认样式之外的一种样式。将它的 `Style` 属性设置为 `UIProgressViewStyle.Bar`，这样条形就会像在接收新电子邮件时
    Mail 应用程序中的条形一样显示。'
- en: See also
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Receiving user input with buttons*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用按钮接收用户输入*'
- en: Displaying content larger than the screen
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示屏幕外的内容
- en: In this recipe, we will learn how to display content that extends beyond the
    screen's bounds.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何显示超出屏幕边界的内 容。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: In this task, we will discuss the `UIScrollView` control. Create an **iPhone
    Single View Application** project, and name it `ScrollApp`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个任务中，我们将讨论 `UIScrollView` 控件。创建一个 **iPhone 单视图应用程序** 项目，并将其命名为 `ScrollApp`。
- en: How to do it...
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create the project:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 创建项目的步骤如下：
- en: Open the `ScrollAppViewController.xib` file in Interface Builder.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `ScrollAppViewController.xib` 文件。
- en: Add a `UIScrollView` object on its view and connect it to an outlet. And save
    the document.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图中添加一个 `UIScrollView` 对象，并将其连接到一个出口。然后保存文档。
- en: 'Back in MonoDevelop, add the following code in the `ScrollAppViewController`
    class:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 MonoDevelop，在 `ScrollAppViewController` 类中添加以下代码：
- en: '[PRE42]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Finally, add an image to the project and set its **Build Action** to **Content**.
    An image larger than the simulator's screen, a size of **320x480** pixels, is
    preferable.
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将图像添加到项目中，并将其 **Build Action** 设置为 **Content**。一个比模拟器屏幕更大的图像，大小为 **320x480**
    像素，是首选的。
- en: Compile and run the application on the simulator. Tap-and-drag on the image
    to display different portions. By press *Alt* *+* mouse-click, you can simulate
    the pinch zooming function.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在图像上点击并拖动以显示不同的部分。通过按下 *Alt* *+* 鼠标点击，可以模拟捏合缩放功能。
- en: How it works...
  id: totrans-355
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UIScrollView` is capable of managing content that expands beyond the screen
    size. The size of the content the scroll view will display must be set in its
    `ContentSize` property:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIScrollView` 能够管理超出屏幕大小的内容。滚动视图将显示的内容大小必须在它的 `ContentSize` 属性中设置：'
- en: '[PRE43]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The `ContentOffset` property defines the position of the content inside the
    scroll view''s bounds:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentOffset` 属性定义了内容在滚动视图边界内的位置：'
- en: '[PRE44]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: What this means is that the image's (x=200, y=50) point will be displayed at
    the origin (x=0, y=0) of the `UIScrollView`. To provide zooming functionality
    for the content, we first set the `MinimumZoomScale` and `MaximumZoomScale` properties
    that set the minimum and maximum zoom scale for the content. A value of `2` means
    the content will be double in size, while a value of `0.5` means the content will
    be half the size.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着图像的 (x=200, y=50) 点将在 `UIScrollView` 的原点 (x=0, y=0) 处显示。为了提供内容的缩放功能，我们首先设置
    `MinimumZoomScale` 和 `MaximumZoomScale` 属性，这些属性设置了内容的缩放比例的最小值和最大值。值为 `2` 表示内容将是原来大小的两倍，而值为
    `0.5` 表示内容将是原来大小的一半。
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'For the actual zooming operation, we need to set the `ViewForZoomingInScrollView`
    property, which accepts a delegate of the type `UIScrollViewGetZoomView` and returns
    a `UIView`. Here, the image view we created is returned, but another higher resolution
    image view can be used instead to provide better image quality when zooming. After
    the delegate is assigned, the initial zoom scale is set:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 对于实际的缩放操作，我们需要设置 `ViewForZoomingInScrollView` 属性，它接受一个 `UIScrollViewGetZoomView`
    类型的代理并返回一个 `UIView`。在这里，我们返回创建的图像视图，但也可以使用另一个更高分辨率的图像视图来提供在缩放时更好的图像质量。在分配代理后，设置初始缩放比例：
- en: '[PRE46]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Finally, the scroll view''s indicator style is set:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，设置滚动视图的指示器样式：
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Indicators are the two lines that appear when scrolling or zooming: one on
    the vertical-right side and one on the horizontal-bottom side of the scroll view,
    which informs the user of the position of the content. Much like scroll bars.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 指示器是当滚动或缩放时出现的两条线：一条位于滚动视图的垂直右侧，另一条位于水平底部，它们告知用户内容的位置。与滚动条类似。
- en: There's more...
  id: totrans-367
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: To provide a more pleasing scrolling and zooming effect to the user, the `UIScrollView`
    exposes the `Bounce` property. By default, it is set to `true`, but we have the
    option to disable it by setting it to `false`. Bouncing the content gives immediate
    feedback to the user that the bounds of the content have been reached, in either
    a horizontal or vertical direction. Furthermore, the `AlwaysBounceHorizontal`
    and `AlwaysBounceVertical` properties can be set individually. Setting one or
    both of these properties will make the scroll view always bounce the content in
    each respective direction, even if the content is equal to or smaller than the
    scroll view's bounds. Hence, no actual scrolling is needed.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给用户提供更令人愉悦的滚动和缩放效果，`UIScrollView` 暴露了 `Bounce` 属性。默认情况下，它被设置为 `true`，但我们可以选择将其设置为
    `false` 来禁用它。当内容在水平或垂直方向上达到边界时，弹跳内容会立即给用户反馈，告知他们已经达到了边界。此外，可以单独设置 `AlwaysBounceHorizontal`
    和 `AlwaysBounceVertical` 属性。设置其中一个或两个这些属性将使滚动视图在相应的方向上始终弹跳内容，即使内容的大小等于或小于滚动视图的边界。因此，实际上并不需要滚动。
- en: UIScrollView events
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UIScrollView` 事件'
- en: 'The `UIScrollView` class exposes some very useful events:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIScrollView` 类公开了一些非常有用的事件：'
- en: '`Scrolled:` This event occurs while the content is being scrolled'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scrolled:` 当内容正在滚动时发生此事件'
- en: '`DecelerationStarted:` This event occurs when the user has started scrolling
    the content'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecelerationStarted:` 当用户开始滚动内容时发生此事件'
- en: '`DecelerationEnded:` This event occurs when the user has finished scrolling
    and the content has stopped moving'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecelerationEnded:` 当用户完成滚动并且内容停止移动时发生此事件'
- en: Note
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If a handler has been assigned to the `Scrolled` event, and the `ContentOffset`
    property is set, the event will be triggered.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已将处理程序分配给`Scrolled`事件，并且设置了`ContentOffset`属性，则将触发事件。
- en: See also
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying images*'
  id: totrans-378
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像*'
- en: '*Displaying and editing text*'
  id: totrans-379
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示和编辑文本*'
- en: '*Navigating through content divided into pages*'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在分页的内容中导航*'
- en: Navigating through content divided into pages
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在分页的内容中导航
- en: In this recipe, we will learn how to use the `UIPageControl` class to provide
    page navigation.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用`UIPageControl`类来实现页面导航。
- en: Getting ready
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UIPageControl` provides a simple visual representation of multiple pages
    or screens in an iOS app, indicated as dots. The dot that corresponds to the current
    page is highlighted. It is usually combined with the `UIScrollView`. Create a
    new **iPhone Single View Application** project in MonoDevelop, and name it `PageNavApp`.
    Add three image files in the project and set their **Build Action** to **Content**.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIPageControl`为iOS应用程序中的多个页面或屏幕提供了一个简单的视觉表示，以点表示。与当前页面相对应的点会被突出显示。它通常与`UIScrollView`结合使用。在MonoDevelop中创建一个新的**iPhone单视图应用程序**项目，并将其命名为`PageNavApp`。在项目中添加三个图像文件，并将它们的**构建操作**设置为**内容**。'
- en: How to do it...
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Here are the steps to create this project:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此项目的步骤如下：
- en: Open the `PageNavAppViewController.xib` file in Interface Builder.
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`PageNavAppViewController.xib`文件。
- en: Add a `UIPageControl` to the bottom of the view and `UIScrollView` above it.
    Resize the scroll view to take up all the remaining space of the view, and save
    the document.
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图底部添加一个`UIPageControl`，在其上方添加`UIScrollView`。调整滚动视图的大小以占用视图剩余的所有空间，并保存文档。
- en: 'Back in MonoDevelop, enter the following code in the `PageNavAppViewController`
    class:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到MonoDevelop中，在`PageNavAppViewController`类中输入以下代码：
- en: '[PRE48]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add the following methods in the class:'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE49]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Compile and run the application on the simulator. Scroll on the scroll view
    to change page. Likewise, tap or scroll on the page control to change page.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在滚动视图中滚动以更改页面。同样，在页面控制上轻触或滚动也可以更改页面。
- en: How it works...
  id: totrans-394
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing we need to do is set the `UIScrollView.PagingEnabled` property
    to `true`, which is done as follows:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是将`UIScrollView.PagingEnabled`属性设置为`true`，如下所示：
- en: '[PRE50]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'This property instructs the scroll view to perform scrolling at multiples of
    the scroll view''s bounds, hence providing paging functionality. After that, the
    image views that will be displayed in different pages are prepared. Here, we take
    care of adjusting each image view''s frame so that they will be positioned next
    to each other:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性指示滚动视图以滚动视图边界的倍数进行滚动，从而提供分页功能。之后，准备将在不同页面中显示的图像视图。在这里，我们注意调整每个图像视图的框架，以便它们彼此相邻：
- en: '[PRE51]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'We have attached handlers for two events. The first one is the `UIScrollView.DecelerationEnded`
    event, which will adjust the page control''s current page when the user scrolls
    the scroll view. The current page is determined by the scroll view''s `ContentOffset`
    property:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为两个事件附加了处理程序。第一个是`UIScrollView.DecelerationEnded`事件，当用户滚动滚动视图时，它将调整页面控制器的当前页面。当前页面由滚动视图的`ContentOffset`属性确定：
- en: '[PRE52]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The second event we attach a handler to is the `UIPageControl.ValueChanged`
    event. In this handler, we make sure the content is scrolled when the user taps
    or drags on the page control. The scroll is performed when the `ContentOffset`
    property is set to the desired image view''s `Frame.X` property, using the `UIScrollView.SetContentOffset(PointF,
    bool)` method:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 我们附加处理器的第二个事件是`UIPageControl.ValueChanged`事件。在这个处理程序中，我们确保当用户在页面控制上轻触或拖动时，内容会滚动。滚动是在将`ContentOffset`属性设置为所需图像视图的`Frame.X`属性时执行的，使用`UIScrollView.SetContentOffset(PointF,
    bool)`方法：
- en: '[PRE53]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The second parameter of the `SetContentOffset()` method instructs the scroll
    view to animate while scrolling.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetContentOffset()`方法的第二个参数指示滚动视图在滚动时进行动画。'
- en: There's more...
  id: totrans-404
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: In this recipe, different `UIImageView` objects have been used. Any kind of
    `UIView` objects can be used, according to the type of content we want to display.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，使用了不同的`UIImageView`对象。可以根据我们想要显示的内容类型使用任何类型的`UIView`对象。
- en: Proper usage of the UIPageControl
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确使用UIPageControl
- en: Users expect that scrolling to other pages will occur when tapping or dragging
    on the page control. It is not good practice to use it for displaying page indexing
    only, without being a fully active control.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 用户期望在点击或拖动页面控件时滚动到其他页面。仅用于显示页面索引而不作为完全活动的控件是不好的做法。
- en: See also
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Displaying images*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示图像*'
- en: '*Displaying content larger than the screen*'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示比屏幕更大的内容*'
- en: Displaying a toolbar
  id: totrans-412
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示工具栏
- en: In this recipe, we will learn how to add and use toolbars in applications.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在应用程序中添加和使用工具栏。
- en: Getting ready
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UIToolbar` class provides a toolbar that holds various buttons. It is the
    bar that resides at the bottom of views. Create a new **iPhone Single View Application**
    project in MonoDevelop, and name it `ToolbarApp`.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIToolbar` 类提供了一个包含各种按钮的工具栏。它是位于视图底部的栏。在 MonoDevelop 中创建一个新的**iPhone 单视图应用程序**项目，并将其命名为
    `ToolbarApp`。'
- en: How to do it...
  id: totrans-416
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Here are the steps to create this project:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此项目的步骤如下：
- en: Open the `ToolbarAppViewController.xib` file in Interface Builder and add a
    `UIToolbar` object at the bottom of its view.
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `ToolbarAppViewController.xib` 文件，并在其视图底部添加一个 `UIToolbar`
    对象。
- en: Select the button it contains by default and set its **Identifier** in the **Attributes
    Inspector** pad to **Save**.
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择默认包含的按钮，并在 **Attributes Inspector** 面板中将它的 **Identifier** 设置为 **Save**。
- en: Add a **Flexible Space Bar Button Item** object to the toolbar.
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向工具栏添加一个 **Flexible Space Bar Button Item** 对象。
- en: Add another button on the toolbar, on the right side of the previous object,
    and set its **Identifier** to **Reply**.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在工具栏上添加另一个按钮，位于上一个对象的右侧，并将其 **Identifier** 设置为 **Reply**。
- en: Add a `UILabel` object on the view and connect all controls, apart from the
    flexible space item, to outlets.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加一个 `UILabel` 对象，并将所有控件（除了灵活空间项）连接到 outlets。
- en: Save the document.
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: 'Back in MonoDevelop, enter the following code in the `ToolBarAppViewController`
    class:'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 MonoDevelop，在 `ToolBarAppViewController` 类中输入以下代码：
- en: '[PRE54]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Compile and run the application on the simulator. Tap on both of the toolbar's
    buttons and see the status string display on the label.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击工具栏的两个按钮，并查看状态字符串在标签上显示。
- en: How it works...
  id: totrans-427
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The toolbar holds items of the type `UIBarButtonItem`. These items are special
    kinds of buttons and spacers. A `UIBarButtonItem` can have a custom type, or any
    of the predefined types that are listed in the **Identifier** attribute in Interface
    Builder. When the item is a button and the behavior it provides is included in
    these identifiers, it is recommended to use them. Each one of these identifiers
    basically provides a specific icon to the button, according to its intended usage,
    and the user is quite familiar with them since they are used by most iOS applications.
    Notice that the **Flexible Space Bar Button Item** we added to the toolbar is
    also a **UIBarButtonItem**, with a specific identifier. Its purpose is to keep
    two buttons apart, changing their in-between distance in situations where this
    is required, for example, when rotating the device at a landscape orientation
    and the toolbar resizes to fit the new width.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 工具栏包含类型为 `UIBarButtonItem` 的项。这些项是特殊类型的按钮和间隔。`UIBarButtonItem` 可以有自定义类型，或者任何在
    Interface Builder 的 **Identifier** 属性中列出的预定义类型。当项是按钮并且它提供的行为包含在这些标识符中时，建议使用它们。这些标识符中的每一个基本上为按钮提供了一种特定的图标，根据其预期用途，用户对它们相当熟悉，因为它们被大多数
    iOS 应用程序所使用。注意，我们添加到工具栏中的 **Flexible Space Bar Button Item** 也是一个 **UIBarButtonItem**，具有特定的标识符。它的目的是在需要时保持两个按钮之间的距离，例如，当设备在横屏方向旋转并且工具栏调整大小以适应新宽度时。
- en: Note
  id: totrans-429
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Just rotating the device will not make the **UIToolbar** resize. This kind
    of behavior will be discussed in [Chapter 3](ch03.html "Chapter 3. User Interface:
    View Controllers"),User Interface: View Controllers'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 仅旋转设备不会使 **UIToolbar** 调整大小。这种行为将在 [第 3 章](ch03.html "第 3 章。用户界面：视图控制器") 中讨论，用户界面：视图控制器
- en: This kind of bar button is displayed in Interface Builder, but not at runtime.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的按钮在 Interface Builder 中显示，但在运行时并不显示。
- en: 'In the code, we add handlers to the bar buttons'' `Clicked` event, whose purpose
    is quite familiar:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中，我们为按钮的 `Clicked` 事件添加了处理程序，其目的是相当熟悉的：
- en: '[PRE55]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: It is being triggered when the user taps on the button.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击按钮时，它会被触发。
- en: There's more...
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The `UIBarButtonItem` class has a `Style` property that determines the button's
    style. It can be used only when the button item's identifier is set to `Custom`.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIBarButtonItem` 类有一个 `Style` 属性，它决定了按钮的样式。它只能在按钮项的标识符设置为 `Custom` 时使用。'
- en: Setting a UIToolbar's items programmatically
  id: totrans-437
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 以编程方式设置 UIToolbar 的项
- en: 'To set bar button items to a `UIToolbar`, use one of the overloads of its `SetItems()`
    method. An example for setting two bar button items in a `UIToolbar` is as follows:'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 要将工具栏项设置为 `UIToolbar`，请使用其 `SetItems()` 方法的重载之一。在 `UIToolbar` 中设置两个工具栏项的示例如下：
- en: '[PRE56]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: See also
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this book:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"),User Interface:
    View Controllers:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 3 章](ch03.html "第 3 章。用户界面：视图控制器")，用户界面：视图控制器：'
- en: '*Navigating through different view controllers*'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同视图控制器之间导航*'
- en: Creating a custom view
  id: totrans-444
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义视图
- en: In this recipe, we will learn how to override the `UIView` class and/or classes
    that derive from it, to create custom views.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何覆盖 `UIView` 类及其派生类，以创建自定义视图。
- en: Getting ready
  id: totrans-446
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: So far, we have discussed many of the available views there are to create iOS
    applications. There will be many cases, however, that we will need to implement
    our own custom views. In this task, we will see how to create a custom view and
    use it.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了创建 iOS 应用程序时可以使用的许多视图。然而，将会有很多情况需要我们实现自己的自定义视图。在本任务中，我们将看到如何创建自定义视图并使用它。
- en: Note
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating custom views is very useful when we want to capture touches or implement
    other custom behavior, such as drawing.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义视图在我们需要捕捉触摸或实现其他自定义行为，例如绘图时非常有用。
- en: Create a new **iPhone Single View Application** project in MonoDevelop, and
    name it `CustomViewApp`.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的**iPhone 单视图应用程序**项目，并将其命名为 `CustomViewApp`。
- en: How to do it...
  id: totrans-451
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Here are the steps to complete this project:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此项目的步骤如下：
- en: Add a new C# class file in the project, and name it `MyView`.
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的 C# 类文件，并将其命名为 `MyView`。
- en: 'Implement it with the following code:'
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码实现：
- en: '[PRE57]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Open the `CustomViewAppViewController.xib` file in Interface Builder, and add
    a `UIView` object on the main view.
  id: totrans-456
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `CustomViewAppViewController.xib` 文件，并在主视图中添加一个 `UIView`
    对象。
- en: Connect it to an outlet and set its **Class** field in the **Identity Inspector**
    to `MyView`.
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其连接到出口，并在**身份检查器**中设置其**类**字段为 `MyView`。
- en: Save the document.
  id: totrans-458
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Compile and run the application on the simulator. Tap-and-drag on the view,
    and watch the touch coordinates being displayed in the label at the bottom of
    the screen.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在视图中轻触并拖动，观察触摸坐标在屏幕底部的标签中显示。
- en: How it works...
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The first thing to note when creating custom views is to derive them from the
    `UIView` class and to decorate them with the `Register` attribute:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 创建自定义视图时要注意的第一件事是从 `UIView` 类派生它们，并用 `Register` 属性装饰它们：
- en: '[PRE58]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: The `Register` attribute basically exposes our class to the Objective-C world.
    Note that the name we pass as its parameter must be the same name that we enter
    in the **Class** field in the **Identity Inspector**. It is important to create
    the following constructor that overrides the base class' `UIView(IntPtr)`.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register` 属性基本上将我们的类暴露给 Objective-C 世界。请注意，我们传递给它的参数名称必须与我们在**身份检查器**中的**类**字段中输入的名称相同。创建以下构造函数以覆盖基类的
    `UIView(IntPtr)` 非常重要。'
- en: '[PRE59]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'This constructor is always being called when a view is initialized through
    native code. If we do not override it, an exception will occur upon initialization
    of the object when the runtime tries to recreate it if it has been removed when
    a memory warning is issued. The other constructor that is used in this example
    is just provided as guidance on what might be used if the view was initialized
    programmatically:'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 当视图通过原生代码初始化时，始终调用此构造函数。如果我们不覆盖它，当运行时尝试在发出内存警告时重新创建它时，对象初始化时将发生异常。本例中使用的另一个构造函数仅作为指导，说明如果视图是程序初始化的，可能会使用什么：
- en: '[PRE60]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Both these constructors call the `Initialize()` method that performs the initialization
    we need, such as creating the label that will be used, set background colors,
    and so on.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个构造函数都调用了 `Initialize()` 方法，该方法执行我们需要的初始化，例如创建将使用的标签，设置背景颜色等。
- en: 'Then, the `TouchesMoved` method is overridden. This is the method that is executed
    when the user drags a finger on the view. Inside the method, we retrieve the `UITouch`
    object from the method''s `NSSet` parameter:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，重写了 `TouchesMoved` 方法。这是当用户在视图中拖动手指时执行的方法。在方法内部，我们从方法的 `NSSet` 参数中检索 `UITouch`
    对象：
- en: '[PRE61]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Note
  id: totrans-470
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: An `NSSet` object is a collection of data that are not in particular order.
    It is similar to an array. Its `AnyObject` parameter returns an object from the
    collection.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSSet` 对象是一个无特定顺序的数据集合。它类似于数组。它的 `AnyObject` 参数从集合中返回一个对象。'
- en: 'The `UITouch` object contains information about user touches. We retrieve the
    touch''s current location from it:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITouch` 对象包含有关用户触摸的信息。我们从其中检索触摸的当前位置：'
- en: '[PRE62]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Its `LocationInView` method accepts a parameter of the type `UIView` that declares
    in which view's coordinate system the location will be calculated. In this case,
    we are interested in the coordinates of `MyView`.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 它的 `LocationInView` 方法接受一个类型为 `UIView` 的参数，该参数声明了位置将在哪个视图的坐标系中计算。在这种情况下，我们感兴趣的是
    `MyView` 的坐标。
- en: There's more...
  id: totrans-475
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If we would like to initialize the custom view that we created programmatically,
    we would enter the following code:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要初始化我们通过编程创建的自定义视图，我们会输入以下代码：
- en: '[PRE63]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: See also
  id: totrans-478
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Adding and customizing views*'
  id: totrans-480
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: 'In this book:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 3](ch03.html "Chapter 3. User Interface: View Controllers"),User Interface:
    View Controllers:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](ch03.html "第3章。用户界面：视图控制器")，用户界面：视图控制器：'
- en: '*View controllers and views*'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*视图控制器和视图*'
