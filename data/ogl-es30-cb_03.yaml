- en: Chapter 3. New Features of OpenGL ES 3.0
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章 OpenGL ES 3.0的新特性
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下配方：
- en: Managing variable attributes with qualifiers
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用限定符管理变量属性
- en: Grouping uniforms and creating buffer objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组统一变量和创建缓冲区对象
- en: Managing VBO with Vertex Array Objects
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用顶点数组对象管理VBO
- en: Reading and writing buffer objects with mapping
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用映射读写缓冲区对象
- en: Rendering multiple objects with geometry instancing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用几何实例化渲染多个对象
- en: Rendering multiple primitives with primitive restart
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用原始重启渲染多个原语
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: OpenGL ES 3.0 was publicly released in August 2012\. It brings the mobile 3D
    graphics to the next level. This release was focused to provide 3D-enriched features
    and enhanced the portability across diverse mobiles, embedded operating systems,
    and platforms. OpenGL ES 3.0 is fully backward compatible with OpenGL ES 2.0\.
    This enables the applications to grow the graphics capabilities and visual features
    incrementally. OpenGL ES 3.0 also introduces a new version of **GL Shading Language**
    (**GLSL**) 3.0\. The GLSL is used for programing shaders. The new shading language
    has also extended the capabilities in many directions, which you will learn in
    the next section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0于2012年8月公开发布。它将移动3D图形提升到了新的水平。这次发布专注于提供增强的3D功能，并提高了在不同移动设备、嵌入式操作系统和平台之间的可移植性。OpenGL
    ES 3.0完全向后兼容OpenGL ES 2.0。这使得应用程序能够逐步增长图形能力和视觉功能。OpenGL ES 3.0还引入了新的**GL着色语言**（**GLSL**）3.0版本。GLSL用于编写着色器。新的着色语言也在许多方面扩展了功能，你将在下一节中了解到。
- en: This chapter will be helpful in understanding the new features introduced in
    OpenGL ES 3.0 and GL shading language 3.0\. This book uses OpenGL ES 3.0 in conjunction
    with GLSL 3.0 for all its recipes.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将有助于理解OpenGL ES 3.0和GL着色语言3.0引入的新特性。本书在所有配方中使用OpenGL ES 3.0与GLSL 3.0结合。
- en: 'The new features of OpenGL ES 3.0 can be broadly divided into the following
    five categories:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的新特性可以大致分为以下五个类别：
- en: '**Geometry**: These features focus on the vertex attributes specifications,
    such as data storage, data transfer, attribute states, primitive assembly, and
    so on. They are explained as follows:'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何**：这些特性专注于顶点属性规范，如数据存储、数据传输、属性状态、原语组装等。它们如下所述：'
- en: '**Transform feedback**: This feature allows us to capture the vertex shader
    output to provide feedback to the GPU for next frame rendering. This way, it avoids
    CPU intervention and makes the rendering efficient.'
  id: totrans-13
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**变换反馈**：这个特性允许我们捕获顶点着色器的输出，为GPU提供下一帧渲染的反馈。这样，它避免了CPU的干预，并使渲染更高效。'
- en: '**Occlusion query**: This enables fast hardware testing to check whether a
    pixel is going to appear on screen or whether it is occluded by another pixel.
    This kind of check is helpful in deciding whether to skip certain operations such
    as geometry processing because it''s occluded.'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**遮挡查询**：这允许快速硬件测试以检查一个像素是否将出现在屏幕上，或者是否被另一个像素遮挡。这种检查有助于决定是否跳过某些操作，例如几何处理，因为它被遮挡。'
- en: '**Geometry instancing**: This allows efficient rendering of an object multiple
    times without calling multiple render API''s. This is very helpful in situations
    such as crowd simulation, trees rendering, and so on.'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**几何实例化**：这允许在不需要调用多个渲染API的情况下高效地渲染一个对象多次。这在人群模拟、树木渲染等情况下非常有用。'
- en: '**Primitive restart**: This new feature allows us to render multiple disconnected
    primitives using a single drawing API call. The index array is used to pack multiple
    primitives (of the same type) in a single bundle. This array contains multiple
    disconnected primitives with a special marker that helps the GPU o render disconnected
    primitives in one go.'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原始重启**：这个新特性允许我们使用单个绘图API调用渲染多个不连续的原语。索引数组用于将多个原语（同一类型）打包在一个捆绑包中。这个数组包含多个不连续的原语，并有一个特殊的标记，帮助GPU一次性渲染不连续的原语。'
- en: '**Textures**: There are many new features added into OpenGL ES 3.0 for textures.
    The features are described here:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**：OpenGL ES 3.0为纹理添加了许多新特性。这些特性在此描述：'
- en: '**Depth textures and shadow comparison**: Depth textures allow the storing
    of the depth buffer information into a texture. This is helpful in rendering shadows
    using the **percentile closest filtering** (**PCF**) technique in which depth
    information is explicitly stored from the depth buffer to a texture using the
    render-to-texture technique. Later, this information is used to test incoming
    fragments for whether they are a part of shadow or not. OpenGL ES 3.0 allows this
    comparison test implicitly.'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**深度纹理和阴影比较**：深度纹理允许将深度缓冲区信息存储到纹理中。这对于使用**百分比最近过滤**（**PCF**）技术渲染阴影非常有帮助，其中深度信息通过渲染到纹理技术显式地从深度缓冲区存储到纹理中。随后，这些信息用于测试传入的片段，以确定它们是否是阴影的一部分。OpenGL
    ES 3.0允许隐式地进行这种比较测试。'
- en: '**Seamless cube maps**: The cubemap rendering is improved to remove artifacts
    from the boundary edges of the images. Now, the filtering techniques take adjacent
    faces texture data into account to produce seamless texture boundaries on the
    face edges. You can refer to the *Implementing Skybox with seamless cube mapping*
    recipe in [Chapter 7](ch07.html "Chapter 7. Textures and Mapping Techniques"),
    *Textures and Mapping Techniques*.'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝立方体贴图**：立方体贴图渲染得到了改进，以消除图像边界边缘的伪影。现在，过滤技术考虑相邻面的纹理数据，以在面边缘产生无缝的纹理边界。您可以参考[第7章](ch07.html
    "第7章. 纹理和映射技术")中的*使用无缝立方体贴图实现天空盒*配方，*纹理和映射技术*。'
- en: '**ETC2/EAC texture-compression formats**: Before OpenGL ES 3.0, there was no
    standard compression format officially supported by OpenGL ES. Developers relied
    on the specific compression formats provided by different vendors, such as PVRTC
    by Imagination Technologies, **Ericsson Texture Compression** (**ETC**) by Sony
    Ericsson, ATC by Qualcomm, and so on. Now, ETC2 and EAC texture-compression formats
    are integrally supported in OpenGL ES 3.0\. Refer to the *Efficient rendering
    with ETC2 compressed texture* recipe in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Textures and Mapping Techniques*.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ETC2/EAC纹理压缩格式**：在OpenGL ES 3.0之前，OpenGL ES没有官方支持的标准压缩格式。开发者依赖于不同供应商提供的特定压缩格式，例如Imagination
    Technologies的PVRTC，Sony Ericsson的**Ericsson Texture Compression**（**ETC**），Qualcomm的ATC等。现在，ETC2和EAC纹理压缩格式在OpenGL
    ES 3.0中得到全面支持。请参考[第7章](ch07.html "第7章. 纹理和映射技术")中的*使用ETC2压缩纹理进行高效渲染*配方，*纹理和映射技术*。'
- en: '**Nonpower of two** (**NPOT**) texture: Now, textures with pixel dimensions
    of the nonpower of two texture are supported with full wrap mode and mipmapping.
    In earlier specifications of OpenGL ES, the textures had to be in the form of
    power of two (POT) dimensions. Therefore, external imaging tools were required
    to convert NPOT to POT format.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非2的幂次方纹理**（**NPOT**）：现在，支持具有非2的幂次方像素维度的纹理以全环绕模式和米级贴图。在OpenGL ES的早期规范中，纹理必须以2的幂次方（POT）维度形式存在。因此，需要外部图像工具将NPOT转换为POT格式。'
- en: '**Texture swizzles**: The GLSL provides a level of abstraction in accessing
    the components of texture, R, G, B, and A, irrespective of the order in which
    they are stored physically.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理混色**：GLSL提供了一种访问纹理组件（R、G、B和A）的抽象级别，无论它们在物理存储中的顺序如何。'
- en: '**Increased 2D texture dimension**: The dimension of 2D texture in OpenGL ES
    3.0 is 2048, which is much more compared to OpenGL ES 2.0.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的2D纹理维度**：OpenGL ES 3.0中2D纹理的维度为2048，这比OpenGL ES 2.0大得多。'
- en: '**3D texture**: OpenGL ES 3.0 supports 3D texture targets. 3D textures are
    widely used in medical imaging.'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D纹理**：OpenGL ES 3.0支持3D纹理目标。3D纹理在医学成像中得到广泛应用。'
- en: '**Arrays of 2D texture**: This new features allows us to store multiple 2D
    textures in the form of an array. This is useful for animation purpose. Prior
    to this, texture sprites were used.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D纹理数组**：这一新特性允许我们将多个2D纹理以数组的形式存储。这对于动画目的非常有用。在此之前，使用纹理精灵。'
- en: '**Shaders**: These are the special small programs that are used in modern computer
    graphics programming to control geometry and pixel color shading. The features
    on shaders are as follows:'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**着色器**：这些是在现代计算机图形编程中用于控制几何和像素颜色着色的特殊小程序。着色器的特性如下：'
- en: '**Program binaries**: The vertex and fragment shaders are compiled and stored
    in a binary format. This binary format needs to be linked to the program at run
    time in OpenGL ES 2.0\. OpenGL ES 3.0 allows an optimization by storing this binary
    into an offline binary format that does not require linking at run time. This
    optimization helps load the application faster by avoiding runtime linking.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序二进制文件**: 顶点和片段着色器被编译并存储在二进制格式中。在OpenGL ES 2.0中，这个二进制格式需要在运行时链接到程序。OpenGL
    ES 3.0允许通过将此二进制存储到不要求运行时链接的离线二进制格式中来实现优化。这种优化通过避免运行时链接来帮助更快地加载应用程序。'
- en: '**Flat/smooth interpolators**: In OpenGL ES 2.0, all the interpolators perform
    linear interpolation across the primitives. With the help of GLSL 3.0, in OpenGL
    ES 3.0, the interpolation can be explicitly declared to have flat and smooth shading.'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平坦/平滑插值器**: 在OpenGL ES 2.0中，所有插值器都在原语之间执行线性插值。借助GLSL 3.0，在OpenGL ES 3.0中，插值可以显式声明为具有平坦和光滑着色。'
- en: '**Buffer objects**: These allow us to store vertex data on the GPU memory.
    The new features have extended the capabilities of buffer objects to make them
    more efficient. Here are the new features:'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区对象**: 这些允许我们在GPU内存上存储顶点数据。新特性扩展了缓冲区对象的功能，使其更高效。以下是新特性：'
- en: '**Uniform blocks**: This allows to group related uniform values into a single
    manageable group. This increases the readability of the shader program.'
  id: totrans-30
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一块**: 这允许将相关的统一值组合成一个可管理的单个组。这增加了着色器程序的可读性。'
- en: '**Layout qualifiers**: The attributes defined in the vertex and fragment shaders
    can be directly bound to the user-defined locations. This way, the on-fly binding
    API calls are not required.'
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局限定符**: 在顶点和片段着色器中定义的属性可以直接绑定到用户定义的位置。这样，就不需要飞行绑定API调用。'
- en: '**Vertex Array Objects**: This feature provides an efficient way to bind vertex
    array data and respective attributes. **Vertex Array Objects** (**VAO**) are used
    to encapsulate the VBO. When a VAO API is called, it efficiently switches the
    states stored in VBO without calling several APIs. This reduces the overhead in
    the switching of vertex array states.'
  id: totrans-32
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点数组对象**: 此功能提供了一种高效的方法来绑定顶点数组和相应的属性。**顶点数组对象**（**VAO**）用于封装VBO。当调用VAO API时，它有效地切换存储在VBO中的状态，而不调用多个API。这减少了顶点数组状态切换的开销。'
- en: '**Uniform buffer object**: This feature stores the uniform block in an efficient
    way as a buffer object. This uniform block object can be bound on fly time. This
    gives an opportunity to share the uniform data among multiple programs at once.
    Additionally, it allows us to set multiple uniform variables in one go.'
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**统一缓冲区对象**: 此功能以高效的方式将统一块存储为缓冲区对象。此统一块对象可以随时绑定。这为一次共享多个程序中的统一数据提供了机会。此外，它允许我们一次性设置多个统一变量。'
- en: '**Subrange buffer mapping**: Unlike mapping the complete buffer from the GPU
    to the CPU side, this mechanism provides an efficient way to access a range of
    memory contents from the GPU memory space. Sometimes, the intention is to update
    only a small section of the buffer. Therefore, mapping the complete buffer is
    inefficient. In such situations, subrange buffer mapping reduces the time of marshaling
    from GPU to CPU to GPU.'
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子范围缓冲区映射**: 与从GPU到CPU侧映射整个缓冲区不同，此机制提供了一种高效的方法来访问GPU内存空间中的内存内容范围。有时，目的是仅更新缓冲区的一小部分。因此，映射整个缓冲区是不高效的。在这种情况下，子范围缓冲区映射减少了从GPU到CPU再到GPU的序列化时间。'
- en: '**Buffer object copies**: This mechanism transfers the data of one buffer object
    to the other one without intervening the CPU.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓冲区对象复制**: 此机制将一个缓冲区对象的数据传输到另一个缓冲区对象，而不涉及CPU。'
- en: '**Sync object**: This provides a synchronized mechanism between the applications
    and GPU. In this way, the application can assure completion of OpenGL ES operations
    on the GPU side.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步对象**: 这提供了一种在应用程序和GPU之间的同步机制。这样，应用程序可以确保GPU侧OpenGL ES操作的完成。'
- en: '**Fencing**: This feature informs the GPU to wait for queuing up new OpenGL
    ES operations until the old operations are completely executed on the GPU.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**栅栏**: 此功能通知GPU等待排队新的OpenGL ES操作，直到旧操作在GPU上完全执行。'
- en: '**Framebuffer**: The new features also include enhancements related to off-screen
    rendering for the framebuffer. Here are the new features:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**帧缓冲区**: 新特性还包括与帧缓冲区离屏渲染相关的增强功能。以下是新特性：'
- en: '**Multiple render target (MRT)**: This feature allows us to perform off-screen
    rendering simultaneously to several color buffers or textures at the same time.
    These textures can be used as input to other shaders or can be used on 3D models.
    MRTs are most commonly used to achieve deferred shading.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多个渲染目标（MRT）**：此功能允许我们同时将离屏渲染到多个颜色缓冲区或纹理。这些纹理可以用作其他着色器的输入，或者用于3D模型。MRTs最常用于实现延迟着色。'
- en: '**Multisample render buffer**: This feature enables the application to perform
    off-screen framebuffer rendering with multisample anti-aliasing. This improves
    the visual quality of the generated image and reduces the jagged-line effect that
    appears in the lines or sharp geometry edges drawn diagonally to the screen.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多采样渲染缓冲区**：此功能使应用程序能够执行具有多采样抗锯齿的离屏帧缓冲区渲染。这提高了生成图像的视觉效果，并减少了在屏幕上以对角线方向绘制的线条或尖锐几何边缘中出现的锯齿状效果。'
- en: This chapter will focus on the new features of geometry and buffer objects.
    As we progress with the upcoming chapters, we will also introduce the new features
    of shaders, textures, and framebuffers.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将重点介绍几何和缓冲区对象的新特性。随着我们进入即将到来的章节，我们还将介绍着色器、纹理和帧缓冲区的新特性。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can explore more about OpenGL ES 3.0 specifications and documentation on
    [http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf](http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf)
    and [http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf](http://www.khronos.org/registry/gles/specs/3.0/es_spec_3.0.3.pdf)和[http://www.khronos.org/opengles/sdk/docs/man3/](http://www.khronos.org/opengles/sdk/docs/man3/)上探索更多关于OpenGL
    ES 3.0规范和文档。
- en: Managing variable attributes with qualifiers
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用限定符管理变量属性
- en: 'GLSL 3.0 has introduced two new qualifiers: storage and layout. Let''s take
    a look at them in detail:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: GLSL 3.0引入了两个新的限定符：存储和布局。让我们详细看看它们：
- en: '**Storage qualifier**: This is a special keyword that specifies the storage
    or the behavior of a global or local variable. It is used in shader programming.
    It enables the communication bridge between the application and shaders. It is
    also used to share information from one shader stage to another. For example,
    a 3D light illumination technique requires an object''s geometry information in
    order to create realistic light shading. This geometry information is calculated
    in the vertex shader and passed to the fragment shader, where this input is used
    to color the fragments of the geometric primitives.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**存储限定符**：这是一个特殊的关键字，用于指定全局或局部变量的存储或行为。它在着色器编程中使用。它使得应用程序和着色器之间建立通信桥梁。它还用于从一个着色器阶段向另一个阶段共享信息。例如，3D光照技术需要物体的几何信息以便创建逼真的光照着色。这些几何信息在顶点着色器中计算，并传递给片元着色器，在那里这个输入被用来着色几何原语的部分。'
- en: 'There are six types of storage qualifiers available in GL SL 3.0\. They are
    described in the following table:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在GL SL 3.0中提供了六种存储限定符。它们在以下表中描述：
- en: '| Qualifier | Meaning |'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 限定符 | 含义 |'
- en: '| --- | --- |'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `const` | This is the value of variable does not alter compile time. |'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `const` | 变量的值在编译时不改变。 |'
- en: '| `in` | This is the copied input variable from the previous stage, which is
    linked to the current shader. If specified in a function argument, this is an
    input variable. |'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `in` | 这是来自前一阶段的复制输入变量，它与当前着色器链接。如果在函数参数中指定，这是一个输入变量。 |'
- en: '| `centroid in` | This is the input type variable linked to the centroid interpolator.
    |'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `centroid in` | 这是与中心插值器链接的输入类型变量。 |'
- en: '| `out` | This is the copied input variable from the previous stage, which
    is linked to the current shader. If specified in a function argument, this is
    an output variable. |'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `out` | 这是来自前一阶段的复制输入变量，它与当前着色器链接。如果在函数参数中指定，这是一个输出变量。 |'
- en: '| `centroid out` | This is the output type variable that is linked to the centroid
    interpolator. |'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `centroid out` | 这是与中心插值器链接的输出类型变量。 |'
- en: '| `uniform` | This is the value of the variables does not change across the
    primitives during the processing. The uniforms are shared across the shaders.
    |'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| `uniform` | 变量的值在处理过程中不会改变。这些统一变量在着色器之间共享。 |'
- en: '**Layout qualifier**: This influences the properties of a variable, such as
    storage, location, memory alignment, and so on. This qualifier is widely used
    in declaring the location of the variable(s) in shaders. Each variable or generic
    attribute declared in the shader is stored in an allocated memory location on
    the GPU. This memory location is used to store data in the variables as a result
    of runtime calculation or input data from the previous stage of the shader. Unlike
    C/C++ pointers, the shading language uses a location ID to access the variable.
    A location is an ID (numeric value(s)) of a variable that is used to connect the
    variable present in the shading language to the application program.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**布局限定符**：这影响变量的属性，如存储、位置、内存对齐等。此限定符在声明着色器中变量位置时广泛使用。在着色器中声明的每个变量或通用属性都存储在GPU上分配的内存位置。此内存位置用于存储数据，作为运行时计算的结果或来自着色器前一个阶段的数据输入。与C/C++指针不同，着色语言使用位置ID来访问变量。位置是变量的ID（数值），用于将着色语言中存在的变量与应用程序程序连接起来。'
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The next table specifies the syntax for the storage and layout qualifiers. The
    storage qualifiers are mentioned before the data type of the variable. The most
    commonly used qualifiers are in and out. These storage qualifiers tell us whether
    the vertex attribute is an incoming or outgoing variable.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下表指定了存储和布局限定符的语法。存储限定符在变量的数据类型之前提及。最常用的限定符是in和out。这些存储限定符告诉我们顶点属性是输入变量还是输出变量。
- en: The layout qualifier assigns an ID or location to the vertex attribute so that
    run the binding and querying of the location can be avoided. The layout qualifier
    is always mentioned before the storage qualifier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 布局限定符为顶点属性分配一个ID或位置，以便避免运行时的绑定和查询位置。布局限定符始终在存储限定符之前提及。
- en: '| Qualifier | Syntax |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 限定符 | 语法 |'
- en: '| --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Storage | `(storage qualifier) [Data type] [Variable Name]` |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 存储 | `(存储限定符) [数据类型] [变量名]` |'
- en: '| Layout | `layout (qualfier1, qualifier2 = value, . . .) [Storage qualifier]`
    |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 布局 | `layout (限定符1,限定符2 = value, . . .) [存储限定符]` |'
- en: How to do it...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The variables in a shader are abstracted in the form of location IDs. Each variable
    or generic attribute is recognized using its location ID and used to bind the
    data in the OpenGL ES program. These location IDs/indexes can be defined using
    the `location` keyword in the layout qualifier.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器中的变量以位置ID的形式抽象化。每个变量或通用属性都通过其位置ID识别，并用于将数据绑定到OpenGL ES程序中。这些位置ID/索引可以使用布局限定符中的`location`关键字定义。
- en: 'In our first recipe, we will demonstrate the use of storage and layout qualifiers:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个配方中，我们将演示存储和布局限定符的使用：
- en: 'Create a vertex shader `LayoutVertex.glsl`, as shown here:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个顶点着色器`LayoutVertex.glsl`，如下所示：
- en: '[PRE0]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create the fragment shader `LayoutFragment.glsl` and modify it, as shown here:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建片段着色器`LayoutFragment.glsl`并修改它，如下所示：
- en: '[PRE1]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Reuse the *Efficient rendering with Vertex Buffer Object* recipe [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials* and define
    the location index according to your choice in the application program, `Cube.cpp`.
    Make sure that the same index is specified in the shader program:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新使用*使用顶点缓冲对象进行高效渲染*配方[第2章](ch02.html "第2章。OpenGL ES 3.0 基础"), *OpenGL ES 3.0
    基础*，并在应用程序程序`Cube.cpp`中根据您的选择定义位置索引。确保在着色器程序中指定相同的索引：
- en: '[PRE2]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create the VBO and IBO in the constructor and enable the following attributes
    like:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中创建VBO和IBO，并启用以下属性：
- en: '[PRE3]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Attach the VBO geometry data to the location ID. This will be used to send
    data from application to the GPU shader processor. Clearly, with the layout qualifier,
    the location query (`glGetAttribLocation`) for the vertex attribute can be avoided:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将VBO几何数据附加到位置ID。这将用于从应用程序发送数据到GPU着色器处理器。显然，使用布局限定符可以避免对顶点属性的布局查询(`glGetAttribLocation`)：
- en: '[PRE4]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The OpenGL ES program defines two index ID's in `Cube.cpp`, `VERTEX_LOCATION`
    and `COLOR_LOCATION` for vertex and color data, respectively. These indices will
    be used to define the attribute location in the shader program. The programmer
    must ensure that the layout location ID used in the shader program for the attribute
    must be same as the one used in the OpenGL ES program. This can be achieved by
    declaring the variable attributes using the layout qualifier. Prefixing the `layout`
    keyword in conjunction with the `location` qualifier allows the user-defined locations
    to attach with attribute variables. If some attribute variables are not specified
    by user-defined location indices, then the compiler would automatically generate
    and assign them.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 程序在 `Cube.cpp` 中定义了两个索引 ID，分别为 `VERTEX_LOCATION` 和 `COLOR_LOCATION`，分别用于顶点和颜色数据。这些索引将用于在着色器程序中定义属性位置。程序员必须确保在着色器程序中用于属性的布局位置
    ID 必须与在 OpenGL ES 程序中使用的 ID 相同。这可以通过使用布局限定符声明变量属性来实现。将 `layout` 关键字与 `location`
    限定符结合使用，允许用户定义的位置与属性变量关联。如果某些属性变量没有通过用户定义的位置索引指定，则编译器会自动生成并分配它们。
- en: In the shader program, `VertexPosition` and `VertexColor` are assigned to the
    same location indices, `0` and `1`, respectively, what was defined in the OpenGL
    ES program. These two variable declarations are of the `vec4` type, which is prefixed
    with the storage qualifier `in`. This gives information that these two variables
    are input to the vertex shader from the OpenGL ES program. The geometry data (vertex
    and color) is sent to the vertex shader by attaching the data to the location
    indexes of `VertexPosition` and `VertexColor` using the `glVertexAttribPointer`
    API in the `RenderCube` function. It should be noted that the generic attribute
    variables must be enabled before they are attached using the `glEnableVertexAttribArray`
    API. This recipe enables them in the `Cube` constructor.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在着色器程序中，`VertexPosition` 和 `VertexColor` 分别被分配到与 OpenGL ES 程序中定义的相同的位置索引 `0`
    和 `1`。这两个变量声明为 `vec4` 类型，并带有存储限定符 `in`。这表明这两个变量是从 OpenGL ES 程序输入到顶点着色器的。通过在 `RenderCube`
    函数中使用 `glVertexAttribPointer` API 将数据附加到 `VertexPosition` 和 `VertexColor` 的位置索引，将几何数据（顶点和颜色）发送到顶点着色器。需要注意的是，在使用
    `glEnableVertexAttribArray` API 附加之前，必须启用通用属性变量。这个配方在 `Cube` 构造函数中启用它们。
- en: When the vertex shader receives an input data for vertices in `VertexPosition`
    and transformation coordinates in the uniform `MODELVIEWPROJECTIONMATRIX`, it
    uses these two variables as an input argument to the `calculatePosition` function
    to calculate the transformed position of the incoming vertex. This calculated
    position returns to the main function as an output storage qualifier in the variable
    called position. The `calculatePosition` function is introduced in this recipe
    to demonstrate another possible use of storage qualifiers in the local scope of
    the shader program.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当顶点着色器接收到 `VertexPosition` 中的顶点输入数据和统一变量 `MODELVIEWPROJECTIONMATRIX` 中的变换坐标时，它使用这两个变量作为
    `calculatePosition` 函数的输入参数来计算传入顶点的变换位置。这个计算出的位置作为输出存储限定符返回到主函数中的 `position` 变量。`calculatePosition`
    函数在本配方中引入，以展示在着色器程序的局部作用域中存储限定符的另一种可能用途。
- en: The `Color` variable uses the incoming value of `VertexColor` and passes it
    to the next stage in which the fragment shader consumes this value to assign the
    color to the fragments. In order to send data from the vertex shader to fragment
    shader, both shaders should use the same attribute variable name. The storage
    qualifier for the vertex shader must be defined as `out` since it is producing
    an output data for fragment shader. In contrast, the fragment shader must be specified
    with the `in` storage qualifier, as this receives the data from the previous stage.
    The fragment shader demonstrates another way of using return values from the shader
    programming functions.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Color` 变量使用 `VertexColor` 的输入值，并将其传递到下一个阶段，其中片段着色器消耗这个值来为片段分配颜色。为了从顶点着色器将数据发送到片段着色器，两个着色器应使用相同的属性变量名称。顶点着色器的存储限定符必须定义为
    `out`，因为它为片段着色器生成输出数据。相比之下，片段着色器必须指定为 `in` 存储限定符，因为它接收来自前一阶段的数据。片段着色器展示了从着色器编程函数返回值的另一种使用方式。'
- en: There's more...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the current recipe, you learned how to bind the location indices of the generic
    attribute variables in OpenGL ES from the shader program using layout qualifiers.
    As an alternative, the `glBindAttribLocation` API can also be used to explicitly
    bind the location index.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前教程中，你学习了如何使用布局限定符从着色器程序中绑定OpenGL ES中通用属性变量的位置索引。作为替代，也可以使用`glBindAttribLocation`
    API显式绑定位置索引。
- en: '**Syntax**:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**：'
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '| Variable | Description |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `program` | This is the program object handle |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `program` | 这是程序对象句柄 |'
- en: '| `index` | This is the index of the generic vertex attribute or variable |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 这是通用顶点属性或变量的索引 |'
- en: '| `name` | This is the vertex shader attribute variable that the index is to
    be bound |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `name` | 这是顶点着色器属性变量，索引将被绑定 |'
- en: However, it is advisable to encourage layout qualifier as it does not produce
    the overhead of an API call for attaching the location index to shader program.
    The use of a layout location qualifier in the shader programing avoids the binding
    of attribute location at runtime in the OpenGL ES program.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，建议鼓励使用布局限定符，因为它不会产生将位置索引附加到着色器程序的API调用的开销。在着色器程序中使用布局位置限定符可以避免在OpenGL ES程序中运行时绑定属性位置。
- en: See also
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Using the per-vertex attribute to send data to a shader* recipe
    in [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES
    3.0 on Android/iOS*
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第1章中的*使用顶点属性将数据发送到着色器*教程，*OpenGL ES 3.0在Android/iOS上*，[第1章](ch01.html "第1章. OpenGL
    ES 3.0在Android/iOS上")
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第2章中的*使用顶点缓冲对象进行高效渲染*教程，*OpenGL ES 3.0基础知识*，[第2章](ch02.html "第2章. OpenGL ES
    3.0基础知识")
- en: Grouping uniforms and creating buffer objects
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组统一变量和创建缓冲对象
- en: The interface block helps in grouping the uniform variables into one logical
    bunch. This is very useful in grouping the related variables in the shader programing.
    The interface block gives an opportunity to share the uniform data among multiple
    programs at once. This allows us to set multiple uniform variables in one go,
    which can be used many times.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接口块有助于将统一变量分组到一个逻辑组中。这在着色器程序中分组相关变量非常有用。接口块为一次共享多个程序中的统一数据提供了机会。这允许我们一次性设置多个统一变量，这些变量可以多次使用。
- en: A **Uniform Buffer Object** (**UBO**) is a buffer object for the interface blocks
    (containing uniform) similar to VBO, IBO, and so on. It stores the contents of
    the interface block in the GPU memory for quick data access at runtime. The UBO
    uses bind points that act as a mediator between the uniform block and uniform
    buffer. In this recipe, we will create a uniform block and learn how to program
    uniform buffer objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**统一缓冲对象**（**UBO**）是一种用于接口块（包含统一变量）的缓冲对象，类似于VBO、IBO等。它在GPU内存中存储接口块的内容，以便在运行时快速访问数据。UBO使用绑定点，作为统一块和统一缓冲之间的中介。在本教程中，我们将创建一个统一块并学习如何编程统一缓冲对象。'
- en: This recipe demonstrates the concept of interface block. In this recipe, we
    created an interface block to store transformation matrices. This block contain
    three uniforms. The interface block is stored as a buffer object using the UBO
    feature. This allows us to store the interface block as an OpenGL ES buffer object.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程演示了接口块的概念。在本教程中，我们创建了一个接口块来存储变换矩阵。此块包含三个统一变量。接口块使用UBO功能作为缓冲对象存储。这允许我们将接口块作为OpenGL
    ES缓冲对象存储。
- en: Getting ready
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The syntax to create the uniform block is very simple. The following table
    shows the syntax and use test cases of the implementation:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 创建统一块的语法非常简单。以下表格显示了语法和实现测试用例：
- en: '| Syntax | Individual uniforms | Uniform blocks |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 语法 | 单个统一变量 | 统一块 |'
- en: '| --- | --- | --- |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '|'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE6]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '|'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE7]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '|'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE8]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Here is the step-by-step description that demonstrates the interface block
    and helps in programming the uniform block object:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是逐步描述，展示了接口块并有助于编程统一块对象：
- en: 'Reuse the previous recipe, *Managing variable attributes with qualifiers*,
    and create the vertex shader (`UniformBlockVertex.glsl`) as shown here:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新使用之前的教程，*使用限定符管理变量属性*，并创建顶点着色器（`UniformBlockVertex.glsl`），如下所示：
- en: '[PRE9]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create the fragment shader, (`UniformBlockFragment.glsl`), as follows:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建片段着色器（`UniformBlockFragment.glsl`），如下所示：
- en: '[PRE10]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the `Cube::InitModel()` function, compile the given shader(s) and create
    the program object. Make sure that the program is in use (`glUseProgram`) before
    the UBO creation is attempted. In this recipe, we created the UBO in a separate
    class member function `CreateUniformBufferObject`. Follow these steps to understand
    this function:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Cube::InitModel()` 函数中，编译给定的着色器（们）并创建程序对象。在尝试创建 UBO 之前，确保程序正在使用中（`glUseProgram`）。在此配方中，我们在一个单独的类成员函数
    `CreateUniformBufferObject` 中创建了 UBO。按照以下步骤来理解此函数：
- en: '[PRE11]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Query the index of the uniform block that is defined in the vertex shader using
    the `glGetUniformBlockIndex` API into `blockIdx`. This API accepts the program
    ID and the name of the uniform block whose block index needs to be queried.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glGetUniformBlockIndex` API 查询在顶点着色器中定义的统一块索引，并将其存储在 `blockIdx` 中。此 API
    接受程序 ID 和需要查询块索引的统一块名称。
- en: Use `blockIdx` and query the block data size in the `blockSize` variable with
    the help of the `glGetActiveUniformBlockiv` API. Bind the uniform block index
    to binding point `bindingPoint` with `glUniformBlockBinding`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `blockIdx` 并借助 `glGetActiveUniformBlockiv` API 查询 `blockSize` 变量中的块数据大小。使用
    `glUniformBlockBinding` 将统一块索引绑定到绑定点 `bindingPoint`。
- en: Create the object handle for uniform buffer block and bind it to the symbolic
    constant `GL_UNIFORM_BUFFER`, and allocate the required memory specified by `blockSize`.
    Finally, bind the UBO with binding point by using `glBindBufferBase`.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建统一缓冲块的对象句柄，并将其绑定到符号常量 `GL_UNIFORM_BUFFER`，并分配由 `blockSize` 指定的所需内存。最后，使用 `glBindBufferBase`
    通过绑定点绑定 UBO。
- en: 'In the render function, make use of buffer object memory mapping to modify
    the content of UBO:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染函数中，利用缓冲对象内存映射来修改 UBO 的内容：
- en: '[PRE12]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The uniform block declaration in the vertex shader groups the model, view,
    and projection matrices into one logical block called **transformation**. When
    the shader program gets compiled, it assigns a unique ID/index to the block called
    block index. The user-defined location indexes are not permitted in uniform blocks.
    The following five steps are required to create a UBO:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中的统一块声明将模型、视图和投影矩阵组合成一个名为 **transformation** 的逻辑块。当着色器程序被编译时，它为该块分配一个唯一的
    ID/索引，称为块索引。在统一块中不允许使用用户定义的位置索引。创建 UBO 需要以下五个步骤：
- en: Use the `glGetUniformBlockIndex` API to query the `Transformation` ID in the
    `blockIdx` variable.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glGetUniformBlockIndex` API 查询 `blockIdx` 变量中的 `Transformation` ID。
- en: In order to allocate the memory for the UBO, use the `glGetActiveUniformBlockiv`
    API to query the size of the `Transformation` uniform block in the `blockSize`
    variable.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了为 UBO 分配内存，使用 `glGetActiveUniformBlockiv` API 查询 `Transformation` 统一块的大小并将其存储在
    `blockSize` 变量中。
- en: Bind `blockIdx` (block index) to `bindingPoint` (binding point) using the `glUniformBlockBinding`
    API. UBO uses the concept of binding points to create a connection between the
    block index and the buffer object. Both must be bound to the binding point.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glUniformBlockBinding` API 将 `blockIdx`（块索引）绑定到 `bindingPoint`（绑定点）。UBO
    使用绑定点的概念在块索引和缓冲对象之间建立连接。两者都必须绑定到绑定点。
- en: Unlike the buffer objects (VBO and IBO) are created in OpenGL ES, similarly
    create the uniform buffer object. The `glBindBuffer` and `glBufferData` APIs must
    use the `GL_UNIFORM_BUFFER` symbolic constant to ensure UBO buffer to the OpenGL
    ES state machine.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与在 OpenGL ES 中创建的缓冲对象（VBO 和 IBO）类似，同样创建统一缓冲对象。必须使用 `GL_UNIFORM_BUFFER` 符号常量来确保
    UBO 缓冲区与 OpenGL ES 状态机。
- en: As mentioned in step 3, we need to attach the UBO with the respective binding
    point that is already attached to the block index. Use the `glBindBufferBase`
    API to bind UBO and `bindingPoint`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如第 3 步所述，我们需要将 UBO 与已附加到块索引的相应绑定点相关联。使用 `glBindBufferBase` API 绑定 UBO 和 `bindingPoint`。
- en: The UBO can be used to set several values with the single UBO binding call.
    `RenderCube()` binds the UBO to set the uniform values for model, view, and projection
    matrices. The buffer object allows modifications to buffer elements using buffer-mapping
    techniques.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: UBO 可以通过单个 UBO 绑定调用设置多个值。`RenderCube()` 绑定 UBO 来设置模型、视图和投影矩阵的统一值。缓冲对象允许使用缓冲区映射技术修改缓冲区元素。
- en: The OpenGL ES 3.0 release has introduced a new feature for range buffer mapping.
    This feature allows us to modify a subset of the buffer object. Unlike the old
    buffer-mapping technique, where the complete buffer needs to be mapped onto the
    CPU side, this technique appears to be much more efficient.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0的发布引入了一个新的范围缓冲区映射特性。这个特性允许我们修改缓冲对象的一个子集。与需要将整个缓冲区映射到CPU侧的老式缓冲区映射技术不同，这种技术看起来要高效得多。
- en: Use the `glMapBufferRange` API to map the UBO on the client side to modify the
    model, view, and projection matrices with updated values. Make sure that you unmap
    the buffer object after modification is completed by sing the `glUnmapBufferAPI`.
    Use the existing code for VBO rendering.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`glMapBufferRange` API在客户端映射UBO以修改模型、视图和投影矩阵的更新值。确保在修改完成后使用`glUnmapBufferAPI`取消映射缓冲对象。使用现有的VBO渲染代码。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The following figure describes the concept of binding point in UBOs. Each uniform
    block is identified with a unique index within the shader program. This index
    is attached to a binding point. Similarly, the UBO is also attached to the binding
    point and provides a mechanism to share the same data among different programs.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 下图描述了UBO中绑定点的概念。每个统一块在着色程序中都有一个唯一的索引。这个索引附加到一个绑定点上。同样，UBO也附加到绑定点上，并提供了一种在不同程序间共享相同数据的方法。
- en: '![There''s more...](img/5527OT_03_01.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_03_01.jpg)'
- en: In the preceding figure, **P1_2** and **P2_1** are pointing to the same binding
    point. Therefore, both share the same data.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**P1_2**和**P2_1**指向同一个绑定点。因此，它们共享相同的数据。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第2章](ch02.html "第2章. OpenGL ES 3.0 基础")中的*使用顶点缓冲对象进行高效渲染*食谱。
- en: '*Reading and writing buffer objects with mapping*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用映射读取和写入缓冲对象*'
- en: Managing VBO with Vertex Array Objects
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用顶点数组对象管理VBO
- en: 'In [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES
    3.0 Essentials*, we introduced two features to load the vertex attributes using
    vertex arrays and **Vertex Buffer Object** (**VBO**). Both these features allow
    us to load the vertex attribute in the OpenGL ES rendering pipeline. The VBO are
    considered efficient compared to vertex arrays because they store the vertex data
    in the GPU memory. This reduces the cost of data copy between CPU and GPU. In
    this recipe, we will understand a new feature: **Vertex Array Objects** (**VAO**)
    of OpenGL ES 3.0\. This feature is more efficient compared to VBO.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章. OpenGL ES 3.0 基础")中，我们介绍了使用顶点数组和**顶点缓冲对象**（**VBO**）来加载顶点属性的两个特性。这两个特性允许我们在OpenGL
    ES渲染管道中加载顶点属性。与顶点数组相比，VBO被认为更高效，因为它们将顶点数据存储在GPU内存中。这减少了CPU和GPU之间数据复制的成本。在本食谱中，我们将了解一个新特性：OpenGL
    ES 3.0的**顶点数组对象**（**VAO**）。这个特性比VBO更高效。
- en: When a vertex attribute is loaded, it requires some additional calls to set
    the attribute states in the OpenGL ES rendering pipeline. For example, prior to
    rendering, the buffer object is bound using the `glBindBuffer` API, the data array
    is assigned using the `glVertexAttributePointer` API, and the vertex attribute
    is enabled using the `glEnableVertexAttribArray` API. The VAO stores all such
    states into a single object in order to remove the overhead caused by these calls.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载顶点属性时，需要在OpenGL ES渲染管道中设置一些额外的调用以设置属性状态。例如，在渲染之前，使用`glBindBuffer` API绑定缓冲对象，使用`glVertexAttribPointer`
    API分配数据数组，并使用`glEnableVertexAttribArray` API启用顶点属性。VAO将这些状态存储在单个对象中，以消除这些调用造成的开销。
- en: This allows the application to quickly switch among available vertex array buffers
    and set their respective states. This makes the rendering efficient and also helps
    keep the programming code compact and clean.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许应用程序快速在可用的顶点数组缓冲区之间切换，并设置它们各自的状态。这使得渲染更高效，同时也帮助保持编程代码紧凑且干净。
- en: How to do it...
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: This recipe demonstrates a simple grid geometry rendering using VAO in conjunction
    with VBO. There is no change required in shaders for programming VAO. Perhaps
    previous recipes from this chapter can be used.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了使用VAO和VBO结合进行简单网格几何渲染。对于VAO的编程，不需要对着色器进行任何更改。也许可以使用本章之前的食谱。
- en: 'The steps to create VAO are very straightforward:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 创建VAO的步骤非常简单：
- en: 'Create a `Grid` class and define the geometry in the `CreateGrid` function.
    This function takes the dimension and division of the grid. Inside this function,
    create a VBO, IBO, and VAO, as shown in the following code:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Grid`类，并在`CreateGrid`函数中定义几何形状。此函数接受网格的维度和分割。在此函数内部，创建一个VBO、IBO和VAO，如下面的代码所示：
- en: '[PRE13]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a VBO, generate the buffer, and fill in the buffer object with the vertex
    information:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个VBO，生成缓冲区，并将顶点信息填充到缓冲对象中：
- en: '[PRE14]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Similarly, create an IBO and fill in the buffer with the element indexes:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个IBO，并用元素索引填充缓冲区：
- en: '[PRE15]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Generate the VAO ID using the `glGenVertexArrays` API. Bind this generated
    `Vertex_VAO_Id` using `glBindVertexArray`. The code written after the creation
    of the VAO is recorded in the state vector of the VAO object. Therefore, use the
    VBO and bind the data to the required vertex attribute for rendering purposes:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glGenVertexArrays` API生成VAO ID。使用`glBindVertexArray`绑定生成的`Vertex_VAO_Id`。因此，在VAO创建后的代码记录在VAO对象的状态向量中。因此，使用VBO并将数据绑定到所需的顶点属性以进行渲染：
- en: '[PRE16]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Unbind the VAO, VBO, and IBO, once the vertex states and attributes are set
    properly:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦正确设置顶点状态和属性，解绑VAO、VBO和IBO：
- en: '[PRE17]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Render the geometry with VAO using the `Render()` function, as shown here:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Render()`函数通过VAO渲染几何形状，如下所示：
- en: '[PRE18]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The VAO stores the vertex array client states and the buffer binding in a state
    vector. When the VAO ID is bound, the subsequent operation calls, such as calls
    to bind with VBO, enable client states, and attach data buffer to generic attributes,
    are stored in the state vector of the VAO. This way, when the VAO is bound, the
    state vector provides the full state of current settings, configurations, and
    client states of the vertex array. Instead of making several calls, this one binding
    call will be sufficient to enable vertex array configurations and states.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: VAO将顶点数组客户端状态和缓冲区绑定存储在状态向量中。当VAO ID被绑定时，后续的操作调用，如绑定VBO、启用客户端状态和将数据缓冲区附加到通用属性，都存储在VAO的状态向量中。这样，当VAO被绑定时，状态向量提供了当前设置、配置和顶点数组的客户端状态的完整状态。而不是进行多次调用，这个绑定调用就足以启用顶点数组的配置和状态。
- en: '![How it works...](img/5527OT_03_02.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_03_02.jpg)'
- en: See also
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Rendering primitives with vertex arrays* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章。OpenGL ES 3.0 基础")中的*使用顶点数组渲染原语*配方，*OpenGL ES 3.0 基础*
- en: Reading and writing buffer objects with mapping
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用映射读取和写入缓冲对象
- en: The previous recipe introduced a new feature to access vertex arrays using VAO.
    This object minimizes the overhead of switch among vertex arrays and their respective
    states. This recipe will go one step ahead in order to teach you how to update
    the data of the buffer objects using buffer mapping. The VBO can be updated using
    `glBufferData` and `glBufferSubData` as demonstrated in many recipes. These APIs
    can be used to upload or download data to the device. In contrast, the buffer
    mapping is an efficient way to update the buffer objects that are residing in
    the GPU memory.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方介绍了一个新功能，即使用VAO访问顶点数组。此对象最小化了在顶点数组及其相应状态之间切换的开销。本配方将进一步教你如何使用缓冲映射更新缓冲对象的
    数据。VBO可以使用`glBufferData`和`glBufferSubData`进行更新，如许多配方中所示。这些API可以用于将数据上传或下载到设备。相比之下，缓冲映射是更新驻留在GPU内存中的缓冲对象的效率较高的方法。
- en: This recipe will demonstrate buffer object range mapping. In this recipe, we
    will reuse the cube geometry and render each vertex of the cube as a point primitive,
    instead of a triangle primitive. Each vertex of the cube is programmed to change
    its colors randomly using the buffer object range mapping feature after a fixed
    interval of time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本示例将演示缓冲对象范围映射。在这个示例中，我们将重用立方体几何形状，并将立方体的每个顶点渲染为点原语，而不是三角形原语。立方体的每个顶点都经过编程，在固定的时间间隔后使用缓冲对象范围映射功能随机改变其颜色。
- en: Getting ready
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Before we start with a step-by-step description, here is the overview of buffer
    object range mapping:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始逐步描述之前，这里是对缓冲对象范围映射的概述：
- en: Bind the buffer that needs to be mapped using `glBindBuffer`.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glBindBuffer`绑定需要映射的缓冲区。
- en: Get the pointer to the memory location from driver memory space using the `glMapBufferRange`
    API.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`glMapBufferRange` API从驱动器内存空间获取内存位置的指针。
- en: Use this pointer to perform any read/write operations on the acquired memory.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用此指针对获取的内存执行任何读写操作。
- en: Invalidate the acquire pointer using the `glUnmapBuffer` API. This API allows
    us to send updated memory contents to the GPU memory space.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `glUnmapBuffer` API 无效化获取指针。此API允许我们将更新后的内存内容发送到GPU内存空间。
- en: How to do it...
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'This recipe does not require any special change in the vertex and fragment
    shaders. For this recipe, we used a new GL shading language API called `gl_PointSize`.
    This API is used to specify the size of the `GL_POINTS` primitives. Make use of
    the *Efficient rendering with* *Vertex Buffer Object* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*, and proceed
    with the following steps to program range mapping onto a buffer object:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方不需要在顶点和片段着色器中进行任何特殊更改。对于此配方，我们使用了一个新的GL着色语言API，称为 `gl_PointSize`。此API用于指定
    `GL_POINTS` 原始形状的大小。利用 [第2章](ch02.html "第2章。OpenGL ES 3.0 基础") 中的 *使用顶点缓冲对象进行高效渲染*
    配方，并按照以下步骤将范围映射编程到缓冲区对象：
- en: First, create the VAO of the cube geometry using the previous VAO recipe.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，使用之前的VAO配方创建立方体几何的VAO。
- en: 'Program the map range buffer inside the `Render()` function as shown here.
    The following steps will describe this function:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Render()` 函数内部编程映射范围缓冲区，如下所示。以下步骤将描述此函数：
- en: '[PRE19]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'First, bind the VBO in order to map the color buffer data using the `glBindBuffer`
    API. Map the pointer to the color data memory. The color data in the VBO starts
    from the size index and is also size bytes long:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，绑定VBO以使用 `glBindBuffer` API映射颜色缓冲区数据。将指针映射到颜色数据内存。VBO中的颜色数据从大小索引开始，也是大小字节长：
- en: '[PRE20]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On successful mapping of the buffer object, it returns a valid pointer to the
    memory mapped location. If an error occurs, the API would return the `NULL` pointer.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在成功映射缓冲区对象后，它返回指向内存映射位置的合法指针。如果发生错误，API将返回 `NULL` 指针。
- en: '**Syntax**:'
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE21]'
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '| Variable | Description |'
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the type of buffer, which is expected to bind for
    memory mapping, for example, `GL_MAP_READ_BIT` and `GL_MAP_WRITE_BIT` |'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了预期用于内存映射的缓冲区类型，例如，`GL_MAP_READ_BIT` 和 `GL_MAP_WRITE_BIT` |'
- en: '| `offset` | This specifies the starting offset within the buffer object that
    is the subject of interest for mapping |'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `offset` | 这指定了映射对象中感兴趣映射的起始偏移量 |'
- en: '| `length` | This specifies the range of the buffer that needs to be mapped
    |'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `length` | 这指定了需要映射的缓冲区范围 |'
- en: '| `access` | This is the symbol constant flag combination that indicates the
    desired access to the buffer range |'
  id: totrans-188
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `access` | 这是指示所需访问缓冲区范围的符号常量标志组合 |'
- en: 'Copy the new color values in this mapped memory buffer:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制映射内存缓冲区中的新颜色值：
- en: '[PRE22]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Unmap the memory mapped buffer to indicate the OpenGL ES rendering pipeline
    to transfer this data to the GPU memory space:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 解除内存映射缓冲区，以指示OpenGL ES渲染管道将此数据传输到GPU内存空间：
- en: '[PRE23]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `UnmapBuffer` API returns the Boolean `TRUE` if it successfully unmaps the
    current mapped buffer. If some error occurs, it returns `FALSE`.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UnmapBuffer` API在成功解除当前映射的缓冲区时返回布尔值 `TRUE`。如果发生某些错误，它返回 `FALSE`。'
- en: '**Syntax**:'
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE24]'
  id: totrans-195
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '| Variable | Description |'
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-197
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `target` | This specifies the type of the buffer that needs to unbound |'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_TB
  zh: '| `target` | 这指定了需要解除绑定的缓冲区类型 |'
- en: 'Bind the VAO and render the geometry using the `GL_POINTS` primitive. The `GL_POINTS`
    primitive renders small dots on the screen. In order to increase the dimension
    of these dots, the `gl_PointSize` API can be used in the vertex shader, as shown
    in the next step:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 绑定VAO并使用 `GL_POINTS` 原始形状渲染几何形状。`GL_POINTS` 原始形状在屏幕上渲染小点。为了增加这些点的尺寸，可以在顶点着色器中使用
    `gl_PointSize` API，如下一步所示：
- en: '[PRE25]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Create `BufferMappingVertex.glsl` as follows:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BufferMappingVertex.glsl` 如下：
- en: '[PRE26]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: How it works...
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the VBO, `glBufferData` and `glBufferSubData` use the user data and copy
    it into a hooked/pinned location in the device memory location. This hooked location
    can be accessed by the GPU. The user data is copied to this memory location like
    `memcpy` internally. As the data copying process gets completed, the driver starts
    **direct memory allocation** (**DMA**) without intervening the CPU cycles.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在VBO中，`glBufferData` 和 `glBufferSubData` 使用用户数据并将其复制到设备内存位置的钩子/固定位置。此钩子位置可以被GPU访问。用户数据像
    `memcpy` 内部一样复制到这个内存位置。随着数据复制过程的完成，驱动程序开始 **直接内存分配**（**DMA**），而不干预CPU周期。
- en: The target destination of the DMA depends upon the usage hints from the (`GL_STREAM_DRAW`,
    `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`, `GL_STATIC_READ`, `GL_STATIC_COPY`,
    `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, or `GL_DYNAMIC_COPY`) APIs.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: DMA的目标目的地取决于(`GL_STREAM_DRAW`, `GL_STREAM_READ`, `GL_STREAM_COPY`, `GL_STATIC_DRAW`,
    `GL_STATIC_READ`, `GL_STATIC_COPY`, `GL_DYNAMIC_DRAW`, `GL_DYNAMIC_READ`, 或 `GL_DYNAMIC_COPY`)
    API的使用提示。
- en: In contrast, the `glMapBufferRange` method is considered much more efficient.
    The API first hooks a memory location directly into the driver memory space. This
    pinned memory location is available through a pointer to the application. This
    pointer can be directly used to update the location for the uploading or downloading
    of data for read/write purposes. Once the operation on the mapped location for
    read/write is completed, the pointer can be made invalid by calling `glUnMapBuffer`.
    This API call hints the OpenGL ES pipeline to push the updated data to the GPU
    memory using DMA calls.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，`glMapBufferRange`方法被认为效率更高。API首先将一个内存位置直接钩接到驱动程序内存空间中。这个固定的内存位置可以通过指向应用程序的指针来访问。这个指针可以直接用来更新上传或下载数据的位置。一旦对映射位置的读写操作完成，可以通过调用`glUnMapBuffer`使指针无效。这个API调用提示OpenGL
    ES管道使用DMA调用将更新后的数据推送到GPU内存。
- en: '![How it works...](img/5527OT_03_03.jpg)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理](img/5527OT_03_03.jpg)'
- en: See also
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to the *Swizzling* recipe in [Appendix](apa.html "Appendix A. Supplementary
    Information on OpenGL ES 3.0"), *Supplementary Information on OpenGL ES 3.0*
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[附录](apa.html "附录 A. OpenGL ES 3.0 补充信息")中的*Swizzling*配方，*OpenGL ES 3.0 补充信息*
- en: Refer to the *Transform feedback particle system with sync objects and fences*
    recipe in [Chapter 12](ch12.html "Chapter 12. Real-time Shadows and Particle System"),
    *Real-time Shadows and Particle System*
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅[第12章](ch12.html "第12章. 实时阴影和粒子系统")中的*带有同步对象和栅栏的变换反馈粒子系统*配方，*实时阴影和粒子系统*
- en: Render multiple objects with geometry instancing
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用几何实例化渲染多个对象
- en: The geometry instancing allows us to render multiple instances of the same object
    in a single rendering API call. These multiple instances differ in their generic
    attributes, such as transformation matrices, color, scale, and so on. This feature
    is very useful to implement particle systems, crowd simulation, rendering of jungle
    trees, and so on. Compared to the traditional way of rendering multiple objects
    that use multiple rendering calls, this technique is very efficient as it requires
    a single API call. This reduces the overhead of CPU processing in sending multiple
    rendering calls to the OpenGL ES rendering engine.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 几何实例化允许我们在单个渲染API调用中渲染同一对象的多个实例。这些多个实例在通用属性上有所不同，例如变换矩阵、颜色、缩放等。这个特性对于实现粒子系统、人群模拟、丛林树木渲染等非常有用。与传统方式渲染多个对象相比，这种技术非常高效，因为它只需要一个API调用。这减少了将多个渲染调用发送到OpenGL
    ES渲染引擎的CPU处理开销。
- en: This recipe demonstrates the rendering of 1000 cubes using geometric instancing.
    For this, we will use 1000 matrices in a VBO. Each matrix contains a transformation
    to place a cube in the 3D space. The information of the matrices are updated using
    the range map buffer feature as discussed in the previous recipe. This allows
    us to pass new transformation data on the fly at run time. The transformed data
    contains new rotation and translated positions.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了使用几何实例化渲染1000个立方体的过程。为此，我们将使用VBO中的1000个矩阵。每个矩阵包含一个变换，用于将立方体放置在3D空间中。矩阵信息通过前一个配方中讨论的范围映射缓冲区功能进行更新。这允许我们在运行时动态传递新的变换数据。变换数据包含新的旋转和移动位置。
- en: '![Render multiple objects with geometry instancing](img/5527OT_03_04.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![使用几何实例化渲染多个对象](img/5527OT_03_04.jpg)'
- en: How to do it...
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: So far, in our recipes, the model-view-projection matrix is always treated as
    uniform in the vertex shader. For this recipe, we will make use of the VAO and
    declare the model-view-projection matrix as a generic attribute instead of a uniform.
    Since the matrix is an attribute, a new VBO is required. This VBO is stored in
    the `matrixId` variable. `RenderCube()` uses the map buffer to update transformation
    matrix data.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的配方中，模型视图投影矩阵在顶点着色器中始终被视为统一变量。对于这个配方，我们将使用VAO并将模型视图投影矩阵声明为一个通用属性，而不是统一变量。由于矩阵是一个属性，需要一个新的VBO。这个VBO存储在`matrixId`变量中。`RenderCube()`使用映射缓冲区来更新变换矩阵数据。
- en: 'Here are the steps to implement geometric instancing:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实现几何实例化的步骤如下：
- en: 'Create the vertex shader and add the following code. There is no change required
    for the fragment shader. It can be reused:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建顶点着色器并添加以下代码。对于片段着色器不需要任何更改，它可以被重用：
- en: '[PRE27]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In `Cube::InitModel()`, use the existing code and add a new VBO for matrix
    transformation. Get the ID of the generated buffer object in `matrixId`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cube::InitModel()`中，使用现有代码并添加一个新的VBO用于矩阵变换。在`matrixId`中获取生成的缓冲区对象的ID：
- en: '[PRE28]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Allocate the memory to the VBO for matrix transformation. The dimension variable
    is initialized with 10\. It gives the number of cubes along an axis. Therefore,
    along *x*, *y*, and *z* axes, *10 x 10 x1 0 = 1000 cubes*. The total size of the
    buffer would be size of *(GLfloat) * 16 (16 float elements in mat4) * 1000 (cubes)*:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为矩阵变换的VBO分配内存。维度变量初始化为10。它给出了沿轴的立方体数量。因此，沿*x*、*y*和*z*轴，*10 x 10 x 1 0 = 1000个立方体*。缓冲区的总大小将是*(GLfloat)
    * 16（mat4中的16个浮点元素）* * 1000（立方体）*：
- en: '[PRE29]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `glBufferData` uses `GL_DYNAMIC_DRAW`. This symbolic constant specifies
    that the buffer is going to contain some data that is dynamic in nature. In other
    words, the data will require updates in the buffer. This symbolic constant helps
    the graphics driver to manage buffer memory in the best possible way to achieve
    high-performance graphics rendering.
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`glBufferData`使用`GL_DYNAMIC_DRAW`。这个符号常量指定缓冲区将包含一些动态性质的数据。换句话说，数据需要在缓冲区中更新。这个符号常量帮助图形驱动程序以最佳方式管理缓冲区内存，以实现高性能的图形渲染。'
- en: 'In the same function, after creating the VAO (`Vertex_VAO_Id`), define the
    generic attribute states and configuration of the transformation matrix buffer
    object. This helps in saving the vertex array client states and the buffer binding
    in the VAO (`Vertex_VAO_Id`). The `glVertexAttribDivisor` calculates the instance
    ID from the total number of instances given. For more information, refer to the
    *There''s more…* section in this recipe:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一函数中，在创建VAO（`Vertex_VAO_Id`）之后，定义变换矩阵缓冲区对象的通用属性状态和配置。这有助于在VAO（`Vertex_VAO_Id`）中保存顶点数组客户端状态和缓冲区绑定。`glVertexAttribDivisor`从提供的实例总数计算实例ID。有关更多信息，请参阅本食谱中的*更多内容…*部分：
- en: '[PRE30]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In `Cube::RenderCube()`, use range buffer mapping to map the transformation
    buffer on the client-side memory. Update the data in the memory and unmap it.
    Use VAO and render the cube of cubes using the geometric instance API called `glDrawElementsInstanced`.
    This API''s last argument specifies the number of instances the given primitive
    will be rendered:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Cube::RenderCube()`函数中，使用范围缓冲区映射将变换缓冲区映射到客户端内存。更新内存中的数据，然后取消映射。使用VAO并通过调用几何实例API
    `glDrawElementsInstanced`渲染立方体的立方体。此API的最后一个参数指定了给定原语将被渲染的实例数：
- en: '[PRE31]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: How it works...
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The application first compiles the shader programs. This makes us aware of all
    the generic attribute locations used in the shader program. Create a VBO of 1000
    matrix elements. Each element represents a transformation matrix. This matrix
    element is updated with new values of the transformation of every frame in the
    `RenderCube` function.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序首先编译着色器程序。这使得我们了解在着色器程序中使用的所有通用属性位置。创建一个包含1000个矩阵元素的VBO。每个元素代表一个变换矩阵。此矩阵元素在`RenderCube`函数中通过每一帧的变换更新新值。
- en: 'The generic attributes are first enabled using `glEnableVertexAttribArray`.
    The data array is attached to the generic location with `glVertexAttribPointer`.
    The following figure shows how the OpenGL ES program API is attached to the layout
    location of the vertex shader to send data:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 首先使用`glEnableVertexAttribArray`启用通用属性。使用`glVertexAttribPointer`将数据数组附加到通用位置。以下图示展示了如何将OpenGL
    ES程序API附加到顶点着色器的布局位置以发送数据：
- en: '![How it works...](img/5527OT_03_05.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_03_05.jpg)'
- en: 'Note that the generic attributes are sent as a group of four. Therefore, for
    a 4 x 4 matrix, we will need four attribute locations. The start location of the
    attribute should be mentioned into the vertex shader using a layout qualifier:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，通用属性作为一组四个发送。因此，对于4 x 4矩阵，我们需要四个属性位置。属性的开始位置应使用布局限定符在顶点着色器中指定：
- en: '[PRE32]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The following figure shows how the attribute locations are managed by the compiler:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图示展示了编译器如何管理属性位置：
- en: '![How it works...](img/5527OT_03_06.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_03_06.jpg)'
- en: Similar to the other locations such as `VERTEX_LOCATION (0)` and `COLOR_LOCATION
    (1)`, the transformation matrix locations (`2`, `3`, `4`, `5`) also need to be
    enabled and attached to the array data.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他位置类似，例如`VERTEX_LOCATION (0)`和`COLOR_LOCATION (1)`，变换矩阵位置（`2`, `3`, `4`, `5`）也需要启用并附加到数组数据上。
- en: The `glVertexAttribDivisor` API is responsible for controlling the rate at which
    OpenGL ES advances the data from an instanced array. The first parameter of this
    API specifies the generic attribute that needs to be treated as an instanced array.
    This tells the OpenGL ES pipeline to use this attribute per instance rendering.
    For example, in this example, the generic attributes, `2`, `3`, `4`, `5`, are
    instanced attributes. Therefore, OpenGL ES consumes the data from the transformation
    matrix array as an instance ID. We will see how this instance ID is calculated
    in a moment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttribDivisor` API负责控制OpenGL ES从实例数组中推进数据的速率。此API的第一个参数指定了需要作为实例数组处理的通用属性。这告诉OpenGL
    ES管道使用此属性进行每个实例渲染。例如，在这个例子中，通用属性`2`、`3`、`4`、`5`是实例属性。因此，OpenGL ES将转换矩阵数组的数据作为实例ID消耗。我们将在稍后看到这个实例ID是如何计算的。'
- en: Note
  id: totrans-239
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The default value of the divisor is `0` when it is not specified in the program
    explicitly. If the divisor is `0`, the attribute index is advanced once per-vertex.
    If the divisor is not `0`, the attribute advances once per divisor instance of
    the set(s) of the vertices being rendered.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当在程序中未显式指定除数时，除数的默认值为`0`。如果除数为`0`，则属性索引在每个顶点处前进一次。如果除数不为`0`，则属性在每个除数实例的集合（组）中渲染时前进一次。
- en: '**Syntax**:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE33]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '| Variable | Description |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `index` | This specifies generic attribute layout location |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `index` | 这指定了通用属性布局位置 |'
- en: '| `divisor` | This specifies the number of instances that will pass between
    updates of the generic attribute at the index slot |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| `divisor` | 这指定了在索引槽更新通用属性之间的实例数量 |'
- en: The rendering of the geometric instancing requires special instanced-based drawing
    APIs from OpenGL ES 3.0, as mentioned here for array- and index-based geometric
    data.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 几何实例化渲染需要OpenGL ES 3.0的特殊基于实例的绘图API，如这里所述的基于数组和索引的几何数据。
- en: '**Syntax**:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**语法**:'
- en: '[PRE34]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '| Variable | Description |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 变量 | 描述 |'
- en: '| --- | --- |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `mode` | This specifies the type of the primitive that needs to be rendered
    |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| `mode` | 这指定了需要渲染的原始类型 |'
- en: '| `count` | This specifies the number of indices considered in the drawing
    |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `count` | 这指定了在绘图中考虑的索引数量 |'
- en: '| `type` | This is used by `glDrawElementsInstanced`, this specifies the data
    type of the indices stored |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 这由`glDrawElementsInstanced`使用，指定存储索引的数据类型 |'
- en: '| `indices` | This specifies the arrays containing the order of the indices
    |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `indices` | 这指定了包含索引顺序的数组 |'
- en: '| `primcount` | This specifies the number of copies to be rendered |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `primcount` | 这指定了要渲染的副本数量 |'
- en: In the present recipe, the `glDrawElementsInstanced` API is used to render multiple
    instances of the same object. This API works in conjunction with another API called
    `glVertexAttribDivisor`. In order to update the VBO matrix elements, buffer mapping
    is used, which is an efficient way to update the buffer elements. If the geometric
    data is not index based but array based, then `glDrawArraysInstanced` can be used.
    This API accepts almost the same parameters. Refer to the online *OpenGL ES 3.0
    Reference Manual* for more information.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前配方中，使用了`glDrawElementsInstanced` API来渲染相同对象的多个实例。此API与另一个名为`glVertexAttribDivisor`的API协同工作。为了更新VBO矩阵元素，使用了缓冲区映射，这是一种高效更新缓冲区元素的方法。如果几何数据不是基于索引而是基于数组，则可以使用`glDrawArraysInstanced`。此API接受几乎相同的参数。有关更多信息，请参阅在线*OpenGL
    ES 3.0 参考手册*。
- en: There's more...
  id: totrans-258
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The second attribute of `glVertexAttribDivisor` specifies the divisor. This
    divisor helps in calculating the instance ID from the total number of instances.
    The following figure shows a simple example of the working logic of this API.
    In this figure, we assumed that there are total five instances to be rendered,
    and the figure contains five matrices. When the divisor is `5`, it produces `5`
    instance ID of the (`0`, `1`, `2`, `3`, `4`). This instance ID will be used as
    an index to the transformation matrix array. Similarly, when the divisor is `2`,
    it generates three instances (`0`, `1`, `2`). It generates two instances (`0`,
    `1`) when the divisor is `3`.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '`glVertexAttribDivisor`的第二个属性指定了除数。这个除数有助于从实例总数中计算实例ID。以下图显示了此API工作逻辑的简单示例。在这个图中，我们假设有总共五个要渲染的实例，图中包含五个矩阵。当除数为`5`时，它产生`5`个实例ID（`0`、`1`、`2`、`3`、`4`）。这个实例ID将用作转换矩阵数组的索引。同样，当除数为`2`时，它生成三个实例（`0`、`1`、`2`）。当除数为`3`时，它生成两个实例（`0`、`1`）。'
- en: '![There''s more...](img/5527OT_03_07.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_03_07.jpg)'
- en: See also
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Managing VBO with Vertex Array Objects*'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用顶点数组对象管理VBO*'
- en: Refer to the *Efficient rendering with ETC2 compressed texture* and *Implementing
    Skybox with seamless cube mapping* recipes in [Chapter 7](ch07.html "Chapter 7. Textures
    and Mapping Techniques"), *Texture and Mapping Techniques*
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第7章](ch07.html "第7章。纹理和映射技术")中的*使用ETC2压缩纹理进行高效渲染*和*使用无缝立方映射实现Skybox*配方，*纹理和映射技术*
- en: Rendering multiple primitives with primitive restart
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用原始重启渲染多个原始形状
- en: OpenGL ES 3.0 introduced a new feature called primitive restart, where multiple
    disconnected geometry primitives can be rendered using a single API. This feature
    uses a special marker in the vertex data or the index data to concatenate different
    geometries of the same drawing type into a single batch. The restart primitive
    feature executes on the GPU. Therefore, it eliminates the communication overhead
    per drawing call. This provides high-performance graphics by avoiding multiple
    drawing calls from CPU to GPU.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 3.0引入了一个名为原始重启的新功能，其中可以使用单个API渲染多个断开连接的几何原始形状。该功能使用顶点数据或索引数据中的特殊标记将同一绘图类型的不同几何形状连接成一个批次。重启原始功能在GPU上执行。因此，它消除了每次绘图调用时的通信开销。这通过避免从CPU到GPU的多次绘图调用，提供了高性能的图形。
- en: The recipe shows us how to use the primitive restart technique to render a cube
    using two sets of geometries, which are separated by a special marker.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方展示了如何使用原始重启技术，通过两套几何形状来渲染一个立方体，这些几何形状由一个特殊的标记分隔。
- en: '![Rendering multiple primitives with primitive restart](img/5527OT_03_08.jpg)'
  id: totrans-267
  prefs: []
  type: TYPE_IMG
  zh: '![使用原始重启渲染多个原始形状](img/5527OT_03_08.jpg)'
- en: Getting ready
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The marker used by the restart primitive feature to separate geometries is the
    highest value of the data type with which the element index or vertex data array
    is specified. For instance, an index value of `GLushort` and `GLint` should be
    *0 x FFFF* (*65535*) and *0 x FFFFFFFF* (4*294967295*), respectively.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 重启原始功能用于分隔几何形状的标记是用于指定元素索引或顶点数据数组的特定数据类型的最高值。例如，`GLushort`和`GLint`的索引值应分别为*0x
    FFFF* (*65535*)和*0x FFFFFFFF* (4*294967295*)。
- en: How to do it...
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To render multiple primitives, follow these steps:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要渲染多个原始形状，请按照以下步骤操作：
- en: 'Define the cube vertices and indices, as shown here:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义立方体的顶点和索引，如下所示：
- en: '| Cube vertices | Indices |'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| 立方体顶点 | 索引 |'
- en: '| --- | --- |'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE35]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '|'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: '[PRE36]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '|'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '|'
- en: 'In order to render the cube with primitive restart, it must first of all be
    enabled, using `glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX)`. Specify the total
    size of the indice and include the number of markers that are used in the geometry
    indices:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使用原始重启渲染立方体，首先必须启用它，使用`glEnable(GL_PRIMITIVE_RESTART_FIXED_INDEX)`。指定索引的总大小，并包括在几何索引中使用的标记数量：
- en: '[PRE37]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: There's more...
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The other way in which the disconnected geometry primitives can be rendered
    is called triangle degeneration. Triangle degeneration is the capability of the
    GPU to recognize disconnected primitives in the triangle strip or triangle fan
    index information on the basis of some special pattern.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种渲染断开连接的几何原始形状的方法被称为三角形退化。三角形退化是指GPU能够根据某些特殊模式识别三角形带或三角形扇索引信息中的断开原始形状的能力。
- en: For example, the following figure shows the special index pattern data that
    can be used to render degenerated triangles using the `glDrawElement` or `glDrawElementsInstanced`
    API.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，以下图显示了可以使用`glDrawElement`或`glDrawElementsInstanced` API渲染退化三角形的特殊索引模式数据。
- en: '![There''s more...](img/5527OT_03_09.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_03_09.jpg)'
- en: 'The degeneration between the two geometries is achieved by repeating the last
    index of the previous geometry and the first index of the next primitive. This
    rule of degeneration is only applicable when the previous geometry contains an
    odd number of triangles. Behind the curtains, the triangle would be drawn in the
    following order: (0, 1, 2), (2, 1, 3), (2, 3, 3), (3, 3, 6), (3, 6, 6), (6, 6,
    7), (6, 7, 8), (8, 7, 10). The repeated indices form an area equivalent to zero,
    allowing the GPU to discard the triangles. These zero area triangles are mentioned
    using the bold font.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 两个几何形状之间的退化是通过重复前一个几何形状的最后一个索引和下一个原始形状的第一个索引来实现的。这种退化的规则仅适用于前一个几何形状包含奇数个三角形的情况。幕后，三角形将按照以下顺序绘制：(0,
    1, 2)，(2, 1, 3)，(2, 3, 3)，(3, 3, 6)，(3, 6, 6)，(6, 6, 7)，(6, 7, 8)，(8, 7, 10)。重复的索引形成一个等效于零的区域，允许GPU丢弃这些三角形。这些零面积三角形用粗体字提及。
- en: The second type of degeneration case is where the first geometry contains an
    odd number of triangles. For instance, the following image demonstrates the first
    geometry with three (odd) triangles. As per this case rule, the last index of
    the first geometry is repeated twice, followed by the first index of the second
    geometry.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种退化情况是第一种几何图形包含奇数个三角形。例如，以下图像展示了包含三个（奇数）三角形的第一个几何图形。根据此规则，第一个几何图形的最后一个索引重复两次，然后是第二个几何图形的第一个索引。
- en: '![There''s more...](img/5527OT_03_10.jpg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_03_10.jpg)'
- en: 'For instance, the indices specified for degenerate triangles (0, 1, 2, 3, 4,
    4, 4, 8, 8, 9, 10, 11) generate the following triangles: (0, 1, 2), (2, 1, 3),
    (2, 3, 4), (4, 3, 4), (4, 4, 4), (4, 4, 6), (4, 6, 6), (6, 6, 9), (6, 7, 8), (8,
    7, 9), (9, 8, 10).'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，为退化三角形指定的索引（0, 1, 2, 3, 4, 4, 4, 8, 8, 9, 10, 11）生成以下三角形：（0, 1, 2），（2, 1,
    3），（2, 3, 4），（4, 3, 4），（4, 4, 4），（4, 4, 6），（4, 6, 6），（6, 6, 9），（6, 7, 8），（8, 7,
    9），（9, 8, 10）。
- en: See also
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Using the per-vertex attribute to send data to a shader* recipe
    in [Chapter 1](ch01.html "Chapter 1. OpenGL ES 3.0 on Android/iOS"), *OpenGL ES
    3.0 on Android/iOS*
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第1章中的*使用顶点属性将数据发送到着色器*配方，*OpenGL ES 3.0在Android/iOS上*，[第1章](ch01.html "Chapter 1. OpenGL
    ES 3.0 on Android/iOS")
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第2章中的*使用顶点缓冲对象进行高效渲染*配方，*OpenGL ES 3.0基础知识*，[第2章](ch02.html "Chapter 2. OpenGL
    ES 3.0 Essentials")
