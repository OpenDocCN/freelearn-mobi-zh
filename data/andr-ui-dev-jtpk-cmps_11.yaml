- en: 'Chapter 8: Working with Animations'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章：使用动画
- en: In the previous chapters, I introduced you to many technical aspects of Jetpack
    Compose and showed you how to write well-behaving and good-looking apps. Now,
    adding animations and transitions will make your apps really shine! Compose simplifies
    the process of adding animation effects greatly over the old View-based approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我向您介绍了Jetpack Compose的许多技术方面，并展示了如何编写表现良好且外观美观的应用。现在，添加动画和过渡将使您的应用真正闪耀！Compose在添加动画效果方面极大地简化了旧视图方法的过程。
- en: In this chapter, you will learn important animation-related application programming
    interfaces, see animations of single and multiple properties, as well as transitions
    between composables in action, and master the relationship between state changes
    and visual interactions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习重要的动画相关应用程序编程接口，看到单多个属性的动画，以及组合件之间的过渡动作，并掌握状态变化和视觉交互之间的关系。
- en: 'The main sections of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要部分如下：
- en: Using animation to visualize state changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画来可视化状态变化
- en: Showing and hiding UI elements with animations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动画显示和隐藏UI元素
- en: Spicing up transitions through visual effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过视觉效果增强过渡
- en: 'We start by using animations to visualize state changes. Think of a simple
    use case: clicking a button might change the color of a UI object. But, just switching
    between colors feels somewhat abrupt, whereas a gradual change is much more visually
    pleasing. Also, if you want to change several values during the animation, Jetpack
    Compose can do that easily, too. I''ll introduce you to the `updateTransition()`
    composable, which is used in such scenarios.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先使用动画来可视化状态变化。考虑一个简单的用例：点击按钮可能会改变UI对象的颜色。但是，只是颜色之间的切换感觉有些突然，而渐变变化则更加视觉上令人愉悦。此外，如果您想在动画期间更改多个值，Jetpack
    Compose也可以轻松做到。我将向您介绍`updateTransition()`组合函数，它用于此类场景。
- en: The *Showing and hiding UI elements with animations* section introduces you
    to the `AnimatedVisibility()` composable function. It allows you to apply enter
    and exit transitions, which will be played back while the content appears or disappears.
    We will also animate size changes and learn about the corresponding `animateContentSize()`
    modifier.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*使用动画显示和隐藏UI元素*这一节介绍了`AnimatedVisibility()`组合函数。它允许你应用进入和退出过渡，这些过渡将在内容出现或消失时播放。我们还将动画化尺寸变化，并了解相应的`animateContentSize()`修饰符。'
- en: In the *Spicing up transitions through visual effects* section, we will be using
    the `Crossfade()` composable to switch between two layouts with a crossfade animation.
    Furthermore, you will learn about `AnimationSpec`. This interface represents the
    specification of an animation. A take on infinite animations concludes the section.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在*通过视觉效果增强过渡*这一节中，我们将使用`Crossfade()`组合函数通过交叉淡入淡出动画在两个布局之间切换。此外，你还将了解`AnimationSpec`。此接口表示动画的规范。无限动画的探讨结束了这一节。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter is based on the `AnimationDemo` sample. Please refer to the *Technical
    requirements* section in [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio, and how to get the repository accompanying this book.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于`AnimationDemo`示例。请参考[*第1章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个Compose应用*，了解如何安装和设置Android
    Studio，以及如何获取本书的配套仓库。
- en: All the code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码文件都可以在GitHub上找到，网址为[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_08)。
- en: Using animation to visualize state changes
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画来可视化状态变化
- en: 'State is app data that may change over time. In a Compose app, state (for example,
    a color) is represented through `State` or `MutableState` instances. State changes
    trigger recompositions. The following example shows a button and a box. Clicking
    the button toggles the color of the box between red and white by changing state:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 状态是可能随时间变化的应用数据。在Compose应用中，状态（例如，颜色）通过`State`或`MutableState`实例表示。状态变化会触发重新组合。以下示例显示了一个按钮和一个盒子。点击按钮会通过改变状态在盒子的红色和白色之间切换颜色：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this example, `color` is a simple immutable variable. It is set each time
    `toggled` (a mutable `Boolean` state) changes (this happens inside `onClick`).
    As `color` is used with a modifier applied to `Box()` (`background(color = color)`),
    clicking the button changes the box color.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`color` 是一个简单的不可变变量。每次 `toggled`（一个可变的 `Boolean` 状态）改变时（这发生在 `onClick`
    内部），它都会被设置。由于 `color` 与应用于 `Box()` 的修饰符一起使用（`background(color = color)`），点击按钮会改变盒子的颜色。
- en: If you try the code, the switch feels very sudden and abrupt. This is because
    white and red are not very similar. Using an animation will make the change much
    more pleasant. Let's see how this works.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您尝试这段代码，开关的感觉非常突然和生硬。这是因为白色和红色并不非常相似。使用动画会使变化更加愉快。让我们看看它是如何工作的。
- en: Animating single value changes
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化单个值的变化
- en: 'To animate a color, you can use the built-in `animateColorAsState()` composable.
    Replace the `val color = if (toggled) …` assignment inside `StateDemo()` with
    the following code block. If you want to try it out, you can find a composable
    function called `SingleValueAnimationDemo()` in `AnimationDemoActivity.kt`, which
    belongs to the `AnimationDemo` sample:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 要动画化颜色，您可以使用内置的 `animateColorAsState()` 可组合函数。将 `StateDemo()` 内部的 `val color
    = if (toggled) …` 赋值替换为以下代码块。如果您想尝试它，您可以在 `AnimationDemoActivity.kt` 中找到一个名为 `SingleValueAnimationDemo()`
    的可组合函数，它属于 `AnimationDemo` 示例：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`animateColorAsState()` returns a `State<Color>` instance. Whenever `targetValue`
    changes, the animation will run automatically. If the change occurs while the
    animation is in progress, the ongoing animation will adjust to match the new target
    value.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`animateColorAsState()` 返回一个 `State<Color>` 实例。每当 `targetValue` 发生变化时，动画将自动运行。如果变化发生在动画进行中，正在进行的动画将调整以匹配新的目标值。'
- en: Tip
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Using the `by` keyword, you can access the color state like ordinary variables.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `by` 关键字，您可以像访问普通变量一样访问颜色状态。
- en: 'You can provide an optional listener to get notified when the animation is
    finished. The following line of code prints the color that matches the new state:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以提供一个可选的监听器，以便在动画完成后收到通知。以下代码行打印出与新状态匹配的颜色：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To customize your animation, you can pass an instance of `AnimationSpec<Color>`
    to `animateColorAsState()`. The default value is `colorDefaultSpring`, a private
    value in `SingleValueAnimation.kt`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 要自定义您的动画，您可以将 `AnimationSpec<Color>` 的实例传递给 `animateColorAsState()`。默认值是 `colorDefaultSpring`，它是
    `SingleValueAnimation.kt` 中的一个私有值：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '`spring()` is a top-level function in `AnimationSpec.kt`. It receives a damping
    ratio, a stiffness, and a visibility threshold. The following line of code makes
    the color animation very soft:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring()` 是 `AnimationSpec.kt` 中的一个顶级函数。它接收阻尼比、刚度和可见性阈值。以下代码行使颜色动画非常柔和：'
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`spring()` returns `SpringSpec`. This class implements the `FiniteAnimationSpec`
    interface, which in turn extends `AnimationSpec`. This interface defines the specification
    of an animation, which includes the data type to be animated and the animation
    configuration, in this case, a spring metaphor. There are others. We will be returning
    to this interface in the *Spicing up transitions through visual effects* section.
    Next, we look at animating multiple value changes.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '`spring()` 返回 `SpringSpec`。这个类实现了 `FiniteAnimationSpec` 接口，该接口反过来又扩展了 `AnimationSpec`。这个接口定义了动画的规范，包括要动画化的数据类型和动画配置，在这种情况下，是一个弹簧隐喻。还有其他一些。我们将在
    *通过视觉效果增强过渡* 部分回到这个接口。接下来，我们将查看如何动画化多个值的变化。'
- en: Animating multiple value changes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画化多个值的变化
- en: 'In this section, I will show you how to animate several values at once upon
    a state change. The setup is similar to `StateDemo()` and `SingleValueAnimationDemo()`:
    a `Column()` instance contains a `Button()` instance and a `Box()` instance. But
    this time, the content of the box is `Text()`. The button toggles a state, which
    starts the animation.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向您展示如何在状态改变时同时动画化几个值。设置类似于 `StateDemo()` 和 `SingleValueAnimationDemo()`：一个
    `Column()` 实例包含一个 `Button()` 实例和一个 `Box()` 实例。但这次，盒子中的内容是 `Text()`。按钮切换状态，从而启动动画。
- en: 'The following version of `MultipleValuesAnimationDemo()` does not yet contain
    an animation. It will be inserted below the comment reading **FIXME: animation
    setup missing**:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '以下版本的 `MultipleValuesAnimationDemo()` 还不包含动画。它将被插入到读取为 **FIXME: animation setup
    missing** 的注释下方：'
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Box()` shows a black border, whose width is controlled by `borderWidth`.
    To apply borders to your composable functions, just add the `border()` modifier.
    `Text()` is rotated. You can achieve this with the `rotate()` modifier. The `degrees`
    variable holds the angle. `degrees` and `borderWidth` will change during the animation.
    Here''s how this is done:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box()` 显示一个黑色边框，其宽度由 `borderWidth` 控制。要为你的可组合函数应用边框，只需添加 `border()` 修饰符。`Text()`
    被旋转。你可以使用 `rotate()` 修饰符实现这一点。`degrees` 变量持有角度。`degrees` 和 `borderWidth` 将在动画过程中发生变化。以下是实现方式：'
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `updateTransition()` composable function configures and returns a `Transition`.
    When `targetState` changes, the transition will run all of its child animations
    toward their target values. Child animations are added using `animate…()` functions.
    They are not part of a `Transition` instance but are extension functions. `animateDp()`
    adds an animation based on density-independent pixels.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`updateTransition()` 可组合函数配置并返回一个 `Transition`。当 `targetState` 发生变化时，转换将运行其所有子动画以达到目标值。子动画通过
    `animate…()` 函数添加。它们不是 `Transition` 实例的一部分，而是扩展函数。`animateDp()` 基于密度无关像素添加动画。'
- en: In my example, it controls the border width. `animateFloat()` creates a `Float`
    animation. This function is ideal for changing the rotation of `Text()`, which
    is a `Float` value. There are more `animate…()` functions, which operate on other
    data types. For example, `animateInt()` works with `Int` values. `animateOffset()`
    animates an `Offset` instance. You can find them in the `Transition.kt` file,
    which belongs to the `androidx.compose.animation.core` package.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的示例中，它控制边框宽度。`animateFloat()` 创建一个 `Float` 动画。这个函数非常适合改变 `Text()` 的旋转，因为 `Text()`
    是一个 `Float` 值。还有更多的 `animate…()` 函数，它们作用于其他数据类型。例如，`animateInt()` 与 `Int` 值一起工作。`animateOffset()`
    动画化一个 `Offset` 实例。你可以在 `Transition.kt` 文件中找到它们，该文件属于 `androidx.compose.animation.core`
    包。
- en: '`Transition` instances provide several properties reflecting the status of
    a transition. For example, `isRunning` indicates whether any animation in the
    transition is currently running. `segment` contains the initial state and the
    target state of the currently ongoing transition. The current state of the transition
    is available through `currentState`. This will be the initial state until the
    transition is finished. Then, `currentState` is set to the target state.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Transition` 实例提供了一些反映转换状态的属性。例如，`isRunning` 指示转换中的任何动画是否正在运行。`segment` 包含当前正在进行的转换的初始状态和目标状态。转换的当前状态可通过
    `currentState` 获取。这将是在转换完成之前的初始状态。然后，`currentState` 被设置为目标状态。'
- en: As you have seen, it is very easy to use state changes to trigger animations.
    So far, these animations have modified the visual appearance of one or more composable
    functions. In the next section, I will show you how to apply animations while
    showing or hiding UI elements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，使用状态变化来触发动画非常简单。到目前为止，这些动画已经修改了一个或多个可组合函数的视觉外观。在下一节中，我将向你展示如何在显示或隐藏 UI
    元素时应用动画。
- en: Showing and hiding UI elements with animations
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画显示和隐藏 UI 元素
- en: Often, your UI will contain information that need not be visible all the time.
    For example, in an address book you may want to show only key attributes of a
    contact, and present detailed information upon request, typically after a button
    click. However, just showing and hiding the additional data feels sudden and abrupt.
    Using animations leads to a more pleasant experience, so let's look into this
    more.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你的 UI 将包含不需要始终可见的信息。例如，在地址簿中，你可能只想显示联系人的关键属性，并在请求时提供详细信息，通常是在按钮点击后。然而，仅仅显示和隐藏附加数据会感觉突然且生硬。使用动画可以使体验更加愉快，所以让我们更深入地了解一下。
- en: Understanding AnimatedVisibility()
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 `AnimatedVisibility()`
- en: 'In this section, we will look at my sample composable `AnimatedVisibilityDemo()`.
    It belongs to the `AnimationDemo` project. Like `StateDemo()`, `SingleValueAnimationDemo()`,
    and `MultipleValuesAnimationDemo()`, it uses a `Column()` instance, which contains
    a `Button()` instance and a `Box()` instance. This part of the code is simple
    and straightforward, so there is no need to repeat it in print. The button toggles
    a state, which starts the animation. Let''s see how this works:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看我的示例可组合函数 `AnimatedVisibilityDemo()`。它属于 `AnimationDemo` 项目。与 `StateDemo()`、`SingleValueAnimationDemo()`
    和 `MultipleValuesAnimationDemo()` 类似，它使用一个 `Column()` 实例，该实例包含一个 `Button()` 实例和一个
    `Box()` 实例。这部分代码简单直接，因此无需在打印中重复。按钮切换状态，从而启动动画。让我们看看它是如何工作的：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The box is wrapped in `AnimatedVisibility()`. This built-in composable function
    animates the appearance and disappearance of its content, when the `visible` parameter
    changes. You can specify different `EnterTransition` and `ExitTransition` instances.
    In my example, the box enters by sliding in horizontally and exits by sliding
    out vertically.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 框架被包裹在 `AnimatedVisibility()` 中。这个内置的可组合函数在 `visible` 参数变化时动画其内容的出现和消失。你可以指定不同的
    `EnterTransition` 和 `ExitTransition` 实例。在我的例子中，框架通过水平滑动进入，通过垂直滑动退出。
- en: 'Currently, there are three transition types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，有三种过渡类型：
- en: Fade
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 淡入
- en: Expand and shrink
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展和缩小
- en: Slide
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滑动
- en: 'They can be combined using `+`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以通过 `+` 组合使用：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The combination order doesn't matter as the animations start simultaneously.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 组合顺序并不重要，因为动画是同时开始的。
- en: If you do not pass a value for `enter`, the content will default to fading in
    while expanding vertically. Omitting `exit` will cause the content to fade out
    while shrinking vertically.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有为 `enter` 传递值，内容将默认在垂直扩展的同时淡入。省略 `exit` 将导致内容在垂直缩小的同时淡出。
- en: Please Note
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意
- en: At the time of writing, `AnimatedVisibility()` is experimental. To use it in
    your app, you must add the `@ExperimentalAnimationApi` annotation. This will change
    with Jetpack Compose 1.1.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，`AnimatedVisibility()` 是实验性的。要在你的应用中使用它，你必须添加 `@ExperimentalAnimationApi`
    注解。这将在 Jetpack Compose 1.1 中改变。
- en: In this section, I showed you how to animate the appearance and disappearance
    of content. A variation of this subject is to visualize size changes (if either
    `width`, `height`, or both are `0`, the UI element is no longer visible). Let's
    find out how to do this in the following section.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我向你展示了如何动画内容的出现和消失。这个主题的一个变体是可视化大小变化（如果 `width`、`height` 或两者都是 `0`，则 UI
    元素不再可见）。让我们在下一节中找出如何做到这一点。
- en: Animating size changes
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画大小变化
- en: 'Sometimes you may want to change the amount of space a UI element requires
    onscreen. Think of text fields. In compact mode, your app could show only three
    lines, whereas in detail mode it might display 10 lines or more. My `SizeChangeAnimationDemo()`
    sample composable (*Figure 8.1*) uses a slider to control the `maxLines` value
    of `Text()`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能想改变 UI 元素在屏幕上所需的空间量。想想文本字段。在紧凑模式下，你的应用可能只显示三行，而在详细模式下可能显示 10 行或更多。我的 `SizeChangeAnimationDemo()`
    示例可组合函数（*图 8.1*）使用滑块来控制 `Text()` 的 `maxLines` 值：
- en: '![Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 显示 SizeChangeAnimationDemo() 的 AnimationDemo 示例](img/B17505_08_1.jpg)'
- en: '](img/B17505_08_1.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.1 – 显示 SizeChangeAnimationDemo() 的 AnimationDemo 示例](img/B17505_08_1.jpg)'
- en: Figure 8.1 – The AnimationDemo sample showing SizeChangeAnimationDemo()
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 显示 SizeChangeAnimationDemo() 的 AnimationDemo 示例
- en: 'The general setup follows the examples from the previous sections: a `Column()`
    instance acts as a container for some composable functions, in this case a `Slider()`
    instance and a `Text()` instance. Then a state change triggers the animation.
    Here is the code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通用设置遵循上一节中的示例：一个 `Column()` 实例作为一些可组合函数的容器，在本例中是一个 `Slider()` 实例和一个 `Text()`
    实例。然后状态变化触发动画。以下是代码：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`size` is a mutable `Float` state. It is passed to `Slider()` as its default
    value. When the slider is moved, `onValueChange {}` is invoked. The lambda expression
    receives the new value, which is assigned to `size`. The `Text()` composable uses
    the state as a value for `maxLines`.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`size` 是一个可变的 `Float` 状态。它被传递给 `Slider()` 作为其默认值。当滑块被移动时，`onValueChange {}`
    被调用。lambda 表达式接收新值，并将其分配给 `size`。`Text()` 可组合函数使用状态作为 `maxLines` 的值。'
- en: 'The animation is handled by the `animateContentSize()` modifier. It belongs
    to the `androidx.compose.animation` package. The modifier expects two parameters,
    `animationSpec` and `finishedListener`. I introduced both briefly in the *Animating
    single value changes* section. `animationSpec` defaults to `spring()`. If you
    want the lines to appear all at once after some delay, you can add the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 动画由 `animateContentSize()` 修饰符处理。它属于 `androidx.compose.animation` 包。该修饰符期望两个参数，`animationSpec`
    和 `finishedListener`。我在 *动画单个值变化* 部分简要介绍了这两个。`animationSpec` 默认为 `spring()`。如果你想在延迟后一次性显示所有线条，可以添加以下内容：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: A snap animation immediately switches the animating value to the end value.
    You pass the number of milliseconds to wait before the animation runs. It defaults
    to `0`. Now, `snap()` returns an instance of `SnapSpec`, an implementation of
    `AnimationSpec`. We will turn to this interface in the *Spicing up transitions
    through visual effects* section.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 快照动画立即将动画值切换到最终值。您需要传递动画运行前等待的毫秒数。默认值为`0`。现在，`snap()`返回一个`SnapSpec`实例，它是`AnimationSpec`的实现。我们将在*通过视觉效果增强过渡效果*部分转向此接口。
- en: The default value of `finishedListener` is `null`. You can provide an implementation,
    if your app wants to get notified when the size change animation is finished.
    Both the initial value and the final size are passed to the listener. If the animation
    is interrupted, the initial value will be the size at the point of interruption.
    This helps determine the direction of the size change.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`finishedListener`的默认值是`null`。如果您希望当大小变化动画完成时收到通知，您可以提供实现。初始值和最终大小都会传递给监听器。如果动画被中断，初始值将是中断点的大小。这有助于确定大小变化的方向。'
- en: This concludes our look at showing and hiding UI elements with animations. In
    the next section, we focus on exchanging parts of the UI. For example, we will
    be using `Crossfade()` to switch between two composable functions with a crossfade
    animation.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们关于使用动画显示和隐藏UI元素的探讨。在下一节中，我们将专注于交换UI的某些部分。例如，我们将使用`Crossfade()`通过交叉淡入淡出动画在两个可组合函数之间切换。
- en: Spicing up transitions through visual effects
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过视觉效果增强过渡效果
- en: 'So far, I have shown you animations that modify certain aspects of a UI element,
    like its color, size, or visibility. But sometimes you may want to *exchange*
    parts of your UI. Then, `Crossfade()` comes in handy. It allows you to switch
    between two composable functions with a crossfade animation. Let''s look at my
    `CrossfadeAnimationDemo()` sample (*Figure 8.2*), part of the `AnimationDemo`
    project, to see how this works:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我向您展示了修改UI元素某些方面的动画，例如其颜色、大小或可见性。但有时您可能想要*交换*UI的某些部分。这时，`Crossfade()`就派上用场了。它允许您通过交叉淡入淡出动画在两个可组合函数之间切换。让我们看看我的`CrossfadeAnimationDemo()`示例（*图8.2*），它是`AnimationDemo`项目的一部分，看看它是如何工作的：
- en: '![Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 显示CrossfadeAnimationDemo()的AnimationDemo示例]'
- en: '](img/B17505_08_2.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_08_2.jpg]'
- en: Figure 8.2 – The AnimationDemo sample showing CrossfadeAnimationDemo()
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 显示CrossfadeAnimationDemo()的AnimationDemo示例
- en: A switch toggles between two screens. As we are focusing on animation, I kept
    the `Screen()`composable very simple, just a box with customizable background
    color, and a big text centered inside. You can find its source code in `AnimationDemoActivity.kt`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 开关在两个屏幕之间切换。由于我们专注于动画，我保持了`Screen()`可组合的简单性，只是一个可自定义背景颜色的盒子，以及一个居中的大文本。您可以在`AnimationDemoActivity.kt`中找到其源代码。
- en: Crossfading composable functions
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 混叠可组合函数
- en: 'Like most examples in this chapter, `CrossfadeAnimationDemo()` uses a `Column()`
    as the root element. The column contains a switch, and the screen to display.
    Which one is shown depends on a mutable `Boolean` state:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与本章中的大多数示例一样，`CrossfadeAnimationDemo()`使用`Column()`作为根元素。该列包含一个开关和要显示的屏幕。显示哪个取决于一个可变的`Boolean`状态：
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `onCheckedChange` lambda expression of `Switch()` toggles `isFirstScreen`.
    This state is passed to `Crossfade()` as the `targetState` parameter. Like in
    the other animations I showed you so far, it triggers the animation every time
    the value changes. Specifically, the content called with the old value will be
    faded out, and the content called with the new one will be faded in.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Switch()`的`onCheckedChange` lambda表达式切换`isFirstScreen`。这个状态作为`targetState`参数传递给`Crossfade()`。像之前我向您展示的其他动画一样，每次值改变时都会触发动画。具体来说，调用旧值的内联内容将淡出，而调用新值的内联内容将淡入。'
- en: '`Crossfade()` receives an `animationSpec` of type `FiniteAnimationSpec<Float>`.
    It defaults to `tween()`. This function returns a `TweenSpec` instance configured
    with the given duration, delay, and easing curve. The parameters default to `DefaultDurationMillis`
    (300 ms), `0`, and `FastOutSlowInEasing`. The easing curve is represented by instances
    of `CubicBezierEasing`. This class models third-order Bézier curves. Its constructor
    receives four parameters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Crossfade()`接收一个类型为`FiniteAnimationSpec<Float>`的`animationSpec`。默认为`tween()`。此函数返回一个配置了给定持续时间、延迟和缓动曲线的`TweenSpec`实例。参数默认为`DefaultDurationMillis`（300毫秒）、`0`和`FastOutSlowInEasing`。缓动曲线由`CubicBezierEasing`类的实例表示。此类模拟三阶贝塞尔曲线。其构造函数接收四个参数：'
- en: The *x* and *y* coordinates of the first control point
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个控制点的*x*和*y*坐标
- en: The *x* and *y* coordinates of the second control point
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个控制点的*x*和*y*坐标
- en: 'The documentation explains that the line through the point (0, 0) and the first
    control point is tangent to the easing at the point (0, 0), and that the line
    through the point (1, 1) and the second control point is tangent to the easing
    at the point (1, 1). `CubicBezierEasing` is an implementation of the `Easing`
    interface (the `androidx.compose.animation.core` package). Besides `FastOutSlowInEasing`,
    you can choose from three other predefined curves: `LinearOutSlowInEasing`, `FastOutLinearInEasing`,
    and `LinearEasing` to customize your animation.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 文档解释说，通过点(0, 0)和第一个控制点的线在点(0, 0)处与缓动函数相切，而通过点(1, 1)和第二个控制点的线在点(1, 1)处与缓动函数相切。`CubicBezierEasing`是`Easing`接口的实现（位于`androidx.compose.animation.core`包中）。除了`FastOutSlowInEasing`之外，你还可以从其他三个预定义曲线中选择：`LinearOutSlowInEasing`、`FastOutLinearInEasing`和`LinearEasing`来自定义你的动画。
- en: 'As `Crossfade()` receives an `animationSpec` of type `FiniteAnimationSpec<Float>`,
    you can, for example, pass the following code to use a spring animation with very
    low stiffness:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Crossfade()`接收一个类型为`FiniteAnimationSpec<Float>`的`animationSpec`，例如，你可以传递以下代码来使用具有非常低刚度的弹簧动画：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the next section, we look at how the different specifications of an animation
    are related.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨动画的不同规范之间的关系。
- en: Understanding animation specifications
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解动画规范
- en: '`AnimationSpec` is the base interface for defining animation specifications.
    It stores the data type to be animated and the animation configuration. Its only
    function, `vectorize()`, creates a `VectorizedAnimationSpec` instance with the
    given `TwoWayConverter` (which converts a given type to and from `AnimationVector`).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`AnimationSpec`是定义动画规范的基接口。它存储要动画化的数据类型和动画配置。它的唯一功能`vectorize()`，创建一个带有给定`TwoWayConverter`（将给定类型转换为`AnimationVector`并从`AnimationVector`转换回）的`VectorizedAnimationSpec`实例。'
- en: The animation system operates on `AnimationVector` instances. `VectorizedAnimationSpec`
    describes how these vectors should be animated, for example, simply interpolating
    between the start and end values (as you have seen with `TweenSpec`), showing
    no animation at all (`SnapSpec`), or applying spring physics to produce the motion
    (`SpringSpec`).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 动画系统在`AnimationVector`实例上操作。`VectorizedAnimationSpec`描述了这些向量应该如何被动画化，例如，简单地插值于起始值和结束值之间（正如你在`TweenSpec`中看到的），完全不显示动画（`SnapSpec`），或者应用弹簧物理来产生运动（`SpringSpec`）。
- en: The `FiniteAnimationSpec` interface extends `AnimationSpec`. It is directly
    implemented by the `RepeatableSpec` and `SpringSpec` classes. It overrides `vectorize()`
    to return `VectorizedFiniteAnimationSpec`. Now, `FiniteAnimationSpec` is the parent
    of the interface `DurationBasedAnimationSpec`, which overrides `vectorize()` to
    return `VectorizedDurationBasedAnimationSpec`. Then, `DurationBasedAnimationSpec`
    is implemented by the `TweenSpec`, `SnapSpec`, and `KeyframesSpec` classes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`FiniteAnimationSpec`接口扩展了`AnimationSpec`。它直接由`RepeatableSpec`和`SpringSpec`类实现。它重写了`vectorize()`方法以返回`VectorizedFiniteAnimationSpec`。现在，`FiniteAnimationSpec`是接口`DurationBasedAnimationSpec`的父接口，该接口重写了`vectorize()`方法以返回`VectorizedDurationBasedAnimationSpec`。然后，`DurationBasedAnimationSpec`由`TweenSpec`、`SnapSpec`和`KeyframesSpec`类实现。'
- en: 'To create a `KeyframesSpec` instance, you can invoke the `keyframes()` function
    and pass an initialization function for the animation. After the duration of the
    animation, you pass mappings of the animating value at a given amount of time
    in milliseconds:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`KeyframesSpec`实例，你可以调用`keyframes()`函数并传递一个用于动画的初始化函数。在动画的持续时间之后，你传递在给定毫秒数的时间点上的动画值的映射：
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this example, the animation takes 8 seconds, which is longer than you'd ever
    practically use, but allows you to observe the changes. If you apply the code
    snippet to `CrossfadeAnimationDemo()`, you will notice that each letter is visible
    twice during the course of the animation.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，动画持续了8秒，这比实际使用中你可能会用到的任何时间都要长，但它允许你观察这些变化。如果你将代码片段应用到`CrossfadeAnimationDemo()`中，你会注意到在动画过程中每个字母都可见两次。
- en: So far, we have looked at finite animations. What if you want an animation to
    continue forever? Jetpack Compose does this in the `CircularProgressIndicator()`
    and `LinearProgressIndicator()` composables. `InfiniteRepeatableSpec` repeats
    the provided animation until it is canceled manually.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了有限动画。如果你想要一个动画永远继续下去怎么办？Jetpack Compose在`CircularProgressIndicator()`和`LinearProgressIndicator()`可组合组件中这样做。`InfiniteRepeatableSpec`会重复提供的动画，直到手动取消。
- en: When used with transitions or other animation composables, the animation will
    stop when the composable is removed from the compose tree. `InfiniteRepeatableSpec`
    implements `AnimationSpec`. The constructor expects two arguments, `animation`
    and `repeatMode`. The `RepeatMode` enum class defines two values, `Restart` and
    `Reverse`. The default value for `repeatMode` is `RepeatMode.Restart`, meaning
    each repeat restarts from the beginning.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 当与过渡或其他动画组合组件一起使用时，当组合组件从Compose树中移除时，动画将停止。`InfiniteRepeatableSpec`实现了`AnimationSpec`接口。构造函数期望两个参数，`animation`和`repeatMode`。`RepeatMode`枚举类定义了两个值，`Restart`和`Reverse`。`repeatMode`的默认值是`RepeatMode.Restart`，意味着每次重复都从开始处重新开始。
- en: 'You can use `infiniteRepeatable()` to create an `InfiniteRepeatableSpec` instance.
    My `InfiniteRepeatableDemo()` sample composable (*Figure 8.3*) shows you how to
    do this:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`infiniteRepeatable()`来创建一个`InfiniteRepeatableSpec`实例。我的`InfiniteRepeatableDemo()`示例组合组件（*图8.3*）展示了如何做到这一点：
- en: '![Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 显示InfiniteRepeatableDemo()的AnimationDemo示例](img/B17505_08_3.jpg)'
- en: '](img/B17505_08_3.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_08_3.jpg)'
- en: Figure 8.3 – The AnimationDemo sample showing InfiniteRepeatableDemo()
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 显示InfiniteRepeatableDemo()的AnimationDemo示例
- en: 'The composable rotates a text clockwise from 0 to 359 degrees. Then, the animation
    restarts. `Text()` is centered inside `Box()`:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 可组合的组件将文本顺时针旋转0到359度。然后，动画重新开始。`Text()`组件在`Box()`组件内居中：
- en: '[PRE14]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To create a potentially infinite animation, you first need to remember an infinite
    transition using `rememberInfiniteTransition()`. You can then invoke `animateFloat()`
    on the transition instance. This returns `State<Float>`, which is used with the
    `rotate()` modifier. `infiniteRepeatable()` is passed to `animateFloat()` as its
    `animationSpec` parameter. The animation itself is based on keyframes. We need
    to define only two frames, the first representing the start, and the second representing
    the end angle.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个可能无限循环的动画，你首先需要使用`rememberInfiniteTransition()`记住一个无限过渡。然后你可以在过渡实例上调用`animateFloat()`。这返回`State<Float>`，它与`rotate()`修饰符一起使用。`infiniteRepeatable()`作为其`animationSpec`参数传递给`animateFloat()`。动画本身基于关键帧。我们只需要定义两个帧，第一个代表起始角度，第二个代表结束角度。
- en: 'If you want the text to return to its initial angle rather than rotating continuously,
    you can change the `repeatMode` parameter to the following:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让文本返回到其初始角度而不是持续旋转，你可以将`repeatMode`参数更改为以下内容：
- en: '[PRE15]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Then you should add short delays to the beginning and the end. `keyframes {}`
    should look like this:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 然后你应该在开始和结束处添加短暂的延迟。`keyframes {}`应该看起来像这样：
- en: '[PRE16]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This concludes our look at animation specifications. To finish this chapter,
    let me briefly summarize what you have learned, and what you can expect in the
    next chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对动画规格的探讨。为了完成本章，让我简要总结一下你所学到的内容，以及你可以在下一章中期待的内容。
- en: Summary
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter showed you how easy it is to use Jetpack Compose to enrich your
    apps with animations and transitions. We started by using simple animations to
    visualize state changes. For example, I introduced you to `animateColorAsState()`.
    We then used `updateTransition()` to obtain `Transition` instances and invoked
    extension functions such as `animateDp()` and `animateFloat()` to animate several
    values based on state changes simultaneously.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向你展示了如何轻松使用Jetpack Compose通过动画和过渡来丰富你的应用。我们首先使用简单的动画来可视化状态变化。例如，我向你介绍了`animateColorAsState()`。然后我们使用`updateTransition()`来获取`Transition`实例，并调用扩展函数如`animateDp()`和`animateFloat()`，以根据状态变化同时动画化多个值。
- en: The *Showing and hiding UI elements with animations* section introduced you
    to the `AnimatedVisibility()` composable function, which allows you to apply enter
    and exit transitions. They are played back while the content appears or disappears.
    You also learned how to animate size changes using the `animateContentSize()`
    modifier.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在*使用动画显示和隐藏UI元素*部分，你了解了`AnimatedVisibility()`组合函数，它允许你应用进入和退出过渡。它们在内容出现或消失时播放。你还学习了如何使用`animateContentSize()`修饰符来动画化大小变化。
- en: In the final main section, *Spicing up transitions through visual effects*,
    we used the `Crossfade()` composable function to switch between two layouts with
    a crossfade animation. Furthermore, you learned about `AnimationSpec` and related
    classes and interfaces. I concluded the section with a take on infinite animations.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在最终的主部分，*通过视觉效果增强过渡*，我们使用了`Crossfade()`组合函数在两个布局之间切换，并使用交叉淡入淡出动画。此外，你还了解了`AnimationSpec`和相关类和接口。我在本节结束时对无限动画进行了总结。
- en: In [*Chapter 9*](B17505_09_ePub.xhtml#_idTextAnchor148), *Exploring Interoperability
    APIs*, you will learn how to mix old-fashioned views and composable functions.
    We will once again return to ViewModels as a means for sharing data between both
    worlds. And I will show you how to integrate third-party libraries in your Compose
    app.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第9章*](B17505_09_ePub.xhtml#_idTextAnchor148)，*探索互操作性API*，你将学习如何混合传统的视图和可组合函数。我们还将再次回到ViewModels，作为在两个世界之间共享数据的一种手段。并且我会向你展示如何将第三方库集成到你的Compose应用中。
