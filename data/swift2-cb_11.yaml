- en: Chapter 11. Extensions, Photos, and More
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章. 扩展、照片及其他
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Developing the geekiest keyboard
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发最酷的键盘
- en: Time to take your pill
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 是时候服用你的药片了
- en: Adding effects to your photos
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的照片添加效果
- en: Being a film critic
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 成为电影评论家
- en: Leaving breadcrumbs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 留下痕迹
- en: Creating the Currency Converter app
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建货币转换器应用程序
- en: Method swizzling in Swift
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift中的方法交换
- en: Associated objects in Swift
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift中的关联对象
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This is the last chapter of this book. Here, we are going to learn different
    topics that weren't mentioned in the previous chapters, mainly new features of
    Xcode 6.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这是本书的最后一章。在这里，我们将学习前几章未提及的不同主题，主要是Xcode 6的新功能。
- en: Developing the geekiest keyboard
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发最酷的键盘
- en: App extensions are a new feature where an application can come with some kind
    of plugins, which can even interact with other apps.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 应用扩展是一个新特性，其中应用程序可以附带一些插件，这些插件甚至可以与其他应用程序交互。
- en: 'In this case, we are going to develop a keyboard for geek people. This keyboard
    will contain only two keys: key *0* and key *1*. When you type a combination of
    eight keys, you will get a new character.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们将为极客开发一个键盘。这个键盘将只包含两个键：键 *0* 和键 *1*。当你输入八个键的组合时，你会得到一个新的字符。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, make sure that you have iOS 8, it doesn't matter if you are
    using the simulator or a physical device. The custom keyboard feature is only
    available on iOS 8.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，请确保您有iOS 8，无论您使用的是模拟器还是物理设备。自定义键盘功能仅在iOS 8上可用。
- en: Create a new single view application called `Chapter 11 Geekboard` and let's
    start coding.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 11 Geekboard` 的新单视图应用程序，让我们开始编码。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'The main development of this recipe is based on the app extension of the custom
    keyboard. However, as we are going to need a view for testing our keyboard, let''s
    start by clicking on the storyboard and adding a text field on our view. Link
    this text field with the view controller calling it `inputTextField`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此菜谱的主要开发基于自定义键盘的应用扩展。然而，由于我们需要一个视图来测试我们的键盘，让我们先点击故事板，并在我们的视图中添加一个文本字段。将此文本字段与名为
    `inputTextField` 的视图控制器链接：
- en: '[PRE0]'
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s make this text field the first responder, just as the application
    is about to launch. You won''t need to tap on the field for displaying the keyboard:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们使这个文本字段成为即将启动的应用程序的首个响应者。您不需要点击字段来显示键盘：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This is everything we have to code with this view controller; everything else
    will be done on the application extension. The next step is opening the menu and
    adding a new target to our project. In this case, select **Custom Keyboard** from
    the **Application Extension** section:![How to do it…](img/00169.jpeg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是我们必须使用此视图控制器编写的所有内容；其他所有内容都将由应用程序扩展完成。下一步是打开菜单，并向我们的项目添加一个新目标。在这种情况下，从 **应用程序扩展**
    部分中选择 **自定义键盘**：![如何操作…](img/00169.jpeg)
- en: Call this target `Geekboard` and press **Yes** when a dialog asks for activating
    the **Geekboard** scheme:![How to do it…](img/00170.jpeg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此目标命名为 `Geekboard`，当对话框询问激活 **Geekboard** 方案时按 **是**：![如何操作…](img/00170.jpeg)
- en: Before coding, let's start by adding a new view to this target; therefore click
    on the new file from the menu and choose **View** from the **User Interface**
    section:![How to do it…](img/00171.jpeg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编码之前，让我们先向此目标添加一个新视图；因此，从菜单中选择新文件，并在 **用户界面** 部分中选择 **视图**：![如何操作…](img/00171.jpeg)
- en: Call this view `Geekboard` (again) but before pressing the **Create** button
    ensure that this file belongs to the extension target as shown in the following
    screenshot:![How to do it…](img/00172.jpeg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此视图命名为 `Geekboard`（再次），但在按下 **创建** 按钮之前，确保此文件属于扩展目标，如下面的截图所示：![如何操作…](img/00172.jpeg)
- en: Once it is created, click on the new file (`Geekboard.xib`), select the only
    view it has, and let's change some properties of it by clicking on the **Attribute
    Inspector**. Here you have to change the size to **Freeform**, the status bar
    to **None**, and the background color to silver:![How to do it…](img/00173.jpeg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建完成后，点击新文件（`Geekboard.xib`），选择它拥有的唯一视图，然后通过点击 **属性检查器** 来更改一些属性。在这里，您需要将大小更改为
    **自由形式**，状态栏更改为 **无**，背景颜色更改为银色：![如何操作…](img/00173.jpeg)
- en: Great! After that, select the **Size Inspector** and change the view size to
    **320** by **160**:![How to do it…](img/00174.jpeg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了！之后，选择 **大小检查器**，将视图大小更改为 **320** x **160**：![如何操作…](img/00174.jpeg)
- en: The view properties are done, now we need to set the file's owner class. To
    do it click on the file's owner icon (the yellow cube), select the identity inspector,
    and change the class name to `KeyboardViewController`:![How to do it…](img/00175.jpeg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 视图属性已完成，现在我们需要设置文件的拥有者类。要做到这一点，请单击文件的拥有者图标（黄色立方体），选择身份检查器，并将类名更改为`KeyboardViewController`：![如何操作…](img/00175.jpeg)
- en: 'There is one more thing we need to do in this XIB file: we have to add a few
    components for this layout. Add a label, for letting the user know the binary
    combination that was made, and two buttons: one that represents digit 0 and another
    one that represents digit **1**. It should look something similar to the following
    screenshot:![How to do it…](img/00176.jpeg)'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个XIB文件中，我们还需要做一件事：我们必须为此布局添加一些组件。添加一个标签，让用户知道所制作的二进制组合，以及两个按钮：一个代表数字0，另一个代表数字**1**。它应该看起来类似于以下截图：![如何操作…](img/00176.jpeg)
- en: 'Of course the label is going to be changed and the buttons don''t need a different
    action due to the only difference being the digit value; therefore we will create
    the same action for both buttons and differentiate them by checking the sender.
    To summarize, link the label and the buttons with the `KeyboardViewController`
    as per the following code:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，标签将会被更改，按钮不需要不同的动作，因为唯一的区别是数字值；因此，我们将为两个按钮创建相同的动作并通过检查发送者来区分它们。总结一下，根据以下代码将标签和按钮与`KeyboardViewController`链接：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-33
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't remove any code done by the Xcode on the `KeyboardViewController` yet.
    If it's necessary to remove any code, it will be explicitly written.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要删除`KeyboardViewController`上由Xcode完成的任何代码。如果需要删除任何代码，它将明确写出。
- en: 'Link both buttons with an empty action called `addBit`. Don''t worry about
    by its contents, we are going to develop it later:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮与一个名为`addBit`的空动作链接。不用担心它的内容，我们稍后会开发它：
- en: '[PRE3]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'On the `KeyboardViewController` we are also going to add two attributes for
    controlling the current keyboard state:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`KeyboardViewController`中，我们还将添加两个用于控制当前键盘状态的属性：
- en: '[PRE4]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now we need to set up the view, so go to the `viewDidLoad` method and add some
    lines of code after `super.viewDidLoad` and before the Apple precooked code:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要设置视图，所以转到`viewDidLoad`方法，在`super.viewDidLoad`之后和苹果预编译代码之前添加一些代码行：
- en: '[PRE5]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Once we have typed that, we can complete our app by developing the buttons
    event:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打完这些后，我们可以通过开发按钮事件来完成我们的应用程序：
- en: '[PRE6]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The application is done, let's test it. Press play, and when the application
    launches the keyboard is shown but, that's not our keyboard!!! What happened?
    The reason is that you have to add this keyboard the same way you add another
    language keyboard on your device.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经完成，让我们来测试它。按下播放键，当应用程序启动时，显示的键盘不是我们的键盘！！！发生了什么？原因是您必须以与在设备上添加另一种语言键盘相同的方式添加此键盘。
- en: Bearing that in mind, press the home button, go to settings, choose general,
    then keyboard, then another option of keyboards, and at last the option **Add
    new keyboard...**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 考虑到这一点，按住主页按钮，进入设置，选择通用，然后键盘，然后键盘选项中的另一个选项，最后选择**添加新键盘...**。
- en: You should see some suggested keyboards and another section with third-party
    keyboards. Select the **Geekboard** from this section:![How to do it…](img/00177.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您应该会看到一些建议的键盘和另一个包含第三方键盘的部分。从该部分选择**Geekboard**：![如何操作…](img/00177.jpeg)
- en: 'Return to your app (**Chapter 11 Geekboard**) and you will see that the keyboard
    is not there yet. So you have to tap the globe icon until you get your keyboard
    and, voila!, it''s working. Type this binary message: `01001000 01000101 01001100
    01001100 01001111` for example, but if you are really geeky, you can go to the
    **Mail** application and write an e-mail with only this keyboard. Do you accept
    the challenge?'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回您的应用程序（**第11章 Geekboard**），您将看到键盘还没有出现。因此，您必须轻触地球图标，直到您获得键盘，然后，哇！它开始工作了。例如，键入这个二进制消息：`01001000
    01000101 01001100 01001100 01001111`，但如果您真的很酷，您可以去**邮件**应用程序，只用这个键盘写一封电子邮件。你接受挑战吗？
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: A custom keyboard is a feature called **App Extension**. It has some limitations,
    for example, it can't be used for passwords and other text field types such as
    phone contacts. It also can't display anything above its top.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义键盘是一个称为**应用扩展**的功能。它有一些限制，例如，它不能用于密码和其他文本字段类型，如电话联系人。它也不能在其顶部显示任何内容。
- en: Creating a custom keyboard implies creating a controller of type `UIInputViewController`,
    which is a class that inherits from `UIViewController`, meaning that you can use
    the `UIViewController` methods if necessary.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个自定义键盘意味着创建一个 `UIInputViewController` 类型的控制器，这是一个继承自 `UIViewController` 的类，这意味着如果需要，你可以使用
    `UIViewController` 的方法。
- en: For making the keyboard development simpler, we added a new XIB file, which
    allowed us to visually create the layout. Some developers think that the XIB files
    were removed from the Xcode since the storyboard was incorporated, however you
    can see that this is not true; you can still use the XIB files for customizing
    some views such as a keyboard or a table cell.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使键盘开发更简单，我们添加了一个新的 XIB 文件，这使得我们可以直观地创建布局。一些开发者认为，由于故事板被整合，XIB 文件已被从 Xcode
    中移除，然而你可以看到这并不正确；你仍然可以使用 XIB 文件来定制一些视图，例如键盘或表格单元格。
- en: 'Submitting a text to the text field is very easy: you only need to create a
    `UITextDocumentProxy` object and use the `insertText` method. It will know the
    active text field magically.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 将文本提交到文本字段非常简单：你只需要创建一个 `UITextDocumentProxy` 对象并使用 `insertText` 方法。它将神奇地知道活动文本字段。
- en: There's more…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: The custom keyboards communication is a bit limited because it can't use the
    network or share any file with the containing app by default. In case you desire
    to use these features, you have to go to its `Info.plist` and set the option `RequestsOpenAccess`
    to `yes`.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义键盘的通信有点有限，因为它默认不能使用网络或与包含的应用程序共享任何文件。如果你希望使用这些功能，你必须进入它的 `Info.plist` 并将选项
    `RequestsOpenAccess` 设置为 `yes`。
- en: 'In the next recipe, we are going to learn something different: we are going
    to develop for the Apple Watch.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习一些不同的事情：我们将为 Apple Watch 开发。
- en: Time to take your pill
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 现在是吃药的时候了
- en: Who in this world has never fallen sick? Let's face it, soon or later we get
    sick and we have to follow the doctor's prescription. If you are like me and look
    at your watch frequently when it's time to take a pill, maybe what we need is
    an app that can tell us about it, and this time it will be an Apple Watch application.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个世界上，谁从未生病过？让我们面对现实，迟早我们都会生病，我们必须遵循医生的处方。如果你像我一样，在吃药的时候经常看手表，也许我们需要的是一个可以告诉我们这个信息的应用程序，这次它将是一个
    Apple Watch 应用程序。
- en: Getting ready
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe you will need Xcode 6.2 or higher, because we are going to use
    the WatchKit, which is not available on previous versions.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，你需要 Xcode 6.2 或更高版本，因为我们将要使用 WatchKit，这在之前的版本中不可用。
- en: Start as usual by just creating a single view iOS application and call it `Chapter
    11 Red Pill`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，只需创建一个单独的视图 iOS 应用程序，并将其命名为 `第 11 章 红丸`。
- en: How to do it…
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: The first step we need to do is just create a new target, but this time you
    have to add the **WatchKit App** from the **WatchKit** section:![How to do it…](img/00178.jpeg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的第一步是创建一个新的目标，但这次你必须从 **WatchKit** 部分的 **WatchKit 应用** 中添加：![如何操作…](img/00178.jpeg)
- en: On the **Next** dialog uncheck the notifications, glance and complications options;
    it will make the project cleaner:![How to do it…](img/00179.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **下一步** 对话框中取消选中通知、快速查看和复杂功能选项；这将使项目更简洁：![如何操作…](img/00179.jpeg)
- en: After that, a dialog requesting to activate the WatchKit App will appear; accept
    it by pressing the **Activate** button:![How to do it…](img/00180.jpeg)
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将出现一个请求激活 WatchKit 应用的对话框；通过按下 **激活** 按钮接受它：![如何操作…](img/00180.jpeg)
- en: 'You can see that there are two new groups on your project: one for the WatchKit
    extension and another one for the WatchKit app. Open your extension group and
    add a new Swift file called `FrequencyData.swift`. Here you only need to type
    this simple code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以看到在你的项目中有两个新的组：一个用于 WatchKit 扩展，另一个用于 WatchKit 应用。打开你的扩展组，添加一个名为 `FrequencyData.swift`
    的新 Swift 文件。这里你只需要输入以下简单的代码：
- en: '[PRE7]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now go to your WatchKit app group, expand it, and click on the storyboard.
    Here you have something like the view controller but here it''s called interface.
    In your interface, add a label and try to make it fit on the whole screen. Connect
    it with the interface controller as an IBOutlet:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在转到你的 WatchKit 应用组，展开它，并点击故事板。这里你有一个类似于视图控制器的东西，但在这里它被称为界面。在你的界面中添加一个标签，并尝试让它适合整个屏幕。将其与界面控制器作为
    IBOutlet 连接：
- en: '[PRE8]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Create a new interface and place another label; you don't have to connect it
    just change its text to `It's time to take your pill`. If it doesn't fit, change
    the label number of lines to two.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的界面，放置另一个标签；你不必连接它，只需将其文本更改为 `现在是吃药的时候了`。如果它不适合，将标签的行数更改为两行。
- en: Now click on the first interface, hold the control key and drag it to the second
    interface. You may now have your storyboard looking like the following:![How to
    do it…](img/00181.jpeg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击第一个界面，按住控制键并将其拖动到第二个界面。现在您的Storyboard可能看起来像以下这样：![如何操作…](img/00181.jpeg)
- en: Select the second interface and go to its attribute inspector. Set the identifier
    to `its_time`:![How to do it…](img/00182.jpeg)
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第二个界面，并转到其属性检查器。将标识符设置为`its_time`：![如何操作…](img/00182.jpeg)
- en: 'Return to the extension group and open the `InterfaceController` file. As usual
    we are going to start by adding the necessary attributes:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到扩展组，并打开`InterfaceController`文件。像往常一样，我们将从添加必要的属性开始：
- en: '[PRE9]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now initialize the context on the `awakeWithContext` method:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在`awakeWithContext`方法上初始化上下文：
- en: '[PRE10]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'After that, we have to request the user to select the time he needs to take
    his pill. Do it on the method `willActivate`:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们必须请求用户选择他需要服用药片的时间。在`willActivate`方法中执行此操作：
- en: '[PRE11]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As you can see, we need a method called `tick`, which is going to be called
    every second. Code it this way:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们需要一个名为`tick`的方法，它将每秒被调用一次。按照这种方式编写代码：
- en: '[PRE12]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The app is done, let's test it by changing the current scheme to `Chapter 11
    Red Pill WatchKit App` and pressing play. You should see a dialog like the following
    one:![How to do it…](img/00183.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已完成，让我们通过将当前方案更改为`第11章红丸WatchKit应用程序`并按播放来测试它。您应该看到一个像以下这样的对话框：![如何操作…](img/00183.jpeg)
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Choose 2 minutes, which was done just for testing, and wait until you get your
    alert.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 选择2分钟，这只是为了测试，等待直到您收到警报。
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, the components classes are different; instead of `UIViewController`
    we have `WKInterfaceController`, and instead of `UILabel` we have `WKInterfaceLabel`.
    Some methods are different, for example the interface controller initializes its
    attributes on the `awakeWithContext` method rather than `viewDidLoad`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，组件类不同；我们有的不是`UIViewController`，而是`WKInterfaceController`，我们有的不是`UILabel`，而是`WKInterfaceLabel`。一些方法也不同，例如，界面控制器在`awakeWithContext`方法上初始化其属性，而不是在`viewDidLoad`方法上。
- en: There's more…
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There is one component called `WKInterfaceTimer`, which works as a label with
    an `NSTimer` like we did. In this recipe we used the `WKInterfaceLabel` with an
    `NSTimer` because it is more flexible and you can customize the text that is on
    your component.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为`WKInterfaceTimer`的组件，它的工作方式就像我们使用`NSTimer`一样。在这个菜谱中，我们使用了`WKInterfaceLabel`与`NSTimer`，因为它更灵活，您可以自定义组件上的文本。
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: WatchKit has more features such as notifications and glance. Try to have a look
    on the official documentation at [https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969](https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969)
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: WatchKit具有更多功能，如通知和快速查看。请尝试查看官方文档：[https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969](https://developer.apple.com/library/ios/documentation/General/Conceptual/WatchKitProgrammingGuide/index.html#//apple_ref/doc/uid/TP40014969)
- en: In the next recipe, we are going to return to iOS and learn how to use the camera
    for taking pictures.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将回到iOS，学习如何使用相机拍照。
- en: Adding effects to your photos
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为您的照片添加效果
- en: 'It is unbelievable how mobile phones have replaced traditional photo cameras.
    I remember when we used to take the camera only to special events and nowadays
    our cameras follow us everywhere. We can say that the mobile phone has gone even
    further: you can take a picture of yourself on the phone, edit it, and share it
    with your friends and family.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 令人难以置信的是，手机已经取代了传统的照相机。我记得我们过去只会在特殊事件时携带相机，而现在我们的相机无处不在。我们可以这样说，手机已经更进一步：您可以在手机上拍照，编辑它，并与您的朋友和家人分享。
- en: In this recipe, we are going to learn how to take a picture with your phone
    and edit it in a very easy way.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何以非常简单的方式使用手机拍照并编辑它。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: As we are going to use the device camera for this recipe you will need a physical
    device for testing this app. You can change it if you are using photos from the
    gallery, but you will also need to upload some pictures to the simulator.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用设备相机进行此菜谱，因此您需要一个物理设备来测试此应用程序。如果您使用的是图库中的照片，则可以更改它，但您还需要将一些图片上传到模拟器中。
- en: Create a project called `Chapter 11 Photo Effects` and let's move on.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`第11章照片效果`的项目，然后继续前进。
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Open your project, click on the **General Settings** of your target and add
    a framework called **CoreImage**. After that go to the storyboard, add an image
    view and four buttons under it. Change the button labels to `Take photo`, `Sepia`,
    `Blur,` and `Dots`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开你的项目，点击目标配置的 **通用设置** 并添加一个名为 **CoreImage** 的框架。之后进入故事板，在其下添加一个图像视图和四个按钮。将按钮标签更改为
    `Take photo`、`Sepia`、`Blur` 和 `Dots`。
- en: 'Connect the image with the view controller as an attribute and call it `imageView`.
    Now create one action for each button and call them `takePhoto`, `sepia`, `blur`,
    and `dots`. Don''t worry about their contents now, we are going to fill them in
    later:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图片与视图控制器作为属性连接并命名为 `imageView`。现在为每个按钮创建一个动作，分别命名为 `takePhoto`、`sepia`、`blur`
    和 `dots`。现在不必担心它们的实现内容，我们稍后会填充它们：
- en: '[PRE13]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Click on the view controller source code and let''s start completing it by
    adding a new attribute called `image` of optional type `UIImage`:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击视图控制器源代码，让我们通过添加一个名为 `image` 的可选类型 `UIImage` 的新属性来开始完善它：
- en: '[PRE14]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The `UIImagePickerController` requires a delegate and only accepts objects
    that are also navigation controller delegates, therefore append these protocols
    to the view controller definition:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`UIImagePickerController` 需要一个代理，并且只接受也是导航控制器代理的对象，因此将这些协议附加到视图控制器定义中：'
- en: '[PRE15]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'It''s almost time to start coding functions, however we still need to add a
    detail: we have to import the core image on the top of the file:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 几乎是时候开始编写函数了，但我们仍然需要添加一个细节：我们必须在文件顶部导入核心图像：
- en: '[PRE16]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Good, at this time we can start coding the view controller methods. Start by
    checking whether your device has a camera on the `viewDidLoad` method:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，到目前为止，我们可以开始编写视图控制器方法。首先在 `viewDidLoad` 方法中检查你的设备是否有相机：
- en: '[PRE17]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The next step is completing the `takePhoto` method. This method initializes
    the image picker and calls the camera view:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是完善 `takePhoto` 方法。此方法初始化图片选择器并调用相机视图：
- en: '[PRE18]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As you might imagine, the delegate needs to have at least one method; in this
    case we need one method for receiving the picture from the user and another in
    case of canceling it:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所想，代理至少需要有一个方法；在这种情况下，我们需要一个方法来接收用户拍摄的图片，另一个方法是在取消的情况下：
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Once we have done that, we only need to complete the effects code; they are
    very similar but not the same, so here you have them:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们完成这些，我们只需要完善效果代码；它们非常相似但并不相同，所以这里它们是：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The app is done. Now press play, take a photo, and choose the effect you like
    most.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已完成。现在按播放，拍照，并选择你最喜欢的效果。
- en: How it works…
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: '`UIImagePickerController` was created for using the camera easily; this way
    we don''t have to use complicated camera settings and worry about different states
    of it. To use the `UIImagePickerController` you need a delegate and on its method
    you can retrieve the taken picture as a `UIImage`.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImagePickerController` 是为了方便使用相机而创建的；这样我们就不必使用复杂的相机设置，也不必担心它的不同状态。要使用 `UIImagePickerController`，你需要一个代理，在其方法中你可以检索用户拍摄的图片作为
    `UIImage`。'
- en: After receiving the picture you can use the Core Image for adding some effects;
    however you need to convert from `UIImage` to `CIImage`. If you loaded the `UIImage`
    from a local file you can convert it easily by calling a property `CIImage`; however
    this is not the case, as this picture was loaded from the camera so you need to
    create a new object and send your `UIImage` as an argument.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在接收到图片后，你可以使用 Core Image 添加一些效果；但是你需要将 `UIImage` 转换为 `CIImage`。如果你从本地文件加载了 `UIImage`，你可以通过调用一个属性
    `CIImage` 来轻松转换；然而，这种情况并不适用，因为这张图片是从相机加载的，所以你需要创建一个新的对象并将你的 `UIImage` 作为参数传递。
- en: Now you can use the filter that you want with the corresponding values. When
    you use a `CIFilter` you have to check the attributes that are accepted by it;
    sometimes you can use the default values and sometimes you would like to change
    them.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以使用相应的值使用你想要的过滤器。当你使用 `CIFilter` 时，你必须检查它接受的属性；有时你可以使用默认值，有时你可能想更改它们。
- en: After using the filter you can retrieve your picture by using the `outputImage`
    attribute and after that you can construct a new `UIImage` with the `CIImage`
    generated.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用过滤器后，你可以使用 `outputImage` 属性检索你的图片，然后你可以使用生成的 `CIImage` 构造一个新的 `UIImage`。
- en: See also
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '`CoreImage` has a lot of filters, so nowadays it''s not necessary to look for
    libraries or algorithms that modify our pictures. Check the filters that are available
    at [https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346)
    and test them with different attributes.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CoreImage`有很多过滤器，所以现在没有必要寻找修改我们图片的库或算法。检查[https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346](https://developer.apple.com/library/ios/documentation/GraphicsImaging/Reference/CoreImageFilterReference/index.html#//apple_ref/doc/uid/TP40004346)上可用的过滤器，并用不同的属性测试它们。'
- en: In the next recipe, we are going to learn how we can send information from the
    iPhone to our Mac.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在下一个菜谱中，我们将学习如何将信息从iPhone发送到我们的Mac。
- en: Being a film critic
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 成为电影评论家
- en: There are times that an app needs to transfer information from your device to
    the computer and vice versa; for example, you might be watching a movie on your
    iPad on your way home (assuming that you are not the driver) and then you will
    continue watching it on your computer.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，应用程序需要从您的设备传输信息到电脑，反之亦然；例如，您可能在回家的路上在iPad上观看电影（假设您不是司机），然后您将在电脑上继续观看。
- en: 'For scenarios like this one, Apple has created a new technology called **Handoff**.
    The idea is simple: continue the task you are doing on another device.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这种类型的场景，苹果创造了一种名为**Handoff**的新技术。想法很简单：在另一台设备上继续您正在进行的任务。
- en: In this recipe we are going to create an app where the user can start writing
    his opinion about a film on one device and check it on a Mac application. This
    recipe will be divided into smaller sections for easier consumption.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用程序，用户可以在一台设备上开始撰写他对电影的看法，并在Mac应用程序中查看。这个菜谱将被分成更小的部分，以便更容易消费。
- en: Getting ready
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: The Handoff framework has software and hardware requirements. The software requirements
    are Xcode 6, iOS 8, and OS X Yosemite (10.10); therefore make sure that your hardware
    is able to use all these software versions (or higher). Unfortunately Handoff
    can't be used with the simulator. Another software requirement is that both devices
    (the computer and your Apple mobile device) must be logged into the same iCloud
    account and they must be paired.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Handoff框架有软件和硬件要求。软件要求是Xcode 6、iOS 8和OS X Yosemite（10.10）；因此请确保您的硬件能够使用所有这些软件版本（或更高版本）。不幸的是，Handoff不能与模拟器一起使用。另一个软件要求是，两台设备（电脑和您的苹果移动设备）必须登录到同一个iCloud账户，并且它们必须配对。
- en: 'The requirement for the hardware is that it has Bluetooth LE 4.0\. The easiest
    way to check whether your iPhone or iPad can use this feature is by opening your
    settings, going to general and checking whether there is an option called **Handoff
    & Suggested Apps**:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件要求是它具有蓝牙LE 4.0。检查您的iPhone或iPad是否可以使用此功能的简单方法是打开设置，进入通用，检查是否有名为**Handoff &
    Suggested Apps**的选项：
- en: '![Getting ready](img/00184.jpeg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00184.jpeg)'
- en: 'Make sure that the **Handoff** option is on, as shown in the following screenshot:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 确保Handoff选项已开启，如下面的截图所示：
- en: '![Getting ready](img/00185.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00185.jpeg)'
- en: 'Once you have checked the device requirements, it''s time to check whether
    the computer meets the requirements. On your Mac computer, open the system preferences,
    then open the **General options**, and ascertain that there is a Handoff option
    and it is checked:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您检查了设备要求，就是时候检查电脑是否符合要求了。在您的Mac电脑上，打开系统偏好设置，然后打开**通用选项**，确认Handoff选项已勾选：
- en: '![Getting ready](img/00186.jpeg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00186.jpeg)'
- en: Note
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of all requirements, the most complicated one is that this technology needs
    the application signed by a team (or a developer), which implies being enrolled
    on the Apple Development Program for each platform. This means that if you are
    going to use this technology between mobile devices and mac computers, you need
    both subscriptions.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有要求中，最复杂的是这项技术需要由团队（或开发者）签名的应用程序，这意味着需要在每个平台上的苹果开发计划中注册。这意味着如果您打算在移动设备和mac电脑之间使用这项技术，您需要两个订阅。
- en: In this recipe we are going to use both platforms but if you only have an iOS
    subscription, it is very straightforward to change the Mac app to an iOS app.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用这两个平台，但如果您只有iOS订阅，将Mac应用更改为iOS应用非常简单。
- en: Now we can start coding the project; in this case start creating a workspace
    called `Chapter 11 Films`.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以开始编码项目；在这种情况下，开始创建一个名为 `Chapter 11 Films` 的工作空间。
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做这件事...
- en: We will split the recipe into three mini-recipes for better understanding.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将食谱分成三个小食谱，以便更好地理解。
- en: Creating the workspace
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建工作空间
- en: 'Create the workspace in a group called `Common Code`; here you have to add
    a new Swift file called `FilmData.swift`, and we are going to add this simple
    class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名为 `Common Code` 的组中创建工作空间；在这里，您需要添加一个名为 `FilmData.swift` 的新 Swift 文件，我们将添加以下简单的类：
- en: '[PRE21]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Let's create a new iOS project called `Chapter 11 Films iOS`. Ensure that it
    is going to be added to your workspace on the combo box:![Creating the workspace](img/00187.jpeg)
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为 `Chapter 11 Films iOS` 的新 iOS 项目。确保它将被添加到您的组合框中的工作空间：![创建工作空间](img/00187.jpeg)
- en: Repeat the procedure with a Mac OS X Cocoa application called `Chapter 11 Films
    MacOSX`, but be aware that you have to add it to the workspace and the group must
    be in the workspace too:![Creating the workspace](img/00188.jpeg)
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用名为 `Chapter 11 Films MacOSX` 的 Mac OS X Cocoa 应用程序重复此过程，但请注意，您必须将其添加到工作空间中，并且组也必须在工作空间中：![创建工作空间](img/00188.jpeg)
- en: Once we have both projects, let's add to both of them the first file we created
    at the beginning of this recipe (`FilmData.swift`). This way we don't have to
    repeat the code for each project:![Creating the workspace](img/00189.jpeg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这两个项目，让我们将我们在本食谱开头创建的第一个文件（`FilmData.swift`）添加到它们中。这样我们就不必为每个项目重复代码：![创建工作空间](img/00189.jpeg)
- en: Once we have these common parts we are going to continue with the Mac application.
    So click on the Mac project, go to **General Settings**, change the signing section
    to **Developer ID**, and select your team account:![Creating the workspace](img/00190.jpeg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这些通用部分，我们将继续进行 Mac 应用程序的开发。因此，点击 Mac 项目，转到 **General Settings**，将签名部分更改为
    **Developer ID**，并选择您的团队账户：![创建工作空间](img/00190.jpeg)
- en: Now click on the `info.plist` file, which is located on the **Supporting Files**
    group and add a new key called **NSUserActivityTypes**. Change its type to array,
    try to expand it but as you can see there is no item, so click on the plus sign
    and write the value `com.packtpub.editingfilm`:![Creating the workspace](img/00191.jpeg)
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击位于 **Supporting Files** 组中的 `info.plist` 文件，添加一个名为 **NSUserActivityTypes**
    的新键。将其类型更改为数组，尝试展开它，但如您所见，没有项目，因此点击加号并写入值 `com.packtpub.editingfilm`：![创建工作空间](img/00191.jpeg)
- en: 'The next step is clicking on the XIB file and adding five labels into the only
    window we have. Put one under the other and, after that, start from the first
    one connecting to the `AppDelegate.swift`:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是点击 XIB 文件，并将五个标签添加到我们唯一的窗口中。将它们一个接一个地放置，然后从第一个开始连接到 `AppDelegate.swift`：
- en: '[PRE22]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'After that we only need to add the following code to the `AppDelegate`:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们只需将以下代码添加到 `AppDelegate` 中：
- en: '[PRE23]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Good, the Mac application is done; before we press play remember that you have
    to log in on iCloud to do it, so you have to open the **System Preferences**,
    then go to iCloud and log in.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，Mac 应用程序已完成；在我们按播放之前，请记住您必须登录到 iCloud 才能这样做，因此您必须打开 **系统偏好设置**，然后转到 iCloud
    并登录。
- en: Note
  id: totrans-153
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that this account must be the same one that you are going to use on
    the mobile device. Once it is done, return to your app and press play. You should
    see just a window with some labels—don't worry about them now as we are going
    to check them later.
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 记住，这个账户必须与您将在移动设备上使用的账户相同。完成后，返回您的应用程序并按播放。您应该看到一个带有一些标签的窗口——现在不用担心它们，因为我们稍后会检查它们。
- en: Developing the iOS part of the app
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 开发应用程序的 iOS 部分
- en: At this time, we are ready to develop the iOS part of the app. First, you have
    to set your team on the main project target and also add the key `NSUserActivityTypes`
    on the `info.plist`. As we did on the Mac application, change its type to Array
    and add the value `com.packtpub.editingfilm` as we also did on the Mac application.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个时候，我们已经准备好开发应用程序的 iOS 部分。首先，您必须在主项目目标上设置您的团队，并在 `info.plist` 上添加键 `NSUserActivityTypes`。就像我们在
    Mac 应用程序中所做的那样，将其类型更改为 Array，并添加值 `com.packtpub.editingfilm`，就像我们在 Mac 应用程序中所做的那样。
- en: Click on the storyboard and, as usual, you might see only a view controller.
    Click on it, go to the **Editor** menu, move down to the option `Embed in` and
    select **Navigation controller**. As you might expect, we are going to add a second
    view controller later. Now just remove the navigation bar by clicking on the navigation
    controller, select the attribute inspector, and uncheck the option **Show Navigation
    Bar**:![Developing the iOS part of the app](img/00192.jpeg)
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击故事板，就像往常一样，你可能只会看到一个视图控制器。点击它，进入**编辑器**菜单，向下移动到选项`嵌入`并选择**导航控制器**。正如你所预期的那样，我们稍后会添加第二个视图控制器。现在只需通过点击导航控制器，选择属性检查器，取消选择选项**显示导航栏**：![开发应用的iOS部分](img/00192.jpeg)
- en: 'Now return to the original view controller and simply add a table view on that.
    In this case we need to display some cells with contents and we also need to do
    something when they are selected. This means that we will need to set the view
    controller to `UITableViewDelegate` and `UITableViewDatasource`:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在返回到原始视图控制器，并在其中简单地添加一个表格视图。在这种情况下，我们需要显示一些带有内容的单元格，并且当它们被选中时还需要做一些事情。这意味着我们需要将视图控制器设置为`UITableViewDelegate`和`UITableViewDatasource`：
- en: '[PRE24]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'After that, bind the table view with the view controller as the data source
    and delegate. As a data source, we need an array of `FilmData`, which will be
    an attribute initialized with a private function:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，将表格视图与视图控制器作为数据源和代理绑定。作为数据源，我们需要一个`FilmData`数组的数组，它将是一个使用私有函数初始化的属性：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Of course, we are going to receive an error here because we need to implement
    this function, so do it outside the class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当然，我们在这里会收到一个错误，因为我们需要实现这个函数，所以请在类外部实现它：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'After that we need to complete the data source methods on the view controller
    class:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们需要在视图控制器类中完成数据源方法：
- en: '[PRE27]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Even then, the app is not finished yet. You should press play and test it, and
    you will see a view similar to the following one. Don't forget to make sure that
    you have chosen the right schema; otherwise it will restart the application:![Developing
    the iOS part of the app](img/00193.jpeg)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使如此，应用还没有完成。你应该按播放并测试它，你会看到一个类似于以下视图。别忘了确保你已经选择了正确的模式；否则，它将重新启动应用：![开发应用的iOS部分](img/00193.jpeg)
- en: 'Once this phase is done, we can return to our view controller and implement
    the last method. Don''t worry when you get some compiler errors, they are going
    to be fixed soon:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦这个阶段完成，我们就可以回到我们的视图控制器并实现最后一个方法。当你得到一些编译器错误时，不要担心，它们很快就会被修复：
- en: '[PRE28]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This view controller is done, the next step is to create a new Cocoa Touch class
    that inherits from the UIViewController, called `FilmDetailViewController`. Uncheck
    the **XIB** option:![Developing the iOS part of the app](img/00194.jpeg)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个视图控制器已经完成，下一步是创建一个新的继承自`UIViewController`的Cocoa Touch类，称为`FilmDetailViewController`。取消选择**XIB**选项：![开发应用的iOS部分](img/00194.jpeg)
- en: Once you have your new Swift file you can return to the storyboard and add a
    new view controller. In this storyboard add five labels, one stepper, a text view,
    and a button. Change the text view background to gray. You should have a layout
    similar to the following one:![Developing the iOS part of the app](img/00195.jpeg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦你有了新的Swift文件，你就可以回到故事板，添加一个新的视图控制器。在这个故事板中添加五个标签、一个步进器、一个文本视图和一个按钮。将文本视图的背景改为灰色。你应该有一个类似于以下布局：![开发应用的iOS部分](img/00195.jpeg)
- en: The new view controller needs to know that its class is not the default view
    controller, therefore select the view controller, go to its identity inspector
    and change its class to **FilmDetailViewController**. Levering that we are here,
    we should also set **Storyboard ID** to `film_detail`:![Developing the iOS part
    of the app](img/00196.jpeg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新的视图控制器需要知道它的类不是默认视图控制器，因此选择视图控制器，进入其身份检查器，将其类更改为**FilmDetailViewController**。利用这一点，我们还应该将**Storyboard
    ID**设置为`film_detail`：![开发应用的iOS部分](img/00196.jpeg)
- en: 'Now link the labels, the stepper, and the text view with the view controller:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将标签、步进器和文本视图与视图控制器链接起来：
- en: '[PRE29]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Once we have these attributes we can set the actions. The only one that will
    need a protocol is the text view; then start adding the `UITextViewDelegate` to
    the class header:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦我们有了这些属性，我们就可以设置动作。唯一需要协议的是文本视图；然后开始向类头中添加`UITextViewDelegate`：
- en: '[PRE30]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'After that we can connect the view controller as the text view delegate, create
    an action called done for the button, and another one called `changeScore` as
    the stepper value changed event:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，我们可以将视图控制器作为文本视图代理连接起来，为按钮创建一个名为done的动作，并为步进器值变化事件创建一个名为`changeScore`的动作：
- en: '[PRE31]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Coding the class
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编写类代码
- en: 'Great, now we can code the previous class without worrying about the storyboard.
    Let''s start with the attribute `film`, which will contain the information of
    the movie that is on screen:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 太好了，现在我们可以编写之前的类而不用担心故事板了。让我们从属性 `film` 开始，它将包含正在屏幕上的电影信息：
- en: '[PRE32]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then we can initialize the views we have on screen and an inherited attribute
    called `userActivity`. Remember that here we suppose that the attribute film was
    already set:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以初始化屏幕上的视图以及一个继承属性 `userActivity`。记住，在这里我们假设属性 `film` 已经设置：
- en: '[PRE33]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'After that we can complete the views events; here we are going to add a new
    one called `textViewDidChange`, which belongs to the `UITextViewDelegate`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以完成视图事件；这里我们将添加一个新的事件，称为 `textViewDidChange`，它属于 `UITextViewDelegate`：
- en: '[PRE34]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The last part of this code is about getting all of the information we want
    to transmit and updating the `userActivity` state:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码的最后一部分是获取我们想要传输的所有信息并更新 `userActivity` 状态：
- en: '[PRE35]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Testing the app
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试应用程序
- en: The app is done and as you know, we have to test it. Before pressing play, make
    sure that the right schema is selected and the app is going to be installed on
    your mobile device, not on the simulator.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序已经完成，正如你所知，我们必须对其进行测试。在按下播放按钮之前，确保已选择正确的模式，并且应用程序将被安装在你的移动设备上，而不是在模拟器上。
- en: Press play, select a movie you like most (or hate most), set a score for it,
    and write your comment. Return to your Mac (remember that you haven't stopped
    the Mac application) and check that your dock has a new icon. It means that it
    detected a user activity that can be read. Click on this icon:![Testing the app](img/00197.jpeg)
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下播放按钮，选择你最喜欢（或最讨厌）的电影，为它设置评分，并写下你的评论。返回到你的 Mac（记住你没有停止 Mac 应用程序）并检查你的 dock
    是否有一个新的图标。这意味着它检测到了可以读取的用户活动。点击此图标：![测试应用程序](img/00197.jpeg)
- en: You will see that your Mac app is in the foreground and it will show the information
    received from your device:![Testing the app](img/00198.jpeg)
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会看到你的 Mac 应用程序在前台，并且它会显示从你的设备接收到的信息：![测试应用程序](img/00198.jpeg)
- en: How it works…
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Handoff works with a feature called **Activity**. Activities are some kind of
    information about what the user is doing right now, such as composing an e-mail,
    editing a video, and so on.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: Handoff 与一个名为 **Activity** 的功能一起工作。活动是关于用户当前正在做什么的一些信息，例如撰写电子邮件、编辑视频等等。
- en: 'When using Handoff you have to plan three phases for your activities: creating
    the activity, updating it, and destroying it. We created it on the `viewDidLoad`
    method, updated it every time the user changed the score or the opinion text,
    and destroyed it when the user pressed the done button.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Handoff 时，你必须为你的活动规划三个阶段：创建活动、更新活动和销毁活动。我们在 `viewDidLoad` 方法中创建了它，每次用户更改分数或意见文本时都更新它，当用户按下完成按钮时销毁它。
- en: If you want to use Handoff on your own classes you have to add an `NSUserActivity`
    object. A good feature about this class is that it is the same using the AppKit
    (OS X) and the UIKit (iOS). Some classes already have this object as a property
    such as `NSDocument`, `UIDocuments`, `NSResponder`, and `UIResponder`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在你的类中使用 Handoff，你必须添加一个 `NSUserActivity` 对象。这个类的一个好特点是它在 AppKit（OS X）和 UIKit（iOS）中都可以使用。一些类已经将这个对象作为属性，例如
    `NSDocument`、`UIDocuments`、`NSResponder` 和 `UIResponder`。
- en: As the `UIViewController` inherits from `UIResponder`, we could use the existing
    attribute `userActivity`. Every time that we or the app thinks that the activity
    needs to be updated, the method `updateUserActivityState` is called. Here it should
    set the whole information that should be transmitted even when the information
    hasn't changed such as the movie title, the director, or the production year because
    after updating the state, the `userInfo` dictionary is going to empty.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `UIViewController` 继承自 `UIResponder`，我们可以使用现有的属性 `userActivity`。每次我们认为活动需要更新时，都会调用
    `updateUserActivityState` 方法。在这里，它应该设置应该传输的所有信息，即使信息没有变化，例如电影标题、导演或制作年份，因为更新状态后，`userInfo`
    字典将会清空。
- en: Tip
  id: totrans-196
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Don't overload the user info dictionary; Apple recommends storing up to 3k of
    information, more than that can affect the application performance.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过度加载用户信息字典；苹果建议存储最多 3k 的信息，超过这个量可能会影响应用程序性能。
- en: 'For receiving the information we need two steps: the first one is checking
    whether the app accepts the activity at that moment by implementing the method
    `willContinueUserActivityWithType` on the app delegate. The other one is implementing
    the app delegate method `continueUserActivity` for retrieving the information
    and sending it to the corresponding view or object.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 接收所需信息需要两个步骤：第一步是通过在应用代理上实现方法 `willContinueUserActivityWithType` 来检查应用是否接受该时刻的活动；第二步是实现应用代理方法
    `continueUserActivity` 以获取信息并将其发送到相应的视图或对象。
- en: An important detail is that Handoff is for being used between apps by the same
    company or developer and only with the same user; that's the reason that you have
    to use the same team signature and the user must be logged in.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 一个重要的细节是，Handoff 是用于同一公司或开发者之间的应用之间，并且仅与同一用户；这就是为什么你必须使用相同的团队签名，并且用户必须登录。
- en: There's more…
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: In this case, we created an app that edits your movie opinion and another one
    that can receive it, however you can modify the Mac application in a way that
    it can also edit and retransmit it to the device application. Try to do it as
    homework.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们创建了一个编辑你的电影观点的应用，另一个可以接收它的应用，然而你可以修改 Mac 应用程序，使其也可以编辑并将其重新传输到设备应用。试着作为家庭作业来做。
- en: See also
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Apple has a good sample about how to use Handoff with photos; have a look at
    [https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html](https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html)
    to download it.
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 苹果有一个关于如何使用 Handoff 与照片的示例；查看 [https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html](https://developer.apple.com/library/ios/samplecode/PhotoHandoff/Listings/README_md.html)
    下载它。
- en: Leaving breadcrumbs
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下痕迹
- en: Have you ever gone somewhere and started wondering whether your path was the
    best one? At times, we would like to review our journey once we've reached the
    destination. Usually we do this when the journey has been a very long one. In
    this recipe, we are going to create an app for recording our steps and then we
    can check the path we took.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经去过某个地方，并开始怀疑你的路线是否最佳？有时，当我们到达目的地后，我们想要回顾我们的旅程。通常，当旅程非常漫长时，我们会这样做。在这个菜谱中，我们将创建一个用于记录我们步伐的应用，然后我们可以检查我们所走的路径。
- en: Getting ready
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'Create a new single-view application called `Chapter 11 Breadcrumbs`, add the
    `Core Location` framework, and the `Map Kit` framework. You can use the simulator
    or a physical device for testing this app, however if you are as lazy as me, it
    will be better using the simulator, that way you don''t have to stand up and walk
    to test it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Chapter 11 Breadcrumbs` 的新单视图应用，添加 `Core Location` 框架和 `Map Kit` 框架。你可以使用模拟器或物理设备来测试这个应用，然而如果你和我一样懒惰，使用模拟器会更好，这样你就不需要站起来走动来测试它：
- en: '![Getting ready](img/00199.jpeg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/00199.jpeg)'
- en: How to do it…
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Once you have added the frameworks, you just need to follow these steps for
    creating the app:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了框架，你只需遵循以下步骤来创建应用：
- en: Open the storyboard, add a label on the top, a button under it, and a map view
    under that. The result can be similar to the following screenshot:![How to do
    it…](img/00200.jpeg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开故事板，在顶部添加一个标签，在其下方添加一个按钮，再在其下方添加一个地图视图。结果可以类似于以下截图：![如何做…](img/00200.jpeg)
- en: 'As usual, start connecting the label and the map view with the view controller:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同往常，开始将标签和地图视图连接到视图控制器：
- en: '[PRE36]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now you can click on the view controller and start by importing the core location
    and the map kit frameworks, and of course don''t remove the UIKit:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以点击视图控制器，并首先导入核心定位和地图框架，当然不要移除 UIKit：
- en: '[PRE37]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After that, complete the `ViewController` class by adding the `CLLocationManagerDelegate`
    and the `MKMapViewDelegate` protocols, as shown:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，通过添加 `CLLocationManagerDelegate` 和 `MKMapViewDelegate` 协议来完成 `ViewController`
    类，如下所示：
- en: '[PRE38]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next step is adding the view controller attributes. In this case we will
    need the location manager for receiving the current position, an array of positions
    that we have passed through, and a Boolean attribute for following the user on
    the map:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加视图控制器属性。在这种情况下，我们需要位置管理器来接收当前位置、我们经过的位置数组以及一个布尔属性来在地图上跟随用户：
- en: '[PRE39]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now we need to initialize the manager attribute and the map view to do it,
    so we are going to use the method `viewDidLoad`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要初始化管理属性和地图视图来完成它，所以我们将使用 `viewDidLoad` 方法：
- en: '[PRE40]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Then we need to update the map view and the `locationStack` every time we receive
    a new location:'
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要在每次接收到新的位置时更新地图视图和 `locationStack`：
- en: '[PRE41]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The app is still not displaying the path; the reason is that we need to draw
    it by writing the map view method `renderForOverlay`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序仍然没有显示路径；原因是我们需要通过编写地图视图方法`renderForOverlay`来绘制它：
- en: '[PRE42]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now the app is working; however it can be quite difficult to check our journey
    because it is always being updated, so it is time to add the button event:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序正在运行；然而，检查我们的旅程可能相当困难，因为它总是在更新，所以是时候添加按钮事件了：
- en: '[PRE43]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The app is almost done. There is one detail that you still need to set up:
    the permission on iOS 9\. So go to your `info.plist`, then add a new record with
    the key **Required background modes**, and write in `Item 0` a string value of
    **App registers for location updates**:![How to do it…](img/00201.jpeg)'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序几乎完成了。还有一项细节需要你设置：iOS 9上的权限。所以请前往你的`info.plist`文件，然后添加一个新的记录，键为**Required
    background modes**，在`Item 0`中写入字符串值**App registers for location updates**：![如何操作…](img/00201.jpeg)
- en: Now the app is done, press play and walk around if you are using a physical
    device or click on **Debug**, then scroll down to location and select freeway
    drive if you are using the simulator.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在应用程序已经完成，如果你使用的是物理设备，请按播放并四处走动；如果你使用的是模拟器，请点击**调试**，然后向下滚动到位置并选择高速公路驾驶。
- en: How it works…
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The core location framework allows us to retrieve the current device position
    but of course it needs a delegate; that's the reason we had to implement the `CLLocationManagerDelegate`
    protocol. This protocol receives positions from the method `didUpdateLocations`.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 核心定位框架允许我们检索当前设备位置，但当然它需要一个代理；这就是我们为什么必须实现`CLLocationManagerDelegate`协议的原因。该协议通过`didUpdateLocations`方法接收位置。
- en: Once we receive it, we could store the location into the `locationStack` array.
    Actually if you don't want to keep information of the whole journey, you can just
    store the last location.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们收到它，我们就可以将位置存储到`locationStack`数组中。实际上，如果你不想保留整个旅程的信息，你只需存储最后一个位置即可。
- en: After storing a new location, we can create a polyline, which is like a segment
    of our journey. This information is submitted to the map view.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 存储了新的位置后，我们可以创建一条折线，这就像是我们旅程的一部分。这些信息被提交到地图视图。
- en: The map view needs to render it with the method `rendererForOverlay` of the
    `MKMapViewDelegate`. The reason for that is that you are free to draw what you
    want on the map, and you can create shapes such as circles, squares, and so on
    for highlighting an area.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 地图视图需要使用`MKMapViewDelegate`的`rendererForOverlay`方法来渲染它。这样做的原因是你可以自由地在地图上绘制你想要的任何内容，并且你可以创建圆形、正方形等形状来突出显示一个区域。
- en: There's more…
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Drawing a route on a map view is something very common, mainly if you would
    like to use directions. Have a look at MKDirections, which can be very useful.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图视图中绘制路线是非常常见的，尤其是如果你想要使用方向。看看MKDirections，它可能非常有用。
- en: Creating the Currency Converter app
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建货币转换器应用程序
- en: Nowadays, our apps must be prepared to be executed everywhere; therefore your
    app should have as many languages as possible. Consider that internationalization
    is very important for using different languages or different number formats.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序必须准备好在各个地方执行；因此，你的应用程序应该尽可能包含多种语言。考虑到国际化对于使用不同的语言或不同的数字格式非常重要。
- en: In this recipe, we are going to create an app that will show us the currency
    exchange rate, but more important than that, it will be adapted to the current
    location.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个应用程序，它将显示货币汇率，但更重要的是，它将适应当前位置。
- en: Getting ready
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a single-view application called `Chapter 11 Currency Converter` and
    place the two flag pictures on the `images.xcassets`. These pictures can be downloaded
    from the book resources.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Chapter 11 Currency Converter`的单视图应用程序，并将两张旗帜图片放在`images.xcassets`中。这些图片可以从书籍资源中下载。
- en: How to do it…
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Follow these steps to create the Currency Converter app:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建货币转换器应用程序：
- en: First, click on the **Supporting Files** group and add a new file. In this case,
    go to the **Resource** section and select the **Strings File**:![How to do it…](img/00202.jpeg)
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，点击**支持文件**组并添加一个新文件。在这种情况下，前往**资源**部分并选择**字符串文件**：![如何操作…](img/00202.jpeg)
- en: 'Inside this file, add these keys with their corresponding values:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个文件中，添加以下键及其对应值：
- en: '[PRE44]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now, go to the storyboard and add four labels, two buttons, a text field, and
    an image view on the bottom, similar to the following screenshot:![How to do it…](img/00203.jpeg)
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，前往故事板并添加四个标签、两个按钮、一个文本框和一个图像视图在底部，类似于以下截图：![如何操作…](img/00203.jpeg)
- en: 'Once you have your layout done, connect the UI components (except the title
    label) with the view controller with the following names:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成布局，请使用以下名称将UI组件（除了标题标签）与视图控制器连接：
- en: '[PRE45]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Change the text field **Keyboard Type** to **Numbers and Punctuations** in the
    attribute inspector:![How to do it…](img/00204.jpeg)
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在属性检查器中将文本字段的**键盘类型**更改为**数字和标点符号**：![如何操作…](img/00204.jpeg)
- en: 'Add the protocol `UITextFieldDelegate` to the view controller:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将协议`UITextFieldDelegate`添加到视图控制器：
- en: '[PRE46]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: Now, set the view controller as the text field delegate and write `Amount of
    money` as the text field placeholder.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将视图控制器设置为文本字段代理，并将`Amount of money`作为文本字段占位符写入。
- en: Another important action is changing the view class from `UIView` to `UIControl`
    so we can hide the keyboard easily:![How to do it…](img/00205.jpeg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个重要操作是将视图类从`UIView`更改为`UIControl`，这样我们就可以轻松地隐藏键盘：![如何操作…](img/00205.jpeg)
- en: 'Go to the view controller and add the following attributes:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往视图控制器并添加以下属性：
- en: '[PRE47]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'At this time, we can start coding the view controller methods; starting from
    the beginning we are going to implement the `viewDidLoad` method:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们可以开始编写视图控制器方法；从开始我们将实现`viewDidLoad`方法：
- en: '[PRE48]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, there is a private method called `setup`, which we are going
    to implement right now. This method is responsible for retrieving the currency
    rate from the Internet and calculates the value of the amount of money that the
    user has entered:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，有一个名为`setup`的私有方法，我们现在将实现它。此方法负责从互联网检索货币汇率并计算用户输入的金额的价值：
- en: '[PRE49]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We are going to implement the buttons event. The event is the same for both
    of them, so connect the touch up event with this method:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将实现按钮的事件。这两个按钮的事件是相同的，因此将触摸事件与以下方法连接：
- en: '[PRE50]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Connect the main view (the one that we changed to `UIControl`) touch up event
    with the view controller creating a method called touchup:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主视图（我们将其更改为`UIControl`）的触摸事件与视图控制器创建的名为`touchup`的方法连接：
- en: '[PRE51]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Now we can complete the view controller with the last method, which allows
    us to hide the keyboard when the return key is pressed:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用最后一个方法完成视图控制器，这个方法允许我们在按下回车键时隐藏键盘：
- en: '[PRE52]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The app is basically done, however we can only say that it is ready for localization,
    but except for the currency format we can say that there is nothing that could
    demonstrate it. So click on your project on the project navigator, and go to the
    info tab of the project. Make sure that you selected the project and not the target.
    Scroll down to the **Locations** section and click on the plus sign. Select **Spanish,**
    a new language:![How to do it…](img/00206.jpeg)
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序基本上已经完成，然而我们只能说它已准备好本地化，但是除了货币格式外，我们可以说没有其他可以证明这一点的东西。因此，点击项目导航器中的项目，转到项目的**Info**标签页。确保你选择了项目而不是目标。滚动到**Locations**部分并点击加号。选择**Spanish**，一种新语言：![如何操作…](img/00206.jpeg)
- en: Now expand your storyboard and select **Main.strings (Spanish)**:![How to do
    it…](img/00207.jpeg)
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在展开你的故事板并选择**Main.strings (Spanish)**：![如何操作…](img/00207.jpeg)
- en: 'Change the title from `Currency Converter` to `Conversor de monedas` and the
    text field place holder from `Amount of money` to `Cantidad de dinero`. The modified
    lines should be similar to the following ones:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将标题从`Currency Converter`更改为`Conversor de monedas`，并将文本字段占位符从`Amount of money`更改为`Cantidad
    de dinero`。修改后的行应类似于以下行：
- en: '[PRE53]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Try to design the whole layout before translating it to other languages; adding
    components to your view sometimes makes you translate everything again.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在将布局翻译成其他语言之前，尝试设计整个布局；有时向视图中添加组件会让你再次翻译一切。
- en: Return to `Localizable.strings`, and on the file inspector, click on the **Localize…**
    button, which is located in the **Localization** section:![How to do it…](img/00208.jpeg)
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回`Localizable.strings`，在文件检查器中点击位于**Localization**部分的**Localize…**按钮：![如何操作…](img/00208.jpeg)
- en: A dialog requesting to move this file to the `lproj` folder will appear. Choose
    the base language:![How to do it…](img/00209.jpeg)
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件移动到`lproj`文件夹的对话框将出现。选择基本语言：![如何操作…](img/00209.jpeg)
- en: As you can see, the localization section has replaced the old button with some
    language options; check the **Spanish** option:![How to do it…](img/00210.jpeg)
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，本地化部分已用一些语言选项替换了旧按钮；检查**Spanish**选项：![如何操作…](img/00210.jpeg)
- en: Expand the `Localizable.strings` and click the Spanish one:![How to do it…](img/00211.jpeg)
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开`Localizable.strings`并点击西班牙语选项：![如何操作…](img/00211.jpeg)
- en: 'Now update the values translating them to the Spanish language, as in the following
    lines:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在更新值，将它们翻译成西班牙语，如下所示：
- en: '[PRE54]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: It's time to test our app, press play and check that the app works perfectly
    fine, then press the home button, go to **Settings**, enter into the **General**
    section, tap (or click) on **Language & Region**, and change the region to **Spain**
    and the language to **Spanish**. Now return to your app and you should see it
    with Spanish text; the numbers should be represented with the Spanish format:![How
    to do it…](img/00212.jpeg)
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候测试我们的应用程序了，按播放并检查应用程序是否运行得很好，然后按主页按钮，进入**设置**，进入**通用**部分，点击（或单击）**语言与地区**，将地区更改为**西班牙**，语言更改为**西班牙语**。现在返回到你的应用程序，你应该看到它使用西班牙文文本；数字应以西班牙格式表示：![如何做到这一点…](img/00212.jpeg)
- en: How it works…
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When you would like to translate your app to other languages you first have
    to create it with the base language (default language) but bear in mind that every
    text can be translated; therefore instead of using hardcoded text, you have to
    retrieve it from the `Localizable.strings` file.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想将你的应用程序翻译成其他语言时，你首先必须使用基础语言（默认语言）创建它，但请记住，每个文本都可以被翻译；因此，而不是使用硬编码的文本，你必须从`Localizable.strings`文件中检索它。
- en: Use the `NSLocalizedString` for retrieving strings from the Localizable file.
    You can also get format strings and use them in the String format initializer.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`NSLocalizedString`从本地化文件中检索字符串。你还可以获取格式字符串并在字符串格式初始化器中使用它们。
- en: You can also use date and number formatters using `NSDateFormatter` and `NSNumberFormatter`;
    that way you don't have to worry about local dates and numbers.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以使用`NSDateFormatter`和`NSNumberFormatter`来使用日期和数字格式化；这样你就不必担心本地日期和数字了。
- en: It's also possible to translate your storyboard, so it is not necessary to set
    the labels and placeholders on the view did load.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 也可以翻译你的故事板，因此不需要在视图加载时设置标签和占位符。
- en: There's more…
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多…
- en: You can also translate other files such as the launch screen and the `Info.plist`.
    For example you can change the application name according to the language using
    the `Bundle display name` key (`CFBundleDisplayName`).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以翻译其他文件，例如启动屏幕和`Info.plist`。例如，你可以使用`Bundle display name`键（`CFBundleDisplayName`）根据语言更改应用程序名称。
- en: The `NSLocalizedString` has other options that allow you to use translation
    in complex applications.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSLocalizedString`有其他选项，允许你在复杂的应用程序中使用翻译。'
- en: Method swizzling in Swift
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中的方法交换
- en: Method swizzling is a well-known practice with programming languages that support
    a dynamic method dispatch. This is also very common in Objective-C. With method
    swizzling, you are able to swap out a method implementation for a different one
    at runtime. It is recommended to use method swizzling sparingly and only when
    an alternative (possibly protocols or extensions) is not present.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 方法交换是支持动态方法调度的编程语言中的一种常见做法。这在Objective-C中也非常常见。通过方法交换，你可以在运行时交换一个方法实现为另一个实现。建议谨慎使用方法交换，并且仅在没有替代方案（可能是协议或扩展）时使用。
- en: Getting ready
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a playground and name it `Swizzling`. We will not be using a project
    for this recipe so do not worry about project settings.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为`Swizzling`的游乐场。我们在这个食谱中不会使用项目，所以不用担心项目设置。
- en: How to do it…
  id: totrans-292
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'We will use `UIViewController` as an example. Add the following code to your
    playground:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将以`UIViewController`为例。将以下代码添加到你的游乐场中：
- en: '[PRE55]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'We also want to make sure that we are not swizzling from a subclass when we
    expect the super class. Add the following code after initializing the static struct:'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还想要确保当我们期望父类时，我们不会从子类中进行交换。在初始化静态结构后添加以下代码：
- en: '[PRE56]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works…
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: For this example we want additional actions to be taken for every `UIViewController`;
    however, we need to preserve the original functionality of `viewWillAppear`. This
    can only be accomplished with method swizzling. Although Swift takes a more static
    approach to method dispatch, you are still able to swizzle methods at runtime.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们希望为每个`UIViewController`执行额外的操作；然而，我们需要保留`viewWillAppear`的原始功能。这只能通过方法交换来完成。尽管Swift在方法调度方面采取了更静态的方法，但你仍然可以在运行时交换方法。
- en: We wrap every call in a `dispatch_once` block to guarantee this only happens
    once at runtime. We define each Selector, both the existing and the new one. Once
    we make a call to `class_addMethod` we check that it worked, and if so, swap implementations
    (happens at runtime).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将每个调用包裹在 `dispatch_once` 块中，以确保这仅在运行时发生一次。我们定义每个选择器，包括现有的和新的一。一旦我们调用 `class_addMethod`，我们检查它是否成功，如果是，则交换实现（在运行时发生）。
- en: If you are familiar with Objective-C, you will note that normally swizzling
    methods occur in the load method, which is guaranteed to be called when a class
    definition is loaded. Considering this is an Objective-C method only, we call
    the swizzling code in initialize, which occurs before any class methods are called.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你熟悉Objective-C，你会注意到通常方法交换发生在加载方法中，这是在类定义加载时保证会被调用的。考虑到这是一个Objective-C方法，我们只在初始化方法中调用交换代码，这是在调用任何类方法之前发生的。
- en: There's more…
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In addition to swizzling system methods, you can also swizzle methods created
    in custom Swift classes. There are some extra considerations, however. The class
    must extend NSObject and the desired method must also include the dynamic attribute
    in their definition. Using `@objc` will cause your code to run through the Objective-C
    runtime (thus supporting dynamic method dispatch); however, it does not guarantee
    the dynamic dispatch of a property or method.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 除了交换系统方法之外，你还可以交换自定义Swift类中创建的方法。然而，有一些额外的考虑。类必须扩展 `NSObject`，并且期望的方法定义中也必须包含动态属性。使用
    `@objc` 会使你的代码通过Objective-C运行时运行（从而支持动态方法分发）；然而，它并不保证属性或方法的动态分发。
- en: Associated objects in Swift
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift中的关联对象
- en: In addition to method swizzling, we can also utilize another runtime process
    known as associated objects. This is similar to extensions in Swift; however,
    extensions do not allow you to add a new property to an existing class. Let's
    add a descriptive name property to all UIViewControllers.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 除了方法交换之外，我们还可以利用另一种称为关联对象的运行时过程。这与Swift中的扩展类似；然而，扩展不允许你向现有类添加新属性。让我们给所有 `UIViewControllers`
    添加一个描述性名称属性。
- en: Getting ready
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a playground and name it `Associated Objects`. We will not be using a
    project for this recipe so do not worry about project settings. If you used the
    previous recipe, you may continue with the same playground file.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `Associated Objects` 的游乐场。我们在这个食谱中不会使用项目，所以不用担心项目设置。如果你使用了之前的食谱，你可以继续使用相同的游乐场文件。
- en: How to do it…
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Add the following code to your playground file:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的游乐场文件中：
- en: '[PRE57]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: How it works…
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we create a private static struct to store keys that reference our objects.
    In this case, it will only be the `DescriptiveName` object. Now we define a new
    variable for `UIViewController` and perform the required methods in the get and
    set methods.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个私有的静态结构体来存储引用我们的对象的键。在这种情况下，它将只包含 `DescriptiveName` 对象。现在我们为 `UIViewController`
    定义一个新的变量，并在获取和设置方法中执行所需的方法。
- en: We use the `objc_getAssociatedObject()` to return the proper object and cast
    it as a String object. For set, we call the `objc_setAssociatedObject()` method.
    Here we pass in self to let the runtime know we are adding to the `UIViewController`
    and then reference our static struct for the object we want to associate with
    the class. Last, we set up the property to be retained and non-atomic.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `objc_getAssociatedObject()` 来返回正确的对象，并将其转换为String对象。对于设置，我们调用 `objc_setAssociatedObject()`
    方法。在这里，我们传递 `self` 以让运行时知道我们正在向 `UIViewController` 添加内容，然后引用我们静态结构体中的对象，我们想要将其与类关联。最后，我们设置属性以保留并设置为非原子。
- en: The result is that every `UIViewController` will contain a new property, `DescriptiveName`,
    which can be accessed anywhere in code.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是每个 `UIViewController` 都将包含一个新的属性，`DescriptiveName`，可以在代码的任何地方访问。
