- en: Swift Playgrounds
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 游乐场
- en: Throughout this book, we have been using Swift Playgrounds to work through code
    examples as we explore the Swift language. Playgrounds are great for this use
    case, as they allow you to explore code and framework APIs without needing the
    infrastructure of an iOS, macOS, or tvOS app to execute the code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们一直在使用 Swift 游乐场来处理代码示例，以探索 Swift 语言。游乐场非常适合这种用途，因为它们允许你在不需要 iOS、macOS
    或 tvOS 应用程序的基础设施的情况下探索代码和框架 API。
- en: Their features go beyond how we have used them so far in this book, and in this
    chapter, we will explore some of those features, from using additional code and
    resources to creating fully interactive experiences.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 它们的功能超出了我们在本书中迄今为止的使用，在本章中，我们将探索其中的一些功能，从使用额外的代码和资源到创建完全交互式的体验。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Using Swift Playgrounds for UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Swift 游乐场进行 UI 开发
- en: Importing resources into playgrounds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将资源导入游乐场
- en: Importing code into playgrounds
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将代码导入游乐场
- en: Multi-page playgrounds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多页游乐场
- en: Using Swift Playgrounds on iPadOS
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 iPadOS 上使用 Swift 游乐场
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/37t4f0A](https://bit.ly/37t4f0A).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[https://bit.ly/37t4f0A](https://bit.ly/37t4f0A)。
- en: Using Swift Playgrounds for UI
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Swift 游乐场进行 UI 开发
- en: We can use Playgrounds to experiment with UI and test custom views and interfaces.
    In this recipe, we will build a bar chart view that we can use to display numerical
    data in chart form and use a playground to test it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用游乐场来实验 UI 并测试自定义视图和界面。在本食谱中，我们将构建一个条形图视图，我们可以用它以图表形式显示数值数据，并使用游乐场来测试它。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we'll create an iOS-based playground to build our bar chart. In Chapter
    1, *Swift Building Blocks*, we went through creating a new playground, so return
    there if you need a refresher.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个基于 iOS 的游乐场来构建我们的条形图。在第一章《Swift 基础》中，我们学习了如何创建一个新的游乐场，所以如果你需要复习，请回到那里。
- en: 'We will create a custom view that will display information in bar chart form,
    and use that to test some features of playgrounds. You can either enter the following
    code into a new iOS-based playground or download the playground named `Simple_iOS.playground`
    from this book''s GitHub repository:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个自定义视图，以条形图的形式显示信息，并使用它来测试游乐场的一些功能。你可以将以下代码输入到一个新的 iOS 游乐场中，或者从本书的 GitHub
    仓库下载名为 `Simple_iOS.playground` 的游乐场：
- en: 'Create a `Color` struct:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Color` 结构体：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a `Bar` struct and `BarView`:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Bar` 结构体和 `BarView`：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Create the `BarChart` view:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `BarChart` 视图：
- en: '[PRE2]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How to do it...
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In the code that we defined in the **Getting ready** section, the `BarChart`
    view can be created with a frame and a background color, and then bars can be
    added in the form of a `Bar` struct containing a value and a color. The `BarChart`
    view uses these to create subviews of the correct relative size and scale to represent
    the values of the bars.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们定义的 **准备** 部分的代码中，可以使用框架和背景颜色创建 `BarChart` 视图，然后可以通过包含值和颜色的 `Bar` 结构体以条形的形式添加条。`BarChart`
    视图使用这些信息来创建正确相对大小和比例的子视图，以表示条形的值。
- en: 'Let''s write some code to make use of our `BarChart` view:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写一些代码来利用我们的 `BarChart` 视图：
- en: 'Enter the following into the playground at the bottom:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游乐场的底部输入以下内容：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Press the blue play button at the bottom-left of the playground window to execute
    the code. As your code executes, you will see that the playground sidebar fills
    up with information.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下游乐场窗口左下角的蓝色播放按钮来执行代码。随着代码的执行，你将看到游乐场侧边栏充满了信息。
- en: 'In Chapter 1, *Swift Building Blocks*, we saw that playgrounds have a timeline
    that provides information about each line of execution. As you pass your cursor
    over the line, you see an eye-shaped icon that will display a preview of the result
    of that line of execution. Where the line involves a UI element such as `view`,
    the playground will render that view and display it in a preview box:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第1章《Swift构建块》中，我们了解到游乐场有一个时间轴，它提供了关于每行执行的信息。当你将光标移过某行时，你会看到一个眼睛形状的图标，它将显示该行执行的结果预览。如果该行涉及UI元素，如`view`，游乐场将渲染该视图并在预览框中显示它：
- en: '![](img/38e889da-668d-46db-909a-ca90e823c1c9.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/38e889da-668d-46db-909a-ca90e823c1c9.png)'
- en: Figure 7.1 – BarChart preview box
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 柱状图预览框
- en: 'The same is true for the pinned inline preview that you can get by pressing
    the square button in the timeline:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这同样适用于通过按时间轴中的方形按钮获得的固定内联预览：
- en: '![](img/9d5b513b-badc-43c0-a5ff-b7845022ad43.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9d5b513b-badc-43c0-a5ff-b7845022ad43.png)'
- en: Figure 7.2 – BarChart inline preview
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 柱状图内联预览
- en: These features can be great for testing and tweaking view code.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能对于测试和调整视图代码非常有用。
- en: 'If the purpose of the playground is to demo or experiment with a custom view
    component and you''d like a more prominent view output, you can use the playground''s
    live view feature:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果游乐场的目的是演示或实验自定义视图组件，并且你希望获得更突出的视图输出，你可以使用游乐场的实时视图功能：
- en: 'Import the `PlaygroundSupport` framework at the top of the playground:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在游乐场的顶部导入`PlaygroundSupport`框架：
- en: '[PRE4]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `PlaygroundSupport` framework provides a number of features for accessing
    various features of the playground.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`PlaygroundSupport`框架提供了一系列功能，用于访问游乐场的各种功能。'
- en: 'Add the following to set our `BarChart` view to be the playground''s live view:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下内容以设置我们的`BarChart`视图为游乐场的实时视图：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If the playground''s live view isn''t visible, you can display it from the
    menu. Go to Editor | Live View:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游乐场的实时视图不可见，你可以从菜单中显示它。转到编辑器 | 实时视图：
- en: '![](img/86c567e5-614c-4f42-befc-e780e44af661.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/86c567e5-614c-4f42-befc-e780e44af661.png)'
- en: Figure 7.3 – Live view
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 实时视图
- en: This view will be updated as the code in the playground changes. Try changing
    the value of the bars and see the view change.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当游乐场中的代码发生变化时，此视图将更新。尝试更改柱子的值，看看视图如何变化。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'A playground''s live view can be anything that conforms to `PlaygroundLiveViewable`.
    On iOS, both `UIView` and `UIViewController` conform to `PlaygroundLiveViewable`,
    as do their equivalents on macOS: `NSView` and `NSViewController`.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 游乐场的实时视图可以是任何符合`PlaygroundLiveViewable`的组件。在iOS上，`UIView`和`UIViewController`都符合`PlaygroundLiveViewable`，macOS上的等效组件`NSView`和`NSViewController`也是如此。
- en: In the preceding code, we construct a `BarChart`, which is a `UIView`, and assign
    it to the `liveView` property of the current `PlaygroundPage`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们构建了一个`BarChart`，它是一个`UIView`，并将其分配给当前`PlaygroundPage`的`liveView`属性。
- en: These live views respond to touch events just as they would in a macOS app or
    in the iOS simulator. Therefore, you can use them to test interactive views and
    controls.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实时视图对触摸事件的响应就像在macOS应用程序或iOS模拟器中一样。因此，你可以使用它们来测试交互式视图和控制。
- en: Unfortunately, playgrounds do not currently support interface builder layout
    files, which are the `.xibs` and `.storyboard` files. Therefore, to use Playgrounds
    with your custom views, you will have to lay out your views programmatically.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，游乐场目前不支持界面构建器布局文件，即`.xibs`和`.storyboard`文件。因此，为了使用带有自定义视图的游乐场，你必须以编程方式布局你的视图。
- en: Be aware that iOS-based playgrounds support many, but not all, of the frameworks
    available in the iOS SDK, so this may limit what you can do in a playground.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，基于iOS的游乐场支持iOS SDK中许多但不是所有框架，因此这可能会限制你在游乐场中能做的事情。
- en: There's more...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the preceding example, and for most of this book, we focused on iOS-based
    playgrounds. However, macOS-based playgrounds are just as useful for the macOS
    platform and can also be used for UI testing and experimentation.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，以及本书的大部分内容中，我们专注于基于iOS的游乐场。然而，基于macOS的游乐场对于macOS平台同样有用，也可以用于UI测试和实验。
- en: You will find a macOS-based playground called `Simple_macOS.playground` that
    also creates a simple bar chart view in this book's GitHub repository at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书的GitHub仓库中找到一个名为`Simple_macOS.playground`的基于macOS的游乐场，它也创建了一个简单的条形图视图。[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI)
- en: 'Alternatively, you can create a new macOS-based playground and enter the following
    code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，您也可以创建一个新的基于macOS的游乐场，并输入以下代码：
- en: 'Create a `Color` struct:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Color`结构体：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a `Bar` struct and `BarView`:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`Bar`结构体和`BarView`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create the `BarChart` view:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`BarChart`视图：
- en: '[PRE8]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Use the `BarChart` to display information:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`BarChart`来显示信息：
- en: '[PRE9]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This macOS version of our custom `barView` works exactly like the iOS version,
    and the live view for a macOS-based playground works exactly like its iOS-based
    counterparts.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们自定义的`barView`在macOS版本上与iOS版本完全相同，基于macOS的游乐场的实时视图与其基于iOS的对应版本完全相同。
- en: Similar to iOS, macOS-based playgrounds support many, but not all, of the frameworks
    available in the macOS SDK, so this may limit what you can do in a playground.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 与iOS类似，基于macOS的游乐场支持许多，但不是所有在macOS SDK中可用的框架，因此这可能会限制您在游乐场中能做的事情。
- en: Hopefully, you can see from this recipe that Swift Playgrounds can be really
    useful for viewing UI experimentation on both iOS and macOS.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您可以从本食谱中看到，Swift Playgrounds对于在iOS和macOS上查看UI实验确实非常有用。
- en: See also
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Apple's reference for the Playground Support framework can be found at [http://swiftbook.link/docs/playgroundsupport](http://swiftbook.link/docs/playgroundsupport).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Apple的Playground Support框架参考可以在[http://swiftbook.link/docs/playgroundsupport](http://swiftbook.link/docs/playgroundsupport)找到。
- en: Importing resources into playgrounds
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将资源导入到游乐场中
- en: While building apps, we will often need to include resources, such as images.
    How can we do the same with playgrounds so that our UI can incorporate these images?
    That is what we will investigate in this recipe.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建应用程序时，我们通常会需要包含资源，例如图片。我们如何才能在游乐场中做到这一点，以便我们的UI可以包含这些图片？这正是本食谱将要探讨的内容。
- en: We will improve our bar chart custom view from the previous recipe by adding
    a semi-transparent image to provide a texture for the bars.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在上一个食谱中的条形图自定义视图中添加半透明图像来提供纹理，来改进我们的条形图自定义视图。
- en: Getting ready
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will start with the playground from the previous recipe.
    The playground is called `Simple_iOS.playground`, and you can get it from the
    GitHub repository for this book at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI)
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将从上一个食谱中的游乐场开始。这个游乐场的名字是`Simple_iOS.playground`，您可以从本书的GitHub仓库中获取它。[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/01_Using_Swift_Playgrounds_for_UI)
- en: 'We will be using a semi-transparent texture image for this recipe. You can
    supply your own, or download a sample one from here: [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources)'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将使用半透明纹理图像。您可以提供自己的图像，或者从这里下载一个示例：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds/EmbeddedResource.playground/Resources)
- en: How to do it...
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s take a look at the following steps to understand how to add our image
    to the playground:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下步骤，了解如何将我们的图片添加到游乐场中：
- en: 'We need to open up Xcode''s project navigator, which is often not visible by
    default when a playground is opened. To reveal the project navigator, select View
    | Navigators | Project from the menu. Alternatively, you can select the left pane
    reveal button in the top-left corner of the Xcode window:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要打开Xcode的项目导航器，通常在打开游乐场时默认不可见。要显示项目导航器，从菜单中选择视图 | 导航器 | 项目。或者，您也可以选择Xcode窗口左上角的最左侧面板展开按钮：
- en: '![](img/43cbb9b5-0d88-41a1-bb7c-5ff765b0dad2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/43cbb9b5-0d88-41a1-bb7c-5ff765b0dad2.png)'
- en: Figure 7.4 – Project navigator
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4 – 项目导航器
- en: The playground will be listed at the top of the project navigator, along with
    a disclosure triangle.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds将列在项目导航器的顶部，与展开三角形一起。
- en: Select the triangle to reveal folders named `Sources` and `Resources`.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择三角形以显示名为`Sources`和`Resources`的文件夹。
- en: 'Drag the texture image from Finder into the `Resources` folder:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将纹理图像从Finder拖入`Resources`文件夹：
- en: '![](img/9252bd56-5d3a-4cc4-b9c5-39ad0c0f7279.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9252bd56-5d3a-4cc4-b9c5-39ad0c0f7279.png)'
- en: Figure 7.5 – Adding a file to the project
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 向项目中添加文件
- en: Now that we have embedded our texture image within our playground, we need to
    make use of it. We want each bar in the bar chart to have a settable color, but
    for the texture to sit on top of that color.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将纹理图像嵌入到我们的Playground中，我们需要使用它。我们希望条形图中的每个条都有可设置的颜色，但纹理要放在这个颜色之上。
- en: 'Update the `BarView` part of our code to use the texture image:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新我们代码中的`BarView`部分以使用纹理图像：
- en: '[PRE10]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can retrieve the image in the same way we would in a full app by referencing
    the filename of the image, without the file extension, in a `UIImage` initializer:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可以通过引用图像的文件名（不包含文件扩展名）在`UIImage`初始化器中检索图像，就像在完整的应用程序中做的那样：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'When the playground is executed, you will see that our bar chart looks a lot
    more interesting:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 当Playground执行时，你会看到我们的条形图看起来要有趣得多：
- en: '![](img/82aa36b1-7709-45fe-ac97-d578eb0237bf.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82aa36b1-7709-45fe-ac97-d578eb0237bf.png)'
- en: Figure 7.6 – Textured bar chart
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6 – 纹理条形图
- en: How it works...
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To understand where the image that we added is stored, it helps to know how
    playgrounds are structured.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解我们添加的图像存储在哪里，了解Playgrounds的结构很有帮助。
- en: 'A playground is actually a folder, but with a `.playground` file extension.
    We can see this by taking a playground file and showing the context menu, which
    can be done by right-clicking or holding *Ctrl* while clicking on the file. From
    this menu, select Show Package Contents:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Playground是一个文件夹，但具有`.playground`文件扩展名。我们可以通过右键单击或按住*Ctrl*键单击文件来显示上下文菜单。从该菜单中选择“显示包内容”：
- en: '![](img/ac4a88cc-26b3-4f6a-9efe-284d1b2f6daf.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ac4a88cc-26b3-4f6a-9efe-284d1b2f6daf.png)'
- en: Figure 7.7 – Viewing Package Contents
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.7 – 查看包内容
- en: 'This will open the playground as a folder, showing its contents. In there,
    you will find a number of files, including one called `Contents.swift`, which
    is the Swift file containing the code that is executed. There is also a folder
    called `Resources`, which contains the texture image we imported:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开Playground作为文件夹，显示其内容。在那里，你会找到许多文件，包括一个名为`Contents.swift`的文件，它包含执行代码的Swift文件。还有一个名为`Resources`的文件夹，其中包含我们导入的纹理图像：
- en: '![](img/a5abe1ff-9729-4f31-b307-fde116dc58df.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![](img/a5abe1ff-9729-4f31-b307-fde116dc58df.png)'
- en: Figure 7.8 – Package Contents
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.8 – 包内容
- en: By dragging the image into the file navigator, Xcode created this folder and
    placed the image in it. Alternatively, we could have created this folder manually
    and dropped it in the image. Playgrounds will look for a folder named `Resources`,
    and all the resources in it will be made available from the playground.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将图像拖入文件导航器，Xcode创建了此文件夹并将图像放入其中。或者，我们也可以手动创建此文件夹并将图像放入其中。Playgrounds会寻找名为`Resources`的文件夹，并将其中所有资源都提供给Playground。
- en: See also
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The result of this recipe is available as `EmbeddedResources.playground` in
    the GitHub repository for this book, in the `chapter 7` folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的结果可在本书的GitHub仓库中找到，位于`chapter 7`文件夹下的`EmbeddedResources.playground`。
- en: Importing code into playgrounds
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将代码导入Playgrounds
- en: As we have seen throughout this chapter, and this book, playgrounds are a great
    canvas for exploring APIs, frameworks, and custom code. However, if you want to
    explore uses for your own code, it appears that you need to include all the code
    needed in the playground, and that can make it long and unwieldy.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章和本书中看到的，Playgrounds是探索API、框架和自定义代码的绝佳画布。然而，如果你想探索你自己的代码的用途，似乎你需要将所有需要的代码都包含在Playground中，这可能会使它变得很长且难以管理。
- en: It doesn't need to be that way. In this recipe, we will see how you can embed
    Swift code in your playground and make use of it from your playground code.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 不一定需要这样。在本食谱中，我们将看到如何将Swift代码嵌入到Playground中，并从Playground代码中使用它。
- en: Getting ready
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the playground from the previous recipe, called
    `EmbeddedResources.playground`, which can be retrieved from this book's GitHub
    repository at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用上一个菜谱中的游乐场，名为 `EmbeddedResources.playground`，可以从本书的 GitHub 仓库中检索到，网址为
    [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/02_Import_Resources_into_Playgrounds)。
- en: How to do it...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will take the `BarChart` custom view and related code and move it to a separate
    file embedded within the playground, leaving us free to use the playground to
    experiment with our custom view:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 `BarChart` 自定义视图和相关代码移动到游乐场中嵌入的单独文件中，这样我们就可以自由地使用游乐场来实验我们的自定义视图：
- en: If the playground's project navigator isn't visible, select View | Navigators
    | Project from the menu.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果游乐场的项目导航器不可见，请从菜单中选择视图 | 导航器 | 项目。
- en: 'Select the Sources folder and then select File | New | File from the menu to
    create a new Swift file in your `**Sources**` folder:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `Sources` 文件夹，然后从菜单中选择文件 | 新建 | 文件来在你的 `**Sources**` 文件夹中创建一个新的 Swift 文件：
- en: '![](img/aa82d350-1fc3-440d-a597-f7f798c30d73.png)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![](img/aa82d350-1fc3-440d-a597-f7f798c30d73.png)'
- en: Figure 7.9 – Sources folder
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.9 – Sources 文件夹
- en: If you already have Swift files that you want to embed in a playground, you
    can drag the files into the `Sources` folder, just like we did with our texture
    image in the previous recipe.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经有想要嵌入到游乐场中的 Swift 文件，你可以像我们在上一个菜谱中处理纹理图像那样，将这些文件拖拽到 `Sources` 文件夹中。
- en: Rename the new file `Color.swift`, as we will use this to hold our `Color` struct
    that is currently in the main playground content.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件 `Color.swift` 重命名为 `Color`，因为我们将会使用这个文件来存放当前主游乐场内容中的 `Color` 结构体。
- en: 'Enter the following code into `Color.swift`:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到 `Color.swift` 文件中：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we have added `public` access controls to the `Color` struct and its
    initializer; we will see more about that as we progress.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经为 `Color` 结构体及其初始化器添加了 `public` 访问控制；随着我们的进展，我们将了解更多关于这一点。
- en: 'Create another new Swift file in the `Sources` folder as we did earlier, called
    `BarChart.swift`, and then enter the rest of the code needed to define the `BarChart`
    custom view, starting with the `Bar` struct:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如同我们之前所做的那样，在 `Sources` 文件夹中创建另一个新的 Swift 文件，命名为 `BarChart.swift`，然后输入定义 `BarChart`
    自定义视图所需的其余代码，从 `Bar` 结构体开始：
- en: '[PRE13]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is followed by `BarView`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是 `BarView`：
- en: '[PRE14]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'And finally, we have `BarChart`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `BarChart`：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'With the `BarChart` implementation code contained in the `Sources` folder,
    the playground contents can be just for experimenting with the `BarChart` custom
    view. Remove the code we placed in the other files and you are left with the following:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Sources` 文件夹中包含的 `BarChart` 实现代码，游乐场内容可以仅用于实验 `BarChart` 自定义视图。移除我们放在其他文件中的代码，你将得到以下内容：
- en: '[PRE16]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In moving the `BarChart` implementation to embedded Swift files, we added `public`
    access control at points where we wanted it to be accessible from the playground
    content. This is because code within the `Sources` folder acts as a kind of lightweight
    module in terms of access control.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在将 `BarChart` 实现移动到嵌入的 Swift 文件中时，我们在想要从游乐场内容中访问的地方添加了 `public` 访问控制。这是因为 `Sources`
    文件夹中的代码在访问控制方面充当一种轻量级模块。
- en: Anything with the default `internal` access control is only accessible to other
    code inside the `Sources` folder. To make it accessible to code in the main playground
    content, it needs to be declared as `public` or `open`. This is really useful,
    as it allows you to be in control of what you expose to the playground content;
    so, you can provide well-designed APIs that don't expose the underlying complexity.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 任何具有默认 `internal` 访问控制的代码仅对 `Sources` 文件夹内的其他代码可访问。为了使其对主游乐场内容中的代码可访问，它需要声明为
    `public` 或 `open`。这非常有用，因为它允许你控制暴露给游乐场内容的内容；因此，你可以提供设计良好的 API，而不暴露底层复杂性。
- en: If you require a refresher on access controls or want to learn more, check out
    the recipe entitled *Controlling access with access control*, in [Chapter 2](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml),
    *Mastering the Building Blocks*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要复习访问控制或想了解更多，请查看第 2 章 *掌握构建块* 中名为 *使用访问控制控制访问* 的菜谱。
- en: See also
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The result of this recipe can be found in `EmbeddedSources.playground` in this
    book's GitHub repository.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的结果可以在本书GitHub仓库的`EmbeddedSources.playground`中找到。
- en: Further information about Swift access controls can be found in [Chapter 2](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml),
    *Mastering the Building Blocks*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Swift访问控制的更多信息可以在[第2章](67605929-e031-49f6-83a9-9f7352e9bad3.xhtml)，*掌握构建块*中找到。
- en: Multi-page playgrounds
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 多页面游乐场
- en: We've discussed how playgrounds can be a great tool for exploring APIs and experimenting
    with UIs. However, playgrounds can also be used for documenting APIs, and providing
    rich, linkable content. Swift Playgrounds provides support for rich text formatting
    in comments and multiple pages of content, and we will explore those features
    in this recipe.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了游乐场如何成为探索API和实验UI的强大工具。然而，游乐场也可以用于记录API，并提供丰富、可链接的内容。Swift游乐场在注释和多个页面内容中提供了对丰富文本格式的支持，我们将在本菜谱中探索这些功能。
- en: Getting ready
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start with the playground we used in the last recipe, which displayed
    our custom `BarChart` view. You can get the playground, called `EmbeddedSources.playground`,
    from the GitHub repository for this book at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从上一个菜谱中使用的游乐场开始，该游乐场显示了我们的自定义`BarChart`视图。你可以从本书的GitHub仓库中获取游乐场，名为`EmbeddedSources.playground`，网址为[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07)。
- en: We will use our `BarChart` view to display the price in US dollars of three
    different cryptocurrencies over a 6-month period between January 2020 and June
    2020\. We can show each type of currency on a different playground page.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用我们的`BarChart`视图来显示三种不同的加密货币在2020年1月至2020年6月之间的6个月期间的价格（美元）。我们可以在不同的游乐场页面上显示每种类型的货币。
- en: 'If you want to know more about cryptocurrencies, you can watch this explanatory
    video:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于加密货币的信息，你可以观看这个解释视频：
- en: '[http://swiftbook.link/videos/cryptocurrencies](http://swiftbook.link/videos/cryptocurrencies).'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://swiftbook.link/videos/cryptocurrencies](http://swiftbook.link/videos/cryptocurrencies)。'
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'By default, playgrounds have just one Swift content file, but for our purpose,
    we want to have three pages in our playground, one for each of the three cryptocurrencies
    we will document: Bitcoin, Etherium, and Lightcoin. Let''s get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，游乐场只有一个Swift内容文件，但为了我们的目的，我们想在游乐场中有三个页面，每个页面对应我们将要记录的三种加密货币：比特币、以太坊和莱特币。让我们开始吧：
- en: If the project navigator isn't visible, you should make it visible using the
    menu by selecting View | Navigators | Project.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目导航器不可见，你应该通过菜单选择视图 | 导航器 | 项目来使其可见。
- en: 'To create a new playground page, you can click on the plus button in the bottom
    left-hand corner of the project navigator, or select File | New | Playground Page
    from the menu:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的游乐场页面，你可以点击项目导航器左下角的加号按钮，或者从菜单中选择文件 | 新建 | 游乐场页面：
- en: '![](img/8d036058-f503-42c7-9d68-8f2750155e88.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8d036058-f503-42c7-9d68-8f2750155e88.png)'
- en: Figure 7.10 – New Playground Page
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.10 – 新游乐场页面
- en: 'When creating a new playground page, the existing contents of the playground
    become a playground page, and another blank page is created:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建一个新的游乐场页面时，现有的游乐场内容将成为一个游乐场页面，并且会创建另一个空白页面：
- en: '![](img/b19ed5fc-387a-433b-9621-055121c7a461.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b19ed5fc-387a-433b-9621-055121c7a461.png)'
- en: Figure 7.11 – Creating a new page in Playgrounds
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.11 – 在游乐场中创建新页面
- en: 'Create three pages in total, as we will display data on three different cryptocurrencies,
    and rename them as follows:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建总共三个页面，因为我们将在三个不同的加密货币上显示数据，并将它们重命名为以下名称：
- en: '`Bitcoin`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Bitcoin`'
- en: '`Etherium`'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Etherium`'
- en: '`Lightcoin`'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Lightcoin`'
- en: Each of these pages can use the `BarChart` code in the `Sources` folder that
    we added in the previous recipe, so we can create a `BarChart` view on each page
    to chart the value of each currency.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面都可以使用我们在上一个菜谱中添加到“源”文件夹中的`BarChart`代码，因此我们可以在每个页面上创建一个`BarChart`视图来绘制每种货币的价值。
- en: 'Enter the following code into the `Bitcoin` playground page:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码输入到`Bitcoin`游乐场页面：
- en: '[PRE17]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, enter the following code into the `Etherium` playground page:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码输入到`Etherium`游乐场页面：
- en: '[PRE18]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Lastly, enter the following code into the `Lightcoin` playground page:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将以下代码输入到`Lightcoin`游乐场页面：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Each page displays the value history as a bar chart when run, and you can use
    the project navigator to switch between them.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个页面在运行时都会以条形图的形式显示价值历史，你可以使用项目导航器在它们之间切换。
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As we did in previous recipes, we can take a look inside the playground to
    see how each playground page is represented. Right-click on the playground, or
    hold *Ctrl* while clicking on it. From this menu, select Show Package Contents:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们在之前的菜谱中做的那样，我们可以查看游乐场内部，看看每个游乐场页面是如何表示的。右键点击游乐场，或者按住 *Ctrl* 键点击它。从该菜单中选择显示包内容：
- en: '![](img/6507b3a7-71a9-4d35-b158-fadb2227bf4e.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6507b3a7-71a9-4d35-b158-fadb2227bf4e.png)'
- en: Figure 7.12 – Viewing Package Contents
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.12 – 查看包内容
- en: 'You will see that the `Contents.swift` folder that we saw earlier has been
    replaced with a folder containing three `.xcplaygroundpage` files, one for each
    page in the playground:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到我们之前看到的`Contents.swift`文件夹已经被一个包含三个`.xcplaygroundpage`文件的文件夹所取代，每个文件对应游乐场中的一个页面：
- en: '![](img/6b6ba5b8-7ac1-4e6a-9ed9-1c9facc79830.png)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6b6ba5b8-7ac1-4e6a-9ed9-1c9facc79830.png)'
- en: Figure 7.13 – Extracted content
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.13 – 提取的内容
- en: Each of these `.playgroundpage` files is essentially a playground in itself.
    You can right-click on `.playgroundpage` and select Show Package Contents, and
    you will see the same playground structure that we saw previously. Much like the
    normal playground, a `.xcplaygroundpage` file can contain the `Sources` and `Resources`
    subfolders, and placing code and resources in these will make them visible to
    just that page.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这些`.playgroundpage`文件本质上就是一个游乐场。你可以右键点击`.playgroundpage`并选择显示包内容，你将看到我们之前看到的相同的游乐场结构。就像正常的游乐场一样，`.xcplaygroundpage`文件可以包含`Sources`和`Resources`子文件夹，将代码和资源放在这些文件夹中，将使它们仅对该页面可见。
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Since we can now add multiple pages of content and have the ability to embed
    code and resources, Swift Playgrounds appears very useful in terms of interactive
    code documentation. To assist in this use case, it would be great if we could
    have some control over the presentation of our comments; well we can, as playgrounds
    support comments in **Markdown**.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们现在可以添加多页内容，并且有嵌入代码和资源的能力，Swift游乐场在交互式代码文档方面看起来非常有用。为了帮助这个用例，如果我们能对我们的注释的展示有所控制那就太好了；实际上我们可以，因为游乐场支持Markdown注释。
- en: Markdown is a lightweight text formatting syntax, invented by *John Gruber*,
    and is widely used to write text that can then be rendered with rich text formatting.
    More details about Markdown can be found at [http://swiftbook.link/markdown/docs](http://swiftbook.link/markdown/docs).
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: Markdown是一种轻量级文本格式化语法，由*John Gruber*发明，广泛用于编写可以以富文本格式渲染的文本。有关Markdown的更多详细信息，请参阅[http://swiftbook.link/markdown/docs](http://swiftbook.link/markdown/docs)。
- en: We won't delve into the Markdown syntax, but you can find a useful *cheat sheet*
    at [http://swiftbook.link/markdown/cheatsheet](http://swiftbook.link/markdown/cheatsheet).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会深入Markdown语法，但你可以在[http://swiftbook.link/markdown/cheatsheet](http://swiftbook.link/markdown/cheatsheet)找到一个有用的速查表。
- en: 'In our playground, open up the File Inspector window by selecting from the
    menu View | Inspectors | File and look under Playground Settings. You will see
    an option for Render Documentation. Ensure that this is set to off while we write
    some Markdown comments:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游乐场中，通过选择菜单视图 | 检查器 | 文件打开文件检查器窗口，然后在游乐场设置下查看。你会看到一个渲染文档的选项。确保在我们编写一些Markdown注释时，这个选项是关闭的：
- en: '![](img/5120e954-28b5-446c-aa7f-8fec187b91d0.png)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5120e954-28b5-446c-aa7f-8fec187b91d0.png)'
- en: Figure 7.14 – Playground Settings
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.14 – 游乐场设置
- en: 'Let''s now add some comments to our `Bitcoin` page:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们在我们的`Bitcoin`页面上添加一些注释：
- en: '[PRE20]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: To indicate to the playground that your comments contain Markdown formatting,
    a colon, `:`, is added after the opening of the comment block. This works for
    multi-line comments, `/*:`, and single-line comments, `//:`.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让游乐场知道你的注释包含Markdown格式，在注释块的开始后添加一个冒号，`:`。这对于多行注释`/*:`和单行注释`//:`都适用。
- en: 'With these comments in place, let''s turn Render Documentation back on and
    see what the comments look like:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些注释到位后，让我们将渲染文档功能重新打开，看看注释看起来如何：
- en: '![](img/d24515e8-fc57-49e2-a82a-6f46534368e5.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d24515e8-fc57-49e2-a82a-6f46534368e5.png)'
- en: Figure 7.15 – Rendered document
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.15 – 渲染的文档
- en: 'In addition, playgrounds also support the creation of Markdown links between
    the playground pages; you can link to the next page with `@next` and to the previous
    page with `@previous`. So, in Markdown, the links will be as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，游乐场还支持在游乐场页面之间创建Markdown链接；你可以使用`@next`链接到下一页，使用`@previous`链接到上一页。所以，在Markdown中，链接将如下所示：
- en: '[PRE21]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: It is left as an exercise to the reader to add Markdown comments to the other
    two pages and provide links between the pages.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 将添加Markdown注释到其他两个页面并建立页面之间的链接，留作读者的练习。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The result of this recipe can be found as `MultiplePages.playground` in the
    GitHub repository for this book at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的结果可以在本书的GitHub仓库中的`MultiplePages.playground`文件找到，网址为[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter07/04_Multi-Page_Playgrounds/MultiplePages.playground)。
- en: Further information pertaining to the Markdown syntax can be found at [http://swiftbook.link/markdown/docs](http://swiftbook.link/markdown/docs).
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 有关Markdown语法的更多信息可以在[http://swiftbook.link/markdown/docs](http://swiftbook.link/markdown/docs)找到。
- en: Using Swift Playgrounds on iPadOS
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在iPadOS上使用Swift Playgrounds
- en: In 2016, Apple released an iPad-only app called Swift Playgrounds. Taken from
    the success of Playgrounds from Xcode, Swift Playgrounds for iPadOS went a step
    further and added an additional educational element to the app. In 2020, Apple
    also released a version for macOS, opening the doors for educational purposes
    and to those starting out who may feel a little intimidated by the Xcode IDE.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年，苹果发布了一个仅适用于iPad的应用程序，名为Swift Playgrounds。Swift Playgrounds for iPadOS借鉴了Xcode中Playgrounds的成功，并进一步为应用程序添加了一个额外的教育元素。2020年，苹果还发布了一个macOS版本，为教育目的以及那些可能对Xcode
    IDE感到有些畏惧的初学者打开了大门。
- en: In this recipe, we'll take a look at how we can more easily replicate a recipe
    similar to that from [Chapter 6](32abd392-d947-461c-a9e9-912b34704c9b.xhtml),
    *Building iOS Apps with Swift*, straight on our iPad.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将探讨如何在iPad上更轻松地复制类似于[第6章](32abd392-d947-461c-a9e9-912b34704c9b.xhtml)中“使用Swift构建iOS应用程序”的食谱。
- en: Getting ready
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, you'll need either an iPad running iOS 14.0 in order to download
    Swift Playgrounds from the App Store or alternatively, you can download the macOS
    version from the Mac App Store and follow along with this recipe too.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，你需要一台运行iOS 14.0的iPad来从App Store下载Swift Playgrounds，或者你也可以从Mac App Store下载macOS版本，并跟随这个食谱进行操作。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We''ll start by launching the Swift Playgrounds app from your device. You should
    be presented with the following:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从你的设备启动Swift Playgrounds应用程序。你应该会看到以下内容：
- en: '![](img/4202ce08-141b-4d26-b348-ca71a4ebdf8e.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4202ce08-141b-4d26-b348-ca71a4ebdf8e.png)'
- en: Figure 7.16 – Swift Playgrounds on iPadOS
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.16 – iPadOS上的Swift Playgrounds
- en: Next, you can either scroll along with the Get a Playground carousel until you
    see Blank or tap on the new document icon on the top left next to Locations.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你可以选择滚动浏览“获取游乐场”轮播图，直到看到空白页面，或者点击左上角靠近“位置”的新文档图标。
- en: A new document will be created and added to your playgrounds. Tap on this to
    open it.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将创建一个新的文档并将其添加到你的游乐场中。点击它以打开。
- en: 'Welcome to the Playgrounds Editor. This is where we can go ahead and write
    code, with a sense of familiarity that you''ll get from developing in Xcode:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到游乐场编辑器。这是我们编写代码的地方，你将感受到与在Xcode中开发时的熟悉感：
- en: '![](img/1b43150d-b4d6-4f00-b312-fa0d08b4fb98.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![](img/1b43150d-b4d6-4f00-b312-fa0d08b4fb98.png)'
- en: Figure 7.17 – My Playground
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.17 – 我的游乐场
- en: 'We''ll start by doing something simple, just to get familiar with the IDE (*yes,
    I''m calling it an IDE - it kind of is in a way...*):'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个简单的操作开始，只是为了熟悉IDE（是的，我在称呼它为IDE——从某种意义上说，它确实如此...）：
- en: Tap on the screen to raise the keyboard. If the keyboard doesn't raise, simply
    press the chevron on the right-hand side of the bottom toolbar. While you are
    down there, take a look at some of the available keyword suggestions – let, var,
    if, and so on.
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕以弹出键盘。如果键盘没有弹出，只需按下底部工具栏右侧的箭头键。当你处于那里时，看看一些可用的关键字建议——let、var、if等等。
- en: 'Go ahead and tap on the let constant. You will notice that the following is
    autopopulated for you:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往并点击let常量。你会注意到以下内容为你自动填充：
- en: '[PRE22]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the name placeholder highlighted, simply start typing your variable name,
    create one called `isSwitchedOn`, and now press the *tab* key to move the highlighted
    placeholder over to the `value`here. Then, type the word `true`.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在名称占位符高亮显示的情况下，只需开始输入你的变量名，创建一个名为`isSwitchedOn`的变量，然后按*tab*键将高亮显示的占位符移动到`value`这里。然后，输入单词`true`。
- en: Just as you would expect in Swift, type inference kicks in and we've created
    a constant Bool called `isSwitchedOn` with the value of `true`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在Swift中预期的那样，类型推断开始工作，我们创建了一个名为`isSwitchedOn`的布尔常量，其值为`true`。
- en: 'Next, on a new line, tap on `if` and complete the following highlighted code
    snippet:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在新的一行上，点击`if`并完成以下突出显示的代码片段：
- en: '[PRE23]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Once done, press the Run My Code button and you should observe that a red indicator
    appears on the icon to the left of this button. Tap on that to reveal the console
    window and check out your print statement.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，点击“运行我的代码”按钮，你应该会注意到按钮左侧的图标上出现了一个红色指示器。点击它以显示控制台窗口并检查你的打印语句。
- en: 'Pretty cool hey! OK, so let''s do something a bit more complex and fun. Create
    another project and call it `Quotes` (or whatever name you prefer):'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 真的很酷啊！好的，那么让我们来做一些更复杂、更有趣的事情。创建另一个项目，并将其命名为`Quotes`（或你喜欢的任何名称）：
- en: 'First, we need to add a couple of imports if they are not already there:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，如果还没有添加，我们需要添加几个导入：
- en: '[PRE24]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is followed by the third line, which sets the playground to run continuously.
    We'll go into more details as to why we need that in our *How it works...* section.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这后面是第三行，它将游乐场设置为持续运行。我们将在“如何工作...”部分中详细介绍为什么我们需要这样做。
- en: 'Next, we''ll continue by creating a couple of structs, as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建几个结构体，如下所示：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'These match the response type from the API we are about to call. Next, let''s
    create a function similar to the `fetchRepos()` function:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些与即将调用的API的响应类型相匹配。接下来，让我们创建一个类似于`fetchRepos()`函数的函数：
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: For simplicity, I've made some small tweaks here, as highlighted in the preceding
    code. We have just made an adjustment to the `return` type, returning our codable
    object that we created in the previous step.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简单起见，我在这里做了一些小的调整，如前述代码中突出显示的那样。我们只是调整了`return`类型，返回我们在上一步中创建的可编码对象。
- en: We're also calling a different API, one that will return us with an array of
    quotes that we can iterate through.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还调用了一个不同的API，它将返回一个包含引言的数组，我们可以遍历它。
- en: 'Next, let''s call our function:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们调用我们的函数：
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Here, we''re just iterating around the response, but you should see the following
    red badge appear next to our console icon:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们只是在遍历响应，但你应该看到控制台图标旁边出现以下红色徽章：
- en: '![](img/7150ec30-df04-400a-9e2b-5bb0f5286afa.jpeg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7150ec30-df04-400a-9e2b-5bb0f5286afa.jpeg)'
- en: Figure 7.18 – The Stop running button
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.18 – 停止运行按钮
- en: Go ahead and tap on the icon and see the results logged to the console. If everything
    is going well, you should now see a list of 10 quotes.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好的，请点击图标并查看结果是否已记录到控制台。如果一切顺利，你现在应该能看到一个包含10条引言的列表。
- en: 'With this all working, let''s take a look at how we can arrange our code a
    little better, much like Playgrounds in Xcode. Our main Swift file is embedded
    within a single root file; however, we are given support for **modules** with
    the addition of shared code files:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都工作正常后，让我们看看我们如何更好地组织我们的代码，就像Xcode中的Playgrounds一样。我们的主要Swift文件嵌入在一个根文件中；然而，我们通过添加共享代码文件得到了对**模块**的支持：
- en: 'To access these, press on the navigation icon in the top-left corner next to
    the close button. When pressed, it should look something like this:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要访问这些，请点击右上角靠近关闭按钮的导航图标。按下时，它应该看起来像这样：
- en: '![](img/c14fb91a-fc89-4bf8-8120-2ec132994266.jpeg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c14fb91a-fc89-4bf8-8120-2ec132994266.jpeg)'
- en: Figure 7.19 – Project navigation window
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.19 – 项目导航窗口
- en: Don't worry too much about the file structure, we'll go through that in the
    *How it works...* section later; all you need to know for now is that all code
    that can be used (or *shared*) by the playground file is within a module called
    UserModule (which can be renamed should you wish).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 不要过于担心文件结构，我们将在“如何工作...”部分稍后介绍；现在你需要知道的是，所有可以由游乐场文件使用（或*共享*）的代码都在一个名为UserModule的模块中（如果你愿意，可以重命名）。
- en: Under here is a file called `SharedCode.swift`. Highlight this and cut and paste
    the codable structs from the main project into here. You can rename `SharedCode.swift`
    to `Models.swift` if you like.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里有一个名为`SharedCode.swift`的文件。突出显示它并将主项目中的可编码结构体剪切并粘贴到这里。如果你喜欢，可以将`SharedCode.swift`重命名为`Models.swift`。
- en: 'Run the project again and you''ll notice that you''re given the following compiler
    error – Property cannot be declared public because its type uses an internal type*.*
    Basically, due to the way Swift Playgrounds interprets external files, you need
    to make the structs public:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行项目，你会注意到你得到了以下编译器错误——属性不能声明为public，因为它的类型使用了一个内部类型*.*基本上，由于Swift Playgrounds解释外部文件的方式，你需要将结构体声明为public：
- en: '[PRE28]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Run this again and you''ll see the logic working again in all its glory, but
    as nice as it is to see this in the output window, let''s again take a look at
    how we can add this to our `liveView` canvas:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行，你会看到逻辑再次以所有它的辉煌工作，但尽管在输出窗口中看到这一点很令人高兴，但让我们再次看看我们如何将其添加到我们的 `liveView` 画布中：
- en: 'We start by programmatically creating a `TableViewController()`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先通过编程创建一个 `TableViewController()`：
- en: '[PRE29]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'We''ll override `viewWillLoad()` and add in our code here to call our `fetchQuotes()`
    function:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将重写 `viewWillLoad()` 并在这里添加我们的代码来调用 `fetchQuotes()` 函数：
- en: '[PRE30]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Now we''ll need to add a couple of class properties, so incorporate the following:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要添加几个类属性，所以结合以下内容：
- en: '[PRE31]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`URLSession` will be used for our `fetchQuotes()` function just as we needed
    before. The quotes array will be where we store all our quotes from the API response.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`URLSession` 将用于我们的 `fetchQuotes()` 函数，正如我们之前需要的那样。引用数组将是我们存储从 API 响应中获取的所有引用的地方。'
- en: Next, copy the `fetchQuotes()` function into the `TableViewController` class
    (currently this will sit outside).
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将 `fetchQuotes()` 函数复制到 `TableViewController` 类中（目前这将位于外部）。
- en: 'Now, we can extend `viewDidLoad()` to call our function:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以扩展 `viewDidLoad()` 来调用我们的函数：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Notice that in the preceding code, rather than printing the output to the console,
    we'll now add this to our quotes array. Once our array has been populated and
    we're no longer iterating around the response, we can call `reloadData()` on our
    table view, which we'll need to do inside `DispatchQueue.main.async` to force
    the reload on the main thread (as we're currently inside an asynchronous response
    callback from our API).
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们不会将输出打印到控制台，而是将其添加到我们的引用数组中。一旦我们的数组被填充，并且我们不再迭代响应，我们就可以在我们的表格视图中调用
    `reloadData()`，这需要在 `DispatchQueue.main.async` 中执行以强制在主线程上重新加载（因为我们目前处于来自 API
    的异步响应回调中）。
- en: 'Once this is done, let''s add in some `UITableView` delegates that are required
    in order for our Table view to display our data:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦完成，让我们添加一些必要的 `UITableView` 代理，以便我们的表格视图可以显示我们的数据：
- en: '[PRE33]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We will now need to add `numberOfSections()` in any order, which will return
    `1` followed by `numberOfRowsInSection()`, which will return the number of quotes
    in our array.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要按任何顺序添加 `numberOfSections()`，它将返回 `1`，然后是 `numberOfRowsInSection()`，它将返回我们数组中的引用数量。
- en: 'Finally, we need to add in the `cellForRowAt()` delegate:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要添加 `cellForRowAt()` 代理：
- en: '[PRE34]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we simply create an instance of `UITableViewCell()`. If no reuse identifier
    is set, we'll add one to our cell (we've called ours `table.view.cell`, but you
    can call it anything you want). Then, using the current index of the cell being
    called, we obtain the text from our quotes array.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们简单地创建一个 `UITableViewCell()` 的实例。如果没有设置重用标识符，我们将为我们的单元格添加一个（我们称之为 `table.view.cell`，但你可以称它为任何你想要的）。然后，使用正在调用的单元格的当前索引，我们从引用数组中获取文本。
- en: 'Finally, we need to assign `TableViewContoller` to our Live view:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要将 `TableViewContoller` 分配给我们的 Live 视图：
- en: '[PRE35]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Press Run My Code and you should see the following:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下“运行我的代码”并你应该看到以下内容：
- en: '![](img/0474ab16-5dc9-44e2-ad2f-e80ec4dcc0b1.png)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0474ab16-5dc9-44e2-ad2f-e80ec4dcc0b1.png)'
- en: Figure 7.20 – Results live view
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.20 – 结果实时视图
- en: Whether your using Playground on the iPad or via the Mac App Store, it goes
    without saying that it's certainly a powerful alternative to Xcode.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是在 iPad 上使用 Playground 还是通过 Mac App Store，它当然是一个比 Xcode 更强大的替代品。
- en: How it works...
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Swift Playgrounds has some powerful features, and especially if you're used
    to using Xcode, you'll immediately start to make a comparison (I know I did).
    But taking a step back and seeing how it all wonderfully knits together certainly
    opened my eyes to not only writing code but developing on an iPad.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: Swift Playgrounds 有一些强大的功能，特别是如果你习惯使用 Xcode，你将立即开始进行比较（我知道我就是这样）。但退一步，看到这一切是如何美妙地交织在一起，确实让我对不仅编写代码，还在
    iPad 上进行开发有了新的认识。
- en: 'Let''s take a look at the code completion. Normally with Xcode, we''ll expect
    this to show up when we''re typing away, in a small dialog/table next to our text,
    but with Swift Playgrounds on iPadOS, we get this in the form of a horizontal
    scroll bar at the bottom of the screen:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看代码补全。通常，在 Xcode 中，我们期望它在我们在输入时显示，在我们文本旁边的小对话框/表格中，但使用 iPadOS 上的 Swift Playgrounds，我们在屏幕底部得到一个水平滚动条的形式：
- en: '![](img/44568049-8fcc-4144-90a9-8d82003a2d7f.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/44568049-8fcc-4144-90a9-8d82003a2d7f.jpeg)'
- en: Figure 7.21 – Syntax suggestions
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.21 – 语法建议
- en: Here, we can see an example of code completion on `UITableView`. Notice that
    immediately we're given multiple options that refer to just UITableViews. Go ahead
    and re-implement the delegate you did earlier, and you will then see another show
    up in the suggestions as you start to type `numberOf` – it just works.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们可以看到一个在`UITableView`上的代码补全示例。注意，我们立即得到了多个仅针对UITableView的选项。继续重新实现您之前所做的代理，然后您会在开始输入`numberOf`时看到另一个建议出现
    – 它就是那么简单。
- en: 'Another thing to note is compiler errors, displayed in a similar way to how
    Xcode does it (although more in line with your code in the editor). The following
    red symbol with a description of your error will be presented when running your
    code. Tapping on the button will collapse the error, allowing you to inspect your
    code in a little more detail:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是编译错误，其显示方式与Xcode类似（尽管更符合编辑器中的代码）。当运行您的代码时，将显示以下带有错误描述的红色符号。点击按钮将折叠错误，让您可以更详细地检查您的代码：
- en: '![](img/9e2c5a79-418d-401c-874d-707eb8dc6ed0.jpeg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e2c5a79-418d-401c-874d-707eb8dc6ed0.jpeg)'
- en: Figure 7.22 – Error inspection
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.22 – 错误检查
- en: 'Alternatively, if you have a number of errors, then you can simply click on
    the red icon to the left of the + icon in the menu bar to display a list of current
    errors:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果您有很多错误，您可以直接点击菜单栏中+图标左侧的红色图标来显示当前错误列表：
- en: '![](img/4dc3ee08-c202-44a4-afea-d96bccf41625.jpeg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4dc3ee08-c202-44a4-afea-d96bccf41625.jpeg)'
- en: Figure 7.23 – Error indicator
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.23 – 错误指示器
- en: 'With this in mind, the compiler may not always give you errors and you may
    be forced to "step through" your code in order to find out what exactly is going
    on in your logic. If we refer back to the *How to do it...* section, you''ll remember
    that we needed to add the following line of code to make our function work:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个前提，编译器可能并不总是给您错误提示，您可能被迫“逐步执行”您的代码，以找出您的逻辑中究竟发生了什么。如果我们回顾一下*如何做…*部分，您会记得我们需要添加以下代码行来使我们的函数正常工作：
- en: '[PRE36]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This was due to our playground finishing its execution before our API had returned
    the call. Let's comment this out for the moment and run our code and you will
    notice that it never displays our list of quotes, but we want to see what is happening.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的沙盒在API返回调用之前就完成了执行。让我们暂时注释掉这一行，然后运行我们的代码，您会注意到它从未显示我们的引用列表，但我们想看看发生了什么。
- en: 'To the left of the Run My Code button is a timer icon. Tap on this to see the
    following options:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在“运行我的代码”按钮的左侧有一个计时器图标。点击这个图标可以看到以下选项：
- en: '![](img/5c61087e-06f9-4c53-8261-6ebd7ec40d27.png)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5c61087e-06f9-4c53-8261-6ebd7ec40d27.png)'
- en: Figure 7.24 – Running my code options
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.24 – 运行我的代码选项
- en: '**Run My Code** is highlighted by default, but two additional options exist
    – **Step Through My Code** and **Step Slowly**. What these do (essentially the
    same thing, although one does it more slowly than the other) is highlight each
    line of code as it is executed, or intended to be executed, allowing you to follow
    and check any potential logic issues. For those who are already familiar with
    Xcode''s IDE, this is common practice for debugging.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行我的代码**默认高亮显示，但还有两个额外的选项 – **逐步执行我的代码**和**慢速执行**。这些选项的作用（本质上是一样的，尽管一个执行得比另一个慢）是在代码执行或打算执行时突出显示每一行代码，让您可以跟踪并检查任何潜在的逻辑问题。对于已经熟悉Xcode
    IDE的人来说，这是调试的常见做法。'
- en: Tap on one of these two options with the preceding code commented out and you'll
    see that our code never finishes (because the main, synchronous function finished
    before the completion handler fired). If you try this a few times, you'll notice
    that it does occasionally stop at different points inside the completion. Uncomment
    the line and watch it step through right to the end.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 点击这两个选项之一，并注释掉前面的代码，您会看到我们的代码永远不会结束（因为主同步函数在完成处理程序触发之前就结束了）。如果您尝试几次，您会注意到它偶尔会在完成处理程序的不同点停止。取消注释这一行，然后观察它如何逐步执行到结束。
- en: 'Another thing to note is the object menu to the top right. Pressing on the
    plus button provides a plethora of code snippets to choose from, while you can
    also import images into an asset like a catalog, allowing you to reference image
    literals just like you can in Xcode:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是右上角的对象菜单。按下加号按钮会提供一大堆代码片段供您选择，同时您还可以将图片导入到类似目录的资产中，这样您就可以像在Xcode中一样引用图像文字：
- en: '![](img/d13fa924-6cdd-48a8-afd6-9f150121f4a4.jpeg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d13fa924-6cdd-48a8-afd6-9f150121f4a4.jpeg)'
- en: Figure 7.25 – Layout result
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.25 – 布局结果
- en: Finally, I'd like to touch on the file inspector again over on the left-hand
    side. If you open this up again, you'll see an Edit button, which, in turn, does
    what it says on the tin. It lets you edit, rename, and re-order Swift files for
    your project and module.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我想再次提及左侧的文件检查器。如果您再次打开它，您会看到一个编辑按钮，它实际上就是它所说的那样。它允许您编辑、重命名和重新排序项目中的模块的Swift文件。
- en: As mentioned earlier in this recipe, Swift Playgrounds is designed for both
    iPadOS and macOS, with both working in identical ways, and you should be able
    to follow this recipe perfectly on both (hint, I wrote half of this recipe on
    the iPad and the other on the Mac version just to test it out!).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，Swift Playgrounds是为iPadOS和macOS设计的，两者以相同的方式工作，您应该能够在两者上完美地遵循这个食谱（提示，我一半的食谱是在iPad上写的，另一半是在Mac版本上写的，只是为了测试它！）。
- en: There's more
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多
- en: 'One final section worth going over is the Tools section. Click on the three
    dots to the right of the **+** icon in the top-right corner. You should now be
    presented with the following:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，最后一个部分是工具部分。点击右上角**+**图标右侧的三个点。现在您应该会看到以下内容：
- en: '![](img/3b1ec6b2-f46b-46b3-bccf-f89daa373fa9.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3b1ec6b2-f46b-46b3-bccf-f89daa373fa9.jpeg)'
- en: Figure 7.26 – Playground options
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.26 – 操场选项
- en: 'We will go through each of these individually or collectively:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一或集体地过一遍这些内容：
- en: '**Playgrounds Help / Documentation**'
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Playgrounds帮助 / 文档**'
- en: As you would expect, Help is focused around the App/IDE and interface giving
    you an overview of what is available, while Documentation is Apple-specific API
    documentation.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所预期，帮助功能集中在应用程序/IDE和界面上，为您提供可用性的概述，而文档则是苹果特定的API文档。
- en: '**Take Picture / Create PDF**'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**拍照 / 创建PDF**'
- en: These options share a screenshot or PDF of the canvas in its current state.
    Other standard iPadOS sharing options are also available.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项共享画布当前状态的截图或PDF。其他标准的iPadOS共享选项也可用。
- en: '**Record Movie / Broadcast Live**'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**录制电影 / 直播广播**'
- en: Record Movie starts a "screen recorder"-like scenario with stop and record controls
    that appear at the top of your screen. Broadcasting alternatively hooks into third-party
    apps that can be found on the Apple App Store that support broadcasting.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 录制电影开始一个类似于“屏幕录制”的场景，带有出现在屏幕顶部的停止和录制控制。广播选项可以连接到在Apple App Store上可以找到的第三方应用程序，这些应用程序支持广播。
- en: '**Share / Advanced**'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分享 / 高级**'
- en: Share initiates the default iPadOS share sheet for the option to share your
    current playbook.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 分享将启动默认的iPadOS共享表单，以便分享您当前的操作剧本。
- en: Advanced gives you two options, one to export your playbook, and the second
    to take a more in-depth look at your current playbook's hierarchy.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 高级选项提供两个选项，一个是导出您的操作剧本，另一个是更深入地查看您当前操作剧本的层次结构。
- en: '**License agreements**'
  id: totrans-300
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**许可协议**'
- en: This is nothing to write home about, just your usual software license agreement
    information.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 这没有什么值得大书特书的，只是您通常的软件许可协议信息。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Apple''s Swift Playgrounds page**: [https://www.apple.com/swift/playgrounds/](https://www.apple.com/swift/playgrounds/)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**苹果的Swift Playgrounds页面**：[https://www.apple.com/swift/playgrounds/](https://www.apple.com/swift/playgrounds/)'
