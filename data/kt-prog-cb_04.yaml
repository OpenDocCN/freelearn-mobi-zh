- en: Functions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数
- en: 'The following recipes will be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下内容：
- en: Specifying default values in functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中指定默认值
- en: Using named arguments in functions
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在函数中使用命名参数
- en: Creating the `RecyclerView` Adapter in Kotlin
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建 `RecyclerView` 适配器
- en: Creating getter setters in Kotlin
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建 getter setters
- en: Passing variable arguments to a function
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将可变参数传递给函数
- en: Passing a function as a parameter to another
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个函数
- en: Declaring a `static` function
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明一个 `static` 函数
- en: Using the `use` keyword in Kotlin
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用 `use` 关键字
- en: Working with Closure in Kotlin
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用闭包
- en: Function literals with receivers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带接收者的函数字面量
- en: Working with anonymous functions
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用匿名函数
- en: Introduction
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Functions are the building blocks of any code. They help make our programs more
    modular, secure, and easy to understand. Functions are crucial in object-oriented
    programming as they play an important role in abstraction and encapsulation (two
    very important design principles). Kotlin brings a lot of updates to the way we
    use functions. It makes functional programming easier with the help of chaining
    and lambdas. In this chapter, we will learn recipes that will help us work with
    functions. So let's get started!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是任何代码的构建块。它们帮助我们使程序更加模块化、安全且易于理解。函数在面向对象编程中至关重要，因为它们在抽象和封装（两个非常重要的设计原则）中扮演着重要角色。Kotlin
    通过链式和 lambda 表达式的方式，为我们的函数使用方式带来了许多更新。它使函数式编程变得更加容易。在本章中，我们将学习一些有助于我们处理函数的技巧。那么，让我们开始吧！
- en: Specifying default values in functions
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中指定默认值
- en: 'If you come from the Java world, you might remember that we can''t specify
    a default value to methods. This means that we can''t do something like this in
    Java:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你来自 Java 世界，你可能记得我们无法为方法指定默认值。这意味着我们无法在 Java 中这样做：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We need to write two methods for it, and it is known as *method overloading:*
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为它编写两个方法，这被称为 *方法过载*：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Also, suppose you have a function with three different kinds of parameters,
    such as these:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，假设你有一个具有三种不同类型参数的函数，例如这些：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then you''ll have seven instances of method overloading:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你将拥有七个方法过载的实例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Kotlin provides you with default values in the methods by which you can prevent
    an insane amount of method overloading. Some people might say, "Hey, why don't
    we use the builder pattern instead of method overloading?". Those people are right,
    but Kotlin's way is easier than that. Let's see how!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 通过提供默认值的方法为你提供，这样你可以防止方法过载的数量变得疯狂。有些人可能会说：“嘿，我们为什么不使用构建器模式而不是方法过载呢？”这些人是对的，但
    Kotlin 的方法比这更容易。让我们看看吧！
- en: Getting ready
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和执行我们的代码。你可以使用你感到舒适的任何开发环境。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In Kotlin, parameters of functions can have default values, and they are used
    when the corresponding argument is omitted. This, in turn, reduces the number
    of overloads. The preceding example with three different types of parameters can
    be resolved easily in Kotlin with a lot less code:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，函数的参数可以有默认值，并且当省略相应的参数时，它们会被使用。这反过来又减少了过载的数量。前面的例子中，具有三种不同类型的参数可以在
    Kotlin 中轻松解决，代码量也少得多：
- en: 'Let''s add the mentioned code in the editor, run it, and check the output:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在编辑器中添加提到的代码，运行它，并检查输出：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If you run the preceding code, you will see the following output:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，你会看到以下输出：
- en: '[PRE5]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, we didn't have to implement four different methods, and we could
    map the arguments. The default parameters are used when we don't call the methods
    by providing explicit parameters, so when you don't pass any parameters, it just
    uses all the default ones. With the help of named arguments, we can decrease the
    number of methods even further, but we will cover this in the next recipe.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如你所见，我们不必实现四个不同的方法，我们可以映射参数。当不通过提供显式参数来调用方法时，会使用默认参数，所以当你不传递任何参数时，它就使用所有默认参数。借助命名参数，我们可以进一步减少方法的数量，但我们将在这下一个技巧中介绍。
- en: 'One thing to note is that default arguments will also work with constructors.
    So you can have a class declaration as follows:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要注意的一件事是，默认参数也会与构造函数一起工作。所以你可以有一个如下所示的类声明：
- en: '[PRE6]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: To learn more about a data class, head on to the [Chapter 11](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e1822868-fcb7-4623-8727-eb961254acdf.xhtml), *How
    to create data class recipe.*
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于数据类的信息，请前往[第11章](https://www.safaribooksonline.com/library/view/kotlin-programming-cookbook/9781788472142/e1822868-fcb7-4623-8727-eb961254acdf.xhtml)，*如何创建数据类食谱*。
- en: 'Then we can declare objects, as shown:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们可以声明对象，如下所示：
- en: '[PRE7]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As you can see, with the help of default values in the constructors, we are
    avoiding the need to implement multiple constructors, which we used to do in Java.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，借助构造函数中的默认值，我们避免了实现多个构造函数的需要，这是我们以前在Java中经常做的。
- en: 'Remember that there is a catch here. We won''t be able to do this if you are
    creating objects in Java. This means that doing things as shown in the following
    code will not be accepted by Java. Now I know you''ll be like "What happened to
    100% interoperability with Java ?!":'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，这里有一个陷阱。如果你在Java中创建对象，我们将无法这样做。这意味着以下代码所示的操作将不会被Java接受。现在我知道你会想“Java的100%互操作性去哪了？！”：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We just need to do a small modification if we want to expose multiple overloads
    to Java callers, that is—namely adding `@JvmOverloads` to the constructors and
    functions with default values so that the preceding class declaration becomes
    this:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们想要向Java调用者公开多个重载，我们只需要进行一个小修改，即——即在具有默认值的构造函数和函数上添加`@JvmOverloads`，这样前面的类声明就变成了这样：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Also, our method becomes this:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们的方法也变成了这样：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is a small price to pay, but the `@JvmOverloads` annotation helps our constructors
    and functions to have default values, called from the Java world too.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一点小小的代价，但`@JvmOverloads`注解帮助我们的构造函数和函数在Java世界中也能有默认值。
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If we want our code to work only in the Kotlin world, then we don't need the
    `@JvmOverloads` annotation because Kotlin has its own rules by which it can work
    with default values in constructors and functions. Adding the `@JvmOverloads`
    annotation creates all the necessary overloads. So if you decompile your Kotlin
    bytecode, you will see all the overloaded versions of constructors and functions.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想让我们的代码只在Kotlin世界中工作，那么我们不需要`@JvmOverloads`注解，因为Kotlin有自己的规则，可以通过这些规则在构造函数和函数中使用默认值。添加`@JvmOverloads`注解会创建所有必要的重载。所以如果你反编译Kotlin的字节码，你会看到构造函数和函数的所有重载版本。
- en: Using named arguments in functions
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在函数中使用命名参数
- en: This recipe can be thought of as an extension to the previous recipe, *Specifying
    default values in functions*. Default parameters and named arguments in the function
    together can bring down the number of method overloads by a huge amount. We've
    already seen how to use default parameters in functions; now, let's see how to
    use name arguments.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱可以被视为对之前食谱的扩展，*在函数中指定默认值*。函数中的默认参数和命名参数一起可以大幅减少方法重载的数量。我们已经看到了如何在函数中使用默认参数；现在，让我们看看如何使用命名参数。
- en: Getting ready
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用IntelliJ IDEA来编写和执行我们的代码。你可以使用你感到舒适的任何开发环境。
- en: How to do it...
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Another step forward to reduce the number of overloads and increase code readability
    is to use named arguments. Let''s take look at the following code:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了减少重载数量并提高代码的可读性，我们还可以使用命名参数。让我们看看以下代码：
- en: 'Taking the same example of the `foo` function, here''s how we can use named
    arguments:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以`foo`函数的相同示例，以下是我们可以如何使用命名参数：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is the output that you will get by running the preceding code:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行上述代码将得到以下输出：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The named arguments prevent us from overloads and also make our code much more
    readable. Also, we don''t need to put in all the arguments. What I mean is, if
    you just had two parameters—`a` and `c`—then you would have to do something like
    this:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 命名参数防止我们出现重载，并且使我们的代码更加易于阅读。此外，我们不需要输入所有参数。我的意思是，如果你只有两个参数——`a`和`c`——那么你可能需要这样做：
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You have to add a default value to fill the space between `a` and `c`. However,
    with named arguments, you are able to use `foo(a=1,c="Custom string")` without
    needing default arguments in between.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你必须添加一个默认值来填充`a`和`c`之间的空间。然而，使用命名参数，你能够使用`foo(a=1,c="Custom string")`而无需在中间添加默认参数。
- en: One key thing to note is that when we call a function with both positional and
    named arguments, we need to place the positional arguments before the first named
    one. For example, the `foo(1,b = 0.1)` call is allowed, but `foo(a = 1, 0.1)`
    is not.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个需要注意的关键点是，当我们调用一个同时带有位置参数和命名参数的函数时，我们需要将位置参数放在第一个命名参数之前。例如，`foo(1,b = 0.1)`
    调用是允许的，但 `foo(a = 1, 0.1)` 是不允许的。
- en: The default values and named arguments can bring down the number of overloads
    needed to a minimum, making the code size small and improving the code's readability.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 默认值和命名参数可以将所需的函数重载数量降到最低，使代码量小，并提高代码的可读性。
- en: Creating the RecyclerView Adapter in Kotlin
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建 RecyclerView 适配器
- en: '`RecyclerView` is among the most widely used elements in Android development.
    It is essentially used to display data in a list using an adapter. In this recipe,
    we will learn how to leverage great things in Kotlin to make `RecyclerView` much
    more efficient. We will also be using `DiffUtils`. It is available from 24.02\.
    According to the documentation:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`RecyclerView` 是 Android 开发中最广泛使用的元素之一。它本质上用于通过适配器显示列表中的数据。在这个菜谱中，我们将学习如何利用
    Kotlin 的强大功能使 `RecyclerView` 更加高效。我们还将使用 `DiffUtils`。它从 24.02 开始可用。根据文档：'
- en: DiffUtil is a utility class that can calculate the difference between two lists
    and output a list of update operations that converts the first list into the second
    one.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: DiffUtil 是一个实用类，可以计算两个列表之间的差异，并输出一个更新操作列表，将第一个列表转换为第二个列表。
- en: The definition is self-explainatory. The `notifyDatasetChanged`is a very expensive
    operation of the adapter. The `DiffUtils` only updates the parts that were changed,
    unlike `notifyDatasetChanged`, which updates the whole list.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 定义是自我解释的。`notifyDatasetChanged` 是适配器的一个非常昂贵的操作。`DiffUtils` 只更新已更改的部分，而 `notifyDatasetChanged`
    则更新整个列表。
- en: Getting ready
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Android project in Android Studio. You can also clone the [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook) repository and
    check out the 1-recycler-view-in-kotlin branch.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的 Android 项目。您也可以克隆 [https://gitlab.com/aanandshekharroy/kotlin-cookbook](https://gitlab.com/aanandshekharroy/kotlin-cookbook)
    仓库并检出 1-recycler-view-in-kotlin 分支。
- en: 'In this app, we will be creating a simple list of different Android flavors
    released by Google, something like what''s seen here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们将创建一个简单的列表，列出 Google 发布的不同 Android 风味，类似于这里所看到的：
- en: '![](img/b54683bd-ccf2-4456-94b3-81583e451185.jpeg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b54683bd-ccf2-4456-94b3-81583e451185.jpeg)'
- en: As you can see, there is a floating action button; clicking it will update the
    order of the list. We will be updating the list (`RecyclerView`), but we will
    update it using `DiffUtils` instead of the `notifyDatasetChanged` method.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有一个浮动操作按钮；点击它将更新列表的顺序。我们将更新列表（`RecyclerView`），但我们将使用 `DiffUtils` 而不是 `notifyDatasetChanged`
    方法来更新它。
- en: How to do it...
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'So, let''s now follow these steps to create the app we just discussed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们按照以下步骤创建我们刚才讨论的应用：
- en: 'First, we need to create a list of Android flavors. So, we will first create
    a data class that takes in image and name of flavor:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个 Android 风味的列表。因此，我们将首先创建一个数据类，它包含图像和风味的名称：
- en: '[PRE14]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We have defined the type of image as `Int` because we will be using the IDs
    of drawable items. In the `drawable` folder, we will be keeping all the required
    images.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将图像类型定义为 `Int`，因为我们将会使用可绘制项的 ID。在 `drawable` 文件夹中，我们将保存所有必需的图像。
- en: 'Next, we will create a list of Android flavors:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个 Android 风味的列表：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we will create an adapter. We will name it `AndroidFlavourAdapter`:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个适配器。我们将命名为 `AndroidFlavourAdapter`：
- en: '[PRE16]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The preceding code is quite standard for the general implementation of `RecyclerView`,
    except for the two things.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码对于 `RecyclerView` 的一般实现来说相当标准，除了两点。
- en: 'One of these is the `loadImage` function, which is not a native function but
    an extension function, whose implementation is this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中之一是 `loadImage` 函数，它不是一个原生函数，而是一个扩展函数，其实现如下：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Another thing is that we have defined the list of `AndroidFlavours` in the
    adapters. The `flavoursList` in the adapter is an `observable` property. This
    means the listener gets notified of changes to this property. Hence, we get the
    following construct:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一件事是我们已经在适配器中定义了 `AndroidFlavours` 的列表。适配器中的 `flavoursList` 是一个 `observable`
    属性。这意味着监听器会通知此属性的变化。因此，我们得到以下结构：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, whenever we try to assign a value to the `flavourItems` variable, the
    construct under the `{ .. }` block is run, and we have old and new values to do
    an operation if we want. In this case, we will do it using the `notifyChanges` method.
    Let''s look at the `notifyChanges` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，每次我们尝试为 `flavourItems` 变量赋值时，`{ .. }` 块下的构造就会运行，如果我们想进行操作，我们将有旧值和新值。在这种情况下，我们将使用
    `notifyChanges` 方法。让我们看看 `notifyChanges` 方法：
- en: '[PRE19]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I will explain the preceding code in the next section.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我将在下一节解释前面的代码。
- en: 'Now, let''s set up the adapter:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们设置适配器：
- en: '[PRE20]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `shuffle` function will just randomize the order of the list of `AndroidFlavours`.
    The `.shuffle()` function is not a native function provided by Kotlin or Java, but
    an extension function:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`shuffle` 函数将随机化 `AndroidFlavours` 列表的顺序。`.shuffle()` 函数不是 Kotlin 或 Java 提供的本地函数，而是一个扩展函数：'
- en: '[PRE21]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Let's dive into the `DiffUtils`. The `DiffUtils` requires two arrays/lists,
    one of which should be the old list and the other should be the new list.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解 `DiffUtils`。`DiffUtils` 需要两个数组/列表，其中一个应该是旧列表，另一个应该是新列表。
- en: 'There are five main functions:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有五个主要函数：
- en: '`getNewListSize()`: This returns the size of the new list.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getNewListSize()`: 这个方法返回新列表的大小。'
- en: '`getOldListSize()`: This method returns the size of the old list.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getOldListSize()`: 这个方法返回旧列表的大小。'
- en: '`areItemsTheSame()`: This method is used to determine whether two objects represent
    the same item.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`areItemsTheSame()`: 这个方法用于确定两个对象是否表示相同的项。'
- en: '`areContentsTheSame()`: This method is used to determine whether the two objects
    contain the same data. In our implementation, we are returning true if both objects
    have the same name and image.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`areContentsTheSame()`: 这个方法用于确定两个对象是否包含相同的数据。在我们的实现中，如果两个对象都有相同的名称和图像，我们返回
    true。'
- en: '`getChangePayload()`: When `areItemsTheSame()` returns true and `areContentsTheSame()`
    returns false, then `DiffUtils` calls this method to get the payload of changes.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getChangePayload()`: 当 `areItemsTheSame()` 返回 true 且 `areContentsTheSame()`
    返回 false 时，`DiffUtils` 调用此方法以获取更改的有效载荷。'
- en: 'In our implementation of the preceding method, we are adding the change of
    name and image in the payload:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们实现前面的方法中，我们在有效载荷中添加了名称和图像的更改：
- en: '[PRE22]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, after the diff calculation, the `DiffUtils` object dispatches the
    changes to the Adapter. To do that, we call the `dispatchUpdatesTo` method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在差异计算之后，`DiffUtils` 对象将更改派发到适配器。为此，我们调用 `dispatchUpdatesTo` 方法：
- en: '[PRE23]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To update the changes from the data in the payload, you need to override `onBindViewHolder` *(*`holder:
    FlavourViewHolder`*,* `position: Int`*,* `payloads: MutableList<Any>?`):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '要更新来自有效载荷中的数据的更改，你需要重写 `onBindViewHolder` (*`holder: FlavourViewHolder`*, `position:
    Int`*, `payloads: MutableList<Any>?`):'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The changes in the payload are dispatched using the `notifyItemRangeChanged` method
    of the adapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 使用适配器的 `notifyItemRangeChanged` 方法将有效载荷中的更改派发。
- en: There's more...
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The documentation states that the `DiffUtils` might take some time to process
    the diff between two lists if the lists are too big, so this must be calculated
    on a background thread, for example, using `RxJava`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 文档指出，如果列表太大，`DiffUtils` 可能需要一些时间来处理两个列表之间的差异，因此这必须在后台线程上计算，例如，使用 `RxJava`。
- en: Creating getter setters in Kotlin
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中创建 getter-setters
- en: If you have worked with Java, you probably know what a *getter-setter* is. Java
    has fields and getter-setters are the methods that are used to **access **(getter)
    and **modify **(setter) member variables. They are an essential part of encapsulation
    (one of the design principles).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你曾经使用过 Java，你可能知道什么是 *getter-setter*。Java 有字段，getter-setters 是用于 **访问**（getter）和
    **修改**（setter）成员变量的方法。它们是封装（设计原则之一）的必要部分。
- en: However, in Kotlin, we don't have any fields, but we have **properties** instead.
    A property can have a custom implementation of an **accessor** and a **mutator.**
    In this recipe, we will see how we can implement custom accessors and mutators.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 Kotlin 中，我们没有字段，而是有 **属性**。属性可以有自定义的访问器和修改器实现。在这个菜谱中，我们将看到我们如何实现自定义访问器和修改器。
- en: Getting ready
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with. We will be using examples to
    understand the custom getter-setters of Kotlin.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和执行我们的代码。你可以使用你感到舒适的任何开发环境。我们将使用示例来理解 Kotlin 的自定义 getter-setters。
- en: How to do it...
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Let''s follow these steps to understand how custom getter-setters work in Kotlin:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解 Kotlin 中自定义 getter-setters 的工作原理：
- en: 'The syntax of a Kotlin `property` looks like this:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Kotlin `property`的语法如下：
- en: '[PRE25]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: So if you use something like `val a =1`, you get a default `getter` and `setter`.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 所以如果您使用`val a =1`，您将获得默认的`getter`和`setter`。
- en: 'Now, let''s see how we can create a custom `getter`. Suppose we have a property
    whose value depends on another property:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何创建一个自定义的`getter`。假设我们有一个属性，其值依赖于另一个属性：
- en: '[PRE26]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you run the preceding code, you''ll see the output in the console as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，您将在控制台看到以下输出：
- en: '![](img/03cb3100-9ee4-4b7d-8892-2d2cc59edbf2.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/03cb3100-9ee4-4b7d-8892-2d2cc59edbf2.png)'
- en: 'As you can see, we can modify the getter in the `get` method of the property.
    If the property type is inferred from the getter, we can also do this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，我们可以修改属性的`get`方法中的getter。如果属性类型是从getter推断出来的，我们也可以这样做：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The result will be the same, of course.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果当然是一样的。
- en: 'Now, let''s take a look at accessors:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看访问器：
- en: 'In Java, we used to do something like the following:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Java中，我们通常做如下操作：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'If we try to pull this off in Kotlin, it will look something like this:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试在Kotlin中实现这一点，它将类似于以下这样：
- en: '![](img/dce9a56d-ffa5-4a0d-9573-69d304ed95b6.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dce9a56d-ffa5-4a0d-9573-69d304ed95b6.png)'
- en: As you can see, we will get a warning from IDE suggesting that it is a recursive
    call. Why? Because when you are trying to set a value using`.isListBig`, you are
    already using a setter inside a setter, hence the **recursive cycle**.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所见，IDE会提示我们这是一个递归调用。为什么？因为当您尝试使用`.isListBig`设置值时，您已经在设置器内部使用了设置器，因此形成了**递归循环**。
- en: 'In order to get away from this recursive call and still implement a setter,
    you need the `field` keyword. So the preceding implementation will look something
    like this:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免递归调用并仍然实现setter，您需要使用`field`关键字。因此，前面的实现将类似于以下这样：
- en: '[PRE29]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When you initialize `isListBig` while declaring the property, the value is assigned
    to the backing field without invoking the setter. The `field` keyword is used
    to access the backing field, and it will be generated for a property if it uses
    the default implementation of at least one of the accessors, or if a custom accessor
    references it through the `field` identifier.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您在声明属性时初始化`isListBig`，值将分配给后端字段，而不调用setter。`field`关键字用于访问后端字段，如果属性至少使用了一个访问器的默认实现，或者如果自定义访问器通过`field`标识符引用它，则会生成该字段。
- en: 'If you want to restrict the access of your setter, you can do so with the following:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您想限制setter的访问权限，您可以使用以下方式：
- en: '[PRE30]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Also, suppose you are using some sort of dependency injection. You can do it
    with this:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，假设您正在使用某种形式的依赖注入。您可以使用以下方式实现：
- en: '[PRE31]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Similar to `set`, you can also have a custom implementation of `get`.  Let''s
    look at an example:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 与`set`类似，您也可以为`get`实现自定义实现。让我们看一个例子：
- en: '[PRE32]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, let''s say that we are trying to access the `name` property:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们假设我们正在尝试访问`name`属性：
- en: '[PRE33]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If you run the preceding code, you''ll see this output:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，您将看到以下输出：
- en: '![](img/60f65486-b3f3-440f-aca3-691f96c2f84f.png)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60f65486-b3f3-440f-aca3-691f96c2f84f.png)'
- en: Note that we have used `field` in the `get()` method too. It's the same backing
    field that we explained earlier.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在`get()`方法中也使用了`field`。它是我们之前解释过的同一个后端字段。
- en: There's more...
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'One thing to note here is that you cannot implement a custom getter or setter
    for your property in the constructor. You need to declare a property in the body
    of the class:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，您不能在构造函数中为您的属性实现自定义的getter或setter。您需要在类的主体中声明属性：
- en: '[PRE34]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One key thing to note here is that you need to keep the visibility of the getter
    exactly similar to the visibility of the property:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一个关键点是，您需要保持getter的可见性与属性的可见性完全相同：
- en: '[PRE35]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The preceding code is perfectly valid, though it's redundant to place the same
    access modifier again, hence it's better to omit it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是完全有效的，尽管再次放置相同的访问修饰符是多余的，因此最好省略它。
- en: 'The setter, on the other hand, can have an access modifier less permissive
    than the property. Consider this example:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，setter可以有一个比属性权限低的访问修饰符。考虑以下示例：
- en: '[PRE36]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The preceding code is valid because the access modifier of the setter, `private`,
    is less permissive than the property''s access modifier:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码是有效的，因为setter的访问修饰符`private`比属性的访问修饰符权限低：
- en: '[PRE37]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The preceding code, however, is not valid, as `protected` is less permissive
    than `public`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，前面的代码是无效的，因为`protected`的权限比`public`低。
- en: Passing variable arguments to a function
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将可变参数传递给函数
- en: There are a lot of scenarios in which we need to pass variable arguments to
    a function. In Kotlin, we can do that using the `vararg` modifier. In this recipe,
    we will go through all the ways of doing that. We will look at a few examples
    to demonstrate how to use this feature of Kotlin.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多场景中，我们需要将可变参数传递给函数。在 Kotlin 中，我们可以使用 `vararg` 修饰符来实现这一点。在本菜谱中，我们将介绍所有实现方法。我们将通过一些示例来展示如何使用
    Kotlin 的这一特性。
- en: Getting ready
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install the preferred development environment that compiles and
    runs Kotlin. You can also use the command line for this purpose, for which you
    need Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for your development environment.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此任务，为此您需要安装 Kotlin 编译器和 JDK。我正在使用在线
    IDE [https://try.kotlinlang.org/](https://try.kotlinlang.org/) 来编译和运行我的 Kotlin
    代码，以完成本菜谱。您也可以使用 IntelliJ IDEA 作为您的开发环境。
- en: How to do it...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s go through the following steps, where we demonstrate how to pass a variable
    number of arguments to a function:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过以下步骤来了解，我们将演示如何将可变数量的参数传递给函数：
- en: 'Using `vararg`, we can pass comma-separated arguments to a function, where
    we have defined the single argument to a method as `vararg`, as in the following
    example:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `vararg`，我们可以将逗号分隔的参数传递给一个函数，其中我们已将方法中的单个参数定义为 `vararg`，如下例所示：
- en: '[PRE38]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Also, if you already have an array of values, you can directly pass it using
    the `*` spread operator:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果您已经有一个值数组，您可以直接使用 `*` 展开操作符传递它：
- en: '[PRE39]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: So basically, `vararg` tells the compiler to take the passed arguments and wrap
    them into an array.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，`vararg` 告诉编译器将传递的参数包装成一个数组。
- en: The spread operator, on the other hand, simply tells the compiler to unwrap
    array members and pass them as separate arguments. The spread operator—that is, `*`–is
    put just before the name of the array being passed in.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一方面，展开操作符简单地告诉编译器展开数组成员并将它们作为单独的参数传递。展开操作符——即 `*`——被放置在传递的数组名称之前。
- en: However, obviously one may always need to pass other arguments, named arguments,
    and so on.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，显然有时可能需要传递其他参数，如命名参数等。
- en: 'In the following example code, we try to pass another argument other than `vararg`:'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我们尝试传递除了 `vararg` 之外的另一个参数：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'In the next example, the first argument is similar to the `vararg` type, but
    it works:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个示例中，第一个参数类似于 `vararg` 类型，但它可以工作：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'So usually, `vararg` is the last argument passed, but what if we want to pass
    other arguments after `vararg`? We can, but they have to be named. That is why
    the following code will not compile:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，通常 `vararg` 是最后一个传递的参数，但如果我们想在 `vararg` 之后传递其他参数怎么办？我们可以这样做，但它们必须被命名。这就是为什么以下代码无法编译的原因：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: It does not compile because the last string passed in it is considered part
    of `vararg`, and the compiler throws an error because we did not pass the value
    of `c`.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这段代码无法编译，因为最后传入的字符串被认为是 `vararg` 的一部分，并且编译器抛出错误，因为我们没有传递 `c` 的值。
- en: 'To do it correctly, we need to pass `c` as a named argument, just as shown
    here:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要正确实现，我们需要将 `c` 作为命名参数传递，就像这里所示：
- en: '[PRE44]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output is as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '[PRE45]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: How it works...
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `vararg` modifier tells the compiler to take all comma-separated arguments
    and wrap them into an array, while `*`—that is the spread operator—unwraps elements
    of the array and passes them as arguments.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`vararg` 修饰符告诉编译器将所有以逗号分隔的参数包装成一个数组，而 `*`（即展开操作符）则展开数组元素并将它们作为参数传递。'
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if we want the first argument to have a default value, like in this example:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们希望第一个参数有一个默认值，就像这个例子一样：
- en: '[PRE46]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'We want all arguments to be considered as part of `vararg`, but the compiler
    reads the first argument as `b`. In this case, naming the passed arguments can
    solve the problem:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望所有参数都被视为 `vararg` 的一部分，但编译器将第一个参数读取为 `b`。在这种情况下，命名传递的参数可以解决这个问题：
- en: '[PRE47]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the preceding code, the compiler understands that the value of `b` is not
    passed, and it takes the default value. Similarly, if you want to have two `vararg`
    in your function, you will need to pass named arguments.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，编译器理解到 `b` 的值没有被传递，并采用了默认值。同样，如果您想在函数中拥有两个 `vararg`，您将需要传递命名参数。
- en: Passing a function as a parameter to another
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将函数作为参数传递给另一个
- en: Kotlin gives us the power to declare *high-order functions*. In a high-order
    function, we can pass and return functions as parameters. This is an extremely
    useful feature and makes our code much more easy to work with. In fact, many of
    the Kotlin library’s functions are high order, such as `map`. In Kotlin, we can
    declare functions and function references as values that are then passed in to
    the function. In this section, we will first understand how to declare lambdas
    and then how to pass them into a function.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin赋予我们声明*高阶函数*的能力。在高阶函数中，我们可以将函数作为参数传递和返回。这是一个极其有用的特性，使得我们的代码更容易处理。实际上，许多Kotlin库的函数都是高阶的，例如`map`。在Kotlin中，我们可以声明函数和函数引用作为值，然后将其传递给函数。在本节中，我们将首先了解如何声明lambda，然后了解如何将它们传递给函数。
- en: Getting ready
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to
    compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    as the development environment.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。我正在使用[https://try.kotlinlang.org/](https://try.kotlinlang.org/)上的在线IDE来编译和运行我的Kotlin代码，以完成这个菜谱。您也可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it...
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s follow these steps to understand the working of high-order functions:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下步骤来了解高阶函数的工作原理：
- en: 'Let''s start by understanding how we declare functions as lambdas:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们先了解如何将函数声明为lambda：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the preceding code block, we declared two lambdas: one (`funcMultiply`)
    that takes two integers and returns an integer, and another (`funcSayHi`) lambda
    that takes a string and returns a unit—that is, it returns nothing.'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们声明了两个lambda：一个（`funcMultiply`）接受两个整数并返回一个整数，另一个（`funcSayHi`）lambda接受一个字符串并返回一个单元——也就是说，它不返回任何内容。
- en: 'Although we did not need to declare the type of arguments and the return type
    in the preceding example, in some cases we need to explicitly declare the argument
    types and return types. We do this in the following way:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在前面的例子中我们不需要声明参数类型和返回类型，但在某些情况下，我们需要显式地声明参数类型和返回类型。我们按照以下方式来做：
- en: '[PRE49]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'So now that we have a general idea of how lambdas work, let''s try and pass
    one in another function—that is, we will try a high-order function. Check out
    this code snippet:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经对lambda的工作原理有了大致的了解，让我们尝试将一个lambda传递给另一个函数——也就是说，我们将尝试一个高阶函数。看看这个代码片段：
- en: '[PRE50]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Yup, it is as simple as that—create a function lambda and pass it into the function.
    So this is just one aspect of a high-order function—that is, we can pass a function
    as an argument to the function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的，就这么简单——创建一个函数lambda并将其传递给函数。所以这只是一个高阶函数的一个方面——也就是说，我们可以将一个函数作为参数传递给另一个函数。
- en: 'Another use of high-order functions is to return a function. Consider the following
    example where we need a function that transforms the total price of an order according
    to certain conditions. Kind of like in an e-commerce site, but way simpler:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 高阶函数的另一个用途是返回一个函数。考虑以下示例，我们需要一个根据某些条件转换订单总价的函数。有点像电子商务网站，但简单得多：
- en: '[PRE51]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Note how we need to change functions that we apply based on certain conditions
    so that we return a function that suits the conditions. We assign the returned
    function to a variable and then we can just put `append ()` in front of the variable
    to use it as a function, just like we did with the lambdas. This works because
    the high-order function is essentially returning a lambda.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意我们如何需要根据某些条件更改我们应用的函数，以便返回一个符合条件的函数。我们将返回的函数赋值给一个变量，然后我们只需在变量前加上`append ()`就可以将其用作函数，就像我们处理lambda一样。这是因为高阶函数本质上返回一个lambda。
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Kotlin, we can assign a function to a variable, and then we can pass it into
    a function or return it from a function. This is because it's essentially declared
    like a variable. This is done using a lambda declaration of functions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，我们可以将一个函数赋值给一个变量，然后我们可以将这个函数传递给另一个函数或从函数中返回它。这是因为它本质上就像一个变量一样声明。这是通过函数的lambda声明来实现的。
- en: Declaring a static function
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 声明一个静态函数
- en: '**Static functions** are very useful as they help us prevent copying the same
    methods in multiple objects so you can follow the **don''t repeat yourself** (**DRY**)
    rule. They are also useful when you don''t need to create an instance of an object.
    In Kotlin, we don''t have static methods/functions and variables, like we did
    in Java, but we can still achieve the same results. Let''s see how!'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**静态函数**非常有用，因为它们帮助我们避免在多个对象中复制相同的方法，这样我们就可以遵循**不要重复自己**（**DRY**）的原则。当不需要创建对象实例时，它们也非常有用。在
    Kotlin 中，我们没有像 Java 那样静态方法/函数和变量，但我们仍然可以实现相同的结果。让我们看看如何实现吧！'
- en: Getting ready
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with. We will be learning about static
    functions by going through the examples and their workings.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和执行我们的代码。你可以使用你感到舒适的任何开发环境。我们将通过示例及其工作原理来学习静态函数。
- en: How to do it...
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: One of the use cases of static methods is that we can prevent multiple copying
    of the same methods in different classes, and also that we don't need to create
    an object of the enclosing class.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法的一个用例是，我们可以防止在不同类中多次复制相同的方法，并且我们不需要创建封装类的对象。
- en: 'Kotlin recommends creating package-level functions. If you are coming from
    the Java world, this probably won''t make any sense to you as this isn''t supported
    in Java. Let''s see how it''s done in Kotlin:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 建议创建包级别的函数。如果你来自 Java 世界，这可能对你来说没有什么意义，因为在 Java 中不支持这一点。让我们看看 Kotlin
    中是如何实现的：
- en: 'You need to create a Kotlin file with the `.kt` extension and just declare
    the method that you''ll be using in many places. I have created a `SampleClass.kt`
    file and have added a method that we will be calling from other classes:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你需要创建一个以`.kt`扩展名的 Kotlin 文件，并仅声明你将在许多地方使用的方法。我已经创建了一个`SampleClass.kt`文件，并添加了一个我们将从其他类中调用的方法：
- en: '[PRE52]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, I''ll call this method from `HelloWorld.kt`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我将从`HelloWorld.kt`中调用这个方法：
- en: '[PRE53]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Since the function was present in `packageA`, we used the `import` statement.
    This way, we followed DRY and didn't need to create an instance of any class.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于函数存在于`packageA`中，我们使用了`import`语句。这样，我们遵循了DRY原则，并且不需要创建任何类的实例。
- en: 'Another way to do it is by putting methods or variables in an object declaration.
    So we can modify the `SameClass.kt` into the following:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种方法是，通过在对象声明中放置方法或变量来实现。因此，我们可以将`SameClass.kt`修改如下：
- en: '[PRE54]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Any method or variable under object declaration will work as a `static` method
    or variable. In order to access it, we can do this:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在对象声明下定义的任何方法或变量都将作为`static`方法或变量工作。为了访问它，我们可以这样做：
- en: '[PRE55]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: This is much like how we call static methods.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这与调用静态方法非常相似。
- en: 'However, suppose you want the class name as a qualifier and access elements
    of the class. You can still use it using the `companion` keyword. Here''s how
    it will look:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，假设你想要使用类名作为限定符并访问类的元素。你仍然可以使用`companion`关键字来实现。以下是它的样子：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'If you want to call the method under the `companion` object, you''ll need to
    access it like this:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想要调用`companion`对象下的方法，你需要像这样访问它：
- en: '[PRE57]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If `Companion` seems like an eyesore to you, you can use the `@JvmStatic` annotation:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`Companion`看起来让你感到不舒服，你可以使用`@JvmStatic`注解：
- en: '[PRE58]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Then, you can access it using `SampleClass.foo()`, just like you do in a Kotlin
    class.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以像在 Kotlin 类中一样使用`SampleClass.foo()`来访问它。
- en: Using the use keyword in Kotlin
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Kotlin 中使用 use 关键字
- en: There are some situations where if you use a resource (for example, a file)
    then you have to take care of its lifecycle so that you don't leak resources.
    For example, if you read from a file, you need to close it after use, or else
    you'll leave it in an unstable state. Java 7 brought an update that could handle
    this without a need to handle it explicitly. Kotlin also provides this feature,
    but in a much easier way. It does so by using the `use` method. We will learn about
    this in the following recipe. So let's get started!
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些情况下，如果你使用资源（例如，文件），你必须注意其生命周期，以确保不会泄露资源。例如，如果你从文件中读取，使用后需要关闭它，否则你会将其留在不稳定的状态。Java
    7 带来了一项更新，可以处理这种情况，而无需显式处理。Kotlin 也提供了这个功能，但方式更加简单。它是通过使用`use`方法来实现的。我们将在接下来的菜谱中了解这一点。那么，让我们开始吧！
- en: Getting ready
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA to write and execute our code. You can use whatever
    development environment you are comfortable with.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和执行我们的代码。你可以使用你感到舒适的任何开发环境。
- en: How to do it...
  id: totrans-240
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s take the following steps to understand the `use` function of Kotlin:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们采取以下步骤来理解 Kotlin 的 `use` 函数：
- en: 'To understand the `use` keyword, we will need to go back to Java. Prior to
    Java 7, managing the resources that needed to be closed was a bit cumbersome.
    For example, look at the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要理解 `use` 关键字，我们需要回到 Java。在 Java 7 之前，管理需要关闭的资源有点繁琐。例如，看看以下代码：
- en: '[PRE59]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Let's examine the preceding code. We know an exception can be thrown inside
    the `try` block when we use the `input` object. However, it can also be thrown
    in the `finally` block, because we are trying to close the `input` object. Now,
    the `finally` block will be called whether or not the `try` block throws an exception.
    Suppose both the `try` and `finally` blocks throw exceptions—which one of the
    two will propagate? The answer is that the exception will be thrown in the `finally`
    block, even if the exception of `try` would make more sense here.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们检查前面的代码。我们知道在使用 `input` 对象时，`try` 块内部可能会抛出异常。然而，它也可能在 `finally` 块中抛出，因为我们正在尝试关闭
    `input` 对象。现在，无论 `try` 块是否抛出异常，`finally` 块都会被调用。假设 `try` 和 `finally` 块都抛出了异常——哪一个将会传播？答案是，异常将在
    `finally` 块中抛出，即使 `try` 的异常在这里可能更有意义。
- en: 'Java 7 brought an update to this problem by introducing the try-with-resource
    construct, which looks something like this:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Java 7 通过引入 try-with-resource 构造来更新了这个问题，其外观如下：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: When the `try` block finishes executing, the `FileInputStream` object is closed
    automatically. Also, if both the operations—`input.read()` and the closing of
    the input object—throw exceptions, the exception thrown by `input.read()` will
    propagate. The `use` keyword of Kotlin does the exact same work. In this section,
    we will see how.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当 `try` 块执行完毕后，`FileInputStream` 对象会自动关闭。此外，如果 `input.read()` 操作和关闭输入对象的操作都抛出异常，`input.read()`
    抛出的异常将会传播。Kotlin 的 `use` 关键字做的是完全相同的工作。在本节中，我们将看到它是如何实现的。
- en: 'In the preceding example, we saw in Java will look something like the following
    in Kotlin if we implement the `use` keyword:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在前面的例子中，如果我们实现 `use` 关键字，Java 中的代码将类似于以下内容：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: How it works...
  id: totrans-250
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`use` accepts a function literal and is defined as an extension on an instance
    of closeable. It will close down the resource, just like the try-with-resources
    construct, after the function'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '`use` 接受一个函数字面量，并在可关闭实例上定义为一个扩展。它将在函数完成后关闭资源，就像 try-with-resources 构造一样。'
- en: has completed, whether an exception was raised or not.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 已完成，无论是否抛出了异常。
- en: Working with closures
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理闭包
- en: 'MDN ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures))
    says this:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: MDN ([https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures))
    说：
- en: '“A closure is a special kind of object that combines two things: a function,
    and the environment in which that function was created. The environment consists
    of any local variables that were in-scope at the time the closure was created”'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: “闭包是一种特殊的对象，它结合了两样东西：一个函数，以及该函数被创建时的环境。环境包括在闭包创建时处于作用域内的任何局部变量。”
- en: '**Closures** in functional programming are the functions that are *aware* of
    their surroundings. By this, I mean that a closure function has access to the
    variables and parameters defined in the outer scope. Remember that in Java and
    traditional procedural programming, the variables were tied to the scope, and
    as soon as the block got executed, local properties were blown out of the memory.
    Java 8 lambdas can access outer variables, but can''t modify them, and this limits
    the capabilities if you try to do functional programming in Java 8\. Let''s take
    a look at an example where we work with closures in Kotlin.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程中的 **闭包** 是那些 **了解** 自己周围环境的函数。通过这种方式，我的意思是闭包函数可以访问在外部作用域中定义的变量和参数。记住，在
    Java 和传统的过程式编程中，变量是绑定到作用域的，一旦块执行完毕，局部属性就会被从内存中清除。Java 8 的 lambda 可以访问外部变量，但不能修改它们，这限制了你在
    Java 8 中尝试进行函数式编程的能力。让我们看看一个在 Kotlin 中处理闭包的例子。
- en: Getting ready
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will be using IntelliJ IDEA for writing and executing our code. You can use
    whatever development environment you are comfortable with.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 IntelliJ IDEA 来编写和执行我们的代码。你可以使用你熟悉的任何开发环境。
- en: How to do it...
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In this example, we will simply create an array of integers and calculate its
    sum:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将简单地创建一个整数数组并计算其总和：
- en: '[PRE62]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In the preceding example, the `sum` variable is defined in the outer scope;
    still, we are able to access and modify it.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`sum` 变量是在外部作用域中定义的；尽管如此，我们仍然能够访问和修改它。
- en: There's more...
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want to learn more about high-order functions or closures, head on to
    the *Passing a function as a parameter to another* recipe of this chapter.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于高阶函数或闭包的内容，请参阅本章的 *将函数作为参数传递给另一个函数* 食谱。
- en: Function literals with receivers
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带接收者的函数字面量
- en: A **Function literal** is a function that is not declared but that is passed
    in as an expression. Lambdas and anonymous functions are function literals. In
    Kotlin, we can call a function literal with a receiver object, and we can call
    methods on the receiver object inside the body of the function literal, quite
    like extension functions. In this recipe, we will learn how to use function literals
    with receivers.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**函数字面量** 是一种未声明但作为表达式传递的函数。Lambda 表达式和匿名函数都是函数字面量。在 Kotlin 中，我们可以使用接收者对象调用函数字面量，并且可以在函数字面量的主体内部调用接收者对象的方法，这与
    Kotlin 中的扩展函数非常相似。在本食谱中，我们将学习如何使用带接收者的函数字面量。'
- en: Getting ready
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/) to
    compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for development environment.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行 Kotlin。您也可以使用命令行来完成此任务，这需要安装 Kotlin 编译器和 JDK。我在 [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    上使用在线 IDE 来编译和运行本食谱的 Kotlin 代码。您也可以使用 IntelliJ IDEA 作为开发环境。
- en: How to do it...
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Follow these steps to understand function literals:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤理解函数字面量：
- en: 'Let''s start with a simple function literal on a `String`, which returns a
    string added to the receiver string:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在 `String` 上的一个简单函数字面量开始，它返回一个添加到接收者字符串上的字符串：
- en: '[PRE63]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: A function literal has access to the receiver it has been called on, and it
    can access methods associated with that receiver.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 函数字面量可以访问它被调用的接收者，并且可以访问与该接收者相关联的方法。
- en: We can also pass the receiver as a parameter in an ordinary function, where
    the first parameter is for a receiver. This can be useful in scenarios where we
    need to use an ordinary function.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们也可以在普通函数中将接收者作为参数传递，其中第一个参数用于接收者。这在需要使用普通函数的场景中可能很有用。
- en: 'So `String.(String) -> Int` is similar to `(String, String) -> Int` is compatible.
    Check out the following example :'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此 `String.(String) -> Int` 与 `(String, String) -> Int` 是兼容的。查看以下示例：
- en: '[PRE64]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: If the receiver type can be inferred, then lambda can be used as the function
    literal.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可以推断接收者类型，则 lambda 可以用作函数字面量。
- en: 'So basically, we can call a function literal on a receiver object, and inside
    the body of the function, we can access and call methods on a receiver object,
    similar to an extension function in Kotlin. The following is the syntax for this:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，我们可以在接收者对象上调用函数字面量，并在函数的主体内部访问和调用接收者对象的方法，这与 Kotlin 中的扩展函数类似。以下是这个语法的示例：
- en: '[PRE65]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Working with anonymous functions
  id: totrans-280
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用匿名函数
- en: In Kotlin, we can have functions as expressions by creating lambdas. Lambdas
    are function literals—that is, they are not declared as they are expressions and
    can be passed as parameters. However, we cannot declare return types in lambdas.
    Although the return type is inferred automatically by Kotlin compiler in most
    cases, for cases where it cannot be inferred on its own or it needs to be declared
    explicitly, we use anonymous functions. In this recipe, we will see how to use
    anonymous functions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，我们可以通过创建 lambda 表达式来拥有函数表达式。Lambda 表达式是函数字面量——也就是说，它们不是作为声明而是作为表达式，并且可以作为参数传递。然而，我们无法在
    lambda 表达式中声明返回类型。尽管 Kotlin 编译器在大多数情况下会自动推断返回类型，但对于那些无法自动推断或需要显式声明的情形，我们使用匿名函数。在本食谱中，我们将了解如何使用匿名函数。
- en: Getting ready
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You need to install a preferred development environment that compiles and runs
    Kotlin. You can also use the command line for this purpose, for which you need
    Kotlin compiler installed, along with JDK. I am using an online IDE at [https://try.kotlinlang.org/](https://try.kotlinlang.org/)
    to compile and run my Kotlin code for this recipe. You can also use IntelliJ IDEA
    for the development environment.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要安装一个首选的开发环境，该环境可以编译和运行Kotlin。您也可以使用命令行来完成此目的，为此您需要安装Kotlin编译器和JDK。我正在使用[https://try.kotlinlang.org/](https://try.kotlinlang.org/)上的在线IDE来编译和运行我的Kotlin代码，以完成此菜谱。您也可以使用IntelliJ
    IDEA作为开发环境。
- en: How to do it...
  id: totrans-284
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'In the following steps, we will learn about anonymous functions with the help
    of some examples:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下步骤中，我们将通过一些示例学习匿名函数：
- en: 'Let''s start by declaring a function as a lambda:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将函数声明为lambda函数开始：
- en: '[PRE66]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'In the preceding code block, we have declared two lambdas: one (`funcMultiply`)
    that takes two integers and returns an integer, and another (`funcSayHi`) lambda
    that takes a string and returns a unit—that is, it returns nothing.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码块中，我们声明了两个lambda函数：一个（`funcMultiply`）接受两个整数并返回一个整数，另一个（`funcSayHi`）lambda函数接受一个字符串并返回一个单元——也就是说，它不返回任何内容。
- en: 'Although in the preceding example we did not need to declare the type of arguments
    and return type, in some cases we need to explicitly declare the argument types
    and return types. We do that in the following way, by means of an anonymous function:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然在前面的示例中我们不需要声明参数类型和返回类型，但在某些情况下，我们需要显式声明参数类型和返回类型。我们通过以下方式使用匿名函数来完成此操作：
- en: '[PRE67]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'So now we have a general idea of how anonymous functions work. Now, let''s
    try and pass one in another function—that is, we will try a high-order function.
    Check out this code snippet:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在我们已经对匿名函数的工作方式有了大致的了解。现在，让我们尝试将一个匿名函数传递给另一个函数——也就是说，我们将尝试一个高阶函数。查看以下代码片段：
- en: '[PRE68]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'So basically, an anonymous function is declared just like a regular function,
    but without a name. The body can be an expression, as in the following example,
    or a block, as in the preceding example. One thing to note is that parameters
    are always passed inside the parentheses in the case of anonymous functions, unlike
    in lambda expressions:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，基本上，匿名函数的声明方式与常规函数相同，但没有名称。主体可以是一个表达式，如以下示例所示，或者是一个代码块，如前面的示例所示。需要注意的是，在匿名函数的情况下，参数总是传递在括号内，这与lambda表达式不同：
- en: '[PRE69]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Another interesting difference between a lambda and an anonymous function is
    that in a lambda, the return statement returns from the enclosing function, whereas
    in an anonymous function, it simply returns from the function itself.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Lambda函数和无名函数之间另一个有趣的区别是，在lambda函数中，return语句会从封装函数返回，而在匿名函数中，它只是简单地从函数本身返回。
- en: One can omit the parameter type and return type from an anonymous function as
    well if it can be inferred on its own.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可以自动推断，还可以省略匿名函数的参数类型和返回类型。
- en: Anonymous functions can access and modify variables inside their closures.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匿名函数可以访问和修改其闭包内的变量。
- en: So basically, one can declare an anonymous function just like a regular function
    without a name (hence, the name anonymous). It can be an expression or a code
    block.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，可以像常规函数一样声明一个匿名函数，而不需要名称（因此得名匿名）。它可以是表达式，也可以是代码块。
