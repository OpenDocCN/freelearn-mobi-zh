- en: Creating Sprites and Interactive Objects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建精灵和交互对象
- en: 'We have learned almost everything about the basics that we need to create various
    components in Android, so we can now move on to do some more exciting stuff. Now,
    at this point, we will start working on a proper 2D game. It will be a small 2D
    side scroller game like Mario. However, before we do that, let''s first talk about
    games as a development concept. In order to understand more about games, you will
    need to understand a bit of **Game Theory**. So, before we proceed with creating
    images and backgrounds on screen, let''s dive into some game theory. Here are
    a list of topics we will be covering in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经几乎学到了创建Android中各种组件所需的所有基础知识，因此我们现在可以继续做一些更有趣的事情。现在，在这个阶段，我们将开始制作一个真正的2D游戏。它将是一个类似于马里奥的小型2D横版滚动游戏。然而，在我们这样做之前，让我们首先谈谈游戏作为一个开发概念。为了更好地了解游戏，你需要了解一点**博弈论**。所以，在我们继续创建屏幕上的图像和背景之前，让我们深入探讨一些博弈论。以下是本章我们将涵盖的一些主题列表：
- en: Game Theory
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 博弈论
- en: Working with colors
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色
- en: Creating images on screen
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在屏幕上创建图像
- en: Making a continuous scrolling background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作连续滚动的背景
- en: Let's start with the first one.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个开始。
- en: Game Theory
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 博弈论
- en: 'If you observe a game carefully in its source code level, you will observe
    that a game is just a set of illusions to create certain effects and display them
    on screen. Perhaps, the best example of this can be the game that we are about
    to develop. In order to make your character move ahead, you can do either of two
    things:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察游戏的源代码，你会注意到游戏只是一系列错觉，用于创建某些效果并在屏幕上显示。也许，最好的例子就是我们即将开发的这个游戏。为了使你的角色向前移动，你可以做以下两件事之一：
- en: Make the character move ahead
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让角色向前移动
- en: Make the background move behind
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让背景在后面移动
- en: Let's take a look at this in a bit more detail. The preceding two points can
    be achieved with the help of some illusions; let's understand how.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这个。前两点可以通过一些错觉来实现；让我们了解如何。
- en: Illusions
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 幻觉
- en: 'Either of the two things mentioned in the preceding section will give you an
    illusion that the character is moving in a certain direction. Also, if you remember Mario
    properly, then you will notice that the clouds and grasses are one and the same,
    only their colors were changed. This was because of the memory limitations of
    the console platform at the time:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中提到的任何两种东西都会给你一种错觉，即角色正在向某个方向移动。如果你正确地记得马里奥，那么你会注意到云彩和草地是相同的，只是它们的颜色改变了。这是因为当时控制台平台的内存限制：
- en: '![](img/B05066_04_02-2.png)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_02-2.png)'
- en: Game developers use many such *tricks* in order to get their game running. Of
    course, in today's times, we don't have to worry much about memory limitations
    because our mobile device has the capability of the Apollo 11 rocket, which landed
    on the moon. Now, keeping in mind the mentioned two scenarios; we will use one
    of them in our game to make our character move.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏开发者使用许多这样的**技巧**来确保他们的游戏能够运行。当然，在当今时代，我们不必过于担心内存限制，因为我们的移动设备具有阿波罗11号火箭的能力，它曾在月球上着陆。现在，考虑到提到的两种情况；我们将在我们的游戏中使用其中之一来使我们的角色移动。
- en: 'We also have to understand that every game is a loop of activities. Unlike
    an app, you will need to draw your game resources at every single frame. The illusion
    of moving or any other effect will be stronger the more frames per second the
    mobile device can draw them. This concept is called as **Frames Per Second** (**FPS**). It''s
    almost similar to that of the concept of old films where a huge film used to be
    projected on the screen by rolling per frame. Take a look at the following screenshot to
    understand this concept better:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须理解，每个游戏都是一个活动的循环。与应用程序不同，你需要在每一帧上绘制你的游戏资源。移动或其他效果的错觉将随着移动设备每秒可以绘制的帧数增加而变得更强烈。这个概念被称为**每秒帧数**（**FPS**）。它几乎与旧电影的概念相似，其中一大块胶片通过每帧滚动来在屏幕上投影。看看下面的截图，以更好地理解这个概念：
- en: '![](img/B05066_04_01.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_01.png)'
- en: Sprite sheet of a game character
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏角色的精灵图集
- en: You must have been wondering since the last chapter what a sprite means, if
    not the popular cold drink. As you can see in the preceding screenshot, a sprite
    sheet is simply an image consisting of multiple images within themselves in order
    to create an animation, and thereby a sprite is simply an image. If we want to
    make our character run, we will simply read the file `Run_000` and play it all
    the way sequentially through to `Run_009`, which will make it appear as though
    the character is running. We will take a look at this in [*Chapter 5*](517d0010-d72f-4ccc-9f45-365f6918e87f.xhtml),
    *Adding Animation to Your Game*, which we will follow through.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 自从上一章以来，你可能一直在想精灵是什么意思，如果不是流行的冷饮。正如你在前面的屏幕截图中所见，精灵图集只是一个由多个图像组成的图像，这些图像本身又包含多个图像，以创建动画，因此精灵只是一个图像。如果我们想让我们的角色跑步，我们只需简单地读取文件`Run_000`并按顺序播放到`Run_009`，这样角色看起来就像是在跑步。我们将在[*第五章*](517d0010-d72f-4ccc-9f45-365f6918e87f.xhtml)“为你的游戏添加动画”中查看这一点，我们将继续进行。
- en: A majority of things that you will be working with when making a game would
    be based on manipulating your movements. So, you will need to be clear about your
    coordinates system because it will come in handy—be it for firing a bullet out
    of a gun, character movement, or simply turning around to look here and there--all
    of it is based on the simple component of movement.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你制作游戏时，你将处理的大多数事情都将基于操纵你的移动。因此，你需要清楚你的坐标系，因为它会很有用——无论是从枪中发射子弹、角色移动，还是简单地转身四处张望——所有这些都基于简单的移动组件。
- en: Game loop
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: 'In its core, every game is basically just a loop of events. It is a set up
    to give calls to various functions and code blocks to execute in order to have
    draw calls on your screen, and thereby making the game playable. Mostly, your
    game comprises three parts:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，每个游戏基本上都是一个事件的循环。它是一组调用各种函数和代码块以在屏幕上执行绘制调用的设置，从而使游戏可玩。大多数情况下，你的游戏由三个部分组成：
- en: Initialize
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 初始化
- en: Update
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新
- en: Draw
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制
- en: Initializing the game means to set an entry point to your game through which
    the other two parts can be called. Your game begins here and is called just once.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化游戏意味着为你的游戏设置一个入口点，通过这个入口点可以调用其他两个部分。你的游戏从这里开始，并且只调用一次。
- en: Once your game is initialized, you need to start giving calls to your events
    that can be managed through your `update` function.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的游戏初始化，你需要开始调用你的事件，这些事件可以通过你的`update`函数进行管理。
- en: The `draw` function is responsible for drawing all your image data on the screen. Everything
    you see on the screen including your backgrounds, images, or even your GUI is
    the responsibility of the `draw` method.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '`draw`函数负责在屏幕上绘制所有图像数据。屏幕上显示的所有内容，包括你的背景、图像，甚至是你的GUI，都是`draw`方法的职责。'
- en: To say the least, your game loop is the heart of your game. This is just a basic
    overview of the game loop, and there is much more complexity you can add to it.
    However, for now, this much information is sufficient for you to get started.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 至少可以说，你的游戏循环是游戏的核心。这只是一个游戏循环的基本概述，你还可以添加更多复杂性。然而，目前，这些信息已经足够你开始。
- en: 'The following image perfectly illustrates what a game loop is:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图像完美地说明了什么是游戏循环：
- en: '![](img/B05066_04_03.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_03.png)'
- en: Image Source: [https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469](https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来源：[https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469](https://gamedevelopment.tutsplus.com/articles/gamedev-glossary-what-is-the-game-loop--gamedev-2469)
- en: Game Design Document
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏设计文档
- en: 'Before starting a game, it is essential to create a **Game Design Document
    (GDD)**. This document serves as a groundwork for the game you will be making.
    In all, 99% of the time when we start making a game, we lose track of the features
    planned for it and deviate from the core game experience. So, it is always recommended
    to have a GDD in place in order to keep focus. A GDD consists of the following
    things:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始游戏之前，创建一个**游戏设计文档（GDD）**是至关重要的。这份文档是你将要制作的游戏的基础。总的来说，当我们开始制作游戏时，有99%的时间我们会失去对计划的功能的跟踪，并偏离核心游戏体验。因此，始终建议有一个GDD，以便保持专注。GDD包括以下内容：
- en: Gameplay mechanics
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 游戏玩法机制
- en: Story (if any)
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 故事（如果有）
- en: Level design
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关卡设计
- en: Sound and music
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音和音乐
- en: UI planning and game controls
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI规划和游戏控制
- en: 'You can read more about the Game Design Document by navigating to the following
    link:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过以下链接了解更多关于游戏设计文档的信息：
- en: '[https://en.wikipedia.org/wiki/Game_design_document](https://en.wikipedia.org/wiki/Game_design_document)'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '[游戏设计文档](https://en.wikipedia.org/wiki/Game_design_document)'
- en: Prototyping
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型设计
- en: When making a game, we need to test it simultaneously. A game is one of the
    most complex pieces of software, and if we mess up on one part there is a chance
    that it might break the entire game as a whole. This process can be called as
    **Prototyping**. Making a prototype of your game is one of the most important
    aspects of a game because this is where you test out the basic mechanics of your
    game. A prototype should be a simple working model of your game with basic functionality.
    It can also be termed as a **stripped down version** of your game.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作游戏时，我们需要同时进行测试。游戏是最复杂的软件之一，如果我们在一部分出错，可能会破坏整个游戏。这个过程可以称为**原型设计**。制作游戏的原型是游戏最重要的方面之一，因为这是你测试游戏基本机制的地方。原型应该是具有基本功能的一个简单的工作模型，也可以称为游戏的**简化版本**。
- en: Surface and Canvas
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表面和画布
- en: We saw how to create images and buttons using components from our palette in
    an Android app. However, this concept is a bit different in games. In games, we
    work with something known as a **Canvas**, which is used to draw images onto our
    **Surface**. To give you a basic understanding, a Surface is anything that holds
    pixels onto it. Basically, a Surface holds your Canvas, which then maps it onto
    your views. All of your image manipulations are is based on this. So, for the
    purpose of drawing anything in our game, we will use a `SurfaceView` component.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了如何使用从我们的 Android 应用调色板中的组件创建图像和按钮。然而，在游戏中，这个概念略有不同。在游戏中，我们与一个称为**画布**的东西一起工作，它用于在**表面**上绘制图像。为了给你一个基本的概念，表面是任何在其上持有像素的东西。基本上，表面持有你的画布，然后将其映射到视图上。所有的图像操作都是基于这个。因此，为了在游戏中绘制任何东西，我们将使用`SurfaceView`组件。
- en: Working with colors and images
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理颜色和图像
- en: 'Now that we have learned these concepts as well as having an understanding
    of working on Android Studio, we can proceed to start working on making our game
    from scratch. Let''s clear all the buttons and text views in our `activity_fullscreen.xml`
    file and remove all the references in our Java code so that it looks somewhat
    like this:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学习了这些概念，并且对在 Android Studio 上的工作有了了解，我们可以开始从头开始制作我们的游戏。让我们清除`activity_fullscreen.xml`文件中的所有按钮和文本视图，并从我们的
    Java 代码中移除所有引用，使其看起来大致如下：
- en: '![](img/B05066_04_03.png)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_04_03.png)'
- en: 'Take a look at the Component Tree window below your Palette for a proper reference:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 看看你调色板下面的组件树窗口，以获得适当的参考：
- en: '![](img/B05066_04_04.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_04_04.png)'
- en: Note here that at this point we are back to square one with our app.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，此时我们回到了应用的原点。
- en: When you are done with this, just run and test your app once to check whether
    there are any errors; if not, then proceed further. We will now take a look at
    how to create basic colors using hex color codes and then proceed to create images
    for our background as well as other components.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，只需运行并测试你的应用一次，检查是否有任何错误；如果没有，则继续进行。现在我们将看看如何使用十六进制颜色代码创建基本颜色，然后继续创建背景以及其他组件的图像。
- en: Creating colors
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建颜色
- en: This is fairly simple, and we have seen this in our previous chapter as well.
    Simply go to your `colors.xml` file located in the `app/res/values/` folder. Here,
    you can observe multiple hex color code values. A hex color code represents a
    six-digit alphanumeric value, which is responsible for giving a color. The value
    starts from **#000000** (black) to **#ffffff** (white).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单，我们也在上一章中看到了这一点。只需前往位于`app/res/values/`文件夹中的`colors.xml`文件。在这里，你可以观察到多个十六进制颜色代码值。十六进制颜色代码代表一个六位数的字母数字值，负责赋予颜色。值从**#000000**（黑色）到**#ffffff**（白色）。
- en: 'In our `colors.xml`, if you observe there are already predefined values as
    seen in the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`colors.xml`中，如果你观察，可以看到已经预定义了值，如下面的截图所示：
- en: '![](img/B05066_04_05.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B05066_04_05.png)'
- en: Hex color code values
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 十六进制颜色代码值
- en: 'In this file, you can tweak in these values or simply add your own values as
    well. Let''s say if you want to add the color red, then you simply add the following
    line into this code to get the red value:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个文件中，你可以调整这些值，或者简单地添加你自己的值。比如说，如果你想添加红色，你只需将以下行添加到这段代码中，以获取红色值：
- en: '[PRE0]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you observe the syntax closely, you will observe that this hex code is in
    the format of `RRGGBB`, which means that the first two alphanumeric digits constitute
    the composition of the red color, the second two digits correspond to the green
    color, and the last two digits correspond to that of the blue color. Also, with
    the name field, you can use this color in any component as we have done in our
    background. Go ahead, try and tweak some values in the `colorPrimary`, and see
    what changes happen.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察语法，您会注意到这个十六进制代码的格式为`RRGGBB`，这意味着前两个字母数字组成红色成分，第二个两个数字对应绿色，最后两个数字对应蓝色。此外，使用名称字段，您可以在任何组件中使用这种颜色，就像我们在背景中所做的那样。现在，尝试调整`colorPrimary`中的某些值，看看会发生什么变化。
- en: 'Also, note here that in hex color code, we can only use numbers from 0-9 and
    characters from a-f. So, if you use something such as #99z9pt, then this won''t
    give out any color or number output. Try this out so that you get a clearer understanding
    of this color code concept.'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在十六进制颜色代码中，我们只能使用0-9的数字和a-f的字符。因此，如果您使用类似于#99z9pt的东西，那么它不会产生任何颜色或数字输出。尝试这样做，以便您对这种颜色代码概念有更清晰的理解。
- en: That is all about colors in Android Studio. You can use them in your backgrounds,
    surfaces, and so on using your understanding of XML files as we have seen in previous
    chapters, or you also set them programmatically from your Java code. Let's now
    move on to the most interesting part, working with images.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是Android Studio中关于颜色的全部内容。您可以使用它们在背景、表面等地方使用您对XML文件的理解，就像我们在前面的章节中看到的那样，或者您也可以从Java代码中程序化地设置它们。现在，让我们继续到最有趣的部分，即处理图像。
- en: Creating images
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像
- en: We've taken a look at the project structure of an Android project. So, by now
    we are clear about the difference between where to put code files and where to
    put our resources. Images are resources, and therefore, they can either be put
    in the `res` folder of our Android Studio Project or AssetManager, but more specifically,
    we can't just put them in the `res` folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经查看了一个Android项目的项目结构。因此，到现在我们已经清楚代码文件和资源放置的位置的区别。图像是资源，因此它们可以放在Android Studio项目的`res`文件夹或AssetManager中，但更具体地说，我们不能仅仅将它们放在`res`文件夹中。
- en: 'There is, by convention, a specific folder exclusively for our image resources,
    that is, the `drawable` folder. You can find this folder in `app/res/drawable`.
    If you are not able to see it, then create it manually by right-clicking on the
    `res` folder and selecting New | Android resource directory, and in Resource Type,
    select drawable. You do not have to do this if the `drawable` folder already exists
    in your folder:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按照惯例，有一个专门用于图像资源的特定文件夹，即`drawable`文件夹。您可以在`app/res/drawable`中找到此文件夹。如果您看不到它，则可以通过在`res`文件夹上右键单击并选择“新建
    | Android资源目录”，然后在“资源类型”中选择“drawable”来手动创建它。如果您的文件夹中已经存在`drawable`文件夹，则无需这样做：
- en: '![](img/B05066_04_06.png)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_06.png)'
- en: Creating the drawable folder
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 创建drawable文件夹
- en: 'This folder includes all your image resources in your project including resources,
    such as background images, icons, and sprite sheets. For the purpose of this game,
    we''ll put all our image resources into the `drawable` folder. We will now create
    a background image, and in our next chapter, we will learn how to put another
    image on top of that. After we are done with this, we will create an `OnClickListener`
    on our newly created image on top of our background so that it changes the image.
    So for this, we will need three image resources. Let''s call them the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件夹包含项目中所有图像资源，包括资源，如背景图片、图标和精灵图集。为了本游戏的目的，我们将所有图像资源放入`drawable`文件夹。现在我们将创建一个背景图片，在下一章中，我们将学习如何在上面的图片上放置另一张图片。完成这些后，我们将在背景上创建一个新的`OnClickListener`，以便更改图片。因此，我们需要三个图像资源。让我们称它们为以下：
- en: '`background_image`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`background_image`'
- en: '`image_1`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_1`'
- en: '`image_2`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`image_2`'
- en: For this chapter, we have taken the following stock images. You are free to
    use any images of your choice as you deem fit.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们已选取以下库存图片。您可以根据自己的需要自由选择任何图片。
- en: '`background_image`: The following is the background image we will be using
    for our game:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`background_image`：以下是我们游戏将使用的背景图片：'
- en: '![](img/B05066_04_11.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_11.png)'
- en: '`image_1`: The following is one of the frames of our player:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`image_1`：以下是我们玩家的一个帧：'
- en: '![](img/image_1.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_1.png)'
- en: '`image_2`: The following is another image frame of our character:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`image_2`：以下是我们角色的另一个图像帧：'
- en: '![](img/image_2.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![](img/image_2.png)'
- en: 'So, we will have our `background_image` and `image_1` on top of it. When we
    click on our `image_1`, it will get converted into `image_2`. Let''s get some
    stock image resources and put them into our `res/drawable` folder. To do this,
    simply right-click on any images you want to put in the `drawable` folder and
    select Copy:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将在`background_image`的上方放置`image_1`。当我们点击`image_1`时，它将转换为`image_2`。让我们获取一些库存图片资源并将它们放入我们的`res/drawable`文件夹中。为此，只需在你想放入`drawable`文件夹的任何图片上右键单击并选择复制：
- en: '![](img/B05066_04_07.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_07.png)'
- en: 'And then, right-click on the drawable folder and select Paste:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在drawable文件夹上右键单击并选择粘贴：
- en: '![](img/B05066_04_08.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_08.png)'
- en: After this, you will be prompted with a dialog box. Press Ok to successfully
    import your image resources in your `project` folder.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你会弹出一个对话框。点击“确定”以成功将你的图片资源导入到你的`project`文件夹中。
- en: 'Now that we have our image resources in place, it''s time to get them on our
    screen. You can do this right away by taking an ImageView component and setting
    its property to your desired image, but since we are making a game, we will go
    the *Canvas Way*. To do that, first we need to replace our entire Java code, in
    our `FullscreenActivity.java` and make it look like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经放置了图像资源，是时候将它们显示在我们的屏幕上了。你可以立即通过获取一个ImageView组件并将其属性设置为你的期望图片来实现这一点，但由于我们正在制作游戏，我们将采用*Canvas方式*。为此，首先我们需要替换我们`FullscreenActivity.java`中的全部Java代码，使其看起来像这样：
- en: '[PRE1]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: All the changes you need to do in your existing code have been marked in **bold**
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在现有代码中做的所有更改都已用**粗体**标出。
- en: Note here that we have eliminated all the toggle status bar functions and have
    kept only our `onCreate` method. The other interesting thing we did with the `getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
    WindowManager.LayoutParams.FLAG_FULLSCREEN);` is that we have manually set our
    game to fullscreen mode. We also eliminated the Title screen window with `requestWindowFeature(Window.FEATURE_NO_TITLE);`
    code. Now, note here you will be getting an error on your `GameView(this)` code.
    This is because we still haven't created our `GameView` class. So, let's go ahead
    and make that but before that let's make one minor change in our manifest file.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里我们已经消除了所有切换状态栏的功能，只保留了我们的`onCreate`方法。我们还用`getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN,
    WindowManager.LayoutParams.FLAG_FULLSCREEN);`手动将游戏设置为全屏模式。我们还用`requestWindowFeature(Window.FEATURE_NO_TITLE);`代码消除了标题屏幕窗口。现在，注意这里你会在你的`GameView(this)`代码上得到一个错误。这是因为我们还没有创建我们的`GameView`类。所以，让我们先创建这个类，但在那之前，让我们在我们的清单文件中做一个小的修改。
- en: 'Open up your `AndroidManifest.xml` file located in the `app/manifests/` folder.
    In your `<activity>` code, add the orientation as landscape as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 打开位于`app/manifests/`文件夹中的`AndroidManifest.xml`文件。在你的`<activity>`代码中，添加方向为横屏，如下所示：
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will now explicitly tell the application that our game is in landscape
    mode.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这将明确告诉应用程序我们的游戏处于横屏模式。
- en: 'Now, let''s move ahead and make our `GameView` class. To do so, simply right-click
    on your `app/java/packagename` folder and select New | Java Class, like this:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续并创建我们的`GameView`类。要做到这一点，只需在你的`app/java/packagename`文件夹上右键单击并选择新建 |
    Java类，如下所示：
- en: '![](img/B05066_04_09.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_09.png)'
- en: 'After you do so, a new window will open up asking you the details of the new
    class you want to make. Simply type in `GameView` inside of the Name text box
    and press OK to proceed, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这样做之后，将打开一个新窗口，询问你想要创建的新类的详细信息。只需在名称文本框中输入`GameView`并按OK继续，如图所示：
- en: '![](img/B05066_04_10.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_10.png)'
- en: 'We will be needing two more classes to set our side-scrolling background image,
    so repeat the same process and create the following two classes:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要再创建两个类来设置我们的侧滑背景图片，所以重复同样的步骤，创建以下两个类：
- en: '`BackgroundImage`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundImage`'
- en: '`MainGameThread`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainGameThread`'
- en: 'So, in total, you now have four classes in your project:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在你的项目中总共有四个类：
- en: '`BackgroundImage`'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BackgroundImage`'
- en: '`FullscreenActivity`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FullscreenActivity`'
- en: '`GameView`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameView`'
- en: '`MainGameThread`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainGameThread`'
- en: 'Our aim is to have a background image on the screen, which would continuously
    scroll through our view. Let''s first open up our `BackgroundImage.java` file
    and write the following code in it:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的目的是在屏幕上有一个背景图片，它会连续滚动通过我们的视图。让我们首先打开我们的`BackgroundImage.java`文件，并在其中写入以下代码：
- en: '[PRE3]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s try to understand this code now. We have simply created a class here
    and following is a step-by-step breakdown of each code block inside our class:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试理解这段代码。我们在这里简单地创建了一个类，以下是类中每个代码块的逐步分解：
- en: We imported Bitmap and Canvas, which is needed for our image and Canvas operations.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们导入了Bitmap和Canvas，这是进行图像和画布操作所需的。
- en: We declared private variables `xc`, `yc`, and `dxc`, which are simply the *x*,
    *y* coordinates and displacement in *x*. The default value of these variables
    will be zero since we haven't initialized them.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声明了私有变量`xc`、`yc`和`dxc`，它们分别是*x*、*y*坐标和*x*方向的位移。这些变量的默认值将是零，因为我们还没有初始化它们。
- en: We then declared a Bitmap private variable, which will be holding our actual
    image file to be displayed on the screen.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们声明了一个私有的Bitmap变量，它将保存要显示在屏幕上的实际图像文件。
- en: Next, we created a constructor for our class, so we can pass an image into it
    using the res reference inside it and within our constructor, we equated this
    reference with our background image variable declared in step 3.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们为我们的类创建了一个构造函数，这样我们就可以通过res引用将其传递进去，并在构造函数中，我们将这个引用与步骤3中声明的背景图像变量相等。
- en: We then created a vector displacement method in order to add a unit vector to
    our image's position value in order to make it move.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个向量位移方法，以便将单位向量添加到图像的位置值中，使其移动。
- en: Then, we used the update method that will be called every time and put all our
    displacement and reset logic in it. If the image goes out of our screen, then
    we reset the position to 0 in order to give a continuous movement effect.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用了每次都会被调用的更新方法，并将所有的位移和重置逻辑放入其中。如果图像超出我们的屏幕，我们就将位置重置为0，以产生连续移动的效果。
- en: Now, if you remember, we discussed at the beginning that in order to draw anything
    on the screen, you need a Canvas. So, using the draw method, we took a Canvas
    as a reference variable and included our draw logic in it. Observe here that we
    are drawing our background image twice. This is because if our image is scrolling
    continuously, then there will be a void in between and it'll appear black, so
    we use the same image and draw it twice on screen a bit further from our main
    image in order to give a continuous loop effect. In order to understand this as
    a live example, you can try removing either one of the `canvas.drawBitmap()` code
    to see for yourself.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，如果你还记得，我们在开始时讨论过，为了在屏幕上绘制任何东西，你需要一个画布。因此，使用draw方法，我们将画布作为一个引用变量，并将我们的绘制逻辑包含在其中。注意，我们在这里绘制了两次背景图像。这是因为如果我们的图像持续滚动，中间将会有一个空白区域，它将显示为黑色，所以我们使用相同的图像，并在屏幕上稍微远离主图像的位置绘制两次，以产生连续循环的效果。为了理解这个活生生的例子，你可以尝试移除`canvas.drawBitmap()`代码中的任何一个，自己看看效果。
- en: 'That''s it for the `BackgroundImage.java` file. By this time, you must be getting
    a few errors on your `GameView.WIDTH` code. Don''t worry about that. We will come
    to it later. Before addressing that error, we must first set up our game thread
    since all our update functions are going to be called from our thread. Our objectives
    for our `MainGameThread.java` file are the following:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`BackgroundImage.java`文件的内容。到这时，你可能在你的`GameView.WIDTH`代码上遇到一些错误。不要担心，我们稍后会解决它。在解决这个错误之前，我们必须首先设置我们的游戏线程，因为所有的更新函数都将从我们的线程中调用。我们的`MainGameThread.java`文件的目标如下：
- en: Give a continuous call to the update function
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对更新函数进行连续调用
- en: Base our performance on frames per second
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以每秒帧数为基础进行性能评估
- en: 'So, open up your `MainGameThread.java` file and type in the following:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开你的`MainGameThread.java`文件，并输入以下内容：
- en: '[PRE4]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here''s what we have done in our `MainGameThread.java` file:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`MainGameThread.java`文件中，我们做了以下操作：
- en: We created all the variables needed to run our thread.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了运行线程所需的所有变量。
- en: We created the constructor for our `MainGameThread` file by taking a `SurfaceHolder`
    and `GameView` references and set their references to `this` file.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`MainGameThread`文件创建了一个构造函数，通过传入`SurfaceHolder`和`GameView`引用，并将它们的引用设置为`this`文件。
- en: We created a method to keep a track of our running thread with a return value
    of Boolean.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个方法来跟踪我们的运行线程，它有一个布尔值返回值。
- en: 'We override the default `run` method of a thread to make it do the stuff we
    need specifically:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们重写了线程的默认`run`方法，使其执行我们需要的特定操作：
- en: We use our surfaceholder variable for manipulating our image pixel data.
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用surfaceholder变量来操作图像的像素数据。
- en: We calculate our frames per second.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算每秒的帧数。
- en: We take an average of frames per second to calculate and display it in the console
    view.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算每秒的平均帧数，并在控制台视图中显示它。
- en: 'By doing this, we are now ready with our thread class and finally only left
    with our `GameView` class. In our `GameView`, we are actually going to put all
    the image data we built on screen and display it. So, let''s open up the `GameView.java`
    file and start typing the following:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们现在已经准备好了我们的线程类，最后只剩下我们的`GameView`类。在我们的`GameView`中，我们将实际上把我们在屏幕上构建的所有图像数据放上去并显示出来。所以，让我们打开`GameView.java`文件并开始输入以下内容：
- en: '[PRE5]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This code is pretty easy to understand. Our `GameView` is the place where we
    create our Surface and draw everything onto it. So, we have extended the `SurfaceView`
    and implemented our callback, `SurfaceHolder`. This gives us access to some pre-written
    methods, which we will be overriding. Before you understand these methods, let''s
    try to understand the logic behind this code. It can be divided into the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很容易理解。我们的`GameView`是我们创建Surface并在此之上绘制一切的地方。因此，我们扩展了`SurfaceView`并实现了我们的回调，`SurfaceHolder`。这给了我们访问一些预写方法的权限，我们将覆盖这些方法。在你理解这些方法之前，让我们先尝试理解这段代码背后的逻辑。它可以分为以下几部分：
- en: We create the default constructor for our GameView class, which then gives a
    call to start our `MainGameThread`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为`GameView`类创建默认构造函数，然后调用`start`我们的`MainGameThread`。
- en: Using predefined methods, we override them and create our Canvas on top of our
    surface.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用预定义的方法，我们覆盖它们并在我们的Surface之上创建我们的Canvas。
- en: We call the update function in our `BackgroundImage` class.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在`BackgroundImage`类中调用更新函数。
- en: We set scaling of our image to match our phone's resolution dynamically.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们动态地设置图像的缩放以匹配手机的分辨率。
- en: 'Now that we know the logic, we can now read through the methods and understand
    them each one by one. We have the following methods in our code:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了逻辑，我们就可以逐个阅读这些方法并理解它们。在我们的代码中，我们有以下方法：
- en: '`surfaceChanged`: We have created an empty method with parameters. If our surface
    changes, then this method is called'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`surfaceChanged`：我们创建了一个带有参数的空方法。如果我们的Surface发生变化，那么这个方法就会被调用'
- en: '`surfaceDestroyed`: If the surface is destroyed, this method is called'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`surfaceDestroyed`：如果Surface被销毁，这个方法就会被调用'
- en: '`surfaceCreated`: After our surface is created, we can start the game loop;
    this is where we initialize our background image and set its resource, as you
    can see in the code, `bgImg = newBackgroundImage(BitmapFactory.decodeResource(getResources(),
    R.drawable.background_image));`'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`surfaceCreated`：在我们的Surface创建后，我们可以开始游戏循环；这就是我们初始化背景图像并设置其资源的地方，正如你在代码中所看到的，`bgImg
    = newBackgroundImage(BitmapFactory.decodeResource(getResources(), R.drawable.background_image));`'
- en: '`onTouchEvent`: This method is called whenever there is a touch on the screen'
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onTouchEvent`：每当屏幕上有触摸时，这个方法就会被调用'
- en: '`update`: This method is the update method, and in here, we are giving a call
    to the `update` method of `BackgroundImage`'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`update`：这个方法是更新方法，在这里，我们调用`BackgroundImage`的`update`方法'
- en: '`draw`: This method gives a call to draw our image onto the screen, and we make
    some calculations to scale our image and set it properly onto our phone as per
    its resolution'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`draw`：这个方法调用将我们的图像绘制到屏幕上，我们进行一些计算以缩放图像并将其适当地设置到手机上，以符合其分辨率'
- en: 'After you are done with this file, don''t forget to check your `FullscreenActivity.java`
    and make sure that its code looks like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在你完成这个文件后，别忘了检查你的`FullscreenActivity.java`文件，并确保其代码看起来像这样：
- en: '[PRE6]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: It is now recommended that you build an apk for this game and test it on your
    device since if you try running this on your emulator it will run extremely slow.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在建议你为这个游戏构建一个apk并在你的设备上测试它，因为如果你在模拟器上尝试运行它，它会运行得非常慢。
- en: 'Build it and execute it on your device/emulator, and you will see an output
    like this in which your background image is continuously scrolling:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的设备/模拟器上构建并执行它，你将看到如下输出，其中你的背景图像会持续滚动：
- en: '![](img/B05066_04_11.png)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B05066_04_11.png)'
- en: That's it! Your side-scrolling background is up and running.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！你的侧边滚动背景已经启动并运行。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Congratulations! You have successfully learned how to create images and work
    with colors in Android Studio. You have also implemented a side-scrolling background,
    which will act as a foundation for the further part of this game.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你已经成功学习了如何在Android Studio中创建图像并处理颜色。你还在游戏中实现了侧边滚动背景，这将是游戏后续部分的基础。
- en: In the next chapter, we will create our player character and implement a click
    listener on our image objects as well as learn how to animate objects with the
    concept of sprite sheets we have just learned.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将创建我们的玩家角色，并在我们的图像对象上实现点击监听器，同时学习如何使用我们刚刚学到的精灵表的概念来动画化对象。
