- en: Chapter 5. Adding a Details View
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。添加详情视图
- en: 'In this chapter, we will walk you through the process of creating a new activity
    to display the details of the selected POI. This activity also allows the user
    to create, update, and delete POIs from the server. The following topics will
    be covered in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将向您介绍创建一个新活动以显示所选POI详情的过程。此活动还允许用户从服务器创建、更新和删除POI。本章将涵盖以下主题：
- en: Creating the layout and activity for displaying POI details
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建用于显示POI详情的布局和活动
- en: Using `LinearLayout`, `TableLayout`, and `ScrollView` to lay out the activity
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`LinearLayout`、`TableLayout`和`ScrollView`来布局活动
- en: Passing data between the activities using Intent bundles
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Intent捆绑在活动之间传递数据
- en: Consuming web services to perform the HTTP `POST` and `DELETE` operations
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗Web服务以执行HTTP `POST`和`DELETE`操作
- en: Performing the `EditText` validation using the `EditText.Error` property
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`EditText.Error`属性执行`EditText`验证
- en: Displaying confirmation prompts
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示确认提示
- en: Creating the POIDetail layout
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建POIDetail布局
- en: So far, we have built the `POIApp` to display the list of POIs fetched from
    the server. Currently, the list view displays limited information about POIs such
    as name, address, image, and distance. Let's now extend the `POIApp` by adding
    another activity that displays detailed information of the selected POI. The POI
    details activity will be revealed only when the user taps on any of the POI item
    from the list or when the user selects the **New** (**+**) action from the navigation
    bar. Additionally, the details activity will allow the user to create a new POI,
    update, or delete the existing POI.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了`POIApp`来显示从服务器获取的POI列表。目前，列表视图仅显示有关POI的有限信息，例如名称、地址、图像和距离。现在让我们通过添加另一个活动来扩展`POIApp`，该活动显示所选POI的详细信息。当用户从列表中点击任何POI项或用户从导航栏中选择**新建**（**+**）操作时，将显示POI详情活动。此外，详情活动将允许用户创建新的POI、更新或删除现有POI。
- en: 'Keeping all the preceding use cases in mind, let''s create a new layout for
    POI details:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有前面的用例，让我们为POI详情创建一个新的布局：
- en: Select the `Resources/layout` folder in the **Solution** pad.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中选择`Resources/layout`文件夹。
- en: Right-click on **Add** and select **New File**.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**添加**并选择**新建文件**。
- en: In the **New File** dialog box, click on **Android** and select **Layout**,
    enter POI detail in the **Name** field, and select **New**.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框中，点击**Android**并选择**布局**，在**名称**字段中输入POI详情，然后选择**新建**。
- en: Notice that a new file is created with `LinearLayout` as the top-level container.
    The `POIDetail` view will have a number of fields and will likely require scrolling
    on devices with a smaller screen size. The default Android layout managers, such
    as `LinearLayout`, `RelativeLayout`, `FrameLayout`, or `TableLayout`, do not provide
    automatic scrolling when the content grows and the data goes beyond its actual
    screen size.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，已创建了一个新文件，其顶级容器为`LinearLayout`。`POIDetail`视图将包含多个字段，并且在小屏幕尺寸的设备上可能需要滚动。默认的Android布局管理器，如`LinearLayout`、`RelativeLayout`、`FrameLayout`或`TableLayout`，在内容增长且数据超出其实际屏幕大小时不提供自动滚动。
- en: In our previous chapter, for displaying the POI list, the layout gave us scrolling
    for free because we were using `ListView`; however, in the case of the POI detail
    activity, we need to use `ScrollView` for making the items scrollable.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的章节中，为了显示POI列表，布局为我们提供了免费滚动，因为我们使用了`ListView`；然而，在POI详情活动的案例中，我们需要使用`ScrollView`来使项目可滚动。
- en: Understanding ScrollView
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解`ScrollView`
- en: '`ScrollView` is a special kind of layout designed to hold a view larger than
    its actual size. When the child''s Views size grows beyond the `ScrollView` size,
    it automatically adds the scroll bar and can scroll vertically. The following
    are some of the key things you must to know before using ScrollView:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScrollView`是一种特殊的布局，用于容纳比其实际尺寸更大的视图。当子视图的大小超过`ScrollView`大小时，它会自动添加滚动条并可以垂直滚动。在使用`ScrollView`之前，你必须了解以下关键事项：'
- en: '`ScrollView` can hold at most one direct child. This means that if you have
    a complex layout with multiple children, then you must enclose them inside another
    standard layout, such as LinearLayout, TableLayout, or RelativeLayout.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`最多可以容纳一个直接子项。这意味着如果您有一个具有多个子项的复杂布局，那么您必须将它们包含在另一个标准布局中，例如`LinearLayout`、`TableLayout`或`RelativeLayout`。'
- en: Like any other standard layout manager, the `layout_height` and `layout_width`
    attributes can be used to adjust the height and width of `ScrollView`.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与任何其他标准布局管理器一样，可以使用`layout_height`和`layout_width`属性来调整`ScrollView`的高度和宽度。
- en: '`ScrollView` is ideal for screens where scrolling is required, but it is an
    overhead when scroll view is used to render a larger collection of data. For such
    instances, you should consider using specialized adapter views, such as `ListView`
    and `GridView`.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`对于需要滚动的屏幕来说很理想，但当滚动视图用于渲染大量数据时，它将增加开销。在这种情况下，您应考虑使用专门的适配器视图，如`ListView`和`GridView`。'
- en: Never place a `ListView` or `GridView` inside `ScrollView` because they both
    take care of their own vertical scrolling. By doing so, the `ListView` child will
    never receive gestures because it will be handled by the parent `ScrollView`.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 永远不要在`ScrollView`内放置`ListView`或`GridView`，因为它们都负责自己的垂直滚动。这样做的话，`ListView`子项将永远不会接收到手势，因为它将由父`ScrollView`处理。
- en: '`ScrollView` only supports vertical scrolling. For horizontal scrolling, you
    can use `HorizontalScrollView`.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScrollView`仅支持垂直滚动。对于水平滚动，可以使用`HorizontalScrollView`。'
- en: The `android:fillViewport` property defines whether the `ScrollView` should
    stretch its content to fill the viewport. You can set the same property by calling
    the `setFillViewport(true)` method on `ScrollView`.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:fillViewport`属性定义了`ScrollView`是否应该将其内容拉伸以填充视口。您可以通过在`ScrollView`上调用`setFillViewport(true)`方法来设置相同的属性。'
- en: 'Now that we understand `ScrollView`, let''s jump back to the `POIDetail` layout
    and add a `ScrollView` to support vertical scrolling of content for devices of
    smaller screen size:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了`ScrollView`，让我们回到`POIDetail`布局，并添加一个`ScrollView`以支持小屏幕尺寸设备的垂直内容滚动：
- en: With the `POIDetail.xaml` file opened in the `Content` view, select the top-level
    `LinearLayout` and press the *Delete* key.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Content`视图中打开`POIDetail.xaml`文件，选择顶级`LinearLayout`并按*Delete*键。
- en: In the **Toolbox** pad, locate the **ScrollView** widget and drag it onto the
    Content view.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**面板中，找到**ScrollView**小部件并将其拖动到内容视图。
- en: In the **Toolbox** pad, locate the **LinearLayout** (vertical) widget and drag
    it onto the Content view inside `ScrollView`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**面板中，找到**LinearLayout**（垂直）小部件并将其拖动到`ScrollView`内的内容视图中。
- en: With `LinearLayout` selected, set **Padding** in the Layout section of the **Properties**
    pad to `5dp`.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择`LinearLayout`后，在**属性**面板的布局部分设置**填充**为`5dp`。
- en: 'We are now ready to add labels and edit controls to the layout. The following
    screenshot depicts the layout we are trying to achieve:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好向布局中添加标签和编辑控件。以下截图显示了我们试图实现的布局：
- en: '![](img/PIsRjcV4.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/PIsRjcV4.jpg)'
- en: We will use simple `TextView` widgets to serve as labels and `EditText` widgets
    to serve as input controls. The `EditText` widget contains a number of properties
    that can be used to customize its behavior. One of these properties is named `InputType`,
    and it controls aspects such as which type of keyboard to use for inputs (alpha,
    numeric, and so on) and how many lines of text are allowed. The **Toolbox** pad
    presents a number of templates or preconfigured `EditText` widgets in the list
    under the group name **Text Fields**.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用简单的`TextView`小部件作为标签，并使用`EditText`小部件作为输入控件。`EditText`小部件包含一些可以用来自定义其行为的属性。其中一个属性名为`InputType`，它控制输入时使用的键盘类型（字母、数字等）以及允许的文本行数。**工具箱**面板在**文本字段**组名下提供了一些模板或预配置的`EditText`小部件。
- en: 'The following screenshot depicts the list:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了列表：
- en: '![](img/FJbX9Qgz.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/FJbX9Qgz.jpg)'
- en: 'Add a series of `TextView` and `EditText` controls to the **Name**, **Description**,
    and **Address** fields. Name the `EditText` widgets according to the following
    table and use the corresponding Toolbox widget so that the appropriate editing
    characteristics are applied:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 将一系列`TextView`和`EditText`控件添加到**名称**、**描述**和**地址**字段中。根据以下表格命名`EditText`小部件，并使用相应的工具箱小部件，以便应用适当的编辑特性：
- en: Name
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 名称
- en: Widget toolbox name
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件工具箱名称
- en: '`nameEditText`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameEditText`'
- en: '**Plain Text**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**纯文本**'
- en: '`descrEditText`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`descrEditText`'
- en: '**Multiline Text**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**多行文本**'
- en: '`addrEditText`'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`addrEditText`'
- en: '**Multiline Text**'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**多行文本**'
- en: We are now ready to address the **Latitude** and **Longitude** fields, and we
    will employ a new layout manager, `TableLayout`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备处理**纬度**和**经度**字段，我们将使用一个新的布局管理器`TableLayout`。
- en: Using the TableLayout manager
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用TableLayout管理器
- en: The `TableLayout` manager is an extension of `LinearLayout`. As the name indicates,
    `TableLayout` is used to align a child's View elements in rows and columns format.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableLayout`管理器是`LinearLayout`的扩展。正如其名所示，`TableLayout`用于以行和列格式对子视图元素进行对齐。'
- en: The concept of `TableLayout` works something similar to an HTML table. `TableLayout`
    consists of the `&lt;table&gt;` tag and `TableRow` is like a `&lt;tr&gt;` element.
    You can add any view or view group inside a table cell.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`TableLayout`的概念与HTML表格类似。`TableLayout`由`<table>`标签组成，`TableRow`类似于`<tr>`元素。您可以在表格单元格内添加任何视图或视图组。'
- en: 'We would like to add the **Latitude** and **Longitude** fields in a table.
    Let''s add a `TableLayout` with two rows and two columns with the top row being
    used for the labels and the bottom row being used for the edit fields. In order
    to do so, perform the following steps:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在表格中添加**纬度**和**经度**字段。让我们添加一个两行两列的`TableLayout`，顶部行用于标签，底部行用于编辑字段。为了做到这一点，请执行以下步骤：
- en: Locate `TableLayout` in the **Toolbox** pad, drag it onto the Content view below
    the `addrEditText` widget and drop it. A `TableLayout` will be created with three
    rows and three columns.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**面板中找到`TableLayout`，将其拖放到`addrEditText`小部件下方的**内容**视图中，并放下。将创建一个三行三列的`TableLayout`。
- en: Select one of the rows in `TableLayout`, right-click on it and select **Delete
    Row**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TableLayout`中选择一行，右键点击并选择**删除行**。
- en: Select one of the columns in the `TableLayout`, right-click on it and select
    **Delete Column**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`TableLayout`中选择一列，右键点击并选择**删除列**。
- en: Select the first column, right-click on and select **Stretch Column**. Similarly,
    do it for the second column.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一列，右键点击并选择**拉伸列**。同样，对第二列也进行此操作。
- en: 'You should now have a `TableLayout` with a visible outline of two rows, each
    having two columns like what is depicted in the following screenshot:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在应该有一个`TableLayout`，其可见轮廓为两行，每行有两个列，如下面的截图所示：
- en: '![](img/hGGSLbu3.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/hGGSLbu3.jpg)'
- en: We now need to add the `TextView` widgets for the two labels in the first row
    and number (decimal) widgets for the **Latitude** and **Longitude** edit controls,
    naming them `latEditText` and `longEditText`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要添加第一行中两个标签的`TextView`小部件和用于**纬度**和**经度**编辑控制的数字（十进制）小部件，分别命名为`latEditText`和`longEditText`。
- en: We have now completed the `POIDetail` layout, and the Content view you see should
    look the same as the preceding screenshot.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了`POIDetail`布局，您看到的**内容**视图应该与前面的截图相同。
- en: Working with EditText's InputType
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EditText的InputType
- en: 'The `EditText` element provides a property named `InputType` that checks the
    behavior of the control when data is being entered. When the description and address
    widgets were added, we selected **Multiline Text** from the **Toolbox** pad. The
    following code shows that in this case the `inputType` was automatically set:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText`元素提供了一个名为`InputType`的属性，该属性检查在输入数据时控件的行为。当添加描述和地址小部件时，我们从**工具箱**面板选择了**多行文本**。以下代码显示在这种情况下`inputType`被自动设置：'
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The `InputType` property can also be set or changed from within the **Properties**
    pad under the **Widget** tab in the **Input Format** section. What may not be
    obvious is that `inputType` can combine values, which come in handy in our situation.
    The following table shows a reasonable set of values for `inputType`; feel free
    to experiment:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`InputType` 属性也可以在**输入格式**部分的**Widget**选项卡下的**属性**面板中设置或更改。可能不明显的是，`inputType`可以组合值，这在我们的情况下非常有用。以下表格显示了`inputType`的合理值集；请随意实验：'
- en: Widget
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件
- en: Input type
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 输入类型
- en: '`nameEditText`'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`nameEditText`'
- en: '`inputType="textCapWords"`'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputType="textCapWords"`'
- en: '`descrEditText`'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`descrEditText`'
- en: '`inputType="textMultiLine|textCapSentences"`'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputType="textMultiLine|textCapSentences"`'
- en: '`addrEditText`'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '`addrEditText`'
- en: '`inputType="textMultiLine"`'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputType="textMultiLine"`'
- en: '`latEditText`'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`latEditText`'
- en: '`inputType="numberDecimal|numberSigned"`'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputType="numberDecimal|numberSigned"`'
- en: '`longEditText`'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`longEditText`'
- en: '`inputType="numberDecimal|numberSigned"`'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`inputType="numberDecimal|numberSigned"`'
- en: 'Switch to the Code view to see what has been added to the layout:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 切换到代码视图以查看已添加到布局的内容：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Creating POIDetailActivity
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建POIDetailActivity
- en: 'Now that we have the `POIDetail` layout ready, we need a corresponding activity.
    Perform the following steps to create a new activity for the POI details:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`POIDetail`布局，我们需要一个相应的活动。按照以下步骤创建一个新的POI详情活动：
- en: With the `POIApp` project selected in the **Solution** pad, right-click on it
    and navigate to **Add** | **New File**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中选择`POIApp`项目，右键点击并导航到**添加** | **新建文件**。
- en: In the **New File** dialog, click on **Android** and select **Activity**, enter
    `POIDetailActivity` as **Name**, and click on **New**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新建文件** 对话框中，点击 **Android** 并选择 **Activity**，将 **名称** 输入为 `POIDetailActivity`，然后点击
    **新建**。
- en: 'As you may recall from Chapter 3, *Creating the Points Of Interest App*, one
    of the first things that needs to be done when an activity is created is to set
    the layout content, which is accomplished by calling `SetContentView(layoutId)`.
    Add the following line of code to the `OnCreate()` method of the `POIDetailActivity`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第 3 章中回忆起的，在创建活动时需要做的第一件事之一是设置布局内容，这是通过调用 `SetContentView(layoutId)` 来实现的。将以下行代码添加到
    `POIDetailActivity` 的 `OnCreate()` 方法中：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding navigation to POIDetailActivity
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将导航添加到 POIDetailActivity
- en: There are two scenarios where we need to navigate from `POIListActivity` to
    `POIDetailActivity`, either by selecting the **New** action on the navigation
    bar or by selecting any of the POIs from the list. The main difference between
    the two scenarios is that when selecting an existing POI from the list, we will
    have to pass the details of the selected POI to the `POIDetailActivity` so that
    the user can edit and update the POI record. When creating a new POI, we don't
    pass any data. Let's first choose the simplest one, and add the navigation to
    the **New** action.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 有两种情况需要从 `POIListActivity` 导航到 `POIDetailActivity`，要么是通过在导航栏上选择 **新建** 操作，要么是通过从列表中选择任何
    POI。这两种情况的主要区别在于，当从列表中选择现有的 POI 时，我们必须将所选 POI 的详细信息传递给 `POIDetailActivity`，以便用户可以编辑和更新
    POI 记录。在创建新的 POI 时，我们不传递任何数据。让我们先选择最简单的一种，并将导航添加到 **新建** 操作中。
- en: The `Activity` class provides a method named `StartActivity()` that is used
    to start a new activity. The `StartActivity()` method can also be used in a number
    of different scenarios. In case of the **New** action, we will be using it in
    its most basic form. For starting an activity, all that we need to do is to invoke
    `StartActivity()` by passing the type for the activity we want to start.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity` 类提供了一个名为 `StartActivity()` 的方法，用于启动新的活动。`StartActivity()` 方法也可以在许多不同的场景中使用。在
    **新建** 操作的情况下，我们将使用其最基本的形式。要启动一个活动，我们只需要通过传递我们想要启动的活动类型来调用 `StartActivity()`。'
- en: 'The following code snippet demonstrates the code that needs to be added to
    the placeholder that we added to `POIListActivity` in the `OnOptionsItemSelected()`
    method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段演示了需要在 `OnOptionsItemSelected()` 方法中添加到 `POIListActivity` 中占位符的代码：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now run the app on the Android device or simulator and see what we have
    built so far. In `POIListActivity`, click on the **New** button on the navigation
    bar, and notice that the newly created `POIDetailActivity` is opened:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将应用程序运行在 Android 设备或模拟器上，看看我们到目前为止已经构建了什么。在 `POIListActivity` 中，点击导航栏上的
    **新建** 按钮，注意新创建的 `POIDetailActivity` 已经打开：
- en: '![](img/LSCs9ILv.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/LSCs9ILv.jpg)'
- en: Navigation on the POIList item click
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 POI 列表项点击时的导航
- en: In the second scenario, we need to pass the details of the POI to display `POIDetailActivity`.
    To accomplish this, we will use the `Intent` class. The `Intent` class can be
    used in conjunction with `StartActivity()` in order to launch a new activity and
    pass information about the activity to be launched. We will use the `Intent` class
    to launch `POIDetailActivity` and pass the details of the selected POI.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们需要传递 POI 的详细信息以显示 `POIDetailActivity`。为了完成这个任务，我们将使用 `Intent` 类。`Intent`
    类可以与 `StartActivity()` 结合使用，以便启动新的活动并传递有关要启动的活动的信息。我们将使用 `Intent` 类来启动 `POIDetailActivity`
    并传递所选 POI 的详细信息。
- en: 'First, we need to construct an instance of `Intent` by providing the current
    activity context and the type of target activity that will receive the intent;
    in our case, `POIDetailActivity`. The following code demonstrates how to properly
    construct the intent:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要通过提供当前活动上下文和将要接收意图的目标活动类型来构造一个 `Intent` 实例；在我们的情况下，是 `POIDetailActivity`。以下代码演示了如何正确构造意图：
- en: '[PRE4]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Intent` object has an `Extras` property that is used to send extra data
    as a bundle from one activity to another. The `Intent` class provides a series
    of overloaded versions of the `PutExtra()` method, which allows you to add various
    types of **key/value** pairs to the `Extras` property. The values can be of any
    primitive types such as `int`, `boolean`, `char`, `string`, `double`, `float`,
    `long`, and so on. For example, to add the string data type, you can use the following
    syntax:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`对象有一个`Extras`属性，用于将额外数据作为包从一个活动发送到另一个活动。`Intent`类提供了一系列重载的`PutExtra()`方法，允许你向`Extras`属性添加各种类型的**键/值**对。值可以是任何原始类型，如`int`、`boolean`、`char`、`string`、`double`、`float`、`long`等。例如，要添加字符串数据类型，可以使用以下语法：'
- en: '[PRE5]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: For `POIApp`, we need to add all of the properties of the selected `PointOfInterest`
    object. Instead of passing each property with a distinct key, we can further simplify
    this process using the **Json.NET** component. It serializes the `PointOfInterest`
    .NET object into a JSON string that can be passed to `POIDetailActivity` with
    the distinct key `poi`, and at the receiver end, we will deserialize it back to
    the `PointOfInterest` object.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`POIApp`，我们需要添加所选`PointOfInterest`对象的全部属性。而不是使用不同的键传递每个属性，我们可以进一步简化此过程，使用**Json.NET**组件。它将`PointOfInterest`
    .NET对象序列化为JSON字符串，可以通过具有不同键`poi`传递给`POIDetailActivity`，在接收端，我们将它反序列化回`PointOfInterest`对象。
- en: Apart from using the `Intent` bundle, there are various other options to pass
    data between activities. For complex objects, serializing using the Json.NET component
    and passing data bundles using Internet is not a recommended option. The size
    limit for the Android intent bundle is limited to somewhere around 1 MB, so you
    should always be cautioned about your data limits. You may consider using any
    of the other alternatives for better performance.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`Intent`包外，还有各种其他选项可以在活动之间传递数据。对于复杂对象，使用Json.NET组件进行序列化并通过互联网传递数据包不是一个推荐选项。Android
    intent包的大小限制大约为1 MB，因此你应该始终注意你的数据限制。你可以考虑使用其他任何替代方案以获得更好的性能。
- en: 'Some of my recommendations are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我的以下建议如下：
- en: Write the data to a file and pass only the file path to the second activity.
    The second activity can access the content using the same file path.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入文件，并只传递文件路径给第二个活动。第二个活动可以使用相同的文件路径访问内容。
- en: Use SQLite to store the object in a table. Pass only the unique ID or query
    a parameter to the second activity. The second activity can access the data by
    reading from the database.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLite将对象存储在表中。只传递唯一的ID或查询一个参数给第二个活动。第二个活动可以通过从数据库中读取来访问数据。
- en: Create a singleton class to hold the data. The second activity can directly
    access the data using a singleton instance.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个单例类来保存数据。第二个活动可以直接通过单例实例访问数据。
- en: 'In our case, the POI object is tiny. We are happy to go with the `Intent` bundle
    approach. The following code syntax converts the selected `PointOfInterest` object
    to a JSON string using the `SerializeObject()` method of the `JsonConvert` class
    and adds it to `Intent` using the `PutExtra()` method:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，POI对象很小。我们很高兴采用`Intent`包方法。以下代码语法使用`JsonConvert`类的`SerializeObject()`方法将选定的`PointOfInterest`对象转换为JSON字符串，并使用`PutExtra()`方法将其添加到`Intent`中：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The last step is a call to `StartActivity()`, passing in the `Intent` class
    we created in the earlier step:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是调用`StartActivity()`，传入我们在早期步骤中创建的`Intent`类：
- en: '[PRE7]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'With this, your POIListActivity `OnListItemClick` should have the following
    code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你的POIListActivity的`OnListItemClick`应该有如下代码：
- en: '[PRE8]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now that we have passed the data from `POIListActivity`, let's now access the
    POI object from the `POIDetailActivity` class.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经从`POIListActivity`传递了数据，现在让我们从`POIDetailActivity`类中访问POI对象。
- en: Receiving the data in POIDetailActivity
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在POIDetailActivity中接收数据
- en: When we get to the `OnCreate()` method of the `POIDetailActivity`, we need to
    access the `PointOfInterest` object sent from `POIListActivity`. This object will
    be used to display the details of the selected POI. The following section will
    walk you through the process of retrieving the extra bundle metadata from `Intent`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们到达`POIDetailActivity`的`OnCreate()`方法时，我们需要访问从`POIListActivity`发送的`PointOfInterest`对象。此对象将用于显示所选POI的详细信息。以下部分将指导您通过检索`Intent`中的额外包元数据的过程。
- en: Each activity has an `Intent` property that contains the intent and the corresponding
    information that was passed while starting the activity. The `Intent` class provides
    a number of methods to access any of the `Extras` bundle data by providing the
    corresponding keys. Before we retrieve the data, we can confirm whether the value
    for the specified key is available by calling the `HasExtra ("poi")` method. The
    `HasExtra` method returns a `boolean` value; if it returns `false`, we can assume
    that we are creating a new POI; otherwise, we need to retrieve the value of the
    extra.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 每个活动都有一个包含intent和启动活动时传递的相应信息的`Intent`属性。`Intent`类提供了一系列方法，通过提供相应的键来访问任何`Extras`包数据。在我们检索数据之前，我们可以通过调用`HasExtra("poi")`方法来确认指定键的值是否可用。`HasExtra`方法返回一个`boolean`值；如果它返回`false`，我们可以假设我们正在创建一个新的POI；否则，我们需要检索额外的值。
- en: The `Intent` class has a series of `GetXXExtra()` methods, where `XX` represents
    the type for the value of a key/value pair. In our case, we can use the `GetStringExtra()`
    method on the intent to get the `poiJson` string passed in from `POIListActivity`.
    The `GetStringExtra()` method accepts a string (which is the key from the key/value
    pair originally set on the intent) and returns the value associated with the key.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`Intent`类有一系列`GetXXExtra()`方法，其中`XX`代表键/值对值的类型。在我们的情况下，我们可以使用`GetStringExtra()`方法在intent上获取从`POIListActivity`传递过来的`poiJson`字符串。`GetStringExtra()`方法接受一个字符串（这是最初在intent上设置的键/值对中的键），并返回与该键关联的值。'
- en: 'Let''s declare a `PointOfIntrest` variable to hold the POI object received
    from `POIListActivity`:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们声明一个`PointOfIntrest`变量来保存从`POIListActivity`接收到的POI对象：
- en: '[PRE9]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following listing to the `OnCreate()` method of `POIDetailActivity`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下列表添加到`POIDetailActivity`的`OnCreate()`方法中：
- en: '[PRE10]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Binding variables to controls
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将变量绑定到控件上
- en: 'As we learned in the previous chapter, we need to manually bind user interface
    widgets to internal program references in order to manipulate their content, assign
    event handlers, and so on. Declare a set of private variables for each of the
    input widgets we created in the layout. The following listing is from the source
    folder:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所学，我们需要手动将用户界面小部件绑定到内部程序引用，以便操作其内容、分配事件处理器等。为我们在布局中创建的每个输入小部件声明一组私有变量。以下列表来自源文件夹：
- en: '[PRE11]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'A call to `FindViewById&lt;T&gt;` is required to bind each variable to its
    corresponding user interface widget. The following listing depicts what should
    be added to the `OnCreate()` method somewhere after the call to `SetContentView()`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 需要调用`FindViewById<T>`来将每个变量绑定到相应的用户界面小部件。以下列表描述了应该在`SetContentView()`调用之后添加到`OnCreate()`方法中的内容：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Populating user interface widgets
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 填充用户界面小部件
- en: At this point, we have a reference to the `PointOfInterest` object, but we have
    not taken any action to populate the content on UI. Populating the POI details
    on UI is a pretty straightforward process.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经有了一个`PointOfInterest`对象的引用，但我们还没有采取任何行动来填充UI上的内容。在UI上填充POI详情是一个相当直接的过程。
- en: The `EditText` widget has a property named `Text`, which we can set to initialize
    the content for the widget. Let's create a simple method named `UpdateUI()`, which
    takes care of populating the POI details on the user interface widgets.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText`小部件有一个名为`Text`的属性，我们可以将其设置为初始化小部件的内容。让我们创建一个名为`UpdateUI()`的简单方法，它负责在用户界面小部件上填充POI详情。'
- en: 'The following listing shows what is needed for `UpdateUI()`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了`UpdateUI()`所需的内容：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Call the `UpdateUI()` method at the end of the `OnCreate()` callback.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在`OnCreate()`回调的末尾调用`UpdateUI()`方法。
- en: 'You should be able to run `POIApp` now, and test the navigation by clicking
    on any one of the list rows in `POIListActivity`. Notice that the `POIDetailActivity`
    will display the details of the selected POI object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您应该能够运行`POIApp`，并通过点击`POIListActivity`中的任何一行来测试导航。请注意，`POIDetailActivity`将显示所选POI对象的详情：
- en: '![](img/V733e2Kh.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/V733e2Kh.jpg)'
- en: Adding the save and delete actions
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加保存和删除操作
- en: 'Using `POIDetailActivity`, users can choose to save or delete POIs. The same
    Save button works for two scenarios: when the POI details are passed from `POIListActivity`,
    it will update the POI details; otherwise, it will create a new record.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`POIDetailActivity`，用户可以选择保存或删除POI。相同的保存按钮适用于两种场景：当POI详情从`POIListActivity`传递过来时，它将更新POI详情；否则，它将创建一条新记录。
- en: 'We need a way to accomplish these tasks from the user interface. Let''s use
    `ActionBar` and add two actions: `Save` and `Delete`. Create a new file named
    `POIDetailMenu.xml` under the `Resources/menu` directory to declare the menu layout.
    The following listing shows what is needed for `POIDetailMenu.xml`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一种从用户界面完成这些任务的方法。让我们使用`ActionBar`并添加两个操作：`Save`和`Delete`。在`Resources/menu`目录下创建一个名为`POIDetailMenu.xml`的新文件来声明菜单布局。以下列表显示了`POIDetailMenu.xml`所需的内容：
- en: '[PRE14]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note that each menu item has an icon specified. These icons can be found in
    the code bundle `Assets` folder.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，每个菜单项都有一个指定的图标。这些图标可以在代码包的`Assets`文件夹中找到。
- en: 'We need to override both the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()`
    methods. This is very similar to what we created in Chapter 4, *Adding a ListView*.
    Add the following code snippets to the `POIDetailActivity` class:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`OnCreateOptionsMenu()`和`OnOptionsItemSelected()`方法。这与我们在第4章*添加ListView*中创建的非常相似。将以下代码片段添加到`POIDetailActivity`类中：
- en: '[PRE15]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You may notice that, in the previous code snippets, we introduced two new methods:
    `SavePOI()` and `DeletePOI()`. Both of these methods are used to keep the `OnOptionsItemSelected()`
    method clean and concise. The `SavePOI()` and `DeletePOI()` methods encapsulate
    the logic required to save or delete the POI object.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会注意到，在前面的代码片段中，我们引入了两个新方法：`SavePOI()`和`DeletePOI()`。这两个方法都用于保持`OnOptionsItemSelected()`方法简洁。`SavePOI()`和`DeletePOI()`方法封装了保存或删除POI对象所需的逻辑。
- en: Disabling the delete action
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用删除操作
- en: One thing that's different in `POIDetailView` is that we have a scenario where
    we need to disable the `Delete` action. If a new POI is being created, the `Delete`
    action should not be allowed. First, we need to get the reference of the menu
    item inside the `OnPrepareOptionsMenu()` method, and then we can call the `SetEnabled(bool)`
    method by passing your preference to enable or disable the menu action.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`POIDetailView`中有一点不同，我们需要一个场景来禁用`Delete`操作。如果一个新POI正在创建，则不应允许删除操作。首先，我们需要在`OnPrepareOptionsMenu()`方法中获取菜单项的引用，然后我们可以通过传递您的偏好来调用`SetEnabled(bool)`方法以启用或禁用菜单操作。
- en: The `IMenu` class provides a `FindItem()` method that can be used to obtain
    a reference to a specific IMenuItem, which in turn provides the `SetEnabled()`
    method for enabling and disabling actions. Disabling a menu item makes the button
    nonfunctional; however, it will still be visible on the screen. For better user
    experience, let's hide the `Delete` action completely by calling the `SetVisible(false)`
    method.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMenu`类提供了一个`FindItem()`方法，可以用来获取特定`IMenuItem`的引用，该引用提供了用于启用和禁用操作的`SetEnabled()`方法。禁用菜单项会使按钮失效；然而，它仍然会显示在屏幕上。为了更好的用户体验，让我们通过调用`SetVisible(false)`方法完全隐藏`Delete`操作。'
- en: 'The following listing shows how to disable the `Delete` action when a new POI
    is being entered:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了在输入新POI时如何禁用`Delete`操作：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Adding the save and delete actions in POIService
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在POIService中添加保存和删除操作
- en: In Chapter 4, *Adding a ListView*, we created the specialized `POIService` class
    that handles the logic for downloading data using the `async` and `await` keywords
    in conjunction with `HttpClient`. For now, the `POIService` class has only one
    method `GetPoisListAsync()`, that deals with fetching the list of records from
    the REST web service. Let's extend its functionality to create a new or update
    and delete a POI. Let's first start with creating a POI.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4章*添加ListView*中，我们创建了专门的`POIService`类，该类使用`HttpClient`结合`async`和`await`关键字处理下载数据的逻辑。目前，`POIService`类只有一个方法`GetPoisListAsync()`，它处理从REST网络服务获取记录列表。让我们扩展其功能以创建新的或更新和删除POI。让我们首先从创建POI开始。
- en: Consuming the web service to create or update a POI
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费网络服务以创建或更新POI
- en: At this point, we have already deployed the web service provided in the book
    code bundle, and `POIApp` is already consuming the same web services to fetch
    the list of POIs. In this section, we will use the same web service to create
    a new or update an existing POI.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经在代码包中部署了提供的网络服务，并且`POIApp`已经消费了相同的网络服务来获取POI列表。在本节中，我们将使用相同的网络服务来创建新的POI或更新现有的POI。
- en: 'The following API specification is used to create a new or update an existing
    POI:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 以下API规范用于创建新的或更新现有的POI：
- en: '[PRE17]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Notice some of the key points in the preceding API specification: the request
    method is `POST`, Content-type is `application/json`, and the POI JSON object
    is sent as part of the request body. The `POST` method is an indication for the
    server application to lookup for the attached request content body, and the Content-Type
    describes the MIME type of the data the server is about to receive. In this case,
    the content type is `application/json`, which means that the server is expecting
    the POI details to be sent in the form of a JSON string.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面API规范中的关键点：请求方法是`POST`，Content-type是`application/json`，POI JSON对象作为请求体的一部分发送。`POST`方法指示服务器应用程序查找附加的请求内容体，Content-Type描述了服务器即将接收的数据的MIME类型。在这种情况下，内容类型是`application/json`，这意味着服务器期望以JSON字符串的形式发送POI详细信息。
- en: To create a new POI, we need to send the POI details such as name, description,
    latitude, longitude, and address while creating a new POI record. Once the POI
    is created, a unique ID will be created and assigned for each POI record. To update
    the existing POI record, we must send the POI ID along with the updated POI details
    as part of the request body.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的POI，我们需要在创建新的POI记录时发送POI的详细信息，如名称、描述、纬度、经度和地址。一旦POI被创建，将为每个POI记录创建并分配一个唯一的ID。要更新现有的POI记录，我们必须在请求体中发送POI
    ID以及更新的POI详细信息。
- en: Adding the CreateOrUpdatePOIAsync method to POIService
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`CreateOrUpdatePOIAsync`方法添加到`POIService`
- en: 'Now that we understand that the details of the web service can be used to create
    or update a POI record, let''s create a new `async` method named `CreateOrUpdatePOIAsync()`
    in the `POIService` class, and perform the following steps:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们了解到，可以使用网络服务的详细信息来创建或更新一个POI记录，那么让我们在`POIService`类中创建一个新的`async`方法，命名为`CreateOrUpdatePOIAsync()`，并执行以下步骤：
- en: 'Create a new `async` method `CreateOrUpdatePOIAsync()` that accepts the `PointOfInterest`
    instance. This holds the details of the POI that you need to send to the server
    in order to create or update the operation. This method returns `Task&lt;String&gt;`
    because the result of the create/update request is returned as a string:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`async`方法`CreateOrUpdatePOIAsync()`，它接受`PointOfInterest`实例。这个实例包含了你需要发送到服务器以创建或更新操作的POI的详细信息。此方法返回`Task<String>`，因为创建/更新请求的结果以字符串形式返回：
- en: '[PRE18]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Declare a string constant that represents the web service endpoint in order
    to create a new or update an existing POI:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个表示创建或更新现有POI的Web服务端点的字符串常量：
- en: '[PRE19]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Alternatively, you can use the following Apiary mock API URL, if you have not
    set up the web server code already:'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，如果你还没有设置Web服务器代码，可以使用以下Apiary模拟API URL：
- en: '[PRE20]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you might have noticed in the web service API specification, the server
    expects the POI details in a JSON string format. Hence, we need to serialize the
    POI object to a JSON using the Json.NET component:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如你可能已经在网络服务API规范中注意到的，服务器期望POI详细信息以JSON字符串格式提供。因此，我们需要使用Json.NET组件将POI对象序列化为JSON：
- en: '[PRE21]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code will convert the POI object to the following JSON format:'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码将POI对象转换为以下JSON格式：
- en: '[PRE22]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The preceding JSON string contains the uppercase keys, such as `Name`, `Address`,
    which are incompatible for a given web service API specification. For this, we
    can use the `ContractResolver` class from Json.NET to provide custom settings
    while serializing the POI object.
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的JSON字符串包含大写键，如`Name`、`Address`，这些键对于特定的网络服务API规范是不兼容的。为此，我们可以使用Json.NET的`ContractResolver`类在序列化POI对象时提供自定义设置。
- en: 'Declare an inner class named `POIContractResolver` inside `POIService` and
    extend it from `DefaultContractResolver`. Override the `ResolvePropertyName` method.
    You need to include the `Newtonsoft.Json.Serialization` namespace directive in
    the `POIService` class:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIService`内部声明一个名为`POIContractResolver`的内部类，并从`DefaultContractResolver`扩展它。重写`ResolvePropertyName`方法。你需要在`POIService`类中包含`Newtonsoft.Json.Serialization`命名空间指令：
- en: '[PRE23]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The preceding code snippet is self-explanatory. It resolves all the `PointOfInterest`
    object properties to lowercase JSON keys.
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述代码片段是自我解释的。它将所有`PointOfInterest`对象属性解析为小写JSON键。
- en: 'Now we can use the following code snippet to serialize the POI object into
    a JSON string with lowercase keys. Add the following listing to the `CreateOrUpdatePOIAsync`
    method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们可以使用以下代码片段将POI对象序列化为具有小写键的JSON字符串。将以下列表添加到`CreateOrUpdatePOIAsync`方法中：
- en: '[PRE24]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let us now asynchronously send the POI details JSON data using `HttpClient`
    class. The `HttpClient` class provides `PostAsync()` method that is used to sends
    a POST request to the specified URI as an asynchronous operation. The following
    code snippet demonstrates posting data to the server using the `HttpClient` class:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将异步发送 POI 详细信息的 JSON 数据，使用 `HttpClient` 类。`HttpClient` 类提供了 `PostAsync()`
    方法，该方法用于以异步操作向指定的 URI 发送 POST 请求。以下代码片段演示了使用 `HttpClient` 类向服务器发送数据：
- en: '[PRE25]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The preceding code block looks familiar to the `GetPoisListAsync` method but
    with some obvious differences. Here, we are calling `PostAsync` instead of the
    `GetAsync` method to send an asynchronous POST request. The `PostAsync` method
    accepts two parameters: a string representing a web service URL and an instance
    of `HttpContent` for the HTTP entity body. The `PostAsync` method accepts the
    different HTTP entity body formats such as `ByteArrayContent`, `MultipartContent`,
    `StreamContent`, and `StringContent`, representing the request body and content
    header. Here, in our case, we are sending the POI JSON as `StringContent`.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码块看起来与 `GetPoisListAsync` 方法相似，但有一些明显的区别。在这里，我们调用 `PostAsync` 而不是 `GetAsync`
    方法来发送异步 POST 请求。`PostAsync` 方法接受两个参数：一个表示 Web 服务 URL 的字符串和一个表示 HTTP 实体主体的 `HttpContent`
    实例。`PostAsync` 方法接受不同的 HTTP 实体主体格式，如 `ByteArrayContent`、`MultipartContent`、`StreamContent`
    和 `StringContent`，代表请求体和内容头。在这里，在我们的情况下，我们发送 POI JSON 作为 `StringContent`。
- en: Currently, the `CreateOrUpdatePOIAsync()` method prints the result of this operation
    on the console. Later in this chapter, we will see how to use the `CreateOrUpdatePOIAsync
    ()` method from `POIDetailActivity` to complete the save operation.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`CreateOrUpdatePOIAsync()` 方法会在控制台上打印此操作的结果。在本章的后面部分，我们将看到如何从 `POIDetailActivity`
    使用 `CreateOrUpdatePOIAsync ()` 方法来完成保存操作。
- en: Consuming the web service to delete the POI
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费 Web 服务以删除 POI
- en: 'To delete the POI from the server, the client needs to send the information
    about the POI to be deleted. As all the POI records are uniquely assigned with
    a unique ID property, we just need to pass the ID of the POI to be deleted. Let''s
    understand the following API specification used to delete the POI:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要从服务器删除 POI，客户端需要发送关于要删除的 POI 的信息。由于所有 POI 记录都唯一分配了具有唯一 ID 属性的唯一标识符，我们只需传递要删除的
    POI 的 ID。让我们了解以下用于删除 POI 的 API 规范：
- en: '[PRE26]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: From the preceding API specification, the request method is `DELETE` and the
    web service requires the POI ID to be passed to the end of the URL for the server
    to know which POI to be deleted. As we are not sending any data to the request
    body, we don't need to specify the `Content-Type` request header. The result of
    the operation is that this API responds back with a `Success` or `Failure` plain
    text message.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的 API 规范中，请求方法是 `DELETE`，Web 服务需要将 POI ID 传递到 URL 的末尾，以便服务器知道要删除哪个 POI。由于我们不需要向请求体发送任何数据，因此我们不需要指定
    `Content-Type` 请求头。操作的结果是，此 API 会以 `Success` 或 `Failure` 纯文本消息的形式返回。
- en: Adding the DeletePOIAsync method to POIService
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 DeletePOIAsync 方法添加到 POIService
- en: 'Consuming the web service to delete a POI is similar to the `GetPoisListAsync()`
    method implementation. The following steps will help you create a new `async`
    method and consume the web service to delete the POI:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 消费 Web 服务以删除 POI 与 `GetPoisListAsync()` 方法实现类似。以下步骤将帮助您创建一个新的 `async` 方法，并消费
    Web 服务以删除 POI：
- en: 'Create a new `async` method `DeletePOIAsync()` that accepts an integer value
    `poiId` that represents a unique `PointOfInterest` object:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `async` 方法 `DeletePOIAsync()`，该方法接受一个整数值 `poiId`，它代表一个唯一的 `PointOfInterest`
    对象：
- en: '[PRE27]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Declare a string constant that represents the URL to web service API for the
    delete action:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个表示用于删除操作的 Web 服务 API URL 的字符串常量：
- en: '[PRE28]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that the `DELETE_POI` string expects the `poiId` parameter to end of
    the URL. This is the ID of the POI to be deleted from the server.
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，`DELETE_POI` 字符串期望 `poiId` 参数位于 URL 的末尾。这是要从服务器删除的 POI 的 ID。
- en: 'Alternatively, you can use the following Apiary test URL:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，您可以使用以下 Apiary 测试 URL：
- en: '[PRE29]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s now proceed to create an instance of `HttpClient` and to delete the
    POI from the server. Add the following code snippets to the `DeletePOIAsync()`
    method:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将创建一个 `HttpClient` 实例，并从服务器删除 POI。将以下代码片段添加到 `DeletePOIAsync()` 方法中：
- en: '[PRE30]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the preceding code snippet, the `DeleteAsync()` method sends a delete request
    asynchronously to the specified **Uniform Resource Identifier** (**URI**), and
    the result of this operation is printed on the console.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，`DeleteAsync()` 方法异步地向指定的**统一资源标识符**（**URI**）发送删除请求，并将此操作的结果打印在控制台上。
- en: Creating SavePOI()
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SavePOI()
- en: Notice that in the previous step, in the *Adding Save and Delete action* section,
    we are calling the `SavePOI()` and `DeletePOI()` actions from the `OnOptionsItemSelected()`
    method, but we haven't declared them at all. These two methods will deal with
    consuming web services to create, update, and delete the POI. The following sections
    will take you through both the `SavePOI()` and `DeletePOI()` actions.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在上一个步骤中，在*添加保存和删除操作*部分，我们从 `OnOptionsItemSelected()` 方法中调用了 `SavePOI()` 和
    `DeletePOI()` 操作，但我们根本就没有声明它们。这两个方法将处理消耗网络服务以创建、更新和删除 POI。接下来的部分将向您介绍 `SavePOI()`
    和 `DeletePOI()` 操作。
- en: Let's now declare a new method `SavePOI()` in the `POIDetailActivity` class.
    The `SavePOI()` method could avoid placing a lot of logic in the `OnOptionsItemSelected()`
    method. This method will validate the user input and initiate the server request
    to create or update the POI.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将在 `POIDetailActivity` 类中声明一个新的方法 `SavePOI()`。`SavePOI()` 方法可以避免在 `OnOptionsItemSelected()`
    方法中放置过多的逻辑。此方法将验证用户输入并启动服务器请求以创建或更新 POI。
- en: 'We will cover the field validation in an upcoming section and now focus on
    getting the user data from the screen and initiate a create/update request. The
    following listing shows what should be present in `SavePOI()`:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下一节中介绍字段验证，现在我们专注于从屏幕获取用户数据并启动创建/更新请求。以下列表显示了 `SavePOI()` 中应该包含的内容：
- en: '[PRE31]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Notice that we are calling a new method, that is, `CreateOrUpdatePOIAsync()`
    from `SavePOI()`. We need to add the `CreateOrUpdatePOIAsync()` to `POIDetailActivity`.
    It is an `async` method, which will take care of initializing the `POIService`
    class and initiating the web service request to save the POI.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在 `SavePOI()` 中调用了一个新方法，即从 `SavePOI()` 调用的 `CreateOrUpdatePOIAsync()`。我们需要将
    `CreateOrUpdatePOIAsync()` 添加到 `POIDetailActivity` 中。它是一个 `async` 方法，将负责初始化 `POIService`
    类并启动保存 POI 的网络服务请求。
- en: 'The following code snippet listing shows what should be present in the `CreateOrUpdatePOIAsync()`
    method:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段列表显示了 `CreateOrUpdatePOIAsync()` 方法中应该包含的内容：
- en: '[PRE32]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Notice that the preceding method does the following tasks:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，前面提到的方法执行以下任务：
- en: First, it creates an instance of the `POIService` class and confirms the network
    availability by calling the `isConnected()` method.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它创建一个 `POIService` 类的实例并通过调用 `isConnected()` 方法确认网络可用性。
- en: If a device is not connected to the Internet, it shows an appropriate `Toast`
    message to the user.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果设备未连接到互联网，它将向用户显示适当的 `Toast` 消息。
- en: If the network is available, it calls the `CreateOrUpdatePOIAsync()` method,
    which is defined in the `POIService` class. The web service request can be a long-running
    blocking operation, and hence, we are using **async await** to make the request
    asynchronous.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果网络可用，它将调用 `CreateOrUpdatePOIAsync()` 方法，该方法定义在 `POIService` 类中。网络服务请求可能是一个长时间运行的阻塞操作，因此我们使用
    **async await** 来使请求异步。
- en: A toast message is displayed to notify the user about the result of the save/update
    operation.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示一个吐司消息来通知用户保存/更新操作的结果。
- en: Once the save request is successful, it displays a toast message and calls the
    activity `Finish()` method. The `Finish()` method causes the `POIDetailActivity`
    activity to be closed, and the previous activity on the stack will be brought
    back to the foreground; in our case, `POIListActivity`.
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦保存请求成功，它将显示一个吐司消息并调用活动的 `Finish()` 方法。`Finish()` 方法导致 `POIDetailActivity`
    活动关闭，并将堆栈中的上一个活动带到前台；在我们的例子中是 `POIListActivity`。
- en: Creating DeletePOI()
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 DeletePOI()
- en: Like `SavePOI()`, the `DeletePOI()` method was created to simplify the logic
    in `OnOptionsItemSelected()`. Before deleting the POI, we must ask the user to
    reconfirm by showing a dialog. Later in this chapter, we will show you how to
    display a confirmation prompt before initiating the deleted request.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `SavePOI()` 类似，`DeletePOI()` 方法被创建是为了简化 `OnOptionsItemSelected()` 中的逻辑。在删除
    POI 之前，我们必须通过显示对话框来要求用户重新确认。在本章的后面部分，我们将向您展示如何在启动删除请求之前显示确认提示。
- en: We created the `CreateOrUpdatePOIAsync()` method in `POIDetailActivity`, let's
    now add another new method named `DeletePOIAsync()`. This method performs pretty
    much the same task as the `CreateOrUpdatePOIAsync()` method does in `POIDetailActivity`.
    It checks for the Internet connection availability, initiates the delete operation
    asynchronously, and finally, notifies the user with a toast message.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `POIDetailActivity` 中创建了 `CreateOrUpdatePOIAsync()` 方法，现在让我们添加另一个新方法，名为
    `DeletePOIAsync()`。此方法执行的任务与 `POIDetailActivity` 中的 `CreateOrUpdatePOIAsync()`
    方法非常相似。它检查互联网连接的可用性，异步启动删除操作，并最终通过 toast 消息通知用户。
- en: 'Add the following `DeletePOIAsync` method to your `POIDetailActivity` class:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下 `DeletePOIAsync` 方法添加到你的 `POIDetailActivity` 类中：
- en: '[PRE33]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The following listing shows what should be present in the `DeletePOI()` method:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表显示了 `DeletePOI()` 方法中应该存在的内容：
- en: '[PRE34]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s now build and run the app. You should now be able to perform the add,
    update, and delete operations:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们构建并运行这个应用。你现在应该能够执行添加、更新和删除操作：
- en: '![](img/JAsfJjf8.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/JAsfJjf8.jpg)'
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: If you're using the Apiary mock feed URL for the save and delete operation,
    no POI will be deleted or saved. Apiary is just used for testing purpose only.
    You must deploy the web service code bundle provided in this book for the `Save`
    and `Delete` action to take effect on the server data.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 Apiary 模拟数据 URL 进行保存和删除操作，则不会删除或保存任何 POI。Apiary 仅用于测试目的。你必须部署本书中提供的网络服务代码包，以便
    `保存` 和 `删除` 操作对服务器数据进行生效。
- en: Adding validation
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加验证
- en: 'Any nontrivial app will have some level of the validation required. The `POIApp`
    app is somewhat trivial, but we have a small set of rules we need to enforce that
    will facilitate the discussion:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 任何非平凡的应用都会有一定程度的验证需求。`POIApp` 应用相对简单，但我们有一组需要强制执行的规则，这将有助于讨论：
- en: Property
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 属性
- en: Rule
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 规则
- en: '`Name`'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '`名称`'
- en: This cannot be empty or null
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这不能为空或为空值
- en: '`Latitude`'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`纬度`'
- en: This contains a valid decimal number between `-90` and `90`
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含一个在 `-90` 和 `90` 之间的有效十进制数
- en: '`Longitude`'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`经度`'
- en: This contains a valid decimal number between `-180` and `180`
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这包含一个在 `-180` 和 `180` 之间的有效十进制数
- en: Using the EditText.Error property
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 `EditText.Error` 属性
- en: 'The `EditText` widget has a string property named `Error`, which simplifies
    the effort of displaying errors to the user, particularly if you want to be able
    to show all the fields with errors at once. The following screenshot displays
    the error received for leaving the **Name** field empty:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditText` 小部件有一个名为 `Error` 的字符串属性，它简化了向用户显示错误的工作，尤其是如果你想一次性显示所有带有错误的字段时。以下截图显示了因留空
    **名称** 字段而接收到的错误：'
- en: '![](img/TAoykf1S.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![](img/TAoykf1S.jpg)'
- en: 'To use this facility, simply set the property to an error message and clear
    the property when no errors exist. The following example demonstrates implementing
    the rule for the **Name** property:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，只需将属性设置为错误消息，当不存在错误时清除属性。以下示例演示了为 **名称** 属性实现规则的实现：
- en: '[PRE35]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Notice the local Boolean variable named `errors`, which is used to keep track
    of whether any errors have been found. Edits for **Latitude** and **Longitude**
    are a little more involved, as you need to account for converting text to a `double`
    value and allow a `null` value to be specified.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 注意名为 `errors` 的局部布尔变量，它用于跟踪是否找到任何错误。对于 **纬度** 和 **经度** 的编辑稍微复杂一些，因为你需要将文本转换为
    `double` 值，并允许指定 `null` 值。
- en: 'The following code demonstrates one of the approaches to implement the edits:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了实现编辑的一种方法：
- en: '[PRE36]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Implement the rules identified at the start of this section in the `SavePOI()`
    method using the `EditText.Error` property.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `EditText.Error` 属性在 `SavePOI()` 方法中实现本节开头确定的规则。
- en: 'You can update and save the POI properties only if all of the edits are passed.
    The following listing shows one of the ways to structure the logic:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当所有编辑都通过时，你才能更新和保存 POI 属性。以下列表显示了结构化逻辑的一种方法：
- en: '[PRE37]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run `POIApp` and confirm that the validations are working correctly.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `POIApp` 并确认验证是否正确工作。
- en: Adding a delete confirmation prompt
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加删除确认提示
- en: It's a best practice for apps to provide a confirmation before performing any
    type of destructive update, particularly if it cannot be undone. As such we need
    to provide a confirmation for the `Delete` action. Fortunately, Android makes
    this relatively easy with the `AlertDialog` and `AlertDialog.Builder` classes.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用来说，在执行任何类型的破坏性更新之前提供确认是一个最佳实践，尤其是如果无法撤销的话。因此，我们需要为 `删除` 操作提供确认。幸运的是，Android
    通过 `AlertDialog` 和 `AlertDialog.Builder` 类使这相对容易。
- en: 'The `AlertDialog` class allows you to display a modal confirmation dialog.
    The `AlertDialog.Builder` class is an embedded class that helps you construct
    an instance of an `AlertDialog` method; you can think of it as a factory class.
    The steps are as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`AlertDialog`类允许您显示一个模态确认对话框。`AlertDialog.Builder`类是一个嵌套类，它帮助您构建一个`AlertDialog`实例的方法；您可以将其视为一个工厂类。步骤如下：'
- en: Create an instance of `AlertDialog.Builder`.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`AlertDialog.Builder`实例。
- en: Set various properties on the builder instance, such as the message, the button
    text, the calling of event handlers when a button is clicked, and so on.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建器实例上设置各种属性，如消息、按钮文本、当按钮被点击时调用事件处理器等。
- en: Call `Show()` on the instance of `AlertDialog.Builder` to create and display
    an instance of `AlertDialog`.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AlertDialog.Builder`的实例上调用`Show()`以创建并显示`AlertDialog`实例。
- en: In our case, we want an `AlertDialog` class with a simple message and an **OK**
    and **Cancel** button. When we click on **Cancel**, we simply need to close the
    dialog and do nothing. When the user selects **OK**, we need to initiate the delete
    POI operation.
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在我们的案例中，我们想要一个包含简单消息以及**OK**和**Cancel**按钮的`AlertDialog`类。当我们点击**Cancel**时，我们只需关闭对话框并什么都不做。当用户选择**OK**时，我们需要启动删除POI操作。
- en: 'Create an event handler that will be called when you click on the **OK** button.
    This method will now call `DeletePOIAsync()` to perform the delete operation.
    The following listing depicts these changes:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个事件处理器，当您点击**OK**按钮时将被调用。此方法现在将调用`DeletePOIAsync()`以执行删除操作。以下列表展示了这些更改：
- en: '[PRE38]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the logic that constructs the `AlertDialog` class into the existing `DeletePOI()`
    method. The following listing depicts this logic:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将构建`AlertDialog`类的逻辑添加到现有的`DeletePOI()`方法中。以下列表展示了这个逻辑：
- en: '[PRE39]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `SetPositiveButton()` and `SetNegativeButton()` methods allow button captions
    and event handlers to be specified. In the case of the *negative* button **Cancel**,
    we provide an empty event handler because there is nothing to do; Android will
    take care of closing the dialog. `AlertDialog` also provides a *neutral* button.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetPositiveButton()`和`SetNegativeButton()`方法允许指定按钮标题和事件处理器。在**取消**的**消极**按钮的情况下，我们提供一个空的事件处理器，因为没有要做的事情；Android将负责关闭对话框。`AlertDialog`还提供了一个**中立**按钮。'
- en: Tip
  id: totrans-245
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: On devices prior to Honeycomb, the button order (left to right) was *positive*
    - *neutral* - *negative*. On newer devices, using the Holo theme, the button order
    (left to right) is *negative* - *neutral* - *positive*.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在Honeycomb之前的设备上，按钮顺序（从左到右）是**积极** - **中立** - **消极**。在较新的设备上，使用Holo主题，按钮顺序（从左到右）是**消极**
    - **中立** - **积极**。
- en: 'Run `POIApp` and verify that the delete confirmation is working correctly.
    The following screenshot shows the delete confirmation dialog when the user clicks
    on the delete action:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 运行`POIApp`并验证删除确认是否正常工作。以下截图显示了用户点击删除操作时的删除确认对话框：
- en: '![](img/vkmgTyjW.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/vkmgTyjW.jpg)'
- en: Refreshing POIListActivity
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刷新POIListActivity
- en: Actions we take on `POIDetailActivity`, such as `Save` and `Delete`, have an
    effect on the data displayed in `POIListActivity`. We need to ensure that `ListView`
    in `POIListActivity` is refreshed and displays the updated POI list when it becomes
    active again. To achieve this, we have to depend on the activity life cycle callback
    methods.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`POIDetailActivity`上采取的操作，如`Save`和`Delete`，会影响`POIListActivity`中显示的数据。我们需要确保当`POIListActivity`再次变得活跃时，`ListView`被刷新并显示更新的POI列表。为了实现这一点，我们必须依赖于活动生命周期回调方法。
- en: As you may recall from Chapter 1, *The Anatomy of an Android App*, when an activity
    is moved to the background due to the start of a new activity, the `OnPause()`
    method is called. This would have happened for `POIListActivity` when `POIDetailActivity`
    was started. Once `POIDetailActivity` is completed by either calling the `Finish()`
    method or by pressing the device back button, the `POIListActivity` will be brought
    back to the foreground and the `OnResume()` method will be called.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从第1章“Android应用的解剖结构”中可能记得的，当一个活动由于新活动的启动而被移动到后台时，会调用`OnPause()`方法。当`POIDetailActivity`启动时，这就会发生在`POIListActivity`上。一旦`POIDetailActivity`通过调用`Finish()`方法或按设备返回按钮完成，`POIListActivity`将回到前台，并调用`OnResume()`方法。
- en: 'Let''s remove the call to `DownloadPoisListAsync()` in the `OnCreate()` method
    and add the following snippets to refresh `POIListActivity`:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`OnCreate()`方法中移除对`DownloadPoisListAsync()`的调用，并添加以下片段以刷新`POIListActivity`：
- en: '[PRE40]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We have covered a lot of ground in this chapter. We have completed the POI details
    activity to perform add, update, or delete POIs. If you have any unintended deviations,
    you can refer to the code bundle.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量内容。我们完成了POI详细信息活动，以执行添加、更新或删除POI的操作。如果您有任何意外的偏差，您可以参考代码包。
- en: Summary
  id: totrans-255
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground creating complex layouts using different
    layout managers such as `LinearLayout`, `TableLayout`, and `ScrollView` and using
    `EditText` to validate the form data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用不同的布局管理器，如`LinearLayout`、`TableLayout`和`ScrollView`，以及使用`EditText`来验证表单数据，创建了大量的复杂布局。
- en: Now a new activity is added to `POIApp` that displays the details of the POI
    and allows the user to perform add, update, or delete POI operations. The `StartActivity`
    method is used in combination with `Intent` for passing the data bundle between
    activities.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在`POIApp`中添加了一个新的活动，用于显示POI的详细信息，并允许用户执行添加、更新或删除POI操作。`StartActivity`方法与`Intent`结合使用，用于在活动之间传递数据包。
- en: We also extended the `POIService` class by adding additional methods to perform
    the web service `POST` and `DELETE` operations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还通过添加执行网络服务`POST`和`DELETE`操作的方法，扩展了`POIService`类。
- en: The next chapter will guide you to deal with the application behavior when a
    device orientation changes.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将指导您处理设备方向改变时应用程序的行为。
