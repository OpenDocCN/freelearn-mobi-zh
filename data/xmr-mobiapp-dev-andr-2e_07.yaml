- en: Chapter 7. Designing for Multiple Screen Sizes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章：为多种屏幕尺寸设计
- en: In early 2011, Android Honeycomb 3.0 (API level 11) was released specifically
    to support larger screen-sized tablets. Since then, the Android ecosystem has
    exploded and all subsequent Android releases have been targeted to offer more
    screen sizes, including smart phones, tablets, and Google TV.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年初，安卓蜂巢3.0（API级别11）发布，专门用于支持更大屏幕尺寸的平板电脑。从那时起，安卓生态系统爆炸式增长，所有后续的安卓版本都旨在提供更多屏幕尺寸，包括智能手机、平板电脑和谷歌电视。
- en: 'This chapter will walk you through dealing with multiple screen sizes and making
    your application compatible to work with smart phones and tablets. In the course
    of this chapter, we will extend the `POIApp` we have been developing and optimize
    it for Android tablets. The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将指导您处理多种屏幕尺寸并使您的应用程序兼容智能手机和平板电脑。在本章的过程中，我们将扩展我们一直在开发的`POIApp`并为其优化以适应安卓平板电脑。本章将涵盖以下主题：
- en: Introduction to the Android tablets ecosystem
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓平板电脑生态系统简介
- en: Creating and managing fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和管理片段
- en: Making `POIApp` compatible with Android tablets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使`POIApp`与安卓平板电脑兼容
- en: Dealing with `ListFragment` to display the POI list
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理`ListFragment`以显示POI列表
- en: Creating the multi-pane layout for tablets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为平板电脑创建多面板布局
- en: Adding alternative layouts for Android tablets
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为安卓平板电脑添加替代布局
- en: Using `DialogFragment` to display dialogs
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`DialogFragment`显示对话框
- en: Working with fragments for older Android devices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为旧版安卓设备使用片段
- en: Retaining the fragment state on device configuration changes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在设备配置更改时保留片段状态
- en: An introduction to Android tablets
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓平板电脑简介
- en: The first ever Android tablet was released in 2011 with Android Version 3.0\.
    However, all subsequent Android releases were targeted to support a range of screen
    sizes, including small, medium, and large ones. Due to its open nature, the Android
    ecosystem has a variety of device manufacturers, and hence, there are devices
    with different screen sizes and densities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 第一款安卓平板电脑于2011年发布，搭载安卓版本3.0。然而，所有后续的安卓版本都旨在支持一系列屏幕尺寸，包括小、中和大尺寸。由于其开放性，安卓生态系统拥有各种设备制造商，因此存在不同屏幕尺寸和密度的设备。
- en: Applications built for Android smart phones can run on tablets without making
    any changes. However, if the UI is not optimized, it will give you a disagreeable
    user experience. Developers must take the extra space as an opportunity and use
    it efficiently to design a UI that can display more information on larger screens.
    For example, the Gmail application in the Android phone will have two activities
    for displaying the recent e-mail list and details of a selected e-mail. However,
    the same app in the tablet displays the e-mail list and the details on the same
    page, using the multi-pane split view layout.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为安卓智能手机构建的应用程序可以在不进行任何更改的情况下在平板电脑上运行。然而，如果UI没有优化，它将给您带来不愉快的用户体验。开发者必须将额外空间视为机会，并有效地利用它来设计一个可以在更大屏幕上显示更多信息的UI。例如，安卓手机中的Gmail应用程序将有两个活动来显示最近的电子邮件列表和所选电子邮件的详细信息。然而，同一应用程序在平板电脑上使用多面板分割视图布局在同一页面上显示电子邮件列表和详细信息。
- en: 'The key things to be considered while designing user interfaces for Android
    applications are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 设计安卓应用程序用户界面时需要考虑的关键因素如下：
- en: '**Screen size**: This is the actual physical screen size of the device; generally,
    grouped into small, normal, large, and extra large. Although there is no official
    confirmation on the minimum and maximum screen sizes, they usually range from
    2.55 to 10.1 inches.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕尺寸**：这是设备的实际物理屏幕尺寸；通常分为小、正常、大和超大。尽管没有官方确认最小和最大屏幕尺寸，但它们通常在2.55到10.1英寸之间。'
- en: '**Screen density**: This is the number of pixels present in the physical area
    of the screen, which is represented as dpi (dots per inch). High-density screens
    have more pixels than low-density screens.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕密度**：这是屏幕物理区域中像素的数量，表示为dpi（每英寸点数）。高密度屏幕比低密度屏幕有更多的像素。'
- en: '**Resolution**: This is the number of pixels present on the device screen.
    It is usually defined as `width x height`. For example, the resolution for a Nexus
    5 device is `1080 x 1920`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分辨率**：这是设备屏幕上像素的数量。它通常定义为`宽度 x 高度`。例如，Nexus 5设备的分辨率为`1080 x 1920`。'
- en: '**Screen orientation**: A device''s orientation could be either in landscape
    or portrait mode.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕方向**：设备的方向可以是横屏或竖屏模式。'
- en: Creating an Android tablet emulator
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建安卓平板电脑模拟器
- en: So far, we have built the `POIApp` to display the list of POIs fetched from
    the server and tested it on the Android smart phone. Before we begin with extending
    the `POIApp` to support Android tablets, let's create a new emulator instance
    for the Android tablet and run the existing `POIApp` built so far.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经构建了 `POIApp` 来显示从服务器获取的 POI 列表，并在 Android 智能手机上进行了测试。在我们开始扩展 `POIApp`
    以支持 Android 平板电脑之前，让我们为 Android 平板电脑创建一个新的模拟器实例并运行到目前为止构建的现有 `POIApp`。
- en: 'In order to create an emulator for the tablet, perform the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建平板电脑的模拟器，执行以下步骤：
- en: From the main menu bar, navigate to **Tools** and open **Google Emulator Manager**.
    This will open the AVD manager window.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单栏导航到 **工具** 并打开 **Google 模拟器管理器**。这将打开 AVD 管理器窗口。
- en: To create a new emulator, click on the **Create** button, in the right-hand
    side pane.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的模拟器，点击右侧面板中的 **创建** 按钮。
- en: Set the **AVD Name** field to `Nexus10`, select **Nexus 10** from the **Device**
    drop-down menu, set the **Target** field to `Android 4.4.x`, if needed, uncheck
    the **Hardware keyboard present** option, and click on **OK**.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **AVD 名称** 字段设置为 `Nexus10`，从 **设备** 下拉菜单中选择 **Nexus 10**，将 **目标** 字段设置为 `Android
    4.4.x`，如果需要，取消选中 **硬件键盘存在** 选项，然后点击 **确定**。
- en: Note that the **Target** setting specifies the version of the Android platform
    and the API level that will be used for the emulator.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，**目标** 设置指定了模拟器将使用的 Android 平台版本和 API 级别。
- en: Provide the configurations such as the **AVD name**, **Device**, **Skin**, **Target**,
    **Memory Options**, and so on, as shown in the following screenshot:![](img/dGehWnxQ.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供如以下截图所示的配置，例如 **AVD 名称**、**设备**、**皮肤**、**目标**、**内存选项**等：![](img/dGehWnxQ.jpg)
- en: If you're using third-party emulator solutions, such as Xamarin Android Player
    or Genymotion, you can download either the Nexus 7 or Nexus 10 simulator for testing
    purposes in the tablet configuration.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在使用第三方模拟器解决方案，例如 Xamarin Android Player 或 Genymotion，您可以在平板电脑配置中下载 Nexus
    7 或 Nexus 10 模拟器进行测试。
- en: 'Now start the Nexus 10 emulator created in the previous steps and run the existing
    `POIApp` built so far. The following screenshot depicts the UI of the `POIApp`
    on the tablet that has not been optimized for larger screens:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动之前步骤中创建的 Nexus 10 模拟器，并运行到目前为止构建的现有 `POIApp`。以下截图显示了未针对大屏幕优化的平板电脑上的 `POIApp`
    用户界面：
- en: '![](img/SBTOtSYO.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/SBTOtSYO.jpg)'
- en: With the additional screen real estate, the UI elements can be organized in
    various locations to make the app look nicer. Currently, the `POIApp` is using
    two activities for displaying the POI list and POI details. For tablets, we can
    use a multi-pane split layout to display both the POI list and details in the
    same activity by sharing the same screen space. Android activities are meant to
    be for single purposes and they don't allow embedding one activity inside another.
    The Android fragment can be used to solve this problem. A fragment is a reusable
    user interface component used to build dynamic and modular user interfaces for
    different screen sizes. An activity can contain one fragment or multiple fragments.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 利用额外的屏幕空间，UI 元素可以组织在各个位置，使应用看起来更美观。目前，`POIApp` 使用两个活动来显示 POI 列表和 POI 详细信息。对于平板电脑，我们可以使用多面板分割布局，在同一个活动中通过共享相同的屏幕空间来显示
    POI 列表和详细信息。Android 活动旨在用于单一目的，并且不允许在另一个活动内部嵌入活动。Android 片段可以用来解决这个问题。片段是一个可重用的用户界面组件，用于为不同屏幕尺寸构建动态和模块化的用户界面。一个活动可以包含一个片段或多个片段。
- en: An introduction to fragments
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 片段简介
- en: Fragments are reusable pieces of a user interface component that provide flexibility
    to the application design. As you have already learnt from Chapter 1, *The Anatomy
    of an Android App*, fragments are reusable mini-activities, such as UI components,
    that can manage their own life cycles. Fragments are always intended to work without
    depending on another activity or fragment. Like an `Activity` class, a fragment
    class needs to extend from the `Fragment` class. To make things even easier, Android
    provides some of the additional specialized fragment subclasses such as `ListFragment`,
    `DialogFragment`, and `PreferenceFragment`.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 片段是用户界面组件的一部分，提供了对应用程序设计的灵活性。正如您在第一章“Android 应用解剖”中学到的，片段是可重用的迷你活动，如 UI 组件，可以管理它们自己的生命周期。片段总是旨在在没有依赖另一个活动或片段的情况下工作。与
    `Activity` 类一样，片段类需要从 `Fragment` 类扩展。为了使事情更加简单，Android 提供了一些额外的专用片段子类，例如 `ListFragment`、`DialogFragment`
    和 `PreferenceFragment`。
- en: The following table shows the list of fragment subclasses and their purposes.
    You may also extend any of the following fragment subclasses to create your own
    fragment.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了片段子类及其用途列表。您还可以扩展以下任何片段子类以创建自己的片段。
- en: '`ListFragment`'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListFragment`'
- en: This displays a list of data items from different sources, such as an array,
    a cursor, and so on.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了来自不同来源的数据项列表，例如数组、游标等。
- en: '`DialogFragment`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogFragment`'
- en: This displays a fragment as a floating dialog window.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了一个作为浮动对话框窗口的片段。
- en: '`PreferenceFragment`'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`PreferenceFragment`'
- en: This displays the hierarchical app preferences list. The preferences are saved
    when any changes are made by a user. The Nexus device settings screen design follows
    the `PreferenceFragment` pattern.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这显示了应用程序的首层偏好设置列表。当用户进行任何更改时，偏好设置将被保存。Nexus设备设置屏幕设计遵循`PreferenceFragment`模式。
- en: Creating a new fragment
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个新的片段
- en: A fragment can be seen as a modular component of an activity, which maintains
    its own life cycle, that handles user events and can be added to or removed from
    a running activity. The process of creating a fragment is very similar to creating
    an activity.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 片段可以被视为活动的一个模块化组件，它维护自己的生命周期，处理用户事件，并且可以被添加到或从运行的活动中移除。创建片段的过程与创建活动非常相似。
- en: 'Perform the following steps to create and add a fragment in Android:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中创建和添加片段的步骤如下：
- en: The first step toward creating a fragment is to define its layout. Like the
    activity layout, you can either use the drag-and-drop interface builder available
    in Xamarin Studio, or you may use the XML code editor to create the layouts.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建片段的第一步是定义其布局。与活动布局类似，您可以使用Xamarin Studio中可用的拖放界面构建器，或者您可以使用XML代码编辑器来创建布局。
- en: 'Create a new class that directly extends the `Fragment` class or its subclasses.
    The following code snippet extends the `Fragment` base class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个直接扩展`Fragment`类或其子类的新的类。以下代码片段扩展了`Fragment`基类：
- en: '[PRE0]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now implement the necessary fragment methods. To begin with, let's override
    the `OnCreateView()` method. This method adds the fragment to the view hierarchy
    and returns a `View` instance that represents the fragment.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在实现必要的片段方法。首先，让我们重写`OnCreateView()`方法。此方法将片段添加到视图层次结构，并返回一个表示片段的`View`实例。
- en: 'The fragments UI can be created in two ways: by declaring the XML layout and
    inflating the fragment layout inside `OnCreateView()`, or by creating all the
    interfaces dynamically. For simplicity, the XML declarative approach is always
    preferred:'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 片段的UI可以通过两种方式创建：通过在`OnCreateView()`中声明XML布局并填充片段布局，或者通过动态创建所有接口。为了简单起见，总是首选XML声明方法：
- en: '[PRE1]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Optionally, you may override other fragment life cycles such as `OnPause()`,
    `OnResume()`, and so on, to control other life cycle event callbacks.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可选地，您可以覆盖其他片段生命周期，如`OnPause()`、`OnResume()`等，以控制其他生命周期事件回调。
- en: 'Finally, let''s add the fragments to the activity. This can be done in two
    ways: either by declaratively adding the activity layout, or by adding it programmatically.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将片段添加到活动中。这可以通过两种方式完成：要么通过声明性添加活动布局，要么通过编程添加。
- en: 'Use the following code snippet to add the fragment by declaring the `&lt;fragment&gt;`
    tag in the activity layout:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下代码片段通过在活动布局中声明`<fragment>`标签来添加片段：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'To add the fragment dynamically, you need to first create a fragment placeholder
    container layout and assign an ID to it:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要动态添加片段，您需要首先创建一个片段占位符容器布局并为其分配一个ID：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now that you have specified the `ViewGroup` in which the fragment will be added
    dynamically, you can use the `FragmentTransaction` instance to add, remove, and
    replace the transactions. Use the following snippets to get the instance of `FragmentTransaction`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经指定了片段将动态添加到的`ViewGroup`，您可以使用`FragmentTransaction`实例来添加、删除和替换事务。使用以下代码片段来获取`FragmentTransaction`实例：
- en: '[PRE4]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'You can then use the `Add()`, `Remove()`, and `Replace()` methods by passing
    the instance of the fragment and the ID of the `View` to which the fragment will
    be added. Once the fragment transactions are completed, you must call the `Commit()`
    method for the changes to take effect:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以通过传递片段实例和片段将要添加到的`View`的ID来使用`Add()`、`Remove()`和`Replace()`方法。一旦片段事务完成，您必须调用`Commit()`方法以使更改生效：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: So far, you have a fair idea of how to work with fragments; let's now proceed
    to make the `POIApp` work with fragments and reuse the fragments to optimize the
    tablet's layouts.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你对如何使用片段有了相当的了解；现在让我们继续让 `POIApp` 与片段一起工作，并重用片段来优化平板电脑的布局。
- en: Making POIApp compatible with Android tablets
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使 `POIApp` 兼容 Android 平板
- en: We have already covered a lot of ground on the fragment basics and life cycle
    in Chapter 1, *The Anatomy of an Android App*. I recommend that you read the concepts
    if you haven't gone through them already. Let's now go through the steps to create
    and manage fragments and build the `POIApp` to support the multi-pane tablet layout.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章 *Android App 的解剖结构* 中，我们已经覆盖了很多关于片段基础和生命周期的内容。如果你还没有阅读这些概念，我建议你阅读一下。现在让我们通过以下步骤来创建和管理片段，并构建
    `POIApp` 以支持多栏平板电脑布局。
- en: 'Currently, the `POIApp` is using two activities: `POIListActivity` for displaying
    the list of POIs, and `POIDetailsActivity` for displaying the details. Now we
    will create two new fragments: `POIListFragment` and `POIDetailFragment`, which
    will be reused for both the smart phone and multi-pane tablet layout:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`POIApp` 正在使用两个活动：`POIListActivity` 用于显示 POI 列表，`POIDetailsActivity` 用于显示详情。现在我们将创建两个新的片段：`POIListFragment`
    和 `POIDetailFragment`，这两个片段将被重用于智能手机和多栏平板电脑布局：
- en: '![](img/iZ5oaLuk.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![](img/iZ5oaLuk.jpg)'
- en: 'Notice the following points in the preceding screenshot, which will be implemented
    in the rest of the sections in this chapter:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意以下截图中的要点，这些将在本章其余部分中实现：
- en: The phone layout contains two activities; `POIListActivity` and `POIDetailsActivity`,
    that host `POIListFragment` and `POIDetailFragment` respectively. Here, the activities
    will work like placeholders to hold fragments. Most of the application logic is
    to be moved from an activity to fragments.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 手机布局包含两个活动；`POIListActivity` 和 `POIDetailsActivity`，分别托管 `POIListFragment` 和
    `POIDetailFragment`。在这里，活动将像占位符一样工作，以容纳片段。大部分的应用逻辑都应该从活动移动到片段中。
- en: The `POIListFragment` will contain the logic to initialize the list view, download
    the data using methods declared in the `POIService` class, and prepare the UI.
    Currently, the same logic is placed on `POIListActivity`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POIListFragment` 将包含初始化列表视图的逻辑，使用在 `POIService` 类中声明的方法下载数据，并准备用户界面。目前，相同的逻辑放置在
    `POIListActivity` 中。'
- en: The `POIDetailFragment` will contain the logic to display the details of the
    selected POI and the ability to create, update, and delete the POI.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POIDetailFragment` 将包含显示所选 POI 详情的逻辑，以及创建、更新和删除 POI 的能力。'
- en: The tablet real estate is comparatively larger, and hence its layout can hold
    both `POIListFragment` and `POIDetailFragment` on a single activity. This allows
    us to reuse the fragments and enables different user experiences on different
    screen sizes.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 平板电脑的可用空间相对较大，因此其布局可以在单个活动中同时容纳 `POIListFragment` 和 `POIDetailFragment`。这使我们能够重用片段，并允许在不同屏幕尺寸上提供不同的用户体验。
- en: The following sections in this chapter will guide you through how to use fragments
    to build the `POIApp` using the multi-pane split view layout for Android tablets.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的以下部分将指导你如何使用片段构建 `POIApp`，使用 Android 平板的分栏视图布局。
- en: Using fragments for displaying POIDetails
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段显示 POIDetails
- en: In order to make things simple, we will move step by step. First, let's create
    a new fragment to display the details of the POI, and this will enable you to
    edit, update, and delete the POI. Currently, the `POIDetailActivity` activity
    contains the same logic. At this point, let's keep it simple and not complicate
    things by thinking about the multi-pane tablet layout.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使事情简单，我们将逐步进行。首先，让我们创建一个新的片段来显示 POI 的详情，这将使你能够编辑、更新和删除 POI。目前，`POIDetailActivity`
    活动包含相同的逻辑。在这个阶段，让我们保持简单，不要通过考虑多栏平板电脑布局来使事情复杂化。
- en: Creating the POIDetailsFragment layout
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 POIDetailsFragment 布局
- en: 'Let''s begin with creating a new layout file for the POI details fragment and
    name it `POIDetailFragment.axml`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从为 POI 详情片段创建一个新的布局文件开始，并将其命名为 `POIDetailFragment.axml`：
- en: Select the `Resources/Layout` folder in the **Solution** pad.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Solution** 面板中选择 `Resources/Layout` 文件夹。
- en: Right-click on **Add** and select **New File**.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 **Add** 并选择 **New File**。
- en: In the **New File** dialog box, click on **Android** and select **Layout**,
    enter `POIDetailFragment` in the **Name** field, and select **New**.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **New File** 对话框中，点击 **Android** 并选择 **Layout**，在 **Name** 字段中输入 `POIDetailFragment`，并选择
    **New**。
- en: Note that we will not make any changes to the POI details screen layout. So,
    let's just copy the layout XML source code from `POIDetail.axml` and paste it
    into the newly created `POIDetailFragment.axml` file.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们不会对POI详细信息屏幕布局进行任何更改。所以，我们只需将`POIDetail.axml`中的布局XML源代码复制并粘贴到新创建的`POIDetailFragment.axml`文件中。
- en: Creating the POIDetailFragment
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建POIDetailFragment
- en: 'Now that we have the POI details fragment layout ready, we need a corresponding
    fragment. To create `POIDetailFragment`, perform the following steps:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了POI详细信息片段布局，我们需要相应的片段。要创建`POIDetailFragment`，请执行以下步骤：
- en: Select the `POIApp` project in the **Solution** pad, right-click on it, and
    navigate to **Add** | **New File**.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中选择`POIApp`项目，右键单击它，然后导航到**添加** | **新建文件**。
- en: From the **New File** dialog box, click on **Android** and select **Fragment**,
    enter `POIDetailFragment` in the **Name** field, and click on **New**.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**新建文件**对话框中，点击**Android**并选择**Fragment**，在**名称**字段中输入`POIDetailFragment`，然后点击**新建**。
- en: The `POIDetailFragment` created in the previous steps will contain the logic
    to display the details of the POI and enables various actions, such as create,
    update, and delete the POI. Currently, the business logic is in `POIDetailsActivity`.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前一步骤中创建的`POIDetailFragment`将包含显示POI详细信息并启用各种操作的逻辑，例如创建、更新和删除POI。目前，业务逻辑在`POIDetailsActivity`中。
- en: 'Declare the following set of private variables for each of the input widgets
    we created in the layout. Add the following listing to your `POIDetailFragment`
    class:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为我们在布局中创建的每个输入小部件声明以下私有变量。将以下列表添加到您的`POIDetailFragment`类中：
- en: '[PRE6]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override the `OnAttach()` method and save the reference of the `activity` instance:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnAttach()`方法并保存`activity`实例的引用：
- en: '[PRE7]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Override the `OnCreateView()` method, inflate the fragment layout, and bind
    each variable to its corresponding user interface widget by calling the `FindViewById&lt;T&gt;`
    method and the `UpdateUI()` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnCreateView()`方法，填充片段布局，并通过调用`FindViewById<T>`方法和`UpdateUI()`方法将每个变量绑定到相应的用户界面小部件：
- en: '[PRE8]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Copy and paste the `UpdateUI()`, `SavePOI()`, `DeletePOI()`, and `ConfirmDelete()`
    methods' code from the `POIDetailsActivity` class to the `POIDetailFragment` class.
    You will get a compilation error wherever this keyword is used. Replace this with
    the activity instance.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`UpdateUI()`、`SavePOI()`、`DeletePOI()`和`ConfirmDelete()`方法从`POIDetailsActivity`类复制并粘贴到`POIDetailFragment`类中。您将在使用此关键字的地方遇到编译错误。将其替换为活动实例。
- en: Now copy both the `CreateOrUpdatePOIAsync()` and `DeletePOIAsync()` methods
    from `POIDetailsActivity` to the `POIDetailFragment` class. Here, you will again
    notice a compilation error near the `Finish()` method and the `Toast` initialization.
    For the `Toast` instantiation, replace this with the activity instance and replace
    `Finish()` with `activity.Finish()`.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将`CreateOrUpdatePOIAsync()`和`DeletePOIAsync()`方法从`POIDetailsActivity`复制到`POIDetailFragment`类中。在这里，你将再次注意到`Finish()`方法和`Toast`初始化附近出现编译错误。对于`Toast`实例化，将其替换为活动实例，并将`Finish()`替换为`activity.Finish()`。
- en: 'Now let''s override the `OnCreate()` method. Here, we will retrieve the details
    of the POI sent to `POIDetailFragment`. Each fragment has an `Arguments` property
    that contains the data bundles. As with activities, we can use a series of `GetXXX()`
    methods, where `XXX` represents the type of the value of a name/value pair:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们重写`OnCreate()`方法。在这里，我们将检索发送到`POIDetailFragment`的POI详细信息。每个片段都有一个`Arguments`属性，其中包含数据包。与活动一样，我们可以使用一系列`GetXXX()`方法，其中`XXX`代表名称/值对的值的类型：
- en: '[PRE9]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Working with the save and delete actions
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作保存和删除操作
- en: The `POIDetailFragment` displays the details of the selected POI to the user
    and also retains the ability to save a new or delete an existing POI. The save
    and delete actions are to be added to the action bar in `POIDetailFragment`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`POIDetailFragment`向用户显示所选POI的详细信息，并保留保存新POI或删除现有POI的能力。保存和删除操作需要添加到`POIDetailFragment`中的操作栏。'
- en: 'The following steps will guide you through what is needed to add the actions
    in the `POIDetailFragment`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您了解在`POIDetailFragment`中添加操作所需的内容：
- en: 'To make the action bar button work on the fragments, you need to first enable
    this option by calling the `SetHasOptionsMenu ()` method and passing the `bool`
    value `true`. The `bool` value represents whether or not the fragment wants to
    contribute in order to populate the menu items. Add the following block to `OnCreateView()`
    before the `return` statement:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使片段中的动作栏按钮工作，您需要首先通过调用`SetHasOptionsMenu()`方法并传递`bool`值`true`来启用此选项。`bool`值表示片段是否希望贡献以填充菜单项。在`OnCreateView()`中的`return`语句之前添加以下代码块：
- en: '[PRE10]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In Chapter 5, *Adding a Details View*, we have already added the menu declaration
    to the `POIDetailMenu.xml` file. The `POIDetailFragment` will continue to use
    the same menu XML declaration.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第5章“添加详情视图”中，我们已经将菜单声明添加到了`POIDetailMenu.xml`文件。`POIDetailFragment`将继续使用相同的菜单XML声明。
- en: 'Override the fragment version of the `OnCreateOptionsMenu()` and `OnOptionsItemSelected()`
    methods in `POIDetailFragment`, and add the following code blocks:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIDetailFragment`中重写`OnCreateOptionsMenu()`和`OnOptionsItemSelected()`方法的片段版本，并添加以下代码块：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that in the previous code blocks, we are not making any changes to the
    logic while populating the `save` and `delete` actions. It is just the copy of
    the same code, which was used in the `POIDetailActivity` class.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在之前的代码块中，我们在填充`save`和`delete`操作时没有对逻辑进行任何更改。这只是相同代码的副本，它被用于`POIDetailActivity`类。
- en: Override the `OnPrepareOptionsMenu()` method in `POIDetailFragment` to disable
    the delete action while a new POI is being created.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`POIDetailFragment`中重写`OnPrepareOptionsMenu()`方法，以在创建新POI时禁用删除操作。
- en: 'The following listing shows how to disable the delete action when a new POI
    is being created:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表展示了如何在新POI创建时禁用删除操作：
- en: '[PRE12]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Adding the POIDetailFragment to POIDetailActivity
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将POIDetailFragment添加到POIDetailActivity
- en: 'Now that we are ready with the `POIDetailFragment`, we can add it to `POIDetailActivity`
    to make it fully functional. As discussed earlier in this chapter, a fragment
    can be added to an activity in two ways: using a declarative approach, or by dynamically
    inflating the layout. For `POIDetailActivity`, we will add the fragment dynamically.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`POIDetailFragment`，我们可以将其添加到`POIDetailActivity`中使其完全功能化。正如本章前面所讨论的，一个片段可以通过两种方式添加到活动中：使用声明性方法，或者通过动态填充布局。对于`POIDetailActivity`，我们将动态地添加片段。
- en: The following sections will take you through the code refactoring process of
    adding `POIDetailFragment` to the `POIDetailActivity` activity.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 以下章节将带您了解将`POIDetailFragment`添加到`POIDetailActivity`活动中的代码重构过程。
- en: Modifying the POI details activity layout
  id: totrans-109
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改POI详情活动布局
- en: Now that we have placed the entire details view layout in the `POIDetailFragment`
    layout, the `POIDetail` activity layout will have a simple container that can
    host the fragment. For this purpose, we can use `FrameLayout`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将整个详情视图布局放置在`POIDetailFragment`布局中，`POIDetail`活动布局将有一个简单的容器，可以容纳片段。为此，我们可以使用`FrameLayout`。
- en: '`FrameLayout` is a special kind of a layout manager, generally used to display
    a single item. When multiple views are added, they are placed in a stack with
    the most recently added child on the top.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`FrameLayout`是一种特殊的布局管理器，通常用于显示单个项目。当添加多个视图时，它们被放置在一个堆栈中，最近添加的子视图位于顶部。'
- en: 'Let''s make the following changes to the POI details activity layout and add
    a dummy view that acts as a placeholder to hold the fragment:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们对POI详情活动布局进行以下更改，并添加一个占位符视图以容纳片段：
- en: Open the `Resources/POIDetail.axml` file, and in the **Document Outline** view,
    click on **ScrollView** and then click on **Delete**. Notice that the layout will
    be empty.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Resources/POIDetail.axml`文件，在**文档大纲**视图中点击**ScrollView**，然后点击**删除**。注意布局将变为空。
- en: Search for **FrameLayout** in the **Toolbox** and drag it to the simulator window
    to add it as a root element.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**中搜索**FrameLayout**，并将其拖到模拟器窗口中作为根元素添加。
- en: Click on **FrameLayout** in the **Document Outline** view and then click on
    the **Properties** window. Set the view ID to `poiDetailLayout`.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文档大纲**视图中点击**FrameLayout**，然后点击**属性**窗口。将视图ID设置为`poiDetailLayout`。
- en: 'Click on the **Source** tab in the layout editor and notice that the following
    code is generated:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在布局编辑器的**源**选项卡中点击，注意以下代码被生成：
- en: '[PRE13]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Refactoring POIDetailActivity to add POIDetailFragment
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重构POIDetailActivity以添加POIDetailFragment
- en: 'Currently, the `POIDetailFragment` contains the logic we wrote earlier to perform
    the add, update, or delete operations in `POIDetailActivity`. Now let''s refactor
    `POIDetailActivity` to thin out the logic and just add `POIDetailFragment` to
    it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，`POIDetailFragment`包含我们在`POIDetailActivity`中编写的逻辑，以执行添加、更新或删除操作。现在让我们重构`POIDetailActivity`，简化逻辑，并仅将其添加到其中：
- en: Open the `POIDetailActivity` class from the Solution Explorer.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从解决方案资源管理器中打开`POIDetailActivity`类。
- en: 'Select all of the code and delete everything except the basic activity template.
    For the sake of simplicity, you may replace the whole `POIDetailActivity` class
    with the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有代码并删除除基本活动模板之外的所有内容。为了简化，你可以用以下代码替换整个`POIDetailActivity`类：
- en: '[PRE14]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now it is time to add `POIDetailFragment` to `Activity`. Let's first initialize
    the `POIDetailFragment` and pass the POI details data received from `POIListActivity`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候将`POIDetailFragment`添加到`Activity`中。让我们首先初始化`POIDetailFragment`，并传递从`POIListActivity`接收到的POI详细信息数据。
- en: To display the details of the selected POI, the `POIDetailFragment` expects
    the POI data to be passed to it. Like any other activity, data bundles can be
    passed to a fragment using its `Arguments` property. The `Arguments` property
    has its own set of the `PutXX()` and `GetXX()` methods (`XX` represents the data
    types, such as string, double, and so on) that are used to send and retrieve data
    from fragments.
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 要显示所选POI的详细信息，`POIDetailFragment`期望将POI数据传递给它。像任何其他活动一样，可以使用其`Arguments`属性将数据包传递给片段。`Arguments`属性有一组自己的`PutXX()`和`GetXX()`方法（`XX`代表数据类型，如字符串、双精度浮点数等），用于从片段发送和检索数据。
- en: 'Add the following code snippet to the `OnCreate()` callback right after the
    `SetContentView()` method:'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`SetContentView()`方法之后立即将以下代码片段添加到`OnCreate()`回调中：
- en: '[PRE15]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `POIDetailActivity` layout contains a placeholder layout where the `POIDetailFragment`
    will be added. The `FragmentTransaction` class can be used to perform any of the
    fragment transactions, such as adding, replacing, or deleting fragments. Instantiate
    the fragment transaction to add `POIDetailFragment` to the `POIDetailActivity`
    view hierarchy:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`POIDetailActivity`布局包含一个占位符布局，其中将添加`POIDetailFragment`。`FragmentTransaction`类可用于执行任何片段事务，例如添加、替换或删除片段。实例化片段事务以将`POIDetailFragment`添加到`POIDetailActivity`视图层次结构中：'
- en: '[PRE16]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Let's now build and run the app in a simulator. Notice that you will see the
    same output that we built in Chapter 5, *Adding a Details View*. Now we are using
    `POIDetailFragment` that holds the logic to add, update, and delete POIs.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们在模拟器中构建并运行应用程序。注意，你将看到我们在第5章“添加详细信息视图”中构建的相同输出。现在我们正在使用`POIDetailFragment`，它包含添加、更新和删除POI的逻辑。
- en: The same `POIDetailFragment` will be reused while creating the multi-pane split
    view layout for the tablet.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建平板电脑的多面板分割视图布局时，将重用相同的`POIDetailFragment`。
- en: Using the list fragment for displaying the POI list
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用列表片段显示POI列表
- en: So far, we have created a fragment using the `Fragment` subclass to display
    the details of the point of interest. Let's now use a specialized `ListFragment`
    class to create a new fragment to display the POI list fetched from the server.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经使用`Fragment`子类创建了一个片段来显示兴趣点的详细信息。现在让我们使用专门的`ListFragment`类来创建一个新的片段，用于显示从服务器获取的POI列表。
- en: Understanding ListFragment
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解列表片段
- en: 'Before we start creating the `POIListFragment`, let''s understand the following
    key concepts of `ListFragment`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始创建`POIListFragment`之前，让我们了解`ListFragment`的以下关键概念：
- en: '`ListFragment` is a specialized `Fragment` subclass used to display the list
    of items from different data sources, such as an array or a cursor, that hold
    the query results.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListFragment`是一个用于显示来自不同数据源（如数组或游标）的项目列表的专门`Fragment`子类，这些数据源包含查询结果。'
- en: '`ListFragment` provides a default layout that contains a single list view.
    However, it can be customized using your own custom layout.'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListFragment`提供了一个默认布局，其中包含一个单独的列表视图。但是，可以使用自己的自定义布局进行自定义。'
- en: While using a custom layout for `ListFragment`, your layout must contain a `ListView`
    object with the ID `@android:id/list`.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在为`ListFragment`使用自定义布局时，你的布局必须包含一个ID为`@android:id/list`的`ListView`对象。
- en: Like the normal `ListView`, the list fragment needs the instance of an adapter
    to operate on. It exposes a public `ListAdapter` property to set the list adapter.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与正常的`ListView`一样，列表片段需要适配器的实例来操作。它公开了一个`ListAdapter`属性来设置列表适配器。
- en: You can override `OnListItemClick()`, provided `ListFragment` allows you to
    detect user-click events on the list items.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果`ListFragment`允许检测用户对列表项的点击事件，你可以重写`OnListItemClick()`。
- en: Creating the POIListFragment layout
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建POIListFragment布局
- en: Here, in our example, the `POIDetailsFragment` will contain a `ListView` that
    takes the full width and height of the parent and a `ProgressBar` to the center
    of the screen. We will now create a custom layout for `ListFragment`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`POIDetailsFragment`将包含一个占满父视图宽度和高度的`ListView`和一个位于屏幕中心的`ProgressBar`。我们现在将为`ListFragment`创建一个自定义布局。
- en: Let's begin by creating a new layout file for the POI list fragment and name
    it `POIListFragment.axml`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建用于POI列表片段的新布局文件开始，并将其命名为`POIListFragment.axml`。
- en: Select the `Resources/Layout` folder in the **Solution** pad.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中选择`Resources/Layout`文件夹。
- en: Right-click on **Add** and select **New File**.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击**添加**并选择**新建文件**。
- en: In the **New File** dialog box, click on **Android** and select **Android Layout**,
    enter `POIListFragment` in the **Name** field, and select **New**.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框中，点击**Android**并选择**Android布局**，在**名称**字段中输入`POIListFragment`，然后选择**新建**。
- en: Copy the layout XML source code from `POIList.axml` and paste it in to the newly
    created `POIListFragment.axml` file.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`POIList.axml`中的布局XML源代码复制并粘贴到新创建的`POIListFragment.axml`文件中。
- en: Notice that we are declaring the custom layout for `ListFragment`. We must change
    the list view ID to `@android:id/list`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，我们正在声明`ListFragment`的自定义布局。我们必须将列表视图ID更改为`@android:id/list`。
- en: 'The `POILsitFragment.axml` file will have the following code snippets:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`POILsitFragment.axml`文件将包含以下代码片段：'
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Creating the fragment to display the POI list using POIListFragment
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用POIListFragment创建用于显示POI列表的片段
- en: Now that we have the layout ready for the `POIListFragment`, let's move ahead
    to create a new fragment to display the list of POIs. Note that we are not making
    any significant changes to the logic we have written for `POIListActivity`. Instead,
    we will refactor the same logic to work with fragments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经为`POIListFragment`准备好了布局，让我们继续创建一个新的片段来显示POI列表。注意，我们没有对我们的`POIListActivity`逻辑进行任何重大的修改。相反，我们将重构相同的逻辑以使其与片段一起工作。
- en: 'Perform the following steps to create `POIListFragment` and make it fully functional:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建`POIListFragment`并使其完全可用：
- en: Select the `POIApp` in the **Solution** pad, right-click on **Add**, and select
    **New File**.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**解决方案**面板中选择`POIApp`，右键单击**添加**并选择**新建文件**。
- en: In the **New File** dialog box, click on **Android** and select **New file**,
    enter `POIListFragment` in the **Name** field, and select **New**.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**新建文件**对话框中，点击**Android**并选择**新建文件**，在**名称**字段中输入`POIListFragment`，然后选择**新建**。
- en: 'Extend it from `ListFragment` and implement `OnCreateView()` to inflate the
    POI list fragment layout:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`ListFragment`扩展它并实现`OnCreateView()`以填充POI列表片段布局：
- en: '[PRE18]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that the list fragments with the custom layout need to have a `ListView`
    object declaration with the ID `@android:id/list`.
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，具有自定义布局的列表片段需要声明一个ID为`@android:id/list`的`ListView`对象。
- en: 'Declare the following set of private variables to hold the instance of the
    list adapter, progress bar, and list of POIs, after the download is complete:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下载完成后，声明以下一组私有变量以保存列表适配器实例、进度条和POI列表：
- en: '[PRE19]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Override the `OnAttach()` method and save the reference of the `activity` instance:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnAttach()`方法并保存`activity`实例的引用：
- en: '[PRE20]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add the following code blocks to the `OnCreateView()` method before the `return`
    statements to initialize the progress bar:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCreateView()`方法中的`return`语句之前添加以下代码块以初始化进度条：
- en: '[PRE21]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create a new method named `DownloadPoisListAsync` (the same as declared in
    `POIListActivity`). We will be using the same logic we wrote earlier for `POIListActivity`
    with a small modification as follows. You will get a compilation error wherever
    the `this` keyword is used. Replace `this` with the `activity` instance:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`DownloadPoisListAsync`的新方法（与在`POIListActivity`中声明的相同）。我们将使用之前为`POIListActivity`编写的相同逻辑，并进行以下小的修改。你会在使用`this`关键字的地方得到编译错误。将`this`替换为`activity`实例：
- en: '[PRE22]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that in the preceding code blocks, we use the `ListAdapter` property
    defined in the `ListFragment` class to set the adapter instance.
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，在前面的代码块中，我们使用了在`ListFragment`类中定义的`ListAdapter`属性来设置适配器实例。
- en: 'Override the `OnResume()` life cycle method and call `DownloadPoisListAsync()`
    to start the download when a fragment is resumed:'
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnResume()`生命周期方法并调用`DownloadPoisListAsync()`以在片段恢复时开始下载：
- en: '[PRE23]'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Note that `POIListFragment` contributes to the action bar menu items and enables
    this option for the fragment by adding the following statement to `OnCreateView()`
    before the `return` statement:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`POIListFragment`通过在`OnCreateView()`方法中添加以下语句来为片段添加动作栏菜单项，并在`return`语句之前启用此选项：
- en: '[PRE24]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Override the fragment version of the `OnCreateOptionsMenu` and `OnOptionsItemSelected`
    methods and paste in the following code. We are just reusing the same logic from
    `POIListActivity`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写片段版本的`OnCreateOptionsMenu`和`OnOptionsItemSelected`方法，并粘贴以下代码。我们只是重用了`POIListActivity`中的相同逻辑：
- en: '[PRE25]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Override the `OnListItemClick()` method from `ListFragment` to detect the list
    row click action. The following code block is a copy of the same logic we wrote
    for the `POIClicked()` method in `POIListActivity`:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnListItemClick()`方法，从`ListFragment`中检测列表行点击动作。以下代码块是我们为`POIListActivity`中的`POIClicked()`方法编写的相同逻辑的副本：
- en: '[PRE26]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: At this point, the list fragment will display the list of POIs and is ready
    to be added to `POIListActivity`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，列表片段将显示POI列表，并准备好添加到`POIListActivity`。
- en: Adding POIListFragment to POIListActivity
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将`POIListFragment`添加到`POIListActivity`
- en: For `POIListFragment` to work, it has to be added to `POIListActivity`. In the
    previous section, you learned how to add the fragment dynamically. Now let's add
    the `POIListFragment` using a declarative approach.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使`POIListFragment`能够工作，它必须被添加到`POIListActivity`中。在前一节中，你学习了如何动态添加片段。现在，让我们使用声明性方法添加`POIListFragment`。
- en: Modifying the POI list activity layout
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 修改POI列表活动布局
- en: A fragment can be added to an activity view hierarchy using the `&lt;fragment&gt;`
    tag declaration in its layout. The `layout_width` and `layout_height` attributes
    of the `&lt;fragment&gt;` tag are used to control the `LayoutParams` provided
    when attaching the fragment's view to the activity layout.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用布局中的`&lt;fragment&gt;`标签声明将片段添加到活动视图层次结构。`&lt;fragment&gt;`标签的`layout_width`和`layout_height`属性用于控制将片段的视图附加到活动布局时提供的`LayoutParams`。
- en: 'Make the following changes to the POI list activity layout (`POIList.axml`)
    to add `POIListFragment` statically:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对POI列表活动布局（`POIList.axml`）进行以下更改，以静态地添加`POIListFragment`：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The value of the `&lt;fragment&gt;` attribute should be a fully qualified fragment
    class name. The `class` attribute indicates that the specified fragment class
    will be attached to the activity's content layout.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`&lt;fragment&gt;`属性的值应该是完全限定的片段类名。`class`属性表示指定的片段类将被附加到活动的内容布局。'
- en: Adding POIListFragment to POIListActivity
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将`POIListFragment`添加到`POIListActivity`
- en: 'Now that we are ready with `POIListFragment`, and we have attached it to the
    POI list activity content layout, we do not have to do anything much inside `POIListActivity`.
    Update the existing `POIListActivity` class with the following code blocks:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`POIListFragment`，并且已经将其附加到POI列表活动内容布局，我们不需要在`POIListActivity`内部做太多事情。使用以下代码块更新现有的`POIListActivity`类：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'So far, we have done a great deal of work by creating two fragments that hold
    the logic to download and display the POI details. Now it''s time to compile and
    run the app. Compile and run the application on the Android emulator:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经通过创建两个片段来处理下载和显示POI详情的逻辑，完成了很多工作。现在，是时候编译并运行应用了。在Android模拟器上编译并运行应用：
- en: '![](img/jsNKGobJ.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/jsNKGobJ.jpg)'
- en: Notice that the app will download the data from the POI web service and display
    the list of POIs on the scrollable list view. It works in exactly the same way
    as it did when we built it in Chapter 5, *Adding a Details View*, but now it works
    with fragments.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，该应用将从POI网络服务下载数据，并在可滚动列表视图中显示POI列表。它的工作方式与我们在第5章“添加详情视图”中构建它时完全相同，但现在它使用的是片段。
- en: Creating a multi-pane layout for tablets
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为平板电脑创建多面板布局
- en: By now, you have a fair idea of how fragments work, and we have refactored the
    existing `POIApp` to work with fragments. The following sections will walk you
    through the key steps required to build the multi-pane layout and make the application
    compatible with Android tablets.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 到现在为止，你对片段的工作方式有了相当的了解，我们已经重构了现有的`POIApp`以使用片段。以下章节将指导你完成构建多面板布局和使应用兼容Android平板电脑的关键步骤。
- en: In Chatper 6, *Making App Orientation Aware*, we discussed the various configuration
    qualifiers to be considered while adding alternative layouts in Android. One of
    the qualifiers is the device's screen size. The Android powered device sizes ranges
    from small, normal, large, xlarge to layout-xxlarge. Since Android 3.2, Android
    has recommended that you use the `sw&lt;N&gt;dp` configuration qualifier to define
    an extra large layout for a tablet.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章“使应用方向感知”中，我们讨论了在Android中添加替代布局时需要考虑的各种配置限定符。其中一个限定符是设备的屏幕尺寸。Android设备的尺寸范围从小型、正常、大型、超大到布局-xxlarge。自Android
    3.2以来，Android建议您使用`sw<N>dp`配置限定符来定义平板电脑的额外大型布局。
- en: Let's assume that we require at least `600dp` of screen width to build a multi-pane
    layout for the `POIApp`. For this, we need add a new `layout-sw600dp` subdirectory
    under the `Resources` directory. The Android runtime will pick the layout placed
    under this directory if the device configuration matches `600dp` of width.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们需要至少`600dp`的屏幕宽度来为`POIApp`构建多窗格布局。为此，我们需要在`Resources`目录下添加一个新的`layout-sw600dp`子目录。如果设备配置匹配`600dp`的宽度，Android运行时会选择此目录下放置的布局。
- en: For tablet configuration, the `POIListActivity` layout will host both `POIListFragment`
    and the `POIDetailFragment` in a single activity. The POI list fragment will be
    placed to the left of the screen covering 40 percent of the total width, and the
    details fragment is docked to the right, covering the remaining 60 percent of
    the total width.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 对于平板电脑配置，`POIListActivity`布局将在单个活动中同时托管`POIListFragment`和`POIDetailFragment`。POI列表片段将放置在屏幕左侧，覆盖总宽度的40%，而详情片段则停靠在右侧，覆盖剩余的60%总宽度。
- en: Xamarin Studio provides an easy-to-use layout designer that allows you to alternatively
    add layouts for various device configurations without any hassle. You don't need
    to remember or manually add the different folder names for different configuration
    qualifiers. The designer takes care of creating, editing, and deleting alternative
    layouts for different configurations.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio提供了一个易于使用的布局设计器，允许您轻松地为各种设备配置添加布局，而无需任何麻烦。您无需记住或手动添加不同配置限定符的不同文件夹名称。设计器负责为不同配置创建、编辑和删除替代布局。
- en: 'The following section shows the usages of the Xamarin Studio layout designer
    to add alternative layouts for Android tablets:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分展示了Xamarin Studio布局设计器的用法，用于为Android平板电脑添加替代布局：
- en: Open the `POIList.axml` layout file and click on the **Content** tab to open
    the layout designer.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`POIList.axml`布局文件，并点击**内容**选项卡以打开布局设计器。
- en: Click on the **Alternative Layouts** button located in the top-left corner.
    This enables a special editor to manage the alternative layouts. The following
    screenshot depicts the special editor provided in Xamarin Studio to edit and manage
    the alternative layouts for different configurations:![](img/zOfxWkZc.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击位于左上角的**替代布局**按钮。这启用了一个特殊编辑器来管理替代布局。以下截图展示了Xamarin Studio提供的特殊编辑器，用于编辑和管理不同配置的替代布局：![img/zOfxWkZc.jpg](img/zOfxWkZc.jpg)
- en: Click on the **+New Version** button to add another version of the layout for
    a given configuration.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建版本**按钮，为给定配置添加布局的另一个版本。
- en: This will open a dialog asking for different configuration parameters. For now,
    we will consider the minimum width for the tablet layout to be `600dp`. Enter
    the smallest screen width value as `600`, and then click on **Add**:![](img/mW606wsD.jpg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这将打开一个对话框，要求输入不同的配置参数。目前，我们将平板电脑布局的最小宽度视为`600dp`。输入最小的屏幕宽度值`600`，然后点击**添加**：![img/mW606wsD.jpg](img/mW606wsD.jpg)
- en: Notice that a new folder with the name `layout-sw600dp`, and that a new version
    of the `POIList` layout will be created in the Project Explorer.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，将创建一个名为`layout-sw600dp`的新文件夹，并在项目资源管理器中创建`POIList`布局的新版本。
- en: Select the `sw600dp` layout to edit.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`sw600dp`布局进行编辑。
- en: Search for **FrameLayout** in the **Toolbox** and drag it to the simulator window
    to add it as a root element. This will be used to add `POIDetailFragment` dynamically
    when a user selects any POI from the list.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**工具箱**中搜索**FrameLayout**，并将其拖到模拟器窗口中，作为根元素添加。这将用于在用户从列表中选择任何POI时动态添加`POIDetailFragment`。
- en: Click on **FrameLayout** in the **Document Outline** view and then click on
    the **Properties** window. Set the view ID to `poiDetailLayout`.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**文档大纲**视图中点击**FrameLayout**，然后点击**属性**窗口。将视图ID设置为`poiDetailLayout`。
- en: Now we have a list fragment and a frame layout in the screen. Let's assign 40
    percent of the screen width for the list to appear and 60 percent for the details
    layout. This can be done using the `weight` property.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经在屏幕上有一个列表片段和一个帧布局。让我们为列表分配40%的屏幕宽度以显示，为详情布局分配60%的宽度。这可以通过使用`weight`属性来完成。
- en: Select `listFragment` from the **Document Outline** view and change the weight
    property to `2` and the `layout_width` property to `0dp`. This allows the weight
    property to decide the width of the view. Now, select `detailsLayout` from the
    document outline view, and change the weight property to `3` and the `layout_width`
    property to `0dp`.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 从**文档大纲**视图中选择`listFragment`，并将权重属性更改为`2`以及`layout_width`属性更改为`0dp`。这允许权重属性决定视图的宽度。现在，从文档大纲视图中选择`detailsLayout`，并将权重属性更改为`3`以及`layout_width`属性更改为`0dp`。
- en: Set the **Padding left**and **Padding right** properties to `20dp` for both
    `listFragment` and `detailsLayout`.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`listFragment`和`detailsLayout`的**Padding left**和**Padding right**属性设置为`20dp`。
- en: 'The following screenshot depicts the layout built so far:'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下截图展示了到目前为止构建的布局：
- en: '![](img/Z73UBBUs.jpg)'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/Z73UBBUs.jpg)'
- en: 'Click on the **Source** tab and notice that the following code gets generated:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**源**选项卡，注意以下代码被生成：
- en: '[PRE29]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Updating the POIApp to support the multi-pane split layout
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将POIApp更新为支持多面板分割布局
- en: In an Android tablet, the POI activity layout is declared to host both the POI
    list and POI details fragments by sharing the same screen space. The `POIListFragment`
    is statically added to the layout, and `POIDetailFragment` will be added dynamically
    when a user selects any POI item from the list. The `FrameLayout` with the `detailsLayout`
    ID is used as a placeholder to host the `POIDetailFragment`. However, in mobile
    devices, when a user clicks on any POI list item, it will continue to start `POIDetailActivity`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android平板电脑中，POI活动布局被声明为通过共享相同的屏幕空间来容纳POI列表和POI详情片段。`POIListFragment`被静态添加到布局中，当用户从列表中选择任何POI项时，`POIDetailFragment`将被动态添加。具有`detailsLayout`
    ID的`FrameLayout`用作占位符以容纳`POIDetailFragment`。然而，在移动设备中，当用户点击任何POI列表项时，它将继续启动`POIDetailActivity`。
- en: 'The following steps will take you through the changes required to make the
    `POIApp` work for the multi-pane layout in Android powered tablets:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您进行必要的更改，以使`POIApp`在Android平板电脑上的多面板布局中工作：
- en: 'First, we need to find out if the device is running in the multi-pane mode.
    This is useful in order to understand whether you want to start a new activity
    or update the fragment content in the same activity. Let''s declare a static Boolean
    variable that holds the information about whether or not an app is running in
    the dual mode:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要找出设备是否正在多面板模式下运行。这有助于了解您是想在新的活动中启动还是更新同一活动中的片段内容。让我们声明一个静态布尔变量，用于保存应用程序是否在双模式下的信息：
- en: '[PRE30]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'If the `detailsLayout` is not `null` and visible, then we can assume that the
    device is running in the multi-pane view mode. Add the following code blocks to
    your `POIListActivity` in the `OnCreate()` method to initialize the `isDualMode`
    variable:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果`detailsLayout`不为`null`且可见，则我们可以假设设备正在多面板视图模式下运行。在`POIListActivity`的`OnCreate()`方法中添加以下代码块以初始化`isDualMode`变量：
- en: '[PRE31]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Currently, the new action in `POIListFragment` takes the user to `POIDetailActivity`.
    Now for tablets, instead of invoking another activity, the `POIDetailFragment`
    will be shown on the right-hand side of the same activity.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，`POIListFragment`中的新操作会将用户带到`POIDetailActivity`。现在对于平板电脑，而不是调用另一个活动，`POIDetailFragment`将显示在同一活动的右侧。
- en: 'Add the following code blocks to the `OnOptionsItemSelected()` method under
    a new action:'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将以下代码块添加到`OnOptionsItemSelected()`方法下的新操作：
- en: '[PRE32]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that, as we are not passing any details of the POI, the `POIDetailsFragment`
    will show the empty fields and allow the user to add a new POI.
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，由于我们没有传递任何POI的详细信息，`POIDetailsFragment`将显示空字段并允许用户添加新的POI。
- en: As in the previous steps, we need the same implementation in the `OnListItemClick()`
    method. When a user clicks on the POI list item, instead of taking them to another
    activity, the POI details will be shown on the same activity in the right-hand
    details pane.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们还需要在`OnListItemClick()`方法中实现相同的逻辑。当用户点击POI列表项时，而不是将他们带到另一个活动，POI详情将在同一活动的右侧详情面板中显示。
- en: 'Update the `OnListItemClick()` method with the following code snippets:'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用以下代码片段更新`OnListItemClick()`方法：
- en: '[PRE33]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We are almost done! Let''s now run the `POIApp` in the Android tablet emulator.
    You will notice that the POI app shows the multi-pane layout, as shown in the
    following screenshot:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了！现在让我们在 Android 平板模拟器中运行 `POIApp`。你会注意到 POI 应用显示了多窗格布局，如下面的截图所示：
- en: '![](img/SpXNlUS6.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_IMG
  zh: '![](img/SpXNlUS6.jpg)'
- en: Working with DialogFragment
  id: totrans-227
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与 DialogFragment 一起工作
- en: In this chapter, we already covered how to use the fragment and `ListFragment`
    to optimize layout for Android tablets. Let's now discuss another specialized
    fragment subclass, `DialogFragment`. The current implementation of the `POIApp`
    uses `AlertDialog` to display the confirmation dialog to a user before deleting
    the POI. In this section, we will replace the `AlertDialog` implementation with
    `DialogFragment`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经介绍了如何使用片段和 `ListFragment` 来优化 Android 平板的布局。现在让我们讨论另一个专门的片段子类，`DialogFragment`。`POIApp`
    的当前实现使用 `AlertDialog` 在删除 POI 之前向用户显示确认对话框。在本节中，我们将用 `DialogFragment` 替换 `AlertDialog`
    实现。
- en: '`DialogFragment` is used to display a fragment as a floating dialog window
    that pops up on top of the current window. `DialogFragment` is the subclass of
    fragment and was introduced in Android 3.0 API level 11\. Google recommends that
    you use `DialogFragment` for implementing the dialog because of the following
    reasons:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`DialogFragment` 用于显示一个作为浮动对话框窗口的片段，该窗口会出现在当前窗口的顶部。`DialogFragment` 是片段的子类，并在
    Android 3.0 API 级别 11 中引入。谷歌建议你使用 `DialogFragment` 来实现对话框，原因如下：'
- en: Like normal fragments, `DialogFragment` manages its own life cycle. Events such
    as the user pressing the device's Back button or rotating the screen are handled
    in `DialogFragment`.
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与普通片段一样，`DialogFragment` 管理自己的生命周期。例如，用户按下设备的返回按钮或旋转屏幕等事件都在 `DialogFragment`
    中处理。
- en: A `DialogFragment` UI can be reused and embedded inside another activity. For
    example, if you wish your dialog to appear differently on different screen sizes,
    you can embed the `DialogFragment` inside the activity layout, which is similar
    to normal fragments.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DialogFragment` UI 可以被重用并嵌入到另一个活动内部。例如，如果你希望你的对话框在不同屏幕尺寸上显示不同，你可以在活动布局中嵌入
    `DialogFragment`，这与普通片段类似。'
- en: Although `DialogFragment` was introduced in Android 3.0, Google has released
    the Android support library, using which you can use the `DialogFragment` class
    for devices running on Android 1.6 or higher. The subsequent section (fragment
    for older Android devices) will describe how to add the Android Support Library
    to the Xamarin Studio solution.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然 `DialogFragment` 是在 Android 3.0 中引入的，但谷歌发布了 Android 支持库，通过它你可以使用 `DialogFragment`
    类在运行 Android 1.6 或更高版本的设备上。接下来的部分（适用于旧版 Android 设备的片段）将描述如何将 Android 支持库添加到 Xamarin
    Studio 解决方案中。
- en: 'Keeping the preceding points in mind, we will replace the `AlertDialog` and
    use `DialogFragment` in the `POIDetailFragment` class. Creating a dialog fragment
    is similar to the process of creating normal fragments. You need to first create
    a class that inherits from `DialogFragment` and overrides one of the following
    methods to provide the view hierarchy for your dialog:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在牢记前面的要点的基础上，我们将替换 `AlertDialog` 并在 `POIDetailFragment` 类中使用 `DialogFragment`。创建对话框片段的过程与创建普通片段类似。你需要首先创建一个继承自
    `DialogFragment` 的类，并重写以下方法之一来为你的对话框提供视图层次结构：
- en: '`OnCreateView()`: This method is used to inflate the layout for the dialog.
    It is the same as the `Fragment.OnCreateView()` callback. If you want your fragment
    UI to be reusable / embedded inside another view, you must override `OnCreateView()`
    and inflate the layout.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCreateView()`: 这个方法用于填充对话框的布局。它与 `Fragment.OnCreateView()` 回调相同。如果你想使你的片段
    UI 可重用/嵌入到另一个视图内部，你必须重写 `OnCreateView()` 并填充布局。'
- en: '`OnCreateDialog()`: This method returns an instance of `Dialog`. This method
    is called automatically while creating the layout for the dialog. As we have already
    used `AlertDialog` in the `POIApp`; in this example, we will override the `OnCreateDialog()`
    to create the `DialogFragment`.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCreateDialog()`: 这个方法返回一个 `Dialog` 实例。在创建对话框布局时，这个方法会自动被调用。由于我们已经在 `POIApp`
    中使用了 `AlertDialog`；在这个例子中，我们将重写 `OnCreateDialog()` 来创建 `DialogFragment`。'
- en: 'The following steps will show you how use the `DialogFragment` class to show
    the **Delete** confirmation dialog to a user:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将展示如何使用 `DialogFragment` 类向用户显示 **删除** 确认对话框：
- en: Create a new fragment class and name it `DeleteDialogFragment`.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的片段类，并将其命名为 `DeleteDialogFragment`。
- en: 'Inherit the `DeleteDialogFragment` class from `DialogFragment`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `DialogFragment` 类继承 `DeleteDialogFragment` 类：
- en: '[PRE34]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Override the `OnCreateDialog()` method and add the following code snippets.
    The code blocks used in the `OnCreateDialog()` method are similar to the code
    we used in `POIDetailFragment` in the `DeletePOI()` method:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`OnCreateDialog()`方法并添加以下代码片段。在`OnCreateDialog()`方法中使用的代码块与我们之前在`POIDetailFragment`的`DeletePOI()`方法中使用的代码块类似：
- en: '[PRE35]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We have constructed a basic version of `DialogFragment`. Now we need to initialize
    the fragment and use the `FragmentTransaction` to display the dialog box. Add
    the following code snippets to the `POIDetailFragment DeletePOI()` method:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经构建了一个基本的`DialogFragment`版本。现在我们需要初始化片段并使用`FragmentTransaction`来显示对话框。将以下代码片段添加到`POIDetailFragment
    DeletePOI()`方法中：
- en: '[PRE36]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Like any other fragment, the operations on the dialog fragments are done using
    fragment transactions. The `Show()` method is used to add the dialog fragment
    to the activity view hierarchy and then commit the transaction. This takes two
    parameters: an instance of the fragment transaction, and a tag. The string value
    tag can be used later to retrieve the fragment instance from the fragment manager.'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 任何其他片段的操作都是通过片段事务来完成的。使用`Show()`方法将对话框片段添加到活动视图层次结构中，然后提交事务。这需要两个参数：一个片段事务的实例和一个标签。字符串值标签可以在以后用于从片段管理器检索片段实例。
- en: Now run and test the `POIApp`. Notice that the dialog fragment works great.
    However, it doesn't display the name of the POI that the user wants to delete.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在运行并测试`POIApp`。注意，对话框片段工作得很好。然而，它没有显示用户想要删除的POI的名称。
- en: To display the name of the POI in the **Delete** confirmation dialog, we need
    to pass the POI name to `DeleteDialogFragment`. This can be accomplished using
    the fragment `Arguments` property.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在**删除**确认对话框中显示POI的名称，我们需要将POI名称传递给`DeleteDialogFragment`。这可以通过使用片段的`Arguments`属性来实现。
- en: 'Add the following code snippets to the `DeletePOI()` method after the fragment
    initialization and before calling `dialogFragment.Show()`:'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在片段初始化之后和调用`dialogFragment.Show()`之前，将以下代码片段添加到`DeletePOI()`方法中：
- en: '[PRE37]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we need to make the following changes to the `DeleteDialogFragment` class
    in the `OnCreateDialog()` method to retrieve and display the name of the POI:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在`DeleteDialogFragment`类的`OnCreateDialog()`方法中进行以下更改以检索和显示POI的名称：
- en: '[PRE38]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Run the `POIApp` and notice that the **Delete** confirmation dialog now displays
    the name of the POI to be deleted. However, when you click on the **OK** button,
    the dialog is dismissed but the `delete` action is not working. We will pass the
    event callback from the fragment dialog to the `POIDetailFragment`. This can be
    easily accomplished using the `TargetFragment` property.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`POIApp`并注意，**删除**确认对话框现在显示了要删除的POI的名称。然而，当你点击**确定**按钮时，对话框被关闭，但`删除`操作没有执行。我们将从片段对话框传递事件回调到`POIDetailFragment`。这可以通过使用`TargetFragment`属性轻松实现。
- en: 'While adding the dialog fragment, we need to provide the target fragment information
    to the dialog by calling the `SetTargetFragment()` method. This method accepts
    two parameters: an instance of fragments that is the target of the dialog, and
    an optional integer request code.'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在添加对话框片段时，我们需要通过调用`SetTargetFragment()`方法向对话框提供目标片段信息。此方法接受两个参数：一个片段实例，它是对话框的目标，以及一个可选的整型请求代码。
- en: 'The following code snippet shows the changes required in the `DeletePOI()`
    method:'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在`DeletePOI()`方法中所需的更改：
- en: '[PRE39]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Now we can access the instance of POIDetailsFragment from the dialog fragment
    using the `TargetFragment` property, and call the `DeletePOIAsync()` method to
    initiate the delete POI web service request.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以通过使用`TargetFragment`属性从对话框片段访问`POIDetailsFragment`的实例，并调用`DeletePOIAsync()`方法来启动删除POI的Web服务请求。
- en: 'The following code shows what should be present in the `DeleteDialogFragment`
    class:'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 以下代码展示了`DeleteDialogFragment`类中应该包含的内容：
- en: '[PRE40]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Now run and test the `POIApp`. Notice that the `DeletePOI` is fully functional
    with `FragmentDialog`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行并测试`POIApp`。注意，`DeletePOI`与`FragmentDialog`一起完全功能正常。
- en: Fragments for older Android devices
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适用于旧版Android设备的片段
- en: As we discussed earlier, the Fragment API was added in Android 3.0 API level
    11\. In the `POIApp` example discussed so far, I have assumed that the user who
    tests my application will be using Android 3.0 or later. However, if your business
    demands that you support your app for older devices, then you can still take advantage
    of the new Fragment API classes.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前讨论的，Fragment API是在Android 3.0 API级别11中添加的。在迄今为止讨论的`POIApp`示例中，我假设测试我的应用程序的用户将使用Android
    3.0或更高版本。然而，如果你的业务需求要求你支持旧设备上的应用程序，那么你仍然可以利用新的Fragment API类。
- en: As there is some portion of the market still running on 3.0, Google provides
    support libraries that allow you to implement fragments while maintaining backward
    compatibility. The Fragment features are available in the V4 support library,
    and it works in Android 1.6 API level 4.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于市场上仍有一部分在使用3.0版本，谷歌提供了支持库，允许你在保持向后兼容的同时实现片段。Fragment功能在V4支持库中可用，且在Android
    1.6 API级别4上运行。
- en: You cannot directly use the `Fragment` class as we have used it in this chapter.
    You have to add the Support package to your solution. For users of Xamarin Studio
    5.9.x or above, while creating a new solution, you can select **Maximum Compatibility**
    for the targeted platform selection to include support packages in your project.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能直接使用我们在本章中使用的`Fragment`类。你必须将支持包添加到你的解决方案中。对于Xamarin Studio 5.9.x或更高版本的用户，在创建新解决方案时，你可以为目标平台选择选择**最大兼容性**以将支持包包含到你的项目中。
- en: 'Alternatively, you can add Android support packages by navigating to **Packages**
    | **Add packages**. This will open the NuGet package browser, as shown in the
    following screenshot. You can search for Support packages and click on the **Add
    Package** button to add the selected package to your project:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以通过导航到**包** | **添加包**来添加Android支持包。这将打开NuGet包浏览器，如下面的截图所示。你可以搜索支持包，然后点击**添加包**按钮将选定的包添加到你的项目中：
- en: '![](img/iPwO3foe.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/iPwO3foe.jpg)'
- en: 'After the Android Support packages are added to the project, you can start
    implementing the fragment features for older Android devices. The Support package
    fragment classes work pretty much similar to the native Android 3.0 compatible
    fragment classes. However, the following are some of the changes required by your
    app for using the supported compatible APIs:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在将Android支持包添加到项目后，你可以开始为旧版Android设备实现片段功能。支持包的片段类基本上与原生Android 3.0兼容的片段类相似。然而，以下是一些你的应用程序在使用支持兼容API时需要进行的更改：
- en: Your activity that will host the support fragment must extend now and inherit
    from `Support.V4.App.FragmentActivity`
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将要承载支持片段的活动必须现在扩展并从`Support.V4.App.FragmentActivity`继承。
- en: Use `Support.V4.App.Fragment` instead of `Android.App.Fragment`
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Support.V4.App.Fragment`而不是`Android.App.Fragment`
- en: Use `SupportFragmentManager` instead of `FragmentManager`
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SupportFragmentManager`而不是`FragmentManager`
- en: Handling configuration changes with fragments
  id: totrans-269
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用片段处理配置更改
- en: In Chapter 6, *Making Your App Orientation-aware*, we discussed how Android
    activities respond to device configuration changes. In this section, we will take
    a look at the fragment behavior in the event of configuration changes.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在第6章*使你的应用方向感知*中，我们讨论了Android活动如何响应设备配置更改。在本节中，我们将探讨在配置更改事件中片段的行为。
- en: Like activities, fragment provides the `OnSaveInstanceState()` method that can
    be used to save the state of your fragment. This works in pretty much the same
    way as its activity counterpart. The `OnSaveInstanceState()` method supplies a
    `Bundle` instance into which we can dump the data bundles. The saved fragment
    instance can be retrieved from the `OnCreate()`, `OnActivityCreated()`, or `OnCreateView()`
    callback.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 与活动类似，片段提供了`OnSaveInstanceState()`方法，可以用来保存你的片段状态。这基本上与它的活动对应方法相同。`OnSaveInstanceState()`方法提供了一个`Bundle`实例，我们可以将其中的数据包导出。保存的片段实例可以从`OnCreate()`、`OnActivityCreated()`或`OnCreateView()`回调中检索。
- en: 'The following steps will guide you through saving and retaining the POI list
    scroll position when the device configuration changes:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导你如何在设备配置更改时保存和保留POI列表的滚动位置：
- en: 'Get the index of the first visible list item and save it to a bundle in the
    `OnSaveInstanceState()` method:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnSaveInstanceState()`方法中获取第一个可见列表项的索引并将其保存到bundle中：
- en: '[PRE41]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: In the preceding code snippet, the string `scroll_position` is used as the key
    to save the current scroll position of `ListView`.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，字符串`scroll_position`被用作键来保存`ListView`的当前滚动位置。
- en: 'Restore the saved list''s scrolling position in `OnCreate()`. Note that we
    have to use the same key that we used to save:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnCreate()`中恢复保存的列表的滚动位置。注意我们必须使用我们保存时使用的相同键：
- en: '[PRE42]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following code snippet to the `DownloadPoisListAsync()` method in the
    `POIListFragment` class. This queues a message to scroll the POI list view to
    the previously saved scroll position:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`POIListFragment`类中的`DownloadPoisListAsync()`方法。这将队列一个消息以将POI列表视图滚动到之前保存的滚动位置：
- en: '[PRE43]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Build and run the app on the Android device or emulator. Change your device
    orientation and notice that the list view scroll position is now retained.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android设备或模拟器上构建和运行应用程序。更改您的设备方向并注意现在列表视图的滚动位置已保留。
- en: Summary
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered a lot of ground on creating and managing fragments,
    including the following topics:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了创建和管理片段的许多内容，包括以下主题：
- en: The `Fragment` class and what it does, and creating and managing fragments
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Fragment`类及其功能，以及创建和管理片段'
- en: How to use a declarative approach for adding fragments to activities using the
    `&lt;fragment&gt;` tag
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用声明性方法通过`<fragment>`标签将片段添加到活动中
- en: Using `ListFragment` with `ListAdapter` to populate the data
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`ListFragment`和`ListAdapter`来填充数据
- en: How to add alternative layout resources from Xamarin Studio layout designer
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Xamarin Studio布局设计器添加替代布局资源
- en: How to reuse the fragments to create a multi-pane split view layout for Android
    tablets
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何重用片段以创建适用于Android平板电脑的多窗格分割视图布局
- en: How to create a dialog using `DialogFragment`, and create its view hierarchy
    using the `OnCreateDialog()` method
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用`DialogFragment`创建对话框，并使用`OnCreateDialog()`方法创建其视图层次结构
- en: Optimizing the `POIApp` layout to support large-screen Android tablets
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化`POIApp`布局以支持大屏幕Android平板电脑
- en: Dealing with configuration changes to save and retain the fragment state
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理配置更改以保存和保留片段状态
- en: The next chapter will guide you to deal with data persistence using SQLite in
    Android.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将指导你使用SQLite在Android中处理数据持久化。
- en: 'Let''s take a look at the following references:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下参考：
- en: '[http://android-developers.blogspot.in/2012/11/designing-for-tablets-were-here-to-help.html](http://android-developers.blogspot.in/2012/11/designing-for-tablets-were-here-to-help.html)'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://android-developers.blogspot.in/2012/11/designing-for-tablets-were-here-to-help.html](http://android-developers.blogspot.in/2012/11/designing-for-tablets-were-here-to-help.html)'
- en: '[https://developer.android.com/distribute/essentials/quality/tablets.html](https://developer.android.com/distribute/essentials/quality/tablets.html)'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/distribute/essentials/quality/tablets.html](https://developer.android.com/distribute/essentials/quality/tablets.html)'
- en: '[http://developer.xamarin.com/guides/android/user_interface/designer_overview/part_3_-_alternative_layout_views/](http://developer.xamarin.com/guides/android/user_interface/designer_overview/part_3_-_alternative_layout_views/)'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://developer.xamarin.com/guides/android/user_interface/designer_overview/part_3_-_alternative_layout_views/](http://developer.xamarin.com/guides/android/user_interface/designer_overview/part_3_-_alternative_layout_views/)'
