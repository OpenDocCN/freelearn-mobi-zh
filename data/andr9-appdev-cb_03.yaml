- en: Views, Widgets, and Styles
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 视图、小部件和样式
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Inserting a widget into a layout
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在布局中插入小部件
- en: Using graphics to show the button state
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形显示按钮状态
- en: Creating a widget at runtime
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时创建小部件
- en: Creating a custom component
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: Applying a style to a View
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式应用到视图
- en: Turning a style into a theme
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将样式转换为主题
- en: Selecting a theme based on the Android OS version
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据Android操作系统版本选择主题
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The term **widgets** can refer to several different concepts in Android. When
    most people talk about widgets, they are referring to **app widgets**, which are
    typically seen on the home screen. App widgets are like mini applications by themselves
    as they usually provide a subset of functionality, based on their main application.
    (Usually, most app widgets are installed along with an application, but that is
    not a requirement. They can be standalone apps in a widget format.) A common app
    widget example is a weather application that offers several different app widgets
    for the home screen. [Chapter 6](1521f6e9-278d-413a-9d00-374d369b6acb.xhtml),
    *Beyond Your App - Home Screen Widgets, Search, and the System UI*, will discuss
    home screen app widgets and provide recipes to create your own.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，术语**小部件**可以指几个不同的概念。当大多数人谈论小部件时，他们指的是**应用小部件**，通常在主屏幕上看到。应用小部件本身就像迷你应用程序，因为它们通常提供基于其主要应用程序的功能子集。（通常，大多数应用小部件与应用程序一起安装，但这不是必需的。它们可以作为独立的应用程序以小部件格式存在。）一个常见的小部件应用示例是提供几个不同小部件的主屏幕天气应用程序。[第6章](1521f6e9-278d-413a-9d00-374d369b6acb.xhtml)，*超越您的应用
    - 主屏幕小部件、搜索和系统UI*，将讨论主屏幕应用小部件并提供创建自己的菜谱。
- en: When developing for Android, the term widgets generally refers to specialized
    Views placed in the layout files, such as a Button, TextView, CheckBox, and so
    on. This chapter will focus on widgets for screen layouts.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在为Android开发时，术语小部件通常指的是放置在布局文件中的专用视图，如Button、TextView、CheckBox等。本章将专注于屏幕布局的小部件。
- en: 'To see the list of widgets provided in the **Android SDK**, open a layout file
    in Android Studio, and click on the Design tab. Along the left-hand side of the
    Design view, you will see the list of items that can be placed on the layout: Common,
    Text, Buttons, Widgets, Layouts, Containers, Google, and Legacy. Even though many
    of the items are not in the Widget category, by definition, they are still widgets.
    As you can see in the following screenshot, the Widgets category groups the more
    complicated controls:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看**Android SDK**提供的部件列表，请在Android Studio中打开一个布局文件，并点击设计标签。在设计视图的左侧，您将看到可以放置在布局中的项目列表：常用、文本、按钮、小部件、布局、容器、Google和遗留。尽管许多项目不在小部件类别中，但根据定义，它们仍然是小部件。如图所示，小部件类别将更复杂的控件分组：
- en: '![](img/33485eb8-95a3-42d6-9f5d-dba55d072fe5.png)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/33485eb8-95a3-42d6-9f5d-dba55d072fe5.png)'
- en: As you can see from the list, the Android SDK provides many useful widgets—from
    a simple TextView, Button, or Checkbox, to the much more complex widgets such
    as the WebView, ProgressBar, and SearchView. As useful as the built-in widgets
    are, it's also very easy to expand on what's provided in the SDK. We can extend
    an existing widget to customize its functionality, or we can create our own widget
    from scratch by extending the base View class. (We will provide an example of
    this in the *Creating a custom component* recipe later.)
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如列表所示，Android SDK提供了许多有用的部件——从简单的TextView、Button或Checkbox，到更复杂的部件，如WebView、ProgressBar和SearchView。尽管内置部件很有用，但也很容易在SDK提供的内容上扩展。我们可以扩展现有部件以自定义其功能，或者我们可以通过扩展基本View类从头创建自己的部件。（我们将在后面的*创建自定义组件*菜谱中提供一个例子。）
- en: The visual look of widgets can also be customized. These settings can be used
    to create **styles**, which in turn can be used to create **themes**. Just like
    with other development environments, creating a theme offers the benefit of easily
    changing the appearance throughout our entire application with minimal effort.
    Lastly, the Android SDK also provides many built-in themes and variations, such
    as the Material theme introduced in Android 5 and later the Material Design 2.0.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的视觉外观也可以自定义。这些设置可以用来创建**样式**，进而可以用来创建**主题**。就像在其他开发环境中一样，创建主题的好处是可以通过最小的努力轻松地更改整个应用程序的外观。最后，Android
    SDK还提供了许多内置主题和变体，例如在Android 5中引入的Material主题以及之后的Material Design 2.0。
- en: Inserting a widget into a layout
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在布局中插入小部件
- en: As you may have seen from previous recipes, **widgets** are declared in a layout
    file, or created in code. For this recipe, we will go step by step to add a button
    with the Android Studio Designer. (For later recipes, we will just show the layout
    XML.) After creating the button, we will create a method to receive the button
    click events using `onClickListener()`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从之前的菜谱中看到的，**小部件**是在布局文件中声明的，或者是在代码中创建的。在这个菜谱中，我们将一步一步地使用 Android Studio 设计器添加一个按钮。（对于后续的菜谱，我们只会展示布局
    XML。）创建按钮后，我们将创建一个方法来接收按钮点击事件，使用 `onClickListener()`。
- en: Getting ready
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `InsertWidget`. Use the default
    options for creating a Phone and Tablet project and select Empty Activity when
    prompted for the Activity Type. You can delete the default `TextView` (or leave
    it) as it will not be needed for this recipe.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中启动一个新项目，并将其命名为 `InsertWidget`。使用创建手机和平板项目的默认选项，并在提示活动类型时选择空活动。你可以删除默认的
    `TextView`（或者保留它），因为在这个菜谱中不需要它。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To insert a widget into a layout, follow these steps:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要将小部件插入到布局中，请按照以下步骤操作：
- en: 'Open the `activity_main.xml` file in Android Studio and click on the Design
    tab. As you can see, by default, Android Studio adds a `TextView` to the layout.
    Select the `TextView` and delete it:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中打开 `activity_main.xml` 文件并点击设计标签。如您所见，默认情况下，Android Studio
    会向布局添加一个 `TextView`。选择 `TextView` 并删除它：
- en: '![](img/73e5ebe5-038d-4277-9f6c-19aab5efc25a.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/73e5ebe5-038d-4277-9f6c-19aab5efc25a.png)'
- en: 'Find Button in the widget list and drag it to the center of the activity screen
    on the right:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在小部件列表中找到按钮并将其拖到活动屏幕右边的中心：
- en: '![](img/da220ca8-1259-4491-9945-b7d54804b6cf.png)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/da220ca8-1259-4491-9945-b7d54804b6cf.png)'
- en: 'Though we placed the button in the center of the screen, the button will not
    actually be centered when you run the app. If we want it centered, we need to
    set the layout properties accordingly. (Currently, the button is just centered
    in the design tool to make it easier to work with but this has no affect when
    the app is running.) To center the button, start by selecting the button in the
    design view. When it is selected, you will see the edge nodes. Drag each edge
    node to the corresponding edge of the screen as shown in the following screenshot:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 虽然我们将按钮放置在屏幕中心，但在运行应用程序时按钮实际上并不会居中。如果我们想让它居中，我们需要相应地设置布局属性。（目前，按钮只是在设计工具中居中，以便更容易工作，但这在应用程序运行时没有任何影响。）要使按钮居中，首先在设计视图中选择按钮。当它被选中时，你会看到边缘节点。将每个边缘节点拖动到屏幕相应边缘，如图所示：
- en: '![](img/3f0babc7-7a16-48de-a5a7-f758e24112ce.png)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3f0babc7-7a16-48de-a5a7-f758e24112ce.png)'
- en: 'To view the `xml` created, click on the Text tab as shown in the following
    screenshot. See how the button is centered using the `ConstraintLayout` parameters.
    Also, take note of the default ID as we will need it for the next step:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看创建的 `xml`，请点击文本标签，如图所示。看看按钮是如何使用 `ConstraintLayout` 参数居中的。还要注意默认 ID，因为我们将在下一步需要它：
- en: '![](img/eb81e949-1a40-4441-8416-75bbbf5b9989.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eb81e949-1a40-4441-8416-75bbbf5b9989.png)'
- en: 'Now, open the `MainActivity.java` file to edit the code. Add the following
    code to the `onCreate()` method to set up `onClickListener()`:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `MainActivity.java` 文件来编辑代码。将以下代码添加到 `onCreate()` 方法中以设置 `onClickListener()`：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Run the application on a device or emulator.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Creating the UI with the Android Studio is as simple as dragging and dropping
    Views. You can also edit the properties of the Views directly in the Design tab.
    Switching to the XML code is as simple as hitting the Text tab.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Android Studio 创建 UI 与拖放视图一样简单。你还可以直接在设计标签页中编辑视图的属性。切换到 XML 代码就像点击文本标签一样简单。
- en: 'What we did here is very common in Android development – creating the UI in
    XML, then hooking up the UI components (Views) in the Java code. To reference
    a View from code, it must have a resource identifier associated with it. This
    is done using the `id` parameter:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是 Android 开发中非常常见的事情——在 XML 中创建 UI，然后在 Java 代码中连接 UI 组件（视图）。要从代码中引用视图，它必须与一个资源标识符相关联。这是通过使用
    `id` 参数来完成的：
- en: '[PRE1]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `onClickListener` function displays a pop-up message on the screen called
    **Toast**, when the button is pressed.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `onClickListener` 函数在按钮按下时在屏幕上显示一个名为 **Toast** 的弹出消息。
- en: There's more...
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Take a look again at the format of the identifier we created previously, `@+id/button`.
    The `@` sign specifies this is going to be a resource and the `+` sign indicates
    a new resource. (If we failed to include the plus sign, we would get a compile-time
    error stating No resource matched the indicated name).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 再次看看我们之前创建的标识符的格式，`@+id/button`。`@`符号指定这是一个资源，而`+`符号表示一个新的资源。（如果我们没有包含加号，我们会得到一个编译时错误，指出没有资源与指定的名称匹配）。
- en: See also
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '*Butter Knife – Field and method binding for Android views* (open source project):
    [http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Butter Knife – 字段和方法绑定用于Android视图*（开源项目）: [http://jakewharton.github.io/butterknife/](http://jakewharton.github.io/butterknife/)'
- en: Using graphics to show button state
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用图形来显示按钮状态
- en: We've talked about the versatility of Android Views and how behavior and visual
    appearance can be customized. In this recipe, we will create a drawable **state
    selector**, which is a resource defined in XML that specifies the drawable to
    use based on the View's state.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了Android视图的通用性以及如何自定义行为和视觉外观。在这个菜谱中，我们将创建一个可绘制**状态选择器**，这是一个在XML中定义的资源，它根据视图的状态指定要使用的可绘制资源。
- en: 'The most commonly used states, along with the possible values, include the
    following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的状态及其可能的值包括以下内容：
- en: '`state_pressed=["true" | "false"]`'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_pressed=["true" | "false"]`'
- en: '`state_focused=["true" | "false"]`'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_focused=["true" | "false"]`'
- en: '`state_selected=["true" | "false"]`'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_selected=["true" | "false"]`'
- en: '`state_checked=["true" | "false"]`'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_checked=["true" | "false"]`'
- en: '`state_enabled=["true" | "false"]`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`state_enabled=["true" | "false"]`'
- en: 'To define a state selector, create an XML file with the `<selector>` element,
    as shown:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义状态选择器，创建一个包含`<selector>`元素的XML文件，如下所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Within the `<selector>` element, we define an `<item>` element to identify
    the drawable to be used based on the specified state(s). Here''s an example `<item>`
    element using multiple states:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在`<selector>`元素内，我们定义一个`<item>`元素来识别基于指定状态的可绘制资源。以下是一个使用多个状态的`<item>`元素的示例：
- en: '[PRE3]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: It's important to remember the file is read from top to bottom so the first
    item that meets the state requirements will be used. A default drawable, one with
    no states included, would need to go last.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要记住文件是从上到下读取的，所以第一个满足状态要求的项将被使用。一个默认的可绘制资源，即没有包含状态的资源，需要放在最后。
- en: For this recipe, we will use a state selector to change the background color
    based on the `ToggleButton` state.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将使用状态选择器根据`ToggleButton`的状态来改变背景颜色。
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `StateSelector` using the
    default Phone & Tablet options. When prompted for the Activity Type, select Empty
    Activity. To make it easier to type the code for this recipe, we will use a color
    as the graphic to represent the button state.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`StateSelector`，使用默认的智能手机和平板电脑选项。当提示选择活动类型时，选择空活动。为了使编写此菜谱的代码更简单，我们将使用颜色作为图形来表示按钮状态。
- en: How to do it...
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'We will start by creating the state selector, which is a resource file defined
    with XML code. We will then set up the button to use our new state selector. Here
    are the steps:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建状态选择器，这是一个使用XML代码定义的资源文件。然后我们将设置按钮使用我们新的状态选择器。以下是步骤：
- en: 'Create a new Drawable resource file in the `res/drawable` folder and call it:
    `state_selector.xml`. The file should contain the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/drawable`文件夹中创建一个新的Drawable资源文件，并将其命名为：`state_selector.xml`。该文件应包含以下代码：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now open the `activity_main.xml` file and drop in `ToggleButton` as follows:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在打开`activity_main.xml`文件，并按照以下方式添加`ToggleButton`：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Run the application on a device or emulator.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The main concept to understand here is the Android State Selector. As shown
    in step 1, we created a resource file to specify a **drawable** (a color in this
    case) based on `state_checked`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这里要理解的主要概念是Android状态选择器。如步骤1所示，我们创建了一个资源文件来指定基于`state_checked`的**可绘制资源**（在这种情况下是一个颜色）。
- en: Android supports many other state conditions besides checked. While typing in
    `android:state`, look at the autocomplete drop-down menu to see the list of other
    options.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Android支持除已检查之外的其他许多状态条件。当在`android:state`中键入时，查看自动完成下拉菜单以查看其他选项列表。
- en: 'Once we have the drawable resource created (the XML from step 1), we just have
    to tell the view to use it. Since we want the background color to change based
    on the state, we use the `android:background` property. The `state_selector.xml` is
    a drawable resource that can be passed to any property that accepts a drawable.
    We could, for example, replace the check image of a checkbox with the following
    XML:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了可绘制资源（步骤 1 中的 XML），我们只需告诉视图使用它即可。由于我们希望背景颜色根据状态改变，我们使用 `android:background`
    属性。`state_selector.xml` 是一个可绘制资源，可以传递给任何接受可绘制资源的属性。例如，我们可以用以下 XML 替换复选框的勾选图像：
- en: '[PRE6]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: There's more...
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多...
- en: 'What if we wanted actual images for the graphics instead of just a color change?
    This is as easy as changing the drawable referenced in the item state. The source
    code available for download uses two graphics, downloaded from: [https://pixabay.com/](https://pixabay.com/)
    (this site was chosen because the images are free to use and don''t require a
    login).'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要实际的图像而不是仅仅改变颜色呢？这就像更改项目状态中引用的可绘制资源一样简单。可用于下载的源代码使用了两个图形，下载自：[https://pixabay.com/](https://pixabay.com/)（选择此网站是因为图像免费使用且无需登录）。
- en: 'Once you have your desired images, place them in the `res/drawable` folder.
    Then, change the state item line in the XML to reference your images. Here''s
    an example:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您有了所需的图像，请将它们放置在 `res/drawable` 文件夹中。然后，将 XML 中的状态项行更改为引用您的图像。以下是一个示例：
- en: '[PRE7]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: (Change `check_on` to match your image resource name)
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: （将 `check_on` 改为与您的图像资源名称匹配）
- en: Using designated folders for screen-specific resources
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用指定文件夹为特定屏幕资源
- en: When Android encounters a `@drawable` reference, it expects to find the target
    in one of the `res/drawable` folders. These are designed for different screen
    densities - `ldpi` (low dots per inch), `mdpi` (medium), `hdpi` (high), and `xhdpi`
    (extra-high) - and they allow us to create resources for specific target devices.
    When an application is running on a specific device, Android will load resources
    from the designated folder that most closely matches the actual screen density.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 遇到 `@drawable` 引用时，它期望在 `res/drawable` 文件夹之一中找到目标。这些是为不同的屏幕密度设计的 - `ldpi`（每英寸低点数）、`mdpi`（中等）、`hdpi`（高）和
    `xhdpi`（超高） - 并且允许我们为特定目标设备创建资源。当应用程序在特定设备上运行时，Android 将从与实际屏幕密度最接近的指定文件夹中加载资源。
- en: If it finds this folder empty, it will try the next nearest match and so on
    until it finds the named resource. For tutorial purposes, a separate set of files
    for each possible density is not required, and so placing our images in the `drawable`
    folder is a simple way to run the exercise on any device.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果它发现此文件夹为空，它将尝试下一个最近的匹配，依此类推，直到找到命名的资源。出于教程目的，不需要为每个可能的密度设置一组单独的文件，因此将我们的图像放置在
    `drawable` 文件夹中是运行练习的简单方法。
- en: For a complete list of resource identifiers available, visit [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取可用的资源标识符的完整列表，请访问 [http://developer.android.com/guide/topics/resources/providing-resources.html](http://developer.android.com/guide/topics/resources/providing-resources.html)。
- en: See also
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For another example of Android resource selection, see the *Selecting a theme
    based on the Android version *recipe
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Android 资源选择的另一个示例，请参阅 *根据 Android 版本选择主题* 菜谱
- en: Creating a widget at runtime
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时创建小部件
- en: As mentioned before, generally, the UI is declared in XML files and then modified
    during runtime through the Java code. It is possible to create the UI completely
    in Java code, though for a complex layout, it would generally not be considered
    best practice.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，通常 UI 在 XML 文件中声明，然后在运行时通过 Java 代码进行修改。虽然可以在 Java 代码中完全创建 UI，但对于复杂的布局，通常不会将其视为最佳实践。
- en: In this recipe, we are going to add a view to the existing layout defined in
    `activity_main.xml`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将向在 `activity_main.xml` 中定义的现有布局中添加一个视图。
- en: Getting ready
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimeWidget`. Select the
    Empty Activity option when prompted for the Activity Type.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `RuntimeWidget`。当提示选择 Activity 类型时，选择 Empty
    Activity 选项。
- en: How to do it...
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We will start by adding an ID attribute to the existing layout so we can access
    the layout in code. Once we have a reference to the layout in code, we can add
    new views to the existing layout. Here are the steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向现有布局添加一个 ID 属性，以便在代码中访问该布局。一旦我们在代码中有了布局的引用，我们就可以向现有布局添加新视图。以下是步骤：
- en: 'Open`res/layout/activity_main.xml` and add an ID attribute to the root `ConstraintLayout`,
    as follows:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `res/layout/activity_main.xml` 并向根 `ConstraintLayout` 添加一个 ID 属性，如下所示：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Completely remove the default `<TextView>` element.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完全移除默认的 `<TextView>` 元素。
- en: 'Open the `MainActivity.java` file so we can add code to the `onCreate()` method.
    Add the following code (after `setContentView())` to get a reference to `ConstraintLayout`:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 文件，以便我们可以向 `onCreate()` 方法中添加代码。在 `setContentView()`
    之后添加以下代码以获取对 `ConstraintLayout` 的引用：
- en: '[PRE9]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Create `DatePicker` and add it to the layout with the following code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `DatePicker` 并使用以下代码将其添加到布局中：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Run the program on a device or emulator.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is hopefully very straightforward code. First, we get a reference to the
    parent layout using `findViewById`. We added the ID to the existing `ConstraintLayout`
    (in step 1) to get a reference. We create a `DatePicker` in code and add it to
    the layout with the `addView()` method.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码希望非常直观。首先，我们使用 `findViewById` 获取父布局的引用。我们在现有的 `ConstraintLayout`（在第 1 步中）中添加了
    ID 以获取引用。我们通过 `addView()` 方法在代码中创建一个 `DatePicker` 并将其添加到布局中。
- en: There's more...
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'What if we wanted to create the entire layout from code? Though it may not
    be considered best practice, there are times when it is certainly easier (and
    less complex) to create the entire layout from code. Let''s see how this example
    would look if we didn''t use the layout from `activity_main.xml`. Here''s how
    `onCreate()` would look:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想从代码中创建整个布局呢？虽然这可能不被认为是最佳实践，但在某些情况下，从代码中创建整个布局确实更容易（且更简单）。让我们看看如果我们没有使用
    `activity_main.xml` 中的布局，这个例子会是什么样子。以下是 `onCreate()` 的样子：
- en: '[PRE11]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this example, it's really not that different. If you create a view in code
    and want to reference it later, you either need to keep a reference to the object,
    or assign the view an ID to use `findViewByID()`. To give a view an ID, use the
    `setID()` method by passing in `View.generateViewId()` (to generate a unique ID)
    or define the ID using `<resources>` in XML.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，实际上并没有太大的不同。如果你在代码中创建了一个视图并希望稍后引用它，你需要保留对对象的引用，或者给视图分配一个 ID 以使用 `findViewByID()`。要给视图分配一个
    ID，请使用 `setID()` 方法并通过传递 `View.generateViewId()`（以生成一个唯一的 ID）或使用 XML 中的 `<resources>`
    定义 ID。
- en: Creating a custom component
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义组件
- en: As we have seen in previous recipes, the Android SDK provides a wide range of
    components. But what happens when you can't find a prebuilt component that fits
    your unique needs? You can always create your own!
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在之前的菜谱中看到的，Android SDK 提供了广泛的各种组件。但是，当你找不到适合你独特需求的预构建组件时会发生什么？你总是可以创建自己的！
- en: 'In this recipe, we will walk through creating a custom component that derives
    from the `View` class, just like the built-in widgets. Here''s a high-level overview:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将逐步创建一个从 `View` 类派生的自定义组件，就像内置小部件一样。以下是高级概述：
- en: Create a new class that extends View.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类，它扩展了 `View` 类。
- en: Create custom constructor(s).
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建自定义构造函数(s)。
- en: Override `onMeasure()`, as the default implementation returns a size of 100
    x 100.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `onMeasure()`，因为默认实现返回 100 x 100 的大小。
- en: Override `onDraw()`, as the default implementation draws nothing.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 覆盖 `onDraw()`，因为默认实现不绘制任何内容。
- en: Define custom methods and listeners (such as the `onClick()` event).
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义自定义方法和监听器（例如 `onClick()` 事件）。
- en: Implement custom functionality.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现自定义功能。
- en: Overriding `onMeasure()` and `onDraw()` is not strictly required, but the default
    behavior is likely not what you would want.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖 `onMeasure()` 和 `onDraw()` 不是严格要求的，但默认行为可能不是你想要的。
- en: Getting ready
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `CustomView`. Use the default
    wizard options, including the Phone & Tablet SDK and select Empty Activity when
    prompted for the Activity Type. Once the project files are created and open in
    Android Studio, you are ready to begin.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中开始一个新的项目，并将其命名为 `CustomView`。使用默认向导选项，包括手机和平板 SDK，并在被提示活动类型时选择空活动。一旦项目文件创建并打开在
    Android Studio 中，你就可以开始工作了。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create a new class for our custom component to derive from the Android
    `View` class. Our custom component could be a subclass of an existing class, such
    as the activity, but we will create it in a separate file to make it easier to
    maintain. Here are the steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为我们的自定义组件创建一个新的类，使其从 Android 的 `View` 类派生。我们的自定义组件可以是现有类的子类，例如活动，但我们将在单独的文件中创建它以使其更容易维护。以下是步骤：
- en: Start by creating a new Java class and calling it `CustomView`. This is where
    we will implement our custom component, as described in the *Introduction*.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的Java类，并将其命名为`CustomView`。这就是我们将实现自定义组件的地方，如*简介*中所述。
- en: 'Change the class constructor so it extends View. It should look as follows:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类构造函数更改为扩展`View`。它应如下所示：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Define a `Paint` object for the class, which will be used in `onDraw()`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为类定义一个`Paint`对象，它将在`onDraw()`中使用：
- en: '[PRE13]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create a default constructor, which requires the activity `Context`, so we
    can inflate the view. We will set the paint properties here as well. The constructor
    should look as follows:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个默认构造函数，它需要一个活动`Context`，这样我们就可以填充视图。我们还将在这里设置画笔属性。构造函数应如下所示：
- en: '[PRE14]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Override the `onDraw()` method as follows:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式重写`onDraw()`方法：
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, inflate our custom view in `MainActivity.java` by replacing `setContentView()` in
    the `onCreate()` method with our view, as shown:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`MainActivity.java`中通过将`onCreate()`方法中的`setContentView()`替换为我们的视图来填充我们的自定义视图，如下所示：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the application on a device or emulator to see it in action.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行应用程序，以查看其实际效果。
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'We start by extending the `View` class, just as the built-in components do.
    Next, we create the default constructor. This is important as we need the context
    to pass down to the `super` class, which we do with the following call:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先扩展`View`类，就像内置组件一样。接下来，我们创建默认构造函数。这很重要，因为我们需要将上下文传递给`super`类，我们通过以下调用来实现：
- en: '[PRE17]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We need to override `onDraw()`, otherwise, as mentioned in the *Introduction*,
    our custom view won't display anything. When `onDraw()` is called, the system
    passes in a **Canvas** object. The canvas is the screen area of our view. (Since
    we didn't override `onMeasure()`, our view would be 100 x 100, but since our entire
    activity consists of just this view, we get the whole screen as our canvas.)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要重写`onDraw()`，否则，如*简介*中所述，我们的自定义视图将不会显示任何内容。当`onDraw()`被调用时，系统会传递一个**Canvas**对象。画布是我们视图的屏幕区域。（由于我们没有重写`onMeasure()`，我们的视图将是100
    x 100，但由于我们的整个活动只包含这个视图，所以我们得到整个屏幕作为我们的画布。）
- en: We created the `Paint` object at the class level, and as `final`, to be more
    efficient with memory allocation. (`onDraw()` should be as efficient as possible
    since it can be called multiple times per second.) As you see from running the
    program, our `onDraw()` implementation just sets the background color to cyan
    and prints text to the screen (using `drawText()`).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在类级别创建了`Paint`对象，并将其设置为`final`，以提高内存分配的效率。（`onDraw()`应该尽可能高效，因为它可能每秒被调用多次。）如您从运行程序中看到的那样，我们的`onDraw()`实现只是将背景颜色设置为青色，并在屏幕上打印文本（使用`drawText()`）。
- en: There's more...
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Actually, there's a lot more. We've just touched the surface of what you can
    do with a custom component. Fortunately, as you see from this example, it doesn't
    take a lot of code to get basic functionality. We could easily spend an entire
    chapter on topics such as passing layout parameters to the view, adding listener
    callbacks, overriding `onMeasure()`, using our view in the IDE, and so on. These
    are all features you can add as your needs dictate.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，还有很多。我们只是触及了使用自定义组件可以做的事情的表面。幸运的是，正如您从这个示例中看到的，要获得基本功能并不需要很多代码。我们很容易就能用整个章节来讨论诸如将布局参数传递给视图、添加监听器回调、重写`onMeasure()`、在IDE中使用我们的视图等问题。这些都是您根据需要可以添加的功能。
- en: While a custom component is always an option, there are other options that might
    require less coding. Extending an existing widget is often enough without the
    overhead of creating a custom component from scratch. If what you need is a solution
    with multiple widgets, there's also the **compound control**. A compound control,
    such as a combo box, is just two or more controls grouped together as a single
    widget.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然自定义组件始终是一个选项，但可能还有其他选项可能需要更少的编码。扩展现有小部件通常足以避免从头创建自定义组件的开销。如果您需要的是具有多个小部件的解决方案，还有**复合控件**。复合控件，如组合框，只是将两个或更多控件组合在一起作为一个小部件。
- en: A compound control would generally extend from a layout, not a View, since you
    will be adding multiple widgets. You probably wouldn't need to override `onDraw()`
    and `onMeasure()`, as each widget would handle the drawing in their respective
    methods.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您将添加多个小部件，复合控件通常从布局扩展，而不是从`View`扩展。您可能不需要重写`onDraw()`和`onMeasure()`，因为每个小部件都会在其相应的方法中处理绘制。
- en: See also
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on drawing, look at [Chapter 10](a9bb5495-da76-415c-b83e-c75d0b8ce4fd.xhtml),
    *Graphics and Animation*.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关绘图的其他信息，请参阅第 10 章，*图形和动画*。
- en: For full details on the `View` object, refer to the Android Developer resource
    at [http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html).
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关 `View` 对象的完整详细信息，请参阅 Android 开发者资源[http://developer.android.com/reference/android/view/View.html](http://developer.android.com/reference/android/view/View.html)。
- en: Applying a style to a View
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式应用于视图
- en: A **style** is a collection of property settings to define the look of a View.
    As you have already seen while defining layouts, a view offers many settings to
    determine how it looks, as well as functions. We have already set a view height,
    width, background color, and padding, plus there are many more settings such as
    text color, font, text size, margin, and so on. Creating a style is as simple
    as pulling these settings from the layout and putting them in a style resource.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**样式**是一组属性设置，用于定义视图的外观。正如你在定义布局时已经看到的，视图提供了许多设置来决定其外观以及功能。我们已设置视图的高度、宽度、背景颜色和填充，还有许多其他设置，如文本颜色、字体、文本大小、边距等。创建样式就像将这些设置从布局中提取出来，并将它们放入样式资源中。'
- en: In this recipe, we will go through the steps of creating a style and hooking
    it up to a view.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将通过创建样式并将其连接到视图的步骤进行操作。
- en: Similar to Cascading Style Sheets, Android Styles allow you to specify your
    design settings separate from the UI code.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与层叠样式表（Cascading Style Sheets）类似，Android 样式允许你将设计设置与 UI 代码分开指定。
- en: Getting ready
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Android Studio project and call it `Styles`. Use the default wizard
    options to create a Phone & Tablet project and select Empty Activity when prompted
    for the `Activity type`. We haven't looked at it before, but by default, the wizard
    also creates a `styles.xml` file, which we will use for this recipe.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目，并将其命名为 `Styles`。使用默认向导选项创建一个手机和平板项目，并在提示 `Activity
    类型` 时选择空活动。我们之前没有看过它，但默认情况下，向导还会创建一个 `styles.xml` 文件，我们将使用它来完成本食谱。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will create our own style resource to change the appearance of `TextView`.
    We can add our new style to the `styles.xml` resource created by Android Studio
    using the following steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建自己的样式资源来更改 `TextView` 的外观。我们可以通过以下步骤将我们新的样式添加到 Android Studio 创建的 `styles.xml`
    资源中：
- en: 'Open the default `styles.xml` file located in `res/values`, as shown here:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开位于 `res/values` 中的默认 `styles.xml` 文件，如图所示：
- en: '![](img/35a07f43-6fcc-4395-8f50-9e704ba94725.png)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![](img/35a07f43-6fcc-4395-8f50-9e704ba94725.png)'
- en: 'We will create a new style called `MyStyle` by adding the following XML below
    the existing `AppTheme` style:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将通过在现有 `AppTheme` 样式下方添加以下 XML 创建一个名为 `MyStyle` 的新样式：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now tell the view to use this style. Open the `activity_main.xml` file and
    add the following attribute to the existing `<TextView>` element:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在告诉视图使用这个样式。打开 `activity_main.xml` 文件，并将以下属性添加到现有的 `<TextView>` 元素中：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 4\. Either run the application or view the results in the Design tab.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 4. 要么运行应用程序，要么在“设计”选项卡中查看结果。
- en: How it works...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: A style is a resource, defined by using the `<style>` element in a `<resources>`
    element of an XML file. We used the existing `styles.xml` file, but that is not
    a requirement, as we can use whatever filename we want. As seen in this recipe,
    multiple `<style>` elements can be included in one XML file.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是一种资源，通过在 XML 文件的 `<resources>` 元素中使用 `<style>` 元素定义。我们使用了现有的 `styles.xml`
    文件，但这不是必需的，因为我们可以使用任何我们想要的文件名。如本食谱所示，一个 XML 文件中可以包含多个 `<style>` 元素。
- en: Once the style is created, you can easily apply it to any number of other views
    as well. What if you wanted to have a button with the same style? Just drop a
    button in the layout and assign the same style.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了样式，你就可以轻松地将它应用到任何数量的其他视图上。如果你想有一个具有相同样式的按钮怎么办？只需在布局中添加一个按钮，并分配相同的样式。
- en: What if we created a new button, but wanted the button to expand the full width
    of the view? How do we override the style for just that view? Simply specify the
    attribute in the layout as you've always done. The local attribute will take priority
    over the attribute in the style.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们创建了一个新的按钮，但想让按钮扩展视图的全宽，我们如何只为该视图覆盖样式？只需在布局中指定属性，就像你以前做的那样。局部属性将优先于样式中的属性。
- en: There's more...
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'There is another feature of styles**: inheritance**. By specifying a parent
    when defining the style, we can have styles build on each other, creating a hierarchy
    of styles. If you look at the default style in `styles.xml`: `AppTheme`, you will
    see the following line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 样式的另一个特性是 **继承**。在定义样式时指定父样式，我们可以让样式相互构建，创建一个样式层次结构。如果你查看 `styles.xml` 中的默认样式
    `AppTheme`，你会看到以下这一行：
- en: '[PRE20]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '`AppTheme` inherits from a theme defined in the Android SDK.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppTheme` 继承自 Android SDK 中定义的主题。'
- en: 'If you want to inherit from a style you have created yourself, there is a shortcut
    method. Instead of using the parent attribute, you can specify the parent name
    first, followed by a period, then the new name, such as the following:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要继承你创建的样式，有一个快捷方法。你不需要使用父属性，你可以首先指定父名称，然后跟一个点，然后是新名称，例如以下这样：
- en: '`<style name="MyParent.MyStyle" >`'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '`<style name="MyParent.MyStyle" >`'
- en: You saw how to specify a style for a view, but what if we wanted all the `TextView`
    objects in our application to use a specific style? We'd have to go back to each
    `TextView` and specify the style. But there's another way. We can include a `textViewStyle`
    item in a style to automatically assign a style to all `TextView` objects. (There's
    a style for each of the widget types so you can do this for `Button`, `ToggleButton`,
    `TextView`, and so on.)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经看到了如何为视图指定样式，但如果我们想让应用程序中的所有 `TextView` 对象都使用特定的样式怎么办？我们不得不回到每个 `TextView`
    并指定样式。但还有另一种方法。我们可以在样式中包含一个 `textViewStyle` 项，以自动将样式分配给所有 `TextView` 对象。（每种小部件类型都有一个样式，因此你可以为
    `Button`、`ToggleButton`、`TextView` 等做同样的事情。）
- en: 'To set the style for all `TextView` objects, add the following line to the
    `AppTheme` style:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要为所有 `TextView` 对象设置样式，请将以下行添加到 `AppTheme` 样式中：
- en: '[PRE21]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Since the theme for our application already uses `AppTheme`, we only have to
    add that single line to `AppTheme` to have all our `TextView` objects styled with
    our custom `MyStyle`.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序主题已经使用了 `AppTheme`，我们只需将那一行添加到 `AppTheme` 中，就可以让所有的 `TextView` 对象都使用我们的自定义
    `MyStyle` 进行样式化。
- en: See also
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The Android Design Support Library at [https://www.google.com/design/spec/material-design/introduction.html](https://www.google.com/design/spec/material-design/introduction.html).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设计支持库位于 [https://www.google.com/design/spec/material-design/introduction.html](https://www.google.com/design/spec/material-design/introduction.html)。
- en: Turning a style into a theme
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将样式转换为主题
- en: A **theme** is a style applied to an activity or the whole application. To set
    a theme, use the `android:theme` attribute in the `AndroidManifest.xml` file.
    The `theme` attribute applies to the `<Application>` element as well as the `<Activity>`
    elements. All views within that element will be styled with the theme specified.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**主题**是应用于活动或整个应用程序的样式。要设置主题，请使用 `AndroidManifest.xml` 文件中的 `android:theme`
    属性。`theme` 属性适用于 `<Application>` 元素以及 `<Activity>` 元素。该元素内的所有视图都将使用指定的主题进行样式化。'
- en: It's common to set the application theme, but then override a specific activity
    with a different theme.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 设置应用程序主题很常见，但通常会覆盖特定的活动以使用不同的主题。
- en: In the previous recipe, we set `textViewStyle` using the `AppTheme` style (which
    the wizard created automatically). In this recipe, you will learn how to set both
    the application and activity themes.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们使用 `AppTheme` 样式（由向导自动创建）设置了 `textViewStyle`。在这个菜谱中，你将学习如何设置应用程序和活动主题。
- en: Along with the style settings we have already explored, there are additional
    style options we didn't discuss because they don't apply to a View, they apply
    to the window as a whole. Settings such as hiding the application title or action
    bar and setting the window background, just to name a few, apply to the window
    and therefore must be set as a theme.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经探索的样式设置外，还有一些我们没有讨论的附加样式选项，因为它们不适用于视图，而是适用于整个窗口。例如，隐藏应用程序标题或操作栏以及设置窗口背景等设置，都适用于窗口，因此必须作为主题设置。
- en: For this recipe, we are going to create a new theme based on the autogenerated
    `AppTheme`. Our new theme will modify the window appearance to make it a **dialog**.
    We will also look at the `theme` settings in the `AndroidManifest.xml`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们将基于自动生成的 `AppTheme` 创建一个新的主题。我们的新主题将修改窗口外观，使其成为一个 **对话框**。我们还将查看 `AndroidManifest.xml`
    中的 `theme` 设置。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `Themes`. Use the default
    wizard options and select Empty Activity when prompted for the Activity type.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中启动一个新的项目，并将其命名为 `Themes`。使用默认向导选项，并在被提示活动类型时选择 Empty Activity。
- en: How to do it...
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We start by adding a new theme to the existing `styles.xml` file to make our
    activity look like a dialog. Here are the steps to create the new theme and set
    the activity to use the new theme:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先向现有的`styles.xml`文件添加一个新的主题，使我们的活动看起来像对话框。以下是创建新主题并将活动设置为使用新主题的步骤：
- en: 'Since themes are defined in the same resource as styles, open the `styles.xml`
    file located in `res/values` and create a new style. We will create a new style
    based on the `AppTheme` already provided, and set `windowIsFloating`. The XML
    will be as follows:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于主题和样式定义在相同的资源中，请打开位于`res/values`的`styles.xml`文件，并创建一个新的样式。我们将基于已提供的`AppTheme`创建一个新的样式，并设置`windowIsFloating`。XML将如下所示：
- en: '[PRE22]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, set the activity to use this new dialog theme. Open the `AndroidManifest.xml`
    file and add a `theme` attribute to the activity element, as shown:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，设置活动使用这个新的对话框主题。打开`AndroidManifest.xml`文件，并将`theme`属性添加到活动元素中，如下所示：
- en: '[PRE23]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note that both application and activity will now have a theme specified.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在应用和活动都将指定一个主题。
- en: Now run the application on a device or emulator to see the dialog theme in action.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在设备或模拟器上运行应用程序，以查看对话框主题的实际效果。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Our new theme, `MyDialog`, inherits the base `AppTheme` using the alternative
    parent declaration, since `AppTheme` is defined in our code (and not a system
    theme). As mentioned in the *Introduction*, some settings apply to the window
    as a whole, which is what we see with the `windowIsFloating` setting. Once our
    new theme is declared, we assign our theme to the activity in the `AndroidManifest`
    file.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的新主题`MyDialog`使用替代父声明继承了基本`AppTheme`，因为`AppTheme`是在我们的代码中定义的（而不是系统主题）。如*简介*中所述，一些设置适用于整个窗口，这就是我们通过`windowIsFloating`设置所看到的情况。一旦我们声明了新的主题，我们就在`AndroidManifest`文件中将我们的主题分配给活动。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You might have noticed we could have just added `windowIsFloating` to the existing
    `AppTheme` and been done. Since this application only has one activity, the end
    result would be the same, but then any new activities would also appear as a dialog.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们只需将`windowIsFloating`添加到现有的`AppTheme`中即可完成。由于这个应用只有一个活动，最终结果将是相同的，但这样任何新的活动也会显示为对话框。
- en: Selecting a theme based on the Android version
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 根据Android版本选择主题
- en: Most users prefer to see apps using the latest themes provided by Android. To
    be competitive with the many other apps in the market, you'll probably want to
    upgrade your app as well, but what about your users who are still running older
    versions of Android? By setting up our resources properly, we can use **resource
    selection** in Android to automatically define the parent theme based on the Android
    OS version the user is running.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数用户更喜欢看到使用Android提供的最新主题的应用。为了在市场上与其他众多应用竞争，你可能也想升级你的应用，但那些仍在运行较旧Android版本的用户怎么办？通过正确设置我们的资源，我们可以使用Android中的**资源选择**来根据用户运行的Android
    OS版本自动定义父主题。
- en: 'First, let''s explore the three main themes available in Android:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们探索Android中可用的三个主要主题：
- en: Theme - Gingerbread and earlier
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theme - Gingerbread和更早版本
- en: Theme.Holo - Honeycomb (API 11)
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theme.Holo - Honeycomb (API 11)
- en: Theme.Material - Lollipop (API 21)
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Theme.Material - Lollipop (API 21)
- en: This recipe will show how to properly set up the resource directories for Android
    to use the most appropriate theme based on the API version the app is running
    on.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示如何为Android设置资源目录，以便根据应用运行的API版本使用最合适的主题。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Start a new project in Android Studio and call it `AutomaticThemeSelector`.
    Use the default wizard option to make a Phone & Tablet project. Select the Empty
    Activity when prompted for the Activity Type. On the Configure Activity dialog,
    deselect the Backwards Compatibility (AppCompat) checkbox.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中启动一个新项目，并将其命名为`AutomaticThemeSelector`。使用默认向导选项创建一个手机和平板项目。当被提示活动类型时，选择空活动。在配置活动对话框中，取消选择向后兼容性（AppCompat）复选框。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Normally, we use the AppCompat option when creating a project but in the preceding
    *Getting ready* section, we deselected this option as we need to explicitly set
    our resources manually. We will verify we are extending from the generic `Activity`
    class, then we can add our new style resources to select the theme based on the
    API. Here are the steps:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们在创建项目时使用AppCompat选项，但在前面的*准备工作*部分，我们取消选择了此选项，因为我们需要显式手动设置我们的资源。我们将验证我们是否扩展了通用的`Activity`类，然后我们可以添加我们的新样式资源来根据API选择主题。以下是步骤：
- en: 'We need to make sure `MainActivity` extends from `Activity` and not `AppCompatActivity`.
    Open `ActivityMain.java` and if necessary, change it to read as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要确保`MainActivity`继承自`Activity`而不是`AppCompatActivity`。打开`ActivityMain.java`文件，如果需要，将其修改为如下所示：
- en: '[PRE24]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Open `activity_main.xml` and drop in two views: `Button` and `Checkbox`.'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`文件，添加两个视图：`Button`和`Checkbox`。
- en: 'Open `styles.xml` and remove `AppTheme` as it will not be used. Add our new
    theme so the file reads as follows:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`styles.xml`文件，移除`AppTheme`，因为它将不会被使用。添加我们新的主题，使文件内容如下所示：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We need to create two new values folders for API 11 and 21\. To do this, we
    need to change Android Studio to use the project view rather than the Android
    view. (Otherwise, we won''t see the new folders in the next step.) At the top
    of the Project window, it shows Android; change this to Project for the project
    view. See the following screenshot:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要为API 11和21创建两个新的值文件夹。为此，我们需要将Android Studio更改为使用项目视图而不是Android视图。（否则，在下一步中我们将看不到新文件夹。）在项目窗口的顶部，它显示Android；将其更改为项目以使用项目视图。请参阅以下截图：
- en: '![](img/9f845c84-9762-4f9c-8b8a-207f574c8ee3.png)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9f845c84-9762-4f9c-8b8a-207f574c8ee3.png)'
- en: 'Create a new directory by right-clicking on the `res` folder and navigating
    to New | Directory, as shown in the following screenshot:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`res`文件夹上右键单击并导航到新建 | 目录，创建一个新的目录，如下截图所示：
- en: '![](img/7f0a6e45-657d-4982-ac7b-e423ad33cc87.png)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f0a6e45-657d-4982-ac7b-e423ad33cc87.png)'
- en: 'Use the following name for the first directory: `values-v11`.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 首个目录使用以下名称：`values-v11`。
- en: Repeat this for the second directory using `values-v21`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 使用相同的方法为第二个目录使用`values-v21`。
- en: 'Now create a `styles.xml` file in each of the new directories. (Right-click
    on the `values-v11` directory and go to the New | File option.) For `values-v11`,
    use the following style to define the Holo theme:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在每个新目录中创建一个`styles.xml`文件。（在`values-v11`目录上右键单击并选择新建 | 文件选项。）对于`values-v11`，使用以下样式定义Holo主题：
- en: '[PRE26]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'For `values-v21`, use the following code to define the Material theme:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`values-v21`，使用以下代码定义Material主题：
- en: '[PRE27]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The last step is to tell the application to use our new theme. To do this,
    open `AndroidManifest.xml` and change the application `android:theme` attribute
    to `AutomaticTheme`. It should read as follows:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是告诉应用程序使用我们新的主题。为此，打开`AndroidManifest.xml`文件，将应用程序的`android:theme`属性更改为`AutomaticTheme`。它应该如下所示：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now run the application on a physical device or emulator. If you want to see
    the three different themes, you will need to have a device or emulator running
    the different versions of Android.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在物理设备或模拟器上运行应用程序。如果您想看到三种不同的主题，您将需要一个运行不同版本Android的设备或模拟器。
- en: How it works...
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we are using the Android resource selection process to assign
    the appropriate theme (which is a resource) based on the API version. Since we
    need to choose the theme based on the OS version in which it was released, we
    created two new values folders specifying the API version. This gives us a total
    of three `styles.xml` files: the default style, one in the `values-v11` directory,
    and the last in the `values-v21` directory.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用Android资源选择过程根据API版本分配适当的主题（这是一个资源）。由于我们需要根据发布时的操作系统版本选择主题，因此我们创建了两个新的值文件夹，指定API版本。这使我们总共有三个`styles.xml`文件：默认样式，一个在`values-v11`目录中，最后一个在`values-v21`目录中。
- en: Notice the same theme name is defined in all three `styles.xml` files. This
    is how the resource selection works. Android will use the resource from the directory
    that best fits our values. Here we are using the API level, but other criteria
    are available as well. It is very common to define separate resources based on
    other criteria, such as screen size, screen density, and even orientation.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在所有三个`styles.xml`文件中定义了相同的主题名称。这就是资源选择的工作方式。Android将使用最适合我们值的目录中的资源。在这里，我们使用API级别，但还有其他标准可供选择。根据屏幕大小、屏幕密度，甚至方向定义单独的资源是非常常见的。
- en: The last step was to specify our new theme as the application theme, which we
    did in the Android Manifest.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是指定我们的新主题作为应用程序主题，我们在AndroidManifest中已经做到了这一点。
- en: There's more...
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: For more information on resource selection, see the *Using designated folders
    for screen-specific resources* section as well as the *Using graphics to show
    button state *recipe*.*
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 关于资源选择更多信息，请参阅*使用指定文件夹为屏幕特定资源*部分以及*使用图形显示按钮状态*食谱*。
