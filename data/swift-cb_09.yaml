- en: Performance and Responsiveness in Swift
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 中的性能和响应性
- en: We have covered a lot of ground in the previous chapters, and we have a lot
    of Swift tools in our tool belt. Now it's time to delve into more advanced topics,
    looking at how certain Swift types are implemented, how they can be used, and
    what their performance characteristics are. We will also look at how we can perform
    asynchronous tasks using **Grand Central Dispatch** (**GCD**) through the Dispatch
    framework and the higher-level operations in the Foundation framework that are
    also built on GCD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们已经覆盖了大量的内容，并且我们在工具箱中有许多 Swift 工具。现在是时候深入研究更高级的主题，看看某些 Swift 类型的实现方式，它们的使用方法以及它们的性能特征。我们还将探讨如何通过
    Dispatch 框架和基于 GCD 的高层操作在 Foundation 框架中执行异步任务。
- en: Understanding the multithreaded environment available on all Apple platforms,
    as well as the performance profile of the Swift constructs you use, is vital to
    building a fast and responsive app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 理解所有 Apple 平台上可用的多线程环境以及你使用的 Swift 构造的性能特征对于构建快速响应的应用程序至关重要。
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Value and reference semantics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值和引用语义
- en: Using Dispatch queues for concurrency
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Dispatch 队列进行并发操作
- en: Concurrent queues and dispatch groups
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发队列和调度组
- en: Implementing the operation class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现操作类
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: All the code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码都可以在本书的 GitHub 仓库中找到：[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3bn2l2O](https://bit.ly/3bn2l2O)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际操作：[https://bit.ly/3bn2l2O](https://bit.ly/3bn2l2O)
- en: Value and reference semantics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值和引用语义
- en: We saw back in Chapter 1, *Swift Building Blocks*, that certain Swift types
    behave differently from others, specifically regarding ownership and the mutation
    of properties. We even defined this difference, saying that classes are *reference*
    types, while structs and enums are *value* types. In this recipe, we will examine
    why these types behave differently and the performance implications this entails.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一章“Swift 基础”中，我们了解到某些 Swift 类型与其他类型的行为不同，特别是在属性的所有权和修改方面。我们甚至定义了这种差异，指出类是**引用**类型，而结构体和枚举是**值**类型。在本节中，我们将探讨为什么这些类型的行为不同以及这种差异带来的性能影响。
- en: Let's create the model for an app that allows a user to schedule events that
    they do every day and reminds them when these events should occur.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个应用程序的模型，允许用户安排他们每天都会进行的事件，并在这些事件应该发生时提醒他们。
- en: Getting ready
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We need to decide how we will model our daily event. The key to this decision
    is whether we want our event to have reference semantics or value semantics. We
    discussed the differences between the two in [Chapter 1](f9d48715-ffca-464f-95bf-722958f02e72.xhtml),
    *Swift Building Blocks*, but let's re-examine the differences.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要决定如何建模我们的日常事件。这个决定的关键在于我们希望我们的事件具有引用语义还是值语义。我们在[第一章](f9d48715-ffca-464f-95bf-722958f02e72.xhtml)“Swift
    基础”中讨论了这两种语义的区别，但让我们重新审视这些区别。
- en: '*Value* types are simple data structures that you can think of as just bundles
    of data. Swift makes these types more useful by allowing them to have methods,
    but any change or *mutation* of the underlying data results in a whole new bundle
    of data. In contrast, *reference* types are more complex data structures that
    have an identity outside of their component properties. Therefore, a change in
    the component properties will be available via any references to the object.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**值**类型是简单的数据结构，你可以将其视为仅仅是数据包。Swift 通过允许这些类型拥有方法使其更加有用，但任何对底层数据的更改或**修改**都会导致一个全新的数据包。相比之下，**引用**类型是更复杂的数据结构，它们在其组件属性之外具有一个身份。因此，组件属性的任何更改都将通过任何对该对象的引用而可用。'
- en: A value type's simple composition has the advantage of being very cheap on resources
    to create and maintain. However, this simplicity comes at the expense of dynamic
    dispatch, which enables sub-classing.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 值类型的简单组合在资源创建和维护方面具有非常低廉的优势。然而，这种简单性是以动态调度为代价的，它使得子类化成为可能。
- en: How to do it...
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Given this distinction, what behavior do we want for our daily event? If we
    change the name of our event, should we expect anything that has a reference to
    it to also see that change? That sounds like the behavior we want, so our daily
    event should be a reference type:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定这种区别，我们希望我们的日常活动有什么行为？如果我们更改事件名称，我们应该期望任何引用它的事物也会看到这种更改吗？这听起来就像是我们想要的行为，所以我们的日常活动应该是一个引用类型：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Let''s check that this gives us the behavior we expect:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们检查这是否会给我们期望的行为：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We want to be reminded of our event every day at a certain time, but for our
    purpose, `Date` in `Foundation` is a bit of an overkill, since it contains both
    date and time information, and we only need to maintain time information. Let's
    create something to represent the time, irrespective of the date. What behavior
    is most appropriate for our time model? Should it have reference semantics or
    type semantics?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望在每天特定时间提醒我们的活动，但就我们的目的而言，`Foundation` 中的 `Date` 确实有点过度，因为它包含了日期和时间信息，而我们只需要维护时间信息。让我们创建一个表示时间的实体，而不考虑日期。我们时间模型最合适的行为什么？它应该具有引用语义还是类型语义？
- en: 'Let''s try both and see which seems to most accurately model the situation
    we are after:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试两种方法，看看哪一种似乎最能准确地模拟我们想要的情况：
- en: 'We''ll create time as a class, with reference semantics:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建一个表示时间的类，具有引用语义：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s see how this will behave when its properties are changed:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们看看当其属性更改时，这会如何表现：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: When we change the properties of an instance of `ClockTime`, it has the unintended
    consequence of changing all references to that same instance of `ClockTime`. Since
    reference semantics aren't a perfect fit for `ClockTime`, let's change it to a
    value type and see whether that is more appropriate.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们更改 `ClockTime` 实例的属性时，它会产生一个意想不到的后果，即更改对该相同 `ClockTime` 实例的所有引用。由于引用语义并不完全适合
    `ClockTime`，让我们将其更改为值类型，看看这是否更合适。
- en: 'We now have two options for value types in Swift; we can model `ClockTime`
    as a `struct` or an `enum`. Enums are great for modeling concepts that have a
    small number of finite values. While there are a finite number of minutes in a
    day, it''s not a small number, and we might want to do math calculations on the
    hours and minutes in `ClockTime`, so a `struct` is more appropriate:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，Swift 中对于值类型我们有两种选择；我们可以将 `ClockTime` 模型化为 `struct` 或 `enum`。枚举非常适合用于具有少量有限值的概念的建模。虽然一天中有有限分钟的数目，但这不是一个小的数字，我们可能想要对
    `ClockTime` 中的小时和分钟进行数学计算，所以 `struct` 更合适：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s see how this changes the behavior when we change the properties of a
    `ClockTime` instance:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看当我们更改 `ClockTime` 实例的属性时，这会如何改变行为：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With `ClockTime` as a value type, changing a property of a `ClockTime` instance
    results in a new instance, so the change doesn't have the unintended consequences
    that we saw when it was a reference type.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `ClockTime` 是值类型，更改 `ClockTime` 实例的属性会导致创建一个新的实例，因此更改不会产生我们当它是引用类型时所看到的意外后果。
- en: Lastly, let's consider some of the dynamic features that we will give up by
    making `ClockTime` a value type. Will we ever want to subclass `ClockTime`? This
    doesn't seem likely, and it is right to characterize `ClockTime` as a simple bundle
    of data. So, in this scenario, modeling `ClockTime` as a value type is the right
    decision.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑一下，如果我们把 `ClockTime` 作为值类型，我们会放弃的一些动态特性。我们是否想要将 `ClockTime` 作为子类？这似乎不太可能，而且将
    `ClockTime` 描述为简单的数据包是合适的。因此，在这种情况下，将 `ClockTime` 模型化为值类型是正确的决定。
- en: 'To complete the model, we will add a `ClockTime` property to the `DailyEvent`
    class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了完成模型，我们将在 `DailyEvent` 类中添加一个 `ClockTime` 属性：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We've already covered how value types differ from reference types. Now, let's
    examine why they behave differently.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了值类型与引用类型的不同之处。现在，让我们探讨它们为什么会有不同的行为。
- en: 'When storing new instances of a type in memory, Swift has two different data
    structures that it can use for storage: the **Stack** and the **Heap**. These
    structures are common to many programming languages. Value types are stored on
    the **Stack**, and reference types are stored on the **Heap****.** Understanding
    how data is stored in these structures, even at the superficial level that we
    will cover, will help us to understand why value types and reference types have
    differing behaviors.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当在内存中存储类型的新的实例时，Swift 有两种不同的数据结构可以用于存储：**栈**和**堆**。这些结构在许多编程语言中都是常见的。值类型存储在**栈**上，而引用类型存储在**堆**上**。即使在我们将要覆盖的表面层次上理解数据在这些结构中的存储方式，也将帮助我们理解为什么值类型和引用类型具有不同的行为。
- en: The stack can be thought of as sequential blocks of data. An instance of a type
    may be represented by multiple blocks of data, and an instance can be referenced
    using the memory position of its first piece of data. A **Stack Pointer**, which
    is a reference to the memory position at the end of the stack, is maintained.
    New instances are always added to the end of the stack, and then the stack pointer's
    position is updated to the new end of the stack.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 栈可以被视为数据块序列。一个类型的实例可能由多个数据块表示，并且可以使用其实例的第一块数据的内存位置来引用实例。维护一个**栈指针**，它是对栈末尾内存位置的引用。新实例总是添加到栈的末尾，然后更新栈指针的位置到新的栈末尾。
- en: 'Let''s go through adding a value type instance using a simplified diagram of
    the stack. Before anything is added, the stack pointer is at the top of the stack:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简化版的栈图来了解如何添加一个值类型实例。在添加任何内容之前，栈指针位于栈顶：
- en: '![](img/a3981653-ae39-4677-87e0-ec80787be9e2.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3981653-ae39-4677-87e0-ec80787be9e2.jpg)'
- en: Figure 9.1 – Representation of the stack and stack pointer
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1 – 栈和栈指针的表示
- en: 'A `ClockTime` struct for 07:00 is added to the stack. This takes up three blocks,
    and the stack pointer moves to the next empty block on the stack:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 为07:00添加一个`ClockTime`结构体到栈上。它占用三个块，栈指针移动到栈上的下一个空块：
- en: '![](img/aa8bb748-2db5-48e2-82e3-06b4eacb04f2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa8bb748-2db5-48e2-82e3-06b4eacb04f2.jpg)'
- en: Figure 9.2 – Stack pointer after adding a ClockTime struct for 7:00
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 添加7:00的ClockTime结构体后的栈指针
- en: 'Another `ClockTime` struct for 09:30 is added to the stack. This has a size
    of four blocks, and the stack pointer moves to the next empty block on the stack:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 为09:30添加另一个`ClockTime`结构体到栈上。它占用四个块，栈指针移动到栈上的下一个空块：
- en: '![](img/91818305-f75d-4005-b9ba-3637859a4a6a.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/91818305-f75d-4005-b9ba-3637859a4a6a.jpg)'
- en: Figure 9.3 – Stack pointer after adding a ClockTime struct for 9:30
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 添加9:30的ClockTime结构体后的栈指针
- en: 'Once data is placed on the stack, it is immutable. To see why this is an important
    restriction, let''s try and change our first `ClockTime` instance on the stack.
    The simplicity and efficiency of the stack is predicated on the fact that it is
    a continuous block of memory. If we try and change any data already on the stack,
    it may take up more space, which will cause data in the subsequent blocks to be
    overwritten:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦数据被放置在栈上，它就是不可变的。为了了解为什么这是一个重要的限制，让我们尝试更改栈上的第一个`ClockTime`实例。栈的简单性和效率基于它是一个连续的内存块的事实。如果我们尝试更改栈上已经存在的任何数据，它可能会占用更多空间，这会导致后续块中的数据被覆盖：
- en: '![](img/fad6256b-de25-4ba5-8cef-a21b203ba00f.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fad6256b-de25-4ba5-8cef-a21b203ba00f.jpg)'
- en: Figure 9.4 – Changing the first ClockTime instance on the stack
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 修改栈上的第一个ClockTime实例
- en: Therefore, any change to a `struct` results in a new, changed version of the
    `struct` appended at the end of the stack.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对`struct`的任何更改都会在栈底追加一个新的、更改后的`struct`版本。
- en: 'Let''s mutate a `ClockTime` instance and see how that looks in our simplified
    stack representation by taking it step by step:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐步修改一个`ClockTime`实例，并看看在我们的简化栈表示中它看起来如何：
- en: 'We have a `ClockTime` struct for 9:00 assigned to the variable named `event1Time`:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将一个`ClockTime`结构体赋值给名为`event1Time`的变量：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'See the following diagram for a visual representation of how this may look:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了这种可能的外观：
- en: '![](img/d0ac446d-b30a-44ed-bfa7-9f7304a5fe25.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d0ac446d-b30a-44ed-bfa7-9f7304a5fe25.jpg)'
- en: Figure 9.5 – Assigning the event1Time variable to a ClockTime struct for 09:00
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 将event1Time变量赋给09:00的ClockTime结构体
- en: 'The value of `event1Time` is also assigned to a new variable, called `event2Time`:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`event1Time`的值也被赋给一个新的变量，称为`event2Time`：'
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '![](img/171561e4-439a-48ae-b392-ed8dccf7ed6b.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/171561e4-439a-48ae-b392-ed8dccf7ed6b.jpg)'
- en: Figure 9.6 – Assigning the value of event1Time to event2Time
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 将event1Time的值赋给event2Time
- en: 'When we mutate `event2Time`, changing the minute value to `30`, a new `ClockTime`
    instance with the changed minute value is placed at the end of the stack:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们修改`event2Time`，将分钟值改为`30`时，一个新的具有更改后的分钟值的`ClockTime`实例被放置在栈底：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '![](img/5a7b80e6-e41f-41bd-a1f7-69b005a4543f.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5a7b80e6-e41f-41bd-a1f7-69b005a4543f.jpg)'
- en: Figure 9.7 – The new ClockTime instance placed at the end of the stack
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.7 – 放置在栈底的新ClockTime实例
- en: The `event2Time` variable now points to this new stack position, while `event1Time`
    continues to point to the stack position of the original `ClockTime` struct for
    09:00.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`event2Time`变量现在指向这个新的栈位置，而`event1Time`继续指向09:00的原始`ClockTime`结构体的栈位置。'
- en: As the preceding examples show, the stack is a very simple and efficient data
    structure, and its properties explain the behavior we see when we use value types
    such as `struct` and `enums`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的示例所示，栈是一个非常简单且高效的数据结构，其属性解释了当我们使用`struct`和`enums`等值类型时看到的行为。
- en: In contrast, reference types, such as class objects, are stored on the heap,
    which enables more dynamic and complex behavior at the expense of efficiency.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，引用类型，如类对象，存储在堆上，这以牺牲效率为代价，使得行为更加动态和复杂。
- en: 'An accurate look at heap allocations is beyond the scope of this book, but
    let''s take a very simplified look at how a reference type instance is stored
    on the **Heap**. The heap is not a continuous chain of blocks, but an area of
    memory that can be free or already allocated:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 对堆分配的准确分析超出了本书的范围，但让我们非常简化地看看引用类型实例是如何存储在**堆**上的。堆不是一个连续的块链，而是一个可能空闲或已分配的内存区域：
- en: '![](img/699c254b-0e9e-4cda-a47e-b0642d70f6a8.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/699c254b-0e9e-4cda-a47e-b0642d70f6a8.jpg)'
- en: Figure 9.8 – Representation of the heap
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.8 – 堆的表示
- en: 'When a class is allocated to the heap, it must search through the heap to find
    a set of free blocks appropriate for its size. The reference type instance may
    include references to other reference types or value types by storing their stack
    positions:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个类分配到堆上时，它必须搜索堆以找到适合其大小的空闲块集。引用类型实例可能通过存储它们的栈位置来包含对其他引用类型或值类型的引用：
- en: '![](img/b397d89e-dcc4-4bfd-b03a-1e23c1898178.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b397d89e-dcc4-4bfd-b03a-1e23c1898178.jpg)'
- en: Figure 9.9 – Allocation of a class in the heap
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.9 – 堆中的类分配
- en: 'Multiple variables can hold references to the same instance:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 多个变量可以持有对同一实例的引用：
- en: '![](img/58e4a2b8-89de-4e90-9d73-1b0db7cbd05c.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/58e4a2b8-89de-4e90-9d73-1b0db7cbd05c.jpg)'
- en: Figure 9.10 – Multiple variables holding references to the same instances
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.10 – 持有对同一实例引用的多个变量
- en: 'When reference types are modified, they aren''t copied. Instead, extra space
    must be found to accommodate the extra information. All references to the instance
    have the changed information:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当引用类型被修改时，它们不会被复制。相反，必须找到额外的空间来容纳额外的信息。所有对实例的引用都有更改后的信息：
- en: '![](img/bf8452ee-3324-439e-a907-4244a9233cee.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf8452ee-3324-439e-a907-4244a9233cee.jpg)'
- en: Figure 9.11 – Modifying reference types
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.11 – 修改引用类型
- en: This recipe describes the difference between reference semantics and value semantics,
    and hopefully illustrates that these behaviors arise from the way in which they
    are stored in memory.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方描述了引用语义和值语义之间的区别，并希望说明这些行为源于它们在内存中的存储方式。
- en: Both have their uses, and it's important to choose the right type when building
    your model.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都有其用途，并且在构建你的模型时选择正确的类型非常重要。
- en: See also
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Swift blog**: Value and reference types: [http://swiftbook.link/blog/type-semantics](http://swiftbook.link/blog/type-semantics)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**Swift博客**：值类型和引用类型：[http://swiftbook.link/blog/type-semantics](http://swiftbook.link/blog/type-semantics)'
- en: '**Apple Developer Videos (developer account needed)**:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**Apple开发者视频（需要开发者账户）**：'
- en: 'WWDC 2016 - Protocol and Value-Oriented Programming in UIKit Apps: [https://developer.apple.com/videos/play/wwdc2016/419](https://developer.apple.com/videos/play/wwdc2016/419)'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WWDC 2016 - UIKit应用中的协议和面向值编程：[https://developer.apple.com/videos/play/wwdc2016/419](https://developer.apple.com/videos/play/wwdc2016/419)
- en: Using Dispatch queues for concurrency
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调度队列进行并发
- en: We live in a multicore computing world. Multicore processors are found in everything,
    from our laptops and mobile phones to our watches. With these multiple cores comes
    the ability to work in parallel. These concurrent streams of work are known as
    *threads*, and programming in a multithreaded way enables your code to make the
    best use of the processor's cores. Deciding how and when to create new threads
    and manage the available resources are complex tasks, so Apple has built a framework
    to do the hard work for us. It is called *Grand Central Dispatch*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们生活在一个多核计算的世界。从我们的笔记本电脑、移动电话到我们的手表，到处都可以找到多核处理器。这些多个核心带来了并行工作的能力。这些并行的工作流被称为*线程*，以多线程方式编程可以使你的代码充分利用处理器的核心。决定何时以及如何创建新线程和管理可用资源是复杂任务，因此苹果为我们构建了一个框架来处理这些困难的工作。它被称为*Grand
    Central Dispatch*。
- en: '**Grand Central Dispatch** (**GCD**) handles the thread maintenance and monitors
    the available resources while providing a simple, queue-based interface for getting
    concurrent work done. With the open-sourcing of Swift, Apple also open-sourced
    GCD in the form of `libdispatch`, since Swift does not yet have built-in concurrency
    features.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**Grand Central Dispatch**（**GCD**）负责线程维护并监控可用资源，同时提供了一个简单、基于队列的接口来执行并发工作。随着Swift的开放源代码，苹果也将GCD以`libdispatch`的形式开源，因为Swift还没有内置的并发功能。'
- en: In this recipe, we will explore some of the features of `libdispatch`, also
    known as the Dispatch framework, and see how we can use concurrency to build apps
    that are efficient and responsive.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索`libdispatch`的一些特性，也称为调度框架，并看看我们如何使用并发来构建高效且响应迅速的应用程序。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We will see how we can improve the responsiveness of an app using GCD, so first,
    we need to start with an app that requires some improvement. Go to [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups).
    Here, you will find the repository of an app that takes a collection of photos
    and turns them into a PDF photo book. You can download the app source files directly
    from GitHub or by using `git`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看到如何使用GCD提高应用程序的响应性，因此首先，我们需要从一个需要改进的应用程序开始。访问[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09/PhotobookCreator_DispatchGroups)。在这里，你可以找到一个应用程序的仓库，该应用程序将一组照片转换成PDF相册。你可以直接从GitHub或使用`git`下载应用程序源代码：
- en: '[PRE10]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If you build and run the app, you will see a collection of sample images, with
    the ability to add more:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行应用程序，你将看到一系列样本图像，并能够添加更多：
- en: '![](img/2dbb1d24-5525-4173-9c7c-10b3bbe95ec1.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2dbb1d24-5525-4173-9c7c-10b3bbe95ec1.png)'
- en: Figure 9.12 – Sample images
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.12 – 样本图像
- en: When you tap on Generate Photo Book, the app will take the photos you have chosen,
    resize them to the same size, and save them as a multi-page PDF that can then
    be exported or shared. Depending on how many photos are included and the performance
    of the device, this process can take a little time to complete. During this time,
    the whole interface is unresponsive; for example, you can't scroll through the
    pictures.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击生成相册时，应用程序将选择你选择的照片，将它们调整到相同的大小，并将它们保存为可以导出或分享的多页PDF。根据包含的照片数量和设备的性能，这个过程可能需要一些时间来完成。在这段时间内，整个界面都无响应；例如，你不能滚动图片。
- en: How to do it...
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Let''s examine why the app is unresponsive during photo book generation and
    how we can fix this:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析为什么在生成相册时应用程序会变得无响应，以及我们如何修复这个问题：
- en: 'Open up the `PhotoBookCreator` project and navigate to `PhotoCollectionViewController.swift`.
    In this file, you will find the following method:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`PhotoBookCreator`项目并导航到`PhotoCollectionViewController.swift`。在这个文件中，你会找到以下方法：
- en: '[PRE11]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this method, we call three functions that can take quite a long time to complete.
    We take the output of one function and feed it into the next function, and the
    result is a URL for our photo book, which we then launch with some UI to preview
    and export.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们调用三个可能需要相当长时间才能完成的函数。我们取一个函数的输出并将其输入到下一个函数中，结果是相册的URL，然后我们使用一些UI来预览和导出。
- en: This work to resize and crop the photos, and then generate the photo book, is
    taking place in the same queue where UI touch events are processed, the main queue,
    which is why our UI is unresponsive.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作，包括调整和裁剪照片，然后生成相册，正在处理UI触摸事件的同一个队列中进行，也就是主队列，这就是为什么我们的UI变得无响应。
- en: 'To free up the main queue for UI events, we can create our own private queue,
    which we can use to execute our long-running functions:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了释放主队列以处理UI事件，我们可以创建自己的私有队列，我们可以使用它来执行我们的长时间运行函数：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: By calling the `async` method on our `DispatchQueue` and providing a block of
    code, we are scheduling that block to be executed. GCD will execute that block
    when resources are available. Now, our long-running code isn't blocking the main
    queue, so our UI will remain responsive; however, if you were to run the app with
    just this change, you would get some very odd behavior when the app tried to show
    the preview view controller.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的 `DispatchQueue` 上调用 `async` 方法并提供一段代码块，我们正在安排该代码块被执行。当资源可用时，GCD 将执行该代码块。现在，我们的长时间运行代码不会阻塞主队列，因此我们的
    UI 将保持响应；然而，如果你只运行这个更改后的应用，当应用尝试显示预览视图控制器时，你会得到一些非常奇怪的行为。
- en: We just discussed the fact that UI touch events are delivered to the main queue,
    which is why we wanted to avoid blocking it; however, `UIKit` expects *all* UI
    events to happen on the main queue. Since we are currently creating and presenting
    the preview view controller from our private queue, we are defying this `UIKit`
    expectation, which can produce a number of bugs, including UI elements that never
    appear, or appear long after they were presented.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚才讨论了 UI 触摸事件被发送到主队列的事实，这就是为什么我们想要避免阻塞它；然而，`UIKit` 预期所有 UI 事件都在主队列上发生。由于我们目前是从我们的私有队列创建和展示预览视图控制器，我们违反了
    `UIKit` 的这个预期，这可能导致许多错误，包括 UI 元素永远不会出现，或者出现得比它们展示的时间长得多。
- en: 'To solve this problem, we need to ensure that when we are ready to present
    our UI, we do that operation on the main queue:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要确保当我们准备好展示我们的 UI 时，我们在主队列上执行这个操作：
- en: '[PRE13]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, if you run the app, you will find that you can generate a photo book while
    still being able to interact with the UI; for instance, being able to scroll the
    table view.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用，你会发现你可以在与 UI 交互的同时生成相册；例如，能够滚动表格视图。
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'GCD uses queues to manage blocks of work in a multithreaded environment. Queues
    operate on a **first in first out** (**FIFO**) policy. When GCD determines that
    resources are available, it will take the next block from the queue and execute
    it. Once the block has finished executing, it will be removed from the queue:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 使用队列在多线程环境中管理工作代码块。队列按照 **先进先出**（**FIFO**）策略操作。当 GCD 确定资源可用时，它将从队列中取出下一个代码块并执行它。一旦代码块执行完成，它将从队列中移除：
- en: '![](img/e89ccaf5-a5e4-44f1-b15f-6d0e8d94b819.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e89ccaf5-a5e4-44f1-b15f-6d0e8d94b819.jpg)'
- en: Figure 9.13 – FIFO policy
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.13 – FIFO 策略
- en: 'There are two types of `DispatchQueue`: *serial* and *concurrent*. With the
    simplest form of a queue, a serial queue, GCD will only execute one block at a
    time from the top of the queue. When each block finishes executing, it is removed
    from the queue, and each block moves up one position.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`DispatchQueue` 有两种类型：*串行* 和 *并发*。在队列的最简单形式中，即串行队列，GCD 将一次只从队列顶部执行一个代码块。当每个代码块执行完成时，它将从队列中移除，每个代码块向上移动一个位置。'
- en: The main queue, which processes all UI events, is an example of a serial queue,
    and this explains why performing a long-running operation on the main queue will
    cause your UI to become unresponsive. While your long-running operation is executing,
    nothing else on the main queue will be executed until the long-running operation
    has finished.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 处理所有 UI 事件的主队列是一个串行队列的例子，这也解释了为什么在主队列上执行长时间运行的操作会导致你的 UI 变得无响应。当你的长时间运行操作正在执行时，主队列上的其他任何操作都不会执行，直到长时间运行的操作完成。
- en: 'With the second type of queue, a concurrent queue, GCD will execute as many
    blocks on different threads as resources allow. The next block to execute will
    be the block closest to the top of the stack that isn''t already executing, and
    blocks are removed from the stack when finished:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 使用第二种类型的队列，即并发队列，GCD 将在允许的资源范围内，在不同的线程上执行尽可能多的代码块。下一个要执行的代码块将是堆栈顶部最近的一个尚未执行的代码块，当代码块执行完成后，它们将从堆栈中移除：
- en: '![](img/82170dbe-0af1-4bbb-89c3-1d883a108df9.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/82170dbe-0af1-4bbb-89c3-1d883a108df9.jpg)'
- en: Figure 9.14 – Execution when the second type of queue is added
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.14 – 添加第二种队列时的执行情况
- en: Concurrent queues can be really useful when you have numerous operations that
    are independent of each other. We will look into concurrent queues further in
    the *Concurrent queues and dispatch groups* recipe.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有许多相互独立的操作时，并发队列非常有用。我们将在 *并发队列和调度组* 菜谱中进一步探讨并发队列。
- en: See also
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'The GitHub repository for `libdispatch`: [https://github.com/apple/swift-corelibs-libdispatch](https://github.com/apple/swift-corelibs-libdispatch)'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libdispatch` 的 GitHub 仓库：[https://github.com/apple/swift-corelibs-libdispatch](https://github.com/apple/swift-corelibs-libdispatch)'
- en: 'Documentation for dispatch queues: [http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分发队列的文档：[http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)
- en: Concurrent queues and dispatch groups
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发队列和分发组
- en: In the previous recipe, we looked into using a private serial queue to keep
    our app responsive by moving long-running operations off the main queue. In this
    recipe, we will break our operations down into smaller, independent blocks and
    place them on a concurrent queue.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个菜谱中，我们探讨了使用私有串行队列来通过将长时间运行的操作从主队列中移除来保持我们的应用响应。在本菜谱中，我们将把我们的操作分解成更小、独立的块，并将它们放置在并发队列中。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to build on the app we improved in the last recipe, which is an
    app that will produce a PDF photo book from a collection of photos. You can get
    the code for this app at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
    and choose the `PhotobookCreator_DispatchGroups` folder.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上次菜谱中改进的应用程序的基础上构建，这是一个从照片集合中生成PDF照片书的应用程序。您可以在[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)获取此应用程序的代码，并选择`PhotobookCreator_DispatchGroups`文件夹。
- en: Open the project in XCode and navigate to the `PhotoCollectionViewController.swift`
    file.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在XCode中打开项目，并导航到`PhotoCollectionViewController.swift`文件。
- en: How to do it...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: We saw in the last recipe how dispatch queues operate on a FIFO policy. GCD
    will execute a block from the top of the queue and remove it from the queue when
    it has finished executing. The number of blocks that GCD will allow to execute
    at the same time will depend on the type of queue being used. *Serial* queues
    will only have one block of code being executed at any time; other blocks in the
    queues will have to wait until the block at the top of the queue has finished
    executing. However, for a *concurrent* queue, GCD will concurrently execute as
    many blocks as there are resources available. We can make more efficient use of
    a concurrent queue by breaking down the work into smaller, independent blocks,
    allowing them to be executed concurrently.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一个菜谱中，我们看到了分发队列如何按照FIFO策略操作。GCD将执行队列顶部的块，并在执行完成后将其从队列中移除。GCD允许同时执行的块的数量将取决于所使用的队列类型。*串行*队列在任何时候都只会执行一个代码块；队列中的其他块将不得不等待队列顶部的块执行完毕。然而，对于*并发*队列，GCD将并发执行尽可能多的块，直到有可用资源。我们可以通过将工作分解成更小、独立的块来更有效地使用并发队列，允许它们并发执行。 '
- en: 'Take a look at the current implementation of the `generatePhotoBook` method.
    The only thing that has changed since the last recipe is that we now present the
    preview UI within a completion that is passed to the `generatePhotoBook` method.
    This simplifies the method and prevents us from needing to weakly capture `self`
    within the `async` block:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 看看`generatePhotoBook`方法的当前实现。自上次菜谱以来，唯一的变化是我们现在在传递给`generatePhotoBook`方法的完成回调中呈现预览UI。这简化了方法，并防止我们在`async`块中弱捕获`self`：
- en: '[PRE14]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The work we are doing is in one block of code that we place on a queue. Let's
    see whether we can break this down into smaller, independent pieces of work that
    can be executed concurrently. We can't perform the scale and crop operations concurrently,
    as they will be operating on the same `UIImage` objects, and we will not get the
    intended result if the image is cropped before it's scaled.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在执行的工作是在一个代码块中，我们将其放置在队列上。让我们看看我们是否可以将它分解成更小、独立的工作块，这些工作块可以并发执行。我们不能并发执行缩放和裁剪操作，因为它们将操作相同的`UIImage`对象，如果图像在缩放之前被裁剪，我们将不会得到预期的结果。
- en: 'However, we can apply the scale and crop operation to each photo separately
    and perform that operation concurrently on the other photos. Once each photo has
    been scaled and cropped, we can use the processed images to generate the photo
    book:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可以分别对每张照片应用缩放和裁剪操作，并在其他照片上并发执行该操作。一旦每张照片都被缩放和裁剪，我们可以使用处理过的图像来生成照片书：
- en: '![](img/737635fd-c762-486f-ac2c-9e117e86421c.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/737635fd-c762-486f-ac2c-9e117e86421c.jpg)'
- en: Figure 9.15 – Serial approach and concurrent approach
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.15 – 串行方法和并发方法
- en: Splitting the work up in this way may not make the overall operation faster,
    as there is an overhead to each block of work. The efficiency improvement of dividing
    the work into concurrent blocks will depend on the operation involved, and how
    many concurrent operations can run.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式分割工作可能不会使整体操作更快，因为每个工作块都有开销。将工作分割成并发块带来的效率提升将取决于涉及的操作以及可以运行的并发操作的数量。
- en: We now have blocks of work that can run concurrently, but we have given ourselves
    a new problem; how do we coordinate all these concurrent pieces of work so that
    we know they are all completed and we can start generating the photo book? Here,
    GCD can help us. We can use a `DispatchGroup` to coordinate our operations on
    each of the images and be notified when they are all completed.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有可以并发运行的工作块，但我们给自己带来了一个新的问题；我们如何协调所有这些并发工作，以便我们知道它们都已经完成，我们可以开始生成相册？在这里，GCD可以帮助我们。我们可以使用`DispatchGroup`来协调我们对每个图像的操作，并在它们全部完成时得到通知。
- en: A dispatch group is like a turnstile at a stadium. Every time someone enters
    the stadium, they pass through the turnstile, and one extra person is counted
    as being in the stadium, and at the end of the day, as people leave the stadium
    and pass through the turnstile, the number of people in the stadium decreases.
    Once there is no one left in the stadium, the lights can be turned off.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 分发组就像体育场的大门。每次有人进入体育场，他们都会通过大门，并且有一个人被计算为在体育场内，到了最后一天，当人们离开体育场并通过大门时，体育场内的人数会减少。一旦体育场内没有人了，就可以关灯了。
- en: 'Let''s use a dispatch group to coordinate the work of our photo book creator:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用分发组来协调相册创建者的工作：
- en: 'First, we will create a dispatch group:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个分发组：
- en: '[PRE15]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Every time we start a blockwork to resize a photo, we will enter the group:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次我们开始一个块来调整照片大小时，我们将进入组：
- en: '[PRE16]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Once the work is finished, we will leave the group:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工作完成后，我们将离开小组：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Finally, we will ask the group to notify us when the last resize operation
    has finished and left the group. Then, we can take the processed files and generate
    the photo book:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将要求小组在最后一次调整大小操作完成后并离开小组时通知我们。然后，我们可以取走处理过的文件并生成相册：
- en: '[PRE18]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let''s take a look at our `generatePhotoBook` method, now using a concurrent
    queue and dispatch groups:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看我们的`generatePhotoBook`方法，现在使用并发队列和分发组：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Dispatch queues are serial by default, so to create a concurrent queue instead,
    we pass the `.concurrent` attribute when it is created:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 分发队列默认是串行的，因此要创建一个并发队列，我们可以在创建时传递`.concurrent`属性：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Before we loop through all the photos, we set up anything that isn''t specific
    to each photo:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历所有照片之前，我们设置任何不是针对每张照片的特定内容：
- en: '[PRE21]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This includes creating the `DispatchGroup`, which we will use to coordinate
    the work. Since our photo resizing will now be happening concurrently, we need
    a place to collect the photos once they have been processed. We can use a Swift
    array for this; however, a Swift array is a value type, so we can't use it from
    within multiple blocks, as each block will be taking a copy of the array, not
    the original array itself.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这包括创建`DispatchGroup`，我们将用它来协调工作。由于我们的照片调整大小现在将并发进行，我们需要一个地方来收集处理过的照片。我们可以使用Swift数组来做到这一点；然而，Swift数组是一个值类型，所以我们不能在多个块中使用它，因为每个块都会复制数组，而不是原始数组本身。
- en: 'To solve this with a Swift array, we would need to make the `processedPhotos`
    array property on the view controller, which would mean we would have to weakly
    capture self in the blocks that we would need to unwrap. A simpler way to solve
    this problem is to use a collection that has reference semantics; the `Foundation`
    framework provides that in the form of `NSArray` and `NSMutableArray`. As we saw
    earlier in this chapter, it''s important to understand the semantics of the construct
    being used and pick the right tool for the right job:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 要用Swift数组解决这个问题，我们需要在视图控制器中将`processedPhotos`数组属性设置为，这意味着我们必须在需要解包的块中弱捕获self。解决这个问题的更简单的方法是使用具有引用语义的集合；`Foundation`框架以`NSArray`和`NSMutableArray`的形式提供这种语义。正如我们在本章前面所看到的，理解正在使用的构造的语义并选择合适的工具来完成工作是很重要的：
- en: '[PRE22]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: For each photo, we enter the group and place the resize work on the concurrent
    queue. We can use the same scale and crop methods that we used previously, just
    passing an array containing one photo. Once the work is completed, we'll replace
    the original photo with the processed photo in the array and leave the group.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每张照片，我们进入组，并将缩放工作放在并发队列上。我们可以使用之前使用的相同的缩放和裁剪方法，只需传递包含一张照片的数组。一旦工作完成，我们将用处理过的照片替换数组中的原始照片，并离开组。
- en: 'Once every block has left the group, this `notify` block will execute. We retrieve
    the processed photos and use them to generate the photo book. Finally, we ensure
    that the completion handler is executed on the main queue:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦每个块都离开组，这个`notify`块将执行。我们检索处理过的照片，并使用它们来生成照片簿。最后，我们确保完成处理程序在主队列上执行：
- en: '[PRE23]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If you build and run the app, you can still generate a photo book and the UI
    is still responsive, and now GCD can make the best use of the available resources
    to generate our photo book.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你构建并运行应用程序，你仍然可以生成照片簿，UI仍然响应，现在GCD可以最好地利用可用资源来生成我们的照片簿。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Documentation relating to dispatch queues: [http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与派发队列相关的文档：[http://swiftbook.link/docs/dispatchqueue](http://swiftbook.link/docs/dispatchqueue)
- en: 'Documentation relating to dispatch groups: [http://swiftbook.link/docs/dispatchgroup](http://swiftbook.link/docs/dispatchgroup)'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与派发组相关的文档：[http://swiftbook.link/docs/dispatchgroup](http://swiftbook.link/docs/dispatchgroup)
- en: Implementing the operation class
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现操作类
- en: In this chapter so far, we have taken our long-running operations and scheduled
    them as blocks of code, called **closures**, on dispatch queues. This has made
    it really easy to move long-running code off of the main queue, but if we intend
    to reuse this long-running code, pass it around, track its state, and generally
    deal with it in an object-orientated way, a closure is not ideal.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们将长时间运行的操作作为代码块，称为**闭包**，在派发队列上进行调度。这使得将长时间运行代码从主队列中移除变得非常容易，但如果我们的意图是重用这段长时间运行的代码，传递它，跟踪其状态，并以面向对象的方式处理它，闭包并不是理想的选择。
- en: To solve this, the `Foundation` framework provides an object, `Operation`, that
    allows us to wrap up our block of work within an encapsulated object.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，`Foundation`框架提供了一个名为`Operation`的对象，它允许我们将工作块封装在一个封装的对象中。
- en: In this recipe, we will take the photo book app we used throughout this chapter
    and convert our long-running blocks to an `Operation` instance.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用本章中使用的照片簿应用程序，并将我们的长时间运行代码块转换为`Operation`实例。
- en: Getting ready
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We are going to build on the app we improved in the last recipe, which is an
    app that will produce a PDF photo book from a collection of photos. You can get
    the code for this app at [https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)
    and choose the `PhotobookCreator_StartOperations` folder.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在上一个菜谱中改进的应用程序的基础上进行构建，这是一个从照片集合生成PDF照片簿的应用程序。你可以在这个应用程序的代码在[https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09](https://github.com/PacktPublishing/Swift-Cookbook-Second-Edition/tree/master/Chapter09)中找到，并选择`PhotobookCreator_StartOperations`文件夹。
- en: Open the folder and navigate to the `PhotoCollectionViewController.swift` file.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 打开文件夹并导航到`PhotoCollectionViewController.swift`文件。
- en: How to do it...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s recap how we broke the work down into independent parts:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们如何将工作分解成独立的部分：
- en: '![](img/062bde1e-59e3-47eb-be26-9d081791e091.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/062bde1e-59e3-47eb-be26-9d081791e091.jpg)'
- en: Figure 9.16 – Concurrent Approach blocks
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.16 – 并发方法块
- en: 'We can turn each of these blocks of work into separate operations:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这些工作块中的每一个转换成单独的操作：
- en: Let's create an operation to scale and crop each photo.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个操作来缩放和裁剪每张照片。
- en: We define an operation by sub-classing the `Operation` class, so in the project,
    create a new Swift file and call it `PhotoResizeOperation.swift`.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过子类化`Operation`类来定义一个操作，因此在这个项目中，创建一个新的Swift文件，并将其命名为`PhotoResizeOperation.swift`。
- en: 'In the simplest `Operation` implementation, we only need to override one method,
    `main()`, so let''s copy and paste the relevant code from our `generatePhotobook`
    method. This `main()` method will be executed when the operation starts:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最简单的`操作`实现中，我们只需要重写一个方法，即`main()`方法，因此让我们从我们的`generatePhotobook`方法中复制并粘贴相关代码。这个`main()`方法将在操作开始时执行：
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Copying and pasting the code is not enough, as there are a number of dependencies
    that were previously being captured by the block. Now we have to explicitly provide
    these dependencies to the operation:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仅复制和粘贴代码是不够的，因为之前有一些依赖项被代码块捕获。现在我们必须明确地提供这些依赖项给操作：
- en: '[PRE25]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We have converted our resize block to an operation. We now need to do the same
    for the block that generates the photo book:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经将调整大小的代码块转换成了操作。现在我们需要对生成照片书的代码块做同样的处理：
- en: '[PRE26]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We pass the dependencies into the operation, just like in `PhotoResizeOperation`.
    The output of this operation is a URL for the resulting photo book. We expose
    that as a property on the operation so that it can be retrieved outside the operation.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将依赖项传递给操作，就像在`PhotoResizeOperation`中一样。这个操作的输出是一个结果照片书的URL。我们将其作为操作的属性公开，以便可以在操作外部检索。
- en: 'With our blocks of work converted to operations, let''s switch over to `PhotoCollectionViewController.swift`
    and update our `generatePhotoBook` method to use this new operation:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将我们的工作代码块转换为操作后，让我们切换到`PhotoCollectionViewController.swift`并更新我们的`generatePhotoBook`方法以使用这个新操作：
- en: '[PRE27]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Let''s walk through the changes step by step:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一步一步地看看这些更改：
- en: 'Where we were previously using a `DispatchQueue` to manage the execution of
    our blocks, operations are now managed with an `OperationQueue`:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前使用`DispatchQueue`来管理代码块的执行的地方，现在使用`OperationQueue`来管理操作：
- en: '[PRE28]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The method signature in the following code and the dependencies we need to
    generate upfront remain the same:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码中的方法签名和我们需要提前生成的依赖项保持不变：
- en: '[PRE29]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, we create the operation to generate the photo book, passing in the dependencies:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建生成照片书的操作，传递依赖项：
- en: '[PRE30]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Although the operation will be executed last, we create it first so that we
    can make it dependent on the resize operations we are about to create. An operation
    does not execute immediately upon creation. It will only execute when the `start()`
    method of `Operation` is called, which can be called manually, or, if an `Operation`
    is placed on an `OperationQueue`, it will be called by the queue as appropriate:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管操作将在最后执行，但我们首先创建它，以便我们可以使其依赖于我们即将创建的调整大小操作。一个操作在创建时不会立即执行。它只有在调用`Operation`的`start()`方法时才会执行，这可以手动调用，或者如果将`Operation`放置在`OperationQueue`上，它将由队列在适当的时候调用：
- en: '[PRE31]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Now, as you can see from the preceding code, we loop through the number of photos
    that we intend to process and create a resize operation for each, passing in the
    dependencies.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，正如您可以从前面的代码中看到的那样，我们遍历我们打算处理的照片数量，并为每一张照片创建一个调整大小的操作，传递依赖项。
- en: With our move to use `Operation`, one thing we have lost is the use of `DispatchGroup`,
    which we used to ensure that we only generated the photo book once all the photo
    resize blocks had completed. We can, however, achieve the same goals using operation
    dependencies. An operation can be declared as dependent on a set of other operations,
    so it will not begin executing until the operations it depends on have finished.
    To ensure that the `generateBookOp` operation, which we just created, only executes
    when all the `PhotoResizeOperation` operations are complete, we add each of them
    as a dependency of `generateBookOp`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们转向使用`Operation`的过程中，我们失去了一件事，那就是`DispatchGroup`的使用，我们曾用它来确保只有在所有照片调整大小代码块完成之后才生成照片书。然而，我们可以通过操作依赖项达到相同的目标。一个操作可以被声明为依赖于一组其他操作，因此它将不会开始执行，直到它所依赖的操作完成。为了确保我们刚刚创建的`generateBookOp`操作仅在所有`PhotoResizeOperation`操作完成时执行，我们将它们中的每一个都添加为`generateBookOp`的依赖项。
- en: 'With this done, we can place each `PhotoResizeOperation` on the `OperationQueue`:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，我们可以将每个`PhotoResizeOperation`放置在`OperationQueue`上：
- en: '[PRE32]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`Operation` has a `completionBlock` property; any block set here will be executed
    once the operation has completed. We can use this to fire our completion handler
    on the main queue. Since we need to provide the completion handler with the URL
    to the photo book created by `generateBookOp`, we can retrieve this from within
    the block, as we know that the operation will be finished and the URL will be
    there. However, we need to be careful. We are providing a closure to `generateBookOp`,
    which will be retained, and we are using, and therefore capturing and retaining,
    the `generateBookOp` operation in the same block. This will lead to a retain cycle,
    and `generateBookOp` will never get released from memory. To avoid this retain
    cycle, we specify that we want to weakly capture `generateBookOp` in the block
    we provide, using the `[weak generateBookOp]` capture list. This won''t increment
    the retain count, preventing the retain cycle from happening.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`Operation`有一个`completionBlock`属性；任何设置在这里的块将在操作完成后执行。我们可以使用这个属性在主队列上触发我们的完成处理程序。由于我们需要向完成处理程序提供由`generateBookOp`创建的相册的URL，我们可以在块内部检索它，因为我们知道操作将完成，URL将存在。然而，我们需要小心。我们向`generateBookOp`提供了一个闭包，它将被保留，并且我们在同一个块中使用它，因此捕获并保留了`generateBookOp`操作。这将导致保留循环，`generateBookOp`将永远不会从内存中释放。为了避免这种保留循环，我们在提供的块中指定我们想要弱捕获`generateBookOp`，使用`[weak
    generateBookOp]`捕获列表。这不会增加保留计数，从而防止保留循环的发生。'
- en: 'Much like `DispatchQueue`, `OperationQueue` has an available property that
    provides a reference to the main queue, upon which the UI events are processed.
    Also, `OperationQueue` has a convenience method that will take a block of code,
    wrap it in an `Operation`, and add it to the queue. We use this to ensure that
    the completion handler is executed on the main queue:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与`DispatchQueue`类似，`OperationQueue`有一个可用的属性，它提供了一个对主队列的引用，UI事件在此队列上处理。此外，`OperationQueue`有一个便利方法，它将代码块包装在一个`Operation`中，并将其添加到队列中。我们使用这个方法来确保完成处理程序在主队列上执行：
- en: '[PRE33]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As the final step, we put the `generateBookOp` operation on the processing queue.
    It's important that we do this as the last step because, once placed on the queue,
    the operation may be executed immediately, but we don't want it executed immediately.
    We only want `generateBookOp` executed once all the resize operations are complete,
    and if we placed the operation on the queue before setting up the dependencies,
    this could happen.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最后一步，我们将`generateBookOp`操作放在处理队列上。我们这样做作为最后一步非常重要，因为一旦放置在队列上，操作可能会立即执行，但我们不希望它立即执行。我们只想在所有调整大小操作完成后执行`generateBookOp`，如果我们在此之前将操作放在队列上，这可能会发生。
- en: Now that we have transitioned our app over to using `Operation`, let's build
    and then run and verify that everything works just as it did before.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经将我们的应用程序过渡到使用`Operation`，让我们构建并运行它，然后验证一切是否如预期那样工作。
- en: 'Users of our photo book app currently do not have the ability to cancel the
    generation of a photo book once the process has started, so let''s add that functionality:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们相册应用程序的用户目前没有在过程开始后取消相册生成的能力，所以让我们添加这个功能：
- en: 'We will examine our two operations and look for opportunities to check the
    `isCancelled` property and exit early. Switch to `PhotoResizeOperation.swift`
    and add `isCancelled` checks to the `main()` method:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将检查我们的两个操作，寻找检查`isCancelled`属性并提前退出的机会。切换到`PhotoResizeOperation.swift`并在`main()`方法中添加`isCancelled`检查：
- en: '[PRE34]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Before each piece of long-running work, we check the `isCancelled` property,
    and if it is `true`, we return early, which will finish the operation.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在每项长时间运行的工作之前，我们检查`isCancelled`属性，如果它是`true`，我们就提前返回，这将完成操作。
- en: 'We can do the same in `GeneratePhotoBookOperation.swift`:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们同样可以在`GeneratePhotoBookOperation.swift`中这样做：
- en: '[PRE35]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Next, we will need to add some UI that allows the user to cancel the photo book
    generation once it is in progress. This is an exercise for the reader, or you
    can switch to the `end-operations` branch to see how I have implemented it.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要添加一些用户界面，允许用户在生成过程中取消相册的生成。这是一个练习，或者你可以切换到`end-operations`分支来查看我是如何实现的。
- en: 'Once the user chooses to cancel generating a photo book, we can call the following
    command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦用户选择取消生成相册，我们可以调用以下命令：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This will fire the `cancel()` method on all the operations in the queue.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在队列中的所有操作上触发`cancel()`方法。
- en: We now have an app with a cancelable, long-running operation.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个具有可取消的长时间运行操作的应用程序。
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'How does `OperationQueue` know when to start an operation and when to remove
    it from the queue? It knows by monitoring the operation''s state. The `Operation`
    class goes through a number of state transformations during its life cycle. The
    following diagram describes how these state transformations occur:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`OperationQueue` 如何知道何时开始一个操作以及何时从队列中移除它？它是通过监控操作的状态来知道的。`Operation` 类在其生命周期中会经历多个状态转换。以下图表描述了这些状态转换是如何发生的：'
- en: '![](img/225f9e07-2d51-4a5c-8cf6-89d829dc3212.jpg)'
  id: totrans-223
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/225f9e07-2d51-4a5c-8cf6-89d829dc3212.jpg)'
- en: Figure 9.17 – Operation life cycle
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.17 – 操作生命周期
- en: 'Information about the operation''s state is exposed through a number of Boolean
    properties on `Operation`, and the operation queue uses the properties to know
    when to perform certain actions on the operations. Let''s look at these properties
    one by one:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `Operation` 上的多个布尔属性暴露操作的状态信息，操作队列使用这些属性来知道何时对操作执行某些操作。让我们逐一查看这些属性：
- en: '[PRE37]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An operation will return `true` for `isReady` when all its dependencies are
    finished. If it doesn''t have any dependencies, it will always return `true`.
    The queue will only start executing an operation if `isReady` is `true`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当所有依赖项完成时，操作将返回 `true` 给 `isReady`。如果没有依赖项，它将始终返回 `true`。队列只有在 `isReady` 为 `true`
    时才会开始执行操作：
- en: '[PRE38]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Once `start` is called on an operation, either manually or by a queue, `isExecuting`
    will return `true`, and when the operation has finished executing, `isExecuting`
    will revert to returning `false`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对操作调用 `start`，无论是手动还是由队列调用，`isExecuting` 将返回 `true`，当操作执行完毕时，`isExecuting`
    将恢复为返回 `false`。
- en: 'Since operations remain on the queue until they have finished, the queue uses
    the `isExecuting` property to ensure that it doesn''t call `start` on an operation
    that has already started:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于操作会保留在队列中，直到它们完成，因此队列使用 `isExecuting` 属性来确保它不会对一个已经开始的操作调用 `start`：
- en: '[PRE39]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Once the operation has finished doing whatever processing is required, `isFinished`
    should return `true`. When `isFinished` starts to return `true`, it will be removed
    from the queue, and the queue will no longer maintain a reference to the operation.
    For the simplest implementation of `Operation`, as we implemented earlier, `isFinished`
    returns `true` automatically when the `main()` method has finished executing:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦操作完成了所需的任何处理，`isFinished` 应该返回 `true`。当 `isFinished` 开始返回 `true` 时，它将被从队列中移除，并且队列将不再保持对操作的引用。对于我们在前面实现的
    `Operation` 的最简单实现，`isFinished` 在 `main()` 方法执行完毕时会自动返回 `true`：
- en: '[PRE40]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Operations can be canceled by calling the `cancel()` method on the operation.
    Once called, the `isCancelled` property will return true. This can be used to
    exit early from a long-running operation, but it is up to you to check the `isCancelled`
    method and interrupt any long-running code if it returns `true`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在操作上调用 `cancel()` 方法来取消操作。一旦调用，`isCancelled` 属性将返回 `true`。这可以用来提前退出长时间运行的操作，但是检查
    `isCancelled` 方法并在它返回 `true` 时中断任何长时间运行的代码取决于你。
- en: See also
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Documentation relating to the `Operation` class: [http://swiftbook.link/docs/operation](http://swiftbook.link/docs/operation)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Operation` 类相关的文档：[http://swiftbook.link/docs/operation](http://swiftbook.link/docs/operation)
