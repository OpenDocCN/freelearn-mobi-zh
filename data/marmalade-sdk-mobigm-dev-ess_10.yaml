- en: Chapter 10. Extending Marmalade with the Extensions Development Kit (EDK)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章. 使用扩展开发工具包（EDK）扩展Marmalade
- en: In the previous chapter we mentioned how Marmalade's **Extensions Development
    Kit** (**EDK**) was a possible way of adding functionality to a Marmalade application
    that had not been otherwise exposed, by using the standard Marmalade APIs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到了Marmalade的**扩展开发工具包**（**EDK**）是如何通过使用标准的Marmalade API来向Marmalade应用程序添加未在其他方面公开的功能的一种可能方式。
- en: 'In this chapter we''ll be looking at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下主题：
- en: An overview of what the EDK is and why it is needed
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: EDK概述及其必要性
- en: How to extend Marmalade by creating an EDK extension for Windows, iOS, and Android
    to support reading gyroscope information
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何通过创建Windows、iOS和Android的EDK扩展来扩展Marmalade以支持读取陀螺仪信息
- en: Why is the EDK necessary?
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么EDK是必要的？
- en: The Marmalade SDK manages to work its magic of being able to take one codebase
    and deploy it to multiple platforms by providing a set of APIs that sit on top
    of the APIs specific to each platform.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: Marmalade SDK通过提供一套API，这些API位于每个平台特定API之上，实现了能够将一个代码库部署到多个平台上的神奇功能。
- en: A deployed application executable actually consists of two separate files. Our
    application code is compiled into an **S3E file**, which is the Marmalade equivalent
    of a Windows **Dynamic Link Library** (**DLL**). This file is the same across
    all platforms.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 部署的应用程序可执行文件实际上由两个独立的文件组成。我们的应用程序代码被编译成**S3E文件**，这是Marmalade的Windows**动态链接库**（**DLL**）等价物。该文件在所有平台上都是相同的。
- en: In order to execute our S3E file, a Loader program is used. This program is
    the glue between the platform we are running on and our own code. The loader program
    starts up first, loads the S3E file into memory, and then passes control to the
    code within it. If our code needs to make a platform-dependant call, it actually
    makes a request to a function in the loader that will then call the correct operating
    system function.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行我们的S3E文件，我们使用一个加载程序。这个程序是我们运行的平台和我们的代码之间的粘合剂。加载程序首先启动，将S3E文件加载到内存中，然后将控制权传递给其中的代码。如果我们的代码需要执行平台相关的调用，它实际上会向加载程序中的一个函数发出请求，然后该函数会调用正确的操作系统函数。
- en: The loader program is a fixed entity and cannot be changed by us, so Marmalade
    provides us with the EDK system to enable us to make platform-specific function
    calls. Certain parts of the Marmalade SDK have actually been implemented in just
    this manner; for example, the s3eFacebook API is actually an extension!
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 加载程序是一个固定的实体，我们无法更改它，因此Marmalade为我们提供了EDK系统，使我们能够进行平台特定的函数调用。Marmalade SDK的某些部分实际上就是这样实现的；例如，s3eFacebook
    API实际上是一个扩展！
- en: The only problem with the EDK is that it is not a completely cross-platform
    solution. At the time of writing, it was only possible to write extensions for
    iOS, Android, Windows, and Mac OSX.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: EDK的唯一问题是它不是一个完全跨平台的解决方案。在撰写本文时，只能为iOS、Android、Windows和Mac OSX编写扩展。
- en: Note
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since this book is primarily concerned with development using the Windows version
    of Marmalade, we won't be looking at how to build a Mac extension here, however
    we will need access to a Mac computer in order to build iOS extensions since,
    by necessity, we have to use the Apple iOS SDK, which is not available as a Windows
    download. For details on creating Mac extensions, look in the Marmalade documentation
    by going to **Marmalade (C++)** | **Extensions Development Kit (EDK)** | **EDK
    Guides by Platform** | **OS X EDK Guide**.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书主要关注使用Marmalade的Windows版本进行开发，因此我们不会探讨如何构建Mac扩展，然而，由于我们不可避免地需要使用Apple iOS
    SDK，因此我们需要访问Mac计算机来构建iOS扩展，因为iOS SDK作为Windows下载不可用。有关创建Mac扩展的详细信息，请参阅Marmalade文档，前往**Marmalade
    (C++)** | **扩展开发工具包 (EDK)** | **按平台划分的EDK指南** | **OS X EDK指南**。
- en: Creating an extension for gyroscope input
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用于陀螺仪输入的扩展
- en: To illustrate the process of creating a Marmalade extension, we'll take a look
    at how to add support for gyroscope input. This is a useful addition since it
    lets us add a whole new input method to our games yet it also demonstrates just
    how easy it is to extend Marmalade's functionality.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明创建Marmalade扩展的过程，我们将查看如何添加对陀螺仪输入的支持。这是一个有用的添加，因为它让我们能够向我们的游戏添加全新的输入方法，同时也展示了扩展Marmalade功能是多么容易。
- en: 'Our extension will consist of the following functions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们扩展将包含以下函数：
- en: '| Function | Description |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 描述 |'
- en: '| --- | --- |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `GyroscopeAvailable` | This function is automatically generated for us by
    the EDK build process. It returns `S3E_TRUE` if the Gyroscope extension is supported
    for the current platform, and `S3E_FALSE` if it isn''t. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `GyroscopeAvailable` | 这个函数由 EDK 构建过程自动为我们生成。如果当前平台支持陀螺仪扩展，则返回 `S3E_TRUE`；如果不支持，则返回
    `S3E_FALSE`。|'
- en: '| `GyroscopeSupported` | Not all mobile devices actually contain gyroscope
    hardware, so this function is provided to determine whether or not we can make
    use of the gyroscope in our game. The function returns a normal C++ `bool` value
    indicating whether a gyroscope is present. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `GyroscopeSupported` | 并非所有移动设备实际上都包含陀螺仪硬件，因此这个函数提供了确定我们是否可以在游戏中使用陀螺仪的方法。该函数返回一个正常的
    C++ `bool` 值，指示是否存在陀螺仪。|'
- en: '| `GyroscopeStart` and`GyroscopeStop` | These two functions start and stop
    the hardware generating gyroscope input data. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `GyroscopeStart` 和 `GyroscopeStop` | 这两个函数用于启动和停止生成陀螺仪输入数据的硬件。|'
- en: '| `GyroscopeGetX` ,`GyroscopeGetY` , and`GyroscopeGetZ` | Returns the current
    gyroscope data values for the X, Y, and Z axes. The values are returned as `float`
    values in radians per second. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `GyroscopeGetX`、`GyroscopeGetY` 和 `GyroscopeGetZ` | 返回 X、Y 和 Z 轴的当前陀螺仪数据值。这些值以每秒弧度（`float`
    值）的形式返回。|'
- en: The API detailed earlier provides the bare minimum functionality required to
    provide gyroscope support and has deliberately been kept simple in order to demonstrate
    the process of building an extension more clearly.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 之前详细说明的 API 提供了提供陀螺仪支持所需的最小功能，并且故意保持简单，以便更清楚地展示构建扩展的过程。
- en: Declaring the extension API
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明扩展 API
- en: 'The first step in creating an extension is to specify the functions it will
    contain, which we will do using an **S4E file**. This file is used to define the
    API of our extension and is best illustrated by an example. If you want to follow
    along, create a new directory called `Gyroscope` and create a file called `Gyroscope.s4e`
    inside it with the following contents:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建扩展的第一步是指定它将包含的函数，我们将使用 **S4E 文件** 来完成这项工作。这个文件用于定义我们扩展的 API，最好通过一个例子来说明。如果您想跟上来，创建一个名为
    `Gyroscope` 的新目录，并在其中创建一个名为 `Gyroscope.s4e` 的文件，其内容如下：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The example starts with the line `include:`, which is then followed by any number
    of C preprocessor commands, include files, structure definitions, and class definitions
    that will become part of the extension's main header file. In our case we are
    just including the `s3eTypes.h` file; but if we needed to pass lots of data between
    the extension and the calling code, we might want to add structures or classes,
    enumerations, and definitions here too.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 示例从 `include:` 行开始，随后跟随着任意数量的 C 预处理器命令、包含文件、结构定义和类定义，这些将成为扩展的主要头文件的一部分。在我们的例子中，我们只是包含了
    `s3eTypes.h` 文件；但如果我们需要在扩展和调用代码之间传递大量数据，我们可能还想在这里添加结构或类、枚举和定义。
- en: Next we have the `functions:` section of the file, which is little more than
    a list of the functions that our extension will contain and can be called from
    within a Marmalade project that makes use of the extension.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是文件的 `functions:` 部分，这基本上是包含我们扩展将包含并可以在使用扩展的 Marmalade 项目中调用的函数的列表。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We do not have to list the `GyroscopeAvailable` function explicitly in the list
    of functions. The EDK build process automatically generates this function for
    us by taking the name of the S4E file and appending "Available" to the end of
    it.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不必在函数列表中明确列出 `GyroscopeAvailable` 函数。EDK 构建过程会自动为我们生成这个函数，通过取 S4E 文件名并在其末尾添加
    "Available" 来实现。
- en: As you can see, the functions are listed almost as if they were normal C function
    prototypes. Each function is listed on its own line by first stating the return
    type and then its name and parameter list (which all just happen to be empty in
    this example!).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，函数的列表几乎就像它们是正常的 C 函数原型一样。每个函数都单独列出，首先声明返回类型，然后是其名称和参数列表（在这个例子中，所有这些都恰好是空的！）。
- en: 'Additionally, each function in the S4E file function list also specifies a
    default value it will return and can be followed by a number of optional directives
    that control the behavior of the function, how it is added to the extension, and
    how it is called. Our example makes no use of these directives, but the following
    table shows what can be specified:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，S4E 文件中函数列表中的每个函数还指定了它将返回的默认值，并且可以跟随着一系列可选指令，这些指令控制函数的行为、如何将其添加到扩展中以及如何调用它。我们的例子没有使用这些指令，但以下表格显示了可以指定的内容：
- en: '| Directive | Description |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `run_on_osthread` | Specifies that the extension function should only be
    executed on the main OS thread of the application. This is particularly important
    if the function performs any kind of user interface interaction, as many platforms
    will only allow UI calls to be made on the main thread. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `run_on_osthread` | 指定扩展函数应在应用程序的主要OS线程上执行。如果该函数执行任何类型的用户界面交互，这尤其重要，因为许多平台只允许在主线程上调用UI调用。|'
- en: '| `no_lock` | Disables thread-safe locking when calling this function. By default
    all extension functions can only be called on a single thread at any particular
    time and locking code is automatically generated to ensure that this happens.
    |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `no_lock` | 在调用此函数时禁用线程安全锁定。默认情况下，所有扩展函数只能在任何特定时间由单个线程调用，并且会自动生成锁定代码以确保这一点。|'
- en: '| `fast` | Enables fast stack switching. This is an optimization option, which
    means less data needs to be passed between our application and the loader when
    making an extension function call by using the same stack as the loader module.
    Normally the loader module and our application code have separate stacks. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| `fast` | 启用快速栈切换。这是一个优化选项，意味着在通过使用与加载模块相同的栈来调用扩展函数时，我们应用程序和加载器之间需要传递的数据更少。通常，加载模块和我们的应用程序代码有独立的栈。|'
- en: '| `no_assert` | Stops an assert from being raised if an extension function
    is called on a platform for which the extension has not been built. The default
    value for the function will be returned. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| `no_assert` | 如果在尚未为该平台构建扩展的情况下调用扩展函数，将阻止抛出断言。函数的默认值将被返回。|'
- en: '| `order` | By default each function listed in the S4E file will be added to
    the extension in list order and this order is used internally to locate the correct
    function pointer to call. As our extension develops over time, we may want to
    add or depreciate functions but still keep related functions together in the S4E
    file. By adding `order=x` after a function declaration we say that this function
    will occupy position `x` in the function order, with *x=1* being immediately after
    the last function that does not specify an order value. If that sounds confusing,
    don''t worry; for our own projects we will probably never need to make use of
    this feature as it is only really an issue if we are making our extension available
    for other people to use! |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| `order` | 默认情况下，S4E文件中列出的每个函数都将按列表顺序添加到扩展中，并且此顺序在内部用于定位要调用的正确函数指针。随着我们的扩展随时间发展，我们可能想要添加或弃用函数，但仍希望将相关函数在S4E文件中保持在一起。通过在函数声明后添加`order=x`，我们表示此函数将占据函数顺序中的位置`x`，其中`x=1`表示紧接在未指定顺序值的最后一个函数之后。如果这听起来很复杂，请不要担心；对于我们的项目，我们可能永远不会需要使用此功能，因为它只有在我们将扩展提供给其他人使用时才真正成为问题！|'
- en: 'There are also a number of global directives that can be specified in the S4E
    file and these should be listed at the very start of the file before the `include:`
    line. Again our example makes no use of these directives, but for your information
    they are listed in the following table:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在S4E文件中还可以指定一些全局指令，并且这些指令应列在文件的最开始处，在`include:`行之前。同样，我们的示例没有使用这些指令，但为了您的信息，它们列在以下表中：
- en: '| Directive | Description |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 指令 | 描述 |'
- en: '| --- | --- |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `no_init_term` | Specifies that the extension needs no initialization or
    termination functions to be automatically generated. It is unlikely you will ever
    use this directive since these functions are generally required in order to set
    up the interface between the extension and our project code. |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| `no_init_term` | 指定扩展不需要自动生成初始化或终止函数。由于这些函数通常用于设置扩展与我们的项目代码之间的接口，因此您不太可能使用此指令。|'
- en: '| `errors` | Allows access to some macros that make communication of errors
    easier to implement by automatically generating functions, such as `GetError`,
    present in many of the S3E APIs that make up the low-level Marmalade API. |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| `errors` | 允许访问一些宏，这些宏通过自动生成函数（如许多S3E API中存在的`GetError`）使错误通信更容易实现。这些API构成了低级Marmalade
    API。|'
- en: '| `globals` | Declares that the extension will require a global structure block
    allocated for its internal use and makes some macros available in order to support
    getting and setting values in this structure. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `globals` | 声明扩展将需要为其内部使用分配一个全局结构块，并使一些宏可用，以便支持在此结构中获取和设置值。|'
- en: '| `callbacks` | States that this extension wants to make use of callbacks and
    will automatically define callback IDs to support this using the same approach
    used in other built-in S3E APIs. |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `callbacks` | 表示此扩展希望使用回调，并将自动定义回调 ID 以支持此功能，使用与其他内置 S3E API 相同的方法。|'
- en: Making an extension for Windows
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为 Windows 制作扩展
- en: We'll begin by creating our extension for use on Windows. Obviously it's unlikely
    that a Windows PC would feature gyroscope hardware (though I guess not impossible!),
    but starting with the Windows version is easiest as it does not require us to
    install any additional software or SDKs in order to build it.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建用于 Windows 的扩展。显然，Windows PC 很可能没有陀螺仪硬件（尽管我想不是不可能的！），但以 Windows 版本开始是最容易的，因为它不需要我们安装任何额外的软件或
    SDK 来构建它。
- en: Creating a Windows extension
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Windows 扩展
- en: Since we won't actually be supporting gyroscope input on Windows, our API only
    needs to return `false` in the `GyroscopeSupported` function and the functions
    for accessing current gyroscope values should always return a `0` value. Obviously
    the start and stop functions need to do absolutely nothing!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们实际上不会在 Windows 上支持陀螺仪输入，我们的 API 只需要在 `GyroscopeSupported` 函数中返回 `false`，并且访问当前陀螺仪值的函数应该始终返回一个
    `0` 值。显然，开始和停止函数需要做的是绝对没有任何操作！
- en: We've already created the S4E file, so now we'll put it to use. Open Windows
    Explorer, navigate to the `Gyroscope` directory, and then right-click on the `Gyroscope.s4e`
    file. Select the menu option **Build Windows Extension**, which will run a Python
    script that generates a number of new files and directories.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了 S4E 文件，现在我们将开始使用它。打开 Windows 资源管理器，导航到 `Gyroscope` 目录，然后右键单击 `Gyroscope.s4e`
    文件。选择菜单选项 **构建 Windows 扩展**，这将运行一个 Python 脚本，生成多个新文件和目录。
- en: 'In the main `Gyroscope` directory three new files are created:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在主 `Gyroscope` 目录中创建了三个新文件：
- en: '`Gyroscope_build.mkf` is the MKF file for the extension that allows us to specify
    additional generic or platform-dependant source files that are needed for building
    it'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gyroscope_build.mkf` 是扩展的 MKF 文件，允许我们指定构建它所需的附加通用或平台相关源文件。'
- en: '`Gyroscope.mkf` is the MKF file any Marmalade project that makes use of our
    extension will need to include as a subproject to access the extension functions'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gyroscope.mkf` 是任何使用我们扩展的 Marmalade 项目需要包含为子项目以访问扩展函数的 MKF 文件'
- en: '`Gyroscope_windows.mkb` is the MKB file that creates a Visual Studio project
    that we can use to compile the extension code'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Gyroscope_windows.mkb` 是创建一个 Visual Studio 项目的 MKB 文件，我们可以使用它来编译扩展代码'
- en: There are four subdirectories created as well. We can safely ignore the `stamp`
    directory, which contains a file used internally by the EDK build scripts to track
    changes to the extension API. We can also ignore the files in the `interface`
    directory, which are autogenerated and should not be altered.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 还创建了四个子目录。我们可以安全地忽略 `stamp` 目录，它包含一个由 EDK 构建脚本内部使用的文件，用于跟踪扩展 API 的更改。我们还可以忽略
    `interface` 目录中的文件，这些文件是自动生成的，不应被修改。
- en: The `h` directory contains a single file, `Gyroscope.h`, which again we should
    not modify, as any changes we make will be overwritten by the extension creation
    scripts. This file is very useful, however, as it is the file we will include
    in our project sources to access the functions in the extension.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`h` 目录包含一个名为 `Gyroscope.h` 的单个文件，我们不应修改它，因为我们所做的任何更改都将被扩展创建脚本覆盖。然而，这个文件非常有用，因为它是我们将包含在我们的项目源文件中以便访问扩展中函数的文件。'
- en: Finally there is the `source` directory that in turn contains three more subdirectories.
    The `generic` subdirectory contains source files that will define the default
    behavior of the extension if platform-specific source files are not provided.
    The `h` directory also contains files that are used across all platforms for building
    the extension code. While we can make changes to these files, it is unlikely we
    will ever need to.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 最后是 `source` 目录，它反过来又包含三个更多的子目录。`generic` 子目录包含定义扩展默认行为的源文件，如果未提供平台特定的源文件。`h`
    目录还包含用于构建扩展代码的所有平台的文件。虽然我们可以修改这些文件，但我们不太可能需要这样做。
- en: This leaves us with the `windows` subdirectory that contains a single file called
    `Gyroscope_platform.cpp`. This file contains stubs for each of our extension functions
    that were generated from the data provided in the functions list of the S4E file.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得我们拥有一个名为 `Gyroscope_platform.cpp` 的单个文件的 `windows` 子目录。此文件包含从 S4E 文件的功能列表中提供的数据生成的我们每个扩展函数的存根。
- en: Note however that all the stubbed functions end with the suffix `_platform`.
    The EDK system actually generates a set of generic functions with the exact names
    specified in the S4E file that calls the equivalent functions that are suffixed
    with `_platform`, if they exist. This is necessary so that code that uses an extension
    can still be compiled and executed on a platform for which an extension has not,
    or cannot, be created.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，所有模拟函数都以`_platform`后缀结尾。EDK系统实际上生成了一组具有S4E文件中指定名称的通用函数，如果存在，则调用以`_platform`结尾的等效函数。这是必要的，以便使用扩展的代码仍然可以在没有或无法创建扩展的平台上进行编译和执行。
- en: Implementing a Windows extension
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Windows扩展
- en: Ordinarily we would need to modify the `Gyroscope_platform.cpp` file to implement
    the extension; but for our purposes no changes are actually necessary as the generated
    stubs provide the desired functionality on Windows.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要修改`Gyroscope_platform.cpp`文件来实现扩展；但出于我们的目的，实际上并不需要任何更改，因为生成的模拟提供了在Windows上所需的函数。
- en: Obviously, in this case a Windows extension is a little redundant, but bear
    in mind we could always create a more complex extension that somehow emulates
    gyroscope behavior, perhaps using a joystick or some other input device.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，在这种情况下，一个Windows扩展有点多余，但请记住，我们始终可以创建一个更复杂的扩展，它以某种方式模拟陀螺仪行为，也许使用游戏手柄或其他输入设备。
- en: Building a Windows extension
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建Windows扩展
- en: To build the extension, we just double-click the `Gyroscope\Gyroscope_windows.mkb`
    file to create a Visual Studio project. Once Visual Studio starts up, select the
    **(x86) Release** build type from the drop-down menu at the top of the Visual
    Studio IDE, go to the menu option **Build** | **Build Solution** (or just press
    the *F7* key), and the Windows version of the extension will be created. Simple!
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建扩展，我们只需双击`Gyroscope\Gyroscope_windows.mkb`文件来创建一个Visual Studio项目。一旦Visual
    Studio启动，从Visual Studio IDE顶部的下拉菜单中选择**（x86）发布**构建类型，转到菜单选项**构建** | **构建解决方案**（或直接按*F7*键），扩展的Windows版本将被创建。很简单！
- en: Making an Android extension
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Android扩展
- en: Now we'll turn our attention to Android. We'll need to install some software
    before we can begin, though, as the build process needs to be able to access Java
    development tools and the Android SDK.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将注意力转向Android。然而，在我们开始之前，我们需要安装一些软件，因为构建过程需要能够访问Java开发工具和Android SDK。
- en: Installing the required software for Android development
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装Android开发所需的软件
- en: 'First of all you will need to install the Java JDK, which is available for
    download at the following address:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，您需要安装Java JDK，它可在以下地址下载：
- en: '[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://www.oracle.com/technetwork/java/javase/downloads/index.html](http://www.oracle.com/technetwork/java/javase/downloads/index.html)'
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When downloading the JDK, make sure it is Version 6 that you download and not
    the newer Version 7\. The Android SDK is not guaranteed to work correctly with
    Version 7.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下载JDK时，请确保下载的是版本6，而不是更新的版本7。Android SDK与版本7可能无法正确工作。
- en: Once the install package has downloaded, execute it and follow the instructions
    to install the Java development tools to your PC.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下载安装包后，执行它并按照说明将Java开发工具安装到您的PC上。
- en: Next you will need to download the Android SDK and NDK. The Android SDK is the
    Java library normally used to develop Android applications, while the NDK is an
    additional set of libraries that allows Java Android code to interface with compiled
    C++ code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，您需要下载Android SDK和NDK。Android SDK是通常用于开发Android应用程序的Java库，而NDK是一组额外的库，它允许Java
    Android代码与编译的C++代码接口。
- en: 'The Android SDK is available at the following URL:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK可在以下网址获取：
- en: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/sdk/index.html](http://developer.android.com/sdk/index.html)'
- en: It comes as a Windows installer file; so just execute it, accept all the default
    install options, and wait for it to install.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 它以Windows安装程序文件的形式提供；所以只需执行它，接受所有默认安装选项，等待安装完成。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once the Android SDK has been installed, it is useful to set the environment
    variable `ANDROID_ROOT` to the installation directory. This lets the Marmalade
    deployment tool know where the Android platform tools can be found so that it
    can automatically install and run generated package files on an Android device
    connected to your PC using a USB cable.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Android SDK，将环境变量 `ANDROID_ROOT` 设置为安装目录是有用的。这可以让 Marmalade 部署工具知道 Android
    平台工具的位置，以便它可以自动安装和运行连接到你的 PC 的 Android 设备上的生成的包文件。
- en: 'Next you can visit the following URL to download the Android NDK:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以访问以下 URL 下载 Android NDK：
- en: '[http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://developer.android.com/tools/sdk/ndk/index.html](http://developer.android.com/tools/sdk/ndk/index.html)'
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You will need different versions of the NDK depending on which version of Marmalade
    you are using. If you are using Marmalade 6.1 or higher, as expected in this book,
    you will need NDK version 8\. For earlier versions of Marmalade, you will need
    NDK version 7.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 根据你使用的 Marmalade 版本，你可能需要不同版本的 NDK。如果你使用的是 Marmalade 6.1 或更高版本，正如本书所预期的那样，你需要
    NDK 版本 8。对于 Marmalade 的早期版本，你需要 NDK 版本 7。
- en: The NDK is supplied as a ZIP archive, so you will need to decompress it using
    a suitable archiving program (for example, WinZip). The NDK should be contained
    in a directory named something like `android-ndk-xxx`, where `xxx` refers to the
    version number of the NDK. You can either copy this directory into the root of
    your `C:` or you can set the environment variable `NDK_ROOT` to point to the installation
    path.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: NDK 以 ZIP 存档的形式提供，因此你需要使用合适的归档程序（例如，WinZip）将其解压缩。NDK 应该包含在一个名为 `android-ndk-xxx`
    的目录中，其中 `xxx` 指的是 NDK 的版本号。你可以将其复制到 `C:` 的根目录，或者你可以设置环境变量 `NDK_ROOT` 以指向安装路径。
- en: Creating an Android extension
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 Android 扩展
- en: Now that we have the necessary development tools in place, we can create the
    Android extension files by again using the Windows Explorer to locate the `Gyroscope.s4e`
    file. Right-click on the file and select the **Build Android Extension** menu
    option.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经安装了必要的开发工具，我们可以通过再次使用 Windows 资源管理器来定位 `Gyroscope.s4e` 文件来创建 Android 扩展文件。右键单击文件并选择
    **构建 Android 扩展** 菜单选项。
- en: The files `Gyroscope_android.mkb` and `Gyroscope_android_java.mkb` will be created
    in the main `Gyroscope` directory. These files will be used later to build the
    extension code.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`Gyroscope_android.mkb` 和 `Gyroscope_android_java.mkb` 文件将在主 `Gyroscope` 目录中创建。这些文件将在稍后用于构建扩展代码。'
- en: The `source` directory will now contain a new directory called `android` that
    contains two files `Gyroscope.java` and `Gyroscope_platform.cpp`. The former is
    where we can add Java code that uses the Android SDK code to implement our extension
    API. The latter is the C++ code that our Marmalade project will call, which in
    turn calls the Java implementation code.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 目录现在将包含一个名为 `android` 的新目录，其中包含两个文件 `Gyroscope.java` 和 `Gyroscope_platform.cpp`。前者是我们可以添加使用
    Android SDK 代码来实现我们的扩展 API 的 Java 代码的地方。后者是我们 Marmalade 项目将调用的 C++ 代码，它反过来调用 Java
    实现代码。'
- en: It is possible to implement the entire extension in the `Gyroscope_platform.cpp`
    file by using the **Java Native Interface** (**JNI**) to access and call into
    the compiled Java code; but this adds an extra layer of complexity and implementing
    the extension in Java is normally a far easier proposition!
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能通过使用 **Java Native Interface**（**JNI**）来访问和调用编译后的 Java 代码，在 `Gyroscope_platform.cpp`
    文件中实现整个扩展；但这增加了一个额外的复杂性层，通常在 Java 中实现扩展要简单得多！
- en: Implementing an Android extension
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 Android 扩展
- en: 'To implement the gyroscope code for Android, we will need to edit the file
    `source\android\Gyroscope.java`. First we need to make a reference to the Java
    classes we''ll be using; so change the list of import declarations at the top
    of the file to look like this:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要为 Android 实现陀螺仪代码，我们需要编辑 `source\android\Gyroscope.java` 文件。首先，我们需要引用我们将要使用的
    Java 类；因此，将文件顶部的导入声明列表更改为如下所示：
- en: '[PRE1]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first two imports allow us access to some helper functions that provide
    access to things such as the application's main `Activity` class (all applications
    in Android need to be derived from this base class). We'll need this to access
    some system resources.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个导入允许我们访问一些辅助函数，这些函数提供了对诸如应用程序的主要 `Activity` 类（所有 Android 应用程序都需要从这个基类派生）等事物的访问。我们需要这个来访问一些系统资源。
- en: The remaining imports are for the parts of the Android SDK that we will need
    to use to access the gyroscope data.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的导入是为了使用Android SDK的某些部分，我们将使用它们来访问陀螺仪数据。
- en: 'The EDK system has generated a Java class called `Gyroscope` that contains
    stubs for all the methods we need to implement. We will need to alter the class
    definition slightly, though, as we need to implement some methods that will receive
    gyroscope updates. Change the class definition as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: EDK系统已生成一个名为`Gyroscope`的Java类，其中包含我们需要实现的所有方法的占位符。不过，我们需要稍微修改类定义，因为我们需要实现一些将接收陀螺仪更新的方法。按如下方式更改类定义：
- en: '[PRE2]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`SensorEventListener` is a Java interface that our class must implement in
    order to receive sensor events (in our case, gyroscope data).'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`SensorEventListener`是一个Java接口，我们的类必须实现它以接收传感器事件（在我们的案例中，是陀螺仪数据）。'
- en: 'We''ll also add some member variables for caching the gyroscope values and
    a flag that we''ll use to handle the fact that some Android devices return gyroscope
    values in degrees per second rather than radians per second. Add the following
    code to the bottom of the class definition:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将添加一些成员变量来缓存陀螺仪值，以及一个标志，我们将用它来处理某些Android设备返回每秒度数而不是每秒弧度值的事实。将以下代码添加到类定义的底部：
- en: '[PRE3]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Before we start implementing the EDK itself, we''ll add a couple of private
    helper functions to allow us to access the Android `SensorManager` and gyroscope
    `Sensor` instances that will allow us to retrieve the current gyroscope data.
    Add the following two methods at the beginning of the class definition:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始实现EDK本身之前，我们将添加几个私有辅助函数，以便我们可以访问Android的`SensorManager`和陀螺仪`Sensor`实例，这将允许我们检索当前的陀螺仪数据。在类定义的开始处添加以下两个方法：
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `GetSensorManager` method accesses the global `SensorManager` instance by
    using the main `Context` class of the Marmalade application. We do this using
    Marmalade's `LoaderActivity` class that contains a member variable that is a reference
    to the main Android SDK `Activity` class instance. This reference can then be
    cast into a reference to a `Context` instance, since `Activity` derives from `Context`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetSensorManager`方法通过使用Marmalade应用程序的主`Context`类来访问全局`SensorManager`实例。我们使用Marmalade的`LoaderActivity`类来完成此操作，该类包含一个成员变量，它是主Android
    SDK `Activity`类实例的引用。然后，由于`Activity`类继承自`Context`，这个引用可以被转换为`Context`实例的引用。'
- en: Once we have the `Context` reference, we use it to obtain a reference to the
    Android `SensorManager` class that is responsible for controlling input devices,
    including the gyroscope. If no reference is available, a `null` reference will
    be returned.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了`Context`引用，我们就用它来获取负责控制输入设备（包括陀螺仪）的Android `SensorManager`类的引用。如果没有可用的引用，将返回一个`null`引用。
- en: The `GetGyroscopeSensor` method lets us check for the presence of a gyroscope
    by requesting the `SensorManager` class for the default gyroscope handler. If
    a suitable handler is not found (that is, a return value of `null`), there is
    no gyroscope hardware available on this device.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetGyroscopeSensor`方法允许我们通过请求`SensorManager`类的默认陀螺仪处理程序来检查是否存在陀螺仪。如果没有找到合适的处理程序（即返回值为`null`），则表示此设备上没有陀螺仪硬件。'
- en: 'Now we can start implementing the API by looking at the `GyroscopeSupported`
    method. This function needs to return `true` only if the device has gyroscope
    hardware. We can do this as follows:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过查看`GyroscopeSupported`方法来开始实现API。这个函数只有在设备具有陀螺仪硬件时才需要返回`true`。我们可以这样做：
- en: '[PRE5]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'It is now time to implement the function that will allow us to start receiving
    gyroscope data. Find the `GyroscopeStart` method and change it to the following
    code snippet:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候实现一个函数，使我们能够开始接收陀螺仪数据。找到`GyroscopeStart`方法，并将其更改为以下代码片段：
- en: '[PRE6]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this method we start by ensuring that the cached gyroscope values are zero
    and we assume that the device will return values in radians per second. We then
    obtain the gyroscope's `Sensor` class instance using our private `GetGyroscopeSensor`
    method.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们首先确保缓存的陀螺仪值为零，并假设设备将返回每秒弧度值。然后，我们使用我们的私有`GetGyroscopeSensor`方法获取陀螺仪的`Sensor`类实例。
- en: To determine whether this device returns values in degrees or radians, we look
    at the maximum range value of the gyroscope sensor. We set the `mUsesDegrees`
    member variable to `true` if the maximum range is greater than 100, as there does
    not appear to be any more robust way of determining this.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确定这个设备返回的是角度还是弧度值，我们查看陀螺仪传感器的最大范围值。如果最大范围大于100，我们将`mUsesDegrees`成员变量设置为`true`，因为没有更可靠的方法来确定这一点。
- en: We then set our class instance to be a listener for gyroscope data. Periodically,
    the `onSensorChanged` method (which we have yet to implement) will be called with
    new gyroscope values.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们将我们的类实例设置为陀螺仪数据的监听器。定期地，`onSensorChanged` 方法（我们尚未实现）将使用新的陀螺仪值被调用。
- en: 'Next we will implement the `GyroscopeStop` function, which should look like
    this:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将实现 `GyroscopeStop` 函数，它应该看起来像这样：
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Yet again we obtain the `SensorManager` class reference and tell it that we
    no longer want to receive gyroscope data. We also clear the cached gyroscope values
    just in case our code tries to access them while the gyroscope hardware is not
    active.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 再次获取 `SensorManager` 类引用，并告诉它我们不再希望接收陀螺仪数据。我们还清除缓存的陀螺仪值，以防我们的代码在陀螺仪硬件不活跃时尝试访问它们。
- en: 'The next three methods we need to implement are those that return the cached
    gyroscope values. These are easy to implement and should look like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要实现的下一个三个方法是返回缓存的陀螺仪值的方法。这些方法很容易实现，应该看起来像这样：
- en: '[PRE8]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We are now almost finished. All that is left to do is implement the listener
    methods that are part of the `SensorEventListener` interface that we have derived
    the `Gyroscope` class from. Add the following code after the `GyroscopeGetZ` method.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在几乎完成了。剩下要做的就是实现 `SensorEventListener` 接口中我们从中派生 `Gyroscope` 类的监听器方法。在 `GyroscopeGetZ`
    方法之后添加以下代码。
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `onAccuracyChanged` method is left empty since it must be implemented to
    satisfy the interface. The `onSensorChanged` method is important, though, as this
    will receive the new gyroscope input values. We first check to see if the passed
    in `SensorEvent` contains reliable data (the device itself will determine what
    constitutes reliable data); then, we just pull out the new gyroscope values and
    store them in our member variables.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`onAccuracyChanged` 方法留空，因为它必须实现以满足接口。然而，`onSensorChanged` 方法很重要，因为它将接收新的陀螺仪输入值。我们首先检查传入的
    `SensorEvent` 是否包含可靠的数据（设备本身将确定什么构成可靠数据）；然后，我们只需提取新的陀螺仪值并将它们存储在我们的成员变量中。'
- en: If we determined that the device is returning values in degrees per second,
    we do a quick conversion to radians to ensure that our extension always returns
    consistent values.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定设备返回的是每秒度数，我们进行快速转换到弧度，以确保我们的扩展始终返回一致值。
- en: Building an Android extension
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建 Android 扩展
- en: Our Android extension code is now ready to be built and this is even simpler
    than it was with the Windows version. All we have to do is open Windows Explorer
    and navigate to the `Gyroscope` directory, and double-click first the `Gyroscope_android_java.mkb`
    file and then the `Gyroscope_android.mkb` file. The first MKB file will build
    the Java code, while the second will build the C++ code that will be called from
    our project code and that will in turn call the Java code.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在 Android 扩展的代码已经准备好构建，这甚至比 Windows 版本还要简单。我们只需要打开 Windows 资源管理器，导航到 `Gyroscope`
    目录，然后双击第一个 `Gyroscope_android_java.mkb` 文件，然后是 `Gyroscope_android.mkb` 文件。第一个
    MKB 文件将构建 Java 代码，而第二个将构建将被我们的项目代码调用的 C++ 代码，该代码反过来会调用 Java 代码。
- en: Making an iOS extension
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 iOS 扩展
- en: Building an EDK extension for iOS is a little more involved as it requires us
    to have access to the Apple iOS SDK and therefore an Apple Mac.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 构建 iOS 的 EDK 扩展稍微复杂一些，因为它要求我们能够访问 Apple iOS SDK，因此需要一个 Apple Mac。
- en: Installing the required software for iOS development
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安装 iOS 开发所需的软件
- en: 'Firstly, you will need to download the iOS SDK that is bundled together with
    Apple''s XCode development environment. Head over to the following web page, which
    will contain a link to open the Mac App Store where the latest version of XCode
    can be downloaded:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，你需要下载与 Apple 的 XCode 开发环境捆绑在一起的 iOS SDK。访问以下网页，其中将包含一个链接到 Mac App Store，可以下载最新的
    XCode 版本：
- en: '[https://developer.apple.com/xcode/index.php](https://developer.apple.com/xcode/index.php)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/xcode/index.php](https://developer.apple.com/xcode/index.php)'
- en: Once XCode has downloaded and you have installed it, you will then need to download
    the Marmalade SDK in its Mac OS X incarnation. Head over to the Marmalade website
    at the following URL, log in, and download the Mac version of Marmalade.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦下载了 XCode 并安装了它，你接下来需要下载 Marmalade SDK 的 Mac OS X 版本。访问以下 URL 的 Marmalade
    网站，登录并下载 Marmalade 的 Mac 版本。
- en: '[https://www.madewithmarmalade.com/downloads](https://www.madewithmarmalade.com/downloads)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://www.madewithmarmalade.com/downloads](https://www.madewithmarmalade.com/downloads)'
- en: Install the Marmalade SDK to the default location. If you only have a single
    Marmalade license, you will need to use the Marmalade website to release the license
    from your PC so you can use it on the Mac. Refer to [Chapter 1](ch01.html "Chapter 1. Getting
    Started with Marmalade"), *Getting Started with Marmalade*, of this book for more
    information on how to do this.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 将 Marmalade SDK 安装到默认位置。如果您只有一个 Marmalade 许可证，您将需要使用 Marmalade 网站，从您的 PC 释放许可证，以便您可以在
    Mac 上使用它。有关如何操作的更多信息，请参阅本书的 [第 1 章](ch01.html "第 1 章。Marmalade 入门")，*Marmalade
    入门*。
- en: Creating an iOS extension
  id: totrans-130
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建 iOS 扩展
- en: Unsurprisingly, we create the files needed for the iOS Extension in a similar
    manner to the Windows and Android extensions. Just right-click on the `Gyroscope.s4e`
    file and select the menu option **Build iPhone Extension**.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 毫不奇怪，我们以类似的方式创建 iOS 扩展所需的文件，就像 Windows 和 Android 扩展一样。只需右键单击 `Gyroscope.s4e`
    文件，然后选择菜单选项 **构建 iPhone 扩展**。
- en: Just two new files will be created for the iOS extension. These are `Gyroscope_iphone.mkb`,
    which is the MKB file that we will use to build the extension code, and `source\iphone\Gyroscope_platform.mm`,
    which contains the auto-generated stubs for our API functions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 为 iOS 扩展将创建两个新的文件。这些是 `Gyroscope_iphone.mkb`，这是我们用来构建扩展代码的 MKB 文件，以及 `source\iphone\Gyroscope_platform.mm`，其中包含我们
    API 函数的自动生成的存根。
- en: Implementing an iOS extension
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 iOS 扩展
- en: To implement the iOS version of the Gyroscope extension, we need to edit the
    `Gyroscope_platform.mm` file. This file is an Objective-C source file that also
    allows us to use C and C++ code in the same file. The function stubs are all standard
    C-style functions, but we can still make use of Objective-C classes and features
    within them.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现 Gyroscope 扩展的 iOS 版本，我们需要编辑 `Gyroscope_platform.mm` 文件。此文件是一个 Objective-C
    源文件，它还允许我们在同一文件中使用 C 和 C++ 代码。函数存根都是标准的 C 风格函数，但我们可以仍然在它们中使用 Objective-C 类和功能。
- en: 'On iOS, we use an Objective-C class called `CMMotionManager` to gain access
    to gyroscope data, so we first need to let our code know about this class by changing
    the list of included files as follows:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 上，我们使用名为 `CMMotionManager` 的 Objective-C 类来访问陀螺仪数据，因此我们首先需要通过更改包含文件列表来让我们的代码了解这个类：
- en: '[PRE10]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll also declare a global pointer to a `CMMotionManager` instance that we
    will use throughout the rest of our code. Add the following line after the include
    files:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将声明一个指向 `CMMotionManager` 实例的全局指针，我们将在代码的其余部分使用它。在包含文件之后添加以下行：
- en: '[PRE11]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We''ll need to allocate an instance of this class before we can access the
    gyroscope. Luckily, the EDK build script has generated a function called `GyroscopeInit_platform`
    that is automatically called for us when we use the extension in our project,
    so this will make a good place to allocate a new `CMMotionManager` instance, as
    shown in the following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以访问陀螺仪之前，我们需要为这个类分配一个实例。幸运的是，EDK 构建脚本已经生成了一个名为 `GyroscopeInit_platform`
    的函数，当我们在项目中使用扩展时，它会自动为我们调用，因此这是一个分配新的 `CMMotionManager` 实例的好地方，如下面的代码所示：
- en: '[PRE12]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'We also need to free the instance when our application is terminated and once
    again the EDK build script has come to our rescue with the function `GyroscopeTerminate_platform`.
    We need to modify this function so that it stops the gyroscope, if it is still
    active, and then releases the `CMMotionManager` instance. Here''s the completed
    function:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要在应用程序终止时释放该实例，并且 EDK 构建脚本再次通过 `GyroscopeTerminate_platform` 函数来帮助我们。我们需要修改此函数，以便在陀螺仪仍然活跃时停止它，然后释放
    `CMMotionManager` 实例。以下是完成后的函数：
- en: '[PRE13]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The rest of the implementation is actually surprisingly easy, as the `CMMotionManager`
    class works in a very similar manner to the API we have chosen for the extension.
    We''ll start with checking to see if gyroscope hardware is available. The `GyroscopeSupported_platform`
    function looks like this:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的其余部分实际上非常简单，因为 `CMMotionManager` 类的工作方式与我们所选择的扩展 API 非常相似。我们将从检查陀螺仪硬件是否可用开始。`GyroscopeSupported_platform`
    函数看起来如下：
- en: '[PRE14]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Starting and stopping the gyroscope hardware is also little more than calling
    a method of the `CMMotionManager` class. For safety we wrap these calls with further
    checks to make sure the gyroscope is available and not already started or stopped.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 启动和停止陀螺仪硬件实际上也不过是调用 `CMMotionManager` 类的一个方法。为了安全起见，我们用进一步的检查来包装这些调用，以确保陀螺仪可用且尚未启动或停止。
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The only thing left to do is get hold of the current gyroscope input values.
    The `CMMotionManager` class contains a property called `gyroData` of class `CMGyroData`,
    which in turn contains a `CMRotationRate` property called, funnily enough, `rotationRate`
    that holds the current gyroscope data.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的唯一事情就是获取当前的陀螺仪输入值。`CMMotionManager`类包含一个名为`gyroData`的`CMGyroData`类属性，该属性反过来包含一个名为`rotationRate`的`CMRotationRate`属性，它保存当前的陀螺仪数据。
- en: The following code shows the implementation for getting hold of the gyroscope
    data for the x axis. How to obtain the y and z axes values should be fairly obvious
    from this!
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了获取x轴陀螺仪数据的实现方法。从这一点可以看出，如何获取y轴和z轴的值应该是相当明显的！
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: There is one final thing we have to do before we can build the extension, and
    that is to tell the EDK build tools that we need to include the iOS SDK framework
    `CoreMotion`, as this contains the code for the `CMMotionManager` class.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们构建扩展之前，还有最后一件事要做，那就是告诉EDK构建工具我们需要包含iOS SDK框架`CoreMotion`，因为这个框架包含了`CMMotionManager`类的代码。
- en: 'To add a framework to our extensions, we must edit the `Gyroscope.mkf` file.
    Look for the `deployments` section for iOS towards the bottom of the file (Marmalade
    refers to it as the "iphone platform" for legacy reasons) and add the following
    line to it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 要将框架添加到我们的扩展中，我们必须编辑`Gyroscope.mkf`文件。在文件的底部查找iOS的`deployments`部分（由于历史原因，Marmalade将其称为“iphone平台”）并添加以下行到其中：
- en: '[PRE17]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Building an iOS extension
  id: totrans-153
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 构建iOS扩展
- en: So far, all of the previous steps for creating an iOS extension can be done
    equally well on Windows or Mac, but this final step absolutely requires us to
    use a Mac.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，创建iOS扩展的所有先前步骤都可以在Windows或Mac上同样很好地完成，但这个最后一步绝对需要我们使用Mac。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to ensure the Mac has access to the entire `Gyroscope` directory. How
    you achieve this is up to you, but a good way is to share the `Gyroscope` directory
    out on your development Windows PC and then access this share on the Mac. This
    way the code is built on the Mac but all the compiled files are already in the
    correct place on your Windows development machine.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保Mac可以访问整个`Gyroscope`目录。你如何实现这一点取决于你，但一种好方法是共享`Gyroscope`目录到你的开发Windows
    PC上，然后在Mac上访问这个共享。这样代码在Mac上构建，但所有编译文件都已经在你Windows开发机器的正确位置。
- en: 'To build the extension you first need to open a Mac terminal window. Make the
    `Gyroscope` directory the current directory in the terminal window and then enter
    the following command line:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建扩展，首先需要打开Mac终端窗口。将`Gyroscope`目录设置为终端窗口中的当前目录，然后输入以下命令行：
- en: '[PRE18]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will build the extension and our work on the Mac is done. Simple, but kind
    of annoying that we only needed to execute one command, isn't it?
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这将构建扩展，我们在Mac上的工作就完成了。简单，但只执行一个命令就有点烦人，不是吗？
- en: Using the Gyroscope extension
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用陀螺仪扩展
- en: We've now seen how to create and build extension modules for Windows, Android,
    and iOS, but how do we make use of them in our Marmalade projects?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经看到了如何为Windows、Android和iOS创建和构建扩展模块，但我们如何在Marmalade项目中使用它们呢？
- en: It's actually surprisingly easy. All we have to do is reference our extension
    in the project MKB file's `subprojects` section (the easiest way to do this is
    to provide a relative path to the `Gyroscope` directory from the main project
    directory), just as we would with any normal code module, and then include the
    auto-generated `Gyroscope.h` header file so we can call the extension functions.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这出奇地简单。我们只需要在项目MKB文件的`subprojects`部分引用我们的扩展（最简单的方法是从主项目目录提供到`Gyroscope`目录的相对路径），就像我们处理任何正常的代码模块一样，然后包含自动生成的`Gyroscope.h`头文件，这样我们就可以调用扩展函数。
- en: The only thing to bear in mind is that because an extension may not have been
    created for every platform we wish to target, we must make sure the extension
    is available for use before we call any of its functions. This is easily done
    by using the `GyroscopeAvailable` function that is automatically generated for
    us by the EDK build scripts. If this function returns `S3E_TRUE`, the extension
    is available for use. If it returns `S3E_FALSE`, any call to an extension function
    will fire an assert but will otherwise do nothing.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的唯一一点是，由于可能没有为我们要针对的每个平台创建扩展，我们必须确保在调用其任何函数之前扩展可用。这可以通过使用EDK构建脚本为我们自动生成的`GyroscopeAvailable`函数轻松完成。如果这个函数返回`S3E_TRUE`，则扩展可用。如果它返回`S3E_FALSE`，对扩展函数的任何调用将触发断言，但否则不会做任何事情。
- en: There are also no special steps required for building or deploying our application,
    even on Android, where any code written in Java needs to be supplied in a JAR
    file. The deployment tool will automatically add any required extension files
    to the install package without us having to do a thing.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在Android上，构建或部署我们的应用程序也不需要任何特殊步骤，因为在Java中编写的任何代码都需要以JAR文件的形式提供。部署工具将自动将所需的扩展文件添加到安装包中，而无需我们做任何事情。
- en: Example code
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 示例代码
- en: The following sections detail the code samples that accompany this chapter.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 以下部分详细介绍了伴随本章的代码示例。
- en: The Gyroscope project
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 陀螺仪项目
- en: This project contains the complete source code for the Gyroscope extension developed
    throughout the course of this chapter. Compiled versions of the extension have
    also been included so you can build the other example projects for this chapter
    without having to first build the extension itself.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目包含本章开发过程中开发的陀螺仪扩展的完整源代码。还包含了扩展的编译版本，这样您就可以构建本章的其他示例项目，而无需首先构建扩展本身。
- en: The GyroTest project
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GyroTest项目
- en: The GyroTest project is a simple example that makes use of the Gyroscope extension.
    It demonstrates how to include the Gyroscope extension into a project, how to
    check if the extension is available, and then how to call the extension function
    if it is available.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: GyroTest项目是一个简单的示例，它使用了陀螺仪扩展。它演示了如何将陀螺仪扩展包含到项目中，如何检查扩展是否可用，以及如果可用，如何调用扩展函数。
- en: The sample will be displayed on screen whether or not gyroscope support is available.
    If it is, the raw gyroscope values will also be displayed on screen.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 无论陀螺仪支持是否可用，样本都将显示在屏幕上。如果可用，原始陀螺仪值也将显示在屏幕上。
- en: The Skiing project
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 滑雪项目
- en: Our final update to the Skiing project sees it make use of the Gyroscope extension
    developed in this chapter as another possible control method.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对滑雪项目的最终更新使其能够利用本章开发的陀螺仪扩展作为另一种可能的控制方法。
- en: As with the other input methods in the game, a class called `GyroscopeManager`
    has been created, which wraps up the Gyroscope extension. This then keeps all
    use of the extension functions in a single source file, which makes it easier
    to update should we ever change the API of the extension in any way.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 与游戏中其他输入方法一样，创建了一个名为 `GyroscopeManager` 的类，它封装了陀螺仪扩展。这样，所有对扩展函数的使用都集中在一个源文件中，如果将来需要以任何方式更改扩展的API，这将使得更新变得更加容易。
- en: No matter how still the device is, even if left lying on a stable surface, the
    gyroscope values will always have a certain amount of jitter. The `GyroscopeManager`
    class deals with this by maintaining a filtered version of the gyroscope inputs
    that are used to control the skier in the game.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 无论设备多么静止，即使放在稳定的表面上，陀螺仪值总会有一定程度的抖动。`GyroscopeManager` 类通过维护用于控制游戏中滑雪者的陀螺仪输入的过滤版本来处理这个问题。
- en: In every update of the main game loop, a new filtered value for each gyroscope
    axis is calculated by adding a percentage of the difference between the current
    filtered value and the new raw value for each axis to the current filtered value.
    This results in the smaller effects of jitter mostly being ignored without losing
    the larger intentional gyroscope inputs from the player.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在主游戏循环的每次更新中，通过将每个轴的当前过滤值与新原始值之间的差异的百分比加到当前过滤值上，计算每个陀螺仪轴的新过滤值。这导致大部分抖动效果被忽略，同时不会丢失玩家有意输入的较大陀螺仪输入。
- en: Summary
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter we've looked at how to use the Extensions Development Kit to
    extend the functionality of Marmalade. As you can see, it is relatively easy to
    create an extension that can make use of the APIs available on each of the platforms
    currently supported by the EDK.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了如何使用扩展开发工具包来扩展Marmalade的功能。如您所见，创建一个可以利用EDK当前支持的每个平台上的API的扩展相对容易。
- en: The Gyroscope extension is a good example of supporting a hardware feature that
    hasn't yet been exposed in the main Marmalade SDK, but extensions can also come
    in extremely handy if you want to use any third party libraries that may have
    been created directly for a particular platform using its native SDK.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 陀螺仪扩展是支持尚未在主Marmalade SDK中公开的硬件特性的好例子，但如果您想使用可能直接为特定平台使用其本地SDK创建的任何第三方库，扩展也会非常有用。
- en: As this book draws to a close, you should now have a good grasp of the power
    of the Marmalade SDK and will hopefully be jumping at the opportunity of developing
    a game and launching it on a number of extremely popular platforms. Happy coding
    and best of luck writing the next big gaming phenomenon!
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 随着本书的结束，你现在应该已经很好地掌握了Marmalade SDK的强大功能，并且希望你能抓住开发游戏并在多个极受欢迎的平台上线的机会。祝您编码愉快，创作出下一个大型游戏现象的最佳祝福！
