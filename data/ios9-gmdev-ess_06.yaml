- en: Chapter 5. GameplayKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章. GameplayKit
- en: For many years, video game development has relied on the tenets of **object-oriented
    design** (**OOD**). Of the core features in OOD, the concepts of inheritance and
    polymorphism have been the most useful in this branch of software engineering.
    It makes sense to think of entities in our games as homogenous groups of objects;
    objects that we then write rules for in how they interact with each other. For
    example, thanks to inheritance, all objects in our game can be given the class
    name of `GameObject`; they have functions we'll use throughout the game and then
    we can branch them off into child classes, such as `Player` or `Enemy`. We can
    then continue that thought process as we come up with more specific types of entities,
    be they objects such as `Player`, different enemies, **non-player characters**
    (**NPCs**), or whatever makes sense for the game we are making. Calling a function
    on those objects, such as `Shoot()` or `Health()`, could be unique for each child
    of the parent class and thus we make use of polymorphism in OOD.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，视频游戏开发一直依赖于**面向对象设计**（**OOD**）的原则。在OOD的核心特性中，继承和多态的概念在这一分支的软件工程中最为有用。将游戏中的实体视为同质的对象群体是有意义的；然后我们为这些对象编写规则，以确定它们如何相互交互。例如，得益于继承，我们游戏中的所有对象都可以赋予`GameObject`类名；它们拥有我们在整个游戏中都会使用的功能，然后我们可以将它们分支到子类，例如`Player`或`Enemy`。然后，随着我们提出更多具体的实体类型，无论是`Player`、不同的敌人、**非玩家角色**（**NPCs**）还是我们为制作的游戏所需要的内容，我们可以继续这种思考过程。对那些对象调用函数，如`Shoot()`或`Health()`，可能对父类的每个子类都是独特的，因此我们在OOD中利用了多态。
- en: However, as mentioned in the previous chapter, although inheritance-based structuring
    is great for most software applications (including simple games), the unique needs
    and pairings of video game rules and entities cause inheritance-based structuring
    to break one of the rules of OOP. That rule is the reusability of our code. The
    solution to that problem is to separate the game objects and the game's rules
    into what's known as component-based structuring. Building games with this mentality
    can allow us to build unique objects, actions, and rules with the ability to not
    only shift them around throughout our single game project, but also to use them
    in other projects, cutting the overly customized structuring in which building
    a game via inheritance-based structuring can cause.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如前一章所述，尽管基于继承的结构对于大多数软件应用（包括简单的游戏）来说都很不错，但视频游戏规则和实体的独特需求和配对导致基于继承的结构违反了OOP的一个规则。这个规则就是代码的可重用性。解决这个问题的方法是，将游戏对象和游戏规则分开，称为基于组件的结构。以这种心态构建游戏可以让我们构建独特的对象、动作和规则，不仅能够在单个游戏项目中调整它们，还可以在其他项目中使用它们，从而减少通过基于继承的结构构建游戏时可能导致的过度定制化结构。
- en: Apple's solution to this issue is the GameplayKit framework. GameplayKit is
    a completely independent framework that can be used with both SpriteKit or SceneKit
    games, as well as games written in low-level APIs, such as OpenGL and Metal. First
    announced for iOS 9 and Xcode 7 at *WWDC15*, GameplayKit takes the common methodologies
    and concepts used in game development for years and allows us to work on those
    aspects independently of what is being drawn on the screen. This framework doesn't
    handle what's drawn on the screen and is, thus, made specifically for the Model
    portion of MVC.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果针对这个问题提出的解决方案是GameplayKit框架。GameplayKit是一个完全独立的框架，可以与SpriteKit或SceneKit游戏以及使用底层API（如OpenGL和Metal）编写的游戏一起使用。在*WWDC15*上首次宣布支持iOS
    9和Xcode 7，GameplayKit将多年来在游戏开发中使用的常见方法和概念提取出来，使我们能够独立于屏幕上的绘制内容来处理这些方面。这个框架不处理屏幕上的绘制内容，因此它是专门为MVC的模型部分设计的。
- en: There are several game development concepts handled by GameplayKit, which we
    shall review in this chapter. These concepts are **entities and components**,
    **state machines**, **agents**, **goals**, **behaviors**, pathfinding, MinMaxAI,
    random sources, and rule systems.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: GameplayKit处理了几个游戏开发概念，我们将在本章中回顾这些概念。这些概念包括**实体和组件**、**状态机**、**代理**、**目标**、**行为**、路径查找、MinMaxAI、随机源和规则系统。
- en: Entities and components
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实体和组件
- en: We can think of entities as the objects in our game. They can be the player,
    an enemy character, an NPC, level decorations and backgrounds, or even the UI
    used to inform the player of their lives, power, and other stats. The entity is
    thought of as a container of components. Components are behaviors that dictate
    the appearance and actions of an entity. One might ask, "how is this any different
    from objects and functions?" The short answer is that objects and functions in
    inheritance-based design describe more of what our game objects are, while working
    with component-based structuring focuses more on what they do. As we deal with
    the classes and functionality of the GameplayKit framework, we will be able to
    get a better handle on this. In this framework, we'll see that entities and components
    are handled with the `GKEntity` and `GKComponent` classes, respectively.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将实体想象成游戏中的对象。它们可以是玩家、敌人角色、NPC、关卡装饰和背景，甚至是用来告知玩家生命值、力量和其他统计数据用的 UI。实体被视为组件的容器。组件是决定实体外观和行为的特性。有人可能会问，“这与对象和函数有什么不同？”简短的回答是，在基于继承的设计中，对象和函数描述了我们的游戏对象是什么，而基于组件的结构化则更多地关注它们做什么。随着我们处理
    GameplayKit 框架的类和功能，我们将能够更好地理解这一点。在这个框架中，我们将看到实体和组件分别通过 `GKEntity` 和 `GKComponent`
    类来处理。
- en: Note
  id: totrans-7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are still a bit confused about component-based structuring, check back
    in our previous chapter where we went into this in a bit more detail. You can
    also visit the developer page about this design methodology here: [https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对于基于组件的结构化还有一点点困惑，可以回顾我们之前的一章，在那里我们对此进行了更详细的介绍。你还可以访问关于这种设计方法的开发者页面：[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/EntityComponent.html)。
- en: Using GKEntity and GKComponent objects in our games
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的游戏中使用 GKEntity 和 GKComponent 对象
- en: 'Anyone familiar with Java or C# will understand the concept of an *abstract*
    class. The `GKComponent` class is essentially an abstract class. Quoting from
    the speakers at WWDC: think of components as "little black boxes of functionality."
    Objects of the class `GKEntity` are like our generic `GameObject` class mentioned
    before. However, unlike the objects we''ve dealt with before, we typically don''t
    add too much in the way of custom functionality to them (otherwise, we''d be leaning
    towards inheritance-based structuring).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 任何熟悉 Java 或 C# 的人都会理解抽象类的概念。`GKComponent` 类本质上是一个抽象类。引用 WWDC 的演讲者的话：将组件想象成“功能的小黑盒”。`GKEntity`
    类的实例就像我们之前提到的通用 `GameObject` 类。然而，与之前我们处理的对象不同，我们通常不会给它们添加太多的自定义功能（否则，我们就会倾向于基于继承的结构化）。
- en: 'We first create a game object and subclass it as a member of the `GKEntity`
    type. For this example, let''s just call our object class `GameEntity`. Also,
    don''t forget to import the GameplayKit API:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个游戏对象，并将其作为 `GKEntity` 类型的成员进行子类化。在这个例子中，让我们将我们的对象类命名为 `GameEntity`。同时，别忘了导入
    GameplayKit API：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: What this code does is create our `GKEntity` objects; in this case, the tower
    game example's archer character. Next it adds predefined `GKComponent` objects
    via the `addComponent(_:)` function. We also create a `GKComponentSystem` object
    named `moveComponentSystem` that will be used to update only movement type components.
    The archer's own `moveComponent` class is added to this system with `moveComponentSystem.addComponent(_:)`.
    Make a note of how the parameters passed through this object in addition to its
    initialization are class types of the component types denoted by the `.class`
    or `.self` properties, depending on which language we are writing our code in.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码的作用是创建我们的 `GKEntity` 对象；在这个例子中，是塔防游戏示例中的弓箭手角色。接下来，它通过 `addComponent(_:)`
    函数添加预定义的 `GKComponent` 对象。我们还创建了一个名为 `moveComponentSystem` 的 `GKComponentSystem`
    对象，它将只更新移动类型组件。弓箭手自己的 `moveComponent` 类通过 `moveComponentSystem.addComponent(_:)`
    添加到这个系统中。注意，除了初始化之外，通过这个对象传递的参数是组件类型的类类型，这些类型由 `.class` 或 `.self` 属性表示，具体取决于我们用哪种语言编写代码。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of this publication, the `componentForClass()` function might not be fully
    functional for the Swift programming language. So if the Swift implementation
    isn''t working as expected for this and other GameplayKit object initializations,
    the Objective-C version of this code will need to be used and linked to your project
    via an Objective-C–Swift bridging file. This will more than likely be ironed out
    in future updates to Swift as Apple continues to move away from Objective-C as
    the main language of the platform. For more information on how to make this bridging
    file, check out this link: [https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 publication，`componentForClass()` 函数可能对 Swift 编程语言不完全有效。因此，如果 Swift 实现对于这个和其他
    GameplayKit 对象初始化没有按预期工作，您将需要使用 Objective-C 版本的此代码，并通过 Objective-C-Swift 桥接文件将其链接到您的项目中。随着苹果继续将
    Objective-C 从平台的主要语言转变为次要语言，这很可能在未来 Swift 的更新中得到解决。有关如何创建此桥接文件的更多信息，请参阅此链接：[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/BuildingCocoaApps/MixandMatch.html)。
- en: Apple provides us with a project named `Maze` that uses these classes as well
    as some other concepts we'll be going over shortly.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为我们提供了一个名为 `Maze` 的项目，该项目使用了这些类以及其他我们很快就会讨论的概念。
- en: 'Here''s a link to the project that could help to give you an even better idea
    of entities and components:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个链接，可以帮助您更好地了解实体和组件：
- en: '[https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip](https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip](https://developer.apple.com/sample-code/wwdc/2015/downloads/Maze.zip)'
- en: Before we go over more specific code use related to `GKEntity` and `GKComponent`
    objects, we'll look into a game development concept that is best coupled with
    these objects, which is the concept of **state machines**.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论与 `GKEntity` 和 `GKComponent` 对象相关的更具体的代码使用之前，我们将探讨一个与这些对象最佳结合的游戏开发概念，即**状态机**的概念。
- en: State machines
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态机
- en: A video game, more than any other type of application, bases much of its logic
    on whether the game or entities in that game are currently in one of a number
    of different states.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他类型的应用程序相比，视频游戏的大部分逻辑都基于游戏或游戏中的实体当前是否处于多种不同状态之一。
- en: This could be checking whether the game is in the *intro* scene, running in
    the main gameplay mode, the player has died, the player is idle, a boss enemy
    has appeared, the game is over, the stage is over, the boss is low on health,
    and much more.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能包括检查游戏是否处于 *intro* 场景，是否在主游戏模式中运行，玩家是否已死亡，玩家是否空闲，一个Boss敌人是否出现，游戏是否结束，阶段是否结束，Boss血量是否很低，等等。
- en: '![State machines](img/00062.jpeg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![状态机](img/00062.jpeg)'
- en: An example of state machines for either AI or character animations
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 状态机示例，适用于人工智能或角色动画
- en: In the past, it has always been common practice for game developers to write
    their own custom state machine logic from scratch and then use the update/render
    cycle to check on these various states. Typically this would be done in a custom
    class or simply in a custom-made enum object that will shift through various states,
    such as `.GameOver`, `.MainGame`, `.LowHealth`, and so on. These states could
    also describe the status of an individual entity in our game and dictate which
    animation cycle to run. For example, the player could be charging their attack
    and we'd want to use that state of the player to animate the charging animation.
    Objects in the game scene might check back on such states via switch statements
    to make sure that they are not doing any action that wouldn't make sense based
    on the context of the state. It wasn't too long before multiplatform game engines
    made this a part of the workflow, particularly in the animation handlers. These
    objects that let us inform the game and entities in the game of the various states
    are known as state machines. GameplayKit allows us to work with this concept in
    conjunction with its component/entity functionality. The framework provides the
    abstract class `GKState` for us to subclass from for our game's states, and the
    class `GKStateMachine` to utilize for placing these state objects into a designated
    state machine. An object of the type `GKStateMachine` can only be in one state
    at a time, so it gives us a better way to use and reuse these states, as opposed
    to the old boilerplate/switch statement methodology.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，游戏开发者编写自己的自定义状态机逻辑一直是常见的做法，然后使用更新/渲染周期来检查这些各种状态。通常这会在自定义类或简单地在一个自定义的枚举对象中完成，该对象会通过各种状态进行切换，例如
    `.GameOver`、`.MainGame`、`.LowHealth` 等。这些状态也可以描述我们游戏中单个实体的状态，并规定要运行哪个动画周期。例如，玩家可能正在充能攻击，我们希望使用玩家的这种状态来动画化充能动画。游戏场景中的对象可能会通过
    switch 语句检查这些状态，以确保它们不会执行与状态上下文不符的任何动作。不久之后，多平台游戏引擎使这部分成为工作流程的一部分，尤其是在动画处理程序中。这些让我们能够通知游戏及其中的实体的各种状态的对象被称为状态机。GameplayKit
    允许我们与其组件/实体功能一起工作，这个框架为我们提供了一个抽象类 `GKState`，我们可以从它派生我们的游戏状态，以及一个类 `GKStateMachine`，用于将这些状态对象放入指定的状态机中。`GKStateMachine`
    类型的对象一次只能处于一个状态，因此它为我们提供了更好的使用和重用这些状态的方法，而不是旧的样板/switch 语句方法。
- en: The previous diagram is from *WWDC15* and uses an example of what a PacMan-like
    ghost character's, or any other game character's, animation and AI state machines
    would look like. Also note that not all paths could lead to each other. For example,
    the ghost can switch back and forth between chasing and fleeing, but can neither
    be defeated while chasing nor could it respawn unless it was previously in the
    defeated state. These are known as state transitions or edges in a state machine.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图表来自 *WWDC15*，展示了类似 PacMan 的幽灵角色或任何其他游戏角色的动画和 AI 状态机的样子。请注意，并非所有路径都能相互连接。例如，幽灵可以在追逐和逃跑之间来回切换，但在追逐时无法被击败，除非它之前处于被击败状态，否则无法重生。这些被称为状态转换或状态机中的边。
- en: By default, all edges are valid and we override the `isValidNextState(_:)` function
    in our `GKState` objects/components to tell the state machine if we are allowed
    to move between certain states.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，所有边都是有效的，我们在自己的 `GKState` 对象/组件中重写 `isValidNextState(_:)` 函数，以告诉状态机我们是否允许在某些状态之间移动。
- en: 'Here''s how this is done in the DemoBots sample program''s `TaskBotAgentControlledState`
    class. DemoBots is the iOS 9 SpriteKit demo mentioned in [Chapter 3](part0033_split_000.html#VF2I1-d06b23b4a4554b3182353558917969c2
    "Chapter 3. SpriteKit and 2D Game Design"), *SpriteKit and 2D Game Design*:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 DemoBots 示例程序中的 `TaskBotAgentControlledState` 类中，就是这样实现的。DemoBots 是在 [第 3
    章](part0033_split_000.html#VF2I1-d06b23b4a4554b3182353558917969c2 "第 3 章。SpriteKit
    和 2D 游戏设计") 中提到的 iOS 9 SpriteKit 示例，*SpriteKit 和 2D 游戏设计*：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the preceding code, we see the states created from the premade classes of
    `GKState` (chase, flee, defeated, and respawn). The `stateMachine` object, at
    initialization, receives a parameter of an array of `GKState` objects, as shown
    in: `let stateMachine = GKStateMachine(states: [chase,flee,defeated,respawn])`.
    Then, in this example, we start that state machine at the state `chase`. This,
    of course, will be different based on the logic of your own game''s components.
    `GKStateMachine` objects can also return the `currentState()` function; thus,
    we can guide various entities and components in our game based on the current
    pulse of the game''s objects.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '在前面的代码中，我们看到从`GKState`（追逐、逃跑、失败和重生）的预制类中创建的状态。在初始化时，`stateMachine`对象接收一个`GKState`对象数组的参数，如下所示：`let
    stateMachine = GKStateMachine(states: [chase,flee,defeated,respawn])`。然后，在这个例子中，我们从`chase`状态开始那个状态机。当然，这会根据你自己的游戏组件的逻辑而有所不同。`GKStateMachine`对象还可以返回`currentState()`函数；因此，我们可以根据游戏对象的当前脉动来引导我们游戏中的各种实体和组件。'
- en: 'Find out more on `GKState` and `GKStateMachine` in the following full documentation:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下完整文档中了解更多关于`GKState`和`GKStateMachine`的信息：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/)'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKState_Class/)'
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState)'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKStateMachine_Class/index.html#//apple_ref/occ/instm/GKStateMachine/canEnterState)'
- en: Next we go over agents, goals, and behaviors.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍代理、目标和行为。
- en: Agents, goals, and behaviors
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代理、目标和行为
- en: When we make entities in our games, particularly those that are not the player,
    we want them to perform various actions. These actions are dictated by **artificial
    intelligence** (**AI**) that we give them, and are based on various states of
    the game, the player, the environment, or the player themselves. We can have a
    group of enemies follow a certain path, track the player, or automatically move
    smoothly around obstacles using our game's physical world. The framework allows
    us to make our game entities be what's known as **agents**. Agents are entities
    that can have goals and behaviors attached to them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在游戏中创建实体时，尤其是那些不是玩家的实体，我们希望它们执行各种动作。这些动作是由我们赋予它们的**人工智能**（**AI**）决定的，并基于游戏的各种状态、玩家、环境或玩家自身。我们可以让一组敌人沿着特定的路径移动，追踪玩家，或者使用游戏物理世界自动平滑地绕过障碍物。该框架允许我们使我们的游戏实体成为所谓的**代理**。代理是可以附加目标和行为的实体。
- en: Agents in GameplayKit, which utilize the `GKAgent` class, can have `GKComponent`
    objects that automatically set various behaviors and are based on the weight of
    their goals. The weight of a goal is usually a float from `0` to `1`. The higher
    the goal's weight value is compared with other goals, the greater the chance that
    the agent will perform those behaviors. For example, if an enemy character is
    low on health, we'd probably want their `Heal` goal to have a higher goal weight.
    The enemy will behave in a fashion that shows the urgency of that current low
    health situation by healing more often and thus giving the player a more challenging
    and intelligent opponent. In other words, agents, goals, and behaviors are a stackable
    and malleable AI system.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: GameplayKit中的代理，利用`GKAgent`类，可以拥有自动设置各种行为并基于其目标权重`GKComponent`对象。目标权重通常是一个从`0`到`1`的浮点数。与其他目标相比，目标权重值越高，代理执行那些行为的可能性就越大。例如，如果一个敌人角色的健康值很低，我们可能希望他们的`Heal`目标具有更高的目标权重。敌人将通过更频繁地治疗来表现出当前低健康状态的紧迫性，从而给玩家提供一个更具挑战性和智能的对手。换句话说，代理、目标和行为是一个可堆叠和可塑的AI系统。
- en: 'Here''s an overview of this functionality in GameplayKit:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是GameplayKit中此功能的一个概述：
- en: '![Agents, goals, and behaviors](img/00064.jpeg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![代理、目标和行为](img/00064.jpeg)'
- en: A behavior, via the `GKBehavior` class, is made of an array of `GKGoal` objects
    that are each given a certain weight. For example, we could have a `GKBehavior`
    class for an NPC in a racing game named `RacingBehavior`. That behavior would
    be a combination of two goals, such as `FollowPath` and `AvoidAgents`. Together
    those goals would make a character in our game that will automatically move away
    from other NPCs while staying on the current track for the stage we are in.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `GKBehavior` 类，一个行为由一系列 `GKGoal` 对象组成，每个对象都被赋予了一定的权重。例如，我们可以为赛车游戏中的非玩家角色（NPC）创建一个名为
    `RacingBehavior` 的 `GKBehavior` 类。这种行为将是两个目标（如 `FollowPath` 和 `AvoidAgents`）的组合，这些目标将使我们的游戏中的角色在当前阶段保持在当前赛道上，同时自动避开其他
    NPC。
- en: 'Here''s a visual representation of these classes:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这些类的视觉表示：
- en: '![Agents, goals, and behaviors](img/00065.jpeg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![智能体、目标和行为](img/00065.jpeg)'
- en: 'A `GKAgent` object, as we can see in the preceding image, has a number of physics-based
    properties, such as `mass`, `radius`, `maxSpeed`, and more. Like other GameplayKit
    objects, it utilizes the `updateWithDeltaTime()` function to sync with the render/game
    loop updates of either `GKComponentSystem` or `GKEntity`. Are you starting to
    see a pattern here with these objects? In a way, we can also think of a `GKAgent`
    object being similar to a SpriteKit or a SceneKit node since they work on our
    game''s physics. However, whether we made our game with SpriteKit, SceneKit, or
    our own custom render components, such as in OpenGL or Metal, we need to link
    up these classes to what''s displayed on the screen with the special `GKAgentDelegate`
    class. Here''s a diagram of that class and its functions:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，`GKAgent` 对象具有许多基于物理的属性，例如 `mass`（质量）、`radius`（半径）、`maxSpeed`（最大速度）等。与其他
    GameplayKit 对象一样，它使用 `updateWithDeltaTime()` 函数与 `GKComponentSystem` 或 `GKEntity`
    的渲染/游戏循环更新同步。你开始看到这些对象的模式了吗？从某种意义上说，我们也可以将 `GKAgent` 对象视为类似于 SpriteKit 或 SceneKit
    节点，因为它们在我们的游戏物理上工作。然而，无论我们是用 SpriteKit、SceneKit 还是自己的自定义渲染组件（如 OpenGL 或 Metal）制作游戏，我们都需要使用特殊的
    `GKAgentDelegate` 类将这些类链接到屏幕上显示的内容。以下是该类及其功能的图解：
- en: '![Agents, goals, and behaviors](img/00066.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![智能体、目标和行为](img/00066.jpeg)'
- en: 'The `agentWillUpdate()` function is what we use to tell the agent what to do
    just before the game''s `update()` function, and the `agentDidUpdate()` function
    is what we use to tell the agent what to do on screen after the `update()` function.
    This can be, in the case of a `Follow GKGoal` object, having a reference to the
    player''s position on the screen before the update takes place. Here''s the example
    of this from *WWDC15*, but written in Swift as opposed to the Objective-C example
    that was given:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`agentWillUpdate()` 函数是我们用来在游戏 `update()` 函数之前告诉智能体要做什么的，而 `agentDidUpdate()`
    函数则是用来在 `update()` 函数之后告诉智能体在屏幕上要做什么的。在 `Follow GKGoal` 对象的情况下，这可以是在更新发生之前对玩家位置的引用。以下是从
    *WWDC15* 中找到的例子，但与提供的 Objective-C 示例不同，这里使用的是 Swift 编写：'
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In line `(1),` the `toSeparateFromAgents` parameter of `GKGoal` lets us pass
    a reference for the `GKAgent` objects we wish to keep a certain distance from.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `(1)` 中，`GKGoal` 的 `toSeparateFromAgents` 参数允许我们传递一个引用，用于我们希望保持一定距离的 `GKAgent`
    对象。
- en: In line `(2)`, the `behavior.setWeight()` function passes the predetermined
    float `GameplayConfiguration.Flocking.separationWeight` as the weight for this
    very goal. The higher the weight, the more priority is put on that goal.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在行 `(2)` 中，`behavior.setWeight()` 函数将预定的浮点数 `GameplayConfiguration.Flocking.separationWeight`
    作为这个目标的权重传递。权重越高，该目标的重要性就越高。
- en: 'You''ll notice from the full documentation of `GKGoal` linked to later that
    much of the `GKGoal` class deals with the attraction or repulsion agents have
    to each other. Combining different characteristics of this basic functionality
    lets us create unique goals that `GKAgent` parameters get, as shown here: [https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 从稍后链接的 `GKGoal` 的完整文档中，你可以注意到 `GKGoal` 类的大部分内容都处理智能体之间的吸引或排斥。通过组合这种基本功能的不同特性，我们可以创建独特的目标，这些目标由
    `GKAgent` 参数获得，如下所示：[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKGoal_Class/index.html)。
- en: To backtrack a bit, here is a more basic way we can create these objects, as
    shown at the conference both in Objective-C and Swift.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了回顾一下，以下是在会议中展示的创建这些对象的基本方法，无论是使用 Objective-C 还是 Swift。
- en: '[PRE9]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We see in the preceding code that when we create goals we assign agents to them
    that we are either seeking or avoiding. Goals on agents can have a target speed,
    as seen with the `toReachTargetSpeed:` parameter, and these can all be bundled
    up into the current behavior with set weights given to them.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的代码中看到，当我们创建目标时，我们会将代理分配给它们，这些代理要么是寻求的，要么是避免的。代理上的目标可以有目标速度，如`toReachTargetSpeed:`参数所示，所有这些都可以捆绑到当前的行为中，并给予它们相应的权重。
- en: 'Here''s more documentation on `GKGoal`, `GKAgent`, `GKAgentDelegate`, and `GKBehavior`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这是关于`GKGoal`、`GKAgent`、`GKAgentDelegate`和`GKBehavior`的更多文档：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Agent.html)'
- en: One other thing to note is that the obstacles array reference passed here is
    part of the `GKObstacle` class. This class references objects on the scene that
    we tell agents to usually avoid when moving across the screen, and are part of
    our next topic, **Pathfinding**.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一点需要注意的是，这里传递的障碍物数组引用是`GKObstacle`类的一部分。这个类引用了场景中的对象，我们告诉代理在移动时通常要避开这些对象，它们是我们下一个主题**路径查找**的一部分。
- en: Pathfinding
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路径查找
- en: Navigation is an integral part of most games. We could have an overworld scene
    in our game showing the various levels traversed or yet to be visited, with branching
    pathways to each point, or we could have a 3D action platformer with a spell that
    points out a logical path to our next quest or battle location. We can also see
    pathfinding in top-down isometric games. For instance, the player could be fighting
    off a hoard of enemies all locked on the player's location on the screen. Good
    pathfinding AI would not only tell the enemies to move toward their goal, but
    to dynamically avoid any impassable objects in their way and detour to a better
    route automatically . In our talk on agents, goals, and behaviors, we somewhat
    covered that. Behaviors, which `GKAgent` objects adhere to, sync with various
    game physics and thus create smooth AI movements to change with other agents/objects
    in the scene. However, it would be great to also be able to inform these components
    where they can and can't traverse in a scene, and that's where pathfinding comes
    in.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是大多数游戏的一个基本组成部分。在我们的游戏中，可以有一个世界地图场景，显示已经穿越或尚未访问的各种关卡，每个点都有分支路径，或者我们可以有一个3D动作平台游戏，其中有一个法术可以指出通往下一个任务或战斗位置的合理路径。我们还可以在俯视视角的等距游戏中看到路径查找。例如，玩家可能正在屏幕上与一群锁定在玩家位置上的敌人战斗。好的路径查找AI不仅会告诉敌人向目标移动，还会动态避开任何不可逾越的障碍物，并自动绕行到更好的路径。在我们的关于代理、目标和行为的讨论中，我们多少涉及了这一点。遵循`GKAgent`对象的行为，与各种游戏物理同步，从而创建与其他场景中的代理/对象一起平滑的AI移动。然而，如果能通知这些组件在场景中可以和不可以穿越的地方，那就太好了，这就是路径查找的作用所在。
- en: '![Pathfinding](img/00067.jpeg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![路径查找](img/00067.jpeg)'
- en: 'The preceding diagram shows what Pathfinding is and is an in-game visual given
    to us by Apple during the *WWDC15* conference. It can be broken down as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了路径查找是什么，以及苹果公司在*WWDC15*会议上提供的游戏内视觉。
- en: Pathfinding involves nodes with transversal paths to and from those nodes in
    what's known as a **navigation graph**.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路径查找涉及具有穿越路径的节点，这些路径被称为**导航图**中的节点。
- en: These nodes can be single directional or bidirectional and, most importantly,
    there can be a path calculated with this graph that represents the best path a
    `GKAgent` can take.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些节点可以是单向的或双向的，最重要的是，可以使用这个图计算出一个路径，该路径代表了`GKAgent`可以采取的最佳路径。
- en: The squares shown in the earlier scene represent `GKObstacle` objects that are
    placed in the scene (be it by code or visually in the Xcode editor's tools).
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在前面的场景中显示的方块代表放置在场景中的`GKObstacle`对象（无论是通过代码还是通过Xcode编辑器的工具进行视觉放置）。
- en: 'Here''s the full documentation for the `GKObstacle` class:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`GKObstacle`类的完整文档：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/GameplayKit/Reference/GKObstacle_Class/index.html)'
- en: Like other GameplayKit features, we use various abstract classes to child from
    for setting up the navigation graph and overall Pathfinding functionality; those
    classes are `GKGraph`, `GKGridGraph`, `GKGridGraphNode`, and `GKObstacleGraph`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他 GameplayKit 功能一样，我们使用各种抽象类来子类化以设置导航图和整体路径搜索功能；这些类是 `GKGraph`、`GKGridGraph`、`GKGridGraphNode`
    和 `GKObstacleGraph`。
- en: '![Pathfinding](img/00068.jpeg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![路径搜索](img/00068.jpeg)'
- en: 'It''s not too foreboding when we see the preceding diagram of classes and go
    through them one by one. The main, and most common, class used id the `GKGraph`
    class. This is where we can attach to it one of two different graph specification
    types: `GKGridGraph` or `GKObstacleGraph`. `GKGraph` lets us add and remove nodes,
    connect them, and find the optimal path between nodes. Of the two specification
    types, `GKGridGraph` has a simpler functionality that is meant for easy, 2D-based
    navigation graph creation, whereas `GKObstacleGraph` lets us set up a navigation
    graph using `GKObstacle` objects. Nodes are automatically created around those
    obstacles based on their shape, and these classes do much of the footwork needed
    to calculate the paths our agents need to take from the start to the finish of
    their set path(s). If we want to add even more functionality to our nodes, say
    if we want customized movement based on terrain type in addition to shape, then
    we could use the nodes of `GridGraphNode`.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们看到类的前置图并逐个处理它们时，并不会感到太过令人担忧。最主要的，也是最常用的类是 `GKGraph` 类。这就是我们可以附加两种不同的图规范类型之一的地方：`GKGridGraph`
    或 `GKObstacleGraph`。`GKGraph` 允许我们添加和删除节点，连接它们，并找到节点之间的最优路径。在这两种规范类型中，`GKGridGraph`
    具有更简单的功能，旨在轻松创建基于 2D 的导航图，而 `GKObstacleGraph` 允许我们使用 `GKObstacle` 对象设置导航图。节点会根据它们的形状自动创建在那些障碍物周围，这些类做了许多计算路径的工作，我们的智能体需要从起点到它们设定的路径的终点。如果我们想给节点添加更多功能，比如说如果我们想根据地形类型进行定制化移动，除了形状之外，我们就可以使用
    `GridGraphNode` 的节点。
- en: The `costToNode()` function, for example, can be used to indicate that though
    this path would be the optimal path on a flat, even and similar type plane, it
    would cost more to traverse. For example, if there's quicksand in our game, the
    player could traverse it, so it wouldn't make sense to make an impassable `GKObstacle`
    object over the quicksand. Instead we would say that the path across that terrain
    between the two nodes costs more. This will make our game's navigation smarter
    and will handle such custom parameters.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`costToNode()` 函数可以用来表示，尽管这条路径在平坦、均匀且相似的平面上是最佳路径，但穿越它将花费更多。例如，如果我们的游戏中存在流沙，玩家可以穿越它，因此没有必要在流沙上创建不可逾越的
    `GKObstacle` 对象。相反，我们会说，两个节点之间穿越这种地形的路径成本更高。这将使我们的游戏导航更智能，并能处理这样的自定义参数。
- en: Note
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `costToNode()` function is actually an example of best practice. We can
    choose to not use it, but, if we are not careful, our game's pathfinding AI could
    end up rather unintuitive. This would not only make a poor experience for the
    player, but end up adding more time from debugging faulty AI actions later on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`costToNode()` 函数实际上是一个最佳实践的例子。我们可以选择不使用它，但如果我们不小心，我们的游戏路径搜索 AI 可能会变得相当不直观。这不仅会给玩家带来糟糕的体验，而且最终会在调试错误的
    AI 行为上花费更多时间。'
- en: Let's look at some code samples to get a better understanding of these classes
    and how to work with them. Do note that the code as of *WWDC15* is in Objective-C.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些代码示例，以更好地理解这些类以及如何使用它们。请注意，截至 *WWDC15* 的代码是 Objective-C 编写的。
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The following code sample is how the DemoBots project worked with the navigation
    in Swift, using what's known as a lazy stored property.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了 DemoBots 项目如何使用 Swift 中的导航，使用所谓的懒存属性。
- en: 'More information on the Swift keyword, `lazy`, can be found here:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 Swift 关键字 `lazy` 的信息可以在这里找到：
- en: '[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html](https://developer.apple.com/library/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Properties.html)'
- en: 'Swift example from DemoBots:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 来自 DemoBots 的 Swift 示例：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In short, `lazy` variables are quick array initializations in which their values
    are not known at first and are controlled by outside sources. In the case of DemoBots,
    these are obstacles that are created automatically from the bounds of SpriteKit
    nodes, which is done by the SpriteKit node function `obstaclesFromNodePhysicsBodies()`.
    This example, just shows how much time can be saved when using the provided frameworks.
    In the first example and more so in past game development, much of this logic
    would have to be manually done via terribly complex boilerplate code logic.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，`懒惰变量`是快速数组初始化，它们的值最初是未知的，并由外部来源控制。在DemoBots的情况下，这些是通过SpriteKit节点的边界自动创建的障碍物，这是通过SpriteKit节点函数`obstaclesFromNodePhysicsBodies()`完成的。这个例子仅仅展示了使用提供的框架可以节省多少时间。在第一个例子以及过去的游戏开发中，这部分逻辑大多需要通过极其复杂的样板代码逻辑手动完成。
- en: 'For more information on Pathfinding with GameplayKit, check out the examples
    and documentation found here:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于使用GameplayKit进行路径查找的信息，请查看以下示例和文档：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html)'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Pathfinding.html)'
- en: MinMaxAI
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: MinMaxAI
- en: So far, we've created AI that's great for the components and objects that are
    active in a scene with their movement, behaviors, and navigation, but what about
    AI that can understand the game's rules like the player? A good example of this
    is a game of chess or various other board/tile-like games. It'd be great to control
    how much the computer can make progress in the game with various levels of difficulty
    for the player. We can also want to let the game decide for us what the next best
    move is. Something like this is common in three-match type games, such as **Bejeweled^®**
    or **CandyCrush^®,** in which you are looking at grid and the game gives you a
    hint. This type of logic is where **MinMaxAI** comes in.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的AI非常适合那些在场景中活跃的组件和对象，它们有运动、行为和导航，但关于能够理解游戏规则的AI呢？一个很好的例子是象棋或其他各种类似棋盘/拼图的游戏。控制计算机在游戏中以不同难度级别取得进展的能力将是非常棒的。我们还可以希望让游戏为我们决定下一步的最佳走法。这种类型的东西在类似**宝石迷阵^®**或**糖果传奇^®**的三匹配类型游戏中很常见，在这些游戏中，你看着网格，游戏会给你提示。这种逻辑正是**MinMaxAI**发挥作用的地方。
- en: '![MinMaxAI](img/00069.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![MinMaxAI](img/00069.jpeg)'
- en: MinMaxAI works by taking an inventory of all of the available moves for our
    game and placing them into a decision tree. Based on the parameters we give the
    AI, we can tell it how to choose these decision branches, typically in terms of
    game difficulty. This is done by taking in the players, a list of all their possible
    moves as well as their scores, and plugging them into a `Game Model` protocol
    that then uses MinMaxAl to determine the best move. The Tic-Tac-Toe example from
    *WWDC15* is shown in the preceding diagram. Note how some branches would lead
    to more losses than draws or wins for the computer AI. A harder difficulty level
    would make the computer *player* choose the paths that more likely lead to a win
    for it, or, in the case of those three-match games, give the player a suggestion
    for the next best move.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: MinMaxAI通过列出游戏中所有可能的走法并将它们放入决策树中来工作。根据我们给AI提供的参数，我们可以告诉它如何选择这些决策分支，通常是以游戏难度为标准。这是通过输入玩家、他们所有可能的走法以及他们的分数，并将它们插入到一个`Game
    Model`协议中完成的，然后该协议使用MinMaxAI来确定最佳走法。*WWDC15*中的井字棋示例在前面图中展示。注意，有些分支可能会导致计算机AI的损失多于平局或胜利。更难的游戏难度会使计算机*玩家*选择更有可能带来胜利的路径，或者，在那些三匹配游戏中，为玩家提供下一步最佳走法的建议。
- en: Of course, as one might have guessed, this type of logic is best for turn-based
    or tile-based games. MinMaxAI can work in any game, but that game, or at least
    the implementation of MinMaxAI, will only work if there's a set base of moves
    and future moves for it to take into its `Game Model` protocol. An action platformer,
    unless given some choice of features, wouldn't be able to use MinMaxAI, for example.
    What's great about this functionality in GameplayKit is that it doesn't need to
    know the details of your game's rules; it just needs the ability to look into
    future possible moves.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，正如人们可能已经猜到的，这种逻辑最适合回合制或基于拼图的游戏。MinMaxAI可以在任何游戏中工作，但那个游戏，或者至少MinMaxAI的实现，只有在有一个固定的移动基础和未来移动可以纳入其`Game
    Model`协议的情况下才能工作。例如，一个动作平台游戏除非提供了某些功能选择，否则无法使用MinMaxAI。GameplayKit中这个功能很棒的地方在于，它不需要了解你游戏规则的具体细节；它只需要能够查看未来可能的移动。
- en: '![MinMaxAI](img/00070.jpeg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![MinMaxAI](img/00070.jpeg)'
- en: The class diagram shows the classes and functions used when dealing with MinMaxAI.
    We see `GKGameModel`, which is actually a protocol for a game state. The `GKState`
    objects that adhere to this protocol need to provide a list of players, the active
    player, the player's score, and the player's list of moves, the latter via the
    `gameModelUpdatesForPlayer()` function. We then tell the `GKGameModel` object
    what to do as it moves on to the next game move with the `applyGameModelUpdate()`
    function. `GKGameModelUpdate` is essentially an abstract of a game's move and
    is used by the `GKMinMaxStrategist` class to build a decision tree, which is thus
    applied to `GKGameModel` to change that state in the `setGameModel()` function.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 类图显示了处理MinMaxAI时使用的类和函数。我们看到`GKGameModel`，它实际上是一个游戏状态的协议。遵循此协议的`GKState`对象需要提供一个玩家列表、活动玩家、玩家的得分以及玩家的移动列表，后者通过`gameModelUpdatesForPlayer()`函数实现。然后我们通过`applyGameModelUpdate()`函数告诉`GKGameModel`对象在移动到下一个游戏动作时应该做什么。`GKGameModelUpdate`本质上是对游戏动作的抽象，并由`GKMinMaxStrategist`类用来构建决策树，因此应用于`GKGameModel`以在`setGameModel()`函数中改变状态。
- en: The `GKGameModelPlayer` class is a protocol for a player of the game who makes
    a move, as stated previously, with `GKGameModelUpdate`. The `playerId` property
    is a unique number you can set, which is used to differentiate the players in
    our game's logic and deal with their own set of moves. This allows the flexibility
    to have both a hinting structure for the player (or players in a multiplayer game)
    in addition to also having the computer player have an AI for its own moves. The
    `playerID` property is required to adhere to this protocol as we wouldn't know
    the player we are referencing without it.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`GKGameModelPlayer`类是一个协议，用于表示进行移动的游戏玩家，如前所述，使用`GKGameModelUpdate`。`playerId`属性是一个可以设置的唯一数字，用于在游戏逻辑中区分玩家并处理他们自己的移动集合。这允许玩家（或多人游戏中的玩家）具有提示结构，同时计算机玩家也有自己的AI进行移动。`playerID`属性必须遵循此协议，因为没有它我们就不知道我们引用的是哪个玩家。'
- en: The `GKMinMaxStrategist` class is the actual AI itself that is tied to the `gameModel`
    property we created with the prior protocols. The `maxLookAheadDepth` property
    is how many moves ahead the AI will look, the more the better and then it returns
    the best move via the `bestMoveForPlayer()` function. We can use the `randomMoveForPlayer()`
    function to add a bit of randomness to the next move choices; this could be used
    particularly for the computer's own AI to maybe purposely cause it to make mistakes
    by choosing a less optimal move.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`GKMinMaxStrategist`类是实际与之前协议中创建的`gameModel`属性关联的AI。`maxLookAheadDepth`属性表示AI将查看多少步，越多越好，然后通过`bestMoveForPlayer()`函数返回最佳移动。我们可以使用`randomMoveForPlayer()`函数为下一个移动选择添加一些随机性；这可以特别用于计算机自己的AI，可能通过选择一个不太理想的移动来故意使其出错。'
- en: A quick Objective-C snippet showing how to do this in code is given in the following
    code. Don't worry about the syntax if you are only familiar with the Swift language
    we've provided in this book; just get an idea on the basics for setting up these
    objects.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中提供了一个快速的对象C代码片段，展示了如何通过代码实现这一点。如果你只熟悉我们在这本书中提供的Swift语言，不必担心语法；只需了解设置这些对象的基本知识即可。
- en: '[PRE13]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'This is also, like many of the code snippets in this chapter, taken from the
    *WWDC15* conference. It uses a chess game as an example. The intricate details
    of setting up a chess game model are a bit complex, so simply take note of how
    in this code a `ChessGameModel` object (which is a child of the abstract `GKGameModel`
    class) is first created. Then, we create an object of the `GKMinMaxStrategist`
    class named `minmax`, set its game model, set its `maxLookAheadDepth` property
    to `6`, and pass the game''s move and the current active player to the `minMax`
    object. Finally, we update the game''s model with the `applyGameModelUpdate()`
    function. It''s also done in Objective-C at the time of this publication, but
    check out the `FourInaRow` demo found here: [https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html).'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是本章中许多代码片段的来源，就像*WWDC15*会议上的内容。它以棋局为例。设置棋局模型的详细过程有些复杂，所以只需注意在这个代码中，首先创建了一个`ChessGameModel`对象（它是抽象`GKGameModel`类的子类）。然后，我们创建了一个名为`minmax`的`GKMinMaxStrategist`类对象，设置了它的游戏模型，将其`maxLookAheadDepth`属性设置为`6`，并将游戏移动和当前活动玩家传递给`minMax`对象。最后，我们使用`applyGameModelUpdate()`函数更新了游戏模型。当时，这是在Objective-C中完成的，但请查看这里找到的`FourInaRow`演示：[https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/FourInARow/Introduction/Intro.html)。
- en: This project will let us see a more complete implementation of this AI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目将让我们看到这个AI的更完整实现。
- en: 'For even more on MinMaxAI, check out the following documentation link:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 想要了解更多关于MinMaxAI的信息，请查看以下文档链接：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html).'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/Minmax.html)。'
- en: Next we will talk about adding *controlled* randomness to our games with GameplayKit's
    random sources.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论如何使用GameplayKit的随机源为我们的游戏添加*可控*的随机性。
- en: Random sources
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 随机源
- en: Randomness in games has been a staple of AI, player moves, level design, and
    game *replayability* since the early days of game development. The `rand()` function
    in various programming languages, in addition to a range of numbers to scale that
    randomness, has typically been used to give our applications some less predictable
    outcomes. However, games sometimes need to have what we like to call *controlled*
    randomness. When debugging a game, we don't want to ever run into a problem where
    a shipped product has an untested state. Sometimes, when using past conventions
    of randomness, we can run into a situation where the only time some rare events
    happen may be after a game is out and in the hands of thousands, if not millions,
    of players who add to the testing pool that we didn't have in the developing phase.
    Therefore, we may want to control the distribution of randomness. In a typical
    random selection of outcomes, we get a bell curve of results where the average
    or middle-ranged outcomes will occur more often than fringe outcomes. This is
    fine in some games, but rather undesirable in others. Another bit about the `rand()`
    function is that its randomness can vary based on other factors, such as the system
    it's on, the current date and time, and other uncontrollable factors. What we
    need, then, is platform-independent determinism and customizable distribution.
    With GameplayKit's random sources, we can accomplish that.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发初期，随机性一直是人工智能、玩家移动、关卡设计和游戏*可玩性*的基石。在多种编程语言中的`rand()`函数，以及一系列用于缩放随机性的数字，通常被用来让我们的应用程序产生一些不太可预测的结果。然而，有时游戏需要我们所说的*可控*随机性。在调试游戏时，我们不希望遇到已发布产品存在未测试状态的问题。有时，在采用过去的随机性惯例时，我们可能会遇到一些罕见事件只在游戏发布后，在成千上万的，如果不是数百万的玩家手中发生，这些玩家增加了我们在开发阶段没有的测试池。因此，我们可能想要控制随机性的分布。在典型的随机结果选择中，我们得到一个结果呈钟形曲线，平均或中等范围的结果会比边缘结果更频繁地发生。这在某些游戏中是可以接受的，但在其他游戏中则不太理想。关于`rand()`函数的另一件事是，它的随机性可能会根据其他因素而变化，例如它所在的系统、当前日期和时间以及其他不可控因素。因此，我们需要的是平台无关的确定性和可定制的分布。通过GameplayKit的随机源，我们可以实现这一点。
- en: '![Random sources](img/00071.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![随机源](img/00071.jpeg)'
- en: We see a number of the different classes we can use in the preceding image.
    The base class is `GKRandomSource`, which actually uses the ARC4 type algorithm
    by default (via its `GKARC4RandomSource` subclass). ARC4 is a quick/low overhead
    and has the typical randomness that we use in many instances. It's different from
    the `arc4Random()` C call in which instances of `GKARC4RandomSource` are independent
    from each other. `GKRandomSource` can also become a subclass to either the Linear
    Congruential or the Mersenne Twister algorithms. Their benefits and disadvantages
    are shown in the diagram.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面的图像中看到了我们可以使用的多个不同类。基本类是 `GKRandomSource`，它实际上默认使用ARC4类型算法（通过其 `GKARC4RandomSource`
    子类）。ARC4是一种快速/低开销的算法，具有我们在许多实例中使用的典型随机性。它与 `arc4Random()` C调用不同，其中 `GKARC4RandomSource`
    的实例是相互独立的。`GKRandomSource` 也可以成为线性同余或梅森旋转算法的子类。它们的优缺点在图中显示。
- en: It's not recommended that these objects are used for cryptography, so it's best
    to use other the encryption / hashing frameworks that Apple recommends ([https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html](https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html)).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 不建议将这些对象用于加密，因此最好使用苹果推荐的加密/哈希框架（[https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html](https://developer.apple.com/library/ios/documentation/Security/Conceptual/cryptoservices/GeneralPurposeCrypto/GeneralPurposeCrypto.html))。
- en: The remaining classes give us control of the random number/outcome distribution
    methodologies. The `GKRandDistribution` objects let us use helper methods that,
    for example, give us the ability to create x-sided die pieces in addition to letting
    us set its lowest and highest range values. The `GKGaussianDistribution` and `GKShuffledDistribution`
    classes also let us use those helper functions, but `GKGaussianDistribution` is
    used when we want to have a bell-curve type randomization where the middle values
    happen more often than the fringe values. Its mean and deviation properties give
    us controls on that bell curve and if we maybe want more occurrences of fringe
    values. `GKShuffledDistribution`, as we can tell from its name, is great for creating
    an even and complete range distribution, for shuffling decks of cards, or making
    sure that every value occurs evenly. This class's `uniformDistance` property is
    a float between the values of `0.0` and `1.0`. At `0.0`, all shuffling is completely
    random; at `1.0`, the distribution of all values is even.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余的类为我们提供了控制随机数/结果分布方法的能力。`GKRandDistribution` 对象允许我们使用辅助方法，例如，除了让我们设置其最低和最高范围值外，还能创建x面骰子。`GKGaussianDistribution`
    和 `GKShuffledDistribution` 类也允许我们使用这些辅助函数，但`GKGaussianDistribution` 在我们需要具有中间值比边缘值更频繁出现的钟形曲线类型随机化时使用。其均值和偏差属性为我们提供了对钟形曲线的控制，以及如果我们可能想要更多边缘值出现的情况。`GKShuffledDistribution`，正如其名称所示，非常适合创建均匀且完整的范围分布，用于洗牌或确保每个值均匀出现。此类的
    `uniformDistance` 属性是一个介于 `0.0` 和 `1.0` 之间的浮点数。在 `0.0` 时，所有洗牌都是完全随机的；在 `1.0` 时，所有值的分布都是均匀的。
- en: 'Adding random sources to our games is very simple. Here''s some code examples
    using these classes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中添加随机源非常简单。以下是一些使用这些类的代码示例：
- en: '[PRE14]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: As we can see, these are very quick, simple lines of code that all use the various
    random source classes. Most are simple property calls, so that when we create
    our objects in Swift, as seen in the preceding code, it just needs one or two
    lines of code to utilize these class types and their various randomization functionalities.
    Combining this to the goal weight of, say, a wander or track AI behavior, and
    we get some diverse and moderately controlled randomness for the objects and characters
    in our games.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，这些是非常快速、简单的代码行，所有这些代码都使用了各种随机源类。大多数都是简单的属性调用，因此当我们使用 Swift 创建对象时，如前述代码所示，只需一行或两行代码即可利用这些类类型及其各种随机化功能。结合例如游荡或追踪AI行为的目标权重，我们就可以为游戏中的对象和角色获得一些多样化和适度控制的随机性。
- en: 'To read up more on random sources/randomization in this framework, see the
    documentation link here:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于此框架中的随机源/随机化信息，请参阅此处文档链接：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html)'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RandomSources.html)'
- en: Rule systems
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 规则系统
- en: 'Last, but not least, we come to GameplayKit''s rule systems. This aspect of
    the framework uses what''s known as **fuzzy logic** or approximations, mainly
    in the context of transitions between game states. This isn''t something all too
    new to game development. Anyone familiar with linear interpolation will be right
    at home as this is practically the same concept. Unlike the typical use of linear
    interpolation, which tends to revolve around transitions between physical actions,
    GameplayKit''s rule systems perform these approximate transitions between various
    game states. Think of the objects/entities in our games as nouns, the components
    and actions as verbs, and these rules as the interactions between these verbs
    and nouns. As we''ve seen throughout this chapter, this would very much describe
    game states. So why add an extra layer to this logic? Well, let''s look at this
    example from the GameplayKit announcement. This is where transitions between game
    states and/or entity-component actions could use this fuzzy logic:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们来到了GameplayKit的规则系统。框架的这一部分使用所谓的**模糊逻辑**或近似，主要是在游戏状态之间的转换上下文中。这并不是游戏开发中特别新颖的东西。任何熟悉线性插值的人都会感到非常熟悉，因为这实际上是一个相同的概念。与通常围绕物理动作之间的转换的线性插值不同，GameplayKit的规则系统在各个游戏状态之间执行这些近似转换。想想看，我们游戏中的对象/实体就像名词，组件和动作就像动词，而规则则是这些动词和名词之间的交互。正如我们在本章中看到的，这非常符合游戏状态。那么为什么要在逻辑中添加一个额外的层次呢？好吧，让我们看看GameplayKit公告中的这个例子。这是游戏状态和/或实体-组件动作之间可能使用这种模糊逻辑的地方：
- en: '[PRE15]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This pseudo code could represent a car NPC in our game. Maybe a city building
    game, where there are various car `GKAgent` objects that have this code as part
    of their behavior. This seems sound until we get to values at or near `5`. What
    we might notice in our game are a bunch of NPC cars accelerating and braking in
    a jerky motion. To solve this, we make the transitions between braking and accelerating
    not be so finite, but instead transition in approximation.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这段伪代码可能代表我们游戏中一个NPC汽车。也许是一个城市建造游戏，其中有许多具有此代码作为其行为一部分的`GKAgent`汽车对象。这似乎听起来不错，直到我们接近或达到`5`的值。在我们的游戏中，我们可能会注意到一群NPC汽车以颠簸的方式加速和制动。为了解决这个问题，我们让制动和加速之间的转换不是那么有限，而是以近似的方式进行转换。
- en: '![Rule systems](img/00072.jpeg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![规则系统](img/00072.jpeg)'
- en: 'The preceding image is a better illustration of this, with the original logic
    on the left and fuzzy logic on the right. This creates a smooth transition between
    actions or states where rule systems come into play; here are the classes we use
    to implement this type of logic:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张图更好地说明了这一点，左边的原始逻辑和右边的模糊逻辑。这创造了在规则系统起作用时动作或状态之间的平滑过渡；以下是实现此类逻辑所使用的类：
- en: '![Rule systems](img/00073.jpeg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![规则系统](img/00073.jpeg)'
- en: We use the `GKRuleSystem` and `GKRule` class instances to utilize rule systems.
    `GKRule` represents a specific decision to be made based on an external state,
    and `GKRuleSystem` evaluates a set of rules against state data to determine a
    set of facts. We can assert facts or retract them, and we can grade the *fuzziness*
    factor between these rules.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`GKRuleSystem`和`GKRule`类实例来利用规则系统。`GKRule`代表基于外部状态要作出的一个特定决策，而`GKRuleSystem`则评估一组规则与状态数据，以确定一组事实。我们可以断言事实或撤销它们，并且我们可以对这些规则之间的*模糊性*因素进行评分。
- en: 'Let''s take a look at this in code to get a better feel for it:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过代码来看看，以更好地理解它：
- en: '[PRE16]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: First, the `sys` object of `GKRuleSystem` is created, and we grab the `distance`
    state value and save that to the `distance` variable. We then assert/add a rule
    named `close` that happens if `1.0f - distance / kBrakingDistance`. The next finite
    rule we add is `far`, which is defined as `distance` / `kBrakingDistance`, or
    basically any distance greater than `1 - distance / kBrakingDistance`. We create
    new fuzzy values of `close` and `far`, named `farness` and `closeness`, that are
    based on the `gradeForFact` property of `GKRuleSystem`. Then, from this, we get
    our `fuzzyAcceleration` value from the difference between `farness` and `closeness`
    and apply that acceleration to our car. This is checked during the update render
    cycle automatically and keeps the logic transitions smooth, removing jerky movements
    between the different states.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建 `GKRuleSystem` 的 `sys` 对象，然后我们获取 `distance` 状态值并将其保存到 `distance` 变量中。接着，我们断言/添加一个名为
    `close` 的规则，当 `1.0f - distance / kBrakingDistance` 成立时触发。接下来添加的有限规则是 `far`，定义为
    `distance / kBrakingDistance`，或者基本上是任何大于 `1 - distance / kBrakingDistance` 的距离。我们创建了新的模糊值
    `close` 和 `far`，分别命名为 `farness` 和 `closeness`，这些值基于 `GKRuleSystem` 的 `gradeForFact`
    属性。然后，从这个基础上，我们通过 `farness` 和 `closeness` 之间的差异得到 `fuzzyAcceleration` 值，并将这个加速度应用到我们的汽车上。这个操作在更新渲染周期中自动进行，以保持逻辑转换的平滑性，消除不同状态之间的突然运动。
- en: 'This simple example code from *WWDC15* is in Objective-C, but we can see more
    examples (some in Swift) in the full documentation page as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个简单的示例代码来自 *WWDC15*，使用的是 Objective-C，但我们可以在完整的文档页面中看到更多示例（其中一些是 Swift 编写的），如下所示：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html](https://developer.apple.com/library/prerelease/ios/documentation/General/Conceptual/GameplayKit_Guide/RuleSystems.html)'
- en: We can also see some of this implemented in the demo projects we linked to previously.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在之前链接到的演示项目中看到一些这样的实现。
- en: With these classes, we can create a number of complex rule systems that transition
    in a more fluid fashion.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些类，我们可以创建许多复杂的规则系统，这些系统以更流畅的方式转换。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter has gone into a great deal of this deep and independent game-centric
    framework. We have first reviewed the basic concepts of entities and components,
    and how GameplayKit takes advantage of the component-based structuring. We then
    moved on to a staple of game development, the concept of state machines, and how
    GameplayKit utilizes them. Then, we have reviewed ways by which we can automatically
    control components and entities in our games with agents, goals, and behaviors,
    as well as Pathfinding's navigation graphs that add to this automation. We have
    learned that MinMaxAI lets us hint future moves to the player or give the computer
    a smart way of challenging us in various turn-based games. Finally, we have seen
    how random sources add controllable variety to outcomes in our games, whereas
    Rule systems can keep transitions of various states from being too finite. There's
    much more to GameplayKit than we could show here, so it's highly recommended that
    you read through some of the documentation links provided earlier to get an even
    better feel for what this framework has to offer. In the next chapter, we move
    on to the Metal API as well as some other tricks and tips that aid best in making
    the most out of your game and keeping your games at that all too crucial 60 fps.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了大量的独立游戏中心框架。我们首先回顾了实体和组件的基本概念，以及 GameplayKit 如何利用基于组件的结构。然后，我们转向游戏开发的一个基本概念——状态机，以及
    GameplayKit 如何利用它们。接着，我们回顾了通过代理、目标和行为自动控制游戏中的组件和实体的方法，以及路径查找的导航图，这些图增加了这种自动化的功能。我们了解到
    MinMaxAI 允许我们向玩家暗示未来的移动，或者给计算机提供一种在各种回合制游戏中挑战我们的智能方式。最后，我们看到了如何通过随机源为游戏的结果添加可控制的变化，而规则系统可以防止各种状态转换过于有限。GameplayKit
    的内容远不止于此，所以我们强烈建议您阅读之前提供的部分文档链接，以更好地了解这个框架所能提供的内容。在下一章中，我们将继续探讨 Metal API 以及一些其他技巧和提示，这些技巧和提示有助于您充分利用游戏，并保持游戏在至关重要的
    60 fps。
