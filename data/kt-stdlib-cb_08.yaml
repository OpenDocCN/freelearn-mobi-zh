- en: Best Practices for the Android, JUnit, and JVM UI Frameworks
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android、JUnit 和 JVM UI 框架的最佳实践
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Clean and safe `View` binding with the Android Extensions plugin
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Android Extensions 插件进行干净且安全的 `View` 绑定
- en: Applying coroutines for asynchronous UI programming on Android, JavaFX, and
    Swing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android 上、JavaFX 和 Swing 中应用协程进行异步 UI 编程
- en: Easy class-serialization on Android using the `@Parcelize` annotation
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `@Parcelize` 注解在 Android 上轻松进行类序列化
- en: Implementing a custom property delegate that provides lifecycle-aware values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现提供生命周期感知值的自定义属性代理
- en: Easy operations on `SharedPreferences`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `SharedPreferences` 上进行轻松操作
- en: Less boilerplate `Cursor` data parsing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更少的样板 `Cursor` 数据解析
- en: Mocking dependencies with the Mockito Kotlin library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Mockito Kotlin 库模拟依赖项
- en: Verifying function invocations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证函数调用
- en: Unit tests for Kotlin coroutines
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin 协程的单元测试
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The current chapter is going to address problems specific to the popular frameworks
    that Kotlin uses most often. In general, it is going to focus on Android platform-specific
    aspects and asynchronous UI programming with coroutines both on the Android and
    JVM frameworks, such as JavaFX and Swing. It will also guide you through writing
    effective unit tests for the JVM platform using the JUnit framework ([https://junit.org/junit5/](https://junit.org/junit5/)).
    The recipes related to unit-testing will include also more advanced topics, such
    as mocking dependencies with the `mockito-kotlin` ([https://github.com/nhaarman/mockito-kotlin](https://github.com/nhaarman/mockito-kotlin))
    library, testing asynchronous code based on the coroutines framework, and working
    with assertions provided by the standard library.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当前章节将解决 Kotlin 最常使用的流行框架的特定问题。总的来说，它将侧重于 Android 平台特定的方面，以及在 Android 和 JVM 框架（如
    JavaFX 和 Swing）上的异步 UI 编程，同时也会指导您使用 JUnit 框架（[https://junit.org/junit5/](https://junit.org/junit5/))
    为 JVM 平台编写有效的单元测试。与单元测试相关的菜谱还将包括更高级的主题，例如使用 `mockito-kotlin` ([https://github.com/nhaarman/mockito-kotlin](https://github.com/nhaarman/mockito-kotlin))
    库模拟依赖项、基于协程框架测试异步代码，以及使用标准库提供的断言。
- en: Clean and safe view-binding with the Android Extensions plugin
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Android Extensions 插件进行干净且安全的视图绑定
- en: In this recipe, we are going to explore the view-binding feature provided by
    the Kotlin Android Extensions plugin. It allows us to obtain references to `View` type
    elements declared in the XML layout files in an easy and robust way, without using
    the original `findViewById()` function. We are going to declare a `TextView` element
    in the `Activity` layout and obtain a reference to it in order to display a sample
    text in it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探索 Kotlin Android Extensions 插件提供的视图绑定功能。它允许我们以简单且健壮的方式获取在 XML 布局文件中声明的
    `View` 类型元素的引用，而不使用原始的 `findViewById()` 函数。我们将声明一个 `TextView` 元素在 `Activity` 布局中，并获取其引用以在其中显示示例文本。
- en: Getting ready
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to make use of the Kotlin Android Extensions plugin, we need to enable
    it in the Android project module-level `build.gradle` script by adding the following
    declaration:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Kotlin Android Extensions 插件，我们需要在 Android 项目模块级别的 `build.gradle` 脚本中启用它，通过添加以下声明：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in this book's GitHub
    repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow the Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在本书 GitHub 仓库中找到的 AndroidSamples 项目中检查与 Android 框架相关的菜谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与
    Android 相关的菜谱，您只需在 Android Studio 中创建一个新的项目。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'Create a new Activity in the project:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中创建一个新的 Activity：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Implement the UI layout in the `activity_main.xml` file under the `src/main/res/layout/` directory:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `src/main/res/layout/` 目录下的 `activity_main.xml` 文件中实现 UI 布局：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Set the layout for the `MainActivity` inside the `onCreate()` hook function:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 钩子函数中设置 `MainActivity` 的布局：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Get a reference to the `TextView` declared in the XML layout and display a
    sample text in it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取在 XML 布局中声明的 `TextView` 的引用并在其中显示示例文本：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: How it works...
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'As the result, the `MainActivity` class is going to display a greeting inside `TextView`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`MainActivity` 类将在 `TextView` 中显示问候语：
- en: '![](img/e9734da9-b156-4c59-8934-228b2aca2451.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9734da9-b156-4c59-8934-228b2aca2451.png)'
- en: Under the hood, the Android Extensions plugin has generated extension properties
    for the `MainActivity` class for each of the `View` elements declared in the `activity_main.xml`
    file. The generated properties have the same names as the IDs of their corresponding
    layout elements.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在底层，Android 扩展插件为 `activity_main.xml` 文件中声明的每个 `View` 元素为 `MainActivity` 类生成了扩展属性。生成的属性与它们对应布局元素的
    ID 名称相同。
- en: 'Compared to the standard way of obtaining references to `View` classes using
    the `findViewById(): View` function, the Android Extensions binding mechanism
    is much cleaner and more painless. It is also safe and robust as it does not require
    casting the `View` type to specific subclasses, and it regenerates all the extension
    properties whenever any changes are made to the XML layout files. Also, compared
    to other third-party view-binding libraries, it is much easier to use as it doesn''t
    require any manual property declarations. It just works seamlessly.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '与使用 `findViewById(): View` 函数获取 `View` 类引用的标准方式相比，Android 扩展绑定机制更加简洁和易于忍受。它还非常安全和健壮，因为它不需要将
    `View` 类型强制转换为特定的子类，并且每当 XML 布局文件有任何更改时，它都会重新生成所有扩展属性。此外，与其他第三方视图绑定库相比，它更容易使用，因为它不需要任何手动属性声明。它只需无缝工作。'
- en: There's more...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'By default, the Android Extensions plugin supports the `Activity`, `Fragment`,
    and `View` type containers where you can use the automatic view binding mechanism
    out of the box. However, there is a possibility to use any class as an Android
    Extensions container, by implementing the `LayoutContainer` interface. For example,
    it can be used in the `RecyclerView.ViewHolder` subclasses:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Android 扩展插件支持 `Activity`、`Fragment` 和 `View` 类型容器，在这些容器中你可以直接使用自动视图绑定机制。然而，通过实现
    `LayoutContainer` 接口，你可以使用任何类作为 Android 扩展容器。例如，它可以用在 `RecyclerView.ViewHolder`
    的子类中：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can learn more about Android Extensions applications in the official reference: [https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在官方参考中了解更多关于 Android 扩展应用程序的信息：[https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html)。
- en: Applying coroutines for asynchronous UI programming on Android, JavaFX, and
    Swing
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android、JavaFX 和 Swing 上应用协程进行异步 UI 编程
- en: Most of the JVM-based GUI frameworks have one thing in common—they run a specific
    thread that is responsible for updating the state of the application's UI. In
    this recipe, we're going to learn how to execute tasks asynchronously in the background
    and switch to the UI thread to update the GUI of the app. We're going to create
    a simple counter, which is going to display the incremented integer value every
    second. The mechanism responsible for infinite counter-incrementing should operate
    in the background, however, it should switch to the UI thread context every time
    it needs to perform an update of the UI state.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数基于 JVM 的 GUI 框架有一个共同点——它们运行一个特定的线程，该线程负责更新应用程序 UI 的状态。在这个菜谱中，我们将学习如何在后台异步执行任务，并切换到
    UI 线程以更新应用程序的 GUI。我们将创建一个简单的计数器，它将每秒显示递增的整数值。负责无限计数器递增的机制应在后台运行，但是每当它需要更新 UI 状态时，它应该切换到
    UI 线程上下文。
- en: Getting ready
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The first step to start working with Kotlin Coroutines is to add the core-framework
    dependency to the project:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用 Kotlin 协程的第一步是将核心框架依赖项添加到项目中：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Apart from the Coroutines core dependency, we will need to add one of the framework-specific
    coroutines sub-modules, providing the coroutine-context implementation responsible
    for dispatching the coroutine on the UI thread. You can find the list of coroutines''
    framework sub-modules in the official guide: [https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md).
    In this recipe, we are going to target the Android platform, however, you can
    easily port the sample code to one of the supported frameworks such as, Android,
    Swing, or JavaFx.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 Coroutines 核心依赖项之外，我们还需要添加一个框架特定的协程子模块，提供负责在 UI 线程上调度协程的协程上下文实现。你可以在官方指南中找到协程框架子模块的列表：[https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md](https://github.com/Kotlin/kotlinx.coroutines/blob/master/ui/coroutines-guide-ui.md)。在这个菜谱中，我们将针对
    Android 平台，然而，你可以轻松地将示例代码移植到支持的框架之一，例如 Android、Swing 或 JavaFx。
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project, available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在GitHub仓库中查看与Android框架相关的配方实现和配置，该仓库位于AndroidSamples项目：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与Android相关的配方，你只需要在Android
    Studio中创建一个新的项目。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Add a new Activity subclass:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的Activity子类：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement the UI layout in the `activity_main.xml` file under the `src/main/res/layout/`
    directory:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`src/main/res/layout/`目录下的`activity_main.xml`文件中实现UI布局：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Set the layout for `MainActivity` inside the `onCreate()` hook function:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onCreate()`钩子函数内设置`MainActivity`的布局：
- en: '[PRE9]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Start a new coroutine running in the background, incrementing the counter every
    second and displaying it in the `TextView` obtained from the XML layout:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在后台启动一个新的协程，每秒增加计数器并在从XML布局中获得的`TextView`中显示：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Allow coroutine-cancellation by clicking the **cancel** button:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击**取消**按钮允许协程取消：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The coroutine started in the `MainActivity.onCreate()` function is running an
    infinite `while` loop. Each iteration starts with a one-minute delay and incrementation
    of the counter variable. Next, we are applying the `withContext()` function in
    order to update `TextView` with the new value.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainActivity.onCreate()`函数中启动的协程正在运行一个无限`while`循环。每次迭代都以一分钟延迟和计数器变量的增加开始。接下来，我们使用`withContext()`函数来更新`TextView`的新值。
- en: The `withContext()` function allows us to switch to a new coroutine dispatcher,
    obtained from the context argument, in order to execute a block of code passed
    to it. It doesn't create and start a new coroutine, but it modifies the context
    of the parent coroutine immediately. The new dispatcher is applied only temporarily
    to execute a given block of code. Any further operations executed inside the coroutine
    scope after the `withContext()` function call will be run with the original coroutine
    context.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`withContext()`函数允许我们切换到从上下文参数获得的新协程调度器，以执行传递给它的代码块。它不会创建和启动一个新的协程，而是立即修改父协程的上下文。新调度器仅临时应用于执行给定的代码块。在`withContext()`函数调用之后，在协程作用域内执行的任何进一步操作都将使用原始协程上下文运行。'
- en: We are assigning a `Job` instance returned by the coroutine to the `job` variable.
    Next, we are setting up the listener to the cancel button. Whenever the cancel
    button is clicked, the `cancel()` function is invoked on the coroutine `Job` reference.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将协程返回的`Job`实例分配给`job`变量。接下来，我们设置取消按钮的监听器。每次点击取消按钮时，都会在协程`Job`引用上调用`cancel()`函数。
- en: As the result, our `MainActivity` implementation is going to update the `TextView`
    value every second. Once the cancel button is clicked, the update mechanism is
    stopped immediately.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`MainActivity`实现将每秒更新`TextView`的值。一旦点击取消按钮，更新机制将立即停止。
- en: There's more...
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you're developing an application using different JVM frameworks, in order
    to switch to the UI thread from the background, you can use the `withContext()`
    function with the `JavaFx` or `Swing` constants instead of the Android `UI` context
    constants.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用不同的JVM框架开发应用程序，为了从后台切换到UI线程，你可以使用带有`JavaFx`或`Swing`常量的`withContext()`函数，而不是Android的`UI`上下文常量。
- en: See also
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to explore the basics of the coroutines framework, you should
    take a look at the recipes in [Chapter 7](331a4e70-5675-4383-970c-6f5fc75421cf.xhtml), *Making
    Asynchronous Programming Great Again*
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想探索协程框架的基础知识，你应该查看[第7章](331a4e70-5675-4383-970c-6f5fc75421cf.xhtml)中的配方，*让异步编程再次伟大*。
- en: Easy class serialization on Android using the @Parcelize annotation
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`@Parcelize`注解在Android上轻松实现类序列化
- en: In this recipe, we are going to make use of the `@Parcelize` annotation to simplify
    the implementation of the Android `Parcelable` interface, allowing us to serialize
    objects efficiently. `@Parcelize` is available in the Kotlin Android Extensions
    plugin and provides automatic code-generation for Kotlin classes that implement
    the `Parcelable` interface.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用`@Parcelize`注解来简化Android `Parcelable`接口的实现，使我们能够有效地序列化对象。`@Parcelize`在Kotlin
    Android Extensions插件中可用，并为实现`Parcelable`接口的Kotlin类提供自动代码生成。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to implement the Android instrumented test case in order to verify
    the effect of a class serialization and deserialization in action. To make use
    of the Android KTX library, we need to add it to the project dependencies. In
    our case, we will need it in the `android-test` module. We can add it with the
    following declaration:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现 Android 仪器化测试用例，以验证类序列化和反序列化在实际中的效果。为了使用 Android KTX 库，我们需要将其添加到项目依赖项中。在我们的例子中，我们将在
    `android-test` 模块中使用它。我们可以通过以下声明添加它：
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In order to make use of the Kotlin Android Extensions plugin, we need to enable
    it in the Android project module-level `build.gradle` script by adding the following
    declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Kotlin Android 扩展插件，我们需要在 Android 项目模块级别的 `build.gradle` 脚本中启用它，通过添加以下声明：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the book's GitHub
    repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在书中 GitHub 仓库中找到的 AndroidSamples 项目中检查与 Android 框架相关的食谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与
    Android 相关的食谱，您只需在 Android Studio 中创建一个新的项目。
- en: How to do it...
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Let''s start by creating a sample User class that implements the `Parcelable`
    interface using the `@Parcelize` annotation:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个使用 `@Parcelize` 注解实现 `Parcelable` 接口的示例 `User` 类开始：
- en: '[PRE14]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Verify serialization and deserialization of the `User` class instance by writing
    and reading it from the `Bundle` instance:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过编写和读取 `Bundle` 实例来验证 `User` 类实例的序列化和反序列化：
- en: '[PRE15]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We have started by defining the `User` class, which contains a property of the
    `Address` class. Both `User` and `Address` are decorated with the `@Parcelize`
    annotation. It tells the Android Extensions plugin to generate code for the `Parcelable`
    interface implementation. Inside the `testUserParcelisation()` function, we are
    creating an instance of the `User` class and serializing it using the Android
    `Bundle` mechanism. We are putting the original `User` class instance to the `Bundle`
    under the `"my_user"` key, and later we deserialize its instance by calling `bundle.get("my_user")
    as User`. Finally, we compare the original and deserialized `User` instances using
    the `assertEquals()` function.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了 `User` 类，其中包含 `Address` 类的属性。`User` 和 `Address` 都被 `@Parcelize` 注解装饰。它告诉
    Android 扩展插件生成 `Parcelable` 接口实现的代码。在 `testUserParcelisation()` 函数内部，我们创建了一个 `User`
    类的实例，并使用 Android 的 `Bundle` 机制对其进行序列化。我们将原始的 `User` 类实例放在 `"my_user"` 键下，然后通过调用
    `bundle.get("my_user") as User` 反序列化其实例。最后，我们使用 `assertEquals()` 函数比较原始和反序列化的
    `User` 实例。
- en: '`@Parcelize` handles generating the `Parcelable` implementation for the following
    types:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`@Parcelize` 处理为以下类型生成 `Parcelable` 实现：'
- en: All the primitive types, `String`, `CharSequence`, objects and enums, `Exception`,
    `Size`, `SizeF`, `Bundle`, `IBinder`, `IInterface`, `FileDescriptor`, `SparseArray`, `SparseIntArray`, `SparseLongArray`,
    and `SparseBooleanArray`. It also supports any `Serializable` types (for example,
    `java.util.Date`), as well as `Collection` and `Array` types. It also works with
    nullable types.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 所有原始类型、`String`、`CharSequence`、对象和枚举、`Exception`、`Size`、`SizeF`、`Bundle`、`IBinder`、`IInterface`、`FileDescriptor`、`SparseArray`、`SparseIntArray`、`SparseLongArray`
    和 `SparseBooleanArray`。它还支持任何 `Serializable` 类型（例如，`java.util.Date`），以及 `Collection`
    和 `Array` 类型。它还适用于可空类型。
- en: See also
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: You can learn more about the features dedicated to Android development in the
    Kotlin Android Extensions plugin by studying the official guide: [https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以通过学习官方指南来了解更多关于 Kotlin Android 扩展插件针对 Android 开发的功能：[https://kotlinlang.org/docs/tutorials/android-plugin.html](https://kotlinlang.org/docs/tutorials/android-plugin.html)
- en: Implementing a custom property delegate that provides lifecycle-aware values
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现一个自定义属性委托，提供生命周期感知的值
- en: Often, we need to declare a class property, which should depend on the lifecycle
    state of `Activity` or `Fragment`. In this recipe, we are going to employ both
    the Kotlin `Lazy` delegate and the `Lifecycle` class provided by the Android Architecture
    Components library ([https://developer.android.com/topic/libraries/architecture/](https://developer.android.com/topic/libraries/architecture/)).
    We are going to implement a custom property delegate that will provide values
    in a lazy manner. This means that they are going to be instantiated only on the
    first call. Moreover, we are going to clear their values once `Activity` or `Fragment`
    gets destroyed. This will avoid memory leaks, which can be caused by managing
    properties dependent on the `Context` instance with the standard `Lazy` delegate.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们需要声明一个类属性，该属性应依赖于 `Activity` 或 `Fragment` 的生命周期状态。在这个菜谱中，我们将使用 Kotlin 的
    `Lazy` 代理和 Android 架构组件库提供的 `Lifecycle` 类 ([https://developer.android.com/topic/libraries/architecture/](https://developer.android.com/topic/libraries/architecture/))。我们将实现一个自定义属性代理，它将以懒加载的方式提供值。这意味着它们只会在第一次调用时实例化。此外，一旦
    `Activity` 或 `Fragment` 被销毁，我们将清除它们的值。这将避免由使用标准 `Lazy` 代理管理依赖于 `Context` 实例的属性而导致的内存泄漏。
- en: Getting ready
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: The basic `Lazy` delegate initialized using the `lazy()` function provided by
    the standard library gives the desired possibility of declaring a property of
    a non-null type, which can only be instantiated after a certain lifecycle event.
    For example, we reference an element of a screen layout in a property only after
    the layout was set up inside the `Activity.onCreate()` hook function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用标准库提供的 `lazy()` 函数初始化的基本 `Lazy` 代理提供了声明非空类型属性的能力，该属性只能在某个生命周期事件之后实例化。例如，我们仅在
    `Activity.onCreate()` 钩子函数内部设置布局之后，在属性中引用屏幕布局的元素。
- en: However, such an implementation using `Lazy` will cause a memory leak if the
    property holds a reference to the `Activity` instance internally, as it will not
    allow it to be deleted by a garbage collector. The reason for this is that the
    lazy delegate is caching the instance it's holding. We are going to implement
    our own property delegate, called `LifeCycleAwareLazy`, which will both extend
    the `Lazy` interface and clear the value it's holding when the activity is about
    to be destroyed.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果属性内部持有 `Activity` 实例的引用，则使用 `Lazy` 实现的这种实现将导致内存泄漏，因为它不允许垃圾收集器删除它。这是因为懒代理正在缓存它所持有的实例。我们将实现自己的属性代理，称为
    `LifeCycleAwareLazy`，它将扩展 `Lazy` 接口，并在活动即将被销毁时清除它所持有的值。
- en: 'We are going to use the `Lifecycle` library module available with the Android
    Architecture Components provided by Google. We need to add it to the project dependencies
    in the module-level `build.gradle` script:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用由 Google 提供的 Android 架构组件中的 `Lifecycle` 库模块。我们需要将其添加到模块级别的 `build.gradle`
    脚本中的项目依赖项：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Declare the `LifecycleAwareLazy` class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `LifecycleAwareLazy` 类：
- en: '[PRE17]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Register an observer to the given `Lifecycle` instance inside the `init` block:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `init` 块内注册观察者到给定的 `Lifecycle` 实例：
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Implement an internal field that represents the current value stored by the
    delegate:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个表示代理当前存储值的内部字段：
- en: '[PRE19]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Implement the `value` property and the `isInitialized()` function required
    by the `Lazy` interface:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `Lazy` 接口所需的 `value` 属性和 `isInitialized()` 函数：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Implement the `GenericLifecycleObserver` interface:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `GenericLifecycleObserver` 接口：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: How it works...
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `LifecycleAwareLazy` class we have implemented can be seen as an extended
    version of the standard `Lazy` delegate implementation. It observes events emitted
    by the `Lifecycle` instance passed to it in the constructor and handles the value
    accordingly. Internally, it contains the private `_value: Any?` mutable property
    set initially to the `UNINITIALIZED_VALUE` object, which represents an empty state.
    The `_value` property reflects the current state of the delegated property, which
    can be initialized or uninitialized. The `LifecycleAwareLazy` class exposes also
    the immutable `value` property, which is responsible for returning a final value
    of the delegated property. Not it is marked with the `@get:Synchronized` annotation
    which informs the compiler to generate thread-safe getter function for this property.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '我们实现的`LifecycleAwareLazy`类可以看作是标准`Lazy`代理实现的扩展版本。它观察由构造函数传递给它的`Lifecycle`实例发出的事件，并相应地处理值。内部，它包含一个私有可变属性`_value:
    Any?`，初始设置为`UNINITIALIZED_VALUE`对象，表示空状态。`_value`属性反映了委托属性的当前状态，可以是已初始化或未初始化。`LifecycleAwareLazy`类还公开了一个不可变的`value`属性，该属性负责返回委托属性的最终值。注意，它被标记为`@get:Synchronized`注解，这会通知编译器为这个属性生成线程安全的获取器函数。'
- en: Inside the `value` property getter, the current value of the `_value` property
    is checked. Whenever it is equal to `UNINITIALIZED_VALUE`, first it gets reassigned
    to the result of the `initialiser` function passed in the constructor and then
    it is returned as the value of the delegated property.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在`value`属性获取器内部，检查`_value`属性当前的值。每当它等于`UNINITIALIZED_VALUE`时，首先将其重新分配为构造函数中传递的`initialiser`函数的结果，然后作为委托属性的值返回。
- en: '`Lifecycle` is a class that holds the information about the current lifecycle
    state of an associated component (such as an activity or a fragment). It allows
    other objects to observe this state by subscribing to the state-change events
    by passing a callback to the `Lifecycle.addObserver()` function. You can also
    obtain a current state by accessing the `Lifecycle.currentState` property.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Lifecycle`是一个包含关联组件（如活动或片段）当前生命周期状态的类。它允许其他对象通过订阅状态更改事件来观察此状态，通过将回调传递给`Lifecycle.addObserver()`函数。你也可以通过访问`Lifecycle.currentState`属性来获取当前状态。'
- en: Inside the `init` block, we are subscribing to the state updates of the `Lifecycle`
    object passed as the `LifecycleAwareLazy` constructor parameter. We are passing
    the `LifecycleAwareLazy` instance using the `GenericLifecycleObserver` implementation
    to the `lifecycle.addObserver(this)` function.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`块中，我们正在订阅通过`LifecycleAwareLazy`构造函数参数传递的`Lifecycle`对象的州更新。我们通过使用`GenericLifecycleObserver`实现将`LifecycleAwareLazy`实例传递给`lifecycle.addObserver(this)`函数。
- en: We implement the `GenericLifeObserver` interface by overriding the `onStateChanged()`
    function inside the `LifecycleAwareLazy` class. As you can see, we are updating
    the `_value` mutable property to the `UNINITIALIZED_VALUE` object whenever the
    `Lifecycle.Event.ON_STOP` event is emitted, meaning that the activity is about
    to be destroyed. This way, we can be sure that the `_value` property won't block
    the activity or fragment from being garbage-collected, even if it holds a reference
    to an activity `Context` instance directly or indirectly. This is a huge win compared
    to the standard lazy delegate, which can lead to potential memory leaks.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在`LifecycleAwareLazy`类内部覆盖`onStateChanged()`函数来实现`GenericLifeObserver`接口。正如你所看到的，每当`Lifecycle.Event.ON_STOP`事件被触发时，即活动即将被销毁，我们都会将可变属性`_value`更新为`UNINITIALIZED_VALUE`对象。这样，我们可以确保即使`_value`属性直接或间接地持有活动`Context`实例的引用，它也不会阻止活动或片段被垃圾回收。与标准的懒加载代理相比，这是一个巨大的优势，因为标准的懒加载代理可能导致潜在的内存泄漏。
- en: See also
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to get familiar with the basics of the property-delegation pattern,
    take a look at the *Implementing delegated class properties *recipe from [Chapter
    5](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml), *Tasteful Design Patterns Adopting
    Kotlin Concepts*
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要熟悉属性委托模式的基础知识，请查看[第5章](6d4b1b39-8b80-46aa-af17-be9d3ed2c3cd.xhtml)中的*实现委托类属性*配方，*采用Kotlin概念的优雅设计模式*。
- en: Easy operations on SharedPreferences
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在SharedPreferences上的简单操作
- en: In this recipe, we will make use of the Android KTX library developed by Google,
    providing a set of useful extensions and utilities dedicated to Android app-development.
    We are going to apply extension functions that allow us to operate on the `SharedPreferences`
    class in a clean and robust way.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用由 Google 开发的 Android KTX 库，它提供了一套针对 Android 应用开发的实用扩展和工具。我们将应用扩展函数，允许我们以干净和健壮的方式操作
    `SharedPreferences` 类。
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'In order to make use of the Android KTX library, we need to add it to the project
    dependencies. In our case, we will need it in the `android-test` module. We can
    add it with the following declaration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Android KTX 库，我们需要将其添加到项目的依赖项中。在我们的例子中，我们将在 `android-test` 模块中使用它。我们可以通过以下声明来添加它：
- en: '[PRE22]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We are going to implement the Android instrumented test case in order to verify
    the effects of the operations we'll perform on `SharedPreferences`. You can examine
    the implementation and configuration of recipes related to the Android framework
    in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现 Android 仪器测试用例，以验证我们对 `SharedPreferences` 执行的操作的效果。你可以在 GitHub 仓库中找到的
    AndroidSamples 项目中检查与 Android 框架相关的菜谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与
    Android 相关的菜谱，你只需要在 Android Studio 中创建一个新的项目。
- en: How to do it...
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a function that returns the `SharedPreferences` instance:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个返回 `SharedPreferences` 实例的函数：
- en: '[PRE23]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Save a sample string to the `SharedPreferences` instance:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个示例字符串保存到 `SharedPreferences` 实例中：
- en: '[PRE24]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Verify whether the string was successfully saved:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证字符串是否已成功保存：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: How it works...
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are using the `edit()` extension function provided by the KTX library for
    the `SharedPreferences` class. It takes the lambda block, including the operations
    we want to perform on the `SharedPreferences.Editor` instance, and automatically
    invokes the `SharedPreferences.Editor.apply()` function to submit the transaction.
    The lambda block passed to the `edit()` function implements the type, `SharedPreferences.Editor.()
    -> Unit`, which allows us to access an instance of `Editor` through the implicit
    `this` modifier.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 KTX 库为 `SharedPreferences` 类提供的 `edit()` 扩展函数。它接受一个 lambda 块，包括我们想要在
    `SharedPreferences.Editor` 实例上执行的操作，并自动调用 `SharedPreferences.Editor.apply()` 函数来提交事务。传递给
    `edit()` 函数的 lambda 块实现了类型 `SharedPreferences.Editor.() -> Unit`，这允许我们通过隐式的 `this`
    修饰符访问 `Editor` 实例。
- en: If you'd like to submit operations applied to the `Editor` using the blocking
    `commit()` instead of the asynchronous `apply()` function, you should pass an
    additional `commit = true` parameter to the `edit()` function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望使用阻塞的 `commit()` 方法而不是异步的 `apply()` 函数来提交对 `Editor` 的操作，你应该将额外的 `commit
    = true` 参数传递给 `edit()` 函数。
- en: See also
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: If you'd like to get familiar with more features offered by the Android KTX
    library, take a look at the library's official guide: [https://developer.android.com/kotlin/ktx](https://developer.android.com/kotlin/ktx)
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你想要熟悉 Android KTX 库提供的更多功能，请查看库的官方指南：[https://developer.android.com/kotlin/ktx](https://developer.android.com/kotlin/ktx)
- en: Less boilerplate Cursor data parsing
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更少的样板 `Cursor` 数据解析
- en: In this recipe, we are going to learn how to work with the Android `Cursor`
    type in a more effective and easy way.  We are going to create an extension function
    for the `Cursor` type, allowing us to query it in a clean way. We will also implement
    a practical example showing how to access the system-content resolver in order
    to fetch contacts stored on the device and transform `Cursor` into a list of strings
    representing the contacts' names.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何以更有效和简单的方式在 Android 中使用 `Cursor` 类型。我们将为 `Cursor` 类型创建一个扩展函数，允许我们以干净的方式查询它。我们还将实现一个实际示例，展示如何访问系统内容解析器以获取设备上存储的联系人，并将
    `Cursor` 转换为表示联系人名称的字符串列表。
- en: Getting ready
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You can examine the implementation and configuration of the recipes related
    to the Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 GitHub 仓库中找到的 AndroidSamples 项目中检查与 Android 框架相关的菜谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与
    Android 相关的菜谱，你只需要在 Android Studio 中创建一个新的项目。
- en: How to do it...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Implement an extension function that allows us to fetch the values of a requested
    column name from `Cursor`:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个扩展函数，允许我们从 `Cursor` 中获取请求的列名值：
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Obtain the `Cursor` instance that points to the system contacts table:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取指向系统联系人表的 `Cursor` 实例：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Invoke the `use` function on the `cursor` instance and iterate through the
    data inside its scope:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `cursor` 实例上调用 `use` 函数，并在其作用域内迭代数据：
- en: '[PRE28]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We are applying the `use()` extension function provided by the standard library
    to execute a set of operations on the `Cursor` instance. `use()` can be invoked
    on any class that implements the `Closeable` interface. Internally, after executing
    the lambda block passed to it as an argument, `use()` automatically invokes the
    `close()` function on the object it was called on. Thanks to that, we can safely
    perform any operation on the `Cursor` instance and be sure that, even if some
    of them fail or result in throwing an exception, the cursor will eventually be
    closed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用标准库提供的 `use()` 扩展函数来在 `Cursor` 实例上执行一系列操作。`use()` 可以在任何实现了 `Closeable`
    接口类上调用。内部，在执行传递给它的 lambda 块之后，`use()` 会自动调用它所调用的对象的 `close()` 函数。多亏了这一点，我们可以在
    `Cursor` 实例上安全地执行任何操作，并且可以确信，即使其中一些操作失败或抛出异常，光标最终也会被关闭。
- en: Inside the `use()` function's scope, we are iterating the cursor with the `while`
    loop by moving it to the next row in each iteration. For each of the rows, we
    are using the `getString()` extension function to obtain the current contact display
    name from the cursor. It allows us to avoid code duplication by combining `Cursor.getString()`
    and `Cursor.getColumnIndex()` together.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `use()` 函数的作用域内，我们通过 `while` 循环迭代光标，每次迭代都将光标移动到下一行。对于每一行，我们使用 `getString()`
    扩展函数从光标中获取当前的联系人显示名称。这允许我们通过将 `Cursor.getString()` 和 `Cursor.getColumnIndex()`
    结合起来避免代码重复。
- en: Mocking dependencies with the Mockito Kotlin library
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Mockito Kotlin 库模拟依赖项
- en: Often when writing unit test cases for complex classes, we face the problem
    of instantiating a great number of properties that the class we want to test depends
    on. Although this problem could be solved with dependency injection, it is faster,
    more efficient, and more desirable to mock a behavior of a specific object without
    instantiating it at all. In this recipe, we are going to explore how to use the
    Mockito Kotlin library to mock dependencies when writing a unit test for a simple
    registration form that contains an internal dependency whose behavior we are going
    to mock.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 经常在编写复杂类的单元测试用例时，我们会遇到一个问题，即需要实例化大量我们想要测试的类所依赖的属性。虽然这个问题可以通过依赖注入来解决，但模拟特定对象的行为而不实例化它更快、更高效、更受欢迎。在这个菜谱中，我们将探讨如何使用
    Mockito Kotlin 库在编写一个包含内部依赖项的简单注册表单的单元测试时模拟依赖项。
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to use the JUnit library, which provides the core framework for
    running test-case classes. We need to add it our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JUnit 库，它为运行测试用例类提供核心框架。我们需要通过在 `gradle.build` 脚本中声明它来将其添加到我们项目的依赖项列表中：
- en: '[PRE29]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Kotlin Mockito 库，我们可以通过以下声明将其添加到项目的依赖项中：
- en: '[PRE30]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You can examine the implementation and configuration of the recipes related
    to the Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到的AndroidSamples项目中查看与Android框架相关的食谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与Android相关的食谱，您只需在Android
    Studio中创建一个新的项目。
- en: 'In this recipe, we are going to write a unit test for the `RegistrationFormController`
    class, declared as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将为以下声明的`RegistrationFormController`类编写单元测试：
- en: '[PRE31]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '`RegistrationApi` is defined as the following interface:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegistrationApi`接口定义如下：'
- en: '[PRE32]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Since we don't want to implement the `RegistrationApi` interface in order to
    instantiate the `RegistrationFormController` class, we are going to mock it instead
    using the Mockito Kotlin `mock()` function.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不希望为了实例化`RegistrationFormController`类而实现`RegistrationApi`接口，我们将使用Mockito
    Kotlin的`mock()`函数来模拟它。
- en: How to do it...
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Create a new test class:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试类：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create a mocked instance of the `RegistrationApi` interface as the test-class
    property:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`RegistrationApi`接口的模拟实例作为测试类的属性：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a class property of the `RegistrationFormController` type:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`RegistrationFormController`类型的类属性：
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the test method to check whether `checkIfEmailCanBeRegistered()` behaves
    correctly for an invalid email address occurrence:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试方法来检查`checkIfEmailCanBeRegistered()`方法在无效电子邮件地址出现时是否表现正确：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How it works...
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Inside the `` `email shouldn't be registered if it's not valid`() `` test method,
    we are setting up our mocked `RegistrationApi` property to return `true` any time
    its `isEmailAddressAvailable()` function is invoked, regardless of the string
    value passed to it. Next, we are updating the `currentEmailAddress` property of
    the `RegistrationFormController` class with an invalid email address value. The
    test is going to pass because the `isEmailIsValid()` function works correctly
    and returns `false` for a given email address value.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在`email shouldn't be registered if it's not valid`测试方法中，我们设置我们的模拟`RegistrationApi`属性，使其在`isEmailAddressAvailable()`函数被调用时返回`true`，无论传递给它的字符串值是什么。接下来，我们将`RegistrationFormController`类的`currentEmailAddress`属性更新为无效的电子邮件地址值。测试将通过，因为`isEmailIsValid()`函数工作正常，并且对于给定的电子邮件地址值返回`false`。
- en: As you can see, thanks to the mocking, we've avoided implementing the dependency
    of the class we were testing. It's a proper technique that allows us to test the
    specific parts of the business logic while mimicking the desired behavior of the
    dependencies. Mocking can be also useful when we are not able to instantiate the
    dependencies because they are specific to a platform that is not compatible with
    the pure JVM (that is, Android).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，得益于模拟，我们避免了实现被测试类的依赖项。这是一种适当的技巧，它允许我们在模拟依赖项期望行为的同时测试业务逻辑的特定部分。当依赖项是特定于不兼容纯JVM（即Android）平台的平台时，模拟也可能很有用。
- en: See also
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: You can look into the *Verifying function invocations* recipe in order to explore
    how to check whether any specific interactions with the mocked dependency were
    observed
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以查看*验证函数调用*食谱，以了解如何检查是否观察到与模拟依赖项的任何特定交互
- en: Verifying function invocations
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证函数调用
- en: Along with the possibility of simulating the particular behavior of dependencies
    in test methods, mocking allows us to verify whether specific functions of the
    mocked objects were invoked. In this recipe, we are going to write a unit tests
    for a simple registration-form controller. The registration form contains two
    internal dependencies that we are going to mock using the Mockito Kotlin library.
    We are going to test whether the proper functions are being invoked in different
    scenarios.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在测试方法中模拟依赖项的特定行为之外，模拟还允许我们验证模拟对象的具体函数是否被调用。在这个食谱中，我们将为简单的注册表单控制器编写单元测试。注册表单包含两个内部依赖项，我们将使用Mockito
    Kotlin库来模拟它们。我们将测试在不同场景下是否调用了适当的函数。
- en: Getting ready
  id: totrans-170
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to use the JUnit library to provide a core framework for running
    test-case classes. We need to add it to our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用JUnit库来提供一个核心框架，用于运行测试用例类。我们需要通过在`gradle.build`脚本中声明它来将其添加到我们的项目依赖项列表中：
- en: '[PRE37]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用Kotlin Mockito库，我们可以通过以下声明将其添加到项目依赖项中：
- en: '[PRE38]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub仓库中找到的AndroidSamples项目中查看与Android框架相关的菜谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与Android相关的菜谱，您只需在Android
    Studio中创建一个新的项目。
- en: 'In this recipe, we are going to write a unit test for the `RegistrationFormController`
    class, declared as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将编写一个针对`RegistrationFormController`类的单元测试，该类声明如下：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'It contains the `RegistrationApi` property which is defined as the following
    interface:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个`RegistrationApi`属性，该属性定义为以下接口：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'and the `TextView` type property defined as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以及以下方式定义的`TextView`类型属性：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Since we don't want to implement the `RegistrationApi` and `TextView` interface
    in order to instantiate the `RegistrationFormController` class in our test, we
    are going to mock them using the Mockito Kotlin `mock()` function.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想为了在测试中实例化`RegistrationFormController`类而实现`RegistrationApi`和`TextView`接口，我们将使用Mockito
    Kotlin的`mock()`函数来模拟它们。
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Create a new test class:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试类：
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a mocked instance of the `RegistrationApi` interface as the test-class
    property:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`RegistrationApi`接口的模拟实例作为测试类的属性：
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a mocked `TextView` instance:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个模拟的`TextView`实例：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Create the `RegistrationFormController` object as the `MyTest` class property:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RegistrationFormController`对象作为`MyTest`类的属性创建：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add a test method to verify whether the success message is shown if the address
    is available:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试方法以验证如果地址可用，是否会显示成功消息：
- en: '[PRE46]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a test method to verify whether the error message is shown if the address
    is not available:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个测试方法以验证如果地址不可用，是否会显示错误消息：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: How it works...
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Apart from behavior-mocking, Mockito Kotlin provides a reliable way of verifying
    interactions with mocked dependencies that occurred while executing the test method.
    In both the `` `should display success message when email address is available`()
    `` and  `` `should display error message when email address isn''t available`()
    `` functions, we just want to check whether the desired function of the `TextView`
    dependency was invoked. In order to do this, we are invoking the `verify()` function.
    For example, in order to check whether the `showErrorMessage()` function has been
    called on the mocked `view: TextView` dependency, we call the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '除了行为模拟之外，Mockito Kotlin提供了一种可靠的方式来验证在执行测试方法期间与模拟依赖项的交互。在`should display success
    message when email address is available`和`should display error message when email
    address isn''t available`函数中，我们只想检查`TextView`依赖项的期望功能是否被调用。为了做到这一点，我们调用`verify()`函数。例如，为了检查`showErrorMessage()`函数是否在模拟的`view:
    TextView`依赖项上被调用，我们调用以下代码：'
- en: '[PRE48]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If the `showErrorMessage()` is not invoked, the test method will fail and the
    proper log message will be printed to the console.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`showErrorMessage()`没有被调用，测试方法将失败，并且适当的日志消息将被打印到控制台。
- en: Unit tests for Kotlin coroutines
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin协程的单元测试
- en: In this recipe, we are going to explore how to effectively test code that uses
    coroutines internally. We are going to write a unit test for the part of a code
    that runs asynchronously in the background while trying to authorize the given
    user credentials using an external API. We are going to employ the Kotlin Mockito
    library to mock the calls to the external API and the `TextCoroutineContext` class,
    allowing us to test asynchronous code with ease.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何有效地测试使用协程内部代码的代码。我们将编写一个单元测试，用于测试在尝试使用外部API验证给定用户凭据的同时，在后台异步运行的代码部分。我们将使用Kotlin
    Mockito库来模拟对外部API和`TextCoroutineContext`类的调用，从而能够轻松地测试异步代码。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'We are going to use the JUnit library to provide the core framework for running
    test-case classes. We need to add it to our project''s list of project dependencies
    by declaring it in the `gradle.build` script:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 JUnit 库为运行测试用例类提供核心框架。我们需要通过在 `gradle.build` 脚本中声明它来将其添加到我们项目的项目依赖项列表中：
- en: '[PRE49]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In order to make use of the Kotlin Mockito library, we can add it to the project
    dependencies with the following declaration:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用 Kotlin Mockito 库，我们可以通过以下声明将其添加到项目依赖项中：
- en: '[PRE50]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: You can examine the implementation and configuration of recipes related to the
    Android framework in the AndroidSamples project available in the GitHub repository: [https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/). To
    follow Android-related recipes, you just need to create a new project in Android
    Studio.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 GitHub 仓库中找到的 AndroidSamples 项目中检查与 Android 框架相关的食谱的实现和配置：[https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/](https://github.com/PacktPublishing/Kotlin-Standard-Library-Cookbook/)。要遵循与
    Android 相关的食谱，您只需在 Android Studio 中创建一个新的项目。
- en: 'In this recipe, we are going to write a unit test for the `Authenticator` class,
    defined as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将为以下定义的 `Authenticator` 类编写一个单元测试：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The `Api` property is given as the following interface:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Api` 属性如下所示：'
- en: '[PRE52]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Create a new test class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的测试类：
- en: '[PRE53]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add a mocked `Api` type test-class property:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个模拟的 `Api` 类型测试类属性：
- en: '[PRE54]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Instantiate the `Authenticator` class as the class property:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Authenticator` 类实例化为类属性：
- en: '[PRE55]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Implement the test to verify whether the `Api.authorise()` function is called
    at least 10 times in case of consecutive failed authorization attempts:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现测试以验证在连续授权尝试失败的情况下，`Api.authorise()` 函数是否至少被调用 10 次：
- en: '[PRE56]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: How it works...
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, with mocking, we've avoided implementing the `Api` dependency of the `Authenticator` class
    we were writing the test for. In fact, we are not interested in testing real results
    returned by the `Api` implementation. We want to test the mechanism of the `tryToAuthorise()`
    function and verify whether it's going to retry calling the `Api.authorise()`
    function at least 10 times in case of constant authorization failures. This is
    why we have set up the `api` mock to always return an empty string for the `authorise()`
    function result.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过模拟，我们避免了实现我们正在为其编写测试的 `Authenticator` 类的 `Api` 依赖。实际上，我们对测试 `Api` 实现返回的真实结果不感兴趣。我们想要测试
    `tryToAuthorise()` 函数的机制，并验证在连续授权失败的情况下，它是否会至少重试调用 `Api.authorise()` 函数 10 次。这就是为什么我们将
    `api` 模拟设置为对 `authorise()` 函数的结果始终返回空字符串的原因。
- en: As you can imagine, such a test would take a lot of time to complete because,
    internally, the `tryToAuthorise()` function waits for 10 seconds before retrying
    the authorization. In order to avoid the too-long execution time, we need to artificially
    move forward in time by 100 seconds and check whether the `Api.authorise()` function
    was invoked at least 10 times. We are able to do this by scheduling the two coroutines
    started with the `runBlocking()` function, and internally inside the `tryToAuthorise()`
    function, to run on the same instance of `TestCoroutineContext`. Then, to move
    forward in time by 100 seconds, we just call the `advanceTimeBy(100, TimeUnit.SECONDS)`
    function on the `TestCoroutineContext` instance. As a result, our test method
    is going to complete in less than a second.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想象，这样的测试将花费很多时间才能完成，因为内部，`tryToAuthorise()` 函数在重试授权之前会等待 10 秒。为了避免执行时间过长，我们需要通过将时间人为地向前推进
    100 秒来检查 `Api.authorise()` 函数是否至少被调用 10 次。我们能够通过安排使用 `runBlocking()` 函数启动的两个协程，并在
    `tryToAuthorise()` 函数内部，在同一个 `TestCoroutineContext` 实例上运行，来实现这一点。然后，为了将时间向前推进
    100 秒，我们只需在 `TestCoroutineContext` 实例上调用 `advanceTimeBy(100, TimeUnit.SECONDS)`
    函数。结果，我们的测试方法将在不到一秒内完成。
