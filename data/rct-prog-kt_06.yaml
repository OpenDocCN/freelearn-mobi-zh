- en: More on Operators and Error Handling
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多关于操作符和错误处理
- en: In the previous chapter, we learned about operators and how to use them. We
    learned how operators can help us in solving complex problems with ease. We got
    a grip on operators and their types, and we learned basic filtering operators
    and transforming operators in detail. It's time to move on to some interesting
    and advanced things you can do with operators.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了操作符及其使用方法。我们学习了操作符如何帮助我们轻松解决复杂问题。我们掌握了操作符及其类型，并详细学习了基本过滤操作符和转换操作符。现在是时候继续学习一些有趣且高级的操作符用法了。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Combining producers (Observable/Flowable)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合生产者（Observable/Flowable）
- en: Grouping emissions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分组发射
- en: Filtering/suppressing operators
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤/抑制操作符
- en: Error handling operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理操作符
- en: Real-world HTTP client example
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实际的 HTTP 客户端示例
- en: So, what are we waiting for? Let's get started with combining producer (Observable/Flowable)
    instances.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么？让我们开始结合生产者（Observable/Flowable）实例。
- en: Combining producers (Observable/Flowable)
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合生产者（Observable/Flowable）
- en: While developing applications, it's a common situation to combine data from
    multiple sources before using them. One such situation is when you are building
    some offline application following an offline-first approach, and you want to
    combine the resultant data you got from the HTTP call with the data from the local
    database.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，在开始使用之前结合多个来源的数据是一种常见的情况。其中一种情况是当你遵循离线优先的方法构建某些离线应用程序时，你希望将来自 HTTP
    调用的结果数据与来自本地数据库的数据结合。
- en: 'Now, without wasting much time, let''s take a look at the operators that can
    help us combine producers:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再浪费时间，让我们看看可以帮助我们组合生产者的操作符：
- en: '`startWith()`'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`startWith()`'
- en: '`merge()`, `mergeDelayError()`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge()`，`mergeDelayError()`'
- en: '`concat()`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concat()`'
- en: '`zip()`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip()`'
- en: '`combineLatest()`'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`combineLatest()`'
- en: 'Basically, there are a few mechanisms to combine producers (Observables/Flowables).
    They are as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，有一些机制可以组合生产者（Observables/Flowables）。它们如下：
- en: Merging producers
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 合并生产者
- en: Concatenating producers
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接生产者
- en: Ambiguous combination of producers
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生产者组合的歧义
- en: Zipping
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: Combine latest
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合最新
- en: We will discuss all the previously mentioned techniques to combine producers
    in this chapter. However, let's start with an operator that we are already aware
    of.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将讨论之前提到的所有组合生产者的技术。然而，让我们从一个我们已经熟悉的操作符开始。
- en: The startWith operator
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`startWith` 操作符'
- en: 'We got introduced to the `startWith` operator in the previous chapter, but
    there''s still a lot to cover. This operator also lets you combine multiple producers.
    Take a look at the following example:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 `startWith` 操作符，但还有很多内容要介绍。这个操作符还允许你组合多个生产者。看看下面的例子：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We can pass another source `Observable` or an `Iterator` instance to be prepended
    before the source `Observable` that the operator has subscribed to starts emitting.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将另一个源 `Observable` 或 `Iterator` 实例传递给 `startWith` 操作符，在它所订阅的源 `Observable`
    开始发射之前添加。
- en: 'In the preceding program, on comment `(1)`, we used the `startWith` operator
    and passed an `Interator` instance to it. The `startWith` operator internally
    converts the passed `Iterator` instance to an `Observable` instance (it''ll convert
    it to a `Flowable` instance in case you''re using `Flowable`). Here is the signature
    of the `startWith` operator:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，在注释 `(1)` 处，我们使用了 `startWith` 操作符并将其传递了一个 `Iterator` 实例。`startWith`
    操作符内部将传递的 `Iterator` 实例转换为 `Observable` 实例（如果你使用 `Flowable`，它将转换为 `Flowable` 实例）。以下是
    `startWith` 操作符的签名：
- en: '[PRE1]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the preceding signature of the `startWith` operator, we can also see that
    it uses `concatArray` internally, which we will be covering very soon in this
    chapter.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `startWith` 操作符的前一个签名中，我们也可以看到它内部使用了 `concatArray`，我们将在本章中很快介绍这一点。
- en: On comment `(2)`, we used the `startWith` operator with another source `Observable`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(2)` 处，我们使用了 `startWith` 操作符并传递了另一个源 `Observable`。
- en: 'Here is the output of the program:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是程序的输出：
- en: '![](img/7f451284-3231-439c-8882-2f532286a69a.png)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7f451284-3231-439c-8882-2f532286a69a.png)'
- en: As we have got some grip on the `startWith` operator, now let's move forward
    with the `zip` operator. The `zip` operator implements a zipping mechanism to
    combine producers.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经对 `startWith` 操作符有了基本的了解，现在让我们继续学习 `zip` 操作符。`zip` 操作符实现了一种压缩机制来组合生产者。
- en: Zipping emissions – zip operator
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 压缩发射 – `zip` 操作符
- en: 'The `zip` operator is quite interesting. Think of a situation where you''re
    working with multiple `Observable`/`Flowables` and want to perform some kind of
    operation on each subsequent emission of each producer. The `zip` operator enables
    you to perform exactly that. It accumulates emissions of multiple producers to
    create a new emission via the specified function. So, let''s look at a pictorial
    representation to delve deeper:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`操作符非常有趣。想象一下你正在处理多个`Observable`/`Flowables`，并想在每个生产者的每个后续排放上执行某种操作。`zip`操作符允许你正好执行这一点。它通过指定的函数累积多个生产者的排放以创建一个新的排放。所以，让我们通过一个图示来深入了解：'
- en: '![](img/a9bcc79d-99a6-490f-94ce-5f00d05cfb18.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a9bcc79d-99a6-490f-94ce-5f00d05cfb18.jpg)'
- en: As the picture depicts, the `zip` operator accumulates emissions from multiple
    producers into a single emission. It also takes a function to apply on the emissions
    as the `scan` or `reduce` operator, but applies them to emissions from different
    producers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如图片所示，`zip`操作符将多个生产者的排放累积到一个单一的排放中。它还接受一个函数来应用于排放，就像`scan`或`reduce`操作符一样，但它将这些函数应用于来自不同生产者的排放。
- en: For the sake of simplicity, we used two `Observable` in the preceding picture
    and the following example, but the `zip` operator works with up to nine `Observables`/`Flowables`.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，我们在前面的图片和下面的例子中使用了两个`Observable`，但`zip`操作符可以与多达九个`Observables`/`Flowables`一起工作。
- en: 'Consider the following code:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `zip` operator is defined in `companion object` (`static` method in Java)
    of the `Observable` class, thus can be directly accessed by writing `Observable.zip`
    itself. No need to access it through another instance. So, let''s take a look
    at the output before we proceed:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`操作符定义在`Observable`类的`companion object`（Java中的`static`方法）中，因此可以直接通过写入`Observable.zip`本身来访问。不需要通过另一个实例来访问。所以，在我们继续之前，让我们看看输出：'
- en: '![](img/4f81d024-cb15-45c4-95aa-954067938d35.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4f81d024-cb15-45c4-95aa-954067938d35.png)'
- en: 'In order to understand and use the `zip` operator better, you need to keep
    the following points about it in mind:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解和使用`zip`操作符，你需要记住以下关于它的要点：
- en: The `zip` operator works on each emission of the supplied producers. For example,
    if you pass three producers *x*, *y*, and *z* to the `zip` operator, it will accumulate
    the *n^(th)* emission of *x* with the *n^(th)* emission of *y* and *z*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`操作符作用于提供的生产者的每个排放。例如，如果你将三个生产者*x*、*y*和*z*传递给`zip`操作符，它将累积*x*的第*n*个排放与*y*和*z*的第*n*个排放。'
- en: The `zip` operator waits for each of its producers to emit, before applying
    the function to them. For example, if you use `Observable.interval` as one of
    the producers in the `zip` operator, the `zip` operator will wait for each emission
    and will emit the accumulated values at the specified intervals as well.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`操作符在应用函数之前等待每个生产者发射。例如，如果你在`zip`操作符中使用`Observable.interval`作为生产者之一，`zip`操作符将等待每个排放，并将累积的值在指定的间隔内发射。'
- en: If any of the producers notify `onComplete` or `onError` without emitting the
    item it was waiting for, then it'll discard all emissions afterwards, including
    that particular one from other producers as well. For example, if producer *x*
    emits `10` items, producer *y* emits `11` items, and producer *z* emits `8` items,
    the `zip` operator will accumulate the first `8` emissions from all the producers
    and will discard all remaining emissions from producer *x* and *y*.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果任何生产者在未发射它所等待的项目的情况下通知`onComplete`或`onError`，那么它将丢弃之后的所有排放，包括来自其他生产者的那个特定排放。例如，如果生产者*x*发射`10`个项目，生产者*y*发射`11`个项目，生产者*z*发射`8`个项目，`zip`操作符将累积来自所有生产者的前`8`个排放，并将丢弃来自生产者*x*和*y*的所有剩余排放。
- en: The zipWith operator
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`zipWith`操作符'
- en: The instance version (that is, the copy of the function, which should be called
    with an instance rather than static) of the `zip` operator is `zipWith`, which
    can be called from the `Observable` instance itself. The only problem with this
    version is that you can pass only another source `Observable`. If you need to
    work with three or more `Observable` instances, you should rather consider using
    the `zip` operator instead of `zipWith`.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`zip`操作符的实例版本（即函数的副本，应该使用实例而不是静态调用）是`zipWith`，它可以从`Observable`实例本身调用。这个版本唯一的问题是只能传递另一个源`Observable`。如果你需要与三个或更多的`Observable`实例一起工作，你最好考虑使用`zip`操作符而不是`zipWith`。'
- en: 'Here''s an example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个例子：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The output is as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/b6e88bba-25d3-4737-b3ba-390da7fae31b.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b6e88bba-25d3-4737-b3ba-390da7fae31b.png)'
- en: On comment `(1)`, we used the `zipWith` operator on the `Observable` instance,
    `observable1`, and passed another `Observable` instance, `observable2`, to it
    with a lambda to apply to the emissions. From the output, we can tell that the
    `zipWith` operator accumulates the producer it's subscribed to, with the producer
    it is provided with.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(1)`中，我们在`Observable`实例`observable1`上使用了`zipWith`操作符，并将另一个`Observable`实例`observable2`传递给它，使用lambda表达式来应用发射。从输出中，我们可以看出`zipWith`操作符累积了它订阅的生产者以及它提供给生产者的生产者。
- en: The combineLatest operator
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: combineLatest操作符
- en: The `combineLatest` operator works in a similar way like the `zip` operator.
    It accumulates the emissions of the provided producers. The only difference between
    `combineLatest` and `zip` is that the `zip` operator waits for each of its source
    producers to emit, before it starts processing all the emissions to create its
    new one, but the `combineLatest` operator starts as soon as it receives any emit
    from any of its source producers.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest`操作符的工作方式与`zip`操作符类似。它累积提供的生产者的发射。`combineLatest`和`zip`之间的唯一区别是，`zip`操作符等待其每个源生产者发射，然后才开始处理所有发射以创建其新的发射，但`combineLatest`操作符在接收到其源生产者中的任何一个发射后立即开始。'
- en: 'To understand this operator better, we will see an example with both, the `zip`
    and the `combineLatest` operator. Let''s first try the example with the `zip`
    operator, as we gained some grip on it already:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这个操作符，我们将通过`zip`和`combineLatest`操作符的例子来展示。让我们首先尝试使用`zip`操作符的例子，因为我们已经对其有所了解：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The output is as follows. As expected, it accumulates each and every emission
    and prints them:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下。正如预期的那样，它累积了每一个发射并打印出来：
- en: '![](img/608d635c-814e-4199-a81d-cf6e69c67487.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/608d635c-814e-4199-a81d-cf6e69c67487.png)'
- en: In this program, we created `Observable` with a 100 milliseconds interval on
    comment `(1)`. On comment `(2)`, we created another `Observable` with a `250`
    milliseconds interval. In the output, we can see `3` emits, as, after zipping
    them, the total interval becomes `350` milliseconds, and within 1,100 milliseconds
    of delay, there is room for only `3` emits with `350` milliseconds interval in
    between them.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们在注释`(1)`中创建了一个具有100毫秒间隔的`Observable`。在注释`(2)`中，我们创建了一个具有`250`毫秒间隔的另一个`Observable`。在输出中，我们可以看到有`3`个发射，因为，在压缩后，总间隔变为`350`毫秒，在1,100毫秒的延迟内，只有`3`个发射，它们之间有`350`毫秒的间隔。
- en: 'Now, let''s test the same code with `combineLatest`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们用`combineLatest`测试相同的代码：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Here is the output:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '![](img/8fba26bd-b03d-462c-ad06-38bbeb21d92b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8fba26bd-b03d-462c-ad06-38bbeb21d92b.png)'
- en: As the output suggests, the `combineLatest` operator processes and emits the
    value as soon as it gets an emit from any of its source producers by using the
    last emitted value for all other source producers.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`combineLatest`操作符在接收到其源生产者中的任何一个发射后立即处理并发射值，对于所有其他源生产者使用最后一个发射的值。
- en: Now, let's move forward with merging producers, with the help of the `merge`
    operator.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在`merge`操作符的帮助下继续合并生产者。
- en: Merging Observables/Flowables – merge operator
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 合并Observables/Flowables – merge操作符
- en: The zipping operation will let you accumulate emissions, but what if you want
    to subscribe to each emission by all the source producers? Say you have two different
    producers and have the same set of actions to be applied when subscribing to them;
    there's no way to mix imperative programming and reactive programming and repeatedly
    subscribe to both of the producers separately with the same code. It'll also result
    in redundant code. So, what is the solution here? You got it right; merging all
    the emissions of all the source producers together and subscribing to them as
    a whole is the solution.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩操作将允许你累积发射，但如果你想要订阅所有源生产者的每一个发射呢？比如说，你有两个不同的生产者，并且当订阅它们时应用相同的动作集；没有方法可以混合命令式编程和响应式编程，并使用相同的代码分别单独订阅两个生产者。这也会导致代码冗余。那么，这里的解决方案是什么？你答对了；将所有源生产者的发射合并在一起，并作为一个整体来订阅就是解决方案。
- en: 'So, let''s get an example here:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在这里举一个例子：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In this program, on comment `(1)`, we will merge two `observable` and subscribe
    to them as a whole. The output is as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，在注释`(1)`中，我们将合并两个`observable`并作为一个整体来订阅它们。输出如下：
- en: '![](img/df6ceb40-6b39-4978-ac8d-51a2e27e0a61.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![](img/df6ceb40-6b39-4978-ac8d-51a2e27e0a61.jpg)'
- en: As the output shows, the `merge` operator merged two `Observables` and put the
    emissions of both the `Observables` in their order of emission.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`merge`操作符合并了两个`Observables`，并将两个`Observables`的发射按照发射顺序放置。
- en: 'The merging operation, however, doesn''t maintain the order specified; rather,
    it''ll start listening to all the provided producers instantly and will fire emissions
    as soon as they are emitted from the source. Let''s look at an example that illustrates
    this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，合并操作并不保持指定的顺序；相反，它将立即开始监听所有提供的生产者，并在它们从源处发出时立即触发排放。让我们看看一个说明这一点的例子：
- en: '[PRE7]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, on comment `(1)` and `(2)`, we created two `Observable<Long>`
    instances with the `Observable.interval` operator, then mapped it with `Observable`
    numbering and got instances of `Observable<String>`. The objective of the `map`
    operator here is to inject an `Observable` identification in the output so we
    can easily identify the `Observable` source from the merged output.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，在注释（1）和（2）中，我们使用`Observable.interval`操作符创建了两个`Observable<Long>`实例，然后使用`Observable`编号进行映射，得到了`Observable<String>`的实例。这里`map`操作符的目标是在输出中注入一个`Observable`标识，这样我们就可以轻松地从合并输出中识别`Observable`的来源。
- en: 'So, here is the much discussed output:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，这里就是大家讨论了很多的输出：
- en: '![](img/ff22fe73-51f3-4f15-98fd-1b208241fa60.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![](img/ff22fe73-51f3-4f15-98fd-1b208241fa60.jpg)'
- en: The output clearly shows that the `merge` operator took emissions from `observable2`
    first, as they came first, even though we put `observable1` first in the `merge`
    operator.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，`merge`操作符首先从`observable2`中获取排放，因为它们先到达，尽管我们在`merge`操作符中首先放置了`observable1`。
- en: 'The `merge` operator, however, supports up to four parameters. As a fallback,
    we have the `mergeArray` operator, which accepts `vararg` of `Observable`; the
    following is an example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`merge`操作符支持多达四个参数。作为一个后备方案，我们有`mergeArray`操作符，它接受`vararg`的`Observable`；以下是一个例子：
- en: '[PRE8]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The output is as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/2589493f-e1c8-42b1-b8e2-1a7430d6c215.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![](img/2589493f-e1c8-42b1-b8e2-1a7430d6c215.jpg)'
- en: 'As with the `zip` operator, the `merge` operator also has a version for calling
    on instances of `Observable`''s rather than, statically, `mergeWith`; we can call
    this operator on `Observable` instances. So, let''s look at an example:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与`zip`操作符一样，`merge`操作符也有一个用于调用`Observable`实例的版本，而不是静态的`mergeWith`；我们可以在`Observable`实例上调用此操作符。所以，让我们看看一个例子：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The program is simple enough. We are creating two `Observable` instances, and
    then merging `observable1` with `observable2` with the `mergeWith` operator called
    on the `observable1` instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 程序很简单。我们创建了两个`Observable`实例，然后使用在`observable1`实例上调用的`mergeWith`操作符将`observable1`与`observable2`合并。
- en: 'The output is as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6229c197-8b2f-4b50-92df-86f4bbe2293d.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/6229c197-8b2f-4b50-92df-86f4bbe2293d.jpg)'
- en: The literal meaning of merging is combining two things together to create a
    new one, irrespective of any order; all the merging operators do the same thing.
    If you want to maintain the order, you have to concatenate one after another.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 合并的字面意思是将两件事物结合起来创造一个新的事物，不考虑任何顺序；所有合并操作符都做同样的事情。如果你想保持顺序，你必须一个接一个地连接。
- en: Concatenating producers (Observable/Flowable)
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接生产者（Observable/Flowable）
- en: Concatenating operators are almost the same with `merge` operators, except that
    the concatenating operators respect the prescribed ordering. Instead of subscribing
    to all provided producers in one go, it subscribes to the producers one after
    another; only once, it received `onComplete` from the previous subscription.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 连接操作符几乎与`merge`操作符相同，除了连接操作符尊重规定的顺序。它不会一次性订阅所有提供的生产者，而是逐个订阅生产者；只有当它从前一个订阅中收到`onComplete`后，才会这样做。
- en: 'So, let''s modify our last program with the `concatenate` operator and see
    the changes:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们使用`concatenate`操作符修改我们最后的程序，看看变化：
- en: '[PRE10]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As we already mentioned, the `concat` operator subscribes to the next source
    `Observable` in the queue only after it got `onComplete` from its current source
    `Observable`; we also know that the `Observable` instances created with `Observable.interval`
    never emit `onComplete`. Rather, they keep emitting numbers until `Long.MAX_VALUE`
    is reached. So, as a quick fix, we used the `take` operator on comment `(1)`,
    which will take the first two emissions from `Observable.interval` and then will
    append an `onComplete` notification to it so that the `concat` operator can start
    listening to the next source Observable as well.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，`concat`操作符只有在从当前源`Observable`收到`onComplete`后才会订阅队列中的下一个源`Observable`；我们也知道使用`Observable.interval`创建的`Observable`实例永远不会发出`onComplete`。相反，它们会一直发出数字，直到达到`Long.MAX_VALUE`。因此，作为一个快速修复，我们在注释（1）上使用了`take`操作符，它将从`Observable.interval`中取出前两个排放，然后向其中添加一个`onComplete`通知，这样`concat`操作符也可以开始监听下一个源`Observable`。
- en: We are discussing the `take` operators in this chapter in the *Skipping and
    taking emissions* section. Don't forget to take a look.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的 *跳过和获取发射* 部分讨论了 `take` 操作符。别忘了看看。
- en: 'So, here is the output:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，以下是输出结果：
- en: '![](img/af28c538-b870-460e-9eae-28b4c6925bc4.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/af28c538-b870-460e-9eae-28b4c6925bc4.jpg)'
- en: From the output, we can clearly see that the `concat` operator is subscribed
    to the next supplied source `Observable` only after it got the `onComplete` notification
    from its first one.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以清楚地看到，`concat` 操作符仅在从其第一个 `Observable` 收到 `onComplete` 通知后，才订阅下一个提供的源
    `Observable`。
- en: Just like the `merge` operator, the `concat` operator also has `concatArray`
    and `concatWith` variants, and they work in almost the same way, just concatenating
    instead of merging.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `merge` 操作符一样，`concat` 操作符也有 `concatArray` 和 `concatWith` 变体，它们几乎以相同的方式工作，只是连接而不是合并。
- en: Ambiguously combining producers
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模糊组合生产者
- en: The ambiguous combination of producers is probably the easiest among all combination
    types. Think of a situation where you're fetching data from two data sources (may
    be two separate APIs or database tables), and want to proceed with the first one
    you got and discard the other one. In the imperative programming technique, you
    would probably be required to write checks for that; however, with RxKotlin, the
    `amb` operator is there to hold your back.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者的模糊组合可能是所有组合类型中最简单的一种。想象一下，你正在从两个数据源（可能是两个不同的 API 或数据库表）获取数据，并希望使用你得到的第一份数据并丢弃其他数据。在命令式编程技术中，你可能需要编写检查来处理这种情况；然而，使用
    RxKotlin，`amb` 操作符就在那里为你提供支持。
- en: The `amb` operator takes a list of `Observable` (`Iterable<Observable>` instance)
    as parameter, subscribes to all `Observables` present in the `Iterable` instance,
    emits the items that it got from the first `Observable` it got an emit from, and
    discards the rest of `Observables` present on the `Iterable` instance.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`amb` 操作符接受一个 `Observable` 列表（`Iterable<Observable>` 实例）作为参数，订阅 `Iterable`
    实例中存在的所有 `Observable`，从它接收到的第一个 `Observable` 发射的项目，并丢弃 `Iterable` 实例上存在的其余 `Observable`。'
- en: 'The following example will help us understand better:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例将帮助我们更好地理解：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'So, in this program, we created two `Observable`''s with a `500` and a `100`
    milliseconds interval on comment `(1)` and `(2)` respectively. On comment `(3)`,
    we used the `listOf` function to create a `List<Observable>` from those two `Observable` and
    passed it to the `amb` operator. Here''s the output:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们在注释 `(1)` 和 `(2)` 分别创建了两个具有 `500` 毫秒和 `100` 毫秒间隔的 `Observable`。在注释
    `(3)` 中，我们使用了 `listOf` 函数从这两个 `Observable` 创建了一个 `List<Observable>`，并将其传递给了 `amb`
    操作符。以下是输出结果：
- en: '![](img/4a444006-a544-4e14-a511-161416f032af.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a444006-a544-4e14-a511-161416f032af.jpg)'
- en: We can see from the output that the `amb` operator took the emissions from `observable2`
    and didn't care about `observable1`, as the `observable2` instance emitted first.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中我们可以看到，`amb` 操作符从 `observable2` 中获取了发射项，并不关心 `observable1`，因为 `observable2`
    实例先发射了。
- en: Just like other combination operators, `amb` also has `ambArray` and `ambWith`
    operator variants.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他组合操作符一样，`amb` 也有 `ambArray` 和 `ambWith` 操作符变体。
- en: Grouping
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 分组
- en: Grouping is a powerful operation that can be achieved using RxKotlin. This operation
    allows you to group emissions based on their property. Say, for example, you have
    an `Observable` / `Flowable` emitting integer numbers (`Int`), and, as per your
    business logic, you have some separate code for even and odd numbers and want
    to handle them separately. Grouping is the best solution in that scenario.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 分组是使用 RxKotlin 可以实现的一种强大操作。这个操作允许你根据它们的属性对发射项进行分组。比如说，你有一个发射整数数字（`Int`）的 `Observable`
    / `Flowable`，根据你的业务逻辑，你为偶数和奇数有一些单独的代码，并希望分别处理它们。在这种情况下，分组是最好的解决方案。
- en: 'Let''s take an example:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this example, I've grouped emissions based on their remainder when divided
    by `5`, so, basically, there should be `5` groups (`0` through `4`). On comment
    `(1)` of this example, we used the `groupBy` operator and passed a predicate to
    it, upon which the grouping should be performed. The `groupBy` operator takes
    the result of the predicate to group emissions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我根据它们除以 `5` 的余数对发射项进行了分组，所以，基本上应该有 `5` 组（从 `0` 到 `4`）。在这个例子的注释 `(1)`
    中，我们使用了 `groupBy` 操作符并将其传递给一个谓词，根据这个谓词进行分组。`groupBy` 操作符根据谓词的结果对发射项进行分组。
- en: On comment `(2)` of this example, we used the `blockingSubscribe` operator to
    subscribe to the newly created `Observable<GroupedObservable<K, T>>` instance.
    We could also use the simple `subscribe` operator; however, as we are printing
    the output to the console, by using `subscribe`, everything will look like a mess.
    Mainly because the `subscribe` operator doesn't wait for the given task on emission
    to complete before taking the next emission. On the other hand, `blockingSubscribe`
    will make the program wait until it completes processing an emission, before proceeding
    to a new one.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例的注释`(2)`中，我们使用了`blockingSubscribe`操作符来订阅新创建的`Observable<GroupedObservable<K,
    T>>`实例。我们也可以使用简单的`subscribe`操作符；然而，由于我们将输出打印到控制台，使用`subscribe`会使一切看起来都很混乱。主要是因为`subscribe`操作符在接收下一个排放之前不会等待给定的任务完成。另一方面，`blockingSubscribe`将使程序等待直到它完成处理一个排放，然后才会进行下一个。
- en: The `groupBy` operator returns `Observable` that emits `GroupedObservable`,
    containing our groups; so, inside `blockingSubscribe`, we need to subscribe to
    the emitted `GroupedObservable` instance. On comment `(3)`, we did the same, after
    printing the `key` of the emitted `GroupedObservable` instance.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '`groupBy`操作符返回包含我们的组的`Observable`，因此，在`blockingSubscribe`内部，我们需要订阅发出的`GroupedObservable`实例。在注释`(3)`中，我们做了同样的事情，在打印发出`GroupedObservable`实例的`key`之后。'
- en: 'The output is as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4e4b8792-faec-4bba-bfb6-e69ecaf5e0a3.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4e4b8792-faec-4bba-bfb6-e69ecaf5e0a3.jpg)'
- en: flatMap, concatMap – In details
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`flatMap`，`concatMap` – 详细说明'
- en: As promised in the previous chapter, now we will take a deeper dive into the
    `flatMap` and `concatMap` operators, as, by now, we have already gained some sort
    of expertise on the `merge` and `concat` operators and know the differences between
    them.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一章所承诺的，现在我们将更深入地探讨`flatMap`和`concatMap`操作符，因为我们已经对`merge`和`concat`操作符有了某种程度的了解，并且知道它们之间的区别。
- en: Let's start with the differences between `flatMap` and `concatMap`, after which,
    we will also discuss their ideal implementation scenarios. We will also discuss
    some of their variants to know them better.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`flatMap`和`concatMap`之间的区别开始，之后，我们还将讨论它们的理想实现场景。我们还将讨论它们的一些变体，以便更好地了解它们。
- en: 'In the previous chapter, we mentioned that `flatMap` internally uses the `merge`
    operator and `concatMap` internally uses the `concat` operator. However, what
    difference does that make? You just learned the differences between the `merge`
    and the `concat` operator, but what is the point of having two separate mapping
    operators based on them? So, let''s start with an example. We will see an example
    with `flatMap`, and then we will try to implement the same with `concatMap`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一章中，我们提到`flatMap`内部使用`merge`操作符，而`concatMap`内部使用`concat`操作符。然而，这有什么区别呢？你刚刚学习了`merge`和`concat`操作符之间的区别，但是基于它们有两个独立的映射操作符有什么意义呢？所以，让我们从一个例子开始。我们将看到一个使用`flatMap`的例子，然后我们将尝试使用`concatMap`实现相同的操作：
- en: '[PRE13]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the preceding program, we created an `Observable` instance. We then used
    the `flatMap` operator with the `delay` operator on it to add a random delay to
    the emissions.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的程序中，我们创建了一个`Observable`实例。然后，我们在它上面使用`flatMap`操作符和`delay`操作符来为排放添加随机延迟。
- en: 'The output is as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/6d34b8d5-676e-409a-9f4b-c50b60f2b5e0.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6d34b8d5-676e-409a-9f4b-c50b60f2b5e0.jpg)'
- en: From the output, we can see that the downstream didn't get the emissions in
    their prescribed order; I think you got the reason behind it, didn't you? That's
    right; the cause behind it is simply the `merge` operator, as the `merge` operator
    subscribes and reemits the emissions asynchronously all at one go, thus the order
    is not maintained.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中，我们可以看到下游没有按照规定的顺序接收排放；我想你已经找到了原因，不是吗？没错；背后的原因是简单的`merge`操作符，因为`merge`操作符异步地一次性订阅和重新发射排放，因此顺序没有得到保持。
- en: 'Now, let''s implement the code with the `concatMap` operator:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们使用`concatMap`操作符来实现代码：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The output is as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/fa64ca05-a241-4e58-b7bc-b7b48ec15e2e.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/fa64ca05-a241-4e58-b7bc-b7b48ec15e2e.jpg)'
- en: As the `concatMap` operator uses `concat` internally, it maintains the prescribed
    order of emissions.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`concatMap`操作符内部使用`concat`，它保持了规定的排放顺序。
- en: So, when to use which operator? Let's take a look at the following real-time
    scenarios; all of them are applicable, especially when you are building an app.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时使用哪个操作符呢？让我们看看以下实时场景；所有这些场景都适用，尤其是在你构建应用程序时。
- en: When to use flatMap operator
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用`flatMap`操作符
- en: 'Take a look at the following list—it contains the contexts and situations where
    `flatMap` will fit best:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下列表——它包含了`flatMap`最适合的上下文和情况：
- en: When you're working with a list of data within a page, activity, or fragment
    and want to send some data to a server or a database per item of the list. The
    `concatMap` operator will also do here; however, as the `flatMap` operator works
    asynchronously, it'll be faster, and, as you're sending data, the order doesn't
    really matter.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你在页面、活动或片段中处理数据列表，并希望为列表中的每一项发送数据到服务器或数据库时。`concatMap`操作符在这里也会这样做；然而，由于`flatMap`操作符是异步的，它将更快，而且，由于你正在发送数据，顺序实际上并不重要。
- en: Whenever you want to perform any operation on list items asynchronously and
    in a comparatively short time period.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想要在相对较短的时间内异步地对列表项执行任何操作时。
- en: When to use concatMap operator
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用`concatMap`操作符
- en: So, when to use `concatMap`?
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，何时使用`concatMap`？
- en: 'The following list contains the contexts and situations where `concatMap` will
    fit best:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含`concatMap`最适合的上下文和情况：
- en: When you are downloading the list of data to display to the user. The order
    really matters here, you will surely not want to load and display the second item
    of the list after the third and fourth one are already displayed, would you?
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你正在下载要显示给用户的列表数据时。这里的顺序真的很重要，你当然不希望在不显示第三和第四项之后加载并显示列表的第二项，对吧？
- en: Performing some operation on a sorted list, making sure the list stays the same.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在有序列表上执行一些操作，确保列表保持不变。
- en: Understanding switchMap operator
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解`switchMap`操作符
- en: The `switchMap` operator is really interesting. It listens to all the emissions
    of the source producer (Observable/Flowable) asynchronously, but emits only the
    latest one within the timeframe. Let's explain it a bit more.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`switchMap`操作符非常有趣。它异步监听源生产者（Observable/Flowable）的所有发射，但只发射时间段内的最新项。让我们进一步解释一下。'
- en: 'When the source `Observable` emits more than one item consecutively before
    the `switchMap` has emitted any of them, `switchMap` will take the last one and
    discard any emission that came in between. Let''s take an example to understand
    it better:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当源`Observable`在`switchMap`发射任何项之前连续发射多个项时，`switchMap`将只取最后一个，并丢弃任何介于其间的发射。让我们通过一个例子来更好地理解它：
- en: '[PRE15]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The output is as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/60858640-4fdd-41eb-8dc1-b6b82683cfea.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/60858640-4fdd-41eb-8dc1-b6b82683cfea.jpg)'
- en: In the program, we took two approaches at first, we used the `delay` operator,
    and then we reused the same with the `delay` operator. From the output, we can
    see that, for the second one, `switchMap` only emitted the last item, as it got
    consecutive emission for each one before it reemitted them. However, for the first
    one, it reemitted all the items before receiving any further emit.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序中，我们最初采取了两种方法，我们使用了`delay`操作符，然后我们用`delay`操作符重用了同样的方法。从输出中我们可以看到，对于第二种情况，`switchMap`只发射了最后一个项，因为它在重新发射之前收到了连续的发射。然而，对于第一种情况，它在收到任何进一步的发射之前重新发射了所有项。
- en: 'Still confused? Let''s modify the program a bit more:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 仍然感到困惑？让我们进一步修改程序：
- en: '[PRE16]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this program, instead of adding delay to all the emissions, we emitted all
    the numbers divisible by `3` without delay, and added a delay to the rest.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们不是对所有发射添加延迟，而是立即发射所有能被`3`整除的数字，并对其余的添加延迟。
- en: 'The output is as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/70c95536-36a1-43b6-95c6-f5ead179e4ec.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/70c95536-36a1-43b6-95c6-f5ead179e4ec.jpg)'
- en: As expected, the `switchMap` operator emits the only those items which were
    emitted by the source without delay, and the last emitted item by the source.
    The reason is quite simple; the `switchMap` operator was able to emit them before
    it received the following item.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`switchMap`操作符只发射了那些在源操作符无延迟发射的项，以及源操作符最后发射的项。原因很简单；`switchMap`操作符在接收到下一个项之前就已经能够发射它们。
- en: Skipping and taking emissions
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过和取发射
- en: Just like the preceding situation in this chapter, where we used the `take`
    operator, there are often some scenarios where you would like to take some of
    the emissions and skip the remaining ones. The `skip` and `take` operators are
    of huge help in those scenarios. They are actually a part of the filtering operators
    we discussed in the previous chapter; however, honestly, they do deserve a dedicated
    discussion. So, here it is.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本章前面使用`take`操作符的情况一样，通常有一些场景，你希望取一些发射并跳过其余的。`skip`和`take`操作符在这些场景中非常有帮助。它们实际上是我们在上一章讨论的过滤操作符的一部分；然而，坦白说，它们确实值得专门的讨论。所以，这就是。
- en: Skipping emissions (skip, skipLast, skipUntil, and skipWhile)
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳过发射（skip、skipLast、skipUntil和skipWhile）
- en: There may be a requirement where you would like to skip some emissions at the
    beginning or skip emissions until a particular condition is met. You may even
    have to wait for another producer before taking emissions and skip all remaining
    ones.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会有这样的需求，你希望跳过开始的一些发射，或者跳过发射直到满足特定条件。你可能甚至需要等待另一个生产者发射后再获取发射并跳过所有剩余的发射。
- en: These operators are designed keeping the exact scenario in mind. They help you
    skip emissions in various ways.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作符是根据具体场景设计的。它们以各种方式帮助你跳过发射。
- en: 'RxKotlin provides us with many variations and overloads of the `skip` operator;
    we will discuss the most important ones among them:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: RxKotlin为我们提供了`skip`操作符的许多变体和重载；我们将讨论其中最重要的几个：
- en: '`skip`'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skip`'
- en: '`skipLast`'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipLast`'
- en: '`skipWhile`'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipWhile`'
- en: '`skipUntil`'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`skipUntil`'
- en: We will take a look at all of the preceding listed operators one by one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐一查看所有列出的前述操作符。
- en: 'Let''s start with `skip`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`skip`开始：
- en: '[PRE17]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `skip` operator has two important overloads: `skip(count:Long)` and `skip(time:Long,
    unit:TimeUnit)`; the first overload works on count, discarding the first *n* number
    of emissions, while the second overload works on time, discarding all the emissions
    that came in the specified time duration.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`skip`操作符有两个重要的重载：`skip(count:Long)`和`skip(time:Long, unit:TimeUnit)`；第一个重载基于计数，丢弃前*n*个发射，而第二个重载基于时间，丢弃在指定时间间隔内到达的所有发射。'
- en: In this program, on comment `(1)`, we used the `skip(count)` operator to skip
    the first `5` emissions. On comment `(2)`, we used the `skip(time,unit)` operator
    to skip all emissions in the first `400` milliseconds (4 seconds) of the subscription.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，在注释（1）处，我们使用了`skip(count)`操作符来跳过前`5`次发射。在注释（2）处，我们使用了`skip(time,unit)`操作符来跳过订阅前`400`毫秒（4秒）内的所有发射。
- en: 'Here is the output:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '![](img/506e0abb-25c6-4dac-b820-a20fe9287f81.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![](img/506e0abb-25c6-4dac-b820-a20fe9287f81.png)'
- en: 'Now, let''s take a look at how the `skipLast` operator works:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`skipLast`操作符是如何工作的：
- en: '[PRE18]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `skipLast` operator has many overloads like the `skip` operator. The only
    difference is that this operator discards emissions from last. In this program,
    we used the `skipLast(count)` operator to skip the last `5` emissions on comment
    `(1)`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipLast`操作符有多个重载，就像`skip`操作符一样。唯一的区别是，这个操作符会丢弃最后的发射。在这个程序中，我们在注释（1）处使用了`skipLast(count)`操作符来跳过最后的`5`次发射。'
- en: 'Here is the output:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出：
- en: '![](img/72778450-3956-42c5-ac04-9c3337ec6556.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![](img/72778450-3956-42c5-ac04-9c3337ec6556.png)'
- en: 'Unlike `skip` and `skipLast`, both of which skip emissions on the basis of
    count or time, `skipWhile` skips them on the base of a predicate (logical expression).
    You''ve to pass a predicate to the `skipWhile` operator, just like the `filter`
    operator. It will keep skipping emissions while the predicate evaluates to true.
    It will start passing all emissions downstream as soon as the predicate returns
    false. Let''s take a look at the following piece of code:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 与`skip`和`skipLast`不同，这两个操作符都是基于计数或时间来跳过发射，而`skipWhile`是基于谓词（逻辑表达式）来跳过发射。你需要向`skipWhile`操作符传递一个谓词，就像`filter`操作符一样。它会在谓词评估为true时继续跳过发射。一旦谓词返回false，它将开始将所有发射传递到下游。让我们看看以下代码片段：
- en: '[PRE19]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The output is as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/7c858ab3-fdba-42c1-92e5-ca5f9be5ed7d.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![](img/7c858ab3-fdba-42c1-92e5-ca5f9be5ed7d.png)'
- en: Note that, unlike filter, the `skipWhile` operator will execute the predicate
    until it returns false and pass all the emissions thereafter. If you want the
    predicate, check on all the emissions; you should rather consider the `filter`
    operator.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与filter不同，`skipWhile`操作符会执行谓词直到它返回false，并传递所有后续的发射。如果你想检查所有发射的谓词，你更应该考虑`filter`操作符。
- en: 'Think of a situation where you''re working with two producers, producer1 and
    producer2, and want to start processing emissions from producer1 as soon as producer2
    starts emitting. In this scenario, `skipUntil` can help you out. Let''s look at
    this example:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你正在处理两个生产者，producer1和producer2，并且希望在producer2开始发射时立即开始处理producer1的发射。在这种情况下，`skipUntil`可以帮助你。让我们看看这个例子：
- en: '[PRE20]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We will explain the code, but take a look at the output first:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将解释代码，但首先看看输出：
- en: '![](img/167b8199-a206-4b24-904b-ece08f0cb4b4.png)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![](img/167b8199-a206-4b24-904b-ece08f0cb4b4.png)'
- en: On comment `(1)`, we created an `Observable` instance (`observable2`) with `Observable.timer`,
    which should trigger emission after `500` milliseconds. On comment `(2)`, we used
    that `Observable` instance (`observable2`) as the parameter to the `skipUntil`
    operator, which will make it discard all the emissions of `observable1` until
    `observable2` emits.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(1)`中，我们使用`Observable.timer`创建了一个`Observable`实例(`observable2`)，它应该在`500`毫秒后触发发射。在注释`(2)`中，我们使用那个`Observable`实例(`observable2`)作为`skipUntil`操作符的参数，这将使它丢弃`observable1`的所有发射，直到`observable2`发射。
- en: Take operators (take, takeLast, takeWhile, and takeUntil)
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取操作符（take、takeLast、takeWhile和takeUntil）
- en: 'The `take` operators work in exactly the opposite way than the `skip` operators.
    Let''s take an example of them one by one and understand how they work:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`take`操作符与`skip`操作符正好相反。让我们逐个举例说明，了解它们是如何工作的：'
- en: '[PRE21]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This program is almost like the program with `skip`. The difference is that
    here, we used `take` instead of `skip`. Let''s check the difference to understand
    better:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序几乎和带有`skip`的程序一样。区别在于这里，我们使用了`take`而不是`skip`。让我们检查一下差异，以便更好地理解：
- en: '![](img/5f9ecce8-1164-4214-aaf3-0acac163aedf.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5f9ecce8-1164-4214-aaf3-0acac163aedf.png)'
- en: The output shows it clearly. In the exact opposite way than the `skip` operator,
    the `take` operator passes the specified emissions to downstream, discarding the
    remaining ones. Most importantly, it also sends `onComplete` notifications to
    downstream on its own, as soon as it completes passing all the specified emissions.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示了这一点。与`skip`操作符正好相反，`take`操作符将指定的发射传递给下游，并丢弃剩余的。最重要的是，它还在其完成传递所有指定的发射后，向下游发送`onComplete`通知。
- en: 'Let''s test it with `takeLast` operator:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`takeLast`操作符来测试一下：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And, here is the output; it prints the last `5` numbers in the emission:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，这里是输出；它打印了排放中的最后`5`个数字：
- en: '![](img/b68993d0-5f7f-4e5c-a9b7-30d127ae0b96.png)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b68993d0-5f7f-4e5c-a9b7-30d127ae0b96.png)'
- en: 'Now take a look at the `takeWhile`:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 现在看看`takeWhile`：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The output is the exact opposite of `skipWhile`; instead of skipping the first
    `10` numbers, it prints them and discards the remaining ones:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 输出与`skipWhile`正好相反；它不是跳过前`10`个数字，而是打印它们并丢弃剩余的：
- en: '![](img/b09b0f74-c355-4734-8478-f8ddfd573c14.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b09b0f74-c355-4734-8478-f8ddfd573c14.png)'
- en: The error handling operators
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理操作符
- en: 'While developing applications, errors may occur. We have to handle those errors
    properly to make sure our applications perform seamlessly on the user''s end.
    Take the following program as an example:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发应用程序时，可能会发生错误。我们必须正确处理这些错误，以确保我们的应用程序在用户端无缝运行。以下程序为例：
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the output:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/5ce81943-b2e2-46d0-854d-6202f1815d5e.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/5ce81943-b2e2-46d0-854d-6202f1815d5e.jpg)'
- en: As expected, the program threw an error and that is a bad thing if that occurs
    on the user end. So, let's take a look at how we can handle errors in a reactive
    way. RxKotlin provides us with a few operators for error handling, which we'll
    take a look at. We will use the previous program and apply various error handling
    operators to them to understand them better.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，程序抛出了错误，如果这种情况发生在用户端，那将是一件坏事。所以，让我们看看我们如何以响应式的方式处理错误。RxKotlin为我们提供了一些错误处理操作符，我们将查看它们。我们将使用之前的程序并将各种错误处理操作符应用到它们上，以便更好地理解它们。
- en: onErrorReturn – return a default value on error
  id: totrans-208
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: onErrorReturn – 在错误发生时返回默认值
- en: 'The `onErrorReturn` provides you with a technique to specify a default value
    to return to the downstream in case an error occurred in the upstream. Take a
    look at the following code snippet:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorReturn`为你提供了一个技术，以便在上游发生错误时指定一个默认值返回给下游。看看下面的代码片段：'
- en: '[PRE25]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We used the `onErrorReturn` operator to return `-1` whenever an error occurs.
    The output is as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`onErrorReturn`操作符在发生错误时返回`-1`。输出如下：
- en: '![](img/b47f7737-4dd2-4843-8c97-6de780c3e88c.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b47f7737-4dd2-4843-8c97-6de780c3e88c.jpg)'
- en: As we can see in the output, the `onErrorReturn` operator returns the specified
    default value. The downstream didn't receive any item further as the upstream
    stopped emitting items as soon as the error occurred.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 如输出所示，`onErrorReturn`操作符返回指定的默认值。由于上游在发生错误后停止发射项目，下游没有接收到任何其他项目。
- en: As we mentioned earlier, both `onError` and `onComplete` are terminal operators,
    so the downstream stops listening to that upstream as soon as it receives any
    of them.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前提到的，`onError`和`onComplete`都是终端操作符，所以一旦它接收了它们中的任何一个，下游就停止监听上游。
- en: The onErrorResumeNext operator
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: onErrorResumeNext操作符
- en: The `onErrorResumeNext` operator helps you subscribe to a different producer
    in case any error occurs.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '`onErrorResumeNext` 操作符可以帮助你在发生任何错误时订阅不同的生产者。'
- en: 'Here is an example:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个例子：
- en: '[PRE26]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The output is as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 输出如下：
- en: '![](img/4a5eb34f-e255-4706-b80b-929b6810fed6.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![](img/4a5eb34f-e255-4706-b80b-929b6810fed6.jpg)'
- en: This operator is especially useful when you want to subscribe to another source
    producer in case any error occurs.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作符在你想在发生任何错误时订阅另一个源生产者时特别有用。
- en: Retrying on error
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误重试
- en: 'The `retry` operator is another error handling operator that enables you to
    retry/re-subscribe to the same producer when an error occurs. You just need to
    provide a predicate or retry-limit when it should stop retrying. So, let''s look
    at an example:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '`retry` 操作符是另一个错误处理操作符，它允许你在发生错误时重新尝试/重新订阅相同的生产者。你只需要提供一个谓词或重试限制，以确定何时停止重试。所以，让我们看看一个例子：'
- en: '[PRE27]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: On comment `(1)`, we used the `retry` operator with a retry limit, and on comment
    `(2)`, we used the `retry` operator with a predicate. The `retry` operator will
    keep retrying until the predicate returns true and will pass the error to downstream
    whenever the predicate returns false.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(1)` 中，我们使用了一个带有重试限制的 `retry` 操作符，在注释 `(2)` 中，我们使用了一个带有谓词的 `retry` 操作符。`retry`
    操作符将一直重试，直到谓词返回 true，并且每当谓词返回 false 时，都会将错误传递到下游。
- en: 'Here is the output:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/0eb2a87c-b227-44ed-a8ed-883acece3045.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0eb2a87c-b227-44ed-a8ed-883acece3045.jpg)'
- en: An HTTP example
  id: totrans-228
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP 示例
- en: Any learning is not complete until and unless we apply it to a real-time scenario.
    So far, you have learned many concepts of reactive programming. Now, it's time
    to apply them to a real-world scenario, where we will use an API to get some data
    through an HTTP request and print the response data to the console.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 任何学习只有在将其应用于实时场景之后才算完整。到目前为止，你已经学习了响应式编程的许多概念。现在，是时候将它们应用于现实世界的场景了，我们将使用 API
    通过 HTTP 请求获取一些数据，并将响应数据打印到控制台。
- en: 'We used one additional plugin for this example—`RxJava-Apache-HTTP`. If you''re
    using Gradle as your build tool, add the following dependency:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为这个例子使用了一个额外的插件——`RxJava-Apache-HTTP`。如果你使用 Gradle 作为构建工具，请添加以下依赖项：
- en: '[PRE28]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Here is the code:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是代码：
- en: '[PRE29]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this program, we used `HttpAsyncClients.createDefault()` to get an instance
    of `CloseableHttpAsyncClient`. Before starting an HTTP request, we first need
    to start the client. We did this in the code on comment `(2)`, with `httpClient.start()`.
    On comment `(3)`, we created a GET request and converted it to an observable of
    type `ObservableHttpResponse`, so we used the `flatMap` operator to get access
    to the content of the response. Inside the `flatMap` operator, we used the `map`
    operator to convert the byte response into a `String` on comment `(4)`.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用 `HttpAsyncClients.createDefault()` 获取 `CloseableHttpAsyncClient`
    的实例。在开始 HTTP 请求之前，我们首先需要启动客户端。我们在注释 `(2)` 中的代码中这样做，使用 `httpClient.start()`。在注释
    `(3)` 中，我们创建了一个 GET 请求并将其转换为类型为 `ObservableHttpResponse` 的可观察对象，因此我们使用了 `flatMap`
    操作符来访问响应的内容。在 `flatMap` 操作符内部，我们在注释 `(4)` 中使用 `map` 操作符将字节响应转换为 `String`。
- en: On comment `(5)`, we used the `onErrorReturn` operator to return a default `String`
    in case there's an error.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释 `(5)` 中，我们使用了 `onErrorReturn` 操作符来返回一个默认的 `String`，以防出现错误。
- en: Finally, after the `onErrorReturn` operator, we subscribed to the chain and
    printed the response on comment `(6)`. We closed the `httpClient` as soon as we
    were done with the response.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 `onErrorReturn` 操作符之后，我们订阅了链，并在注释 `(6)` 中打印了响应。我们一完成响应，就关闭了 `httpClient`。
- en: 'The following is partly a screenshot of the output:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的部分是输出截图：
- en: '![](img/44dfe194-ba14-4a85-b8c0-5760ff6aeb3b.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![](img/44dfe194-ba14-4a85-b8c0-5760ff6aeb3b.jpg)'
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a rather a long chapter. You learned about combining producers, and
    learned, in depth, about the `flatMap`, `concatMap`, and `switchMap` operators.
    You got introduced to the `take` and `skip` operators and their variants. You
    learned about the error handling approaches in reactive programming. We also tried
    our skills with an HTTP client example, where we requested an API to fetch JSON
    data and print it to the console. We didn't try to parse the JSON data, as it
    could increase complexity at this level. Later in this book, we will definitely
    parse data and display that properly.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个相当长的章节。你学习了如何组合生产者，并深入了解了 `flatMap`、`concatMap` 和 `switchMap` 操作符。你了解了 `take`
    和 `skip` 操作符及其变体。你学习了响应式编程中的错误处理方法。我们还尝试了一个 HTTP 客户端示例，其中我们请求 API 获取 JSON 数据并将其打印到控制台。我们没有尝试解析
    JSON 数据，因为这可能会增加这一级别的复杂性。在本书的后面部分，我们肯定会解析数据并正确显示。
- en: While this and [Chapter 5](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml), *Asynchronous
    Data Operators and Transformations* were more about operators, the next chapter,
    [Chapter 7](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml), *Concurrency and Parallel
    Processing in RxKotlin with Schedulers*, is mainly about schedulers, handling
    concurrency, and multi-threading, and we will get a deeper dive in asynchronous
    programming with RxKotlin. As we are gradually moving to more advanced topics
    and chapters through this book, you need to pay more attention to each chapter
    to get a proper grasp on each aspect of reactive programming in Kotlin.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然[第五章](e395e42a-afc0-4424-9d0f-2de06e19989d.xhtml)，“异步数据操作符和转换”更多地涉及操作符，但下一章[第七章](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml)，“使用调度器的
    RxKotlin 并发和并行处理”主要关注调度器、处理并发和多线程，我们将更深入地探讨使用 RxKotlin 的异步编程。随着我们通过这本书逐渐过渡到更高级的主题和章节，你需要更加关注每一章，以便正确掌握
    Kotlin 中反应式编程的各个方面。
- en: So, what are you waiting for? Turn the page, [Chapter 7](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml), *Concurrency
    and Parallel Processing in RxKotlin with Schedulers* is waiting for you.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，你还在等什么？翻到下一页，[第七章](7eb4ad8c-cb73-4c9d-b611-fdc9b61b6a17.xhtml)，“使用调度器的 RxKotlin
    并发和并行处理”正在等待着你。
