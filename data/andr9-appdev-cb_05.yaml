- en: Fragments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fragments
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Creating and using a Fragment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用Fragment
- en: Adding and removing Fragments during runtime
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时添加和移除Fragment
- en: Passing data between Fragments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Fragment之间传递数据
- en: Handling the Fragment back stack
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理Fragment回退栈
- en: Introduction
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: With a firm understanding of layouts from [Chapter 2](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml),
    *Layouts*, we'll dig deeper into UI development with Fragments. Fragments are
    a way to separate your UI into smaller sections that can easily be reused. Think
    of Fragments as mini-activities, complete with their own classes, layouts, and
    life cycle. Instead of designing your screen in one Activity Layout, possibly
    duplicating functionality across multiple layouts, you can break the screen into
    smaller, logical sections and turn them into Fragments. Your Activity Layout can
    then reference one or multiple Fragments, as needed.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在对[第2章](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)，*布局*中的布局有了一定的理解之后，我们将更深入地探讨使用Fragment进行UI开发。Fragment是将UI分割成更小部分以便于重用的一种方式。将Fragment视为具有自己的类、布局和生命周期的迷你活动。您不必在一个Activity布局中设计整个屏幕，可能还会在多个布局中重复功能，而是可以将屏幕分割成更小的、逻辑上合理的部分，并将它们转换为Fragment。然后，您的Activity布局可以按需引用一个或多个Fragment。
- en: Creating and using a Fragment
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和使用Fragment
- en: Android didn't always support Fragments. The early versions of Android were
    designed for phones when screens had relatively small displays. It wasn't until
    Android started being used on tablets that there was a need to split the screen
    into smaller sections. Android 3.0 introduced the `Fragments` class and the Fragment
    Manager.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Android并不总是支持Fragment。Android的早期版本是为手机设计的，当时屏幕相对较小。直到Android开始在平板电脑上使用时，才需要将屏幕分割成更小的部分。Android
    3.0引入了`Fragments`类和Fragment管理器。
- en: Along with a new class, also came the Fragment Lifecycle. The Fragment Lifecycle
    is similar to the Activity Lifecycle introduced in [Chapter 1](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml),
    *Activities*, as most events parallel the Activity Lifecycle.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着新类的出现，也出现了Fragment生命周期。Fragment生命周期与在[第1章](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml)，*活动*中引入的活动生命周期相似，因为大多数事件都与活动生命周期并行。
- en: 'Here''s a brief overview of the main callbacks:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对主要回调的简要概述：
- en: '`onAttach()`: It''s called when the Fragment is associated with an Activity.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAttach()`: 当Fragment与Activity关联时调用。'
- en: '`onCreate()`: It''s called when the Fragment is first created.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 当Fragment首次创建时调用。'
- en: '`onCreateView()`: It''s called when the Fragment is about to be displayed for
    the first time.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreateView()`: 当Fragment即将首次显示时调用。'
- en: '`onActivityCreated()`: It''s called when the associated Activity is created.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onActivityCreated()`: 当相关Activity被创建时调用。'
- en: '`onStart()`: It''s called when the Fragment will become visible to the user.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart()`: 当Fragment将变为用户可见时调用。'
- en: '`onResume()`: It''s called just before a Fragment is displayed.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 在Fragment显示之前调用。'
- en: '`onPause()`: It''s called when the Fragment is first suspended. The user may
    return to the Fragment, but this is where you should persist any user data.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当Fragment首次暂停时调用。用户可能会返回到Fragment，但这是您应该持久化任何用户数据的地方。'
- en: '`onStop()`: It''s called when the Fragment is no longer visible to the user.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop()`: 当Fragment不再对用户可见时调用。'
- en: '`onDestroyView()`: It''s called to allow final cleanup.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroyView()`: 它被调用以允许最终的清理。'
- en: '`onDetach()`: It''s called when the Fragment is no longer associated with the
    Activity.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDetach()`: 当Fragment不再与Activity关联时调用。'
- en: 'For our first exercise, we will create a new Fragment derived from the standard
    `Fragment` class. But there are several other Fragment classes we could derive
    from, including the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的第一个练习，我们将创建一个新的由标准`Fragment`类派生的Fragment。但我们可以从以下几个其他Fragment类中派生，包括以下内容：
- en: '`DialogFragment`: It''s used for creating a floating dialog'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DialogFragment`: 它用于创建一个浮动对话框'
- en: '`ListFragment`: It creates a `ListView` in a Fragment, similar to `ListActivity`'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListFragment`: 它在Fragment中创建一个`ListView`，类似于`ListActivity`'
- en: '`PreferenceFragment`: It creates a list of `Preference` objects, commonly used
    for a Settings page'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PreferenceFragment`: 它创建了一个`Preference`对象的列表，通常用于设置页面'
- en: In this recipe, we will walk through creating a basic Fragment derived from
    the `Fragment` class and include it in an Activity Layout.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将通过创建一个由`Fragment`类派生的基本Fragment，并将其包含在Activity布局中来进行操作。
- en: Getting ready
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `CreateFragment`. Use the
    default Phone & Tablet option and select Empty Activity on the Add an Activity
    to Mobile dialog.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `CreateFragment`。使用默认的 `Phone & Tablet` 选项，并在
    `Add an Activity to Mobile` 对话框中选择 `Empty Activity`。
- en: How to do it...
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this recipe, we will create a new `Fragment` class with an accompanying layout
    file. We will then add the Fragment to the Activity Layout so it will be visible
    when the activity starts.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们将创建一个新的 `Fragment` 类及其相应的布局文件。然后，我们将片段添加到 Activity 布局中，以便在活动启动时可见。
- en: 'Here are the steps to create and display a new Fragment:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和显示新片段的步骤如下：
- en: 'Create a new layout called `fragment_one.xml` using the following XML:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下 XML 创建一个新的布局文件 `fragment_one.xml`：
- en: '[PRE0]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Create a new Java class called `FragmentOne.java` with the following code:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FragmentOne.java` 的新 Java 类，代码如下：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open the `activity_main.xml` file and replace the existing `<TextView>` element
    with the following `<fragment>` element:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 文件，并用以下 `<fragment>` 元素替换现有的 `<TextView>` 元素：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Run the program on a device or emulator.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating a new class, the same as we do for an Activity. In this
    recipe, we only create an overwrite for the `onCreateView()` method to load our
    Fragment layout. But, just like with the Activity events, we can override the
    other events as we need them. Once the new Fragment is created, we then add it
    to the Activity Layout. Since the original `Activity` class was created before
    Fragments existed, they do not support Fragments. That's why, unless otherwise
    indicated, all the examples for this book extend from `AppCompatActivity`. (If
    you used the Android Studio New Project Wizard, then by default `MainActivity`
    extends `AppCompatActivity`.)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个新的类，与 Activity 类似。在此配方中，我们只创建对 `onCreateView()` 方法的覆盖，以加载我们的片段布局。但是，就像
    Activity 事件一样，我们可以根据需要覆盖其他事件。一旦创建了新的片段，我们就将其添加到 Activity 布局中。由于原始 `Activity` 类是在片段存在之前创建的，因此它们不支持片段。这就是为什么，除非另有说明，本书的所有示例都扩展自
    `AppCompatActivity`。（如果您使用了 Android Studio 新项目向导，则默认情况下 `MainActivity` 扩展自 `AppCompatActivity`。）
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We're only creating a single, simple Fragment in this recipe to teach the fundamentals
    of Fragments. But this is a good time to point out the power of Fragments. If
    we are creating multiple Fragments (and usually we are, as that's the point of
    using Fragments), when creating the Activity Layouts as we did in step 4, we could
    create different layout configurations using the Android Resource Folders. The
    portrait layout may have only a single Fragment while the landscape may have two
    or more. The Master/Detail layout typically uses Fragments, thus only requiring
    each screen section to be designed and coded once, then included in the layout
    as appropriate.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在此配方中，我们只创建了一个简单的片段来教授片段的基本原理。但这是一个指出片段强大功能的好时机。如果我们正在创建多个片段（通常我们是这样做的，因为使用片段的目的），在创建活动布局时（如步骤
    4 所示），我们可以使用 Android 资源文件夹创建不同的布局配置。纵向布局可能只有一个片段，而横向布局可能有两个或更多。Master/Detail 布局通常使用片段，因此只需要为每个屏幕部分设计一次并编码，然后根据需要将其包含在布局中。
- en: See also
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: For more information on the Master/Detail pattern, see the *Passing data between
    Fragments* recipe later in this chapter.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于 Master/Detail 模式的更多信息，请参阅本章后面的 *在片段之间传递数据* 配方。
- en: Adding and removing Fragments during runtime
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在运行时添加和删除片段
- en: Defining a Fragment in the layout, as we did in the previous recipe, is known
    as a static Fragment, which doesn't allow the fragment to be changed during runtime.
    Rather than using the `<fragment>` element, we will create a container to hold
    the Fragment, then create the Fragment dynamically in the Activity's `onCreate()`
    method.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在布局中定义片段，就像我们在前面的配方中所做的那样，称为静态片段，它不允许在运行时更改片段。而不是使用 `<fragment>` 元素，我们将创建一个容器来容纳片段，然后在
    Activity 的 `onCreate()` 方法中动态创建片段。
- en: 'The FragmentManager provides the APIs for adding, removing, and changing Fragments
    during runtime using a FragmentTransaction. A Fragment transaction consists of
    the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: FragmentManager 提供了在运行时使用 FragmentTransaction 添加、删除和更改片段的 API。一个 Fragment 事务包括以下步骤：
- en: Starting a transaction
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始事务
- en: Performing one or multiple actions
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 执行一个或多个操作
- en: Committing the transaction
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提交事务
- en: This recipe will demonstrate the Fragment Manager by adding and removing Fragments
    during runtime.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将通过在运行时添加和删除片段来演示片段管理器。
- en: Getting ready
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `RuntimeFragments`. Use
    the default Phone & Tablet option and select Empty Activity on the Add an Activity
    to Mobile dialog.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`RuntimeFragments`。使用默认的 Phone & Tablet 选项，并在 Add
    an Activity to Mobile 对话框中选择 Empty Activity。
- en: How to do it...
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To demonstrate adding and removing Fragments, we first need to create the Fragments,
    which we will do by extending the `Fragment` class. After creating the new Fragments,
    we need to alter the layout for the Main Activity to include the Fragment container.
    From there, we just add the code to handle the Fragment transactions. Here are
    the steps:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示添加和删除片段，我们首先需要创建片段，我们将通过扩展 `Fragment` 类来实现。在创建了新的片段之后，我们需要修改主活动的布局以包含片段容器。从那里，我们只需添加处理片段事务的代码。以下是步骤：
- en: 'Create a new layout file called `fragment_one.xml` and include the following
    XML:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `fragment_one.xml` 的新布局文件，并包含以下 XML：
- en: '[PRE3]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The second layout file called `fragment_two.xml` is almost identical, with
    the only difference being the text:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个布局文件 `fragment_two.xml` 几乎相同，唯一的区别是文本：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create a new Java class called `FragmentOne.java` with the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FragmentOne.java` 的新 Java 类，并包含以下代码：
- en: '[PRE5]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Import from the support library as follows:'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按照以下方式从支持库中导入：
- en: '[PRE6]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create the second Java class called `FragmentTwo` with the following code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个 Java 类 `FragmentTwo`，并包含以下代码：
- en: '[PRE7]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As before, import from the support library:'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如前所述，从支持库中导入：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need to add a container and a button to the Main Activity layout. Change
    `activity_main.xml` as follows:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们需要在主活动布局中添加一个容器和一个按钮。按照以下方式更改 `activity_main.xml`：
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the Fragments created and the container added to the layout, we are now
    ready to write the code to manipulate the Fragments. Open `MainActivity.java`
    and add the following code below the class constructor:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建了片段并将容器添加到布局中后，我们现在可以编写操作片段的代码。打开 `MainActivity.java` 并在类构造函数下方添加以下代码：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following code to the existing `onCreate()` method, below `setContentView()`:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有的 `onCreate()` 方法中，在 `setContentView()` 下方添加以下代码：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Import from the support libraries:'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从支持库中导入：
- en: '[PRE12]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The last code we need to add handles the Fragment switching, called by the
    button:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后需要添加的代码处理片段切换，由按钮调用：
- en: '[PRE13]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Run the program on a device or emulator.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the steps for this recipe involve setting up the Fragments. Once the
    Fragments are declared, we create them in the `onCreate()` method. Though the
    code can be condensed to a single line, it's shown in the long form as it makes
    it easier to read and understand.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此菜谱的大多数步骤都涉及设置片段。一旦声明了片段，我们就在 `onCreate()` 方法中创建它们。虽然代码可以压缩成一行，但为了便于阅读和理解，这里以长形式展示。
- en: First, we get `FragmentManager` so we can begin `FragmentTransaction`. Once
    we have `FragmentTransaction`, we start the transaction with `beginTransaction()`.
    Multiple actions can occur within the transaction, but all we need here is to
    `add()` our initial Fragment. We call the `commit()` method to finalize the transaction.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们获取 `FragmentManager` 以开始 `FragmentTransaction`。一旦我们有了 `FragmentTransaction`，我们就使用
    `beginTransaction()` 开始事务。事务中可以发生多个操作，但这里我们只需要 `add()` 我们初始的片段。我们调用 `commit()`
    方法来最终化事务。
- en: 'Now that you understand the Fragment transaction, here is the succinct version
    for `onCreate()`:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了片段事务，以下是 `onCreate()` 的简洁版本：
- en: '[PRE14]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Our `switchFragment()` method does basically the same type of Fragment transaction.
    Instead of calling the `add()` method, we call the `replace()` method with the
    existing Fragment. We keep track of the current Fragment with the `showingFragment`
    variable so we know which Fragment to show next. We are not limited to switching
    between two Fragments either. If we needed additional Fragments, we just need
    to create them.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `switchFragment()` 方法基本上执行相同的片段事务。我们不是调用 `add()` 方法，而是调用带有现有片段的 `replace()`
    方法。我们通过 `showingFragment` 变量跟踪当前片段，以便知道下一个要显示的片段。我们也不限于在两个片段之间切换。如果我们需要额外的片段，我们只需创建它们即可。
- en: There's more...
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the *Switching between activities* recipe from [Chapter 1](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml),
    *Activities*, we discussed the back stack. Most users would expect the back key
    to move backward through the "screens" and they don't know or care if those screens
    are activities or Fragments. Fortunately, Android makes it very easy to add Fragments
    to the back stack just by adding a call to `addToBackStack()` before calling `commit()`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](ef2fe8b4-1320-45f5-b0d5-fb9fd1d35e07.xhtml)的*切换活动*食谱中，我们讨论了返回栈。大多数用户都期望返回键可以向后移动通过“屏幕”，他们不知道或不在乎那些屏幕是活动还是片段。幸运的是，Android通过在调用`commit()`之前添加对`addToBackStack()`的调用，使得向返回栈添加片段变得非常简单。
- en: When a Fragment is removed or replaced without adding it to the back stack,
    it is immediately destroyed. If it is added to the back stack, it is stopped and,
    if the user returns to the Fragment, it is restarted, instead of recreated.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个片段被移除或替换而没有添加到返回栈时，它将被立即销毁。如果它被添加到返回栈，它将被停止，如果用户返回到该片段，它将被重新启动，而不是重新创建。
- en: See also
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on managing the Fragment back stack, see the *Handling
    the Fragment back stack* recipe later in this chapter.
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关于管理片段返回栈的更多信息，请参阅本章后面的*处理片段返回栈*食谱。
- en: Passing data between Fragments
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在片段之间传递数据
- en: Often, the need arises to pass information between Fragments. An email application
    serves as a classic example. It's common to have the list of emails in one Fragment
    and show the email details in another Fragment (this is commonly referred to as
    a Master/Detail pattern). Fragments make creating this pattern easier because
    we only have to code each Fragment once, then include them in different layouts.
    We can easily have a single Fragment in a portrait layout with the ability to
    swap out the master Fragment with the detail Fragment when an email is selected.
    We can also create a two-panel layout where both the list and detail Fragments
    are side by side. Either way, when the user clicks the email in the list, the
    email opens up in the detail panel. This is when we need to communicate between
    two Fragments.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 经常需要在不同片段之间传递信息。电子邮件应用程序是一个经典的例子。通常，电子邮件列表在一个片段中，而在另一个片段中显示电子邮件详情（这通常被称为主/详细模式）。片段使得创建这种模式变得更容易，因为我们只需要为每个片段编写一次代码，然后在不同布局中包含它们。我们可以轻松地在一个纵向布局中放置一个片段，当选择电子邮件时，可以用详细片段替换主片段。我们还可以创建一个双面板布局，其中列表和详细片段并排。无论哪种方式，当用户点击列表中的电子邮件时，电子邮件将在详细面板中打开。这就是我们需要在两个片段之间进行通信的时候。
- en: Since one of the primary goals of Fragments is that they be completely self-contained,
    direct communication between Fragments is discouraged, and for good reason. If
    Fragments had to rely on other Fragments, your code would likely break when the
    layouts changed and only one Fragment was available. Fortunately, direct communication
    is not required for this scenario either. All Fragment communication should pass
    through the host activity. The host activity is responsible for managing the Fragments
    and can properly route the messages.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于片段的主要目标之一是它们应该是完全自包含的，因此不建议片段之间进行直接通信，这也有充分的理由。如果片段必须依赖于其他片段，那么当布局更改且只有一个片段可用时，你的代码很可能会出错。幸运的是，在这种情况下也不需要直接通信。所有片段通信都应该通过宿主活动进行。宿主活动负责管理片段，并且可以正确地路由消息。
- en: 'Now the question becomes: How do Fragments communicate with the activity? The
    answer is with an interface. You''re probably already familiar with an interface,
    as that''s how a view communicates an event back to an activity. One of the most
    common examples is the button `onClick()` interface.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在问题变成了：片段如何与活动通信？答案是使用接口。你可能已经熟悉接口，因为这是视图如何将事件回传给活动的方式。最常见的一个例子是按钮的`onClick()`接口。
- en: 'In this recipe, we will create two Fragments to demonstrate passing data from
    one Fragment to another via the host activity. We''ll also build on what we learned
    from the previous recipe by including two different Activity Layouts-one for portrait
    and one for landscape. When in portrait mode, the activity will swap the Fragments
    as needed. Here is a screenshot of when the application first runs in portrait
    mode:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建两个片段来演示通过宿主活动从一个片段向另一个片段传递数据。我们还将基于之前食谱中学到的知识，包括两个不同的活动布局——一个用于纵向，一个用于横向。在纵向模式下，活动将根据需要交换片段。以下是应用程序首次在纵向模式下运行的截图：
- en: '![](img/61791176-99c3-4df2-abf1-952d0bf12877.png)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![截图](img/61791176-99c3-4df2-abf1-952d0bf12877.png)'
- en: 'This is the screen showing the detail Fragment when you click on a country
    name:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是点击国家名称时显示详细 Fragment 的屏幕：
- en: '![](img/b9284ade-ae65-4094-95fa-e3daa5e4124d.png)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b9284ade-ae65-4094-95fa-e3daa5e4124d.png)'
- en: 'When in landscape, both Fragments will be side by side, as shown in the landscape
    screenshot:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在横向模式下，两个 Fragment 将并排显示，如横向截图所示：
- en: '![](img/8b2e7654-2324-4dac-933b-62c32b833286.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8b2e7654-2324-4dac-933b-62c32b833286.png)'
- en: Since the Master/Detail pattern generally involves a list for the master, we'll
    take advantage of `ListFragment` (mentioned in the *Creating and using a Fragment*
    section). When an item in the list is selected, the item text (country name in
    our example) will be sent to the detail Fragment via the host activity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Master/Detail 模式通常涉及一个主列表，我们将利用 `ListFragment`（在 *创建和使用 Fragment* 部分中提到）。当列表中的项目被选中时，项目文本（在我们的例子中是国家名称）将通过宿主活动发送到详细
    Fragment。
- en: Getting ready
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `FragmentCommunication`. Use
    the default Phone & Tablet option and select Empty Activity on the Add an Activity
    to Mobile dialog.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，命名为 `FragmentCommunication`。使用默认的 Phone & Tablet
    选项，并在 Add an Activity to Mobile 对话框中选择 Empty Activity。
- en: How to do it...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: To fully demonstrate working Fragments, we'll need to create two Fragments.
    The first Fragment will extend from `ListFragment` so it will not need a layout.
    We're going to go one step further by creating both portrait and landscape layouts
    for our Activity. For portrait mode, we'll swap Fragments and for landscape mode,
    we'll show both Fragments side by side.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完全展示工作的 Fragment，我们需要创建两个 Fragment。第一个 Fragment 将扩展 `ListFragment`，因此它不需要布局。我们将更进一步，为我们的
    Activity 创建纵向和横向布局。对于纵向模式，我们将交换 Fragment，对于横向模式，我们将同时显示两个 Fragment。
- en: When typing this code, Android Studio will offer two different library import
    options. Since the New Project Wizard automatically references the AppCompat library,
    we need to use the support library APIs instead of the framework APIs. Though
    very similar, the following code uses the support Fragment APIs.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当输入此代码时，Android Studio 将提供两种不同的库导入选项。由于新项目向导自动引用了 AppCompat 库，我们需要使用支持库 API
    而不是框架 API。尽管非常相似，以下代码使用了支持 Fragment API。
- en: 'Here are the steps, starting with the first Fragment:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是步骤，从第一个 Fragment 开始：
- en: 'Create a new Java class called `MasterFragment` and change it so it extends
    `ListFragment` as shown:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `MasterFragment` 的新 Java 类，并修改它使其扩展 `ListFragment`，如下所示：
- en: '[PRE15]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Import from the following library:'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从以下库中导入：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the following interface inside the `MasterFragment` class:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MasterFragment` 类中创建以下接口：
- en: '[PRE17]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Set up the interface callback listener with the following code:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码设置接口回调监听器：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The last step for the `MasterFragment` is to create `ListAdapter` to populate `ListView`,
    which we do in the `onViewCreated()` method. When a country name is selected,
    we''ll use `setOnItemClickListener()` to call our `OnMasterSelectedListener` interface
    with the following code:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MasterFragment` 的最后一步是创建 `ListAdapter` 以填充 `ListView`，我们在 `onViewCreated()`
    方法中这样做。当选择国家名称时，我们将使用 `setOnItemClickListener()` 调用我们的 `OnMasterSelectedListener`
    接口，如下所示：'
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Next, we need to create `DetailFragment`, starting with the layout. Create
    a new layout file called `fragment_detail.xml` with the following XML:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建 `DetailFragment`，从布局开始。创建一个名为 `fragment_detail.xml` 的新布局文件，其 XML
    如下所示：
- en: '[PRE20]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new Java class called `DetailFragment` extending from `Fragment` as
    follows:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `DetailFragment` 的新 Java 类，它扩展自 `Fragment`，如下所示：
- en: '[PRE21]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Import from the following library:'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从以下库中导入：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add the following constant to the class:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下常量添加到类中：
- en: '[PRE23]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Override `onCreateView()` as follows:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下重写 `onCreateView()` 方法：
- en: '[PRE24]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Code `onViewCreated()` as follows:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写 `onViewCreated()` 如下：
- en: '[PRE25]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The last step for this Fragment is to update `TextView` when we receive the
    selected country name. Add the following method to the class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于此 Fragment 的最后一步，当接收到选中的国家名称时更新 `TextView`。向类中添加以下方法：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The existing `activity_main.xml` layout will handle the portrait mode layout.
    Remove the existing `<TextView>` and replace with the following `<FrameLayout>`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现有的 `activity_main.xml` 布局将处理纵向模式布局。删除现有的 `<TextView>` 并替换为以下 `<FrameLayout>`：
- en: '[PRE27]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: For the landscape layout, create a new directory called `layout-land` in the
    `res` folder. The final result will be `res/layout-land`.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于横向布局，在 `res` 文件夹中创建一个名为 `layout-land` 的新目录。最终结果将是 `res/layout-land`。
- en: If you do not see the new `res/layout-land` directory, change from Android view
    to project view.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您看不到新的 `res/layout-land` 目录，请从 Android 视图切换到项目视图。
- en: 'Create a new `activity_main.xml` layout in `res/layout-land` as follows:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`res/layout-land`中创建一个新的`activity_main.xml`布局，如下所示：
- en: '[PRE28]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final steps are to set up `MainActivity` to handle the Fragments. Open
    the `MainActivity.java` file and add the following class variable to track single/dual
    pane:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后的步骤是将`MainActivity`设置起来以处理Fragment。打开`MainActivity.java`文件，并添加以下类变量以跟踪单/双面板：
- en: '[PRE29]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, change `onCreate()` as follows:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，按照以下方式修改`onCreate()`：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The last code to add is the `sendCountryName()` method, which handles sending
    the country name to `DetailFragment`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要添加的代码是`sendCountryName()`方法，它处理将国家名称发送到`DetailFragment`：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Run the program on a device or emulator.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We start by creating `MasterFragment`. In the Master/Detail pattern we are using,
    this usually represents a list, so we create a list by extending `ListFragment`.
    `ListFragment` is the Fragment equivalent of `ListActivity`. Other than extending
    from a Fragment, it's basically the same.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建`MasterFragment`。在我们使用的Master/Detail模式中，这通常代表一个列表，所以我们通过扩展`ListFragment`来创建一个列表。`ListFragment`是`ListActivity`的Fragment等价物。除了扩展自Fragment之外，它基本上是相同的。
- en: As stated in the recipe introduction, we shouldn't attempt to communicate directly
    with other Fragments.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如菜谱介绍中所述，我们不应尝试直接与其他Fragment通信。
- en: 'To provide a means to communicate the list item selection, we expose the interface:
    `OnMasterSelectedListener`. We call `onItemSelected()` every time an item is selected
    in the list.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供一个通信列表项选择的方式，我们暴露了接口：`OnMasterSelectedListener`。每次在列表中选择一个项目时，我们都调用`onItemSelected()`。
- en: 'Most of the work for passing data between Fragments is done in the host activity
    but, ultimately, the receiving Fragment needs a way to receive the data. `DetailFragment`
    supports this in two ways:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在Fragment之间传递数据的大部分工作是在宿主活动中完成的，但最终，接收Fragment需要一种接收数据的方式。`DetailFragment`以两种方式支持这一点：
- en: Passing the country name in the argument bundle, available at creation time
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时传递国家名称到参数包中
- en: A public method for the activity to call directly.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个公开的方法，供活动直接调用。
- en: When the activity creates the Fragment, it also creates a bundle to hold the
    data we want to send. Here we add the country name using `KEY_COUNTRY_NAME` defined
    in step 7\. We retrieve this bundle with `getArguments()` in `onViewCreated()`.
    If the key is found in the bundle, it is extracted and displayed using the `showSelectedCountry()`
    method. This is the same method the activity will call directly if the Fragment
    is already visible (in the two-panel layout).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动创建Fragment时，它也会创建一个包含我们想要发送的数据的bundle。在这里，我们使用在第7步中定义的`KEY_COUNTRY_NAME`添加国家名称。我们在`onViewCreated()`中使用`getArguments()`检索这个bundle。如果在bundle中找到该键，它将通过`showSelectedCountry()`方法提取并显示。这是活动如果Fragment已经可见（在双面板布局中）将直接调用的相同方法。
- en: 'Most of the work for this recipe is in the activity. We created two layouts:
    one for portrait and one for landscape. When in landscape orientation, Android
    will choose the landscape layout from the `res/layout-land` directory created
    in step 12\. Both layouts use a `<FrameLayout>` placeholder, similar to the previous
    exercise. We manage the Fragments in both `onCreate()` and `sendCountryName()`.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的大部分工作都在活动中。我们创建了两个布局：一个用于纵向，一个用于横向。当处于横向方向时，Android将选择在第12步中创建的`res/layout-land`目录中的横向布局。这两个布局都使用一个`<FrameLayout>`占位符，类似于之前的练习。我们在`onCreate()`和`sendCountryName()`中管理Fragment。
- en: 'In `onCreate()`, we set the `mDualPane` flag by checking whether the current
    layout includes the `frameLayout` view. If `frameLayout` is found (meaning it''s
    not null), then we have only a single panel because `frameLayout` is only defined
    in the portrait layout. If `frameLayout` is not found, then we have two `<FrameLayout>`
    elements instead: one for `MasterFragment` and another for `DetailFragment`.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onCreate()`中，我们通过检查当前布局是否包含`frameLayout`视图来设置`mDualPane`标志。如果找到`frameLayout`（意味着它不是null），那么我们只有一个面板，因为`frameLayout`仅在纵向布局中定义。如果没有找到`frameLayout`，那么我们有两个`<FrameLayout>`元素：一个用于`MasterFragment`，另一个用于`DetailFragment`。
- en: The last thing we do in `onCreate()` is to set up the `MasterFragment` listener
    by creating an anonymous callback, which passes the country name to the `sendCountryName()` method.
    The `sendCountryName()` method is where the data is actually passed to `DetailFragment`.
    If we are in portrait (or single-pane) mode, we need to create `DetailFragment`
    and replace the existing `MasterFragment`. This is where we create the bundle
    with the country name and call `setArguments()`. Notice how we call `addToBackStack()`
    before committing the transaction? This allows the back key to bring the user
    back to the list (`MasterFragment`). If we are in landscape mode, `DetailFragment`
    is already visible so we call the `howSelectedCountry()` public method directly.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，我们最后要做的事情是通过创建匿名回调来设置 `MasterFragment` 监听器，该回调将国家名称传递给 `sendCountryName()`
    方法。`sendCountryName()` 方法是数据实际上传递给 `DetailFragment` 的地方。如果我们处于纵向（或单面板）模式，我们需要创建
    `DetailFragment` 并替换现有的 `MasterFragment`。这就是我们创建包含国家名称的 bundle 并调用 `setArguments()`
    的地方。注意我们在提交事务之前调用 `addToBackStack()`？这允许返回键将用户带回列表（`MasterFragment`）。如果我们处于横向模式，`DetailFragment`
    已经可见，所以我们直接调用 `howSelectedCountry()` 公共方法。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'In `MasterFragment`, before sending the `onItemSelected()` event, we check
    to make sure the listener is not null with the following code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MasterFragment` 中，在发送 `onItemSelected()` 事件之前，我们使用以下代码检查监听器是否为空：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Though it's the job of the activity to set up the callback to receive the events,
    we don't want this code to crash if there's no listener. An alternative approach
    would be to verify the activity extends our interface in the Fragment's `onAttach()`
    callback.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然设置回调以接收事件是活动的职责，但我们不希望如果没有监听器，代码会崩溃。另一种方法是在 Fragment 的 `onAttach()` 回调中验证活动是否扩展了我们的接口。
- en: The objective for this recipe was to demonstrate the proper pattern for communicating
    between fragments (by using an interface) and how to pass data. We used the `ListView`
    fragment because it made typing this example easier, but for real-world applications,
    it's probably better to use `RecyclerView`. `RecyclerView` does not have a pre-made
    `Fragment` class (or `Activity` class) so you need to roll your own but it's no
    different than the examples shown in earlier chapters.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方的目标是演示在片段之间通信的正确模式（通过使用接口）以及如何传递数据。我们使用了 `ListView` 片段，因为它使编写此示例更容易，但在实际应用中，可能最好使用
    `RecyclerView`。`RecyclerView` 没有预制的 `Fragment` 类（或 `Activity` 类），因此你需要自己实现，但这与前面章节中显示的示例没有区别。
- en: See also
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For `RecyclerView` examples, refer to the *RecyclerView replaces ListView* section
    in [Chapter 2](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml), *Layouts* and the *Using
    Contextual Batch Mode with RecyclerView* section in [Chapter 4](271b832c-648f-4a10-967e-aac99272e9a9.xhtml),
    *Menus and Action Mode*.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `RecyclerView` 示例，请参阅 [第 2 章](0b95f21f-496a-48ca-900c-32d887d3a3fe.xhtml)
    的 *RecyclerView replaces ListView* 部分，*布局*，以及 [第 4 章](271b832c-648f-4a10-967e-aac99272e9a9.xhtml)
    的 *Using Contextual Batch Mode with RecyclerView* 部分，*菜单和操作模式*。
- en: For more information on resource directories, see the *Selecting themes based
    on the Android version* section in [Chapter 3](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml),
    *Views, Widgets, and Styles*.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有关资源目录的更多信息，请参阅 [第 3 章](3adebbef-b8f1-41ca-ba6c-c56329c9ea53.xhtml) 的 *Selecting
    themes based on the Android version* 部分，*视图、小部件和样式*。
- en: Handling the Fragment back stack
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Fragment 返回栈
- en: In several of the previous recipes, it was mentioned that you should call the
    `addToBackStack()` method in the Fragment transaction to enable Android to maintain
    a Fragment back stack. This is the first step, but may not be enough to provide
    a rich user experience. In this recipe, we'll explore two other callbacks: `onBackPressed()`
    and `onBackStackChanged()`. As you'll see, by implementing these callbacks, your
    application can provide specific behavior for the Fragment back stack. The `onBackPressed()`
    callback allows the app to check the back stack state and provide custom behavior,
    such as closing the app when appropriate.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的几个配方中，提到你应该在 Fragment 事务中调用 `addToBackStack()` 方法，以便 Android 能够维护一个 Fragment
    返回栈。这是第一步，但可能不足以提供丰富的用户体验。在这个配方中，我们将探索另外两个回调：`onBackPressed()` 和 `onBackStackChanged()`。正如你将看到的，通过实现这些回调，你的应用程序可以为
    Fragment 返回栈提供特定的行为。`onBackPressed()` 回调允许应用程序检查返回栈状态并提供自定义行为，例如在适当的时候关闭应用程序。
- en: The `onBackStackChanged()` callback is called whenever the actual back stack
    changes - such as when a Fragment is popped from the back stack. By overriding
    this callback, your app can check the current Fragment and update the UI (such
    as the *Home* key back arrow) as appropriate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当实际的返回栈发生变化时（例如，当从返回栈中弹出 Fragment 时），会调用 `onBackStackChanged()` 回调。通过重写此回调，您的应用可以检查当前
    Fragment 并根据需要更新 UI（例如，*主页* 键的返回箭头）。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `FragmentBackStack`. Use
    the default Phone & Tablet option and select Empty Activity on the Add an Activity
    to Mobile dialog.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `FragmentBackStack`。使用默认的 Phone & Tablet 选项，并在添加活动到移动对话框中选择
    Empty Activity。
- en: How to do it...
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'To demonstrate handling the Fragment back stack, we''ll create two fragments
    with a Next button to create a back stack. With that setup, we''ll implement the
    `onBackPressed()` callback to exit the app when the user reaches the top Fragment.
    We''ll be using the Fragment Manager from the support library, so be sure to choose
    the support library version when prompted for the import library. We''ll need
    two layout files - one for each fragment - along with two fragment classes. Here
    are the steps in detail:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示处理 Fragment 返回栈，我们将创建两个带有 Next 按钮的 Fragment 来创建返回栈。有了这个设置，我们将实现 `onBackPressed()`
    回调，当用户到达顶部 Fragment 时退出应用。我们将使用支持库中的 Fragment Manager，所以当提示导入库时，请确保选择支持库版本。我们需要两个布局文件——每个
    Fragment 一个——以及两个 Fragment 类。以下是详细步骤：
- en: 'Create a new layout file called `fragment_one.xml` with the following XML:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的布局文件 `fragment_one.xml`，其 XML 如下：
- en: '[PRE33]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Create the second fragment layout file called `fragment_two.xml` with the same
    XML as above, changing the following text property:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个 Fragment 布局文件 `fragment_two.xml`，其 XML 与上面相同，但更改以下文本属性：
- en: '[PRE34]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'With the layout files created, it''s time to create the classes for the fragments.
    Create a new Java class called `FragmentOne.java` with the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建布局文件后，是时候创建片段的类了。创建一个新的 Java 类 `FragmentOne.java`，代码如下：
- en: '[PRE35]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Create the second Java class called `FragmentTwo` with the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建第二个名为 `FragmentTwo` 的 Java 类，代码如下：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now we need to add a container and a button to the Main Activity layout. Change `activity_main.xml` as
    follows:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将容器和按钮添加到 MainActivity 布局中。按如下方式更改 `activity_main.xml`：
- en: '[PRE37]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'With the Fragments created and the container added to the layout, we are now
    ready to write the code to manipulate the Fragments. Open `MainActivity.java` and
    add the following code below the class constructor:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建 Fragment 并将容器添加到布局后，我们现在可以编写操作 Fragment 的代码。打开 `MainActivity.java` 并在类构造函数下方添加以下代码：
- en: '[PRE38]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Add the following code to the existing `onCreate() `method, below `setContentView()`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 方法中，在 `setContentView()` 下方：
- en: '[PRE39]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The last method to implement is the `onBackPressed()` callback:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要实现的方法是 `onBackPressed()` 回调：
- en: '[PRE40]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run the program on a device or emulator.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备或模拟器上运行程序。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the steps are similar to the *Adding and removing Fragments during runtime *recipe
    discussed previously, until step 8\. The first seven steps just set up the app
    to create the fragments for our demonstration. In step 8, we implement the `onBackPressed()`
    callback. This is where we code for our specific situation. For this sample, all
    we need to do is make the Next button visible again.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数步骤与之前讨论的 *在运行时添加和删除 Fragment 的食谱* 相似，直到第 8 步。前七步只是设置应用以创建用于演示的 Fragment。在第
    8 步中，我们实现了 `onBackPressed()` 回调。这就是我们为特定情况编写代码的地方。对于这个示例，我们只需要再次使 Next 按钮可见。
- en: There's more...
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'With the basics covered for handling the back stack, it''s time to discuss
    the other callback: `onBackStackChanged()`. This is where you can implement custom
    behavior when the stack changes. One common example is changing the Home icon
    to a back arrow. We get this behavior automatically with an Activity when we set
    the parent property (in AndroidManifest), but Android doesn''t do this for fragments.
    What if we wanted to have a back arrow on `FragmentTwo`? Add this line of code
    to the NextButton `onClick()`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理返回栈的基本知识覆盖后，现在是时候讨论另一个回调：`onBackStackChanged()`。这是您可以在栈发生变化时实现自定义行为的地方。一个常见的例子是将主页图标更改为返回箭头。当我们设置父属性（在
    AndroidManifest 中）时，我们自动获得 Activity 的这种行为，但 Android 并不会为 Fragment 做这件事。如果我们想在
    `FragmentTwo` 上有一个返回箭头，请将此行代码添加到 NextButton 的 `onClick()` 中：
- en: '[PRE41]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: If you run the app now, you'll see the back arrow when you go to `FragmentTwo`.
    The problem is, the back arrow doesn't actually do anything. The next problem
    you may notice is that if you use the back key, you still see the back arrow when
    you return to `FragmentOne`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用，当你进入`FragmentTwo`时，你会看到返回箭头。问题是，返回箭头实际上并没有做任何事情。你可能注意到的下一个问题是，如果你使用返回键，当你返回到`FragmentOne`时，你仍然会看到返回箭头。
- en: 'To make the back arrow work, add the following code to `MainActivity`:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使返回箭头生效，将以下代码添加到`MainActivity`中：
- en: '[PRE42]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Now the app will respond to the back arrow and treat it the same as the back
    key. What about the second issue? The Home icon still shows the back arrow. This
    is where we can use the `onBackStackChanged()` callback. Instead of modifying
    the NextButton `onClick()` as we did earlier, we can put all our code in `onBackStackChanged()`.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在应用将响应返回箭头，并将其与返回键同等对待。那么第二个问题呢？主页图标仍然显示返回箭头。这就是我们可以使用`onBackStackChanged()`回调的地方。我们不需要像之前那样修改NextButton的`onClick()`方法，我们可以将所有代码放入`onBackStackChanged()`中。
- en: 'To do this, we need to implement the `OnBackStackChangedListener` interface
    in the class definition. Change the `MainActivity` declaration as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这个功能，我们需要在类定义中实现`OnBackStackChangedListener`接口。将`MainActivity`的声明修改如下：
- en: '[PRE43]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Then add this line to the `onCreate()` method (below `setContentView()`) to
    add the listener:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后将此行代码添加到`onCreate()`方法中（在`setContentView()`下方）以添加监听器：
- en: '[PRE44]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Now we can implement the `onBackStackChanged()` callback:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以实现`onBackStackChanged()`回调函数：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Now when you run the app, you'll see the back arrow when you go to `FragmentTwo`.
    You can press the back arrow icon or use the back key to return to the first screen.
    Thanks to the `onBackStackChanged()` callback, you won't see the back arrow when
    you're on `FragmentOne`.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在当你运行应用并进入`FragmentTwo`时，你会看到返回箭头。你可以点击返回箭头图标或使用返回键返回到第一个屏幕。多亏了`onBackStackChanged()`回调，当你处于`FragmentOne`时，你不会看到返回箭头。
