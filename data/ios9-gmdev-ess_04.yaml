- en: Chapter 3. SpriteKit and 2D Game Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：SpriteKit和2D游戏设计
- en: Now that we understand the basics of coding in Swift, the generic flow and class
    structure of an iOS app, as well as the optional structuring of apps with storyboards
    and segues, we can move on to transforming our apps into playable games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了Swift编程的基础知识，iOS应用的通用流程和类结构，以及使用故事板和切换的app的可选结构，我们可以继续将我们的应用转换为可玩的游戏。
- en: For this chapter, we will begin with the 2D game design and game development
    framework created exclusively by Apple for iOS game developers known as SpriteKit.
    SpriteKit first became available with iOS 7 to help simplify the game development
    process for the family of iOS devices. The framework runs a typical rendering
    loop to draw and update 2D objects/sprites to your game's scene. There's much
    going on behind the scenes to run this loop and draw your game sprites. Thankfully,
    Apple built the first party game development frameworks to do much of the heavy
    lifting for us. This way, we can focus more on making the game itself without
    worrying too much about how that game will connect and run with the hardware,
    something developers in the past had to contend with.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将从苹果专为iOS游戏开发者创建的2D游戏设计和游戏开发框架开始，这个框架被称为SpriteKit。SpriteKit首次在iOS 7中可用，旨在简化iOS设备系列的游戏开发过程。该框架运行一个典型的渲染循环，用于绘制和更新2D对象/精灵到游戏场景中。在幕后有很多事情在进行，以运行这个循环并绘制游戏精灵。幸运的是，苹果构建了第一方游戏开发框架，为我们做了很多繁重的工作。这样，我们可以更多地专注于制作游戏本身，而不必过多担心游戏如何与硬件连接和运行，这是过去开发者必须应对的问题。
- en: Every update of iOS and Xcode continues to add more tools and frameworks to
    improve the ease of game design, including the companion framework introduced
    first at *WWDC15* for iOS 9 known as **GameplayKit**. GameplayKit can allow us
    to separate, copy, and modularize the game logic and even copy for use in future
    game projects, be it SpriteKit or the 3D framework of our next chapter, SceneKit.
    We will go over GameplayKit in later chapters as well. At the end of this chapter,
    we will look at a complete game example that is for a simple game in its gameplay
    but somewhat complex in its logic.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 每次iOS和Xcode的更新都在继续添加更多工具和框架，以改善游戏设计的便捷性，包括在*WWDC15*上首次引入的iOS 9配套框架，称为**GameplayKit**。GameplayKit可以让我们分离、复制和模块化游戏逻辑，甚至可以复制用于未来游戏项目，无论是SpriteKit还是我们下一章的3D框架SceneKit。我们将在后面的章节中详细介绍GameplayKit。在本章结束时，我们将查看一个完整的游戏示例，其游戏玩法简单，但逻辑相对复杂。
- en: A brief history of iOS game development engines
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS游戏开发引擎简史
- en: SpriteKit and the 3D game framework, SceneKit, were not the first methods used
    for developing games in iOS. We'll quickly see why it became a welcomed addition
    to the developer toolset. Initially, we, the game developers, had to practically
    talk directly with the GPU using the OpenGL API to put both 2D and 3D graphics/vertices
    on to the screen. On the upper level, there always was Foundation and CocoaTouch
    to interact with user gestures to manipulate UIKit objects, but dealing with game
    development essentials, such as SpriteSheets, mipmaps, normal maps, partial emitters,
    bounding boxes, and culling, involved some level of lower-level structuring. Apple
    made those calls to various graphics buffers and VBOs slightly easier when they
    created their GLKit framework in 2011\. Thankfully, various third-party frameworks,
    such as Cocos2D, Box2D, Sparrow, GameMaker, Unity, Unreal Engine, and others made
    this process less engineering-intensive in an effort to keep the *design* aspect
    of game design the focus. GameMaker, Unity, and Unreal Engine are more sandboxing-
    / drag-and-drop-styled engines akin to the mentality behind storyboards and segues,
    while engines such as Cocos2D and Sparrow are more code-heavy / boilerplate OOP
    structures that shortcut the initial coding buildup. Engines such as Unity and
    Unreal Engine are great in that they offer a more hands-on sandboxing-type environment
    with various features that simplify the MVC model. Some drawbacks to such engines
    are that they are sometimes closed source, usually cost money to utilize to their
    fullest and aren't device-specific (Unity particularly falls into this category).
    Working with these visual engines could sometimes lead to optimizations being
    required in platform-specific IDEs such as Xcode, due to a sometimes *one-size-fits-all*
    methodology. Apple's SpriteKit and the 3D API, SceneKit which we'll see later,
    give us a first-party platform-specific middle ground that grants the developer
    both upper-level API editing, but even lower-level graphic API (OpenGL/Metal)
    customizations.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 和 3D 游戏框架 SceneKit 并非是 iOS 开发游戏时最初使用的方法。我们将很快看到为什么它们成为了开发者工具集受欢迎的补充。最初，我们，即游戏开发者，必须实际上直接使用
    OpenGL API 与 GPU 通信，以便将 2D 和 3D 图形/顶点放置到屏幕上。在更高层次上，始终有 Foundation 和 CocoaTouch
    与用户手势交互，以操作 UIKit 对象，但处理游戏开发的基本要素，如 SpriteSheets、mipmap、法线贴图、部分发射器、边界框和剔除，涉及到一定程度的底层结构。当苹果公司在
    2011 年创建了他们的 GLKit 框架时，他们使这些对各种图形缓冲区和 VBO 的调用稍微容易了一些。幸运的是，各种第三方框架，如 Cocos2D、Box2D、Sparrow、GameMaker、Unity、Unreal
    Engine 等，通过努力保持游戏设计中的 *设计* 方面作为重点，使得这个过程不那么具有工程密集性。GameMaker、Unity 和 Unreal Engine
    是更类似沙盒/拖放风格的引擎，类似于故事板和转场背后的思维模式，而像 Cocos2D 和 Sparrow 这样的引擎则更侧重于代码/样板 OOP 结构，从而简化了初始编码构建。Unity
    和 Unreal Engine 等引擎很棒，因为它们提供了一个更上手型的沙盒环境，具有简化 MVC 模型的各种功能。这些引擎的一些缺点是它们有时是闭源的，通常需要付费才能充分利用，并且不是针对特定设备的（Unity
    尤其属于这一类别）。与这些视觉引擎一起工作有时可能导致在平台特定的 IDE（如 Xcode）中需要进行优化，因为有时采用了一种 *一刀切* 的方法。苹果的
    SpriteKit 和我们稍后将要看到的 3D API SceneKit 提供了一个第一方平台特定的中间地带，它为开发者提供了高级 API 编辑，甚至还有底层图形
    API（OpenGL/Metal）的定制化。
- en: Note
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The negatives to sandbox/drag-and-drop-styled engines have decreased over time.
    Engines used by AAA studios, such as Unreal Engine, Unity, Havok, and others have
    lessened their upper-level ambiguity between the API and targeted devices' lower-level
    code. A good example of this would be Unity's IL2CPP, which converts the upper-level
    API calls directly to fast device-specific C++ code. This includes code and graphics
    pipeline optimizations that make use of Apple's slim Metal API. This homogenization
    of upper level applications with traditional boilerplate code now allows developers
    from all skill levels to make amazing games. That is why from iOS 8, iOS 9, and
    onwards, the Apple game development frameworks adopted a more visual design methodology.
    Xcode 7 introduced game state machines, components, and the ability to edit/copy
    and reuse player actions and animations throughout your projects. This allows
    developers to work specifically in iOS/Xcode while utilizing the visual design
    benefits of the device-independent game engines.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，沙盒/拖放式引擎的缺点已经减少。AAA工作室使用的引擎，如Unreal Engine、Unity、Havok等，已经减少了API与目标设备底层代码之间的上层模糊性。一个很好的例子是Unity的IL2CPP，它将上层的API调用直接转换为快速的设备特定C++代码。这包括利用苹果的精简Metal
    API的代码和图形管道优化。这种将上层应用程序与传统样板代码同质化的方法现在允许所有技能水平的开发者制作出惊人的游戏。这就是为什么从iOS 8、iOS 9开始，苹果的游戏开发框架采用了更直观的设计方法。Xcode
    7引入了游戏状态机、组件，以及在整个项目中编辑/复制和重用玩家动作和动画的能力。这允许开发者专门在iOS/Xcode上工作，同时利用设备无关的游戏引擎的视觉设计优势。
- en: For this chapter, we will learn how to make a tile puzzle game named `SwiftSweeper`
    using the SpriteKit framework and with a more traditional boilerplate code method.
    This means that we will make our first demo game in a code-heavy / model-centric
    fashion. Not only will this give us a look into the inner workings of SpriteKit's
    code but it will also let us utilize more from the Swift programming language
    from [Chapter 1](part0014_split_000.html#DB7S1-d06b23b4a4554b3182353558917969c2
    "Chapter 1. The Swift Programming Language"), *The Swift Programming Language*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将学习如何使用SpriteKit框架和更传统的样板代码方法制作一个名为`SwiftSweeper`的拼图游戏。这意味着我们将以代码密集/模型为中心的方式制作我们的第一个演示游戏。这不仅让我们了解了SpriteKit代码的内部工作原理，还让我们能够从[第1章](part0014_split_000.html#DB7S1-d06b23b4a4554b3182353558917969c2
    "第1章。Swift编程语言")《Swift编程语言》中更多地利用Swift编程语言。
- en: We will conclude this chapter by briefly mentioning Apple's latest SpriteKit
    demo game, DemoBots, which utilizes more of the visual tools/frameworks from Xcode
    7 and later. Seeing the more code-intensive method first though will later let
    us appreciate the time saved with these newer tools.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过简要提及苹果最新的SpriteKit演示游戏DemoBots来结束本章，它利用了Xcode 7及以后的更多视觉工具/框架。然而，首先看到更密集的代码方法将使我们能够欣赏这些新工具节省的时间。
- en: Apple has gone out of their way to mimic the visual design methodology to game
    design seen in other engines since game design is as much about code/logic as
    it is about art and design.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果为了模仿其他引擎中看到的游戏设计视觉设计方法，不遗余力，因为游戏设计在代码/逻辑方面与艺术和设计一样重要。
- en: The game loop
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏循环
- en: The game loop is a game developer's roadmap. The names differ depending on the
    framework and platform, but the same rules apply. The game loop comprises of all
    the methods, physics updates, and draw calls that occur during a single frame
    of your game and their order of execution. The golden rule to game development
    is to try to keep this loop always spinning in full iterations at no slower than
    16.6 milliseconds, or 60 frames per second.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环是游戏开发者的路线图。名称根据框架和平台而异，但规则是相同的。游戏循环包括在游戏的单个帧中发生的所有方法、物理更新和绘制调用，以及它们的执行顺序。游戏开发的黄金法则是在不超过16.6毫秒，即每秒60帧的速度下，始终以完整迭代的方式运行这个循环。
- en: There are aspects of the game loop that don't have to be controlled by the game
    developer as much as they used to be in the past, though we do have the option
    to work down to the very GPU calls using OpenGL, or even better, Apple's Metal
    API. We will discuss more on these topics later on.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏循环的一些方面不需要像过去那样由游戏开发者控制，尽管我们仍然有选择使用OpenGL或更好的苹果Metal API直接进行GPU调用的选项。我们将在稍后讨论这些话题。
- en: 'Here is what the SpriteKit game loop looks like:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是SpriteKit游戏循环的样子：
- en: '![The game loop](img/00020.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环](img/00020.jpeg)'
- en: The preceding is an illustration given to us directly from the Apple Developer
    site. We see a number of functions that are called during a single frame. The
    first function iterated through is `update()`. The `update()` function is where
    we add most of our own game-specific updates and various checks on game objects
    (such as positions and character statuses).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 上述内容是直接从苹果开发者网站上给出的示例。我们看到在单个帧中调用了许多函数。首先迭代的是`update()`函数。`update()`函数是我们添加大部分游戏特定更新和游戏对象（如位置和角色状态）的各种检查的地方。
- en: The loop structure gives us the option to do updates after we know a certain
    set of tasks in the frame have happened, that's where `didEvaluateActions()`,
    `didSimulatePhysics()`, `didApplyConstraints()`, and `didFinishUpdate()` functions
    come in handy.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 循环结构让我们有机会在知道帧中某些任务已经发生后进行更新，这就是`didEvaluateActions()`、`didSimulatePhysics()`、`didApplyConstraints()`和`didFinishUpdate()`函数派上用场的地方。
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Anyone coming from Unity might be familiar with its general game loop functions,
    such as `Awake()`, `Start()`, `FixedUpdate()`, `update()`, and `LateUpdate()`.
    The SpriteKit game loop allows some similar code/render flow, but as we'll see,
    there are some slight differences.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Unity的任何人可能对其通用的游戏循环函数很熟悉，例如`Awake()`、`Start()`、`FixedUpdate()`、`update()`和`LateUpdate()`。SpriteKit游戏循环允许一些类似的代码/渲染流程，但正如我们将看到的，有一些细微的差别。
- en: For more on the game loop and its functions, see the following link from the
    Apple documentation at [https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 关于游戏循环及其函数的更多信息，请参阅苹果文档中的以下链接：[https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html](https://developer.apple.com/library/ios/documentation/GraphicsAnimation/Conceptual/SpriteKit_PG/Actions/Actions.html)。
- en: Utilizing the other game loop methods could make sure certain calls in your
    game don't go out of order and can even help with the important task of making
    the most out of each frame in a fast, efficient manner.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 利用其他游戏循环方法可以确保你的游戏中某些调用不会出错，甚至可以帮助以快速、高效的方式完成每个帧的重要任务。
- en: 'For instance, in the public game PikiPop, mentioned previously, here''s how
    the game uses the game loop in its main `GameScene.swift` code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在之前提到的公共游戏PikiPop中，以下是游戏如何在主`GameScene.swift`代码中使用游戏循环的方式：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding code first checks whether the player is playable with the `isPlayable`
    Boolean. This status can mean a number of things, like if the player is alive
    or not, is spawning, and so on. The game loop's `update()` function, which is
    being overridden from its parent `update()` function of the `SKScene` object,
    takes a parameter of the time utility type `CFTimeInterval`. `CFTimeInterval`
    is a special Core Foundation double type that measures time in seconds and thus
    updates the player object (if not null) during each interval.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码首先检查玩家是否可玩，使用的是`isPlayable`布尔值。这种状态可以意味着许多事情，比如玩家是否存活，是否在生成，等等。游戏循环的`update()`函数，它覆盖了`SKScene`对象的父`update()`函数，接受一个时间实用类型`CFTimeInterval`的参数。`CFTimeInterval`是一种特殊的Core
    Foundation双精度类型，以秒为单位测量时间，因此在每个间隔期间更新玩家对象（如果非空）。
- en: As a brief summary of PikiPop, it's a procedural 2D side-scrolling game somewhat
    similar to the game Flappy Bird. Unlike Flappy Bird, Piki is able to traverse
    the game in all directions based on player taps and swipes. Piki could get trapped
    between the stage objects and the edge of the stage.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 作为PikiPop的简要总结，它是一个类似于Flappy Bird的程序化2D横版滚动游戏。与Flappy Bird不同，Piki可以根据玩家的点击和滑动在所有方向上穿越游戏。Piki可能会被困在舞台对象和舞台边缘之间。
- en: '![The game loop](img/00021.jpeg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![游戏循环](img/00021.jpeg)'
- en: The preceding image is Piki getting injured if pushed into the left-hand side
    of the screen.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像显示了Piki如果被推到屏幕的左侧，会受到伤害。
- en: Edges in that game's stages use SpriteKit's own special objects named **SKConstraints**.
    More on these later, but in short, they dictate the range and orientation SpriteKit
    sprites can take. Sprites in SpriteKit (both developer-defined objects, such as
    PikiPop's Player object and the default `SKSpriteNode`) are all derived from `SKNode`
    objects that work with `SKConstraints` and other physics-based framework functionality.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 该游戏阶段中的边缘使用的是SpriteKit自己的特殊对象，名为**SKConstraints**。关于这些内容的更多介绍将在后面提供，但简而言之，它们决定了SpriteKit精灵可以采取的范围和方向。SpriteKit中的精灵（包括开发者定义的对象，如PikiPop的玩家对象和默认的`SKSpriteNode`）都是来自`SKNode`对象，这些对象与`SKConstraints`和其他基于物理框架的功能一起工作。
- en: 'We could check whether Piki is being pushed against the corner in the `update()`
    part of the game loop, but since constraints are part of the framework''s physics
    architecture, it''s best to do this check during the `didSimulatePhysics()` portion
    of the render loop of `SKScene` as seen here:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在游戏循环的 `update()` 部分检查 Piki 是否被推到角落，但由于约束是框架物理架构的一部分，最好在 `SKScene` 渲染循环的
    `didSimulatePhysics()` 部分进行此检查，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The first part of this code, `let block: (SKNode!, UnsafeMutablePointer<ObjCBool>)
    -> Void = { node, stop in`, is done in what''s known as a **block** or a **closure**
    syntax, which Swift lets us do rather dynamically. Don''t mind the details of
    this kind of code for the moment; just note that we check the player''s position
    in *x* versus the edge of the window''s frame in this portion of the game loop.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '这段代码的第一部分，`let block: (SKNode!, UnsafeMutablePointer<ObjCBool>) -> Void = {
    node, stop in`，使用的是所谓的**块**或**闭包**语法，Swift 允许我们以相当动态的方式使用它。目前不必关心这类代码的细节；只需注意，在这一部分的游戏循环中，我们检查玩家的位置在
    *x* 方向上与窗口框架边缘的位置。'
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Here''s more information on writing blocks/closures in Swift:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是关于在 Swift 中编写块/闭包的更多信息：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html](https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Closures.html)'
- en: Tile game – SwiftSweeper
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Tile game – SwiftSweeper
- en: Time to stop talking about SpriteKit and get right into it! As stated at the
    beginning of this chapter, we will first show you how to make a simple-looking
    tile game in SpriteKit using the slightly more difficult boilerplate/code-drive-styled
    design. Don't worry, this is not going to involve direct calls to the GPU with
    C++ and handling extremely tiny memory requirements like veteran game developers
    did during the early console days. However, we will be using lots of code-heavy
    calls with SpriteKit objects, functions, and classes. Granted, getting down into
    the code directly is continually becoming less of the developer's responsibility
    as Apple continues to make more design-centric functionalities in Xcode.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候停止谈论 SpriteKit 了，让我们直接进入正题！正如本章开头所述，我们将首先向您展示如何使用稍微复杂一些的样板/代码驱动式设计在 SpriteKit
    中制作一个看起来简单的瓦片游戏。不用担心，这不会涉及到像早期控制台游戏开发者那样直接调用 GPU 和处理极小的内存需求。然而，我们将使用大量的与 SpriteKit
    对象、函数和类相关的代码调用。诚然，随着 Apple 继续在 Xcode 中提供更多以设计为中心的功能，直接编写代码的开发者责任正在逐渐减少。
- en: Knowing the code structure can give you an edge over developers coming in on
    a more top-down methodology and coding will always be behind custom game logic.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 了解代码结构可以让你在采用更自上而下的方法进入的开发者中占据优势，并且编写代码始终会落后于自定义游戏逻辑。
- en: '![Tile game – SwiftSweeper](img/00022.jpeg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![Tile game – SwiftSweeper](img/00022.jpeg)'
- en: What is SwiftSweeper?
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SwiftSweeper 是什么？
- en: '`SwiftSweeper` is a clone of the classic tile puzzle game, MineSweeper, written
    entirely in Swift. `SwiftSweeper` makes use of Swift''s ability to use Unicode
    emoticons so that we don''t have to use many image assets and should give us a
    great starting point to making our own tile/puzzler game with difficulty levels.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`SwiftSweeper` 是一个完全用 Swift 编写的经典瓦片拼图游戏 MineSweeper 的克隆版。`SwiftSweeper` 利用
    Swift 使用 Unicode 表情符号的能力，这样我们就不需要使用许多图像资源，这应该为我们制作自己的具有难度级别的瓦片/拼图游戏提供一个很好的起点。'
- en: We will build up much of the game from scratch, but the full source code can
    be found at [https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从零开始构建大部分游戏，但完整的源代码可以在[https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper)找到。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As at the time writing of this book, this was built in Xcode 7 Beta (7A120f)
    for the initial iOS 9 release and optimized for iPhone.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书撰写时，这是在 Xcode 7 测试版（7A120f）中构建的，针对最初的 iOS 9 版本进行了优化，并针对 iPhone 进行了优化。
- en: The goal of the game is to tap every tile on the game board without hitting
    mines hidden throughout the board. You do get some help though. Every tile that
    isn't a mine will tell the player how many tiles around it are mines. If the player
    knows that a tile without a doubt is a mine via the process of elimination, they
    can plant a flag on that tile to make sure that they don't tap that space. Tap
    all of the tiles that aren't a mine to win the game! `SwiftSweeper` even saves
    the time it took you to win for each difficulty level you chose to give the game
    a bit of replay value.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的目标是在不碰到隐藏在游戏板上的地雷的情况下点击游戏板上的每一个方块。不过，你也会得到一些帮助。不是地雷的每一个方块都会告诉玩家周围有多少个地雷。如果玩家通过排除法确定某个方块肯定有地雷，他们可以在该方块上插上旗帜，以确保不会点击那个空间。点击所有不是地雷的方块以赢得游戏！`SwiftSweeper`甚至还会保存你赢得每个难度级别所需的时间，为游戏增添一些可玩性。
- en: Creating our SpriteKit game
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的SpriteKit游戏
- en: 'Now that we know the goal of our game, here''s how we go about building it
    in SpriteKit:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经知道了游戏的目标，以下是我们在SpriteKit中构建游戏的方法：
- en: First, open Xcode and create a new project.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开Xcode并创建一个新项目。
- en: Now select the Game template and click on **Next**.![Creating our SpriteKit
    game](img/00023.jpeg)
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择游戏模板，并点击**下一步**。![创建我们的SpriteKit游戏](img/00023.jpeg)
- en: Next, fill in the product name. We will name this project `SwiftSweeperExample`
    and make sure that the language is Swift with **SpriteKit** selected as the game
    technology as well as the devices set to iPhone.![Creating our SpriteKit game](img/00024.jpeg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写产品名称。我们将把这个项目命名为`SwiftSweeperExample`，并确保语言设置为Swift，同时将游戏技术选为**SpriteKit**，并将设备设置为iPhone。![创建我们的SpriteKit游戏](img/00024.jpeg)
- en: Then, click on **Next**, and we now have a brand new SpriteKit game project
    with a number of files already written up for us to get us started.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**下一步**，我们现在有一个全新的SpriteKit游戏项目，其中已经为我们准备好了许多文件，以便我们开始。
- en: Now click on the project's main file in the navigation pane and deselect all
    but the **Portrait** selection in the **Device Orientation** field.![Creating
    our SpriteKit game](img/00025.jpeg)
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在点击导航面板中的项目主文件，并在**设备方向**字段中取消选择除了**纵向**以外的所有选项。![创建我们的SpriteKit游戏](img/00025.jpeg)
- en: Since we are going to work mostly with code, we can also either ignore or delete
    the `GameScene.sks` file for now. These files are Xcode's option for you to visually
    design your game scene. We will know more on these files later when we work with
    our more visually designed SpriteKit game example.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们主要会使用代码，我们可以暂时忽略或删除`GameScene.sks`文件。这些文件是Xcode为你提供的用于视觉设计游戏场景的选项。当我们使用更具有视觉设计的SpriteKit游戏示例工作时，我们将对这类文件有更深入的了解。
- en: Build and run the app to see Apple's default SpriteKit project, which has `Hello
    World` written in Chalkduster font and a rotating spaceship appears where you
    click or tap on the screen.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建并运行应用程序，以查看Apple的默认SpriteKit项目，其中以Chalkduster字体写着“Hello World”，并在您点击或触摸屏幕的地方出现一个旋转的宇宙飞船。
- en: An overview of the SpriteKit structure and objects
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SpriteKit结构和对象的概述
- en: Before we add our code, let's use this template to get an idea on how SpriteKit's
    basic objects, functions, and flow work.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们添加代码之前，让我们使用这个模板来了解SpriteKit的基本对象、函数和流程。
- en: 'As we stated in the previous chapter, `AppDelegate.swift` is the main entry
    point. The code then moves to `GameViewController.swift`, which is a child of
    the `UIViewController` class that imports the SpriteKit framework. The following
    code is written in the `viewDidLoad()` function of `GameViewController`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中所述，`AppDelegate.swift`是主入口点。代码随后移动到`GameViewController.swift`，它是`UIViewController`类的一个子类，并导入了SpriteKit框架。以下代码是在`GameViewController`的`viewDidLoad()`函数中编写的：
- en: '[PRE2]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-58
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在[http://www.packtpub.com](http://www.packtpub.com)的账户下载示例代码文件，以获取您购买的所有Packt
    Publishing书籍的示例代码。如果您在其他地方购买了这本书，您可以访问[http://www.packtpub.com/support](http://www.packtpub.com/support)并注册，以便将文件直接通过电子邮件发送给您。
- en: Using the keyword `override`, this version of `viewDidLoad()` can now either
    add to or well override the parent class's functionality. `super.viewDidLoad()`
    calls the parent class's original functionality and then it works its own custom
    functionality. This is how Swift handles the OOP concept of inheritance.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关键字`override`，这个版本的`viewDidLoad()`现在可以添加到或完全覆盖父类的功能。`super.viewDidLoad()`调用父类的原始功能，然后执行它自己的自定义功能。这就是Swift处理面向对象继承概念的方式。
- en: 'Next, we see how a game scene is first created with `GameViewController`. A
    major aspect of SpriteKit is that it works in scenes that are members of the `SKScene`
    class, which are themselves children of the `SKNode` class. The `SKNode` classes
    are the main building blocks of nearly every object in SpriteKit. Be it sprites,
    lights, videos, effects, physics fields, audio files (`SKAudioNodes`), cameras
    (`SKCameraNodes`), or labels/UI objects, they are `SKNode` classes. These objects
    all hold important information, most importantly coordinate information of object''s
    node family. For games, this allows the developer to create custom classes, such
    as `Enemies`, `GameLights`, `Tiles`, and so on, that all have screen and other
    information on both parent and child nodes. For example, we can hit every enemy
    on the screen with an attack by the player by calling an inherited function in
    a parent `Enemy` class. We don''t need to check for each individual type of enemy
    but instead enumerate through the parent nodes in the various game loop functions
    of `SKScene`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到如何使用`GameViewController`首先创建游戏场景。SpriteKit的一个主要方面是它在`SKScene`类的场景上工作，这些场景本身是`SKNode`类的子类。`SKNode`类是SpriteKit中几乎所有对象的主体构建块。无论是精灵、灯光、视频、效果、物理场、音频文件（`SKAudioNodes`）、相机（`SKCameraNodes`）还是标签/UI对象，它们都是`SKNode`类。这些对象都持有重要信息，最重要的是对象节点家族的坐标信息。对于游戏，这允许开发者创建自定义类，例如`Enemies`、`GameLights`、`Tiles`等，这些类在父节点和子节点上都有屏幕和其他信息。例如，我们可以通过在父`Enemy`类中调用继承的功能来攻击屏幕上的每个敌人。我们不需要检查每个单独的敌人类型，而是通过在`SKScene`的各种游戏循环函数中遍历父节点来枚举：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Do you remember the block/closure call in PikiPop? To actually use it in the
    `didSimulatePhysics()` function of `SKScene`, we call the `enumerateChildNodesWithName`
    function of `SKNode` to target only those nodes in the scene and have that block
    of code run for each member in the scene with that name.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得PikiPop中的块/闭包调用吗？为了在`SKScene`的`didSimulatePhysics()`函数中实际使用它，我们调用`SKNode`的`enumerateChildNodesWithName`函数来仅针对场景中的那些节点，并让该代码块为场景中具有该名称的每个成员运行。
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The name is simply a *string* that can be set using the `SKNode.name` property.
    Have every custom node initiate with a given name (or change during game play),
    and you have a whole group of objects you can single out in the scene.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 名称只是一个可以用`SKNode.name`属性设置的**字符串**。让每个自定义节点以一个给定的名称（或在游戏过程中更改），你就有了一组可以在场景中单独识别的对象。
- en: You can find more on `SKNode` in Apple's official documentation at [https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在Apple的官方文档中找到更多关于`SKNode`的信息，链接为[https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKNode_Ref/)。
- en: Scene transitions and the choice of code, storyboards, and/or SKS files
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景过渡和代码、故事板以及/或SKS文件的选择
- en: The `GameScene.swift` class in our project inherits from `SKScene`, and it is
    there that the game loop / rendering functions we mentioned earlier occur. SpriteKit
    runs on scenes, and scenes can be transitioned and segued to and from it.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们项目中的`GameScene.swift`类继承自`SKScene`，游戏循环/渲染函数就是在这里发生的。SpriteKit在场景上运行，并且可以从场景中过渡和跳转。
- en: In the previous chapter, we showed how to structure a game using storyboards
    and segues. `SKScene` makes it where you don't even have to use storyboards but
    just straight code to transition. We can use storyboards, and we can also visually
    design each individual scene using `.sks` files or a combination of all three
    methods. With code, `SKScene` can transition with the `SKTransition` objects and
    functions. Actually, as we'll see with `SwiftSweeper`, we can just use code to
    manually refresh assets in the scene to do *transitions*. This method is rather
    old fashioned and not as elegant as `SKTransition` storyboards and SKS files,
    so let's take a quick look at how to transition scenes in code with `SKTransition`,
    storyboards, and briefly into SKS files via code. Later, and in the next chapter,
    we will focus much more on the visual SKS files since every update to iOS and
    Xcode continues to put the focus on these visual tools to shorten the coding time
    and workflow.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们展示了如何使用故事板和切换来构建游戏。`SKScene` 使得你甚至不需要使用故事板，只需直接使用代码进行切换。我们可以使用故事板，也可以使用
    `.sks` 文件或三种方法的组合来视觉设计每个单独的场景。使用代码，`SKScene` 可以通过 `SKTransition` 对象和函数进行切换。实际上，正如我们将通过
    `SwiftSweeper` 看到的，我们只需使用代码手动刷新场景中的资源来执行 *切换*。这种方法相当过时，并且不如 `SKTransition` 故事板和
    SKS 文件优雅，所以让我们快速了解一下如何使用 `SKTransition`、故事板以及通过代码简要地进入 SKS 文件进行场景切换。稍后，在下一章中，我们将更多地关注视觉
    SKS 文件，因为每次 iOS 和 Xcode 的更新都会继续关注这些视觉工具，以缩短编码时间和工作流程。
- en: An SKTransition example
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 SKTransition 示例
- en: 'The following code changes the game''s scene:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码更改了游戏的场景：
- en: '[PRE5]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `SKTransition` classes are really just types of segues. As in the preceding
    code, the transition is a directional switch to the next scene with the `SKTransitionDirection.Up`
    enumerator type. As we saw in `GameViewController`, the new scene is created with
    the similar functions that control the scene''s view size and aspect ratio and
    then presents that scene to the unwrapped view with `self.scene!.view!.presentScene(scene,
    transition: transition)`.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKTransition` 类实际上只是切换类型。正如前面的代码所示，切换是一个使用 `SKTransitionDirection.Up` 枚举类型的方向性切换到下一个场景。正如我们在
    `GameViewController` 中看到的，新场景是通过控制场景视图大小和宽高比的类似函数创建的，然后使用 `self.scene!.view!.presentScene(scene,
    transition: transition)` 将场景展示给未包装的视图。'
- en: 'Also note that this takes place in the same function as we see in our current
    project''s `GameScene.swift` class, `override func touchesBegan(touches: Set<UITouch>,
    withEvent event: UIEvent?){}`. This is the function that handles touch gestures
    from the player and checks whether the name of the node touched matches the `SceneChangeButton`
    string.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '还要注意，这个过程发生在与我们在当前项目中的 `GameScene.swift` 类中看到相同的函数中，即 `override func touchesBegan(touches:
    Set<UITouch>, withEvent event: UIEvent?){}`。这是处理玩家触摸手势并检查触摸的节点名称是否与 `SceneChangeButton`
    字符串匹配的函数。'
- en: 'More on `SKTransition` and other neat transition effects you can give your
    games can be found here in the official documentation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 `SKTransition` 以及你可以为你的游戏提供的其他精美切换效果，可以在官方文档中找到：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/)'
- en: Note
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'As of Swift 2.0 / iOS 9, this touch delegate function takes in a parameter
    that is a set of `UITouches` via `touches: Set<UITouch>` and an optional `UIEvent`.
    This is a change from past Swift iterations and could change in future updates.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '截至 Swift 2.0 / iOS 9，此触摸代理函数通过 `touches: Set<UITouch>` 接收一个参数，它是一组 `UITouches`，以及一个可选的
    `UIEvent`。这与之前的 Swift 迭代不同，并且可能会在未来更新中发生变化。'
- en: A SKScene/storyboard example
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一个 SKScene/Storyboard 示例
- en: 'Here''s the code for a `SKScene`/storyboard example:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个 `SKScene`/Storyboard 示例的代码：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As we saw in the previous chapter, using the visual help of storyboard files
    can give us great visual road maps to our apps, both game and non-game. The preceding
    code uses a link to an `@IBAction` linkage on a storyboard file to set a new scene.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中看到的，使用故事板文件的视觉帮助可以为我们提供通往我们应用程序的视觉路线图，无论是游戏还是非游戏。前面的代码使用一个链接到故事板文件中的
    `@IBAction` 链接来设置一个新的场景。
- en: Storyboards in games can be great for the prototyping phase when we know just
    the general structure of our game, and can be perfect for the game's menu navigations
    or even for all individual game scenes***.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的故事板在当我们只知道游戏的一般结构时可以用于原型设计阶段，并且对于游戏的菜单导航甚至对于所有单个游戏场景都是完美的***。
- en: The button itself is removed before the transition via the `button.removeFromSuperview()`
    call to prevent a memory leak caused by the new scene being drawn over what could
    have been an unseen menu button—unseen to the player but not to the game's memory
    stack.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '在过渡之前，通过调用`button.removeFromSuperview()`来移除按钮本身，以防止新场景绘制在可能未被看到的菜单按钮上——对玩家来说是看不见的，但对游戏的内存堆栈来说不是。 '
- en: Tip
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '***It''s usually the best practice to only use storyboards for overall navigation
    menus and not for each individual level/scene. The `SKScene` and `SKNode` functionality
    can let us reuse similar scene structures and save much of the coding for similarly
    structured levels. Games with many levels could turn our storyboards into a web
    of confusing structures and thus undo their initial purpose. Scenes with the actual
    gameplay could just be in their own single view controller in the storyboard,
    and we''d have the pause, share, and other menus be controlled by storyboard segues.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**通常，最好只使用Storyboard来设计整体导航菜单，而不是每个单独的水平/场景。`SKScene`和`SKNode`的功能可以让我们重用相似的场景结构，并为类似结构的水平节省大量的编码工作。拥有许多级别的游戏可能会将我们的Storyboard变成一个令人困惑的结构网，从而取消其最初的目的。实际游戏场景可以仅在其自己的单个视图控制器中存在于Storyboard中，而暂停、分享和其他菜单将由Storyboard的segues控制。'
- en: SKScene transitions with SKS files
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SKS文件的SKScene过渡
- en: A `.sks` file is a special SpriteKit scene file that can allow the creation
    of a scene as well as the placement of the player, particles, enemies, and level
    assets in a visual, drag and drop way. Transitioning to a visually designed `.sks`
    file in Swift is the same as our initial `SKTransition` example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`.sks`文件是一种特殊的SpriteKit场景文件，它允许以视觉、拖放的方式创建场景以及放置玩家、粒子、敌人和关卡资源。在Swift中将过渡到视觉设计的`.sks`文件与我们的初始`SKTransition`示例相同。'
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The creation of the `gameScene` constant with the `SKScene` initializer `fileNamed`
    and then presenting that scene to the view works the same with either the `.swift`
    file or `.sks` file. This gives us the flexibility to both code and/or visually
    design our game scenes. In the case of `SwiftSweeper`, we will do the more code-centric
    methodology, but feel free to build on this game on your own if you wish with
    either more code, Storyboards, and/or with visually designed `SpriteKitScene`
    (`.sks`) files.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SKScene`初始化器`fileNamed`创建`gameScene`常量，然后将该场景展示给视图，无论是`.swift`文件还是`.sks`文件，其工作原理都是相同的。这使我们能够既通过代码又/或通过视觉设计我们的游戏场景。在`SwiftSweeper`的情况下，我们将采用更侧重于代码的方法，但如果您愿意，也可以使用更多的代码、Storyboard和/或视觉设计的`SpriteKitScene`（`.sks`）文件来构建这个游戏。
- en: Assets, sprites, and icons
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产、精灵和图标
- en: As of Xcode 7, game assets are placed in the `Assets.xcassets` folder. Previous
    versions of Xcode might have had an `Images.xcassets` folder for the game's icons
    and sprites, but this has changed and might continue to change with each new iOS
    release.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Xcode 7，游戏资源放置在`Assets.xcassets`文件夹中。Xcode的早期版本可能有一个`Images.xcassets`文件夹用于游戏的图标和精灵，但这一情况已经改变，并且可能会随着每个新的iOS版本而继续变化。
- en: '![Assets, sprites, and icons](img/00026.jpeg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![资产、精灵和图标](img/00026.jpeg)'
- en: An image from Apple's WWDC15 conference
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 来自Apple WWDC15会议的一张图片
- en: Starting with iOS 9 and Xcode 7, the `assets` folder was given even more flexibility
    with the ability to handle the various app icon sizes, the launch image, sets
    of images, and sprite atlases. This also allows us to develop with various memory
    saving capabilities introduced in iOS 9 like **app slicing** / **app thinning**
    and on-demand resources. The app slicing/thinning feature makes sure that only
    the assets relevant to the device are downloaded, which saves space on the player's
    iPhone or iPad. On-demand resources let us tag assets that are available in the
    device's memory only during certain parts of our games. This way, we can create
    even larger games for our players to experience without taxing the sometimes-limited
    space in the Apple family of devices.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 从iOS 9和Xcode 7开始，`assets`文件夹获得了更多的灵活性，能够处理各种应用图标大小、启动图像、图像集和精灵图集。这也允许我们使用iOS
    9中引入的各种内存节省功能进行开发，如**应用切片**/**应用瘦身**和按需资源。应用切片/瘦身功能确保只有与设备相关的资产被下载，这可以在玩家的iPhone或iPad上节省空间。按需资源允许我们标记在游戏中的特定部分才存在于设备内存中的资产。这样，我们就可以为玩家创建更大的游戏体验，而不会耗尽苹果设备家族中有时有限的存储空间。
- en: You can find more on app slicing/thinning at [https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html](https://developer.apple.com/library/prerelease/ios/documentation/IDEs/Conceptual/AppDistributionGuide/AppThinning/AppThinning.html)上找到更多关于应用切片/精简的信息。
- en: When setting up your game for on-demand services, something that could be great
    to know in the initial planning of your games, can be found in the official documentation
    at [https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/](https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 当为按需服务设置你的游戏时，这是在游戏初期规划中值得了解的，可以在官方文档[https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/](https://developer.apple.com/library/prerelease/ios/documentation/FileManagement/Conceptual/On_Demand_Resources_Guide/)中找到。
- en: Sprite atlases and animating sprites
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 精灵图集和动画精灵
- en: SwiftSweeper actually doesn't use animating sprites; as we'll see, it simply
    uses Unicode emoticon characters to animate the screen. Yet, we can't discuss
    SpriteKit and 2D game development without mentioning sprites, animating and optimizing
    them with texture atlases/sprite sheets, could we? A sprite atlas is a collection
    of images bundled into a single image, also known as a **sprite sheet** or **texture
    atlas**. While developing 2D games, it is highly recommended to use texture atlases
    as opposed to various image sets because to the renderer, texture atlases will
    equate to far fewer draw calls and thus can make sure that your game runs at that
    needed 60 fps. The `Collectables.atlas` folder in `Assets.xcassets` could hold
    all of your game's collectables and with the `SKTextureAtlas` class, efficiently
    draw those collectables to the screen. When storing the images to say the player's
    idle, walking, and jumping animations, we use texture atlases to store them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftSweeper实际上并不使用动画精灵；正如我们将要看到的，它只是使用Unicode表情符号字符来动画化屏幕。然而，我们无法在不提及精灵、动画化和使用纹理图集/精灵图来优化它们的情况下讨论SpriteKit和2D游戏开发，对吧？精灵图集是一组打包成单个图像的图像集合，也称为**精灵图**或**纹理图集**。在开发2D游戏时，强烈建议使用纹理图集而不是各种图像集，因为对于渲染器来说，纹理图集将等于更少的绘制调用，从而确保你的游戏以所需的60
    fps运行。《Collectables.atlas》文件夹位于`Assets.xcassets`中，可以存储你游戏中所有的可收集物品，并且使用`SKTextureAtlas`类，可以有效地将这些可收集物品绘制到屏幕上。当我们存储玩家静止、行走和跳跃动画的图像时，我们使用纹理图集来存储它们。
- en: 'Creating a texture atlas is very simple and is presented as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 创建纹理图集非常简单，如下所示：
- en: Simply click on your `Assests.xcassets` folder and right-click on an empty part
    of the folder's hierarchy.![Sprite atlases and animating sprites](img/00027.jpeg)
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 简单地点击你的`Assests.xcassets`文件夹，然后在文件夹层次结构的空白部分右键点击。![精灵图集和动画精灵](img/00027.jpeg)
- en: Click on **New Sprite Atlas** and just like this, we have a folder where we
    can store various sprites for our game.![Sprite atlases and animating sprites](img/00028.jpeg)
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**新建精灵图集**，就像这样，我们就有了可以存储我们游戏各种精灵的文件夹。![精灵图集和动画精灵](img/00028.jpeg)
- en: Make sure to name the folder based on how you wish to categorize the groups
    of sprites. You'd need this name when referencing them in code.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保根据你希望如何分类精灵组来命名文件夹。在代码中引用它们时你需要这个名称。
- en: 'To create a reference to this atlas in code and animate the sprites, we use
    `SKTextureAtlas` as follows:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在代码中创建对这张图集的引用并动画化精灵，我们使用`SKTextureAtlas`如下所示：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: First, this code creates an `SKTextureAtlas` reference to the player's sprite
    atlas using the initializer `SKTextureAtlas(named:"Player.atlas")`. Then, we create
    an array of textures using one of Swift's orders block `map(NSRange){…}`. This
    is a closure block that iterates through the textures in the sprite atlas based
    on the range specified in the map call. The `number` object is a simple index
    object we can use to represent the index of the mapping.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，这段代码使用初始化器`SKTextureAtlas(named:"Player.atlas")`创建了一个指向玩家精灵图集的`SKTextureAtlas`引用。然后，我们使用Swift的一个顺序块`map(NSRange){…}`创建了一个纹理数组。这是一个闭包块，它根据map调用中指定的范围遍历精灵图集中的纹理。`number`对象是一个简单的索引对象，我们可以用它来表示映射的索引。
- en: 'This is done because our player has these sprite names for the normal/idle
    animation:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们的玩家有这些用于正常/静止动画的精灵名称：
- en: '[PRE9]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since we know that the sprite animations are named with an indexed naming structure,
    it's better to use Swift's functional programming tools, such as `map()`, here
    to simplify the code. 2D Sprites with many frame-by-frame animations (games such
    as Metal Slug) could be iterated through in such a fashion.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们知道精灵动画是以索引命名结构命名的，因此在这里使用 Swift 的函数式编程工具，如 `map()`，可以简化代码。具有许多帧帧动画的 2D 精灵（如
    Metal Slug）可以以这种方式迭代。
- en: '`SKTextureAtlas` also has a class function named `preloadTextureAtlases` we
    can use to preload an array of texture atlases:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`SKTextureAtlas` 还有一个名为 `preloadTextureAtlases` 的类函数，我们可以使用它来预加载一系列纹理图集：'
- en: '[PRE10]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is great to make sure that a stage's sprites are loaded before entering
    the stage.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，可以确保在进入舞台之前加载舞台的精灵。
- en: Creating our game logic
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的游戏逻辑
- en: For the sake of simplicity, MineSweeper won't have many different assets or
    any sprite textures. It instead uses Swift's Unicode emoticon character capabilities
    and `UIView` calls to design the game's graphics in a rather old-fashioned, very
    MineSweeper-like way.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化起见，扫雷不会有很多不同的资产或任何精灵纹理。它相反使用 Swift 的 Unicode 表情符号字符能力和 `UIView` 调用来以相当老式、非常类似扫雷的方式设计游戏的图形。
- en: Not only do we do this to give us a somewhat simplistic starting point, but
    to show how Swift code and SpriteKit classes can let us create the entire game's
    logic and flow without the initial need of sprite assets. This way, if developing
    as a team or by yourself, the game can be made before doing the sometimes grueling
    process of making wonderful visual assets. Thinking with code and structure first
    can ensure that you have a working prototype that you can polish later with sprites,
    music, and atmosphere.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这样做不仅是为了给我们一个相对简单的起点，而且还为了展示 Swift 代码和 SpriteKit 类如何让我们在不需要初始精灵资产的情况下创建整个游戏逻辑和流程。这样，无论是作为团队还是个人开发，游戏可以在进行有时令人疲惫的制作精美视觉资产的过程之前制作出来。首先思考代码和结构可以确保你有一个可以稍后用精灵、音乐和氛围进行润色的可工作原型。
- en: 'We''ve so far left SwiftSweeper waiting as just a shell of the SpriteKit game
    template. It''s about time we get to the game''s model:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只是让 SwiftSweeper 作为 SpriteKit 游戏模板的一个外壳等待。是时候我们开始构建游戏模型了：
- en: First, let's add our image assets. For more information, visit [https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo](https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo).
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加我们的图像资产。更多信息，请访问 [https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo](https://mega.co.nz/#!XhEgCRgJ!4QqKMl1l1P4opWU7OH2wEN_noVQ86z5mxEyLuyUrcQo)。
- en: This is a link to the `Assets.xcassets` folder of `SwiftSweeper`. We can add
    these individually, but the simplest way is to just replace your project's `Assets.xcassets`
    folder directly in your computer where your project's folder is located. You can
    have Xcode open while you do this, it'll automatically update from the original
    template files.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个指向 `SwiftSweeper` 的 `Assets.xcassets` 文件夹的链接。我们可以单独添加这些文件，但最简单的方法是直接在计算机上替换你的项目文件夹中的
    `Assets.xcassets` 文件夹。你可以在此过程中打开 Xcode，它会自动从原始模板文件更新。
- en: 'Next, let''s add the sound files from the following URL:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加以下 URL 的声音文件：
- en: '[https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY](https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY)'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY](https://mega.co.nz/#!T5dUnJZb!NUT837QQnKeQbTpI8Jd8ISJMx7TnXvucZSY7Frw5gcY)'
- en: 'Add the sounds by doing the following:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过以下步骤添加声音：
- en: Right-click on the `SwiftSweeperExample` folder that holds the Swift files and
    then go to **New** | **Group** from the menu.![Creating our game logic](img/00029.jpeg)
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击包含 Swift 文件的 `SwiftSweeperExample` 文件夹，然后从菜单中选择 **New** | **Group**。![创建我们的游戏逻辑](img/00029.jpeg)
- en: Name this folder `Sounds` and drag it to the bottom of the files within the
    same `SwiftSweeperExample` folder.![Creating our game logic](img/00030.jpeg)
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将此文件夹命名为 `Sounds` 并将其拖到同一 `SwiftSweeperExample` 文件夹中的文件底部。![创建我们的游戏逻辑](img/00030.jpeg)
- en: Right-click the `Sounds` folder and select `Add Files To "SwiftSweeperExample"`.![Creating
    our game logic](img/00031.jpeg)
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 `Sounds` 文件夹，并选择 `Add Files To "SwiftSweeperExample"`。![创建我们的游戏逻辑](img/00031.jpeg)
- en: Add the sounds from the `SwiftSweeperSounds` folder, and they should now be
    in your project.
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `SwiftSweeperSounds` 文件夹添加声音，现在它们应该已经在你的项目中了。
- en: '![Creating our game logic](img/00032.jpeg)'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![创建我们的游戏逻辑](img/00032.jpeg)'
- en: All of the assets should be now in the project, so now we can build our game.
    Let's first start with the actual tiles.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 所有资产现在都应该在项目中，因此现在我们可以构建我们的游戏。让我们首先从实际的瓷砖开始。
- en: 'Now create a new Swift file, name it `Tile`, and paste the following code into
    the file:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个新的 Swift 文件，将其命名为 `Tile`，并将以下代码粘贴到该文件中：
- en: '[PRE11]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here are some stepwise logic we adhere to while creating tiles:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建地砖时，我们遵循以下逐步逻辑：
- en: While building any code logic, we usually place the properties about this object
    at the top. We know that each tile in a game of MineSweeper will be part of a
    row and a column. The number of the row and the column this tile will have during
    gameplay won't change during the course of a single round, so we make them constants
    with the keyword `let` and set them with the type `Int` as we know that you can't
    have fractions of a row or a column, at least in terms of the tile objects.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构建任何代码逻辑时，我们通常将这个对象的相关属性放在顶部。我们知道在扫雷游戏中的每一块地砖都将是一行和一列的一部分。在游戏过程中，这块地砖所在的行和列的编号不会改变，所以我们将它们设置为常量，使用关键字
    `let`，并使用 `Int` 类型来设置，因为我们知道行或列不能有分数，至少在地砖对象方面是这样的。
- en: A tile can have a few different states. It could be already tapped, it could
    have a flag placed on it, and if it's a a mine. Since these are true/false properties,
    we set them with as Boolean variables `isTileDown`, `isFlagged`, and `isAMine`.
    We set them to `false` initially.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 地砖可以有几个不同的状态。它可能是已经被点击的，它上面可能放置了旗帜，或者它可能是一个地雷。由于这些是布尔属性，我们使用布尔变量 `isTileDown`、`isFlagged`
    和 `isAMine` 来设置它们。我们最初将它们设置为 `false`。
- en: Tiles in MineSweeper count how many tiles around them are mines, so we create
    the integer counter `nearbyMines` to hold that information.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在扫雷游戏中，地砖会计算它们周围有多少地雷，因此我们创建一个整数计数器 `nearbyMines` 来保存这些信息。
- en: When an instance of a tile object is created, we want the game to set its row
    and column number placement on the `GameBoard`, so we create the default initializer,
    `init`, to have two parameter inputs for both the row and column.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当创建一个地砖对象的实例时，我们希望游戏在 `GameBoard` 上设置其行和列编号位置，因此我们创建默认初始化器 `init`，它有两个参数输入，分别是行和列。
- en: That's all we need for the `Tile` objects, so let's move on to setting the button
    functionality of these `Tile` objects with the `MineTileButton` class.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `Tile` 对象，我们需要的就这些，所以让我们继续使用 `MineTileButton` 类来设置这些 `Tile` 对象的按钮功能。
- en: 'Create a new Swift file and name it `MineTileButton` and paste the following
    code into it:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 Swift 文件，并将其命名为 `MineTileButton`，然后将以下代码粘贴到其中：
- en: '[PRE12]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here''s the explanation of the code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是对代码的解释：
- en: Since we are creating a `UIButton` object, we import the UIKit framework for
    this object.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们正在创建一个 `UIButton` 对象，因此我们导入 UIKit 框架用于这个对象。
- en: These are the properties of this button object. We need a `Tile` object named
    `tile` to reference, a `CGFloat` size named `tileSize` to represent the rectangle
    this button will occupy.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些是这个按钮对象的属性。我们需要一个名为 `tile` 的 `Tile` 对象来引用，一个名为 `tileSize` 的 `CGFloat` 大小来表示这个按钮将占用的矩形。
- en: 'The initializer for this class takes in a `Tile` object named `tileButton`
    and a `CGFloat` named `size`. We assign the class''s own tile to `tileButton`
    and `tileSize` to `size` and then we make a square named `tileBoundingFrame` with
    the `CGRectMake()` method. This is done just after we set an *x* and *y* value
    of `CGFloat` to the square based on the `tileSize`. The `UIButton` parent `init(frame:
    )` initializer uses the `tileBoundingFrame` as the parameter via `super.init(frame:
    tileBoundingFrame)`.'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '这个类的初始化器接受一个名为 `tileButton` 的 `Tile` 对象和一个名为 `size` 的 `CGFloat`。我们将类的自己的地砖分配给
    `tileButton`，将 `tileSize` 分配给 `size`，然后使用 `CGRectMake()` 方法创建一个名为 `tileBoundingFrame`
    的正方形。这是在我们根据 `tileSize` 为正方形设置 `CGFloat` 的 `x` 和 `y` 值之后完成的。`UIButton` 的父类初始化器
    `init(frame:)` 通过 `super.init(frame: tileBoundingFrame)` 使用 `tileBoundingFrame`
    作为参数。'
- en: Since Xcode 5, the `init` function is needed mainly to keep the compiler happy
    while dealing with UI objects.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 Xcode 5 以来，`init` 函数主要是在处理 UI 对象时让编译器满意所需的。
- en: The function `getTileLabelText()` returns a string based on the status of the
    `tile` object. If the tile is not a mine, we know that we have to either place
    something for there being no tiles; traditionally, this is just a blank space
    or an empty `""` string, but for now, we are just placing `0` there, leaving the
    logic open for customization. Honestly, we could simply return the nested if-else
    statement's return `\(self.tile.nearbyMines)`, and it'd return the same result.
    As we see, it's returning the particular `Tile` object's `nearbyMines` property.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getTileLabelText()` 函数根据 `tile` 对象的状态返回一个字符串。如果方块不是地雷，我们知道我们必须放置一些东西，因为没有方块；传统上，这只是一个空白空间或一个空的
    `""` 字符串，但到目前为止，我们只是在那里放置 `0`，留下逻辑以供自定义。说实话，我们可以简单地返回嵌套的 if-else 语句的返回值 `\(self.tile.nearbyMines)`，它将返回相同的结果。正如我们所见，它返回特定
    `Tile` 对象的 `nearbyMines` 属性。'
- en: If the tile is a mine, then we return the collision Unicode emoji character.
    The `getTileLabelText()` function is called when the player taps an `unflagged`
    tile.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果方块是地雷，则返回碰撞 Unicode 表情字符。当玩家点击一个未标记的方块时，会调用 `getTileLabelText()` 函数。
- en: Swift's ability to use Unicode character symbols can be a great visual aid in
    the planning process of your games. The collision Unicode emoji used in line `(6)`
    is `U+1F4A5 (128165)`. If you see only a square box and not the red explosion-like
    character, it can be seen in the full project download mentioned earlier in the
    chapter or at the following link.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Swift 使用 Unicode 字符符号的能力可以在您游戏的规划过程中起到很好的视觉辅助作用。在行 `(6)` 中使用的碰撞 Unicode 表情是
    `U+1F4A5 (128165)`。如果您只看到一个方框而不是红色的爆炸状字符，可以在本章前面提到的完整项目下载中查看，或者通过以下链接查看。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Find more information on this emoji at [http://www.charbase.com/1f4a5-unicode-collision-symbol](http://www.charbase.com/1f4a5-unicode-collision-symbol).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://www.charbase.com/1f4a5-unicode-collision-symbol](http://www.charbase.com/1f4a5-unicode-collision-symbol)
    查找有关此表情符号的更多信息。
- en: GameBoard
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GameBoard
- en: Now that we have our tile object and button logic that will represent each tile
    object named `MineTileButton`, we need to create an object representing the collection
    of these objects, that is, `GameBoard`.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有了代表每个名为 `MineTileButton` 的方块对象的 tile 对象和按钮逻辑，我们需要创建一个代表这些对象集合的对象，即 `GameBoard`。
- en: The full `GameBoard.swift` code is a bit too large to show here in its entirety,
    so we will summarize its main features and segments.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 `GameBoard.swift` 代码在这里全部展示出来会有些过大，所以我们将总结其主要功能和部分。
- en: 'We can view the entire code either in the full project link mentioned earlier
    in the chapter, or directly below in order to copy to your current game project
    file:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在本章前面提到的完整项目链接中查看整个代码，或者直接在下面复制到您当前的游戏项目文件中：
- en: '[https://mega.co.nz/#!X8FB2aAK](https://mega.co.nz/#!X8FB2aAK)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mega.co.nz/#!X8FB2aAK](https://mega.co.nz/#!X8FB2aAK)'
- en: 'For our `GameBoard`, we are looking to create a tiled board of 10x10 size that
    also has three levels of difficulty: easy, medium, and hard. To create the difficulty,
    we simply use an enumerator named `difficulty` to store the game''s difficulty
    levels.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `GameBoard`，我们希望创建一个 10x10 大小的瓦片板，并且具有三个难度级别：简单、中等和困难。为了创建难度，我们只需使用一个名为
    `difficulty` 的枚举来存储游戏的难度级别。
- en: The most important properties of `GameBoard` include `boardSize_` (which is
    set to `10` in this case), a variable that will represent the number of mines
    that will be placed named `mineRandomizer`, the number of mines active on the
    board named `mineCount`, and the Tile objects that will populate the board named
    `tiles`.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameBoard` 的最重要的属性包括 `boardSize_`（在本例中设置为 `10`），一个将代表放置的地雷数量的变量 `mineRandomizer`，板上的活动地雷数量
    `mineCount`，以及将填充板上的 `tiles` 对象。'
- en: 'Make a note of the syntax used for the `tiles` property:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `tiles` 属性所使用的语法：
- en: '[PRE13]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this way, we can create an ordered 2D array (or matrix) in Swift*. The `GameBoard`
    object will basically store an array of an array of `Tile` type objects.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式，我们可以在 Swift 中创建一个有序的二维数组（或矩阵）。`GameBoard` 对象基本上将存储一个 `Tile` 类型对象的数组数组。
- en: Note
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '*Swift does have more ways to express matrices, for example, we can use Structs
    to define our own unique matrices. As at the time of this publication, Swift does
    not have its own true functionality for fixed length arrays, as we see in various
    C languages. However, using the nested braces `[[]]` is fine for what we are trying
    to accomplish.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '*Swift 有更多方式来表示矩阵，例如，我们可以使用 Structs 来定义我们自己的独特矩阵。截至本出版物的时间，Swift 没有自己真正的固定长度数组功能，正如我们在各种
    C 语言中看到的那样。然而，使用嵌套的大括号 `[[]]` 对于我们试图完成的事情来说是完全可以的。'
- en: 'The initializer for `GameBoard`, `init(selectedDifficulty:difficulty){}`, takes
    in the player-selected difficulty as it''s single parameter then builds the board
    based on the `boardSize` property and then uses the following nested for-in loop
    to populate the entire board with `Tile` objects:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameBoard`的初始化器`init(selectedDifficulty:difficulty){}`接受玩家选择的难度作为其单一参数，然后根据`boardSize`属性构建板，然后使用以下嵌套for-in循环用`Tile`对象填充整个板：'
- en: '[PRE14]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Since the `tiles` object is a 2D array, we first need to perform this nested
    loop that first creates a 1D array of `Tile` objects (named `tilesRow`) for each
    row and then add a tile for each column in that row with the `.append` function.
    The main tiles 2D array is then appended that `tilesRow` array.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`tiles`对象是一个二维数组，我们首先需要执行这个嵌套循环，首先为每一行创建一个`Tile`对象的1D数组（命名为`tilesRow`），然后使用`.append`函数在该行的每一列中添加一个瓷砖。然后，将`tilesRow`数组附加到主瓷砖二维数组中。
- en: Tip
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you wish to make a `GameBoard` instance that is a rectangle or of another
    shape, you'd have to take into account the differing column and row amounts. This
    would make the nested for-loop have more complexity by needing a separate `columnSize`
    and `rowSize` property. Many puzzle games will make their boards look complex
    to the player but might still keep their internal structures simple to either
    squares or rectangles by instead filling in that tile with a nonplayable section
    or background/transparent tile.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望创建一个矩形或其他形状的`GameBoard`实例，你必须考虑到不同的列和行数量。这将使嵌套循环更加复杂，需要单独的`columnSize`和`rowSize`属性。许多益智游戏可能会让玩家看起来很复杂，但它们的内部结构可能仍然很简单，要么是正方形，要么是矩形，通过填充那个瓷砖为不可玩区域或背景/透明瓷砖来实现。
- en: It's a way for a developer to cut corners while at the same time allowing complex
    functionality and design. It's why we built this game with separate classes representing
    the Tiles, the tile button functionalities, and the game board layout.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种开发者可以节省时间的同时允许复杂功能和设计的做法。这就是我们为什么用代表瓷砖、瓷砖按钮功能和游戏板布局的单独类来构建这个游戏。
- en: Using inheritance, we can continue to customize what each tile does and thus
    allow a myriad of features based on a simple foundation.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过继承，我们可以继续自定义每个瓷砖的功能，从而基于简单的基础实现众多功能。
- en: It's why video games have always been the poster children to make the most out
    of object-oriented design.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么电子游戏一直是利用面向对象设计的典范。
- en: Don't worry if at first it's tough to get a full understanding of this, as nested
    loops tend to be brain twisters. Just observe how the interior for-loop won't
    exit until it's done filling in columns based on the `boardSize`_ property. This
    kind of loop is made easier with the fact that the rows and columns are all equal
    at 10.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一开始难以完全理解这一点，不要担心，因为嵌套循环往往很费脑筋。只需观察内部for循环不会退出，直到根据`boardSize`_属性填充完列。由于行和列都是10，这种循环变得更容易。
- en: 'The initializer then calls the `resetBoard()` function, which resets the `mineCount`
    to `0`, and does two more nested for-loops:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 然后初始化器调用`resetBoard()`函数，将`mineCount`重置为`0`，并执行两个额外的嵌套for循环：
- en: '[PRE15]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This board-iterating for-loop randomly sets which tiles are mines using the
    `createRandomMineTiles()` function as well as resets the tiles to being untouched
    with the `tiles[row][column].isTileDown = false` call. The `createRandomMineTiles()`
    function works off the current difficulty level, particularly the `mineRandomizer`
    property that is determined in the `implementDifficulty()` function. The higher
    the `mineRandomizer` value, the less of a chance the iterated tile will be made
    into a mine.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个遍历板的for循环使用`createRandomMineTiles()`函数随机设置哪些瓷砖是地雷，以及使用`tiles[row][column].isTileDown
    = false`调用将瓷砖重置为未触摸状态。`createRandomMineTiles()`函数基于当前难度级别工作，特别是`mineRandomizer`属性，该属性在`implementDifficulty()`函数中确定。`mineRandomizer`值越高，迭代瓷砖成为地雷的机会就越小。
- en: 'The next nested for-loop in `resetBoard()` is the following:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`resetBoard()`中的下一个嵌套for循环如下：'
- en: '[PRE16]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This iterates through every tile on the board and sets the number the player
    will see if tapped. That number of course being the number of mines surrounding
    a non-mine tile, that is, the `nearbyMines` property of the `Tile` class.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这会遍历板上的每个瓷砖，并设置玩家在点击时将看到的数字。这个数字当然是围绕非地雷瓷砖的周围地雷的数量，即`Tile`类的`nearbyMines`属性。
- en: 'This rather complex chain of calculations begins with the `calculateNearbyMines()`
    function and runs through the array/tile index calculating functions, `getNearbyTiles()`
    and `getAdjacentTileLocation()`. We provided various detailed comments in each
    of these functions to get a better understanding on how they work. It''s advised
    that you read the intricate details on how it''s done but to not muddy an already
    complex game logic explanation, take notes on the following line in `getNearbyTiles()`:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当复杂的计算链从`calculateNearbyMines()`函数开始，然后通过数组/瓷砖索引计算函数`getNearbyTiles()`和`getAdjacentTileLocation()`进行计算。我们在这些函数中提供了各种详细的注释，以便更好地理解它们的工作原理。建议你阅读如何实现的详细细节，但为了避免使已经复杂的游戏逻辑解释更加混乱，请在`getNearbyTiles()`中的以下行做笔记：
- en: '[PRE17]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: If any line in these three complex functions is to be understood, it's this
    one. The `nearbyTileOffset` object is an explicitly written array of tuples, which
    contains every offset that could exist around a single 2D tile. Actually, it's
    best to think of each member of this array as an (*x*,*y*) 2D Vector.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要理解这三个复杂函数中的任何一行，那就是这一行。`nearbyTileOffset`对象是一个显式编写的元组数组，包含围绕单个2D瓷砖可能存在的每个偏移量。实际上，最好将这个数组中的每个成员视为一个(*x*,*y*)
    2D向量。
- en: Thus, as commented in the preceding code, the offset of (`-1`,`-1`) would be
    to the bottom left of the tile since `x = -1` (left 1) and `y = -1` (down 1).
    Similarly, (`1`,`0`) is to the right, (`1`,`1`) is the top-right corner.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如前述代码中注释的那样，偏移量（`-1`,`-1`）位于瓷砖的左下角，因为`x = -1`（左1）和`y = -1`（下1）。同样，(`1`,`0`)位于右侧，(`1`,`1`)是右上角。
- en: We also have to take into account that some tiles are on the edge and/or column
    of the board, thus some of the tile offsets won't return the reference to another
    tile; they'll instead return nil.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须考虑到一些瓷砖位于边缘和/或列上，因此一些瓷砖偏移量不会返回另一个瓷砖的引用；相反，它们将返回nil。
- en: '[PRE18]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This for-loop in `getNearbyTiles()` not only checks the offsets of every tile,
    but also, using the call to `getAjacentTileLocation()`, accounts for edge or corner
    tiles.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在`getNearbyTiles()`中的这个for循环不仅检查每个瓷砖的偏移量，而且还通过调用`getAjacentTileLocation()`来考虑边缘或角落瓷砖。
- en: Again, these three functions are rather complex, even in a less line-by-line
    / semi-generic explanation of their functionality. So, don't worry if you don't
    understand the flow/order at first.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这三个函数相当复杂，即使是在对它们的函数功能进行逐行/半通用解释的情况下也是如此。所以，如果你一开始不理解流程/顺序，请不要担心。
- en: 'Finally, for `resetBoard()`, we can''t win the game without knowing if the
    player got every non-mine tile, so we get that information with the line:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，对于`resetBoard()`，如果我们不知道玩家是否得到了每个非地雷瓷砖，我们就无法赢得游戏，所以我们通过以下行获取该信息：
- en: '[PRE19]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When the player's number of completed moves (counted in the `GameScene` class)
    equals `numOfTappedTilesToWin`, the player wins!
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家的完成移动次数（在`GameScene`类中计数）等于`numOfTappedTilesToWin`时，玩家获胜！
- en: This is all done before the player makes the first move! This is done in order
    to have the values already predetermined. Yes, we could make some of these calculations
    during the player's touch, but dealing with boilerplate game logic is usually
    fast enough to prepare the game at load time so that we can use the game play
    to focus on effects, sequences, and other visual notifications during the game
    loop.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作都是在玩家进行第一次移动之前完成的！这样做是为了确保值已经预先确定。是的，我们可以在玩家触摸时进行一些计算，但处理样板游戏逻辑通常足够快，可以在加载时准备游戏，这样我们就可以在游戏循环期间使用游戏玩法来关注效果、序列和其他视觉提示。
- en: This functionality is controlled by the `GameScene.swift` file, which we will
    summarize next.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这个功能由`GameScene.swift`文件控制，我们将在下一部分对其进行总结。
- en: Putting it all together in GameScene.swift
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将所有这些在`GameScene.swift`中整合在一起
- en: We now have the core of SwiftSweeper's logic set up, but now it's time to present
    it in our `SKScene` provided by the game template, `GameScene`. This scene uses
    the game/rendering loop functions that we mentioned at the beginning of the chapter.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了SwiftSweeper逻辑的核心，现在是时候将其展示在游戏模板提供的`SKScene`中，即`GameScene`。这个场景使用了我们在本章开头提到的游戏/渲染循环函数。
- en: The SwiftSweeper version of `GameScene.swift` is rather large at about 800 lines
    of code, so like `GameBoard`, we won't be going over it line by line but instead
    we'll be summarizing some of the important aspects of the scene. As stated previously,
    every update to Xcode and iOS brings more visual ways of setting up these scenes,
    so getting to know every line of code in this example isn't necessary, but still
    recommended if you really wish to dive deep into how to use code to present SpriteKit
    game scenes.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: SwiftSweeper 的 `GameScene.swift` 版本相当大，大约有 800 行代码，所以像 `GameBoard` 一样，我们不会逐行分析它，而是会总结场景的一些重要方面。正如之前所述，每次
    Xcode 和 iOS 的更新都会带来更多设置这些场景的视觉方式，因此了解这个示例中的每一行代码不是必要的，但如果你真的想深入了解如何使用代码来展示 SpriteKit
    游戏场景，仍然建议这样做。
- en: 'The full code can be found in the full project link mentioned earlier in the
    chapter or (if you''ve been building it from scratch throughout the chapter) at
    the link mentioned here:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的代码可以在本章前面提到的完整项目链接中找到，或者（如果你一直在本章从头开始构建）在下面提到的链接中：
- en: '[https://mega.co.nz/#!PgljBL7b](https://mega.co.nz/#!PgljBL7b)'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://mega.co.nz/#!PgljBL7b](https://mega.co.nz/#!PgljBL7b)'
- en: We used various `//MARK:` comments to section off parts of this code, so you
    can navigate easier. After copying the code into your project, you could build
    and run the app. As long as everything was placed into the project correctly,
    you should have a working version of SwiftSweeper running on your phone or in
    the phone simulators. Play through it a bit to get an idea what is being done
    in GameScene to present the game. Sometimes, seeing a game in action lets us see
    the code behind it better. If any errors pop up, something went wrong and if all
    else fails, you can download the completed project from [https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了各种 `//MARK:` 注释来分隔代码的各个部分，这样你可以更容易地导航。将代码复制到你的项目中后，你可以构建并运行应用程序。只要一切都被正确地放置到项目中，你应该在你的手机或手机模拟器上运行一个可工作的
    SwiftSweeper 版本。玩一会儿，以了解游戏场景中正在进行的操作，以展示游戏。有时候，看到游戏的实际运行情况能让我们更好地看到其背后的代码。如果出现任何错误，说明出了问题，如果所有其他方法都失败了，你可以从
    [https://github.com/princetrunks/SwiftSweeper](https://github.com/princetrunks/SwiftSweeper)
    下载完整的项目。
- en: 'The first visual entry point in GameScene, `didMoveToView()`, is actually rather
    small as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场景（GameScene）的第一个视觉入口点 `didMoveToView()` 实际上相当小，如下所示：
- en: '[PRE20]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We simply set the background color to white and load the instructions. Again,
    we didn't say that this was meant to be a beautiful-looking game.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是将背景颜色设置为白色并加载说明。再次强调，我们并没有说这是一个看起来很美的游戏。
- en: The `loadInstructions()` function manually places the instructions sprite on
    the screen and sets the `currentGameState_ enum to .Instructions`. A **game state**
    or **state machine** is common game development methodology that instructs characters,
    the player, and the game itself what state it is in. This could be used to make
    sure that certain parts of the gameplay don't happen in parts they aren't suppose
    to. iOS 9 / Xcode 7 introduced the framework; we'll dive into more later chapters
    named GamePlayKit, which, among other game logic functions, works with state machines
    that can be modular and independent from a specific scene. Components from the
    class `SKComponents` and more modern usage of `SKAction`, also introduced in iOS
    9, work in the same way, independent from OOP inheritance. Think of more dynamic/usable
    versions of protocols.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadInstructions()` 函数手动将说明精灵放置在屏幕上，并将 `currentGameState_` 枚举设置为 `.Instructions`。**游戏状态**或**状态机**是常见的游戏开发方法，它指导角色、玩家和游戏本身处于什么状态。这可以用来确保某些游戏玩法不会发生在它们不应该发生的地方。iOS
    9 / Xcode 7 引入了框架；我们将在后面的章节中深入探讨，例如 GamePlayKit，它除了其他游戏逻辑函数外，还与可以模块化和独立于特定场景的状态机一起工作。`SKComponents`
    类的组件以及 iOS 9 中引入的 `SKAction` 的更现代用法以相同的方式工作，独立于 OOP 继承。想想更动态/可用的协议版本。'
- en: 'The next overall step in the GameScene is the `chooseDifficultyMenu()` that
    came with the `removeInstructions()` function, which was called after the player
    taps the screen. This tap is checked in the function we mentioned in a few examples
    prior, `touchesBegan()`, using the game state as a logic check:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场景的下一个整体步骤是 `chooseDifficultyMenu()`，它伴随着 `removeInstructions()` 函数，在玩家点击屏幕后调用。这个点击在之前提到的几个示例中的函数
    `touchesBegan()` 中进行检查，使用游戏状态作为逻辑检查：
- en: '[PRE21]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Note how the `touchesBegan` function is actually rather simple. It only checks
    if we tapped the flag button or if we tapped on the instructions. What about the
    tiles? Well, remember that we made these tiles all members of `UIButton` with
    the `MineTileButton` class. Here''s the function that controls this:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 注意`touchesBegan`函数实际上相当简单。它只检查我们是否点击了旗帜按钮或是否点击了说明。那么方块呢？记住，我们把这些方块都变成了`UIButton`的成员，使用`MineTileButton`类。这是控制这个功能的函数：
- en: '[PRE22]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Members of the `UIButton` class send out a reference of what has been tapped
    to the scene. In this game, is an object of the type, `MineTileButton`. Using
    the game state to check if it's logical to the scene, we either end the round
    if a mine is hit with the `mineHit()` function or we increment the moves performed
    (used to calculate the win by comparing it to `numOfTappedTilesToWin_` calculated
    at the start of the round). If the game state is `.FlagPlanting`, then we instead
    deal with the logic behind planting a flag on the tiles. Tiles with flags don't
    react to `.MineTap` game state taps and thus, if you put a flag on the wrong tile,
    you won't get the win until you uncover all of the non-mine tiles.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIButton`类的成员会向场景发送被点击的引用。在这个游戏中，这是一个`MineTileButton`类型的对象。使用游戏状态来检查它是否对场景合理，我们要么使用`mineHit()`函数结束回合，要么增加执行的移动次数（用于通过将其与回合开始时计算的`numOfTappedTilesToWin_`进行比较来计算胜利）。如果游戏状态是`.FlagPlanting`，那么我们则处理在方块上放置旗帜的逻辑。带有旗帜的方块不会对`.MineTap`游戏状态点击做出反应，因此，如果你在错误的方块上放置了旗帜，你将无法在揭示所有非地雷方块之前获得胜利。'
- en: Through the rest of the code, we'll find a timer, alerts for the player based
    on the outcome, and even the ability to save times per difficulty levels using
    the class functions of the `NSUserDefaults` class.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在剩余的代码中，我们将找到一个计时器，根据结果向玩家发出警报，甚至可以使用`NSUserDefaults`类的类函数来保存每个难度级别的计时时间。
- en: Again, it's not exactly all that visually elegant, but intricate in code and
    most importantly a fully functioning game. We advise you to check out more of
    the code in `GameScene.swift`, but one major issue to our design one might have
    caused in the beginning is that this only works with iPhones.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这并不完全是在视觉上非常优雅，但在代码上很复杂，最重要的是一个完全功能性的游戏。我们建议您查看`GameScene.swift`中的更多代码，但可能对设计造成的一个主要问题是，这仅在iPhone上工作。
- en: Using visual tools such as autolayout, seen briefly in the previous chapter,
    will allow easier design changes for the entire family of iOS devices. Since many
    of the visual assets in SwiftSweeper's GameScene were manually placed in the view
    (particularly the instructions), we'd have to account for every device type in
    code. This is possible, but as the family of devices grows, manual code used for
    screen visuals could be broken rather easily in future iOS updates and device
    announcements. That's why in our next chapter about SceneKit and later, we will
    mostly diverge from this code-centric structure and embrace the hands-on tools
    and newer frameworks such as GamePlaykit from Xcode 7 and later.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如autolayout这样的视觉工具，如前一章中简要提到的，将允许为iOS设备系列更容易地进行设计更改。由于SwiftSweeper的GameScene中的许多视觉资产都是手动放置在视图中的（尤其是说明），我们不得不在代码中考虑每种设备类型。这是可能的，但随着设备系列的扩展，用于屏幕视觉的手动代码在未来iOS更新和设备公告中可能会很容易被破坏。这就是为什么在下一章关于SceneKit以及之后的章节中，我们将主要偏离以代码为中心的结构，并拥抱动手工具和更新的框架，如Xcode
    7及以后的GamePlaykit。
- en: DemoBots
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DemoBots
- en: As at the initial publication of this book, *WWDC15* recently completed and
    gave us a great new SpriteKit demo project for iOS 9 and Xcode 7 named **DemoBots**.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 就在本书最初出版时，*WWDC15*刚刚结束，为我们提供了一个名为**DemoBots**的针对iOS 9和Xcode 7的精彩新的SpriteKit演示项目。
- en: '![DemoBots](img/00033.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![DemoBots](img/00033.jpeg)'
- en: DemoBots is a SpriteKit project provided by Apple that uses components, state
    machines, on-demand services, GameplayKit, ReplayKit, and more!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: DemoBots是Apple提供的SpriteKit项目，它使用组件、状态机、按需服务、GameplayKit、ReplayKit等！
- en: The full project documentation to DemoBots can be found at [https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html).
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: DemoBots的完整项目文档可以在[https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/DemoBots/Introduction/Intro.html)找到。
- en: 'To see it in action from *WWDC15*, see the video and PDF file from the *Deeper
    into GameplayKit with DemoBots* keynote:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要从*WWDC15*中看到它的实际效果，请查看*Deeper into GameplayKit with DemoBots*主题演讲的视频和PDF文件：
- en: '[https://developer.apple.com/videos/wwdc/2015/?id=609](https://developer.apple.com/videos/wwdc/2015/?id=609)'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/videos/wwdc/2015/?id=609](https://developer.apple.com/videos/wwdc/2015/?id=609)'
- en: 'The SpriteKit keynote can be found here:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit的演讲可以在以下链接找到：
- en: '[https://developer.apple.com/videos/wwdc/2015/?id=604](https://developer.apple.com/videos/wwdc/2015/?id=604)'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/videos/wwdc/2015/?id=604](https://developer.apple.com/videos/wwdc/2015/?id=604)'
- en: DemoBots's gameplay even has easily editable enemy AI / navigation schemes uses
    the `SKCameraNode` introduced in iOS 9 that follows the player and doesn't move
    the scene around in the view as in past versions of SpriteKit. As we mentioned
    at the beginning of the chapter, mimicking the tools we see in multiplatform game
    engines.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: DemoBots的游戏玩法甚至有易于编辑的敌人AI/导航方案，它使用了iOS 9中引入的`SKCameraNode`，它跟随玩家，不会像过去版本的SpriteKit那样在视图中移动场景。正如我们在本章开头提到的，模仿我们在多平台游戏引擎中看到的工具。
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: We went through a number of topics here in this chapter. We first spoke on why
    SpriteKit was a welcomed addition to iOS after years of developers only having
    third-party gaming frameworks, such as Cocos2D and Sparrow. We discussed how SpriteKit
    fits in the game development ecosystem as rather powerful, multiplatform game
    engines, such as Unity and Unreal Engine, continue to become more prominent. Next,
    we went into the SpriteKit game loop and rendering cycle that is used by `SKScene`.
    Then, we began to build our demo tile game, `SwiftSweeper`, and dove more into
    the basic structure of SpriteKit's most prominent object classes. The iOS 9 `assets`
    folder was reviewed in addition to texture atlases and how to animate sprites
    using these asset tools. Then, we went into the rather complex logic and code
    that goes into mimicking a tile game such as MineSweeper.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了多个主题。我们首先讨论了为什么在多年的开发者只能使用第三方游戏框架，如Cocos2D和Sparrow之后，SpriteKit成为了iOS的受欢迎的补充。我们讨论了SpriteKit如何在游戏开发生态系统中适应，因为像Unity和Unreal
    Engine这样的强大、多平台游戏引擎继续变得更加突出。接下来，我们探讨了`SKScene`使用的SpriteKit游戏循环和渲染周期。然后，我们开始构建我们的演示拼图游戏`SwiftSweeper`，并更深入地了解了SpriteKit最突出的对象类的基本结构。除了纹理图集以及如何使用这些资产工具来动画精灵之外，还回顾了iOS
    9的`assets`文件夹。然后，我们进入了模拟类似扫雷这样的拼图游戏的相对复杂的逻辑和代码。
- en: Next, we move on to iOS's 3D game development framework, SceneKit, where we
    will diverge more towards the visual tools Apple now brings to us since iOS 8
    / iOS 9\. We'll take less of a code-centric methodology now that we know the basic
    scene/code structure that both SceneKit and SpriteKit share. SpriteKit scenes
    can overlay SceneKit scenes, so we will see some of what we hinted at with Apple's
    own DemoBots demo shortly.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将转向iOS的3D游戏开发框架SceneKit，我们将更多地关注自iOS 8/iOS 9以来苹果为我们带来的视觉工具。由于我们已经了解了SceneKit和SpriteKit共享的基本场景/代码结构，我们现在将采用较少以代码为中心的方法。SpriteKit场景可以覆盖SceneKit场景，因此我们将很快看到我们用苹果自己的DemoBots演示暗示的一些内容。
