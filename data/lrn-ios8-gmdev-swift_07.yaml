- en: Chapter 7. Advanced SpriteKit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 高级 SpriteKit
- en: In this chapter, we will cover some advanced features that are present in SpriteKit,
    such as lighting and physics, that will make the process of game development easier
    and will make our game looking prettier. With lighting, we can create a light
    source and make certain objects in the scene cast shadows and get affected by
    the light. Using a physics engine, we can make the game objects automatically
    get affected by gravity and forces applied externally.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 SpriteKit 中的一些高级功能，例如灯光和物理，这将使游戏开发过程更加容易，并使我们的游戏看起来更漂亮。通过灯光，我们可以创建光源，并使场景中的某些对象产生阴影并受到光的影响。使用物理引擎，我们可以使游戏对象自动受到重力和外部施加的力的作用。
- en: We will also look at how to import classes, which are written in Objective-C,
    so that if you have already written some classes for the SpriteKit Objective-C,
    we can easily bring them into Swift without the need to rewrite the code again.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将探讨如何导入用 Objective-C 编写的类，这样如果你已经为 SpriteKit Objective-C 编写了一些类，我们可以轻松地将它们带入
    Swift，而无需再次重写代码。
- en: Using this new knowledge of importing Objective-C classes, we will look at tools
    such as Glyph Designer and Spine. With Glyph Designer, we can have custom fonts
    that take up less space and processing power than regular labels, and with Spine,
    we can create skeletal-based animation, which is a better optimized way of creating
    animations.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 使用导入 Objective-C 类的新知识，我们将探讨诸如 Glyph Designer 和 Spine 等工具。使用 Glyph Designer，我们可以拥有比常规标签占用更少空间和处理能力的自定义字体，而使用
    Spine，我们可以创建基于骨骼的动画，这是一种创建动画的更好优化方式。
- en: 'The topics covered in this chapter are as follows:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题如下：
- en: Lighting and shadows
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 灯光和阴影
- en: Sprite Illuminator
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Sprite Illuminator
- en: Physics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理
- en: Objective-C in Swift
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C 在 Swift 中
- en: Glyph Designer
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Glyph Designer
- en: Skeletal animations
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 骨骼动画
- en: Lighting and shadows
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 灯光和阴影
- en: We can create light sources in SpriteKit using a **LightNode**. The LightNode
    can be placed in the scene like a sprite node by adding it to the scene.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **LightNode** 在 SpriteKit 中创建光源。LightNode 可以像精灵节点一样放置在场景中，通过将其添加到场景中。
- en: 'To create a light source, open the `MainMenuScene` class and add the following
    after we added the background to the scene:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建光源，打开 `MainMenuScene` 类，并在我们添加背景到场景之后添加以下内容：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Similar to how we create an SKSpriteNode, we create an SKLightNode to create
    lights in Swift. We position it by centering it along the width and placing it
    at three quarters the height of the screen.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们创建 SKSpriteNode 类似，我们在 Swift 中创建 SKLightNode 来创建灯光。我们通过在宽度上居中并放置在屏幕高度的四分之三处来定位它。
- en: If you build and run the game now, you will see that there is no change to the
    scene. This is because we have to tell the scene specifically which objects should
    be affected by the light source. This is done by assigning a category bitmask
    to the light source so that we can later go to the object and tell it to be affected
    by the light of a certain bitmask. Here, we assign the bitmask as `1`. Since the
    bitmask takes a UINT32, there can be 32 light sources in total in a scene at a
    time, as there are 32 bits or 4 bytes in an integer.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在构建并运行游戏，你会看到场景没有任何变化。这是因为我们必须明确告诉场景哪些对象应该受到光源的影响。这是通过将类别掩码位赋给光源来完成的，这样我们就可以稍后去对象那里告诉它受到特定掩码位的光源的影响。在这里，我们赋值掩码为
    `1`。由于掩码位使用 UINT32，因此一个场景中一次可以有总共 32 个光源，因为整数中有 32 位或 4 个字节。
- en: By setting the bitmask category of the LightNode to `1`, we are saying the first
    bit is switched ON for this light source. So, while assigning categories, you
    won't use general integer numbers to define a category. So, the category of a
    light should be 1, 2, 4, 8, 16, and so on. Here, `1` means that the first bit
    is ON, `2` means that the second bit is ON, and `4` means that the third bit is
    ON, and so on. Do not use general numbers such as 1, 2, 3, 4, and 5 and so on
    for defining categories, as it would lead to unexpected results.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 LightNode 的掩码类别设置为 `1`，我们表示这个光源的第一个位是开启的。所以，在分配类别时，你不会使用一般的整数数字来定义一个类别。因此，灯光的类别应该是
    1、2、4、8、16 等等。在这里，`1` 表示第一个位是开启的，`2` 表示第二个位是开启的，`4` 表示第三个位是开启的，以此类推。不要使用像 1、2、3、4
    等一般的数字来定义类别，因为这会导致意外的结果。
- en: While creating light sources, we also need to provide other information regarding
    the light source, such as falloff. Like all light sources, it has maximum intensity
    at the source, and the more you move away from the source, the weaker and weaker
    the intensity becomes. Falloff determines how quickly the light source loses its
    intensity. A value of `1` means that it will never lose its value of intensity
    and `0` means that it will lose it immediately.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建光源时，我们还需要提供有关光源的其他信息，例如衰减。像所有光源一样，它在源头具有最大强度，并且你离源头越远，强度就越弱。衰减决定了光源强度下降的速度。`1`的值表示它永远不会失去其强度值，而`0`表示它会立即失去。
- en: Along with bitmask and falloff, we also need to provide the color of the light
    source, the ambient light, and the color of the shadows. For the light and shadow
    color, we give white and black. Note that in the shadow color, we reduced the
    value of the opacity as otherwise the shadows will be completely black. For the
    ambient color, we reduced the blue variable to zero, as there is enough blue from
    the sky in the background. Then, we add the light to the scene.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 除了掩码和衰减之外，我们还需要提供光源的颜色、环境光和阴影的颜色。对于光和阴影的颜色，我们给出白色和黑色。注意，在阴影颜色中，我们降低了不透明度的值，否则阴影将完全黑色。对于环境光，我们将蓝色变量降低到零，因为背景中已经有足够的蓝色。然后，我们将光源添加到场景中。
- en: To actually make an object get affected by the light source, we have to assign
    the `lightBitMask` property of that object to the category bitmask of the light
    source we assigned earlier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要使对象实际上受到光源的影响，我们必须将该对象的`lightBitMask`属性分配给之前分配的光源的分类掩码。
- en: 'So, to make the BG get affected by the light source, add the following in the
    code after where we added the BG to the scene and run the game to see the result,
    as shown in the following image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要使背景受到光源的影响，在将背景添加到场景后并在代码中添加以下内容，然后运行游戏以查看结果，如下所示图像：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Lighting and shadows](img/B04014_07_01.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![照明和阴影](img/B04014_07_01.jpg)'
- en: 'Wow! Isn''t that pretty? Here I changed the color of the font to blue so that
    the light source is easily visible. This can be done by adding the following highlighted
    line in `myLabel`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！这不是很漂亮吗？这里我将字体颜色改为蓝色，以便更容易看到光源。这可以通过在`myLabel`中添加以下高亮行来完成：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now to cast shadows, all we have to do is call `shadowCastBitMask` on the object
    that you want to cast shadows. Assign the category bitmask of the light source
    to it so that shadows can be cast.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在要投射阴影，我们只需要在你想投射阴影的对象上调用`shadowCastBitMask`。将光源的分类掩码分配给它，以便可以投射阴影。
- en: 'We will ask the play button sprite image to cast a shadow, so after adding
    the play button to the scene, add the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要求播放按钮精灵图像投射阴影，因此，在将播放按钮添加到场景后，添加以下代码：
- en: '[PRE3]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, the play button will cast a shadow depending upon where the light source
    is.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，播放按钮会根据光源的位置投射阴影。
- en: There are a few things to keep in mind while creating light sources and shadows
    in a scene. Only sprites can cast shadows in a SpriteKit scene. I tried applying
    it to the label and it wasn't able to create shadows from the text.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在场景中创建光源和阴影时，有一些事情需要记住。只有精灵可以在SpriteKit场景中投射阴影。我尝试将其应用于标签，但它无法从文本中创建阴影。
- en: If you are making an object get affected by the light, make sure that it is
    never deleted and then added back into the scene. If the object is removed, the
    light source has to recalculate the lighting in the scene, and this process is
    done again once the object is added back into the scene. This will cause a flicker
    while recalculating the light and shadows in the scene.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在制作一个受光源影响的对象，确保它永远不会被删除并重新添加到场景中。如果对象被移除，光源必须重新计算场景中的照明，这个过程在对象被重新添加到场景中时再次执行。这将在场景中重新计算光和阴影时引起闪烁。
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's is better to add shadows to objects that you know won't get deleted in
    the future.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将阴影添加到你知道将来不会删除的对象上。
- en: 'Also, in `GameViewController`, change `ignoreSiblingOrder` to `false`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`GameViewController`中，将`ignoreSiblingOrder`更改为`false`：
- en: '[PRE4]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'With that said, let us run the scene to see the shadow in action, as shown
    in the following image:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们运行场景，看看阴影的效果，如下所示图像：
- en: '![Lighting and shadows](img/B04014_07_02.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![照明和阴影](img/B04014_07_02.jpg)'
- en: This is awesome. But wouldn't it be great if we could add some moving clouds
    that cast shadows in the scene? Also, since the cloud is moving, we can use the
    parallax sprite class to make the BG scroll like we did in the previous chapter.
    We can also add a sprite for the sun and make it spin.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒。但如果我们能在场景中添加一些投射阴影的移动云层，那就太好了。此外，由于云层在移动，我们可以使用视差精灵类使背景像我们在上一章中做的那样滚动。我们还可以添加一个太阳精灵并使其旋转。
- en: To do this for this chapter, we will create a separate sprite for the sky and
    change the BG sprite to not include clouds, as we will be adding a new cloud sprite
    and moving it using the moving sprite class and making it loop around the scene.
    So, go to the resources folder of this chapter, go into the lighting directory,
    and get the sky, sun, cloud, and the new BG images. Create image assets called
    sky, sun, and cloud. Replace the old BG sprite with the new ones.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成本章的内容，我们将为天空创建一个单独的精灵，并将背景精灵的云层移除，因为我们将会添加一个新的云层精灵，并使用移动精灵类将其移动，使其在场景中循环。因此，前往本章的资源文件夹，进入照明目录，获取天空、太阳、云层和新的背景图像。创建名为天空、太阳和云层的图像资源。用新的背景精灵替换旧的背景精灵。
- en: 'In the `MainMenuScene` class, add the sky sprite first as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainMenuScene`类中，首先添加天空精灵，如下所示：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, add the sun sprite to the scene as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，按照以下方式将太阳精灵添加到场景中：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After adding the sun to the scene, make it get affected by the light. Then,
    we create a new `repeatActionForever` variable on it so that it will rotate the
    sun sprite by one degree every second forever.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在将太阳添加到场景后，使其受到光线的影响。然后，我们在其上创建一个新的`repeatActionForever`变量，使其每秒旋转太阳精灵一度，永远旋转。
- en: 'Next, at the top of the `MainMenuScene` class, add the following global variables:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`MainMenuScene`类的顶部添加以下全局变量：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we want to call the update methods on the `scrollingBg`, `cloudNode`, and
    cloud objects in the `update` function, we want them to be global variables.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望在`update`函数中调用`scrollingBg`、`cloudNode`和云对象的更新方法，因此我们希望它们是全局变量。
- en: Now, initiate the classes and variables in the `didMoveToView` method.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`didMoveToView`方法中初始化类和变量。
- en: 'First create `cloudNode` as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先按照以下方式创建`cloudNode`：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, initiate the `shadowcaste` property on `cloudNode` and add it to the
    cloud moving sprite variable so that we can update its position later:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`cloudNode`上初始化`shadowcaste`属性，并将其添加到云移动精灵变量中，以便我们稍后更新其位置：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We make the cloud move slowly when compared to the background since the background
    is moving at speed of `–5.0`. If we make both of them move at the same speed,
    then it will look as if the background and cloud are one image and moving together.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 与背景相比，我们使云层移动得较慢，因为背景以`-5.0`的速度移动。如果我们让两者以相同的速度移动，那么它们将看起来像是一张图片，并且一起移动。
- en: Below this, add the light source.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之下，添加光源。
- en: After this, initiate the `scrollingBg` class by creating two sprite images called
    `BG1` and `BG2`. Add them to the scene and initiate `lightingBitMask` on both
    the background sprites.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在此之后，通过创建两个名为`BG1`和`BG2`的精灵图像来初始化`scrollingBg`类。将它们添加到场景中，并在两个背景精灵上初始化`lightingBitMask`。
- en: 'Next, initiate the `scrollingBg` class by passing in the background sprites,
    the `viewsize`, and the speed as follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过传递背景精灵、`viewsize`和速度来初始化`scrollingBg`类，如下所示：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, we have to update the position of `scrollingBg`, the cloud, and the cloud
    node objects. So, add an update function and add the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须更新`scrollingBg`、云层和云节点对象的位置。因此，添加一个更新函数并添加以下内容：
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here we call the `update` and `moveSprite` functions of `scrollingBg` and cloud
    objects. We also update the position of the `cloudNode` sprite by settings its
    `X` position to the right of the screen once the image has gone beyond the left,
    as shown in the following image:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`scrollingBg`和云对象的`update`和`moveSprite`函数。我们还通过将`cloudNode`精灵的`X`位置设置为屏幕右侧，一旦图像超过左侧，来更新`cloudNode`精灵的位置，如图所示：
- en: '![Lighting and shadows](img/B04014_07_03.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![照明和阴影](img/B04014_07_03.jpg)'
- en: 'We have to be careful with the order in which the objects were added to the
    scene to make sure the shadows are cast properly. The order is as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须注意对象添加到场景中的顺序，以确保阴影正确投射。顺序如下：
- en: '`sky`'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sky`'
- en: '`sun`'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sun`'
- en: Cloud (`cloudNode`)
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 云（`cloudNode`）
- en: '`lightNode`'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lightNode`'
- en: '`scrollingBg` (`BG1` and `BG2`)'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`scrollingBg` (`BG1`和`BG2`)'
- en: This is important since the shadow is cast in the same depth as the light source
    and not at the depth of the object.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为阴影是在光源的深度投射，而不是在对象的深度。
- en: Tip
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In the preceding image, though we ask the light to cast on the play button,
    we don't see a shadow as we saw in the earlier screenshot since the background
    layer is above that. If you bring `lightNode` to the top-most layer, you will
    see the play button cast a shadow, but then even though the clouds are behind
    the background layer, their shadows will be seen over the trees in the background
    layer, which is odd. So, it is important at which layer you add the light source.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图像中，尽管我们要求光线照在播放按钮上，但由于背景层在上面，我们没有看到像早期截图中的阴影。如果你将`lightNode`移到最顶层，你会看到播放按钮投下阴影，但即使云层在背景层后面，它们的阴影也会在背景层的树木上显现，这看起来很奇怪。因此，在哪个层添加光源是很重要的。
- en: One more thing you have to be careful about is the size of the image that you
    want the light to get affected by. You will see that that I didn't enable the
    `lightBitMask` property on the sky image, as it brought down the FPS of the game
    to 45 and everything was running slowly on my iPadMini Retina. So I disabled lighting
    on the sky layer and just kept it on the run and background sprites. But this
    was still causing stutter and slowdown on iPad3, so I had to completely disable
    lighting on all the images to have a consistent 60 FPS.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 你还必须注意你想要光线影响的图像的大小。你会发现我没有在天空图像上启用`lightBitMask`属性，因为它将游戏的FPS降低到45，我的iPadMini
    Retina上的一切都运行得很慢。所以我禁用了天空层的照明，只保留了运行和背景精灵的照明。但即使在iPad3上，这仍然会导致卡顿和减速，所以我不得不完全禁用所有图像的照明，以保持一致的60
    FPS。
- en: Adding lighting and shadows is very hardware and processor intensive, so make
    sure you do enough testing on all the devices while implementing them in your
    game so that, irrespective of which device the game is running on, it runs at
    a smooth FPS.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 添加光照和阴影非常依赖于硬件和处理器，所以在你的游戏中实现它们时，请确保在所有设备上进行足够的测试，以确保无论游戏在哪个设备上运行，都能以平滑的FPS运行。
- en: This is all for lighting; we will move to the `GameplayScene` class to look
    at physics and see how to implement it. We will return to `MainMenuScene` when
    we look at Glyph Designer and Spine later in this chapter.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于光照的所有内容；我们将转到`GameplayScene`类，看看物理，并了解如何实现它。当我们在本章后面查看Glyph Designer和Spine时，我们将返回到`MainMenuScene`。
- en: In the next section, we will see how to add physics by replacing the small physics
    engine we created earlier, which was used to create gravity to pull the player
    down or bump the player up.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将看到如何通过替换我们之前创建的小型物理引擎来添加物理，该引擎用于创建重力以拉下玩家或推起玩家。
- en: Sprite Illuminator
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Sprite Illuminator
- en: Although SpriteKit adds a normal map on its own, you can also specify your own
    normal maps for better results. To download Sprite Illuminator, go to [https://www.codeandweb.com/spriteilluminator](https://www.codeandweb.com/spriteilluminator)
    and download the DMG file.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SpriteKit会自动添加法线图，但你也可以指定自己的法线图以获得更好的效果。要下载Sprite Illuminator，请访问[https://www.codeandweb.com/spriteilluminator](https://www.codeandweb.com/spriteilluminator)并下载DMG文件。
- en: 'Once Sprite Illuminator has been downloaded, double-click on the DMG file and
    copy the application to the **Applications** folder. Go to the Launchpad and start
    the application. Once the application launches, you should see the window as in
    the following screenshot:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 下载Sprite Illuminator后，双击DMG文件，并将应用程序复制到**应用程序**文件夹。转到启动盘，启动应用程序。一旦应用程序启动，你应该会看到以下截图中的窗口：
- en: '![Sprite Illuminator](img/B04014_07_04.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![Sprite Illuminator](img/B04014_07_04.jpg)'
- en: Let us look at the interface in detail.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看界面。
- en: On the left, we have the **Sprites** panel. The middle panel is the **Preview**
    panel, in which you can see a preview of all the changes as you make them. The
    panel on the right is called the **Tools** panel. We will drill down further into
    each of these panels.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，我们有**精灵**面板。中间面板是**预览**面板，其中你可以看到你所做的所有更改的预览。右侧的面板称为**工具**面板。我们将进一步深入了解这些面板中的每一个。
- en: The Sprites panel
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**精灵面板**'
- en: 'In the **Sprites** panel, you can modify the sprite, global light, and display
    mode as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在**精灵**面板中，你可以按如下方式修改精灵、全局光和显示模式：
- en: '**Sprite**: Here we can add or remove the sprites for which we want the normal
    map to be created.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**精灵**：在这里，我们可以添加或移除需要创建法线图的精灵。'
- en: '**Global light**: We can change the property of the global light source by
    affecting its `Z` position, brightness, light color, and ambient color. This is
    just for visualization purposes, in the game, we will have to add a light source
    and change its properties in SpriteKit.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**全局光照**：我们可以通过影响其`Z`位置、亮度、光照颜色和环境颜色来改变全局光源的属性。这只是为了可视化目的，在游戏中，我们将在 SpriteKit
    中添加光源并改变其属性。'
- en: '**Display mode**: By default, the **Lit texture** mode is ON. This gives a
    preview of how the image will look with lighting and normal map enabled. Texture
    mode will just show the texture without lighting and normal map. Lit surface will
    show the image with the light source but without the normal map. The **Normal
    map** mode will show only the normal map that you have created for an image.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示模式**：默认情况下，**光照纹理**模式是开启的。这会显示图像在启用光照和法线贴图时的预览。纹理模式将仅显示纹理而不显示光照和法线贴图。光照表面将显示带有光源的图像但不显示法线贴图。**法线贴图**模式将仅显示为图像创建的法线贴图。'
- en: The Preview panel
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 预览面板
- en: The **Preview** panel will show the preview of the image depending upon the
    mode you select in the **Display mode** section.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**预览**面板将根据你在**显示模式**部分选择的模式显示图像预览。'
- en: The Tools panel
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工具面板
- en: 'We will be spending most of the time in the tools panel. This is where we will
    be creating the height map for any image. The **Tools** panel includes **Effects**
    and **Brushes and Tools**:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在工具面板上花费大部分时间。这是我们将为任何图像创建高度图的地方。**工具**面板包括**效果**和**画笔和工具**：
- en: Under **Effects**, using the **Bevel** and **Emboss** tool we can add height
    or depth to the map. This works exactly how the same tools work in Photoshop.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在**效果**类别下，使用**斜面**和**浮雕**工具我们可以给地图添加高度或深度。这正好与 Photoshop 中的相同工具的工作方式相同。
- en: 'Under **Brushes,** five brushes are included. The brushes included are **Height**,
    **Angle**, **Structure**, **Smoothen**, and **Erase**:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在**画笔**类别下，包含五种画笔。这些画笔包括**高度**、**角度**、**结构**、**平滑**和**擦除**：
- en: '**Height**: This can be added to an area that you wish to make appear to be
    protruding from the image. You can specify the values for **Brush Size**, **Height**,
    **Hardness**, **Contour**, and **Direction** for it.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高度**：这可以添加到一个你希望看起来从图像中凸出的区域。你可以为它指定**画笔大小**、**高度**、**硬度**、**轮廓**和**方向**的值。'
- en: '**Angle**: This can be added to an area which might be at a particular angle
    to the direction of the light. This is most useful while developing isometric
    tile maps. Apart from specifying the values for **Brush Size**, **Opacity**, and
    **Hardness**, we can specify the direction of the surface by selecting the area
    around the sphere.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角度**：这可以添加到一个可能以特定角度相对于光源方向的区域。这在开发等距瓦片地图时非常有用。除了指定**画笔大小**、**不透明度**和**硬度**的值外，我们还可以通过选择球体周围的区域来指定表面的方向。'
- en: '**Structure**: This brush is used to add some rough texture to an area. You
    can modify the brush size, density, height, and direction.'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构**：这个画笔用于在某个区域添加一些粗糙的纹理。你可以修改画笔的大小、密度、高度和方向。'
- en: '**Smoothness**: This brush is used to smoothen an area. The brush size and
    smoothness can be controlled by the slider.'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平滑度**：这个画笔用于平滑某个区域。可以通过滑块控制画笔大小和平滑度。'
- en: '**Erase**: If we wish to erase an effect or brush we can do so by using the
    erase brush'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**擦除**：如果我们想擦除效果或画笔，可以使用擦除画笔。'
- en: 'There are a couple of **selection tools** that are provided that can make the
    selection process a little simpler. So, if you want to apply a brush or an effect
    in a particular area, you can isolate that area using the selection tool and apply
    the effect in just that area:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 提供了一些**选择工具**，可以使选择过程变得简单一些。所以，如果你想在一个特定区域应用画笔或效果，你可以使用选择工具隔离该区域，并在该区域应用效果：
- en: '**Wand/Color**: This tool is like the wand tool in Photoshop. You can also
    adjust the tolerance level.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '** wand/颜色**：这个工具类似于 Photoshop 中的 wand 工具。你还可以调整容差级别。'
- en: '**Polygon**: You can create a closed polygon loop around the area of an image
    with this tool.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多边形**：你可以使用这个工具在图像的某个区域周围创建一个闭合的多边形环路。'
- en: '**Move**: You can move the image with this tool.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**移动**：你可以使用这个工具移动图像。'
- en: Once you are happy with your creation, you can click on the **Publish** button
    and a normal map will be created for your image. The normal map will be a PNG
    file with the same file name as your original file suffixed with `_n`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对你的创作满意，你可以点击**发布**按钮，并为你的图像创建一个法线贴图。法线贴图将是一个 PNG 文件，文件名与原始文件相同，后缀为 `_n`。
- en: Using Sprite Illuminator, I have created a normal map for the hero sprite (shown
    in the following screenshot). The file and resources are included in the `Resources`
    folder of this chapter.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用精灵照明器，我为英雄精灵创建了一个法线贴图（如下截图所示）。文件和资源包含在本章的`Resources`文件夹中。
- en: '![The Tools panel](img/B04014_07_05.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![工具面板](img/B04014_07_05.jpg)'
- en: In the `Sprite Illuminator` folder in the `Resources` directory, I have created
    the two versions of the regular image and normal map for both the sizes. I have
    also renamed the files to avoid any name conflicts. Drag these four files into
    the project.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Resources`目录的`Sprite Illuminator`文件夹中，我为两种尺寸的常规图像和法线贴图创建了两个版本。我还重命名了文件以避免任何名称冲突。将这些四个文件拖入项目中。
- en: To use these assets in the `GamePlayScene.swift` file, comment out the old code
    for adding and animating the hero sprite, and add the following highlighted code
    instead.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`GamePlayScene.swift`文件中使用这些资源，注释掉添加和动画英雄精灵的旧代码，并添加以下突出显示的代码。
- en: Here, instead of loading the hero file in the image set, we are assigning the
    `heroSI` and `heroSI_n` texture to the hero variable.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是在图像集中加载英雄文件，而是将`heroSI`和`heroSI_n`纹理分配给英雄变量。
- en: Also, we set the `lightBitmask` property of the hero to `1` so that the light
    source affects it.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将英雄的`lightBitmask`属性设置为`1`，以便光源影响它。
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Physics
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理
- en: In other frameworks, you will most probably have to import a physics engine
    library of your choice, such as Box2d, or chipmunk would configure it to make
    it work properly. You would also have to write custom code for making collision
    detection work. In SpriteKit, every scene has physics running in the background
    as soon as the scene is created. You are not required to do anything else to make
    it work. So, in the gameplay scene, we will disable the physics engine we created
    and replace it with SpriteKit's inbuilt physics engine.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他框架中，你很可能会需要导入你选择的物理引擎库，例如Box2d或chipmunk，并配置它以使其正常工作。你还需要编写自定义代码以使碰撞检测工作。在SpriteKit中，一旦创建场景，每个场景都会在后台运行物理效果。你不需要做任何事情来使其工作。因此，在游戏场景中，我们将禁用我们创建的物理引擎，并用SpriteKit的内置物理引擎替换它。
- en: Open up the `gameplayScene.swift` file and comment out the `updateHero` function
    in the `update` function. As you might remember, the `updateHero` function took
    care of making the hero get affected by gravity, making sure the hero was inside
    the screen at all times and also making sure thrust is applied when the player
    taps the left half of the screen. Using the inbuilt physics engine, we will see
    how we can make it do all the work for us.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`gameplayScene.swift`文件，在`update`函数中注释掉`updateHero`函数。如您所记得，`updateHero`函数负责让英雄受到重力影响，确保英雄始终在屏幕内，并在玩家点击屏幕左侧时应用推力。使用内置的物理引擎，我们将看到我们如何让它为我们完成所有工作。
- en: As I said earlier, the physics is already active, meaning that there is already
    some gravity that is acting on the scene. So, let us make the hero get affected
    by gravity.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所说，物理效果已经激活，这意味着场景中已经存在一些正在作用的引力。因此，让我们让英雄受到重力的影响。
- en: 'In the `init` function, right after we added the hero sprite to the scene,
    add the following line:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，在我们将英雄精灵添加到场景之后，添加以下行：
- en: '[PRE13]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This is all we have to do to tell the hero to get affected by physics. The `physicsBody`
    property of any sprite will assign a body to the sprite, making it behave like
    a solid object, meaning that now this sprite will have physics properties like
    any object in real life. It will have a density, respond to friction, be bouncy,
    and get affected by other bodies. Now we can apply force to it or make it move
    with a certain velocity. If some moving body hits this body, as Newton said, it
    would react to that hit and move.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们告诉英雄受到物理影响所需做的所有事情。任何精灵的`physicsBody`属性都会将一个物体分配给精灵，使其表现得像一个固体物体，这意味着现在这个精灵将具有与现实生活中任何物体相同的物理属性。它将具有密度，对摩擦力做出反应，具有弹性，并受到其他物体的作用。现在我们可以施加力或以一定的速度移动它。如果移动的物体撞击这个物体，正如牛顿所说，它会对此撞击做出反应并移动。
- en: When we assign a body, we have the option of giving shape to the body. Here
    we are giving a rectangle with the same dimensions as the sprite. If we wish,
    we could have given the body the shape of a circle or we could also use a custom
    shape.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们分配一个物体时，我们可以选择给物体赋予形状。在这里，我们给物体赋予了一个与精灵相同尺寸的矩形。如果我们愿意，我们也可以给物体赋予圆形的形状，或者我们可以使用自定义形状。
- en: If we build and run the game now, we will see that the hero will just fall through
    the bottom of the screen. This is because nothing is preventing the hero from
    going through. To counter this downward motion, we have to create a body around
    the scene to prevent the hero from falling down.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在构建并运行游戏，我们会看到英雄会直接穿过屏幕底部。这是因为没有任何东西阻止英雄通过。为了对抗这种向下运动，我们必须在场景周围创建一个物理体，以防止英雄掉落。
- en: 'In the `init` function, add the following code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在`init`函数中，添加以下代码：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Previously, we attached a physics body to the hero, and now we are initiating
    the physics body property of the scene itself. The difference here is that it
    is an `edgeLoop` body type. An edge loop is different from a regular body type
    in that the former doesn't have volume. So, it doesn't have mass, density, friction,
    and so on, and you can't apply force or make it move with a velocity. But other
    bodies will get affected by it, meaning that if a regular body is moving and gets
    obstructed by an `edgeLoop`, then the regular body will stop moving.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们给英雄添加了一个物理体，而现在我们正在初始化场景本身的物理体属性。这里的区别在于它是一个`edgeLoop`类型的物理体。边环体与常规物理体不同，因为前者没有体积。所以，它没有质量、密度、摩擦等，你不能施加力或使其以速度移动。但其他物体将会受到它的影响，这意味着如果一个常规物体在移动并被`edgeLoop`阻挡，那么常规物体将停止移动。
- en: '![Physics](img/B04014_07_06.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![物理](img/B04014_07_06.jpg)'
- en: While creating an edge loop, we have to pass in the shape of the loop, so here
    we are giving the shape of a rectangle starting from the origin that is the bottom
    left of the screen, which is (0, 0), and the size of the view by passing in the
    width and height of the screen.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建边环时，我们必须传递环的形状，因此这里我们提供了从屏幕左下角的原点开始的矩形形状，即(0, 0)，并通过传递屏幕的宽度和高度来获取视图的大小。
- en: 'Now, if you build and run, you will see that the hero stops. In fact, the hero
    not only stops but also bounces a bit once she hits the bottom of the screen.
    You can set the mass, density, friction, and restitution values depending upon
    how heavy or bouncy you need your character to be by changing the values, as shown
    in the following. The values range from `0` to `1` in all cases: `0` being less
    bouncy, dense, affected by friction, and so on, and `1` being the opposite end
    of the spectrum.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行，你会看到英雄停止了。事实上，英雄不仅停止了，而且一旦她碰到屏幕底部，还会弹跳一下。你可以根据需要让角色有多重或弹跳，通过改变以下所示的价值来设置质量、密度、摩擦和恢复值。所有这些值范围从`0`到`1`：`0`表示更不弹跳、更密集、受摩擦影响等，而`1`则是光谱的另一端。
- en: '[PRE15]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can also change the value of the gravity in the scene so if you wanted to
    make a level set on the moon, you can change the default gravity to 1/6th of its
    original value to give that effect.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以更改场景中的引力值，如果你想制作一个在月球上的关卡，你可以将默认引力更改为原始值的1/6，以产生那种效果。
- en: One important thing to note about the physics engine is that it is not in pixels
    but in real-world values. For example, the default value of gravity is actually
    9.8 meters/(second * second). All the values, which are actually pixels, are converted
    to meters, and SpriteKit does the conversion from pixels to meters internally.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 关于物理引擎的一个重要注意事项是它不是以像素为单位，而是以真实世界值为单位。例如，重力的默认值实际上是9.8米/(秒 * 秒)。实际上所有以像素为单位的值都被转换为米，SpriteKit内部进行像素到米的转换。
- en: '![Physics](img/B04014_07_07.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![物理](img/B04014_07_07.jpg)'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To have moon like gravity, access the gravity property of the physics world
    property of the scene and change gravity to 1/6th of 9.8 as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要有类似月球的引力，访问场景物理世界属性的引力属性，并将引力更改为9.8的1/6，如下所示：
- en: '*self.physicsWorld.gravity = CGVector(dx: 0, dy: -1.64)*'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '*self.physicsWorld.gravity = CGVector(dx: 0, dy: -1.64)*'
- en: The `gravity` property expects a `CGVector` value since we want the gravity
    to exert a downward force, the value of `x` is zero and `y` is kept at `–1.64`
    from the default value of `–9.8` as this is what gravity would be on the moon.
    You can change it back to `–9.8` for a more Earthy feeling.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`gravity`属性期望一个`CGVector`值，因为我们希望引力施加向下的力，所以`x`的值为零，`y`保持为从默认值`-9.8`的`-1.64`，这是月球上的引力。你可以将其改回`-9.8`以获得更地球的感觉。'
- en: 'We can now add a force on the hero such that we can thrust her up in the air.
    So, in the `touchesBegan` function, we can remove the code that we previously
    added to push the hero up in the air and apply a physics force in the upward direction.
    But before we add the force, we have to set the velocity of the hero zero since
    the hero would have to overcome the downward velocity to move upward. If the velocity
    in the negative *y* direction is too big, then, irrespective of how much force
    you apply upward, it will all be nullified by the downward gravitational force
    acting on the hero. First make the downward velocity of the hero zero and then
    apply the force upward. Take the following thrust code:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以对英雄施加一个力，这样我们就可以将她推到空中。因此，在 `touchesBegan` 函数中，我们可以移除之前添加的将英雄推到空中的代码，并施加一个向上的物理力。但在我们施加力之前，我们必须将英雄的速度设置为零，因为英雄必须克服向下的速度才能向上移动。如果负
    *y* 方向的速度太大，那么，无论你向上施加多少力，都会被作用在英雄身上的向下重力力所抵消。首先将英雄的向下速度设置为零，然后向上施加力。以下是一个推力代码示例：
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Replace this with the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 将其替换为以下代码：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we set the hero's velocity to `0`. Since there is no velocity acting in
    the *x* direction, it doesn't matter if we set just the `Y` value to `0` or both
    the `X` and `Y` values to `0`.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将英雄的速度设置为 `0`。由于没有在 *x* 方向上作用的力，所以设置 `Y` 值为 `0` 或同时将 `X` 和 `Y` 值都设置为 `0`
    都没有关系。
- en: Next, we apply an **impulse** in the *y* direction with an `X` value of `0`
    and `Y` value equal to `300`. But wait!
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 *y* 方向上施加一个 `X` 值为 `0`、`Y` 值为 `300` 的冲量。但等等！
- en: Note
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**What is this impulse thing?**'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**什么是这个冲量？**'
- en: All this time we were talking about applying force and now we are actually applying
    an impulse. In the physics engine, there is a separate property called force and
    how it works is that once you apply a force to a body, the force will be constantly
    applied to the body. We just want the force to be applied once after we tap the
    left half of the screen. So, we apply an impulse and not force. If we wanted the
    player to keep moving up once we tap the screen, we should use the force property
    instead of impulse. So, be sure how you want your object to behave and apply either
    a force or an impulse on your physics object accordingly.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些时间我们都在谈论施加力，而现在我们实际上是在施加一个冲量。在物理引擎中，有一个单独的属性称为力，其工作原理是，一旦你对一个物体施加力，这个力就会持续作用于物体。我们只想在点击屏幕左半部分后一次性施加力。因此，我们施加的是冲量而不是力。如果我们想在点击屏幕后让玩家继续向上移动，我们应该使用力属性而不是冲量。所以，确保你想要你的对象如何表现，并相应地对你的物理对象施加力或冲量。
- en: And that is all. Now you have the player behaving exactly as we did with our
    own homegrown physics engine previously. Run the game and test it.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样。现在玩家表现与我们之前使用自己的物理引擎时完全一样。运行游戏并测试它。
- en: Objective-C in Swift
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Objective-C 在 Swift 中
- en: Let us now look at how to import Objective-C classes into Swift and use them.
    We will then use this to use tools such as Glyph Designer and Spine, which have
    implementations in Objective-C but don't have specific classes in Swift.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将 Objective-C 类导入 Swift 并使用它们。然后我们将使用这些工具，如具有 Objective-C 实现但 Swift 中没有特定类的
    Glyph Designer 和 Spine。
- en: For making Objective-C classes work with Swift, you will need to create a bridging
    header file. The file is usually named with the convention `<ProjectName>-Bridging-Header.h`,
    and then you will need to add the file location into **Objective-C Bridging Header**
    under **Swift Compiler – Code Generation** in the project `Build Settings`.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让 Objective-C 类与 Swift 兼容，你需要创建一个桥接头文件。该文件通常按照约定命名为 `<ProjectName>-Bridging-Header.h`，然后你需要在项目的
    `Build Settings` 下的 **Swift Compiler – Code Generation** 中添加文件位置到 **Objective-C
    Bridging Header**。
- en: Note
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are using the code provided along with this book, you might need to modify
    the path to avoid compilation errors.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用这本书附带提供的代码，你可能需要修改路径以避免编译错误。
- en: Usually, if you create a new header file in a swift project, you will be greeted
    with the following window asking to treat the current file created as the bridging
    header file, and Xcode will automatically add the location of the file in **Build
    Settings**. In case it doesn't pop up, we will have to walk through the steps
    to make sure Xcode knows where to look for the bridging header file manually.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你在 Swift 项目中创建一个新的头文件，你会看到一个窗口询问是否将当前创建的文件作为桥接头文件处理，Xcode 将自动将文件位置添加到 **Build
    Settings** 中。如果它没有弹出，我们将必须按照以下步骤进行操作，以确保 Xcode 知道在哪里查找桥接头文件，手动进行操作。
- en: '![Objective-C in Swift](img/B04014_07_08.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![Objective-C in Swift](img/B04014_07_08.jpg)'
- en: For creating the bridging header file for the current project, go to **File**
    | **New** | **File** and then select **Source** under **iOS** and select the header
    file with an "H" on it. Name the file **skGame-Bridging-Header** and click on
    **Create**.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要为当前项目创建桥接头文件，请转到**文件** | **新建** | **文件**，然后在**iOS**下选择**源**，并选择带有“H”的头文件。将文件命名为**skGame-Bridging-Header**，然后点击**创建**。
- en: Now, go to **Build Settings** and in the search type `bridging`, as shown in
    the following screenshot. Double-click to the right of **Objective–C Bridging
    Header** and drag-and-drop the bridging header file that we just created from
    the project onto the box. Hit *Enter*. Now, the project knows the location of
    the bridging header file. We can use this file to call the header files of Objective-C
    classes so that they can be shared with Swift.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到**构建设置**，在搜索框中输入`bridging`，如图所示。双击**Objective-C桥接头**右侧，并将我们刚刚创建的项目中的桥接头文件拖放到框中。按*Enter*键。现在，项目知道了桥接头文件的位置。我们可以使用这个文件来调用Objective-C类的头文件，以便它们可以被Swift共享。
- en: '![Objective-C in Swift](img/B04014_07_09.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![Objective-C in Swift](img/B04014_07_09.jpg)'
- en: Glyph Designer
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Glyph Designer
- en: Glyph Designer is an application that can be used to make fonts that can be
    used in the game. But don't we already have an SKLabel for that? That is true.
    But SKLabel takes the font from the system, and converts the font files into an
    image at run time and then displays it onto the screen. So, whenever the score
    needs to be incremented, the system will need to convert the font into an image
    and then display that on the screen. This is very similar to the problem we faced
    with sprites earlier and used Texture Packer to get around it.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Glyph Designer是一个可以用来制作游戏字体应用程序。但我们不是已经有了SKLabel吗？这是真的。但SKLabel从系统中获取字体，并在运行时将字体文件转换为图像，然后将其显示在屏幕上。所以，每当分数需要增加时，系统都需要将字体转换为图像，然后将其显示在屏幕上。这与我们之前遇到的精灵问题非常相似，我们使用了Texture
    Packer来解决这个问题。
- en: Although you can use system fonts for bigger games, it is better to use a Bitmap
    font, a font in which the letters and numbers are already converted to images
    rather than converting them every time. So, with Glyph Designer, we can create
    a Bitmap font and use it to better optimize the game.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以使用系统字体来制作大型游戏，但使用位图字体会更好，位图字体中字母和数字已经转换为图像，而不是每次都进行转换。因此，使用Glyph Designer，我们可以创建位图字体，并使用它来更好地优化游戏。
- en: Bitmap fonts are similar to a spritesheet and will have an image with all the
    letters, numbers, and symbols in it, and this image file will be accompanied with
    a data file that has the locations and size of the symbols and letters. Whenever
    a letter needs to be displayed on the screen, the data file will be checked for
    the location of the letter, which will be retrieved and then displayed on screen.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 位图字体类似于精灵图，其中包含所有字母、数字和符号的图像，并且这个图像文件将附带一个包含符号和字母位置和大小的数据文件。每当需要在屏幕上显示字母时，数据文件将检查字母的位置，然后检索并显示在屏幕上。
- en: The trial version of the application can be downloaded from [https://71squared.com/glyphdesigner](https://71squared.com/glyphdesigner).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从[https://71squared.com/glyphdesigner](https://71squared.com/glyphdesigner)下载应用程序的试用版。
- en: '![Glyph Designer](img/B04014_07_10.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![Glyph Designer](img/B04014_07_10.jpg)'
- en: After downloading the application, you can open it and it will create a new
    untitled project. On the left panel, you will see a list of all the fonts that
    are present in the system. The center view shows the spritesheet of the file that
    will be created. This is a preview window and will dynamically change according
    to the changes you make.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下载应用程序后，你可以打开它，它将创建一个新的未命名项目。在左侧面板中，你会看到系统中所有字体列表。中心视图显示了将要创建的文件精灵图。这是一个预览窗口，会根据你做的更改动态变化。
- en: 'The right panel is where you will be making most of the changes after selecting
    the font that you want to modify on the left. On the right panel, you will find
    the following headings (as shown in the following screenshot):'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择左侧要修改的字体后，你将在右侧面板中进行大部分更改。在右侧面板中，你会找到以下标题（如图所示）：
- en: '**Glyph Info**'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号信息**'
- en: '**Texture Atlas**'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理图集**'
- en: '**Glyph Fill**'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号填充**'
- en: '**Glyph Stroke**'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号笔画**'
- en: '**Glyph Shadow**'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**符号阴影**'
- en: '**Included Glyphs**'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**包含的符号**'
- en: '![Glyph Designer](img/B04014_07_11.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![Glyph Designer](img/B04014_07_11.jpg)'
- en: 'You should be mostly concerned with **Glyph Fill**, **Stroke**, and **Shadow**:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该主要关注**符号填充**、**笔画**和**阴影**：
- en: '**Glyph Fill**: We can select the type of fill, that is **Solid**, **Gradient**,
    or **Image**. So, basically we can select the color of the font here.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glyph Fill**：我们可以选择填充类型，即**实心**、**渐变**或**图像**。所以，基本上我们在这里可以选择字体的颜色。'
- en: '**Glyph Stroke**: This will create a new stroke effect around the letter. You
    can select the color and the size of the stroke here.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glyph Stroke**：这将围绕字母创建一个新的描边效果。在这里，你可以选择描边的颜色和大小。'
- en: '**Glyph Shadow**: Here we can select the color and direction of the shadows.
    There are two types of shadows: inner and outer. This effect will give the letters
    a bit of depth.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Glyph Shadow**：在这里，我们可以选择阴影的颜色和方向。有两种类型的阴影：内阴影和外阴影。这种效果会给字母带来一些深度感。'
- en: Once you are satisfied with the changes, click on the **Export** button and
    select the format. You can select the `skf @2` version or the normal `skf` version
    for generating the files for **2x** and **1x** resolutions.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你对更改满意，点击 **导出** 按钮并选择格式。你可以选择 `skf @2` 版本或正常的 `skf` 版本来生成 **2x** 和 **1x**
    分辨率的文件。
- en: '![Glyph Designer](img/B04014_07_12.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![Glyph Designer](img/B04014_07_12.jpg)'
- en: Implementing a Bitmap font
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现位图字体
- en: Make sure you select `.skf` in the export type. This will create a folder with
    `.atlas` at the end with all the characters and symbols in it and a `.skf` file
    that is the data file associated with the font.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 确保选择 `.skf` 作为导出类型。这将创建一个以 `.atlas` 结尾的文件夹，其中包含所有字符和符号，以及与字体相关联的数据文件 `.skf`。
- en: Drag both the `.atlas` folder and the `.skf` file into the project.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `.atlas` 文件夹和 `.skf` 文件拖入项目。
- en: 'Now we are ready to implement the Bitmap font in the game:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好在游戏中实现位图字体：
- en: For making Glyph Designer work with SpriteKit, we will need the universal static
    library created by 71Squared. Go to [https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit](https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit)
    and download the `libSSBitmapFont.zip` file from the bottom of the page.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了让 Glyph Designer 与 SpriteKit 兼容，我们需要使用 71Squared 创建的通用静态库。请访问 [https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit](https://71squared.zendesk.com/hc/en-us/articles/200037472-Using-Glyph-Designer-1-8-with-Sprite-Kit)，并从页面底部下载
    `libSSBitmapFont.zip` 文件。
- en: After the file is downloaded, extract it and drag the `SSBitmapFont.h` and `SSBitmapFontLableNode.h`
    files into the project. Don't drag the folder containing the files, but just the
    individuals files themselves. Also, drag the `libSSBitmapFont.a` file into the
    project.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 文件下载完成后，解压并将 `SSBitmapFont.h` 和 `SSBitmapFontLableNode.h` 文件拖入项目。不要拖动包含文件的文件夹，只需拖动单个文件。同时，将
    `libSSBitmapFont.a` 文件拖入项目。
- en: 'Go to the bridged header file we created earlier and import the two header
    `SSBitmapFont.h` and `SSBitmapFontLabelNode.h` files in the bridged header file
    as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往我们之前创建的桥接头文件，并在桥接头文件中导入两个头文件 `SSBitmapFont.h` 和 `SSBitmapFontLabelNode.h`，如下所示：
- en: '[PRE18]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now we can access the files anywhere in our Swift project.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在 Swift 项目的任何地方访问这些文件。
- en: To make sure everything works correctly, just build the project to make sure
    that there aren't any errors popping up.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保一切正常工作，只需构建项目以确保没有错误弹出。
- en: In the `MainMenuScene` class, we will use the Bitmap font to display the name
    of the game instead of `SKLabelNode`. Open the `MainMenuScene` class. At the top
    of the class, add the following code. This is similar to what we did to get the
    `bgMusic.mp3` file in the `GameViewController` class. But here we will get the
    SKF file from the main bundle location of the project.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainMenuScene` 类中，我们将使用位图字体来显示游戏名称，而不是使用 `SKLabelNode`。打开 `MainMenuScene`
    类。在类的顶部添加以下代码。这与我们在 `GameViewController` 类中获取 `bgMusic.mp3` 文件的方式类似。但在这里，我们将从项目的主包位置获取
    SKF 文件。
- en: '[PRE19]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here we create a new variable called `bmFontFile`, and using the `SSBitmapFont`
    class we imported from Objective-C, we get the name of the `skGame_font` font
    file from the project location. Along with the name, we also need to provide the
    extension of the `skf` file.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个名为 `bmFontFile` 的新变量，并使用从 Objective-C 导入的 `SSBitmapFont` 类，从项目位置获取
    `skGame_font` 字体文件的名称。除了名称外，我们还需要提供 `skf` 文件的扩展名。
- en: 'Since we have the `bmFont` file saved, we can use this file to create new text
    or a label by passing in the text and assigning the position, and adding it to
    the scene. So, we replace the code of `SKLabelNode` that we had added previously
    with the following code to see the Bitmap font in action:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们已经保存了`bmFont`文件，我们可以通过传入文本并指定位置，然后将它添加到场景中，来使用此文件创建新的文本或标签。因此，我们用以下代码替换了我们之前添加的`SKLabelNode`代码，以查看位图字体的实际效果：
- en: '[PRE20]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We create a new constant called `bmFontText` and use the `nodeFromString` property
    of `bmFontFile` to assign the `Ms.TinyBazooka` text to it. We set the position
    as usual and add the `bmFontText` to the scene:![Implementing a Bitmap font](img/B04014_07_13.jpg)
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建了一个新的常量`bmFontText`，并使用`bmFontFile`的`nodeFromString`属性将`Ms.TinyBazooka`文本分配给它。我们像往常一样设置位置，并将`bmFontText`添加到场景中：![实现位图字体](img/B04014_07_13.jpg)
- en: You can immediately see that the Bitmap font is a lot sharper than the text
    created with `SKLableNode`. So, it is no surprise that these days, games made
    by both professional companies both independent developers use Bitmap fonts instead.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以立即看到，位图字体比使用`SKLableNode`创建的文本要清晰得多。因此，毫不奇怪，如今，无论是专业公司还是独立开发者，都使用位图字体。
- en: Skeletal animation
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 骨骼动画
- en: In an earlier chapter, we saw how to make animations in the game using frame-based
    animation, in which we imported a series of images and created an animation by
    cycling through the frames. Although frame-based animations are good, they can
    be tedious to make. The artist has to draw each frame and you can't have too many
    frames if you want to keep the bundle size low. As a result, the animations don't
    look very fluid. Moreover, if you want to make some changes to the character,
    then it is back to the drawing board for the artist, as he has to go through all
    the frames of the animations and redo them.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了如何使用基于帧的动画在游戏中制作动画，其中我们导入了一系列图像，并通过循环帧来创建动画。尽管基于帧的动画很好，但制作起来可能会很繁琐。艺术家必须绘制每一帧，如果您想保持包的大小低，则不能有太多的帧。因此，动画看起来不太流畅。此外，如果您想对角色进行一些修改，那么艺术家就必须回到画板前，因为他必须通过动画的所有帧并重新绘制它们。
- en: 'Using the skeletal animation technique instead of making the individual frames
    for animation, we import individual parts of the character and make a spritesheet,
    as shown in the following:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 使用骨骼动画技术而不是为动画制作单独的帧，我们导入角色的各个部分并制作一个精灵图集，如下所示：
- en: '![Skeletal animation](img/B04014_07_14.jpg)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_14.jpg)'
- en: Using an application, we position the parts of the character and then create
    an animation. This way we can create different animations such as walking, running,
    jumping, attacking, and so on, from the body parts. All the animations are exported
    as a data file.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用应用程序，我们定位角色的各个部分，然后创建动画。这样，我们可以从身体部分创建不同的动画，如行走、跑步、跳跃、攻击等，所有动画都导出为数据文件。
- en: When the data file and character parts are brought into the game, the data file
    will be referred to place parts of the character to form the posture of the character.
    Later, when we call an animation to play on the character, the data file will
    be referred to again to create the movement dynamically. Lets us see how to create
    skeletal animations.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据文件和角色部分被带入游戏中时，数据文件将被用来放置角色的各个部分以形成角色的姿势。稍后，当我们调用动画在角色上播放时，数据文件将再次被用来动态地创建运动。让我们看看如何创建骨骼动画。
- en: For creating the animations, we will be using an application called **Spine**
    by Esoteric Software. You can download the trial version from their website at
    [http://esotericsoftware.com/](http://esotericsoftware.com/).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建动画，我们将使用Esoteric Software公司的一个名为**Spine**的应用程序。您可以从他们的网站[http://esotericsoftware.com/](http://esotericsoftware.com/)下载试用版。
- en: '![Skeletal animation](img/B04014_07_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_15.jpg)'
- en: The trial version won't allow you to save the project but I have included the
    project file with the resources for this chapter so that you can open it in the
    trial version and play around with it.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 试用版不允许您保存项目，但我已经包含了本章的资源项目文件，以便您可以在试用版中打开它并对其进行操作。
- en: After downloading the DMG file from the site, double-click on it to install
    it. Once the installation is complete, click on the spine logo on the top left
    side of the screen to create a new project, as shown in the following screenshot.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 从网站上下载DMG文件后，双击它进行安装。安装完成后，点击屏幕左上角的spine标志创建一个新项目，如下面的截图所示。
- en: Next we have to bring in the parts of the character so that we can pose the
    character properly for animation. This phase is called the character setup.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须引入角色的各个部分，以便我们可以为动画正确地摆姿势。这个阶段被称为角色设置。
- en: In the resources for this chapter in the spine folder, you will find a folder
    called `heroParts`, copy this folder onto the desktop.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在脊柱文件夹中本章的资源中，你会找到一个名为`heroParts`的文件夹，将此文件夹复制到桌面上。
- en: When you open Spine, the default project will be loaded. For creating a new
    project, click on the Spine icon on the top left and then select **New Project**.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 当你打开Spine时，默认项目将被加载。要创建一个新项目，请点击屏幕左上角的Spine图标，然后选择**新建项目**。
- en: '![Skeletal animation](img/B04014_07_16.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_16.jpg)'
- en: On the **Tree** panel on the right-hand side, in the **Hierarchy** panel, select
    the **Images** folder, as in the preceding screenshot. At the bottom you will
    now be able to select the path to the `heroParts` folder. Click on **Browse**
    and point it to the other `heroParts` folder on the desktop.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧的**树**面板上，在**层次**面板中，选择**图像**文件夹，如图所示。在底部，你现在可以选中`heroParts`文件夹的路径。点击**浏览**并指向桌面上的另一个`heroParts`文件夹。
- en: All the parts will appear under the **Images** tab. Next, drag all the parts
    onto the checked view panel. You can click on the individual parts and use the
    rotate and translate button in the **Transform** panel on the bottom to place
    the parts of the hero. If some parts need to be in front of others, then click
    on the triangle next to **Draw Order** in the **Hierarchy** panel and drag an
    image to make it appear above or below any other object.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 所有部分都将出现在**图像**选项卡下。接下来，将所有部分拖动到选中的视图面板中。你可以点击单个部分，并在屏幕底部的**变换**面板中使用旋转和平移按钮来放置英雄的部分。如果某些部分需要放在其他部分之前，那么在**层次**面板中点击**绘制顺序**旁边的三角形，并将一个图像拖动以使其出现在任何其他对象之上或之下。
- en: The small plus at the center of the view panel is the root node. Move this node
    to the middle of the character by locking the images by clicking on the **Images**
    button in the **Compensate** panel on the bottom of the screen. You can rename
    the root node by clicking on it. Rename it to `hip` for the sake of convenience.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 视图面板中心的加号是根节点。通过在屏幕底部的**补偿**面板中点击**图像**按钮锁定图像，将此节点移动到角色的中间。你可以通过点击它来重命名根节点。为了方便起见，将其重命名为`hip`。
- en: 'Once the character is set up properly, it should look like the following image.
    Refer to the following screenshot for checking the **Draw Order**:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦角色设置正确，它应该看起来像以下图像。参考以下截图以检查**绘制顺序**：
- en: '![Skeletal animation](img/B04014_07_17.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_17.jpg)'
- en: Next we will draw the bones. Bones work very similarly to human bones. You can
    attach one or more parts of the character to a bone, and then when you move or
    rotate the bone, the character part will move or rotate accordingly.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们将绘制骨骼。骨骼的工作方式与人类骨骼非常相似。你可以将角色的一个或多个部分附着到骨骼上，然后当你移动或旋转骨骼时，角色部分将相应地移动或旋转。
- en: First, we will create bones for the legs. To create bones, click on the **Create**
    button with the bones icon on it on the **Tools** panel on the bottom of the screen.
    Now we will create a bone from the hip to the left foot. Left click on **hip**
    to start creating a bone. While still holding the left mouse button, move the
    mouse toward the left-foot image. Press the *Shift* key on the keyboard while
    over the left foot. Once the left foot is highlighted, release the mouse button
    and *Shift* key.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将为腿部创建骨骼。要创建骨骼，请点击屏幕底部**工具**面板上带有骨骼图标的**创建**按钮。现在我们将从臀部创建一个到左脚的骨骼。左键点击**臀部**开始创建骨骼。在仍然按住左鼠标按钮的同时，将鼠标移动到左脚图像上。在左脚上方按下键盘上的*Shift*键。一旦左脚被高亮显示，释放鼠标按钮和*Shift*键。
- en: Now do the process again for the other foot. Start from the hip and press the
    *Shift* key, and when the other foot is highlighted, release the mouse and *Shift*
    key. It is OK if the bone is not perfectly aligned with the foot.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在为另一只脚重复此过程。从臀部开始，并按下*Shift*键，当另一只脚被高亮显示时，释放鼠标和*Shift*键。如果骨骼没有与脚完美对齐，这是可以的。
- en: Again, from the hip, create a bone to the body so that it is closer to the start
    of the hand, but make sure the body is highlighted and not the hand. Name this
    bone `body` in the **Hierarchy** panel. Now, from the end of this newly created
    bone, create one bone for the hand and another for the head of the character.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，从臀部创建一个骨骼到身体，使其更接近手的起始位置，但确保身体被突出显示，而不是手。在**层次结构**面板中将这个骨骼命名为`body`。现在，从这个新创建的骨骼的末端创建一个用于手的骨骼和另一个用于角色头部的骨骼。
- en: 'You will notice that the bazooka is still attached to the hip or the root bone.
    In the **Hierarchy** panel, move the bazooka node under the hand bone. This way,
    the bazooka will move along with the hand bone. The following screenshot shows
    the bone hierarchy after completion:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到火箭筒仍然连接在臀部或根骨骼上。在**层次结构**面板中，将火箭筒节点移动到手骨骼下。这样，火箭筒就会随着手骨骼移动。以下截图显示了完成后的骨骼层次结构：
- en: '![Skeletal animation](img/B04014_07_18.jpg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_18.jpg)'
- en: Now you can click on the individual bones, rotate them, and when you rotate
    the bone, the body part also rotates along with it. Here is the character in different
    poses.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以点击单个骨骼，旋转它们，当你旋转骨骼时，身体部分也会随之旋转。这里展示了角色的不同姿势。
- en: Note
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure the rotate button is clicked on in the **Transpose** panel and the
    images are not locked.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在**转置**面板中点击了旋转按钮，并且图像没有被锁定。
- en: '![Skeletal animation](img/B04014_07_19.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_19.jpg)'
- en: Now, the character is setup and ready to be animated. Click on the **Setup**
    button on the **View** panel. You are now in **Animation** mode. A new panel will
    open up below called **DopeSheet**. Click on the **Animations** heading under
    the **Hierarchy** panel and click on **NewAnimations** at the bottom of the screen.
    A new window will open, asking for a name, enter `walk` here and Click on **OK**.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，角色已经设置好，准备进行动画制作。点击**视图**面板上的**设置**按钮。你现在处于**动画**模式。一个新面板将在下面打开，称为**Dopesheet**。在**层次结构**面板下点击**动画**标题，然后在屏幕底部点击**新动画**。将打开一个新窗口，要求输入名称，在这里输入`walk`并点击**确定**。
- en: 'Apart from the new **Dopesheet** panel, you will see that the **Transformation**
    panel has also changed a bit. If you click on any bone, a green key symbol appears
    next to the **Rotate**, **Translate**, and **Scale** buttons, as shown in the
    following screenshot:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 除了新的**Dopesheet**面板外，你还会看到**变换**面板也略有变化。如果你点击任何骨骼，**旋转**、**平移**和**缩放**按钮旁边会出现一个绿色键符号，如下面的截图所示：
- en: '![Skeletal animation](img/B04014_07_20.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_20.jpg)'
- en: These keys record the changes made in the **Rotation**, **Translation**, and
    **Scale** buttons of that bone. Green signifies that no changes have been recorded.
    Click on the three green buttons in the **Transform** panel at the 0th frame.
    Now, the values have been recorded as the keys have changed from green to red.
    Now, move the time line slider in blue from the 0th frame in the dopesheet to
    the 5th frame. Again the keys are green. Rotate the leg back a little bit and
    once again click on all three keys to make them red.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这些键记录了该骨骼**旋转**、**平移**和**缩放**按钮所做的更改。绿色表示没有记录任何更改。在0帧的**变换**面板中点击三个绿色按钮。现在，值已经被记录，因为键已经从绿色变为红色。现在，将蓝色的时间线滑块从dopesheet中的0帧移动到5帧。再次，键是绿色的。稍微旋转腿部，然后再次点击所有三个键使它们变为红色。
- en: If you move the timeline slider between the 0th and 5th frames, you will see
    the leg rotating back and forth. Click on the play button to see the animation
    in action. Click on the loop button to the right end of the play button to loop
    the animation. This is how an animation is created.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将时间轴滑块在0帧和5帧之间移动，你会看到腿部来回旋转。点击播放按钮查看动画效果。点击播放按钮右侧的循环按钮以循环动画。这就是创建动画的方法。
- en: We will create a simple walk cycle animation that we will later import in the
    game and play the animation. Undo all the actions to go back to the original pose.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的行走循环动画，稍后将其导入游戏并播放动画。撤销所有操作以回到原始姿势。
- en: For creating the walk cycle, we record the position, rotation, and scale of
    all the bones in the 0th, 6th, 12th, 18th, and 24th frames. The pose on the 0th
    and 24th frames is the same. The pose in the 12th frame is the opposite of that
    in the 0th frame, as the position of the feet will be interchanged, meaning the
    foot that was previously at the back in the 0th frame will be at the front and
    vice versa. At the 6th and 18th frames, the feet will be brought back together
    and the character will be raised by moving the hip/root.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建行走循环，我们在第0帧、第6帧、第12帧、第18帧和第24帧记录了所有骨骼的位置、旋转和缩放。第0帧和第24帧的姿势相同。第12帧的姿势与第0帧相反，因为脚的位置将会互换，这意味着在第0帧中原本在后面的脚将移到前面，反之亦然。在第6帧和第18帧，将脚重新放在一起，并通过移动臀部/根骨来提升角色。
- en: The following screenshot shows the poses at different frames. Starting from
    the left, the first pose is for the 0th and 24th frames. So, rotate the leg bones
    apart, and select all the bones and create a key by clicking on all three green
    key buttons. Keeping the same pose, move the time slider to the 24th frame and
    click on the key buttons again.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了不同帧的姿势。从左到右，第一个姿势是第0帧和第24帧的。因此，旋转腿骨分开，选择所有骨骼，并通过点击所有三个绿色关键按钮来创建关键。保持相同的姿势，将时间滑块移动到第24帧，然后再次点击关键按钮。
- en: The middle image shows the pose for the 12th frame where the legs are switched.
    So, once again, rotate the legs and move the time slider to the 12th frame and
    click on the key buttons.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 中间的图像显示了第12帧的姿势，此时腿已经交换。因此，再次旋转腿，并将时间滑块移动到第12帧，然后点击关键按钮。
- en: The image on the right shows the pose for the 6th and 18th frames. Here, move
    the legs closer and raise the character by moving the hip bone up. Move the time
    slider to the 6th frame and create a key frame. To create the key frame for the
    18th frame, no changes are made to the pose. Just move the time slider to the
    18th frame and create a new key frame. That's it; your walk cycle is ready. Click
    on the play button and enjoy!
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 右侧的图像显示了第6帧和第18帧的姿势。在这里，将腿靠近，并通过向上移动臀部骨骼来提升角色。将时间滑块移动到第6帧并创建关键帧。为了创建第18帧的关键帧，对姿势不做任何更改。只需将时间滑块移动到第18帧并创建一个新的关键帧即可。就这样；你的行走循环就准备好了。点击播放按钮并享受吧！
- en: Make sure all the bones were selected when clicking on the green button to record
    the frame.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在点击绿色按钮记录帧时选择了所有骨骼。
- en: '![Skeletal animation](img/B04014_07_21.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_21.jpg)'
- en: Now, if you have the essential or pro version of Spine, you can export the data
    file by clicking on the Spine icon on the top left and then clicking on **Export**.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你拥有Spine的精华版或专业版，你可以通过点击左上角的Spine图标，然后点击**导出**来导出数据文件。
- en: The exported data type will be of type `.json`. Select the location where you
    want the data file to be exported and leave the other values as default. Click
    on the **Export** button to export the JSON data file.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 导出的数据类型将是`.json`类型。选择你想要导出数据文件的位置，并将其他值保留为默认值。点击**导出**按钮来导出JSON数据文件。
- en: When you export the file, you will notice that the data file is named skeleton.
    Rename the file to `player` manually, as every time the file is named skeleton
    by default and we don't want this file to be overwritten while creating JSON files
    for other characters.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导出文件时，你会注意到数据文件被命名为skeleton。请手动将文件重命名为`player`，因为每次文件默认命名为skeleton，我们不希望这个文件在为其他角色创建JSON文件时被覆盖。
- en: To create the atlas for the images for the spine animation, create a folder
    called `player.atlas` and copy all the character parts from the `heroParts` folder
    into it.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 要为脊动画创建图像的图集，创建一个名为`player.atlas`的文件夹，并将`heroParts`文件夹中的所有角色部分复制到其中。
- en: Now drag the `player.atlas` and `player.json` files into the project.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将`player.atlas`和`player.json`文件拖入项目。
- en: For animating the character, we require the Spine runtime. Similar to Glyph
    Designer, it is written in Objective-C, but as we did earlier, we will import
    the header file in the bridging header file and make the Objective-C classes accessible
    in Swift.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 为了对角色进行动画处理，我们需要Spine运行时。与Glyph Designer类似，它是用Objective-C编写的，但正如我们之前所做的那样，我们将导入头文件到桥接头文件中，并使Objective-C类在Swift中可访问。
- en: To get the header files, go to [https://github.com/mredig/SGG_SKSpineImport](https://github.com/mredig/SGG_SKSpineImport),
    and download the ZIP file and extract it. From the extracted folder, go to the
    `SpineImporter` folder and drag all the files in the folder to the Swift project.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取头文件，请访问[https://github.com/mredig/SGG_SKSpineImport](https://github.com/mredig/SGG_SKSpineImport)，下载ZIP文件并解压。从解压的文件夹中，转到`SpineImporter`文件夹，并将文件夹中的所有文件拖到Swift项目中。
- en: 'In the `Bridging Header` file, add the `SpineImport.h` file as follows:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Bridging Header`文件中，添加`SpineImport.h`文件，如下所示：
- en: '[PRE21]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `MainMenuScene` class, we will add the player animation. At the top
    of the class, create a global variable hero and assign the `SGG_Spine` class to
    it as follows:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainMenuScene`类中，我们将添加玩家动画。在类的顶部，创建一个全局变量hero，并将其分配给`SGG_Spine`类，如下所示：
- en: '[PRE22]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, add the following code right after where we added `BG1` and `BG2` to the
    scene:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在将`BG1`和`BG2`添加到场景之后，添加以下代码：
- en: '[PRE23]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We provide the name of the JSON data file and the name of the atlas in the `skeletonFromFile`
    property of the hero. Since we didn't use any skins in the game, the third parameter
    is kept `nill`.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在英雄的`skeletonFromFile`属性中提供了JSON数据文件的名称和图集的名称。由于我们在游戏中没有使用任何皮肤，第三个参数保持为`nill`。
- en: We, then, position the hero variable and increase the scale a bit.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将英雄变量定位并稍微增加其缩放比例。
- en: To tell which animation to start playing, we use the `runAnimation` property
    of the hero and assign the walk animation we created in spine.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 为了告诉要播放哪个动画，我们使用英雄的`runAnimation`属性，并分配我们在spine中创建的行走动画。
- en: 'Finally, we add the hero to the scene. Build and run the game to see the final
    result, as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将英雄添加到场景中。构建并运行游戏，查看以下截图所示的最终结果：
- en: '![Skeletal animation](img/B04014_07_22.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![骨骼动画](img/B04014_07_22.jpg)'
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you saw how to add lighting and shadows to our game without
    much effort. Since Apple included it with SpriteKit, you can be sure the code
    to create the effect is well optimized. In other frameworks, this effect has to
    be written by a developer, and the developer needs to have good experience to
    make an optimized lighting and shadow effect.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您看到了如何不费吹灰之力地为我们的游戏添加光照和阴影。由于Apple将其包含在SpriteKit中，您可以确信创建效果的代码已经得到了很好的优化。在其他框架中，这个效果需要由开发者编写，并且开发者需要有良好的经验才能制作出优化的光照和阴影效果。
- en: We also had a brief introduction to SpriteKit's physics engine and replaced
    our homemade physics engine with it. Here we have barely even scratched the surface
    of the possibilities with the physics engine. With good knowledge and experience,
    we can make our own Angry Birds clone.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还简要介绍了SpriteKit的物理引擎，并用它替换了我们自制的物理引擎。在这里，我们对物理引擎的可能性几乎只是触及了皮毛。有了良好的知识和经验，我们可以制作出自己的愤怒的小鸟克隆版。
- en: Apart from SpriteKit's Lighting and Physics engines, we also saw how to bring
    Objective-C code into Swift and make use of it to implement tools such as Glyph
    Designer and Spine. Both Glyph Designer and Spine are professional tools that
    are an absolute must for game developers and designers. They really help in optimizing
    and simplifying the game development process by a lot.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 除了SpriteKit的光照和物理引擎之外，我们还看到了如何将Objective-C代码引入Swift，并利用它实现如Glyph Designer和Spine等工具。Glyph
    Designer和Spine都是专业工具，对于游戏开发者和设计师来说是绝对必须的。它们真的在很大程度上帮助优化和简化了游戏开发过程。
- en: It is time to say goodbye to Ms. TinyBazooka, for, in the next two chapters,
    we will be entering the world of 3D game development. But we will return to SpriteKit
    in [Chapter 10](ch10.html "Chapter 10. Publishing and Distribution"), *Publishing
    and Distribution*, where we will see how to publish this game to the App Store.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候向TinyBazooka小姐说再见了，因为在接下来的两个章节中，我们将进入3D游戏开发的世界。但我们在第10章（[Chapter 10. 发布和分发](ch10.html
    "Chapter 10. Publishing and Distribution")）中会回到SpriteKit，我们将看到如何将这款游戏发布到App Store。
