- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Taking the First Steps with Swift
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift入门第一步
- en: 'Ever since I was 12 years old and wrote my first program in BASIC, I have been
    passionate about programming. Even as I became a professional programmer, programming
    remained more of a passion than a job, but in the years preceding the first release
    of Swift, that passion had waned. I was unsure why I was losing that passion.
    I attempted to recapture it with some of my side projects, but nothing really
    brought back the excitement that I used to have. Then, something amazing happened:
    Apple announced Swift in 2014\. Swift is such an exciting and progressive language
    that it has brought a lot of that passion back for me and made programming fun
    again. With official versions of Swift available for the Linux and Windows platforms
    and an unofficial version for the ARM platform, developing with Swift is becoming
    available to people outside the Apple ecosystem. There are also some very exciting
    projects using Swift, such as TensorFlow for machine learning and CoreML for IBM
    Watson. This is an exciting time to be learning the Swift language.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我在12岁时用BASIC编写了我的第一个程序以来，我就对编程充满热情。即使我成为了一名专业程序员，编程对我来说更多的是一种热情而非工作，但在Swift首次发布之前的那几年里，这种热情已经减弱。我不确定为什么我会失去这种热情。我试图通过一些我的副项目来重新找回它，但没有什么真正能让我找回曾经拥有的那种兴奋感。然后，发生了令人惊讶的事情：苹果公司在2014年宣布了Swift。Swift是一种如此令人兴奋和进步的语言，它让我重新找回了很多那种热情，并让编程再次变得有趣。随着Swift的官方版本可用于Linux和Windows平台，以及ARM平台的不官方版本，使用Swift进行开发正在变得对苹果生态系统之外的人开放。还有一些非常令人兴奋的项目使用Swift，例如用于机器学习的TensorFlow和用于IBM
    Watson的CoreML。这是一个学习Swift语言的好时机。
- en: 'In this chapter, you will learn about the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下主题：
- en: What is Swift?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是Swift？
- en: What are some of the features of Swift?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift有哪些特性？
- en: What are playgrounds?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是playgrounds？
- en: How to use playgrounds
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用playgrounds
- en: What are the basic syntaxes of the Swift language?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swift语言的基本语法是什么？
- en: What is Swift?
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是Swift？
- en: Swift is a programming language that was introduced by Apple at the **Worldwide
    Developers Conference** (**WWDC**) in 2014\. Swift was arguably the most significant
    announcement at WWDC 2014 and very few people, including Apple insiders, were
    aware of the project's existence prior to it being announced.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Swift是一种由苹果公司在2014年的**全球开发者大会**（**WWDC**）上推出的编程语言。Swift可以说是2014年WWDC上最重要的公告，包括苹果内部人士在内的很少有人在此之前知道这个项目的存在。
- en: It was amazing, even by Apple's standards, that they could keep Swift a secret
    for as long as they did and that no one suspected they were going to announce
    a new development language. At WWDC 2015, Apple made another big splash when they
    announced Swift 2\. Swift 2 was a major enhancement to the Swift language. During
    that conference, Chris Lattner said that a lot of the enhancements were based
    on direct feedback that Apple received from the development community. It was
    also announced that Swift would become an open source project. In my opinion,
    this was the most exciting announcement of WWDC 2015.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 即使按照苹果的标准，他们能够将Swift保密这么长时间，而且没有人怀疑他们将要宣布一个新的开发语言，这仍然令人惊讶。在2015年WWDC上，苹果公司再次引起了轰动，当他们宣布Swift
    2时。Swift 2是对Swift语言的重大增强。在这次会议上，Chris Lattner表示，许多增强都是基于苹果从开发社区直接收到的反馈。还宣布Swift将成为一个开源项目。在我看来，这是2015年WWDC上最令人兴奋的公告。
- en: In December 2015, Apple officially released Swift as open source with the [https://swift.org/site](https://swift.org/site),
    which is dedicated to the open source Swift community. The Swift repository is
    located on Apple's GitHub page ([http://github.com/apple](http://github.com/apple)).
    The Swift evolution repository ([https://github.com/apple/swift-evolution](https://github.com/apple/swift-evolution))
    tracks the evolution of Swift by documenting the proposed changes. A list of which
    proposals were accepted and rejected can be found in the evolution repository.
    In addition to these resources, Apple has moved away from using mailing lists
    as the primary form of communication with the Swift community, and has set up
    Swift forums ([https://forums.swift.org](https://forums.swift.org)).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在2015年12月，苹果公司正式将Swift语言以开源的形式发布，网址为[https://swift.org/site](https://swift.org/site)，该网站致力于开源Swift社区。Swift的代码库位于苹果公司的GitHub页面([http://github.com/apple](http://github.com/apple))上。Swift进化代码库([https://github.com/apple/swift-evolution](https://github.com/apple/swift-evolution))通过记录提议的变更来追踪Swift的进化。可以在这个进化代码库中找到哪些提议被接受和拒绝的列表。除此之外，苹果公司已经不再使用邮件列表作为与Swift社区的主要沟通方式，并建立了Swift论坛([https://forums.swift.org](https://forums.swift.org))。
- en: Swift 3, which was released in 2016, was a major enhancement to the Swift language
    that was not source-compatible with previous releases of the Swift language. It
    contained fundamental changes to the language itself and to the Swift standard
    library. One of the main goals of Swift 3 was to be source-compatible across all
    platforms, so the code that was written for one platform would be compatible with
    all other platforms. This means that the code we develop for macOS should work
    on Linux.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 2016年发布的Swift 3是对Swift语言的重大增强，它不与Swift语言的先前版本保持源代码兼容性。它包含了语言本身和Swift标准库的根本性变化。Swift
    3的主要目标之一是在所有平台上保持源代码兼容性，这意味着为某一平台编写的代码应该与其他所有平台兼容。这意味着我们为macOS开发的代码应该在Linux上运行。
- en: In September 2017, Swift 4 was released. One of the primary goals of the Swift
    4 compiler was to be source-compatible with Swift 3\. This enables us to compile
    both Swift 3 and Swift 4 projects with the Swift 4 compiler. Apple has established
    a community-owned source-compatibility test suite that will be used to regression
    test changes to the compiler.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 2017年9月，发布了Swift 4。Swift 4编译器的主要目标之一是与Swift 3保持源代码兼容性。这使得我们能够使用Swift 4编译器编译Swift
    3和Swift 4的项目。苹果公司建立了一个社区拥有的源代码兼容性测试套件，该套件将用于回归测试编译器的变更。
- en: 'Projects that are added to the test suite will be periodically built against
    the latest development version of Swift to help us understand the impact of the
    changes being made to Swift. You can find the Swift source compatibility page
    here: [https://swift.org/source-compatibility/](https://swift.org/source-compatibility/).'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 被添加到测试套件中的项目将定期与Swift的最新开发版本进行构建，以帮助我们了解对Swift所做的变更的影响。您可以在以下页面找到Swift源代码兼容性页面：[https://swift.org/source-compatibility/](https://swift.org/source-compatibility/)。
- en: One of the original goals of Swift 4 was to stabilize the Swift **Application
    Binary Interface** (**ABI**). The main benefit of a stable ABI is to allow us
    to distribute frameworks in a binary format across multiple versions of Swift.
    If a stable ABI is in place, we can build a framework with the Swift 4 compiler
    and have it work with applications that were written in future versions of Swift.
    This feature ended up being deferred to Swift 5.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 4的原始目标之一是稳定Swift的**应用程序二进制接口**（**ABI**）。稳定ABI的主要好处是允许我们在多个Swift版本之间以二进制格式分发框架。如果有一个稳定的ABI，我们可以使用Swift
    4编译器构建一个框架，并且它能够与使用未来版本Swift编写的应用程序一起工作。这个特性最终被推迟到了Swift 5。
- en: 'With the release of Swift 5, the ABI has been declared stable for all Apple
    platforms. You can read Swift''s ABI Stability Manifesto here: [https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md](https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md).
    As development for Swift on other platforms, such as Linux, matures, the Swift
    Core team has said that they will evaluate stabilizing the ABI for those platforms
    as well. A stable ABI means that a library that is compiled for one version of
    Swift—let''s say Swift 5—will theoretically work with future versions of Swift,
    without having to be recompiled.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Swift 5 的发布，ABI 已被宣布对所有苹果平台稳定。您可以在以下链接中阅读 Swift 的 ABI 稳定性宣言：[https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md](https://github.com/apple/swift/blob/master/docs/ABIStabilityManifesto.md)。随着
    Swift 在其他平台，如 Linux 上的开发逐渐成熟，Swift 核心团队表示，他们还将评估稳定这些平台的 ABI。稳定的 ABI 意味着为 Swift
    的某个版本编译的库——比如说 Swift 5——理论上可以与未来的 Swift 版本一起工作，而无需重新编译。
- en: 'Since Swift 5 was released, Apple has released three additional versions: 5.1,
    5.2, and 5.3\. Each of these releases has added to or improved Swift. Throughout
    this book, we will see some of these changes and show you how you can use them.
    However, one of the most exciting changes will not be shown because we do not
    have a way to actually show it. This change occurred in Swift 5.1 when the Swift
    community implemented the **Language Server Protocol** (**LSP**).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Swift 5 发布以来，苹果已经发布了三个额外的版本：5.1、5.2 和 5.3。这些版本都对 Swift 进行了补充或改进。在这本书的整个过程中，我们将看到其中的一些变化，并展示您如何使用它们。然而，其中一个最令人兴奋的变化将不会展示，因为我们没有实际展示它的方法。这个变化发生在
    Swift 5.1 时，Swift 社区实现了**语言服务器协议**（**LSP**）。
- en: The LSP enables code editors and IDEs to standardize the support for languages.
    Before LSP, when an editor or IDE wanted to support a particular language, that
    support had to be built into the tool. With LSP, the language itself provides
    that functionality, so any editor or IDE that supports LSP can now support Swift
    with features such as syntax highlighting, autocomplete, and tooltips. This enables
    support for Swift in any editor that supports LSP, such as VSCode. This is pretty
    exciting news if you have ever tried to code a Swift application in vi.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 允许代码编辑器和 IDE 标准化对语言的支持。在 LSP 之前，当编辑器或 IDE 想要支持某种特定语言时，这种支持必须集成到工具中。有了 LSP，语言本身提供了这种功能，因此任何支持
    LSP 的编辑器或 IDE 现在都可以支持 Swift，具有语法高亮、自动完成和工具提示等功能。这使得任何支持 LSP 的编辑器，如 VSCode，都可以支持
    Swift。如果你曾经尝试在 vi 中编写 Swift 应用程序，这将是一个令人兴奋的消息。
- en: One of the most exciting things, with the release of Swift 5.3, was the release
    of an officially supported Windows 10 port of Swift. This is exciting because
    we are now able to use our Swift knowledge to develop on the Windows platform.
    The Windows port is provided by Saleem Abdulrasool, platform champion for the
    Windows port of Swift.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 随着 Swift 5.3 的发布，最令人兴奋的事情之一是发布了官方支持的 Windows 10 版本的 Swift。这是因为我们现在能够使用我们的 Swift
    知识在 Windows 平台上进行开发。Windows 版本由 Swift Windows 平台支持者 Saleem Abdulrasool 提供。
- en: The development of Swift was started in 2010 by Chris Lattner. He implemented
    much of the basic language structure when only a few people were aware of its
    existence. It wasn't until late 2011 that other developers began to contribute
    to Swift. In July 2013, it became a major focus of the Apple Developer Tools group.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 的开发始于 2010 年，由克里斯·拉特纳（Chris Lattner）发起。当只有少数人知道其存在时，他就实现了大部分基本语言结构。直到
    2011 年晚些时候，其他开发者才开始为 Swift 做贡献。2013 年 7 月，它成为苹果开发者工具组的主要关注点。
- en: Chris started working at Apple in the summer of 2005\. He held several positions
    within the Developer Tools group and was the director and architect of that group
    when he left Apple in 2017\. On his home page ([http://www.nondot.org/sabre/](http://www.nondot.org/sabre/)),
    he notes that Xcode's playground (we'll talk more about playgrounds a little later
    in this chapter) became a personal passion of his because it makes programming
    more interactive and approachable. If you are using Swift on the Apple platform,
    you will be using playgrounds a lot as a test and experimentation platform. You
    can also use Swift Playgrounds on the iPad.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 克里斯于 2005 年夏天开始在苹果公司工作。他在开发者工具组内担任了多个职位，并在 2017 年离开苹果公司时是该组的总监和架构师。在他的主页（[http://www.nondot.org/sabre/](http://www.nondot.org/sabre/））上，他提到
    Xcode 的 playground（我们将在本章稍后更详细地讨论 playground）成为他个人的热情所在，因为它使编程更加互动和易于接近。如果您在苹果平台上使用
    Swift，您将大量使用 playground 作为测试和实验平台。您还可以在 iPad 上使用 Swift Playgrounds。
- en: There are a lot of similarities between Swift and Objective-C. Swift adopts
    the readability of Objective-C's named parameters and dynamic object model. When
    we refer to Swift as having a dynamic object model, we are referring to the ability
    of types to change at runtime. This includes adding new (custom) types and changing/extending
    existing types.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 和 Objective-C 之间有很多相似之处。Swift 采用了 Objective-C 的命名参数的可读性和动态对象模型。当我们说 Swift
    具有动态对象模型时，我们指的是类型在运行时可以改变的能力。这包括添加新的（自定义）类型和修改/扩展现有类型。
- en: While there are a lot of similarities between Swift and Objective-C, there are
    significant differences between them as well. Swift's syntax and formatting are
    a lot closer to Python than Objective-C, but Apple did keep the curly brackets.
    I know Python people would disagree with me, and that is all right because we
    all have different opinions, but I like the curly brackets. Swift actually requires
    the curly brackets for control statements, such as `if` and `while`, which eliminate
    bugs, such as `goto fail` in Apple's SSL library.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 和 Objective-C 之间有很多相似之处，但它们之间也存在一些显著的不同。Swift 的语法和格式与 Python 比起 Objective-C
    来说更接近，但 Apple 仍然保留了花括号。我知道 Python 的人会不同意我，这很正常，因为我们都持有不同的观点，但我喜欢花括号。实际上，Swift
    要求在控制语句（如 `if` 和 `while`）中使用花括号，这消除了诸如 Apple SSL 库中的 `goto fail` 这样的错误。
- en: Swift features
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 功能
- en: When Apple first introduced Swift, it said that *Swift is Objective-C without
    the C*. This really only tells us half of the story. Objective-C is a superset
    of C and provides object-oriented capabilities and a dynamic runtime to the C
    language. This meant that with Objective-C, Apple needed to maintain compatibility
    with C, which limited the enhancements it could make to the Objective-C language.
    As an example, Apple could not change how the `switch` statement functioned and
    has still maintained compatibility with the C language.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Apple 首次推出 Swift 时，它说“Swift 是没有 C 的 Objective-C”。这实际上只告诉我们故事的一半。Objective-C
    是 C 的超集，为 C 语言提供了面向对象的能力和动态运行时。这意味着使用 Objective-C，Apple 需要维护与 C 的兼容性，这限制了它对 Objective-C
    语言的增强。例如，Apple 不能改变 `switch` 语句的功能，同时仍然保持与 C 语言的兼容性。
- en: Since Swift does not need to maintain the same C compatibility as Objective-C,
    Apple was free to add any feature/enhancement to the language. This allowed Apple
    to include the best features from many of today's most popular and modern languages,
    such as Objective-C, Python, Java, Ruby, C#, and Haskell.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Swift 不需要像 Objective-C 那样维护相同的 C 兼容性，因此 Apple 可以自由地向语言添加任何功能/增强。这使得 Apple
    能够包含当今许多最受欢迎和现代语言中的最佳功能，例如 Objective-C、Python、Java、Ruby、C# 和 Haskell。
- en: 'The following table shows a list of some of the most exciting enhancements
    that Swift offers compared to the Objective-C language:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格展示了 Swift 相比 Objective-C 语言提供的最激动人心的增强功能列表：
- en: '| Swift feature | Description |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| Swift 功能 | 描述 |'
- en: '| Type inference | Swift can automatically deduce the type of a variable or
    constant, based on the initial value. |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 类型推断 | Swift 可以根据初始值自动推断变量或常量的类型。|'
- en: '| Generics | Generics allow us to write code once to perform identical tasks
    for different types of objects. |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 泛型 | 泛型允许我们编写一次代码，以对不同类型的对象执行相同任务。|'
- en: '| Collection mutability | Swift does not have separate objects for mutable
    or non-mutable containers. Instead, you define mutability by defining the container
    as a constant or variable. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 集合可变性 | Swift 没有为可变或不可变容器定义单独的对象。相反，你通过定义容器为常量或变量来定义可变性。|'
- en: '| Closure syntax | Closures are self-contained blocks of functionality that
    can be passed around and used in our code. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 闭包语法 | 闭包是包含功能性的自包含块，可以在我们的代码中传递和使用。|'
- en: '| Optionals | Optionals define a variable that might not have a value. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 可选 | 可选定义了一个可能没有值的变量。|'
- en: '| `switch` statement | The `switch` statement has been drastically improved.
    This is one of my favorite improvements. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `switch` 语句 | `switch` 语句得到了大幅改进。这是我最喜欢的改进之一。|'
- en: '| Tuples | Functions can have multiple return types by using tuples. |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| 元组 | 函数可以通过使用元组来具有多个返回类型。|'
- en: '| Operator overloading | Classes can provide their own implementations of existing
    operators. |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 运算符重载 | 类可以提供现有运算符的自己的实现。|'
- en: '| Enumerations with associated values | In Swift, we can do a lot more than
    just define a group of related values with enumerations. |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 带关联值的枚举 | 在 Swift 中，我们可以使用枚举做很多不仅仅是定义一组相关值的事情。|'
- en: '| Protocols and protocol- oriented design | Apple introduced the protocol-oriented
    programming paradigm with Swift version 2\. This is a new way of not only writing
    applications but also changing how we think about programming. This is discussed
    in *Chapter 10*, *Protocol-Oriented Design*. |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 协议和协议导向设计 | 苹果在Swift 2中引入了协议导向编程范式。这是一种不仅编写应用程序，而且改变我们思考编程方式的新方法。这在第10章“协议导向设计”中有详细讨论。|'
- en: 'Table 1.1: Swift features'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 表1.1：Swift特性
- en: 'Before we begin our journey into the wonderful world of Swift development,
    let''s take a detour and visit a place that I have loved ever since I was a kid:
    the playground.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始探索Swift开发的奇妙世界之前，让我们绕道访问一个自从我还是个孩子就喜欢的地点：游戏场。
- en: Playgrounds
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏场
- en: When I was a kid, the best part of the school day was going to the playground.
    It really did not matter what we were playing, as long as we were on the playground.
    When Apple introduced playgrounds as part of Xcode 6, I was excited just by the
    name, but I wondered whether Apple would be able to make its playgrounds as fun
    as the playgrounds of my youth. While Apple's playgrounds might not be as fun
    as playing kickball when I was 9 years old, it definitely brings a lot of fun
    back to experimenting and playing with code.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当我还是个孩子的时候，学校一天中最美好的时光就是去游戏场。我们玩什么并不重要，只要我们在游戏场就好。当苹果公司将游戏场作为Xcode 6的一部分引入时，我仅仅是因为这个名字就感到兴奋，但我怀疑苹果能否让它的游戏场像我的童年游戏场一样有趣。虽然苹果的游戏场可能没有我在9岁时踢垒球的乐趣，但它确实为实验和玩代码带来了很多乐趣。
- en: Playgrounds are also available for iPad. While we are not going to cover the
    iPad version specifically in this section, the iPad version is a great way to
    experiment with the Swift language and is a great way to get children interested
    in programming.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场也适用于iPad。虽然我们不会在本节中具体介绍iPad版本，但iPad版本是实验Swift语言的好方法，也是吸引孩子们对编程产生兴趣的好方法。
- en: Getting started with playgrounds
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用游戏场
- en: Playgrounds are interactive work environments that let us write code and see
    the results immediately as changes are made to the code. This means that playgrounds
    are a great way to learn and experiment with Swift. Now that we can use Swift
    Playgrounds on iPad, we do not even need to have a computer in front of us to
    experiment with Swift.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场是交互式的工作环境，允许我们在代码发生变化时立即看到结果。这意味着游戏场是学习Swift和进行实验的绝佳方式。现在我们可以在iPad上使用Swift
    Playgrounds，我们甚至不需要在面前有电脑就可以实验Swift。
- en: If you are using Swift on the Linux platform, you will not have playgrounds
    available, but you can use the **Read-Evaluate-Print-Loop** (**REPL**) shell to
    experiment with Swift without compiling your code. If you are using Swift on something
    other than a macOS computer or iPad, you can safely skip this section and go to
    the *Swift language syntax* section. In *Chapter 2*, *Swift Documentation and
    Installing Swift*, we look at additional tools, such as Swift's package manger
    and the Swift compiler, as alternative ways that we can build and run the sample
    code in this book.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在Linux平台上使用Swift，您将没有游戏场可用，但您可以使用**读取-评估-打印-循环**（**REPL**）shell在不需要编译代码的情况下实验Swift。如果您在除macOS计算机或iPad以外的设备上使用Swift，您可以安全地跳过本节，转到“Swift语言语法”部分。在第2章“Swift文档和安装Swift”中，我们探讨了Swift包管理器和Swift编译器等额外工具，作为我们构建和运行本书中示例代码的替代方法。
- en: Playgrounds also make it incredibly easy for us to try out new APIs, prototype
    new algorithms, and demonstrate how code works. You can use playgrounds throughout
    this book to see how the sample code works. Therefore, before we really get into
    Swift development, let's spend some time learning about, and getting comfortable
    with, playgrounds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏场还使我们尝试新API、原型化新算法和展示代码工作方式变得极其容易。您可以使用游戏场来查看示例代码的工作方式。因此，在我们真正开始Swift开发之前，让我们花些时间学习和熟悉游戏场。
- en: Do not worry if the Swift code does not make a lot of sense right now; as we
    proceed through this book, the code that we use in the following examples will
    begin to make sense. We are simply trying to get a feel for playgrounds right
    now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果Swift代码现在看起来没有太多意义，请不要担心；随着我们继续阅读这本书，我们将在接下来的示例中使用的代码将开始变得有意义。我们只是现在试图对游戏场有一个感觉。
- en: 'A playground can have several sections, but the three that we will be using
    extensively in this book are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一个游戏场可以有几个部分，但在这本书中我们将广泛使用以下三个部分：
- en: '**Coding Area**: This is where you enter your Swift code.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码区域**：这是您输入Swift代码的地方。'
- en: '**Results Sidebar**: This is where the results of your code are shown. Each
    time you type in a new line of code, the results are reevaluated, and the **Results
    Sidebar** section is updated with the new results.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结果侧边栏**：这是显示你代码结果的地方。每次你输入新的一行代码时，结果都会重新评估，并且 **结果侧边栏** 部分会更新为新的结果。'
- en: '**Debug Area**: This area displays the output of the code, and it can be very
    useful for debugging.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调试区域**：这个区域显示代码的输出，对于调试来说非常有用。'
- en: 'The following screenshot shows how these sections are arranged in a playground:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了这些部分在游乐场中的排列方式：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_01_01.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  自动生成描述](img/B16683_01_01.png)'
- en: 'Figure 1.1: Playground layout'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：游乐场布局
- en: 'Let''s start a new playground. The first thing we need to do is start Xcode.
    Once Xcode has started, we can select the **Get started with a playground** option,
    as shown in the following screenshot:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始一个新的游乐场。我们首先需要启动 Xcode。一旦 Xcode 启动，我们可以选择 **使用游乐场开始** 选项，如下面的截图所示：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_01_02.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  自动生成描述](img/B16683_01_02.png)'
- en: 'Figure 1.2: Starting a new playground'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：开始新的游乐场
- en: 'Alternatively, we can navigate to **Playground...** by going to **File** |
    **New** from the top menu bar, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以通过从顶部菜单栏的 **文件** | **新建** 转到 **游乐场...** 来导航，如下面的截图所示：
- en: '![A screenshot of text  Description automatically generated](img/B16683_01_03.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![文本截图  自动生成描述](img/B16683_01_03.png)'
- en: 'Figure 1.3: Creating a new playground'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：创建新的游乐场
- en: 'Next, we should see a screen similar to *Figure 1.4*. This screen lets us name
    our playground and select whether the playground is an **iOS**, **tvOS**, or **macOS**
    playground. For most of the examples in this chapter, it is safe to assume that
    you can select any of the OS options, unless it is otherwise noted. You can also
    select a template to use. For the examples in this book, we will be using the
    **Blank** template for all of our code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们应该看到一个类似于 *图 1.4* 的屏幕。这个屏幕允许我们命名我们的游乐场，并选择游乐场是 **iOS**、**tvOS** 还是 **macOS**
    游乐场。在本章的大部分示例中，可以安全地假设你可以选择任何操作系统选项，除非另有说明。你还可以选择一个模板来使用。对于本书的示例，我们将使用 **空白**
    模板来编写所有代码：
- en: '![A screen shot of a computer  Description automatically generated](img/B16683_01_04.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_01_04.png)'
- en: 'Figure 1.4: Playground templates'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4：游乐场模板
- en: 'Finally, we are asked for the location in which to save our playground. After
    we select the location, the playground will open and look similar to *Figure 1.5*:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要选择保存游乐场的位置。选择位置后，游乐场将打开并看起来类似于 *图 1.5*：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_05.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_01_05.png)'
- en: 'Figure 1.5: Playground screen'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：游乐场屏幕
- en: In the preceding screenshot, we can see that the coding area of the playground
    looks similar to the coding area for an Xcode project. What is different here
    is the sidebar on the right-hand side. This sidebar is where the results of our
    code are shown. The code in the previous screenshot imports the **Cocoa** framework
    since it is a macOS playground. If it were an iOS playground, it would import
    the **UIKit** framework instead.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的截图中，我们可以看到游乐场的编码区域看起来与 Xcode 项目的编码区域相似。这里的不同之处在于右侧的侧边栏。这个侧边栏是显示我们代码结果的地方。前面的截图中的代码导入了
    **Cocoa** 框架，因为它是一个 macOS 游乐场。如果它是一个 iOS 游乐场，它将导入 **UIKit** 框架。
- en: If your new playground does not open the debug area, you can open it manually
    by pressing the shift + command + Y keys together. Alternatively, you can use
    the sidebar button at the top-right corner of the playground window. You can also
    close the debug area by pressing shift + command + Y again. Later in this chapter,
    we will see why the debug area is so useful. Another way to open or close the
    debug area is to click on the button that looks like an upside-down triangle,
    in a box that is on the border between the debug area and the coding area.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的新游乐场没有打开调试区域，你可以通过同时按下 shift + command + Y 键来手动打开它。或者，你也可以使用游乐场窗口右上角的侧边栏按钮。再次按下
    shift + command + Y 可以关闭调试区域。在本章的后面部分，我们将看到为什么调试区域如此有用。打开或关闭调试区域的另一种方法是点击一个看起来像倒三角形的按钮，该按钮位于调试区域和编码区域之间的边界框中。
- en: iOS, tvOS, and macOS playgrounds
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: iOS、tvOS 和 macOS 游乐场
- en: When you start a new iOS or tvOS playground, the playground imports the UIKit
    framework. This gives us access to the UIKit framework, which provides the core
    infrastructure for iOS and tvOS applications. When we start a new macOS playground,
    the playground imports the Cocoa framework.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始一个新的 iOS 或 tvOS 游乐场时，游乐场会导入 UIKit 框架。这使我们能够访问 UIKit 框架，它为 iOS 和 tvOS 应用程序提供核心基础设施。当我们开始一个新的
    macOS 游乐场时，游乐场会导入 Cocoa 框架。
- en: What the last paragraph means is that if we want to experiment with specific
    features of either UIKit or Cocoa, we need to open the correct playground. As
    an example, if we have an iOS playground open, and we want to create an object
    that represents a color, we would use a `UIColor` object. If we had a macOS playground
    open, we would use an `NSColor` object to represent a color.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 上一段话的意思是，如果我们想对 UIKit 或 Cocoa 的特定功能进行实验，我们需要打开正确的游乐场。例如，如果我们有一个 iOS 游乐场打开，并且我们想创建一个表示颜色的对象，我们会使用
    `UIColor` 对象。如果我们有一个 macOS 游乐场打开，我们会使用 `NSColor` 对象来表示颜色。
- en: Creating and displaying graphs in playgrounds
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在游乐场中创建和显示图形
- en: 'Creating and displaying graphs is useful when we are prototyping new algorithms.
    This is because they allow us to see the value of a variable throughout our calculations.
    To see how graphing works, look at the following playground:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在原型设计新算法时，创建和显示图形非常有用。这是因为它们允许我们在整个计算过程中看到变量的值。要了解图形化工作原理，请查看以下游乐场：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_06.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_01_06.png)'
- en: 'Figure 1.6: Creating a loop'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：创建循环
- en: In this playground, we set the `j` variable to `1`. Next, we create a `for`
    loop that assigns numbers `1` through `5` to the `i` variable. At each step in
    the `for` loop, we set the value of the `j` variable to the current value of `j`
    plus `i`. A graph can change the values of the `j` variable at each step of the
    `for` loop, helping us see how the variable changes over time. We will cover `for`
    loops in detail later in this book.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游乐场中，我们将 `j` 变量设置为 `1`。接下来，我们创建一个 `for` 循环，将数字 `1` 到 `5` 分配给 `i` 变量。在 `for`
    循环的每一步中，我们将 `j` 变量的值设置为当前 `j` 的值加上 `i`。图形可以在 `for` 循环的每一步中改变 `j` 变量的值，帮助我们看到变量随时间的变化。我们将在本书的后面详细讲解
    `for` 循环。
- en: 'To bring up the graph, click on the symbol that is shaped like a circle with
    a dot in it. We can then move the timeline slider to see the values of the `j`
    variable at each step of the `for` loop. The following playground shows what the
    graph should look like:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要显示图形，点击形状像圆圈带点的符号。然后我们可以移动时间线滑块，查看 `for` 循环每一步中 `j` 变量的值。以下游乐场显示了图形应该看起来像什么：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_07.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成描述](img/B16683_01_07.png)'
- en: 'Figure 1.7: Drawing a graph'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7：绘制图形
- en: Graphs can be very helpful when we want to see how variables change over the
    course of the code's execution.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想看到变量在代码执行过程中的变化时，图形非常有帮助。
- en: What playgrounds are not
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么不是游乐场
- en: 'There is a lot more that we can do with playgrounds, and we have only scratched
    the surface in our quick introduction here. Before we leave this brief introduction,
    let''s take a look at what playgrounds are not so that we can better understand
    when not to use playgrounds:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用游乐场做很多事情，而我们在这里的快速介绍中只是触及了皮毛。在我们离开这个简短的介绍之前，让我们看看什么是游乐场不是，以便我们更好地理解何时不应使用游乐场：
- en: '**Playgrounds should not be used for performance testing**: The performance
    you see from any code that is run in a playground is not representative of how
    fast the code will run when it is in your project'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游乐场不应用于性能测试**：在游乐场中运行的任何代码的性能并不能代表代码在项目中的运行速度'
- en: '**Playgrounds do not support on-device execution**: You cannot run the code
    that is present in a playground as an external application or on an external device'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**游乐场不支持设备上的执行**：你不能将游乐场中的代码作为外部应用程序或在外部设备上运行'
- en: Now, let's familiarize ourselves with some basic Swift syntax.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们熟悉一些基本的 Swift 语法。
- en: Swift language syntax
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swift 语言语法
- en: If you are an Objective-C developer, and you are not familiar with modern languages
    such as Python or Ruby, the code in the previous screenshots may have looked pretty
    strange. The Swift language syntax is a huge departure from Objective-C, which
    was based largely on Smalltalk and C.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你是一名 Objective-C 开发者，并且你对现代语言如 Python 或 Ruby 不熟悉，前面截图中的代码可能看起来相当奇怪。Swift 语言的语法与基于
    Smalltalk 和 C 的 Objective-C 有很大的不同。
- en: The Swift language uses modern concepts and syntax to create very concise and
    readable code. There is also a heavy emphasis on eliminating common programming
    mistakes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 语言使用现代概念和语法来创建非常简洁和可读的代码。同时，也强调消除常见的编程错误。
- en: Before we get into the Swift language itself, let's look at some of the basic
    syntax of the Swift language.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入研究 Swift 语言本身之前，让我们看看一些 Swift 语言的基本语法。
- en: Comments
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注释
- en: Writing comments in Swift code is a little different from writing comments in
    Objective-C code. We can still use double slash (`//`) for single-line comments
    and `/**` and `*/` for multiline comments; however, if we want to use the comments
    to also document our code, we need to use the triple slash (`///`) or multiline
    comment block.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 代码中编写注释与在 Objective-C 代码中编写注释略有不同。我们仍然可以使用双斜杠 (`//`) 进行单行注释，以及使用 `/**`
    和 `*/` 进行多行注释；然而，如果我们想使用注释来记录代码，我们需要使用三斜杠 (`///`) 或多行注释块。
- en: You can auto-generate a comment template based on your signature of the method/function
    with Xcode by highlighting it and pushing *command* + *option* + */* together.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 Xcode 根据方法的签名自动生成注释模板，只需突出显示它，然后同时按下 *command* + *option* + */*。
- en: 'To document our code, we generally use fields that Xcode recognizes. These
    fields are as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了记录我们的代码，我们通常使用 Xcode 识别的字段。这些字段如下：
- en: '**Parameter**: When we start a line with `parameter {param name}:`, Xcode recognizes
    this as the description of a parameter.'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：当我们以 `parameter {param name}:` 开头一行时，Xcode 会将其识别为参数的描述。'
- en: '**Return**: When we start a line with `return:`, Xcode recognizes this as the
    description of the return value.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回**：当我们以 `return:` 开头一行时，Xcode 会将其识别为返回值的描述。'
- en: '**Throws**: When we start a line with `throws:`, Xcode recognizes this as a
    description of any errors that this method may throw.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出**：当我们以 `throws:` 开头一行时，Xcode 会将其识别为该方法可能抛出的任何错误描述。'
- en: 'The following playground shows examples of both single-line and multiline comments
    and how to use the comment fields:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的游乐场展示了单行和多行注释的示例以及如何使用注释字段：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_01_08.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![手机截图  自动生成的描述](img/B16683_01_08.png)'
- en: 'Figure 1.8: Adding comments in a playground'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.8：在游乐场中添加注释
- en: To write good comments, I would recommend using single-line comments within
    a function to give quick one-line explanations of your code. We then use multiline
    comments outside functions and classes to explain what the function and class
    do. The preceding playground shows a good way to use comments. By using proper
    documentation, as we did in the preceding screenshot, we can use the documentation
    feature within Xcode. If we hold down the *option* key and then click on the function
    name anywhere in our code, Xcode will display a popup with a description of the
    function.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 要写好注释，我建议在函数内部使用单行注释，以快速给出代码的一行解释。然后，我们在函数和类外部使用多行注释来解释函数和类的作用。前面的游乐场展示了如何正确使用注释。通过使用适当的文档，就像我们在前面的截图中所做的那样，我们可以在
    Xcode 中使用文档功能。如果我们按住 *option* 键，然后在代码中的任何地方点击函数名，Xcode 将显示一个包含函数描述的弹出窗口。
- en: 'The following screenshot shows what that popup would look like:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了弹出窗口的外观：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_09.png)'
  id: totrans-104
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_09.png)'
- en: 'Figure 1.9: Xcode documentation on functions'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9：Xcode 中关于函数的文档
- en: 'We can see that the documentation contains five fields. These fields are as
    follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，文档包含五个字段。这些字段如下：
- en: '**Declaration**: This is the function''s declaration.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明**：这是函数的声明。'
- en: '**Parameters**: This is the description of the function''s as they appear in
    the comments. The parameter descriptions are prefixed with the `Parameters`: tag
    in the comment section.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**参数**：这是函数参数在注释中的描述。参数描述以注释部分的 `Parameters:` 标签为前缀。'
- en: '**Throws**: The throws description is prefixed with the `throws` tag and describes
    what errors are thrown by the methods.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**抛出异常**：`throws` 描述前缀为 `throws` 标签，用于描述方法抛出的错误。'
- en: '**Returns**: The returns description is prefixed with the `returns:` tag in
    the comment section.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：`returns` 描述前缀在注释部分为 `returns:` 标签。'
- en: '**Declared In**: This is the file that the function is declared in so that
    we can easily find it.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**声明在**：这是函数声明的文件，这样我们就可以轻松找到它。'
- en: 'There are significantly more fields that we can add to our comments. You can
    find the complete list on Apple''s site: [https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/MarkupFunctionality.html](https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_re).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在注释中添加更多的字段。你可以在 Apple 的网站上找到完整的列表：[https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_ref/MarkupFunctionality.html](https://developer.apple.com/library/content/documentation/Xcode/Reference/xcode_markup_formatting_re)。
- en: If you are developing for the Linux platform, I would still recommend using
    Apple's documentation guidelines because, as other Swift IDEs are developed, I
    believe they will support the same guidelines.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在为 Linux 平台开发，我仍然建议使用 Apple 的文档指南，因为随着其他 Swift IDE 的开发，我相信它们将支持相同的指南。
- en: Semicolons
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分号
- en: 'You may have noticed, from the code samples so far, that we are not using semicolons
    at the end of lines. Semicolons are optional in Swift; therefore, both lines in
    the following playground are valid in Swift:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，到目前为止的代码示例中我们没有在行尾使用分号。在 Swift 中，分号是可选的；因此，以下 playground 中的两行在 Swift
    中都是有效的：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_10.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_10.png)'
- en: 'Figure 1.10: The use of semicolons in Swift'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10：Swift 中分号的使用
- en: For style purposes, it is strongly recommended that you do not use semicolons
    in your Swift code. If you are really set on using semicolons, be consistent and
    use them on every line of code; however, there is no warning if you forget them.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，强烈建议你在 Swift 代码中不要使用分号。如果你真的想使用分号，请保持一致性，并在每一行代码中使用它们；然而，如果你忘记了，也不会有警告。
- en: 'I will stress this again: it is recommended that you do not use semicolons
    in Swift.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我再强调一次：建议你在 Swift 中不要使用分号。
- en: Parentheses
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 括号
- en: 'In Swift, parentheses around conditional statements are optional; for example,
    both `if` statements in the following playground are valid:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，条件语句周围的括号是可选的；例如，以下 playground 中的两个 `if` 语句都是有效的：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_11.png)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_11.png)'
- en: 'Figure 1.11: Parentheses in Swift'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：Swift 中的括号
- en: For style purposes, it is recommended that you do not include parentheses in
    your code unless you have multiple conditional statements on the same line. For
    readability purposes, it is good practice to put parentheses around individual
    conditional statements that are on the same line.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，建议你除非在同一行上有多个条件语句，否则不要在代码中使用括号。为了可读性，将括号放在同一行上的单个条件语句周围是一个好的做法。
- en: Curly brackets
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 花括号
- en: In Swift, unlike most other languages, a curly bracket is required after conditional
    or loop statements. This is one of the safety features that is built into Swift.
    Arguably, there have been numerous security bugs that could have been prevented
    if the developer had used curly brackets. These bugs could have also been prevented
    by other means, such as unit testing and code reviews, but requiring developers
    to use curly brackets, in my opinion, is a good security standard.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，与大多数其他语言不同，在条件或循环语句之后需要使用花括号。这是 Swift 内置的安全特性之一。可以说，如果开发者使用了花括号，那么可能已经避免了大量的安全漏洞。这些漏洞也可以通过其他方式避免，例如单元测试和代码审查，但在我看来，要求开发者使用花括号是一个良好的安全标准。
- en: 'The following playground shows you the error you get if you forget to include
    curly brackets:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 playground 展示了如果你忘记包含花括号时将得到的错误：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_12.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_12.png)'
- en: 'Figure 1.12: Curly brackets in Swift'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：Swift 中的花括号
- en: An assignment operator does not return a value
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 赋值运算符不返回值
- en: 'In most other languages, the following line of code is valid, but it probably
    isn''t what the developer meant to do:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他语言中，以下行代码是有效的，但可能并不是开发者想要执行的操作：
- en: '[PRE0]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift, this statement is not valid. Using an assignment operator (`=`) in
    a conditional statement (`if`, `while`, and `guard`) will throw an error. This
    is another safety feature built into Swift. It prevents the developer from forgetting
    the second equals sign (`=`) in a comparison statement. This error is shown in
    the following playground:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，这个语句是无效的。在条件语句（`if`、`while` 和 `guard`）中使用赋值运算符（`=`）会引发错误。这是 Swift
    中内置的另一个安全特性。它防止开发者忘记比较语句中的第二个等号（`=`）。以下 playground 展示了此错误：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_13.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_13.png)'
- en: 'Figure 1.13: Assignment operators in Swift'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.13：Swift 中的赋值运算符
- en: Spaces are optional in conditional and assignment statements
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在条件和赋值语句中，空白是可选的。
- en: 'For both conditional (`if` and `while`) and assignment (`=`) statements, the
    white spaces are optional. Therefore, in the following playground, both the `i`
    and `j` blocks of code are valid:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于条件（`if` 和 `while`）和赋值（`=`）语句，空白是可选的。因此，在以下 playground 中，`i` 和 `j` 代码块都是有效的：
- en: '![A screenshot of a computer screen  Description automatically generated](img/B16683_01_14.png)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![计算机屏幕截图  自动生成的描述](img/B16683_01_14.png)'
- en: 'Figure 1.14: Spaces in Swift'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.14：Swift 中的空格
- en: For style purposes, I recommend adding the white spaces as the `j` block shows
    (for readability), but as long as you pick one style and are consistent, either
    style is acceptable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了风格上的考虑，我建议添加空白，就像 `j` 块所示（为了可读性），但只要您选择一种风格并保持一致，任何风格都是可接受的。
- en: Hello World
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hello World
- en: All good computer books that are written to teach a computer language have a
    section that shows the user how to write a Hello World application. This book
    is no exception. In this section, we will show you how to write two different
    Hello World applications.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 所有旨在教授计算机语言的优秀计算机书籍都有一个部分，展示了用户如何编写 Hello World 应用程序。这本书也不例外。在本节中，我们将向您展示如何编写两个不同的
    Hello World 应用程序。
- en: Our first Hello World application will be a traditional Hello World application
    that simply prints Hello World to the console. Let's begin by creating a new playground
    and naming it `Chapter_1_Hello_World`.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个 Hello World 应用程序将是一个传统的 Hello World 应用程序，它只是将 Hello World 打印到控制台。让我们首先创建一个新的
    playground，并将其命名为 `Chapter_1_Hello_World`。
- en: 'In Swift, to print a message to the console, we use the `print()` function.
    In its most basic form, we would use the `print()` function to print out a single
    message, as shown in the following code:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，要打印消息到控制台，我们使用 `print()` 函数。在其最基本的形式中，我们会使用 `print()` 函数打印出一条单独的消息，如下面的代码所示：
- en: '[PRE1]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Usually, when we use the `print()` function, we want to print more than just
    static text. We can include the value of variables and/or constants by using string
    interpolation or by separating the values within the `print()` function with commas.
    String interpolation uses a special sequence of characters, `\( )`, to include
    the values of variables and/or constants in the string. The following code shows
    how to do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，当我们使用 `print()` 函数时，我们希望打印的不仅仅是静态文本。我们可以通过使用字符串插值或通过在 `print()` 函数中使用逗号分隔值来包含变量和/或常量的值。字符串插值使用一个特殊的字符序列，`\(
    )`，在字符串中包含变量和/或常量的值。以下代码展示了如何做到这一点：
- en: '[PRE2]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We can also define two parameters in the `print()` function that change how
    the message is displayed in the console. These parameters are the `separator`
    and `terminator` parameters. The `separator` parameter defines a string that is
    used to separate the values of the variables/constants in the `print()` function.
    By default, the `print()` function separates each variable/constant with a space.
    The `terminator` parameter defines what character is put at the end of the line.
    By default, the newline character is added at the end of the line.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以在 `print()` 函数中定义两个参数，这两个参数会改变消息在控制台中的显示方式。这些参数是 `separator` 和 `terminator`
    参数。`separator` 参数定义了一个用于在 `print()` 函数中分隔变量/常量值的字符串。默认情况下，`print()` 函数使用空格分隔每个变量/常量。`terminator`
    参数定义了在行尾放置的字符。默认情况下，会在行尾添加换行符。
- en: 'The following code shows how we would create a comma-separated list that does
    not have a newline character at the end:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何创建一个以逗号分隔的列表，列表末尾没有换行符：
- en: '[PRE3]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There is one other parameter that we can add to our `print()` function: the
    `to:` parameter. This parameter will let us redirect the output of the `print()`
    function. In the following example, we redirect the output to a variable named
    `line`:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以向我们的 `print()` 函数添加一个参数：`to:` 参数。这个参数将允许我们重定向 `print()` 函数的输出。在下面的示例中，我们将输出重定向到名为
    `line` 的变量中：
- en: '[PRE4]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Previously, the `print()` function was simply a useful tool for basic debugging,
    but now, with the new, enhanced `print()` function, we can use it for a lot more.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，`print()` 函数只是一个用于基本调试的有用工具，但现在，随着新的增强型 `print()` 函数，我们可以用它做更多的事情。
- en: The output from the previous two examples is a comma-separated list of Jon,
    Kailey, Kara.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例的输出是一个以逗号分隔的 Jon、Kailey、Kara 列表。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We began this chapter with a discussion on the Swift language and gave a brief
    history of it. We also mentioned some of the changes that are present in the newer
    versions of Swift. We then showed you how to start and use playgrounds to experiment
    with Swift programming. We also covered the basic Swift language syntax and discussed
    proper language styles. This chapter concluded with two Hello World examples.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的开始讨论了 Swift 语言，并简要介绍了其历史。我们还提到了 Swift 新版本中的一些变化。然后我们向您展示了如何启动和使用游乐场来实验
    Swift 编程。我们还涵盖了 Swift 语言的基本语法，并讨论了适当的语言风格。本章以两个 Hello World 示例结束。
- en: In the next chapter, we will look at the documentation offered by Apple and
    the Swift community. We will then see how we can build Swift from source and use
    the Swift compiler.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将查看 Apple 和 Swift 社区提供的文档。然后我们将了解如何从源代码构建 Swift 以及如何使用 Swift 编译器。
