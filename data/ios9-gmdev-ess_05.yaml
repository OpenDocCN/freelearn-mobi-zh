- en: Chapter 4. SceneKit and 3D Game Design
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章：SceneKit 和 3D 游戏设计
- en: For this chapter, we will be going over the iOS framework used for 3D game development
    known as SceneKit. SceneKit first became available in iOS 7 but originally was
    just used for MacOS development. Previously, developers had to code 3D games using
    OpenGL or third-party frameworks and engines, such as Cocos3D, Unreal Engine,
    Havok, and Unity. As the graphical power in the iOS family of devices improved,
    so did the need for an immersive, hands-on first-party 3D game design engine.
    SceneKit shortly became available for iOS giving developers an Xcode built-in
    solution to make 3D games.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将介绍用于 3D 游戏开发的 iOS 框架，称为 SceneKit。SceneKit 首次在 iOS 7 中可用，但最初仅用于 MacOS
    开发。以前，开发者必须使用 OpenGL 或第三方框架和引擎，如 Cocos3D、Unreal Engine、Havok 和 Unity 来编写 3D 游戏。随着
    iOS 设备家族图形能力的提升，对沉浸式、互动式的一方 3D 游戏设计引擎的需求也增加了。SceneKit 很快就可供 iOS 使用，为开发者提供了一个 Xcode
    内置的解决方案来制作 3D 游戏。
- en: In the previous chapter, we approached iOS game development in a more code-based
    methodology. We'll still be working in some code, but since the introduction of
    Xcode 5 and Xcode 6, Apple has provided some great demos that show how the IDE
    can be just as visually dynamic of a game engine as multiplatform game engines
    are. The benefit of using Xcode and the SpriteKit/SceneKit frameworks over those
    engines is that you have a dedicated design environment for a specific platform.
    In our case, that platform is iOS and the Apple family of devices. As iOS frequently
    updates and continues to give new features, Xcode and these frameworks will update
    with it. Updates to the multiplatform engines usually occur at a later date with
    sometimes the additional need to install plugins to ensure that your app runs
    smoothly in future updates.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们以更基于代码的方法论来处理 iOS 游戏开发。我们仍然会编写一些代码，但自从 Xcode 5 和 Xcode 6 的推出以来，Apple
    提供了一些出色的示例，展示了 IDE 如何与多平台游戏引擎一样具有视觉动态性。使用 Xcode 和 SpriteKit/SceneKit 框架而不是这些引擎的好处是，您有一个针对特定平台的专业设计环境。在我们的案例中，这个平台是
    iOS 和 Apple 设备家族。随着 iOS 的频繁更新并继续提供新功能，Xcode 和这些框架将与其一起更新。多平台引擎的更新通常发生在较晚的时间，有时还需要安装插件以确保您的应用程序在未来的更新中能够顺利运行。
- en: In addition to the very dynamic and tool-rich DemoBots SpriteKit demo, the *June
    2015 World Wide Developer's Conference* also introduced a wonderful SceneKit demo
    named Fox. The Fox demo also makes use of features introduced in iOS 9 that we
    can use for either SpriteKit or SceneKit, such as reusable actions, components,
    and state machines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 除了非常动态且工具丰富的 DemoBots SpriteKit 示例之外，2015 年 6 月的全球开发者大会（World Wide Developer's
    Conference）还介绍了一个名为 Fox 的出色 SceneKit 示例。Fox 示例还利用了 iOS 9 中引入的功能，这些功能可用于 SpriteKit
    或 SceneKit，例如可重用动作、组件和状态机。
- en: In this chapter, we will go over the basics of SceneKit and we will make a simple
    SceneKit scene (known as `SCNScene`) using both code and the visual design tools
    Xcode provides. We will then add physics, lights, and particles to our SceneKit
    objects and scene. We will then wrap up with a look into the *WWDC15* Fox Demo
    and some of the features/APIs it uses, which became available in iOS 8 and iOS
    9.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍 SceneKit 的基础知识，并使用代码和 Xcode 提供的视觉设计工具创建一个简单的 SceneKit 场景（称为 `SCNScene`）。然后，我们将向我们的
    SceneKit 对象和场景添加物理、灯光和粒子。最后，我们将探讨 *WWDC15* Fox 示例以及它使用的某些功能/API，这些功能在 iOS 8 和
    iOS 9 中可用。
- en: Note
  id: totrans-5
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In the previous chapter, we left out much of these asset creation features in
    our discussion on SpriteKit. With SpriteKit scene files, (`.sks`), we can also
    create game assets, such as lights, physics fields, bounding boxes/physics constraints,
    normal maps, textures, entire levels, and characters in the same fashion that
    SceneKit scene files (`.scn`) work. We will at times show the SpriteKit method
    to similar features.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们在讨论 SpriteKit 时省略了许多这些资产创建功能。使用 SpriteKit 场景文件（`.sks`），我们也可以以与 SceneKit
    场景文件（`.scn`）相同的方式创建游戏资产，例如灯光、物理场、边界框/物理约束、法线贴图、纹理、整个关卡以及角色。我们有时会展示 SpriteKit 方法来展示类似的功能。
- en: Since SpriteKit and SceneKit scene assets work similarly and can be together
    in the same scene (thanks to their inherit node/tree functionality), we thought
    that it was best to save the visual and asset tool discussion for this chapter.
    The previous chapter's talk on the game/render loop and much of the scene code
    functionality will work in SceneKit much like it did previously in SpriteKit.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SpriteKit和SceneKit场景资产的工作方式相似，并且可以在同一场景中一起使用（归功于它们的继承节点/树功能），我们认为最好将视觉和资产工具讨论留到本章。前一章关于游戏/渲染循环以及场景代码功能的大部分内容将在SceneKit中像之前在SpriteKit中那样工作。
- en: So in other words, we are already set up to dive right into SceneKit.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，换句话说，我们已经准备好直接进入SceneKit。
- en: SceneKit basics and working with nodes
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SceneKit基础和节点操作
- en: Like SpriteKit, SceneKit is based on the concept of nodes. SpriteKit objects
    are children of the `SKNode` class, while SceneKit objects are children of the
    `SCNNode` class.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 与SpriteKit一样，SceneKit基于节点的概念。SpriteKit对象是`SKNode`类的子类，而SceneKit对象是`SCNNode`类的子类。
- en: '![SceneKit basics and working with nodes](img/00034.jpeg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![SceneKit基础和节点操作](img/00034.jpeg)'
- en: The preceding image is the SceneGraph hierarchy from Apple's SceneKit introduction.
    As we see, SceneKit has various nodes that branch off from the `SCNScene` class.
    These include the generic `SCNNode` for lights, geometry, and the camera.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图像是Apple SceneKit介绍中的SceneGraph层次结构。正如我们所见，SceneKit从`SCNScene`类分支出各种节点。这些包括用于灯光、几何和摄像机的通用`SCNNode`。
- en: Nodes are a tree data structure that can have other nodes added to them and
    have information of other nodes in the structure. As seen in the preceding graph,
    it's shown with the `childNode[]` array and parent properties. Spatial information,
    such as position, scale, and orientation, can be received from these properties.
    This is what makes nodes unique to other parent-child structuring in object-oriented
    design (OOD).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 节点是一种可以添加其他节点并具有结构中其他节点信息的数据结构。如前图所示，它通过`childNode[]`数组和父属性展示。空间信息，如位置、缩放和方向，可以从这些属性中获取。这就是节点在面向对象设计（OOD）中相对于其他父子结构独特的特点。
- en: 'In SpriteKit, we''d typically add a node to our scene or to another node within
    our scene via the `addChild()` function. In SceneKit, the same functionality is
    done with `addChildNode()`. For example, the main root node in a SceneKit scene
    is the `SCNScene` node that is placed in the `SCNView` node, that is, the framework''s
    unique version of the `UIView` class. To add a basic sphere object to our scene,
    we''d do the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在SpriteKit中，我们通常通过`addChild()`函数将节点添加到场景或场景中的另一个节点。在SceneKit中，相同的功能通过`addChildNode()`实现。例如，SceneKit场景中的主要根节点是放置在`SCNView`节点中的`SCNScene`节点，即框架的`UIView`类的独特版本。要将基本球体对象添加到场景中，我们会执行以下操作：
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As stated with SpriteKit, working with nodes in SpriteKit can allow us to group
    various members of our game scene together into their own parent nodes and make
    actions on them in one call also iterating through for loops or other iteration
    calls.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 正如SpriteKit所述，通过SpriteKit中的节点，我们可以将游戏场景中的各种成员组合成它们自己的父节点，并在一个调用中对这些节点执行动作，同时通过循环或其他迭代调用进行迭代。
- en: SpriteKit / SceneKit interactivity
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SpriteKit / SceneKit交互
- en: One great feature of SceneKit is that we can have a SpriteKit scene overlay
    our 3D game.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit的一个显著特点是我们可以将SpriteKit场景叠加到3D游戏中。
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Using the `SCNView` property `overlaySKcene`, we can take an already established
    `SKScene` node (which can be a character, an animation sequence, an HUD, and more)
    and have them in our 3D scene.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`SCNView`的`overlaySKScene`属性，我们可以将已经建立的`SKScene`节点（可以是角色、动画序列、HUD等）添加到我们的3D场景中。
- en: Want to have a cute sprite animation overlay your 3D character's stage win or
    maybe want to make a 2.5D game with 2D sprites and physics overlaying a 3D background?
    Then this is how you can do it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 想要有一个可爱的精灵动画叠加到3D角色的舞台胜利场景上，或者想要制作一个2.5D游戏，使用2D精灵和物理效果叠加在3D背景上？那么这就是你可以这样做的方法。
- en: '![SpriteKit / SceneKit interactivity](img/00035.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![SpriteKit / SceneKit交互](img/00035.jpeg)'
- en: The most common functionality of mixing SpriteKit with SceneKit is that SpriteKit
    is the HUD for the SceneKit scene. The lives, collectables, and character icon
    seen in the earlier Fox demo shows a SpriteKit node overlaying a SceneKit scene.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将SpriteKit与SceneKit混合使用最常见的功能是，SpriteKit是SceneKit场景的用户界面（HUD）。在早期的Fox演示中看到的生命、可收集物品和角色图标显示了一个SpriteKit节点叠加在SceneKit场景上。
- en: Nodes in general can help add a functional structure to your game and game scenes.
    A high reliance on nodes and inheritance in game design doesn't come without its
    flaws though.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，节点可以帮助为你的游戏和游戏场景添加功能结构。然而，在游戏设计中过度依赖节点和继承并不是没有缺陷的。
- en: The issue with inheritance-based structuring and game design
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基于继承的结构化和游戏设计的问题
- en: Before going forward, we should mention about a certain pitfall that could plague
    a game that relies too much on the concept of nodes and even the general concept
    of inheritance-based structuring in OOD. When possible, it's best not to rely
    too much on inheritance for your game logic and work more with what's known as
    composite-based structuring. We'll go deeper into this in our next chapter when
    we talk about the helper game development framework first introduced in iOS 9,
    GamePlayKit, but here's a glance so that we know that working with inheritance
    and even nodes might not always be the best solution in our games.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续前进之前，我们应该提到一个可能困扰过度依赖节点概念甚至面向对象设计（OOD）中基于继承的结构化的一般概念的陷阱。当可能的时候，最好不要过度依赖继承来处理你的游戏逻辑，而更多地使用所谓的基于组合的结构化。我们将在下一章中深入探讨这个问题，当时我们将首先介绍在iOS
    9中首次引入的辅助游戏开发框架GamePlayKit，但在这里我们先了解一下，与继承和节点一起工作可能并不是我们游戏中总是最佳的选择。
- en: '![The issue with inheritance-based structuring and game design](img/00036.jpeg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![基于继承的结构化和游戏设计的问题](img/00036.jpeg)'
- en: At first glance, one might think that inheritance-based structuring is perfectly
    made for game development. Many of us familiar with OOD know that we can have
    generic parent classes or nodes of our game objects, such as an all-encompassing
    `GameObject` class, and then use inheritance and polymorphism to work with unique
    child classes from this base class. For small, simplistic games that will hold
    true, but games tend to have objects that could share some of the same functionality,
    but make no sense to have in a parent-child structure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 初看之下，人们可能会认为基于继承的结构化非常适合游戏开发。我们中许多熟悉面向对象设计（OOD）的人都知道，我们可以有通用的父类或游戏对象的节点，例如一个包含所有功能的`GameObject`类，然后使用继承和多态来处理从这个基类派生出的独特子类。对于小型、简单的游戏来说，这确实是正确的，但游戏往往有可以共享一些相同功能但放在父-子结构中又没有意义的对象。
- en: 'Take this typical structuring in a tower-based strategy game:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在塔式策略游戏中，我们可以采用这种典型的结构化方式：
- en: '![The issue with inheritance-based structuring and game design](img/00037.jpeg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![基于继承的结构化和游戏设计的问题](img/00037.jpeg)'
- en: In a typical tower game, we'd have our base, tower, and enemy objects that can
    all inherit from a generic `GameObject` class we define. Towers can fire at enemies
    but so can enemies back at the towers and other player-based objects. Part of
    good programming and design is to have reusable code and methods. Normally, we'd
    do this with inheritance. The preceding graph shows two-way inheritance that can
    solve this. We would then want a `ShootingEnemy` class that inherits the movement
    and shooting functionality. We can't do this, as that would involve inheriting
    from two separate and rather unrelated classes of objects. In OOD, there's only
    one child-parent relationship. The next solution shown on the right would be to
    have the generic `GameObject` class have this functionality. The issue that arises
    is that our once simple `GameObject` parent class becomes all but simple and we
    inevitably want to add additional features and functionalities to objects in our
    game. In the past, this would involve refactoring tons of code to accommodate
    what essentially are simple design add-ons. Protocols used to be somewhat of a
    solution to this as they'd force us to make a class in a certain way, but even
    they could get confusing and don't involve the implementation of these features.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个典型的塔式游戏中，我们会有基础、塔和敌人对象，它们都可以从我们定义的通用`GameObject`类继承。塔可以对敌人开火，敌人也可以对塔和其他基于玩家的对象开火。良好的编程和设计的一部分是拥有可重用的代码和方法。通常，我们会通过继承来实现这一点。前面的图表显示了可以解决这个问题的双向继承。我们接下来会想要一个继承移动和射击功能的`ShootingEnemy`类。但我们不能这样做，因为这会涉及到从两个完全不同且相当无关的对象类继承。在面向对象设计中，只有一个子-父关系。右边的下一个解决方案是将这种功能添加到通用的`GameObject`类中。出现的问题是我们曾经简单的`GameObject`父类变得相当复杂，我们不可避免地想要在我们的游戏对象中添加额外的功能和功能。在过去，这会涉及到重构大量代码以适应本质上只是简单设计附加的功能。协议曾经是某种解决方案，因为它们会强迫我们以某种方式创建一个类，但即使是它们也可能变得令人困惑，并且不涉及这些功能的实现。
- en: The solution would be to work with entities and components.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是与实体和组件一起工作。
- en: '![The issue with inheritance-based structuring and game design](img/00038.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![基于继承的结构和游戏设计的问题](img/00038.jpeg)'
- en: This preceding diagram gives an example of composite-based structuring. With
    this methodology, we can have components that share similar functionality, being
    used by multiple and usually unrelated game objects. This way, the generic `GameObject`
    class in this example doesn't have to have every possible function of its child
    class and we can keep `Enemy` classes as being members of `Enemy`. The shared
    functionality can be written once and then used throughout the game and even in
    the other games we wish to make. iOS 9's SpriteKit demo, DemoBots, and the SceneKit
    demo mentioned earlier, Fox, both use composite-based structuring for actions
    and animations.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表给出了基于组合的结构示例。使用这种方法，我们可以拥有具有相似功能的部分，这些部分被多个通常无关的游戏对象使用。这样，本例中的通用`GameObject`类就不必具备其子类可能的所有功能，我们还可以将`Enemy`类作为`Enemy`的成员。共享功能可以一次性编写，然后在整个游戏中以及在其他我们希望制作的游戏中使用。iOS
    9的SpriteKit演示、DemoBots以及前面提到的SceneKit演示Fox都使用基于组合的结构进行动作和动画。
- en: It's important when thinking with nodes in both SpriteKit and SceneKit that
    they are used in the context of the View of the MVC model, or in both frameworks,
    the context of their scenes.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当在SpriteKit和SceneKit中考虑节点时，重要的是它们在MVC模型的View上下文中使用，或者在两个框架中，它们的场景上下文中使用。
- en: As for scenes in SceneKit, let's move on to making a very basic one.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SceneKit中的场景，让我们继续制作一个非常基本的场景。
- en: Our first SceneKit scene – the Xcode template
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们的第一个SceneKit场景 – Xcode模板
- en: 3D art and animation is a very in-depth topic. We could go on *ad nauseam* about
    materials, shaders, lighting, sculpting, PVR textures, and all of the topics of
    what makes great 3D objects for games, movies, architecture, or any other 3D object-based
    application.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 3D艺术和动画是一个非常深入的话题。我们可以无休止地讨论材料、着色器、光照、雕刻、PVR纹理以及所有使游戏、电影、建筑或任何其他基于3D对象的应用程序中的3D对象变得出色的主题。
- en: Some of the details of these topics are beyond the scope of this book, so for
    now, let's keep things simple.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主题的一些细节超出了本书的范围，所以现在让我们保持简单。
- en: '![Our first SceneKit scene – the Xcode template](img/00039.jpeg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![我们的第一个SceneKit场景 – Xcode模板](img/00039.jpeg)'
- en: 'Let''s work with the default SceneKit scene and objects that Xcode gives us
    as a start, as shown in the preceding image:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从Xcode提供的默认SceneKit场景和对象开始，如图所示：
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As of the time of writing this book, we used the SceneKit template for Xcode
    7 – Beta. Based on the version you use, there might be some differences.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，我们使用了Xcode 7 – Beta的SceneKit模板。根据你使用的版本，可能会有一些差异。
- en: First, open Xcode, create a new project, and select the **Game** template.![Our
    first SceneKit scene – the Xcode template](img/00040.jpeg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开Xcode，创建一个新的项目，并选择**游戏**模板。![我们的第一个SceneKit场景 – Xcode模板](img/00040.jpeg)
- en: Next, name your project, make sure that the **Game Technology** field says **SceneKit**,
    and click on **Next**.![Our first SceneKit scene – the Xcode template](img/00041.jpeg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为你的项目命名，确保**游戏技术**字段显示为**SceneKit**，然后点击**下一步**。![我们的第一个SceneKit场景 – Xcode模板](img/00041.jpeg)
- en: The project files and structure are about the same as we saw with SpriteKit
    but with a couple of differences, particularly the `art.scnassets` folder. The
    only difference is that there is now an `art.scnassets` folder in addition to
    `Assests.xcassets`. This is where our 3D objects are held. Click on that folder
    to see the `ship.dae` asset that Apple provides.![Our first SceneKit scene – the
    Xcode template](img/00042.jpeg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 项目文件和结构大致与SpriteKit相同，但有一些不同，特别是`art.scnassets`文件夹。唯一的区别是现在除了`Assests.xcassets`外，还有一个`art.scnassets`文件夹。这是我们的3D对象所在之处。点击该文件夹以查看Apple提供的`ship.dae`资产。![我们的第一个SceneKit场景
    – Xcode模板](img/00042.jpeg)
- en: 'With the SceneKit editor, we can view and edit the following 3D file types:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SceneKit编辑器，我们可以查看和编辑以下3D文件类型：
- en: DAE
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: DAE
- en: OBJ
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: OBJ
- en: Alembic
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alembic
- en: STL
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: STL
- en: PLY
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: PLY
- en: The example given to us is a spaceship of the type DAE and with the `ship.dae`
    file as the ship's texture file (`texture.png`). Before we look into the code
    and how the scene works, build and run the program on either your own device or
    the Xcode device simulator.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 给我们的示例是一个DAE类型的宇宙飞船，`ship.dae`文件作为飞船的纹理文件（`texture.png`）。在我们查看代码和场景如何工作之前，请在自己的设备或Xcode设备模拟器上构建并运行程序。
- en: From the sample scene, we see our spaceship rotating in front of a black background
    and we can change its orientation when we swipe the ship. Tapping on the ship
    causes it to glow red for a moment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 从示例场景中，我们看到我们的宇宙飞船在黑色背景前旋转，并且我们可以通过滑动飞船来改变其方向。点击飞船会使它瞬间发出红色光芒。
- en: Let's now see what's going on with the code and then we'll get into the tools
    the editor gives us to edit our objects and scenes without any code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看代码中发生了什么，然后我们将探讨编辑器为我们提供的工具，以便在不编写任何代码的情况下编辑我们的对象和场景。
- en: SceneKit project flow and structure
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SceneKit 项目流程和结构
- en: Like SpriteKit, a SceneKit scene uses the same game-rendering loop as we saw
    from the previous chapter and the same type of entry point structuring we mentioned
    in *Chapter 2*, *Structuring and Planning a Game Using iOS 9 Storyboards and Segues*.
    We have the `AppDelegate.swift` file that is our entry point with the ability
    to control special app functionality based on upper level device events, such
    as the app closing, going into the background, and coming back from being in the
    background. We also have the launch screen and `Main.storyboard` files as seen
    before in SpriteKit.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 与 SpriteKit 类似，SceneKit 场景使用与上一章中看到的相同的游戏渲染循环，以及我们在 *第 2 章* 中提到的相同类型的入口点结构，即
    *使用 iOS 9 Storyboards 和 Segues 设计游戏结构和规划*。我们有一个 `AppDelegate.swift` 文件，它是我们的入口点，可以根据上层设备事件控制特殊的应用功能，例如应用关闭、进入后台和从后台返回。我们还有之前在
    SpriteKit 中看到的启动屏幕和 `Main.storyboard` 文件。
- en: '![SceneKit project flow and structure](img/00043.jpeg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![SceneKit 项目流程和结构](img/00043.jpeg)'
- en: The difference with the `Main.storyboard` file is that it has a SceneKit scene
    icon, shown with the cube, as seen in the preceding screenshot.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `Main.storyboard` 文件不同的是，它有一个 SceneKit 场景图标，如前一张截图所示，以立方体形式显示。
- en: 'The `ViewController` class the AppDelegate moves to is the `GameViewController.swift`
    class. This is where all of our code for the demo takes place:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: AppDelegate 转移到的 `ViewController` 类是 `GameViewController.swift` 类。这是我们所有演示代码所在的地方：
- en: '[PRE2]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We see that we begin with the overwritten `viewDidLoad()` function. SceneKit
    lets us create an entire scene with even an instance of our 3D object/assets,
    as seen from the unwrapped `let scene = SCNScene(named: "art.scnassets/ship.dae")!`
    call. This simply creates the scene object. To get the object seen on the screen,
    we still need to attach this to the `SCNView` node, as we will see later in the
    function.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '我们看到我们开始于重写的 `viewDidLoad()` 函数。SceneKit 允许我们创建一个完整的场景，甚至包括我们的 3D 对象/资产的一个实例，正如我们从解包的
    `let scene = SCNScene(named: "art.scnassets/ship.dae")!` 调用中看到的。这仅仅创建了场景对象。要获取屏幕上显示的对象，我们仍然需要将其附加到
    `SCNView` 节点，正如我们稍后将在函数中看到的。'
- en: 'Let''s look at some more of the code here:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这里的一些代码：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `viewDidLoad()` function mentioned earlier is provided to us in the template.
    It''s actually rather simple to follow and other than the `handleTap()` function,
    does practically all that''s needed to create this scene. Anyone who''s created
    3D graphics in OpenGL either for iOS or other platforms would appreciate how SceneKit
    gives us a number of simple upper level controls for the scene and objects. Here
    are more details of the provided code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到的 `viewDidLoad()` 函数在模板中提供给我们。实际上，它非常简单易懂，除了 `handleTap()` 函数外，几乎完成了创建这个场景所需的所有工作。任何在
    OpenGL 中为 iOS 或其他平台创建过 3D 图形的开发者都会欣赏 SceneKit 给我们提供的场景和对象的高级简单控制。以下是提供的代码的更多细节：
- en: 'On line `(1)`, an `SCNNode` named cameraNode is created, and we assign the
    `camera` attribute of `SCNNode` to the `SCNCameraNode` type. Then, the camera
    is placed in a three-dimensional space using the `SCNVector3()` function on the
    camera''s `position` property. In this case, the camera is placed at (`x: 0`,
    `y: 0`, `z: 15`). In other words, the *x* and *y* coordinates are set at the origin
    while the camera is moved slightly backwards in the *z* axis.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '在行 `(1)` 上，创建了一个名为 cameraNode 的 `SCNNode`，并将 `SCNNode` 的 `camera` 属性赋值为 `SCNCameraNode`
    类型。然后，使用相机 `position` 属性上的 `SCNVector3()` 函数将相机放置在三维空间中。在这种情况下，相机放置在 (`x: 0`,
    `y: 0`, `z: 15`)。换句话说，*x* 和 *y* 坐标被设置为原点，而相机在 *z* 轴上稍微向后移动。'
- en: '![SceneKit project flow and structure](img/00044.jpeg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![SceneKit 项目流程和结构](img/00044.jpeg)'
- en: You can find the SceneKit coordinate diagram at [https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/)
    找到 SceneKit 坐标图。
- en: The coordinate system in SceneKit is what's known as a **Right-Handed Coordinate
    System**. One trick to understand the 3D coordinates is if we take our right hand,
    make a gun-like gesture out with our thumb up in the air and pointer finger straight
    ahead of us while our middle finger to the side at a right angle from the pointer
    finger, we'd have our *x*, *y*, and *z* coordinates. Your middle finger would
    be on the *x* axis (left/right), your thumb would be on the *y* axis (up/down),
    and your pointer finger would be on the *z* axis (backward/forward).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit中的坐标系被称为**右手坐标系**。理解3D坐标系的一个技巧是，如果我们用右手，做出类似枪的手势，拇指向上，食指直伸在我们面前，中指与食指成直角，我们就会得到*x*、*y*和*z*坐标。你的中指会在*x*轴（左右），拇指会在*y*轴（上下），食指会在*z*轴（前后）。
- en: In the `(2)` block of code, we are adding lights to our screen. SceneKit, as
    well as SpriteKit, lets us create a number of different lighting effects, from
    ambient occlusion, the use of normal maps, and more. Here, an instance of `SCNNode`
    is created with the name `lightNode`, and the `SCNNode` property light is assigned
    the `SCNLight` class type. The first light created and added to the scene is what's
    known as an `SCNLightTypeOmni` type light, as seen from the implicitly unwrapped
    call `lightNode.light!.type = SCNLightTypeOmni`. This type of light is typically
    used more for debugging as the next light added, `ambientLightNode`, would be
    one of the types used to create the atmosphere to your game. As we see with the
    line, `ambientLightNode.light!.color = UIColor.darkGrayColor()`, we can assign
    a color to that light in code.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在`(2)`代码块中，我们正在向屏幕添加灯光。SceneKit以及SpriteKit都允许我们创建多种不同的光照效果，从环境遮挡、使用法线贴图等。在这里，创建了一个名为`lightNode`的`SCNNode`实例，并将`SCNNode`属性`light`赋值为`SCNLight`类类型。第一个创建并添加到场景中的灯光是所谓的`SCNLightTypeOmni`类型灯光，正如从隐式解包的调用`lightNode.light!.type
    = SCNLightTypeOmni`中看到的那样。这种类型的灯光通常更多地用于调试，因为接下来添加的灯光`ambientLightNode`将是用于创建游戏氛围的类型之一。正如我们通过`ambientLightNode.light!.color
    = UIColor.darkGrayColor()`这一行所看到的那样，我们可以在代码中为该灯光指定颜色。
- en: More information on `SCNLights` can be found at [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SCNLights`的更多信息可以在[https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNLight_Class/index.html)找到。
- en: We'll soon see how to visually add lights and other aspects of the demo `viewDidLoad()`
    function to our scene, but it's usually beneficial to understand the boilerplate
    code behind the scenes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很快就会看到如何将灯光和其他方面可视化地添加到`viewDidLoad()`函数中，但通常理解幕后的一些样板代码是有益的。
- en: 'In the line `(3)`, `let ship = scene.rootNode.childNodeWithName("ship", recursively:
    true)!` is how we add our `ship` object to the scene''s root node. This is not
    too much different than other objects in the scene. It takes the string `ship`
    from the name of our `ship.dae` object in the `art.scnassets` folder. The `recursively:
    true` parameter in the `childNodeWithName` function tells the scene that it should
    add all child nodes of the object to the scene. Depending on how the 3D object
    was modeled and rigged in its original 3D model program, the object might have
    a complex array of child nodes. Setting recursively to `true` will iterate through
    not just the child nodes but their child nodes as well.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '在`(3)`行中，`let ship = scene.rootNode.childNodeWithName("ship", recursively:
    true)!`是我们将`ship`对象添加到场景根节点的方法。这与场景中的其他对象并没有太大的不同。它从`art.scnassets`文件夹中`ship.dae`对象的名称中获取字符串`ship`。`childNodeWithName`函数中的`recursively:
    true`参数告诉场景它应该将对象的全部子节点添加到场景中。根据原始3D模型程序中3D对象的建模和绑定方式，对象可能有一个复杂的子节点数组。将`recursively`设置为`true`将迭代子节点以及它们的子节点。'
- en: 'The following long line (part of line `(4)`) is a compact way of telling the
    ship to rotate continually by *x*, *y*, and/or *z* angles based on its current
    orientation:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下长行（`(4)`行的一部分）是告诉船只根据其当前方向以*x*、*y*和/或*z*角度持续旋转的紧凑方式：
- en: '[PRE4]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This can be broken down into its various parts, as it's an `SCNAction` within
    an `SCNAction`, namely, the `rotateByX` function wrapped into a `repeatActionForever`
    function of `SCNAction`. Actions in both SceneKit (`SCNAction`) and SpriteKit
    (`SKAction`) cannot only be added to objects by code but also in Xcode's visual
    editor, as we shall see later in our review of the Fox demo.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以分解为其各个部分，因为它是一个嵌套在`SCNAction`中的`SCNAction`，即`rotateByX`函数被包裹在`SCNAction`的`repeatActionForever`函数中。SceneKit（`SCNAction`）和SpriteKit（`SKAction`）中的动作不仅可以通过代码添加到对象中，还可以在Xcode的视觉编辑器中添加，正如我们稍后将在Fox演示的回顾中看到的那样。
- en: 'Find more on both the `SCNAction` and `SKAction` classes here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里了解更多关于`SCNAction`和`SKAction`类的信息：
- en: For `SCNAction`, refer to [https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SCNAction`，请参阅[https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SCNAction_Class/)。
- en: For `SKAction`, refer to [https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`SKAction`，请参阅[https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/](https://developer.apple.com/library/ios/documentation/SpriteKit/Reference/SKAction_Ref/)。
- en: In line `(5)`, we create the `SCNView` object and assign it as the view of `GameViewController`
    with the line `let scnView = self.view as! SCNView`. The scene and its nodes that
    we created with the object named `scene` back in line `(1)` then gets assigned
    to the `scene` attribute of `scnView` via `scnView.scene = scene`. There is a
    slight bit of ambiguity as to which scene is assigned to what node, but this essentially
    has to do with the setting up of `rootNode` itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在行（5）中，我们创建了`SCNView`对象，并将其分配给`GameViewController`的视图，使用行`let scnView = self.view
    as! SCNView`。然后，我们使用名为`scene`的对象在行（1）中创建的场景及其节点被分配给`scnView`的`scene`属性，通过`scnView.scene
    = scene`。关于哪个场景分配给了哪个节点，有一些轻微的不确定性，但这基本上与`rootNode`的设置本身有关。
- en: The next few lines (of `(6)`) show some of the properties that we can use from
    the `SCNView` class; the first being the ability to control the camera with the
    `allowsCameraControl` property. Setting this to `false` would prevent the player
    from being able to move the camera about. This could be great for in-game cut
    scenes or locking the camera during a part of a stage where it would be necessary.
    The line `scnView.showsStatistics = true` tells the scene to show any rendering
    data that would be beneficial to debugging. For example, we could see the **frames
    per second** (**fps**) our game is running at.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的几行（即（6））展示了我们可以从`SCNView`类中使用的某些属性；首先是使用`allowsCameraControl`属性控制摄像头的功能。将此设置为`false`将阻止玩家移动摄像头。这对于游戏中的剪辑场景或锁定舞台的一部分，使其成为必要的情况可能非常棒。`scnView.showsStatistics
    = true`这一行告诉场景显示任何对调试有益的渲染数据。例如，我们可以看到游戏运行的**每秒帧数**（**fps**）。
- en: This is equivalent to a SpriteKit scene's code part of `skView.showsFPS` and
    `skView.showsNodeCount`, where `skView` is the name of an `SKView` object.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这与SpriteKit场景的代码部分`skView.showsFPS`和`skView.showsNodeCount`等价，其中`skView`是`SKView`对象的名字。
- en: The next line, `scnView.backgroundColor = UIColor.blackColor()`, allows us to
    set the background color to black, just the same way as we did with `ambientLightNode.light!.color
    = UIColor.darkGrayColor()` using the `UIColor` class.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 下一行，`scnView.backgroundColor = UIColor.blackColor()`，允许我们将背景颜色设置为黑色，就像我们使用`UIColor`类将`ambientLightNode.light!.color
    = UIColor.darkGrayColor()`设置为深灰色颜色一样。
- en: SceneKit Debugging Options
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SceneKit 调试选项
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: As of iOS 9, even more debugging options became available through the use of
    the `SCNDebugOptions` struct and the `debugOptions` attribute of `SCNView`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 截至iOS 9，通过使用`SCNDebugOptions`结构和`SCNView`的`debugOptions`属性，更多的调试选项变得可用。
- en: 'If we were to write the following, we''d be able to see our ship''s bounding
    boxes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们写下以下内容，我们就能看到我们船的边界框：
- en: '[PRE5]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There are other options such as `ShowLightInfluences`, `ShowPhysicsShapes`,
    and `ShowWireframe`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其他选项还包括`ShowLightInfluences`、`ShowPhysicsShapes`和`ShowWireframe`。
- en: '![SceneKit Debugging Options](img/00045.jpeg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![SceneKit 调试选项](img/00045.jpeg)'
- en: WWDC15's Fox Demo with the .ShowBoundingBoxes and ShowPhysicsShapes options
    enabled
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: WWDC15的Fox演示，启用了.ShowBoundingBoxes和ShowPhysicsShapes选项
- en: 'Finally, in line `(7)`, `let tapGesture = UITapGestureRecognizer(target: self,
    action: "handleTap:")` creates a `UITapGestureRecognizer` object named `tapGesture`,
    which will call the function `handleTap(gestureRecognize: UIGestureRecognizer)`
    when any tap is performed and `scnView.addGestureRecognizer(tapGesture)` adds
    that recognizer to the scene.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '最后，在行`(7)`中，`let tapGesture = UITapGestureRecognizer(target: self, action:
    "handleTap:")`创建了一个名为`tapGesture`的`UITapGestureRecognizer`对象，当任何点击发生时，它将调用函数`handleTap(gestureRecognize:
    UIGestureRecognizer)`，而`scnView.addGestureRecognizer(tapGesture)`将识别器添加到场景中。'
- en: Handling user input in SceneKit
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在SceneKit中处理用户输入
- en: The `UITapGestureRecognizer` objects are great in order to selectively organize
    the input we receive from the player. This goes for both SceneKit and SpriteKit
    scenes. We can have recognizers for taps, swipes in each direction, panning, pinches,
    and long presses; long presses are great for when you'd need to possibly handle
    a character charging their attack.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITapGestureRecognizer`对象在选择性组织我们从玩家那里接收到的输入方面非常出色。这适用于SceneKit和SpriteKit场景。我们可以为点击、每个方向的滑动、平移、捏合和长按设置识别器；长按非常适合当你可能需要处理角色充电攻击时。'
- en: 'Here''s the documentation of the `UITapGestureRecognizer` class for reference:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是`UITapGestureRecognizer`类的文档，供您参考：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html](https://developer.apple.com/library/prerelease/ios/documentation/UIKit/Reference/UIGestureRecognizer_Class/index.html)'
- en: 'Let''s take a look at that `handleTaps` function as it contains an object of
    the SceneKit class, `SCNTransaction`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看那个`handleTaps`函数，因为它包含了一个SceneKit类的对象`SCNTransaction`：
- en: '[PRE6]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In line `(1)`, we are just creating a reference to the current `SCNView` object
    named `scnView`. Next, the constant `p` is created using `gestureRecognize.locationInView(scnView)`.
    What this is doing is capturing the gesture's location in the view we wish to
    keep tabs on. In this case, it's the entire view, `scnView`. If we had subviews,
    say a game's menu screen, then we could if we'd wish only target gestures there
    in this fashion.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`(1)`中，我们只是创建了一个对当前`SCNView`对象`scnView`的引用。接下来，使用`gestureRecognize.locationInView(scnView)`创建了常量`p`。这所做的是捕获我们希望跟踪的视图中的手势位置。在这种情况下，是整个视图`scnView`。如果我们有子视图，比如一个游戏菜单屏幕，那么如果我们愿意，我们可以以这种方式仅针对那里的手势进行目标识别。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If building a game where the player has to tap at the spur of the moment and
    many times for a character's movement or dodging, we did find the `touchesBegan()`
    functionality we spoke about in SpriteKit to be a bit faster than `UITapGestureRecognizer`.
    This might eventually become a moot point with each new and faster iOS device,
    but if your game's controls are heavily dependent on quickness of the player,
    you might notice some lag in response to the gestures via the `UITapGesterRecognizer`
    approach. This could effect the goal of your game, so try the `touchesBegan()`
    function to see what works best for your game. Using `touchesBegan()` for swipes
    and other non-tap gestures could be rather tricky, so there's a trade-off there
    on the development side too.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果正在构建一个玩家需要即兴点击多次以控制角色移动或躲避的游戏，我们发现SpriteKit中提到的`touchesBegan()`功能比`UITapGestureRecognizer`要快一些。但随着每个新的、更快的iOS设备的推出，这最终可能成为一个无足轻重的问题，但如果你的游戏控制高度依赖于玩家的速度，你可能会注意到通过`UITapGestureRecognizer`方法对手势的响应会有一些延迟。这可能会影响你的游戏目标，所以尝试使用`touchesBegan()`函数看看哪个最适合你的游戏。使用`touchesBegan()`进行滑动和其他非点击手势可能会相当棘手，因此在开发方面也存在权衡。
- en: Next in line `(2)`, we take a count of how many of these gestures, taps in our
    case, were captured in the view using the `hitTest()` function of `SCNView` and
    only counting if that gesture made contact with any object in our scene by passing
    the position constant, `p`, as a parameter. The function `hitTest()` returns an
    array of event results, and the `count` property then counts how large that array
    is. We can then capture a reference to the first tap by referencing the first
    member of that array. We only have a single object in this demo provided for us,
    the spaceship, so we can just get an instance of Swift's most upper parent object,
    `AnyObject`. Our `hitTest` object, `hitResults`, is an array containing references
    to every object tapped in this context. Again, this is just our spaceship object,
    so we can simply take the first object instanced at `hitTest[0]`. This is what
    the result constant represents.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是 `(2)`，我们使用 `SCNView` 的 `hitTest()` 函数来计算在视图中捕获了多少个这样的手势，在我们的例子中是触摸，并且只有当该手势与场景中的任何对象接触时才计数，通过传递位置常量
    `p` 作为参数。`hitTest()` 函数返回一个事件结果数组，然后 `count` 属性计算该数组的大小。我们可以通过引用该数组的第一个成员来捕获第一次触摸的引用。在这个演示中，我们只有一个对象提供给我们，即飞船，因此我们可以直接获取
    Swift 最上层的父对象 `AnyObject` 的实例。我们的 `hitTest` 对象 `hitResults` 是一个包含在这个上下文中触摸到的每个对象引用的数组。再次强调，这只是一个飞船对象，所以我们可以简单地取
    `hitTest[0]` 处的第一个实例。这就是结果常量所代表的。
- en: The line `let material = result.node!.geometry!.firstMaterial!` shows us how
    we get a reference to that object's material by drilling down the node's children
    using the dot operator while also implicitly unwrapping each node via the exclamation
    point (`!`). This material reference is needed for when the tap needs to make
    the spaceship turn red.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码 `let material = result.node!.geometry!.firstMaterial!` 展示了我们是怎样通过使用点操作符深入到节点的子节点来获取该对象材质的引用，同时通过感叹号（`!`）隐式解包每个节点。这个材质引用在需要触摸使飞船变红时是必需的。
- en: Tip
  id: totrans-104
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This is actually a nice broad example of how we can select only certain objects
    in our SceneKit scene to be the focus of a player's input. Here, it just picks
    any object using the broad type `AnyObject` class, but imagine a game where only
    a certain type of character or characters are selectable; think of an isometric
    top down shooter or **real-time strategy** (**RTS**) game. We could possibly check
    whether the tapped object only is a member of a certain class type (`isKindOfClass()`)
    or conforms to a certain protocol (`conformsToProtocol()`) before taking any action
    on those selected game objects. Want the player in your RTS game to only take
    actions on Tank objects? Then combining this with a menu that tells the game which
    object type is the focus could be what gives you that ability here in SceneKit.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这实际上是一个很好的例子，说明了我们如何只选择 SceneKit 场景中的某些对象作为玩家输入的焦点。在这里，它只是使用宽泛的类型 `AnyObject`
    类选择任何对象，但想象一下一款只有特定类型的角色或角色可选择的游戏；比如一个等距俯视射击游戏或**实时策略**（**RTS**）游戏。我们可能在采取任何行动之前检查触摸的对象是否仅是某个特定类类型的成员（`isKindOfClass()`）或符合某个协议（`conformsToProtocol()`）。如果你的
    RTS 游戏中的玩家只想对坦克对象采取行动？那么结合一个菜单告诉游戏哪个对象类型是焦点，可能就是你在 SceneKit 中获得这种能力的方法。
- en: 'In line `(3)`, the default SceneKit template also hands us this useful bit
    of code showing the use of `SCNTransaction`. The `SCNTransaction` class first
    became available in iOS 8, and we can think of `SCNTransaction` as a laundry list
    of changes and animations we want in the scene to take place at a certain specified
    set of time. An `SCNTransaction` class begins with the `SCNTransaction.begin()`
    call and ends at the `SCNTransaction.commit()` call. Scene graph animation calls
    that are within that block get called, by default, with a 0 second delay. In many
    cases, we''d want to control the duration of these animations, thus we use the
    `setAnimationDuration()` function at the beginning of the `SCNTransaction` block
    to set that. The line `SCNTransaction.setAnimationDuration(0.5)` sets the time
    to complete this block at half a second. Do note that within this block is another
    block of code starting with `SCNTransaction.setCompletionBlock{…}`. What this
    does is execute the call only after the `SCNTransation` block it''s within completes.
    In the case of this template demo, at first for half a second, the ship is highlighted
    red, as done in the `material.emission.contents = UIColor.redColor()` line. After
    this completes, for another half a second, the ship is brought back to it''s original
    color by setting its material emission back to `UIColor.blackColor()`. This is
    a bit confusing at first but there are a slew of animations and transactions we
    can do for our scenes with this method in just one block. Check out this link
    to the documentation; other transitions/transactions can be for fading in/out,
    camera field of view, rotation, translations, lighting, and more: [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey).'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在行`(3)`中，默认的SceneKit模板也给了我们这段有用的代码，展示了`SCNTransaction`的使用。`SCNTransaction`类首次在iOS
    8中可用，我们可以将`SCNTransaction`视为一系列我们希望在场景中特定时间点发生的变化和动画。`SCNTransaction`类从`SCNTransaction.begin()`调用开始，以`SCNTransaction.commit()`调用结束。在该块内的场景图动画调用默认情况下会延迟0秒被调用。在许多情况下，我们可能想要控制这些动画的持续时间，因此我们在`SCNTransaction`块的开始处使用`setAnimationDuration()`函数来设置。`SCNTransaction.setAnimationDuration(0.5)`将完成此块的时间设置为半秒。请注意，在这个块内还有一个以`SCNTransaction.setCompletionBlock{…}`开始的代码块。这样做的作用是在它所在的`SCNTransaction`块完成后才执行调用。在这个模板演示中，首先在半秒内，船只被高亮显示为红色，就像在`material.emission.contents
    = UIColor.redColor()`行中所做的那样。完成之后，在接下来的半秒内，船只的颜色通过将材质发射设置回`UIColor.blackColor()`恢复到原始颜色。一开始这可能有点令人困惑，但我们可以使用这种方法在单个块中为场景执行一系列动画和事务。查看此链接以获取文档；其他过渡/事务可以是淡入淡出、相机视野、旋转、平移、照明等等：[https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNTransaction_Class/index.html#//apple_ref/occ/clm/SCNTransaction/valueForKey)。
- en: As for the default SceneKit template, that's all the code used to make the scene.
    It's a basic scene and far from a game, but it should give us a basic understanding
    of what essentially makes up the main structure and logic of a scene in SceneKit.
    Before we look into the Fox demo and thus an actual full game project, let's look
    at a few other features that were added to Xcode as of iOS 9 / Xcode 7.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 至于默认的SceneKit模板，这就是制作场景所使用的全部代码。这是一个基本的场景，远非游戏，但它应该能让我们对SceneKit中场景的基本结构和逻辑有一个基本的了解。在我们查看Fox演示以及一个实际的全游戏项目之前，让我们看看iOS
    9 / Xcode 7中添加到Xcode的一些其他功能。
- en: SceneKit features introduced in iOS 9 / Xcode 7
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iOS 9 / Xcode 7中引入的SceneKit功能
- en: Let's go back to transitions and animations. As of iOS 9, we can change a character
    or other 3D object's blend mode very easily in SceneKit.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到过渡和动画。截至iOS 9，我们可以在SceneKit中非常容易地更改角色或其他3D对象的混合模式。
- en: '![SceneKit features introduced in iOS 9 / Xcode 7](img/00046.jpeg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![iOS 9 / Xcode 7中引入的SceneKit功能](img/00046.jpeg)'
- en: A display of the various blend modes in SceneKit from WWDC2015
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: WWDC2015中SceneKit的各种混合模式的展示
- en: Blend modes can be changed simply with one line, `aSCNMaterial.blendMode = .Add`,
    where `aSCNMaterial` is an object representing the material of `SCNNode`. Changing
    blend modes can create a number of effects. Some games use a player's *ghost*
    to show a past run through they are trying to beat, or there's the fade effect
    boss characters make when defeated. Combine with `SCNTransaction` to have characters
    fade in and out of these modes.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 混合模式可以通过一行代码简单地更改，`aSCNMaterial.blendMode = .Add`，其中 `aSCNMaterial` 是代表 `SCNNode`
    材料的一个对象。更改混合模式可以创建多种效果。一些游戏使用玩家的 *幽灵* 来显示他们试图超越的过去运行，或者当Boss角色被击败时，会有淡入淡出的效果。结合
    `SCNTransaction` 可以让角色在这些模式中淡入淡出。
- en: Audio nodes and 3D sound
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 音频节点和3D声音
- en: 'As of iOS 9, we can place 3D sounds into our SceneKit scenes. The `addAudioPlayer()`
    function of the `SCNNode` class function lets us append a sound to that node,
    and wherever that node is in 3D space, the sound will adhere to 3D audio mixing;
    that is, if the audio source''s `positional` property is set to `true`. Here''s
    how we''d create 3D sound with audio nodes:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 iOS 9，我们可以在 SceneKit 场景中放置 3D 声音。`SCNNode` 类的 `addAudioPlayer()` 函数让我们可以将声音附加到该节点，并且无论该节点在
    3D 空间中的位置如何，声音都将遵循 3D 音频混音；也就是说，如果音频源的 `positional` 属性设置为 `true`。以下是使用音频节点创建 3D
    声音的方法：
- en: '[PRE7]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This gives a sound effect to the game object, the `SCNNode` named node.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这为游戏对象，名为 `node` 的 `SCNNode` 提供了音效。
- en: 'To actually play the sound, we''d need to call `SCNAction` on it, as shown:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要实际播放声音，我们需要在它上面调用 `SCNAction`，如下所示：
- en: '[PRE8]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `waitForCompletion` property makes sure that the action goes as long as
    the sound is. This might not be the best for a character sound effect though as
    you might want it stopped midway (that is, the player hits the enemy, canceling
    their previously started chant, yell, or something to that degree).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`waitForCompletion` 属性确保动作持续的时间与声音一样长。但这可能不适合角色音效，因为你可能希望在中间停止（也就是说，玩家击中敌人，取消他们之前开始吟唱、尖叫或其他类似动作）。'
- en: Ambience and music
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 环境音效和音乐
- en: 'To add music and ambience, we could follow exactly the same method as adding
    a sound effect to a node: create an `SCNAudioSource` object; add that to an `SCNAudioSource`
    object; and add this to our node with `addAudioPlayer`. The only difference is
    that we''d loop the music and set it''s `positional` property to `false` as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加音乐和环境音效，我们可以遵循添加音效到节点的相同方法：创建一个 `SCNAudioSource` 对象；将其添加到 `SCNAudioSource`
    对象中；然后使用 `addAudioPlayer` 将其添加到我们的节点中。唯一的区别是，我们会循环播放音乐并将它的 `positional` 属性设置为
    `false`，如下所示：
- en: '[PRE9]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: SpriteKit scene transitions in SceneKit
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SceneKit 中的 SpriteKit 场景过渡
- en: 'SpriteKit has some great scene transitions. We could make it look like a door
    is opening up or a page is turning. This could add extra character and polish
    to your game. Before iOS 9, we couldn''t do these 2D transitions in our 3D SceneKit,
    but since Xcode 7 and iOS 9, we can do so in SceneKit and here''s how:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit 有一些很棒的场景过渡效果。我们可以让它看起来像门在打开或页面在翻动。这可以为你的游戏增添额外的特色和精致。在 iOS 9 之前，我们无法在我们的
    3D SceneKit 中进行这些 2D 过渡，但自从 Xcode 7 和 iOS 9 以来，我们可以在 SceneKit 中这样做，下面是如何操作的：
- en: '[PRE10]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, `aSCNView` is just a general reference to some `SCNView` object and when
    we present the scene to that view, we have the option of passing an `SKTransition`
    object for the `withTransition` parameter. The `incomingPointofView` parameter
    can be a reference to a camera's point of view during the transition, and the
    `completionHandler` parameter is the name of a completion block that is called
    after the scene transitions. For example, we could call the functions that start
    the count up of our last stage's score in a score scene that was transitioned
    to after the stage completed. We might not want to begin the counting and other
    functions of the new scene until we know that the scene has been 100% transitioned
    to or, in this case, after we know the total points from the prior scene.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`aSCNView` 只是对某个 `SCNView` 对象的一般引用，当我们向该视图呈现场景时，我们有传递一个 `SKTransition`
    对象作为 `withTransition` 参数的选项。`incomingPointofView` 参数可以是在过渡期间相机视点的引用，而 `completionHandler`
    参数是在场景过渡后调用的完成块的名称。例如，我们可以在阶段完成后过渡到得分场景中调用开始计算上一阶段得分的函数。我们可能不想在知道场景已经 100% 过渡到或在这种情况下，在知道前一个场景的总分之后开始新场景的计算和其他函数。
- en: 'Check out some more examples of `SKTransition` on the class reference page,
    maybe there''s a transition that could help add to your game''s design:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在类参考页面上查看一些 `SKTransition` 的更多示例，也许有一个过渡可以帮助增强你游戏的设计：
- en: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html)'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SpriteKit/Reference/SKTransition_Ref/index.html)'
- en: Fox demo
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 狐狸演示
- en: We've been spending much of our time in both SpriteKit and here in SceneKit
    on the boilerplate code that makes up our game logic. As Xcode continues to update,
    so does the visual design features for iOS game design that don't involve a strong
    understanding of code. There's always some scripting involved, but one of the
    key features in game design is, well, the design aspect of it. At the *WWDC15*
    event, the introduction to iOS 9 and Xcode 7 was a great game demo that can not
    only teach us some of the visual design features that Xcode can do, but also gives
    us a beautiful start to a platforming game in SceneKit. That demo is named *Fox*
    and granted, though it actually stars a red panda and not a fox, we could forgive
    that mixup for how feature-rich and essential it can be to learn how to develop
    SceneKit-powered iOS games.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的大部分时间都花在了SpriteKit和这里的SceneKit上，编写构成游戏逻辑的样板代码。随着Xcode的不断更新，iOS游戏设计中的视觉设计功能也在不断更新，这些功能不需要对代码有深入的了解。总是有一些脚本涉及其中，但游戏设计中的一个关键特性，嗯，就是它的设计方面。在*WWDC15*活动上，iOS
    9和Xcode 7的介绍是一个很好的游戏演示，它不仅能教会我们一些Xcode可以做的视觉设计功能，还为我们提供了一个在SceneKit中制作平台游戏的美丽起点。这个演示名为*Fox*，虽然实际上它以红熊猫为主角而不是狐狸，但我们可以原谅这种混淆，因为它功能丰富且对学习如何开发SceneKit驱动的iOS游戏至关重要。
- en: '![Fox demo](img/00047.jpeg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![狐狸演示](img/00047.jpeg)'
- en: The Fox demo image showing our player character and level assets
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 展示我们的玩家角色和关卡资源的狐狸演示图像
- en: There's much more to this demo than we can show here, so it's encouraged to
    download it for yourself and check out all of the SceneKit features it provides.
    We will focus on a few topics yet to be covered in either SceneKit or SpriteKit,
    such as particles, physics, and the scene graph. The Fox demo also makes use of
    3D game/art design features, such as skyboxes, ambient occlusion, cubemap lighting,
    collision meshes, and more. It really is a nice-quality demo to make beautiful
    games in iOS.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这个演示中还有许多我们在这里无法展示的内容，因此我们鼓励您自己下载并查看它提供的所有SceneKit功能。我们将关注一些尚未在SceneKit或SpriteKit中涵盖的主题，例如粒子、物理和场景图。狐狸演示还使用了3D游戏/艺术设计功能，如天空盒、环境遮挡、立方体贴图照明、碰撞网格等。它真的是一个制作美丽iOS游戏的优质演示。
- en: 'Here is the download link provided by Apple:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是苹果提供的下载链接：
- en: '[https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html)'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html](https://developer.apple.com/library/prerelease/ios/samplecode/Fox/Introduction/Intro.html)'
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing, the Fox demo was written only in Objective-C. We have
    focused on Swift in the entirety of this book, but don't worry too much if some
    aspects of Objective-C are foreign to you. The goal is to see the visual tools
    Xcode provides. In a future date, the Fox demo is bound to be available in Swift,
    be it by Apple themselves or by third-party programmers.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本文时，狐狸演示仅使用Objective-C编写。我们在这本书的整个过程中都专注于Swift，但请不要过于担心，如果您对Objective-C的一些方面感到陌生。目标是看到Xcode提供的视觉工具。在未来某个时间点，狐狸演示肯定将以Swift的形式提供，无论是苹果公司自己还是第三方程序员。
- en: Particle systems
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 粒子系统
- en: Some of the basic assets in any game, be it SpriteKit or SceneKit built, are
    the various particle effects we'd add to characters, objects, or an entire scene.
    Particles can add to the feel of collecting that item, give the player a signal
    that something is happening to the player, like they are gaining or losing health,
    or show the presence and power of an incoming boss fight.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 任何游戏中的一些基本资源，无论是SpriteKit还是SceneKit构建的，都是我们添加到角色、对象或整个场景中的各种粒子效果。粒子可以增强收集物品的感觉，给玩家一个信号，表明玩家发生了某些事情，比如他们正在获得或失去健康，或者显示即将到来的Boss战的存在的力量。
- en: '![Particle systems](img/00048.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/00048.jpeg)'
- en: Collectable particle effect from the Fox demo
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 来自狐狸演示的可收集粒子效果
- en: In the past, the process of making a particle effect would be to manually create
    sometimes rather complex particle emitter shader objects using OpenGL code. This
    can still be done if we so choose (using either Apple's fast, low-level API, Metal,
    or OpenGL), but over time, the process of visually creating and editing particle
    effects has gotten easier. Not too long ago in the iOS development history, frameworks
    such as Cocos2D/ Cocos3D allowed us to use third-party particle effects builders
    to import into our games. With both SpriteKit and SceneKit, Xcode as of about
    iOS 7/iOS 8, a more visual representation of particles was created in Xcode thus
    saving us a large amount of time and effort in creating the effects we want and
    expect to see in our games. The image previously shown displays the Xcode particle
    systems editor with the Fox demo's collectable sparkle effect.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，制作粒子效果的过程是手动创建有时相当复杂的粒子发射器着色器对象，使用OpenGL代码。如果我们选择这样做（使用苹果的快速、低级API，Metal或OpenGL），这仍然可以做到，但随着时间的推移，视觉创建和编辑粒子效果的过程已经变得更加简单。在iOS开发历史上不久前，像Cocos2D/
    Cocos3D这样的框架允许我们使用第三方粒子效果构建器导入到我们的游戏中。随着SpriteKit和SceneKit的出现，从iOS 7/iOS 8开始，Xcode创建了一个更直观的粒子表示，从而为我们节省了大量创建我们想要和期望在游戏中看到的效果的时间和精力。之前显示的图像显示了Xcode粒子系统编辑器，其中包含Fox演示的可收集闪光效果。
- en: 'To create your own particle effect in SceneKit, follow these steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 要在SceneKit中创建自己的粒子效果，请按照以下步骤操作：
- en: Create a new file as we did in the past by navigating to **File** | **New**
    … or simply the keyboard shortcut *command* + *N*.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过导航到**文件** | **新建** … 或者简单地使用键盘快捷键*command* + *N*，创建一个新文件，就像我们过去做的那样。
- en: We then select the **Resource** section under iOS and select the **SceneKit
    Particle System** template. (If working with SpriteKit, select **SpriteKit Particle
    File**.)![Particle systems](img/00049.jpeg)
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们在iOS下选择**资源**部分，并选择**SceneKit粒子系统**模板。（如果使用SpriteKit，请选择**SpriteKit粒子文件**。）![粒子系统](img/00049.jpeg)
- en: Both the SpriteKit and SceneKit particle options give us a list of basic particle
    templates we can start from, such as Reactor, Sparkle, or Bokeh. Select one of
    your choosing or check out a collectable one here in the demo. For SpriteKit,
    this creates an SKS file and the image mask for the particles. The SceneKit template
    creates the 3D particle effect via an SCNP file and the image mask.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SpriteKit和SceneKit的粒子选项都为我们提供了一个基本粒子模板列表，我们可以从这里开始，例如反应器、闪光或模糊。选择您想要的任何一个，或者在这里的演示中查看可收集的一个。对于SpriteKit，这会创建一个SKS文件和粒子的图像遮罩。SceneKit模板通过SCNP文件和图像遮罩创建3D粒子效果。
- en: Let's take a look back at the particle system we created for the collectable
    particle in the demo. If not selected already, click on the attributes inspector
    to view various controls we can edit to customize our particle effects.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在演示中为可收集粒子创建的粒子系统。如果没有选择，请点击属性检查器以查看我们可以编辑以自定义粒子效果的各个控件。
- en: '![Particle systems](img/00050.jpeg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![粒子系统](img/00050.jpeg)'
- en: Feel free to test a number of the variables and fields within the inspector.
    There's the birth rate, which controls how often the particles restart their start
    and end animation, the image, which can make up the shape and color of the particles,
    and the various angles that determine the overall direction of the effects. There's
    also the **Looping** dropdown, which keeps the particles repeating during the
    life of the particle system in the scene. Additionally, the **affected by gravity**
    toggle is what we use to have the particles fall based on the scene's gravity.
    The collection particles loop constantly without gravity, and the confetti particles
    happen once and fall to gravity, as we'd expect confetti to behave. If an object
    in our scene has a physics field, we can also have the particles react to that.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在检查器中，您可以随意测试多个变量和字段。这里有出生率，它控制粒子重新开始其起始和结束动画的频率，图像，它可以构成粒子的形状和颜色，以及决定效果整体方向的各个角度。还有一个**循环**下拉菜单，它使粒子在场景中粒子系统的生命周期内重复。此外，**受重力影响**切换是我们用来根据场景的重力使粒子下落的。集合粒子在没有重力的情况下不断循环，而纸屑粒子发生一次并下落到重力，正如我们预期的那样。如果场景中的物体有一个物理场，我们还可以让粒子对其做出反应。
- en: Placing particles into our pioscene
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将粒子放入我们的pioscene中
- en: 'When we create SpriteKit or SceneKit particles, we can call them in our scene
    via code in either the SpriteKit or SceneKit:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建SpriteKit或SceneKit粒子时，我们可以通过代码在SpriteKit或SceneKit中调用它们：
- en: SpriteKit
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SpriteKit
- en: 'SpriteKit particles aren''t in the Fox demo but to backtrack a bit to our talk
    on SpriteKit, if we''d wanted to add particles to a 2D SpriteKit game, here''s
    an example of how we''d accomplish that:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: SpriteKit粒子不在Fox演示中，但稍微回顾一下我们对SpriteKit的讨论，如果我们想在2D SpriteKit游戏中添加粒子，下面是如何实现这一点的示例：
- en: '[PRE11]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We create a path to our app's bundle with the `NSBundle.mainBundle().pathForResource()`
    function call, and we pass the string of the particle file's name, in this case,
    `Spark`, with the file type, SKS.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`NSBundle.mainBundle().pathForResource()`函数调用创建一个指向我们应用程序包的路径，并传递粒子文件名称的字符串，在本例中为`Spark`，以及文件类型，SKS。
- en: 'Next, we create the `sparkParticle` object using the `NSKeyedUnarchiver.unarchiveObjectWithFile(path!)`
    call that, as we see, takes the path we created in part `(1)`. It''s casted as
    the particle object for SpriteKit, `SKEmitterNode`. `NSKeyedUnarchiver` is a class
    used to decode named objects from keyed archives, an encoded hierarchy of archives.
    This class has some support of what is known type coercion. In short, it can decode
    objects in files, be it whether in a 32-bit or 64-bit architecture. More on this
    special file decoding class here: [https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/)'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们使用`NSKeyedUnarchiver.unarchiveObjectWithFile(path!)`调用创建`sparkParticle`对象，正如我们所看到的，它使用了我们在部分(1)中创建的路径。它被转换为SpriteKit的粒子对象`SKEmitterNode`。`NSKeyedUnarchiver`是一个用于从键值归档中解码命名对象的类，这是一个归档的编码层次结构。这个类有一些已知类型转换的支持。简而言之，它可以解码文件中的对象，无论是32位还是64位架构。更多关于这个特殊的文件解码类信息请参阅：[https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/](https://developer.apple.com/library/mac/documentation/Cocoa/Reference/Foundation/Classes/NSKeyedUnarchiver_Class/)
- en: We then set a position and name for this particle effect and target it to the
    scene while also adding it to the scene node.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们然后为这个粒子效果设置位置和名称，并将其定位到场景中，同时将其添加到场景节点中。
- en: Though this example isn't given in the Fox demo, this is a great example of
    how we can target specific files in our project's navigation hierarchy.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个例子没有在Fox演示中给出，但这是一个很好的例子，说明了我们如何针对项目中导航层次结构中的特定文件。
- en: SceneKit
  id: totrans-159
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SceneKit
- en: 'SceneKit particles are members of the `SCNParticleSystem` class. We add these
    particles to our scene with the `addParticleSystem` function of the `SCNNode`
    class. The Fox demo does this in the `collectFlower()` function with the following
    Objective-C line:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: SceneKit粒子是`SCNParticleSystem`类的成员。我们通过`SCNNode`类的`addParticleSystem`函数将这些粒子添加到我们的场景中。Fox演示在`collectFlower()`函数中通过以下Objective-C行来实现这一点：
- en: '[PRE12]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What this code is doing is calling the scene in the designated view and adding
    the particles, which are declared earlier in the class as `_collectParticles`
    to our scene. It then tells the scene at which point in space this effect will
    appear. In this case, it's the `particalPosition` variable that when traced back
    is taken from the `SCNNode` parameter passed into the `collectFlower()` function.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码所做的是在指定的视图中调用场景，并将之前在类中声明的粒子（`_collectParticles`）添加到我们的场景中。然后它告诉场景这个效果将在空间中的哪个点出现。在这种情况下，是`particalPosition`变量，当回溯时，它来自传递给`collectFlower()`函数的`SCNNode`参数。
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'Here''s how this would be written in Swift:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何用Swift编写的：
- en: '[PRE13]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Swift's `addParticleSystem` API unfortunately doesn't have the `withTransform`
    parameter as in Objective-C, so we'd have to add the particle system to the node
    it will be emitting from, which is denoted by the `particleEmitNode` variable.
    This most likely will change in future API changes of Swift 2.x and later.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: Swift的`addParticleSystem` API不幸地没有像Objective-C那样的`withTransform`参数，因此我们必须将粒子系统添加到它将从中发射的节点上，这由`particleEmitNode`变量表示。这很可能会在Swift
    2.x及以后的API更改中发生变化。
- en: Introducing SceneKit and SpriteKit physics
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍SceneKit和SpriteKit物理
- en: When we look at the `collectFlower()` function from our particle example, we
    see that there's an `SCNNode` parameter passed. This node comes from the function
    `physicsWorld`. In both SpriteKit and SceneKit, we can create an overall set of
    physics rules and handle various physics-related interactions, most notably, contacts
    between two or more nodes. One of the most basic aspects of any game is to do
    something when game objects hit each other. This could be when the player touches
    a collectable, when enemies contact the player or the player hits the enemy with
    an attack. In iOS development and in game engines, we call these boundaries between
    2D sprites or 3D objects as bounding boxes. We mentioned these physics objects
    briefly in our talk of iOS 9 and later `debugOptions` property. Bounding boxes
    for SceneKit objects are created automatically based on the simplified version
    of an object's geometry, but we can edit these shapes with the `SCNBoundingVolume`
    class.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们的粒子示例中的`collectFlower()`函数时，我们看到有一个`SCNNode`参数被传递。这个节点来自`physicsWorld`函数。在SpriteKit和SceneKit中，我们可以创建一套整体的物理规则，并处理各种与物理相关的交互，最值得注意的是，两个或更多节点之间的接触。任何游戏最基本的一个方面就是在游戏对象相互碰撞时做些什么。这可能是当玩家触摸可收集物品时，当敌人接触玩家或玩家用攻击击中敌人时。在iOS开发和游戏引擎中，我们称这些二维精灵或三维对象之间的边界为边界框。我们在关于iOS
    9及以后的`debugOptions`属性的讨论中简要提到了这些物理对象。SceneKit对象的边界框是基于对象的简化几何形状自动创建的，但我们可以使用`SCNBoundingVolume`类来编辑这些形状。
- en: More documentation of this class can be found at [https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于这个类的文档可以在[https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html](https://developer.apple.com/library/prerelease/ios/documentation/SceneKit/Reference/SCNBoundingVolume_Protocol/index.html)找到。
- en: Game physics in iOS and game development in general are much larger topics than
    we can discuss in this chapter. So for now, let's just see how the Fox demo and
    iOS games in general handle the simple concept of two nodes contacting their bounding
    boxes.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: iOS中的游戏物理和一般游戏开发是比我们在这个章节中能讨论的更大的主题。所以现在，让我们看看Fox演示和一般iOS游戏是如何处理两个节点接触其边界框的简单概念的。
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Preceding is a Swift pseudo code example of the Fox demo's `physicsWorld` function.
    The function takes in two parameters, `world` of the type `SCNPhysicsWorld` that
    represents the entire physics environment of a scene and the object representing
    the physics contact of the type `SCNPhysicsContact`. The function here checks
    the bitmask of the nodes in the contact. If the first or second node of the contact
    (`nodeA` or `nodeB`) are in the flower's specific category, then the `collectFlower()`
    function is called and that collectable's node is passed as a parameter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是Fox演示的`physicsWorld`函数的Swift伪代码示例。该函数接受两个参数，`world`类型为`SCNPhysicsWorld`，表示场景的整个物理环境，以及表示物理接触的`SCNPhysicsContact`类型的对象。该函数检查接触中节点的位掩码。如果接触的第一个或第二个节点（`nodeA`或`nodeB`）在花朵的特定类别中，则调用`collectFlower()`函数，并将该可收集物品的节点作为参数传递。
- en: Bitmasking is when we designate a set of bits for another set of bits that can
    be combined together using bitwise math. Think of it as using 1s and 0s to not
    only categorize a range of ones and zeros but also allow us to handle situations
    where many categories happen in the same context.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 位掩码是指我们为另一组位指定一组位，这组位可以通过位运算组合在一起。可以这样想，使用1和0不仅可以将一系列的1和0进行分类，还可以让我们处理在相同上下文中发生多个分类的情况。
- en: For example, we have different categories of objects/events in our game and
    we fit them in their own *slots* in a byte (8 bits). In the Fox demo, the game
    collisions are a bitshift value of 2, thus they represent 00000100 in binary.
    The *category designation* of collectables in the Fox demo a bitshift of 3 or
    00001000, the enemies are 4, 00010000.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的游戏中，我们有不同类别的事件/对象，并将它们放入一个字节的（8位）自己的槽中。在Fox演示中，游戏碰撞是一个2位的位移值，因此它们在二进制中表示为00000100。Fox演示中可收集物品的*类别指定*是一个3位的位移值或00001000，敌人是4，00010000。
- en: 'In the demo, we see the following code for `AAPLBitmaskSuperCollectable`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示中，我们看到以下`AAPLBitmaskSuperCollectable`的代码：
- en: '[PRE15]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: When the category bitmask in either `nodeA` or `nodeB` of the collision match
    the flower collectable (if the *slot* is *on* per say, or equal to 1, then we
    know the collectable was involved in the collision).
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当`nodeA`或`nodeB`的类别掩码与花朵可收集物匹配时（如果槽位是开启的，或者说等于1，那么我们知道可收集物参与了碰撞）。
- en: 'Swift version 1 didn''t really have a similar way to mimic bitmasking as done
    in Objective-C with NSOptions, but as of Swift 2.0, we can perform bitmasking
    like the demo in the following way:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 1版本并没有真正有类似的方式模仿Objective-C中的NSOptions所执行的位掩码，但自Swift 2.0起，我们可以像以下演示那样执行位掩码操作：
- en: '[PRE16]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Essentially, it's a struct that returns bitshifted static variables of itself.
    It's not as elegant as seen in Objective-C and in past C implementation, but if
    we wish to use bitmasking in boilerplate code in Swift, this should allow you
    to do so.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，它是一个返回自身位运算静态变量的结构体。它不如Objective-C和过去的C实现中那样优雅，但如果我们希望在Swift的样板代码中使用位掩码，这应该允许你这样做。
- en: One last note about the `physicsWorld()` function, in order for the function
    to be called during the collision of two physics bodies, we need to set the physics
    world delegate. In most cases, that delegate would be the current game scene.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 最后关于`physicsWorld()`函数的一点说明，为了在两个物理体碰撞时调用该函数，我们需要设置物理世界代理。在大多数情况下，这个代理会是当前的游戏场景。
- en: '[PRE17]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Xcode will most likely tell you that a physics world delegate wasn't set and
    if you haven't, this is the code that is usually placed in the `viewDidLoad()`
    function of `ViewController`.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode很可能会告诉你没有设置物理世界代理，如果你还没有设置，通常这段代码会放在`ViewController`的`viewDidLoad()`函数中。
- en: Visually composed game scenescgs
  id: totrans-184
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉组成的游戏场景图
- en: Getting back to the visual aspects of the Fox demo, let's look at the game scene
    objects created in the project and how we can view the nodes in what's known as
    the **scene graph**.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 回到Fox演示的视觉方面，让我们看看项目中创建的游戏场景对象以及我们如何查看所谓的**场景图**中的节点。
- en: '![Visually composed game scenescgs](img/00051.jpeg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成的游戏场景图](img/00051.jpeg)'
- en: We see that game objects and particle effects in the Fox demo can be visually
    manipulated in Xcode and together in one view. The preceding image shows the flower
    collectable and its components that consist of the 3D mesh, lighting, bounding
    boxes, and the particle effects. In SceneKit, we do this with a SceneKit scene
    file (SCN).
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到在Fox演示中，游戏对象和粒子效果可以在Xcode中视觉上操作，并在一个视图中一起显示。前面的图像显示了花朵可收集物及其组件，包括3D网格、光照、边界框和粒子效果。在SceneKit中，我们使用SceneKit场景文件（SCN）来完成这项操作。
- en: '![Visually composed game scenescgs](img/00052.jpeg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成的游戏场景图](img/00052.jpeg)'
- en: 'To view the scene''s scene graph, click on the side window icon found toward
    the bottom-left of the Xcode window under the visual editor window of the scene,
    as seen in the following screenshot:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看场景的场景图，请点击Xcode窗口中视觉编辑器窗口底部左侧的侧窗图标，如图下截图所示：
- en: '![Visually composed game scenescgs](img/00053.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成的游戏场景图](img/00053.jpeg)'
- en: This is a screenshot of the scene graph. Those familiar with the game engines,
    such as Unity and Unreal Engine, will be quite familiar with this type of component/game
    scene view. The scene graph shows the dropdown hierarchy of all the objects in
    the scene including their own internal components. The flower power-up consists
    of a 3D mesh model named *flower* that has two child particle effects as well
    as a physics body. All three are denoted by the three symbols seen on the right-hand
    side of the graph's objects.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这是场景图的截图。那些熟悉游戏引擎，如Unity和Unreal Engine的人，会对这种组件/游戏场景视图非常熟悉。场景图显示了场景中所有对象的下拉层次结构，包括它们自己的内部组件。花朵升级由一个名为*flower*的3D网格模型组成，它有两个子粒子效果以及一个物理体。这三个都由图右侧的对象上的三个符号表示。
- en: '![Visually composed game scenescgs](img/00054.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成的游戏场景图](img/00054.jpeg)'
- en: We can move the model around in the scene, using *X*, *Y*, and *Z* markers seen
    in the preceding image. We can also zoom in, zoom out, rotate the scene, as well
    as add more objects to the scene.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用前面图像中看到的*X*、*Y*和*Z*标记在场景中移动模型。我们还可以放大、缩小、旋转场景，以及向场景添加更多对象。
- en: '![Visually composed game scenescgs](img/00055.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成的游戏场景图](img/00055.jpeg)'
- en: 'To add more objects to the scene, follow these:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 要向场景添加更多对象，请按照以下步骤操作：
- en: Go to the **media library** found in the library windows at the bottom-right
    of the screen (seen in the prior image).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往屏幕底部右侧的库窗口中找到的**媒体库**（如图所示）。
- en: Now search for `grass` and simply drag and drop it into the scene. Now the premade
    grass object is in this scene as a reference.![Visually composed game scenescgs](img/00056.jpeg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在搜索`grass`并将其简单地拖放到场景中。现在预制的草地对象已作为参考出现在这个场景中。![视觉组成游戏场景scgs](img/00056.jpeg)
- en: This is actually how the `level.scn` file was composed.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这实际上就是`level.scn`文件是如何组成的。
- en: There's also the option to add primitive objects to the scene and build them
    up from there, which is again very similar to the design-centric game engines.
    Simply select from the object library tab right next to the media library icon
    and search `geometry`. There are primitive objects, such as spheres, planes, and
    boxes.![Visually composed game scenescgs](img/00057.jpeg)
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以选择将基本对象添加到场景中，并从那里构建它们，这又与以设计为中心的游戏引擎非常相似。只需从位于媒体库图标旁边的对象库标签中选择，并搜索`geometry`。有基本对象，如球体、平面和盒子。![视觉组成游戏场景scgs](img/00057.jpeg)
- en: The primitive objects lack the lighting, materials and other details that we
    can see in the grass and other premade objects in the projects. Use the even more
    detailed inspector windows for these objects to see and edit various details,
    such as the physics bodies, materials, baking the lighting, and object name identification
    for any scripting/coding.![Visually composed game scenescgs](img/00058.jpeg)
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 基本对象缺少我们在项目中的草地和其他预制对象中可以看到的照明、材质和其他细节。使用这些对象的更详细检查器窗口来查看和编辑各种细节，例如物理体、材质、烘焙照明以及任何脚本/编码的对象名称识别。![视觉组成游戏场景scgs](img/00058.jpeg)
- en: There's also actions that can be added to these objects. Click on the secondary
    editor icon (the upside down triangle in a square at the button right of the flow
    scene's view). This will open the secondary editor that shows a `RotateByEuler`
    action if the flower asset is selected in the scene graph.![Visually composed
    game scenescgs](img/00059.jpeg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还可以添加到这些对象中的动作。点击位于流程场景视图右侧的次要编辑器图标（一个倒三角形在正方形中，位于底部）。如果场景图中选择了花朵资产，这将打开次要编辑器，显示一个`RotateByEuler`动作。![视觉组成游戏场景scgs](img/00059.jpeg)
- en: What this action does is rotate the flower once every second. To see this in
    action, click on the Play button seen just above the secondary editor window timeline.
    We can see how this object will rotate from this action.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个动作的作用是每秒旋转一次花朵。要看到这个动作的效果，请点击位于次要编辑器窗口时间轴上方的播放按钮。我们可以看到这个对象将如何旋转。
- en: The action can be shortened or extended by expanding or condensing it in the
    secondary editor timeline. More details about the action can be edited in the
    Inspector window, and if we'd like, we can use the library to add more actions
    to this object or remove the one provided to have it act in a different way.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以通过在次要编辑器时间轴中展开或收缩来缩短或扩展动作。更多关于动作的详细信息可以在检查器窗口中编辑，如果我们愿意，可以使用库向该对象添加更多动作或删除提供的动作以使其以不同的方式行动。
- en: Test out a few actions, times, and properties yourself. We can see how, without
    any code, we can set up a scene visually and dynamically control actions of each
    object in that scene. Many of these visual features and actions work for both
    SceneKit and SpriteKit scenes.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 自己测试几个动作、时间和属性。我们可以看到，不使用任何代码，我们如何可以直观地设置场景并动态控制场景中每个对象的动作。许多这些视觉功能和动作都适用于SceneKit和SpriteKit场景。
- en: '![Visually composed game scenescgs](img/00060.jpeg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![视觉组成游戏场景scgs](img/00060.jpeg)'
- en: Look at the `level.scn` file to see a scene with a fully composed level camera
    object (as seen in the previous screenshot). Do you want to make a similar level
    with maybe more obstacles and a different skybox? Copy the level and change those
    assets and name it `level2`. This can save a monumental amount of time in the
    design of games and levels. From Xcode 7 onwards, we have tools directly in the
    IDE that originally were only for the multiplatform game engines. It really puts
    the design back into game design.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 查看`level.scn`文件，可以看到一个包含完整组成级别相机对象的场景（如前一张截图所示）。你想制作一个类似的级别，可能包含更多障碍物和不同的天空盒吗？复制级别并更改这些资产，并将其命名为`level2`。这可以在游戏和级别的设计中节省大量时间。从Xcode
    7开始，我们有了IDE中直接的工具，这些工具最初仅用于多平台游戏引擎。这真的让设计回到了游戏设计。
- en: Much of the manual code we've gone over could get daunting, especially for those
    of us who may want to get into game design but are still relatively new to coding.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的大多数手动代码可能会让人感到沮丧，尤其是对于那些可能想进入游戏设计但仍然相对新手的人来说。
- en: '[PRE18]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is all we need to reference a scene from the visually designed tools. Add
    it to the view's root node like we spoke about in the SceneKit basic template
    and it's ready to go. Use code to add spawning enemies, the player, and the 2D
    SpriteKit overlay (which can itself have actions and visual designs in its SKS
    file), and it's a full-fledged game.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从视觉设计工具中引用场景所需的所有内容。就像我们在SceneKit基本模板中提到的那样，将其添加到视图的根节点，它就准备好了。使用代码添加生成敌人、玩家和2D
    SpriteKit叠加层（它本身可以在其SKS文件中拥有动作和视觉设计），这样就构成了一个完整的游戏。
- en: 'For more information on the SceneKit framework as well as the latest updates
    and additions to its library, see the full documentation link as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如需更多关于SceneKit框架以及其库的最新更新和新增内容的信息，请参阅以下完整文档链接：
- en: '[https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/)'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/](https://developer.apple.com/library/ios/documentation/SceneKit/Reference/SceneKit_Framework/)'
- en: Summary
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: At the start of this chapter, we first spoke briefly about the history of 3D
    game design in iOS and how SceneKit came to be from the necessity to have a first-party,
    dynamically robust framework aimed at the complexities of 3D game development.
    We then went over the basic structure of SceneKit and how it and SpriteKit from
    the previous chapter work off the concept of nodes, starting from the view and
    moving on to the scene node and child nodes in that scene. Next, we went over
    how SpriteKit and SceneKit can be used together in the same scene as we then moved
    on to dissecting the default SceneKit template given to us in Xcode, and its various
    assets. In addition to a review of template project's code, we also reviewed some
    of the features, code, and assets, such as the audio nodes, lend modes, and debug
    options that became available as of iOS 9 / Xcode 7\. Finally, for the remainder
    of the chapter, we spoke much about the Fox demo shown during the *WWDC15* convention
    and the various visual game design features that became available since the announcement
    of Xcode 7.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们首先简要地谈到了iOS中3D游戏设计的历史以及SceneKit是如何从需要有一个针对3D游戏开发复杂性的第一方、动态稳健的框架的需求中产生的。然后，我们介绍了SceneKit的基本结构以及它和上一章中提到的SpriteKit是如何基于节点概念工作的，从视图开始，然后是场景节点以及该场景中的子节点。接下来，我们讨论了SpriteKit和SceneKit如何在同一场景中一起使用，然后我们分析了Xcode中给出的默认SceneKit模板及其各种资源。除了回顾模板项目的代码外，我们还回顾了一些功能、代码和资源，例如自iOS
    9 / Xcode 7以来可用的音频节点、渲染模式以及调试选项。最后，在本章的剩余部分，我们详细讨论了在*WWDC15*大会上展示的Fox演示以及自Xcode
    7发布以来可用的各种视觉游戏设计功能。
- en: For our next chapter, we will go into the features of the GameplayKit framework,
    which we introduced briefly when we went over the benefits of using composite-based
    structuring when building our games. With GameplayKit, we can duplicate and reuse
    premade game actions and rules as we did here in this chapter with the visual
    components of our games.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨GameplayKit框架的特点，这是我们之前在介绍使用基于组合的结构构建游戏时的好处时简要介绍过的。使用GameplayKit，我们可以像在本章中处理游戏的视觉组件那样，复制和重用预先制作的游戏动作和规则。
