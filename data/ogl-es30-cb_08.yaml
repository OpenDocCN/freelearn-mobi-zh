- en: Chapter 8. Font Rendering
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章 字体渲染
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Font rendering with the FreeType project
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用FreeType项目进行字体渲染
- en: Rendering different languages with Harfbuzz
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Harfbuzz渲染不同语言
- en: Rendering text on Head Up Display
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在抬头显示（HUD）上渲染文本
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Font rendering is an essential part of computer application programs; it helps
    users to interact with the system and understand information in a readable form.
    OpenGL ES does not provide a built-in support for font rendering; instead, the
    font engine needs to be programed by a developer. There are many font-rendering
    techniques; this chapter will cover the most popular technique for font rendering,
    which is rendered using the **FreeType** project in conjunction with the **Harfbuzz**
    library. The former is used to rasterize symbolic characters or glyphs using font
    files; this library supports different types of font file formats, such as TTF,
    BDF, OTF, Windows FNT, and so on. The latter library is used for multilingual
    support. Using this library, almost all world-famous language scripts can be rendered.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 字体渲染是计算机应用程序的一个基本部分；它帮助用户以可读的形式与系统交互和理解信息。OpenGL ES不提供内置的字体渲染支持；相反，字体引擎需要由开发者编程。有许多字体渲染技术；本章将介绍最流行的字体渲染技术，即使用**FreeType**项目和**Harfbuzz**库进行渲染。前者用于使用字体文件对符号字符或字形进行光栅化；这个库支持不同类型的字体文件格式，如TTF、BDF、OTF、Windows
    FNT等。后者库用于多语言支持。使用这个库，几乎可以渲染所有世界著名的语言脚本。
- en: This chapter will provide you with a detailed description on how to build the
    font engine; we will implement simple text rendering with the help of FreeType.
    We will use the capabilities of the Harfbuzz library to print multilingual text
    rendering, such as Arabic, Thai, Tamil, Punjabi, and so on. Last but not least,
    you will learn the technique to render text in the screen coordinate system on
    the **Head Up Display** (**HUD**) or overlays.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将提供如何构建字体引擎的详细描述；我们将使用FreeType实现简单的文本渲染。我们将使用Harfbuzz库的能力来打印多语言文本渲染，如阿拉伯语、泰语、泰米尔语、旁遮普语等。最后但同样重要的是，你将学习在屏幕坐标系上渲染文本在**抬头显示（HUD**）或叠加层上的技术。
- en: Font rendering with the FreeType project
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用FreeType项目进行字体渲染
- en: In this recipe, we will render a simple Latin text in the 3D space. For this,
    we can create a texture bitmap for each character and render it in a quad geometry
    (rectangle) shape. However, creating each character bitmap could be expensive
    in terms of memory management and performance because it is required to load several
    bitmaps in the texture memory. Instead, the better solution is to create a big
    texture embedded with all characters in it and use their texture coordinates to
    map them on the geometry quad.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将渲染一个简单的拉丁文本在3D空间中。为此，我们可以为每个字符创建一个纹理位图并将其渲染为四边形几何形状（矩形）。然而，创建每个字符位图在内存管理和性能方面可能是昂贵的，因为它需要在纹理内存中加载多个位图。更好的解决方案是创建一个包含所有字符的大纹理，并使用它们的纹理坐标将它们映射到几何四边形上。
- en: 'An overview of the process to render fonts using the FreeType library is as
    follows:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用FreeType库渲染字体的过程概述如下：
- en: Initialize the FreeType library. This initializes the necessary FreeType data
    structure.
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始化FreeType库。这会初始化必要的FreeType数据结构。
- en: Load the font face. This loads the font file and generates the font style (font
    face) information.
  id: totrans-12
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 加载字体面。这会加载字体文件并生成字体样式（字体面）信息。
- en: Specify the font size. With the specified size of the font, create an empty
    texture big enough to contain all glyphs. In order to make the texture backward
    compatible with OpenGL ES 2.0, choose its texture size to be a power of two.
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 指定字体大小。使用指定的字体大小，创建一个足够大的空纹理以包含所有字形。为了使纹理与OpenGL ES 2.0向后兼容，选择其纹理大小为2的幂。
- en: Access the font face data contents. This uses the font face and metric information
    to create glyph images on an empty texture, which is called texture atlas. Glyphs
    will be drawn in the form of row and columns, as shown in the next image.
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 访问字体面数据内容。这使用字体面和度量信息在空纹理上创建字形图像，这被称为纹理图集。字形将以行和列的形式绘制，如图下一幅图像所示。
- en: Map the glyph. This stores the texture coordinates of each glyph image from
    the texture atlas in a data structure and maps it to its respective charcode.
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 映射字形。这将在数据结构中存储从纹理图集中每个字形图像的纹理坐标，并将其映射到相应的charcode。
- en: Render the text. The glyph map contains all character codes, picks the desired
    character, and maps the respective texture coordinate from the texture atlas to
    the quad geometry of each character. For example, the following image shows the
    printing of the Hello World from the texture atlas:![Font rendering with the FreeType
    project](img/5527OT_08_01.jpg)
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染文本。字形映射包含所有字符代码，选择所需的字符，并将从纹理着色图中映射到每个字符的四边形几何形状的相应纹理坐标。例如，以下图像显示了从纹理着色图中打印的
    Hello World：![使用 FreeType 项目的字体渲染](img/5527OT_08_01.jpg)
- en: '**Classes and data structure**:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**类和数据结构**:'
- en: 'The following is a brief description of all the classes and related data structures
    used in font rendering:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是对在字体渲染中使用的所有类和相关数据结构的简要描述：
- en: '`FontGenerator`: This class loads the font file with the help of the FreeType
    library. It stores important information from the font file in the related data
    structure. It uses the FreeType library data structure to build the bitmap texture;
    the bitmap information for each character/glyph is stored locally in a quick accessible
    map:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontGenerator`: 此类在 FreeType 库的帮助下加载字体文件。它将字体文件中的重要信息存储在相关的数据结构中。它使用 FreeType
    库的数据结构构建位图纹理；每个字符/字形的位图信息存储在本地快速访问的映射中：'
- en: '`library`: This is the handle of the FreeType library instance.'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`library`: 这是 FreeType 库实例的句柄。'
- en: '`fontface`: Each font may contain one or more font faces or typeface; it has
    a specific weight, style, condensation, width, slant, italicization, ornamentation,
    and designer or foundry.'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fontface`: 每个字体可能包含一个或多个字体面或字型；它具有特定的重量、样式、紧缩、宽度、倾斜、斜体化、装饰以及设计师或铸造厂。'
- en: '`glyphs`: This is the STL map of glyph and character code.'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glyphs`: 这是字形和字符代码的 STL 映射。'
- en: '`atlasTex`: This contains the handle of the atlas texture object.'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`atlasTex`: 这包含着色图纹理对象的句柄。'
- en: '`Glyph`: This data structure stores information related to a glyph present
    in the font file:'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Glyph`: 此数据结构存储与字体文件中存在的字形相关的信息：'
- en: '`Metric`: Glyph metric is used to position the glyph when rendered in the 2D/3D
    space.'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`度量`: 字形度量用于在 2D/3D 空间中定位渲染的字形。'
- en: '`texCoordX`, `texCoordY`, `atlasX`, and `atlasY`: These store texture coordinates
    of glyphs present in the texture atlas.'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`texCoordX`、`texCoordY`、`atlasX` 和 `atlasY`：这些存储纹理着色图中字形的纹理坐标。'
- en: '`advanceHorizontal` and `advanceVertical`: The advance information is helpful
    in placing next adjacent character with respect to current glyph.'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`advanceHorizontal` 和 `advanceVertical`: 进度信息有助于相对于当前字形放置下一个相邻字符。'
- en: '`Font`: This class is derived from `FontGenerator` and provides an interface
    to load the font file and a helper function to render text.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Font`: 此类继承自 `FontGenerator`，并提供加载字体文件和渲染文本的辅助函数的接口。'
- en: '`FontSample`: This class acts as a consumer of the font renderer; it renders
    sample text for demonstration purposes.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FontSample`: 此类充当字体渲染器的消费者；它用于演示目的渲染示例文本。'
- en: 'The following diagram shows the class diagram of the design; the `Font` class
    is derived from `FontGenerator` and `Model`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了设计类图；`Font` 类继承自 `FontGenerator` 和 `Model`：
- en: '![Font rendering with the FreeType project](img/5527OT_08_02.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![使用 FreeType 项目的字体渲染](img/5527OT_08_02.jpg)'
- en: Getting ready
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The FreeType project is an open source library used for font rasterization;
    it reads font files and is able to generate bitmaps from the vector/curve information
    stored in such files. This library is written in ANSI-C, which makes it portable
    across platforms.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: FreeType 项目是一个用于字体光栅化的开源库；它读取字体文件，并能够从存储在文件中的矢量/曲线信息生成位图。这个库是用 ANSI-C 编写的，这使得它在各个平台上都是可移植的。
- en: Note
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The library is freely available under the download section at [http://www.freetype.org](http://www.freetype.org).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 该库在下载部分免费提供，网址为 [http://www.freetype.org](http://www.freetype.org)。
- en: The **FreeType License** (**FTL**) is the most commonly used one. This is a
    BSD-style license with a credit clause and is compatible with the GNU Public License
    (GPL) version 3 and not with the GPL version 2\. In our GLPI framework, we will
    use the 2.5.4 version, which is placed under the `GLPIFramework/Font/FreeType`
    folder.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**FreeType 许可证**（**FTL**）是最常用的一个。这是一个带有信用条款的 BSD 风格许可，与 GNU 公共许可证（GPL）版本 3
    兼容，但不与 GPL 版本 2 兼容。在我们的 GLPI 框架中，我们将使用 2.5.4 版本，它位于 `GLPIFramework/Font/FreeType`
    文件夹下。'
- en: '**Build process**: The following points provide a detailed description of the
    build process for the FreeType library and other source files required to implement
    this recipe:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建过程**: 以下要点提供了 FreeType 库以及实现此配方所需的其他源文件的构建过程的详细描述：'
- en: '**Android platform**: We need the makefile to build the FreeType project library.
    Add the `Android.mk` makefile under `GLPIFramework/Font/FreeType`; edit this makefile,
    as shown in the following code. This will be compiled as a shared library, which
    is named as GLPift2\. Optionally, you can also add the source code directly in
    the main project makefile instead of compiling a shared library:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android平台**：我们需要makefile来构建FreeType项目库。在`GLPIFramework/Font/FreeType`下添加`Android.mk`
    makefile；编辑此makefile，如下所示。这将编译为共享库，命名为GLPift2\. 可选地，您也可以直接在主项目makefile中添加源代码，而不是编译共享库：'
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open the `Android.mk` makefile present in the project directory under the `JNI`
    folder (`<Source code path>/SimpleFont/Android/JNI`) and include the path of the
    FreeType library `Android.mk` file that we have created in the preceding code:'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开位于`JNI`文件夹（`<源代码路径>/SimpleFont/Android/JNI`）下的项目目录中的`Android.mk` makefile，并包含我们之前代码中创建的FreeType库`Android.mk`文件的路径：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our `GLPift2.so` shared library in order to link at runtime:'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`GLESNativeLib.java`中，编辑`GLESNativeLib`类，并添加我们的`GLPift2.so`共享库的引用以在运行时链接：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**iOS platform**: On the iOS platform, we need to add the same FreeType project
    source files (mentioned under the `LOCAL_SRC_FILES` makefile variable) to your
    project using the **Build Phase** | **Compile Sources** project properties; click
    on add to select source files.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS平台**：在iOS平台上，我们需要使用**构建阶段** | **编译源文件**项目属性将相同的FreeType项目源文件（在`LOCAL_SRC_FILES`
    makefile变量下提到）添加到您的项目中；点击添加以选择源文件。'
- en: 'Provide a path to include header files for the free type project using **Build
    Settings** | **Search Paths** | **Header Search Paths**. For the present case,
    it should be:'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**构建设置** | **搜索路径** | **头文件搜索路径**来为free type项目提供包含头文件的路径。对于当前情况，它应该是：
- en: '[PRE3]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the following preprocessor macro under **Apple LLVM <compiler version>**
    | **Preprocessing** | **Preprocessor Macros**:'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**Apple LLVM <编译器版本>** | **预处理器** | **预处理器宏**下添加以下预处理器宏：
- en: '[PRE4]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Add the `FontGenerator.h/cpp`, `Font.h/cpp` project source files and `FontSample.h/cpp`
    using **File** | **Add Files to <Project Name>**.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用**文件** | **将文件添加到<项目名称>**添加`FontGenerator.h/cpp`、`Font.h/cpp`项目源文件和`FontSample.h/cpp`。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Perform the following steps to understand the procedure of implementing this
    recipe:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以了解实现此菜谱的程序：
- en: 'Create the `FontGenerator` class and add the following code body to it; the
    important data structure is already covered in the previous section under classes
    and data structures:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`FontGenerator`类，并将以下代码体添加到其中；重要的数据结构已在上一节中在类和数据结构部分介绍：
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Make sure that the `<ft2build.h>` header file is included in the source.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保源中包含了`<ft2build.h>`头文件。
- en: 'Initialize the FreeType library in the constructor with the `FT_Init_FreeType`
    function; this constructor will be called from the Font class when its object
    is created from the `Renderer::createModels` function. This function creates a
    new instance of the FreeType library and sets the handle to the library:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`FT_Init_FreeType`函数在构造函数中初始化FreeType库；此构造函数将在从`Renderer::createModels`函数创建Font类的对象时被Font类调用。此函数创建FreeType库的新实例并设置库句柄：
- en: '[PRE6]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The `loadFont` function is responsible for loading the font file using FreeType''s
    `FT_New_Face` function. This function creates a new face with the available typeface
    and style information in the font file. For example, Arial Bold and Arial Italic
    correspond to two different faces. This function calls the `getCorrectResolution`
    function, which is described in the next step:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`loadFont`函数负责使用FreeType的`FT_New_Face`函数加载字体文件。此函数使用字体文件中可用的字体和样式信息创建一个新的面。例如，Arial
    Bold和Arial Italic对应于两个不同的面。此函数调用`getCorrectResolution`函数，该函数将在下一步进行描述：'
- en: '[PRE7]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before creating the texture atlas, it''s important to check whether the texture
    size is supported by a device using the `getCorrectResolution` function. The maximum
    texture size can be queried using the `GL_MAX_TEXTURE_SIZE` symbolic flag. If
    the texture exceeds the maximum supported limit, this function falls back to the
    next immediate smaller available power of two sizes:'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在创建纹理图集之前，使用`getCorrectResolution`函数检查设备是否支持纹理大小非常重要。可以使用`GL_MAX_TEXTURE_SIZE`符号标志查询最大纹理大小。如果纹理超过最大支持的限制，此函数将回退到下一个立即较小的可用2的幂大小：
- en: Note
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The texture altas we generated for this recipe is made of power 2.0 in order
    to make it compatible with OpenGL ES 2.0 version.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为此配方生成的纹理图集由2.0的幂组成，以便与OpenGL ES 2.0版本兼容。
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Read the font information from the FreeType library in the `readFont` function.
    This function sets the font size using `FT_Set_Pixel_Sizes` in pixels:'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`readFont`函数中从FreeType库读取字体信息。此函数使用`FT_Set_Pixel_Sizes`以像素为单位设置字体大小：
- en: '[PRE9]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `fontFace` contains information about the total number of characters in
    the font file. Using this information and the provided font size, the total size
    of the texture atlas is calculated in the power of two dimensions. A two channel
    texture memory is allocated and stored in the `textureData` variable for luminance
    and alpha:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fontFace`包含有关字体文件中字符总数的信息。使用此信息和提供的字体大小，计算纹理图集的总大小为2的幂次维度。分配一个双通道纹理内存并存储在`textureData`变量中，用于亮度和alpha：'
- en: '[PRE10]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Each glyph in the font face is recognized with a unique index; the face object
    contains one or more tables called character maps (charmaps), which are used to
    map glyph indices to character codes. For example, `A` has a character code of
    65 in ASCII encoding.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字体面中的每个字形都有一个唯一的索引；面对象包含一个或多个称为字符映射（charmaps）的表，用于将字形索引映射到字符码。例如，`A`在ASCII编码中的字符码为65。
- en: 'Loop through all the available glyph in the font and load the information for
    a current glyph image using `FT_Load_Glyph`. This function stores the glyph image
    in a special object called glyph slot. The `FT_Load_Glyph` accepts three parameters,
    handles the font face object, glyphs indexes, and loads flags:'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 遍历字体中所有可用的字形，并使用`FT_Load_Glyph`加载当前字形图像的信息。此函数将字形图像存储在称为字形槽的特殊对象中。`FT_Load_Glyph`接受三个参数，处理字体面对象、字形索引和加载标志：
- en: '[PRE11]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: A glyph slot is a container that stores only one type of image at a time. This
    can be bitmap, outline, and so on. The glyph slot object can be accessed using
    **fontFace** | **glyph**. The bitmap information is generated out of the glyph
    slot using the `FT_Render_Glyph` API; it accepts two arguments, the first argument
    is the glyph slot and the second argument is the render mode flag, which specifies
    how to render the glyph image.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 字形槽是一个容器，一次只存储一种图像。这可以是位图、轮廓等。可以使用**fontFace** | **glyph**访问字形槽对象。使用`FT_Render_Glyph`
    API从字形槽生成位图信息；它接受两个参数，第一个参数是字形槽，第二个参数是渲染模式标志，它指定如何渲染字形图像。
- en: 'The glyph information is loaded into the glyph data structure and stored as
    a value in the STL map glyphs with the character code as a key:'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 字形信息被加载到字形数据结构中，并以字符码作为键存储在STL映射`glyphs`中的值：
- en: '[PRE12]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Load the glyph bitmap in the texture atlas using the `generateTexFromGlyph`
    function. This function writes the raster information from the glyph slot to the
    texture data. After all the characters are rastered, load the texture atlas in
    the OpenGL ES texture object with the help of `glTexImage2D` and delete the local
    texture atlas:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`generateTexFromGlyph`函数在纹理图集中加载字形位图。此函数将来自字形槽的栅格信息写入纹理数据。所有字符都栅格化后，使用`glTexImage2D`的帮助将纹理图集加载到OpenGL
    ES纹理对象中，并删除本地纹理图集：
- en: '[PRE13]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `generateTexFromGlyph` function is responsible for loading the current
    specified glyph in to the glyph slot to load it into a particular position in
    the texture atlas specified by `atlasX`, `atlasY`, and `texSize`. The last parameter
    for this function is used to draw a border around the character, which can be
    very helpful in debugging the positioning of a character in texture rendering.
    For example, see the preceding **Hello World** sample text image; it contains
    a border around each character:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`generateTexFromGlyph`函数负责将当前指定的字形加载到字形槽中，并将其加载到由`atlasX`、`atlasY`和`texSize`指定的纹理图集中的特定位置。此函数的最后一个参数用于在字符周围绘制边框，这在调试纹理渲染中字符定位时非常有帮助。例如，参见前面的**Hello
    World**示例文本图像；它包含每个字符周围的边框：'
- en: '[PRE14]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create the `Font` class derived from `Model` and `FontGenerator`:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建从`Model`和`FontGenerator`派生的`Font`类：
- en: '[PRE15]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Create a vertex shader file called `fontVertex.glsl` and add the following
    code; this shader file receives the vertex and texture coordinate information
    from the OpenGL ES program. The received texture coordinates are further sent
    to the fragment shader for the purpose of texture sampling purpose:'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 创建一个名为`fontVertex.glsl`的顶点着色器文件，并添加以下代码；此着色器文件从OpenGL ES程序接收顶点和纹理坐标信息。接收到的纹理坐标随后被发送到片段着色器，用于纹理采样的目的：
- en: '[PRE16]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Create the `fontfrag.glsl` fragment shader; it contains a sampler2D variable
    for the texture input and a uniform `TexColor` for the text color:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `fontfrag.glsl` 片段着色器；它包含一个用于纹理输入的 `sampler2D` 变量和用于文本颜色的 `uniform TexColor`：
- en: '[PRE17]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Load and compile the shader in the `initModel` function and query the vertex
    shader attributes:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initModel` 函数中加载和编译着色器，并查询顶点着色器属性：
- en: '[PRE18]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The `drawGlyph` function is responsible for rendering the glyph. The glyph
    is rendered on a logical square by mapping texture coordinates stored in the glyph
    data structure. Initialize the texture sample with texture unit `0`:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`drawGlyph` 函数负责渲染字形。通过映射存储在字形数据结构中的纹理坐标，在逻辑正方形上渲染字形。使用纹理单元 `0` 初始化纹理采样：'
- en: '[PRE19]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The message string is printed with the help of the `printText` function. This
    function loops through the message string and calls the `drawGlyph` function to
    render each character in it. After rendering each character, the next glyph is
    advanced by the horizontal offset `advanceHorizontal` information stored in the
    glyph data structure for the corresponding character code:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 消息字符串是通过 `printText` 函数打印的。此函数遍历消息字符串并调用 `drawGlyph` 函数来渲染其中的每个字符。渲染每个字符后，下一个字形通过存储在对应字符代码的字形数据结构中的水平偏移
    `advanceHorizontal` 信息来前进：
- en: '[PRE20]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The present case of `drawGlyph()` can be optimized by bunching multiple draw
    calls into a single one. Multiple glyphs can be defined and drawn in one go if
    all glyph quads are computed and specified along with their texture coordinates
    in vertex attribute buffers. We will leave this optimization as an exercise to
    our readers.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当前 `drawGlyph()` 的情况可以通过将多个绘制调用组合成一个来优化。如果所有字形四元组都计算并指定了它们的纹理坐标，并且这些坐标存储在顶点属性缓冲区中，则可以一次性定义和绘制多个字形。我们将把这个优化留给读者作为练习。
- en: 'Create a `FontSample` class derived from `Model` and override the `Render()`
    method in order to render the sample text, as shown in the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个从 `Model` 派生的 `FontSample` 类，并覆盖 `Render()` 方法以渲染示例文本，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the `Renderer::createModel` function, load the font file with the desired
    font size and add the `FontSample` model. Make sure that the font file is added
    to the project:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Renderer::createModel` 函数中，加载所需字号的字体文件并添加 `FontSample` 模型。确保字体文件已添加到项目中：
- en: '[PRE22]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: How it works...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The initialization of FreeType is necessary in order to use it properly and
    without any unexpected surprises during use; this initialization is done in the
    constructor of the `Font` class using the `FT_Init_FreeType` API. This ensures
    that all the modules in the library are ready for use. On successful initialization,
    this API returns `0`; otherwise, it returns an error and sets the handle with
    a `NULL` value.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确使用 FreeType 并在使用过程中避免任何意外惊喜，初始化 FreeType 是必要的；这种初始化是在 `Font` 类的构造函数中通过使用
    `FT_Init_FreeType` API 来完成的。这确保了库中的所有模块都准备好使用。初始化成功时，此 API 返回 `0`；否则，它返回一个错误并将句柄设置为
    `NULL` 值。
- en: The constructor also calls the `loadFont` function; this function loads the
    font file using the `FT_New_Face` API and creates the face object. One font file
    may contain one or more than one font faces; the face contains the font style
    information. It describes a given typeface and style. For example, *Times New
    Roman Regular* and *Times New Roman Italic* correspond to two different faces.
    The `loadFont` function calls `getCorrectResolution` to make sure that the hardware
    device supports the requested texture size of the texture atlas allocation. The
    maximum texture size limit can be queried using `GL_MAX_TEXTURE_SIZE`; if the
    texture size is bigger than the supported limit, it falls back to the next smallest
    available size and returns the new updated resolution and margin size in the `calculatedResolution`
    and `calculatedSize`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数还调用了 `loadFont` 函数；此函数使用 `FT_New_Face` API 加载字体文件并创建面对象。一个字体文件可能包含一个或多个字体面；面包含字体样式信息。它描述了给定的字体类型和样式。例如，*Times
    New Roman Regular* 和 *Times New Roman Italic* 对应于两个不同的面。`loadFont` 函数调用 `getCorrectResolution`
    确保硬件设备支持请求的纹理大小纹理图集分配。最大纹理大小限制可以通过 `GL_MAX_TEXTURE_SIZE` 查询；如果纹理大小大于支持的限制，则回退到下一个可用的最小大小，并在
    `calculatedResolution` 和 `calculatedSize` 中返回新的更新分辨率和边距大小。
- en: 'The `readFont` function sets the font size information using the `FT_Set_Pixel_Size`
    API. This function takes three arguments, namely, font face, pixel width, and
    pixel height. The total number of glyphs in the font file, pixel resolution, and
    the margin size are used to calculate the size of texture atlas, which is allocated
    in the power of two and stored in the `textureData`. The allocated texture is
    stored as two channel information: one for the color information and another for
    the alpha component.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`readFont` 函数使用 `FT_Set_Pixel_Size` API 设置字体大小信息。此函数接受三个参数，即字体样式、像素宽度和像素高度。字体文件中字形的总数、像素分辨率和边距大小被用来计算纹理图集的大小，该图集以2的幂次方分配并存储在
    `textureData` 中。分配的纹理存储为两个通道信息：一个用于颜色信息，另一个用于alpha分量。'
- en: 'Each glyph present in the library is traversed and loaded using the `FT_Load_Glyph`
    API. This loads the current glyph in the glyph slot that can be retrieved with
    `fontFace` | `glyph` and passed to `FT_Render_Glyph` and rasters the bitmap bits.
    These bits are written in the `textureData` using the `generateTexFromGlyph` function.
    The glyph writing in the texture is done from the left to right direction. When
    the number of the glyph reaches the maximum number of glyphs per row, the write
    pointer is set to the next row. After all the glyphs are written in the `textureData`
    texture atlas, create an OpenGL ES texture object and set it with this information:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FT_Load_Glyph` API 遍历并加载库中存在的每个字形。这将在字形槽中加载当前字形，可以通过 `fontFace` | `glyph`
    获取，并传递给 `FT_Render_Glyph`，并将位图位写入。这些位使用 `generateTexFromGlyph` 函数写入 `textureData`。在纹理中的字形写入是从左到右方向进行的。当字形的数量达到每行的最大字形数时，写入指针被设置为下一行。在
    `textureData` 纹织图集纹理中写入所有字形后，创建一个OpenGL ES纹理对象，并使用以下信息设置它：
- en: '![How it works...](img/5527OT_08_03.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_08_03.jpg)'
- en: The `Font` class provides the interface to the external world for texture rendering
    purposes. This class first initializes the shaders in the `initModel` function,
    similar to other GLPI framework models. The `printText` function can be used to
    render the text information; this function accepts a text message string as the
    first argument and colors information in the RGBA format as next four parameters.
    The printing function should disable the culling and depth testing. The former
    testing is disabled because we want to view the font on the back faces as well;
    otherwise, it will surprise the user when texture goes suddenly missing. The latter
    case is helpful to keep the text rendered at the top always; we don't want this
    if it gets occluded by some other objects. The alpha blending must be turned on
    with the `glBlendFunc` (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) blending function.
    Traversing through each character prints the string; the corresponding glyph is
    obtained from the glyphs map for the current character code and passed on to the
    `drawGlyph` function. The `drawGlyph` function makes use of the glyph structure
    and generates the necessary information to draw the bitmap image in the 2D or
    3D space. Each glyph is rendered to a square and mapped with texture coordinates
    from the texture atlas; glyphs need to be placed according to font metrics or
    the glyph metric in the 2D/3D space.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`Font` 类提供了纹理渲染的外部接口。这个类首先在 `initModel` 函数中初始化着色器，类似于其他 GLPI 框架模型。可以使用 `printText`
    函数来渲染文本信息；此函数接受一个文本消息字符串作为第一个参数，以及RGBA格式的颜色信息作为接下来的四个参数。打印函数应禁用剔除和深度测试。前者测试被禁用，因为我们想查看字体在背面；否则，当纹理突然消失时，会令用户感到惊讶。后者情况有助于保持渲染在顶部的文本始终可见；我们不希望它被其他对象遮挡。必须使用
    `glBlendFunc` (`GL_SRC_ALPHA`, `GL_ONE_MINUS_SRC_ALPHA`) 混合函数打开alpha混合。遍历每个字符打印字符串；从当前字符代码的字符映射中获取相应的字形，并将其传递给
    `drawGlyph` 函数。`drawGlyph` 函数利用字形结构生成在2D或3D空间中绘制位图图像所需的信息。每个字形被渲染到一个正方形中，并使用纹理图集的纹理坐标进行映射；字形需要根据字体度量或2D/3D空间中的字形度量进行放置。'
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The glyph metric contains the distance information associated with a particular
    glyph to help it in positioning while creating a text layout.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 字形度量包含与特定字形相关的距离信息，有助于在创建文本布局时进行定位。
- en: '![How it works...](img/5527OT_08_04.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_08_04.jpg)'
- en: There's more...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `printText` function renders a simple text where the transformation can
    be applied to the string to achieve various effects. We have seen that each string
    is rendered as a single glyph at a time. Therefore, it''s possible to perform
    transforming animations on a single glyph. The following image is an example of
    the glyph animation, where glyphs are arranged in a circular fashion and rotates
    along the *y* axis:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`printText`函数渲染简单的文本，其中可以将转换应用于字符串以实现各种效果。我们已经看到每个字符串一次渲染为一个单独的符号。因此，可以对单个符号执行转换动画。以下图像是符号动画的示例，其中符号以圆形排列并沿*y*轴旋转：'
- en: '![There''s more...](img/5527OT_08_05.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_08_05.jpg)'
- en: 'In the current recipe, the `animateText` function can be used to render glyphs
    in an animated fashion. The function definition is explained later on; it accepts
    two more parameters: radius and rotation in addition to the `printText` parameter.
    This function renders glyphs that are arranged in a circular fashion and rotate
    along the *y* axis.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前配方中，可以使用`animateText`函数以动画方式渲染符号。函数定义将在稍后解释；它接受两个额外的参数：半径和旋转，以及`printText`参数。此函数渲染以圆形排列的符号，并沿*y*轴旋转。
- en: 'Based on the number of characters in the string and the given radius, a locus
    is calculated, and each character is placed in such a way that it always faces
    the camera. This way, the letter always faces the camera, irrespective of its
    position and angle along the *y* axis:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 根据字符串中的字符数量和给定的半径，计算一个轨迹，并将每个字符放置得使其始终面向相机。这样，字母始终面向相机，无论其在*y*轴上的位置和角度如何：
- en: '[PRE23]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: See also
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Rendering different languages with Harfbuzz*'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Harfbuzz渲染不同语言*'
- en: Refer to the *Applying texture with UV mapping* recipe in [Chapter 7](ch07.html
    "Chapter 7. Textures and Mapping Techniques"), *Textures and Mapping Techniques*
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第7章中关于*使用UV映射应用纹理*的配方，*纹理和映射技术*
- en: Rendering different languages with Harfbuzz
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Harfbuzz渲染不同语言
- en: The FreeType library performs the rasterization operation in which each character
    is associated with a glyph index; this glyph index maps to the bitmap image. This
    information is more or less sufficient for simple scripts like English, which
    does not change its shape with the context. For example, based on the context,
    Arabic language has four different types of shape forms, where a character may
    change its shape depending on the own location or surrounding characters. With
    Unicode, there was a need for different languages to allow them to create complex
    transformations of glyphs, such as substitution, positioning, bi-directional text,
    context-sensitive shaping, and ligatures. Therefore, we need some special library
    that understands the context of the language and does the job of shaping for us;
    this is where Harfbuzz comes into the picture.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: FreeType库执行光栅化操作，其中每个字符都与一个符号索引相关联；这个符号索引映射到位图图像。对于像英语这样的简单脚本，这些信息或多或少是足够的，因为英语的形状不会随着上下文而改变。例如，基于上下文，阿拉伯语有四种不同的形状形式，其中字符的形状可能取决于其自身位置或周围字符。随着Unicode的出现，不同语言需要能够创建符号的复杂转换，如替换、定位、双向文本、上下文敏感的形状和连字符。因此，我们需要一些特殊的库来理解语言的上下文，并为我们执行形状任务；这就是Harfbuzz发挥作用的地方。
- en: Harfbuzz is a text shaping engine that manages complex text; it performs the
    shaping job on the given Unicode text using the language script and layout direction
    specified by the user. This library does not provide text layout or rendering.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Harfbuzz是一个文本形状引擎，它管理复杂文本；它使用用户指定的语言脚本和布局方向在给定的Unicode文本上执行形状任务。这个库不提供文本布局或渲染。
- en: 'Here are some of the characteristics of complex text:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂文本的一些特性如下：
- en: '**Bi-directionality**: Text written/displayed from left to right and vice versa
    direction. Arabic and Hebrew scripts use the right to left direction. However,
    most other languages, including Latin, are written from left to right. The following
    image shows the mix of English numerals and Arabic text in the bidirectional order.![Rendering
    different languages with Harfbuzz](img/5527OT_08_06.jpg)'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**双向性**：从左到右和相反方向编写的/显示的文本。阿拉伯语和希伯来语脚本使用从右到左的方向。然而，包括拉丁语在内的大多数其他语言都是从左到右编写的。以下图像显示了双向顺序中英语数字和阿拉伯文本的混合。![使用Harfbuzz渲染不同语言](img/5527OT_08_06.jpg)'
- en: '**Shaping**: The character shape depends on the context. For example, the shape
    of the Arabic character changes when it connects to the adjacent characters. The
    following example shows contextual shaping in Arabic.![Rendering different languages
    with Harfbuzz](img/5527OT_08_07.jpg)'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**形状**：字符形状取决于上下文。例如，当阿拉伯字符与相邻字符连接时，其形状会发生变化。以下示例显示了阿拉伯语中的上下文形状。[使用Harfbuzz渲染不同语言](img/5527OT_08_07.jpg)'
- en: '**Ligatures**: A ligature is a special character that combines two or more
    characters into a single character. Here is an example of the Arabic ligature.![Rendering
    different languages with Harfbuzz](img/5527OT_08_08.jpg)'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连字符**：连字符是一种特殊字符，它将两个或多个字符组合成一个单一字符。以下是一个阿拉伯连字符的示例。![使用Harfbuzz渲染不同语言](img/5527OT_08_08.jpg)'
- en: '**Positioning**: Glyphs are adjusted with respect to a given character vertically
    or horizontally; the following image demonstrates the concept of positioning in
    Thai.![Rendering different languages with Harfbuzz](img/5527OT_08_09.jpg)'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**定位**：字符在垂直或水平方向上相对于给定字符进行调整；以下图像展示了泰语中定位的概念。[使用Harfbuzz渲染不同语言](img/5527OT_08_09.jpg)'
- en: '**Reordering**: The position of a character depends on the context. In the
    following example, the last character of the Hindi text (Devanagri script) is
    placed in front of the second last character in the final output.![Rendering different
    languages with Harfbuzz](img/5527OT_08_10.jpg)'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重新排序**：字符的位置取决于上下文。在以下示例中，印地语文本（达拉字母）的最后一个字符在最终输出中位于倒数第二个字符之前。[使用Harfbuzz渲染不同语言](img/5527OT_08_10.jpg)'
- en: '**Split characters**: In this case, the same character appears in more than
    one position.![Rendering different languages with Harfbuzz](img/5527OT_08_11.jpg)'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分割字符**：在这种情况下，相同的字符出现在多个位置。[使用Harfbuzz渲染不同语言](img/5527OT_08_11.jpg)'
- en: Note
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Image courtesy: [http://scripts.sil.org](http://scripts.sil.org)'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图片来源：[http://scripts.sil.org](http://scripts.sil.org)
- en: This recipe will demonstrate text rendering in different types of languages,
    such as Arabic, Thai, Punjabi, Tamil, and English altogether.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将展示不同类型语言的文本渲染，例如阿拉伯语、泰语、旁遮普语、泰米尔语和英语。
- en: '**Classes and data structure**:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**类和数据结构**：'
- en: This recipe will introduce a new class, which is responsible for shaping the
    text as per the specified language.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将介绍一个新的类，该类负责根据指定的语言对文本进行形状处理。
- en: '**FontShaping**: This class is derived from `FontGenerator`. It inherits all
    the vital information from the FreeType library that is necessary for rasterization.
    This class uses the `Harfbuzz-ng` library for text shaping:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**字体形状**：这个类是从`FontGenerator`派生出来的。它继承了从FreeType库中必要的所有重要信息，这些信息对于光栅化是必需的。这个类使用`Harfbuzz-ng`库进行文本形状处理：'
- en: '![Rendering different languages with Harfbuzz](img/5527OT_08_12.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![使用Harfbuzz渲染不同语言](img/5527OT_08_12.jpg)'
- en: Getting ready
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `Harfbuzz-ng` library is an open source library written in ANSI-C. This
    library is freely available under the MIT license.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '`Harfbuzz-ng`库是一个用ANSI-C编写的开源库。这个库在MIT许可下免费提供。'
- en: Note
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The library can be downloaded at [http://freedesktop.org/wiki/Software/HarfBuzz/](http://freedesktop.org/wiki/Software/HarfBuzz/).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 该库可以从[http://freedesktop.org/wiki/Software/HarfBuzz/](http://freedesktop.org/wiki/Software/HarfBuzz/)下载。
- en: '**Build process**: The following steps provide a detailed description of the
    installation process for the `Harfbuzz-ng` library and other source files required
    to implement this recipe:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**构建过程**：以下步骤提供了对`Harfbuzz-ng`库和其他实现此配方所需源文件安装过程的详细描述：'
- en: '**Android**: On the Android platform, we need the makefile to build the `Harfbuzz-ng`
    library. Add the `Android.mk` makefile under `GLPIFramework/Font/harfbuzz-ng`.
    Edit this makefile, as given in the following code. This will be compiled as a
    shared library and named as `GLPiharfbuzz`:'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Android**：在Android平台上，我们需要makefile来构建`Harfbuzz-ng`库。在`GLPIFramework/Font/harfbuzz-ng`下添加`Android.mk`
    makefile。根据以下代码编辑此makefile。这将作为一个共享库编译，并命名为`GLPiharfbuzz`：'
- en: '[PRE24]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In `GLESNativeLib.java`, edit the `GLESNativeLib` class and add the reference
    of our `GLPiharfbuzz.so` shared library in order to link at runtime:'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在`GLESNativeLib.java`中，编辑`GLESNativeLib`类并添加我们的`GLPiharfbuzz.so`共享库的引用，以便在运行时链接：
- en: '[PRE25]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Open the `Android.mk` makefile in the present project directory under the (`<Source
    code path>/Localization/Android/JNI`) JNI folder and include the path of the `Android.mk`
    makefile that we have created in the `harfbuzz` library. Additionally, add the
    following source files in order to build this recipe:'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在当前项目目录下 (`<源代码路径>/Localization/Android/JNI`) JNI 文件夹中打开 `Android.mk` makefile，并包含我们在
    `harfbuzz` 库中创建的 `Android.mk` makefile 的路径。此外，添加以下源文件以构建此配方：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '**iOS**: On the iOS platform, we need to add the same FreeType project source
    files (mentioned under the `LOCAL_SRC_FILES` makefile variable) to your projects
    using the **Build Phase** | **Compile Sources** project properties. Click on add
    to select source files.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**iOS**: 在 iOS 平台上，我们需要将相同的 FreeType 项目源文件（在 `LOCAL_SRC_FILES` makefile 变量下提到）添加到您的项目中，使用
    **构建阶段** | **编译源文件** 项目属性。点击添加以选择源文件。'
- en: 'Provide a path to include the header files for the Harfbuzz project using **Build
    Settings** | **Search Paths** | **Header Search Paths**. For the present case,
    it should be:'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 **构建设置** | **搜索路径** | **头文件搜索路径** 提供一个路径以包含 Harfbuzz 项目的头文件。对于当前情况，应该是：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In addition, add `FontGenerator.h/cpp`, `FontShaping.h/cpp`, `Font.h/cpp`, and
    `FontSample.h/cpp` using **File** | **Add Files to <Project Name>**.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此外，使用 **文件** | **将文件添加到 <项目名称>** 添加 `FontGenerator.h/cpp`、`FontShaping.h/cpp`、`Font.h/cpp`
    和 `FontSample.h/cpp`。
- en: How to do it...
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Reuse the first implemented recipe, *Font rendering with FreeType project*,
    and proceed to the following procedure to program this recipe:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 重新使用第一个实现的配方，即 *使用 FreeType 项目的字体渲染*，然后按照以下步骤编程此配方：
- en: 'Create the `FontShaping` class derived from `FontGenerator` and add the following
    code. This class contains two major functions: `setDirectionAndScript` and `produceShape`:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `FontGenerator` 派生出 `FontShaping` 类，并添加以下代码。这个类包含两个主要功能：`setDirectionAndScript`
    和 `produceShape`：
- en: '[PRE28]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `produceShape` function is responsible for text shaping using the `Harfbuzz-ng`
    library. It accepts a string that needs to be shaped as an input parameter and
    returns the code points after processing the shape. These code points are nothing
    but glyph indexes:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`produceShape` 函数负责使用 `Harfbuzz-ng` 库进行文本形状。它接受一个需要形状的字符串作为输入参数，并返回处理形状后的代码点。这些代码点不过是字形索引：'
- en: '[PRE29]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The Harfbuzz requires scripting and layout direction hints in order to perform
    the text shaping. Therefore, the end user must provide the script type and the
    direction of the text layout:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Harfbuzz 需要脚本和布局方向提示才能执行文本形状。因此，最终用户必须提供脚本类型和文本布局的方向：
- en: '[PRE30]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `FontGenerator::readFont` function, replace the following code. This
    will be useful to map the Harfbuzz-generated code points after text shaping:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FontGenerator::readFont` 函数中，替换以下代码。这将有助于在文本形状后映射 Harfbuzz 生成的代码点：
- en: '[PRE31]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Replace the preceding code with this code:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用此代码替换前面的代码：
- en: '[PRE32]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With respect to the preceding code changes done in the `FontGenerator::readFont`
    function, replace the following code in the `Font::printText` function:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关于在 `FontGenerator::readFont` 函数中进行的先前代码更改，替换 `Font::printText` 函数中的以下代码：
- en: '[PRE33]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Replace the preceding code with this code:'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 用此代码替换前面的代码：
- en: '[PRE34]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'In the `Renderer::createModels` function, add the necessary font files as per
    the supported languages:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Renderer::createModels` 函数中，根据支持的语言添加必要的字体文件：
- en: '[PRE35]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '![How to do it...](img/5527OT_08_13.jpg)'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何做...](img/5527OT_08_13.jpg)'
- en: How it works...
  id: totrans-164
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The working logic to render fonts in the current recipe is the same as the previous
    recipe. Therefore, it's strongly advisable to understand the first recipe before
    reading this section, which will only cover the text shaping working concept.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前配方中渲染字体的工作逻辑与上一个配方相同。因此，强烈建议在阅读本节之前先了解第一个配方，本节将仅涵盖文本形状的工作概念。
- en: This recipe has introduced a new class called `FontShaping`, which is derived
    from `FontGenerator`. From now on, the `Font` class will be inheriting from `FontShaping,`
    instead of `FontGenerator`. The `FontShaping` class is the core engine for text
    shaping. Internally, this class makes use of the `Harfbuzz-ng` library.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方介绍了一个名为 `FontShaping` 的新类，它是由 `FontGenerator` 派生出来的。从现在起，`Font` 类将继承自 `FontShaping`，而不是
    `FontGenerator`。`FontShaping` 类是文本形状的核心引擎。内部，这个类使用了 `Harfbuzz-ng` 库。
- en: We send UTF-8 encoding as an input parameter for multilingual text rendering
    in the `Font::printText` function. This function calls the `FontShaping::produceShaping`,
    which accepts one more argument in addition to the UTF-8 text, which is a vector
    list of code points that are returned from this function to the caller function.
    Code points are basically indexes of glyphs in the font file. In the multilingual
    text rendering, we have used the index of glyphs instead of character code in
    the glyphs map.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`Font::printText`函数中发送UTF-8编码作为多语言文本渲染的输入参数。这个函数调用`FontShaping::produceShaping`，它除了接受UTF-8文本外，还接受一个额外的参数，即从该函数返回给调用函数的代码点向量列表。代码点基本上是字体文件中符号的索引。在多语言文本渲染中，我们使用了符号的索引而不是符号映射中的字符代码。
- en: The `Harfbuzz-ng` library uses its own temporary buffer (of the `hb_buffer_t`
    type) to calculate the shaping information; this temporary buffer is allocated
    using the `hb_buffer_create` API. The created buffer is used to set the text layout
    direction (`hb_buffer_set_direction`) and language script (`hb_buffer_set_script`)
    in the `setDirectionAndScript` function.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`Harfbuzz-ng`库使用它自己的临时缓冲区（`hb_buffer_t`类型）来计算形状信息；这个临时缓冲区是通过`hb_buffer_create`
    API分配的。创建的缓冲区用于在`setDirectionAndScript`函数中设置文本布局方向（`hb_buffer_set_direction`）和语言脚本（`hb_buffer_set_script`）。'
- en: Use the `hb_buffer_add_utf8` API and provide the UTF8 encoded text to the `Harfbuzz`
    library. In addition, the font face information is required from FreeType in order
    to create its own font (`hb_font_t`). This font is created using the `hb_ft_font_create`
    API. The `hb_shape` API does the shaping job for the input string. It accepts
    the `hb_font_t` and `hb_buffer_t` object as an argument.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`hb_buffer_add_utf8` API并提供UTF8编码的文本到`Harfbuzz`库。此外，还需要从FreeType获取字体面信息以创建自己的字体（`hb_font_t`）。这个字体是通过`hb_ft_font_create`
    API创建的。`hb_shape` API为输入字符串执行形状任务。它接受`hb_font_t`和`hb_buffer_t`对象作为参数。
- en: After the shaping process is completed in the library, the number of glyphs
    may change. The `hb_buffer_get_length` API provides the new glyph count. The shaping
    information can be retrieved with the `hb_buffer_get_glyph_infos` API, which returns
    the `hb_glyph_info_t` object that contains all the glyph code points. These code
    points are collected in a vector list and sent back to the `printText` function.
    Make sure that the temporary buffer must be released from the memory at the end
    of the process.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在库中完成形状过程后，符号的数量可能会改变。`hb_buffer_get_length` API提供了新的符号计数。可以通过`hb_buffer_get_glyph_infos`
    API检索形状信息，该API返回包含所有符号代码点的`hb_glyph_info_t`对象。这些代码点收集在一个向量列表中，并返回到`printText`函数。确保在过程结束时释放临时缓冲区。
- en: In the `Font::printText`, the `codePoint` or glyph indexes are retrieved from
    the vector list and render the same way (we have described in the first recipe).
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Font::printText`中，从向量列表中检索`codePoint`或符号索引，并以相同的方式渲染（我们在第一个菜谱中描述过）。
- en: See also
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Font rendering with the FreeType project*'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用FreeType项目进行字体渲染*'
- en: Rendering text on Head Up Display
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在抬头显示（HUD）上渲染文本
- en: Text rendering on the screen coordinate system is a very common use case of
    printing text. The HUD, also known as overlays, allows you to render the text
    on top of a normal scene. The depth of the scene object does not change the size
    of the text. Examples of HUD are menu items, status bar, game scoreboards, and
    so on.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在屏幕坐标系上渲染文本是打印文本的一个非常常见的用例。HUD，也称为叠加层，允许你在正常场景之上渲染文本。场景对象的深度不会改变文本的大小。HUD的例子包括菜单项、状态栏、游戏计分板等。
- en: 'Technically, HUD is an orthographic view where the dimensions of left, right,
    top, and bottom are set equal to the viewport of the scene. In this recipe, we
    will print the vertex position of a rotating 3D cube in the screen coordinates.
    All vertices in the cube (near or far) have text in equal size. It is not affected
    by the distance of vertices from the camera position:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 技术上，HUD是一个正交视图，其中左、右、上、下四个方向的尺寸设置为场景视口的尺寸。在这个菜谱中，我们将打印旋转3D立方体的顶点位置到屏幕坐标。立方体中的所有顶点（近或远）都有相同大小的文本。它不受顶点与相机位置距离的影响：
- en: '![Rendering text on Head Up Display](img/5527OT_08_14.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![在抬头显示（HUD）上渲染文本](img/5527OT_08_14.jpg)'
- en: In the current recipe, we will reuse the *Drawing APIs in OpenGL ES 3.0* recipe
    from [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES
    3.0 Essentials*. This will render a rotating cube in the 3D space. We will use
    the HUD mechanism to display the positions of each vertex in the screen coordinates.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在当前配方中，我们将重用[第2章](ch02.html "第2章。OpenGL ES 3.0 基础")中的*OpenGL ES 3.0 绘图API*配方，*OpenGL
    ES 3.0 基础*。这将渲染一个在3D空间中旋转的立方体。我们将使用HUD机制来显示屏幕坐标中每个顶点的位置。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Reuse the last recipe, *Rendering different languages with Harfbuzz*, and add
    the following files from another recipe *Drawing APIs in OpenGL ES 3.0* in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重用上一个配方，*使用Harfbuzz渲染不同语言*，并添加来自另一个配方*OpenGL ES 3.0 绘图API*的以下文件，[第2章](ch02.html
    "第2章。OpenGL ES 3.0 基础")，*OpenGL ES 3.0 基础*：
- en: Open the `Cube.h` and `Cube.cpp` GL ES program files
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Cube.h`和`Cube.cpp` GL ES程序文件
- en: Open the `CubeVertex.glsl` and `CubeFragment.glsl` GLSL shader files
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`CubeVertex.glsl`和`CubeFragment.glsl` GLSL着色器文件
- en: How to do it...
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'The following instructions will provide a step-by-step procedure to implement
    HUD:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 以下指令将提供一个逐步过程来实现HUD：
- en: 'Edit the `Cube.h`/`cpp` and define a new method called `GetScreenCoordinates`.
    This will produce the screen coordinates from the logical coordinates of the cube
    vertices and collect them in a `screenCoordinateVector` vector list. There is
    no change required for imported shaders:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`Cube.h`/`cpp`并定义一个名为`GetScreenCoordinates`的新方法。这将从立方体顶点的逻辑坐标生成屏幕坐标并将它们收集在`screenCoordinateVector`向量列表中。对于导入的着色器不需要进行任何更改：
- en: '[PRE36]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Call the `GetScreenCoordinates` in the `Cube::Render` function after rendering
    the primitives. For this recipe, we change the rendering primitive from `GL_TRIANGLES
    to GL_LINE_LOOP`:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在渲染原语之后，在`Cube::Render`函数中调用`GetScreenCoordinates`。对于这个配方，我们将渲染原语从`GL_TRIANGLES`更改为`GL_LINE_LOOP`：
- en: '[PRE37]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In `FontSample.h`/`cpp`, create a function called `HeadUpDisplay`; this function
    will be responsible for setting the correct projection system and its dimensions
    for the head up display. The projection system for HUD must be orthographic and
    the dimension must be set to the viewport dimension:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FontSample.h`/`cpp`中创建一个名为`HeadUpDisplay`的函数；这个函数将负责设置正确的投影系统和其尺寸以用于抬头显示。HUD的投影系统必须是正交的，尺寸必须设置为视口尺寸：
- en: '[PRE38]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In `FontSample::Render()`, call the `HeadUpDisplay` function before rendering
    any drawing primitive. This will enable the HUD viewing. Get the vector list from
    the `Cube` class and render the vertex position with the `Font::printText` function:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`FontSample::Render()`中，在渲染任何绘图原语之前调用`HeadUpDisplay`函数。这将启用HUD查看。从`Cube`类获取向量列表，并使用`Font::printText`函数渲染顶点位置：
- en: '[PRE39]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The projection system for head up display must always be in the orthographic
    view. The `FontSample::HeadUpDisplay` function sets the projection matrix to an
    orthographic view with the help of the `Transform::TransformOrtho` API. It accepts
    eight parameters, in which the left-right and top-bottom must be specified with
    the correct dimension matched to the viewport size. Set the `Model` and `View`
    as the identity matrix:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: HUD的投影系统必须始终处于正交视图中。`FontSample::HeadUpDisplay`函数使用`Transform::TransformOrtho`
    API将投影矩阵设置为正交视图。它接受八个参数，其中左右和上下必须指定与视口尺寸匹配的正确尺寸。将`Model`和`View`设置为单位矩阵：
- en: '[PRE40]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The `HeadUpDisplay` function must be called before rendering primitives. For
    this recipe, we have collected screen coordinates of each vertex from the Cube
    class and displayed them using the `Font::printText` function with their respective
    screen coordinates position. The screen space coordinates of a vertex can be calculated
    in the logical coordinate system using the `Transform::TransformProject` function:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在渲染原语之前必须调用`HeadUpDisplay`函数。对于这个配方，我们从`Cube`类收集了每个顶点的屏幕坐标，并使用`Font::printText`函数以及它们各自的屏幕坐标位置来显示它们。顶点的屏幕空间坐标可以使用`Transform::TransformProject`函数在逻辑坐标系中计算：
- en: '![How it works...](img/5527OT_08_15.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_08_15.jpg)'
- en: See also
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: '*Rendering* *different languages with Harfbuzz*'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Harfbuzz渲染* *不同语言*'
- en: Refer to the *Understanding projection system in GLPI* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第2章[理解GLPI中的投影系统](ch02.html "第2章。OpenGL ES 3.0 基础")中的配方
- en: Refer to the *Drawing APIs in OpenGL ES 3.0* recipe in [Chapter 2](ch02.html
    "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章. OpenGL ES 3.0 基础")中的*OpenGL ES 3.0 绘图 API*配方，*OpenGL
    ES 3.0 基础*
