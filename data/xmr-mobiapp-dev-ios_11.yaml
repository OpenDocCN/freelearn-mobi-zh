- en: Chapter 11. Handling Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。处理数据
- en: From time to time it is important for an application to store or manipulate
    data. With the advent of LINQ, manipulation is extremely simple now. The problem,
    though, is that you need to store the data somehow. Thankfully this too is simple
    using SQLite.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 不时地，对于应用程序来说，存储或操作数据是很重要的。随着LINQ的出现，操作现在变得极其简单。然而，问题是您需要以某种方式存储数据。幸运的是，使用SQLite这也同样简单。
- en: 'We will be covering the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中介绍以下主题：
- en: Using SQLite
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用SQLite
- en: Setting up an SQLite helper class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置SQLite辅助类
- en: Using LINQ
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LINQ
- en: Dangers of using LINQ on iOS
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在iOS上使用LINQ的危险
- en: Using SQLite
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SQLite
- en: SQLite is a very simple database system that is also extremely powerful. It
    is outside the scope of this book to give you a master class on using SQLite,
    but understanding how to set up and use the system will help.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite是一个非常简单但功能强大的数据库系统。本书的范围不包括为您提供使用SQLite的高级课程，但了解如何设置和使用该系统将有所帮助。
- en: Installing and setting up SQLite
  id: totrans-9
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装和设置SQLite
- en: Installing can be performed in one of two ways; either you can install from
    the Xamarin component market (it is useful as it supplies you with examples and
    also the Android version) or you can download and install the software manually.
    As there are no additional libraries (SQLite comes as a single C# file) either
    way is good.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 安装可以通过两种方式之一进行；要么你可以从Xamarin组件市场安装（它很有用，因为它为你提供了示例，还包括Android版本）或者你可以手动下载并安装软件。由于没有额外的库（SQLite作为一个单独的C#文件提供），两种方式都很好。
- en: 'Once you have either copied the C# file or installed the component, the `SQLite.net`
    implementation is ready for use. It is as simple as inserting the following `using`
    directive at the top of the source file, and it''s done:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您已经复制了C#文件或安装了组件，`SQLite.net`实现就准备好使用了。只需在源文件顶部插入以下`using`指令即可，操作完成：
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Database basics
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库基础
- en: An easy way to consider a database is like an old card index system (commonly
    known as a **cardex** system). Information (data) can be added, updated, read,
    or deleted—and SQLite gives you that facility within the mobile environment. The
    data is stored in a file with tables (the table can be considered as the box that
    holds the cards) holding the information you want.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑数据库的一个简单方法是将它比作一个古老的卡片索引系统（通常称为**卡片索引系统**）。信息（数据）可以添加、更新、读取或删除——SQLite在移动环境中提供了这些功能。数据存储在一个包含表格的文件中，这些表格（表格可以被认为是存放卡片的盒子）包含了您想要的信息。
- en: 'Before the cardex system can be used though, the method of storage has to be
    defined. The simplest method of doing it is to create a class containing the primitive
    types. SQLite can only store certain types of data: `integer`, `real`, `text`,
    `none`, and `numeric`. No other types are permitted—this includes arrays and collections
    (such as `List<T>`) The types normally used in programming (such as `string` and
    `double`) are **mapped** to these internal types.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用卡片索引系统之前，必须定义存储方法。最简单的方法是创建一个包含原始类型的类。SQLite只能存储某些类型的数据：`integer`、`real`、`text`、`none`和`numeric`。不允许其他类型——这包括数组集合（如`List<T>`）。编程中通常使用的类型（如`string`和`double`）被**映射**到这些内部类型。
- en: A table also requires a primary key. This is the main index key which is typically
    auto-incremented. In a data class, this would be defined using `[PrimaryKey, AutoIncrement]`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个表也需要一个主键。这是通常自动递增的主要索引键。在数据类中，这将使用`[PrimaryKey, AutoIncrement]`定义。
- en: A simple database class
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一个简单的数据库类
- en: 'As a demonstration, a simple database class can be used:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 作为演示，可以使用一个简单的数据库类：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `demoTable` variable can then be brought into the database.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将`demoTable`变量引入数据库。
- en: Create a connection to the database
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建到数据库的连接
- en: Before the database can be used, a connection to the server needs to be set
    up. As with any class, the database class needs to be set up. I've called mine
    `DataManager`. SQLite needs a path to the database file.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据库可以使用之前，需要设置与服务器的连接。就像任何类一样，数据库类也需要设置。我将其命名为`DataManager`。SQLite需要一个指向数据库文件的路径。
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding code sets up an instance of the `DataManager`. To enable the
    database to be used across the app, the following should be added to the `AppDelegate`
    class:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码设置了一个`DataManager`实例。为了使数据库能够在整个应用程序中使用，以下内容应添加到`AppDelegate`类中：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Within the `DataManager` class, a lock is required (in order to prevent more
    than one operation occurring on the database at any time), as is a local copy
    of the database path.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `DataManager` 类中，需要一个锁（以防止任何时刻对数据库进行多个操作），以及数据库路径的本地副本。
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Finally, the table needs to be set up in the database.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，需要在数据库中设置表。
- en: '[PRE5]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You''ll notice that you will need to define a class with the following constants
    in it:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到，你需要定义一个包含以下常量的类：
- en: '[PRE6]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `DBClauseVacuum` constant is used on the final Execute query. The `DBClauseSyncOff`
    constant is used on the first.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBClauseVacuum` 常量用于最后的执行查询。`DBClauseSyncOff` 常量用于第一个。'
- en: At this point, you may have noticed something about using SQLite. It is being
    used as if it is a normal method within a class. This is fine as it is.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能已经注意到了使用 SQLite 的某些方面。它被用作类中的正常方法。这样是可以的。
- en: Setting up an SQLite helper class
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 SQLite 辅助类
- en: Typically using SQLite would require you to make and store the connection globally
    (to save device resources and reduce the possibility of a security problem) and
    then for every call to the database set up a set of queries and issues. Even for
    a trivial database, this can lead to many lines of repeated code and more the
    lines of code you have, the greater is the potential for bugs to crop up.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常使用 SQLite 需要你全局创建并存储连接（以节省设备资源并减少安全问题的可能性），然后在每次调用数据库时设置一组查询和问题。即使是简单的数据库，这也可能导致大量重复的代码，代码行数越多，出现错误的可能性就越大。
- en: A helper class encapsulates all of the functionalities you will need and is
    very easy to write.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助类封装了你需要的所有功能，并且很容易编写。
- en: Writing helper class methods
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写辅助类方法
- en: 'As I mentioned at the outset, databases allow you to read/write from/to a table.
    To start with, it makes sense to be able to read data. The following are two classes:
    the first returns `List<demoRow>` and the other returns a name for the given ID.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我一开始提到的，数据库允许你从/向表中读写数据。首先，能够读取数据是有意义的。以下有两个类：第一个返回 `List<demoRow>`，另一个返回给定
    ID 的名称。
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is very little difference between the two methods except for the database
    call. The List version requires a query—this is used when a non-primitive type
    is used and the data is expected back out. The `ExecuteScalar` method expects
    rows that are of primitive type to be returned.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方法之间几乎没有区别，除了数据库调用。列表版本需要一个查询——这用于非原始类型的数据，并期望返回数据。`ExecuteScalar` 方法期望返回原始类型的数据行。
- en: Accessing these helper methods would be the same as accessing any other method.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 访问这些辅助方法与访问任何其他方法相同。
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: or
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 或者
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Adding data to the database
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向数据库添加数据
- en: Data addition comes in the form of inserting or updating, and unlike a read,
    data addition needs to be trapped in case the insert or update fails and the database
    needs to be rolled back to before the attempt to add data.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 数据添加以插入或更新形式出现，与读取不同，数据添加需要捕获失败的情况，并且数据库需要回滚到添加数据尝试之前的状态。
- en: Thankfully, an insert or update can be handled in one method.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，插入或更新可以在一个方法中处理。
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Again, for the preceding code to work, a single instance of `demoRow` class
    needs to be passed into the method. Using a `List` of `demoRow` is simple to handle.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，为了使前面的代码能够正常工作，需要将 `demoRow` 类的单个实例传递到方法中。使用 `demoRow` 的 `List` 很容易处理。
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Data manipulation using LINQ
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 LINQ 进行数据操作
- en: Accessing a database continually puts a strain onto the system it is sitting
    on and if you consider the number of databases being used at any one time, it
    quickly becomes clear that the overhead of continually hitting the SQL service
    will be high.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 持续访问数据库会对它所在的系统造成压力，如果你考虑任何时刻正在使用的数据库数量，很快就会清楚，不断击打 SQL 服务的开销会很高。
- en: LINQ allows database style queries to be applied to data and the results come
    out. While there are many excellent books out there (quite a few of them are free),
    I will cover a couple of convenient methods of using LINQ within an iOS application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 允许将数据库样式查询应用于数据，并输出结果。虽然有许多优秀的书籍（其中许多是免费的），但我将介绍一些在 iOS 应用程序中使用 LINQ 的便捷方法。
- en: 'While LINQ is extremely powerful, not everything with LINQ will work without
    a problem when coding on iOS. The main reason is how the iPhone works. Quite simply,
    iOS wants to know what is going to happen **Ahead Of Time** (**AOT**). It doesn''t
    like surprises and really doesn''t like data structures it wasn''t aware of. For
    example:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然LINQ非常强大，但在iOS上编码时，并不是所有使用LINQ的操作都不会出现问题。主要原因在于iPhone的工作方式。简单来说，iOS想要知道将要发生什么**提前时间**（**AOT**）。它不喜欢惊喜，并且真的不喜欢它不知道的数据结构。例如：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding code should not cause an issue. But think of it another way—how
    big is `List` is going to be? When you're working ahead of time, space allocations
    are typically finite. (For example, an array of `int` values may have 20 values
    worth of memory reserved and nothing more, the AOT system likes this—it knows
    ahead of time that there will need to be 20 lots of `int` reserved.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码不应该引起任何问题。但换一个角度思考——`List`的大小将会有多大？当你提前工作时，空间分配通常是有限的。（例如，一个`int`值的数组可能有20个值的内存预留，没有更多，AOT系统喜欢这样——它提前知道需要预留20个`int`。）
- en: With this in mind, when using LINQ within an application, you may encounter
    random crashes—it is unlikely, but it may happen and it's worth mentioning it.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这一点，当在应用程序中使用LINQ时，你可能会遇到随机崩溃——这不太可能，但它可能发生，并且值得提及。
- en: LINQ – a whistle-stop tour
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: LINQ – 快速浏览
- en: For my examples, I'll use the `demoRow` table already used in this chapter.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我的示例，我将使用本章中已经使用的`demoRow`表。
- en: '[PRE13]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Somewhere in the returned `List` there is the name `Fred Moriarty` and I want
    to get from `List` the instance of the class with that name in it. I know there
    is only one instance of this name in the list.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在返回的`List`中某个地方有一个名为`Fred Moriarty`的名字，我想从`List`中获取具有该名字的类的实例。我知道列表中只有一个这样的实例。
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding code takes the table and returns the single instance. If the name
    is not found, `null` (or the default value) is returned.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码获取表并返回单个实例。如果找不到该名字，则返回`null`（或默认值）。
- en: Say my list contains a number of `Fred Bloggs` instances in the `Name` field.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我的列表在`Name`字段中有多个`Fred Bloggs`实例。
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Before LINQ came along, this would have been quite a slow affair and would
    have required a code such as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在LINQ出现之前，这将会是一项相当缓慢的工作，并且可能需要如下代码：
- en: '[PRE16]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The previous examples are very simple. LINQ can perform very complex operations
    as well, such as:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例非常简单。LINQ也可以执行非常复杂的操作，例如：
- en: '[PRE17]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here we have two lists (`ContactList` and `invites`). The LINQ query creates
    two loops and selects the instance tester when `UserID` from the outer loop matches
    `UserId` from the inner loop. The result is pretty much instant.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两个列表（`ContactList`和`invites`）。LINQ查询创建了两个循环，并在外层循环的`UserID`与内层循环的`UserId`匹配时选择实例测试器。结果是几乎瞬间的。
- en: SELECT and WHERE in LINQ – a common cause of confusion
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LINQ 中的 SELECT 和 WHERE – 常见的混淆原因
- en: A very common error that at some point everyone meets with LINQ is mixing the
    `WHERE` syntax up with the `SELECT` syntax.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人在某个时候都会遇到的一个非常常见的LINQ错误是将`WHERE`语法与`SELECT`语法混淆。
- en: The `WHERE` syntax is a condition (for example, `WHERE ID==311` or `WHERE A==B`).
    It only returns the condition set. In the following example, `testClass` is a
    list, it contains a class of which there is a string called `Value`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`WHERE`语法是一个条件（例如，`WHERE ID==311`或`WHERE A==B`）。它只返回设置的条件。在以下示例中，`testClass`是一个列表，它包含一个有字符串`Value`的类。'
- en: '[PRE18]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `retString` variable will contain a `List<string>` of all results from `testString`
    where `Value == "fred"`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`retString`变量将包含所有来自`testString`的结果的`List<string>`，其中`Value == "fred"`。'
- en: The `SELECT` syntax returns something for all items in the object passed in
    it. The result might be the items themselves but can be something else.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`SELECT`语法返回传入对象中所有项的内容。结果可能是项本身，也可能是其他内容。'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code transforms the contents of `inString` to be in upper case
    and is output to a list.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将`inString`的内容转换为大写，并输出到一个列表中。
- en: '[PRE20]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Here `Func<inString, outString>` transforms the elements of `inString` to `outString`
    and outputs the element as an `outString` list.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里`Func<inString, outString>`将`inString`的元素转换为`outString`，并将元素作为`outString`列表输出。
- en: Using Select in LINQ
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在LINQ中使用Select
- en: 'Take the following example and remember `Select` performs a transform:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看以下示例，并记住`Select`执行的是转换操作：
- en: '[PRE21]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This will be the output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是输出：
- en: '[PRE22]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '*But what is happening?* The `Select` statement is performed on the string
    array `teams`. It then specifies a lambda expression (`t=>`) which in turn transforms
    the expression to be upper case (`ToUpper()`).'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是发生了什么？* `Select` 语句在字符串数组 `teams` 上执行。然后它指定了一个 lambda 表达式 (`t=>`)，它将表达式转换为大写
    (`ToUpper()`).'
- en: The `Select` statement (as has been seen in the previous code) has an overloaded
    method as well. Again, it is a transforming method.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Select` 语句（如前代码所示）也有一个重载的方法。同样，它也是一个转换方法。'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: If the code was run and a suitable output was used, you would see `E`, `Ol`,
    `Lee`—the index at the start is 0, so no characters are seen.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 如果代码运行并使用了合适的输出，你会看到 `E`，`Ol`，`Lee`——起始索引是 0，所以没有看到任何字符。
- en: Replacing SQL with LINQ
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 替换 SQL 为 LINQ
- en: Depending on your needs, it may be a better option to replace an SQLite database
    with a series of `List<T>` classes and use LINQ to replace the SQL queries. For
    example, if you have a very simple database (such as our `demoTable` database)
    which has a very limited scope for manipulation to be used, it may be a better
    idea to use a list of classes, add to them as you would normally do, and perform
    the queries using LINQ. Without the hit on the database server, this may yield
    a faster response time from the application.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的需求，用一系列 `List<T>` 类替换 SQLite 数据库可能是一个更好的选择，并使用 LINQ 来替换 SQL 查询。例如，如果您有一个非常简单的数据库（例如我们的
    `demoTable` 数据库），它具有非常有限的用于操作的范围，那么使用类列表可能是一个更好的主意，您可以像通常那样向其中添加内容，并使用 LINQ 执行查询。由于没有对数据库服务器的打击，这可能会从应用程序中获得更快的响应时间。
- en: For a more complex table structure where the SQL itself performs a `JOIN` to
    another table or there are complex manipulations involved, using LINQ may not
    result in a usable system.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 对于结构更复杂的表格，其中 SQL 本身执行对另一个表的 `JOIN` 操作，或者涉及复杂的操作，使用 LINQ 可能不会得到一个可用的系统。
- en: LINQ can perform `JOIN` conditions as well as most other functions that SQLite
    can perform—just not as easily.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: LINQ 可以执行 `JOIN` 条件，以及 SQLite 可以执行的大多数其他功能——只是不那么容易。
- en: Remember though, LINQ on the iPhone may decide to just die whereas SQLite won't.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，请注意，iPhone 上的 LINQ 可能会决定直接崩溃，而 SQLite 不会。
- en: Summary
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Data storage on the iPhone can be simple and can also be fraught with problems.
    For safety and reliability, the SQLite option is preferred on the iPhone. For
    speed, you can't beat LINQ but you must ensure that you test the LINQ project
    on a physical device when using LINQ.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 上的数据存储可以很简单，也可能充满问题。为了安全和可靠性，iPhone 上首选 SQLite 选项。对于速度，LINQ 无敌，但您必须确保在使用
    LINQ 时在物理设备上测试 LINQ 项目。
