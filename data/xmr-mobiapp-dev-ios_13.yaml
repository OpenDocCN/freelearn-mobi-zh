- en: Chapter 13. User Preferences
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章 用户偏好
- en: From time to time, it is useful for a user to be able to store preferences (such
    as ringtones for a contact). Thankfully, iOS provides a built-in preference system.
    This is fine if you only ever wish to write an app for iOS, but if the intention
    is to have an app that can be built for any platform that can use .NET, then a
    different approach is required.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，用户能够存储偏好设置（例如联系人的铃声）是非常有用的。幸运的是，iOS提供了一个内置的偏好设置系统。如果你只想为iOS编写应用程序，这没问题，但如果目的是要创建一个可以用于任何可以使用.NET的平台的应用程序，则需要不同的方法。
- en: 'The topics covered in this chapter will be:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖的主题包括：
- en: Using the built-in preference system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用内置偏好设置系统
- en: Rolling your own preference system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义偏好设置系统
- en: The built-in system
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置系统
- en: To start with, a special folder has to be added to your application called `Settings.bundle`
    that contains a file called `Root.plist`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，需要向应用程序中添加一个名为`Settings.bundle`的特殊文件夹，其中包含一个名为`Root.plist`的文件。
- en: This is not a normal file and the `.plist` file needs **Build Action** to be
    set as **Content**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个普通文件，`.plist`文件需要将**Build Action**设置为**Content**。
- en: '![The built-in system](img/00046.jpeg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![内置系统](img/00046.jpeg)'
- en: The `.plist` file is an XML file with entries stored in a regular dictionary
    objecting the `<key><type>` form, where type can be anything (such as `string`,
    `int`, and `double`).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '`.plist`文件是一个XML文件，条目以常规字典对象的形式存储，形式为`<key><type>`，其中类型可以是任何东西（例如`string`、`int`和`double`）。'
- en: 'For example, for creating a preference displayed as a `UISlider` class it would
    be stored as shown in the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于创建以`UISlider`类显示的偏好设置，它将按照以下代码所示进行存储：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is simple to understand, but the file can grow quickly, depending on how
    much information is being stored.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 理解起来很简单，但文件会根据存储的信息量快速增长。
- en: Reading and writing to the .plist file
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 读取和写入.plist文件
- en: Thankfully, it is simple to read from the `.plist` file. All that is required
    is the key to identify the value and the knowledge of the value type to properly
    call the related method.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，从`.plist`文件中读取很简单。所需的一切就是识别值的键以及了解值类型以正确调用相关方法。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Writing to the file can be performed in two ways. The simplest is to just write
    to the file, as shown in the following code:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 写入文件可以通过两种方式完成。最简单的方法是直接写入文件，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The other way is to call the `NSNotificationCenter` class, which broadcasts
    notifications to the application. The `NSUserDefaults` class uses this system
    to emit the `NSUserDefaultsDidChangeNotifcation` notification when the `Settings`
    values change. The good part here is that any `NSObject` class can be set to act
    as an observer for the notification. The observer provides a call back method
    as shown in the following code:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是调用`NSNotificationCenter`类，该类向应用程序广播通知。`NSUserDefaults`类使用这个系统在`Settings`值改变时发出`NSUserDefaultsDidChangeNotifcation`通知。这里的好处是任何`NSObject`类都可以设置为通知的观察者。观察者提供了一个回调方法，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Rolling your own settings system
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义设置系统
- en: While using the built-in settings system may seem useful, the point of using
    the Xamarin range of products is to be able to use a large amount of the same
    code on any platform that now supports `.NET`. While, at the time of writing,
    Windows Mobile is languishing at around three percent of the market share of all
    smart phones, Microsoft is unlikely to allow this to continue and will push their
    massive reserves into getting people to adopt their smart phones. If you want
    the pure mathematics, 97 percent of all smart phones can be coded using the .NET
    platform. (Blackberry has a port of mono for it, but it is not well supported
    and so can be discounted.)
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然使用内置设置系统可能看起来很有用，但使用Xamarin产品系列的目的是在现在支持.NET的任何平台上能够使用大量相同的代码。虽然，在撰写本文时，Windows
    Mobile的市场份额仅为所有智能手机的约三%，但微软不太可能允许这种情况继续，并将推动其庞大的储备力量以促使人们采用他们的智能手机。如果你要计算纯数学，97%的所有智能手机都可以使用.NET平台进行编码。（Blackberry为其提供了mono的端口，但支持不佳，因此可以忽略。）
- en: This, therefore, requires a different strategy for storing user settings. We
    could use an SQLite database to store the details, but, as has been pointed out,
    each access to the sub system will cause a performance hit.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，存储用户设置需要不同的策略。我们可以使用SQLite数据库来存储详细信息，但正如已经指出的那样，对子系统的每次访问都会导致性能下降。
- en: The simplest way is to create a `settings` class and **serialize** or **deserialize**
    the values as and when required. It is an extremely flexible approach and works
    wonderfully.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的方法是创建一个`settings`类，并在需要时**序列化**或**反序列化**值。这是一个极其灵活的方法，并且效果非常好。
- en: Serializing and deserializing data
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化和反序列化数据
- en: 'The following code is a very simple serializer and deserializer:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个非常简单的序列化器和反序列化器：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code will serialize and deserialize any object type that is put
    through it. This includes generic types such as `List<>` and `Dictionary<,>` objects.
    Do not pass in interface members or circular references (like an object that refers
    to an object that refers to the original object)—this will cause the serializer
    to crash.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将序列化和反序列化通过它的任何对象类型。这包括如`List<>`和`Dictionary<,>`等泛型类型对象。不要传递接口成员或循环引用（例如，一个引用到另一个对象的对象，该对象又引用到原始对象）——这将导致序列化器崩溃。
- en: Setting up the Settings file
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置设置文件
- en: Unlike using the `NSUserDefaults.plist` file, the settings file used here is
    still an XML file, but it doesn't need to be set as any particular type. As it
    is also a simple XML file, it can be copied and transferred to the same application
    on a different platform.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`NSUserDefaults.plist`文件不同，这里使用的设置文件仍然是一个XML文件，但它不需要设置为任何特定类型。由于它也是一个简单的XML文件，因此可以复制并传输到不同平台上的相同应用程序。
- en: '![Note](img/00001.gif)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: Note
  id: totrans-31
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: So say you're configuring a file for the app on the iPhone and you want to run
    it on your Android phone as well. You will copy the `Settings` file and run the
    app on the Android phone and you instantly have the settings you had on the iPhone.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在为iPhone上的应用程序配置文件，并且你想要在Android手机上运行它。你将复制`Settings`文件，并在Android手机上运行应用程序，你立即就有了在iPhone上设置的设置。
- en: '![Note](img/00001.gif)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![注意](img/00001.gif)'
- en: The `Settings` file consists of two classes—the `handler` class and the `data`
    class.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Settings`文件由两个类组成——`handler`类和`data`类。'
- en: The handler class
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理类
- en: 'The handler class handles setting up the `Settings` file as well as the accessors
    for the data class. I''ve reproduced the important parts in the following code:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 处理类负责设置`Settings`文件以及数据类的访问器。以下代码中重现了重要部分：
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Adding an accessor
  id: totrans-38
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加访问器
- en: 'The following code is used for any type of object being passed into the configuration
    file:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码用于将任何类型的对象传递到配置文件中：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The preceding simple accessor can be cut and pasted as many times as required.
    The best thing is that the `List<>` object can be of any type—you can even have
    an entire list of classes in there!
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 上述简单的访问器可以根据需要多次复制粘贴。最好的是，`List<>`对象可以是任何类型——你甚至可以在其中有一个完整的类列表！
- en: The data class
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数据类
- en: 'The data class contains nothing except a list of accessors that marry up to
    the ones in the data handler class, and its also contains a default constructor
    as shown in the following code:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 数据类除了包含与数据处理器类中匹配的访问器列表外，还包含一个默认构造函数，如下所示：
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: With the preceding code, you have possibly the most flexible configuration and
    settings system available.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用上述代码，你可能有最灵活的配置和设置系统。
- en: Summary
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'User settings are important—who in their right mind wants to have to set up
    everything time and again, or worse, for every update of the application? When
    updating an application, a file within the application folder will be kept and
    will always be available (except if the app is uninstalled). Stored user settings
    are not always guaranteed to persist between versions. We have seen in this chapter
    two completely different methods of storing configuration settings: the one supplied
    and the one created. There are other ways to do the same as I have demonstrated
    in this chapter.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 用户设置很重要——谁会愿意每次都要重新设置一切，或者更糟糕的是，每次应用程序更新都要设置？在更新应用程序时，应用程序文件夹中的一个文件将被保留，并且始终可用（除非应用程序被卸载）。存储的用户设置并不总是保证在版本之间持久存在。在本章中，我们看到了两种完全不同的存储配置设置的方法：一种是提供的，另一种是创建的。还有其他方法可以做到这一点，就像我在本章中演示的那样。
