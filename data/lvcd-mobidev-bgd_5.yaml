- en: Chapter 5. Making a Jigsaw Puzzle Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章。制作拼图应用
- en: '*Picture this…*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*想象一下…*'
- en: '*So far, we''ve been dealing with a lot of text or calling mobile OS features.
    These are neat things, but they''re not that visual. If you were longing to mess
    around with pictures and image data, your time has come!*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*到目前为止，我们一直在处理大量文本或调用移动操作系统功能。这些事情很整洁，但它们并不那么直观。如果你渴望玩弄图片和图像数据，你的时机到了！*'
- en: LiveCode isn't naturally a graphics powerhouse and its way of handling image
    data (often referred to as "bitmap data" by other tools) is somewhat unusual.
    It effectively stores the pixels of an image as a series of single byte characters
    to represent the red, green, and blue values of each pixel. Handling a final image
    is quite flexible, but in order to create something along the lines of a jigsaw
    puzzle, we need to understand the format of `imageData`, a LiveCode property.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode 并非天生的图形 powerhouse，它处理图像数据（其他工具通常称为“位图数据”）的方式有些不寻常。它有效地将图像的像素存储为一系列单字节字符，以表示每个像素的红色、绿色和蓝色值。处理最终图像相当灵活，但为了创建类似拼图的东西，我们需要了解
    LiveCode 属性 `imageData` 的格式。
- en: 'In this chapter, we will:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将：
- en: Examine the way LiveCode stores bitmap data in an image object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查 LiveCode 在图像对象中存储位图数据的方式
- en: Find a way to use a single bitmap in place of 50 buttons
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 找一种方法使用单个位图代替 50 个按钮
- en: Make a collision detection map
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作一个碰撞检测图
- en: Create a jigsaw puzzle app that takes advantage of several mobile device features
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个利用多个移动设备功能的拼图应用
- en: Image data format
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 图像数据格式
- en: 'In other authoring tools, such as Adobe Director and Adobe Flash, bitmap data
    is stored as a matrix of 24-bit or 32-bit values. If you want to know the color
    of the 20th pixel from the left edge in the 15th row from the top of the image,
    you would have to use a `getPixel` function with these numbers filled in. In Flash,
    which uses a zero starting point for all its variable types, you would have to
    write the following code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他作者工具中，例如 Adobe Director 和 Adobe Flash，位图数据以 24 位或 32 位的值矩阵形式存储。如果你想知道图像顶部第
    15 行从左侧数第 20 个像素的颜色，你将不得不使用一个 `getPixel` 函数并填入这些数字。在 Flash 中，它为所有变量类型使用零起始点，你必须编写以下代码：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You would in fact have to start this line with `var pixelcolor:uint`, but here
    we''re looking at the main differences and not the oddities of having a strongly
    typed programming language! In Director, which like LiveCode uses 1 based variables,
    you would have to write the following code:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你必须以 `var pixelcolor:uint` 开始这一行，但在这里我们关注的是主要差异，而不是强类型编程语言的怪癖！在 Director
    中，它像 LiveCode 一样使用基于 1 的变量，你必须编写以下代码：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Again, there's no need for variable typing or even a semicolon at the end of
    the line. While we digress, Flash too, doesn't need the semicolon at the end or
    at least, you don't have to type it yourself. Flash knew what you meant! Getting
    back to the point…
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，没有必要进行变量类型定义，甚至行尾也不需要分号。当我们分心时，Flash 也不需要行尾的分号，或者至少，你不必自己输入它。Flash 知道你的意图！回到正题…
- en: In LiveCode, each pixel of an image is represented by four bytes, which you
    can access as if they are single-byte characters. The range of values in a byte
    is 0-255, and storing such values, especially the value `0`, in character variables
    does not work out well. Therefore, you would have to convert the character value
    into a numeric value before making use of it. The basic problem is that, although
    the numeric value is stored in a variable, when you come to do calculations on
    it, LiveCode wants to work in Base 10 arithmetic and not in the binary form inside
    the variable. You have to convert the variable into something that can be processed
    using the `charToNum` function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 LiveCode 中，图像的每个像素由四个字节表示，你可以像访问单字节字符一样访问它们。字节的值范围是 0-255，并且存储这些值，特别是值 `0`，在字符变量中效果不佳。因此，在利用它之前，你必须将字符值转换为数值。基本问题是，尽管数值存储在变量中，但当你开始对其执行计算时，LiveCode
    希望使用十进制算术而不是变量内的二进制形式。你必须将变量转换为可以使用 `charToNum` 函数处理的东西。
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: So, why would a character variable not like zeros you ask! Well, in the earliest
    days of personal computers, the predominant programming language was Pascal. In
    Pascal, a variable that contained a literal string needed a way to know how long
    the string was. The first byte of a Pascal string stores the length of the string,
    which was fine up to 255 characters, and in those days, it was most likely thought
    of as enough, and more than anyone would ever need! In real life though, strings
    can be longer than 255 characters. This paragraph alone is over 900 characters
    long. To solve this issue, the C programming language used a zero to indicate
    the end of a *C String*. You could have a million characters in a row; however,
    only the last one would be a zero. RGB values don't care about the limitations
    of C strings and there are zeros all over the place, which is why we convert it
    to a numeric value as soon as we can.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么字符变量不喜欢零呢？好吧，在个人电脑的早期阶段，主要的编程语言是Pascal。在Pascal中，包含字面字符串的变量需要一种方式来知道字符串的长度。Pascal字符串的第一个字节存储字符串的长度，这对于255个字符来说是足够的，而且在当时，人们可能认为这已经足够了，而且比任何人需要的都多！然而，在现实生活中，字符串可以比255个字符长。这个段落本身就有超过900个字符长。为了解决这个问题，C编程语言使用零来表示*C字符串*的结尾。你可以有一行一百万个字符；然而，只有最后一个字符是零。RGB值不关心C字符串的限制，到处都是零，这就是为什么我们尽可能快地将它转换为数值值。
- en: In addition to the oddity of each pixel being stored as four bytes of information,
    there's also no way to tell specify rows and columns. All the pixels in an image
    have their four bytes end to end; you have to do a calculation to know where in
    the data the pixel you're looking for is located. If you have worked on a bitmap
    editor before, say Photoshop or Gimp, you must be aware that you select content
    based on an *X* and *Y* co-ordinate value that correspond to the column and row
    that the pixel is located in. LiveCode doesn't let you access bitmaps in this
    way. Hence, we need to do a calculation.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 除了每个像素以四个字节的信息存储的奇特之处外，也没有办法指定行和列。图像中的所有像素的四个字节都是连续存储的；你必须进行计算才能知道你正在寻找的像素在数据中的位置。如果你之前使用过位图编辑器，比如Photoshop或Gimp，你肯定知道你选择内容是基于一个对应的*X*和*Y*坐标值，这个坐标值对应于像素所在的列和行。LiveCode不让你以这种方式访问位图。因此，我们需要进行计算。
- en: 'Here''s how the pixel from the preceding example would be retrieved in LiveCode
    if you want it as a 24-bit value:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在LiveCode中，如果你想将前一个示例中的像素值作为24位值检索，可以这样操作：
- en: '[PRE2]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: On the face of it, this is one of the few cases where the way it's done in LiveCode
    is considerably longer than in other languages. However, quite often, you really
    need the red, green, and blue values from the pixel, and in other languages, you
    have to take extra steps to extract these values.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 表面上看，这是LiveCode中实现方式比其他语言长得多的情况之一。然而，相当常见的是，你确实需要像素中的红色、绿色和蓝色值，而在其他语言中，你必须采取额外步骤来提取这些值。
- en: The extra steps needed to make the returned number a 24-bit RGB value are no
    big deal, as LiveCode is easily extended by your own functions. If you need the
    24-bit value, use the preceding function and you will have added a `getPixel`
    function to the LiveCode language. You still have to do the calculations to even
    get at just the red value. Maybe one day, LiveCode will have a built-in `getPixel`
    function that works quicker than your own function. The 24-bit number returned
    here is in fact represented as three decimal numbers and not as a 24-bit binary
    value, but it would still be generally referred to as *24 bit*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 将返回的数字转换为24位RGB值的额外步骤并不麻烦，因为LiveCode可以通过你自己的函数轻松扩展。如果你需要24位值，使用前面的函数，你将为LiveCode语言添加一个`getPixel`函数。即使只是获取红色值，你仍然需要进行计算。也许有一天，LiveCode将有一个内置的`getPixel`函数，它的工作速度比你的函数更快。这里返回的24位数字实际上是以三个十进制数字表示的，而不是24位二进制值，但它通常仍被称为*24位*。
- en: Mystery byte…
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 神秘字节…
- en: The first character of the four that represent one pixel is not used. LiveCode
    has tutorials on how to use `imageData`, where that byte is referred to as Alpha.
    That makes sense, as even the other tools that give you a 32-bit number have the
    value broken up into Alpha, Red, Green, and Blue. Why doesn't that byte, which
    RunRev calls Alpha, contain the alpha value? Who knows!
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个像素的四个字符中的第一个字符是不使用的。LiveCode有关于如何使用`imageData`的教程，其中那个字节被称为Alpha。这很有道理，因为即使提供32位数的其他工具也将值拆分为Alpha、红色、绿色和蓝色。为什么RunRev称为Alpha的字节不包含alpha值？谁知道呢！
- en: One possibility is that the value doesn't serve its purpose well enough. When
    talking about alpha transparency, you sometimes may mean that the image is transparent,
    as might be the case in a GIF image. Other times, you may mean that it's translucent,
    where it's only partially see-through.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能性是值没有很好地发挥其作用。当谈到 alpha 透明度时，你有时可能是指图像是透明的，就像 GIF 图像中可能的情况一样。有时，你可能是指它是半透明的，即它只有部分透明。
- en: 'To solve the ambiguous nature of the problem, LiveCode has two other properties
    of an image, `maskData` and `alphaData`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决问题的模糊性，LiveCode 有两个图像的其他属性，`maskData` 和 `alphaData`：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These properties of an image still have all the rows end to end, and you have
    to do the calculation to find where a given pixel's alpha value is stored.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这些图像属性仍然有所有行连在一起，你必须进行计算以找到给定像素的 alpha 值存储的位置。
- en: With `maskData`, you get a set of values for each of the pixels. For every value
    other than 0, the pixel is visible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `maskData`，你可以得到每个像素的一系列值。对于除了 0 以外的每个值，像素都是可见的。
- en: With `alphaData`, you get a set of values of the opaqueness of the pixel. 0
    would be fully transparent, 255 would be fully opaque, and the values in between
    will be translucent. 128 would be 50 percent opaque.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `alphaData`，你可以得到像素不透明度的一系列值。0 将是完全透明的，255 将是完全不透明的，介于两者之间的值将是半透明的。128 将是
    50% 不透明的。
- en: Later in this chapter, we are going to make use of both `maskData` and `alphaData`,
    and we will refer to the 0-255 `alphaData` value as its *transparency*, and the
    zero or nonzero `maskData` value as its *mask*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面，我们将使用 `maskData` 和 `alphaData`，我们将把 0-255 的 `alphaData` 值称为其 *透明度*，把零或非零的
    `maskData` 值称为其 *遮罩*。
- en: Misusing imageData
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: imageData 的误用
- en: The topics in the LiveCode online tutorials include manipulation of `imageData`,
    turning a colored image into a grayscale one (this particular example of turning
    a colored image is located at [http://lessons.runrev.com/s/lessons/m/4071/l/25371-vision-how-do-i-convert-a-color-image-to-grayscale](http://lessons.runrev.com/s/lessons/m/4071/l/25371-vision-how-do-i-convert-a-color-image-to-grayscale)).
    We're not going to do that here. Instead, we'll use the values in the image, mask,
    and alpha to achieve some neat things that don't change the image at all. In fact,
    in some cases, we won't even see the image!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: LiveCode 在线教程中的主题包括 `imageData` 的操作，将彩色图像转换为灰度图像（这个将彩色图像转换为灰度图像的特定示例位于 [http://lessons.runrev.com/s/lessons/m/4071/l/25371-vision-how-do-i-convert-a-color-image-to-grayscale](http://lessons.runrev.com/s/lessons/m/4071/l/25371-vision-how-do-i-convert-a-color-image-to-grayscale)）。我们在这里不会做这个。相反，我们将使用图像、遮罩和
    alpha 中的值来实现一些不会改变图像的巧妙功能。实际上，在某些情况下，我们甚至可能看不到图像！
- en: Time for action – testing a getPixel function
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 测试 getPixel 函数
- en: 'Before getting to useful examples, let''s make a `getPixel` function to obtain
    the color components of a point in the image and then complete a quick test case.
    The following steps will help you in this process:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在到达有用的示例之前，让我们创建一个 `getPixel` 函数来获取图像中某点的颜色分量，然后完成一个快速测试用例。以下步骤将帮助你完成这个过程：
- en: Make a new Mainstack. Click on **Save** to save it as **ImageDataTests**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Mainstack。点击 **保存** 将其保存为 **ImageDataTests**。
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll use the same stack to illustrate several things and at the end, we may
    dare to try it on a mobile device!
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用同一个堆栈来展示几个方面，最后，我们可能会尝试在移动设备上尝试它！
- en: Set the stack's resolution to the size of your largest test device or just try
    1024 x 768 if you'll be using the iPad Simulator.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将堆栈的分辨率设置为你的最大测试设备的大小，或者如果你将使用 iPad 模拟器，就尝试 1024 x 768。
- en: From the **File** menu, navigate to **Import as Control** | **Image** and select
    any small image file you have, to place it in the upper-left corner of the card
    window. The next example, uses a LiveCode logo image that can easily be obtained
    from any LiveCode web page.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **文件** 菜单中，导航到 **导入为控件** | **图像** 并选择你拥有的任何小图像文件，将其放置在卡片窗口的左上角。下一个示例将使用可以从任何
    LiveCode 网页轻松获得的 LiveCode 标志图像。
- en: Place a new `Graphic` object next to the image. It's going to show a single
    color, so just make it big enough so that you can easily see the color. Name it
    `swatch`.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像旁边放置一个新的 `Graphic` 对象。它将显示单色，所以只需让它足够大，以便你可以轻松地看到颜色。将其命名为 `swatch`。
- en: 'Set graphics to default to show an empty box, so type this in the message box
    to fill it:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图形设置为默认显示一个空框，所以在消息框中输入以下内容：
- en: '[PRE4]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Edit the script of the image and type these lines in:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑图像的脚本，并输入以下行：
- en: '[PRE5]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that the two lines are commented out. LiveCode would only complain if we
    keep asking for `getPixel` before we create that function!
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，这两行已被注释掉。如果我们在创建该函数之前不断请求`getPixel`，LiveCode只会抱怨！
- en: 'Edit the stack script. Add the `getPixel` function, which is very much like
    the one shown in the Image data format we discussed in the preceding steps:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑堆栈脚本。添加`getPixel`函数，它与我们在前面步骤中讨论的图像数据格式非常相似：
- en: '[PRE6]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Back in the image script, uncomment the two lines. Start pointing at the image
    and you should see the swatch graphic change color to match the pixel under the
    cursor.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在图像脚本中，取消注释两行。开始指向图像，你应该看到色板图形的颜色改变以匹配光标下的像素。
- en: '*What just happened?*'
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We made a very simple example case of how to use the color of a pixel in an
    image; in this case, how to colorize a swatch. As setting `backgroundColor` of
    a graphic requires `redvalue`, `greenvalue`, and `bluevalue`, we didn't need to
    convert the values from the image to a 24-bit number and the `getPixel` function
    was able to return `tRed,tGreen,tBlue`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了一个非常简单的例子，说明了如何使用图像中像素的颜色；在这种情况下，如何着色色板。由于设置图形的`backgroundColor`需要`redvalue`、`greenvalue`和`bluevalue`，我们不需要将图像中的值转换为24比特数，`getPixel`函数能够返回`tRed,tGreen,tBlue`。
- en: Now, there isn't really any advantage to the way we did that compared to the
    built-in `mouseColor` function. However, at least we gave the `getPixel` function
    a tryout!
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，与我们使用的方法相比，与内置的`mouseColor`函数相比，并没有真正的好处。然而，至少我们尝试了`getPixel`函数！
- en: Pop quiz – how many bits in a byte?
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答——一个字节中有多少比特？
- en: '*Bytes* was mentioned a few times in this chapter and you may well know about
    *bit depth* as we''ve talked about digital photographs. So tell me, how many bits
    are there in a byte?'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '*字节*在本章中提到了几次，你很可能已经知道关于*比特深度*的信息，因为我们已经讨论了数字照片。那么，告诉我，一个字节中有多少比特？'
- en: '32'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '32'
- en: '24'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '24'
- en: '8'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '8'
- en: Depends on how hungry you are
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取决于你有多饿
- en: 'Answer: 8'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：8
- en: We won't even talk about bits or bytes in the rest of this chapter; however,
    if only for the interest to mathematicians, it's good to know that a byte is 8
    bits. A bit is a binary digit, and when you start to think of bits in those terms,
    you will see that a byte can store 2 to the power of 8 values in it (binary being
    Base 2). This comes into play when you look at the length of a Pascal string (2
    to the power of 8 is 256, hence the range of characters in a Pascal String is
    0-255) and it helps you realize that if a picture is made up of one byte, for
    each pixel's red, green, and blue values, it's a 24-bit picture. Once you add
    in another byte of data for the alpha channel, you have a 32-bit picture.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分，我们甚至不会提及比特或字节；然而，仅为了满足数学家的兴趣，了解一个字节由8比特组成是好的。比特是一个二进制数字，当你开始用这种方式思考比特时，你会发现一个字节可以存储2的8次方个值（二进制是基数2）。这一点在查看Pascal字符串的长度时就会显现出来（2的8次方是256，因此Pascal字符串中字符的范围是0-255），这有助于你意识到，如果一张图片由一个字节组成，对于每个像素的红色、绿色和蓝色值，它就是一个24比特的图片。一旦你为alpha通道添加另一个字节的数据，你就得到了一个32比特的图片。
- en: Simulating lots of buttons
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟许多按钮
- en: In some applications, you need to know exactly which area of an image the user
    is pointing at. For example, when there is a map and you want to show information
    related to the region the user has clicked on, this could be done using a lot
    of rectangular buttons or you could break the regions into graphics and use a
    `mouseEnter` handler to detect which region it is. Instead, you could use a single
    image to represent all the regions.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些应用程序中，你需要确切知道用户指向图像的哪个区域。例如，当有一个地图，你想要显示与用户点击的区域相关的信息时，这可以通过很多矩形按钮来完成，或者你可以将区域分解成图形并使用`mouseEnter`处理程序来检测它是哪个区域。相反，你可以使用单个图像来表示所有区域。
- en: Time for action – making a map of the United States
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——制作美国地图
- en: 'There are plenty of places online to get public domain images to use in your
    applications. Search for `public domain images` and you will see links to Wikipedia
    articles, government sites, and other sites that let you download images that
    are free to use. The map shown in the following steps came from the file at:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在网上有很多地方可以获取公共领域图像用于你的应用程序。搜索`public domain images`，你会看到指向维基百科文章、政府网站和其他允许你下载免费使用图像的网站的链接。以下步骤中显示的地图来自以下文件：
- en: '[http://upload.wikimedia.org/wikipedia/commons/3/32/Blank_US_Map.svg](http://upload.wikimedia.org/wikipedia/commons/3/32/Blank_US_Map.svg).'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://upload.wikimedia.org/wikipedia/commons/3/32/Blank_US_Map.svg](http://upload.wikimedia.org/wikipedia/commons/3/32/Blank_US_Map.svg).'
- en: Make a new field named `states`. Find an alphabetical list of the 50 united
    states to paste it into the field or you can type them in!
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `states` 的新字段。找到一个包含 50 个美国州的字母顺序列表，将其粘贴到字段中，或者你也可以手动输入它们！
- en: Make another field, set the text size to 24, and the size of the field wide
    enough for *New Hampshire* to fit in (just the words, not the entire state!).
    Name the field `state`.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个字段，将文本大小设置为 24，并将字段宽度设置得足够容纳 *New Hampshire*（仅限单词，不包括整个州！）的大小。将字段命名为 `state`。
- en: Tip
  id: totrans-68
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Download the completed map**'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**下载完成的地图**'
- en: Note that you can save a lot of work here by downloading the `us-map.png` file
    from the support file section for this book, which you can find at [www.PacktPub.com](http://www.PacktPub.com).
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以通过从本书的支持文件部分下载 `us-map.png` 文件来节省大量工作，你可以在 [www.PacktPub.com](http://www.PacktPub.com)
    找到它。
- en: If you have Adobe Illustrator, open the SVG file with it. If not, open it with
    GIMP. Pixelmator is a low-cost alternative on Macintosh OS X.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你拥有 Adobe Illustrator，用其打开 SVG 文件。如果没有，则用 GIMP 打开。在 Macintosh OS X 上，Pixelmator
    是一个低成本的选择。
- en: In alphabetical order, fill in each state with a color where the red, green,
    and blue values match the line number of that state + 100 . We're adding 100 so
    that the shades of gray we'll see will not be so dark.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按字母顺序，在每个州上填入一个颜色，其中红色、绿色和蓝色的值与该州的行号加 100 相匹配。我们添加 100 是为了让我们将看到的灰色阴影不那么暗。
- en: Continue the same through all the states. Here's how it will start to look like
    in Illustrator, where Idaho is about to be colored as `112`, `112`, `112`:![Time
    for action – making a map of the United States](img/image00274.jpeg)
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对所有州重复相同的操作。以下是 Illustrator 中的开始外观，爱达荷州即将被着色为 `112`，`112`，`112`：![动手实践 – 制作美国地图](img/image00274.jpeg)
- en: Change the size of the map, so that it would fill about a third of the stack
    window, and choose **Export**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改变地图的大小，使其大约填充堆栈窗口的三分之一，然后选择 **导出**。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Color profile settings**'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**颜色配置文件设置**'
- en: LiveCode treats bitmaps in a way that ignores color profile information in the
    image, and that would ruin this thing we're trying to do. While exporting an image,
    check whether there is an option to set the color profile to `genericRGB`. If
    there isn't, then use a utility such as Color Sync to apply the `genericRGB` color
    profile. Once the image is saved, there is something you can do to make sure that
    it gets imported into LiveCode OK. Before importing, set the screen gamma to `2.23`
    by typing in the message box and press *Enter*. This will set LiveCode to the
    right settings to make sure that the color values appear correctly.
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: LiveCode 以一种忽略图像中颜色配置信息的方式处理位图，这会破坏我们试图做的事情。在导出图像时，检查是否有选项将颜色配置文件设置为 `genericRGB`。如果没有，则使用
    Color Sync 等工具应用 `genericRGB` 颜色配置文件。一旦图像保存，你可以做一些事情来确保它能够正确导入到 LiveCode 中。在导入之前，在消息框中输入并将屏幕伽玛设置为
    `2.23`，然后按 *Enter*。这将设置 LiveCode 为正确的设置，以确保颜色值正确显示。
- en: If you're using Illustrator, set the background to be **White** and anti-aliasing
    to be **None**. With GIMP, make sure that the PNG is saved without an alpha channel.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你使用 Illustrator，将背景设置为 **白色**，并将抗锯齿设置为 **无**。在使用 GIMP 时，确保 PNG 文件没有保存 alpha
    通道。
- en: 'Type this line followed by the *Enter* key into the message box:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在消息框中输入此行，然后按 *Enter* 键：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Import the PNG into your `ImageDataTests` stack.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 PNG 图像导入到你的 `ImageDataTests` 栈中。
- en: 'Set the image''s script to this:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像的脚本设置为以下内容：
- en: '[PRE8]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Try pointing at the different states, at least point at the ones that you have
    colored. The state name should appear in the `state` field.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试指向不同的州，至少指向那些你已经着色的州。州名应该出现在 `state` 字段中。
- en: '*What just happened?*'
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: For this case, we only needed to look at the value of the red channel for the
    pixel under the cursor (the green and blue values are the same because we used
    a gray color value for both). Rather than writing another function to get only
    the red part of the data, we reused the existing `getPixel` function, but then
    only took notice of the first item that the function returned. That number, after
    subtracting 100 that we had added to it to make the shades not be so dark, was
    then used as a lookup value to get the corresponding state name.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个案例，我们只需要查看光标下像素的红色通道值（绿色和蓝色值相同，因为我们使用了灰色的颜色值）。而不是编写另一个函数来仅获取数据的红色部分，我们重用了现有的
    `getPixel` 函数，但只关注该函数返回的第一个项目。这个数字，在减去我们添加的 100（为了让阴影不那么暗）之后，被用作查找值来获取相应的州名。
- en: Pop quiz – getting the big picture
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 突击测验 – 获取整体概念
- en: The example map image was an SVG file. Is an SVG file smaller than a PNG file
    for a given image? (do a little Wikipedia research and decide on the answer.)
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 示例地图图像是一个SVG文件。对于给定的图像，SVG文件比PNG文件小吗？（进行一点维基百科研究并决定答案。）
- en: 'Yes'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是的
- en: 'No'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否
- en: Depends on the nature of the image
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取决于图像的性质
- en: 'Answer: 3'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：3
- en: SVG is a description of how to draw the image, whereas PNG is a description
    of the pixels in the image. In PNG, this information is also data compressed in
    a lossless way. For the example map, at its original size, a 24-bit PNG is half
    the size of the SVG file. There is a lot of data needed to describe the outlines
    of the U.S. states! If the image needs to be enlarged, the PNG would become a
    bigger-sized file and the SVG would remain at the same file size. On the other
    hand, if an image was a rectangle piece of a diagonal gradient, the SVG would
    be tiny and the PNG would be huge because there are no long runs of the same-colored
    pixels for the data compression to work well.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: SVG是描述如何绘制图像的方式，而PNG是描述图像像素的方式。在PNG中，这些信息也被以无损方式压缩。对于示例地图，在其原始大小下，24位的PNG文件大小是SVG文件的一半。描述美国各州轮廓需要大量的数据！如果需要放大图像，PNG文件会变成更大的文件，而SVG文件大小将保持不变。另一方面，如果图像是一个对角渐变的矩形块，SVG文件会非常小，而PNG文件会非常大，因为数据压缩无法很好地工作，因为没有相同颜色的像素长串。
- en: Using maskData for collision detection
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用maskData进行碰撞检测
- en: In old 2D maze adventure games, your character would move in distinct chunks,
    and while checking whether there was a wall or gap, the program only had to check
    relatively few locations. The occupied spots could be stored in an array, taking
    up little memory.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在古老的二维迷宫冒险游戏中，你的角色会以明显的块状移动，而在检查是否有墙壁或空隙时，程序只需要检查相对较少的位置。占据的位置可以存储在数组中，占用很少的内存。
- en: With other maze games, like those of marble maze tilt boards, you have to detect
    collisions at a much finer degree. A full-blown physics engine could take care
    of the problem, but it's possible to get some interesting results by storing the
    maze as an image and checking the pixels that are in front of your character or
    marble as the case may be.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于其他迷宫游戏，例如那些弹珠迷宫倾斜板游戏，你必须以更精细的程度检测碰撞。一个完整的物理引擎可以处理这个问题，但通过将迷宫存储为图像并检查角色或弹珠前面的像素，可以得到一些有趣的结果。
- en: In a full-featured game, it would be better to use `imageData` or perhaps `alphaData`,
    so that you can tell when you are going to hit something, and from the value you
    read, you can also tell what it is you have hit. In the marble maze game, you
    need to know when you have gone over a hole, for example.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个功能齐全的游戏中，最好使用`imageData`或可能`alphaData`，这样你就可以知道你将要撞到什么，并且从你读取的值中，你还可以知道你撞到了什么。例如，在弹珠迷宫游戏中，你需要知道你是否已经越过了洞口。
- en: For this next test though, we'll just use `maskData` and see what we can do
    about not hitting the thing that is in front of us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于接下来的测试，我们将只使用`maskData`并看看我们能否避免撞到我们前面的东西。
- en: Time for action – making a racecourse
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 制作赛道
- en: 'We''re going to make a racecourse for little cars to move around. We''ll make
    it out of the stack we''ve built! First, we need to convert what is on the card
    into an image that represents walls and spaces:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将制作一个小汽车的赛道，我们将使用我们构建的堆栈来制作它！首先，我们需要将卡片上的内容转换为表示墙壁和空间的图像：
- en: Using the LiveCode draw tools, add a bunch of objects to the `ImageDataTest`
    stack. These are going to be the obstacles in the racecourse.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用LiveCode的绘图工具，向`ImageDataTest`堆栈中添加一些对象。这些将成为赛道上的障碍物。
- en: 'To create the image we''ll need, type this in the message box:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建我们需要的图像，在消息框中输入以下内容：
- en: '[PRE9]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The preceding command will take a screenshot of the card window and place it
    onto the card as a new *image* control. The new image will overlay the whole card,
    so will not be noticeable. You can confirm that the image was created and select
    it with the Project Browser.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的命令将截取卡片窗口的屏幕截图并将其放置在卡片上作为新的*图像*控件。新的图像将覆盖整个卡片，因此不会引起注意。你可以通过项目浏览器确认图像已创建并选择它。
- en: Right-click on the image that was created and select **Launch Editor**. This
    will open the image in the bitmap editor that you have set in **Preferences**/**General**.
    You will be prompted by LiveCode to select an editor if you haven't previously
    done so.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击创建的图像并选择**启动编辑器**。这将打开你在**首选项**/**常规**中设置的位图编辑器。如果你之前没有这样做，LiveCode会提示你选择一个编辑器。
- en: In your image editor's **Layers** window, duplicate the initial single layer.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的图像编辑器的**图层**窗口中，复制初始的单个图层。
- en: Make a new layer that is transparent beneath the duplicate image layer.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在复制图像图层下方创建一个新的透明图层。
- en: Delete the original layer.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除原始图层。
- en: Use the editor's *Magic Wand* to select the white space of the card image in
    the layer with the image in it (not the transparent layer). Delete the selected
    area to reveal the transparent layer.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用编辑器的*魔术棒*选择包含图像的图层中的卡片图像的空白区域（不是透明图层）。删除所选区域以显示透明图层。
- en: Inverse the selection and fill it with a dark color (the color doesn't matter,
    as it's used just so we can see where the holes are).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 反转选择并填充一个深色（颜色不重要，因为我们只是用它来看到洞的位置）。
- en: Take some time to fill in any small gaps. Also, place a thick border around
    the outside of the image. This shows how the card looks like and how the snapshot
    image should look like by now:![Time for action – making a racecourse](img/image00275.jpeg)
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 花一些时间填补任何小缝隙。还要在图像的外围放置一个粗边框。这显示了卡片的外观以及现在快照图像应该看起来像什么：![是时候行动了——制作赛道](img/image00275.jpeg)
- en: '**Merge** the layers of the document and then select **Save**.'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**合并**文档的图层，然后选择**保存**。'
- en: Return to LiveCode and click on the **Update** button, and the snapshot image
    will be updated to reflect the changes you've made.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回LiveCode并点击**更新**按钮，快照图像将更新以反映您所做的更改。
- en: Give the image the name `backdrop`. Later, we'll set the image behind other
    objects, but for now, we'll leave it on top of everything else.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给图像命名为`backdrop`。稍后，我们将设置图像在其它对象之后，但现在我们将让它位于所有其他对象之上。
- en: '*What just happened?*'
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just made a pretty strange looking racecourse! In a real top-down racing
    game, you would have to carefully design a nice-looking racecourse and make a
    duplicate of the image for collision detection. In the duplicate, you would have
    to erase the parts of the image that represent where cars are allowed to drive
    and then, you would have to fill the rest of the image with a flat color. Players
    would see the nice-looking racecourse, and underneath that would be the duplicate
    flat color version used to detect collisions.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚制作了一个看起来相当奇怪的赛道！在一个真正的俯视赛车游戏中，你必须仔细设计一个看起来很棒的赛道，并为碰撞检测制作图像的副本。在副本中，你必须擦除表示汽车可以驾驶的部分，然后，你必须用单色填充图像的其余部分。玩家将看到看起来很棒的赛道，而在下面则是用于检测碰撞的副本单色版本。
- en: We now need a car that drives itself around the course we've made.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要一个能在我们制作的赛道上自行驾驶的汽车。
- en: Time for action – making a racecar
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候行动了——制作一辆赛车
- en: 'Take as much time as you would like to create an image of the car. Make it
    so that it faces right. Then, once it''s in the stack, we''ll start adding the
    required functions to its script. A size of about 40 pixels across should be about
    right. Our sample car is also available on [www.PacktPub.com](http://www.PacktPub.com).
    The following is a close-up image of what we''re talking about, as seen in Photoshop:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 花尽可能多的时间来创建汽车图像。让它面向右边。然后，一旦它在堆栈中，我们将开始向它的脚本添加所需的函数。大约40像素的宽度应该是合适的。我们的示例汽车也可在[www.PacktPub.com](http://www.PacktPub.com)找到。以下是我们正在讨论的近距离图像，如Photoshop中所示：
- en: '![Time for action – making a racecar](img/image00276.jpeg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![是时候行动了——制作一辆赛车](img/image00276.jpeg)'
- en: 'Yours can be even better than that, if you like! Save it as a 24-bit PNG that
    has transparency. Ok, start your engines…:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你喜欢，你的作品甚至可以更好！保存为具有透明度的24位PNG。好的，发动引擎…：
- en: Import the image as a control and place it somewhere in the white area of the
    `ImageDataTests` stack. Name it `car1`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像作为控件导入，并将其放置在`ImageDataTests`堆栈的白色区域中。命名为`car1`。
- en: Duplicate the image as many times as you like (the following script can handle
    up to 100 cars) and name each one as a sequence, `car2`, `car3`, and so on.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如您所愿复制图像（以下脚本可以处理多达100辆汽车），并按顺序命名每个，例如`car2`、`car3`等。
- en: Arguably, the correct *object-oriented* way to proceed would be to place some
    functions on the images and some in the card or stack script, but for performance
    reasons, we'll put everything in the stack script. Open the stack script.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 争论来说，正确的*面向对象*的方式是将一些函数放在图像上，一些放在卡片或堆栈脚本中，但出于性能原因，我们将一切放在堆栈脚本中。打开堆栈脚本。
- en: 'Add a line for the global variables we''ll need:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用于全局变量的行：
- en: '[PRE10]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We''ll add a Start/Stop button soon, which will call a function to toggle whether
    the cars are moving or not. Add the toggle function to the stack script:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们很快将添加一个启动/停止按钮，该按钮将调用一个函数来切换汽车是否移动。将切换函数添加到堆栈脚本中：
- en: '[PRE11]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `setSpeeds` handler, which is called by `startStopCars`, will initialize
    the `gSpeeds` variable with a random speed for each of the car images. It will
    also set the initial direction to zero as well as position the car at a known
    location in the white area (`200, 200` in this case). Add the `setSpeeds` handler
    to the stack script below the `startStopCars` handler:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由 `startStopCars` 调用的 `setSpeeds` 处理器将为每辆汽车图像初始化 `gSpeeds` 变量，并将初始方向设置为零，并将汽车定位在白色区域的一个已知位置（在本例中为
    `200, 200`）。将 `setSpeeds` 处理器添加到 `startStopCars` 处理器下面的堆栈脚本中：
- en: '[PRE12]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In the `moveCars` handler, shown in step 8, we''re going to look at the `gBackdropMaskData`
    variable to check whether the car is going to run into something solid. Add this
    `hitBarrier` function:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `moveCars` 处理器中，如第 8 步所示，我们将查看 `gBackdropMaskData` 变量以检查汽车是否会撞到坚固的物体。添加此 `hitBarrier`
    函数：
- en: '[PRE13]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `moveCars` handler is initially called by the `startStopCars` handler,
    and then, it calls itself after every two ticks until the `gMovingCars` variable
    is set to `false`. Type in the long `moveCars` handler into the stack script:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`moveCars` 处理器最初由 `startStopCars` 处理器调用，然后，每经过两个计时周期后，它会调用自己，直到 `gMovingCars`
    变量被设置为 `false`。将长的 `moveCars` 处理器输入到堆栈脚本中：'
- en: '[PRE14]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Collision avoidance**'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**避免碰撞**'
- en: Take a moment to look at the `moveCars` handler; what is it doing? You will
    no doubt have heard about collision detection; this is where you have code that
    recognizes when one object has collided with another object or a wall perhaps.
    You might as well trigger an explosion or a collision sound when that happens.
    For our example though, we actually don't want things to collide, as we want the
    cars to turn before they collide. For each car, up to 100 of them, we will look
    ahead of the car to check whether it collides with the edges of the course. If
    it's going to do so, we will change the direction that the car is heading toward,
    repeatedly, until a safe forward direction is found.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 抽取一段时间来查看 `moveCars` 处理器；它在做什么？你无疑已经听说过碰撞检测；这就是你拥有代码来识别一个物体与另一个物体或墙壁发生碰撞的地方。当这种情况发生时，你可以触发一个爆炸或碰撞声音。然而，对于我们的示例，我们实际上不希望发生碰撞，因为我们希望汽车在碰撞前转向。对于每辆汽车，最多
    100 辆，我们将查看汽车前方以检查它是否会撞到赛道的边缘。如果它会这样做，我们将反复改变汽车行驶的方向，直到找到一个安全的前进方向。
- en: 'Add a Start/Stop Cars button to the card window and set its script as:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在卡片窗口中添加一个启动/停止汽车按钮，并设置其脚本为：
- en: '[PRE15]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Select the backdrop image and choose **Send to Back** from the **Object** menu.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择背景图像，并从 **对象** 菜单中选择 **发送到后台**。
- en: It's a good idea to save it now!
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在保存它是个好主意！
- en: Click on the Run/Browse tool and then on the Start/Stop Cars button to see your
    cars drive around the interface. Here's how it looks like when 20 cars move about:![Time
    for action – making a racecar](img/image00277.jpeg)
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击运行/浏览工具，然后点击启动/停止汽车按钮，以查看你的汽车在界面周围行驶。这里有 20 辆汽车移动的样子：![行动时间 – 制作赛车](img/image00277.jpeg)
- en: Note that you can continue to point at the parts of the image you first loaded
    (the LiveCode logo in the preceding example) to see the swatch to the right changing
    color. Also, if you point to different U.S. states, the text in the `state` field
    you created changes.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，你可以继续指向你最初加载的图像的部分（前一个示例中的 LiveCode 标志）以查看右侧的色卡改变颜色。此外，如果你指向不同的美国州，你创建的 `state`
    字段中的文本会改变。
- en: '*What just happened?*'
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: Having already used **imageData** to implement a color picker and to act as
    multiple button areas, we went on to use the **maskData** of the image as a collision
    map. There is quite a bit of arithmetic behind making the cars move in intelligent
    ways, and you could go on to change some of the numbers to get different behavior
    from the cars or you could take a break and get ready to make a jigsaw puzzle!
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用 **imageData** 实现了颜色选择器，并作为多个按钮区域使用，然后继续使用图像的 **maskData** 作为碰撞图。让汽车以智能方式移动背后有很多算术，你可以改变一些数字以获得不同的汽车行为，或者你可以休息一下，准备制作一个拼图！
- en: Pop quiz – calculate this!
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答 – 计算这个！
- en: For the U.S. map, we only needed to simulate 50 buttons. If you make use of
    the red, green, and blue values, how many buttons could you simulate?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对于美国地图，我们只需要模拟 50 个按钮。如果你使用红色、绿色和蓝色值，你能模拟多少个按钮？
- en: One, enormous button
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个巨大的按钮
- en: 65,536 buttons
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 65,536 个按钮
- en: 16,777,216 buttons
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 16,777,216 个按钮
- en: 'Answer: 3'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 答案：3
- en: As with the discussion about *bits and bytes* (hey, I'm sure we weren't going
    to see these words for the rest of this chapter!), the red, green, and blue values
    combine to give us 2 to the power of 24 possible values. If you only used two
    of the colors, then the answer would have been 65,536.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就像关于*位和字节*的讨论一样（嘿，我确信我们不会在本章的其余部分看到这些词了！），红色、绿色和蓝色值组合起来给我们2的24次方可能的值。如果你只使用了两种颜色，那么答案将是65,536。
- en: The things we have tried so far in this chapter use techniques that would be
    useful in any LiveCode application and are not specific to mobile applications.
    You can try the stack you have constructed; it will work well on a mobile device
    with 20 cars driving around the screen! The color picker and states map work on
    a mobile when its screen is touched. However, these tests don't really make use
    of the mobile features.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们尝试的内容使用的技术在任何LiveCode应用中都很有用，并不特定于移动应用。你可以尝试你构建的堆栈；它将在屏幕上有20辆车行驶的移动设备上运行得很好！当触摸屏幕时，颜色选择器和状态图在移动设备上工作。然而，这些测试并没有真正利用到移动设备的功能。
- en: Making a jigsaw puzzle
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作拼图游戏
- en: The remainder of the chapter will build on the preceding information about `imageData`
    and will also take advantage of a few mobile device features. We will make a jigsaw
    puzzle app.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的剩余部分将基于关于`imageData`的前面信息，并利用一些移动设备的功能。我们将制作一个拼图游戏应用。
- en: Going to pieces…
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分解成碎片…
- en: The general technique we're going to use, is to take a set of PNGs that have
    a nice alpha channel in them (that creates the puzzle piece edges) and then we
    will replace the actual pixel data with an image of our own. The first thing we
    need then is some PNGs.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的一般技术是，取一组具有良好alpha通道的PNG图片（这创建了拼图块的边缘），然后我们将用我们自己的图片替换实际的像素数据。因此，我们首先需要一些PNG图片。
- en: If you want to make a commercial mobile application, either create your own
    puzzle shapes or buy a royalty free image. For prototyping, you could grab any
    image from the Web to get the basics going and then you could replace the images
    with higher quality ones that you have bought. Here, we are using a preview image
    from [http://depositphotos.com/](http://depositphotos.com/), which also sells
    higher quality versions.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要制作一个商业移动应用，要么创建你自己的拼图形状，要么购买一个免版税的图片。对于原型设计，你可以从网上抓取任何图片来开始基本操作，然后你可以用你购买的高质量图片替换它们。在这里，我们使用的是来自[http://depositphotos.com/](http://depositphotos.com/)的预览图片，它也销售高质量版本。
- en: When you do have high-quality versions, you may wish to create each puzzle piece,
    so that they touch against each other perfectly. Here, we're using a preview image,
    and we will select the inner part of each piece and create the PNGs from those.
    There will be small gaps between the pieces, but at least this way we can prepare
    the images we need quickly.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 当你拥有高质量版本时，你可能希望创建每个拼图块，以便它们完美地相互接触。在这里，我们使用预览图片，并将每个拼图块的内部部分选择出来，然后从这些部分创建PNG图片。拼图块之间会有小缝隙，但至少这样我们可以快速准备所需的图片。
- en: Time for action – creating the pieces and choosing an image
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手时间 – 创建拼图块和选择图片
- en: 'If you wish to follow along with the exact same image shown here, know that
    it was taken from the top-left section of the file present at:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望跟随这里显示的完全相同的图片，要知道它是从以下文件的上左部分拍摄的：
- en: '[http://static3.depositphotos.com/1004551/191/v/950/depositphotos_1914748-Jigsaw-puzzle-blank-templates.jpg](http://static3.depositphotos.com/1004551/191/v/950/depositphotos_1914748-Jigsaw-puzzle-blank-templates.jpg).'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[http://static3.depositphotos.com/1004551/191/v/950/depositphotos_1914748-Jigsaw-puzzle-blank-templates.jpg](http://static3.depositphotos.com/1004551/191/v/950/depositphotos_1914748-Jigsaw-puzzle-blank-templates.jpg)。'
- en: 'The image is shown here:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图片如下所示：
- en: '![Time for action – creating the pieces and choosing an image](img/image00278.jpeg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![动手时间 – 创建拼图块和选择图片](img/image00278.jpeg)'
- en: 'The following steps will help in creating the pieces and choosing an image:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助创建拼图块和选择图片：
- en: Make a new Mainstack of the size 1024 x 768 (or the size of your tablet device).
    Name the stack `jigsaw`, set the title to `Jigsaw Puzzle`, and save it.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个大小为1024 x 768（或你的平板设备大小）的新主堆栈。将堆栈命名为`jigsaw`，设置标题为`Jigsaw Puzzle`，并保存。
- en: Open the whole puzzle image in your image editor.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的图像编辑器中打开整个拼图图片。
- en: Use the **Magic Wand** tool to pick up the inner part of the upper-left piece
    of the puzzle.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**魔棒**工具选择拼图左上角拼图块的内部部分。
- en: Fill that with a color that makes it easy to spot any remaining gaps.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用一种颜色填充它，以便容易发现任何剩余的缝隙。
- en: Copy and paste into a new document (that has a transparent background) that
    is the size of the piece you copied.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将内容复制并粘贴到一个新的文档中（该文档具有透明背景，大小与复制的碎片相同）。
- en: Repair any gaps using the brush tool that is set to the same fill color.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用设置为相同填充颜色的画笔工具修复任何缺口。
- en: Save it as a PNG file(with Photoshop, that would be save it for Web and devices,
    24 bit, with transparency). Use a naming scheme that may help you identify the
    images easily. For example, `tlcorner.png`, `p1.png`, `trcorner.png`, and so on.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存为PNG文件（使用Photoshop，这将是在Web和设备上保存，24位，具有透明度）。使用可能有助于你轻松识别图片的命名方案。例如，`tlcorner.png`、`p1.png`、`trcorner.png`等等。
- en: Proceed through all the differently shaped areas. In the example image, there
    will be as few as 14 unique shapes. No need to save other pieces that are of the
    same shape and orientation as the ones you already have.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过所有不同形状的区域进行操作。在示例图片中，可能会有多达14种独特的形状。不需要保存与你已经拥有的形状和方向相同的其他碎片。
- en: The set of images will be similar to the ones shown in the following screenshot:![Time
    for action – creating the pieces and choosing an image](img/image00279.jpeg)
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 图片集将与以下屏幕截图中的类似：![操作时间 – 创建碎片和选择图片](img/image00279.jpeg)
- en: Import all the 14 images as **Control/Image**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有14张图片作为**Control/Image**导入。
- en: Lay out a puzzle that covers most of the card window. In the following screenshot,
    the puzzle was of 900 x 622 pixels with 11 x 8 pieces. Make duplicates of the
    middle piece images to fill in the whole puzzle. You can accurately place a piece
    after selecting it using the arrow keys on your keyboard.![Time for action – creating
    the pieces and choosing an image](img/image00280.jpeg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将拼图布局在覆盖大部分卡片窗口的区域。在下面的屏幕截图中，拼图大小为900 x 622像素，由11 x 8个碎片组成。通过选择键盘上的箭头键，你可以选择一个碎片后准确放置。![操作时间
    – 创建碎片和选择图片](img/image00280.jpeg)
- en: Name the images in a grid-like fashion. The top-left piece would be named `p
    1 1`, the top-right edge piece would be named `p 11 1` and the bottom-right piece
    would have the name `p 11 8`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以网格状方式命名图片。左上角的碎片将被命名为`p 1 1`，右上角的边缘碎片将被命名为`p 11 1`，而右下角的碎片将被命名为`p 11 8`。
- en: Select all the pieces and group them. Name the group `pieces`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择所有碎片并将它们分组。将组命名为`pieces`。
- en: 'Make a button with the name `fromcamera` and a label with the name `Take a
    Photo`. Set the button scripts to this:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`fromcamera`的按钮和一个名为`Take a Photo`的标签。将按钮脚本设置为以下内容：
- en: '[PRE16]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Set the buttons to get a drop shadow; use the options in the **Graphic Effects**
    pane of the **Inspector** palette.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮设置为获得阴影效果；使用**检查器**面板中的**图形效果**选项。
- en: 'Edit the card script and add these global variables and functions that will
    initialize the values that will be needed by the other functions we''ll make:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑卡片脚本并添加以下全局变量和函数，它们将初始化其他我们将制作的函数所需的价值：
- en: '[PRE17]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, add the `loadImage` handler, which the two buttons will call in order
    to get an image from the user''s camera or photo album:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`loadImage`处理程序，这两个按钮将调用它以从用户的相机或相册中获取图片：
- en: '[PRE18]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `makepuzzle` and `scatter` lines are commented out for now, so that you
    can test the functions so far.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makepuzzle`和`scatter`行目前被注释掉，这样你可以测试到目前为止的功能。'
- en: '*What just happened?*'
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: The puzzle pieces are now in place and are named in a way that we can take advantage
    of them later when we manipulate them. If you go to **Standalone Application Settings**
    and select **iOS** or **Android**, you can give the app a try.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图碎片现在已就位，并且以我们可以利用的方式命名。如果你转到**独立应用程序设置**并选择**iOS**或**Android**，你可以尝试该应用程序。
- en: Tip
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Setting up some test images**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**设置一些测试图片**'
- en: If you use the iPad Simulator, you won't be able to test getting an image from
    the camera, and at first, you will just have the default images in the photo library.
    To add your own photo, drag images from **Finder** to the Simulator window, and
    the image will be added to the Photos library. You can switch to the simulator
    Home screen to reselect the Jigsaw app using the *cmd* + *Shift* + *H* key combination.
    This way, you can add a few images to the library in order to select one as the
    picture for the puzzle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用iPad模拟器，你将无法测试从相机获取图片的功能，最初你将只有相册中的默认图片。要添加自己的照片，将图片从**Finder**拖动到模拟器窗口，图片将被添加到照片库中。你可以切换到模拟器的首页，使用*cmd*
    + *Shift* + *H*键组合重新选择拼图应用。这样，你可以添加一些图片到库中，以便选择一个作为拼图的图片。
- en: When LiveCode gets an image from the mobile device, both from the camera and
    the library or photo album, it places the picture as an image control that is
    the topmost object on the card. We don't need the image itself, just its `imageData`.
    In the `loadImage` handler, the image is made in the same size as the puzzle pieces
    group, `imageData` is stored in the global variable `originalimage`, and the image
    itself is deleted.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当LiveCode从移动设备获取图片时，无论是从相机还是从库或相册中获取，它都会将图片放置为一个图像控件，这是卡片上最顶层的对象。我们不需要图片本身，只需要它的`imageData`。在`loadImage`处理程序中，图片被制作成与拼图块组相同的大小，`imageData`存储在全局变量`originalimage`中，而图片本身则被删除。
- en: Next, we'll transfer the chosen picture to the puzzle pieces.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将选定的图片传输到拼图块上。
- en: Time for action – transferring imageData
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 转移imageData
- en: 'By setting the chosen image to be of the same width and height as the group
    that holds the puzzle pieces (that''s where the 900 and 662 numbers came from),
    it becomes possible for us to transfer the matching rectangle of data from the
    full image to the puzzle piece in question. The following steps will guide you
    in transferring imageData:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将选定的图像设置为与包含拼图块的组具有相同的宽度和高度（这就是900和662数字的来源），我们就可以将整个图像中匹配的矩形数据传输到相关的拼图块中。以下步骤将指导您传输imageData：
- en: 'Open the card script again. Add the `makepuzzle` handler:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开卡片脚本。添加`makepuzzle`处理程序：
- en: '[PRE19]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `makepuzzle` handler will go through each of the puzzle pieces and call
    another handler to do the transfer of data for that one piece. Here is the `makepiece`
    handler:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makepuzzle`处理程序将遍历每个拼图块并调用另一个处理程序来为该块传输数据。以下是`makepiece`处理程序：'
- en: '[PRE20]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the earlier `imageData` tests, we were only interested in one pixel at a
    time, but here, we want lots of rows of data. The arithmetic, *((y+dy-1) * puzzlewidth…*,
    and so on, quickly pull out a whole row of pixels at a time. These rows are built
    up into a new variable, `tempimage`, which is finally transferred into the actual
    puzzle piece.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在早期的`imageData`测试中，我们一次只对一个像素感兴趣，但在这里，我们想要很多行数据。算术运算，`*((y+dy-1) * puzzlewidth…*`，等等，可以快速一次提取一整行的像素。这些行被构建成一个新的变量`tempimage`，最终被传输到实际的拼图块中。
- en: 'After the pieces have their rectangle of `imageData`, we then need to move
    the pieces into random places, making the game ready for the user to play. This
    is done with a `scatter` handler:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在拼图块有了`imageData`的矩形之后，我们接下来需要将拼图块移动到随机位置，使游戏准备好供用户玩耍。这是通过一个`scatter`处理程序来完成的：
- en: '[PRE21]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The first thing that most jigsaw puzzle players do is they separate the *straight-edged*
    pieces. We can code things in a way so that their time is saved. We can employ
    a function that places the edge pieces away from the non-edge pieces. The `edgepiece`
    function (which is called from the preceding `scatter` handler) is this:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数拼图游戏玩家首先做的事情是分离*直边*拼图块。我们可以以节省他们时间的方式编写代码。我们可以使用一个函数将边缘拼图块放置在非边缘拼图块之外。从先前的`scatter`处理程序中调用的`edgepiece`函数如下：
- en: '[PRE22]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The name that we carefully set for each piece is checked to verify that the
    piece is either at the left, right, top, or bottom edge of the puzzle. In other
    words, it's a piece located at the outer edges of the puzzle. Scatter places the
    straight-edged pieces in the left half of the screen and the others in the right
    half of the screen, as shown here:![Time for action – transferring imageData](img/image00281.jpeg)
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们为每个拼图块精心设置的名称被检查以验证该拼图块是否位于拼图的左、右、上或下边缘。换句话说，它是一个位于拼图外边缘的拼图块。散布将直边拼图块放置在屏幕的左侧，其他拼图块则放置在屏幕的右侧，如图所示：![行动时间
    – 转移imageData](img/image00281.jpeg)
- en: 'The start of the `makepuzzle` handler calls a `resetpuzzle` handler that is
    used to make sure that the pieces are back where they started, ready for a new
    picture to load. This is achieved when you use a property variable on each piece
    named `myloc`, which records the initial location of the piece. Here''s the `resetpuzzle`
    handler:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`makepuzzle`处理程序的开始调用一个`resetpuzzle`处理程序，该处理程序用于确保拼图块回到起始位置，准备好加载新图片。这是通过在每个拼图块上使用名为`myloc`的属性变量来实现的，它记录了拼图块的初始位置。以下是`resetpuzzle`处理程序：'
- en: '[PRE23]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: You can see that if `myloc` is not already set, then the piece must be in its
    start position, and so, the `resetpuzzle` handler goes ahead and records that
    location in the `myloc` property.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以看到，如果`myloc`尚未设置，则拼图块必须在起始位置，因此`resetpuzzle`处理程序会继续并在`myloc`属性中记录该位置。
- en: Uncomment the lines at step 17 of *Time for Action - creating the pieces and
    choosing an image* (`makepuzzle` and scatter lines) and try another test of the
    app. You should now be able to choose a picture and see it in the spread out puzzle
    pieces. Hopefully, you will see something like this:![Time for action – transferring
    imageData](img/image00282.jpeg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消注释在*行动时间 - 创建拼图块和选择图像*步骤17的行（`makepuzzle`和scatter行）并尝试再次测试应用程序。现在你应该能够选择一张图片，并在展开的拼图块中看到它。希望你会看到类似这样的东西：![行动时间
    – 转移imageData](img/image00282.jpeg)
- en: '*What just happened?*'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: As mentioned in the preceding section, the right arithmetic made it relatively
    easy for us to extract a desired rectangle of `imageData` from a larger image,
    and store it in a smaller image that was the size of that rectangle. However,
    there's one bit of magic that wasn't pointed out, the puzzle kept its shape! Even
    though we had completely replaced `imageData` for the image, how did this happen?
    Setting `imageData` doesn't interfere with `alphaData` of the image. The PNGs
    that we imported kept their original alpha channel and so still had the same shape,
    but just a different image.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，正确的算术运算使得我们从大图中提取所需矩形`imageData`相对容易，并将其存储在大小与该矩形相同的小图像中。然而，有一个魔法般的细节并未被指出，即拼图保持了其形状！尽管我们已经完全替换了图像的`imageData`，这是如何发生的呢？设置`imageData`不会干扰图像的`alphaData`。我们导入的PNG图像保留了其原始的alpha通道，因此仍然保持了相同的形状，只是图像不同。
- en: Adding interactivity
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加交互性
- en: Our jigsaw puzzle is ready to be shipped! Well, other than the fact it has no
    interactivity at all! Let's add some.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的拼图游戏已经准备好发货了！好吧，除了它完全没有交互性之外！让我们添加一些。
- en: Time for action – setting up touch events
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 设置触摸事件
- en: The handlers so far have been in the card script, the plan being to have different
    cards with different types of puzzle. The interactivity handlers can be placed
    in the stack script available for all the cards.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的处理程序都在卡片脚本中，计划是让不同的卡片有不同的拼图类型。交互处理程序可以放在所有卡片都适用的堆栈脚本中。
- en: 'Open the stack script. There is only one of the global variables that we will
    also need in the stack script, but there are a couple of initializing items we
    need to cover. Start the stack script with these lines:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开堆栈脚本。在堆栈脚本中，我们还需要一个全局变量，但有一些初始化项需要处理。用以下这些行开始堆栈脚本：
- en: '[PRE24]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `preopenstack` handler checks whether the app is on iPhone and requests
    that the device's native resolution be used. This will make sure that Retina displays
    show the best quality. The `compositorType` being set to `"Static OpenGL"` will
    help performance.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`preopenstack`处理程序检查应用程序是否在iPhone上，并请求使用设备的原生分辨率。这将确保Retina显示屏显示最佳质量。将`compositorType`设置为`"Static
    OpenGL"`将有助于性能。'
- en: 'The interactivity we''ll use will make use of touch events. Each touch comes
    with an associated ID value. Here is the handler that detects the start of a touch
    event:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用的交互性将利用触摸事件。每个触摸都带有相关的ID值。以下是检测触摸事件开始的处理器：
- en: '[PRE25]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The check of the target name is a quick way to make sure that we don't drag
    anything around except for the puzzle pieces. When a piece is touched, we use
    the `relayerGroupedControls` and layer functions to make that piece appear above
    the other pieces.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目标名称的检查是一种快速的方法，以确保我们除了拼图块之外不会拖动任何东西。当拼图块被触摸时，我们使用`relayerGroupedControls`和层函数使该拼图块出现在其他拼图块之上。
- en: Do you remember how we added a dropshadow to the two buttons? Aside from making
    them look nicer, we make use of it here too. By adding the same `dropShadow` to
    the puzzle piece, we create the illusion that the piece is floating above the
    screen.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还记得我们是如何给两个按钮添加阴影效果的吗？除了使它们看起来更美观之外，我们在这里也使用了它。通过给拼图块添加相同的`dropShadow`，我们创造了一种错觉，即拼图块似乎漂浮在屏幕上方。
- en: 'Next thing to watch for is movement, which we can do with the `touchMove` event:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来要注意的是运动，我们可以通过`touchMove`事件来实现：
- en: '[PRE26]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Again, there's a quick double check that you can perform to make sure that it's
    a puzzle piece; otherwise, it's a simple case of setting the location of the piece
    to the location of the user's finger.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，有一个快速的双重检查，以确保它是拼图块；如果不是，那么就是一个简单的将拼图块位置设置为用户手指位置的情况。
- en: 'When the user releases the piece, we check whether it''s near its starting
    place, and if it is near, we move the piece into its place and remove the dropShadow
    effect:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户释放拼图块时，我们检查它是否靠近其起始位置，如果是，我们将拼图块移动到其位置并移除dropShadow效果：
- en: '[PRE27]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This is the `checkdistance` handler and a `distance` function that it calls:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这是`checkdistance`处理程序和它调用的`distance`函数：
- en: '[PRE28]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `distance` function is based on the **Pythagorean theorem**, returning the
    number of pixels between the puzzle piece and its original `myloc` value. `snapdistance`
    is the global variable that is used to determine whether the piece is close enough
    to its starting place to be considered on target.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`distance`函数基于**勾股定理**，返回拼图块与其原始`myloc`值之间的像素数。`snapdistance`是一个全局变量，用于确定拼图块是否足够接近其起始位置，从而被认为是目标位置。'
- en: The `move` line uses LiveCode's move function, which animates the piece into
    its place.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`move`行使用LiveCode的移动函数，将拼图块动画化到其位置。'
- en: 'One last thing, let''s check whether the puzzle is complete. Add this handler
    to the stack script:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一点，让我们检查一下拼图是否完成。将以下处理程序添加到堆栈脚本中：
- en: '[PRE29]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '*What just happened?*'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: The jigsaw puzzle should fully work now. Something that you can't easily guess
    from the touch functions we added is the fact that it works with multitouch. You
    can drag on up to 10 pieces at once (or whatever the multitouch limit is for your
    device). Here, each piece will show a drop shadow and all the pieces will animate
    into their place when you let go of them.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 拼图现在应该完全工作。从我们添加的触摸功能中难以轻易猜测的是，它支持多点触控。你可以同时拖动多达10个拼图块（或你的设备多点触控的限制）。在这里，每个拼图块都会显示一个阴影，当你放手时，所有拼图块都会动画化到它们的位置。
- en: Have a go hero – one for the kids
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄之旅——这是为孩子们准备的
- en: Functions that relate to the puzzle itself are in the card script. Try making
    a new card that has bigger puzzle pieces and a higher value for `snapdistance`
    (the higher the value, the easier it is to get a piece into place). You could
    make an opening card for the stack that has a set of difficulty level buttons,
    one of which would jump to the easier puzzle. This would be ideal for younger
    players.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与拼图本身相关的函数位于卡片脚本中。尝试制作一张新卡片，其中包含更大的拼图块和更高的`snapdistance`值（值越高，将拼图块放置到位就越容易）。你可以为堆栈制作一张包含难度级别按钮的起始卡，其中一个按钮会跳转到更简单的拼图。这对年轻玩家来说将是理想的。
- en: Adding some guide graphics will help players know where the edges of the finished
    puzzle are, and for simpler difficulty levels, you can even include outlines of
    the individual puzzle pieces.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一些引导图形将帮助玩家知道完成拼图的边缘在哪里，对于更简单的难度级别，甚至可以包括单个拼图块的轮廓。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: There are many other possibilities when it comes to making use of `imageData`
    in paint programs, image processing applications, and so on, and it is still the
    same as in the preceding examples. In this chapter, we went over and understood
    the format of `imageData`, `alphaData`, and `maskData` and how to copy areas of
    `imageData` from one image to another. Reading individual pixels of an image and
    finding novel uses for the pixel values was covered here as well. We also saw
    how to use multitouch interactivity to bring those chunks of `imageData` to life
    in the form of a jigsaw puzzle.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用`imageData`于绘图程序、图像处理应用等场景时，有许多其他可能性，并且与前面的示例相同。在本章中，我们回顾并理解了`imageData`、`alphaData`和`maskData`的格式，以及如何将`imageData`的一个区域复制到另一个图像中。这里还涵盖了读取图像的单独像素并寻找像素值的新用途。我们还看到了如何使用多点触控交互，将这些`imageData`块以拼图的形式激活。
- en: Working with graphics can be great fun, hopefully, this will just be the start
    of what you will create. However, in the next chapter, we'll get back to making
    a utility application. Sigh…
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与图形一起工作可以非常有趣，希望这仅仅是您将要创造的起点。然而，在下一章中，我们将回到制作实用应用程序。唉……
