- en: Chapter 2. Database Design Concepts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章 数据库设计概念
- en: In this chapter, you will learn about SQLite's database concepts. Just as with
    most databases, SQLite too can add data using the SQL command called `INSERT`.
    It can also modify data using the `UPDATE` command and remove data using the `DELETE`
    command. It can also retrieve data using the `SELECT` command.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习SQLite的数据库概念。就像大多数数据库一样，SQLite也可以使用名为`INSERT`的SQL命令来添加数据。它还可以使用`UPDATE`命令修改数据，使用`DELETE`命令删除数据。它还可以使用`SELECT`命令检索数据。
- en: These four commands form the base line for any SQL database RDMS in the market.
    This set of commands manipulate the data, and this type of searching is called
    a **query**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这四个命令构成了市场上任何SQL数据库RDMBS的基础。这组命令操作数据，这种类型的搜索称为**查询**。
- en: Database essentials
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库基础知识
- en: This persistent and structured way of storing data is simply called a database,
    and the data itself is stored using tables. Each table consists of columns and
    rows, with a look and feel similar to **Microsoft Excel**.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种持久和结构化的数据存储方式简单地称为数据库，数据本身是使用表格存储的。每个表格由列和行组成，其外观和感觉类似于**Microsoft Excel**。
- en: SQLite is based on the C language and a related API (RDBMS) in the market. The
    C language, for example, is easy to understand and is based on the fundamentals
    of database design with RDBMS. However, learning the actual API will benefit your
    skills and understanding.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite基于C语言和市场上的相关API（RDBMS）。例如，C语言易于理解，并且基于RDBMS的数据库设计基础。然而，学习实际的API将有助于提升你的技能和理解。
- en: In order to understand the API, you will have to learn the components that make
    up the database to improve your knowledge. Understanding data structures, SQL
    transactions, concurrency, and data-locking mechanisms, and creating good optimized
    queries will help you design great database systems.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解API，你必须学习构成数据库的组件，以提升你的知识。理解数据结构、SQL事务、并发性和数据锁定机制，以及创建优化的查询将有助于你设计出色的数据库系统。
- en: Lastly, you need to put this understanding into some software code for the app
    you write and see how it is integrated and executed. The API language extension
    will be discussed further in this chapter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你需要将这种理解应用到你所编写的应用程序的软件代码中，看看它是如何集成和执行的。本章将进一步讨论API语言扩展。
- en: The design objective of SQLite was to keep the role of administration and operation
    easy to use and simple to manage. SQLite is **ACID** (**atomicity**, **consistency**,
    **isolation**, and **durability**) compliant, and is fully transactional using
    **T-SQL**.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的设计目标是使管理和操作简单易用，易于管理。SQLite是**ACID**（**原子性**、**一致性**、**隔离性**和**持久性**）兼容的，并且完全使用**T-SQL**进行事务处理。
- en: As a part of the design, the SQLite database has a variety of datatypes like
    most databases. One of the types is the `INTEGER` type that has 64 bit numeric
    values. This database uses 64 bit numeric values and the data is stored in 1,
    2, 3, 4, 5, 6, or 8 bytes. The `TEXT` type encoding uses UTF-8 for storing it
    in the database. The `BLOB` datatype can be stored directly, with a default size
    of 1,000,000,000 bytes.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 作为设计的一部分，SQLite数据库具有多种数据类型，就像大多数数据库一样。其中一种类型是`INTEGER`类型，它具有64位数值。这个数据库使用64位数值，数据存储在1、2、3、4、5、6或8字节中。`TEXT`类型编码使用UTF-8在数据库中存储。`BLOB`数据类型可以直接存储，默认大小为1,000,000,000字节。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: SQLite also uses the `REAL` type, which is a 64 bit floating point value, and
    there is the standard `NULL` value as well. The `REAL` type will be applied to
    the `FLOAT`, `DOUBLE`, and `REAL` datatypes. The `TEXT` type applies to the `NCHAR`,
    `NVARCHAR`, `TEXT`, and `VARCHAR` datatypes. The `NUMERIC` type applies to `DATE`,
    `DATETIME`, and `BOOLEAN`. SQLite also uses **CRUD** (**Create, Read**, **Update**,
    and **Delete**), and this database is *not* case sensitive.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite还使用`REAL`类型，它是一个64位浮点值，同时也有标准的`NULL`值。`REAL`类型将应用于`FLOAT`、`DOUBLE`和`REAL`数据类型。`TEXT`类型适用于`NCHAR`、`NVARCHAR`、`TEXT`和`VARCHAR`数据类型。`NUMERIC`类型适用于`DATE`、`DATETIME`和`BOOLEAN`。SQLite还使用**CRUD**（**创建**、**读取**、**更新**和**删除**），并且这个数据库**不区分大小写**。
- en: 'The statements are shown as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 语句如下所示：
- en: 'The `CREATE` statement is used to create new tables in the SQLite database.
    The basic syntax and a simple example of `CREATE TABLE` is shown here. The `CREATE
    TABLE` statement has a database name that is fixed. It is followed by a table
    name, which has a start and close bracket. Within this statement, there is a list
    of column(s) to be created, starting with their names and datatypes, as shown
    in the following:'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE`语句用于在SQLite数据库中创建新表。这里显示了`CREATE TABLE`的基本语法和简单示例。`CREATE TABLE`语句有一个固定的数据库名。它后面跟着一个表名，用括号括起来。在这个语句中，有一个要创建的列（s）的列表，从它们的名称和数据类型开始，如下所示：'
- en: '`CREATE table database-name. table-name( column1 datatype, column2 datatype,
    column3, datatype, PRIMARY KEY column1);`'
  id: totrans-14
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CREATE table database-name. table-name( column1 datatype, column2 datatype,
    column3, datatype, PRIMARY KEY column1);`'
- en: 'The `INSERT` statement will have a table name followed by a set of columns
    on the first half. The second half will have the variables, where the data coming
    from that will be inserted into the table. It is important to ensure that the
    programmer uses the same datatype as the column created; otherwise, there will
    be an error or a warning:'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT`语句将在前半部分有一组列，后面跟着一个表名。后半部分将有变量，其中来自这些变量的数据将被插入到表中。确保程序员使用与创建的列相同的数据类型很重要；否则，将出现错误或警告：'
- en: '`INSERT into table-name(column1,column2,column3) VALUES(variable1,variable2,variable3);`'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INSERT into table-name(column1,column2,column3) VALUES(variable1,variable2,variable3);`'
- en: 'The `UPDATE` statement is used to update records or rows within a table. The
    `UPDATE` statement will have a table name, followed by a set of columns to update
    on the left-hand side, and some data variables on the right-hand side, as shown
    in the following:'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE`语句用于更新表中的记录或行。`UPDATE`语句将有一个表名，后面跟着左侧要更新的列的集合和一些数据变量，如下所示：'
- en: '`UPDATE table-name SET column1=variable1, column2=variable2, column3=variable3)
    [where variable4 = 10];`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UPDATE table-name SET column1=variable1, column2=variable2, column3=variable3)
    [where variable4 = 10];`'
- en: 'The `SELECT` statement is used to select information, records, or rows within
    a table. This is shown in *Figure 7*. The `SELECT` statement will have a set of
    columns on the first half, followed by a table name and a condition, as shown
    here:'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT`语句用于从表中选择信息、记录或行。这如图7所示。`SELECT`语句将在前半部分有一组列，后面跟着一个表名和一个条件，如下所示：'
- en: '`SELECT column1, column2, column3 FROM table-name WHERE column1 > 10;`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SELECT column1, column2, column3 FROM table-name WHERE column1 > 10;`'
- en: 'The `DELETE` statement is used to delete records or rows within a table. This
    is shown here. The `DELETE` statement will have a set of columns on the first
    half, followed by a table and any condition:'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`语句用于从表中删除记录或行。这在此处显示。`DELETE`语句将在前半部分有一组列，后面跟着一个表和任何条件：'
- en: '`DELETE from table-name where column1 >10;`'
  id: totrans-22
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE from table-name where column1 >10;`'
- en: The extension and core APIs are the sections that form the API made with the
    C language. The core database carries out functions such as processing SQL syntax
    and connecting to the database. Other tasks, such as error trapping and string
    formatting, are also dealt with the core API. As mentioned earlier, the extension
    API allows programmers to add or extend the current API with a new functionality
    that will add the functionality that does not exist presently or as a current
    definition with the SQLite program.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展和核心API是构成用C语言制作的API的部分。核心数据库执行处理SQL语法和连接到数据库等功能。其他任务，如错误捕获和字符串格式化，也由核心API处理。如前所述，扩展API允许程序员通过添加或扩展当前API的新功能来添加目前不存在或作为SQLite程序当前定义的功能。
- en: Although data structures are outlined, as mentioned previously, using the tokenizer
    or parser, their importance is reduced, since coders are interested in other parts,
    such as the connectivity syntax, parameters, or current functions, and not the
    internals of the products. In order to write some good code, programmers must
    be clued up on SQLite locks, transactions, and the API itself.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然数据结构已经概述，如前所述，使用标记化器或解析器，它们的重要性降低，因为编码者对其他部分更感兴趣，如连接语法、参数或当前函数，而不是产品的内部。为了编写一些好的代码，程序员必须了解SQLite锁、事务和API本身。
- en: Although not a part of the API itself, the **pager** and **B tree** parts of
    the SQLite system contribute heavily as a part of locking and transactions mechanisms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然不是API本身的一部分，但SQLite系统的**分页器**和**B树**部分在锁定和事务机制中作为重要部分做出了贡献。
- en: 'There are eight methods and two objects that make up the C/C++ interface part
    of the SQLite database system. The two objects are: `sqlite3`, which is the actual
    database connection object, and `sqlite3_stmt`, which is the `prepare` statement
    object.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 有八种方法和两种对象构成了SQLite数据库系统的C/C++接口部分。这两个对象是：`sqlite3`，这是实际的数据库连接对象，以及`sqlite3_stmt`，这是`prepare`语句对象。
- en: 'The eight methods comprise the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 八种方法包括以下内容：
- en: '`sqlite3_exec()`: This is a wrapper function'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_exec()`: 这是一个包装函数'
- en: '`sqlite3_close()`: This is a destructor for `sqlite3`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_close()`: 这是`sqlite3`的析构函数'
- en: '`sqlite3_finalize()`:This is a destructor for `sqlite3_stmt`'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_finalize()`: 这是`sqlite3_stmt`的析构函数'
- en: '`sqlite3_column()`: This holds the column values for `sqlite3_stmt`'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_column()`: 这个接口保存`sqlite3_stmt`的列值'
- en: '`sqlite3_step()`:This allows you to step to the next result row and is an advancement
    of `sqlite3_stmt`'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_step()`: 这允许你移动到下一个结果行，是`sqlite3_stmt`的改进。'
- en: '`sqlite3_bind()`: This is how SQL is broken down into parameters from the stored
    application data'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_bind()`: 这是将SQL从存储的应用程序数据中分解成参数的方式'
- en: '`sqlite3_prepare()`:This is a part of the constructor for `sqlite3_stmt`, where
    byte code is produced from SQL that has been compiled, so it can carry out the
    SQL statements (`SELECT`, `UPDATE`)'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_prepare()`: 这是`sqlite3_stmt`构造函数的一部分，其中从编译后的SQL生成字节码，以便执行SQL语句（`SELECT`，`UPDATE`）'
- en: '`sqlite3_open()`: This is the constructor of `sqlite3`, which allows a connection
    to an existing or a new SQLite database'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_open()`: 这是`sqlite3`的构造函数，它允许连接到现有的或新的SQLite数据库'
- en: Initially, SQLite was easy to learn and had only five C/C++ interfaces, but
    now, it has grown in size, functionality, and interfaces to over 200 APIs. It
    can be daunting to use 200 APIs, but SQLite has been designed in such a way that
    you only use the API, but now, it has grown in size and function.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，SQLite易于学习，只有五个C/C++接口，但现在，它已经增长到超过200个API的大小、功能和接口。使用200个API可能会让人感到畏惧，但SQLite的设计方式使得你只需使用API，但现在，它已经增长到更大的规模和功能。
- en: 'These six core interfaces, once mastered, will give programmers a great understanding
    of SQLite. They are listed here:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这六个核心接口一旦掌握，将使程序员对SQLite有更深入的理解。它们在此列出：
- en: '`SQLite3_open()`: This function makes a connection to the SQLite database and,
    once successful, a database connection object will be returned. None of the other
    interfaces will be available until the `SQLite3_open()` interface has been set
    up. They require a starting point, or a reference to a database, and a database
    connection object.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_open()`: 这个函数建立与SQLite数据库的连接，一旦成功，将返回一个数据库连接对象。其他接口在`SQLite3_open()`接口设置之前将不可用。它们需要一个起点，或对数据库的引用，以及一个数据库连接对象。'
- en: '`SQLite3_prepare()`: This function will convert and set up SQL statements into
    a formatted object, and the output will be a pointer that will be stored in reference
    to that object. In order to progress, this interface requires a database connection
    object produced by the `SQLite3_open()` function.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_prepare()`: 这个函数将SQL语句转换并设置成格式化的对象，输出将是一个指针，该指针将存储对该对象的引用。为了继续前进，这个接口需要一个由`SQLite3_open()`函数产生的数据库连接对象。'
- en: '`SQLite3_column()`: This interface does not interrogate the SQL, it just produces
    a prepared statement. This interface is now not the preferred choice for new applications,
    but the alternative `SQLite3_prepare_V2()` interface must be used.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_column()`: 这个接口不查询SQL，它只是生成一个预编译语句。这个接口现在不再是新应用的优先选择，但必须使用替代的`SQLite3_prepare_V2()`接口。'
- en: '`SQLite3_step()`: This interface will look at the prepared statement as set
    up by the `SQLite3_prepare()` function and will return a single column from the
    current record set. This is not purely a function, but a placeholder for the type
    of functions that return values with different datatypes. These form a part of
    the results set. There are other functions that are a part of the `sqlite3_column()`
    setup, and they are, `sqlite3_column_blob()`, `sqlite3_column_bytes()`, `sqlite3_column_bytes16()`,
    `sqlite3_column_count()`, `sqlite3_column_double()`, `sqlite3_column_int()`, `sqlite3_column_int64()`,
    `sqlite3_column_text()`, `sqlite3_column_type()`, and `sqlite3_column_value()`.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_step()`: 这个接口将查看由 `SQLite3_prepare()` 函数设置的预处理语句，并从当前记录集中返回一个单列。这不仅仅是一个函数，而是用于返回不同数据类型值的函数类型的占位符。这些构成了结果集的一部分。还有其他一些是
    `sqlite3_column()` 设置的一部分，它们是：`sqlite3_column_blob()`、`sqlite3_column_bytes()`、`sqlite3_column_bytes16()`、`sqlite3_column_count()`、`sqlite3_column_double()`、`sqlite3_column_int()`、`sqlite3_column_int64()`、`sqlite3_column_text()`、`sqlite3_column_type()`
    和 `sqlite3_column_value()`。'
- en: '`SQLite3_finalize()`: This function is the interface that destroys the prepared
    statement to stop any memory leaks in the system.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_finalize()`: 这个函数是销毁预处理语句的接口，以防止系统中的内存泄漏。'
- en: '`SQLite3_close()`: This interface will shut any database connection and prepared
    statements before closing or ceasing operations.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SQLite3_close()`: 这个接口将在关闭或停止操作之前关闭任何数据库连接和预处理语句。'
- en: There are other routines, such as `sqlite3_bind()` and `sqlite3_reset()`, that
    enable prior statements to be used again and again. Usually, statements are created,
    prepared, and destroyed once, but the aforementioned routines can be used at multiple
    instances.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他一些例程，如 `sqlite3_bind()` 和 `sqlite3_reset()`，允许重复使用先前语句。通常，语句只创建、准备和销毁一次，但上述例程可以在多个实例中使用。
- en: SQLite has the `sqlite3_config()` interface that is first selected before any
    connections to the database are initiated. This interface will have the ability
    to set global changes for the database. It can also allocate memory, set up allocators
    for real-time embedded systems, and page caching for a predefined application
    usage. It can also make adjustments for different treading models.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 有一个 `sqlite3_config()` 接口，在发起任何数据库连接之前首先被选择。这个接口将能够设置数据库的全局更改。它还可以分配内存，为实时嵌入式系统设置分配器，并为预定义的应用程序使用设置页面缓存。它还可以对不同线程模型进行调整。
- en: This database system is flexible, and using `sqlite3_create_collation()`, `sqlite3_create_function()`,
    `sqlite3_create_module()`, and `sqlite3_vfs_register()` functions will allow the
    SQLite system to have a new proprietary functionality on the RDBMS. For example,
    the `sql_create_function()` function will create additional functionality for
    aggregate or scalar purposes. These are `sqlite3_agreegate_context()`, `sqlite3_result()`,
    `sqlite3_user_data()`, and `sqlite3_value()`.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这个数据库系统是灵活的，使用 `sqlite3_create_collation()`、`sqlite3_create_function()`、`sqlite3_create_module()`
    和 `sqlite3_vfs_register()` 函数将允许 SQLite 系统在 RDBMS 上拥有新的专有功能。例如，`sql_create_function()`
    函数将为聚合或标量目的创建额外的功能。这些是 `sqlite3_aggregate_context()`、`sqlite3_result()`、`sqlite3_user_data()`
    和 `sqlite3_value()`。
- en: These are the standard built-in functionalities of the SQLite system that prove
    how flexible the system can be to programmers. It is this flexibility, together
    with the technology that has helped it grow and cultivate to a place where it
    has become the best SQL database for mobiles today.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 SQLite 系统的标准内置功能，证明了该系统对程序员来说是多么灵活。正是这种灵活性，加上帮助它成长和发展的技术，使得它成为了今天最好的移动 SQL
    数据库。
- en: In addition, there are many other interfaces and functions that are too many
    to include in this book. They can be found under the C/C++ interface specification
    of this product.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多其他接口和函数，太多以至于无法包含在这本书中。它们可以在该产品的 C/C++ 接口规范下找到。
- en: SQLite, by default, will do most of the tasks required by programmers, users,
    or DBAs. Programmers are always looking to go beyond the normal bounds of the
    relational database system, or take advantage of these extensions to fulfill their
    solution requirements.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite 将完成程序员、用户或 DBA 所需的大部分任务。程序员总是寻求超越关系型数据库系统的正常界限，或者利用这些扩展来满足他们的解决方案需求。
- en: Reasons for using SQLite
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite 的原因
- en: 'There are many features that make SQLite a great database for mobile technologies.
    For example, there is no administration or configuration involved, the transactions
    are atomic, the database is self-contained in a single cross-platform file, and
    it holds advanced features, such as table expressions and partial indexes. The
    reasons for using SQLite are listed here:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite拥有许多使其成为移动技术优秀数据库的特点。例如，无需管理或配置，事务是原子的，数据库包含在一个单一的跨平台文件中，并且具有高级功能，如表表达式和部分索引。使用SQLite的原因在此列出：
- en: It has a small, versatile, and easy-to-use API. It is very standard-compliant
    and is written using the ANSI-C compliant. There are no external dependencies
    on any external programs or services, and the code is well commented. The source
    code is in the public domain and has a standalone **CLI** (**command-line interface**)
    at its disposal. It is cross-platform compliant, works with Mac, Linux, BSD, Android,
    Solaris, VxWorks, and Windows (WinCE, Win32, WinRT).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个小型、多功能且易于使用的API。它非常符合标准，并使用符合ANSI-C的代码编写。没有对外部程序或服务的依赖，代码注释良好。源代码属于公共领域，并提供了独立的**CLI**（**命令行界面**）。它是跨平台兼容的，与Mac、Linux、BSD、Android、Solaris、VxWorks和Windows（WinCE、Win32、WinRT）兼容。
- en: Its code footprint is very small, less than 500 kB when configured. The amount
    of application range that uses this database is huge. Almost all the products
    can have or have the need for a database that SQLite can handle.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 它的代码占用空间非常小，配置时小于500 kB。使用此数据库的应用程序范围非常广泛。几乎所有的产品都可以拥有或需要SQLite可以处理的数据库。
- en: It may not have all the bells and whistles of an enterprise system, but it is
    very flexible and easily available. SQLite is used by a variety of companies such
    as Adobe, Dropbox, Skype, and many more users.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 它可能没有企业系统所有的功能，但它非常灵活且易于获取。Adobe、Dropbox、Skype等许多公司都使用SQLite。
- en: SQLite is tested independently with its own test facilities and criteria. There
    are tests for memory usage, crash and power loss, fuzz tests boundary value and
    disable optimization tests, regression tests, and behavior checks among others.
    The test harnesses are also independently developed and verified.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite使用自己的测试设施和标准独立进行测试。有针对内存使用、崩溃和断电、模糊测试边界值和禁用优化测试、回归测试和行为检查等的测试。测试工具也是独立开发和验证的。
- en: The testing process for SQLite is well tested and matured, and the TCL tests
    are built using the TCL Scripting language. The test harnesses are made using
    the C code that creates the TCL interface. There are over 800 files of test scripts
    that hold over 10 gigabytes of data and over 30,000 test cases.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的测试过程经过充分测试和成熟，TCL测试使用TCL脚本语言构建。测试工具使用创建TCL界面的C代码制作。有超过800个测试脚本文件，包含超过10
    GB的数据和超过30,000个测试用例。
- en: There are also SQL logic tests that run SQL statements against other database
    engines, such as SQL Server, PostgreSQL, Oracle, and SQLite itself. These form
    a part of the SLT (SQL Logic Test) that runs over 7 million queries and 1 gigabyte
    of test data as a part of the testing load.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 还有针对SQL逻辑的测试，这些测试将SQL语句针对其他数据库引擎运行，例如SQL Server、PostgreSQL、Oracle和SQLite本身。这些构成了SLT（SQL逻辑测试）的一部分，该测试运行超过700万个查询和1GB的测试数据，作为测试负载的一部分。
- en: Also, there are many types of stress and performance testing, including anomaly
    tests, which include the behavior of SQLite on a variety of checks and see how
    it performs when errors occur. All the tests are run on all the platforms that
    SQLite works with. There is a subset of testing scripts that are used as a quick
    test; however, over 200,000 test cases—enough to capture any errors, or misfit
    code—can still be executed quickly.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有许多类型的压力和性能测试，包括异常测试，这些测试包括对SQLite在各种检查中的行为进行测试，并查看错误发生时的表现。所有测试都在SQLite支持的所有平台上运行。存在一个测试脚本的子集，用作快速测试；然而，仍有超过200,000个测试用例——足以捕获任何错误或不适配的代码——可以快速执行。
- en: There are also tests for checking the memory usage that look at memory allocation
    and the use of the `malloc()` function. All the SQL databases use the `malloc()`
    function to allocate and release memory. Since SQLite is heavily used in embedded
    systems, it is required to handle errors in a graceful manner.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 也有用于检查内存使用的测试，这些测试会查看内存分配和`malloc()`函数的使用情况。所有SQL数据库都使用`malloc()`函数来分配和释放内存。由于SQLite在嵌入式系统中被大量使用，因此需要优雅地处理错误。
- en: I/O testing is carried out to ensure that I/O errors are handled and dealt with
    properly. These issues maybe with regard to network errors, configuration, disk
    issues, or permissions. Errors are created to see their effects and to see how
    the software handles them.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 进行I/O测试以确保正确处理和解决I/O错误。这些问题可能与网络错误、配置、磁盘问题或权限有关。创建错误以观察其影响以及软件如何处理它们。
- en: A **virtual file system** (**VFS**) is also used to simulate the database crashing
    as part of the testing procedures. There are also simulations using power failures,
    so any measurement can be recorded. The crash test processes are completed separately.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 使用虚拟文件系统（**VFS**）来模拟数据库崩溃也是测试程序的一部分。还有使用电力故障的模拟，以便记录任何测量数据。崩溃测试过程是单独完成的。
- en: There are also fuzz tests that take care to see that SQLite works with odd and
    different inputs and all the results are checked. Processes are spawned and the
    VFS is used to simulate crashes. In addition to the standard fuzz test, there
    are fuzz tests for SQL that look at the syntax and inputting to the database to
    check the responses and results. These form a part of the TCL testing, and there
    are over 100,000 fuzz tests. All the results are recorded and analyzed.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一些模糊测试，以确保SQLite能够处理奇数和不同的输入，并且所有结果都经过检查。会启动进程并使用VFS来模拟崩溃。除了标准的模糊测试外，还有针对SQL的模糊测试，检查数据库的语法和输入，以检查响应和结果。这些构成了TCL测试的一部分，并且有超过10万个模糊测试。所有结果都被记录和分析。
- en: All branch tests for this database are 100% tested and measured. There are also
    measurements and tests to ensure that any automatic resource leaks are detected,
    noted, and dealt with. Usually, resource leaks occur when, in certain circumstances,
    resources are allocated by the `malloc()` function; but they are not released
    when other processes may require the same resource or some form of shared resource.
    When the resource is not freed or released as instructed, then it leads to resource
    leakage.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有针对此数据库的分支测试都已达到100%的测试和测量。同时，也有测量和测试来确保任何自动资源泄漏都能被检测、记录并处理。通常，资源泄漏发生在特定情况下，资源由`malloc()`函数分配，但在其他进程可能需要相同资源或某种形式的共享资源时，资源没有被释放。当资源没有按照指示释放或释放时，就会导致资源泄漏。
- en: SQLite also has dynamic analysis that checks the internal and external SQLite
    code while the code is being executed or is in use online. This type of analysis
    is used to ensure that SQLite has the best availability and quality for users.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite还具有动态分析功能，在代码执行或在线使用时检查内部和外部SQLite代码。这种分析类型用于确保SQLite为用户提供最佳的可用性和质量。
- en: '**Valgrind** is the simulator of the Linux binary and x86 environments. As
    a simulator, it is much slower, but it is effective. **Memsys2** has a memory
    allocation system that is pluggable; it uses the `malloc()` and `free()` functions.
    If SQLite is compiled with the `SQLite_MEMDEBUG` compile-time option, then, as
    a part of the debugging memory allocator, a larger wrapper is used around the
    `malloc()`, `realloc()`, and `free()` functions. If Memsys2 is used, it looks
    for memory allocation errors at runtime.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**Valgrind**是Linux二进制和x86环境的模拟器。作为一个模拟器，它运行得较慢，但非常有效。**Memsys2**有一个可插拔的内存分配系统；它使用`malloc()`和`free()`函数。如果SQLite使用`SQLite_MEMDEBUG`编译时选项编译，那么作为调试内存分配器的一部分，`malloc()`、`realloc()`和`free()`函数周围将使用更大的包装器。如果使用Memsys2，它将在运行时查找内存分配错误。'
- en: There are the `mutex` subsystems in SQLite that use the `sqlite3_mutex_held()`
    and `sqlite3_mutex_ notheld()` function. This is a pluggable subsystem, and these
    two interfaces detect whether a `mutex` subsystem has a particular thread. SQLite
    uses the `assert()` set of functions to ensure that multithreaded applications
    work correctly within the database system.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite中有`mutex`子系统，使用`sqlite3_mutex_held()`和`sqlite3_mutex_notheld()`函数。这是一个可插拔的子系统，这两个接口检测特定线程是否存在于`mutex`子系统中。SQLite使用`assert()`函数集来确保多线程应用程序在数据库系统中正确工作。
- en: SQLite uses a rollback journal to ensure that all the changes on the database
    are recorded before actually making changes to the database. SQLite has to work
    with different conditions so that it does not conflict or cause undetermined or
    odd behavior that must be managed. Since the code is developed in C, it may work
    with many implementations and libraries during development, but in the production
    area, it must confirm and may not work sometimes.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite使用回滚日志来确保在实际上对数据库进行更改之前记录数据库上的所有更改。SQLite必须与不同的条件一起工作，以避免冲突或引起必须管理的未确定或异常行为。由于代码是用C语言开发的，它可能在开发期间与许多实现和库一起工作，但在生产区域，它必须确认并且有时可能不起作用。
- en: So, checks such as a shifting using a negative number may be tried, or trying
    the `memcpy()` function to copy buffers that are overlapping and checking that
    unsigned or signed variables apply to `char` datatypes. To cope with, and cater
    for these issues, the compiler (**GCC**) may use the `-fraction` to within the
    test suites.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，可能会尝试使用负数进行移位等检查，或者尝试使用`memcpy()`函数复制重叠的缓冲区，并检查无符号或带符号变量是否适用于`char`数据类型。为了应对这些问题，编译器（**GCC**）可能使用`-fraction`选项在测试套件中。
- en: 'Before the code is released, it goes through a ping and checks that unsigned
    or signed, or analyzed and compile time errors will be checked before going forward.
    Both the connections—**Connection 1** and **Connection 2**—are shown as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码发布之前，它将进行ping操作并检查无符号或带符号、分析或编译时错误，然后再继续。以下两个连接——**连接1**和**连接2**——如下所示：
- en: '![Reasons for using SQLite](img/B04725_02_01.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![使用SQLite的原因](img/B04725_02_01.jpg)'
- en: 'Figure 9: SQLite object model with C API'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图9：带有C API的SQLite对象模型
- en: '*Figure 9* outlines the views that a programmer will look at—B-tree and pager,
    rather than components such as tokenizers or parser. *Figure 9* outlines the relationship
    between the components. To know SQLite properly, programmers must understand the
    locks, API, and transactions of SQLite.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*图9*概述了程序员将查看的视图——B树和分页器，而不是标记化器或解析器等组件。*图9*概述了组件之间的关系。为了正确理解SQLite，程序员必须了解SQLite的锁、API和事务。'
- en: As *Figure 9* illustrates, pager and B-tree access is forbidden, but important
    within locks and transactions. The connection to the database and SQL statements
    is most important when the API has many data structures. For example, a connection
    to any SQLite database is held as one transaction and also as one connection to
    the RDMS. A SQL statement is internally represented in the form of a **virtual
    database of engine** (**VDBE**) byte code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如*图9*所示，分页器和B树访问在锁和事务中是禁止的，但很重要。当API有许多数据结构时，与数据库的连接和SQL语句是最重要的。例如，任何SQLite数据库的连接都保持为一个事务，并且也是一个连接到RDBMS的连接。SQL语句在内部以**虚拟数据库引擎**（**VDBE**）字节码的形式表示。
- en: With the B-tree and pager components of SQLite, it will support many database
    objects within each connection, as shown in *Figure 9*. Every database object
    has a B-tree object, which has a relationship with a pager object. The SQL code
    (SQL statements) within each connection are shown in *Figure 9*. Every database
    object has a B-tree object, which has a relationship.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 与SQLite的B树和分页器组件一起，它将支持每个连接中的许多数据库对象，如图9所示。每个数据库对象都有一个B树对象，它与分页器对象有关联。每个连接中的SQL代码（SQL语句）如图9所示。每个数据库对象都有一个B树对象，它与分页器对象有关联。
- en: When B-tree requires information, it prompts the pager component to get the
    data from the database. The pager component will move the data into its memory
    buffer, and the B-tree component will then associate it via its cursor to retrieve
    and view the data.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当B树需要信息时，它会提示分页组件从数据库中获取数据。分页组件将数据移动到其内存缓冲区，然后B树组件通过其游标将其关联起来以检索和查看数据。
- en: Executing SQL statements and commands is a part of the main piece of the API
    that has two methods, which are either prepared or wrapped queries. If the page
    is modified by the cursor, the original page/data must be kept just in case of
    a database rollback. The pager is very important and has to deal with write and
    read events to and from the RDBMS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 执行SQL语句和命令是API的主要部分，有两个方法，即准备或包装查询。如果游标修改了页面，则必须保留原始页面/数据，以防数据库回滚。分页器非常重要，必须处理来自RDBMS的读写事件。
- en: A transaction is set up once an operation is in place. For example, a database
    connection setup will effectively be considered as one transaction. Also remember
    that a connection cannot have more than one transaction open or available at any
    given time.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦执行了操作，就会设置一个事务。例如，数据库连接设置将被视为一个事务。还请记住，在任何给定时间，连接不能打开或可用多个事务。
- en: Therefore, SQL statements from a standard connection will work on the same transaction.
    If the conditions of your program require more than one statement in different
    transactions, you have to engage in using multiple connections, as illustrated
    in *Figure 9*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，来自标准连接的SQL语句将在同一事务中工作。如果你的程序需要在不同事务中执行多个语句，你必须使用多个连接，如图9所示。
- en: It is very important to know how to set up a database connection from the application
    to the SQLite database. If there is no connection, then any of the commands used
    to retrieve, update, or insert data are useless. The connection statement will
    define the data process and its name and will set up a transaction to allow the
    data to pass to the database and back. Once a connection is made, the rest of
    the process sets up the database interactivity. It is not a difficult task to
    complete, but setting up a database is important to learn, because it is the starting
    point of all database activities and applications.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 了解如何从应用程序设置到SQLite数据库的数据库连接非常重要。如果没有连接，那么用于检索、更新或插入数据的任何命令都是无用的。连接语句将定义数据处理及其名称，并设置事务以允许数据传递到数据库并返回。一旦建立连接，其余的过程将设置数据库的交互性。虽然完成这个任务并不困难，但设置数据库是学习的重要部分，因为它是所有数据库活动和应用程序的起点。
- en: Database connections
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据库连接
- en: The `sqlite3_open()` C API function is used to open a connection to the database
    and is held in a single operating system file. This function actually opens the
    file, and thus, a secure connection is made that is not shared. If the memory
    option is used, then the database will be created in **random access memory**
    (**RAM**), once the connection is established. The database will then be removed
    and deleted from RAM when the connection closed.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_open()` C API 函数用于打开到数据库的连接，并且该连接被保存在单个操作系统文件中。此函数实际上打开文件，因此，建立了一个安全且不共享的连接。如果使用内存选项，那么数据库将在**随机存取存储器**（**RAM**）中创建，一旦建立连接。当关闭连接时，数据库将从RAM中删除。'
- en: 'SQLite will attempt to open an existing database, and if an entered database
    name does not exist, then it will assume that the programmer wants to create one.
    SQLite is clever if you want to create a database and then close it without any
    operation, such as creating a table: it will not actually spend resources creating
    the database, only an empty file will exist:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite将尝试打开现有数据库，如果输入的数据库名称不存在，则它将假定程序员想要创建一个。如果你想要创建数据库然后关闭它而不进行任何操作，例如创建表，SQLite非常聪明：它实际上不会花费资源创建数据库，而只是一个空文件将存在：
- en: '[PRE0]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding statement will create the required default file with a table and
    will then drop/delete it, leaving a clean database without any tables. This is
    possibly the neatest way to show an empty database.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的语句将创建所需的默认文件，其中包含一个表，然后将其删除/删除，留下一个没有任何表的干净数据库。这可能是最整洁的方式来展示一个空数据库。
- en: When opening the SQLite database, the programmer or database administrator can
    specify the size of the page in different ranges from 512 to 32,768 bytes. By
    default, SQLite will use a 1,024 byte page size. For a better performance, the
    developer may consider a page size of his SQLite database equal to the operating
    system's page size, which will make operations much more efficient.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 当打开SQLite数据库时，程序员或数据库管理员可以指定页面大小，范围从512字节到32,768字节。默认情况下，SQLite将使用1,024字节的页面大小。为了获得更好的性能，开发者可以考虑将SQLite数据库的页面大小设置为操作系统页面大小，这将使操作更加高效。
- en: It all depends on the type of application you are going to design; paying attention
    to the detail on the type of columns, sizes, and types, which will gear a table
    and database design to be more efficient and perform well. If the application
    you are dealing with has large binary data for example, the database page size
    will increase to match the loading or selecting of data. The `page_size` parameter
    is used as a part of the database page sizing for each database.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这一切都取决于你将要设计的应用程序类型；注意列的类型、大小和类型等细节，这将使表和数据库设计更加高效并表现良好。例如，如果你处理的应用程序有大量的二进制数据，数据库页面大小将增加以匹配数据的加载或选择。`page_size`
    参数用作每个数据库页面大小的组成部分。
- en: Preparing queries
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备查询
- en: 'These are the eight methods and two objects that form the SQLite interface.
    These are the basic list of functions that each user/reader must be aware of when
    using SQLite in code. These statements don''t change, nor does their functionality.
    These are the key statements to ensure that users are aware of the name, format,
    and where these functions are used:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是构成 SQLite 接口的八个方法和两个对象。这些是每个用户/读者在使用 SQLite 编码时必须了解的基本函数列表。这些语句不会改变，其功能也不会改变。这些是确保用户了解名称、格式以及这些函数使用位置的关键语句：
- en: '`sqlite3`: Database connection object, made by `sqlite3_open()`, killed by
    `sqlite3_close`()'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3`: 数据库连接对象，由 `sqlite3_open()` 创建，由 `sqlite3_close()` 销毁'
- en: '`sqlite3_stmt`: Preparation statement object, made by `sqlite3_prepare()`,
    killed by `sqlite3_finalize()`'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_stmt`: 准备语句对象，由 `sqlite3_prepare()` 创建，由 `sqlite3_finalize()` 销毁'
- en: '`sqlite3_open()`: Opens the database (new or existing) and uses constructor
    `sqlite3`'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_open()`: 打开数据库（新或现有）并使用构造函数 `sqlite3`'
- en: '`sqlite3_prepare()`: Compiles some SQL text into byte code to perform updating
    or querying tasks and is the constructor of `sqlite3_stmt`'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_prepare()`: 将一些 SQL 文本编译成字节码以执行更新或查询任务，并且是 `sqlite3_stmt` 的构造函数'
- en: '`sqlite3_bind()`: Application data is stored into the parameters of the original
    SQL'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_bind()`: 将应用程序数据存储到原始 SQL 的参数中'
- en: '`sqlite3_step()`: The further advancement of `sqlite3_stmt` onto the next row
    or completion'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_step()`: 将 `sqlite3_stmt` 进一步推进到下一行或完成'
- en: '`sqlite3_column()`: The current row result outlining column values for `sqlite3_stmt`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_column()`: 当前行结果概述 `sqlite3_stmt` 的列值'
- en: '`sqlite3_finalize()`: `sqlite3_stmt` destructor'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_finalize()`: `sqlite3_stmt` 析构函数'
- en: '`sqlite3_close()`: `sqlite3` destructor'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_close()`: `sqlite3` 析构函数'
- en: '`sqlite3_exec()`: A wrapper function that works for one or many SQL statements
    using `sqlite3_prepare()`, `sqlite3_step()`, `sqlite3_finalize()`, and `sqlite3_column()`'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sqlite3_exec()`: 一个包装函数，用于使用 `sqlite3_prepare()`、`sqlite3_step()`、`sqlite3_finalize()`
    和 `sqlite3_column()` 对一个或多个 SQL 语句进行操作'
- en: 'The `sqlite3_prepare_v2()` function is the one used to prepare and execute
    SQL statements. The prepare function is the method that SQLite uses as a part
    of the following three-stage process:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_prepare_v2()` 函数用于准备和执行 SQL 语句。准备函数是 SQLite 作为以下三个阶段过程的一部分使用的方法：'
- en: First is the preparation stage, next the execution stage, and then the finalization
    stage. On the preparation side (first step), the components, as explained in [Chapter
    1](ch01.html "Chapter 1. Introduction to SQL and SQLite"), *Introduction to SQL
    and SQLite*, outline the parser, tokenizer, and code maker to investigate the
    SQL and make a statement using the `sqlite3_prepare_v2()` function working with
    the compiler. Then, a handle is created with byte code from the `sqlite3_stmt`
    function that collates and uses relevant resources for the statement to execute.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先是准备阶段，然后是执行阶段，最后是最终化阶段。在准备阶段（第一步），正如在[第1章](ch01.html "第1章。SQL和SQLite简介")中所述，*SQL和SQLite简介*，组件概述了解析器、标记器和代码生成器，以调查
    SQL 并使用 `sqlite3_prepare_v2()` 函数与编译器一起生成语句。然后，使用 `sqlite3_stmt` 函数创建一个字节码处理句柄，该句柄整理并使用相关资源以执行语句。
- en: Secondly, VDBE within SQLite will take the byte code and execute it using the
    C API. The `SQLite3_step()` will work with (VDBE) to go through the byte code
    looking at locking resources as required. Different statements will work differently
    in VDBE, but for the `SELECT` statements as an example, using `sqlite3_step()`
    as part of a result set, `SQLITE_ROW()` will be set and the process will go through
    the whole dataset until `SQLITE_DONE` is reached. Other statements in the set
    including `UPDATE`, `INSERT`, and `DELETE` will be directly executed within VDBE.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，SQLite中的VDBE将字节码执行，使用C API。`SQLite3_step()`将与(VDBE)一起工作，遍历字节码，根据需要查看锁定资源。不同的语句在VDBE中工作方式不同，但以`SELECT`语句为例，作为结果集的一部分使用`sqlite3_step()`，`SQLITE_ROW()`将被设置，并且过程将遍历整个数据集，直到达到`SQLITE_DONE`。集合中的其他语句，包括`UPDATE`、`INSERT`和`DELETE`，将在VDBE中直接执行。
- en: The third step is the final one where the resources to VDBE are closed; the
    `sqlite3_finalize()`function does this. Once the `sqlite3_finalize()` function
    is executed and resources are free, the program comes to an end via the VDBE and
    the statement handle is closed as well.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第三步是最后一步，关闭VDBE的资源；`sqlite3_finalize()`函数执行此操作。一旦`sqlite3_finalize()`函数执行并且资源可用，程序将通过VDBE结束，并且语句句柄也将关闭。
- en: Parameterized SQL
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化SQL
- en: 'Using SQL within C code and the API will involve parameterized SQL—the way
    to include data placeholders in an SQL statement. These are the two types of parameterized
    binding: named and positional. See *Figure 10* for more details on how these types
    of parameterized binding are used. The first statement is positional where its
    position is located or marked by a question mark, and these positions are based
    on the number of columns.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在C代码和API中使用SQL将涉及参数化SQL——在SQL语句中包含数据占位符的方式。这些是两种参数化绑定类型：命名和位置。请参阅图10以了解更多关于这些类型参数化绑定如何使用的详细信息。第一个语句是位置性的，其位置由问号定位或标记，这些位置基于列的数量。
- en: The real variable names setup in the programmable language, such as C or Java,
    as shown in the second insert statement in *Figure 10*, outlines the named parameters
    that use a colon as a prefix to indicate it on an SQL statement. By default, `NULL`
    is used as a default value if there is no value for it to be bound to.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在可编程语言（如C或Java）中设置的真正变量名，如图10中的第二个插入语句所示，概述了使用冒号作为前缀在SQL语句中指示的命名参数。如果没有要绑定的值，默认使用`NULL`作为默认值。
- en: Once a statement is bound, you can call on it again more than once without wasting
    the performance or time to recompile it again.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦一个语句被绑定，你可以多次调用它而不会浪费重新编译的性能或时间。
- en: The whole idea of using parameterized SQL is to reuse the same code with different
    parameters without recompiling. It saves on resources and time, and improves efficiency.
    This allows the existing code to be reused several times if the design allows
    it, to save on more code and improve efficiency. If you use quotes or characters
    for plurals as an example, SQLite, by default, will escape the characters and
    insert the right data and convert it properly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 使用参数化SQL的整个想法是使用不同的参数重用相同的代码而不需要重新编译。它节省了资源和时间，并提高了效率。如果设计允许，这允许现有代码被多次重用，以节省更多代码并提高效率。例如，如果你使用引号或字符表示复数，SQLite默认将转义字符并插入正确数据并正确转换。
- en: 'It also stops SQL injections, SQL penetrations, and easy syntax issues or errors.
    The SQL injection to a company is a security vulnerability, which allows a hacker
    to trick the system into adding or modifying data where access is not granted.
    On a browser where the address of a website is seen, the data input is sometimes
    added without any encryption, or no data checking is carried out at the backend
    or frontend to allow penetration. SQL injections, as illustrated and explained
    in *Figure 12*, show that an open piece of code that relies on an input using
    a `%s` string, can be regarded as opened, and can impact the data in the database:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 它还阻止SQL注入、SQL渗透以及简单的语法问题或错误。对于公司来说，SQL注入是一个安全漏洞，允许黑客欺骗系统在未授权的地方添加或修改数据。在浏览器中，当看到网站的地址时，数据输入有时没有任何加密，或者在前后端没有进行数据检查，以允许渗透。如图12所示和解释的SQL注入表明，依赖于使用`%s`字符串的输入的开放代码可以被视为开放的，并且可能影响数据库中的数据：
- en: '![Parameterized SQL](img/4725_02_02.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![参数化SQL](img/4725_02_02.jpg)'
- en: 'Figure 10: Using parameterized SQL'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图10：使用参数化SQL
- en: 'The following snippet shows how a statement can be compiled using one set of
    parameters; using the `function _reset()` method will allow the same compiled
    SQL code to be used again with different parameters:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用一组参数编译一个语句；使用`function _reset()`方法将允许相同的编译SQL代码再次使用不同的参数：
- en: '[PRE1]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Error handling
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: Handling errors is mandatory when writing systems, especially if it is for mobile
    devices; so, attention to detail and catching issues with code is vital. The `SQLITE_BUSY`
    and `SQLITE_ERROR` functions are used by programmers to notify and trap errors,
    and store them for a later analysis.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写系统时处理错误是强制性的，尤其是如果是为了移动设备；因此，注意细节和通过代码捕捉问题至关重要。程序员使用`SQLITE_BUSY`和`SQLITE_ERROR`函数来通知和捕捉错误，并将它们存储起来以供后续分析。
- en: For example, `SQL_ERROR` is activated when resources such as locks cannot be
    granted or are not available, whereas the `SQL_BUSY` covers issues with transactions
    and related matters. Another function called `sqlite3_errcode()` will handle any
    general SQLite error. These methods and functions are the standard way of handling
    errors with SQLite.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当资源如锁无法授予或不可用时，`SQL_ERROR`会被激活，而`SQL_BUSY`则涵盖事务和相关问题。另一个名为`sqlite3_errcode()`的函数将处理任何通用的SQLite错误。这些方法和函数是处理SQLite错误的标准方式。
- en: Queries within the db.exec statement
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: db.exec语句中的查询
- en: 'The `sqlite3_get_table()` function is used to execute SQL statements that actually
    return data, such as the `SELECT` statement, but the `sqlite3_exec()` function
    is a one-way traffic execution and does not return any data, for example, the
    `INSERT` statement. See the following code for more information:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite3_get_table()`函数用于执行实际返回数据的SQL语句，例如`SELECT`语句，而`sqlite3_exec()`函数是单向流量执行，不返回任何数据，例如`INSERT`语句。以下代码提供了更多信息：'
- en: '[PRE2]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: SQL injection attacks
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SQL注入攻击
- en: 'Another issue with SQLite and SQL statements generally is **SQL injection attacks**.
    These can deface websites, result in data corruption, and also affect the reputation
    of your website and its customers. If the input to SQL parameters is direct, then
    a weakness could be penetrable. SQL data input must be checked and filtered to
    allow no one to change the current statement with data elements or even replace
    SQL statements to perform corrupt acts. This can be done using this statement:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite和SQL语句通常还存在另一个问题：**SQL注入攻击**。这些攻击可能导致网站被篡改，数据损坏，并影响您网站及其客户的声誉。如果SQL参数的输入是直接的，那么可能存在可被利用的弱点。SQL数据输入必须进行检查和过滤，以确保没有人能够使用数据元素更改当前语句，甚至替换SQL语句以执行恶意行为。这可以通过以下语句实现：
- en: '[PRE3]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding code shows that an injection can take place where `%s` is the
    input string, and it can be changed to be something else, thus changing the outcome
    result. To protect SQL, constrain the input, use parameters with stored procedures,
    and use parameters with dynamic SQL to reduce the threats.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码显示了注入可能发生的地方，其中`%s`是输入字符串，它可以被更改成其他内容，从而改变结果。为了保护SQL，限制输入，使用存储过程参数，以及使用动态SQL参数来减少威胁。
- en: To prevent your website from being used for `XSS` or `XSRF` attacks, disallow
    the HTML tags in text input provided by users by using functions to find and strip
    tags.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止您的网站被用于`XSS`或`XSRF`攻击，请使用函数查找并删除用户提供的文本输入中的HTML标签。
- en: Creating user-defined functions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建用户定义函数
- en: 'The benefit of using SQLite over other small databases is its flexibility to
    engage with the extension API side by creating your own user-defined function.
    If you are familiar with creating your own function in a language such as Java
    or C, for example, then extending the natural SQLite database will not be difficult.
    The following code outlines how this can be done using the C API:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SQLite而不是其他小型数据库的好处是它可以通过创建自己的用户定义函数来与扩展API交互，从而具有灵活性。如果您熟悉在Java或C等语言中创建自己的函数，那么扩展SQLite数据库将不会很难。以下代码概述了如何使用C
    API实现这一点：
- en: '[PRE4]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Transactions and locks
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务和锁
- en: Transactions and lock states form a part of the makeup of the API and its functions.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 事务和锁状态是API及其函数组成的一部分。
- en: Although difficult to control in their entirety, locks and transactions are
    interlinked with queries within SQLite and most database systems. The key to better
    transactions involves the programmer writing good SQL code, ensuring that it will
    perform well, and catering for possible errors and issues during the journey so
    that the application does not crash or leave the user in the lurch. Another issue
    with locks will relate to which resources you need. Sometimes, it could be a badly
    written code that does not use `autocommit` or is holding an exclusive lock to
    a table and another part of your process, and you can't update it, as an example.
    So, it is very important for the programmer to gauge, learn the API, and understand
    how locking and transaction strategies will work to produce a smooth and good
    app.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然很难完全控制，但锁和事务与SQLite和大多数数据库系统中的查询是相互关联的。更好的事务的关键在于程序员编写良好的SQL代码，确保其性能良好，并在旅途中处理可能出现的错误和问题，以便应用程序不会崩溃或让用户陷入困境。锁的另一个问题将涉及您需要的资源。有时，可能是因为代码编写不当，没有使用`autocommit`或持有对表和您过程另一部分的排他性锁，例如，您无法更新它。因此，对于程序员来说，评估、学习API以及了解锁定和事务策略如何工作以产生流畅和良好的应用程序非常重要。
- en: By default, `autocommit` is used in SQLite where transactions cycles start and
    end, which are controlled by programmers and statements used for the app. Each
    SQL command will run in its own transaction since `autocommit` is used. However,
    within a transaction, especially using a begin command, the programmer has to
    manually call a rollback, or a commit to update the database. Sometimes, a locking
    strategy such as this may cause SQL violations or errors, which has to be handled
    by the error handling code within the app.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，SQLite使用`autocommit`，其中事务周期开始和结束，由程序员和用于应用程序的语句控制。每个SQL命令都将在其自己的事务中运行，因为使用了`autocommit`。然而，在事务内部，特别是在使用`begin`命令时，程序员必须手动调用回滚或提交以更新数据库。有时，这种锁定策略可能会导致SQL违规或错误，这必须在应用程序的错误处理代码中处理。
- en: In terms of passwords, as a programmer or designer, do not store password, such
    as database passwords, in any clear text or script that may be accessed by any
    user. For example, in a directory to a web server, a source file can be compromised.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在密码方面，作为程序员或设计师，不要将密码，如数据库密码，存储在任何可能被任何用户访问的纯文本或脚本中。例如，在指向Web服务器的目录中，源文件可能会被破坏。
- en: Application authentication should be done on two levels with heavy type password
    formats so that access is not compromised, especially with technology, such as
    spyware that looks into compromising your system. The data can be encrypted when
    database authorization provisions do not offer sufficient protection, which is
    initially required.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的身份验证应在两个级别上进行，使用强密码格式，以确保访问不被破坏，尤其是在像间谍软件这样的技术下，它可能会破坏您的系统。当数据库授权条款提供不足的保护时，数据可以被加密，这是最初所需的。
- en: Transactions – reading/writing
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 事务 – 读取/写入
- en: When a `SELECT` statement is used within SQLite, it moves from a default status
    of `UNLOCKED` to `SHARED`, and once the statement is committed, it reverts to
    `UNLOCKED`. There are several states for transaction lock states and locking works
    when there is `autocommit` on or transactional control with `autocommit` off within
    a begin/end statement arrangement. When there is some contention, the transactional
    locking states may alter from `UNLOCKED` to `SHARED`, `RESERVED`, or `EXCLUSIVE`.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 当在SQLite中使用`SELECT`语句时，它从默认的`UNLOCKED`状态移动到`SHARED`状态，一旦语句被提交，它就恢复到`UNLOCKED`状态。事务锁定状态有几种状态，锁定在`autocommit`开启或`autocommit`关闭的`begin/end`语句安排中有事务控制时起作用。当存在一些竞争时，事务锁定状态可能会从`UNLOCKED`变为`SHARED`、`RESERVED`或`EXCLUSIVE`。
- en: If an update is to take place, the programmer may code it so that an `EXCLUSIVE`
    lock is used. This stops updates from other processes, just until the job has
    been done and the lock is released. In this case, the programmer must also code
    and put up a message or write to the log file; if this happens, auditors or database
    administrators will have an audit trail of events during the lifetime of an application.
    It is a very good practice to do so.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 如果要进行更新，程序员可能会编写代码以使用`EXCLUSIVE`锁。这阻止了其他进程的更新，直到工作完成并释放锁为止。在这种情况下，程序员还必须编写代码并发布消息或写入日志文件；如果发生这种情况，审计员或数据库管理员将有一个应用程序生命周期的活动审计记录。这样做是非常好的实践。
- en: Designing for SQLite
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为SQLite设计
- en: Generally, programmers will think that because database systems are huge or
    work best in enterprise, it will be the same for SQLite and the mobile environment.
    Remember when the app is released; ensure that SQLite is built in with some basic
    data for the user to start. Ensure that the data can be dynamically populated
    easily. This will form a part of a great data access strategy and format, which
    should be replicated across all of your applications.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，程序员会认为数据库系统庞大或者在企业环境中表现最佳，因此SQLite和移动环境也会一样。记住，当应用发布时，确保SQLite内置了一些基本数据供用户开始使用。确保数据可以轻松动态填充。这将形成优秀数据访问策略和格式的一部分，应该在所有应用中复制。
- en: As mentioned previously, security to your data is mandatory, and requirements
    around privacy and access, including a form of encryption, must be considered
    to protect information.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，数据安全是强制性的，并且必须考虑隐私和访问要求，包括加密形式，以保护信息。
- en: Another important factor in designing a good database for SQLite is the performance
    and the ability of the software to work efficiently and quickly among the operating
    system on a small device and app that has more demands on it today.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计良好的SQLite数据库时，另一个重要因素是性能和软件在小型设备上高效快速工作的能力，而今天对它的需求更多。
- en: Testing both, manual and automatic, using products such as **Appium** for mobiles,
    is a must, because it can find out relevant bugs, issues, and problems, that manual
    testing may not have uncovered. The usage of SQLite in your application can be
    as complicated or as simple as you require, and the freedom and accessibility
    of code and experts are plentiful, to ensure that your app delivers what it sets
    out to achieve.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 使用如**Appium**等移动产品进行手动和自动测试是必须的，因为它可以发现相关错误、问题和问题，这些问题手动测试可能没有发现。SQLite在你应用中的使用可以像你需要的那么复杂或简单，代码和专家的自由和可访问性都很丰富，以确保你的应用实现其目标。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to design a database system for an application
    using SQLite. You learned the details of how to approach the design and outline
    certain concepts. The next chapter will show you how to administer an SQLite database
    and make use of this functionality.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用SQLite为应用设计数据库系统。你了解了如何接近设计细节，并概述了某些概念。下一章将向你展示如何管理SQLite数据库并利用这一功能。
