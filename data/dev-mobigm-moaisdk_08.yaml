- en: Chapter 8. Let's Build a Platformer!
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。让我们构建一个平台游戏！
- en: Now that we're familiar with handling input and assets, why don't we build a
    platformer prototype? This should be a nice challenge that will introduce us to
    some more concepts and ways to work with Moai SDK.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经熟悉了处理输入和资源，为什么不尝试构建一个平台游戏原型呢？这将是一个很好的挑战，将使我们接触到更多概念和与Moai SDK一起工作的方法。
- en: In order to build this game, we'll copy the full content of the previous chapter's
    code and clean everything from `game.lua` that is specific to the *Concentration*
    game.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了构建这个游戏，我们将复制上一章代码的全部内容，并从`game.lua`中清除所有特定于*Concentration*游戏的代码。
- en: Remove all the constants on the top of the file, the definition for the tile
    (but keep `resource_definitions` since we're going to use it).
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除文件顶部的所有常量，对瓷砖的定义（但保留`resource_definitions`，因为我们将要使用它）。
- en: Remove `self.wasClicking = false` from the `Game:start ()` method.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Game:start ()`方法中删除`self.wasClicking = false`。
- en: Remove the calls to `initializeTiles` and `restartGamePlay` from `Game:initialize
    ()`.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从`Game:initialize ()`中删除对`initializeTiles`和`restartGamePlay`的调用。
- en: Remove the methods `Game:initializeTiles()`, `Game:restartGamePlay ()`, `Game:choseCell
    ()`, `Game:alreadySelectedTile()`, `Game:swapTile ()`, `Game:resetTiles ()`, and
    `Game:removeTiles()`.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除方法`Game:initializeTiles()`、`Game:restartGamePlay ()`、`Game:choseCell ()`、`Game:alreadySelectedTile()`、`Game:swapTile
    ()`、`Game:resetTiles ()`和`Game:removeTiles()`。
- en: That should be it; now you should be good to go.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就足够了；现在您应该可以开始了。
- en: Background
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 背景
- en: 'We''re going to insert a background to our screen:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向屏幕插入一个背景：
- en: The first thing we're going to do is display a background. This should be pretty
    easy for you right now. A good idea will be searching [www.opengameart.org](http://www.opengameart.org)
    for a suitable background. That's what has been done in the code for this chapter,
    and you'll find a background in there.
  id: totrans-10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们要做的第一件事是显示一个背景。现在这对您来说应该很容易。一个好主意是搜索[www.opengameart.org](http://www.opengameart.org)以找到合适的背景。这正是本章代码中所做的，您将在其中找到一个背景。
- en: 'Let''s add the definition. If you''re using an image other than the one provided
    in the book''s code, just go ahead and change the dimensions and filename (this
    code should go inside `resources_definition`):'
  id: totrans-11
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加定义。如果您使用的是书中代码中未提供的图像，只需更改尺寸和文件名即可（此代码应放在`resources_definition`内部）：
- en: '[PRE0]'
  id: totrans-12
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, let''s add a line at the bottom of the `initialize ()` method to load
    the background:'
  id: totrans-13
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`initialize ()`方法的底部添加一行来加载背景：
- en: '[PRE1]'
  id: totrans-14
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And now let''s define that method:'
  id: totrans-15
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们定义这个方法：
- en: '[PRE2]'
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is nothing new, right? It's the same thing we did to load an image in [Chapter
    5](ch05.html "Chapter 5. Showing Images on the Screen"), *Showing Images on the
    Screen*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是什么新东西，对吧？这是我们之前在[第5章](ch05.html "第5章。在屏幕上显示图像")中加载图像所做的一样，*在屏幕上显示图像*。
- en: Now, let's play with the camera and scroll it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们玩一下摄像机并滚动它。
- en: Tip
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Take into account the platform you're targeting when loading backgrounds.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载背景时，请考虑您要针对的平台。
- en: The maximum texture size differs according to the **Shader Model**. You will
    be safe if you're using textures that are 1024 x 1024 or smaller; if you find
    yourself having textures that don't show up on the screen, double-check this.
    Remember that you can always split the textures into smaller ones and load several
    of them in different Props. We ran into this problem with the second scene in
    *The Insulines*; it wasn't working on some computers because it was huge, so we
    had to split it.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理的最大尺寸根据**着色器模型**而有所不同。如果您使用的是1024 x 1024或更小的纹理，那么您将是安全的；如果您发现有些纹理没有显示在屏幕上，请再次检查这一点。请记住，您始终可以将纹理分割成更小的部分，并在不同的Props中加载多个。我们在*The
    Insulines*的第二场景中遇到了这个问题；由于它太大，一些电脑上无法工作，因此我们不得不将其分割。
- en: Camera and scrolling
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摄像机和滚动
- en: If you're planning to create games in 2D, an important thing to master is how
    to use a camera, and that's what we'll do now.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划创建2D游戏，一个重要的事情是要掌握如何使用摄像机，这正是我们现在要做的。
- en: 'Enter this code at the beginning of `Game:initialize ()` in `game.lua`:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在`game.lua`中的`Game:initialize ()`的开始处输入以下代码：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: What we're doing here is creating a new camera using the built-in `MOAICamera2D`
    class.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在这里所做的就是使用内置的`MOAICamera2D`类创建一个新的摄像机。
- en: 'Next, we need to assign that camera to each layer. Below the viewport assignment
    `(self.layer:setViewport ( viewport ))`, add the following line of code:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要将摄像机分配给每一层。在视口分配`(self.layer:setViewport ( viewport ))`下方，添加以下代码行：
- en: '[PRE4]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This binds the layer to that camera. And that's it; when you move the camera,
    you'll see that the viewport will follow, and if you scale the camera up and down,
    it will zoom in and zoom out accordingly. We'll write a few lines to demonstrate
    this.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将层绑定到那个相机。就是这样；当你移动相机时，你会看到视口会跟随，如果你上下缩放相机，它会相应地放大和缩小。我们将写几行代码来演示这一点。
- en: 'Inside `Game:processInput ()` write the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Game:processInput ()`中编写以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We are using a method from `InputManager` that returns the difference between
    the current mouse position and the previous one.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们正在使用`InputManager`中的一个方法，该方法返回当前鼠标位置和上一个位置之间的差异。
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We move the camera using the `moveLoc ()` method and passing the delta in `x`,
    nothing in `y`. The third parameter tells `moveLoc ()` to take half-a-second to
    do the movement. The third parameter is used to define the curve of the animation,
    in this case, we're making it linear, so it will make a movement that is constant
    in speed. We'll go more into this later.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`moveLoc ()`方法移动相机，并通过`x`传递增量，`y`不传递任何内容。第三个参数告诉`moveLoc ()`用半秒钟的时间来完成移动。第三个参数用于定义动画的曲线，在这种情况下，我们使其线性，所以它将产生速度恒定的移动。我们稍后会更深入地探讨这一点。
- en: Tip
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '`MOAIEaseType` defines a bunch of useful curves for our animations; you can
    check them out at [http://getmoai.com/docs/class_m_o_a_i_ease_type.html](http://getmoai.com/docs/class_m_o_a_i_ease_type.html).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`MOAIEaseType`定义了我们动画中一些有用的曲线；你可以在[http://getmoai.com/docs/class_m_o_a_i_ease_type.html](http://getmoai.com/docs/class_m_o_a_i_ease_type.html)查看它们。'
- en: If you run the game now, you'll see that when you move the mouse, the background
    scrolls to the left and right. That's a consequence of the camera being moved.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行游戏，你会看到当你移动鼠标时，背景向左和向右滚动。这是由于相机移动的结果。
- en: So, instead of moving all of the objects on screen, you just move the camera
    when you want to scroll.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，当你想要滚动时，你只需要移动相机，而不是移动屏幕上的所有对象。
- en: What we can do later is scroll the camera to follow our character's movements.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后可以滚动相机以跟随角色的移动。
- en: Parallax
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 垂直透视
- en: Parallax is an effect that's often used (and abused) in games because it creates
    a feeling of depth in 2D scenes. The main idea is to create layers of images,
    which are at different distances, which move at different speeds when scrolling.
    This mimics what happens in reality with objects that are at different distances
    from a viewer (the objects far away move slower than the near ones).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 垂直透视是一种在游戏中经常使用（并且滥用）的效果，因为它在2D场景中创造出深度感。主要思想是创建不同距离的图像层，当滚动时，这些图像以不同的速度移动。这模仿了在现实中，从观众（观察者）距离不同的物体（远处的物体移动速度比近处的物体慢）发生的情况。
- en: We can achieve this by splitting the background into different images (each
    one representing a different plane).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将背景分割成不同的图像（每个图像代表一个不同的平面）来实现这一点。
- en: '![Parallax](img/5064_08_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![垂直透视](img/5064_08_01.jpg)'
- en: 'Here we see the old background split into three layers:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到旧的背景被分割成三层：
- en: A cloudy background
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有云的背景
- en: A tower that is far away
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个较远的塔
- en: Some hills that are nearer
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一些较近的小山丘
- en: Now, what we need to do is make them move at different speeds.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要做的是让它们以不同的速度移动。
- en: Setting up the layers
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置层
- en: In Moai SDK, you can implement this using a `MOAILayer2D` method called `setParallax
    ()`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在Moai SDK中，你可以使用一个名为`MOAILayer2D`的方法`setParallax ()`来实现这一点。
- en: Let's take a look at it.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看它。
- en: As we saw, we'll need a couple of layers to do this. We'll replace our current
    layer with a table of layers. On `Game:initialize ()`, replace the lines for the
    layer initialization with a call to `self:setupLayers ()`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 正如我们所见，我们需要几个层来完成这个任务。我们将用层的表格替换当前的层。在`Game:initialize ()`中，用对`self:setupLayers
    ()`的调用替换层初始化的行。
- en: 'Then we create the actual method:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们创建实际的方法：
- en: '[PRE7]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We''ll create a layer per depth plane that we want. We''ll use three planes
    in this example: a background, a far away plane, and a main plane. (Our character
    and all of the game objects should go inside the main plane)'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将为每个我们想要的深度平面创建一个层。在这个例子中，我们将使用三个平面：一个背景平面，一个远处的平面和一个主要平面。（我们的角色和所有游戏对象都应该放在主要平面内）
- en: '[PRE8]'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then we iterate through all of the layers and assign the viewport and the camera
    correctly.
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们遍历所有层，并正确地分配视口和相机。
- en: '[PRE9]'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now, we create a render table with the layers in order.
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们按顺序创建一个包含层的渲染表。
- en: '[PRE10]'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We'll then make it active.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使其变得活跃。
- en: Now we have our layers ready to play with parallax.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了可以玩垂直透视的层。
- en: Adding images to the different distances
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向不同距离添加图像
- en: 'Now we''ll show images on each layer for you to see how cool this is:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将显示每个层的图像，以便您可以看到这是多么酷：
- en: '[PRE11]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'These are the three resource definitions we''ll need: one for each layer. The
    images can be found in the source code for this chapter.'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要这三个资源定义：每个层一个。这些图像可以在本章的源代码中找到。
- en: There is some more information that we'll need, but instead of adding it into
    the `resource_definitions` table, we'll create another table. Even if the objects
    and definitions look the same, there is a slight conceptual difference between
    them, so it is better to keep them separated.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们还需要一些其他信息，但不是将其添加到`resource_definitions`表中，我们将创建另一个表。即使对象和定义看起来相同，它们之间在概念上存在细微的区别，所以最好将它们分开。
- en: 'Write the following code below the `resource_definitions` table:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`resource_definitions`表下方写下以下代码：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What we're doing here is defining the position and the parallax information
    for each object we're creating. Well, strictly, the parallax is for the layer
    that contains the object.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的是为创建的每个对象定义位置和视差信息。严格来说，视差是为包含对象的层。
- en: 'Now, we''ll rewrite `Game:loadBackground ()` to look like the following:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将重写`Game:loadBackground ()`，使其看起来如下：
- en: '[PRE13]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We iterate through all the things we defined in `background_objects`:'
  id: totrans-73
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们遍历在`background_objects`中定义的所有内容：
- en: '[PRE14]'
  id: totrans-74
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We load the deck using the keys from the `background_objects` table.
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`background_objects`表中的键来加载牌组。
- en: '[PRE15]'
  id: totrans-76
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Here we use the position attribute we defined in `background_objects`:'
  id: totrans-77
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用在`background_objects`中定义的位置属性：
- en: '[PRE16]'
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And here we make use of `setParallax` and use the parallax attribute we defined
    in background objects:'
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`setParallax`并使用我们在背景对象中定义的视差属性：
- en: '[PRE17]'
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: And that's it, we're now good to go. Run the game and move the mouse. You should
    now see the three different layers moving at different speeds.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们现在可以开始了。运行游戏并移动鼠标。你现在应该能看到三个不同的层以不同的速度移动。
- en: Now we are ready to add the main character, so let's jump straight to that!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备添加主要角色，让我们直接跳到那里！
- en: Main character
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主要角色
- en: In order to create our character, we'll need a sprite sheet with animations
    for walking, running, and jumping.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 为了创建我们的角色，我们需要一个包含行走、跑步和跳跃动画的精灵表。
- en: 'It should look something like the following image:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像以下图像：
- en: '![Main character](img/5064_08_02.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![主要角色](img/5064_08_02.jpg)'
- en: 'First of all, we''ll create a resource definition as follows (put this below
    the background resource definition):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个资源定义，如下所示（将其放在背景资源定义下方）：
- en: '[PRE18]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is pretty much the same as we used for our *Concentration* game, but note
    that we added `width` and `height`. That's the size of the tile. In the *Concentration*
    game, we defined the size of the tile in the grid, but now there is no grid, so
    we need to define it here.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与我们在*Concentration*游戏中使用的是一样的，但请注意，我们添加了`width`和`height`。这是瓦片的尺寸。在*Concentration*游戏中，我们在网格中定义了瓦片的尺寸，但现在没有网格，所以我们需要在这里定义它。
- en: 'In order to handle that definition, we need to add some lines to `resource_manager.lua`,
    inside `loadTiledImage`, just below the call to `setSize()`:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了处理这个定义，我们需要在`resource_manager.lua`中的`loadTiledImage`函数内添加一些行，就在调用`setSize()`之后：
- en: '[PRE19]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The preceding code is similar to that in `loadImage`; the difference is that
    we divide `width` and `height` by two and use the resulting values as the rectangle's
    dimensions.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码与`loadImage`中的代码类似；区别在于我们将`width`和`height`除以二，并使用得到的结果作为矩形的尺寸。
- en: 'Let''s create a file called `character.lua` to start creating our character
    (don''t forget to `require` that file in `game.lua`) and add the following code
    to it:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个名为`character.lua`的文件来开始创建我们的角色（别忘了在`game.lua`中`require`该文件），并向其中添加以下代码：
- en: '[PRE20]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is basically the same as what we've been doing in order to load images
    on screen; the important part here is that initialize receives a layer as a parameter
    and adds the Prop to that layer. Can you guess why?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上与我们在屏幕上加载图像时所做的是一样的；这里的重要部分是initialize接收一个层作为参数，并将Prop添加到该层。你能猜到为什么吗？
- en: 'Here is the reason: put the following line at the bottom of `Game:initialize
    ()` in `game.lua` (just below the call to `loadBackground`):'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 原因如下：在`game.lua`中的`Game:initialize ()`的底部添加以下行（就在调用`loadBackground`之后）：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: And voilà, we have our character on screen. Loving it? I think it's pretty static.
    Let's add some animations.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们的角色现在出现在屏幕上了。喜欢吗？我觉得它相当静态。让我们添加一些动画。
- en: Animations
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画
- en: 'Now we are going to work on the animations. We''ll introduce three new classes
    in this section: `MOAIDeckRemapper`, `MOAIAnimCurve`, and `MOAIAnim`. Let''s see
    how these interact.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将开始处理动画。在本节中，我们将介绍三个新的类：`MOAIDeckRemapper`、`MOAIAnimCurve` 和 `MOAIAnim`。让我们看看它们是如何交互的。
- en: 'First of all, on the `character_object` table on `character.lua`, let''s add
    the following (below position):'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `character.lua` 中的 `character_object` 表上，让我们在以下位置添加以下内容：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is the definition for the three animations we're going to use. Take a look
    at it and see that we define a start frame (the tileset index where the animation
    starts), the frame count (the amount of frames for the animation; these frames
    need to be sequentially placed in the tileset, as per the preceding example),
    the time between each frame, and the animation mode.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是我们要使用的三个动画的定义。看看它，你会发现我们定义了一个起始帧（动画开始的瓦片集索引），帧数（动画的帧数；这些帧需要按照前面的示例顺序放置在瓦片集中），每帧之间的时间，以及动画模式。
- en: Similar to `MOAIEaseType`, `MOAITimer` has a bunch of different animation modes.
    You can check them out at [http://getmoai.com/docs/class_m_o_a_i_timer.html](http://getmoai.com/docs/class_m_o_a_i_timer.html).
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类似于 `MOAIEaseType`，`MOAITimer` 有许多不同的动画模式。你可以在 [http://getmoai.com/docs/class_m_o_a_i_timer.html](http://getmoai.com/docs/class_m_o_a_i_timer.html)
    查看它们。
- en: 'Then, we need to add a `MOAIDeckRemapper`. `MOAIDeckRemapper` is used in combination
    with an animation curve in order to tell the Prop which tileset index should be
    displayed in each animation step. Enter the following code in `Character:initialize()`:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要添加一个 `MOAIDeckRemapper`。`MOAIDeckRemapper` 与动画曲线结合使用，以便告诉属性在每个动画步骤中应该显示哪个瓦片集索引。在
    `Character:initialize()` 中输入以下代码：
- en: '[PRE23]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We'll remap just one index (the character animation frame), so we reserve just
    one remapper index.
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将仅重映射一个索引（角色动画帧），因此我们只保留一个重映射器索引。
- en: '[PRE24]'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Then we assign the remapper to the Prop.
  id: totrans-109
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们将重映射器分配给属性（Prop）。
- en: '![Animations](img/5064_08_03.jpg)'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![动画](img/5064_08_03.jpg)'
- en: For the animation to work, we need to create a curve. It will be used to tell
    our `MOAIDeckRemapper` instance which tileset index should be used at a given
    animation step.
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了使动画能够运行，我们需要创建一个曲线。它将被用来告诉我们的 `MOAIDeckRemapper` 实例在给定的动画步骤中应该使用哪个瓦片集索引。
- en: The remapper will be in charge of changing the current Prop's index to the correct
    one.
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重映射器将负责将当前属性（Prop）的索引更改为正确的索引。
- en: The interesting thing is that these curves are defined using keys that set the
    value for a given point in the animation. These values are then interpolated using
    a `MOAIEaseType` curve.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有趣的是，这些曲线是通过设置动画中给定点的值的键来定义的。然后，使用 `MOAIEaseType` 曲线对这些值进行插值。
- en: This is really nice, since we don't have to specify each point in our animation,
    just two of them and the rest are interpolated. Let's see how this works.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这真的很方便，因为我们不需要指定动画中的每个点，只需要两个点，其余的将通过插值生成。让我们看看它是如何工作的。
- en: Let's create a method that will add an animation and review it step by step.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建一个方法来添加动画并逐步审查它。
- en: '[PRE25]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: First, we create an animation curve. These curves are used to generate a specific
    behavior on how to move through the frames. We create a series of points that
    will create a curve (interpolating values). The animation will query the curve
    at a specific point of time and use its value.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们创建一个动画曲线。这些曲线用于生成在帧之间移动的特定行为。我们创建一系列点来生成曲线（插值值）。动画将在特定时间查询曲线并使用其值。
- en: '[PRE26]'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: A **key** is a value that we use to define the curve. We'll need two keys here
    (the start and the end of the curve), but you might want more than one (for example,
    if some part of the animation needs to run faster than the others or stuff like
    that).
  id: totrans-119
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**键**是我们用来定义曲线的值。这里我们需要两个键（曲线的开始和结束），但你可能需要更多（例如，如果动画的某些部分需要比其他部分运行得更快或类似的情况）。'
- en: '[PRE27]'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Using `setKey ()` we define a key:'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `setKey()` 我们定义一个键：
- en: The first parameter is the key number (starting at one). The second is the time
    at which that key should happen; in this case, since it's the first key for our
    animation, the time is zero. Then, we pass the value of that key; in our case,
    it'll be our `startFrame`, and then `MOAIEaseType`. Ease types are a way to tell
    animations to use different curves. In this case, we're using a linear curve.
  id: totrans-122
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个参数是键号（从一开始）。第二个参数是键应该发生的时间；在这种情况下，由于这是动画的第一个键，所以时间是零。然后，我们传递该键的值；在我们的例子中，它将是我们的
    `startFrame`，然后是 `MOAIEaseType`。缓动类型是一种告诉动画使用不同曲线的方式。在这种情况下，我们使用的是线性曲线。
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The second key will be the last one. For the second parameter (`time`), we multiply
    the time between frames by the frame count, should be the total time for the animation.
    After that, we tell it to stop at `frameCount` frames after `startFrame` and,
    again, we use linear interpolation.
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第二个键将是最后一个。对于第二个参数（`time`），我们将帧之间的时间乘以帧数，应该是动画的总时间。之后，我们告诉它在`startFrame`之后的`frameCount`帧处停止，并且再次使用线性插值。
- en: When creating our animation, this will create a linear function from `startFrame`
    at time 0 to `startFrame + frameCount` at the end of the curve. Just what we want
    for our animation.
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当创建我们的动画时，这将创建一个从时间0的`startFrame`到曲线末尾的`startFrame + frameCount`的线性函数。这正是我们动画所需要的。
- en: '[PRE29]'
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, we create our animation, reserve one link that will be used to connect
    the curve to the remapper, and then we connect them.
  id: totrans-127
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建我们的动画，预留一个将用于将曲线连接到重映射器的链接，然后我们将它们连接起来。
- en: What will happen here is that when we start the animation, it will iterate through
    the curve passing the result of the curve to the remapper. When that happens,
    the remapper will change the image displayed by the Prop. The one at the end of
    the call is the index of the remapper we'll be using; since we only reserved one,
    we pass one there.
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里会发生的事情是，当我们开始动画时，它将遍历曲线，并将曲线的结果传递给重映射器。当这种情况发生时，重映射器将改变Prop显示的图像。调用末尾的是我们将使用的重映射器的索引；因为我们只预留了一个，所以我们在这里传递一个。
- en: '[PRE30]'
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Here we set the animation mode we defined.
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们设置了定义的动画模式。
- en: '[PRE31]'
  id: totrans-131
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To finish this, we store the animation under the name we passed as a parameter.
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成此操作后，我们将动画存储为我们传递的参数名称下。
- en: The way this works is not trivial, so it may take a while for you to process
    it. You should play around with the definition and parameters to get an idea of
    how the `MOAIAnim` + `MOAIAnimCurve` + `MOAIDeckRemapper` workflow interacts.
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这种工作方式并不简单，因此你可能需要一段时间来处理它。你应该尝试调整定义和参数，以了解`MOAIAnim` + `MOAIAnimCurve` + `MOAIDeckRemapper`工作流程的交互方式。
- en: 'We''ll define some auxiliary methods to work with these animations:'
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将定义一些辅助方法来处理这些动画：
- en: '[PRE32]'
  id: totrans-135
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '`getAnimation` returns the animation that is indexed by name.'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`getAnimation`返回按名称索引的动画。'
- en: '[PRE33]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this method, we stop the animation that is currently running if it exists.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个方法中，如果存在，我们将停止正在运行的动画。
- en: The following method is used to start an animation. Let's take a look at it.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下方法用于启动动画。让我们看看它。
- en: '[PRE34]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: First, we stop the current animation.
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们停止当前动画。
- en: Stopping the animation is really important, because a running animation consumes
    some memory, and if we don't stop it, we'll end up having tons of animations running
    all the time and consuming a lot of memory. We figured this out while developing
    *The Insulines* as well.
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止动画非常重要，因为正在运行的动画会消耗一些内存，如果我们不停止它，我们最终会有大量的动画一直在运行，消耗大量内存。我们在开发*The Insulines*时也发现了这一点。
- en: '[PRE35]'
  id: totrans-143
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Then we get the animation indexed by name.
  id: totrans-144
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们通过名称索引获取动画。
- en: '[PRE36]'
  id: totrans-145
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: And then we start it.
  id: totrans-146
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后我们启动它。
- en: '[PRE37]'
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: We then return it, in case we want to do something with it later (such as blocking
    the coroutine to chain multiple animations, remember?).
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们返回它，以防我们稍后想对它做些什么（例如，阻塞协程以链接多个动画，记得吗？）。
- en: 'The last thing we need to do is parse all of the animations we defined inside
    `character_object` and create the necessary animations. To do this, go to `Character:initialize`,
    and at the bottom, include the following code:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要做的最后一件事是解析在`character_object`内部定义的所有动画，并创建必要的动画。为此，转到`Character:initialize`，并在底部包含以下代码：
- en: '[PRE38]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here we are iterating through all of the defined animations and are using the
    attributes as parameters for our `addAnimation ()` method.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在遍历所有定义的动画，并使用属性作为`addAnimation()`方法的参数。
- en: 'The result will be that all the animations will be inside `Character.animations`
    and we''ll be able to access them through the methods created earlier (`startAnimation`
    and `stopAnimation`). To see if everything works fine, add the following line:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将是所有动画都将包含在`Character.animations`中，我们将能够通过之前创建的方法（`startAnimation`和`stopAnimation`）访问它们。为了检查一切是否正常工作，请添加以下行：
- en: '[PRE39]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This should start the running animation. You will want to experiment a little
    bit with this by changing the parameters in the definitions and calling different
    animations.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该会启动正在运行的动画。你可能需要通过更改定义中的参数并调用不同的动画来稍微实验一下。
- en: Summary
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started to implement the initial structure for our platformer
    prototype. We created a camera and learned how to move it. We also played with
    layers and parallax. Then we added our character and learned about how to create
    animations from a tiled image.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始为我们的平台游戏原型实现初始结构。我们创建了一个摄像头并学习了如何移动它。我们还尝试了层和视差效果。然后我们添加了我们的角色，并了解了如何从瓦片图像创建动画。
- en: In the next chapter, we'll introduce some physics to the prototype using Box2D,
    which is already shipped with Moai SDK.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用已经随 Moai SDK 一起发布的 Box2D 引擎，将一些物理知识引入原型。
