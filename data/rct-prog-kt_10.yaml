- en: Introduction to Web Programming with Spring for Kotlin Developers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为 Kotlin 开发者介绍使用 Spring 进行 Web 编程
- en: Kotlin is a powerful language, and its power increases, even more, when the
    Spring Framework is used with it. Up until this point, you've learned the concepts
    of reactive programming and how to apply these concepts to Kotlin. So far, we
    developed and wrote code that interacts with the console, but that's not what
    we will do while developing professional apps. We will either build apps that
    will run on mobile devices or we will build web applications or REST APIs. At
    least those are the most commonly built professional software solutions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 是一种强大的语言，当与 Spring 框架结合使用时，其力量更是倍增。到目前为止，你已经学习了响应式编程的概念以及如何将这些概念应用到 Kotlin
    中。到目前为止，我们开发和编写的代码是与控制台交互的，但在开发专业应用程序时，我们不会这样做。我们将构建在移动设备上运行的应用程序，或者构建 Web 应用程序或
    REST API。至少，这些都是最常见的专业软件解决方案。
- en: So, how to build them? How to create RESTful web APIs and Android apps? Let's
    discover. The last three chapters of this book are dedicated to building REST
    APIs and Android apps and, most importantly, making them reactive. Spring is such
    a vast topic that covering it in a single chapter is simply not possible, so we
    will have two chapters on Spring.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如何构建它们？如何创建 RESTful Web API 和 Android 应用程序？让我们来探索。本书的最后一章将致力于构建 REST API
    和 Android 应用程序，最重要的是，使它们具有响应性。Spring 是一个如此广泛的话题，以至于在一个章节中涵盖它是不可能的，因此我们将有两个章节专门介绍
    Spring。
- en: This chapter will start by introducing you to Spring, and, by the end of this
    chapter, you should be proficient enough to write REST APIs in Kotlin with Spring.
    We will not add reactive features in this chapter because we don't want to distract
    you from the concepts and ideas of Spring. We want you to grasp the concepts and
    knowledge of Spring itself well enough before moving ahead with making them reactive.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将从介绍 Spring 开始，到本章结束时，你应该足够熟练，能够使用 Spring 在 Kotlin 中编写 REST API。我们不会在本章中添加响应式功能，因为我们不想让你分心于
    Spring 的概念和思想。我们希望你在继续进行使它们具有响应性之前，能够充分掌握 Spring 的概念和知识。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to Spring, history, and origin of Spring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 简介，Spring 的历史和起源
- en: Spring IoC and dependency injection
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring IoC 和依赖注入
- en: Aspect-oriented programming in Spring
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring 中的面向方面编程
- en: Introduction to Spring Boot
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot 简介
- en: Building REST APIs with Spring Boot
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 构建 REST API
- en: So, what are we waiting for? Let's get started and get familiar with Spring.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还在等什么呢？让我们开始，熟悉 Spring。
- en: Spring, history, and origin of Spring
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring，Spring 的历史和起源
- en: What is Spring? We cannot give a short answer. It's really tough to define Spring
    in a sentence or two. Many people may say Spring is a framework, but this would
    be also an understatement for Spring, as it may also be called a **framework of
    frameworks**. Spring provides you with a lot of tools, such as **DI** (**dependency
    injection**), **IoC** (**Inversion of Control**), and **AOP** (**Aspect-oriented
    programming**). While we can use Spring in almost any type of Java or Kotlin JVM
    application, it is most useful while developing web applications on top of the
    Java EE platform. Before moving into the details of Spring, we should first understand
    from where and why Spring originated and how it has evolved.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Spring 是什么？我们无法给出简短的答案。用一句话或两句话来定义 Spring 真的是很难。许多人可能会说 Spring 是一个框架，但这对于 Spring
    来说也是一种低估，因为它也可能被称为“框架的框架”。Spring 为你提供了许多工具，例如 **DI**（**依赖注入**）、**IoC**（**控制反转**）和
    **AOP**（**面向方面编程**）。虽然我们可以在几乎任何类型的 Java 或 Kotlin JVM 应用程序中使用 Spring，但在基于 Java
    EE 平台开发 Web 应用程序时，它最有用。在深入了解 Spring 之前，我们应该首先了解 Spring 的起源和为什么它会出现，以及它是如何演变的。
- en: The origin and history of Spring
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring 的起源和历史
- en: It has been more than two decades (around 22 years) since Java has been around.
    For enterprise application development, Java introduced a few technologies that
    were heavyweight and were very complex enough.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 自 Java 诞生以来已经超过二十年了（大约 22 年）。对于企业级应用开发，Java 引入了一些重量级且非常复杂的技术。
- en: In 2003, Rod Johnson created Spring as an alternative to the heavyweight and
    complex Enterprise Java Technologies and EJB to make it easy to develop enterprise
    applications in Java. Being lightweight, flexible, and easy to use, Spring gained
    popularity soon. Over time, EJB and Java Enterprise Edition (then J2EE) evolved
    to support POJO-oriented programming models such as Spring. Not only that, arguably
    inspired by Spring, EJB also started offering AOP, DI, and IoC.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在 2003 年，Rod Johnson 创建了 Spring，作为一种替代重量级和复杂的 Enterprise Java 技术（EJB）的方案，以便在
    Java 中轻松开发企业应用程序。由于 Spring 轻量级、灵活且易于使用，它很快获得了人气。随着时间的推移，EJB 和 Java 企业版（当时称为 J2EE）演变为支持以
    POJO 为导向的编程模型，如 Spring。不仅如此，可以说受到 Spring 的启发，EJB 也开始提供 AOP、DI 和 IoC。
- en: However, Spring never looked back. As EJB and Java EE started including ideas
    inspired by Spring, Spring started exploring more unconventional and unexplored
    technology areas, such as Big Data, Cloud Computing, Mobile App Development, and
    even reactive programming, leaving EJB and Java EE far behind.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Spring 从未回头。随着 EJB 和 Java EE 开始包括受 Spring 启发的想法，Spring 开始探索更多非常规和未探索的技术领域，如大数据、云计算、移动应用开发，甚至反应式编程，将
    EJB 和 Java EE 远远抛在后面。
- en: 'During the start of the year, on the month of January 2017, Spring surprised
    everyone by announcing its support for Kotlin (yes, they announced Kotlin support
    even before Google) and released a few Kotlin APIs. And, when the power of Kotlin
    was combined with an already powerful Spring Framework, both got even more powerful.
    As a reason behind adding Kotlin support, they stated:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在年初的 2017 年 1 月，Spring 通过宣布支持 Kotlin（是的，他们甚至在 Google 之前宣布了 Kotlin 支持）并发布了一些
    Kotlin API，让所有人都感到惊讶。而且，当 Kotlin 的力量与已经强大的 Spring 框架结合时，两者都变得更加强大。他们添加 Kotlin
    支持的原因如下：
- en: One of the key strengths of Kotlin is that it provides a very good interoperability
    with libraries written in Java. But there are ways to go even further and allow
    writing fully idiomatic Kotlin code when developing your next Spring application.
    In addition to Spring Framework support for Java 8 that Kotlin applications can
    leverage like functional web or bean registration APIs, there are additional Kotlin
    dedicated features that should allow you to reach a new level of productivity.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的一个关键优势是它提供了与用 Java 编写的库非常好的互操作性。但是，有方法可以更进一步，允许在开发下一个 Spring 应用程序时编写完全符合
    Kotlin 习惯的代码。除了 Kotlin 应用程序可以利用的 Spring 框架对 Java 8 的支持，如函数式 Web 或 Bean 注册 API
    之外，还有额外的 Kotlin 专用功能，这应该允许你达到新的生产力水平。
- en: That's why we are introducing a dedicated Kotlin support in Spring Framework
    5.0.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们在 Spring 框架 5.0 中引入了专门的 Kotlin 支持。
- en: By Pivotal Spring Team [https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 由 Pivotal Spring 团队 [https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0](https://spring.io/blog/2017/01/04/introducing-kotlin-support-in-spring-framework-5-0)。
- en: So, let's start by creating and setting up our Spring project.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们首先创建并设置我们的 Spring 项目。
- en: Dependency injection and IoC
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入和 IoC
- en: '**Inversion of Control** (**IoC**) is a programming technique in which object
    coupling is bound at runtime by an assembler object and is typically not known
    at compile time using static analysis. IoC can be achieved using dependency injection.
    We can say that IoC is the idea and dependency injection is its implementation.
    Now, what is dependency injection? Let''s find out.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）是一种编程技术，其中对象耦合在运行时由一个组装对象绑定，通常在编译时通过静态分析是不可知的。IoC 可以通过依赖注入来实现。我们可以这样说，IoC
    是一个理念，而依赖注入是其实现。那么，什么是依赖注入呢？让我们来了解一下。'
- en: 'Dependency injection is a technique where one component supplies dependencies
    for another component during the instantiation time. The definition sounds confusing,
    right? Let''s explain it with an example. Consider the following interfaces:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种在实例化时一个组件为另一个组件提供依赖的技术。这个定义听起来很复杂，对吧？让我们用一个例子来解释它。考虑以下接口：
- en: '[PRE0]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: A common implementation of the preceding program will be as follows.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 上述程序的一个常见实现如下。
- en: 'The `Employee` class is as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '`Employee` 类如下：'
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'And the `Task` interface is implemented as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 接口实现如下：'
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Then, we will create and use the instance of the `RandomEmployee` class in
    the `main` method as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在 `main` 方法中创建并使用 `RandomEmployee` 类的实例，如下所示：
- en: '[PRE3]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `RandomTask` class is a simple class implementing an interface `Task`, which
    has a function named `execute`. The `RandomEmployee` class on the other hand depends
    on the `Task` class. Now, what do we mean by depends? By depends, we mean that
    the output of an instance of `Employee` class is dependent on the `Task` class.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomTask`类是一个简单的类，实现了名为`Task`的接口，该接口有一个名为`execute`的函数。另一方面，`RandomEmployee`类依赖于`Task`类。那么，我们所说的依赖是什么意思呢？通过依赖，我们指的是`Employee`类实例的输出依赖于`Task`类。'
- en: 'Let''s take a look at the following output:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下输出：
- en: '![](img/a2d67e5c-78c5-46bb-b82c-5e6c33cfb86f.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a2d67e5c-78c5-46bb-b82c-5e6c33cfb86f.jpg)'
- en: The preceding program would work fine, and actually, it is a text book program.
    In colleges/institutes, when we learned coding for the first time, we learned
    the way to initialize variables and/or properties inside constructors or during
    construction time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的程序将正常工作，实际上，它是一个教科书程序。在大学/学院，当我们第一次学习编码时，我们学习了在构造函数内部或构建时初始化变量和/或属性的方法。
- en: Now, just try to remember what you learned a few chapters earlier. We should
    test everything we write. Now, take a look at the code again—is this piece of
    code testable? Or even maintainable? How would you assure that the right *Employee*
    is given the right *Task*? It's a tightly coupled code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，试着回忆一下你之前几章学到的内容。我们应该测试我们所写的一切。现在，再次看看代码——这段代码是否可测试？或者甚至可维护？你将如何确保正确的*Employee*被分配了正确的*Task*？这是一个紧密耦合的代码。
- en: You should always use coupling concisely. It's true that we cannot achieve much
    without coupling. Tightly coupled code, on the other hand, makes it difficult
    to test and maintain.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终使用简洁的耦合。诚然，没有耦合我们无法取得很大成就。另一方面，紧密耦合的代码使得测试和维护变得困难。
- en: 'Rather than letting the objects create their dependencies at the construction
    time, dependency injection provides objects with their dependencies at creation
    time with some third-party class. That third-party class will also coordinate
    with each object in the system. The following diagram shows the general idea behind
    dependency injection:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是让对象在构建时创建它们的依赖关系，依赖注入在创建时通过某个第三方类为对象提供它们的依赖关系。这个第三方类也将与系统中的每个对象进行协调。以下图表展示了依赖注入背后的基本思想：
- en: '![](img/d639a1d5-8324-4935-ad92-01867c099882.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d639a1d5-8324-4935-ad92-01867c099882.jpg)'
- en: This image clearly depicts the flow of dependency injection. There will be a
    Config class (in Spring, there can be an XML Config file or there can be a Config
    class as well) that will create and drive a Bean Container. That Bean Container
    will control the creation of beans or POJOs and will pass them where required.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这张图片清楚地描述了依赖注入的流程。将有一个Config类（在Spring中，可以有一个XML配置文件，也可以有一个Config类）来创建和驱动Bean容器。该Bean容器将控制bean或POJO的创建，并将它们传递到所需的位置。
- en: 'Confused? Let''s get our hands-on code and implement the preceding concept.
    Let''s get started with a brand new implementation of the `Employee` interface
    as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 感到困惑？让我们动手编写代码并实现前面的概念。让我们从`Employee`接口的新实现开始，如下所示：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A `SoftwareDeveloper` class  can only execute `ProgrammingTask`. Now, take
    a look at the XML `config` file shown next:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`SoftwareDeveloper`类只能执行`ProgrammingTask`。现在，看看下面的XML`config`文件：'
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `ProgrammingTask` class, a new implementation of the `Task` interface,
    looks like as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProgrammingTask`类是`Task`接口的新实现，如下所示：'
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This file should be located at `\src\main\resources\META-INF\employee.xml`.
    Now, let's try to understand the `config` file. We declared each bean using the
    `bean` tag. Then, we used the `constructor-arg` tag to indicate a constructor
    argument in that bean.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此文件应位于`\src\main\resources\META-INF\employee.xml`。现在，让我们尝试理解`config`文件。我们使用`bean`标签声明了每个bean。然后，我们使用`constructor-arg`标签来指示该bean中的构造函数参数。
- en: If you want to pass another object as a `constructor-argref` in a bean, you
    have to declare that reference object as a bean as well. Alternatively, you can
    pass `constructor-arg value`, as discussed later in this chapter.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在bean中将另一个对象作为`constructor-argref`传递，你必须将该引用对象声明为bean。或者，你可以像本章后面讨论的那样传递`constructor-arg
    value`。
- en: 'The updated `main` function will look like this:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的`main`函数将如下所示：
- en: '[PRE7]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Before moving into the details of the preceding program, let''s take a look
    at its output:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解前面程序的细节之前，让我们先看看它的输出：
- en: '![](img/d986c93d-2532-4879-87d2-80aeff45e8b8.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d986c93d-2532-4879-87d2-80aeff45e8b8.jpg)'
- en: Cropped output of DI with XML Configuration program
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: DI与XML配置程序的裁剪输出
- en: The first few red-lined outputs are logs of the Spring Framework. Then, we can
    spot the output as Writing Programms.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 前几行红色的输出是Spring框架的日志。然后，我们可以看到输出为Writing Programms。
- en: Now, let's try to understand the program. The `ClassPathXmlApplicationContext`
    is the Bean Container we mentioned in the figure. It creates and keeps record
    of all the beans mentioned in the XML file and provides them to us when asked
    for. The `String` passed in the constructor of `ClassPathXmlApplicationContext`
    is the relative path to the XML configuration file.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们尝试理解这个程序。`ClassPathXmlApplicationContext`是我们图中提到的Bean容器。它创建并记录XML文件中提到的所有bean，并在需要时提供给我们。传递给`ClassPathXmlApplicationContext`构造函数的`String`是XML配置文件的相对路径。
- en: On comment `(2)`, we used `context.getBean()` to get the `Employee` instance.
    This function takes a class name as a parameter and creates an instance of that
    class based on the XML configuration.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(2)`中，我们使用了`context.getBean()`来获取`Employee`实例。这个函数接受一个类名作为参数，并根据XML配置创建该类的实例。
- en: On comment `(3)`, we closed the `context`. The `context`, as a Bean Container,
    always carries the configuration for you, which keeps the memory blocked. In order
    to clean the memory, we should close the `context`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在注释`(3)`中，我们关闭了`context`。`context`作为一个Bean容器，始终为你携带配置，这会阻塞内存。为了清理内存，我们应该关闭`context`。
- en: Now, as we have some idea about dependency injection via XML configuration file,
    we should move toward the annotation-based configuration class and take a look
    at how it works.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，既然我们已经对通过XML配置文件进行依赖注入有了些了解，我们应该转向基于注解的配置类，看看它是如何工作的。
- en: Spring Annotation configuration
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring注解配置
- en: Other than XML, we can also define Spring configuration through annotations
    in a POJO class, which will not be used as a bean. In the previous section, we
    took `Employee` task example; let's now take the `Student`-`Assignment` example,
    a similar one. However, this time, we will not use interfaces; instead, we will
    directly use classes.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 除了XML之外，我们还可以在POJO类中通过注解定义Spring配置，这个类不会被用作bean。在上一节中，我们以`Employee`任务为例；现在让我们以`Student`-`Assignment`为例，一个类似的例子。然而，这次，我们不会使用接口；而是直接使用类。
- en: 'So, here is the `Assignment` class that takes a lambda as a constructor parameter:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是接受lambda作为构造函数参数的`Assignment`类：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This class takes a lambda as `task`, to execute it later, inside the `performAssignment()`
    method. Here is the `Student` class that takes `Assignment` as a property:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类接受一个lambda作为`task`，在`performAssignment()`方法中稍后执行。以下是接受`Assignment`作为属性的`Student`类：
- en: '[PRE9]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'So, `Student` would depend on its `Assignment` and an `Assignment` would depend
    on its task definition (Lambda). The following diagram describes the dependency
    flow for this example:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`Student`将依赖于其`Assignment`，而`Assignment`将依赖于其任务定义（Lambda）。以下图描述了此示例的依赖流：
- en: '![](img/7d938d44-b837-40cc-b715-ee0d9190c556.png)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7d938d44-b837-40cc-b715-ee0d9190c556.png)'
- en: 'How to depict this dependency flow in code? It''s easy with Annotation Config.
    Here is the `Configuration` class that we used:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如何在代码中描述这个依赖流？使用注解配置就很容易。以下是我们所使用的`Configuration`类：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Simple and straightforward, isn't it? The class is annotated with `@Configuration`,
    and the function to return the `Student` and `Assignment` beans is annotated with
    `@Bean`.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 简单直接，不是吗？这个类被注解了`@Configuration`，返回`Student`和`Assignment`对象的函数被注解了`@Bean`。
- en: 'Now, how to use this class? Simple, like the previous one, take a look at the
    `main` function here:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如何使用这个类？很简单，就像之前的那个一样，看看这里的`main`函数：
- en: '[PRE11]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Instead of `ClassPathXmlApplicationContext`, we used `AnnotationConfigApplicationContext`
    and passed the `Configuration` class. The rest of the program is the same.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有使用`ClassPathXmlApplicationContext`，而是使用了`AnnotationConfigApplicationContext`并传递了`Configuration`类。程序的其他部分保持不变。
- en: 'This is the output of the program:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这是程序的输出：
- en: '![](img/c62a0eb0-8c8e-46fc-8bd2-93ccd9dce3ae.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c62a0eb0-8c8e-46fc-8bd2-93ccd9dce3ae.jpg)'
- en: Cropped output of DI with Annotation Configuration program
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: DI with Annotation Configuration程序的裁剪输出
- en: So, we learned dependency injection with Spring. It's really easy, isn't it?
    Actually, the Spring Framework makes everything easy; whatever feature they offer,
    they make it as easy as calling a method from a POJO class. Spring truly utilizes
    the power of a POJO.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们学习了使用Spring的依赖注入。这真的很简单，不是吗？实际上，Spring框架让一切变得简单；无论他们提供什么功能，他们都让它像从POJO类中调用方法一样简单。Spring真正利用了POJO的力量。
- en: So, as we got our hands on dependency injection, let's move forward with Aspect-oriented
    programming.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经掌握了依赖注入，让我们继续学习面向切面的编程。
- en: Spring – AOP
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring – AOP
- en: Before learning how to implement Aspect-oriented programming with Spring, we
    should first learn what Aspect-oriented programming is. The definition of Aspect-oriented
    programming says it is a programming paradigm that aims to increase modularity
    by allowing the separation of cross-cutting concerns. It does so by adding additional
    behavior to existing code (an advice) without modifying the code itself.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习如何使用Spring实现面向切面编程之前，我们首先应该了解什么是面向切面编程。面向切面编程的定义表明，它是一种旨在通过允许分离横切关注点来增加模块化的编程范式。它是通过向现有代码添加额外的行为（建议）来实现的，而不修改代码本身。
- en: Now, what did we mean by cross-cutting concerns? Let's explore.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们所说的横切关注点是什么意思？让我们来探索一下。
- en: In a real-life project, multiple components play their own role. For example,
    if we take our previous scenario into account, the `Student` class itself is a
    component, similarly there could be a faculty component who would evaluate the
    student based on his/her performance. So, let's add a faculty to our program.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际项目中，多个组件扮演着各自的角色。例如，如果我们考虑我们之前的场景，`Student`类本身就是一个组件，同样可能还有一个评估学生表现的教师组件。因此，让我们在我们的程序中添加一个教师。
- en: 'The `Faculty` class should be simple enough, with just a method to evaluate
    a student. Just as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Faculty`类应该足够简单，只需要一个评估学生的方法。如下所示：'
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, how should the faculty grade a student? He/she must somehow know that
    the student has completed an assignment. A common implementation of this business
    logic would be by modifying the `Student` class, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，教师应该如何评分学生？他/她必须以某种方式知道学生已经完成了作业。这种业务逻辑的常见实现方法是通过修改`Student`类，如下所示：
- en: '[PRE13]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Faculty` instance will be passed to a `Student` instance, and, once the
    student is done with performing the assignment, it will call the `Faculty` instance
    and instruct it to evaluate the assignment. However, think again. Is this a proper
    implementation? Why should a student instruct his/her faculty? It's the faculty's
    job to evaluate assignments of a student; it just needs to get notified somehow.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Faculty`实例将被传递给`Student`实例，一旦学生完成作业，它将调用`Faculty`实例并指示它评估作业。然而，再思考一下。这是否是一个合适的实现？为什么学生要指示他的/她的教师？评估学生的作业是教师的工作；它只需要以某种方式得到通知。'
- en: That very thing is known as a cross-cutting concern. `Faculty` and `Student`
    are different components of the program. They shouldn't have direct interaction
    at the time of the assignment review.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 那正是所谓的横切关注点。`Faculty`和`Student`是程序的不同组件。在作业审查时，它们不应该有直接的交互。
- en: 'AOP let''s implement the same. So, here, the `Student` class will be back to
    almost its original state:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: AOP让我们实现相同的功能。因此，在这里，`Student`类将恢复到几乎原始的状态：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Did you notice the differences in the actual code for the `Student` class in
    the previous section? Yes, here we added `open` keyword to the class declaration
    and all the properties and functions of the class. The reason is that, to implement
    AOP, Spring sub-classes our beans and overrides methods (including getters of
    our properties). However, with Kotlin, everything is final unless you specify
    it as open, and that will block Spring AOP to accomplish its purpose. So, in order
    to make Spring work, we have to mention each property and method as open.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到了上一节中`Student`类实际代码中的差异吗？是的，在这里我们向类声明中添加了`open`关键字以及类的所有属性和函数。原因是，为了实现AOP，Spring会子类化我们的bean并覆盖方法（包括我们属性的getter）。然而，在Kotlin中，除非你明确指定为`open`，否则一切都是最终的，这将阻止Spring
    AOP实现其目的。因此，为了使Spring工作，我们必须将每个属性和方法都指定为`open`。
- en: 'The `main` method will be similar, except that we are back to XML-based configuration.
    Take a look at the following piece of code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`main`方法将类似，只是我们又回到了基于XML的配置。看看下面的代码片段：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The only file with new things is the configuration file. Take a look at the
    configuration file here before we explain it:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一包含新内容的文件是配置文件。在我们解释它之前，看看配置文件：
- en: '[PRE16]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: So, let's explain the configuration. On comment `(1)`, we declared a new bean
    named `faculty`, although it really isn't a new thing to you and you may have
    already expected it. I mentioned it in order to prepare you for the next few lines.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们解释一下配置。在注释`(1)`中，我们声明了一个名为`faculty`的新bean，尽管这对你来说并不是什么新鲜事，你可能已经预料到了。我提到它是为了让你为接下来的几行代码做准备。
- en: On comment `(2)`, we indicated that the AOP configuration begins. On comment
    `(3)`, we indicated that this AOP is regarding the `Faculty` class, as the `Faculty`
    class is the class that should be notified.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论 `(2)` 中，我们指出了 AOP 配置的开始。在评论 `(3)` 中，我们指出了这个 AOP 与 `Faculty` 类相关，因为 `Faculty`
    类是应该得到通知的类。
- en: On comment `(4)`, we declared `pointcut`. A `pointcut` is like a bookmark on
    a method, so whenever that method is called, your class should get notified. The
    `id` field denotes the `id` for that `pointcut`, so that you can refer to it in
    your code. The expression field denotes the expression for which we should create
    the `pointcut`. Here, with the execution expression, we stated that the `pointcut`
    should be on execution of the `completeAssignment` method.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论 `(4)` 中，我们声明了 `pointcut`。`pointcut` 就像方法上的书签，所以每当该方法被调用时，你的类都应该得到通知。`id`
    字段表示该 `pointcut` 的 `id`，这样你就可以在代码中引用它。`expression` 字段表示我们应该为它创建 `pointcut` 的表达式。在这里，使用执行表达式，我们声明
    `pointcut` 应该在 `completeAssignment` 方法的执行时触发。
- en: On comment `(5)`, we declared the method in `Faculty` class that should get
    called after the `pointcut` expression is executed. We can also declare a method
    to execute before `pointcut` by using `aop:before`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在评论 `(5)` 中，我们声明了在 `Faculty` 类中应该调用的方法，该方法应在 `pointcut` 表达式执行后调用。我们也可以使用 `aop:before`
    声明一个在 `pointcut` 之前执行的方法。
- en: 'So, now, let''s take a look at the following output:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下输出：
- en: '![](img/a19345db-f043-4316-ad37-e7c8f6ee1d73.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a19345db-f043-4316-ad37-e7c8f6ee1d73.jpg)'
- en: Cropped output of DI with Spring AOP program
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Spring AOP 程序的 DI 剪影输出
- en: As you can see, the `evaluateAssignment` method is called from the `Faculty`
    class every time we call the `completeAssignment` method, apparently, with no
    code, but only with configuration.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，每次我们调用 `completeAssignment` 方法时，都会从 `Faculty` 类中调用 `evaluateAssignment`
    方法，显然，这是没有代码，只有配置。
- en: Introduction to Spring Boot
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Spring Boot 简介
- en: So, we are now familiar with Spring, especially with Spring DI and AOP. Spring
    Boot makes a developer's life easier. So far, we've seen how to perform various
    operations just by using POJO classes and Spring configurations. What would be
    your reaction if I tell you that we can even minimize this configuration? Will
    you be shocked? Then brace yourself, because it's true. With Spring Boot, you
    can get your code ready with minimal configuration and in just a few steps.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在已经熟悉了 Spring，特别是 Spring DI 和 AOP。Spring Boot 使开发者的生活变得更简单。到目前为止，我们已经看到了如何仅通过使用
    POJO 类和 Spring 配置来执行各种操作。如果告诉你我们可以进一步减少配置，你会作何反应？你会震惊吗？那么，请做好准备，因为这是真的。使用 Spring
    Boot，你可以通过最少的配置和几个步骤来准备你的代码。
- en: So, what is Spring Boot? It is a Spring module that provides **RAD** (**Rapid
    application development**) features to the Spring Framework. It is designed to
    simplify the bootstrapping and development of new Spring applications. The framework
    takes an opinionated approach to configuration, freeing developers from the requirement
    to define boilerplate configurations, further reducing your development time.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，Spring Boot 是什么？它是一个为 Spring 框架提供 **RAD**（**快速应用开发**）功能的 Spring 模块。它旨在简化新
    Spring 应用的启动和开发。该框架采用了一种有观点的配置方法，使开发者免于定义样板配置，从而进一步减少开发时间。
- en: 'So, let''s get started. If you are using the IntelliJ IDEA Ultimate edition,
    you can follow these steps to create a Spring Boot application:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。如果你使用的是 IntelliJ IDEA Ultimate 版本，你可以按照以下步骤创建一个 Spring Boot 应用程序：
- en: Start a New Project.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目。
- en: 'From the New Project dialog, select Spring Initializr, define Project SDK,
    and click on Next, as shown in the following screenshot:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从新项目对话框中，选择 Spring Initializr，定义项目 SDK，然后点击下一步，如图所示：
- en: '![](img/1e14e69a-b5a2-45d1-87d7-487f052952ab.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1e14e69a-b5a2-45d1-87d7-487f052952ab.jpg)'
- en: 'On the next screen, define the Group, Artifact, Type (Gradle or Maven), Language
    (Java/Kotlin), Packaging (Jar/War), Java Version, Name, and root package for the
    project, as shown in the following screenshot:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏中，定义 Group、Artifact、Type（Gradle 或 Maven）、Language（Java/Kotlin）、Packaging（Jar/War）、Java
    Version、Name 和项目的根包，如图所示：
- en: '![](img/a5e6b338-6453-455e-ae70-13b215a68658.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5e6b338-6453-455e-ae70-13b215a68658.jpg)'
- en: 'The next screen lets you select multiple Spring dependencies. Make sure to
    set the Spring Boot version to 2.0.0 M6 and above in this screen. For AOP and
    DI, you need to select Aspects under Core, as shown in the screenshot:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一屏允许你选择多个 Spring 依赖项。确保在此屏幕上将 Spring Boot 版本设置为 2.0.0 M6 或更高版本。对于 AOP 和 DI，你需要在核心部分下选择
    Aspects，如图所示：
- en: '![](img/c0a487cd-5222-446e-ad38-0f2c3ec482f3.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c0a487cd-5222-446e-ad38-0f2c3ec482f3.jpg)'
- en: Provide Project name and location and click on Finish.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供项目名称和位置，然后点击完成。
- en: 'Wasn''t it quite easy? Don''t get upset if you don''t have IntelliJ IDEA Ultimate.
    Spring Boot is for everyone. Follow these steps to create a new Spring Boot project
    for whatever IDE you have:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是很简单吗？如果你没有 IntelliJ IDEA Ultimate，请不要沮丧。Spring Boot 是面向每个人的。按照以下步骤，使用你拥有的任何
    IDE 创建一个新的 Spring Boot 项目：
- en: Go to [http://start.spring.io/](http://start.spring.io/).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [http://start.spring.io/](http://start.spring.io/)。
- en: 'Provide the following details, which are similar to IntelliJ IDEA:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供以下详细信息，这些与 IntelliJ IDEA 类似：
- en: '![](img/ef1f3344-e47a-4e47-857b-51e2d305ffb7.jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ef1f3344-e47a-4e47-857b-51e2d305ffb7.jpg)'
- en: Click on Generate Project. The project will get downloaded to your machine.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击生成项目。项目将被下载到你的机器上。
- en: Wasn't it simple enough? Let's try our hands at creating APIs with Spring.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 难道不是足够简单了吗？让我们尝试使用 Spring 创建 API。
- en: Creating a Rest API with Spring Boot
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Spring Boot 创建 Rest API
- en: We've seen the power of Spring and Spring Boot. So, let's use it without any
    further delay. We will build a RESTful web service that will return a `Todo` object.
    We will further enhance this project in the next chapter, where we will add `Todo`
    and fetch a list of `Todo` from the database. We will use JPA and Hibernate along
    with Spring for that purpose.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了 Spring 和 Spring Boot 的力量。所以，让我们毫不拖延地使用它。我们将构建一个 RESTful 网络服务，该服务将返回一个
    `Todo` 对象。我们将在下一章进一步增强这个项目，我们将添加 `Todo` 并从数据库中获取 `Todo` 列表。我们将为此目的使用 JPA 和 Hibernate，以及
    Spring。
- en: 'When we are done with this example, we should get the following response:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们完成这个示例时，我们应该得到以下响应：
- en: '![](img/0d225d4c-79ae-4b5e-9211-07c844f9b455.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d225d4c-79ae-4b5e-9211-07c844f9b455.jpg)'
- en: Cropped screenshot of browser output
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 浏览器输出的裁剪截图
- en: So, let's start by creating a new project. You can use [http://start.spring.io/](http://start.spring.io/)
    or you can use IntelliJ IDEA as well to create a new project.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们先创建一个新的项目。你可以使用 [http://start.spring.io/](http://start.spring.io/)，或者你也可以使用
    IntelliJ IDEA 来创建一个新项目。
- en: 'After you have created the new project, you will see that there''s an `Application`
    class; don''t give much focus to it, it''s there in almost all Spring Boot applications.
    We need to create a new class for `Todo`, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在你创建了新项目之后，你会看到有一个 `Application` 类；不要过多关注它，它在几乎所有的 Spring Boot 应用程序中都有。我们需要创建一个新的类用于
    `Todo`，如下所示：
- en: '[PRE17]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'A REST API requires us to create `RestController`, which would be the endpoint
    for API requests, so here''s our `RestController`:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: REST API 要求我们创建 `RestController`，这将作为 API 请求的端点，所以这里是我们的 `RestController`：
- en: '[PRE18]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Study this small class carefully. First, we annotated our class with `@RestController`
    and `@RequestMapping`. The purpose of them is simple `@RestController` denotes
    that this class will act as a `Controller`, that is, all API requests should pass
    through this class, `@RequestMapping("/api")` denotes that the URL of this class
    will have an `/api` suffix after your base URL (note that the URL in the screenshot
    is `http://127.0.0.1:8080/api/get_todo`). We can skip the second annotation if
    we want for this class.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细研究这个小类。首先，我们用 `@RestController` 和 `@RequestMapping` 注解了我们的类。它们的目的很简单：`@RestController`
    表示这个类将作为 `Controller`，也就是说，所有的 API 请求都应该通过这个类，`@RequestMapping("/api")` 表示这个类的
    URL 将在基本 URL 后添加一个 `/api` 后缀（注意截图中的 URL 是 `http://127.0.0.1:8080/api/get_todo`）。如果我们想省略第二个注解，也是可以的。
- en: Then, we have the `getTodo()` function; the `@RequestMapping` annotation is
    required for this method as it will define the endpoint. This method is also simple—it
    just returns a new object of `Todo`, statically created.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们有 `getTodo()` 函数；这个方法需要 `@RequestMapping` 注解，因为它将定义端点。这个方法也很简单——它只是返回一个静态创建的
    `Todo` 新对象。
- en: 'What? Are you expecting anything more? Sorry to disappoint you, but we are
    done with the API. You can just run the project and hit `http://127.0.0.1:8080/api/get_todo`
    to get the following JSON response:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 什么？你期待更多吗？很抱歉让你失望，但我们已经完成了 API。你只需运行项目，然后访问 `http://127.0.0.1:8080/api/get_todo`
    来获取以下 JSON 响应：
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Isn't it simple enough?
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是足够简单了吗？
- en: Summary
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to Spring with Kotlin. We learned about
    dependency injection and Aspect-oriented programming. We learned how a simple
    POJO class can show great power with the help of the Spring Framework. In this
    chapter, we also learned to create a simple API with Spring.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你通过 Kotlin 了解了 Spring。我们学习了依赖注入和面向切面编程。我们学习了如何通过 Spring 框架，一个简单的 POJO 类可以展现出巨大的力量。在本章中，我们还学习了如何使用
    Spring 创建简单的 API。
- en: In the next chapter, we will focus on enhancing our API to a fully functional
    one with the help of JPA and Hibernate to work with MySQL database. We will also
    learn to implement reactive programming with Spring.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将专注于使用 JPA 和 Hibernate 来增强我们的 API，使其成为一个功能齐全的 API，以便与 MySQL 数据库协同工作。我们还将学习如何使用
    Spring 实现响应式编程。
- en: So, don't wait! Head over to the next chapter right now. Our API is still incomplete.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不要等待！立即前往下一章。我们的 API 仍然不完整。
