- en: Chapter 3. Using Autorelease Pools
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章：使用Autorelease Pools
- en: Consider that you are returning an object you've created (and therefore own)
    to a caller. If it's released inside your method, the returning object will be
    an invalid one. On the other hand, there is the basic rule that you have to release
    the objects you own; then, how do you release them? Simply put the object in the
    autorelease pool. The object is then released when the autorelease pool is drained.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在返回一个你创建（因此拥有）的对象给调用者。如果它在你的方法中被释放，返回的对象将是无效的。另一方面，有一个基本规则，你必须释放你拥有的对象；那么，你该如何释放它们？简单来说，将对象放入自动释放池。当自动释放池被清空时，对象就会被释放。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Understanding the autorelease pool mechanism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解自动释放池机制
- en: How autorelease pool helps
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Autorelease Pool如何帮助
- en: Autoreleased classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动释放类
- en: Autoreleased pool blocks and threads
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自动释放池块和线程
- en: Memory model in Objective-C
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Objective-C中的内存模型
- en: ARC with weak references
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弱引用ARC
- en: Understanding the autorelease pool mechanism
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解自动释放池机制
- en: 'When you first start developing for Cocoa (iOS or Mac OS) you quickly learn
    to follow the standard `alloc`, `init`, and (eventually) `release` cycles:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当你刚开始为Cocoa（iOS或Mac OS）开发时，你会很快学会遵循标准的`alloc`、`init`和（最终）`release`周期：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This is great until you discover the convenience of just doing the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，直到你发现以下操作的便利性：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Let''s look inside and see what actually happens:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看内部实际发生了什么：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This approach is called autorelease pools and they are a part of the **Automated
    Reference Counting** (**ARC**) memory management model used by the Cocoa platform.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法被称为自动释放池，它们是Cocoa平台使用的**自动引用计数（ARC**）内存管理模型的一部分。
- en: The ARC compiler will autorelease any object for you, unless it's returned from
    a method that starts with `new`, `alloc`, `init`, `copy`, or `mutableCopy` in
    its name. As before, these objects are placed into an autorelease pool, but in
    order to introduce a new language construct, `NSAutoreleasePool` has been replaced
    by `@autoreleasepool`, a compiler directive. Even using ARC, we are still free
    to use `autorelease` messages to drain/create our pool at any time. It doesn't
    affect the compiler when implementing `retain` and `release` messages, but provides
    hints when it's safe to make autoreleased objects go out of scope.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: ARC编译器会为你自动释放任何对象，除非它来自一个以`new`、`alloc`、`init`、`copy`或`mutableCopy`开头的方法。和之前一样，这些对象被放入自动释放池，但为了引入一个新的语言结构，`NSAutoreleasePool`已被`@autoreleasepool`编译器指令所取代。即使使用ARC，我们仍然可以自由地使用`autorelease`消息在任何时候清空/创建我们的池。它不会影响实现`retain`和`release`消息时的编译器，但提供了当自动释放对象安全退出作用域时的提示。
- en: Cocoa frameworks (Foundation Kit, Application Kit, and Core Data) have some
    suitable methods to handle basic classes that inherit from `NSObject`, as `NSString`,
    `NSArray`, `NSDictionary`, and many more. These methods quickly allocate, initialize,
    and return the created object for you, which will also be autoreleased without
    you worrying about it so much.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Cocoa框架（Foundation Kit、Application Kit和Core Data）为从`NSObject`继承的基本类提供了一些合适的方法来处理，例如`NSString`、`NSArray`、`NSDictionary`等。这些方法会快速为你分配、初始化并返回创建的对象，而且你无需过多担心，该对象将会自动释放。
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that I really meant "without worrying so much", not "without worrying at
    all" because even with these handy frameworks that create and clear the object
    for you, there will be cases when you want to take more control and create additional
    autorelease pools yourself.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我真正想说的是“不必过多担心”，而不是“完全不担心”，因为即使有这些方便的框架为你创建和清除对象，也仍然会有你想要更多控制并自己创建额外的自动释放池的情况。
- en: Basically, an autorelease pool stores objects and when it's drained, it just
    sends the object a `release` message. The `NSAutoreleasePool` class is used to
    support Cocoa's reference-counted memory management system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，Autorelease Pool存储对象，当它被清空时，它只是向对象发送一个`release`消息。`NSAutoreleasePool`类用于支持Cocoa的引用计数内存管理系统。
- en: 'Autorelease pools were made by Apple and have been part of the language itself
    since OS X 10.7\. If a program references the `NSAutoreleasePool` class while
    in ARC mode, it''s considered invalid and is rejected in the build phase. Instead,
    in ARC mode, you need to replace it with `@autoreleasepool` blocks, thus defining
    a region where an autorelease pool is valid, as you can see in the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自动释放池是由苹果公司制作的，并且自OS X 10.7以来一直是语言的一部分。如果在ARC模式下程序引用了`NSAutoreleasePool`类，则被视为无效，并在构建阶段被拒绝。相反，在ARC模式下，你需要用`@autoreleasepool`块来替换它，从而定义一个自动释放池有效的区域，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In ARC mode, however, you should write:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在ARC模式下，你应该这样写：
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Even if you don't use ARC, you can take advantage of `@autoreleasepool` blocks
    that are far more effective than the `NSAutoreleasePool` class.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你不使用自动引用计数（ARC），你也可以利用比`NSAutoreleasePool`类更有效的`@autoreleasepool`块。
- en: Opposite to an environment that uses garbage collection, in one with reference
    counting, every object that receives an `autorelease` message is placed into an
    `NSAutoreleasePool` object. This `NSAutoreleasePool` class is like a collection
    of these objects and goes one by one sending a release message when it's drained.
    It drains the pool when you're out of scope. Then, every object retain's count
    is decreased by 1\. By using an autorelease as an alternative to a release message,
    you extend the object's lifetime, this time maybe even longer if the object is
    later retained or at least until the `NSAutoreleasePool` class is drained. If
    you put an object into the same pool more than once, for each time, it will receive
    a `release` message.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用垃圾回收的环境相反，在引用计数的环境中，每个收到`autorelease`消息的对象都会被放入一个`NSAutoreleasePool`对象中。这个`NSAutoreleasePool`类就像是一个这些对象的集合，当它被清空时，会逐个发送释放消息。当你超出作用域时，它会清空池子。然后，每个对象的保留计数会减少1。通过使用`autorelease`作为释放消息的替代，你延长了对象的生命周期，这次可能甚至更长，如果对象后来被保留，或者至少直到`NSAutoreleasePool`类被清空。如果你多次将对象放入同一个池子中，每次都会收到一个`release`消息。
- en: While into an environment with reference counting, Cocoa presumes there will
    always be an autorelease pool available; otherwise, objects that have received
    an `autorelease` message won't get released. This practice will leak memory and
    generate proper warning messages.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在引用计数的环境中，Cocoa假设始终会有一个可用的`autorelease`池；否则，收到`autorelease`消息的对象将不会被释放。这种做法会导致内存泄漏并生成适当的警告消息。
- en: At the beginning of a cycle of the event loop, an autorelease pool is created
    by the Application Kit (one of the Cocoa frameworks, also known as AppKit). It
    provides code to create and interact with GUI, and it's drained at the end of
    this cycle, then every autoreleased object created when processing an event is
    just released. It means you don't need to create the pools yourself as the Application
    Kit does it for you. However, if there are many autoreleased objects created by
    your application, you should consider the creation of "local" autorelease pools;
    this is an advantage to avoid the peak memory footprint.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件循环的周期开始时，应用程序套件（Cocoa框架之一，也称为AppKit）会创建一个`autorelease`池。它提供了创建和交互GUI的代码，并在该周期的末尾清空，然后处理事件时创建的每个自动释放对象都会被释放。这意味着你不需要自己创建池子，因为应用程序套件会为你做这件事。然而，如果你的应用程序创建了大量的自动释放对象，你应该考虑创建“局部”的自动释放池；这有助于避免峰值内存占用。
- en: To create an `NSAutoreleasePool` object, you can use the regular `alloc` and
    `init` methods and use `drain` to dismiss it. A pool cannot be retained; the consequences
    of `drain` is like a deallocation, and it's very important to do so in the same
    context you created it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个`NSAutoreleasePool`对象，你可以使用常规的`alloc`和`init`方法，并使用`drain`来销毁它。池子不能被保留；`drain`的效果就像是一个释放操作，这在同一个上下文中创建它非常重要。
- en: 'Every thread has its own stack of autorelease pools. These stacks contain `NSAutoreleasePool`
    objects, which in turn contain autoreleased objects. Every new autoreleased object
    is placed on the top of the pool and every new pool is placed on the top of the
    stack. A pool is removed from a stack when it''s drained. Before a thread is finished,
    it drains every autorelease pool on its stack. Despite the fact that an autorelease
    pool can be manually created and objects can be manually added to it, ARC still
    drains the pool automatically: you''re not allowed to do it yourself.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 每个线程都有自己的autorelease pool栈。这些栈包含`NSAutoreleasePool`对象，这些对象反过来包含autoreleased对象。每个新的autoreleased对象都放在池的顶部，每个新的pool都放在栈的顶部。当池被清空时，它从栈中被移除。在线程完成之前，它会清空其栈上的所有autorelease
    pool。尽管可以手动创建autorelease pool并手动将其添加到对象中，但ARC仍然会自动清空池：不允许你自己这样做。
- en: 'To ensure that you don''t have to worry about ownership, this is what ARC does:
    easily create autorelease pools, and make them temporarily handle the holding
    and releasing of autoreleased objects for you.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你不必担心所有权，这是ARC所做的事情：轻松创建autorelease pools，并暂时为你处理autoreleased对象的持有和释放。
- en: Autorelease pool mechanism
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Autorelease pool机制
- en: There will be times when you need to renounce an object's ownership and a good
    way to do it is by using autorelease pool blocks. Those blocks provide a mechanism
    where you can renounce it and avoid any chance of the object's immediate deallocation.
    Even if sometimes you will need to create your own blocks, or it will be in your
    advantage to do this way, you normally don't need to create them, but there are
    situations where you may need it.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候你需要放弃一个对象的所有权，而使用autorelease pool blocks是一个好方法。这些blocks提供了一个机制，让你可以放弃所有权并避免对象立即被释放。即使有时你需要创建自己的blocks，或者这样做对你有利，你通常不需要创建它们，但有些情况下你可能需要。
- en: 'As in the following code, an autorelease pool block is marked by the usage
    of `@autoreleasepool`:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 正如以下代码所示，autorelease pool block是通过使用`@autoreleasepool`来标记的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Objects that were created inside the block receive a release message when the
    block is terminated. An object receives release messages as many times as it receives
    an autorelease message inside the block.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在block内部创建的对象在block结束时收到释放消息。一个对象在block内部接收的释放消息次数与它接收的autorelease消息次数相同。
- en: 'Autorelease pool blocks can be nested as well:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Autorelease pool blocks也可以嵌套：
- en: '[PRE6]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If an autorelease message is not sent inside the autorelease pool block, Cocoa
    will return error messages and your application will leak memory. You generally
    don''t need to create your own autorelease pool blocks, but there are three situations
    where you will be required to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在autorelease pool block内部没有发送autorelease消息，Cocoa将返回错误消息，你的应用程序将发生内存泄漏。你通常不需要创建自己的autorelease
    pool blocks，但有三种情况下你需要：
- en: While creating a program that is not based on UI, such as a command-line one
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建一个不基于UI的程序时，例如命令行程序
- en: While creating a loop that generates a large number of temporary objects
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建一个生成大量临时对象的循环时
- en: When a secondary thread has to be created
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当需要创建一个次要线程时
- en: Reducing peak memory footprint with autorelease pool blocks
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用autorelease pool blocks减少峰值内存占用
- en: Memory footprint is basically the primary amount of memory used by a program
    in runtime. Temporary autoreleased objects are created in countless applications,
    and they add to the application's memory footprint until the block is ended. Allowing
    this accumulation until the current event loop finally ends, in some cases, may
    result in an exorbitant overhead and you might want to quickly get rid of those
    temporary objects; after all, they are highly adding to the memory footprint.
    In this case, the creation of your own "local" autorelease pool blocks is a solution.
    In the end, all objects are released, consequently deallocated, beneficially reducing
    the memory footprint.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 内存占用基本上是程序在运行时使用的内存的主要数量。在无数应用程序中，临时autoreleased对象被创建，并且它们会添加到应用程序的内存占用中，直到block结束。在某些情况下，允许这种积累直到当前事件循环最终结束，可能会导致过高的开销，你可能希望快速去除这些临时对象；毕竟，它们极大地增加了内存占用。在这种情况下，创建自己的“局部”autorelease
    pool blocks是一个解决方案。最终，所有对象都会被释放，从而被释放，有益地减少了内存占用。
- en: 'Here, you can see how to use an autorelease pool block for a `for` loop:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以看到如何为`for`循环使用autorelease pool block：
- en: '[PRE7]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: There is `NSArray` with many files' URLs and the loop processes one file at
    a time. Every object created inside the block is released when it's ended.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个包含许多文件URL的`NSArray`，循环一次处理一个文件。在块内部创建的每个对象在结束时都会被释放。
- en: 'Every object that was autoreleased inside the autorelease pool block is considered
    disposed of after the block''s termination. If you want to keep a temporary object
    and use it after the autorelease pool block is ended, you must do two things:
    inside the block, send a `retain` message to that object and then, only after
    the block, send the `autorelease` message, as we can see in the following code
    sample:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在autorelease pool块内部自动释放的每个对象，在块终止后都被视为已废弃。如果你想在autorelease pool块结束后保持一个临时对象并使用它，你必须做两件事：在块内部，向该对象发送一个`retain`消息，然后，只有在块之后，发送`autorelease`消息，如下面的代码示例所示：
- en: '[PRE8]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: As the comments in the preceding code explain, by sending a `retain` message
    to `myMatch` inside the autorelease pool block and then, only after the block,
    sending it an `autorelease` message increases this object's lifetime, making it
    available to receive messages outside and properly return it to the method's invoker.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如前述代码中的注释所解释，通过在autorelease pool块内部向`myMatch`发送`retain`消息，然后，只有在块之后，再发送`autorelease`消息，可以增加该对象的生存期，使其能够接收外部消息并正确地返回给方法的调用者。
- en: An overview of Apple autoreleased classes
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Apple自动释放类的概述
- en: As it was said before, the Cocoa framework provides factory methods with autorelease
    for many of the basic classes such as `NSString`, `NSArray`, `NSDictionary`, `NSColor`,
    and `NSDate`. However, in the same time, there are some classes that deserve special
    attention.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前所说，Cocoa框架为许多基本类提供了带autorelease的工厂方法，例如`NSString`、`NSArray`、`NSDictionary`、`NSColor`和`NSDate`。然而，同时也有一些类值得特别注意。
- en: NSRunLoop
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSRunLoop
- en: 'While using `NSRunLoop`, at the beginning of every run loop, an autorelease
    pool will be created, and it will only be destroyed at the end of this run loop.
    To clarify, every temporary object created inside it will be deallocated at the
    end of the running iteration. It might not be beneficial if you are creating a
    large number of temporary objects inside the block; in this case, you should consider
    creating a new autorelease pool, as shown here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用`NSRunLoop`时，在每次运行循环的开始，都会创建一个autorelease pool，并且它只会在这次运行循环结束时被销毁。为了澄清，在它内部创建的每个临时对象将在运行迭代的结束时被释放。如果你在块内部创建大量临时对象，这可能并不有利；在这种情况下，你应该考虑创建一个新的autorelease
    pool，如下所示：
- en: '![NSRunLoop](img/00005.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![NSRunLoop](img/00005.jpeg)'
- en: 'The following code demonstrates what was discussed earlier:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了之前讨论的内容：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that in order to end the autorelease pool, instead of sending a `release`
    message, we sent a `drain` message. It was done this way because in garbage collector
    mode, Objective-C runtime will simply ignore `release` messages, while the `drain`
    message won't be ignored, providing a hint to the collector; however, it doesn't
    destroy the autorelease pool.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了结束autorelease pool，我们发送的是`drain`消息而不是`release`消息。这样做的原因是因为在垃圾回收器模式下，Objective-C运行时会简单地忽略`release`消息，而`drain`消息则不会被忽略，这为回收器提供了一个提示；然而，它并不会销毁autorelease
    pool。
- en: Application Kit creates an autorelease pool in the main thread at the beginning
    of each iteration, event, and releases it at the end of each iteration, thus exempting
    all autorelease objects created during the processing of the event.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Application Kit在每个迭代的开始时在主线程中创建一个autorelease pool，并在每个迭代的结束时释放它，从而免除了在事件处理过程中创建的所有autorelease对象。
- en: Basically, the run loop in iOS waits for the complete execution of an event
    until the application does something else. These events can be touchscreen interactions,
    incoming calls, and so on.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，iOS中的运行循环会等待事件的完整执行，直到应用程序执行其他操作。这些事件可以是触摸屏交互、来电等。
- en: For each iOS event handling, a new autorelease pool is created at the beginning
    and released (drained) when the event's processing is completed. Theoretically,
    it can be any number of nested autorelease pools, but remember they are created
    at the beginning of the event's processing.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个iOS事件处理，在事件处理的开始时创建一个新的autorelease pool，并在事件处理完成后释放（排空）。理论上，可以有任意数量的嵌套autorelease
    pool，但请记住它们是在事件处理开始时创建的。
- en: NSException
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: NSException
- en: Exceptions may happen, and if they do occur, autorelease pools are automatically
    cleaned up after them. Autorelease pools prove to be a handful tool in order to
    write exception-safe code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会发生异常，如果确实发生了，异常发生后的自动释放池会自动清理。自动释放池被证明是编写异常安全代码的有力工具。
- en: 'Even an exception object itself should be autoreleased:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 即使是异常对象本身也应该自动释放：
- en: '[PRE10]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Using one of the preceding patterns will properly free the memory if an exception
    is thrown. It will free the memory in garbage collector mode as well, even if
    it''s not required in this GC mode:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面提到的任何一种模式，如果抛出异常，将正确释放内存。它还会在垃圾回收器模式下释放内存，即使在这个GC模式下不是必需的：
- en: '[PRE11]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: ARC and autorelease
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ARC和自动释放
- en: ARC does still use autorelease as a mechanism, but besides that, its compiled
    code is created to interoperate with no problem with MRC compiled code, thus autorelease
    is present.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: ARC仍然使用自动释放作为机制，但除此之外，其编译代码被创建为与MRC编译代码无问题地交互操作，因此自动释放存在。
- en: Despite the fact that ARC does a good job handling the memory management for
    us, there is still a situation when you need to use autorelease. Sometimes, we
    create a large number of temporary objects and many of them are only used once.
    In this case, you might want to free up the memory used by them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管ARC为我们很好地处理了内存管理，但仍然存在需要使用自动释放的情况。有时，我们创建大量临时对象，其中许多只使用一次。在这种情况下，你可能希望释放它们使用的内存。
- en: 'In order to dealloc those objects into the autorelease pool instead of waiting
    for them to be freed naturally, check out the following code sample in a non-ARC
    environment:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些对象释放到自动释放池而不是等待它们自然释放，请查看以下非ARC环境中的代码示例：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following sample code is for an ARC environment:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例代码是为ARC环境编写的：
- en: '[PRE13]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Autorelease pool blocks and threads
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自动释放池块和线程
- en: You will need to create your own autorelease pool if you are making Cocoa calls
    outside the main thread of the Application Kit. It may happen that you create
    a foundation-only application for example, or separate a thread.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在应用程序套件的主线程之外进行Cocoa调用，你需要创建自己的自动释放池。例如，你可能创建了一个仅使用基础库的应用程序，或者分离了一个线程。
- en: If your application generates a large number of autoreleased objects, instead
    of maintaining a single autorelease pool, you are highly advised to drain the
    autorelease pool and create a new one frequently. This behavior is used by Application
    Kit on the main thread. If you neglect this, your autoreleased objects don't deallocate,
    growing the memory footprint. On the other hand, if your thread doesn't make Cocoa
    calls, you can easily ignore this advice.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序生成大量自动释放对象，而不是维护单个自动释放池，强烈建议你频繁地排空自动释放池并创建一个新的。这种行为在应用程序套件的主线程上被使用。如果你忽视了这一点，你的自动释放对象不会释放，从而增加了内存占用。另一方面，如果你的线程没有进行Cocoa调用，你可以轻松忽略这一建议。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed autorelease pools and how to properly use them.
    We also highlighted the differences between `NSAutoreleasePool` and the new `@autoreleasepool`
    classes and its benefits.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了自动释放池及其正确使用方法。我们还强调了`NSAutoreleasePool`和新的`@autoreleasepool`类及其好处之间的差异。
- en: In the next chapter, we will talk about a few concepts related to object creation
    and initialization, such as immutability, inheritance, and so on. We will delve
    into design patterns such as singletons, which are commonly used in the iOS SDK,
    such as the `UIApplication` class that has a method called `sharedApplication`.
    We will also look into properties as a way to define the information that a class
    intends to encapsulate. We will also look into custom methods and format specifiers
    in [Chapter 4](part0032_split_000.html#page "Chapter 4. Object Creation and Storage"),
    *Object Creation and Storage*. We will cover a lot of materials in the next chapter,
    so sit tight and hang on while we head to [Chapter 4](part0032_split_000.html#page
    "Chapter 4. Object Creation and Storage"), *Object Creation and Storage*!
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论与对象创建和初始化相关的一些概念，例如不可变性、继承等。我们将深入研究如单例模式等设计模式，这些模式在iOS SDK中常用，例如具有名为`sharedApplication`方法的`UIApplication`类。我们还将探讨属性作为定义类意图封装的信息的方式。我们还将探讨在[第4章](part0032_split_000.html#page
    "第4章。对象创建和存储")中自定义方法和格式说明符，*对象创建和存储*。下一章我们将涵盖大量内容，所以请坐稳，在我们前往[第4章](part0032_split_000.html#page
    "第4章。对象创建和存储")，*对象创建和存储*时，请紧握不放！
