- en: Arrow Types
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 箭头类型
- en: Arrow contains many implementations of conventional functional types such as
    `Option`, `Either`, and `Try`, as well many other types classes, such as functor
    and monad.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 包含了许多传统函数类型的实现，如 `Option`、`Either` 和 `Try`，以及许多其他类型类，如 `functor` 和 `monad`。
- en: 'In this chapter, we''ll cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Using `Option` to manage null
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Option` 来管理空值
- en: '`Either` and `Try` to manage errors'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Either` 和 `Try` 用于管理错误'
- en: Combinations and transformers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合和转换器
- en: '`State` to manage application state'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State` 用于管理应用程序状态'
- en: Option
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选项
- en: The `Option<T>` datatype is the representation of a presence or absence of a
    value `T`. In Arrow, `Option<T>` is a sealed class with two sub-types, `Some<T>`,
    a data class that represents the presence of value `T` and `None`, and an object
    that represents the absence of value. Defined as a sealed class, `Option<T>` can't
    have any other sub-types; therefore the compiler can check clauses exhaustively,
    if both cases, `Some<T>` and `None` are covered.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option<T>` 数据类型是值 `T` 的存在或不存在的一种表示。在 Arrow 中，`Option<T>` 是一个密封类，有两个子类型，`Some<T>`，一个表示值
    `T` 存在的数据类，以及 `None`，一个表示值不存在的一个对象。作为一个密封类，`Option<T>` 不能有其他子类型；因此编译器可以全面检查，如果
    `Some<T>` 和 `None` 都被覆盖。'
- en: I know (or I pretend to know) what you're thinking at this very moment—why do
    I need `Option<T>` to represent the presence or absence of `T`, if in Kotlin we
    already have `T` for presence and `T?` for absence?
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道（或者假装知道）你此刻的想法——为什么我需要 `Option<T>` 来表示 `T` 的存在或不存在，如果 Kotlin 中已经有 `T` 表示存在，`T?`
    表示不存在呢？
- en: 'And you are right. But `Option` provides a lot more value than nullable types,
    let''s jump directly to an example:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你是对的。但是 `Option` 提供的比可空类型更多的价值，让我们直接跳到例子：
- en: '[PRE0]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `division` function takes three parameters—two integers (`a`, `b`) and a
    denominator (`den`) and returns a `Pair<Int, Int>`, if both numbers are divisible
    by `den` or `null` otherwise.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '`division` 函数接受三个参数——两个整数（`a`，`b`）和一个除数（`den`），如果两个数都能被 `den` 整除，则返回一个 `Pair<Int,
    Int>`，否则返回 `null`。'
- en: 'We can express the same algorithm with `Option`:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用 `Option` 表达相同的算法：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The function, `optionDivide` takes the nullable result from divide and returns
    it as an `Option`, using the `toOption()` extension function.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `optionDivide` 接受除法操作的空值结果，并使用 `toOption()` 扩展函数将其作为 `Option` 返回。
- en: 'There are no major changes on `optionDivision` compared to `division`, it is
    the same algorithm expressed with different types. If we stop here, then `Option<T>`
    doesn''t provide extra value on top of nullables. Luckily, that isn''t the case;
    there are more ways to use `Option`:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `division` 相比，`optionDivision` 没有太大变化，它是以不同类型表达的同一种算法。如果我们在这里停止，那么 `Option<T>`
    在可空类型之上并没有提供额外的价值。幸运的是，情况并非如此；有更多使用 `Option` 的方法：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`Option` provides several functions to process its internal value, in this
    case, `flatMap` (as a monad) and now our code looks a lot shorter.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option` 提供了几个函数来处理其内部值，在这个例子中，`flatMap`（作为一个 monad）以及现在我们的代码看起来要短得多。'
- en: 'Take a look at the following short list with some of the `Option<T>` functions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 看看以下简短列表中的一些 `Option<T>` 函数：
- en: '| **Function** | **Description** |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `exists(p :Predicate<T>): Boolean` | Returns predicate `p` result if value
    `T` exists, otherwise null. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `exists(p :Predicate<T>): Boolean` | 如果存在值 `T`，则返回谓词 `p` 的结果，否则返回 null。 |'
- en: '| `filter(p: Predicate<T>): Option<T>` | Returns `Some<T>` if the value `T`
    exists and fulfills the predicate `p`, otherwise `None`. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| `filter(p: Predicate<T>): Option<T>` | 如果值 `T` 存在并且满足谓词 `p`，则返回 `Some<T>`，否则返回
    `None`。 |'
- en: '|  `flatMap(f: (T) -> Option<T>): Option<T>` | A `flatMap` transform function
    (like monad). |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '|  `flatMap(f: (T) -> Option<T>): Option<T>` | 一个 `flatMap` 转换函数（类似于 monad）。
    |'
- en: '| `<R> fold(ifEmpty: () -> R, some: (T) -> R): R<R>` | Returns value transformed
    as `R`, invoking `ifEmpty` for `None` and some for `Some<T>`. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| `<R> fold(ifEmpty: () -> R, some: (T) -> R): R<R>` | 返回值被转换为 `R`，对于 `None`
    调用 `ifEmpty`，对于 `Some<T>` 调用 `some`。 |'
- en: '| `getOrElse(default:() -> T): T` | Returns value `T` if exists, otherwise
    returns `default` result. |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| `getOrElse(default:() -> T): T` | 如果存在值 `T`，则返回值 `T`，否则返回 `default` 结果。 |'
- en: '| `<R> map(f: (T) -> R):Option<T>` | A transform function (like `functor`).
    |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `<R> map(f: (T) -> R):Option<T>` | 一个转换函数（类似于 `functor`）。 |'
- en: '| `orNull(): T?` | Returns the value `T` as a nullable `T?`. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `orNull(): T?` | 将值 `T` 返回为可空的 `T?`。 |'
- en: 'The last implementation of division will use comprehensions:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的除法实现将使用列表推导式：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Comprehension is a technique to compute sequentially over any type (such as
    `Option`, `List`, and others) that contains a `flatMap` function and can provide
    an instance of monad (more on this later).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 组合是一种计算技术，可以按顺序计算任何包含 `flatMap` 函数并能提供 monad 实例的类型（例如 `Option`、`List` 等）。
- en: In Arrow, comprehensions use coroutines. Yes, coroutines are useful outside
    the asynchronous execution domain.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Arrow 中，使用协程进行组合。是的，协程在异步执行域之外也很有用。
- en: If we outline the continuations from our previous example it will look like
    this (which is a helpful mental model to understand coroutines)
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将之前示例中的延续进行概述，它将看起来像这样（这是一个有助于理解协程的有用心理模型）
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`Option.monad().binding` is a coroutine builder and the `bind()` function is
    a suspended function. If you recall correctly from our coroutines chapter, a continuation
    is a representation of any code after a suspension point (that is, when a suspended
    function is invoked). In our example, we have two suspension points and two continuations,
    when we return (in the last block line) we are in the second continuation, and
    we have access to both values, `aDiv` and `bDiv`.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option.monad().binding` 是一个协程构建器，而 `bind()` 函数是一个挂起函数。如果你正确地回忆起我们的协程章节，延续是任何挂起点之后（即挂起函数被调用时）的代码表示。在我们的示例中，我们有两个挂起点和两个延续，当我们返回（在最后一行块中）时，我们处于第二个延续中，我们可以访问两个值，`aDiv`
    和 `bDiv`。'
- en: Reading this algorithm as continuations is very similar to our `flatMapDivision`
    function. Behind the scenes, `Option.monad().binding` uses `Option.flatMap` with
    continuations to create the comprehension; once compiled, both `comprehensionDivision`
    and `flatMapDivision` are equivalent, roughly speaking.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 将此算法作为延续来阅读与我们的 `flatMapDivision` 函数非常相似。在幕后，`Option.monad().binding` 使用带有延续的
    `Option.flatMap` 来创建组合；一旦编译，`comprehensionDivision` 和 `flatMapDivision` 在很大程度上是等价的。
- en: The `ev()` method will be explained in the next section.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ev()` 方法将在下一节中解释。'
- en: Arrow's type hierarchy
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Arrow 的类型层次结构
- en: 'There is a limitation in Kotlin''s types system—it doesn''t support **Higher-Kinded
    Types** (**HKT**). Without getting too much into type theory, an HKT is a type
    that declares other generic values as type parameters:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 的类型系统存在一个限制——它不支持**高阶类型**（**HKT**）。不深入类型理论的话，HKT 是一种声明其他泛型值作为类型参数的类型：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Lacking HKT is not great for Kotlin concerning functional programming, as many
    advanced functional constructs and patterns use them.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 Kotlin 的函数式编程来说，缺少 HKT 并不是一件好事，因为许多高级函数式构造和模式都使用了它们。
- en: The Arrow team is working on **Kotlin Evolution and Enhancement Process** (**KEEP**)—the
    community process for adding new language features, called Type Classes as extensions
    in Kotlin ([https://github.com/Kotlin/KEEP/pull/87](https://github.com/Kotlin/KEEP/pull/87))
    to support HKT and other features. At this very moment, it isn't clear if this
    KEEP (coded as *KEEP-87*) will be included anytime soon in Kotlin, but right now
    is the most commented proposal and has attracted a lot of attention. Details aren't
    clear now as it is still a work in progress, but there is a glimpse of hope.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 团队正在致力于**Kotlin 进化和增强过程**（**KEEP**）——这是一个社区流程，用于添加新的语言特性，在 Kotlin 中称为类型类扩展（[https://github.com/Kotlin/KEEP/pull/87](https://github.com/Kotlin/KEEP/pull/87)）以支持
    HKT 和其他特性。目前，尚不清楚这个 KEEP（代码为 *KEEP-87*）何时会被纳入 Kotlin，但到目前为止，这是最受评论的提案，并吸引了大量关注。由于它仍在进行中，细节尚不明确，但其中透露出一丝希望。
- en: Arrow's solution to this problem is to simulate HKT through a technique called
    evidence-based HKTs.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 解决这个问题的方法是通过对称为基于证据的 HKTs 的技术进行模拟。
- en: 'Let''s have a look at an `Option<T>` declaration:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个 `Option<T>` 的声明：
- en: '[PRE6]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Option<A>` is annotated with `@higherkind` which is similar to `@lenses` from
    our previous chapter; this annotation is used to generate code to support evidence-based
    HKTs. `Option<A>` extends from `OptionKind<A>`:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Option<A>` 使用了 `@higherkind` 注解，这与我们上一章中提到的 `@lenses` 类似；这个注解用于生成支持基于证据的 HKTs
    的代码。`Option<A>` 从 `OptionKind<A>` 扩展而来：'
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`OptionKind<A>` is a type alias for `HK<OptionHK, A>`, all this code is generated
    using the `@higherkind` annotation processor. `OptionHK` is an uninstanciable
    class that is used as a unique tag name for `HK` and `OptionKind` is a kind of
    intermediate representation of HKT. `Option.monad().binding` returns `OptionKind<T>`,
    that is why we need to call `ev()` at the end to return a proper `Option<T>`:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`OptionKind<A>` 是 `HK<OptionHK, A>` 的类型别名，所有这些代码都是使用 `@higherkind` 注解处理器生成的。`OptionHK`
    是一个不可实例化的类，用作 `HK` 和 `OptionKind` 的唯一标签名称，而 `OptionKind` 是 HKT 的一种中间表示形式。`Option.monad().binding`
    返回 `OptionKind<T>`，这就是为什么我们需要在最后调用 `ev()` 来返回一个合适的 `Option<T>`：'
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`HK` interface (short-hand for **higher-kinded**) is used to represent an HKT
    of arity one up to `HK5` for arity 5\. On `HK<F, A>`, `F` represents the type
    and `A` the generic parameter, so `Option<Int>` is `OptionKind<Int>` value which
    is `HK<OptionHK, Int>`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`HK` 接口（**higher-kinded** 的简称）用于表示一元到 `HK5` 的 HKT，其中 `HK5` 表示五元。在 `HK<F, A>`
    上，`F` 表示类型，`A` 表示泛型参数，因此 `Option<Int>` 是 `OptionKind<Int>` 值，它是 `HK<OptionHK,
    Int>`。'
- en: 'Let''s have a look now at `Functor<F>`:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看 `Functor<F>`：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Functor<F>` extends `TC`, a marker interface and, as you can guess, it has
    a `map` function. The `map` function receives `HK<F, A>` as the first parameter
    and a lambda `(A) -> B` to transform the value of `A` into `B` and transform it
    into `HK<F, B>.`'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Functor<F>` 扩展 `TC`，一个标记接口，并且，正如你可以猜到的，它有一个 `map` 函数。`map` 函数接收 `HK<F, A>`
    作为第一个参数，并接收一个 lambda `(A) -> B` 来将 `A` 的值转换为 `B`，并将其转换为 `HK<F, B>`。'
- en: 'Let''s create our basic datatype `Mappable` that can provide instances for
    the `Functor` type class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的基本数据类型 `Mappable`，它可以提供 `Functor` 类型类的实例：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Our class, `Mappable<T>` is annotated with `@higherkind` and extends `MappableKind<T>`
    and must have a companion object, it doesn't matter if is empty or not.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们类 `Mappable<T>` 用 `@higherkind` 注解，并扩展 `MappableKind<T>`，必须有一个伴随对象，无论它是空的还是非空的。
- en: 'Now, we need to create our implementation of `Functor<F>`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建我们的 `Functor<F>` 实现：
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Our `MappableFunctorInstance` interface extends `Functor<MappableHK>` and is
    annotated with `@instance(Mappable::class)`. Inside the `map` function, we use
    the first parameter, `MappableKind<A>` and use its `map` function.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `MappableFunctorInstance` 接口扩展 `Functor<MappableHK>` 并用 `@instance(Mappable::class)`
    注解。在 `map` 函数内部，我们使用第一个参数 `MappableKind<A>` 并使用其 `map` 函数。
- en: The `@instance` annotation will generate an object extending the interface, `MappableFunctorInstance`.
    It will create an `Mappable.Companion.functor()` extension function to get the
    object implementing `MappableFunctorInstance` using `Mappable.functor()` (which
    is how we can use `Option.monad()`).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '`@instance` 注解将生成一个扩展接口的对象，`MappableFunctorInstance`。它将创建一个 `Mappable.Companion.functor()`
    扩展函数，使用 `Mappable.functor()`（这是我们如何使用 `Option.monad()` 的方式）来获取实现 `MappableFunctorInstance`
    的对象。'
- en: 'Another alternative is to let Arrow-derived instances automatically provided
    that your datatypes have the right functions:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个替代方案是让 Arrow 衍生的实例自动提供，前提是你的数据类型具有正确的函数：
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `@deriving` annotation will generate `DerivedMappableFunctorInstance` that
    normally you will write manually.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`@deriving` 注解将生成 `DerivedMappableFunctorInstance`，这通常是你手动编写的。'
- en: 'Now, we can create a generic function to use our `Mappable` functor:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个泛型函数来使用我们的 `Mappable` 函子：
- en: '[PRE13]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `buildBicycle` function will take as parameter any `HK<F, Int>` and apply
    the function `f` using its `Functor` implementation, returned by the function
    `arrow.typeclasses.functor` and returns `HK<F, Bicycle>`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`buildBicycle` 函数将接受任何 `HK<F, Int>` 作为参数，并使用由 `arrow.typeclasses.functor` 函数返回的
    `Functor` 实现应用函数 `f`，并返回 `HK<F, Bicycle>`。'
- en: 'The function `arrow.typeclass.functor` resolves at runtime, instances that
    adhere to the `Functor<MappableHK>` requirement:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `arrow.typeclass.functor` 在运行时解析，符合 `Functor<MappableHK>` 要求的实例：
- en: '[PRE14]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We can use `buildBicycle` with `Mappeable<Int>`, or any other HKT class such
    as `Option<T>`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `buildBicycle` 与 `Mappeable<Int>` 或任何其他 HKT 类，例如 `Option<T>`。
- en: 'One problem with the Arrows approach to HKTs is that it must resolve its instances
    at runtime. This is because Kotlin does not have support for implicits or can
    solve type class instances at compile time, leaving Arrow with this only alternative
    until *KEEP-87* is approved and included in the language:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 使用箭头方法处理 HKT 的问题之一是它必须在运行时解析其实例。这是因为 Kotlin 没有对隐式或编译时解决类型类实例的支持，这使得 Arrow 只能选择这个替代方案，直到
    *KEEP-87* 被批准并包含在语言中：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'So, you can have an HKT that has a `map` function but without an instance of
    `Functor` can''t be used, yet isn''t a compilation error:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以有一个具有 `map` 函数的 HKT，但没有 `Functor` 实例无法使用，但这并不是编译错误：
- en: '[PRE16]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Calling `buildBicycle` with a `NotAFunctor<T>` function compiles, but it will
    throw a `ClassNotFoundException` exception at runtime.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `NotAFunctor<T>` 函数调用 `buildBicycle` 会编译，但在运行时将抛出 `ClassNotFoundException`
    异常。
- en: Now that we understand how Arrow's hierarchy works, we can cover other classes.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了 Arrow 的层次结构如何工作，我们可以介绍其他类。
- en: Either
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Either
- en: '`Either<L, R>` is a representation of one of two possible values `L` or `R`,
    but not both at the same time. `Either` is a sealed class (similar to `Option`)
    with two subtypes `Left<L>` and `Right<R>`. Usually `Either` is used to represent
    results that can fail, using the left side to represent the error and the right
    side to represent a successful result. Because representing operations that can
    fail is a common scenario, Arrow''s `Either` is right biased, in other words,
    unless it is documented otherwise all operations run on the right side.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either<L, R>` 表示两种可能值之一 `L` 或 `R`，但不是同时表示。`Either` 是一个密封类（类似于 `Option`），有两个子类型
    `Left<L>` 和 `Right<R>`。通常 `Either` 用于表示可能失败的结果，使用左侧表示错误，右侧表示成功的结果。因为表示可能失败的操作是常见场景，Arrow
    的 `Either` 是右偏的，换句话说，除非有其他说明，否则所有操作都在右侧运行。'
- en: 'Let''s translate our division example from `Option` to `Either`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将我们的除法示例从 `Option` 转换为 `Either`：
- en: '[PRE17]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now instead of returning a `None` value, we''re returning valuable information
    to our user:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在而不是返回一个 `None` 值，我们正在向用户返回有价值的信息：
- en: '[PRE18]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In `eitherDivision`, we're using Arrow's `Tuple<A, B>` instead of Kotlin's `Pair<A,
    B>`. Tuples provide more features than Pair/Triple, and from now on we'll use
    it. To create a `Tuple2`, you can use the extension `infix` function, `toT`.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `eitherDivision` 中，我们使用 Arrow 的 `Tuple<A, B>` 而不是 Kotlin 的 `Pair<A, B>`。元组比
    Pair/Triple 提供更多功能，从现在开始我们将使用它。要创建 `Tuple2`，可以使用扩展 `infix` 函数，`toT`。
- en: 'Next, a short list of the `Either<L, R>` functions:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是一个 `Either<L, R>` 函数的简短列表：
- en: '| **Function** | **Description** |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `bimap(fa:(L) -> T, fb:(R) -> X): Either<T, X>` | Transform using `fa` on
    `Left` and `fb` on `Right` to return `Either<T, X>`. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `bimap(fa:(L) -> T, fb:(R) -> X): Either<T, X>` | 使用 `fa` 对 `Left` 进行转换，使用
    `fb` 对 `Right` 进行转换，以返回 `Either<T, X>`。|'
- en: '| `contains(elem:R): Boolean` | Returns `true` if the `Right` value is the
    same as `elem` parameter, `false` for `Left`. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `contains(elem:R): Boolean` | 如果 `Right` 值与 `elem` 参数相同，则返回 `true`，对于 `Left`
    返回 `false`。|'
- en: '| `exists(p:Predicate<R>):Boolean` | If `Right`, returns Predicate `p` result,
    always `false` for `Left`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `exists(p:Predicate<R>):Boolean` | 如果 `Right`，则返回谓词 `p` 的结果，对于 `Left` 总是返回
    `false`。|'
- en: '| `flatMap(f: (R) -> Either<L, T>): Either<L, T>` | A `flatMap` function as
    in `Monad`, using the value of  `Right`. |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `flatMap(f: (R) -> Either<L, T>): Either<L, T>` | 与 `Monad` 中的 `flatMap`
    函数类似，使用 `Right` 的值。|'
- en: '| `fold(fa: (L) -> T, fb: (R) -> T): T` | Returns a `T` value executing `fa`
    for `Left` and `fb` for `Right`. |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `fold(fa: (L) -> T, fb: (R) -> T): T` | 执行 `fa` 对 `Left` 和 `fb` 对 `Right`
    返回 `T` 值。|'
- en: '| `getOrElse(default:(L) -> R): R` | Returns `Right` value, or results from
    the `default` function. |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `getOrElse(default:(L) -> R): R` | 返回 `Right` 值，或 `default` 函数的结果。|'
- en: '| `isLeft(): Boolean` | Returns `true` if is an instance of `Left` and `false`
    for `Right`. |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `isLeft(): Boolean` | 如果是 `Left` 的实例，则返回 `true`，对于 `Right` 返回 `false`。|'
- en: '| `isRight(): Boolean` | Returns `true` if is an instance of `Right` and `false`
    for `Left`. |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `isRight(): Boolean` | 如果是 `Right` 的实例，则返回 `true`，对于 `Left` 返回 `false`。|'
- en: '| `map(f: (R) -> T): Either<L, T>` | A `map` function as in `Functor`, if `Right`,
    uses function `f` to transform it to `Right<T>`, if `Left`, returns same value
    without transformation. |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `map(f: (R) -> T): Either<L, T>` | 与 `Functor` 中的 `map` 函数类似，如果 `Right`，则使用函数
    `f` 将其转换为 `Right<T>`，如果 `Left`，则返回相同值而不进行转换。|'
- en: '| `mapLeft(f: (L) -> T): Either<T, R>` | A `map` function as in `Functor`,
    if `Left`, uses function `f` to transform it to `Left<T>`, if `Right`, returns
    same value without transformation. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `mapLeft(f: (L) -> T): Either<T, R>` | 与 `Functor` 中的 `map` 函数类似，如果 `Left`，则使用函数
    `f` 将其转换为 `Left<T>`，如果 `Right`，则返回相同值而不进行转换。|'
- en: '| `swap(): Either<R, L>` | Returns `Either` with its types and value swapped.
    |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `swap(): Either<R, L>` | 返回类型和值互换的 `Either`。|'
- en: '| `toOption(): Option<R>` | `Some<T>` for `Right` and `None` for `Left`. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `toOption(): Option<R>` | 对于 `Right` 返回 `Some<T>`，对于 `Left` 返回 `None`。|'
- en: 'The `flatMap` version looks as expected:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 版本看起来符合预期：'
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`Either` has a monad implementation, so we can invoke the binding function:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either` 具有单子实现，因此我们可以调用绑定函数：'
- en: '[PRE20]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Pay attention to `Either.monad<L>()`; for `Either<L, R>` it must define the
    `L` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `Either.monad<L>()`；对于 `Either<L, R>`，它必须定义 `L` 类型：
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our next section, we'll learn about monad transformers.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习单子变换器。
- en: Monad transformers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单子变换器
- en: '`Either` and `Option` are simple to use, but what happens if we combine both?'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Either`和`Option`使用简单，但如果我们将两者结合会发生什么呢？'
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '`UserService.findAge` returns `Either<String, Option<Int>>`; `Left<String>`
    for errors accessing the database or any other infrastructure, `Right<None>` for
    no value found on the database, and `Right<Some<Int>>` for a value found:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`UserService.findAge`返回`Either<String, Option<Int>>`；`Left<String>`表示访问数据库或其他基础设施时出错，`Right<None>`表示数据库中没有找到值，`Right<Some<Int>>`表示找到了值：'
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To print an age, we need two nested folds, nothing too complicated. Problems
    arrive when we need to do operations accessing multiple values:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印年龄，我们需要两个嵌套的折叠，没有什么太复杂的。问题出现在我们需要执行访问多个值的操作时：
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Monads don''t compose, making these operations grow in complexity, very quickly.
    But, we can always count on comprehensions, can''t we? Now, let''s look at the
    following codes:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 摩纳哥不组合，这使得这些操作很快就会变得复杂。但是，我们总是可以依赖列表解析，不是吗？现在，让我们看看以下代码：
- en: '[PRE25]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'This is better, the returning type is not that long, and `fold` is more manageable.
    Let''s take a look at the nested comprehensions in the following code snippet:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好，返回类型不那么长，`fold`也更易于管理。让我们看看以下代码片段中的嵌套列表解析：
- en: '[PRE26]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now, we have the same type of both values and result. But we still have another
    option, monad transformers.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有两个值和结果具有相同的类型。但我们还有一个选择，摩纳哥转换器。
- en: 'A **monad transformer** is a combination of two monads that can be executed
    as one. For our example, we will use `OptionT`, (shorthand for **Option Transformer**)
    as `Option` is the monad type that is nested inside `Either`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**摩纳哥转换器**是两个摩纳哥的组合，可以作为一个整体执行。在我们的例子中，我们将使用`OptionT`（**Option Transformer**的缩写），因为`Option`是嵌套在`Either`内部的摩纳哥类型：'
- en: '[PRE27]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We use `OptionT.monad<EitherKindPartial<String>>().binding`. The `EitherKindPartial<String>` monad
    means that the wrapper type is an `Either<String, Option<T>>`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`OptionT.monad<EitherKindPartial<String>>().binding`。`EitherKindPartial<String>`摩纳哥意味着包装类型是`Either<String,
    Option<T>>`。
- en: 'Inside the `binding` block, we use `OptionT` on values of type `Either<String,
    Option<T>>` (technically on values of type `HK<HK<EitherHK, String>, Option<T>>`)
    to call `bind(): T`, in our case `T`, is `Int`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '在`binding`块内部，我们使用`OptionT`对类型为`Either<String, Option<T>>`（技术上是对类型为`HK<HK<EitherHK,
    String>, Option<T>>`的值）的值调用`bind(): T`，在我们的例子中`T`是`Int`。'
- en: Previously we used just the `ev()` method, but now we need to use the `value()`
    method to extract the `OptionT` internal value.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们只使用了`ev()`方法，但现在我们需要使用`value()`方法来提取`OptionT`内部值。
- en: In our next section, we'll learn about the `Try` type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将学习关于`Try`类型的内容。
- en: Try
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Try
- en: '**Try** is a representation of a computation that may or may not fail. `Try<A>`
    is a sealed class with two possibles sub-classes—`Failure<A>`, representing a
    fail and `Success<T>` representing a successful operation.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**Try**表示可能成功或失败的计算。`Try<A>`是一个密封类，有两个可能的子类—`Failure<A>`，表示失败，`Success<T>`表示成功操作。'
- en: 'Let''s write our division example with `Try`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们用`Try`来写我们的除法示例：
- en: '[PRE28]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The easiest way to create a `Try` instance is to use the `Try.invoke` operator.
    If the block inside throws an exception, it will return `Failure`; if everything
    goes well, `Success<Int>`, for example, the `!!` operator will throw `NPE` if
    divide returns a null:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Try`实例的最简单方法是使用`Try.invoke`操作符。如果块内部抛出异常，它将返回`Failure`；如果一切顺利，例如返回`Success<Int>`，则`!!`操作符将抛出`NPE`，如果除法返回null：
- en: '[PRE29]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s take a look at a short list of the `Try<T>` functions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`Try<T>`函数的简短列表：
- en: '| **Function** | **Description** |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `exists(p: Predicate<T>): Boolean` | If `Success<T>` returns `p` result,
    on `Failure` always return `false`. |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `exists(p: Predicate<T>): Boolean` | 如果`Success<T>`返回`p`结果，在`Failure`时总是返回`false`。|'
- en: '| `filter(p:  Predicate<T>): Try<T>` | Returns `Success<T>` if operation is
    successful and pass predicate `p`, otherwise `Failure`. |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `filter(p: Predicate<T>): Try<T>` | 如果操作成功并且通过谓词`p`，则返回`Success<T>`，否则返回`Failure`。|'
- en: '| `<R> flatMap(f: (T) -> Try<R>): Try<R>` | `flatMap` function as in monad.
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| `<R> flatMap(f: (T) -> Try<R>): Try<R>` | `flatMap`函数，类似于摩纳哥。|'
- en: '| `<R> fold(fa: (Throwable) -> R, fb:(T) -> R): R` | Returns value transformed
    as `R`, invoking `fa` if `Failure`. |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| `<R> fold(fa: (Throwable) -> R, fb:(T) -> R): R` | 返回值转换为`R`，如果为`Failure`则调用`fa`。|'
- en: '| `getOrDefault(default: () -> T): T` | Returns value `T`, invoking default
    if `Failure`. |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| `getOrDefault(default: () -> T): T` | 返回值`T`，如果为`Failure`则调用默认值。|'
- en: '| `getOrElse(default: (Throwable) -> T): T` | Returns value `T`, invoking default
    if `Failure`. |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| `getOrElse(default: (Throwable) -> T): T` | 返回值`T`，如果为`Failure`则调用默认值。|'
- en: '| `isFailure(): Boolean` | Returns `true` if `Failure`, otherwise `false`.
    |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `isFailure(): Boolean` | 如果是 `Failure` 则返回 `true`，否则返回 `false`。|'
- en: '| `isSuccess(): Boolean` | Returns `true` if `Success`, otherwise `false`.
    |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| `isSuccess(): Boolean` | 如果是 `Success` 则返回 `true`，否则返回 `false`。|'
- en: '| `<R> map(f: (T) -> R): Try<R>` | Transforming function as in functor. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| `<R> map(f: (T) -> R): Try<R>` | 如同在函子中转换函数。|'
- en: '| `onFailure(f: (Throwable) -> Unit): Try<T>` | Act on `Failure`. |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| `onFailure(f: (Throwable) -> Unit): Try<T>` | 在 `Failure` 上执行操作。|'
- en: '| `onSuccess(f: (T) -> Unit): Try<T>` | Act on `Success`. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| `onSuccess(f: (T) -> Unit): Try<T>` | 在 `Success` 上执行操作。|'
- en: '| `orElse(f: () -> Try<T>): Try<T>` | Returns itself on `Success` or `f` result
    on `Failure`. |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `orElse(f: () -> Try<T>): Try<T>` | 在 `Success` 上返回自身或在 `Failure` 上返回 `f`
    的结果。|'
- en: '| `recover(f: (Throwable) -> T): Try<T>` | Transform `map` function for `Failure`.
    |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| `recover(f: (Throwable) -> T): Try<T>` | 转换 `map` 函数用于 `Failure`。|'
- en: '| `recoverWith(f: (Throwable) -> Try<T>): Try<T>` | Transform `flatMap` function
    for `Failure`. |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| `recoverWith(f: (Throwable) -> Try<T>): Try<T>` | 转换 `flatMap` 函数用于 `Failure`。|'
- en: '| `toEither() : Either<Throwable, T>` | Transform into `Either`—`Failure` to
    `Left<Throwable>` and `Success<T>` to `Right<T>`. |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| `toEither() : Either<Throwable, T>` | 转换为 `Either`——`Failure` 转换为 `Left<Throwable>`，`Success<T>`
    转换为 `Right<T>`。|'
- en: '| `toOption(): Option<T>` | Transform into `Option`—`Failure` to `None` and
    `Success<T>` to `Some<T>`. |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| `toOption(): Option<T>` | 转换为 `Option`——`Failure` 转换为 `None`，`Success<T>`
    转换为 `Some<T>`。|'
- en: 'The `flatMap` implementation is very similar to `Either` and `Option` and shows
    the value of having a common set of name and behavior conventions:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`flatMap` 的实现与 `Either` 和 `Option` 非常相似，展示了拥有一个共同的命名和行为约定的价值：'
- en: '[PRE30]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Monadic comprehensions are available for `Try` too:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Monadic 理解也适用于 `Try`：
- en: '[PRE31]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There is another kind of monadic comprehension using an instance of `MonadError`:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种使用 `MonadError` 实例的 monadic 理解：
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With `monadError.bindingCatch` any operation that throws an exception is lifted
    to `Failure`, at the end the returns is wrapped into `Try<T>`. `MonadError` is
    also available for `Option` and `Either`.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `monadError.bindingCatch`，任何抛出异常的操作都会提升到 `Failure`，最后返回值会被包裹在 `Try<T>` 中。`MonadError`
    也适用于 `Option` 和 `Either`。
- en: State
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: State
- en: '**State** is a structure that provides a functional approach for handling application
    state. `State<S, A>` is an abstraction over `S -> Tuple2<S, A>`. **S** represents
    the state type, and `Tuple2<S, A>` is the result, with `S` for the newly updated
    state and `A` for the function return.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**State** 是一种提供函数式处理应用程序状态的结构的结构。`State<S, A>` 是 `S -> Tuple2<S, A>` 的抽象。**S**
    代表状态类型，`Tuple2<S, A>` 是结果，其中 `S` 是新更新的状态，`A` 是函数返回值。'
- en: 'We can start with a simple example, a function that returns two things, a price
    and the steps to calculate it. To calculate a price, we need to add  `VAT` of
    20% and apply a discount if the `price` value goes above some threshold:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从一个简单的例子开始，一个返回两个东西的函数，一个价格和计算它的步骤。为了计算价格，我们需要加上 20% 的 `VAT`，如果 `price`
    值超过某个阈值，则应用折扣：
- en: '[PRE33]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: We have a type alias `PriceLog` for `MutableList<Tuple2<String, Double>>`. `PriceLog`
    will be our `State` representation; each step represented with `Tuple2<String,
    Double>`.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个类型别名 `PriceLog` 用于 `MutableList<Tuple2<String, Double>>`。`PriceLog` 将是我们的
    `State` 表示；每个步骤都用 `Tuple2<String, Double>` 表示。
- en: 'Our first function, `addVat(): State<PriceLog, Unit>` represents the first
    step. We write the function using a `State` builder that receives `PriceLog`,
    the state before applying any step and must return a `Tuple2<PriceLog, Unit>`,
    we use `Unit` because we don''t need the price at this point:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的第一个函数 `addVat(): State<PriceLog, Unit>` 表示第一步。我们使用 `State` 构建器编写这个函数，它接收
    `PriceLog`，在应用任何步骤之前的初始状态，并必须返回一个 `Tuple2<PriceLog, Unit>`，我们使用 `Unit` 因为在这个点上我们不需要价格：'
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The `applyDiscount` function is our second step. The only new element that
    we introduce here are two parameters, one for `threshold` and the other for `discount`:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`applyDiscount` 函数是我们的第二步。我们在这里引入的唯一新元素是两个参数，一个用于 `threshold`，另一个用于 `discount`：'
- en: '[PRE35]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The last step is represented by the function `finalPrice()`, and now we return `Double`
    instead of `Unit`:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步由函数 `finalPrice()` 表示，现在我们返回 `Double` 而不是 `Unit`：
- en: '[PRE36]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'To represent the sequence of steps, we use a monad comprehension and use the
    `State` functions sequentially. From one function to the next one, the `PriceLog`
    state is flowing implicitly (is just some coroutine continuations magic). At the
    end, we yield the final price. Adding new steps or switching existing ones is
    as easy as adding or moving lines:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了表示步骤序列，我们使用 monadic 理解并按顺序使用 `State` 函数。从一个函数到下一个函数，`PriceLog` 状态隐式流动（只是某些协程连续性的魔法）。最后，我们产生最终价格。添加新步骤或切换现有步骤就像添加或移动行一样简单：
- en: '[PRE37]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: To use the `calculatePrice` function, you must provide the threshold and discount
    values and then invoke the extension function `run` with an initial state. If
    you're interested just in the price, you can use `runA` or for just the history, `runS`.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `calculatePrice` 函数，你必须提供阈值和折扣值，然后使用初始状态调用扩展函数 `run`。如果你只对价格感兴趣，可以使用 `runA`，或者只对历史感兴趣，使用
    `runS`。
- en: Avoid problems using `State`. Don't confuse the extension function `arrow.data.run`
    with the extension function, `kotlin.run` (imported by default).
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 避免使用 `State` 产生的问题。不要混淆扩展函数 `arrow.data.run` 与扩展函数 `kotlin.run`（默认导入）。
- en: Corecursion with State
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `State` 的核心递归
- en: '`State` is beneficial on corecursion; we can rewrite our old examples with
    `State`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '`State` 在核心递归中很有用；我们可以用 `State` 重新编写我们的旧例子：'
- en: '[PRE38]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Our original `unfold` function use a function, `f: (S) -> Pair<T,S>?` which
    is very similar to `State<S, T>`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '我们原始的 `unfold` 函数使用一个函数，`f: (S) -> Pair<T,S>?`，这与 `State<S, T>` 非常相似：'
- en: '[PRE39]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Instead of having a lambda `(S) -> Pair<T, S>?`, we use `State<S, Option<T>>`
    and we use the function fold from `Option`, with an empty `Sequence` for `None`
    or a recursive call for `Some<T>`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再使用 lambda `(S) -> Pair<T, S>?`，而是使用 `State<S, Option<T>>`，并使用 `Option` 的
    fold 函数，对于 `None` 使用空 `Sequence`，对于 `Some<T>` 使用递归调用：
- en: '[PRE40]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Our old factorial function uses `unfold` with `Pair<Long, Int>` and a lambda—`(Pair<Long,
    Int>) -> Pair<Long, Pair<Long, Int>>?`:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们旧的阶乘函数使用 `unfold` 与 `Pair<Long, Int>` 和 lambda—`(Pair<Long, Int>) -> Pair<Long,
    Pair<Long, Int>>?`：
- en: '[PRE41]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The refactored factorial uses `State<Tuple<Long, Int>, Option<Long>>` but internal
    logic is almost the same, although our new factorial doesn''t use null, which
    is a significant improvement:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写的阶乘使用 `State<Tuple<Long, Int>, Option<Long>>`，但内部逻辑几乎相同，尽管我们新的阶乘没有使用 null，这是一个显著的改进：
- en: '[PRE42]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Similarly, `fib` uses unfold with `Triple<Long, Long, Int>` and a lambda `(Triple<Long,
    Long. Int>) -> Pair<Long, Triple<Long, Long, Int>>?`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，`fib` 使用 unfold 与 `Triple<Long, Long, Int>` 和 lambda `(Triple<Long, Long,
    Int>) -> Pair<Long, Triple<Long, Long, Int>>?`：
- en: '[PRE43]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'And the refactored `fib` uses `State<Tuple3<Long, Long, Int>, Option<Long>>`.
    Pay close attention to the extension operator function `plus`, used with `Tuple2<A,
    B>` and `C` will return `Tuple3<A, B, C>`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写的 `fib` 使用 `State<Tuple3<Long, Long, Int>, Option<Long>>`。请注意，扩展操作符函数 `plus`，与
    `Tuple2<A, B>` 和 `C` 一起使用将返回 `Tuple3<A, B, C>`：
- en: '[PRE44]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: And now, we can use our corecursive functions to generate sequences. There are
    many other uses for `State` that we can't cover here, such as *Message History*
    from *Enterprise Integration Patterns* ([http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html](http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html))
    or navigation on forms with multiple steps such as plane checking or long registration
    forms.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的核心递归函数来生成序列。`State` 的其他许多用途我们在这里无法涵盖，例如来自 *企业集成模式* 的 *消息历史*（[http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html](http://www.enterpriseintegrationpatterns.com/patterns/messaging/MessageHistory.html)）或具有多个步骤的表单导航，如飞机检查或长注册表单。
- en: Summary
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Arrow provides many datatypes and type classes that reduce significantly complex
    tasks and provide a standard set of idioms and expressions. In this chapter, we
    learned how to abstract over null values with `Option` and to express computations
    with `Either` and `Try`. We created a datatype class, and we also learned about
    monadic comprehensions and transformations. Last but not least, we used `State`
    to represent the application state.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: Arrow 提供了许多数据类型和类型类，可以显著简化复杂任务，并提供了一套标准的惯用和表达式。在本章中，我们学习了如何使用 `Option` 抽象 null
    值，以及如何使用 `Either` 和 `Try` 表达计算。我们创建了一个数据类型类，还学习了单调组合和转换。最后但同样重要的是，我们使用了 `State`
    来表示应用程序状态。
- en: And with this chapter, we reach the final of this journey, but rest assured,
    this isn't the end of your journey learning functional programming. As we learned
    in the first chapters, functional programming is all about using functions as
    building blocks to create complex programs. In the same way, with all the concepts
    that you learn here, now you can understand and master new, exciting and more
    powerful ideas.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 通过本章，我们到达了这次旅程的终点，但请放心，这并不是你学习函数式编程的终点。正如我们在第一章所学，函数式编程全部关于使用函数作为构建块来创建复杂程序。同样，通过在这里学到的所有概念，你现在可以理解和掌握新的、令人兴奋的、更强大的想法。
- en: Now a new learning journey begins for you.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你开始了一段新的学习之旅。
