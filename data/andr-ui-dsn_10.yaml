- en: Chapter 10. Best Practices and Securing Your Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章。最佳实践和确保您的应用安全
- en: The Android operating system was designed in anticipation of hackers attempting
    to perform common attacks, such as social engineering attacks that try to trick
    the user into handing over their personal information or installing malware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统是在预期黑客尝试执行常见攻击的情况下设计的，例如试图欺骗用户交出个人信息或安装恶意软件的社会工程学攻击。
- en: Android comes with built-in security features that significantly reduce the
    chances of security exploits succeeding, and that limit the impact of any attacks
    that *do* succeed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Android内置的安全功能可以显著降低安全漏洞成功的可能性，并限制任何成功攻击的影响。
- en: These built-in security controls provide you, your application, and your users
    with a certain level of protection by default. Nevertheless, following security
    best practices is essential for further reducing the chances of your app leaving
    users vulnerable to exploits, data leaks, and other security-related issues.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 这些内置的安全控制默认为您的应用、您的用户和您的用户提供了一定程度的安全保护。尽管如此，遵循安全最佳实践对于进一步减少您的应用使用户容易受到漏洞、数据泄露和其他安全相关问题的攻击的风险至关重要。
- en: In this chapter, we're going to look at how you can make the most of Android's
    built-in security features. Towards the end of this chapter, I'll also look at
    some best practices we haven't covered in detail in any of the previous chapters,
    including how to design more effective notifications and ensuring that your app
    is accessible to all users.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何充分利用Android内置的安全功能。在本章的末尾，我还会讨论一些在之前的章节中没有详细介绍的最佳实践，包括如何设计更有效的通知，以及确保您的应用对所有用户都易于访问。
- en: Keeping user data secure
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护用户数据安全
- en: The most common security concern for your typical Android user is whether the
    applications they've chosen to install can access the sensitive data stored on
    their device.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 对于典型的Android用户来说，最常见的安全问题是他们选择的安装的应用程序是否可以访问他们设备上存储的敏感数据。
- en: If your app has access to the user's data, then you have a responsibility to
    make sure that data remains secure. One of the quickest and easiest ways of protecting
    user data is to take a long hard look at whether your app really needs access
    to this data at all. If you minimize the data your app has access to in the first
    place, then you minimize the risk of your app inadvertently exposing personal
    information. You also reduce the chances of attackers being tempted to try and
    exploit your application in order to gain access to the sensitive data it's privy
    to. You should always be on the lookout for ways to create the same effect *without*
    your app requiring direct access to sensitive data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用可以访问用户的数据，那么您有责任确保这些数据保持安全。保护用户数据的一种最快、最简单的方法是仔细考虑您的应用是否真的需要访问这些数据。如果您首先就最小化应用可以访问的数据，那么您就最小化了应用意外泄露个人信息的风险。您还减少了攻击者试图利用您的应用程序以获取其有权访问的敏感数据的诱惑。您应该始终寻找在不要求应用直接访问敏感数据的情况下实现相同效果的方法。
- en: Wherever possible, don't store usernames or passwords on the user's device.
    Instead, your app should perform initial authentication using the username and
    password supplied by the user, and then switch to a short-lived, service-specific
    authorization token.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，不要在用户的设备上存储用户名或密码。相反，您的应用应使用用户提供的用户名和密码进行初始身份验证，然后切换到短期有效的、特定于服务的授权令牌。
- en: To help protect your users from phishing attacks, you should also minimize the
    number of times your app asks for user credentials. This way, a phishing attack
    is more likely to strike the user as suspicious, as it'll be out of character
    for your app to ask for sensitive information.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助保护您的用户免受钓鱼攻击，您还应该尽量减少您的应用请求用户凭据的次数。这样，钓鱼攻击更有可能被用户视为可疑，因为您的应用请求敏感信息的行为与其常规行为不符。
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your app does need access to passwords and usernames, keep in mind that you
    may be legally required to provide a privacy policy explaining how your app uses
    and stores this data.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用确实需要访问密码和用户名，请记住，您可能依法需要提供隐私政策，说明您的应用如何使用和存储这些数据。
- en: Connecting to a network
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接到网络
- en: Network transactions pose an inherent security risk, particularly since mobile
    users are more likely to connect to unsecured wireless networks such as public
    Wi-Fi hotspots.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 网络事务固有的安全风险，尤其是移动用户更有可能连接到未加密的无线网络，如公共Wi-Fi热点。
- en: 'Whenever your app connects to a network, it''s crucial that you implement the
    following best practices, in order to help keep your users safe:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 每当您的应用程序连接到网络时，实施以下最佳实践至关重要，以帮助保护您的用户安全：
- en: Use `HTTPS` over `HTTP` wherever possible. Also, never automatically trust *any*
    data downloaded from insecure protocols such as `HTTP`.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下使用`HTTPS`而不是`HTTP`。此外，永远不要自动信任从不受信任的协议（如`HTTP`）下载的任何数据。
- en: Implement authenticated, encrypted, socket-level communication using the `SSLSocket`
    class.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SSLSocket`类实现经过身份验证、加密的套接字级别通信。
- en: When you're handling sensitive IPC, use an Android IPC mechanism that can authenticate
    the identity of the application connecting to your IPC, such as a `Binder`, `Intent`, `BroadcastReceiver`,
    or `Messenger with a Service`. This is more secure than using localhost network
    ports.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您处理敏感的IPC时，请使用Android IPC机制来验证连接到您的IPC的应用程序的标识，例如`Binder`、`Intent`、`BroadcastReceiver`或带有服务的`Messenger`。这比使用localhost网络端口更安全。
- en: Don't use unauthenticated SMS data to perform sensitive commands. SMS are neither
    encrypted nor strongly authenticated by default, and are therefore susceptible
    to interception on the network.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要使用未经身份验证的短信数据执行敏感命令。短信默认既未加密也未进行强认证，因此容易在网络上被拦截。
- en: When sending data messages from a web server to your app, you should use the **Google
    Cloud Messaging APIs** and IP networking wherever possible.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从网络服务器向您的应用程序发送数据消息时，您应该尽可能使用**Google Cloud Messaging API**和IP网络。
- en: 'Android N also introduces the concept of a **network security configuration**
    file, which you can use to create custom network security settings for your app
    without having to modify your actual application code. You can use this new network
    security configuration file to:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓N还引入了**网络安全配置文件**的概念，您可以使用它为您的应用程序创建自定义的网络安全设置，而无需修改实际的应用程序代码。您可以使用这个新的网络安全配置文件来：
- en: Specify which certificate authorities are trusted for your app's secure connections
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定哪些证书颁发机构被信任用于您的应用程序的安全连接
- en: Restrict an app's secure connections to specific, named certificates
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制应用程序的安全连接到特定的、命名的证书
- en: Debug secure connections in your app without added risk to the installed base
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在您的应用程序中调试安全连接，而不会对已安装的基础设施造成额外风险
- en: Protect apps from accidentally using clear-text traffic, which is a particular
    security risk as it transmits potentially sensitive data in a human-readable format
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保护应用程序免受意外使用明文流量，这尤其是一个安全风险，因为它以人类可读的格式传输可能敏感的数据。
- en: 'To create a network security configuration file, create a new XML values resource
    file with the following path:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个网络安全配置文件，创建一个新的XML值资源文件，路径如下：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then reference this file in your project''s Manifest:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 然后在您的项目清单中引用此文件：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The structure of a simple network configuration file is as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简单网络配置文件的结构如下：
- en: '[PRE2]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Requesting permissions
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求权限
- en: Android devices do a lot—from snapping photos and recording videos, to providing
    directions, posting to social media, and sending SMS messages. This means your
    typical Android device has access to *huge* amounts of sensitive information.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓设备功能强大——从拍照和录制视频，到提供导航、发布到社交媒体和发送短信。这意味着您的典型安卓设备可以访问大量的敏感信息。
- en: The good news is that Android does a lot to help keep this information secure.
    The platform is based on a privilege-separated system where apps run separately
    from one another and from the system, in a limited-access sandbox. This restricts
    the data and features each app has access to. By default, no Android app has permission
    to perform any operation that could adversely affect the operating system, the
    user, or other applications, which helps prevent malicious apps from corrupting
    data or accessing sensitive information. These permissions also restrict each
    app's access to device features not provided by the basic sandbox, protecting
    the user from apps making unauthorized use of hardware (such as accessing the
    device's camera) or external communication channels (such as connecting to the
    Internet).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，安卓做了很多工作来帮助保护这些信息的安全。该平台基于一个权限分离的系统，其中应用程序相互独立运行，并且与系统独立，在一个受限的沙箱中。这限制了每个应用程序可以访问的数据和功能。默认情况下，没有任何安卓应用程序有权限执行可能对操作系统、用户或其他应用程序产生不利影响的操作，这有助于防止恶意应用程序损坏数据或访问敏感信息。这些权限还限制了每个应用程序对基本沙箱之外提供的设备功能的访问，保护用户免受应用程序未经授权使用硬件（如访问设备的摄像头）或外部通信通道（如连接到互联网）的影响。
- en: However, there are legitimate reasons why your app might need to access the
    user's information or device capabilities, such as an SMS app that requires access
    to your contacts list or a video recording app that needs to access the device's
    camera. If your app does require access to protected information or features,
    then you'll need to prompt the user for access. The user then has the choice to
    accept or deny this permission request.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的应用可能需要访问用户的信息或设备功能，这是有合法理由的，例如需要访问联系人列表的短信应用或需要访问设备摄像头的视频录制应用。如果你的应用确实需要访问受保护的信息或功能，那么你需要提示用户进行访问。用户随后可以选择接受或拒绝这个权限请求。
- en: Originally, Android apps requested all the permissions they might possibly need
    up front before the user could even download the app from Google Play. If the
    user didn't want to grant the app one or more of the requested permissions, their
    only option was to abandon the installation altogether, and go looking for an
    alternative app.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，Android 应用在用户甚至可以从 Google Play 下载应用之前就请求所有可能需要的权限。如果用户不想授予应用一个或多个请求的权限，他们唯一的选项就是完全放弃安装，并寻找替代应用。
- en: Android 6.0 completely overhauled this permissions model, replacing it with
    new **runtime permissions**.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Android 6.0 完全重构了这一权限模型，用新的 **运行时权限** 取代了它。
- en: Beginning with Android 6.0, apps request permissions one by one while the app
    is running, as and when that app requires access to protected services, data,
    or device features.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Android 6.0 开始，应用在运行时逐个请求权限，当应用需要访问受保护的服务、数据或设备功能时，就会进行请求。
- en: For example, imagine you'd developed a note-taking app that supports traditional
    text notes, but also gives users the option to record voice memos. Before Android
    6.0, the user would have to grant this app permission to access the microphone
    at install time. However, under the new permissions model, the user can launch
    your note-taking app and write as many text memos as they want, potentially without
    the app ever requesting access to the microphone. Your app will only request microphone
    access when the user tries to record a voice memo for the first time, as this
    permission is required to complete the current task.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你开发了一个支持传统文本笔记的应用，同时也为用户提供记录语音备忘录的选项。在 Android 6.0 之前，用户必须在安装时授予此应用访问麦克风的权限。然而，在新权限模型下，用户可以启动你的笔记应用并写下他们想要的任何文本备忘录，可能根本不需要应用请求访问麦克风。你的应用只有在用户第一次尝试记录语音备忘录时才会请求麦克风访问权限，因为这项权限是完成当前任务所必需的。
- en: In Android 6.0 and higher, users can change an app's permissions manually at
    any time, by opening their device's **Settings** and selecting **Apps**. At this
    point, they'll see a list of all the apps installed on their device. They can
    then select any app from the list, and tap **Permissions** to see all the permission
    categories this particular app has access to.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 6.0 及更高版本中，用户可以通过打开设备的 **设置** 并选择 **应用** 来手动更改应用的权限。此时，他们将看到设备上安装的所有应用的列表。他们可以从列表中选择任何应用，然后点击
    **权限** 来查看该特定应用可以访问的所有权限类别。
- en: '![Requesting permissions](img/B05061_10_1.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![请求权限](img/B05061_10_1.jpg)'
- en: The user can revoke any permission, by dragging that permission's slider to
    the **Off** position.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 用户可以通过将权限的滑块拖到 **关闭** 位置来撤销任何权限。
- en: '![Requesting permissions](img/B05061_10_2.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![请求权限](img/B05061_10_2.jpg)'
- en: 'This new permission model has a number of benefits for both users and developers:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的权限模型对用户和开发者都有许多好处：
- en: The user no longer has to read through a list of permissions before they can
    install an app, which makes for a more streamlined installation process.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户不再需要在安装应用之前阅读权限列表，这使得安装过程更加流畅。
- en: If you release an update that requires new permissions, previously the user
    had to accept these permissions before they could install the update. In Android
    6.0 and higher, apps update automatically and will then make any new permission
    requests associated with the update, as and when (and if) those permissions are
    required.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你发布的更新需要新的权限，之前用户必须接受这些权限才能安装更新。在 Android 6.0 及更高版本中，应用会自动更新，并且将在需要时（以及如果需要）提出任何与更新相关的新权限请求。
- en: Users have more control over the information and features each app has access
    to. The new permission model gives users the option to deny individual permission
    requests, something that wasn't possible in previous versions of Android. For
    example, a user who has downloaded an image-editing app may be happy to give that
    app access to their gallery, but more hesitate to grant that same app access to
    their device's camera. In previous versions of Android, the user *had* to grant
    that app all the permissions it requested up front, or not install the app at
    all. However in Android 6.0 and higher, the user is free to deny the app access
    to their camera, if they're not comfortable with that particular permission request.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用户对每个应用可以访问的信息和功能有更多的控制权。新的权限模型给用户提供了拒绝单个权限请求的选项，这在之前的 Android 版本中是不可能的。例如，一个下载了图片编辑应用的用户可能会乐意授予该应用访问其图库的权限，但可能会更犹豫是否要授予该应用访问其设备相机的权限。在
    Android 6.0 及更高版本之前，如果用户对某个特定的权限请求感到不舒服，他们可以自由地拒绝该应用访问其相机。
- en: Users are more likely to understand why your app is requesting each permission,
    as requests now happen in context when the user is trying to access a related
    feature for the first time. And when users understand why your app is requesting
    access to sensitive information or device features, they're more likely to grant
    those requests.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于请求现在发生在用户尝试首次访问相关功能时，用户更有可能理解您的应用请求每个权限的原因。当用户理解了您的应用请求访问敏感信息或设备功能的原因时，他们更有可能批准这些请求。
- en: The new permissions model – backwards compatibility
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新的权限模型 – 向后兼容性
- en: Under the new permissions model, users can revoke any permission they've previously
    granted to any app, at any time, even if that app targets API level 22 or lower.
    This means you need to test that your app continues to function normally if the
    user denies one or more of its permission requests—*regardless* of your app's `targetSdkVersion`
    value.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在新的权限模型下，用户可以在任何时间撤销之前授予任何应用的任何权限，即使该应用针对 API 级别 22 或更低。这意味着您需要测试，如果用户拒绝了一个或多个权限请求，您的应用是否仍然可以正常工作——*无论*您的应用的
    `targetSdkVersion` 值是多少。
- en: Initially, if your app winds up on a device running Android 5.1 (API level 22)
    or lower, *or* your app's `targetSdkVersion` is 22 or lower, the system defaults
    to the old permissions model and makes all permission requests up front, at install
    time. If the user denies these permissions requests, then the system won't install
    the app. Similarly, if you add a new permission to an updated version of your
    app, the system will ask the user to grant these new permissions before they can
    install the update.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，如果您的应用运行在 Android 5.1（API 级别 22）或更低版本的设备上，或者您的应用的 `targetSdkVersion` 是 22
    或更低，系统默认使用旧的权限模型，并在安装时提前请求所有权限。如果用户拒绝这些权限请求，则系统不会安装该应用。同样，如果您在应用更新的版本中添加了新的权限，系统将要求用户在安装更新之前授予这些新权限。
- en: However, users can *still* revoke previously granted permissions manually by
    selecting their device's **Settings**, followed by **Apps**, and then selecting
    your app from the list.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，用户仍然可以通过选择设备的**设置**，然后选择**应用**，并从列表中选择您的应用来手动撤销之前授予的权限。
- en: If your app targets an earlier version of the Android platform and you *haven't*
    accounted for the new permissions model, your app may no longer function normally
    (or at all) if the user chooses to revoke one or more of your app's permissions
    manually. The system will warn the user that revoking permissions for apps targeting
    earlier versions of Android can cause the app in question to stop working, but
    the user still has the option to go ahead and revoke these permissions, if they
    really want to.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用针对 Android 平台的早期版本，并且您*尚未*考虑到新的权限模型，如果用户手动撤销了您应用的一个或多个权限，您的应用可能不再正常工作（或根本无法工作）。系统将警告用户，撤销针对早期版本
    Android 的应用权限可能会导致相关应用停止工作，但用户仍然可以选择继续撤销这些权限，如果他们真的想这么做。
- en: Even if your app targets pre-6.0 versions of the Android platform only, you
    shouldn't just assume that you can ignore the new permissions model. You should
    still aim to create an app that provides a good user experience, even if the user
    chooses to revoke some (or all) of its previously granted permissions.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您的应用仅针对 Android 平台 6.0 之前的版本，您也不应仅仅假设可以忽略新的权限模型。您仍然应该旨在创建一个提供良好用户体验的应用，即使用户选择撤销其之前授予的一些（或全部）权限。
- en: Permission groups
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限组
- en: 'Android''s permissions are divided into two categories:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Android的权限分为两类：
- en: 'Normal permissions:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正常权限：
- en: These permissions give your app access to data or resources outside of its sandbox,
    but pose very little direct risk to the user's privacy, the operation of the device,
    or to other apps.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些权限使您的应用能够访问其沙盒之外的数据或资源，但几乎不会对用户的隐私、设备的操作或其他应用构成直接风险。
- en: If you declare that your app requires a normal permission in its `Manifest`,
    the system will automatically grant your app that permission.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您在`Manifest`中声明您的应用需要正常权限，系统将自动授予该权限。
- en: 'Dangerous permissions:'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 危险权限：
- en: These permissions give your app access to data or resources that could pose
    a risk to the user's privacy, or that may affect the user's stored data, other
    apps, or the device's normal operation. For example, being able to read the user's
    contacts list is considered a dangerous permission.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些权限使您的应用能够访问可能对用户隐私构成风险的数据或资源，或者可能影响用户存储的数据、其他应用或设备的正常操作。例如，能够读取用户的联系人列表被视为危险权限。
- en: If the user's device is running Android 6.0 (API Level 23) or higher *and* your
    app's `targetSdkVersion` is 23 or higher, then dangerous permissions trigger a
    permission request only when the user tries to perform an operation that requires
    this permission. For example, if your app requires the `READ_CONTACTS` permission,
    the system may ask for that permission the first time the user tries to create
    an SMS message.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果用户的设备运行Android 6.0（API级别23）或更高版本，并且您的应用的`targetSdkVersion`为23或更高，那么危险权限仅在用户尝试执行需要此权限的操作时才会触发权限请求。例如，如果您的应用需要`READ_CONTACTS`权限，系统可能会在用户第一次尝试创建短信消息时请求该权限。
- en: If your app winds up on a device running Android 5.1 or lower, or its `targetSdkVersion`
    is 22 or lower, the Android system will ask the user to grant all dangerous permissions
    at install time.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您的应用运行在Android 5.1或更低版本的设备上，或者其`targetSdkVersion`为22或更低，Android系统将在安装时要求用户授予所有危险权限。
- en: In addition to the *normal* and *dangerous* ratings, Android groups related
    permissions into permission groups. When your app requests access to a permission,
    the user will be presented with a dialogue requesting access to that entire permissions
    group.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 除了*正常*和*危险*评级之外，Android还将相关的权限分组。当您的应用请求访问一个权限时，用户将看到一个对话框，请求访问整个权限组。
- en: If your app requests a dangerous permission and the user has already granted
    your app access to another dangerous permission from that same group, the system
    will grant that permission automatically without requiring any additional input
    from the user.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用请求一个危险权限，并且用户已经授予了该应用来自同一组的另一个危险权限，系统将自动授予该权限，无需用户提供任何额外输入。
- en: This approach helps mobile users make more informed decisions about what parts
    of their device and what information each app should have access to *without*
    overwhelming them with technical information or too many permission requests.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法帮助移动用户更明智地决定他们的设备哪些部分以及每个应用应该有权访问哪些信息，而不会因为技术信息过多或权限请求过多而使他们感到不知所措。
- en: 'Permissions are divided into nine groups:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 权限分为九组：
- en: Calendar
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 日历
- en: Camera
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 摄像头
- en: Contacts
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人
- en: Location
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置
- en: Microphone
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 麦克风
- en: Phone
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电话
- en: Body sensors
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人体传感器
- en: SMS
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 短信
- en: Storage
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储
- en: Declaring permissions
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明权限
- en: As you develop your app, make a note every time your app requires access to
    resources or information that it doesn't create itself, or whenever it attempts
    to perform actions that could impact the user's privacy, the behavior of other
    apps, or the device in general. Most of the time these actions will require your
    app to make a permissions request.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在您开发应用的过程中，每次您的应用需要访问它自己不创建的资源或信息，或者每次它尝试执行可能影响用户隐私、其他应用行为或设备整体的行为时，都要做笔记。大多数情况下，这些操作将需要您的应用请求权限。
- en: 'To declare a permission, open your project''s `Manifest` and add a `<uses-permission>`
    element as a child of the top-level `<manifest>` element:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要声明一个权限，打开您的项目`Manifest`，并将`<uses-permission>`元素作为顶级`<manifest>`元素的子元素添加：
- en: '[PRE3]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Here''s how the string resources for this permission''s label and description
    might look:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是这个权限的标签和描述字符串资源的可能样子：
- en: '[PRE4]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Verifying permissions
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证权限
- en: Your app won't always need to ask for permission to access protected information
    or features—if your app currently has access to the microphone, then it won't
    need to request this permission, for example. However, since users running Android
    6.0 and higher can revoke previously granted permissions at any time, your app
    will need to check whether it currently has access to protected information or
    features, every time it needs to act on the related permission. Even if the user
    granted this permission previously, in Android 6.0 and higher there's no guarantee
    the user hasn't manually revoked that permission at some point.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用并不总是需要请求权限来访问受保护的信息或功能——如果您的应用当前可以访问麦克风，那么它就不需要请求此权限，例如。然而，由于运行Android 6.0及更高版本的用户的权限可以在任何时候被撤销，因此您的应用需要在每次需要根据相关权限采取行动时检查它是否当前有权访问受保护的信息或功能。即使用户之前已经授予了此权限，在Android
    6.0及更高版本中，也无法保证用户在某个时间点没有手动撤销该权限。
- en: 'To determine whether your app currently has permission to access information
    or features, you need to call the `ContextCompat.checkSelfPermission()`method.
    For example, this code snippet shows you how to check whether your app has permission
    to access the Internet:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定您的应用当前是否有权访问信息或功能，您需要调用`ContextCompat.checkSelfPermission()`方法。例如，以下代码片段展示了如何检查您的应用是否有权访问互联网：
- en: '[PRE5]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`ContextCompat.checkSelfPermission()` is available as part of revision 23 of
    the `support-v4 library` for backwards compatibility ([http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4](http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4)).'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContextCompat.checkSelfPermission()`作为`support-v4 library`第23次修订的一部分提供，以实现向后兼容（[http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4](http://developer.android.com/tools/support-library/features.html?utm_campaign=runtime-permissions-827&utm_source=dac&utm_medium=blog#v4)）。'
- en: 'If your app currently has access to the requested permission, `ContextCompat.checkSelfPermission`
    will return `PackageManager.PERMISSION_GRANTED` and your app can proceed with
    the operation. If the user hasn''t granted your app this permission, or they granted
    the permission but then revoked it at some point, this method returns `PackageManager.PERMISSION_DENIED`
    and you''ll need to request that permission by calling one of the `requestPermission`
    methods:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用当前有权访问请求的权限，`ContextCompat.checkSelfPermission`将返回`PackageManager.PERMISSION_GRANTED`，您的应用可以继续执行操作。如果用户没有授予您的应用此权限，或者他们授予了权限但在某个时间点撤销了它，此方法将返回`PackageManager.PERMISSION_DENIED`，您需要通过调用`requestPermission`方法之一来请求该权限：
- en: '[PRE6]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Handling the permissions request response
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理权限请求响应
- en: 'When your app makes a permission request, the system presents a dialogue to
    the user. When the user responds, the system invokes your app''s `onRequestPermissionsResult()`
    method and passes it the user''s response. To find out whether the user has granted
    or denied the permission request, your app needs to override that method:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用发起权限请求时，系统会向用户显示一个对话框。当用户做出回应时，系统会调用您的应用的`onRequestPermissionsResult()`方法，并将用户的响应传递给它。为了确定用户是否授予或拒绝权限请求，您的应用需要重写该方法：
- en: '[PRE7]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Permissions and <uses-feature>
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 权限和`<uses-feature>`
- en: It's possible that your app may rely on certain hardware or software features
    being present on the user's device, for example your typical camera app will almost
    certainly require a device with camera hardware.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您的应用可能依赖于用户设备上存在某些硬件或软件功能，例如，您典型的相机应用几乎肯定需要带有相机硬件的设备。
- en: 'To prevent users from installing your app on devices that don''t have the hardware
    or software necessary to support it, you need to add the `<uses-feature`> declaration
    to your project''s `Manifest`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止用户在硬件或软件不支持的情况下安装您的应用，您需要在项目的`Manifest`文件中添加`<uses-feature>`声明：
- en: '[PRE8]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You then specify whether your app requires this feature to function at all
    (`true`) or whether it prefers to have this feature but can function without it
    if necessary (`false`):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您指定您的应用是否需要此功能才能运行（`true`）或者是否更喜欢有此功能，但在必要时可以不使用它（`false`）：
- en: '[PRE9]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Although the Android system won't check your app's `Manifest` for `<uses-feature>`
    elements, Google Play does use your app's `<uses-feature>` elements to decide
    whether your app is compatible with the user's device. Google Play won't allow
    any user to install an app that it deems incompatible with their device's hardware
    or software.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Android系统不会检查您的`Manifest`中的`<uses-feature>`元素，但Google Play确实使用您的应用`<uses-feature>`元素来决定您的应用是否与用户的设备兼容。Google
    Play不会允许安装任何它认为与用户设备硬件或软件不兼容的应用。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you add `<uses-feature>` elements to your `Manifest` but don't include the `android:required`
    attribute, Google Play assumes that your app requires this feature (`android:required="true"`).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在`Manifest`中添加了`<uses-feature>`元素，但没有包含`android:required`属性，Google Play将假设您的应用需要此功能（`android:required="true"`）。
- en: Ideally, you should declare all your project's hardware and software requirements,
    but there are a few safeguards in place just in case you forget to mention one
    or more `<uses-feature>` elements.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，您应该声明您项目中的所有硬件和软件要求，但为了以防万一您忘记提及一个或多个`<uses-feature>`元素，已经设置了一些安全措施。
- en: Google Play checks your app's *regular* permissions for any implicit hardware-related
    features. If it finds any, it adds the corresponding hardware or software feature
    to your app's metadata, and then takes these into account when deciding whether
    each potential user can or cannot install your app.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Google Play会检查您的应用中是否有任何隐式的硬件相关权限。如果发现，它将相应的硬件或软件功能添加到您的应用元数据中，并在决定每个潜在用户是否可以安装您的应用时考虑这些因素。
- en: This does help to prevent users from downloading incompatible apps, but it can
    also be a bit of a nuisance. Imagine your app requests `android.permission.CAMERA`
    but you didn't include `<uses-feature android:name="android.hardware.camera">`
    in your `Manifest.` In this scenario, Google Play will assume that your app requires
    camera hardware to function, and consequently won't allow anyone to install your
    app on a device that doesn't have a camera. If your app doesn't actually require
    a camera, this misunderstanding could prevent people with perfectly compatible
    devices from installing your app.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这确实有助于防止用户下载不兼容的应用，但也可能有些麻烦。想象一下，您的应用请求`android.permission.CAMERA`，但您没有在`Manifest`中包含`<uses-feature
    android:name="android.hardware.camera">`。在这种情况下，Google Play将假设您的应用需要摄像头硬件才能运行，因此不会允许在没有任何摄像头的设备上安装您的应用。如果您的应用实际上不需要摄像头，这种误解可能会阻止具有完全兼容设备的用户安装您的应用。
- en: 'To prevent this misunderstanding, you need to open your project''s `Manifest`
    and specify that a camera is preferred, but not essential:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种误解，您需要打开您项目的`Manifest`并指定摄像头是首选的，但不是必需的：
- en: '[PRE10]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For a full list of all the permissions that imply feature requirements, check
    out the official Android docs ( [http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions](http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions)
    ).
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看所有暗示功能要求的权限的完整列表，请查看官方Android文档（[http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions](http://developer.android.com/guide/topics/manifest/uses-feature-element.html#permissions)）。
- en: Note
  id: totrans-108
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Declaring a `<uses-feature>` doesn't automatically grant your app permission
    to access the related features or information. You'll *still* need to request
    every permission your app requires, as normal.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 声明`<uses-feature>`不会自动授予您的应用访问相关功能或信息的权限。您仍然需要像往常一样请求您的应用所需的每个权限。
- en: Best practices for app permissions
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用权限的最佳实践
- en: Despite everything this new runtime permissions model has to offer, it does
    present developers with a few new challenges. Firstly, since your app can request
    permissions at any time, issuing your permission requests at exactly the right
    time is now an important part of the user experience.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个新的运行时权限模型提供了许多功能，但它确实给开发者带来了一些新的挑战。首先，由于您的应用可以在任何时间请求权限，因此现在在准确的时间发出权限请求已成为用户体验的重要组成部分。
- en: Secondly, since the user can now deny individual permissions, you'll need to
    ensure that your app continues to provide a good experience regardless of whether
    the user chooses to deny one or more of your application's permission requests.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 其次，由于用户现在可以拒绝单个权限，您需要确保无论用户是否选择拒绝您的应用的一个或多个权限请求，您的应用都能继续提供良好的体验。
- en: Note
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This doesn't mean that your app has to function even if the user consistently
    denies its requests. It's possible that denying a certain permission may render
    your app completely unable to perform its core functionality. However, even if
    this is the case, you can still provide a good user experience by letting the
    user know *why* your app has suddenly stopped working. For example, whenever the
    user tries to launch your app, you might display a dialogue box listing all the
    missing permissions that your app requires in order to function, and then giving
    the user an easy way of granting these permissions.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不意味着如果用户持续拒绝其请求，您的应用就必须运行。有可能拒绝某个权限会使您的应用完全无法执行其核心功能。然而，即使如此，您仍然可以通过让用户知道为什么您的应用突然停止工作来提供良好的用户体验。例如，每当用户尝试启动您的应用时，您可能显示一个对话框，列出应用为了运行所需的所有缺失权限，并给用户一个简单的方式来授予这些权限。
- en: In this section, we're going to look at all the best practices surrounding permissions,
    so you can make more informed decisions about which permissions your app requests,
    in addition to *when* and *where* it issues those requests.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨所有关于权限的最佳实践，以便您能够更明智地决定您的应用请求哪些权限，以及它在何时何地发出这些请求。
- en: Making as few permission requests as possible
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 尽可能少地请求权限
- en: This is the golden rule of permission requests.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这是权限请求的金科玉律。
- en: Permissions are designed to protect the user and the device, so your app should
    *only* request permissions that it requires to function. Research ([http://repository.cmu.edu/hcii/268](http://repository.cmu.edu/hcii/268))
    suggests that the amount and type of permissions an app requests directly affects
    user behavior. When confronted with two apps that have similar functionality,
    users are more likely to opt for the one that requires fewer permissions.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 权限旨在保护用户和设备，因此您的应用应该*仅*请求它运行所需的权限。研究([http://repository.cmu.edu/hcii/268](http://repository.cmu.edu/hcii/268))表明，应用请求的权限数量和类型直接影响到用户行为。当面对具有相似功能的两款应用时，用户更有可能选择需要较少权限的那款。
- en: If you're going to reach the widest possible audience, you need to limit the
    number of permissions your app requires. This is particularly important under
    the new permissions model, as requests are made as the user is interacting with
    your app. Imagine you've got lost on your way to an important meeting—you open
    up the map application you downloaded the night before, only to be confronted
    with permission requests every time you try to interact with the app. Not what
    you want when you're in a rush! It's incredibly easy to overwhelm a busy, multi-tasking
    mobile user with too much information.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想触及尽可能广泛的受众，您需要限制您的应用所需的权限数量。在新的权限模型下，这一点尤为重要，因为请求是在用户与您的应用交互时提出的。想象一下，您在去一个重要会议的路上迷路了——您打开昨晚下载的地图应用，却发现每次尝试与应用交互时都会遇到权限请求。这可不是您在匆忙时想要的情况！很容易让忙碌的多任务处理型移动用户被过多的信息淹没。
- en: If in doubt, remember that it's easier to add permissions to your app later
    via updates, than it is to remove them—so it's better to play it safe with a less-is-more
    approach.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您不确定，请记住，通过更新向应用添加权限比删除它们要容易得多——因此，采取少即是多的方法更安全。
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Automatic permission adjustments**'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动权限调整**'
- en: New releases of the Android platform may bring new restrictions, which can result
    in your app needing to request permissions that it didn't previously require.
    To make sure your app continues to work for users who are running the latest and
    greatest version of Android, the system may step in and automatically add these
    new permission requests to your project's `Manifest`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Android 平台的新版本可能会带来新的限制，这可能导致您的应用需要请求之前不需要的权限。为了确保您的应用能够继续为运行最新 Android 版本的用户提供服务，系统可能会介入并自动将这些新的权限请求添加到您的项目的
    `Manifest` 中。
- en: When deciding whether to automatically add permissions to your app, Android
    takes a look at your app's `targetSdkVersion`. If the value is lower than the
    version where the new permissions were added, the system may add these permissions
    automatically. This can result in your app requesting permissions that it doesn't
    necessarily need—definitely not a good thing!
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当决定是否自动向您的应用添加权限时，Android 会查看您的应用的 `targetSdkVersion`。如果该值低于添加新权限的版本，系统可能会自动添加这些权限。这可能导致您的应用请求它并不一定需要的权限——这绝对不是好事！
- en: To avoid this, make it a priority to test your project against new releases
    of the Android platform, and then update your `targetSdkVersion` as soon as you're
    confident that your app is compatible with this latest release.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，请将测试你的项目与Android平台的新版本对照作为优先事项，并在你确信你的应用与最新版本兼容后，立即更新你的`targetSdkVersion`。
- en: Requesting critical permissions up front
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提前请求关键权限
- en: If your app's core functionality hinges on having access to certain permissions,
    you should request these critical permissions up front. This is because users
    are more likely to take the time to read and therefore *grant* permission dialogues
    the first time they launch your app, rather than grant permission requests that
    interrupt them when they're midway through performing an important task in your
    app.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用的核心功能依赖于访问某些权限，你应该提前请求这些关键权限。这是因为用户更有可能花时间阅读并因此**授予**在第一次启动你的应用时出现的权限对话框，而不是在应用中执行重要任务中途被中断时授予权限请求。
- en: For non-critical permissions, you should wait until the user tries to access
    a related feature and then request that permission in context.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 对于非关键权限，你应该等到用户尝试访问相关功能时，再在上下文中请求该权限。
- en: Providing extra information where necessary
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在必要时提供额外信息
- en: Ideally, your permission requests should be self-explanatory, *especially* on
    devices running Android 6.0 or higher, where apps request permissions in context.
    For example, if a user taps your app's **Take a photo for your profile picture**
    button, chances are they aren't going to be confused when your app requests access
    to their camera.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你的权限请求应该是自我解释的，**尤其是**在运行Android 6.0或更高版本的设备上，因为应用在上下文中请求权限。例如，如果用户点击你的应用的**为您的个人资料图片拍照**按钮，那么当你的应用请求访问他们的相机时，他们不太可能感到困惑。
- en: However, if you suspect that it may not be immediately obvious why your app
    is requesting a certain permission, then you'll want to provide the user with
    some more information. Your users are always going to feel more comfortable when
    they understand why an app is requesting access to information or features. If
    you *don't* provide this information, then your users may suspect that you're
    leaving them in the dark on purpose.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你怀疑为什么你的应用请求某个权限可能并不立即明显，那么你将希望向用户提供更多一些的信息。当用户理解为什么一个应用请求访问信息或功能时，他们通常会感到更加舒适。如果你**不**提供这些信息，那么你的用户可能会怀疑你故意让他们处于黑暗之中。
- en: Just be wary of explaining *everything*. You shouldn't need to provide an explanation
    for every permission your app requests. If you overwhelm the user with too much
    information, they're going to get frustrated by the constant interruptions, and
    may end up either skim-reading your explanations (bad) or skipping them completely
    (worse).
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 只要注意不要解释**一切**。你不需要为应用请求的每个权限都提供解释。如果你用过多的信息让用户感到困扰，他们可能会因为不断的打扰而感到沮丧，最终可能只是快速浏览你的解释（不好）或者完全跳过它们（更糟）。
- en: If you find yourself providing an explanation *every time* your app makes a
    permission request, this may be an indication of a deeper problem with how your
    app is handling sensitive data or using device features. Maybe your app is requesting
    too many permissions? Or maybe it's requesting miscellaneous permissions that
    are unrelated to its core functionality?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现自己每次应用请求权限时都要提供解释，这可能表明你的应用在处理敏感数据或使用设备功能方面存在更深层次的问题。也许你的应用请求了过多的权限？或者它请求了一些与核心功能无关的杂项权限？
- en: 'Remember that permission request dialogues aren''t the only way of communicating
    with your users. You may want to consider other ways of giving the user the information
    they need to better understand the context of your app''s permission requests.
    For example, you could:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，权限请求对话框并不是与用户沟通的唯一方式。你可能需要考虑其他方式来向用户提供他们需要的信息，以更好地理解应用权限请求的上下文。例如，你可以：
- en: Add this information to your app's Google Play description.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将此信息添加到你的应用Google Play描述中。
- en: Create a privacy policy outlining the information your app needs access to and
    how it uses this information.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制定一份隐私政策，概述你的应用需要访问的信息以及如何使用这些信息。
- en: Create support documentation that your users can turn to if they need more information,
    such as an online user manual or a **Help** section inside your app.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建支持文档，以便用户在需要更多信息时可以查阅，例如在线用户手册或应用内的**帮助**部分。
- en: Update your UI so permission requests are more self-explanatory. Your users
    may be confused if they tap a stock avatar and your app suddenly requests access
    to their camera, however if the stock photo has a **Tap here to take a profile
    picture** label, then your users are *far* less likely to be confused.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更新你的用户界面，使权限请求更加直观。如果用户点击一个默认头像，你的应用突然请求访问他们的摄像头，他们可能会感到困惑，但如果默认照片上有“**点击这里拍摄个人照片**”的标签，那么你的用户就*不太可能*感到困惑。
- en: Create dedicated support channels for your users such as forums, social media
    pages, or an e-mail address where they can reach out to you with any questions.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为你的用户提供专门的客服渠道，例如论坛、社交媒体页面或一个电子邮箱地址，他们可以通过这些渠道向你提出任何疑问。
- en: Paying attention to permissions required by libraries
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意库所需的权限
- en: When you include a library in your project, your project inherits any permissions
    that library requests. Before you use *any* library, always check what permissions
    that library requires, and what it uses those permissions for.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在项目中包含一个库时，你的项目会继承该库请求的任何权限。在你使用*任何*库之前，始终检查该库需要的权限以及它使用这些权限的目的。
- en: Adding multiple libraries to your project without checking their permissions
    first can quickly land you in hot water with your users, as from the user's perspective
    it's your app that's making these requests, and not an external library. These
    libraries may even request permissions that seem completely unrelated to your
    app, potentially making your users even more suspicious.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在不检查权限的情况下将多个库添加到你的项目中，可能会迅速让你陷入与用户的纠纷，因为从用户的角度来看，是你的应用在发起这些请求，而不是外部库。这些库甚至可能请求与你的应用看似完全不相关的权限，这可能会让用户更加怀疑。
- en: If you need to include a library in your project but are concerned that it requires
    too many permissions, then you can always look for an alternative library that
    provides similar functionality but doesn't make quite so many permission requests.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在项目中包含一个库，但又担心它需要太多的权限，那么你总是可以寻找提供类似功能但权限请求较少的替代库。
- en: Being transparent about accessing the camera and microphone
  id: totrans-144
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 透明地访问摄像头和麦克风
- en: Sometimes your app may need to access particularly sensitive features, such
    as the device's camera or microphone. Most of the time your app won't require
    *constant* access to these features, but once the user has granted your app access,
    how do they know that it isn't constantly pulling information from their microphone
    and camera?
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的应用可能需要访问特别敏感的功能，例如设备的摄像头或麦克风。大多数时候，你的应用不需要*持续*访问这些功能，但一旦用户已经授权你的应用访问，他们如何知道它不是在不断地从他们的麦克风和摄像头中提取信息？
- en: No one likes to feel they're being watched, so you should be up front about
    when your app is accessing the device's camera or microphone. For example, you
    could display a pop-up with a timer indicating that your app is going to turn
    the device's camera on in 3, 2, 1, or you could display a flashing microphone
    icon in the corner of the screen whenever your app is *listening* to the user.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人喜欢觉得自己被监视，所以你应该明确告知用户你的应用何时会访问设备的摄像头或麦克风。例如，你可以显示一个带有倒计时的弹出窗口，表明你的应用将在3、2、1后打开设备的摄像头，或者你可以在应用正在*监听*用户时，在屏幕角落显示一个闪烁的麦克风图标。
- en: Considering alternatives
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 考虑替代方案
- en: Even if your app does require access to protected information or features, you
    may be able to engineer your app so it doesn't have to make these requests itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你的应用确实需要访问受保护的信息或功能，你可能能够设计你的应用，使其不需要自己发起这些请求。
- en: An app only needs to request permissions for actions that it performs directly
    - *not* when it's asking other apps to perform a task on its behalf, or supply
    it with information. For example, instead of requesting access to the device's
    camera, you could use `MediaStore.ACTION_IMAGE_CAPTURE` to launch a camera app
    that the user has already installed on their device. You can also use system intents
    to request information from other apps, such as requesting contact information
    from the user's Contacts app, rather than issuing the `READ_CONTACTS` permission.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应用只需要请求它直接执行的操作的权限 - *不是*当它请求其他应用代表它执行任务或提供信息时。例如，你不需要请求访问设备的摄像头，你可以使用`MediaStore.ACTION_IMAGE_CAPTURE`来启动用户已经在设备上安装的相机应用。你还可以使用系统意图从其他应用请求信息，例如从用户的联系人应用请求联系人信息，而不是发出`READ_CONTACTS`权限。
- en: The major downside to this approach is that it presents the user with a dialogue
    every time your app needs to access the protected information or feature, so consider
    whether the frequency or timing of these requests is likely to irritate your users.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的缺点主要是每次您的应用需要访问受保护的信息或功能时都会向用户显示一个对话框，因此请考虑这些请求的频率或时间是否可能激怒您的用户。
- en: Notifications
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通知
- en: Notifications underwent a massive overhaul in Android Lollipop, getting both
    a Material Design makeover *and* new methods that help Android sort notifications
    more intelligently.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Lollipop 中，通知经历了大规模的改进，不仅获得了材料设计的外观，还引入了帮助 Android 更智能地排序通知的新方法。
- en: In Android 5.0 and higher, you can annotate your notifications with the `setPriority()`
    method. Low-priority notifications may be hidden from the user, while higher-priority
    notifications are more likely to interrupt whatever the user is currently doing.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 5.0 及更高版本中，您可以使用 `setPriority()` 方法注释您的通知。低优先级通知可能会从用户那里隐藏，而高优先级通知更有可能打断用户当前正在做的事情。
- en: 'The different priority levels are:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的优先级级别是：
- en: '`Notification.PRIORITY_MAX`: Used for critical and urgent notifications that
    alert the user to a condition that''s time-sensitive, or that they may need to
    resolve before they can continue with the current task.'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notification.PRIORITY_MAX`: 用于关键和紧急通知，提醒用户注意时间敏感的情况，或者在他们继续当前任务之前可能需要解决的问题。'
- en: '`Notification.PRIORITY_HIGH`: Typically used for important communications such
    as chat messages. High-priority notifications appear in a floating *heads-up* window
    that contains action buttons. Action buttons allow the user to act on, or dismiss,
    the heads-up notification without having to navigate away from the current screen.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notification.PRIORITY_HIGH`: 通常用于重要的通讯，如聊天消息。高优先级通知会出现在包含操作按钮的浮动 *heads-up*
    窗口中。操作按钮允许用户在无需离开当前屏幕的情况下对或忽略浮动的通知。'
- en: '`Notification.PRIORITY_LOW`: Used for less urgent notifications.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notification.PRIORITY_LOW`: 用于不那么紧急的通知。'
- en: '`Notification.PRIORITY_MIN`: Used for contextual or background information.
    Minimum-priority notifications aren''t usually shown to the user except under
    special circumstances, such as detailed notification logs.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notification.PRIORITY_MIN`: 用于上下文或背景信息。最低优先级的通知通常不会显示给用户，除非在特殊情况下，例如详细的通知日志。'
- en: '`Notification.PRIORITY_DEFAULT`: You can use this priority flag for all notifications
    that don''t fall into any of the more specific priority categories.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Notification.PRIORITY_DEFAULT`: 您可以使用此优先级标志为所有不属于更具体优先级类别的通知。'
- en: Many Android devices feature a notification LED that you can use to inform users
    about events that are happening inside your app, even when the screen is off.
    Assigning your app's notifications a priority level of `MAX`, `HIGH`, or `DEFAULT`
    should cause the LED to glow.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 许多 Android 设备都配备了通知 LED，您可以使用它来通知用户应用内部正在发生的事件，即使屏幕处于关闭状态。将您应用的通知优先级设置为 `MAX`、`HIGH`
    或 `DEFAULT` 应该会导致 LED 发光。
- en: In Android 5.0 and higher, notifications also appear on the device's lockscreen,
    which means you need to consider whether your notifications contain information
    that users might not want to appear on their lockscreen for the whole world to
    see.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 5.0 及更高版本中，通知也会出现在设备的锁屏上，这意味着您需要考虑您的通知是否包含用户可能不希望在全世界的注视下出现在锁屏上的信息。
- en: 'You can use `setVisibility()` to tell Android how much information it should
    display on the lockscreen, and assign it one of the following values:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `setVisibility()` 来告诉 Android 应在锁屏上显示多少信息，并分配以下值之一：
- en: '`VISIBILITY_SECRET`: No part of the notification appears on the lockscreen.
    This is recommended if your app''s notifications contain personal or potentially
    embarrassing information.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBILITY_SECRET`: 通知的任何部分都不会出现在锁屏上。如果您应用的通知包含个人信息或可能令人尴尬的信息，则建议使用此选项。'
- en: '`VISIBILITY_PRIVATE`: The notification displays some basic information on the
    lockscreen, but most of the information is hidden.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBILITY_PRIVATE`: 通知在锁屏上显示一些基本信息，但大部分信息被隐藏。'
- en: '`VISIBILITY_PUBLIC`: The notification appears on the lockscreen in its entirety.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VISIBILITY_PUBLIC`: 通知完整地出现在锁屏上。'
- en: Notification best practices
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通知最佳实践
- en: Design your notifications well, and they'll provide real value to your users—plus,
    they'll serve as a handy way of enticing users back to your app, by presenting
    them with interesting and timely updates about events that are happening inside
    your application.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的通知，它们将为用户提供真正的价值——此外，它们还将作为吸引用户回到你应用的便捷方式，通过向他们展示关于应用程序内发生的事件的有趣和及时更新。
- en: To make the most out of Android's notification system, you should keep the following
    best practices in mind.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 要充分利用Android的通知系统，你应该牢记以下最佳实践。
- en: Providing the right content
  id: totrans-169
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供正确的内容
- en: 'At the very least, your notifications should contain:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 至少，你的通知应该包含：
- en: A title (`setContentTitle`) and secondary text (`setContentText`)
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个标题（`setContentTitle`）和次要文本（`setContentText`）
- en: A timestamp; note this indicates when the event occurred and *not* when the
    notification was posted
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个时间戳；请注意，这表示事件发生的时间，而不是通知发布的时间
- en: The notification type (optional)
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通知类型（可选）
- en: To make sure the user can recognize your app's pending notifications in the
    system bar, you should include a distinct app icon (`setSmallIcon`).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保用户可以在系统栏中识别出你的应用挂起的推送通知，你应该包含一个独特的应用图标（`setSmallIcon`）。
- en: Your notification icon should be simple and avoid any excessive detail, but
    at the same time it must be eye-catching and distinct from the other notification
    icons users may encounter. You should use the Material Light action bar icon style
    and avoid opaque backgrounds—basically, your notification icon should be a white-on-transparent
    background image.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 你的通知图标应该简单，避免任何过多的细节，但同时也必须引人注目，并且与其他用户可能遇到的推送通知图标明显不同。你应该使用Material Light操作栏图标样式，并避免不透明的背景——基本上，你的通知图标应该是一个白色透明背景的图片。
- en: If you're struggling for inspiration, try booting up your Android device and
    taking a look at the kind of notification icons other applications are using.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感到缺乏灵感，试着启动你的Android设备，看看其他应用程序使用的推送通知图标类型。
- en: Using notifications sparingly
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 谨慎使用通知
- en: Every time you issue a notification, you're interrupting whatever the user is
    doing at that moment, so it's important you use notifications sparingly.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 每次你发布一个通知时，你都在打断用户当时正在做的事情，因此你谨慎地使用通知非常重要。
- en: You should *never* use notifications to alert the user about background operations
    that don't require their input or that aren't time-sensitive. You also shouldn't
    use notifications to alert the user about events that are already happening on
    screen. Instead, inform the user about these events in context via your app's
    UI. For example, if the user has unlocked a new level in your gaming app, and
    that app is currently on screen, you should alert them via an on screen message
    rather than firing off a notification.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你绝对不应该使用通知来提醒用户关于不需要他们输入或不是时间敏感的背景操作。你也不应该使用通知来提醒用户关于屏幕上已经发生的事件。相反，你应该通过你应用的UI在上下文中通知用户这些事件。例如，如果用户在你的游戏应用中解锁了新关卡，并且该应用当前在屏幕上，你应该通过屏幕上的消息提醒他们，而不是发送推送通知。
- en: Even though notifications can be useful for reminding the user about your application,
    you should *never* use unnecessary notifications to tempt the user into launching
    your app. In the long run, unimportant or unwanted notifications are only going
    to make users view your app as an attention-seeker, which may even lead to them
    uninstalling your app and leaving you a negative review on Google Play.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管通知可以用来提醒用户你的应用程序，但你绝对不应该使用不必要的通知来诱使用户打开你的应用。从长远来看，不重要或不想要的推送通知只会让用户认为你的应用是寻求注意，甚至可能导致他们卸载你的应用，并在Google
    Play上给你留下负面评价。
- en: Giving users a choice
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 给用户选择权
- en: Ideally, you should give your users the option to change your app's notifications
    settings, such as switching between sound alerts and vibration alerts, or even
    allowing users to disable notifications entirely.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该给用户选择更改你应用的通知设置，例如在声音警报和振动警报之间切换，甚至允许用户完全禁用通知。
- en: Categorising notifications
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对通知进行分类
- en: 'When ranking and filtering notifications, the Android system may take an app''s
    category into consideration, so you should assign a suitable category to each
    of your app''s notifications. To do this, use the `setCategory()` option and choose
    from the following supported categories:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在对通知进行排名和筛选时，Android系统可能会考虑应用类别，因此你应该为每个应用的通知分配一个合适的类别。为此，使用`setCategory()`选项并从以下支持的类别中选择：
- en: '`CATEGORY_ALARM`: Alarm or timer'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_ALARM`：闹钟或定时器'
- en: '`CATEGORY_CALL`: An incoming voice or video call'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_CALL`： incoming voice or video call'
- en: '`CATEGORY_EMAIL`: Asynchronous bulk message'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_EMAIL`：异步批量消息'
- en: '`CATEGORY_ERROR`: An error in a background operation'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_ERROR`：后台操作中的错误'
- en: '`CATEGORY_EVENT`: Calendar event'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_EVENT`：日历事件'
- en: '`CATEGORY_MESSAGE`: Incoming direct message, such as an SMS'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_MESSAGE`：传入的直接消息，例如短信'
- en: '`CATEGORY_PROGRESS`: The progress of an operation running in the background'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_PROGRESS`：后台运行操作的进度'
- en: '`CATEGORY_PROMO`: A promotion or advert'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_PROMO`：促销或广告'
- en: '`CATEGORY_RECOMMENDATION`: A specific, timely recommendation'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_RECOMMENDATION`：一个具体、及时的推荐'
- en: '`CATEGORY_SERVICE`: An indication of a service that''s running in the background'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_SERVICE`：表示在后台运行的服务'
- en: '`CATEGORY_SOCIAL`: A social network or sharing update'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_SOCIAL`：社交网络或分享更新'
- en: '`CATEGORY_STATUS`: Ongoing information about device or contextual status'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_STATUS`：关于设备或上下文状态的持续信息'
- en: '`CATEGORY_SYSTEM`: This category is reserved for system or device status updates'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_SYSTEM`：此类别保留用于系统或设备状态更新'
- en: '`CATEGORY_TRANSPORT`: Media transport control for playback'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CATEGORY_TRANSPORT`：媒体传输控制以进行播放'
- en: Making use of actions
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 利用操作
- en: You can also add action buttons to your notifications. Action buttons allow
    users to perform common tasks from the notification UI, without them having to
    open the originating app.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以向你的通知添加操作按钮。操作按钮允许用户从通知UI执行常见任务，而无需打开原始应用。
- en: 'You add a button to your notification using the following syntax:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下语法向通知添加按钮：
- en: '[PRE11]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Tip
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Each action should have its own icon and its own name.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作都应该有自己的图标和名称。
- en: Although optional, it's generally a good idea to add at least one action to
    each of your app's notifications. Just don't get carried away—limit yourself to
    a maximum of three actions per notification.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然是可选的，但通常给每个应用的通知至少添加一个操作是个好主意。只是不要过分——每个通知限制最多三个操作。
- en: Using expanded layouts
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用展开布局
- en: 'For users running Android 4.1 and higher, you can supply two different visual
    styles for each of your app''s notifications:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运行 Android 4.1 及更高版本的用户，你可以为每个应用的通知提供两种不同的视觉风格：
- en: '**Normal view**: This is the default, compact layout.'
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常视图**：这是默认的紧凑布局。'
- en: '**Big view style**: A separate layout that appears when the user expands your
    notification by pinching or dragging it open.'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大视图风格**：当用户通过捏合或拖动打开通知时出现的单独布局。'
- en: You have a choice of three different big view styles.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以选择三种不同的大视图风格。
- en: Big text style
  id: totrans-211
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大文本风格
- en: 'This layout provides additional text that''s displayed in the detail area of
    the expanded notification, in place of the notification''s regular `setContentText`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局提供了在展开通知的详细区域显示的附加文本，代替通知的常规`setContentText`：
- en: '[PRE12]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Big picture style
  id: totrans-214
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 大图风格
- en: 'This layout includes a large image attachment:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局包括一个大型图像附件：
- en: '[PRE13]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Inbox style
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 收件箱风格
- en: 'This layout includes a list of up to five items:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 此布局包括最多五个项目的列表：
- en: '[PRE14]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Direct reply notifications
  id: totrans-220
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 直接回复通知
- en: Google are adding a few new features to notifications in the upcoming release
    of Android *N*, including an **inline reply** action button that allows users
    to reply directly from the notification UI.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: Google 在即将发布的 Android *N* 版本中为通知添加了一些新功能，包括一个允许用户从通知UI直接回复的**内联回复**操作按钮。
- en: Direct reply notifications are particularly big news for messaging apps, as
    they give users the ability to reply without even having to launch the messaging
    app. You may have already encountered direct reply notifications in Google Hangouts.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 直接回复通知对于消息应用来说尤其是个大新闻，因为它们使用户能够在甚至不需要启动消息应用的情况下进行回复。你可能已经在 Google Hangouts 中遇到了直接回复通知。
- en: To create a notification action that supports direct reply, you need to create
    an instance of `RemoteInput.Builder` and then add it to your notification action.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个支持直接回复的通知操作，你需要创建一个`RemoteInput.Builder`实例，并将其添加到你的通知操作中。
- en: 'The following code adds a `RemoteInput` to a `Notification.Action`, and creates
    a **Quick Reply** key. When the user triggers the action, the notification prompts
    the user to input their response:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码将一个`RemoteInput`添加到`Notification.Action`中，并创建了一个**快速回复**键。当用户触发操作时，通知会提示用户输入他们的回复：
- en: '[PRE15]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To retrieve the user''s input from the notification interface, you need to
    call `getResultsFromIntent(Intent)` and pass the notification action''s intent
    as the input parameter:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要从通知界面检索用户的输入，你需要调用`getResultsFromIntent(Intent)`并将通知操作的intent作为输入参数传递：
- en: '[PRE16]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Bundled notifications
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组合通知
- en: Don't you just hate it when you connect to the Internet first thing in the morning
    and your Gmail app instantly bombards you with a **4 new messages** notification,
    but doesn't give you any more information about those individual e-mails? Not
    particularly helpful!
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 你早上第一件事就是连接到互联网，然后你的Gmail应用立刻用**4条新消息**通知你，但不会给你关于这些个别电子邮件的任何更多信息，这不是特别有帮助！
- en: When you receive a notification that consists of multiple items, the only thing
    you can really do is open the app and take a look at the individual events that
    make up this grouped notification.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 当您收到一个由多个项目组成的通知时，您唯一能真正做的事情就是打开应用并查看构成这个分组通知的个别事件。
- en: However, the upcoming release of Android N promises to fix this problem by introducing
    **bundled notifications**. This new notification style allows you to group multiple
    notifications from the same app into a single, bundled notification. A bundled
    notification consists of a parent notification that displays summary information
    for that group, plus individual notification items.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即将发布的Android N版本承诺通过引入**捆绑通知**来解决这个问题。这种新的通知样式允许您将来自同一应用的多条通知组合成一个单一、捆绑的通知。捆绑通知由一个父通知组成，显示该组的摘要信息，以及个别通知项。
- en: If the user wants to see more information about these individual items, they
    can *unfurl* the bundled notification card into separate, smaller notifications
    by swiping down with two fingers. When the user expands a bundled notification,
    the system reveals more information about each child notification. The user can
    then act on each of these mini-notifications individually, for example they might
    choose to dismiss the first three notifications about spam e-mails, but open the
    fourth e-mail. This is similar to the Notification Stacks feature you may have
    encountered in Android Wear.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户想了解更多关于这些个别项目的信息，他们可以通过用两根手指向下滑动来展开捆绑通知卡片，将其展开成单独的、更小的通知。当用户展开捆绑通知时，系统会显示每个子通知的更多信息。然后用户可以单独对每个这些迷你通知采取行动，例如他们可能会选择删除关于垃圾邮件的前三条通知，但打开第四封电子邮件。这与您可能在Android
    Wear中遇到的Notification Stacks功能类似。
- en: Note
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Bundled notifications are particularly useful when your app has the potential
    to generate multiple notifications where each child notification is actionable.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的应用有可能生成多个通知，并且每个子通知都是可操作的时候，捆绑通知特别有用。
- en: 'To group notifications, call `setGroup()` for each notification you want to
    add to the same notification stack, and then assign these notifications the same
    key:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 要分组通知，为每个想要添加到同一通知堆栈的通知调用`setGroup()`，然后为这些通知分配相同的键：
- en: '[PRE17]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'When you create another notification that belongs to this stack, you just need
    to assign it the same group key:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当您创建属于此堆栈的另一个通知时，只需为其分配相同的组键：
- en: '[PRE18]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Application widgets
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用小部件
- en: Widgets provide users with a small, convenient sample of your application's
    most important data, typically from the comfort of their home screen.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件为用户提供应用最重要的数据的小型、便捷样本，通常从他们舒适的首页开始。
- en: To create a basic app widget, you need to complete the process described in
    the following sections.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基本的应用小部件，您需要完成以下章节中描述的过程。
- en: Declaring an AppWidgetProvider class in your project's Manifest
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在您的项目Manifest中声明AppWidgetProvider类
- en: The `AppWidgetProvider` class defines the methods that allow you to programmatically
    interact with your app widget based on broadcast events.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppWidgetProvider`类定义了允许您根据广播事件以编程方式与您的应用小部件交互的方法。'
- en: 'Here''s an example of a basic `AppWidgetProvider` implementation:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个基本的`AppWidgetProvider`实现的例子：
- en: '[PRE19]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating an AppWidgetProviderInfo file
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建AppWidgetProviderInfo文件
- en: 'The next step is defining the basic qualities of your widget, such as its minimum
    width and height, and how often it''s updated. Create a `res/xml` directory, if
    your project doesn''t already contain one, and then create a new XML layout file.
    In this example, we''re using `my_appwidget_info.xml`:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是定义您小部件的基本特性，例如其最小宽度和高度，以及更新的频率。如果您的项目还没有包含一个`res/xml`目录，请创建一个，然后创建一个新的XML布局文件。在这个例子中，我们使用`my_appwidget_info.xml`：
- en: '[PRE20]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating the widget's layout
  id: totrans-249
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建小部件的布局
- en: You define your widget's layout in XML in the same way you create a regular
    layout resource file. The only major difference is that app widget layouts are
    based on `RemoteViews`, which don't support every layout and view.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您以创建常规布局资源文件相同的方式在XML中定义您的小部件布局。唯一的重大区别是，应用小部件布局基于`RemoteViews`，它不支持每个布局和视图。
- en: 'As a result, app widgets support the following layout classes only:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用程序小部件仅支持以下布局类：
- en: '`FrameLayout`'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FrameLayout`'
- en: '`GridLayout`'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridLayout`'
- en: '`LinearLayout`'
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LinearLayout`'
- en: '`RelativeLayout`'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RelativeLayout`'
- en: 'They also only support the following widget classes:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 它们也仅支持以下小部件类：
- en: '`AdapterViewFlipper`'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AdapterViewFlipper`'
- en: '`AnalogClock`'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnalogClock`'
- en: '`Button`'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Button`'
- en: '`Chronometer`'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chronometer`'
- en: '`GridView`'
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GridView`'
- en: '`ImageButton`'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageButton`'
- en: '`ImageView`'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ImageView`'
- en: '`ListView`'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ListView`'
- en: '`ProgressBar`'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProgressBar`'
- en: '`StackView`'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StackView`'
- en: '`TextView`'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TextView`'
- en: '`ViewFlipper`'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewFlipper`'
- en: Note
  id: totrans-269
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`RemoteViews` also support `ViewStubs`.'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoteViews`也支持`ViewStubs`。'
- en: App widget best practices
  id: totrans-271
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 应用程序小部件最佳实践
- en: Well-designed app widgets that display useful information serve as a constant
    reminder about how great your app is, tempting the user to launch your application—or
    at the very least, making them less likely to uninstall your app.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 设计良好的应用程序小部件，显示有用的信息，可以作为您应用程序出色的持续提醒，诱使用户启动您的应用程序——至少，这会使他们不太可能卸载您的应用程序。
- en: To make sure your widget presents your application in the best possible light,
    make sure you adhere to the following best practices.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的小部件以最佳方式展示您的应用程序，请确保您遵守以下最佳实践。
- en: Including margins for earlier versions of Android
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 包括早期版本的Android的边距
- en: Your widgets shouldn't extend to the edges of the screen or bump up against
    other widgets, as this can make the user's home screen look messy and cluttered.
    The solution is to add a margin around each edge of your widgets, something that
    Android 4.0 and higher does automatically whenever the user places a widget on
    their home screen. To take advantage of this behavior, you just need to set your
    app's `targetSdkVersion` to `14` or greater.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 您的小部件不应延伸到屏幕边缘或与其他小部件相撞，因为这会使用户的首页看起来杂乱无章。解决方案是在您的小部件的每个边缘添加边距，Android 4.0及以上版本在用户将小部件放置在首页时自动执行此操作。要利用此行为，您只需将应用程序的`targetSdkVersion`设置为`14`或更高版本。
- en: Since Android 4.0 and greater applies margins to your app automatically, you
    shouldn't add any extra margins to your widget when it's installed on devices
    running Android 4.0 and over. However you *will* still need to add margins when
    your app is installed on devices running earlier versions of Android.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Android 4.0及以上版本会自动为您的应用程序应用边距，因此当您的应用程序安装在运行Android 4.0及以上版本的设备上时，您不应为小部件添加任何额外的边距。然而，当您的应用程序安装在运行Android早期版本的设备上时，您仍然需要添加边距。
- en: 'The solution is to create two `dimens.xml` files that specify different margins
    for different versions of Android:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案是创建两个`dimens.xml`文件，分别指定不同版本的Android的不同边距：
- en: '`res/values-v14/dimens.xml`: This file defines the 0dp margins for devices
    running Android 4.0 and greater:'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/values-v14/dimens.xml`：此文件定义了运行Android 4.0及以上版本的设备的0dp边距：'
- en: '[PRE21]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '`res/values/dimens.xml`: This file defines the margins for devices running
    versions of Android lower than 4.0:'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`res/values/dimens.xml`：此文件定义了运行Android 4.0以下版本的设备的边距：'
- en: '[PRE22]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'You can then reference these `dimens.xml` values in your widget''s layout resource
    file, and the Android system will select the appropriate `widget_margins` value
    at runtime:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您可以在小部件的布局资源文件中引用这些`dimens.xml`值，Android系统将在运行时选择适当的`widget_margins`值：
- en: '[PRE23]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Providing flexible graphics and layouts
  id: totrans-284
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 提供灵活的图形和布局
- en: The Android home screen is divided into a grid. The user can place app widgets
    inside free cells, and then stretch them horizontally and/or vertically to occupy
    a different number of cells.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Android首页分为一个网格。用户可以将应用程序小部件放置在空白单元格中，然后水平或垂直拉伸以占用不同数量的单元格。
- en: To ensure your widget's layout is flexible enough to be able to adapt to different
    grid sizes, you should define your widget's background using stretchable nine-patch
    images, and then use flexible layouts such as `LinearLayout`, `RelativeLayout`
    or `FrameLayout`.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的小部件布局足够灵活，能够适应不同的网格大小，您应该使用可拉伸的九宫格图像定义您的小部件背景，然后使用灵活的布局，如`LinearLayout`、`RelativeLayout`或`FrameLayout`。
- en: Not updating too often
  id: totrans-287
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 不要更新得太频繁
- en: If the device is asleep when the app widget framework requests an update from
    the `AppWidgetProvider`, the device will wake up in order to perform this operation.
    Requesting too many updates is a surefire way to drain the user's battery and
    may result in them uninstalling your app, or at the very least banishing your
    app widget from their home screen.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果当应用程序小部件框架请求从`AppWidgetProvider`更新时设备处于睡眠状态，设备将唤醒以执行此操作。请求过多的更新是耗尽用户电池的可靠方法，可能会导致他们卸载您的应用程序，或者至少将您的应用程序小部件从他们的首页上移除。
- en: It's important to consider how often your widget really needs to receive new
    information, for example you'll typically need to update a weather or news widget
    less often than a widget that alerts users about incoming e-mails.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑你的小部件真正需要多久接收一次新信息是很重要的，例如，你通常需要比提醒用户关于即将到来的电子邮件的小部件更频繁地更新天气或新闻小部件。
- en: If you're building a widget that *does* require frequent updates, then it's
    generally a good idea to perform these updates based on an alarm that won't wake
    the device. If this alarm goes off while the device is asleep, this update won't
    be performed until the next time the device wakes up, so it has less impact on
    the device's battery.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在构建一个需要频繁更新的小部件，那么基于一个不会唤醒设备的警报来执行这些更新通常是一个好主意。如果这个警报在设备处于睡眠状态时响起，那么更新将不会在设备下一次唤醒时执行，因此对设备电池的影响较小。
- en: 'To create this kind of alarm, use the `AlarmManager` to set an alarm with an `Intent`
    that your `AppWidgetProvider` receives, and then set the alarm type to either `ELAPSED_REALTIME`
    or `RTC`, for example:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类警报，请使用`AlarmManager`设置一个带有你的`AppWidgetProvider`接收的`Intent`的警报，然后将警报类型设置为`ELAPSED_REALTIME`或`RTC`，例如：
- en: '[PRE24]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Finally, set the widget's `updatePeriodMillis` to zero so it won't override
    your alarm and wake the device.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将小部件的`updatePeriodMillis`设置为零，这样它就不会覆盖你的警报并唤醒设备。
- en: Accessibility best practices
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可访问性最佳实践
- en: Your app is only truly accessible when everyone can navigate it, understand
    it, and use it successfully, including people who may have visual, physical, or
    age-related limitations.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 只有当每个人都能导航、理解并成功使用你的应用时，你的应用才是真正可访问的，包括可能存在视觉、身体或年龄相关限制的人。
- en: Android has several in built accessibility features that help you optimize your
    app for users with visual or physical disabilities, so the good news is that,
    in most cases, creating an accessible app won't require any extensive changes
    to your code.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: Android有几个内置的可访问性功能，可以帮助你优化你的应用以适应有视觉或身体障碍的用户，所以好消息是，在大多数情况下，创建一个可访问的应用不需要对代码进行任何重大更改。
- en: In this section, I'll show you how to use these built-in platform features to
    make sure *everyone* can enjoy using your app.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我将向你展示如何使用这些内置平台功能确保每个人都能享受使用你的应用。
- en: Note
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If your app is part of a team effort, then it's important that everyone on your
    team keeps accessibility in mind. If you're working with a designer or a team
    of testers, then it's a good idea to make sure they're also familiar with the
    following accessibility guidelines.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用是团队工作的一部分，那么确保你的团队中的每个人都考虑到可访问性是很重要的。如果你与设计师或测试团队一起工作，那么确保他们也熟悉以下可访问性指南是一个好主意。
- en: Adding descriptive text to your UI controls
  id: totrans-300
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向你的UI控件添加描述性文本
- en: If you've designed your UI well, you shouldn't have to add an explicit label
    to every on screen element, for example a button with a telephone icon inside
    a **Contacts** app has a pretty obvious purpose. However, users with vision impairments
    may not be able to pick up on these visual clues, so you'll need to provide them
    with some additional information.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经很好地设计了你的UI，那么你不需要为每个屏幕元素添加显式的标签，例如，一个电话图标在**联系人**应用中的按钮具有相当明显的用途。然而，有视觉障碍的用户可能无法捕捉到这些视觉线索，因此你需要为他们提供一些额外的信息。
- en: You should provide content descriptions for every UI component that doesn't
    feature visible text. Also consider whether these descriptions alone provide sufficient
    context for the user to fully understand the related visual elements—without any
    visual context, a **Delete** or **Call the selected contact** content description
    may not be particularly helpful.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该为每个没有可见文本的UI组件提供内容描述。同时考虑这些描述是否足以提供足够的上下文，让用户完全理解相关的视觉元素——在没有视觉上下文的情况下，**删除**或**呼叫所选联系人**的内容描述可能并不特别有帮助。
- en: The text in the description attribute *doesn't* appear on screen, but if the
    user enables speech-based accessibility services such as TalkBack, this description
    is read aloud when the user navigates to that item.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 描述属性中的文本不会显示在屏幕上，但如果用户启用了基于语音的可访问性服务，如TalkBack，当用户导航到该项目时，此描述会被读出来。
- en: 'You can add a description using the `android:contentDescription` XML layout
    attribute:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`android:contentDescription` XML布局属性来添加描述：
- en: '[PRE25]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Imagine that the value of `@string/newSMS` is `Create a new SMS message`. When
    the user hovers over this icon with an accessibility service enabled, this description
    will be read aloud and the user will then understand what this UI element does.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`@string/newSMS`的值为`Create a new SMS message`。当用户在有辅助服务启用的状态下悬停在图标上时，此描述将被读出，用户将了解这个UI元素的功能。
- en: Note
  id: totrans-307
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For `EditTexts,` your top priority should be helping the user to understand
    what content they're expected to enter into this empty field, so you should provide
    an `android:hint` attribute *instead* of a content description. Once the user
    has entered some text into the `EditText`, the accessibility service will read
    this text aloud, instead of the `android:hint` value.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`EditText`，您的首要任务是帮助用户理解他们需要输入到这个空白字段中的内容，因此您应该提供一个`android:hint`属性*而不是*内容描述。一旦用户在`EditText`中输入了一些文本，辅助服务将朗读此文本，而不是`android:hint`的值。
- en: There'll be situations where you want to base an item's content description
    on dynamic elements, such as the state of a slider or the currently selected text
    in a list. If this is the case, then you'll need to edit the content description
    at runtime using the `setContentDescription()` method.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望将项目的内容描述基于动态元素，例如滑块的状态或列表中当前选中的文本。如果是这种情况，那么您需要使用`setContentDescription()`方法在运行时编辑内容描述。
- en: Providing descriptions is particularly important for `ImageButton`, `ImageView`,
    and `Checkbox` components, but you should add content descriptions wherever you
    suspect that users with different abilities might benefit from some additional
    information. Just don't get carried away and add unnecessary descriptions, as
    this just increases the noise the user encounters as they're trying to decipher
    your UI, making it more difficult for them to pull useful information from their
    accessibility service.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 对于`ImageButton`、`ImageView`和`Checkbox`组件，提供描述尤为重要，但您应该在您怀疑不同能力的用户可能从一些额外信息中受益的地方添加内容描述。只是不要过分，不要添加不必要的描述，因为这只会增加用户在尝试解析您的UI时遇到的噪音，使他们在辅助服务中提取有用信息变得更加困难。
- en: Wherever possible, use Android's standard controls as they have `ContentDescriptions`
    built in by default, and therefore work automatically with accessibility services
    such as TalkBack.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用Android的标准控件，因为它们默认内置了`ContentDescriptions`，因此可以自动与TalkBack等辅助服务一起工作。
- en: Designing for focus navigation
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设计焦点导航
- en: Focus navigation is where your users employ directional controls to navigate
    the individual elements that make up your app's UI, similar to the four-way remote
    control navigation on a television. Users with limited vision or limited manual
    dexterity often use this mode of navigation instead of touchscreen navigation.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 焦点导航是指用户使用方向控制器来导航构成应用UI的各个元素，类似于电视上的四向遥控器导航。视力受限或手动灵活性有限的用户通常使用这种导航模式而不是触摸屏导航。
- en: Directional controllers can be software-based or hardware-based, such as a trackball,
    D-pad, or external keyboard. Users may also choose to enable the gestures navigation
    mode available in devices running Android 4.1 and higher.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 方向控制器可以是基于软件的或基于硬件的，例如轨迹球、D-pad或外部键盘。用户还可以选择启用在运行Android 4.1及以上版本的设备中可用的手势导航模式。
- en: To make sure your users can successfully navigate your app using a directional
    controller, you need to verify that all your UI input controls can be reached
    and activated without using the touchscreen. You should also verify that clicking
    a directional controller's center, or **OK** button, has the same effect as touching
    a control that already has focus.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保用户能够使用方向控制器成功导航您的应用，您需要验证所有UI输入控件是否可以在不使用触摸屏的情况下访问和激活。您还应该验证点击方向控制器的中心或**OK**按钮与触摸已获得焦点的控件具有相同的效果。
- en: In order to support focus navigation, you should ensure that all your app's
    navigational elements are focusable. You can achieve this by adding the `android:focusable="true"`
    attribute to your UI elements, or perform this modification at runtime using the `View.setFocusable()` method
    on each UI control.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持焦点导航，您应该确保所有应用导航元素都是可聚焦的。您可以通过添加`android:focusable="true"`属性到UI元素中来实现这一点，或者在每个UI控件上使用`View.setFocusable()`方法在运行时进行此修改。
- en: The UI controls provided by the Android framework are focusable by default,
    and the system visually indicates focus by changing the control's appearance.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Android框架提供的UI控件默认是可聚焦的，系统通过改变控件的外观来视觉上指示焦点。
- en: When a user navigates in any direction using directional controls, focus is
    passed from one UI element to another, as determined by the focus order. The system
    determines the focus order automatically based on an algorithm that finds the
    nearest neighbor in a given direction.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户使用方向控制向任何方向导航时，焦点会从一个 UI 元素传递到另一个 UI 元素，这是由焦点顺序决定的。系统根据在给定方向上找到最近邻的算法自动确定焦点顺序。
- en: 'However, sometimes the results may not be quite what you had in mind, or they
    may not provide the best experience for the user. If this is the case, Android
    provides four optional XML attributes that you can use to override this automatic
    focus order and dictate *exactly* which view will receive focus when the user
    navigates in that direction:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时结果可能并不完全符合您的预期，或者它们可能无法为用户提供最佳体验。如果是这种情况，Android 提供了四个可选的 XML 属性，您可以使用这些属性来覆盖此自动焦点顺序，并确切指定当用户向该方向导航时哪个视图将接收焦点：
- en: '`android:nextFocusUp`: Defines the next view to receive focus when the user
    navigates up'
  id: totrans-320
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusUp`：定义当用户向上导航时将接收焦点的下一个视图'
- en: '`android:nextFocusDown`: Defines the next view to receive focus when the user
    navigates down'
  id: totrans-321
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusDown`：定义当用户向下导航时将接收焦点的下一个视图'
- en: '`android:nextFocusLeft`: Defines the next view to receive focus when the user
    navigates left'
  id: totrans-322
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusLeft`：定义当用户向左导航时将接收焦点的下一个视图'
- en: '`android:nextFocusRight`: Defines the next view to receive focus when the user
    navigates right'
  id: totrans-323
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android:nextFocusRight`：定义当用户向右导航时将接收焦点的下一个视图'
- en: 'The following example XML shows two focusable UI elements where the `android:nextFocusDown`
    and `android:nextFocusUp` attributes have been set explicitly. The `Button` is
    located to the right of the `TextView`, however thanks to the magic of `nextFocus`
    properties, the user can reach the `Button` element by pressing the down arrow
    when the focus is on `TextView`:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例 XML 展示了两个可聚焦的 UI 元素，其中已显式设置了 `android:nextFocusDown` 和 `android:nextFocusUp`
    属性。`Button` 元素位于 `TextView` 的右侧，然而，多亏了 `nextFocus` 属性的魔力，当焦点在 `TextView` 上时，用户可以通过按向下箭头键来访问
    `Button` 元素：
- en: '[PRE26]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The easiest way to test your navigation is to run your app in the emulator and
    navigate around your UI using the emulator's arrow keys and **OK** button only.
    Check that the navigation works as expected in all directions, including when
    you're navigating in reverse.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您导航的最简单方法是在模拟器中运行您的应用，并使用模拟器的箭头键和 **OK** 按钮仅进行导航。检查导航是否在所有方向上按预期工作，包括在反向导航时。
- en: Note
  id: totrans-327
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can also modify the focus order of UI components at runtime, using methods
    such as `setNextFocusDownId()` and `setNextFocusRightId().`
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以在运行时修改 UI 组件的焦点顺序，使用例如 `setNextFocusDownId()` 和 `setNextFocusRightId()`
    等方法。
- en: Custom view controls
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义视图控件
- en: If you build custom interface controls, make sure you implement accessibility
    interfaces for these custom views and provide content descriptions.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您构建自定义界面控件，请确保您为这些自定义视图实现了可访问性接口，并提供了内容描述。
- en: Note
  id: totrans-331
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want your custom controls to be compatible with all versions of Android
    back to 1.6, you'll need to use the Support Library to implement the latest accessibility
    features.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望您的自定义控件与所有版本的 Android（回溯到 1.6）兼容，您需要使用 Support Library 来实现最新的可访问性功能。
- en: When creating custom views, you need to make sure these views are successfully
    creating `AccessibilityEvents` whenever the user selects an item or changes focus,
    as accessibility events are an important part of providing accessibility features
    such as text-to-speech.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义视图时，您需要确保这些视图在用户选择项目或更改焦点时成功创建 `AccessibilityEvents`，因为可访问性事件是提供如文本到语音等可访问性功能的重要部分。
- en: To generate `AccessibilityEvents`, call `sendAccessibilityEvent(int)` with a
    parameter representing the type of event that's occurred. You'll find a complete
    list of the event types Android currently supports in the `AccessibilityEvent`
    reference documentation ([http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html](http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html)).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要生成 `AccessibilityEvents`，请调用 `sendAccessibilityEvent(int)` 并使用表示已发生事件类型的参数。您可以在
    `AccessibilityEvent` 参考文档中找到 Android 当前支持的事件类型的完整列表（[http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html](http://developer.android.com/reference/android/view/accessibility/AccessibilityEvent.html)）。
- en: Providing alternatives to audio prompts
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提供音频提示的替代方案
- en: To assist users who are hearing impaired, you should avoid including any audio-only
    feedback in your app. You should always accompany your app's audio feedback with
    a secondary feedback mechanism, such as closed captions, a transcript, on screen
    notifications, or another visual alternative.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助听力受损的用户，您应该避免在您的应用中包含任何仅音频的反馈。您应该始终使用辅助反馈机制，例如字幕、文本记录、屏幕通知或另一种视觉替代方案来伴随您应用中的音频反馈。
- en: Testing various font sizes
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试各种字体大小
- en: Android users can change the size of the font that appears across their device
    manually, from their device's **Settings |** **Accessibility** screen. To make
    sure these size changes also affect the text within your app, define your app's
    text and associated containers in scaled pixels (`sp`).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓用户可以手动更改其设备上显示的字体大小，从设备的**设置 | 可访问性**屏幕中进行。为了确保这些大小更改也会影响您应用内的文本，请使用缩放像素（`sp`）定义您应用中的文本和相关容器。
- en: Also, keep in mind that when users have large fonts enabled, your app's text
    may become larger than the space you originally allocated for it, so you'll need
    to check that your text and UI looks good and functions normally even when the
    user has large text enabled. In particular, make sure that your UI elements don't
    overlap and that all touchable elements remain reachable across various text sizes.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，当用户启用大字体时，您应用中的文本可能比您最初分配的空间要大，因此您需要检查在用户启用大文本时，您的文本和UI看起来良好且功能正常。特别是，请确保您的UI元素不会重叠，并且所有可触摸元素在各个文本大小下都保持可触及。
- en: Using recommended touch target sizes
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用推荐的触摸目标大小
- en: Make sure all your app's touch targets are at least 48 x 48dp, and ensure that
    the space between on screen elements is always at least 8dp. This helps to ensure
    your UI is easier to navigate for people with manual dexterity challenges, but
    also for children with developing motor skills.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您应用的所有触摸目标至少为48 x 48dp，并确保屏幕元素之间的空间始终至少为8dp。这有助于确保您的UI对有手动灵活性挑战的人以及正在发展运动技能的儿童来说更容易导航。
- en: Providing alternatives to affordances that time out
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供对超时辅助功能的替代方案
- en: Some apps feature icons or controls that disappear after a certain amount of
    time, for example it's common for video playback controls to fade out once the
    user is a few seconds into the video.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用具有在一段时间后消失的图标或控件，例如，视频播放控件在用户观看视频几秒钟后通常会淡出。
- en: This poses a problem for people who are using accessibility features such as
    TalkBack, as TalkBack waits until the user has focused on a control before it
    reads that control's description. If your UI has controls that fade out quickly,
    these controls may actually vanish before the user has a chance to focus on them—which
    means they never get read out, and therefore the user won't be aware of their
    existence.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这对使用如TalkBack等可访问性功能的人构成了问题，因为TalkBack会在读取控件描述之前等待用户将焦点放在控件上。如果您的UI有快速淡出的控件，这些控件实际上可能在用户有机会聚焦之前就消失了——这意味着它们永远不会被读出，因此用户不会意识到它们的存在。
- en: For this reason, you shouldn't rely on timed-out controls for high-priority
    tasks or important functions. If your UI does feature timed-out controls, you
    may want to disable this functionality when accessibility services are enabled,
    so these timed-out controls no longer disappear.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您不应依赖于超时控件来完成高优先级任务或重要功能。如果您的UI确实具有超时控件，您可能希望在可访问性服务启用时禁用此功能，这样这些超时控件就不会消失。
- en: To ensure users with visual impairments can read your text more easily, it's
    recommended that you use a contrast ratio of 4.5:1 between your app's background
    and text. As a general rule, the smaller your text, the more contrast you'll need
    to use.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保有视觉障碍的用户可以更容易地阅读您的文本，建议您在应用背景和文本之间使用4.5:1的对比度比。一般来说，文本越小，您需要使用的对比度就越大。
- en: Also bear in mind that some of your users may be colorblind, so you shouldn't
    use color signals as the only means of conveying important information. In addition
    to color, you can use elements such as patterns, shapes, size, textures, or text.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，您的某些用户可能患有色盲，因此您不应仅使用颜色信号作为传达重要信息的唯一手段。除了颜色之外，您还可以使用图案、形状、大小、纹理或文本等元素。
- en: Testing your application's accessibility features
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试您应用的可访问性功能
- en: Testing is a crucial part of creating an accessible app, as it can uncover problems
    with user interaction that you might not otherwise have spotted.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是创建可访问应用的关键部分，因为它可以揭示您可能没有注意到的用户交互问题。
- en: 'Testing your app''s accessibility features typically involves:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 测试您的应用的可访问性功能通常涉及：
- en: 'Using your app with audible feedback enabled:'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用启用了声音反馈的应用：
- en: Audible accessibility services provide audio prompts that dictate the on screen
    content to your users as they move around your UI. The most effective way of testing
    the experience you're providing to users with visual impairments is to enable
    an audible accessibility service on your Android device and then interact with
    your app using sound alone.
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可听可访问性服务提供音频提示，将屏幕内容读给用户听，当他们移动到您的UI上时。测试您为视障用户提供体验的最有效方式是在您的Android设备上启用可听可访问性服务，然后仅使用声音与您的应用进行交互。
- en: For Android users, feedback is typically provided via the TalkBack accessibility
    service. TalkBack comes preinstalled on many Android devices (open your device's
    **Settings** and select **Accessibility**, followed by **TalkBack**) but you can
    also download TalkBack for free from Google Play.
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于Android用户，反馈通常通过TalkBack可访问性服务提供。TalkBack预安装在许多Android设备上（打开您的设备的**设置**并选择**辅助功能**，然后选择**TalkBack**），但您也可以从Google
    Play免费下载TalkBack。
- en: Once you've enabled an audible accessibility service, spend some time navigating
    around your app using the spoken feedback only. Look for any opportunities to
    improve the experience for users who might be interacting with your app without
    sighted assistance.
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦您启用了可听可访问性服务，花些时间仅使用语音反馈在您的应用中导航。寻找任何可以改善可能在没有视觉辅助的情况下与您的应用交互的用户体验的机会。
- en: You should also check that your app provides enough information for the user
    to understand and act on each on screen element using a service such as TalkBack,
    *without* overloading them with too much information. This can be a tricky balancing
    act—too much or too little information will make it equally difficult for the
    user to decipher your UI.
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您还应该检查您的应用是否提供了足够的信息，以便用户可以使用TalkBack等服务理解并采取行动，而不会因信息过多而感到负担。这可能会是一个棘手的平衡行为——过多或过少的信息都会使用户难以理解您的UI。
- en: Navigating your app using directional controls only, instead of the touchscreen
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用方向控制导航您的应用，而不是触摸屏
- en: As part of accessibility testing, you should verify that your app is easy to
    navigate using directional controls only, meaning without using the touchscreen,
    and ensure that users can move focus between your app's UI elements in a way that
    makes sense.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 作为可访问性测试的一部分，您应该验证您的应用仅使用方向控制即可轻松导航，这意味着不使用触摸屏，并确保用户可以在您的应用UI元素之间以有意义的方式移动焦点。
- en: If available, you can use a physical device with a D-pad or trackball, but if
    your device doesn't have these hardware features you can use a software-based
    directional controller instead, or use the Android emulator and its simulated
    keyboard controls. You may even want to use TalkBack gestures ([https://support.google.com/accessibility/android/answer/6151827](https://support.google.com/accessibility/android/answer/6151827)),
    which allow users to navigate apps (and their device in general) using very specific
    gestures.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 如果可用，您可以使用带有D-pad或轨迹球的物理设备，但如果您的设备没有这些硬件功能，您可以使用基于软件的方向控制器，或者使用Android模拟器和其模拟键盘控制。您甚至可能想使用TalkBack手势（[https://support.google.com/accessibility/android/answer/6151827](https://support.google.com/accessibility/android/answer/6151827)），这允许用户使用非常具体的手势来导航应用（以及他们的设备）。
- en: Summary
  id: totrans-359
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this final chapter, we covered some best practices that I hadn't explored
    in detail in previous chapters, including app security and accessibility best
    practices. You also learned how to create more useful notifications, and began
    to explore the new notification options coming up in Android N.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们介绍了一些在前面章节中没有详细探讨的最佳实践，包括应用安全和可访问性最佳实践。您还学习了如何创建更有用的通知，并开始探索Android
    N中即将推出的新通知选项。
- en: If you want to learn more about developing effective Android apps, you'll find
    lots of additional information in the Android docs ([http://developer.android.com/training/index.html](http://developer.android.com/training/index.html)),
    at the Android blog ([http://android-developers.blogspot.co.uk/](http://android-developers.blogspot.co.uk/)),
    or by checking out some of Google's code samples ([http://developer.android.com/samples/index.html](http://developer.android.com/samples/index.html)).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于开发有效的Android应用的信息，你可以在Android文档中找到大量额外的信息（[http://developer.android.com/training/index.html](http://developer.android.com/training/index.html)），在Android博客上（[http://android-developers.blogspot.co.uk/](http://android-developers.blogspot.co.uk/)），或者通过查看一些Google的代码示例（[http://developer.android.com/samples/index.html](http://developer.android.com/samples/index.html)）。
