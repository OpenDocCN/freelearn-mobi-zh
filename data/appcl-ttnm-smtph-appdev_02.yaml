- en: Chapter 2. Working with Local and Remote Data Sources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：使用本地和远程数据源
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Reading data from remote XML through HTTPClient
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过 HTTPClient 从远程 XML 读取数据
- en: Displaying data using a TableView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 TableView 显示数据
- en: Enhancing your TableView with custom rows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自定义行增强 TableView
- en: Filtering your TableView with the SearchBar control
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SearchBar 控件过滤 TableView
- en: Speeding up your remote data access using JSON and Yahoo! YQL
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 JSON 和 Yahoo! YQL 加速远程数据访问
- en: Creating an SQLite database
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SQLite 数据库
- en: Saving data locally using an SQLite database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 SQLite 数据库本地保存数据
- en: Retrieving data from an SQLite database
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从 SQLite 数据库检索数据
- en: Creating a "pull and release" refresh mechanism
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建“拉动和释放”刷新机制
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Fully understanding the methods available to you in Titanium Studio when it
    comes to reading, parsing, and saving data, is fundamental to the success of the
    apps you will build. Titanium provides you with all of the tools that you will
    need to make everything from simple XML calls over HTTP, implementing JSON for
    improved network speeds, to complex applications running a localized relational
    database (SQLite) for offline storage requirements.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 完全理解您在 Titanium Studio 中可用于读取、解析和保存数据的方法，对于您将构建的应用的成功至关重要。钛金属为您提供所有您需要的工具，从简单的通过
    HTTP 的 XML 调用，到实现 JSON 以提高网络速度，再到运行本地化关系数据库（SQLite）以满足离线存储需求的应用程序。
- en: In this chapter we will not only cover the fundamental methods of implementing
    remote data access over HTTP, but also how to store and present that data effectively
    using TableViews, TableRows, and other customized user interfaces.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不仅将涵盖通过 HTTP 实现远程数据访问的基本方法，还将介绍如何使用 TableViews、TableRows 和其他自定义用户界面有效地存储和展示数据。
- en: Pre-requisites
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前提条件
- en: You should have a basic understanding of both the XML and JSON data formats,
    which are widely-used standardized methods of transporting data across the Web.
    Additionally, you should also understand what **SQL** (**Structured Query Language**)
    is and how to create basic SQL statements such as CREATE, SELECT, DELETE, and
    INSERT. There is a great beginners introduction to SQL at [http://sqlzoo.net](http://sqlzoo.net)
    if you need to refer to tutorials on how to perform common types of database queries.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该对 XML 和 JSON 数据格式有基本的了解，这些是广泛使用的标准方法，用于在网络上传输数据。此外，您还应该了解 **SQL**（**结构化查询语言**）是什么以及如何创建基本的
    SQL 语句，如 CREATE、SELECT、DELETE 和 INSERT。如果您需要参考有关如何执行常见类型数据库查询的教程，[http://sqlzoo.net](http://sqlzoo.net)
    提供了一个很好的 SQL 初学者介绍。
- en: Reading data from remote XML through HTTPClient
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过 HTTPClient 从远程 XML 读取数据
- en: The ability to consume and display feed data from the Internet, through RSS
    feeds or alternate APIs, is the cornerstone of many mobile applications. More
    importantly, many services that you may wish to integrate into your app will probably
    require you to do this at some point or another, such as Twitter or Wikipedia,
    so it is vital to understand and be able to implement remote data feeds and XML.
    Our first recipe for this chapter introduces some new functionality within Titanium
    to help address this need.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 能够通过 RSS 源或替代 API 从互联网消费和显示数据，这是许多移动应用的基础。更重要的是，您可能希望集成到您的应用中的许多服务可能需要您在某个时候这样做，例如
    Twitter 或 Wikipedia，因此理解和能够实现远程数据馈送和 XML 是至关重要的。本章的第一个食谱介绍了钛金属中的一些新功能，以帮助解决这一需求。
- en: If you are intending to follow the entire chapter and build the MyRecipes app,
    then pay careful attention to the first *Getting Ready* section for this recipe,
    as it will guide you through setting up the project.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您打算跟随整个章节并构建 MyRecipes 应用，那么请仔细注意此食谱的第一个 *准备工作* 部分，因为它将指导您设置项目。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare for this recipe, open up Titanium Studio and log in if you have not
    already done so. If you need to register a new account, you can do so for free
    directly from within the application. Once you are logged in, click on **New Project**,
    and the details window for creating a new project will appear. Enter **MyRecipes**
    as the name of the app, and fill in the rest of the details with your own information.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 准备此食谱，请打开 Titanium Studio 并登录，如果您尚未登录的话。如果您需要注册新账户，您可以直接在应用程序内免费注册。登录后，点击**新建项目**，创建新项目的详细信息窗口将出现。将应用程序名称输入为**MyRecipes**，并使用您自己的信息填写其余的详细信息。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pay attention to the app identifier, which is written normally in reverse domain
    notation (that is `com.packtpub.myrecipes`). This identifier cannot be easily
    changed after the project is created and you will need to match it *exactly* when
    creating provisioning profiles for distributing your apps later on.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意应用程序标识符，它通常以反向域名表示法正常书写（即 `com.packtpub.myrecipes`）。在项目创建后，此标识符不能轻易更改，并且在创建用于分发应用的配置文件时，您需要**精确地**匹配它。
- en: Complete source code for this entire chapter can be found in the `/Chapter 2/RecipeFinder`
    folder, while source code for this recipe can be found in the `/Chapter 2/Recipe
    1` folder.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 整个章节的完整源代码可以在 `/Chapter 2/RecipeFinder` 文件夹中找到，而本食谱的源代码可以在 `/Chapter 2/Recipe
    1` 文件夹中找到。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Now our project shell is set up, so let's get down to business! First, open
    your `app.js` file, and two more JavaScript files called `recipes.js` and `favorites.js`.
    In your `app.js`, reference `recipes.js` and `favorites.js` to `win1` and `win2`
    respectively, and give each window a meaningful title (for example, "Recipes").
    We'll also change the tab icons from their defaults to the two icons 'fork-and-knife.png'
    and 'heart.png' respectively. Both of these icons are available in the accompanying
    source files.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的项目外壳已经设置好了，让我们开始工作吧！首先，打开您的 `app.js` 文件，以及另外两个名为 `recipes.js` 和 `favorites.js`
    的 JavaScript 文件。在您的 `app.js` 中，将 `recipes.js` 和 `favorites.js` 分别引用到 `win1` 和
    `win2`，并为每个窗口提供一个有意义的标题（例如，“食谱”）。我们还将更改标签图标从默认图标更改为两个图标 'fork-and-knife.png' 和
    'heart.png'。这两个图标都包含在配套的源文件中。
- en: Open the `recipes.js` file in your IDE. This is the file that will hold our
    code for retrieving and displaying recipes from a RSS feed. Type in the following
    code at the top of your `recipes.js` file. This code will create an `HTTPClient`
    and read in the feed XML from the recipes website.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的 IDE 中打开 `recipes.js` 文件。这是将包含我们从 RSS 提供程序检索和显示食谱的代码的文件。在您的 `recipes.js`
    文件顶部输入以下代码。此代码将创建一个 `HTTPClient` 并从食谱网站读取提供程序的 XML。
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Try running the emulator now for either Android or iPhone. You should have two
    tabs appear on the screen as shown next, and, after a few seconds, a stack of
    XML data printed out to your Titanium Studio console log.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在尝试运行 Android 或 iPhone 的模拟器。屏幕上应该出现两个标签页，如图所示，几秒钟后，在 Titanium Studio 的控制台日志中打印出一堆
    XML 数据。
- en: '![How to do it...](img/3968EXP_02_01.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![如何做到...](img/3968EXP_02_01.jpg)'
- en: How it works…
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you are already familiar with JavaScript for the web, this should make a
    lot of sense to you. Here we are creating an `HTTPClient` using the `Titanium.Network`
    namespace, and opening a `GET` connection on the URL of the feed from the recipes
    website, using an object called `xhr`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经熟悉网络上的 JavaScript，这应该对您来说很有意义。在这里，我们使用 `Titanium.Network` 命名空间创建了一个 `HTTPClient`，并在食谱网站的
    URL 上通过一个名为 `xhr` 的对象打开一个 `GET` 连接。
- en: By implementing the `onload` event listener, we can capture the XML data that
    has been retrieved by the `xhr` object. In the source code you will note that
    we have used `Ti.API.info()` to echo information to the Titanium Studio screen,
    which is a great way to debug and follow events in your app. If your connection
    and `GET` request was successful, you should see a large XML string outputted
    in the Titanium Studio info log. The final piece of the recipe is small but very
    important—calling the `xhr` object's `send()` method. This kicks off the `GET`
    request. Without it, your app would never load any data. It is important to note
    that you will not receive any errors or warnings if you forget to implement `xhr.send()`.
    If your app is not receiving any data, this is the first place to check.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 通过实现 `onload` 事件监听器，我们可以捕获 `xhr` 对象检索到的 XML 数据。在源代码中您会注意到我们使用了 `Ti.API.info()`
    将信息回显到 Titanium Studio 屏幕，这是一种调试和跟踪应用事件的好方法。如果您的连接和 `GET` 请求成功，您应该在 Titanium Studio
    的信息日志中看到一个大的 XML 字符串输出。食谱的最后一部分虽然很小但非常重要——调用 `xhr` 对象的 `send()` 方法。这将启动 `GET`
    请求。如果没有它，您的应用将永远不会加载数据。需要注意的是，如果您忘记实现 `xhr.send()`，您将不会收到任何错误或警告。如果您的应用没有收到任何数据，这是您首先需要检查的地方。
- en: Note
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意事项
- en: If you are having trouble parsing your XML, always check if it is valid first!
    Opening up the XML feed in your browser will normally provide you with enough
    information to determine whether your feed is valid, or if it has broken elements.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在解析 XML 时遇到困难，请始终首先检查它是否有效！在浏览器中打开 XML 提供程序通常会为您提供足够的信息来判断您的提供程序是否有效，或者它是否有损坏的元素。
- en: Displaying data using a TableView
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 TableView 显示数据
- en: TableViews are the most used components in the entire iPhone and Android SDKs,
    almost all of the native apps on your device will utilize tables in some shape
    or form. They are used to display large lists of data in an effective manner,
    allowing for scrolling lists that can be customized visually, searched upon, or
    drilled to expose child views. With so many available properties and options,
    it's easy to get lost in the functionality and ability of these components. Luckily
    for us, Titanium makes it easy to implement TableViews into your application.
    In this recipe, we will implement a TableView and use our XML data feed from the
    previous recipe to populate it with a list of recipes.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: TableView是整个iPhone和Android SDK中最常用的组件，你设备上的几乎所有原生应用程序都会以某种形式使用表格。它们用于以有效的方式显示大量数据，允许自定义滚动列表，可以进行搜索，或者深入查看以暴露子视图。由于有这么多可用的属性和选项，很容易迷失在这些组件的功能和能力中。幸运的是，Titanium使得将TableView实现到应用程序中变得容易。在本食谱中，我们将实现一个TableView，并使用之前食谱中的XML数据源来填充它，显示食谱列表。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    2` folder.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 2/Recipe 2`文件夹中找到。
- en: How to do it...
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Once we have connected our app to a data feed and we''re retrieving XML data
    via the XHR object, we need to be able to manipulate that data and display it
    into a TableView component. Firstly, create an array object called `data` at the
    top of your `recipes.js` file. This array will hold all of the information for
    our TableView in a global context:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将我们的应用程序连接到数据源，并通过XHR对象检索XML数据，我们就需要能够操作这些数据并将其显示到TableView组件中。首先，在`recipes.js`文件的顶部创建一个名为`data`的数组对象。这个数组将在全局范围内存储我们TableView的所有信息：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We are now going to disseminate the XML and read in the required elements to
    our `data` array object, before finally creating a TableView and assigning its
    `data` property to our `data object:`
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将在创建TableView并将其`data`属性分配给我们的数据对象之前，将XML数据分发并读取所需元素到我们的`data`数组对象中：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The following screenshot shows the Table view with the titles of our recipes
    from the XML feed:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了包含我们从XML源中获取的食谱标题的表视图：
- en: '![How to do it...](img/3968EXP_02_02.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/3968EXP_02_02.jpg)'
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first thing you will notice is that we are using the `Ti.XML` namespace
    to assign the list of elements to a new object called `items`. This allows us
    to use a `for` loop construct in order to loop through the items and assign each
    individual item to the `data` array object we created and gave a global scope.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你首先会注意到，我们正在使用`Ti.XML`命名空间将元素列表分配给一个名为`items`的新对象。这允许我们使用`for`循环结构来遍历项目，并将每个单独的项目分配给我们创建并赋予全局作用域的`data`数组对象。
- en: From there we are creating our TableView by implementing the `Titanium.UI.createTableView()`
    function. You should notice almost immediately that many of our regular properties
    are also used by tables, including width, height, and positioning. However, a
    TableView has one extra and important property data. The data property accepts
    an array of data, the values of which can either be used dynamically (as we have
    done here with the title property) or can be assigned to sub-component children
    of a TableRow. As you begin to build more complex applications you will learn
    to fully understand just how flexible table-based layouts can be.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里，我们通过实现`Titanium.UI.createTableView()`函数来创建TableView。你应该会立即注意到，我们的一些常规属性也被表格使用，包括宽度、高度和定位。然而，TableView有一个额外且重要的属性：数据属性。数据属性接受一个数据数组，其值可以是动态的（就像我们在这里使用标题属性那样），也可以分配给TableRow的子组件。随着你开始构建更复杂的应用程序，你将学会完全理解基于表格的布局有多么灵活。
- en: Enhancing your TableViews with custom rows
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过自定义行增强TableView
- en: So far we have created a TableView, which while being totally usable and showing
    the names of our recipes from the XML feed, is a bit bland. To customize our table
    we will need to create and add custom TableRow objects to an array of rows, which
    we can then assign to our TableView object. Each of these TableRow objects is
    essentially a type of View, to which we can add any number of components, such
    as Labels, ImageViews, and Buttons.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个TableView，虽然它完全可用并且显示了XML源中的食谱名称，但看起来有点单调。为了自定义我们的表格，我们需要创建并添加自定义TableRow对象到行数组中，然后我们可以将这些行分配给TableView对象。这些TableRow对象本质上是一种View类型，我们可以向其中添加任何数量的组件，例如标签、ImageView和按钮。
- en: Next, we will create our TableRow objects and add to each one of them the name
    of the recipe from our XML feed, a short description, and a thumbnail image (which
    we will get from the `images` folder in our `Resources` directory) to each one
    of them. If you do not already have an images directory, create one now and copy
    the images from the source code for this recipe, which can be found in the `/Chapter
    2/Recipe 3` folder.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的TableRow对象，并将我们从XML源中获取的食谱名称、简短描述和缩略图（我们将从“Resources”目录下的“images”文件夹中获取）添加到每个对象中。如果您还没有图像目录，请现在创建一个，并将此食谱的源代码中的图像复制到其中，这些源代码可以在“/Chapter
    2/Recipe 3”文件夹中找到。
- en: How to do it...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Open your `recipe.js` file and type in the following code. If you have been
    following along with the previous recipe, then the following code will extend
    what you have already written:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的`recipe.js`文件，并输入以下代码。如果您一直在跟随前面的食谱，那么以下代码将扩展您已经编写的代码：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: How it works...
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: One thing that should be immediately obvious is that a **TableRow** object can
    contain any number of components which you can define and add in the standard
    way (see [Chapter 1](ch01.html "Chapter 1. Building Apps using Native UI Components"),
    *Building Apps Using Native UI Components*, for examples of implementing different
    UI components).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 应该立即明显的一点是，一个**TableRow**对象可以包含任何数量的组件，您可以通过标准方式定义并添加（例如，请参阅[第1章](ch01.html
    "第1章. 使用原生UI组件构建应用")，*使用原生UI组件构建应用*，了解实现不同UI组件的示例）。
- en: What is the `className` property used for then? When rows are rendered on your
    device it all happens on request, that is, only those rows which are visible are
    actually rendered by the OS, which can be seen in the following screenshots. The
    reasons for this are two-fold. First, to conserve memory, of which most devices
    have precious little in comparison to desktop computers. Second, to help speed
    up your application by only performing those CPU tasks which are absolutely necessary.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 那么`className`属性是用来做什么的呢？当行在您的设备上渲染时，这一切都是在请求时发生的，也就是说，只有那些可见的行实际上是由操作系统渲染的，这可以在以下屏幕截图中看到。原因有两个。首先，为了节省内存，与桌面计算机相比，大多数设备都很少。其次，为了通过仅执行绝对必要的CPU任务来加快您的应用程序的速度。
- en: For a few rows, the memory usage without using a `className` will not be too
    high, but for many rows, depending on how many and what interface components you
    are using within the row, your app will load very slowly or may even crash.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几行，不使用`className`的内存使用量不会太高，但对于许多行，这取决于您在行中使用了多少和什么界面组件，您的应用程序可能会加载得很慢，甚至可能崩溃。
- en: '![How it works...](img/3968EXP_02_03.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/3968EXP_02_03.jpg)'
- en: Filtering the TableView using a SearchBar component
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SearchBar组件过滤TableView
- en: So what happens when your user wants to search all data in your TableView? By
    far the easiest way is to use the **SearchBar** component. This is a standard
    control that consists of a searchable text field with an optional cancel button,
    and attaches to the top of your table view using the table view's `searchBar`
    property.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当您的用户想要在TableView中搜索所有数据时会发生什么？到目前为止，最简单的方法是使用**SearchBar**组件。这是一个标准控件，由一个可搜索的文本字段和一个可选的取消按钮组成，并使用表格视图的`searchBar`属性将其附加到表格视图的顶部。
- en: In this next recipe, we will implement a search bar into our **MyRecipes** app
    that filters our recipes based on the `title` property.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将实现一个搜索栏到我们的**MyRecipes**应用程序中，根据`title`属性过滤我们的食谱。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    4` folder.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此食谱的完整源代码可以在“/Chapter 2/Recipe 4”文件夹中找到。
- en: How to do it...
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: First of all, create a `searchBar` component before your `tableView` is defined,
    and then create the event listener's for the `searchBar`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在定义`tableView`之前创建一个`searchBar`组件，然后创建事件监听器。
- en: '[PRE4]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now set the search property of our tableView to our searchBar component, and
    then set the `filterAttribute` of our tableView to`'filter'`. We will define this
    custom property called`'filter'` within each of our row objects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将我们的tableView的搜索属性设置为我们的searchBar组件，然后将我们的tableView的`filterAttribute`设置为`'filter'`。我们将在每个行对象中定义这个名为`'filter'`的自定义属性。
- en: '[PRE5]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, inside each row that you define when looping through our xml data, add
    a custom property called`''filter''` and set it''s value to the title text from
    the XML feed:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在遍历我们的xml数据时定义的每一行中，添加一个名为`'filter'`的自定义属性，并将其值设置为XML源中的标题文本：
- en: '[PRE6]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's it! Run your project and you should now have a search bar attached to
    your table view as shown in the following screenshot. Tap it and type in any part
    of a recipe's title to see the results filtered in your table.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！运行你的项目，你现在应该已经在你的TableView上附加了一个搜索栏，如图所示。点击它并输入菜谱标题的任何部分，你将看到在表格中过滤出的结果。
- en: '![How to do it...](img/3968EXP_02_04.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_02_04.jpg)'
- en: How it works...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the first block of code, we are simply defining our **SearchBar** object
    like any other UI component, before attaching it to the `searchBar` property of
    our TableView in the second block of code. The event listeners for the `searchBar`
    simply ensure that when the user taps either one of the '**Search**' or '**Cancel**'
    buttons, the focus on the text input is lost and the keyboard will therefore become
    hidden.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一块代码中，我们只是像定义任何其他UI组件一样定义我们的**SearchBar**对象，然后在第二块代码中将它附加到TableView的`searchBar`属性上。`searchBar`的事件监听器确保当用户点击“**搜索**”或“**取消**”按钮时，文本输入的焦点会丢失，因此键盘将会隐藏。
- en: The final block of code defines just what data we are searching for, in this
    case, our `filter` property has been set to the title of the recipes. This property
    needs to be added to each row that we define before it is bound to our TableView.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一块代码定义了我们正在搜索的数据，在这种情况下，我们的`filter`属性已经被设置为菜谱的标题。这个属性需要在绑定到TableView之前添加到我们定义的每一行。
- en: Speeding up your remote data access using JSON and Yahoo! YQL
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用JSON和Yahoo! YQL加速远程数据访问
- en: If you are already familiar with using JavaScript heavily for the web, particularly
    when using popular libraries such as jQuery or Prototype, then you may already
    be aware of the benefits of using JSON instead of XML. The JSON data format is
    much less verbose than XML, meaning the file size is smaller and data transfer
    much faster. This is particularly important when a user on a mobile device may
    be limited in data speed due to network access and bandwidth.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经熟悉在网络上大量使用JavaScript，尤其是使用像jQuery或Prototype这样的流行库，那么你可能已经知道使用JSON而不是XML的好处。JSON数据格式比XML简洁得多，这意味着文件大小更小，数据传输更快。这在用户可能因为网络访问和带宽限制而在移动设备上数据速度有限的情况下尤为重要。
- en: If you have never seen Yahoo's YQL console, or heard of the YQL language web
    service, it is essentially a free web service that allows developers and applications
    to query, filter, and combine separate data sources from across the Internet.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从未见过Yahoo的YQL控制台，或者听说过YQL语言Web服务，它本质上是一个免费的Web服务，允许开发者和应用程序查询、过滤和组合来自互联网的多个数据源。
- en: In this recipe, we are going to use the Yahoo! YQL console and web service to
    obtain data from our recipes data feed and transform that data into a JSON object,
    which we will then bind to our TableView.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用Yahoo! YQL控制台和Web服务从我们的菜谱数据源中获取数据，并将这些数据转换成一个JSON对象，然后我们将把这个对象绑定到我们的TableView上。
- en: Note
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    5` folder.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 2/Recipe 5`文件夹中找到。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: First of all, go to Yahoo's YQL console page by opening up [http://developer.yahoo.com/yql/console](http://developer.yahoo.com/yql/console)
    in your browser. On the right-hand side of the browser window you should notice
    a section called '**Data Tables**'. Select '**data**' and then '**feed**' from
    the data tables list. Your SQL statement should automatically change to a simple
    data feed from the Yahoo! News Network. Now, replace the URL value in the YQL
    statement to our recipe's feed, which is [http://www.cuisine.com.au/feed/all-recipes](http://www.cuisine.com.au/feed/all-recipes),
    select '**JSON**' instead of **XML** from the radio buttons below, and click on
    '**Test**' as shown in the following screenshot. You should see a formatted set
    of data return in the results window in JSON format!
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，通过在浏览器中打开[http://developer.yahoo.com/yql/console](http://developer.yahoo.com/yql/console)来访问Yahoo的YQL控制台页面。在浏览器窗口的右侧，你应该注意到一个名为“**数据表**”的部分。从数据表列表中选择“**data**”，然后选择“**feed**”。你的SQL语句应该自动更改为来自Yahoo!新闻网络的简单数据源。现在，将YQL语句中的URL值替换为我们的菜谱源，即[http://www.cuisine.com.au/feed/all-recipes](http://www.cuisine.com.au/feed/all-recipes)，从单选按钮中选择“**JSON**”而不是**XML**，然后点击“**测试**”，如图所示。你应该在结果窗口中看到一组格式化的数据以JSON格式返回！
- en: '![How to do it...](img/3968EXP_02_05.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作...](img/3968EXP_02_05.jpg)'
- en: To use this data we need to copy and paste the full REST query from the YQL
    console. This is right at the bottom of the browser and is a single-line textbox.
    Copy and paste the entire URL into your `xhr.open()` method, replacing the existing
    recipes feed URL.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用这些数据，我们需要从YQL控制台复制并粘贴完整的REST查询。这位于浏览器的底部，是一个单行文本框。将整个URL复制并粘贴到您的`xhr.open()`方法中，替换现有的菜谱源URL。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Make sure when you paste the string in, it hasn't broken due to any apostrophes.
    If it has, you will need to escape any apostrophe characters by replacing**'**
    with **\'**. You may also want to remove the`&callback=cbfunc` parameter from
    the URL as it can sometimes cause the JSON to stop parsing.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在粘贴字符串时，它没有被任何引号打断。如果被打断，您需要通过将**'**替换为**\'**来转义任何引号字符。您可能还想从URL中移除`&callback=cbfunc`参数，因为它有时会导致JSON停止解析。
- en: 'Now, back in the `xhr.onload()` function, let''s replace all of the XML parsing
    code with code to parse our data in JSON format instead:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，回到`xhr.onload()`函数中，让我们用解析JSON格式的代码替换所有的XML解析代码：
- en: '[PRE7]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works...
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see in this recipe, accessing the YQL web service is simply a matter
    of passing an HTTP GET query to the YQL service URL, using a YQL statement as
    a URL parameter. When it processes a query, the Yahoo! YQL service obtains and
    transforms the requested data and returns in your specified format (in our case,
    JSON).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在这道菜谱中看到的那样，访问YQL网络服务只是将一个HTTP GET查询传递给YQL服务URL，使用YQL语句作为URL参数。当它处理查询时，Yahoo!
    YQL服务获取并转换请求的数据，并以您指定的格式返回（在我们的例子中，是JSON）。
- en: Accessing the properties of the JSON data object is also different, and arguably
    much simpler, as compared to XML. In JSON we use simple dot notation to navigate
    the data tree hierarchy and select the property we want to use. If you already
    understand the array syntax in PHP, Javascript, and a number of other C-Style
    languages, this should be pretty familiar to you!
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与XML相比，访问JSON数据对象的属性也有所不同，并且可以说是更简单，因为XML更复杂。在JSON中，我们使用简单的点符号来导航数据树层次结构并选择我们想要使用的属性。如果您已经理解了PHP、JavaScript和其他一些C风格语言中的数组语法，这应该对您来说相当熟悉！
- en: There's more...
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: Throughout this chapter we have only been using a single RSS feed source, but
    what if you have multiple RSS feeds that you wish to read in simultaneously?
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们只使用了一个RSS源，但如果你有多个RSS源希望同时阅读，会怎样呢？
- en: Combining multiple RSS feeds…
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 结合多个RSS源…
- en: The answer to the previous question is to use Yahoo! Pipes—a free service provided
    by Yahoo! that let's you create a "pipe" consisting of one or more RSS, JSON,
    or data feeds which can be filtered and sorted before allowing you to output the
    data to a single feed. Give it a try by signing up for free at [http://pipes.yahoo.com](http://pipes.yahoo.com).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 之前问题的答案是使用Yahoo! Pipes——由Yahoo!提供的一项免费服务，允许您创建一个由一个或多个RSS、JSON或数据源组成的“管道”，在允许您输出数据到单个源之前，可以对数据进行过滤和排序。免费注册试用，请访问[http://pipes.yahoo.com](http://pipes.yahoo.com)。
- en: Creating an SQLite database
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建SQLite数据库
- en: There are many reasons why SQLite has become the relational database of choice
    for mobile handsets—it is scalable, fast, written in native C, and very portable,
    and has the added bonus of an exceptionally small footprint. We need local databases
    on our devices in order to store data when devices are offline, or even to store
    data that is only required locally (high scores in a game, for instance).
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多原因使得SQLite成为移动手机的首选关系数据库——它是可扩展的、快速的、用原生C语言编写的，并且非常便携，还有一个额外的好处是它具有异常小的占用空间。我们需要在设备上使用本地数据库来存储设备离线时的数据，或者甚至存储仅在本地上需要的数据（例如游戏中的高分）。
- en: Additionally, the caching of remote data can help speed up data access times
    in our applications—particularly important when mobile devices may have limited
    connectivity and bandwidth.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，远程数据的缓存可以帮助加快我们应用程序中的数据访问时间——尤其是在移动设备可能有限连接性和带宽的情况下尤为重要。
- en: There are two ways to create SQLite databases in your application, one—create
    the database in code using SQL and two—copy and attach an existing database to
    your app via the 'install' method. In this recipe we will explain how to create
    a database via SQL statements.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的应用程序中创建SQLite数据库有两种方法，一种是在代码中使用SQL创建数据库，另一种是通过“安装”方法复制并附加现有的数据库到您的应用程序中。在本菜谱中，我们将解释如何通过SQL语句创建数据库。
- en: Note
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 1/Recipe
    6` folder.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 本菜谱的完整源代码可以在`/Chapter 1/Recipe 6`文件夹中找到。
- en: How to do it...
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Create a new JavaScript file called `database.js`, and type in the following
    code at the top of your new file:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个名为 `database.js` 的新 JavaScript 文件，并在新文件顶部输入以下代码：
- en: '[PRE8]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now add the following line to the top of each Window that we need to reference
    our database functions from. Do this to both your `recipes.js` and `favorites.js`
    files.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下行添加到每个我们需要从其中引用数据库函数的 Window 的顶部。对您的 `recipes.js` 和 `favorites.js` 文件都执行此操作。
- en: '[PRE9]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: One of the great things about SQLite is the simplicity of its creation. In the
    previous example code, you can see we are not even performing a "create database"
    query anywhere. Simply attempting to open a database that does not exist, in this
    case `mydb`, tells the SQLite engine to create it automatically!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 的一个优点是其创建的简单性。在上面的示例代码中，您可以看到我们甚至没有执行任何“创建数据库”查询。只需尝试打开一个不存在的数据库，在本例中是
    `mydb`，就会告诉 SQLite 引擎自动创建它！
- en: From there we can create our SQL table using standard SQL syntax. In our case,
    we have created a table with an ID that is both the primary key and an auto-incrementing
    number, a title, link, and description. The latter three fields match the data
    being returned from our recipes data source. In the next recipe we can use this
    table to locally store our recipe data.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从那里我们可以使用标准 SQL 语法创建我们的 SQL 表。在我们的例子中，我们创建了一个具有既是主键又是自动递增数字的 ID、标题、链接和描述的表。后三个字段与我们的食谱数据源返回的数据相匹配。在下一个食谱中，我们可以使用这个表来本地存储我们的食谱数据。
- en: There's more...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Let's take a look at attaching a pre-populated database file.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何附加一个预先填充的数据库文件。
- en: Attaching a pre-populated database file…
  id: totrans-114
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 附加一个预先填充的数据库文件…
- en: 'Should you wish to create your database separately and attach it to your application
    at runtime, there is a method called `Titanium.Database.install().Implementing`
    this method is very easy, as it just accepts two parameters—the database file
    and the database name. As an example:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望单独创建数据库并在运行时将其附加到您的应用程序中，有一个名为 `Titanium.Database.install().Implementing`
    的方法。实现此方法非常简单，因为它只需要接受两个参数——数据库文件和数据库名称。例如：
- en: '[PRE10]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There are also numerous free SQLite applications for creating and managing SQLite
    databases. The open source **SQLite Database Browser** tool is freely available
    from [http://sqlitebrowser.sourceforge.net](http://sqlitebrowser.sourceforge.net)
    and runs on Windows, Linux, and Mac OS X.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 还有许多免费的 SQLite 应用程序用于创建和管理 SQLite 数据库。开源的 **SQLite 数据库浏览器** 工具可以从 [http://sqlitebrowser.sourceforge.net](http://sqlitebrowser.sourceforge.net)
    免费获取，并在 Windows、Linux 和 Mac OS X 上运行。
- en: Saving data locally using an SQLite database
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SQLite 数据库本地保存数据
- en: Saving and updating data to your SQLite database is just a matter of creating
    a function for each CRUD operation you need, and forming the SQL statement before
    executing it against the local database (our '`db`' object).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将数据和更新数据保存到您的 SQLite 数据库只是创建一个用于每个所需 CRUD 操作的函数，并在执行之前形成 SQL 语句，然后对本地数据库（我们的
    '`db`' 对象）执行它。
- en: In this recipe, we will edit the `database.js` file to contain two new functions,
    one for inserting a record in our favorites table and one for deleting a record.
    We will also capture the click events on our Table Rows to allow the user to view
    the record in a detailed sub-window, and add a button for creating the favorite.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将编辑 `database.js` 文件以包含两个新函数，一个用于在我们的收藏夹表中插入记录，另一个用于删除记录。我们还将捕获表行的点击事件，以便用户可以在详细子窗口中查看记录，并添加一个创建收藏的按钮。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    7` folder.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在 `/Chapter 2/Recipe 7` 文件夹中找到。
- en: How to do it...
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open your JavaScript file called `database.js`, and type in the following code
    at the top of your new file, after your table creation script:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 打开您的名为 `database.js` 的 JavaScript 文件，并在新文件顶部（在您的表创建脚本之后）输入以下代码：
- en: '[PRE11]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Then, back in our `recipes.js` file, we are going to capture the click event
    of the `tblRecipes` TableView in order to get the tapped row''s data and save
    it to our `favorites` table in SQLite:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，回到我们的 `recipes.js` 文件中，我们将捕获 `tblRecipes` TableView 的点击事件，以便获取被点击行的数据并将其保存到我们的
    SQLite 的 `favorites` 表中：
- en: '[PRE12]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we are creating functions that will accept the parameters to insert a
    favorite record, creating an SQL statement, and then executing that SQL query
    statement against our SQLite database. This is just a basic SQL query, although
    take note that just as you would with a desktop application or website, any input
    parameters should be escaped properly to avoid SQL injection! We're using a simple
    mechanism to do this in our recipe by simply replacing any occurrences of the
    apostrophe characters with a double apostrophe.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们正在创建函数，这些函数将接受插入收藏记录的参数，创建一个SQL语句，然后在我们的SQLite数据库上执行该SQL查询语句。这只是一个基本的SQL查询，尽管请注意，就像您在桌面应用程序或网站上做的那样，任何输入参数都应该被正确转义，以避免SQL注入！在我们的食谱中，我们通过简单地替换任何单引号字符为双引号来实现这一点。
- en: The second half of our code defines a new Window and adds to it a couple of
    buttons and a label for displaying the full text of our recipe. You should refer
    to [Chapter 1](ch01.html "Chapter 1. Building Apps using Native UI Components"),
    *Building Apps Using Native UI Components*, for more details on opening Windows,
    and adding and customizing UI components to them. One final point of interest,
    and a method we haven't come across before, is `Ti.Platform.openURL().` This method
    simply takes a valid URL and launches the Safari browser (or Android browser)
    on your phone. In our recipe, we're passing the "link" property from our data
    so the user can view the recipe in full from it's original website.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们代码的后半部分定义了一个新的窗口，并向其中添加了几个按钮和一个标签，用于显示我们食谱的全文。您应该参考[第1章](ch01.html "第1章. 使用原生UI组件构建应用")，*使用原生UI组件构建应用*，以获取更多关于打开窗口以及向其中添加和自定义UI组件的详细信息。一个有趣的观点，以及我们之前未曾遇到的方法，是`Ti.Platform.openURL().`这个方法简单地接受一个有效的URL，并在您的手机上启动Safari浏览器（或Android浏览器）。在我们的食谱中，我们传递了数据的"链接"属性，以便用户可以从原始网站完整地查看食谱。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Android users can always press their back button on the device to return to
    the app after the browser is launched, but it's worth noting that iPhone users
    would need to close Safari and re-launch the application from their home screen
    after the link button has been pressed. To avoid this, you could create another
    sub-window containing a WebView component, opening this through the `Titanium.UI.currentTab.open()`
    method, just as we did for our detail view in this recipe.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓用户可以在浏览器启动后按下设备上的返回按钮返回到应用，但值得注意的是，iPhone用户在按下链接按钮后需要关闭Safari并从主屏幕重新启动应用。为了避免这种情况，您可以在另一个子窗口中创建一个WebView组件，通过`Titanium.UI.currentTab.open()`方法打开它，就像我们在本食谱中的详细视图一样。
- en: The following screenshots show the detail view window for our recipe, before
    and after we insert a favorite record into the SQLite database table.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了我们的食谱详细视图窗口，在我们在SQLite数据库表中插入收藏记录之前和之后。
- en: '*For an iPhone:*'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对iPhone：*'
- en: '![There''s more...](img/3968EXP_02_06.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/3968EXP_02_06.jpg)'
- en: '*For an Android phone:*'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '*针对Android手机：*'
- en: '![There''s more...](img/3968EXP_02_07.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/3968EXP_02_07.jpg)'
- en: Retrieving data from an SQLite database
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从 SQLite 数据库中检索数据
- en: The ability to create a table and insert data into it is not of much use if
    we don't know how to retrieve that data and present it in some useful way to the
    user! We'll now introduce the concept of a **resultSet** (or recordSet if you
    prefer) in SQLite and how to retrieve data via this resultSet object that can
    be collected and returned to an array format suitable for usage within a TableView.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不知道如何检索数据并以某种有用的方式将其呈现给用户，那么创建表格并插入数据到其中就没有多大用处了！现在，我们将介绍SQLite中的**resultSet**（如果您更喜欢，可以称为recordSet）的概念，以及如何通过这个resultSet对象检索数据，并将其收集并返回到适合在TableView中使用的数组格式。
- en: Note
  id: totrans-140
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    8` folder.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 2/Recipe 8`文件夹中找到。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'In your `database.js` file, add the following function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在您的`database.js`文件中，添加以下函数：
- en: '[PRE13]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, open the `favorites.js` file for the first time, and type in the following
    code. Much of this code should be pretty familiar to you by now, including defining
    and adding a TableView to our Window, plus including the `database.js` file through
    our `Ti.include()` method.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，首次打开`favorites.js`文件，并输入以下代码。现在，这部分代码中的大部分应该对您来说都很熟悉，包括定义和向我们的窗口添加TableView，以及通过我们的`Ti.include()`方法包含`database.js`文件。
- en: '[PRE14]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The first block of code is really just an extension of our previous recipe.
    But instead of creating or removing records, we are selecting them into a database
    recordset called "resultSet", and then looping through this resultSet object adding
    the data we require from each record into our `results` array.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 第一块代码实际上只是我们之前食谱的扩展。但不是创建或删除记录，而是将它们选择到名为“resultSet”的数据库记录集中，然后遍历这个resultSet对象，将每个记录所需的数据添加到我们的`results`数组中。
- en: The `results` array can then be added to our TableView's data property just
    like any other data source such as you obtained at the start of the chapter from
    an external XML feed. One thing to note is that you must *always* iterate to the
    new record in the resultSet using `resultSet.next()`, and when finished, *always
    close* the resultSet using `resultSet.close()`. A failure to do either of these
    actions can cause your application to record invalid data, leak memory badly,
    and in the worst case, fatally crash!
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，可以将`results`数组添加到TableView的数据属性中，就像任何其他数据源一样，例如你在本章开头从外部XML信息流中获取的数据。需要注意的是，你必须*始终*使用`resultSet.next()`迭代到resultSet中的新记录，完成时，*始终*使用`resultSet.close()`关闭resultSet。未能执行这些操作中的任何一个都可能使你的应用程序记录无效数据，严重泄漏内存，在最坏的情况下，可能导致应用程序崩溃！
- en: '![How it works...](img/3968EXP_02_08.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/3968EXP_02_08.jpg)'
- en: The previous screenshot shows the TableView in our **Favorites** tab displaying
    the records we have added as 'favorites' to our local SQLite database.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们的**收藏**标签页中的TableView，显示了我们已经添加为“收藏”到本地SQLite数据库中的记录。
- en: Creating a "pull and release" refresh mechanism
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个“下拉并释放”刷新机制
- en: What happens if you want the user to be able to refresh the feed data in our
    table? You could create a regular button, or possibly check for new data at arbitrary
    time intervals. Alternatively, you could implement a cool 'pull and release' refresh
    mechanism made very popular by Twitter applications such as Tweetie and Twitter
    for Android.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让用户能够刷新表格中的信息流，你可以创建一个常规按钮，或者可能在任意时间间隔检查新数据。或者，你可以实现一个由Twitter应用如Tweetie和Twitter
    for Android等非常流行的“下拉并释放”刷新机制。
- en: In the final recipe for our **Recipe Finder** app, we will implement the very
    same type of refresh mechanism for our recipes feed, using the table view's `headerPullView`
    property.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们**食谱查找器**应用的最终版本中，我们将为我们的食谱信息流实现相同类型的刷新机制，使用表格视图的`headerPullView`属性。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Complete source code for this recipe can be found in the `/Chapter 2/Recipe
    9` folder, while the complete source code for this entire chapter can be found
    in the `/Chapter 2/RecipeFinder` folder.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱的完整源代码可以在`/Chapter 2/Recipe 9`文件夹中找到，而本章的完整源代码可以在`/Chapter 2/RecipeFinder`文件夹中找到。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Open your `recipes.js` file and type in the following code under the "`Ti.include`"
    statements. This is where will be creating the pull view and adding our user interface
    components to it, before creating the event listeners that will perform the data
    request.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的`recipes.js`文件，在`Ti.include`语句下输入以下代码。这就是我们将创建下拉视图并将用户界面组件添加到其中的地方，在创建将执行数据请求的事件监听器之前。
- en: '[PRE15]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Finally, in your `xhr.open()` method, we will do a check to see if this is the
    first time we're loading data or whether this is a reload call made by our "pull
    and release" mechanism. If it's the latter, we'll hide the header pull view and
    reset the contents of it back to its original state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在你的`xhr.open()`方法中，我们将检查这是否是我们第一次加载数据，或者这是否是由我们的“下拉并释放”机制发起的重新加载调用。如果是后者，我们将隐藏头部下拉视图并重置其内容回到原始状态。
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: What we are doing here can really be broken up into two main components. First,
    we're creating a header view using standard UI components. Second, we're using
    events to know when our header view has been 'pulled' down far enough so that
    we can perform a refresh on our recipes data from the XML/JSON feed.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的工作实际上可以分解为两个主要部分。首先，我们使用标准UI组件创建一个头部视图。其次，我们使用事件来知道我们的头部视图已经被“下拉”到足够远的位置，这样我们就可以从XML/JSON信息流中刷新我们的食谱数据。
- en: We know how far the header view has been pulled down via the `contentOffset`
    property of our TableView. In this case, we are executing the refresh of the data
    when the content offset hits 80px, which is the height of both the header view
    and also the height of the TableView's data rows from the top of the screen.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过TableView的`contentOffset`属性知道头部视图下拉了多少。在这种情况下，当内容偏移量达到80px时，我们将执行数据的刷新，这是头部视图的高度，也是TableView数据行从屏幕顶部的高度。
- en: 'Finally, the two variables called `pulling` and `reloading` are used in conjunction
    so we can determine the series of steps in our "pull and release" refresh mechanism
    programmatically:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`pulling` 和 `reloading` 这两个变量结合使用，我们可以通过编程方式确定我们“拉取并释放”刷新机制中的步骤序列：
- en: When the TableView is being pulled down by the user, using a tap and hold gesture
    (`pulling = true`)
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当用户正在下拉TableView，使用点击并保持的手势时（`pulling = true`）
- en: When the TableView has finished pulling but has not yet started to reload the
    data from our remote data source (`pulling = true` and `reloading = false`)
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当TableView已完成拉取操作，但尚未开始从我们的远程数据源重新加载数据时（`pulling = true` 且 `reloading = false`）
- en: When our pulling has completed but we are waiting for the data to finish being
    returned from our remote data source (`pulling = false` and `reloading = true`)
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们的拉取操作已完成，但我们正在等待从我们的远程数据源返回数据完成时（`pulling = false` 且 `reloading = true`）
- en: Finally, when our remote data source has finished streaming the required data
    and the header pull view can be closed, and the scrolling offset of our table
    can return to normal (`pulling = false` and `reloading = false`)
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当我们的远程数据源已完成流式传输所需数据，并且头部拉取视图可以关闭，我们的表格滚动偏移可以恢复正常时（`pulling = false` 且 `reloading
    = false`）
