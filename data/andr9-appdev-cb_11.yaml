- en: A First Look at OpenGL ES
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 初探 OpenGL ES
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Setting up the OpenGL ES environment
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 OpenGL ES 环境
- en: Drawing shapes on GLSurfaceView
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 GLSurfaceView 上绘制形状
- en: Applying the projection and camera view while drawing
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘图时应用投影和相机视图
- en: Moving the triangle with rotation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过旋转移动三角形
- en: Rotating the triangle with user input
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过用户输入旋转三角形
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we saw in the previous chapter, Android offers many tools for handling graphics
    and animations. Although the canvas and drawable objects are designed for custom
    drawing, when you need high-performance graphics, especially 3D gaming graphics,
    Android also supports OpenGL ES. **Open Graphics Library for Embedded Systems**
    (**OpenGL ES**), is targeted at embedded systems. (Embedded systems include consoles
    and phones.)
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章所看到的，Android 提供了许多处理图形和动画的工具。尽管画布和可绘制对象是为自定义绘图设计的，但当您需要高性能的图形，尤其是 3D
    游戏图形时，Android 也支持 OpenGL ES。**嵌入式系统开放图形库**（**OpenGL ES**），针对嵌入式系统。 (嵌入式系统包括游戏机和手机。)
- en: This chapter is meant to serve as an introduction to using OpenGL ES on Android.
    As usual, we'll provide the steps and explain how things work, but we aren't going
    to be digging into the math or technical details of OpenGL. If you are already
    familiar with OpenGL ES from other platforms, such as iOS, this chapter should
    get you up and running quickly. If you are new to OpenGL, hopefully these recipes
    will help you decide whether this is an area you want to pursue.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章旨在作为在 Android 上使用 OpenGL ES 的入门指南。像往常一样，我们将提供步骤并解释事情是如何工作的，但我们将不会深入挖掘 OpenGL
    的数学或技术细节。如果您已经熟悉来自其他平台（如 iOS）的 OpenGL ES，那么本章应该能快速让您上手。如果您是 OpenGL 新手，希望这些菜谱能帮助您决定是否要在这个领域继续探索。
- en: 'Android supports the following versions of OpenGL:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: Android 支持以下版本的 OpenGL：
- en: '**OpenGL ES 1.0**: Android 1.0'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 1.0**：Android 1.0'
- en: '**OpenGL ES 2.0**: Introduced in Android 2.2 (API 8)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 2.0**：在 Android 2.2（API 8）中引入'
- en: '**OpenGL ES 3.0**: Introduced in Android 4.3 (API 18)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.0**：在 Android 4.3（API 18）中引入'
- en: '**OpenGL ES 3.1**: Introduced in Android 5.0 (API 21)'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES 3.1**：在 Android 5.0（API 21）中引入'
- en: The recipes in this chapter are introductory and target OpenGL ES 2.0 and higher.
    OpenGL ES 2.0 is available for nearly all devices currently available. Unlike
    OpenGL ES 2.0 and lower, OpenGL 3.0 and higher require driver implementation from
    the hardware manufacturer. This means that, even if your application is running
    on Android 5.0, OpenGL 3.0 and higher may not be available. Therefore, it's a
    good programming practice to check the available OpenGL versions at runtime. Alternatively,
    if your application requires 3.0 and higher features, you can add a `<uses-feature/>`
    element to your Android manifest. (We'll discuss this in the first recipe that
    follows.)
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的菜谱是入门级的，针对 OpenGL ES 2.0 及更高版本。OpenGL ES 2.0 几乎适用于目前所有可用的设备。与 OpenGL ES
    2.0 及更低版本不同，OpenGL 3.0 及更高版本需要硬件制造商提供驱动程序实现。这意味着，即使您的应用程序在 Android 5.0 上运行，OpenGL
    3.0 及更高版本可能不可用。因此，检查运行时可用 OpenGL 版本是一种良好的编程实践。或者，如果您的应用程序需要 3.0 及更高版本的功能，您可以在
    Android 清单中添加 `<uses-feature/>` 元素。（我们将在接下来的第一个菜谱中讨论这个问题。）
- en: Unlike the other chapters in this book, this chapter is written more as a tutorial,
    with each recipe building on lessons learned from the previous recipe. The *Getting
    ready* section of each recipe will clarify the prerequisites.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的其他章节不同，本章更多地以教程的形式编写，每个菜谱都是基于前一个菜谱中学到的经验。每个菜谱的 *准备* 部分将阐明先决条件。
- en: Setting up the OpenGL ES environment
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 OpenGL ES 环境
- en: Our first recipe will start by showing the steps to set up an activity to use
    an OpenGL `GLSurfaceView`. Similar to the canvas, the `GLSurfaceView` is where
    you will do your OpenGL drawing. As this is the starting point, the other recipes
    will refer to this recipe as the base step when they need a `GLSurfaceView` created.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一道菜谱将从展示设置活动以使用 OpenGL `GLSurfaceView` 的步骤开始。类似于画布，`GLSurfaceView` 是您将进行
    OpenGL 绘图的地方。由于这是起点，其他菜谱在需要创建 `GLSurfaceView` 时将参考此菜谱作为基础步骤。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `SetupOpenGL`. Use the default
    Phone & Tablet options and select Empty Activity when prompted for Activity Type.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `SetupOpenGL`。使用默认的 Phone & Tablet 选项，并在提示活动类型时选择
    Empty Activity。
- en: How to do it...
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We''ll start by indicating the application''s use of OpenGL in the Android
    Manifest, and then we''ll add the OpenGL classes to the activity. Here are the
    steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 Android Manifest 中指出应用程序使用 OpenGL，然后我们将 OpenGL 类添加到活动中。以下是步骤：
- en: 'Open the Android Manifest and add the following XML:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android Manifest 并添加以下 XML：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `MainActivity.java` and add the following global variables:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Add the following inner class to the `MainActivity` class:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类中添加以下内部类：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add another inner class to the `MainActivity` class:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类中添加另一个内部类：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Modify the existing `onCreate()` method as follows:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改现有的 `onCreate()` 方法如下：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以开始在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: If you ran the preceding application, you saw the activity created and the background
    set to gray. Since these are the basic steps for setting up OpenGL, you'll be
    reusing this code for the other recipes in this chapter as well. The following
    explains the process detail.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行了前面的应用程序，你会看到活动创建并且背景设置为灰色。由于这些是设置 OpenGL 的基本步骤，你将在本章的其他配方中重用此代码。以下是对过程的详细说明。
- en: Declaring OpenGL in the Android Manifest
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Android Manifest 中声明 OpenGL
- en: 'We start by declaring our requirement to use OpenGL ES version 2.0 in the Android
    Manifest with the following line:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先在 Android Manifest 中声明我们使用 OpenGL ES 2.0 的需求，如下所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If we were using version 3.0, we would use this:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们使用的是 3.0 版本，我们会使用以下代码：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'For version 3.1, use this:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 3.1 版本，使用以下代码：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Extending the GLSurfaceView class
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展 GLSurfaceView 类
- en: 'Create a custom OpenGL `SurfaceView` class by extending `GLSurfaceView`, as
    we do in this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展 `GLSurfaceView`，创建一个自定义的 OpenGL `SurfaceView` 类，就像我们在这段代码中所做的那样：
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, we instantiate an OpenGL rendered class and pass it to the `GLSurfaceView`
    class with the `setRenderer()` method. The OpenGL `SurfaceView` provides a surface
    for our OpenGL drawing, similar to the `Canvas` and `SurfaceView` objects. The
    actual drawing is done in the `Renderer`, which we'll create next.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实例化一个 OpenGL 渲染类，并通过 `setRenderer()` 方法将其传递给 `GLSurfaceView` 类。OpenGL
    `SurfaceView` 为我们的 OpenGL 绘图提供了一个表面，类似于 `Canvas` 和 `SurfaceView` 对象。实际的绘制是在 `Renderer`
    中完成的，我们将在下一步创建它。
- en: Creating an OpenGL rendered class
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 OpenGL 渲染类
- en: 'The last step is to create the `GLSurfaceView.Renderer` class and implement
    the following three callbacks:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是创建 `GLSurfaceView.Renderer` 类并实现以下三个回调：
- en: '`onSurfaceCreated()`'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceCreated()`'
- en: '`onDrawFrame()`'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDrawFrame()`'
- en: '`onSurfaceChanged()`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onSurfaceChanged()`'
- en: 'Following is the code:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要添加的代码：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Right now, all we're doing with this class is setting up the callbacks and clearing
    the screen using the color we specify with `glClearColor()` (gray in this case).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们使用这个类所做的只是设置回调并使用 `glClearColor()`（在这种情况下为灰色）指定的颜色清除屏幕。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: With the OpenGL environment set up, we'll continue to the next recipe where
    we'll actually draw on the view.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好 OpenGL 环境后，我们将继续到下一个配方，我们将实际在视图中绘制。
- en: Drawing shapes on GLSurfaceView
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 GLSurfaceView 上绘制形状
- en: The previous recipe set up the activity to use OpenGL. This recipe will continue
    by showing how to draw on `OpenGLSurfaceView`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的配方设置了活动以使用 OpenGL。本配方将继续展示如何在 `OpenGLSurfaceView` 上绘制。
- en: First, we need to define the shape. With OpenGL, it is important to realize
    that the order in which the vertices of a shape are defined is very important,
    as they determine the front (face) and back of the shape. It's customary (and
    the default behavior) to define vertices counterclockwise. (Although this behavior
    can be changed, it requires additional code and is not standard practice.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要定义形状。使用 OpenGL 时，重要的是要意识到形状顶点的定义顺序非常重要，因为它们决定了形状的前面（面）和背面。通常（并且是默认行为）是逆时针定义顶点。（尽管这种行为可以改变，但它需要额外的代码，并且不是标准实践。）
- en: 'It''s also important to understand the OpenGL screen coordinate system, as
    it differs from the Android canvas. The default coordinate system defines (`0,0,0`)
    as the center of the screen. The four edge points are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 OpenGL 屏幕坐标系也很重要，因为它与 Android 画布不同。默认坐标系将 (`0,0,0`) 定义为屏幕中心。四个边缘点如下：
- en: '**Top left**: (`-1.0, 1.0, 0`)'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左上角**：(`-1.0, 1.0, 0`)'
- en: '**Top right**: (`1.0, 1.0, 0`)'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右上角**：(`1.0, 1.0, 0`)'
- en: '**Bottom left**: (`-1.0, -1.0, 0`)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**左下角**：(`-1.0, -1.0, 0`)'
- en: '**Bottom right**: (`1.0, -1.0, 0`)'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**右下角**：(`1.0, -1.0, 0`)'
- en: The *Z* axis comes straight out of the screen or straight behind.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*Z* 轴直接从屏幕或直接在屏幕后面出来。'
- en: 'We''re going to create a `Triangle` class since it is the base shape. In OpenGL,
    you generally use a collection of triangles to create objects. To draw a shape
    with OpenGL, we need to define the following:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个`Triangle`类，因为它是基础形状。在OpenGL中，您通常使用三角形的集合来创建对象。要使用OpenGL绘制形状，我们需要定义以下内容：
- en: '**Vertex shader**: This is to draw the shape'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点着色器**：这是为了绘制形状'
- en: '**Fragment shader**: This is to color the shape'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段着色器**：这是为了给形状上色'
- en: '**Program**: This is an OpenGL ES object for the preceding shaders'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**程序**：这是前面着色器的OpenGL ES对象'
- en: The shaders are defined using **OpenGL Shading Language** (**GLSL**), and then
    compiled and added to the OpenGL program object.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 着色器使用**OpenGL着色语言**（**GLSL**）定义，然后编译并添加到OpenGL程序对象中。
- en: 'Following are two screenshots showing the triangle in portrait orientation:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是两个截图，显示了三角形在竖直方向上的样子：
- en: '![](img/89b183c4-e729-4e93-8a6e-e55f7c531575.png)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![](img/89b183c4-e729-4e93-8a6e-e55f7c531575.png)'
- en: 'Here is the same image when the orientation is rotated to landscape:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当方向旋转为横幅时，这里是相同的图像：
- en: '![](img/54be5673-709e-445f-a85a-c0bb8b4e8e3f.png)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![](img/54be5673-709e-445f-a85a-c0bb8b4e8e3f.png)'
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ShapesWithOpenGL`. Use the
    default Phone & Tablet options and select Empty Activity when prompted for Activity
    Type.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为`ShapesWithOpenGL`。使用默认的Phone & Tablet选项，并在提示活动类型时选择Empty
    Activity。
- en: This recipe uses the OpenGL environment created in the previous recipe, *Setting
    up the Open GL environment*. Refer to the previous recipe if you have not already
    completed those steps.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方使用上一配方中创建的OpenGL环境，即**设置OpenGL环境**。如果您尚未完成这些步骤，请参阅上一配方。
- en: How to do it...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As indicated previously, we''ll be using the OpenGL environment created in
    the previous recipe. The steps that follow will walk you through creating a class
    for the triangle shape and drawing it on the GLSurfaceView:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将使用上一配方中创建的OpenGL环境。以下步骤将指导您创建一个用于三角形形状的类，并在GLSurfaceView上绘制它：
- en: Create a new Java class called `Triangle`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Triangle`的新Java类。
- en: 'Add the following global declarations to the `Triangle` class:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下全局声明添加到`Triangle`类中：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add the following `loadShader()` method to the `Triangle` class:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`loadShader()`方法添加到`Triangle`类中：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the `Triangle` constructor, as shown here:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`Triangle`构造函数，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add the `draw()` method as follows:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式添加`draw()`方法：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, open `MainActivity.java` and add a `Triangle` variable to the `GLRenderer`
    class as follows:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开`MainActivity.java`并在`GLRenderer`类中添加一个`Triangle`变量，如下所示：
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Initialize the `Triangle` variable in the `onSurfaceCreated()` callback as
    follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onSurfaceCreated()`回调中初始化`Triangle`变量，如下所示：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `onDrawFrame()` callback, call the `Triangle` `draw()` method after
    glClear is called:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`onDrawFrame()`回调中，在调用`glClear`之后调用`Triangle`的`draw()`方法：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您已准备好在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'As mentioned in the introduction, to draw with OpenGL we first have to define
    the shaders, which we do with the following code:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如介绍中所述，要使用OpenGL绘图，我们首先必须定义着色器，我们使用以下代码来完成：
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since this is uncompiled **OpenGL Shading Language** (**OpenGLSL**), the next
    step is to compile and attach it to our OpenGL object, which we do with the following
    two OpenGL ES methods:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这是未编译的**OpenGL着色语言**（**OpenGLSL**），下一步是将它编译并附加到我们的OpenGL对象上，我们使用以下两个OpenGL
    ES方法来完成：
- en: '`glAttachShader()`'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glAttachShader()`'
- en: '`glLinkProgram()`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`glLinkProgram()`'
- en: After setting up the shaders, we create `ByteBuffer` to store the triangle vertices,
    which are defined in `triangleCoords`. The `draw()` method is where the actual
    drawing occurs using the GLES20 library calls, which is called from the `onDrawFrame()`
    callback.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置好着色器后，我们创建`ByteBuffer`来存储三角形顶点，这些顶点在`triangleCoords`中定义。`draw()`方法是实际绘制的地方，使用GLES20库调用，这些调用是从`onDrawFrame()`回调中调用的。
- en: There's more...
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: From the screenshots in the introduction, you may have noticed that the triangles
    in the portrait and landscape do not look identical to each other. As you can
    see from the code, we make no distinction in terms of orientation when drawing.
    We'll explain why this is happening and show how to correct this issue in the
    next recipe.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 从介绍中的截图，您可能已经注意到，竖直和横幅方向上的三角形看起来并不完全相同。正如您从代码中看到的，我们在绘制时没有对方向进行区分。我们将解释为什么会发生这种情况，并在下一配方中展示如何纠正这个问题。
- en: See also
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: For more information on the OpenGL Shading Language, refer to the following
    link: [https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于OpenGL着色语言的信息，请参考以下链接：[https://www.opengl.org/documentation/glsl/](https://www.opengl.org/documentation/glsl/)。
- en: Applying the projection and camera view while drawing
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制时应用投影和相机视图
- en: As we saw in the previous recipe, when we draw our shape on the screen, the
    shape is skewed by the screen orientation. The reason for this is because, by
    default, OpenGL assumes a perfectly square screen. As we mentioned before, the
    default screen coordinates for the top right are (`1,1,0`) and (`-1,-1,0`) for
    the bottom left.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个食谱中所示，当我们把形状绘制到屏幕上时，形状会因为屏幕方向而倾斜。这是因为默认情况下，OpenGL假设屏幕是完美的正方形。正如我们之前提到的，默认屏幕坐标中右上角是(`1,1,0`)，左下角是(`-1,-1,0`)。
- en: 'Since most device screens are not perfectly square, we need to map the display
    coordinates to match our physical device. In OpenGL, we do this with p*rojection*.
    This recipe will show how to use projection to match the GLSurfaceView coordinates
    with the device coordinates. Along with the projection, we''ll also show how to
    set the Camera View. Following is a screenshot showing the final result:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于大多数设备屏幕都不是完美的正方形，我们需要将显示坐标映射到匹配我们的物理设备。在OpenGL中，我们使用*p*rojection*来完成这个操作。这个食谱将展示如何使用投影来匹配GLSurfaceView坐标与设备坐标。除了投影，我们还将展示如何设置相机视图。以下是显示最终结果的截图：
- en: '![](img/d3734a37-5c26-46da-8476-ad9941368990.png)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d3734a37-5c26-46da-8476-ad9941368990.png)'
- en: Getting ready
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `ProjectionAndCamera`. Use
    the default Phone & Tablet options and select Empty Activity when prompted for
    Activity Type.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为`ProjectionAndCamera`。使用默认的Phone & Tablet选项，并在提示活动类型时选择Empty
    Activity。
- en: This recipe builds on the previous recipe, *Drawing shapes on GLSurfaceView*.
    If you don't already have the previous recipe, start there before starting these
    steps.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基于之前的食谱，*在GLSurfaceView上绘制形状*。如果你还没有之前的食谱，请在开始这些步骤之前先从那里开始。
- en: How to do it...
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As stated previously, this recipe will build on the previous recipe, so complete
    those steps before starting. We will be modifying the previous code to add the
    projection and camera view to the drawing calculations. Here are the steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这个食谱将在之前的食谱基础上构建，因此在开始之前请完成这些步骤。我们将修改之前的代码以添加投影和相机视图到绘图计算中。以下是步骤：
- en: 'Open the `Triangle` class and add the following global declaration to the existing
    declarations:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Triangle`类，并在现有声明中添加以下全局声明：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add a matrix variable to `vertexShaderCode` and use it in the position calculation.
    Here is the final result:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`vertexShaderCode`中添加一个矩阵变量并在位置计算中使用它。以下是最终结果：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Change the `draw()` method to pass in a matrix parameter as follows:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`draw()`方法修改为传递一个矩阵参数，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To use the transformation matrix, add the following code to the `draw()` method
    just before the `GLES20.glDrawArrays()` method:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用变换矩阵，请在`draw()`方法中在`GLES20.glDrawArrays()`方法之前添加以下代码：
- en: '[PRE21]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Open `MainActivity.java` and add the following class variables to the `GLRenderer`
    class:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并将以下类变量添加到`GLRenderer`类中：
- en: '[PRE22]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Modify the `onSurfaceChanged()` callback to calculate the position matrix as
    follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onSurfaceChanged()`回调以按如下方式计算位置矩阵：
- en: '[PRE23]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Modify the `onDrawFrame()` callback to calculate the Camera View as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`onDrawFrame()`回调以按如下方式计算相机视图：
- en: '[PRE24]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, we modify the `vertexShaderCode` to include a matrix variable. We calculate
    the matrix in the `onSurfaceChanged()` callback using the height and width, which
    are passed in as parameters. We pass the transformation matrix to the `draw()`
    method to use it when calculating the position to draw.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们修改`vertexShaderCode`以包含一个矩阵变量。我们使用传入的参数高度和宽度在`onSurfaceChanged()`回调中计算矩阵。我们将变换矩阵传递给`draw()`方法，以便在计算绘制位置时使用。
- en: 'Before we call the `draw()` method, we calculate the camera view. These two
    lines of code calculate the camera view:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用`draw()`方法之前，我们计算相机视图。这两行代码计算了相机视图：
- en: '[PRE25]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Without this code, there would actually be no triangle drawn as the camera perspective
    would not "see" our vertices. (This goes back to our discussion on how the order
    of the vertices dictates the front and back of the image.)
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 没有这段代码，实际上不会绘制三角形，因为相机视角不会“看到”我们的顶点。（这回到了我们讨论顶点顺序如何决定图像的前后。）
- en: When you run the program now, you'll see the output shown in the *Introduction*.
    Notice that we now have an equilateral triangle (all sides equal), even when the
    display is rotated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行程序时，你会看到 *简介* 中所示的输出。注意，我们现在有一个等边三角形（所有边相等），即使显示被旋转。
- en: There's more...
  id: totrans-137
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In the next recipe, we will start showing the power of OpenGL by rotating the
    triangle.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个食谱中，我们将开始展示OpenGL旋转三角形的强大功能。
- en: Moving the triangle with rotation
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过旋转移动三角形
- en: What we've demonstrated so far with OpenGL would probably be easier using the
    traditional canvas or drawable objects. This recipe will show a bit of the power
    of OpenGL by rotating the triangle. Not that we can't create movement with the
    other drawing methods, but how easily can we do this with OpenGL?
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们到目前为止用OpenGL演示的内容可能使用传统的画布或可绘制对象会更简单。这个食谱将通过旋转三角形展示OpenGL的一些强大功能。不是我们不能用其他绘图方法创建运动，而是我们用OpenGL来做这件事有多容易？
- en: 'This recipe will demonstrate how to rotate the triangle, as the following screenshot
    shows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱将演示如何旋转三角形，如下面的截图所示：
- en: '![](img/eb0bb8c5-e7c9-4e42-a3ec-bd3d9122c297.png)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eb0bb8c5-e7c9-4e42-a3ec-bd3d9122c297.png)'
- en: Getting ready
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `CreatingMovement`. Use the
    default Phone & Tablet options and select Empty Activity when prompted for Activity
    Type.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，命名为 `CreatingMovement`。使用默认的 Phone & Tablet 选项，并在提示活动类型时选择
    Empty Activity。
- en: This recipe builds on the previous recipe, *Applying the projection and camera
    view while drawing*. Refer to the previous recipe if you have not already completed
    those steps.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这个食谱基于之前的食谱，*在绘图时应用投影和相机视图*。如果你还没有完成那些步骤，请参考之前的食谱。
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Since we are continuing from the previous recipe, we have very little work
    to do. Open `MainActivity.java` and follow these steps:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们是从上一个食谱继续的，所以我们几乎没有工作要做。打开 `MainActivity.java` 并按照以下步骤操作：
- en: 'Add a Matrix to the `GLRendered` class:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `GLRendered` 类添加一个矩阵：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `onDrawFrame()` callback, replace the existing `mTriangle.draw(mMVPMatrix);`
    statement with the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onDrawFrame()` 回调中，将现有的 `mTriangle.draw(mMVPMatrix);` 语句替换为以下代码：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: We're using the `Matrix.setRotateM()` method to calculate a new rotation matrix
    based on the angle we pass in. For this example, we're using the system uptime
    to calculate an angle. We can use whatever method we want to derive an angle,
    such as a sensor reading or touch events.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Matrix.setRotateM()` 方法根据我们传递的角度计算一个新的旋转矩阵。在这个例子中，我们使用系统运行时间来计算一个角度。我们可以使用任何我们想要的方法来得到一个角度，比如传感器读取或触摸事件。
- en: There's more...
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Using the system clock provides the added benefit of creating continuous movement,
    which certainly looks better for demonstration purposes. The next recipe will
    demonstrate how to use user input to derive an angle for rotating the triangle.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用系统时钟提供了创建连续运动的额外好处，这对于演示目的当然看起来更好。下一个食谱将演示如何使用用户输入来得到旋转三角形的角。
- en: The render mode
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染模式
- en: 'OpenGL offers a `setRenderMode()` option to draw only when the view is dirty.
    This can be enabled by adding the following code to the `CustomGLSurfaceView()`
    constructor just below the `setRenderer()` call:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL提供了一个 `setRenderMode()` 选项，只有在视图变脏时才绘制。这可以通过在 `setRenderer()` 调用下方添加以下代码到
    `CustomGLSurfaceView()` 构造函数中来实现：
- en: '[PRE28]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This will cause the display to update just once, then wait until we request
    an update with `requestRender()`.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致显示只更新一次，然后等待我们使用 `requestRender()` 请求更新。
- en: Rotating the triangle with user input
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过用户输入旋转三角形
- en: The previous example demonstrated rotating the triangle based on the system
    clock. This created a continuously rotating triangle, depending on the render
    mode we used. But what if you wanted to respond to the input from the user?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的例子演示了根据系统时钟旋转三角形。这创建了一个持续旋转的三角形，这取决于我们使用的渲染模式。但如果你想要响应用户的输入呢？
- en: In this recipe, we'll show how to respond to user input by overriding the `onTouchEvent()`
    callback from `GLSurfaceView`. We'll still rotate the triangle using the `Matrix.setRotateM()`
    method, but instead of deriving an angle from the system time, we'll calculate
    an angle based on the touch location.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将展示如何通过重写 `GLSurfaceView` 的 `onTouchEvent()` 回调来响应用户输入。我们仍然会使用 `Matrix.setRotateM()`
    方法来旋转三角形，但不是从系统时间中推导角度，而是基于触摸位置计算角度。
- en: 'Here''s a screenshot showing this recipe running on a physical device (to highlight
    the touch, the Show touches developer option is enabled):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一张显示此配方在物理设备上运行的截图（为了突出触摸，已启用 Show touches 开发者选项）：
- en: '![](img/3405c31e-8deb-4491-b3bf-5f7418a7d4f7.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![](img/3405c31e-8deb-4491-b3bf-5f7418a7d4f7.png)'
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RotateWithUserInput`. Use
    the default Phone & Tablet options and select Empty Activity when prompted for
    Activity Type.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `RotateWithUserInput`。使用默认的 Phone & Tablet
    选项，并在提示活动类型时选择 Empty Activity。
- en: This recipe demonstrates an alternative approach to the previous recipe and
    therefore will be based on the *Applying the projection and camera view while
    drawing* (the same starting point as the previous recipe.)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了与之前配方不同的方法，因此将基于 *在绘制时应用投影和相机视图*（与之前的配方相同的起点。）
- en: How to do it...
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'As stated previously, we will continue, not from the previous recipe, but from
    the *Applying the projection and camera view while drawing* recipe. Open `MainActivity.java`
    and follow these steps:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们将继续，不是从之前的配方开始，而是从 *在绘制时应用投影和相机视图* 配方开始。打开 `MainActivity.java` 并按照以下步骤操作：
- en: 'Add the following global variables to the `MainActivity` class:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下全局变量添加到 `MainActivity` 类中：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Add the following code to the `GLRendered` class:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `GLRendered` 类中：
- en: '[PRE30]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the same class, modify the `onDrawFrame()` method by replacing the existing `mTriangle.draw(mMVPMatrix);` statement
    with the following code:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，通过将现有的 `mTriangle.draw(mMVPMatrix);` 语句替换为以下代码来修改 `onDrawFrame()` 方法：
- en: '[PRE31]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the `onSurfaceChanged()` callback:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `onSurfaceChanged()` 回调中：
- en: '[PRE32]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following code to the `CustomGLSurfaceView` constructor, which is below
    `setRenderer()`:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `CustomGLSurfaceView` 构造函数中，该函数位于 `setRenderer()` 下方：
- en: '[PRE33]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following `onTouchEvent()` to the `CustomGLSurfaceView` class:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `onTouchEvent()` 添加到 `CustomGLSurfaceView` 类中：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行应用程序在设备或模拟器上。
- en: How it works...
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The obvious difference between this example and the previous recipe lies in
    how we derive the angle to pass to the `Matrix.setRotateM()` call. We also changed
    the `GLSurfaceView` render mode using `setRenderMode()` to only draw on request.
    We made the request using `requestRender()` after calculating a new angle in the
    `onTouchEvent()` callback.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方相比，这个例子明显的区别在于我们如何推导出传递给 `Matrix.setRotateM()` 调用的角度。我们还使用 `setRenderMode()`
    改变了 `GLSurfaceView` 的渲染模式，使其仅在请求时绘制。我们在 `onTouchEvent()` 回调中计算了一个新角度后，使用 `requestRender()`
    发出了请求。
- en: We also demonstrated the importance of deriving our own `GLSurfaceView` class.
    Without our `CustomGLSurfaceView` class, we would not have a way to override the
    `onTouchEvent` callback or any other callbacks from `GLSurfaceView`.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还展示了自定义 `GLSurfaceView` 类的重要性。如果没有我们的 `CustomGLSurfaceView` 类，我们就无法覆盖 `onTouchEvent`
    回调或其他来自 `GLSurfaceView` 的回调。
- en: There's more...
  id: totrans-187
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: This concludes the OpenGL ES recipes, but we've only just touched upon the power
    of OpenGL. If you're serious about learning OpenGL, see the links in the next
    section and check out one of the many books written on OpenGL. There are also
    many frameworks available, both 2D and 3D, for graphics and game development.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 OpenGL ES 配方，但我们只是刚刚触及了 OpenGL 的强大功能。如果你认真想学习 OpenGL，请查看下一节中的链接，并查看许多关于
    OpenGL 编写的书籍之一。还有许多框架可用于图形和游戏开发，包括 2D 和 3D。
- en: See also
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: '**OpenGL**: The Industry Standard for High-Performance Graphics: [https://www.opengl.org/](https://www.opengl.org/)'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL**: 高性能图形的行业标准：[https://www.opengl.org/](https://www.opengl.org/)'
- en: '**OpenGL ES**: The Standard for Embedded Accelerated 3D Graphics: [https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES**: 嵌入式加速 3D 图形的标准：[https://www.khronos.org/opengles/](https://www.khronos.org/opengles/)'
- en: '**Unreal Engine**: Android Quick Start: [https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unreal Engine**: Android 快速入门：[https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html](https://docs.unrealengine.com/latest/INT/Platforms/Android/GettingStarted/index.html)'
- en: '**libGDX**: Cross-platform Java game development framework based on OpenGL: [https://github.com/libgdx/libgdx](https://github.com/libgdx/libgdx)'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**libGDX**: 基于 OpenGL 的跨平台 Java 游戏开发框架：[https://github.com/libgdx/libgdx](https://github.com/libgdx/libgdx)'
