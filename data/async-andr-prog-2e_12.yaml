- en: Chapter 12. Asynchronous Programing with RxJava
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第12章. 使用RxJava进行异步编程
- en: In previous chapters, we have been using Android-based constructs such as `Loader`
    and `AsyncTask` to offload work from the main thread to low priority background
    threads.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们一直在使用基于Android的结构，如`Loader`和`AsyncTask`，将工作从主线程卸载到低优先级的后台线程。
- en: Although these straightforward constructs are able to deliver results that require
    intensive IO operations or network data, they don't provide out-of-the-box solutions
    for exception handling, task composition, and asynchronous event processing.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些直接的构造能够提供需要密集I/O操作或网络数据的成果，但它们不提供开箱即用的异常处理、任务组合和异步事件处理的解决方案。
- en: Beyond that, the popular `AsyncTask` construct is not able to deal with `Activity`
    or fragment configuration changes or cache results between configuration changes.
    Therefore, to cope with these kinds of problem, most of time the developer ends
    up creating a lot of extra code and complicated flows to handle the traits of
    these simple constructs.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，流行的`AsyncTask`结构无法处理`Activity`或片段配置更改或缓存配置更改之间的结果。因此，为了应对这类问题，大多数情况下开发者最终会创建大量的额外代码和复杂的流程来处理这些简单结构的特性。
- en: To simplify the development of composable asynchronous work, we will introduce
    you to `RxJava`, a functional framework that allow us to observe, transform, filter,
    and react to streams of events (click, touch, network, I/O events, and so on)
    in order to compose complex lines of execution that are able to react to errors
    and chain asynchronous computations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化可组合的异步工作开发，我们将向您介绍`RxJava`，这是一个函数式框架，它允许我们观察、转换、过滤并对事件流（点击、触摸、网络、I/O事件等）做出反应，以便组合能够响应错误和链式异步计算的复杂执行行。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to RxJava
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RxJava简介
- en: Creating Observables
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建Observables
- en: Transforming Observables
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换Observables
- en: Understanding Schedulers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解调度器
- en: Performing Asynchronous IO with Schedulers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用调度器执行异步I/O
- en: Composing Tasks with RxJava
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJava组合任务
- en: Observing UI events with RxJava
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJava观察UI事件
- en: Combining Tasks with RxJava
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用RxJava组合任务
- en: Working with Subjects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Subjects进行工作
- en: Introduction to RxJava
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava简介
- en: '`RxJava` is an implementation of Reactive Extensions (`ReactiveX`) on JVM,
    which was developed by Netflix and is used to compose asynchronous event processing
    that reacts to an observable source of events.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJava`是Reactive Extensions (`ReactiveX`)在JVM上的实现，由Netflix开发，用于组合对可观察事件源的异步事件处理。'
- en: The framework extends the `Observer` pattern by allowing us to create a stream
    of events that could be intercepted by operator (input/output) functions that
    modify the original stream of events and deliver the result or an error to a final
    `Observer`. This framework abstracts away concerns about things such as low-level
    threading, synchronization, thread safety, concurrent data structures, and non-blocking
    I/O.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架通过允许我们创建可以被操作（输入/输出）函数拦截的事件流来扩展`Observer`模式，这些函数可以修改原始事件流并将结果或错误传递给最终的`Observer`。该框架抽象掉了诸如低级线程、同步、线程安全、并发数据结构和非阻塞I/O等问题。
- en: There are three main basic building blocks that interact with each other in
    `RxJava` processing, the `Observable`, the `Observer`, and the `Subscriber`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RxJava`处理中，有三个主要的基本构建块相互作用，即`Observable`、`Observer`和`Subscriber`。
- en: An `Observable` is an entity that emits a sequence of events (zero or more events)
    of the generic type T (such as String or any Java type) at any point in time,
    or emits a `Throwable` when a failure occurs during the event processing. Beyond
    that, it provides methods to subscribe to its event stream and manage `Observer`
    subscriptions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`是一个实体，它在任何时间点可以发出类型为T（如String或任何Java类型）的事件序列（零个或多个事件），或者在事件处理过程中发生失败时发出`Throwable`。除此之外，它还提供了订阅其事件流和管理`Observer`订阅的方法。'
- en: A `Single` is a special kind of Observable that can only emit either a single
    success event value or an error event.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Single`是一种特殊的Observable，它只能发出单个成功事件值或错误事件。'
- en: 'An `Observer`, after registering as a subscriber, consumes the events of type
    `T` generated by the `Observable<T>`. An Observer must implement `Observer<T>`:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observer`，在注册为订阅者后，会消费由`Observable<T>`生成的类型为`T`的事件。一个`Observer`必须实现`Observer<T>`：'
- en: '[PRE0]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Any `Observer` will receive a callback to `onNext` whenever a new event is emitted
    by the Observable it's subscribed to until it receives `onCompleted` or `onError`
    to close the event stream.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 任何 `Observer` 都会在它订阅的 `Observable` 发出新事件时接收到 `onNext` 回调，直到它收到 `onCompleted`
    或 `onError` 以关闭事件流。
- en: 'A `Subscriber` is a helper abstract class you can use as your Observer''s base
    if you want subscription support. The `Subscriber` class provides methods to cancel
    the Observable subscription:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subscriber` 是一个辅助抽象类，如果你想要订阅支持，可以用作你的观察者的基类。`Subscriber` 类提供了取消 `Observable`
    订阅的方法：'
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '`unsubscribe` is the function used to cancel the `Observer` subscription. Therefore,
    once the `Observer` subscription is terminated, the Subscriber will no longer
    receive the events generated by the Observable.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`unsubscribe` 是用于取消 `Observer` 订阅的函数。因此，一旦 `Observer` 订阅被终止，订阅者将不再接收由 `Observable`
    生成的事件。'
- en: 'Here is a simple graph displaying the common interactions between an `Observable`
    and a `Subscriber`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个简单的图表，展示了 `Observable` 和 `Subscriber` 之间的常见交互：
- en: '![Introduction to RxJava](img/Image_B05062_12_01.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![RxJava 简介](img/Image_B05062_12_01.jpg)'
- en: The `onNext(T)` Observer's callback is invoked when a new item is emitted by
    the Observable.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `Observable` 发出一个新项目时，`onNext(T)` 观察者回调会被调用。
- en: The `onError(Throwable)` Observer's callback is invoked to notify that an error
    condition was found and the stream will be terminated.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当发现错误条件并且流将被终止时，`onError(Throwable)` 观察者回调会被调用以通知。
- en: The `onCompleted()` Observer's callback is invoked to indicate that the stream
    has completed successfully and all the events were delivered with success.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当流成功完成并且所有事件都成功传递时，`onCompleted()` 观察者回调会被调用以指示流已完成。
- en: Cold versus Hot Observable
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 冷与热 Observable
- en: An Observable can be classified as hot or cold based on the time that it starts
    emitting events. A cold Observable only starts emitting events to the Observers
    when an Observer subscribes to it. In this case, it is expected that the Observer
    will receive the stream from the beginning.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 根据 `Observable` 开始发出事件的时间，它可以被分类为热或冷。一个冷的 `Observable` 只有当观察者订阅它时才会开始向观察者发出事件。在这种情况下，预期观察者将接收到从开始到现在的流。
- en: A hot Observable will begin emitting events as soon as it gets created, so the
    Observer will only receive the events emitted after the subscription is created.
    The events emitted before the subscription will not be received by the Observer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 一个热的 `Observable` 会在创建后立即开始发出事件，因此观察者只会接收到订阅创建后发出的事件。在订阅之前发出的事件不会被观察者接收到。
- en: RxJava setup
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RxJava 设置
- en: 'Before we move further, let''s add the required libraries to your project.
    If you''re using Android Studio, just add the following dependencies to the module
    `build.gradle` script:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们将所需的库添加到你的项目中。如果你使用的是 Android Studio，只需将以下依赖项添加到模块 `build.gradle`
    脚本中：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '`rxjava` is a library that implements the Reactive Extensions ([http://reactivex.io/](http://reactivex.io/))
    on Java , and `rxandroid` is a library that adds classes to help write reactive
    components with `RxJava` in Android applications.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`rxjava` 是一个库，它实现了 Java 上的响应式扩展 ([http://reactivex.io/](http://reactivex.io/))，而
    `rxandroid` 是一个库，它为 Android 应用程序中用 `RxJava` 编写响应式组件添加了类。'
- en: Creating Observables
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 Observables
- en: To create an `Observable`, we can either create an `Observable` from scratch
    using the `create` function and calling Observer methods explicitly, or we can
    use built-in `Observable` creation methods that convert common data types to `Observable`
    streams.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个 `Observable`，我们可以使用 `create` 函数从头开始创建一个 `Observable` 并显式调用观察者方法，或者我们可以使用内置的
    `Observable` 创建方法，这些方法将常见的数据类型转换为 `Observable` 流。
- en: 'Let''s start with a simple example and create an observable that emits a `String`
    using the creating `Observable.from` operator:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的例子开始，创建一个使用创建 `Observable.from` 操作符发出 `String` 的 `Observable`：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Observable.from` static function creates `Observable` from an array that
    will synchronously emit `String` items to any Observer. The Observable created
    will be a cold Observable and will only start emitting events after an Observer
    subscribes to it.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable.from` 静态函数从一个数组创建 `Observable`，该数组将同步地将 `String` 项发出到任何观察者。创建的
    `Observable` 将是一个冷 `Observable`，并且只有在观察者订阅它之后才会开始发出事件。'
- en: 'Now, let''s create a `Subscriber` that consumes the data and prints each `String`
    to the Android Log until `Observable` invokes the `onComplete` callback:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个 `Subscriber`，它消费数据并将每个 `String` 打印到 Android 日志中，直到 `Observable` 调用
    `onComplete` 回调：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Next, with `Observable` and the subscriber class just defined, once we subscribe
    our `Subscriber` class on `Observable`, the `onNext()` function will be called
    three times passing each `String` in the Array, defined previously.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用`Observable`和刚刚定义的订阅者类，一旦我们在`Observable`上订阅了`Subscriber`类，`onNext()`函数将被调用三次，传递之前定义的数组中的每个`String`。
- en: 'Subsequently, after all the `Strings` are consumed by the `Subscriber`, the
    `onCompleted` function is called to close the stream:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 随后，在所有`Strings`都被`Subscriber`消费后，将调用`onCompleted`函数来关闭流：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Observable` instance is responsible for managing all subscriptions, notifying
    all its `Subscribers`, and it won't begin emitting items until we subscribe to
    them.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '`Observable`实例负责管理所有订阅，通知所有其`Subscribers`，并且它不会开始发射项目，直到我们订阅它们。'
- en: Apart from using `Observable.from` or another creation operator, we can create
    Observables by calling the `create` method and implementing `Observable.OnSubscribe<T>`
    that explicitly calls `onNext`, `onError`, and `onCompleted`.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用`Observable.from`或其他创建操作符之外，我们还可以通过调用`create`方法并实现`Observable.OnSubscribe<T>`来创建`Observable`，该实现明确调用`onNext`、`onError`和`onCompleted`。
- en: 'Let''s create our own `Observable` that emits integer numbers using the `create`
    function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建自己的`Observable`，使用`create`函数发射整数数字：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Remember that a well-behaved `Observable` must attempt to call either the observer's
    `onCompleted` or `onError` exactly once after emitting all the items by calling
    the subscriber's `onNext` function.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，一个表现良好的`Observable`必须在通过调用订阅者的`onNext`函数发射所有项目后，恰好一次尝试调用观察者的`onCompleted`或`onError`。
- en: Notice that the previous Observable is also classified as a cold Observable
    because it will only start emitting when a Subscriber entity subscribes to it.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，之前的`Observable`也被归类为冷`Observable`，因为它只有在有订阅者实体订阅它时才会开始发射。
- en: Alternatively, we can subscribe to `Observable` using `Action` functions to
    handle the items dispatched in different separated functions. All that you need
    to do is pass an `Action1<T>` function for event processing, an `Action1<Throwable>`
    for the error emission, and `Action0` to receive the stream completion notification.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用`Action`函数订阅`Observable`，以处理在不同分离的函数中分发的项目。你需要做的只是传递一个`Action1<T>`函数用于事件处理，一个`Action1<Throwable>`用于错误发射，以及`Action0`以接收流完成通知。
- en: 'Let''s write the required action functions that react to our `Observable<String>`
    emissions:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写所需的动作函数，以响应我们的`Observable<String>`发射：
- en: '[PRE7]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Beyond the `from` operator and the `create` operator functions there are other
    simple `Observable` functions that can be used to build `Observable`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`from`操作符和`create`操作符函数之外，还有其他简单的`Observable`函数可以用来构建`Observable`：
- en: '`Observable.just`: Creates an `Observable` from a short number of objects (Max
    10 Objects):'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.just`：从少量对象（最多10个对象）创建一个`Observable`：'
- en: '[PRE8]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`Observable.range`: Emits a range of numbers:'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Observable.range`：发射一系列数字：'
- en: '[PRE9]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Transforming Observables
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 转换`Observable`
- en: Apart from the ability to widely implement the `Observable-Subscribe` software
    pattern, the `RxJava` framework allows us to transform, filter, convert, aggregate,
    manipulate, and work with the stream of items emitted by `Observable` by using
    `Observable` operators. These entities are able to completely transform the event
    stream before the events are delivered to the final `Subscriber`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 除了广泛实现`Observable-Subscribe`软件模式的能力之外，`RxJava`框架还允许我们通过使用`Observable`操作符来转换、过滤、转换、聚合、操作和与`Observable`发射的项目流一起工作。这些实体能够在事件交付给最终的`Subscriber`之前完全转换事件流。
- en: '`RxJava` comes with a handy collection of operators that are able to transform
    the event''s content and control the time that the event is delivered.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJava`附带了一系列方便的操作符，能够转换事件的内容并控制事件交付的时间。'
- en: 'Let''s describe the most common operators available on `RxJava`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们描述在`RxJava`上可用的最常见操作符：
- en: '`map`: Applies a function to each item emitted and emits the result of the
    function as a new item.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`map`：对每个发射的项目应用一个函数，并将函数的结果作为新项目发射。'
- en: '`flatMap`: Applies a function to each item emitted by the source `Observable`
    where the function returns an `Observable` that could emit a different number
    of items or a different type of event.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flatMap`：对源`Observable`发射的每个项目应用一个函数，其中该函数返回一个`Observable`，该`Observable`可以发射不同数量的项目或不同类型的事件。'
- en: '`filter`: A transformation operator that uses a function that verifies if each
    item emitted by the source `Observable` satisfies a condition. If the condition
    passes the item, it is forwarded to the following `Subscriber`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`filter`: 一个转换操作符，它使用一个函数来验证源`Observable`发射的每个项目是否满足条件。如果条件通过，则项目被转发到后续的`Subscriber`。'
- en: '`first`: Emits only the first item emitted by the source `Observable`.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`first`: 仅发射源`Observable`发射的第一个项目。'
- en: '`count`: Emits the number of items received from the original `Observable`.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`count`: 发射从原始`Observable`接收到的项目数量。'
- en: '`zip`: Combines the emissions of two `Observables` using a function that receives
    the `N` item of each original `Observable` as an argument.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`zip`: 使用一个函数将两个`Observables`的发射合并，该函数接收每个原始`Observable`的`N`个项作为参数。'
- en: '`contains`: Emits a `Boolean` event that indicates whether the source `Observable`
    has a specified `Object`.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`contains`: 发射一个`Boolean`事件，指示源`Observable`是否包含指定的`Object`。'
- en: '`merge`: Merges the events of multiple `Observers` into one event stream.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`merge`: 将多个`Observers`的事件合并到一个事件流中。'
- en: '`delay`: Delays the emission of an item by a specified amount of time.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delay`: 通过指定的时间延迟发射一个项目。'
- en: For a more complete, detailed, and up-to-date list of operators supported by
    RxJava, check the `RxJava` Wiki on GitHub ([https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators](https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators)).
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取RxJava支持的完整、详细和最新的操作符列表，请查看GitHub上的`RxJava` Wiki（[https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators](https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators)）。
- en: The `RxJava` operators generally process an `Observable` and return an `Observable`.
    This design feature allows us to chain the operators and create a composed sequence
    of operators that transform the event stream. The last operator is responsible
    for delivering the items to the `Subscriber`, or deliver an error when something
    goes wrong.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`RxJava`操作符通常处理一个`Observable`并返回一个`Observable`。这个设计特性允许我们链式调用操作符，创建一个由操作符组成的转换事件流序列。最后一个操作符负责将项目传递给`Subscriber`，或者在出错时传递错误。'
- en: 'Now, let''s create our first operator example that transforms a multiline text
    emitted by the source Observable and delivers a new deliver an Integer with the
    number of lines that contain the word `RxJava`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们创建第一个操作符示例，该示例将转换源`Observable`发射的多行文本，并传递一个包含包含单词`RxJava`的行数的整数。
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To start, we create an `Observable` from the original using the `Observable.just`
    creation operator passing the text source as the unique object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用`Observable.just`创建操作符从原始数据创建一个`Observable`，并将文本源作为唯一对象传递。
- en: Next, to split the original text in to lines, we use the `flatMap` operator,
    which receives the original text emitted by the first `Observable` and returns
    a new `Observable` created from the sliced lines array.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了将原始文本拆分为行，我们使用`flatMap`操作符，它接收第一个`Observable`发射的原始文本，并返回一个由切片行数组创建的新`Observable`。
- en: The new `Observable` coming from the `flatMap` operator will emit a single `String`
    for each line available on the original content, therefore, in order to count
    the lines with the word `RxJava`, we will discard the lines that don't have the
    word using the filter operator.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 来自`flatMap`操作符的新`Observable`将为原始内容中的每一行发射一个单独的`String`，因此，为了计算包含单词`RxJava`的行数，我们将使用过滤操作符丢弃不包含该单词的行。
- en: To finish, we will count the number of events emitted and publish the results
    to a Subscriber that is expecting an integer as a result.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将计算发射的事件数量，并将结果发布给期望整数结果的`Subscriber`。
- en: 'Here is a graphical presentation of the previous functional pipeline:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前功能管道的图形表示。
- en: '![Transforming Observables](img/Image_B05062_12_02.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![转换Observables](img/Image_B05062_12_02.jpg)'
- en: Yes. The extensive set of transformation operators allows us to create a complex
    functional processing chain that is able to transform the data on the way and
    deliver results to any `Subscriber` object in a readable and functional way.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 是的。丰富的转换操作符集允许我们创建一个复杂的函数处理链，该链能够在数据传输过程中进行转换，并以可读和功能性的方式将结果传递给任何`Subscriber`对象。
- en: Understanding Schedulers
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解调度器
- en: There is an incorrect misconception and belief that `RxJava` processing is multithreaded
    by default. An `Observable` and the list of transformations applied by the specified
    operators occur on the same thread that the subscription is made.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 有一种错误的误解和信念，即`RxJava`处理默认是多线程的。`Observable`和由指定操作符应用的转换列表在订阅时发生的同一个线程上执行。
- en: Hence, on Android, if the subscription is carried out on the main thread, the
    operators chain processing will run on the main thread, blocking the UI until
    the work is done.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在 Android 上，如果订阅在主线程上执行，操作符链处理将在主线程上运行，直到工作完成才会阻塞 UI。
- en: While this behavior might work for lightweight processing tasks, when the operation
    requires IO interaction or CPU-intensive computing, the task execution might block
    the main `Thread` and crash the application with an ANR.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这种行为可能适用于轻量级处理任务，但当操作需要 IO 交互或 CPU 密集型计算时，任务执行可能会阻塞主 `Thread` 并导致应用程序崩溃，出现
    ANR。
- en: To simplify the asynchronous and concurrent executions, the `RxJava` framework
    allows us to define a `Scheduler` entity that defines the thread where a unit
    of work is executed.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化异步和并发执行，`RxJava` 框架允许我们定义一个 `Scheduler` 实体，该实体定义了工作单元执行的线程。
- en: The `subscribeOn(Scheduler)` operator allows us to set the Scheduler that defines
    the thread on which the subscription has been made and the Observable will start
    to operate.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn(Scheduler)` 操作符允许我们设置定义订阅已发生的线程和 Observable 将开始操作的 `Scheduler`。'
- en: When no Scheduler is specified, the Observable and operations will run on the
    thread that invoked the `subscribe` function.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果未指定 `Scheduler`，Observable 和操作将在调用 `subscribe` 函数的线程上运行。
- en: On Android, a `subscribe` function is typically invoked from an Android Activity
    or Fragment that runs on the main Thread, then if any operation takes a substantial
    amount of time to finish it will block the UI Thread and degrade the UI responsiveness.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 上，通常从运行在主线程上的 Android Activity 或 Fragment 中调用 `subscribe` 函数，然后如果任何操作需要大量时间才能完成，它将阻塞
    UI 线程并降低 UI 响应性。
- en: By controlling the thread where the subscription is made, we are controlling
    the thread where the Observable and its operators are going to execute and even
    the thread where the subscriber will receive the callbacks.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过控制订阅发生的线程，我们控制了 Observable 和其操作符将要执行的线程，甚至控制了订阅者将接收回调的线程。
- en: The `observeOn(Scheduler)` allows us to set the Scheduler that defines the thread
    in which the Observer callbacks (`onNext`, `onError`, `onCompleted`) are invoked.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`observeOn(Scheduler)` 允许我们设置定义回调（`onNext`、`onError`、`onCompleted`）调用的线程的 `Scheduler`。'
- en: During the Observable and operator chain, we can use `ObserveOn` several times
    to change the thread where the computation will run.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Observable 和操作符链中，我们可以多次使用 `ObserveOn` 来更改计算将运行的线程。
- en: 'To simplify `Scheduler` use, the `RxJava` and the `RxAndroid` library compiled
    a list of predefined `Schedulers` ready to be used to create multithreaded asynchronous
    chains:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 `Scheduler` 的使用，`RxJava` 和 `RxAndroid` 库编译了一个预定义的 `Schedulers` 列表，可以直接使用来创建多线程异步链。
- en: '`Schedulers.immediate()`: Default `Scheduler` that returns a `Scheduler` that
    executes the work immediately in the current thread.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.immediate()`: 默认 `Scheduler`，返回一个在当前线程中立即执行工作的 `Scheduler`。'
- en: '`Schedulers.trampoline()`: Returns a `Scheduler` that queues work in the current
    thread to be executed after the current work completes.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.trampoline()`: 返回一个 `Scheduler`，该 `Scheduler` 将当前线程中的工作排队，在当前工作完成后执行。'
- en: '`Schedulers.newThread()`: Returns a `Scheduler`, spawns a new thread, and executes
    the work on the new `Thread`.'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.newThread()`: 返回一个 `Scheduler`，创建一个新线程，并在新 `Thread` 上执行工作。'
- en: '`Schedulers.computation()`: Returns a `Scheduler` intended for computational
    intensive work. This can be used for event loops, processing callbacks, and other
    computational work. Do not perform blocking IO work on this `Scheduler`. This
    Scheduler uses a fixed thread pool size where the size is dependent on the CPUs
    to optimize CPU usage and minimize CPU switching.'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.computation()`: 返回一个用于计算密集型工作的 `Scheduler`。这可以用于事件循环、处理回调和其他计算工作。不要在此
    `Scheduler` 上执行阻塞 IO 工作。此 `Scheduler` 使用固定大小的线程池，其大小取决于 CPU 以优化 CPU 使用并最小化 CPU
    切换。'
- en: '`Schedulers.io()`: Creates and returns a `Scheduler` that executes the work
    of a cached pool of threads that grows and shrinks as needed, reusing already
    created threads that are idle to execute the require work. This `Scheduler` is
    intended for asynchronously performing blocking IO tasks, such as network or file
    system read and write.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Schedulers.io()`: 创建并返回一个 `Scheduler`，该 `Scheduler` 执行一个按需增长和缩小的线程池的工作，重用已创建的空闲线程来执行所需的工作。此
    `Scheduler` 旨在异步执行阻塞 IO 任务，如网络或文件系统读写。'
- en: '`Scheduler.from(Executor)`: Creates a Scheduler that will execute the unit
    of work on the `java.util.concurrent.Executor` passed as argument.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Scheduler.from(Executor)`: 创建一个将在作为参数传递的`java.util.concurrent.Executor`上执行工作单元的`Scheduler`。'
- en: '`AndroidSchedulers.mainThread()`: Creates a `Scheduler` that executes the required
    work on the Android application main thread. This Android `Scheduler`, provided
    by the `RxAndroid` library, is based on the `HandlerThread` that runs the unit
    of work serially.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AndroidSchedulers.mainThread()`: 创建一个在Android应用程序主线程上执行所需工作的`Scheduler`。这个由`RxAndroid`库提供的Android
    `Scheduler`基于运行工作单元的串行`HandlerThread`。'
- en: '`HandlerScheduler.from(Handler)`: Creates a Scheduler that executes work on
    a specified `Handler`. The `AndroidSchedulers.mainThread()` is of specialization
    of this `Scheduler` that runs on a `Handler` attached to the Android UI thread.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HandlerScheduler.from(Handler)`: 创建一个在指定的`Handler`上执行工作的`Scheduler`。`AndroidSchedulers.mainThread()`是这个`Scheduler`的一个特殊化，它在连接到Android
    UI线程的`Handler`上运行。'
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: By default, `Rxjava` uses `Schedulers.immediate()`, which subscribes to the
    Observer on the current thread and delivers the events in the current thread.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Rxjava`使用`Schedulers.immediate()`，它将观察者订阅到当前线程，并在当前线程上传递事件。
- en: RxJava allows us to define our own Scheduler, but for the scope of this book,
    we will only use the built-in Schedulers to cover our concurrency needs.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: RxJava允许我们定义自己的调度器，但就本书的范围而言，我们只会使用内置的调度器来满足我们的并发需求。
- en: Performing IO operations with Schedulers
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用调度器执行IO操作
- en: In the next example, we will use `Schedulers` to mirror the behavior of `AsyncTask`
    and retrieve text from the network on the background thread. Subsequently, the
    result will be published to a `Subscriber` that runs on the main `Thread`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个示例中，我们将使用`Schedulers`来模拟`AsyncTask`的行为，并在后台线程上从网络检索文本。随后，结果将发布到一个在主`Thread`上运行的`Subscriber`。
- en: 'First of all, we will create a function that creates an `Observable` that emits
    the `String` retrieved from the network:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个函数，该函数创建一个`Observable`，它发出从网络检索到的`String`：
- en: '[PRE11]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Before we specify the `Scheduler` used to run our asynchronous call, we need
    to state two assumptions:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们指定用于运行异步调用的`Scheduler`之前，我们需要声明两个假设：
- en: Since the code that runs on `Observable` performs a network operation we must
    run Observable on the background thread
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于在`Observable`上运行代码执行网络操作，我们必须在后台线程上运行`Observable`。
- en: To publish the result and update the UI, we must execute our Subscriber callbacks
    on the main `Thread`
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了发布结果并更新UI，我们必须在主`Thread`上执行我们的订阅者回调
- en: 'Now, let''s build up the asynchronous `RxJava` execution that retrieves the
    text and update the UI following the previous assumptions and using the `Scheduler`
    entities described earlier:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据之前的假设和前面描述的`Scheduler`实体来构建异步的`RxJava`执行，以检索文本并更新UI：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '`subscribeOn(Schedulers.io())` will make the `Observable` created by the `getTextFromNetwork`
    function run on the `Scheduler.io` thread pool intended for blocking IO operations.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribeOn(Schedulers.io())`将使由`getTextFromNetwork`函数创建的`Observable`在用于阻塞IO操作的`Scheduler.io`线程池上运行。'
- en: Once we call the subscribe function, `downloadText` will be queued to run on
    a thread managed by the `Scheduler` created by `Schedulers.io()`, emitting the
    results as a `String` in the `onNext()` function.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们调用`subscribe`函数，`downloadText`将被排队在由`Schedulers.io()`创建的`Scheduler`管理的线程上运行，在`onNext()`函数中以`String`的形式发出结果。
- en: The `observeOn(AndroidSchedulers.mainThread())` ensures that the Subscriber
    callbacks `onNext`, `onCompleted`, and `onError` will run on the Android main
    Thread. Therefore, if the network operation completes with success, `OnNext` is
    invoked updating EditText with the result obtained.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`observeOn(AndroidSchedulers.mainThread())`确保`Subscriber`回调`onNext`、`onCompleted`和`onError`将在Android主线程上运行。因此，如果网络操作成功完成，将调用`OnNext`更新EditText以显示获得的结果。'
- en: If any exception is thrown during the network execution, a `Throwable` object
    is delivered to the `Subscriber.onError` callback, which executes on the UI Thread,
    and a `Toast` that shows an error is displayed on the UI.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在网络执行过程中抛出任何异常，则将一个`Throwable`对象传递给`Subscriber.onError`回调，该回调在UI线程上执行，并在UI上显示一个显示错误的`Toast`。
- en: This example shows how simple and concise an asynchronous `call` can be on `RxJava`.
    Moreover, it abstracts you from the thread management as `AsyncTask` does and
    provides you exception handling facilities to deal with exceptional errors.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例展示了在`RxJava`上异步`call`是多么简单和简洁。此外，它抽象了您从线程管理中，就像`AsyncTask`所做的那样，并提供异常处理功能来处理异常错误。
- en: Canceling subscriptions
  id: totrans-124
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消订阅
- en: When an Activity or a Fragment gets destroyed, our chain could continue to run
    in the background, preventing the Activity from being disposed if the chain has
    references to the Activity or Fragment. When you no longer need the result of
    the chain, it could make sense to cancel the subscription and terminate the chain
    execution.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当活动（Activity）或片段（Fragment）被销毁时，我们的链式操作可能会在后台继续运行，如果链式操作中包含对Activity或Fragment的引用，则可能会阻止Activity被销毁。当你不再需要链式操作的结果时，取消订阅并终止链式操作执行是有意义的。
- en: 'When we call the `Observable.subscribe()` function, it returns a Subscription
    object that can be used to terminate the chain immediately:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`Observable.subscribe()`函数时，它返回一个Subscription对象，可以用来立即终止链式操作：
- en: '[PRE13]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Again, the most appropriate Activity lifecycle method for this is `onPause`,
    which is guaranteed to be called before the Activity finishes:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，对于这个任务来说，最合适的Activity生命周期方法是`onPause`，因为它在Activity完成之前一定会被调用：
- en: '[PRE14]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Composing Observables
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写可观察对象
- en: As we explained earlier, an `Observable` interface is defined in a way that
    allows us to chain and combine different `Observables` to create complex tasks
    in a functional and declarative way.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前解释的，`Observable`接口是以一种允许我们链式组合不同的`Observables`来以函数式和声明式的方式创建复杂任务的方式定义的。
- en: Starting from our previous work, in our next example, we will make use of the
    `RxJava` composing feature and execute a second network call that depends on the
    previous `Observable` that will translate the text downloaded using a web service
    before we emit the translated text to the `Subscriber`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前的工作开始，在我们的下一个示例中，我们将利用`RxJava`的组成特性，执行一个依赖于前一个`Observable`的第二个网络调用，该`Observable`将使用网络服务下载的文本进行翻译，在我们将翻译后的文本发射到`Subscriber`之前。
- en: 'To execute the translation on the network on a logically separate unit, we
    will create a new `Observable` that receives the text to translate, executes the
    task on the network, and emits the translated text as a String to the following
    `Observable`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在逻辑上独立的单元上执行网络翻译，我们将创建一个新的`Observable`，该`Observable`接收要翻译的文本，在网络中执行任务，并将翻译后的文本作为String类型输出给后续的`Observable`：
- en: '[PRE15]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we are ready to chain the network executions and display the results
    on the UI using the same `Subscriber` used previously:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们准备使用之前使用的相同`Subscriber`来链式执行网络操作并在UI上显示结果：
- en: '[PRE16]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The network IO operation defined on the `translateOnNetwork`, which depends
    on `getTextFromNetwork`, will only run if the previous operation finished with
    success, and takes the result from `getTextFromNetwork` as an argument.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在`translateOnNetwork`上定义的网络IO操作，它依赖于`getTextFromNetwork`，只有在前一个操作成功完成后才会运行，并将`getTextFromNetwork`的结果作为参数。
- en: After `translateOnNetwork Observable` receives the text content from the previous
    network operation, it will use it as input for its operation and will perform
    the translation of the previous content on the network, invoking the function
    `translateText(url, content)`.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在`translateOnNetwork Observable`接收到前一个网络操作中的文本内容后，它将使用这些内容作为其操作的输入，并在网络上对前一个内容进行翻译，调用函数`translateText(url,
    content)`。
- en: Given that `translateText()` finishes with success, the translated content is
    delivered to the next Observable. Since the next Observable is the Subscriber,
    the result is delivered transparently on the main Thread to update the UI.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`translateText()`成功完成，翻译后的内容被传递到下一个`Observable`。由于下一个`Observable`是`Subscriber`，结果在主线程上透明地传递，以更新UI。
- en: Besides that, since we override the `Subscriber` is `onError` function, if something
    goes wrong during the execution of either network requests, the error is propagated
    to our callback to be handled properly. Hence, with a few lines of code, we are
    able to inform the user that an asynchronous task has failed and we were not able
    to deliver the expected data to them.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，由于我们重写了`Subscriber`的`onError`函数，如果在执行网络请求的过程中出现错误，错误将被传播到我们的回调函数中，以便得到适当的处理。因此，通过几行代码，我们能够通知用户异步任务失败，并且我们未能将预期的数据传递给他们。
- en: Great, with a few lines of code we created a complex task that performs a chain
    of asynchronous network operations in the background, delivering the results on
    the main thread, or delivering an error when something goes wrong.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们用几行代码创建了一个复杂的任务，该任务在后台执行一系列异步网络操作，在主线程上交付结果，或者在出现错误时交付错误。
- en: Monitoring the event stream
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 监控事件流
- en: Although so far we have been using the `Observable` operators to manipulate
    stream events, there are operators that allow us to monitor the events without
    changing them. These operators, known sometimes as utility operators, are able
    to react to the events or errors emitted on the `Observable` chain created between
    the source `Observable` and the final `Subscriber` without creating any side effects.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然到目前为止我们一直在使用 `Observable` 操作符来操作流事件，但也有一些操作符允许我们监控事件而不改变它们。这些操作符有时被称为实用操作符，能够在源
    `Observable` 和最终 `Subscriber` 之间创建的 `Observable` 链上对事件或错误做出反应，而不产生任何副作用。
- en: 'Let''s enumerate them and explain the more common utility operators used to
    observe the event stream:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们列举它们并解释更常见的用于观察事件流的实用操作符：
- en: '`doOnSubscribe(Action0)`: Registers an `Action0` function to get called when
    a `Subscriber` subscribes to the `Observable`.'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnSubscribe(Action0)`：注册一个 `Action0` 函数，当 `Subscriber` 订阅 `Observable` 时调用。'
- en: '`doOnUnsubscribe(Action0)`: Registers an `Action0` function to get called when
    a `Subscriber` unsubscribes from the `Observable`.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnUnsubscribe(Action0)`：注册一个 `Action0` 函数，当 `Subscriber` 从 `Observable`
    取消订阅时调用。'
- en: '`doOnNext(Action1)`: Registers an `Action1` to be called when a new event is
    emitted from the source `Observable`. The Event `<T>` object is also passed as
    an argument to the `Action1` function.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnNext(Action1)`：注册一个 `Action1`，当源 `Observable` 发出新事件时调用。事件 `<T>` 对象也作为参数传递给
    `Action1` 函数。'
- en: '`doOnCompleted(Action0)`: Registers an `Action0` function to be called when
    the source `Observable` emits the `onComplete` event.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnCompleted(Action0)`：注册一个 `Action0` 函数，当源 `Observable` 发出 `onComplete`
    事件时调用。'
- en: '`doOnError(Action1)`: Registers an `Action1` function to be called when an
    error is emitted from the source `Observable`. The `Throwable` emitted on the
    `OnError` is also passed to the `Action1.call` function.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnError(Action1)`：注册一个 `Action1` 函数，当源 `Observable` 发出错误时调用。`OnError` 上发出的
    `Throwable` 也传递给 `Action1.call` 函数。'
- en: '`doOnTerminate(Action0)`: Registers an `Action0` function to be invoked when
    an error or `onComplete` is emitted by the source `Observable`. This callback
    function also means that the previous `Observable` will emit no more items.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doOnTerminate(Action0)`：注册一个 `Action0` 函数，当源 `Observable` 发出错误或 `onComplete`
    时调用。此回调函数还意味着之前的 `Observable` 将不再发出更多项目。'
- en: These multipurpose operators will allow us to observe and debug complex chains
    that usually involve several transformations, create progress dialogs to show
    progress, cache results, and even generate processing analytics.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这些多用途操作符将允许我们观察和调试通常涉及多个转换的复杂链，创建进度对话框显示进度，缓存结果，甚至生成处理分析。
- en: 'In our next example, we will make use of these operators to log the progress
    of our previous multi network operation in the Android Log, and to present a progress
    dialog on screen as long as the operation is progressing:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将使用这些操作符在 Android 日志中记录我们之前的多网络操作的进度，并在操作进行时在屏幕上显示进度对话框：
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As you know, to make changes in the Android UI, it is imperative to run your
    code on the main Thread. Hence, in order to receive `doOnNext` from the first
    `Observable` in the main thread, we invoke `subscribeOn()` with `AndroidSchedulers.mainThread()`
    forcing the first `Observable`, the one created with the `just` operator, to emit
    notifications to `doOnNext` in the main Thread.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，要在 Android UI 中进行更改，运行代码在主线程上至关重要。因此，为了在主线程中从第一个 `Observable` 接收 `doOnNext`，我们使用
    `subscribeOn()` 并传入 `AndroidSchedulers.mainThread()`，强制第一个 `Observable`（使用 `just`
    操作符创建的），向主线程中的 `doOnNext` 发送通知。
- en: As soon as `doOnNext()` receives the notification with the String carrying the
    URL to retrieve the text, we display ProgressDialog in the UI and we log a message
    in the Android Log.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `doOnNext()` 收到包含要检索文本的 URL 的字符串的通知，我们就在 UI 中显示进度对话框，并在 Android 日志中记录一条消息。
- en: Next, since we want to perform network operations off the main thread, using
    the `observeOn` operator, we force following `Observables` to send notifications
    to the threads managed by the `IO Scheduler`. This means that the following operators
    and `Observables` will execute and emit events in the IO `Scheduler` threads.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，由于我们想在主线程之外执行网络操作，使用 `observeOn` 操作符，我们强制后续 `Observable` 向由 `IO Scheduler`
    管理的线程发送通知。这意味着后续的操作符和 `Observable` 将在 IO `Scheduler` 线程中执行并发出事件。
- en: In the meantime, between each network operation, we intercept the start of the
    second network operation to print the message in Android with a `doOnNext` between
    `getTextFromNetwork` and `translateOnNetwork Observables`.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在每次网络操作之间，我们拦截第二个网络操作的开始，在`getTextFromNetwork`和`translateOnNetwork Observables`之间使用`doOnNext`打印Android中的消息。
- en: When the network operations finish, and before we update the UI with the results
    and we dismiss the progress dialog, we switch the execution to the main thread
    by again invoking the operator `observeOn()` with the main `Thread Scheduler`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 当网络操作完成时，在我们用结果更新UI并关闭进度对话框之前，我们再次通过调用带有主`Thread Scheduler`的`observeOn()`操作符将执行切换到主线程。
- en: Before we display the results on the screen, with the `doOnTerminate` operator
    we register an `Action` function to be called to dismiss the progress dialog previously
    started. As described before, the function will be invoked, whether the chain
    terminates with success or with an error.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们在屏幕上显示结果之前，使用`doOnTerminate`操作符注册一个`Action`函数，以便在之前启动的进度对话框中调用以关闭它。如前所述，无论链路以成功或错误结束，该函数都将被调用。
- en: At the end, the `Subscriber` callbacks will be invoked to update the UI with
    the results returned or to show an error message.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，将调用`Subscriber`回调来更新UI显示返回的结果或显示错误信息。
- en: 'If the network operation terminates with success you should see a similar logging
    stream in the Android Log:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果网络操作以成功结束，你应在Android日志中看到类似的日志流：
- en: '[PRE18]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For debugging purposes, `[<Thread_Name>]` shows the name of the thread that
    logged the message.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调试目的，`[<Thread_Name>]`显示了记录消息的线程名称。
- en: Combining Observables
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合Observables
- en: In the previous example, we used two `Observable` to create a simple sequence
    of network operations. The second asynchronous operation operated with the result
    of the first operation and the two operations that executed serially produced
    a String result that updates the UI.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们使用了两个`Observable`来创建一个简单的网络操作序列。第二个异步操作使用第一个操作的结果操作，这两个按顺序执行的操作产生了一个字符串结果，用于更新UI。
- en: In our next example, we will run two tasks in parallel and combine the results
    of both operations using a combining `RxJava` operator. Each operation will retrieve
    asynchronously a JSON Object from the network and combine both results in the
    JSON Object to produce the JSON `String` passed to the UI main `Thread`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将并行运行两个任务，并使用一个组合的`RxJava`操作符将两个操作的结果合并。每个操作将异步地从网络检索JSON对象，并将两个结果合并到JSON对象中，以生成传递给UI主`Thread`的JSON字符串。
- en: Since we only want to emit one Event or an error from the operation, we are
    going to use, for the first time, a special kind of Observer, `Single`.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们只想从操作中发出一个事件或错误，我们将首次使用一种特殊的观察者类型，即`Single`。
- en: 'While an `Observable` is able to invoke `onNext`, `onError`, and `onCompleted`
    Observer functions, a `Single` entity will only invoke either `onSuccess` or `onError`
    to a `SingleSubscriber`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`Observable`能够调用`onNext`、`onError`和`onCompleted`观察者函数，但`Single`实体将只调用`onSuccess`或`onError`到`SingleSubscriber`：
- en: '[PRE19]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: After one of the callback functions is called, the `Single` finishes and the
    subscription to it ends. Like a regular `Observable`, the `Single` object emitted
    event can be processed with operators before it reaches the final `SingleSubscriber`.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中一个回调函数被调用后，`Single`完成，对其的订阅结束。像常规`Observable`一样，`Single`对象发出的事件可以在到达最终的`SingleSubscriber`之前使用操作符进行处理。
- en: 'Now, let''s define the two `Single` operations that retrieve a single `JSONObject`
    from the network:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们定义两个从网络检索单个`JSONObject`的`Single`操作：
- en: '[PRE20]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Like we did for the previous `Observable`, we used the `Single.create` static
    function to build a custom `Single` entity that either explicitly calls the `SingleSubscriber.onSuccess`
    function when the network operation finishes with success, or calls the `SingleSubscriber.onError`
    function when an error is thrown on the `getJson` IO operation.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对之前的`Observable`所做的那样，我们使用了`Single.create`静态函数来构建一个自定义的`Single`实体，该实体在网络操作成功完成时显式调用`SingleSubscriber.onSuccess`函数，或者在`getJson`IO操作抛出错误时调用`SingleSubscriber.onError`函数。
- en: The `getJSON` function will basically retrieve a JSON Object by connecting to
    the HTTP URL provided as an argument and return a `JSONObject`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`getJSON`函数基本上通过连接到提供的HTTP URL来检索JSON对象，并返回一个`JSONObject`。'
- en: By forcing the Single to `subscribeOn` the `newThread Sheduler`, we are allowing
    each custom `Single` entity to run their operation concurrently on a new thread.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 通过强制将 `Single` 对象 `subscribeOn` 到 `newThread Scheduler`，我们允许每个自定义的 `Single`
    实体在新线程上并发运行它们的操作。
- en: Since the two operations will run in parallel, we need to use the combining
    operator to combine the `Single` results together in a single `JSONObject` and
    emit the resulting JSON `String` to the final `SingleSubscriber`. The appropriate
    combining operator for our example is zip, because it is able to wait for the
    result of two or more `Single/Observable` and apply a function to each `Single`
    output object.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个操作将并行运行，我们需要使用组合操作符将 `Single` 结果组合成一个单一的 `JSONObject`，并将生成的 JSON `String`
    发射到最终的 `SingleSubscriber`。对于我们的示例，合适的组合操作符是 `zip`，因为它能够等待两个或更多 `Single/Observable`
    的结果，并对每个 `Single` 输出对象应用一个函数。
- en: The function that receives the emitted objects as an argument can produce a
    result of the same type or of a different type.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 接收发射对象作为参数的函数可以产生相同类型或不同类型的结果。
- en: 'This is the `zip` operator function definition for combining two Singles into
    a `Single<R>`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将两个 `Single` 合并成一个 `Single<R>` 的 `zip` 操作符函数定义：
- en: '[PRE21]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In our example, `R` is a String, `T1` and `T2` are a `JSONObject`, and `zipFunction`
    receives the `JSONObjects` arguments to generate a `String` as the result.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，`R` 是一个 `String`，`T1` 和 `T2` 是 `JSONObject`，而 `zipFunction` 接收 `JSONObjects`
    参数以生成一个 `String` 作为结果。
- en: Now we are ready to use the `zip` operator and combine the result of each independent
    asynchronous operation into a `String`. The resulting string will update a `Widget`,
    so the final `Subscriber` should be invoked in the main Thread.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好使用 `zip` 操作符并将每个独立的异步操作的结果组合成一个 `String`。生成的字符串将更新一个 `Widget`，因此最终的
    `Subscriber` 应该在主线程中调用。
- en: 'Let''s write the functional code that fetches the `JSONObject` parts and dispatches
    the resulting `String` to the UI:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写获取 `JSONObject` 部分并将生成的 `String` 分派到 UI 的功能代码：
- en: '[PRE22]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Using the zip operator, we combined the result of the two operations, `postSingle`
    and `authorSingle`, that ran on a new thread created by the `newThread` Scheduler,
    on the `Func2` that received the two `JSONObjects` as arguments and produced a
    `String`.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `zip` 操作符，我们将两个操作的结果，`postSingle` 和 `authorSingle`，在由 `newThread` Scheduler
    创建的新线程上组合，在接收两个 `JSONObjects` 作为参数并生成 `String` 的 `Func2` 上。
- en: 'Since we subscribed the `Single` to work on its own Thread, the `zip` function
    will combine the result of both `Singles` on the thread built by the last defined
    Single (`authorSingle`) resulting in a log similar to the following output:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将 `Single` 订阅到在其自己的线程上工作，`zip` 函数将在由最后定义的 `Single` (`authorSingle`) 构建的线程上合并两个
    `Singles` 的结果，产生类似于以下输出的日志：
- en: '[PRE23]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After combining the objects, the `String` produced by `Func2` is delivered to
    the final `Subscriber` in the main `Thread`.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在合并对象后，`Func2` 生成的 `String` 将被发送到主 `Thread` 中的最终 `Subscriber`。
- en: 'All that remains is to implement the trivial `SingleSubscriber` that updates
    the UI:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的只是实现一个简单的 `SingleSubscriber` 来更新 UI：
- en: '[PRE24]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Observing UI Events with RxJava
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 RxJava 观察UI事件
- en: So far, we have been using `RxJava` to process and manipulate data streams,
    which simplified the development of asynchronous that require IO blocking operations
    that will hang the application for a while.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 `RxJava` 处理和操作数据流，这简化了需要 IO 阻塞操作并可能挂起应用程序一段时间的异步开发。
- en: In this section, we want to explain how to use `RxJava` and reactive streams
    to simplify the handling of UI events generated from Android Widgets.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们想要解释如何使用 `RxJava` 和响应式流来简化处理由 Android Widgets 生成的 UI 事件。
- en: In our next example, we will present a list of Soccer Teams with an instant
    search result input field. As you type in the input field, the names available
    in the list will be filtered if the text that you typed matches the beginning
    of any soccer team on the list.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的下一个示例中，我们将展示一个带有即时搜索结果输入字段的足球队伍列表。当你输入输入字段时，如果你输入的文本与列表中任何足球队伍的名称开头匹配，列表中的可用名称将被过滤。
- en: To achieve the result required, we will create a custom `Observable` that attaches
    a `TextWatcher` to the searching input field, listens for `onTextChanged` events,
    and emits a String event when the text changes.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到所需的结果，我们将创建一个自定义的 `Observable`，该 `Observable` 将 `TextWatcher` 绑定到搜索输入字段，监听
    `onTextChanged` 事件，并在文本更改时发射一个字符串事件。
- en: The Observer will feed a reactive functional stream that will filter our list
    of teams in a Recycler View.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者将提供一个响应式功能流，该流将过滤 Recycler View 中的队伍列表。
- en: 'First, we will write a Custom Observable that registers `TextWatcher` to `EditField`
    when an `Observer` subscribes, and deregisters `TextWatcher` when the subscription
    finishes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将编写一个自定义可观察对象，当 `Observer` 订阅时，它会将 `TextWatcher` 注册到 `EditField`，并在订阅结束时注销
    `TextWatcher`：
- en: '[PRE25]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `TextChangeOnSubscribe` class, which implements the `OnSubscribe<String>`
    and receives a subscription callback, will set a `TextWatcher` in the received
    `EditField` once the subscription is performed by the `Subscriber`.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 实现 `OnSubscribe<String>` 并接收订阅回调的 `TextChangeOnSubscribe` 类，一旦通过 `Subscriber`
    执行订阅，就会在接收到的 `EditField` 中设置一个 `TextWatcher`。
- en: When `TextWatcher.onTextChanged` is invoked to notify a text change in `EditField`,
    a new String event with the new content should be emitted in the Subscriber.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `TextWatcher.onTextChanged` 被调用以通知 `EditField` 中的文本更改时，应该在订阅者中发出一个新的包含新内容的字符串事件。
- en: To unregister the `TextWatcher` in the `EditField`, we add a `MainThreadSubscription`
    anonymous class to the subscriber list that removes our `TextChangeListener` in
    the `EditField`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `EditField` 中注销 `TextWatcher`，我们在订阅者列表中添加一个 `MainThreadSubscription` 匿名类，该类从
    `EditField` 中移除我们的 `TextChangeListener`。
- en: To prevent the text change event from generating too many updates in the UI,
    we used the `debounce` operator to only emit a new search term if there's been
    a 400 millisecond delay since the last text change event.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止文本更改事件在 UI 中生成过多的更新，我们使用了 `debounce` 操作符，只有在自上次文本更改事件以来有 400 毫秒的延迟时，才会发出新的搜索词。
- en: 'Next, we will use the search Events generated by our `Observable` to filter
    the teams available in the `ReciclerView` list:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使用由我们的可观察对象生成的搜索事件来过滤 `ReciclerView` 列表中的队伍：
- en: '[PRE26]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: To filter the soccer team list with the search term emitted by the `textChangeEvent`
    we applied the operator `combineLatest` to `textChangeObs` `Observable` and to
    the `Observable` created from the soccer team list with the operator just.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过 `textChangeEvent` 发射的搜索词过滤足球队伍列表，我们在 `textChangeObs` 可观察对象和通过 `just` 操作符创建的足球队伍列表的可观察对象上应用了
    `combineLatest` 操作符。
- en: The `combineLatest` will combine the latest item emitted by each `Observable`
    using a specified function and emit items based on the results of this function
    invocation.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`combineLatest` 将使用指定的函数组合每个可观察对象发出的最新项，并根据该函数调用的结果发出项。'
- en: The function that combines both `Observables` will simply filter the soccer
    list with the last text content emitted by the `onTextChanged` and sort the resulting
    list.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 组合这两个可观察对象的函数将简单地使用 `onTextChanged` 发出的最后文本内容过滤足球列表，并对结果列表进行排序。
- en: To finalize, a new `RecyclerView.Adapter` is created with the resulting `List<String>`
    and the filtered list of teams will be displayed to the user.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终完成，创建一个新的 `RecyclerView.Adapter`，使用结果 `List<String>`，并将过滤后的队伍列表显示给用户。
- en: Notice that to update our `RecyclerView` with the resulting filtered list, we
    explicitly set the `Observer` to run on the main Thread by passing the Android
    main Thread `Scheduler` to the `observeOn` operator.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了使用结果过滤列表更新我们的 `RecyclerView`，我们通过将 Android 主线程 `Scheduler` 传递给 `observeOn`
    操作符，显式地将 `Observer` 设置为在主线程上运行。
- en: Note
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Don't forget to terminate the subscription before the Activity is destroyed
    by calling `subcription.unsubscribe();`
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记在销毁 Activity 之前通过调用 `subcription.unsubscribe();` 终止订阅。
- en: Although, for educational purposes, we built our own Observables from the Android
    EditField Widget text change events, there is an easy-to-use, open source library
    named RxBinding ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding))
    that is able to create Observables for most Android Widgets available on the Android
    SDK.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管出于教育目的，我们是从 Android EditField 小部件的文本更改事件中构建了自己的可观察对象，但有一个易于使用的开源库名为 RxBinding
    ([https://github.com/JakeWharton/RxBinding](https://github.com/JakeWharton/RxBinding))，它能够为
    Android SDK 中大多数可用的 Android 小部件创建可观察对象。
- en: If you don't want to implement your own Observables, or process UI events in
    a traditional way, you can make use of it to process Android UI events using a
    functional RxJava reactive paradigm.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想实现自己的可观察对象，或者以传统方式处理 UI 事件，你可以利用它来使用功能性的 RxJava 反应式范式处理 Android UI 事件。
- en: Working with Subjects
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与主题一起工作
- en: 'So far, we have been working with `Observables`, `Subscriber`, `Observer`,
    and `Scheduler` entities to create our `RxJava` functional processing lines. In
    this section, we will introduce the reader to a new kind of entity in the `RxJava`
    framework, the `Subject`. The `Subject` is a sort of adapter or bridge entity
    that acts as an `Observable` and `Observer`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直在使用 `Observables`、`Subscriber`、`Observer` 和 `Scheduler` 实体来创建我们的 `RxJava`
    函数式处理流程。在本节中，我们将向读者介绍 `RxJava` 框架中的新实体，即 `Subject`。`Subject` 是一种适配器或桥梁实体，充当 `Observable`
    和 `Observer`：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Since it can act as a `Subscriber`, it can subscribe to one or more `Observables`
    that emit `Objects` of the generic type `T`, and since it acts as an `Observable`,
    it can emit events of the generic type `R` and receive subscriptions from other
    `Subscriber`. Hence, it can emit events of the same type as received or emit a
    different type of event.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它可以充当 `Subscriber`，它可以订阅一个或多个发出泛型类型 `T` 的 `Objects` 的 `Observables`，并且由于它充当
    `Observable`，它可以发出泛型类型 `R` 的事件并接收来自其他 `Subscriber` 的订阅。因此，它可以发出与接收相同类型的事件或发出不同类型的事件。
- en: For example, the `Subject<String, Integer>` will receive events of type `String`
    and emit events of the type `Integer`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Subject<String, Integer>` 将接收类型为 `String` 的事件并发出类型为 `Integer` 的事件。
- en: The `Subject` could receive the events from the `Observable` and generate a
    new event stream with different timings, proxy the events, convert to a new kind
    of event, queue the events, transform the events, or even generate new events.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 可以接收来自 `Observable` 的事件，并生成具有不同时序的新事件流，代理事件，转换为新的事件类型，排队事件，转换事件，甚至生成新事件。'
- en: A `Subject` is always considered a hot `Observable` and will begin emitting
    events as soon as it is created. This is a very important `Subject` feature and
    you should consider it when you want to process the full event stream sequence.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`Subject` 总是被视为热 `Observable`，并在创建后立即开始发出事件。这是一个非常重要的 `Subject` 功能，当你想要处理完整的事件流序列时，你应该考虑它。'
- en: '**RxJava** comes with some standard **Subject** classes designed to be used
    in distinctive use cases. The list below will enumerate the most common ones:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**RxJava** 包含一些标准 **Subject** 类，旨在用于不同的用例。以下列表将列举最常见的几个：'
- en: '`AsyncSubject`: Subjects that will only emit the last item emitted by the source
    `Observable` when the source `Observer` completes the stream by calling `onComplete()`'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncSubject`：只有当源 `Observer` 通过调用 `onComplete()` 完成流时，才会发出源 `Observable`
    最后发出的项目'
- en: '`PublishSubject`: The Subject only delivers to the Observers the events emitted
    after their subscription'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PublishSubject`：该 `Subject` 只向观察者传递订阅后发出的事件'
- en: '`ReplaySubject`: Emits all the events emitted by the source `Observable`, even
    those that were emitted before the subscription is made'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReplaySubject`：发出源 `Observable` 发出的所有事件，即使是在订阅之前发出的'
- en: '`BehaviorSubject`: Emits the last emitted item by the source `Observable` when
    the subscription is done, then continues to any other items emitted by the source
    observable'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`BehaviorSubject`：在订阅完成后，发出源 `Observable` 最后发出的项目，然后继续发出源 `Observable` 发出的其他任何项目'
- en: 'In the following example, we will show you how to use `PublishSubject` and
    demonstrate how the events are propagated to a final `Observer` that subscribes
    and later unsubscribes to the `Subject`. Moreover, we will submit events to `Subject`
    before and after the subscription is made:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将向您展示如何使用 `PublishSubject` 并演示事件如何传播到最终订阅并后来取消订阅 `Subject` 的 `Observer`。此外，我们将在订阅前后向
    `Subject` 提交事件：
- en: '[PRE28]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: First, we created the `PublishSubject` by calling the `PublishSubject.create`
    static function, and then we started delivering integers to it and calling the
    `onNext` function.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过调用 `PublishSubject.create` 静态函数创建了 `PublishSubject`，然后我们开始向其中传递整数并调用
    `onNext` 函数。
- en: In the meantime, we subscribed to the `Subject` with an `Action1` function in
    order to consume the events.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们使用 `Action1` 函数订阅了 `Subject` 以消费事件。
- en: To print the exact time when the subscription and unsubscription is made, we
    provided an `Action0` function to the `doOnUnsubscribe` and `doOnSubscribe` that
    prints a message to the Android Log.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了打印订阅和取消订阅的确切时间，我们向 `doOnUnsubscribe` 和 `doOnSubscribe` 提供了一个 `Action0` 函数，该函数将消息打印到
    Android 日志。
- en: 'As a result, the code above should output the following output:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，上面的代码应该输出以下结果：
- en: '[PRE29]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: As described before, only the events dispatched while the final `Observer` is
    subscribed are emitted to the `Action` callback. Therefore, the events submitted
    before the subscriptions and after the unsubscription are not received by our
    Subscriber.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，只有当最终的 `Observer` 订阅时发出的事件才会被发射到 `Action` 回调。因此，在订阅之前提交和取消订阅之后提交的事件不会被我们的
    `Subscriber` 接收。
- en: Now, for comparison, let's try to compare the event stream emitted by a `ReplaySubject`,
    with the exact sequence of events submitted to the Subject.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了比较，让我们尝试比较由 `ReplaySubject` 发射的事件流与提交给 Subject 的确切事件序列。
- en: 'Again, the `ReplaySubject` class was built by calling the create static function,
    and as a result, you should see the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，`ReplaySubject` 类是通过调用 `create` 静态函数创建的，因此你应该看到以下输出：
- en: '[PRE30]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: On the [http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)
    website, there are diagrams to help you understand graphically the interactions
    between Subjects, Subscribers, and source Observables.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [http://reactivex.io/documentation/subject.html](http://reactivex.io/documentation/subject.html)
    网站上，有一些图表可以帮助你直观地理解 Subject、Subscribers 和源 `Observable` 之间的交互。
- en: As expected, `ReplaySubject` will receive all the events submitted to the `Subject`,
    even the ones delivered before the subscription was made are received by the `Observer`.
    After the `Observer` unsubscribes, it stops receiving the events from the `Subject`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，`ReplaySubject` 会接收提交给 `Subject` 的所有事件，即使是那些在订阅之前提交的事件也会被 `Observer`
    接收。在 `Observer` 取消订阅后，它停止接收来自 `Subject` 的事件。
- en: As an exercise, you can try to create the same for the `AsyncSubject` and `BehaviorSubject`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，你可以尝试为 `AsyncSubject` 和 `BehaviorSubject` 创建相同的操作。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this final chapter, we learned how to use `RxJava`, an open source library
    that helps to process our Android application data or event streams using functional
    and reactive processing pipelines.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们学习了如何使用 `RxJava`，这是一个开源库，它帮助我们使用函数式和响应式处理管道处理 Android 应用程序的数据或事件流。
- en: In the first sections, we learned in detail some of `RxJava` basic building
    blocks—`Observable`, `Observer`, and `Subscriber`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们详细学习了 `RxJava` 的基本构建块——`Observable`、`Observer` 和 `Subscriber`。
- en: Next, we introduced some of `RxJava` most common operators that are able to
    manipulate, transform, and combine event streams generated by an `Observable`.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们介绍了一些 `RxJava` 最常见的操作符，这些操作符能够操作、转换和组合由 `Observable` 生成的事件流。
- en: In order to perform operations asynchronously and concurrently, we learned about
    the `Scheduler`, a magic `RxJava` entity that controls the concurrency, and is
    able to schedule `RxJava` units of work to run in background threads and feed
    the results back to the main Android Thread.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 为了执行异步和并发操作，我们学习了 `Scheduler`，这是一个神奇的 `RxJava` 实体，它控制并发，并且能够将 `RxJava` 工作单元调度到后台线程，并将结果反馈到主
    Android 线程。
- en: Next, using custom `Observables` and combining operators, we learned how to
    associate and compose interdependent complex blocking or long computing operations,
    such as REST API network operation.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过使用自定义 `Observables` 和组合操作符，我们学习了如何关联和组合相互依赖的复杂阻塞或长时间计算操作，例如 REST API 网络操作。
- en: In the meantime, we also learned how to react to a custom `Observable` that
    emits Android Widget UI events using a `RxJava` event functional pipeline.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们还学习了如何使用 `RxJava` 事件功能管道对发射 Android 小部件 UI 事件的自定义 `Observable` 进行响应。
- en: Finally, we learned about the `Subject` `RxJava` entity, an entity that can
    act as an `Observer` and `Observable` and can act as a proxy between our source
    `Observable` and the final `Observer`.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们了解了 `Subject` 是 `RxJava` 实体，它可以充当 `Observer` 和 `Observable`，并且可以作为我们的源
    `Observable` 和最终 `Observer` 之间的代理。
- en: Over the course of this book, we've armed ourselves with a powerful array of
    tools for building responsive Android applications. We discovered that it is incredibly
    important to move as much work as possible off the main thread, and explored a
    number of constructs and asynchronous techniques to make the smoothest and most
    awesome experience for your users.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的整个过程中，我们武装了自己，掌握了一系列强大的工具来构建响应式的 Android 应用程序。我们发现尽可能地将工作从主线程移除非常重要，并探讨了多种构造和异步技术，以提供最流畅和最酷的用户体验。
- en: Remember that to keep your application responsive and avoid any UI lost frames,
    an Android callback (`Service`, `Activity`, and so on) that runs on the main UI
    Thread should terminate in under 16 ms.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，为了保持应用程序的响应性并避免任何 UI 丢失帧，在主 UI 线程上运行的 Android 回调（`Service`、`Activity` 等）应该在
    16 毫秒内终止。
