- en: <st c="0">5</st>
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="0">5</st>
- en: <st c="2">Enhancing iOS Applications with WidgetKit</st>
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="2">使用WidgetKit增强iOS应用程序</st>
- en: <st c="43">As iPhones have evolved over the years, new capabilities have been
    added to take advantage of the big screen, the memory capacity, and the</st> <st
    c="183">powerful processor.</st>
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="43">随着iPhone这些年的发展，新增了功能以利用大屏幕、内存容量和</st> <st c="183">强大的处理器。</st>
- en: <st c="202">One of those capabilities is the home screen widgets – a great way
    to extend our apps and provide information and even interaction in</st> <st c="337">new
    places.</st>
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="202">这些功能之一是主屏幕小部件——扩展我们的应用程序并在</st> <st c="337">新位置提供信息和甚至交互的绝佳方式。</st>
- en: <st c="348">In this chapter, we will cover the</st> <st c="384">following topics:</st>
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="348">在本章中，我们将涵盖以下主题：</st>
- en: <st c="401">The idea</st> <st c="411">of widgets</st>
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="401">小部件的概念</st> <st c="411">是</st>
- en: <st c="421">Understanding how</st> <st c="440">widgets work</st>
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="421">了解小部件是如何</st> <st c="440">工作的</st>
- en: <st c="452">Add our first widget and build a timeline</st> <st c="495">of entries</st>
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="452">添加我们的第一个小部件并构建条目</st> <st c="495">时间线</st>
- en: <st c="505">Add a</st> <st c="512">user-configurable widget</st>
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="505">添加一个</st> <st c="512">用户可配置的小部件</st>
- en: <st c="536">Ensure our widgets are up</st> <st c="563">to date</st>
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="536">确保我们的小部件是最新的</st> <st c="563">的</st>
- en: <st c="570">Customize the</st> <st c="585">widget animations</st>
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="570">自定义小部件动画</st>
- en: <st c="602">Add user interactions such as buttons</st> <st c="641">and toggles</st>
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="602">添加用户交互，例如按钮</st> <st c="641">和开关</st>
- en: <st c="652">Add a control widget to the control center and</st> <st c="700">lock
    screen</st>
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: <st c="652">将控制小部件添加到控制中心和</st> <st c="700">锁屏</st>
- en: <st c="711">So, let’s start with the basics – what is the idea</st> <st c="763">of
    widgets?</st>
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="711">因此，让我们从基础知识开始——小部件的概念是什么？</st> <st c="763">是</st>
- en: <st c="774">Technical requirements</st>
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="774">技术要求</st>
- en: <st c="797">For this chapter, it’s essential to download Xcode version 15.0
    or higher from the</st> <st c="881">App Store.</st>
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="797">对于本章，从</st> <st c="881">App Store</st>下载Xcode版本15.0或更高版本是必要的。</st>
- en: <st c="891">Ensure you’re operating on the most recent version of macOS (Ventura
    or newer).</st> <st c="972">Just search for Xcode in the App Store, choose the
    latest version, and proceed with the download.</st> <st c="1070">Open Xcode and
    complete any further setup instructions that appear.</st> <st c="1138">After Xcode
    is completely up and running, you</st> <st c="1184">can begin.</st>
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="891">确保您正在运行最新版本的macOS（Ventura或更新版本）。</st> <st c="972">只需在App Store中搜索Xcode，选择最新版本，然后继续下载。</st>
    <st c="1070">打开Xcode并完成出现的任何进一步设置说明。</st> <st c="1138">在Xcode完全运行后，您</st> <st
    c="1184">就可以开始了。</st>
- en: <st c="1194">To gain additional capabilities, such as sharing data between the
    widget and the app, you must set up AppGroups and define your AppGroups in</st>
    <st c="1336">your profile.</st>
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1194">要获得额外的功能，例如在widget和应用程序之间共享数据，您必须在您的配置文件中设置AppGroups并定义您的AppGroups。</st>
- en: <st c="1349">Download the sample code from the following</st> <st c="1394">GitHub
    link:</st>
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1349">从以下</st> <st c="1394">GitHub链接</st>下载示例代码：
- en: '[<st c="1406">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '[<st c="1406">https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205</st>](https://github.com/PacktPublishing/Mastering-iOS-18-Development/tree/main/Chapter%205)'
- en: <st c="1492">The idea of widgets</st>
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="1492">小部件的概念</st>
- en: <st c="1512">Adding a widget is not a new concept in iOS or, in fact, in the</st>
    <st c="1577">Apple ecosystem.</st>
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1512">添加小部件不是iOS或，实际上，在</st> <st c="1577">苹果生态系统中</st>的新概念。
- en: <st c="1593">Widgets existed</st> <st c="1610">long ago in 2005 in the</st>
    *<st c="1634">Tiger</st>* <st c="1639">version of macOS, as part of the Dashboard
    feature.</st> <st c="1692">Apple took that idea and introduced</st> *<st c="1728">Today
    Widgets</st>* <st c="1741">in the</st> *<st c="1749">Notification Center</st>*
    <st c="1768">in iOS 8, and in iOS 14, Apple introduced the home screen widgets,
    similar to the widgets that already exist in the Android operating system.</st>
    <st c="1911">In iOS 18, Apple added the ability for third-party applications to
    add widgets to the control center and the</st> <st c="2020">home screen.</st>
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="1593">小部件早在2005年的*<st c="1634">Tiger</st>* <st c="1639">版本中就存在于macOS中，作为仪表板功能的一部分。</st>
    <st c="1692">苹果公司采纳了这个想法，并在iOS 8的*<st c="1728">Today Widgets</st>* <st c="1741">中引入了通知中心，而在iOS
    14中，苹果公司引入了主屏幕小部件，类似于Android操作系统中已经存在的小部件。</st> <st c="1911">在iOS 18中，苹果公司增加了第三方应用向控制中心和主屏幕添加小部件的能力。</st>
- en: <st c="2032">The idea of widgets is not to act as a full-blown application –
    widgets are not supposed to be a mini-version of our app or one of its screens,
    but rather an extension of our current</st> <st c="2216">app’s capabilities.</st>
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2032">小部件的理念不是作为一个完整的应用程序——小部件不应该是我们应用的迷你版本或其屏幕之一，而应该是我们当前应用功能的扩展。</st>
    <st c="2216">小部件的存在是为了增强用户便利性和生产力，总的来说，是提升整体体验。</st>
- en: <st c="2235">Widgets exist to enhance user convenience and productivity and,
    in general, the</st> <st c="2316">overall experience.</st>
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2235">小部件旨在提升用户便利性和生产力，通常来说，是提升整体体验。</st>
- en: <st c="2335">There are</st> <st c="2346">three key roles for widgets</st> <st
    c="2374">in iOS:</st>
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="2335">在iOS中，小部件有三个关键角色：</st>
- en: '**<st c="2381">Information at a glance</st>** <st c="2405">– Widgets provide
    up-to-date and important information to the user about our app.</st> <st c="2488">It
    can be a delivery status, stock values, event calendars, or any other information
    that is useful on a</st> <st c="2593">day-to-day basis.</st>'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2381">一目了然的信息**** <st c="2405">——小部件为我们应用的用户提供最新和重要的信息。</st> <st c="2488">这可能包括配送状态、股票价值、事件日历或任何其他在日常生活中有用的信息。</st>'
- en: '**<st c="2610">A shortcut to our app</st>** <st c="2632">– Tapping on a widget
    opens our app, and in many cases, a specific screen of our app.</st> <st c="2719">Opening
    our app using widgets is even more important in watchOS, where, unlike iOS, the
    springboard is not the user’s default view.</st> <st c="2851">For many app developers,
    it’s a great way of promoting their app and</st> *<st c="2920">fighting</st>*
    <st c="2928">for the user’s attention on the</st> <st c="2961">home screen.</st>'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2610">通往我们应用的捷径**** <st c="2632">——点击小部件可以打开我们的应用，在许多情况下，还可以打开我们应用的特定屏幕。</st>
    <st c="2719">在watchOS中，使用小部件打开我们的应用尤为重要，因为与iOS不同，watchOS的启动界面不是用户的默认视图。</st> <st
    c="2851">对于许多应用开发者来说，这是一种很好的推广他们应用的方式，并在主屏幕上*<st c="2920">争夺</st> <st c="2928">用户的注意力。</st>'
- en: '**<st c="2973">Performing basic actions</st>** <st c="2998">– Starting iOS
    17, Apple added interactive widgets, allowing users to perform basic actions without
    opening their app, such as completing a task, opening the garage door, or accepting
    a payment request.</st> <st c="3202">In iOS 18, this capability</st> <st c="3229">went
    even further, and it’s possible to add our widgets to the control center, or open
    them using the action button on iPhone</st> <st c="3355">15 devices.</st>'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="2973">执行基本操作**** <st c="2998">——从iOS 17开始，苹果公司增加了交互式小部件，允许用户在不打开应用的情况下执行基本操作，例如完成任务、打开车库门或接受支付请求。</st>
    <st c="3202">在iOS 18中，这一功能更进一步，我们甚至可以将小部件添加到控制中心，或者使用iPhone 15设备上的动作按钮打开它们。</st>'
- en: <st c="3366">Going over the different Apple platforms, we can see that the idea
    of showing information</st> <st c="3457">at a glance is widespread – we’ve got
    home and lock screen widgets, complications, and live activities in iOS, padOS,
    macOS,</st> <st c="3582">and watchOS.</st>
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3366">在回顾不同的苹果平台时，我们可以看到，**一目了然地展示信息**的想法非常普遍——在iOS、iPadOS、macOS和watchOS中，我们有主屏幕和锁定屏幕的小部件、复杂性和实时活动。</st>
- en: <st c="3594">For example, the Yahoo!</st> <st c="3619">Weather app shows the
    weather in the user’s current location and Apple’s Reminders app shows the user’s</st>
    <st c="3723">uncompleted reminders.</st>
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3594">例如，Yahoo!</st> <st c="3619">天气应用显示了用户当前位置的天气，而苹果的提醒应用显示了用户的未完成提醒。</st>
- en: <st c="3745">It’s only natural for Apple to straighten the line between the
    different platforms into a single framework –</st> *<st c="3855">WidgetK</st><st
    c="3862">it</st>*<st c="3865">.</st>
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3745">对于苹果来说，将不同平台之间的线条拉直成一个单一框架是顺理成章的——</st> *<st c="3855">WidgetK</st><st
    c="3862">it</st>*<st c="3865">。</st>
- en: <st c="3866">Understanding how widgets work</st>
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="3866">理解小部件的工作原理</st>
- en: <st c="3897">As mentioned at the beginning of this chapter, widgets are not
    mini applications.</st> <st c="3980">Instead, widgets are simple views that show
    relevant information and are updated according to a declared timeline or</st>
    <st c="4097">app events.</st>
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="3897">如本章开头所述，小部件不是迷你应用程序。</st> <st c="3980">相反，小部件是简单的视图，显示相关信息，并根据声明的**时间线**或**应用程序事件**进行更新。</st>
- en: <st c="4108">Widgets run</st> <st c="4121">on a different process than the app.</st>
    <st c="4158">They receive a runtime to perform any code, so they work as static
    views, showing pre-made information to our users.</st> <st c="4275">But, since
    our user’s data is being constantly updated, we can create an array of entries,
    each with information and a date.</st> <st c="4400">The</st> *<st c="4404">WidgetCenter</st>*
    <st c="4416">is responsible for creating a different view for each one of the
    entries, storing it, and replacing the</st> <st c="4521">widget UI according to
    the entries’ dates.</st> <st c="4564">This array of entries is called</st> <st
    c="4596">a</st> **<st c="4598">timeline</st>**<st c="4606">.</st>
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4108">小部件</st> <st c="4121">在不同于应用程序的进程中运行。</st> <st c="4158">它们接收运行时来执行任何代码，因此它们作为静态视图工作，向我们的用户展示预先准备好的信息。</st>
    <st c="4275">但是，由于我们的用户数据正在不断更新，我们可以创建一个条目数组，每个条目都包含信息和日期。</st> <st c="4400">*<st
    c="4404">WidgetCenter</st>* <st c="4416">负责为每个条目创建不同的视图，存储它，并根据条目的日期替换</st> <st
    c="4521">小部件UI</st>。</st> <st c="4564">这个条目数组被称为</st> <st c="4596">一个</st> **<st
    c="4598">时间线</st>**<st c="4606">。</st>
- en: <st c="4607">One good example is the</st> *<st c="4632">Next Event</st>* <st
    c="4642">widget.</st> <st c="4651">The</st> *<st c="4655">Next Event</st>* <st
    c="4665">widget shows the next event in our calendar, and since we have access
    to our user’s calendar, we can build a timeline and refresh the widget data based
    on the calendar event’s list.</st> <st c="4848">All we need to provide is the
    timeline including the different data for each</st> <st c="4925">timeline entry.</st>
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4607">一个很好的例子是</st> *<st c="4632">下一个事件</st>* <st c="4642">小部件。</st>
    <st c="4651">*<st c="4655">下一个事件</st>* <st c="4665">小部件显示我们日历中的下一个事件，由于我们可以访问用户的日历，我们可以根据日历事件列表构建时间线并刷新小部件数据。</st>
    <st c="4848">我们所需提供的只是包括每个</st> <st c="4925">时间线条目</st>的不同数据的**时间线**。</st>
- en: <st c="4940">Using a timeline to update the widget’s content makes the widget
    an extremely effective way to present information to the user, both in battery
    usage and</st> <st c="5095">processing time.</st>
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="4940">使用时间线来更新小部件的内容，使小部件成为一种极其有效的方式向用户展示信息，无论是在电池使用还是在</st> <st c="5095">处理时间</st>上。
- en: <st c="5111">However, the timeline also produces some challenges in the way
    we work with widgets because, unlike the</st> *<st c="5216">Next Event</st>* <st
    c="5226">widget, not every timeline can be built</st> <st c="5267">up front.</st>
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5111">然而，时间线也给我们与小部件一起工作的方式带来了一些挑战，因为与*<st c="5216">下一个事件</st>* <st c="5226">小部件</st>不同，并不是每个时间线都可以预先构建。</st>
- en: <st c="5276">But let’s wait before we dive into the solution to our problems
    and try to add our</st> <st c="5360">first widget.</st>
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5276">但在我们深入到解决问题的解决方案并尝试添加我们的</st> <st c="5360">第一个小部件</st>之前，让我们先等等。
- en: <st c="5373">Adding a widget</st>
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="5373">添加小部件</st>
- en: <st c="5389">Widgets operate</st> <st c="5406">and live outside of our app,
    therefor they are considered to be an</st> *<st c="5473">extension</st>* <st c="5482">of</st>
    <st c="5486">our app.</st>
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5389">小部件</st> <st c="5406">在应用程序外部运行和存在，因此它们被视为我们应用程序的</st> *<st c="5473">扩展</st>
    <st c="5482">之一</st>。</st>
- en: <st c="5494">To add a new widget – we need to a new</st> **<st c="5534">Widget
    Extension</st>** <st c="5550">target by selecting</st> **<st c="5571">File</st>**
    <st c="5575">-></st> **<st c="5579">New</st>** <st c="5582">-></st> **<st c="5586">Target…</st>**<st
    c="5593">.</st>
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5494">要添加一个新的小部件——我们需要通过选择**<st c="5534">小部件扩展</st>** <st c="5550">目标</st>来创建一个新的**<st
    c="5571">文件</st>** <st c="5575">-></st> **<st c="5579">新建</st>** <st c="5582">-></st>
    **<st c="5586">目标…</st>**<st c="5593">。</st>
- en: <st c="5594">Then, in the</st> **<st c="5608">Choose a template for your new
    target</st>** <st c="5645">window, we search for a widget and add the widget extension
    (see</st> *<st c="5711">Figure 5</st>**<st c="5719">.1</st>*<st c="5721">):</st>
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5594">然后，在</st> **<st c="5608">为您的新的目标选择一个模板</st>** <st c="5645">窗口中，我们搜索小部件并添加小部件扩展（见</st>
    *<st c="5711">图 5</st>**<st c="5719">.1</st>*<st c="5721">）：</st>
- en: '![Figure 5.1: The Choose a template for your new target window](img/B21795_05_1.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1：为您的新的目标窗口选择一个模板](img/B21795_05_1.jpg)'
- en: '<st c="5870">Figure 5.1: The Choose a template for your new target window</st>'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5870">图 5.1：为您的新的目标选择一个模板窗口</st>
- en: <st c="5930">After clicking on</st> **<st c="5949">Next</st>**<st c="5953">,
    we should provide a name for our widget, just like any target we add.</st> <st
    c="6025">In addition, uncheck the</st> *<st c="6050">Include Configuration App</st>*
    *<st c="6076">Intent</st>* <st c="6082">checkbox.</st>
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="5930">在点击</st> **<st c="5949">下一步</st>**<st c="5953">后，我们应该为我们的小部件提供一个名称，就像我们添加的任何目标一样。</st>
    <st c="6025">此外，取消选中</st> *<st c="6050">包含配置应用程序</st> * *<st c="6076">意图</st>
    * <st c="6082">复选框。</st>
- en: <st c="6092">Once the widget is added, we can see a new target with the name
    we provided.</st> <st c="6170">Xcode creates a few files for us as part of the
    widget template (assuming that the target name</st> <st c="6265">is</st> `<st
    c="6268">MyWidget</st>`<st c="6276">):</st>
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6092">一旦添加了小部件，我们就可以看到一个新的目标，其名称是我们提供的。</st> <st c="6170">Xcode 会为我们创建一些文件，作为小部件模板的一部分（假设目标名称</st>
    <st c="6265">是</st> `<st c="6268">MyWidget</st>`<st c="6276">）：</st>
- en: '`<st c="6279">MyWidgetBundle</st>` <st c="6294">– The widget bundle is a container
    for the different widgets our extension holds.</st> <st c="6377">Currently, we
    have only one widget, but it is possible to</st> <st c="6435">add more.</st>'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6279">MyWidgetBundle</st>` <st c="6294">– 小部件包是我们扩展所包含的不同小部件的容器。</st>
    <st c="6377">目前，我们只有一个小部件，但可以添加更多。</st>'
- en: '`<st c="6444">MyWidget</st>` <st c="6453">– Contains the widget code itself,
    including its UI</st> <st c="6506">and configuration.</st>'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6444">MyWidget</st>` <st c="6453">– 包含小部件代码本身，包括其 UI</st> <st c="6506">和配置。</st>'
- en: '`<st c="6524">Assets</st>` <st c="6531">– An asset catalog specifically for
    the</st> <st c="6572">widget extension.</st>'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6524">Assets</st>` <st c="6531">– 一个专门为小部件扩展设计的资产目录。</st>'
- en: '`<st c="6589">Info.plist</st>` <st c="6600">– Just like any target, the widget
    extension contains a</st> `<st c="6657">plist</st>` <st c="6662">file with general
    information about the</st> <st c="6703">widget extension.</st>'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="6589">Info.plist</st>` <st c="6600">– 就像任何目标一样，小部件扩展包含一个</st> `<st
    c="6657">plist</st>` <st c="6662">文件，其中包含有关小部件扩展的通用信息。</st>'
- en: <st c="6720">Now, it’s time to</st> <st c="6739">clarify what a widget is –
    the fact that we have different sizes for a widget doesn’t mean they are different
    widgets, as the same widget can have multiple sizes.</st> <st c="6902">A different
    widget is usually a different product, a different UI, and a different use case.</st>
    <st c="6995">In our case, the widget bundle describes the different widgets and
    not the different</st> <st c="7080">widget sizes.</st>
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="6720">现在，是时候</st> <st c="6739">阐明小部件是什么了——我们为小部件有不同的尺寸并不意味着它们是不同的小部件，因为相同的小部件可以有多个尺寸。</st>
    <st c="6902">不同的小部件通常是指不同的产品、不同的 UI 和不同的用例。</st> <st c="6995">在我们的案例中，小部件包描述了不同的小部件，而不是不同的小部件尺寸。</st>
- en: <st c="7093">Now that we have added a widget to our project, we can run our
    app and add the new widget to our springboard (</st>*<st c="7204">Figure 5</st>**<st
    c="7213">.2</st>*<st c="7215">):</st>
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7093">现在我们已经将小部件添加到我们的项目中，我们可以运行我们的应用程序并将新小部件添加到我们的启动板上（</st>*<st c="7204">图
    5</st>**<st c="7213">.2</st>*<st c="7215">）：</st>
- en: '![Figure 5.2: Our new template widget in the springboard](img/B21795_05_2.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2：在启动板中的我们的新模板小部件](img/B21795_05_2.jpg)'
- en: '<st c="7220">Figure 5.2: Our new template widget in the springboard</st>'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7220">图 5.2：在启动板中的我们的新模板小部件</st>
- en: <st c="7274">We can see in</st> *<st c="7289">Figure 5</st>**<st c="7297">.2</st>*
    <st c="7299">that the new widget consists of the current time and some emoji.</st>
    <st c="7365">This is a</st> <st c="7375">good time to play with it and to try
    adding additional</st> <st c="7430">widget sizes.</st>
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7274">我们可以在</st> *<st c="7289">图 5</st>**<st c="7297">.2</st>* <st c="7299">中看到，新的小部件由当前时间和一些表情符号组成。</st>
    <st c="7365">这是玩它并尝试添加额外的</st> <st c="7430">小部件尺寸的好时机。</st>
- en: <st c="7443">Configuring our widget</st>
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="7443">配置我们的小部件</st>
- en: <st c="7466">The way we set up our widget’s look and behavior is by determining
    its configuration.</st> <st c="7553">We have</st> <st c="7561">several configurations
    to work with, and they all conform to a protocol</st> <st c="7633">named</st>
    `<st c="7639">WidgetConfiguration</st>`<st c="7658">.</st>
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7466">我们设置小部件的外观和行为的方式是通过确定其配置。</st> <st c="7553">我们有</st> <st c="7561">几个配置可以工作，并且它们都符合一个名为</st>
    <st c="7633">WidgetConfiguration</st>`<st c="7658">。</st>
- en: <st c="7659">One of the configurations available for us is</st> `<st c="7706">StaticConfiguration</st>`<st
    c="7725">.</st> `<st c="7727">StaticConfiguration</st>` <st c="7746">allows us
    to create a widget that has no</st> <st c="7788">user-configurable options.</st>
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7659">我们可用的配置之一是</st> `<st c="7706">StaticConfiguration</st>`<st c="7725">。</st>
    `<st c="7727">StaticConfiguration</st>` <st c="7746">允许我们创建一个没有任何</st> <st c="7788">用户可配置选项的小部件。</st>
- en: <st c="7814">Let’s have a look at the</st> `<st c="7840">StaticConfiguration</st>`
    <st c="7859">that Xcode provides when we add a</st> <st c="7894">new widget:</st>
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="7814">让我们看看当我们在Xcode中添加一个新小部件时，它提供的</st> `<st c="7840">StaticConfiguration</st>`
    <st c="7859">。</st> <st c="7894">new widget:</st>
- en: '[PRE0]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: <st c="8230">We can</st> <st c="8238">see that</st> `<st c="8247">StaticConfiguration</st>`
    <st c="8266">has several properties shared with all configuration types.</st>
    <st c="8327">Let’s see them in</st> <st c="8345">depth, here:</st>
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8230">我们可以看到</st> `<st c="8247">StaticConfiguration</st>` <st c="8266">具有与所有配置类型共享的几个属性。</st>
    <st c="8327">让我们深入看看它们，如下所示：</st>
- en: '`<st c="8357">kind</st>` <st c="8362">– This is the widget configuration unique
    identifier.</st> <st c="8417">It helps us send requests to a specific widget configuration
    using</st> <st c="8484">the</st> *<st c="8488">WidgetCenter</st>*<st c="8500">.</st>'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8357">kind</st>` <st c="8362">– 这是小部件配置的唯一标识符。</st> <st c="8417">它帮助我们使用</st>
    *<st c="8488">WidgetCenter</st>*<st c="8500">向特定小部件配置发送请求。</st>'
- en: '`<st c="8501">configurationDisplayName</st>` <st c="8526">– This is the widget
    display name as it appears for the user when he wants to pick the right widget</st>
    <st c="8627">to add.</st>'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8501">configurationDisplayName</st>` <st c="8526">– 这是小部件显示名称，当用户想要选择要添加的正确小部件时，它将显示给用户。</st>
    <st c="8627">to add.</st>'
- en: '`<st c="8634">description</st>` <st c="8646">– This is the widget’s description
    that is shown to the user, next to its</st> <st c="8721">display name.</st>'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="8634">description</st>` <st c="8646">– 这是小部件的描述，它显示在用户旁边，紧邻其</st> <st
    c="8721">显示名称。</st>'
- en: <st c="8734">Besides these three parameters, we have additional important parameters.</st>
    `<st c="8807">supportedFamilies</st>` <st c="8825">determines the different sizes
    the widget supports.</st> <st c="8878">Here’s an example of how to limit the widget
    to appear only in</st> <st c="8941">medium size:</st>
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这三个参数之外，我们还有其他一些重要的参数。<st c="8734">supportedFamilies</st> <st c="8825">决定了小部件支持的尺寸。</st>
    <st c="8878">以下是一个如何限制小部件只以中等尺寸显示的示例：</st> <st c="8941">medium size:</st>
- en: '[PRE1]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: <st c="8988">Another property is</st> `<st c="9009">backgroundTask</st>`<st
    c="9023">, which allows our widget to perform a background operation when the
    system gives</st> <st c="9105">it time.</st>
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="8988">另一个属性是</st> `<st c="9009">backgroundTask</st>`<st c="9023">，它允许我们的小部件在系统给它时间时执行后台操作。</st>
- en: <st c="9113">Notice that</st> `<st c="9126">WidgetConfiguration</st>` <st c="9145">is
    just a protocol – when creating a widget, we need to return, in the widget body,
    a structure that conforms to that protocol, and</st> `<st c="9278">StaticConfiguration</st>`
    <st c="9297">is just one way to</st> <st c="9317">do that.</st>
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9113">注意</st> `<st c="9126">WidgetConfiguration</st>` <st c="9145">只是一个协议
    – 当创建小部件时，我们需要在组件体中返回一个符合该协议的结构，并且</st> `<st c="9278">StaticConfiguration</st>`
    <st c="9297">只是实现这一点的其中一种方式。</st>
- en: <st c="9325">Currently, there are three configurations available</st> <st c="9378">for
    us:</st>
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="9325">目前，我们有三种配置可供我们使用：</st> <st c="9378">for us:</st>
- en: '`<st c="9385">StaticConfiguration</st>` <st c="9405">– As mentioned earlier,
    this configuration allows us to create a non-user</st> <st c="9480">configurable
    widget</st>'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9385">StaticConfiguration</st>` <st c="9405">– 如前所述，此配置允许我们创建一个不可配置的小部件</st>'
- en: '`<st c="9499">AppIntentConfiguration</st>` <st c="9522">– This enables the
    user to customize their widget, for example, selecting a city for a weather widget,
    or a specific list for the</st> <st c="9653">reminders app</st>'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="9499">AppIntentConfiguration</st>` <st c="9522">– 这使用户能够自定义他们的小部件，例如，为天气小部件选择一个城市，或为</st>
    <st c="9653">提醒应用</st>'
- en: '`<st c="9666">ActivityConfiguration</st>` <st c="9688">– This configuration
    shows live data for the Live</st> <st c="9739">Activity widget</st>'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ActivityConfiguration>` – 这项配置显示了实时活动小部件的实时数据'
- en: <st c="9754">A widget can</st> <st c="9768">contain only one configuration.</st>
    <st c="9800">If we need to have more than one configuration, that’s a good sign
    we need to create several widgets with different configurations and share some
    of our code</st> <st c="9958">between them.</st>
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个小部件只能包含一个配置。如果我们需要多个配置，那么这是一个很好的迹象，表明我们需要创建具有不同配置的多个小部件，并在它们之间共享一些代码。
- en: <st c="9971">All these widget configurations sound exciting!</st> <st c="10020">Let’s
    start exploring them by starting with</st> <st c="10064">the</st> `<st c="10068">StaticConfiguration</st>`<st
    c="10087">.</st>
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些小部件配置听起来都很吸引人！让我们从探索`StaticConfiguration`开始。
- en: <st c="10088">Working with static configuration</st>
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作与静态配置
- en: <st c="10122">A static widget is a widget that has no user-configurable options.</st>
    <st c="10190">For example, a widget that shows</st> <st c="10223">the current
    time in a specific city cannot be static because the user needs to specify a city
    or a location for</st> <st c="10335">the widget.</st>
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个静态小部件是一个没有用户可配置选项的小部件。例如，一个显示特定城市当前时间的小部件不能是静态的，因为用户需要指定一个城市或位置来配置小部件。
- en: <st c="10346">However, a good example of a static widget is a calendar widget
    that shows a view of the whole month and marks the current day, or a music app
    widget that shows the songs that have been</st> <st c="10533">played recently.</st>
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一个静态小部件的好例子是一个显示整个月视图并标记当前日期的日历小部件，或者是一个显示最近播放的歌曲的音乐应用小部件。
- en: <st c="10549">Even though both the calendar and the music app widgets show information
    not updated by the user, they need to update themselves every once in</st> <st
    c="10693">a while.</st>
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管日历和音乐应用小部件显示的信息不是由用户更新的，但它们需要不时地更新自己。
- en: <st c="10701">If we look back at the static configuration example (in the</st>
    *<st c="10762">Configuring our widget</st>* <st c="10784">section), we can see
    a parameter called</st> `<st c="10825">provider</st>`<st c="10833">, which contains
    a parameter for the view builder closure</st> <st c="10891">named</st> `<st c="10897">entry</st>`<st
    c="10902">.</st>
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们回顾静态配置示例（在*《配置我们的小部件》*部分），我们可以看到一个名为`provider`的参数，它包含一个名为`entry`的视图构建器闭包参数。
- en: <st c="10903">Using</st> `<st c="10910">provider</st>` <st c="10918">and</st>
    `<st c="10923">entry</st>`<st c="10928">, we can provide data to our widget across
    time in an</st> <st c="10982">efficient way.</st>
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`provider`和`entry`，我们可以以高效的方式在时间上为我们的小部件提供数据。
- en: <st c="10996">One key aspect of Widgets is providing data over time, and we
    do that using the Timeline provider.</st> <st c="11096">Now, let’s understand
    what Timeline</st> <st c="11132">Provider means.</st>
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 小部件的一个关键方面是提供时间上的数据，我们使用时间线提供者来实现这一点。现在，让我们了解时间线提供者是什么意思。
- en: <st c="11147">Understanding the Timeline Provider for Widgets</st>
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解小部件的时间线提供者
- en: <st c="11195">There’s a reason why it took Apple almost 14 years to support
    widgets on the iOS home screen.</st> <st c="11290">The</st> <st c="11294">primary
    reason is performance, both power and memory performance.</st> <st c="11360">While
    today’s devices are highly capable, having numerous</st> <st c="11418">active
    widgets on the</st> *<st c="11440">Springboard</st>* <st c="11451">can consume
    a significant amount of power.</st> <st c="11495">Hence, we need to find more
    efficient ways to load our</st> <st c="11550">widgets efficiently.</st>
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个原因，为什么苹果公司花了近14年时间才在iOS主屏幕上支持小部件。主要原因是性能，包括电力和内存性能。虽然今天的设备功能强大，但在Springboard上拥有大量活动小部件会消耗大量的电力。因此，我们需要找到更有效的方法来高效地加载我们的小部件。
- en: <st c="11570">We mentioned efficiency in the</st> *<st c="11602">Understanding
    how widgets work</st>* <st c="11632">section, so let’s get down to the details.</st>
    <st c="11676">Unlike apps, widgets are not active even when they are visible.</st>
    <st c="11740">We can “wake” these widgets at specific times to reload their views.</st>
    <st c="11809">To set the specific periods, we need to create a timeline – an array
    of entries that contain points in time and</st> <st c="11921">relevant data.</st>
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11570">我们在</st> *<st c="11602">理解小部件如何工作</st>* <st c="11632">部分提到了效率，所以让我们深入细节。</st>
    <st c="11676">与应用不同，小部件即使在可见时也不是活跃的。</st> <st c="11740">我们可以在特定时间“唤醒”这些小部件以重新加载它们的视图。</st>
    <st c="11809">为了设置特定时间段，我们需要创建一个时间线 – 一个包含时间点和相关数据的条目数组。</st> <st c="11921">创建一个更长的时线可以最大化我们小部件的更新频率。</st>
- en: <st c="11935">For example, if we want to reload a calendar widget that displays
    the next event, we can create a timeline that holds an array of entries, one for
    each event.</st> <st c="12095">Each entry holds an event time and the name of
    the event that</st> <st c="12157">comes afterward.</st>
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="11935">例如，如果我们想重新加载显示下一个事件的日历小部件，我们可以创建一个包含每个事件的条目的时间线。</st> <st c="12095">每个条目包含事件时间和随后发生的事件名称。</st>
- en: <st c="12173">Conversely, if we want a calendar widget that displays full-day
    information, we may want to create a timeline with an entry for each day.</st>
    <st c="12312">In this case, each entry holds the time of the beginning of the
    day and the list of events</st> <st c="12403">that day.</st>
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12173">相反，如果我们想创建一个显示全天信息的日历小部件，我们可能需要为每一天创建一个包含条目的时间线。</st> <st c="12312">在这种情况下，每个条目包含一天开始的时间和当天的活动列表。</st>
- en: <st c="12412">Creating a longer timeline can maximize the frequency of updates
    for</st> <st c="12482">our widget.</st>
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12412">创建一个更长的时线可以最大化我们小部件的更新频率。</st>
- en: <st c="12493">Now, let’s turn to code and create our first timeline.</st> <st
    c="12549">Here is an example of a timeline provider that displays the</st> <st
    c="12609">next event:</st>
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="12493">现在，让我们转向代码并创建我们的第一个时间线。</st> <st c="12549">以下是一个显示下一个事件的时线提供者的示例：</st>
- en: '[PRE2]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: <st c="13275">The preceding code consists of two structs –</st> `<st c="13321">EventEntry</st>`
    <st c="13331">and</st> `<st c="13336">Provider</st>`<st c="13344">.</st>
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13275">前面的代码包含两个结构体 –</st> `<st c="13321">EventEntry</st>` <st c="13331">和</st>
    `<st c="13336">Provider</st>`<st c="13344">.</st>
- en: '`<st c="13345">EventEntry</st>` <st c="13356">is a struct that conforms to</st>
    `<st c="13386">TimeLineEntry</st>` <st c="13399">protocol.</st> <st c="13410">The</st>
    `<st c="13414">TimeLineEntry</st>` <st c="13427">protocol represents a single
    entry in the widget timeline.</st> <st c="13487">The protocol contains a required
    variable</st> <st c="13529">named date:</st>'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="13345">EventEntry</st>` <st c="13356">是一个符合</st> `<st c="13386">TimeLineEntry</st>`
    <st c="13399">协议的结构体。</st> <st c="13410">`<st c="13414">TimeLineEntry</st>` <st
    c="13427">`协议表示小部件时间线中的单个条目。</st> <st c="13487">该协议包含一个必需的变量</st> <st c="13529">名为
    date:</st>'
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: <st c="13563">The</st> `<st c="13568">date</st>` <st c="13572">variable contains
    the entry point in time where we expect our widget to reload.</st> <st c="13653">Other
    than</st> `<st c="13664">date</st>`<st c="13668">, we added another variable that
    represents the entry’s next event title</st> <st c="13741">named</st> `<st c="13747">nextEvent</st>`<st
    c="13756">.</st>
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13563">`<st c="13568">date</st>` <st c="13572">变量包含我们期望小部件重新加载的时间点。</st>
    <st c="13653">除了`<st c="13664">date</st>`<st c="13668">`之外，我们还添加了一个表示条目下一个事件标题的变量，名为`<st
    c="13741">nextEvent</st>`<st c="13756">`。</st>
- en: <st c="13757">Our second</st> <st c="13769">struct is</st> `<st c="13779">Provider</st>`<st
    c="13787">. The</st> `<st c="13793">Provider</st>` <st c="13801">struct conforms
    to</st> `<st c="13821">TimeLineProvider</st>`<st c="13837">. The goal of the</st>
    `<st c="13855">Provider</st>` <st c="13863">struct is to generate a timeline so
    the</st> *<st c="13904">WidgetCenter</st>* <st c="13916">can reload the widget
    when needed.</st> <st c="13952">Let’s see how the</st> `<st c="13970">Provider</st>`
    <st c="13978">does that.</st>
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="13757">我们的第二个结构体是`<st c="13769">Provider</st>`<st c="13787">`。`<st c="13793">Provider</st>`
    <st c="13801">结构体符合`<st c="13821">TimeLineProvider</st>`<st c="13837">`。`<st c="13855">Provider</st>`
    <st c="13863">结构体的目的是生成一个时间线，以便`<st c="13904">WidgetCenter</st>` <st c="13916">在需要时重新加载小部件。</st>
    <st c="13952">让我们看看`<st c="13970">Provider</st>` <st c="13978">是如何做到这一点的。</st>
- en: <st c="13989">Generating a timeline</st>
  id: totrans-95
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="13989">生成时间线</st>
- en: <st c="14011">I mentioned earlier that a timeline is an array of timeline entries,
    but the reality is a little bit more</st> <st c="14118">complex than that.</st>
    <st c="14137">Looking at the timeline provider implementation, we can see several
    functions that help us to deliver a static UI at any</st> <st c="14258">given
    time.</st>
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14011">我之前提到时间线是一系列时间线条目，但实际情况要复杂一些。</st> <st c="14118">查看时间线提供者实现，我们可以看到几个函数，这些函数可以帮助我们在任何给定时间提供静态UI。</st>
- en: <st c="14269">The Provider struct is a protocol implementation</st>
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14269">Provider结构是一个协议实现</st>
- en: <st c="14318">There’s no</st> <st c="14330">need to call the</st> `<st c="14347">Provider</st>`
    <st c="14355">functions directly.</st> <st c="14376">We pass the timeline provider
    to the widget configuration, and the configuration uses the</st> `<st c="14466">Provider</st>`
    <st c="14474">functions</st> <st c="14485">when needed.</st>
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14318">没有必要直接调用</st> `<st c="14347">Provider</st>` <st c="14355">函数。</st>
    <st c="14376">我们将时间线提供者传递给组件配置，配置在需要时使用</st> `<st c="14466">Provider</st>` <st
    c="14474">函数。</st>
- en: <st c="14497">The first and primary function is</st> `<st c="14532">getTimeLine</st>`<st
    c="14543">. Let’s look at the implementation of the</st> `<st c="14585">getTimeline</st>`
    <st c="14596">function here:</st>
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14497">第一个和主要的功能是</st> `<st c="14532">getTimeLine</st>`<st c="14543">。让我们看看</st>
    `<st c="14585">getTimeline</st>` <st c="14596">函数的实现：</st>
- en: '[PRE4]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: <st c="14833">The</st> `<st c="14838">getTimeline()</st>` <st c="14851">function</st>
    <st c="14861">creates an array of entries, wraps them in a</st> `<st c="14906">Timeline</st>`
    <st c="14914">struct, and returns it using the</st> `<st c="14948">completion</st>`
    <st c="14958">closure.</st> <st c="14968">There</st> <st c="14974">are two interesting
    things</st> <st c="15001">we can see here – the</st> `<st c="15023">Context</st>`
    <st c="15030">parameter and the</st> **<st c="15049">Timeline</st>** **<st c="15058">reload
    policy</st>**<st c="15071">:</st>
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="14833">`<st c="14838">getTimeline()</st>` <st c="14851">函数</st> <st c="14861">创建一个条目数组，将其包装在一个</st>
    `<st c="14906">Timeline</st>` <st c="14914">结构中，并使用</st> `<st c="14948">completion</st>`
    <st c="14958">闭包返回它。</st> <st c="14968">这里有两个有趣的地方可以观察 –</st> `<st c="15023">Context</st>`
    <st c="15030">参数和</st> **<st c="15049">Timeline</st>** **<st c="15058">重载策略</st>**<st
    c="15071">：</st>
- en: '`<st c="15073">Context</st>` <st c="15080">– The</st> `<st c="15087">Context</st>`
    <st c="15094">parameter contains information about the widget environment, such</st>
    <st c="15161">as the widget family (is it a small widget?</st> <st c="15205">Perhaps
    medium?), or the actual widget size.</st> <st c="15250">If the widget UI shows
    more information when it is large, we probably want to load more data into our
    timeline entry.</st> <st c="15368">But the most important information here is
    probably the</st> `<st c="15424">isPreview</st>` <st c="15433">property, which
    indicates whether the widget appears in the widget gallery.</st> <st c="15510">Generally
    speaking, it is best practice to show real user data in our widget in the widget
    gallery, but that’s not only possible due to security or networking issues.</st>
    <st c="15677">Therefore, we can provide mock data for the widget gallery by checking
    the</st> `<st c="15752">isPreview</st>` <st c="15761">property.</st>'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15073">上下文</st>` <st c="15080">–</st> `<st c="15087">Context</st>`
    <st c="15094">参数包含有关小部件环境的信息，例如小部件系列（它是一个小部件吗？</st> <st c="15161">也许是一个中等大小的？），或者实际的小部件大小。</st>
    <st c="15250">如果小部件UI在大尺寸时显示更多信息，我们可能希望将更多数据加载到我们的时间线条目中。</st> <st c="15368">但这里最重要的信息可能是</st>
    `<st c="15424">isPreview</st>` <st c="15433">属性，它指示小部件是否出现在小部件库中。</st> <st c="15510">一般来说，在组件库中展示我们的组件的真实用户数据是最佳实践，但这并不仅限于安全或网络问题。</st>
    <st c="15677">因此，我们可以通过检查</st> `<st c="15752">isPreview</st>` <st c="15761">属性来为组件库提供模拟数据。</st>'
- en: '`<st c="15771">policy</st>` <st c="15778">– The timeline we provide to our
    widget has a final number of entries.</st> <st c="15850">So, what happens when
    they are done, and the timeline reaches its end?</st> <st c="15921">That’s exactly
    the</st> <st c="15940">role of the</st> `<st c="15952">policy</st>` <st c="15958">parameter
    when it describes the timeline reload behavior.</st> <st c="16017">There are several
    options –</st> `<st c="16045">atEnd</st>` <st c="16050">(</st>*<st c="16052">WidgetKit</st>*
    <st c="16062">requests a new timeline),</st> `<st c="16088">never</st>` <st c="16093">(</st>*<st
    c="16095">WidgetKit</st>* <st c="16105">doesn’t ask for a new timeline), and</st>
    `<st c="16142">after(date:Date)</st>` <st c="16158">(</st>*<st c="16160">WidgetKit</st>*
    <st c="16170">generates a new timeline in a specific date).</st> <st c="16216">The
    policy helps the</st> *<st c="16237">WidgetCenter</st>* <st c="16249">to optimize
    the timeline reloading</st> <st c="16285">mechanism better.</st>'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="15771">策略</st>` `<st c="15778">– 我们提供给小部件的时间线有一个最终条目数。</st>` `<st c="15850">那么，当它们完成，时间线达到其尽头时会发生什么？</st>`
    `<st c="15921">这正是</st>` `<st c="15940">策略</st>` `<st c="15952">参数在描述时间线重新加载行为时的作用。</st>`
    `<st c="16017">有几个选项 –</st>` `<st c="16045">atEnd</st>` `<st c="16050">(</st>`
    `<st c="16052">WidgetKit</st>` `<st c="16062">请求一个新的时间线)，</st>` `<st c="16088">never</st>`
    `<st c="16093">(</st>` `<st c="16095">WidgetKit</st>` `<st c="16105">不请求一个新的时间线)，以及</st>`
    `<st c="16142">after(date:Date)</st>` `<st c="16158">(</st>` `<st c="16160">WidgetKit</st>`
    `<st c="16170">在特定日期生成一个新的时间线)。</st>` `<st c="16216">策略有助于</st>` `<st c="16237">WidgetCenter</st>`
    `<st c="16249">更好地优化时间线重新加载机制。</st>'
- en: <st c="16302">Before we continue, a few words about timeline reloading optimization.</st>
    <st c="16374">The fact that we want to build our timeline as long as possible
    doesn’t mean that our widget needs to constantly reload.</st> <st c="16495">The</st>
    *<st c="16499">WidgetCenter</st>* <st c="16511">has a “budget” for each widget
    on the home screen, specifying times during the day when it performs refreshes.</st>
    <st c="16623">It’s in our interest to optimize the way our timeline is structured
    and to “save” the system budget.</st> <st c="16724">Carefully planning the timeline
    entries and reload policy can help us achieve relevant, event-driven</st> <st
    c="16825">refresh intervals.</st>
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16302">在我们继续之前，关于时间线重新加载优化的几点说明。</st>` `<st c="16374">我们希望尽可能长地构建我们的时间线并不意味着我们的小部件需要不断重新加载。</st>`
    `<st c="16495">*<st c="16499">WidgetCenter</st>` `<st c="16511">为每个主屏幕上的小部件都有一个“预算”，指定一天中它执行刷新的时间。</st>`
    `<st c="16623">优化我们的时间线结构和“节省”系统预算符合我们的利益。</st>` `<st c="16724">精心规划时间线条目和重新加载策略可以帮助我们实现相关的事件驱动</st>`
    `<st c="16825">刷新间隔。</st>`'
- en: <st c="16843">Going back to the</st> `<st c="16862">TimelineProvider</st>` <st
    c="16878">protocol, we can see additional two functions –</st> `<st c="16927">placeholder</st>`
    <st c="16938">and</st> `<st c="16943">getSnapshot</st>`<st c="16954">. Let’s</st>
    <st c="16962">implement them.</st>
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16843">回到</st>` `<st c="16862">TimelineProvider</st>` `<st c="16878">协议，我们可以看到另外两个函数
    –</st>` `<st c="16927">placeholder</st>` `<st c="16938">和</st>` `<st c="16943">getSnapshot</st>`
    `<st c="16954">。让我们</st>` `<st c="16962">实现它们。</st>`'
- en: <st c="16977">The first function is</st> `<st c="17000">getTimeline</st>`<st
    c="17011">, which returns a</st> `<st c="17029">Timeline</st>` <st c="17037">structure
    containing a list of entries with actual data for specific periods.</st> <st c="17116">But
    is it enough for our widget to be</st> <st c="17154">fully functional?</st>
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="16977">第一个函数是</st>` `<st c="17000">getTimeline</st>` `<st c="17011">，它返回一个</st>`
    `<st c="17029">Timeline</st>` `<st c="17037">结构，其中包含特定时间段的实际数据条目列表。</st>` `<st
    c="17116">但这是否足以让我们的小部件完全功能正常？</st>`'
- en: <st c="17171">The answer is no – there are two more cases when providing actual
    data may not</st> <st c="17251">be sufficient.</st>
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17171">答案是：不——在提供实际数据可能不足以满足的两种情况下。</st>`'
- en: <st c="17265">The</st> `<st c="17270">placeholder</st>` <st c="17281">function
    answers the first use case.</st> <st c="17319">When the user adds a widget to
    their home screen,</st> *<st c="17369">WidgetKit</st>* <st c="17379">needs to
    display something immediately, before the widget fetches</st> <st c="17445">or
    updates real data from our app.</st> <st c="17480">The</st> `<st c="17484">placeholder</st>`
    <st c="17495">function returns temporary data just to show something to</st> <st
    c="17554">the user:</st>
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="17265">*<st c="17270">placeholder</st>` `<st c="17281">函数解决了第一个用例。</st>`
    `<st c="17319">当用户将小部件添加到他们的主屏幕时，</st>` `<st c="17369">WidgetKit</st>` `<st c="17379">需要在小部件从我们的应用程序获取</st>`
    `<st c="17445">或更新真实数据之前立即显示某些内容。</st>` `<st c="17480">*<st c="17484">placeholder</st>`
    `<st c="17495">函数返回临时数据，仅用于向</st>` `<st c="17554">用户</st>` `<st c="17555">显示：</st>`'
- en: '[PRE5]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: <st c="17672">In our example, we can see a</st> `<st c="17702">placeholder</st>`
    <st c="17713">function that returns the</st> `<st c="17740">English</st>` `<st
    c="17748">class</st>` <st c="17753">text.</st>
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17672">在我们的示例中，我们可以看到一个</st> `<st c="17702">占位符</st>` <st c="17713">函数，它返回</st>
    `<st c="17740">English</st>` `<st c="17748">类</st>` <st c="17753">文本。</st>
- en: <st c="17759">It is important to return temporary data instead of a loading
    indicator, for example, and that’s because we want our user experience to be consistent
    and smooth.</st> <st c="17922">It is also better to be creative and come up with
    elegant information.</st> <st c="17993">For example, if our widget has a timer
    or a time, it is a good idea to show 00:00 to indicate to the user that a timer
    should</st> <st c="18119">appear here.</st>
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="17759">返回临时数据而不是加载指示器很重要，例如，这是因为我们希望用户体验保持一致和流畅。</st> <st c="17922">同时，创造性地提出优雅的信息会更好。</st>
    <st c="17993">例如，如果我们的小部件有一个计时器或时间，显示 00:00 是一个好主意，以向用户表明计时器应该</st> <st c="18119">出现在这里。</st>
- en: <st c="18131">The second function is</st> `<st c="18155">getSnapshot</st>`<st
    c="18166">. The</st> `<st c="18172">getSnapShot</st>` <st c="18183">function is
    even more important than</st> `<st c="18221">placeholder</st>`<st c="18232">.
    When the user browses the widget gallery, the system presents the different widgets.</st>
    <st c="18319">These widgets are being presented without the</st> <st c="18365">system-generated
    timelines.</st>
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18131">第二个函数是</st> `<st c="18155">getSnapshot</st>`<st c="18166">。`<st
    c="18172">getSnapShot</st>` <st c="18183">函数甚至比</st> `<st c="18221">placeholder</st>`<st
    c="18232">` 更重要。当用户浏览小部件画廊时，系统会展示不同的小部件。</st> <st c="18319">这些小部件在没有系统生成的时间线的情况下被展示。</st>
- en: <st c="18392">The</st> `<st c="18397">getSnapshot</st>` <st c="18408">function
    returns a</st> `<st c="18428">TimelineEntry</st>`<st c="18441">-based struct with
    data to present in the</st> <st c="18484">widget gallery.</st>
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18392">`getSnapshot</st>` <st c="18397">函数返回一个基于</st> `<st c="18428">TimelineEntry</st>`<st
    c="18441">的具有要在小部件画廊中呈现的数据的结构。</st>
- en: <st c="18499">Here’s an example of a</st> `<st c="18523">getSnapshot</st>` <st
    c="18534">function:</st>
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18499">以下是一个</st> `<st c="18523">getSnapshot</st>` <st c="18534">函数的示例：</st>
- en: '[PRE6]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: <st c="18720">In this code, the</st> `<st c="18739">getSnapshot</st>` <st c="18750">function
    returns an example event with the current date.</st> <st c="18808">This snapshot
    demonstrates to the user the purpose of our</st> <st c="18866">widget easily.</st>
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18720">在这段代码中，</st> `<st c="18739">getSnapshot</st>` <st c="18750">函数返回一个包含当前日期的示例事件。</st>
    <st c="18808">这个快照向用户展示了我们的</st> `<st c="18866">小部件</st>` <st c="18866">的目的。</st>
- en: <st c="18880">Note that in both</st> `<st c="18899">placeholder</st>` <st c="18910">and</st>
    `<st c="18915">getSnapshot</st>`<st c="18926">, we have the same</st> `<st c="18945">Context</st>`
    <st c="18952">parameter</st> <st c="18963">as the one we had in the</st> `<st
    c="18988">getTimeline</st>` <st c="18999">function.</st> <st c="19010">We need
    the</st> `<st c="19022">Context</st>` <st c="19029">for the same reason as before
    – to understand the environment surrounding</st> <st c="19104">our widget.</st>
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="18880">请注意，在</st> `<st c="18899">占位符</st>` <st c="18910">和</st> `<st
    c="18915">getSnapshot</st>`<st c="18926">` 中，我们都有与</st> `<st c="18945">Context</st>`
    <st c="18952">参数</st> <st c="18963">相同的参数，就像我们在</st> `<st c="18988">getTimeline</st>`
    <st c="18999">函数中拥有的那样。</st> <st c="19010">我们需要</st> `<st c="19022">Context</st>`
    <st c="19029">的原因与之前相同——为了了解围绕</st> `<st c="19104">我们的小部件</st>` <st c="19104">的环境。</st>
- en: <st c="19115">Now that we understand how to generate a timeline provider, let’s
    discuss</st> <st c="19190">the</st> `<st c="19194">TimelineEntry</st>`<st c="19207">.</st>
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19115">现在我们了解了如何生成时间线提供者，让我们来讨论</st> `<st c="19190">TimelineEntry</st>`<st
    c="19207">。</st>
- en: <st c="19208">Building our TimelineEntry structure</st>
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: <st c="19208">构建我们的</st> `<st c="19245">TimelineEntry</st>` <st c="19208">结构</st>
- en: <st c="19245">We can see by now that the</st> `<st c="19273">TimelineProvider</st>`
    <st c="19289">protocol is straightforward as there are only</st> <st c="19336">three
    functions to implement.</st> <st c="19366">One of the things we need to design
    here is</st> `<st c="19410">TimelineEntry</st>`<st c="19423">, and the</st> <st
    c="19433">reason for its importance is that it holds the information we need not
    only to determine when to present information but also what</st> <st c="19564">to
    present.</st>
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以看到，<st c="19245">`TimelineProvider`</st> 协议很简单，因为只需要实现三个函数。</st> <st c="19273">其中我们需要设计的一个是</st>
    `<st c="19410">TimelineEntry</st>`<st c="19423">`，它之所以重要，是因为它包含了我们需要的信息，不仅用于确定何时呈现信息，还包括呈现什么。</st>
    <st c="19433">信息。</st>
- en: <st c="19575">The structure of</st> `<st c="19593">TimelineEntry</st>` <st c="19606">needs
    to fit our widget goal and be aligned with its UI.</st> <st c="19664">Because
    we pre-generate all the entries according to a timeline, we should perform all
    the calculations in advance and generate a structure that can help update the
    widget</st> <st c="19836">content easily.</st>
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19575">时间线条目</st> `<st c="19593">的结构</st>` <st c="19606">需要符合我们的小部件目标并与它的UI对齐。</st>
    <st c="19664">因为我们根据时间线预先生成了所有条目，我们应该提前进行所有计算并生成一个可以轻松更新小部件</st> <st c="19836">内容的结构。</st>
- en: <st c="19851">In fact,</st> `<st c="19861">TimelineEntry</st>` <st c="19874">may
    consist of</st> <st c="19890">four components:</st>
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="19851">实际上，</st> `<st c="19861">时间线条目</st>` <st c="19874">可能由</st> <st
    c="19890">四个组件组成：</st>
- en: '`<st c="19906">date</st>` <st c="19911">– The date</st> <st c="19923">when
    we want our widget to reload the specific entry information.</st> <st c="19989">Notice
    that in most cases, the</st> `<st c="20020">date</st>` <st c="20024">property
    is not part of the information presented on the screen.</st> <st c="20090">For
    example, in a calendar widget, we probably have a date property as part of the</st>
    `<st c="20173">TimelineEntry</st>` <st c="20186">protocol, and something like</st>
    `<st c="20216">eventDate</st>` <st c="20225">for the actual</st> <st c="20241">event
    time.</st>'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="19906">日期</st>` <st c="19911">– 我们希望小部件重新加载特定条目信息的日期。</st> <st c="19923">注意，在大多数情况下，</st>
    `<st c="20020">日期</st>` <st c="20024">属性不是屏幕上展示的信息的一部分。</st> <st c="20090">例如，在日历小部件中，我们可能将日期属性作为</st>
    `<st c="20173">时间线条目</st>` <st c="20186">协议的一部分，并为实际</st> <st c="20216">事件时间使用类似</st>
    `<st c="20225">eventDate</st>` <st c="20241">的属性。</st>'
- en: '`<st c="20401">title</st>`<st c="20406">,</st> `<st c="20408">bodyText</st>`<st
    c="20416">, and</st> `<st c="20422">timeString</st>`<st c="20432">, can simplify
    our code and even</st> <st c="20465">increase performance.</st>'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="20401">标题</st>`<st c="20406">,</st> `<st c="20408">正文内容</st>`<st c="20416">,
    和</st> `<st c="20422">时间字符串</st>`<st c="20432">, 可以简化我们的代码甚至</st> <st c="20465">提高性能。</st>'
- en: '`<st c="20819">TimelineEntry</st>` <st c="20832">is all that we have when the
    user interacts</st> <st c="20877">with it.</st>'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="20819">时间线条目</st>` <st c="20832">是用户与之交互时我们所拥有的全部。</st>'
- en: '`<st c="20902">relevance</st>` <st c="20911">property is an optional property
    that we have as part of the</st> `<st c="20973">TimelineEntry</st>` <st c="20986">protocol.</st>
    <st c="20997">In the</st> `<st c="21004">relevance</st>` <st c="21013">property,
    we can determine the relevance priority of the entry to the user.</st> <st c="21090">For
    example, a to-do app that shows the next task to the user may want to set a high
    score to an entry with a critical task.</st> <st c="21215">Or, a sports app that
    shows the latest news in a widget may want to set a high score for entries that
    contain news about the user’s favorite team.</st> <st c="21362">The entries’ relevance
    values help</st> *<st c="21397">WidgetKit</st>* <st c="21407">to decide how and
    when to present widgets in the system.</st> <st c="21464">For example,</st> *<st
    c="21477">WidgetKit</st>* <st c="21487">may decide to rotate the stack widget
    and show a widget with high-relevance information.</st> <st c="21576">Let’s see
    an example how to set</st> `<st c="21608">relevance</st>` <st c="21617">for</st>
    <st c="21622">a</st> `<st c="21624">TimeLineEntry</st>`<st c="21637">:</st>'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="20902">相关性</st>` <st c="20911">属性是我们作为</st> `<st c="20973">时间线条目</st>`
    <st c="20986">协议的一部分拥有的可选属性。</st> <st c="20997">在</st> `<st c="21004">相关性</st>`
    <st c="21013">属性中，我们可以确定条目对用户的关联优先级。</st> <st c="21090">例如，一个向用户展示下一个任务的待办事项应用可能希望将高分数设置给包含关键任务的条目。</st>
    <st c="21215">或者，一个在小部件中展示最新新闻的运动应用可能希望将高分数设置给包含用户喜欢的球队新闻的条目。</st> <st c="21362">条目的相关性值帮助</st>
    *<st c="21397">WidgetKit</st>* <st c="21407">决定如何在系统中何时展示小部件。</st> <st c="21464">例如，</st>
    *<st c="21477">WidgetKit</st>* <st c="21487">可能决定旋转堆叠小部件并展示一个高相关性信息的小部件。</st>
    <st c="21576">让我们看看如何为</st> `<st c="21608">相关性</st>` <st c="21617">设置</st> `<st
    c="21622">一个</st> `<st c="21624">时间线条目</st>`<st c="21637">的例子：</st>'
- en: '[PRE7]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: <st c="22276">Now that we have created a timeline, let’s turn to the main topic,
    which is building our</st> <st c="22366">widget UI.</st>
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22276">现在我们已经创建了一个时间线，让我们转向主要话题，即构建我们的</st> <st c="22366">小部件UI。</st>
- en: <st c="22376">Building our widget UI</st>
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: <st c="22376">构建我们的小部件UI</st>
- en: <st c="22399">Creating a timeline of entries is critical for our widget to provide
    accurate and relevant information</st> <st c="22503">to the user.</st> <st c="22516">But
    to do that, we also need to render the widget UI.</st> <st c="22570">The place
    where we do that is in the widget’s structure, as we saw at the beginning of this
    chapter in the</st> *<st c="22677">Configuring our</st>* *<st c="22693">widget</st>*
    <st c="22699">section.</st>
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22399">创建条目时间线对于我们的小部件向用户提供准确和相关信息至关重要。</st> <st c="22503">但要做到这一点，我们还需要渲染小部件
    UI。</st> <st c="22516">我们进行渲染的地方是小部件的结构中，正如我们在本章开头在</st> *<st c="22677">配置我们的</st>
    * *<st c="22693">小部件</st> * *<st c="22699">部分</st> 中所看到的。</st>
- en: <st c="22708">Let’s see the</st> <st c="22723">configuration again:</st>
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22708">让我们再次看看</st> <st c="22723">配置：</st>
- en: '[PRE8]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: <st c="22891">As we can see, the</st> `<st c="22910">StaticConfiguration</st>`
    <st c="22929">has a view builder that returns a SwiftUI view, and this is probably
    the first thing we need to understand in</st> *<st c="23040">WidgetKit</st>* <st
    c="23050">– widgets are built with SwiftUI only.</st> <st c="23089">If you still
    haven’t got any experience with SwiftUI,</st> *<st c="23143">WidgetKit</st>* <st
    c="23153">is a great opportunity</st> <st c="23176">to start.</st>
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="22891">正如我们所见，</st> `<st c="22910">StaticConfiguration</st>` <st c="22929">有一个返回
    SwiftUI 视图的视图构建器，这可能是我们在</st> *<st c="23040">WidgetKit</st>* <st c="23050">中需要理解的第一件事——小部件仅使用
    SwiftUI 构建。</st> <st c="23089">如果你还没有任何 SwiftUI 的经验，</st> *<st c="23143">WidgetKit</st>*
    <st c="23153">是一个开始学习的好机会。</st>
- en: <st c="23185">Something that might have caught your attention is the</st> `<st
    c="23241">containerBackground</st>` <st c="23260">view modifier.</st> <st c="23276">If
    you remember, we have discussed how widgets now can be shown in different places
    in the Apple ecosystem –</st> *<st c="23385">iOS</st>* <st c="23388">(both home
    screen and lock screen),</st> *<st c="23425">padOS</st>*<st c="23430">,</st> *<st
    c="23432">macOS</st>*<st c="23437">, and</st> *<st c="23443">watchOS</st>*<st
    c="23450">. But the primary issue with having our widgets on different platforms
    might be the</st> <st c="23534">widget’s background.</st>
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23185">可能引起你注意的可能是</st> `<st c="23241">containerBackground</st>` <st
    c="23260">视图修饰符。</st> <st c="23276">如果你还记得，我们讨论过小部件现在可以在苹果生态系统的不同地方显示——</st> *<st
    c="23385">iOS</st>* <st c="23388">(主屏幕和锁屏)，</st> *<st c="23425">padOS</st>*<st
    c="23430">，</st> *<st c="23432">macOS</st>*<st c="23437">，以及</st> *<st c="23443">watchOS</st>*<st
    c="23450">。但将我们的小部件放在不同的平台上的主要问题可能是小部件的背景。</st> <st c="23534">小部件的背景。</st>
- en: <st c="23554">Adding the</st> `<st c="23566">containerBackground</st>` <st c="23585">view
    modifier ensures that the widget’s background adjusts itself to its container
    and always looks good, no matter where</st> <st c="23708">it appears.</st>
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23554">添加</st> `<st c="23566">containerBackground</st>` <st c="23585">视图修饰符确保小部件的背景会根据其容器进行调整，并且无论出现在哪里都始终看起来很好。</st>
    <st c="23708">它出现在哪里都一样。</st>
- en: <st c="23719">If we look at</st> <st c="23734">our code example again, we can
    see that</st> `<st c="23774">MyWidgetEntryView</st>` <st c="23791">receives one
    parameter, which is the current timeline entry.</st> <st c="23853">Let’s see what
    we can learn</st> <st c="23881">from it.</st>
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23719">如果我们再次查看</st> <st c="23734">我们的代码示例，我们可以看到</st> `<st c="23774">MyWidgetEntryView</st>`
    <st c="23791">接收一个参数，即当前的</st> 时间线条目。</st> <st c="23853">让我们看看我们能从中学习到什么。</st>
- en: <st c="23889">Working with timeline entries</st>
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="23889">处理时间线条目</st>
- en: <st c="23919">Connecting the timeline entry to the widget view is the core of
    how widgets work.</st> <st c="24002">The main role of</st> *<st c="24019">WidgetCenter</st>*
    <st c="24031">is to generate a timeline and provide our widget with the right
    timeline entry at the</st> <st c="24118">right time.</st>
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="23919">将时间线条目连接到小部件视图是理解小部件工作原理的核心。</st> <st c="24002">*<st c="24019">WidgetCenter</st>*
    <st c="24031">的主要作用是生成时间线，并在正确的时间为我们的小部件提供正确的时间线条目。</st>
- en: <st c="24129">The widget</st> <st c="24141">configuration view builder has one
    parameter, a specific timeline entry, so we can return a widget view with</st>
    <st c="24250">relevant data.</st>
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24129">小部件</st> <st c="24141">配置视图构建器有一个参数，即特定的时间线条目，因此我们可以返回一个包含相关数据的</st>
    小部件视图。</st>
- en: <st c="24264">Here’s an example of a widget view that uses a specific</st> <st
    c="24321">timeline entry:</st>
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24264">这是一个使用特定</st> <st c="24321">时间线条目的</st> 小部件视图的示例：</st>
- en: '[PRE9]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: <st c="24632">This code</st> <st c="24643">example shows a simple view that
    shows the next event title and time while using the</st> <st c="24728">timeline
    entry.</st>
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24632">此代码</st> <st c="24643">示例显示了一个简单的视图，它在使用</st> <st c="24728">时间线条目时显示下一个事件标题和时间。</st>
- en: <st c="24743">There are two things we can learn from the way the timeline entry
    works with the</st> <st c="24825">widget view:</st>
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="24743">从时间线条目与组件视图协同工作的方式中，我们可以学到两件事：</st> <st c="24825">组件视图：</st>
- en: '**<st c="24837">The entry should contain all the widget’s data</st>** <st c="24884">–
    We discussed it when we talked about the timeline provider, but now we can see
    why.</st> <st c="24971">Widgets need to be as static and simple as possible.</st>
    <st c="25024">We don’t want to perform any data fetching operations while the
    view</st> <st c="25093">is displayed.</st>'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="24837">条目应包含所有组件的数据</st>** <st c="24884">—— 我们在讨论时间线提供者时提到了这一点，但现在我们可以看到原因了。</st>
    <st c="24971">组件需要尽可能静态和简单。</st> <st c="25024">我们不希望在视图显示时执行任何数据获取操作。</st>'
- en: '**<st c="25106">There is no state</st>** <st c="25124">– Unlike regular SwiftUI
    views, our widget view doesn’t have a state.</st> <st c="25195">There are cases
    where we probably would want to see different views for different situations.</st>
    <st c="25289">For example, in our</st> *<st c="25309">next event</st>* <st c="25319">widget
    example, maybe we want to show a</st> *<st c="25360">connect to your calendar</st>*
    <st c="25384">message if the user hasn’t approved his calendar permissions.</st>
    <st c="25447">To do that, we need to generate different timeline entries and perhaps
    show a different view in the static configuration closure.</st> <st c="25577">Either
    way, we should do these checks</st> <st c="25615">in advance.</st>'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="25106">没有状态</st>** <st c="25124">—— 与常规SwiftUI视图不同，我们的组件视图没有状态。</st>
    <st c="25195">有些情况下，我们可能希望根据不同情况显示不同的视图。</st> <st c="25289">例如，在我们的下一个组件视图示例中，如果我们希望用户尚未批准其日历权限，我们可能想显示一条消息，提示用户*<st
    c="25309">连接到您的日历</st>**。</st> <st c="25360">如果用户尚未批准其日历权限，我们可能想显示一条消息，提示用户*<st
    c="25360">连接到您的日历</st>**。</st> <st c="25384">为了做到这一点，我们需要生成不同的时间线条目，并在静态配置闭包中显示不同的视图。</st>
    <st c="25447">无论如何，我们应该提前进行这些检查。</st>'
- en: <st c="25626">Even though the widgets are naturally static, their UI doesn’t
    have to stay static and bold.</st> <st c="25720">In</st> `<st c="25723">WidgetKit</st>`<st
    c="25732">, it is possible to bring life to our widget by animating</st> <st c="25790">the
    changes.</st>
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25626">尽管组件自然是静态的，但它们的UI不必保持静态和粗体。</st> <st c="25720">在`<st c="25723">WidgetKit</st>`<st
    c="25732">`中，我们可以通过动画变化来使我们的组件生动起来。</st>
- en: <st c="25802">Adding animations</st>
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: <st c="25802">添加动画</st>
- en: <st c="25820">We already</st> <st c="25832">know how animations in iOS development
    work – view animations work by transitioning between two or more states.</st>
    <st c="25944">For example, if a specific view has an opacity of</st> `<st c="25994">1.0</st>`
    <st c="25997">and we change it to</st> `<st c="26018">0.5</st>`<st c="26021">,
    UIKit and SwiftUI can animate that change if</st> <st c="26068">we like.</st>
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="25820">我们已经</st> <st c="25832">了解了iOS开发中动画的工作原理——视图动画通过在两个或多个状态之间转换来实现。</st>
    <st c="25944">例如，如果一个特定的视图的透明度为`<st c="25994">1.0</st>` <st c="25997">，我们将其更改为`<st
    c="26018">0.5</st>`<st c="26021">，如果喜欢，UIKit和SwiftUI可以对该变化进行动画处理。</st>
- en: <st c="26076">Widgets are written in SwiftUI, and in SwiftUI, we can animate
    state changes.</st> <st c="26155">However, widgets don’t use state at all.</st>
    <st c="26196">Instead, we change the widget content using the timeline provider
    (perhaps we can say that, in a way, the timeline entry is our</st> <st c="26324">widget
    state).</st>
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26076">组件是用SwiftUI编写的，在SwiftUI中，我们可以对状态变化进行动画处理。</st> <st c="26155">然而，组件并不使用状态。</st>
    <st c="26196">相反，我们通过时间线提供者（也许我们可以这样说，在某种程度上，时间线条目就是我们的组件状态）来更改组件内容。</st>
- en: <st c="26338">Starting with iOS 16, whenever the</st> *<st c="26374">WidgetCenter</st>*
    <st c="26386">reloads a widget and changes its content using a new entry, it performs
    this</st> <st c="26464">transition automatically.</st>
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26338">从iOS 16开始，每当`<st c="26374">WidgetCenter</st>` <st c="26386">重新加载组件并使用新条目更改其内容时，它会自动执行此`<st
    c="26464">转换</st>`。</st>
- en: <st c="26489">Can we</st> <st c="26497">customize this animation even if we
    don’t have a state in widgets?</st> <st c="26564">Of course we can,</st> <st c="26582">using</st>
    `<st c="26588">contentTransition</st>`<st c="26605">.</st>
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26489">即使我们没有在组件中设置状态，我们能否自定义这个动画？</st> <st c="26497">当然可以，</st> <st
    c="26564">使用`<st c="26588">contentTransition</st>`<st c="26605">。</st>
- en: <st c="26606">As mentioned, in most cases, SwiftUI performs animations based
    on a state change.</st> <st c="26689">For example, look at the</st> <st c="26714">following
    code:</st>
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26606">如前所述，在大多数情况下，SwiftUI根据状态变化执行动画。</st> <st c="26689">例如，看看以下代码：</st>
    <st c="26714">以下代码：</st>
- en: '[PRE10]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: <st c="26941">In this code example, we have a view and a button.</st> <st c="26993">Tapping
    on the button changes the view color, and it does that using the</st> `<st c="27066">withAnimation</st>`
    <st c="27079">function.</st> <st c="27090">Clearly, that can’t work in a widget
    because we need a state to</st> <st c="27154">do that.</st>
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="26941">在这个代码示例中，我们有一个视图和一个按钮。</st> <st c="26993">点击按钮会改变视图的颜色，它是通过使用</st>
    `<st c="27066">withAnimation</st>` <st c="27079">函数来实现的。</st> <st c="27090">显然，这在一个组件中是不可行的，因为我们需要一个状态来</st>
    <st c="27154">完成这个操作。</st>
- en: <st c="27162">Instead, what we</st> <st c="27180">need to do is define how the
    content changes when it’s animated.</st> <st c="27245">To do that, we can</st>
    <st c="27264">use</st> `<st c="27268">contentTransition</st>`<st c="27285">:</st>
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27162">相反，我们需要做的是定义内容在动画时如何变化。</st> <st c="27180">为了做到这一点，我们可以</st> <st
    c="27264">使用</st> `<st c="27268">contentTransition</st>`<st c="27285">:</st>
- en: '[PRE11]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '`<st c="27462">contentTransition</st>` <st c="27480">is a view modifier we
    can add to views to define their transition method.</st> <st c="27555">Imagine
    that all content changes in widgets are done with</st> `<st c="27613">withAnimation</st>`
    <st c="27626">in mind and all we have to do is to change the</st> <st c="27674">transition
    method.</st>'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '`<st c="27462">contentTransition</st>` <st c="27480">是一种我们可以添加到视图中的视图修改器，用于定义它们的过渡方法。</st>
    <st c="27555">想象一下，所有在组件中的内容更改都是通过</st> `<st c="27613">withAnimation</st>` <st
    c="27626">来完成的，而我们唯一需要做的就是改变</st> <st c="27674">过渡方法。</st>'
- en: <st c="27692">Take, for example, the following</st> <st c="27726">code snippet:</st>
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="27692">例如，以下</st> <st c="27726">代码片段：</st>
- en: '[PRE12]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'struct MyWidgetEntryView : View {'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct MyWidgetEntryView : View {'
- en: 'var entry: Provider.Entry'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var entry: Provider.Entry'
- en: 'var body: some View {'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var body: some View {'
- en: VStack {
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: Text("Time:")
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("时间:")
- en: 'Text(entry.nextEventTime, style: .time)'
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Text(entry.nextEventTime, style: .time)'
- en: Text("Next Event")
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("下一个事件")
- en: Text(entry.nextEvent) <st c="28429">.contentTransition(.numericText())</st>
    }
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text(entry.nextEvent) <st c="28429">.contentTransition(.numericText())</st>
    }
- en: '}'
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE13]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'struct CalendarWidgetIntent: WidgetConfigurationIntent {'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct CalendarWidgetIntent: WidgetConfigurationIntent {'
- en: 'static var title: LocalizedStringResource = "Select'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'static var title: LocalizedStringResource = "Select'
- en: Calendar"
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Calendar"
- en: '@Parameter(title: "Calendar") var calendar:'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '@Parameter(title: "Calendar") var calendar:'
- en: CalendarEntity
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: CalendarEntity
- en: '}'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE14]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'struct CalendarEntity: AppEntity {'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct CalendarEntity: AppEntity {'
- en: 'let id: String'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let id: String'
- en: 'let name: String'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let name: String'
- en: 'static var typeDisplayRepresentation:'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'static var typeDisplayRepresentation:'
- en: TypeDisplayRepresentation = "Calendar"
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: TypeDisplayRepresentation = "Calendar"
- en: static var defaultQuery = CalendarQuery()
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: static var defaultQuery = CalendarQuery()
- en: 'var displayRepresentation: DisplayRepresentation {'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var displayRepresentation: DisplayRepresentation {'
- en: 'DisplayRepresentation(title: name)'
  id: totrans-185
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'DisplayRepresentation(title: name)'
- en: '}'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE15]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'struct CalendarQuery: EntityQuery {'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct CalendarQuery: EntityQuery {'
- en: 'func entities(for identifiers: [CalendarEntity.ID])'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func entities(for identifiers: [CalendarEntity.ID])'
- en: async throws -> [CalendarEntity] {
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: async throws -> [CalendarEntity] {
- en: allCalendars.filter { identifiers.contains($0.id) }
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: allCalendars.filter { identifiers.contains($0.id) }
- en: '}'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: func suggestedEntities() async throws ->
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: func suggestedEntities() async throws ->
- en: '[CalendarEntity] {'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[CalendarEntity] {'
- en: allCalendars
  id: totrans-196
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: allCalendars
- en: '}'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: func defaultResult() async -> CalendarEntity? {
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: func defaultResult() async -> CalendarEntity? {
- en: nil
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: nil
- en: '}'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE16]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'AppIntentConfiguration(kind: kind, <st c="33478">intent:</st>'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 'AppIntentConfiguration(kind: kind, <st c="33478">intent:</st>'
- en: '<st c="33485">CalendarWidgetIntent.self,</st> provider:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '<st c="33485">CalendarWidgetIntent.self,</st> provider:'
- en: 'ConfigurableProvider(), content: { entry in'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ConfigurableProvider(), content: { entry in'
- en: 'ConfigurableWidgetView(entry: entry)'
  id: totrans-206
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'ConfigurableWidgetView(entry: entry)'
- en: '})'
  id: totrans-207
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '})'
- en: '[PRE17]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'struct ConfigurableProvider: AppIntentTimelineProvider {'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct ConfigurableProvider: AppIntentTimelineProvider {'
- en: 'func timeline(for configuration: CalendarWidgetIntent,'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'func timeline(for configuration: CalendarWidgetIntent,'
- en: 'in context: Context) async ->'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'in context: Context) async ->'
- en: Timeline<ConfiguredNextEventEntry>
  id: totrans-212
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Timeline<ConfiguredNextEventEntry>
- en: '[PRE18]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'let timeline = Timeline(entries: entries, <st c="35357">WidgetCenter</st> to
    reload the timeline immediately, due to data changes or any other alterations.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 'let timeline = Timeline(entries: entries, <st c="35357">WidgetCenter</st> to
    reload the timeline immediately, due to data changes or any other alterations.'
- en: <st c="35451">Let’s see how</st> <st c="35466">it happens.</st>
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35451">让我们看看它是如何发生的。</st>
- en: <st c="35477">Reload widgets using the WidgetCenter</st>
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35477">使用WidgetCenter重新加载小部件</st>
- en: <st c="35515">Throughout</st> <st c="35527">the chapter, I have mentioned</st>
    *<st c="35557">WidgetCenter</st>* <st c="35569">frequently but I haven’t explained
    what</st> <st c="35610">it means.</st>
  id: totrans-217
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35515">在整个章节中，我经常提到</st> *<st c="35557">WidgetCenter</st>* <st c="35569">，但我还没有解释它的含义。</st>
- en: '*<st c="35619">WidgetCenter</st>* <st c="35632">is an object that holds information
    about the different configured widgets currently used, and it also provides an
    option to</st> <st c="35758">reload them.</st>'
  id: totrans-218
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="35619">WidgetCenter</st>* 是一个包含当前使用配置的不同小部件信息的对象，它还提供了一个选项来 <st c="35758">重新加载它们。</st>'
- en: <st c="35770">To use</st> `<st c="35778">WidgetCenter</st>`<st c="35790">, we
    need to call the</st> `<st c="35812">shared</st>` <st c="35818">property to access
    its</st> <st c="35842">singleton reference:</st>
  id: totrans-219
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35770">要使用 <st c="35778">WidgetCenter</st><st c="35790">，我们需要调用 <st c="35812">shared</st>
    <st c="35818">属性来访问其 <st c="35842">单例引用：</st>
- en: '[PRE19]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: <st c="35882">The difference between</st> *<st c="35906">WidgetCenter</st>*
    <st c="35918">and the rest of the code we have handled up until now is the fact
    that we call</st> *<st c="35998">WidgetCenter</st>* <st c="36010">from the app
    and not the</st> <st c="36036">widget extension.</st>
  id: totrans-221
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="35882">WidgetCenter</st> 与我们迄今为止处理的其他代码之间的区别在于，我们是从应用中调用 <st c="35998">WidgetCenter</st>
    而不是调用 <st c="36036">widget 扩展。</st>
- en: <st c="36053">Let’s see how we can call the</st> `<st c="36084">WidgetCenter</st>`
    <st c="36096">to get a list of</st> <st c="36114">active widgets:</st>
  id: totrans-222
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36053">让我们看看如何调用 <st c="36084">WidgetCenter</st> 来获取活动小部件的列表：</st>
- en: '[PRE20]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: <st c="36278">The</st> `<st c="36283">getCurrentConfigurations</st>` <st c="36307">function
    uses a closure to return an array of active widgets.</st> <st c="36370">Each one
    of them is the</st> `<st c="36394">WidgetInfo</st>` <st c="36404">type – a structure
    that contains information</st> <st c="36450">about a specific</st> <st c="36467">configured
    widget.</st>
  id: totrans-224
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36278">The</st> `<st c="36283">getCurrentConfigurations</st>` <st c="36307">函数使用闭包来返回一个活动小部件的数组。</st>
    <st c="36370">它们中的每一个都是 <st c="36394">WidgetInfo</st> <st c="36404">类型 – 一个包含有关特定
    <st c="36450">配置小部件</st> <st c="36467">信息的结构。</st>
- en: <st c="36485">The</st> `<st c="36490">WidgetInfo</st>` <st c="36500">structure
    has three properties – kind, family,</st> <st c="36548">and configuration:</st>
  id: totrans-225
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36485">The</st> `<st c="36490">WidgetInfo</st>` <st c="36500">结构有三个属性
    – kind, family，和 configuration：</st>
- en: '`<st c="36566">kind</st>` <st c="36571">– This is the string we set when we
    created the widget configuration (look again at the</st> *<st c="36660">Configuring
    our</st>* *<st c="36676">widget</st>* <st c="36682">section).</st>'
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="36566">kind</st>` <st c="36571">– 这是我们创建小部件配置时设置的字符串（再次查看 *<st c="36660">配置我们的</st>
    * *<st c="36676">小部件</st> * *<st c="36682">部分）。</st>'
- en: '`<st c="36692">family</st>` <st c="36699">– The family size of the widget –
    small, medium,</st> <st c="36749">or large.</st>'
  id: totrans-227
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="36692">family</st>` <st c="36699">– 小部件的家庭大小 – 小型、中型或大型。</st>'
- en: '`<st c="36758">configuration</st>` <st c="36772">– The intent that contains
    user configuration information.</st> <st c="36832">The</st> `<st c="36836">configuration</st>`
    <st c="36849">property</st> <st c="36859">is optional.</st>'
  id: totrans-228
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="36758">configuration</st>` <st c="36772">– 包含用户配置信息的意图。</st> <st c="36832">The</st>
    `<st c="36836">configuration</st>` <st c="36849">属性是可选的。</st>'
- en: <st c="36871">If needed, we can use that information to reload the timeline
    of a specific kind of widget.</st> <st c="36964">For example, if we want to reload
    widgets with the kind of</st> `<st c="37023">MyWidget</st>`<st c="37031">, we
    need to call</st> <st c="37049">the following:</st>
  id: totrans-229
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="36871">如果需要，我们可以使用这些信息来重新加载特定类型的小部件的时间线。</st> <st c="36964">例如，如果我们想重新加载具有
    <st c="37023">MyWidget</st> <st c="37031">类型的小部件，我们需要调用</st> <st c="37049">以下内容：</st>
- en: '[PRE21]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: <st c="37119">Notice that the function says</st> `<st c="37150">Timelines</st>`
    <st c="37159">and not</st> `<st c="37168">Timeline</st>`<st c="37176">, as it
    is possible to have several widgets of the</st> <st c="37227">same kind.</st>
  id: totrans-231
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37119">注意，该函数说的是 <st c="37150">Timelines</st> <st c="37159">而不是 <st c="37168">Timeline</st>，因为可能存在多个相同类型的小部件。</st>
- en: <st c="37237">If we want to reload all our app widgets, we can call the</st>
    `<st c="37296">reloadAllTimelines()</st>` <st c="37316">function:</st>
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37237">如果我们想重新加载我们应用中的所有小部件，我们可以调用 <st c="37296">reloadAllTimelines()</st>
    <st c="37316">函数：</st>
- en: '`<st c="37326">WidgetCenter.shared.reloadAllTimelines()</st>`'
  id: totrans-233
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<st c="37326">WidgetCenter.shared.reloadAllTimelines()</st>`'
- en: <st c="37367">There are several great use cases for reloading our widget timeline,
    such as when we get a push notification, or when the user data or settings have
    changed.</st> <st c="37526">If you remember, when we discussed the widget timeline
    in the</st> *<st c="37588">Generating a timeline</st>* <st c="37609">section,
    we talked about the fact that widgets have a certain budget for the amount of
    reloading they can do each day.</st> <st c="37729">But the good news is that calling
    the</st> `<st c="37767">reloadTimelines</st>` <st c="37782">or</st> `<st c="37786">reloadAllTimelines</st>`
    <st c="37804">functions doesn’t count in this budget if our app is in the foreground
    or uses some other technique, such as playing audio in</st> <st c="37931">the
    background.</st>
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37367">在我们的小部件时间线中重新加载有几个很好的用例，例如当我们收到推送通知，或者当用户数据或设置发生变化时。</st> <st
    c="37526">如果你还记得，当我们讨论小部件时间线时，在</st> *<st c="37588">生成时间线</st>* <st c="37609">部分，我们提到了小部件每天可以重新加载的次数有一定的预算。</st>
    <st c="37729">但好消息是，如果我们的应用在前台或使用某些其他技术，例如在</st> <st c="37931">后台播放音频</st>，调用
    `<st c="37767">reloadTimelines</st>` <st c="37782">或</st> `<st c="37786">reloadAllTimelines</st>`
    <st c="37804">函数不计入这个预算。</st>
- en: <st c="37946">In most</st> <st c="37955">cases,</st> `<st c="37962">reloadTimelines</st>`
    <st c="37977">works well when the updated data is already on the device or in
    our app.</st> <st c="38051">But what should we do when the local persistent store
    is</st> <st c="38108">not updated?</st>
  id: totrans-235
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="37946">在大多数</st> <st c="37955">情况下，</st> `<st c="37962">reloadTimelines</st>`
    <st c="37977">当更新后的数据已经在设备上或在我们的应用中时，工作得很好。</st> <st c="38051">但当我们本地的持久存储没有更新时，我们应该怎么办呢？</st>
- en: <st c="38120">We perform a network request,</st> <st c="38151">of course!</st>
  id: totrans-236
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38120">我们执行一个网络请求,</st> <st c="38151">当然！</st>
- en: <st c="38161">Go to the network for updates</st>
  id: totrans-237
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38161">前往网络获取更新</st>
- en: <st c="38191">Performing a network request to update local data is a typical
    operation in mobile apps.</st> <st c="38281">But how</st> <st c="38289">does it
    work</st> <st c="38302">in widgets?</st>
  id: totrans-238
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38191">在移动应用中，执行网络请求以更新本地数据是一种典型操作。</st> <st c="38281">但在小部件中它是如何工作的呢？</st>
    <st c="38289">does it work</st> <st c="38302">in widgets?</st>
- en: <st c="38313">Let’s look at the</st> `<st c="38332">getTimeline</st>` <st c="38343">function
    again:</st>
  id: totrans-239
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="38313">让我们再次看看</st> `<st c="38332">getTimeline</st>` <st c="38343">函数：</st>
- en: '[PRE22]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'func getTimeline(in context: Context, completion: @escaping'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 'func getTimeline(in context: Context, completion: @escaping'
- en: (Timeline<SimpleEntry>) -> Void) {
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: (Timeline<SimpleEntry>) -> Void) {
- en: 'var entries: [SimpleEntry] = [] <st c="38822">calendarService.fetchNextEvents
    { result in</st> switch result {'
  id: totrans-243
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var entries: [SimpleEntry] = [] <st c="38822">calendarService.fetchNextEvents
    { result in</st> switch result {'
- en: 'case .success(let events):'
  id: totrans-244
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'case .success(let events):'
- en: for event in events {
  id: totrans-245
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: for event in events {
- en: 'let entry = SimpleEntry(date:'
  id: totrans-246
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let entry = SimpleEntry(date:'
- en: 'event.alertTime, nextEvent:'
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'event.alertTime, nextEvent:'
- en: 'event.title, nextEventTime:'
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'event.title, nextEventTime:'
- en: event.date)
  id: totrans-249
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: event.date)
- en: entries.append(entry)
  id: totrans-250
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: entries.append(entry)
- en: '}'
  id: totrans-251
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'case .failure(let error):'
  id: totrans-252
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'case .failure(let error):'
- en: 'print("Error fetching next events:'
  id: totrans-253
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'print("Error fetching next events:'
- en: \(error.localizedDescription)")
  id: totrans-254
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: \(error.localizedDescription)")
- en: '}'
  id: totrans-255
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: 'let timeline = Timeline(entries: entries, policy:'
  id: totrans-256
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'let timeline = Timeline(entries: entries, policy:'
- en: .atEnd)
  id: totrans-257
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: .atEnd)
- en: completion(timeline)
  id: totrans-258
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: completion(timeline)
- en: '}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE23]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: http://www.myGreatCalendarAp.com/event/<eventID>/
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: http://www.myGreatCalendarAp.com/event/<eventID>/
- en: '[PRE24]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'struct MyWidgetEntryView : View {'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 'struct MyWidgetEntryView : View {'
- en: 'var entry: Provider.Entry'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var entry: Provider.Entry'
- en: 'var body: some View {'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'var body: some View {'
- en: VStack {
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: VStack {
- en: Text("Time:")
  id: totrans-268
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("时间:")
- en: 'Text(entry.nextEventTime, style: .time)'
  id: totrans-269
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'Text(entry.nextEventTime, style: .time)'
- en: Text("Next Event")
  id: totrans-270
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text("Next Event")
- en: Text(entry.nextEvent) <st c="41571">.widgetURL(URL(string:</st>
  id: totrans-271
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: Text(entry.nextEvent) <st c="41571">.widgetURL(URL(string:</st>
- en: <st c="41593">"</st>https://www.myGreatCalendarApp.com/event/\(entry.eventID)/"<st
    c="41654">))</st> }
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: <st c="41593">"</st>https://www.myGreatCalendarApp.com/event/\(entry.eventID)/"<st
    c="41654">))</st> }
- en: '}'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '}'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE25]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Button("Turn \(entry.isAlarm ? "Off" : "On") Alarm" , role:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 'Button("Turn \(entry.isAlarm ? "Off" : "On") Alarm" , role:'
- en: nil, <st c="43802">entry.isAlaram</st> value. But what’s more interesting here
    is that we have an additional parameter called <st c="43904">Intent</st>, where
    we pass a struct named <st c="43941">MyWidgetIntent</st> along with the <st c="43971">eventID</st>.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: nil, <st c="43802">entry.isAlaram</st> value. 但更有趣的是，我们还有一个额外的参数叫做 <st c="43904">Intent</st>，其中我们传递一个名为
    <st c="43941">MyWidgetIntent</st> 的结构体，以及 <st c="43971">eventID</st>。
- en: <st c="43979">Let’s talk about the App Intent, but this time, in the context
    of</st> <st c="44046">user interaction.</st>
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="43979">让我们谈谈应用意图，但这次是在</st> <st c="44046">用户交互</st>的上下文中。</st>
- en: <st c="44063">Performing the data change using the intent</st>
  id: totrans-279
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="44063">使用意图执行数据更改</st>
- en: <st c="44107">We have already said that the widget doesn’t manage any state.</st>
    <st c="44171">Therefore, the real widgets</st> <st c="44199">state is some kind
    of a combination between a local store and the</st> <st c="44265">timeline provider.</st>
  id: totrans-280
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经说过，小部件不管理任何状态。因此，真正的widget状态是本地存储和timeline provider之间的一种组合。
- en: <st c="44283">The</st> `<st c="44288">MyWidgetIntent</st>` <st c="44302">receives
    an</st> `<st c="44315">eventID</st>` <st c="44322">and is responsible for reaching
    out to</st> `<st c="44362">EventKit</st>` <st c="44370">and updating the actual
    event</st> <st c="44401">alarm information.</st>
  id: totrans-281
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`<MyWidgetIntent>`接收一个`eventID`并负责联系`EventKit`并更新实际事件的警报信息。'
- en: <st c="44419">Let’s look at the</st> <st c="44438">App Intent:</st>
  id: totrans-282
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们看看`App Intent`：
- en: '[PRE26]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: <st c="44780">Besides the</st> `<st c="44793">LocalizedStringResource</st>`
    <st c="44816">static property that we discussed in the</st> *<st c="44858">Customize
    our widget</st>* <st c="44878">section, we have one primary function called</st>
    `<st c="44924">perform()</st>`<st c="44933">. The</st> `<st c="44939">perform()</st>`
    <st c="44948">function executes when the user taps on the button that is linked
    to that App Intent.</st> <st c="45035">Notice that the</st> `<st c="45051">perform()</st>`
    <st c="45060">function is also an async function that lets us perform</st> <st
    c="45117">heavier tasks, such as writing to the database or even performing a</st>
    <st c="45185">URL request.</st>
  id: totrans-284
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 除了我们在*自定义我们的小部件*部分讨论的`LocalizedStringResource`静态属性之外，我们还有一个主要函数叫做`perform()`。`perform()`函数在用户点击与该App
    Intent关联的按钮时执行。请注意，`perform()`函数也是一个异步函数，它允许我们执行更重的任务，例如写入数据库或执行URL请求。
- en: <st c="45197">Once the</st> `<st c="45207">perform()</st>` <st c="45216">function
    completes its execution, the App Intent triggers</st> <st c="45275">the</st> *<st
    c="45279">WidgetCenter</st>*<st c="45291">.</st>
  id: totrans-285
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 一旦`perform()`函数完成执行，App Intent就会触发*WidgetCenter*。
- en: <st c="45292">Updating the widget UI</st>
  id: totrans-286
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 更新小部件UI
- en: <st c="45315">Now that the local store is updated, it’s time for the</st> *<st
    c="45371">WidgetCenter</st>* <st c="45383">to reload the Timeline</st> <st c="45407">Provider.</st>
    <st c="45417">We should already be familiar with that process – the Timeline Provider
    fetches the relevant local data and builds a timeline based on the changes we
    just performed.</st> <st c="45583">At the end, the widget UI is</st> <st c="45612">being
    updated.</st>
  id: totrans-287
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在本地存储已更新，是时候让*WidgetCenter*重新加载Timeline Provider了。我们应该已经熟悉这个过程了——Timeline Provider获取相关的本地数据，并根据我们刚刚执行的变化构建时间线。最后，小部件UI正在被更新。
- en: <st c="45626">Working with App Intent is also great if we want to share code
    execution between different app components.</st> <st c="45734">For example, we
    can share logic code between our widget and the</st> <st c="45798">Siri Shortcut.</st>
  id: totrans-288
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果我们想在不同的应用组件之间共享代码执行，使用App Intent也是很好的。例如，我们可以在我们的widget和Siri Shortcut之间共享逻辑代码。
- en: <st c="45812">We should remember that even if the widget could have a runtime
    of its own, it is still a good practice to separate our code for better flexibility</st>
    <st c="45961">and modularity.</st>
  id: totrans-289
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该记住，即使小部件可能有它自己的运行时，将我们的代码分离以获得更好的灵活性和模块化仍然是一个好的实践。
- en: <st c="45976">Another great usage for App Intent is the control widget, another
    great addition to iOS 18\.</st> <st c="46069">Let’s go over</st> <st c="46083">it
    now.</st>
  id: totrans-290
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: App Intent的另一个很好的用途是控制小部件，这是iOS 18的另一个伟大补充。现在让我们来了解一下。
- en: <st c="46090">Adding a control widget</st>
  id: totrans-291
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 添加控制小部件
- en: '*<st c="46114">WidgetKit</st>* <st c="46125">provides ways</st> <st c="46139">to
    present our apps in the springboard.</st> <st c="46179">However, it doesn’t stop
    there.</st> <st c="46211">Starting iOS 18, it is possible to present widgets in
    the control center and on the lock screen and even attach an App Intent to the
    action button in iPhone</st> <st c="46368">15 Pro.</st>'
  id: totrans-292
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="46114">WidgetKit</st>* <st c="46125">提供了在启动器中展示我们的应用程序的方法。</st> <st
    c="46139">然而，它并不止于此。</st> <st c="46211">从 iOS 18 开始，我们可以在控制中心和锁屏上展示小部件，甚至可以将应用程序意图附加到
    iPhone 15 Pro 的操作按钮上。</st>'
- en: <st c="46375">Adding a widget to the control center or the lock screen</st>
    <st c="46433">is easy.</st>
  id: totrans-293
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46375">将小部件添加到控制中心或锁屏上</st> <st c="46433">很容易。</st>
- en: <st c="46441">Similar to how we create a widget by conforming to the Widget
    protocol, we need to conform to the</st> `<st c="46540">ControlWidget</st>` <st
    c="46553">protocol to create a control widget.</st> <st c="46591">For example,
    imagine we have an app that helps us control smart home accessories, and we want
    to create a widget</st> <st c="46704">that opens and closes our home’s main door.</st>
    <st c="46748">Let’s start by creating a simple control widget</st> <st c="46796">called</st>
    `<st c="46803">MaindoorControl</st>`<st c="46818">:</st>
  id: totrans-294
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="46441">类似于我们通过遵循小部件协议创建小部件的方式，我们需要遵循</st> `<st c="46540">ControlWidget</st>`
    <st c="46553">协议来创建控制小部件。</st> <st c="46591">例如，想象我们有一个帮助我们控制智能家居配件的应用程序，我们想要创建一个可以打开和关闭我们家的主门的小部件。</st>
    <st c="46704">让我们从创建一个简单的控制小部件开始，命名为</st> `<st c="46803">MaindoorControl</st>`<st
    c="46818">：</st>
- en: '[PRE27]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: <st c="47012">In this code example, the</st> `<st c="47039">MaindoorControl</st>`
    <st c="47054">widget contains the</st> `<st c="47075">body</st>` <st c="47079">variable
    from the time of</st> `<st c="47106">ControlWidgetConfiguration</st>`<st c="47132">.
    This is very similar to how we created a home screen widget under the</st> *<st
    c="47204">Configuring our</st>* *<st c="47220">widget</st>* <st c="47226">section.</st>
  id: totrans-296
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47012">在这个代码示例中，</st> `<st c="47039">MaindoorControl</st>` <st c="47054">小部件包含了从</st>
    `<st c="47075">body</st>` <st c="47079">变量到</st> `<st c="47106">ControlWidgetConfiguration</st>`<st
    c="47132">的时间点。</st> 这与我们如何在</st> *<st c="47204">配置我们的</st>* *<st c="47220">小部件</st>*
    <st c="47226">部分创建一个主屏幕小部件非常相似。</st>
- en: <st c="47235">In this case, we return an instance of the</st> `<st c="47279">StaticControlConfiguration</st>`
    <st c="47305">type, which means we don’t give the user the ability to configure
    it.</st> <st c="47376">However, similar to the home screen widget, we can also
    add a user-configurable control widget by returning</st> `<st c="47484">AppIntentControlConfiguration</st>`
    <st c="47513">(look in the</st> *<st c="47527">Customize our</st>* *<st c="47541">widget</st>*
    <st c="47547">section).</st>
  id: totrans-297
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47235">在这种情况下，我们返回一个</st> `<st c="47279">StaticControlConfiguration</st>`
    <st c="47305">类型的实例，这意味着我们不向用户提供配置它的能力。</st> <st c="47376">然而，类似于主屏幕小部件，我们也可以通过返回</st>
    `<st c="47484">AppIntentControlConfiguration</st>` <st c="47513">（查看</st> *<st
    c="47527">自定义我们的</st>* *<st c="47541">小部件</st>* <st c="47547">部分）来添加一个用户可配置的控制小部件。</st>
- en: <st c="47557">We can add two control widget controls – a toggle and a button.</st>
    <st c="47622">In the case of controlling our home’s main door state, we need to
    add a toggle.</st> <st c="47702">Let’s modify our code and add a</st> `<st c="47734">ControlWidgetToggle</st>`
    <st c="47753">instance:</st>
  id: totrans-298
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="47557">我们可以添加两个控制小部件控件 – 一个切换和一个按钮。</st> <st c="47622">在我们的家庭主门状态控制的情况下，我们需要添加一个切换。</st>
    <st c="47702">让我们修改我们的代码并添加一个</st> `<st c="47734">ControlWidgetToggle</st>` <st
    c="47753">实例：</st>
- en: '[PRE28]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <st c="48141">In this</st> <st c="48150">code example, we add the</st> `<st
    c="48175">ControlWidgetToggle</st>`<st c="48194">, containing the</st> <st c="48211">following
    parameters:</st>
  id: totrans-300
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48141">在这个</st> <st c="48150">代码示例中，我们添加了</st> `<st c="48175">ControlWidgetToggle</st>`<st
    c="48194">，包含以下参数：</st>
- en: '**<st c="48232">A title</st>** <st c="48240">– The widget title that appears
    for the widget in the</st> <st c="48295">widget gallery.</st>'
  id: totrans-301
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**<st c="48232">一个标题</st>** <st c="48240">– 在小部件画廊中显示的小部件标题。</st>'
- en: '`<st c="48310">isOn</st>` <st c="48315">– Here, we connect the widget to the
    actual state in</st> <st c="48369">our app.</st>'
  id: totrans-302
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48310">isOn</st>` <st c="48315">– 在这里，我们将小部件连接到我们应用程序中的实际状态。</st> <st
    c="48369">。</st>'
- en: '`<st c="48377">action</st>` <st c="48384">– The App Intent that runs when the
    user taps our control widget.</st> <st c="48451">We’ll cover that later in</st>
    <st c="48477">this section.</st>'
  id: totrans-303
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48377">action</st>` <st c="48384">– 当用户点击我们的控制小部件时运行的 App Intent。</st>
    <st c="48451">我们将在本节的后面部分介绍这一点。</st>'
- en: '`<st c="48545">Label</st>` <st c="48550">displays the control state’s title
    and</st> <st c="48590">an image.</st>'
  id: totrans-304
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<st c="48545">标签</st>` <st c="48550">显示控制状态的标题和</st> <st c="48590">一个图像。</st>'
- en: <st c="48599">The widget instance is straightforward.</st> <st c="48640">Let’s
    see how it looks in our control center (</st>*<st c="48686">Figure 5</st>**<st
    c="48695">.5</st>*<st c="48697">):</st>
  id: totrans-305
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48599">小部件实例很简单。</st> <st c="48640">让我们看看它在我们的控制中心（</st>*<st c="48686">图
    5</st>**<st c="48695">.5</st>*<st c="48697">）中的样子：</st>
- en: '![Figure 5.5: Our control widget in the control center](img/B21795_05_5.jpg)'
  id: totrans-306
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 5.5：控制中心中的我们的控制小部件](img/B21795_05_5.jpg)'
- en: '<st c="48702">Figure 5.5: Our control widget in the control center</st>'
  id: totrans-307
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="48702">图 5.5：控制中心中的我们的控制小部件</st>
- en: '*<st c="48754">Figure 5</st>**<st c="48763">.5</st>* <st c="48765">shows the
    control center’s main door control widget.</st> <st c="48819">However, there’s
    another side</st> <st c="48849">to our control widget – connecting the control
    widget to the action of opening and closing the main door.</st> <st c="48955">Let’s
    look at the</st> `<st c="48973">MaindoorIntent</st>` <st c="48987">struct we saw
    in the</st> `<st c="49009">action</st>` <st c="49015">parameter:</st>'
  id: totrans-308
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*<st c="48754">图 5</st>**<st c="48763">.5</st>* <st c="48765">显示了控制中心的主门控制小部件。</st>
    <st c="48819">然而，我们的控制小部件还有另一个方面</st> <st c="48849">——将控制小部件连接到打开和关闭主门的操作。</st>
    <st c="48955">让我们看看我们在</st> `<st c="48973">MaindoorIntent</st>` <st c="48987">参数中看到的</st>
    `<st c="49009">action</st>` <st c="49015">结构：</st>'
- en: '[PRE29]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <st c="49275">In this code example, we see the</st> `<st c="49309">MaindoorIntent</st>`
    <st c="49323">implementation.</st> <st c="49340">The</st> `<st c="49344">MaindoorIntent</st>`
    <st c="49358">structure conforms to the</st> `<st c="49385">SetValueIntent</st>`
    <st c="49399">protocol, which contains a value we can set.</st> <st c="49445">In
    this example, the value is from the</st> `<st c="49484">Bool</st>` <st c="49488">type,
    which we can use to perform the</st> <st c="49527">desired operation.</st>
  id: totrans-310
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49275">在这个代码示例中，我们看到了</st> `<st c="49309">MaindoorIntent</st>` <st c="49323">实现。</st>
    <st c="49340">`<st c="49344">MaindoorIntent</st>` <st c="49358">结构符合`<st c="49385">SetValueIntent</st>`
    <st c="49399">协议，该协议包含一个我们可以设置的值。</st> <st c="49445">在这个例子中，值来自`<st c="49484">Bool</st>`
    <st c="49488">类型，我们可以用它来执行</st> <st c="49527">所需的操作。</st>
- en: <st c="49545">Adding a</st> <st c="49555">control widget to our app involves
    similar practices that we saw when we added a home screen widget and app intents
    that allow us to share code between widgets and other</st> <st c="49725">app components.</st>
  id: totrans-311
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49545">将控制小部件添加到我们的应用程序中涉及我们在添加主屏幕小部件和允许我们在小部件和其他</st> <st c="49725">应用程序组件之间共享代码的应用程序意图时看到的类似做法。</st>
- en: <st c="49740">Summary</st>
  id: totrans-312
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49740">摘要</st>
- en: <st c="49748">Widgets are enjoyable and fun UI elements we can work with in
    iOS development.</st> <st c="49828">They provide sleek UI, great animation, and
    a glanceable user experience.</st> <st c="49902">We have seen that each iOS version
    has added interesting new widget capabilities to make widgets more powerful</st>
    <st c="50013">than ever.</st>
  id: totrans-313
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="49748">小部件是我们在 iOS 开发中可以与之交互的有趣且有趣的 UI 元素。</st> <st c="49828">它们提供流畅的
    UI、出色的动画和可一览无余的用户体验。</st> <st c="49902">我们已经看到，每个 iOS 版本都添加了有趣的新小部件功能，使小部件比以往任何时候都更强大</st>
    <st c="50013">。</st>
- en: <st c="50023">In this chapter, we learned about the idea of widgets, how to
    add widgets, creating a timeline, and adding user-configurable options.</st> <st
    c="50158">Also, we learned how to create custom animations and even add user interaction.</st>
    *<st c="50238">WidgetKit</st>* <st c="50248">has become a fascinating framework
    to work with.</st> <st c="50297">In the next chapter, we’ll continue to discover
    how to improve the user experience, this time with</st> <st c="50396">SwiftUI
    animations.</st>
  id: totrans-314
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: <st c="50023">在本章中，我们了解了小部件的概念、如何添加小部件、创建时间线以及添加用户可配置选项。</st> <st c="50158">此外，我们还学习了如何创建自定义动画，甚至添加用户交互。</st>
    *<st c="50238">WidgetKit</st>* <st c="50248">已经成为一个令人着迷的框架。</st> <st c="50297">在下一章中，我们将继续探讨如何改进用户体验，这次我们将使用</st>
    <st c="50396">SwiftUI 动画。</st>
- en: '[PRE30]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
