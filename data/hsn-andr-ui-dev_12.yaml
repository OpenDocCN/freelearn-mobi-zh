- en: Customizing Widgets and Layouts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义小部件和布局
- en: In everyday development on Android, you'll find that the core platform and support
    libraries offer a wide range of widgets and layouts for you to build your application.
    There are also a wealth of open source and third-party widgets available on the
    internet. The *Android Arsenal* website ([https://android-arsenal.com/](https://android-arsenal.com/))
    is a well-cataloged list of APIs available for Android, and it is an excellent
    starting point when you need some functionality that is not available in the platform
    or support libraries. Even with this massive wealth of available widgets and libraries,
    you'll sometimes find yourself wanting a widget that hasn't already been built.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android的日常开发中，你会发现核心平台和支持库为你提供了广泛的组件和布局，以构建你的应用程序。互联网上也有大量的开源和第三方小部件。*Android
    Arsenal*网站([https://android-arsenal.com/](https://android-arsenal.com/))是一个对Android可用的API进行了良好分类的列表，当你需要平台或支持库中不可用的功能时，它是一个极好的起点。即使有如此丰富的可用小部件和库，有时你也会发现自己想要一个尚未构建的小部件。
- en: Creating your own widgets on any platform is a sizable undertaking. Widgets
    need to be able to render themselves to look as native as possible using graphics
    primitives such as lines, arcs, circles, and polygons. Many Android widgets (such
    as `Button`) avoid having to do this using the excellent `Drawable` class and
    resources. This enables you to customize the look of widgets simply by changing
    the drawable resources they use to a stateful drawable (as you did with the `RadioButton`
    widgets in [Chapter 2](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml), *Designing
    Form Screens*).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何平台上创建自己的小部件是一项庞大的任务。小部件需要能够使用图形原语（如线条、弧线、圆形和多边形）渲染自己，以尽可能看起来像原生应用。许多Android小部件（如`Button`）通过使用优秀的`Drawable`类和资源来避免这样做。这使得你只需通过更改小部件使用的可绘制资源（如你在[第2章](6ed5cfcb-b233-4bf0-b6fd-012432897224.xhtml)，*设计表单屏幕*）中使用的状态可绘制资源，就可以简单地自定义小部件的外观。
- en: 'In this chapter, we''ll take a look at how to build custom widgets and layout
    components. We''ll take a look at the best practices to use when building your
    own `View` implementations, and how to render 2D graphics using the Android graphics
    APIs. Specifically, we''ll explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何构建自定义小部件和布局组件。我们将探讨在构建自己的`View`实现时应该遵循的最佳实践，以及如何使用Android图形API渲染2D图形。具体来说，我们将探讨以下内容：
- en: Creating a completely custom `View` class
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个完全自定义的`View`类
- en: Rendering 2D graphics using graphics primitives
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用图形原语渲染2D图形
- en: How to create a custom `ViewGroup` to produce custom layout effects
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建一个自定义的`ViewGroup`以产生自定义布局效果
- en: Rendering animations using `Drawable` objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Drawable`对象渲染动画
- en: Creating `View` classes that self-animate
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建能够自我动画的`View`类
- en: Creating custom view implementations
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义视图实现
- en: 'Sometimes, the existing widgets just aren''t enough, no matter how much you
    customize them. Sometimes, you need to display something that simply isn''t supported
    by the platform. In these cases, you might find yourself needing to implement
    your own custom widget. The `View` class can be easily extended to produce many
    different effects, but there are a few things that are worth knowing before you
    tackle it:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，现有的小部件无论你如何自定义都不够用。有时候，你需要显示平台不支持的东西。在这些情况下，你可能需要实现自己的自定义小部件。`View`类可以轻松扩展以产生许多不同的效果，但在你着手之前，有一些事情是值得了解的：
- en: The rendering for a `View` is expected to happen in the `onDraw` method.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 预期`View`的渲染将在`onDraw`方法中发生。
- en: When rendering the graphics for the `View`, you'll use a `Canvas` to send the
    drawing instructions.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当渲染`View`的图形时，你将使用`Canvas`来发送绘图指令。
- en: Each `View` is responsible for calculating the offsets for its padding, and
    by default, the graphics will be clipped to these dimensions.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个`View`负责计算其填充的偏移量，并且默认情况下，图形将被裁剪到这些维度。
- en: You should avoid any object allocation (including arrays, if possible) in the
    `onDraw` method. The `onDraw` methods are probably the most time-sensitive method
    calls in any application, and need to produce as little garbage as possible. Any
    object allocations should be done in other methods and just used in the `onDraw`
    implementation.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该避免在`onDraw`方法中进行任何对象分配（包括数组，如果可能的话）。`onDraw`方法可能是任何应用程序中最时间敏感的方法调用，需要尽可能产生最少的垃圾。任何对象分配都应该在其他方法中完成，并在`onDraw`实现中仅使用。
- en: 'In the travel claims example, it will be really nice if the user can see a
    simple overview graph of their spending for the last few days. To do this, we''ll
    need to write a class that can draw this graph for them. It''s useful to be able
    to change some of the `View` attributes (specifically, the size and color of the
    line graph) using the layout XML file. For this, you''ll need to specify the attribute
    names and their type information for the layout resource compiler. Follow these
    instructions to write a simple line-graph `View` implementation:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在旅行报销示例中，如果用户能看到他们过去几天支出的简单概述图，那将非常棒。为此，我们需要编写一个能够为他们绘制此图的类。能够使用布局XML文件更改一些`View`属性（特别是线形图的尺寸和颜色）很有用。为此，你需要指定属性名称及其类型信息，以便布局资源编译器使用。按照以下说明编写简单的线形图`View`实现：
- en: Right-click on the `res/values` resource directory in the travel claim app and
    select New| Values resource file.
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旅行报销应用中的`res/values`资源目录上右键单击，然后选择“新建”|“值资源文件”。
- en: Name the new file `attrs_spending_graph_view`.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件命名为`attrs_spending_graph_view`。
- en: Click OK to create the new resource file.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的资源文件。
- en: 'You''ll use this file to declare some new XML attributes for the resource compiler
    that can be used in your layout XML files when dealing with your new graph `View`
    class. These XML attributes are given type information (in the form of a `format`
    attribute), which affects how the resource compiler handles them in the layout
    XML:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将使用此文件声明一些新的XML属性，供资源编译器使用，这些属性可以在处理你的新图`View`类时用在布局XML文件中。这些XML属性提供了类型信息（以`format`属性的形式），这会影响资源编译器在布局XML中处理它们的方式：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Now, right-click on the widget package and select New| Java Class.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在组件包上右键单击，然后选择“新建”|“Java类”。
- en: Name the new class `SpendingGraphView`.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为`SpendingGraphView`。
- en: Change the `Superclass` to `android.view.View`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Superclass`更改为`android.view.View`。
- en: Click OK to create the new class.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的类。
- en: 'In the `SpendingGraphView`, declare variables to hold the values that can be
    specified in the layout XML files. These should typically reflect the names used
    in the XML file, and should be initialized with sensible default values:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SpendingGraphView`中声明变量以保存可以在布局XML文件中指定的值。这些变量通常应反映XML文件中使用的名称，并且应使用合理的默认值初始化：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, declare an array for the data points to be rendered into the graph. In
    this implementation, we''ll assume that each data point is the amount spent on
    an unspecified day:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明一个数组以将数据点渲染到图中。在这个实现中，我们假设每个数据点是某个未指定日期的花费金额：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As mentioned earlier, the `onDraw` implementation should have to do as little
    work as possible. In this graph implementation, it means that the entire graph
    is actually calculated ahead of time, and cached in local variables to be drawn
    in the `onDraw` method. The Android graphics APIs provide a `Path` class to define
    any abstract group of connected lines, and the `Paint` class that defines the
    colors, stroke size (pen), fill-style, and so on. You''ll need to declare one
    of each of these to be calculated and rendered:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，`onDraw`实现应尽可能少做工作。在这个图形实现中，这意味着整个图形实际上是提前计算好的，并缓存到局部变量中，以便在`onDraw`方法中绘制。Android图形API提供了一个`Path`类，用于定义任何抽象的连接线组，以及一个`Paint`类，用于定义颜色、笔触大小（笔）、填充样式等。你需要声明一个`Path`和一个`Paint`，以便计算和渲染：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Storing the widget's rendering state on a field in the class might seem to go
    against everything you know about where you should store and pass state, but a
    widget is a form of state container. Its job is to present its state to the user
    and to capture events to trigger state changes. Keeping the construction of the
    graphics primitives out of the `onDraw` implementation means that the graphics
    pipeline isn't slowed by recalculating the graphics state from the graph data
    for every frame.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的字段中存储小部件的渲染状态似乎与您所知道的状态存储和传递的位置相矛盾，但小部件是一种状态容器。其任务是向用户展示其状态并捕获事件以触发状态变化。将图形原语的建设从`onDraw`实现中排除，意味着图形管道不会被每帧从图形数据重新计算图形状态而减慢。
- en: 'Now, implement the standard constructors for a `View` class. You''ll want all
    of these constructors to invoke a single `init()` method to handle the actual
    initialization of the widget, which in this case, will also need to fetch and
    read the attributes given in the layout XML:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现一个`View`类的标准构造函数。你希望所有这些构造函数都调用一个单独的`init()`方法来处理小部件的实际初始化，在这种情况下，还需要从布局XML中获取并读取属性：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, implement the `init` method and use the `Context` to convert the `AttributeSet`
    object and its data into a `TypedArray` object. This is where all the style information
    is merged in from the current `Theme` of the application. When you are finished
    with a `TypedArray`, you need to recycle them, handing them back to the platform
    to be reused. This helps the performance of the `obtainStyledAttributes` method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，实现 `init` 方法并使用 `Context` 将 `AttributeSet` 对象及其数据转换为 `TypedArray` 对象。这是从应用程序的当前
    `Theme` 中合并所有样式信息的地方。当你完成一个 `TypedArray` 后，你需要回收它们，将它们交还给平台以供重用。这有助于 `obtainStyledAttributes`
    方法的性能：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In order to paint the graph correctly, you''ll need a utility method to help
    find the scale of the vertical axis. This involves finding the maximum value that
    the graph will have, and unfortunately, the Android platform doesn''t expose a
    method to do this directly, so you''ll need to implement it yourself:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了正确绘制图表，你需要一个实用方法来帮助找到垂直轴的刻度。这涉及到找到图表将具有的最大值，不幸的是，Android 平台没有直接提供方法来做这件事，所以你需要自己实现它：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The next step is to implement the actual rendering method for the graph data.
    This method will be invoked on the main thread, but won''t be invoked as part
    of the rendering loop. Instead, you''ll calculate all the values and plot the
    graph using a `Path` object (a vector graphics primitive). Then, this method will
    store the plotted line and the `Paint` to use in the path and paint fields you
    declared, and signal that the `View` is *invalid* and needs to have its `onDraw`
    method called as soon as possible:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是实现图表数据的实际渲染方法。此方法将在主线程上调用，但不会作为渲染循环的一部分调用。相反，你将计算所有值并使用 `Path` 对象（矢量图形原语）绘制图表。然后，此方法将存储绘制的线条和要用于路径和绘制字段的
    `Paint`，并发出信号，表示 `View` 是 *无效的*，需要尽快调用其 `onDraw` 方法：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It would actually be quite possible to encapsulate this code in an `ActionCommand`
    or `AsyncTask`, so that these calculations don't block the main thread. You will
    need to invoke the `invalidate()` method in `onForeground()`, or use the `postInvalidate()`
    method instead (which posts the `invalidate()` signal to the main thread). Moving
    such complexity to a background thread is good practice if the amount of data
    the graph is expected to present became very large.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，将此代码封装在 `ActionCommand` 或 `AsyncTask` 中是完全可能的，这样这些计算就不会阻塞主线程。你需要在 `onForeground()`
    中调用 `invalidate()` 方法，或者使用 `postInvalidate()` 方法代替（它将 `invalidate()` 信号发送到主线程）。如果图表预期展示的数据量非常大，将这种复杂性移动到后台线程是良好的实践。
- en: 'Now, you''re ready to override the `onDraw` method and actually paint the graph
    onto the `Canvas` provided by the platform. This `onDraw` implementation simply
    verifies that the graph has been rendered, and then paints the fields onto the
    screen:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你已经准备好覆盖 `onDraw` 方法，并在平台提供的 `Canvas` 上实际绘制图表。这个 `onDraw` 实现只是简单地验证图表是否已渲染，然后将字段绘制到屏幕上：
- en: '[PRE8]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: It's useful to know that you can construct a `Canvas` yourself by having it
    paint to an offscreen `Bitmap` object, allowing you to capture *screenshots* of
    widgets by invoking their `onDraw` method yourself.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有用的事实是，你可以通过让它在一个离屏的 `Bitmap` 对象上绘制来自己构建一个 `Canvas`，这样你就可以通过调用它们的 `onDraw` 方法来捕获
    *屏幕截图*。
- en: 'Now, you just need a few getter and setter methods to allow your application
    to specify the data to be rendered, and a programmatic way to change and fetch
    the XML attribute values. The setter methods also need to invoke the `invalidateGraph()`
    method to cause the data to be recalculated and rendered:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你只需要几个获取器和设置器方法，以便让应用程序指定要渲染的数据，以及一个程序化的方式来更改和获取 XML 属性值。设置器方法还需要调用 `invalidateGraph()`
    方法，以使数据被重新计算并渲染：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `SpendingGraphView` requires that its actual data is delivered programmatically
    using the `setSpendingPerDay` method. This can, fortunately, be done easily using
    the data-binding system, which will also keep the data up to date when the data
    changes.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpendingGraphView` 需要通过 `setSpendingPerDay` 方法以编程方式传递其实际数据。幸运的是，这可以通过数据绑定系统轻松完成，该系统还会在数据更改时保持数据更新。'
- en: Integrating the SpendingGraphView
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成 SpendingGraphView
- en: 'Integrating the `SpendingGraphView` into an application is as simple as declaring
    it in your layout XML file, and providing it with some data points to render:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `SpendingGraphView` 集成到应用程序中就像在布局 XML 文件中声明它一样简单，并给它提供一些数据点以进行渲染：
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can also programmatically find the `SpendingGraphView` using `findViewById`,
    and invoke the `setSpendingPerDay` method from your Java code. Integrating the
    `SpendingGraphView` into the travel claim example is a little more complex. The
    graph belongs on the overview screen, since it gives the user a quick visual indication
    of what their last few days of spending have looked like. If the user starts scrolling,
    the graph needs to scroll off the screen so that there is more screen space for
    the claim items. A nice way to do this is to leverage the `DisplayItem` class
    you wrote to handle the spacers, and simply add one at the beginning of the overview.
    Let''s integrate the new `SpendingGraphView` with the overview screen:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以使用 `findViewById` 编程查找 `SpendingGraphView`，并从您的 Java 代码中调用 `setSpendingPerDay`
    方法。将 `SpendingGraphView` 集成到旅行索赔示例中稍微复杂一些。该图表应位于概览屏幕上，因为它可以快速直观地显示用户过去几天的消费情况。如果用户开始滚动，图表需要从屏幕上滚动出去，以便为索赔项腾出更多屏幕空间。一个不错的方法是利用您编写的
    `DisplayItem` 类来处理间隔，并在概览的开始处添加一个。让我们将新的 `SpendingGraphView` 集成到概览屏幕中：
- en: Right-click on the res/layout directory and select New| Layout resource file.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `res/layout` 目录，然后选择“新建”|“布局资源文件”。
- en: Name the new resource file `card_spending_graph`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新资源文件命名为 `card_spending_graph`。
- en: Change the Root element to be `layout`.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将根元素更改为 `layout`。
- en: Click OK to create the new resource file.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的资源文件。
- en: 'This layout resource will be used with the `DataBoundViewHolder`, and we''ll
    be passing the spending-per-day indirectly as the `item` variable. It''s also
    worth noting that the XML namespace for your custom attributes on the `SpendingGraphView`
    (`strokeColor` and `strokeWidth`) is the `app` namespace. This is what the layout
    resource should look like:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此布局资源将与 `DataBoundViewHolder` 一起使用，我们将间接通过 `item` 变量传递每日消费。还值得注意的是，您的 `SpendingGraphView`
    上的自定义属性（`strokeColor` 和 `strokeWidth`）的 XML 命名空间是 `app` 命名空间。布局资源应该看起来像这样：
- en: '[PRE11]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Use the Code Assistant on the `layout_height` attribute to create a new dimension
    value named `spending_graph_height` (as was just highlighted) in your `dimens.xml`
    values resource file:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `layout_height` 属性上的代码助手，在您的 `dimens.xml` 值资源文件中创建一个名为 `spending_graph_height`
    的新维度值（正如刚刚所强调的）：
- en: '[PRE12]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Open the `ClaimItemAdapter` source file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ClaimItemAdapter` 源文件。
- en: 'Most of the changes will be in the `CreateDisplayListCommand` inner class.
    You''ll need to calculate the user''s spending for a selection of recent days.
    To do this, you''ll need to know how many days ago each claim was, so that you
    can add its amount to the correct day. This method simply counts backward one
    day at a time, until it reaches the given timestamp:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 大多数更改将在 `CreateDisplayListCommand` 内部类中。您需要计算用户最近几天内的消费，为此，您需要知道每个索赔距离今天有多少天，以便可以将其金额添加到正确的日期。此方法简单地逐日倒退，直到达到给定的时间戳：
- en: '[PRE13]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Time APIs such as JODA time ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/))
    and the Java 8 time APIs offer methods specifically for calculating the difference
    between two instants in time (in various different time units). However, the use
    of these APIs is beyond the scope of this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 时间 API，如 JODA 时间 ([http://www.joda.org/joda-time/](http://www.joda.org/joda-time/))
    和 Java 8 时间 API，提供了专门用于计算两个时间点之间差异（以各种不同的时间单位）的方法。然而，这些 API 的使用超出了本书的范围。
- en: 'Next, you''ll need another method in the `CreateDisplayListCommand` to create
    the array of amounts representing the user''s spending over the last few days.
    To keep the implementation simple and quick, we limit this to ten days by default.
    The `getSpendingPerDay` method creates a double for each of these days, and adds
    the amounts to each double for the `ClaimItem` objects filed on each day:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，您需要在 `CreateDisplayListCommand` 中添加另一个方法来创建表示用户过去几天消费的金额数组。为了使实现简单快捷，我们默认将其限制为十天。`getSpendingPerDay`
    方法为这些天中的每一天创建一个双精度浮点数，并将每天的 `ClaimItem` 对象的金额添加到每个双精度浮点数中：
- en: '[PRE14]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The final thing to do in the `CreateDisplayListCommand`, is to create a `DisplayItem`
    as the first item in the list:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CreateDisplayListCommand` 中要做的最后一件事是，在列表中创建一个 `DisplayItem` 作为第一个条目：
- en: '[PRE15]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You''ll also need to add some new code to the `UpdateDisplayListCommand` inner
    class, because it doesn''t know how to compare the spending graph for the `DiffUtil`.
    In the implementation of the `areItemsTheSame` method in the `DiffUtil.Callback`,
    you can treat the `card_spending_graph` layout resources exactly the same as the
    separators, because there is only one of them in the list:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你还需要向 `UpdateDisplayListCommand` 内部类添加一些新代码，因为它不知道如何比较 `DiffUtil` 的支出图。在 `DiffUtil.Callback`
    中 `areItemsTheSame` 方法的实现中，你可以将 `card_spending_graph` 布局资源与分隔符完全相同对待，因为在列表中只有一个：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, you also need the `DiffUtil` to detect that the graph data may have
    changed. In this case, we simply assume that the data has changed, and force the
    `RecyclerView` to bind the new data points to the existing `SpendingGraphView`:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然而，你还需要 `DiffUtil` 来检测图数据可能已更改。在这种情况下，我们简单地假设数据已更改，并强制 `RecyclerView` 将新的数据点绑定到现有的
    `SpendingGraphView`：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The one last thing to ensure is that the user can't swipe the `SpendingGraphView`
    to delete it from the `RecyclerView`, as this will be a huge surprise for the
    user. Open the `OverviewActivity` source file and locate the `SwipeToDeleteCallback`
    inner class.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后要确保的是用户不能通过滑动 `SpendingGraphView` 来从 `RecyclerView` 中删除它，因为这将对用户来说是一个巨大的惊喜。打开
    `OverviewActivity` 源文件并定位到 `SwipeToDeleteCallback` 内部类。
- en: 'We need to tell the `ItemTouchHelper` that the first item in the list cannot
    be swiped or moved. We do this by overriding the default `getMovementFlags` method.
    This method usually just returns the flags that you passed into the constructor,
    but you now want these flags to change for just one item:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要通知 `ItemTouchHelper` 列表中的第一个项目不能滑动或移动。我们通过重写默认的 `getMovementFlags` 方法来实现这一点。此方法通常只返回传递给构造函数的标志，但现在你希望这些标志仅对单个项目进行更改：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Creating a layout implementation
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建布局实现
- en: In most applications, you'll find that a combination of the `ConstraintLayout`,
    `CoordinatorLayout`, and some of the more primitive layout classes (such as `LinearLayout`
    and `FrameLayout)`) are more than enough to achieve any layout requirements you
    can dream up for your user interface. Every now and again though, you'll find
    yourself needing a custom layout manager to achieve an effect required for the
    application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数应用程序中，你会发现 `ConstraintLayout`、`CoordinatorLayout` 以及一些更原始的布局类（如 `LinearLayout`
    和 `FrameLayout`）的组合已经足够满足你为用户界面设计的任何布局需求。然而，偶尔你也会发现自己需要自定义布局管理器来实现应用程序所需的特定效果。
- en: 'Layout classes extend from the `ViewGroup` class, and their job is to tell
    their child widgets where to position themselves, and how large they should be.
    They do this in two phases: the measurement phase and the layout phase.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 布局类从 `ViewGroup` 类扩展，它们的工作是告诉它们的子小部件它们应该放置的位置以及它们应该有多大。它们通过两个阶段来完成这项工作：测量阶段和布局阶段。
- en: All `View` implementations are expected to provide measurements for their actual
    size according to specifications. These measurements are then used by the `View`
    widget's parent `ViewGroup` to allocate the amount of space the widget will consume
    on the screen. For example, a `View` might be told to consume, at most, the screen
    width. The `View` must then determine how much of that space it actually requires,
    and records that size in its **measured dimensions**. The measured dimensions
    are then used by the parent `ViewGroup` during the layout process.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 `View` 实现都应按照规范提供其实际大小的测量值。这些测量值随后被 `View` 小部件的父 `ViewGroup` 用于分配小部件在屏幕上所占用的空间。例如，一个
    `View` 可能被指示最多消耗屏幕宽度。然后 `View` 必须确定它实际需要多少空间，并将该尺寸记录在其 **测量尺寸** 中。测量尺寸随后在布局过程中被父
    `ViewGroup` 使用。
- en: The second phase is the layout phase, and it is conducted by the `ViewGroup`
    parent of each `View` widget. This phase positions the `View` on the screen, relative
    to its parent `ViewGroup` location, and specifies the actual size that the widget
    will consume on the screen (typically based on the measured size calculated in
    the measurement phase).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个阶段是布局阶段，由每个 `View` 小部件的父 `ViewGroup` 执行。此阶段将 `View` 定位在屏幕上，相对于其父 `ViewGroup`
    的位置，并指定小部件将在屏幕上消耗的实际大小（通常基于测量阶段计算出的测量大小）。
- en: When you implement your own `ViewGroup`, you'll need to ensure that all of your
    child `View` widgets are given a chance to measure themselves before you perform
    the actual layout operations.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当你实现自己的 `ViewGroup` 时，你需要确保在执行实际的布局操作之前，所有子 `View` 小部件都有机会测量自己。
- en: 'Let''s build a layout class to arrange its children in a circle. To keep the
    implementation simple, we''ll assume that all the child widgets are the same size
    (for example, if they were all icons):'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建一个布局类，以使其子项呈圆形排列。为了保持实现简单，我们假设所有子小部件具有相同的大小（例如，如果它们都是图标）：
- en: Right-click on the `widget` package in the travel claim example app, and select
    New| Java Class.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在旅行报销示例应用中的 `widget` 包上右键单击，然后选择 New| Java Class。
- en: Name the new class `CircleLayout`.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新类命名为 `CircleLayout`。
- en: Change the Superclass to `android.view.ViewGroup`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将超类更改为 `android.view.ViewGroup`。
- en: Click OK to create the new class.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 OK 创建新类。
- en: 'Declare the standard `ViewGroup` constructors:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明标准的 `ViewGroup` 构造函数：
- en: '[PRE19]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Override the `onMeasure` method to calculate the size of the `CircleLayout`
    and all of its child `View` widgets. The measurement specifications are passed
    in as `int` values, which are interpreted using the `static` methods in the `MeaureSpec`
    class. Measurement specifications come in two flavors: *at most* and *exactly*,
    and each has a *size* value attached. In this particular layout, we always measure
    the `CircleLayout` as the size given in the specification. This means that the
    `CircleLayout` will always consume the maximum amount of space available. It also
    expects all of its children to be able to specify sizes without the `match_parent`
    attribute (as this will cause each child to take up all the available space):'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写 `onMeasure` 方法以计算 `CircleLayout` 及其所有子 `View` 小部件的大小。测量规范以 `int` 值的形式传入，这些值使用
    `MeaureSpec` 类中的 `static` 方法进行解释。测量规范有两种类型：*最多* 和 *正好*，每种类型都附加一个 *大小* 值。在这个特定的布局中，我们始终将
    `CircleLayout` 测量为其规范中给出的大小。这意味着 `CircleLayout` 将始终消耗可用的最大空间。它还期望所有子项能够指定大小，而无需
    `match_parent` 属性（因为这会导致每个子项占用所有可用空间）：
- en: '[PRE20]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next method to implement is the `onLayout` method. This performs the actual
    arrangement of the child `View` widget within the `CircleLayout`, by invoking
    their `layout` method. The `layout` method should never be overridden, because
    it''s closely tied to the platform and performs several other important actions
    (such as notifying layout listeners). Instead, you should override `onLayout`,
    but invoking `layout.CircleLayout` assumes that all the child `View` widgets are
    of the same size (and forces this as part of the `onLayout` implementation). This
    `onLayout` method simply calculates the available space, and then positions the
    child `View` widgets in a circle around the outside edge:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要实现的方法是 `onLayout` 方法。这个方法负责在 `CircleLayout` 中对子 `View` 小部件进行实际排列，通过调用它们的
    `layout` 方法。`layout` 方法不应该被重写，因为它与平台紧密相关，并执行多个其他重要操作（例如通知布局监听器）。相反，你应该重写 `onLayout`，但调用
    `layout.CircleLayout` 假设所有子 `View` 小部件具有相同的大小（并在 `onLayout` 实现中强制执行这一点）。这个 `onLayout`
    方法只是计算可用空间，然后将子 `View` 小部件定位在边缘周围的一个圆圈中：
- en: '[PRE21]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the implementation of the `onLayout` method is quite long, it's also
    relatively simple. Most of the code is concerned with determining the desired
    position of the child `View` widgets. Layout code needs to execute as quickly
    as possible, and should avoid allocating any objects during the `onMeasure` and
    `onLayout` methods (similar to the rules of `onDraw`). Layout is a critical part
    of building the screen from a performance standpoint, because no rendering can
    actually occur without the layout being completed. The layout will also be rerun
    every time the layout changes its structure. For example, if you add or remove
    any child `View` widgets, or change the size or position of the `ViewGroup`. Changing
    the size of a `ViewGroup` might happen on every frame if you use a `CoordinatorLayout`,
    where the `ViewGroup` is being collapsed (or if you change its size as part of
    a property-animation).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `onLayout` 方法的实现相当长，但它也很简单。大部分代码都关注于确定子 `View` 小部件的期望位置。布局代码需要尽可能快地执行，并且在
    `onMeasure` 和 `onLayout` 方法中应避免分配任何对象（类似于 `onDraw` 的规则）。从性能角度来看，布局是构建屏幕的关键部分，因为没有完成布局，实际上无法进行渲染。每次布局结构发生变化时，布局都会重新运行。例如，如果你添加或删除任何子
    `View` 小部件，或者更改 `ViewGroup` 的大小或位置。如果你使用 `CoordinatorLayout`，其中 `ViewGroup` 正在折叠（或者如果你将其大小作为属性动画的一部分进行更改），则
    `ViewGroup` 的大小可能会在每一帧中更改。
- en: Creating animated views
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建动画视图
- en: Most widget animation can be taken care of using the animation APIs in Android.
    The standard animation APIs are designed to take care of animations with a defined
    start and end, or animations that form a simple loop. Some animations, however,
    don't fit into this mold; a good example would be a game. A game has many animations
    running continuously, and you can even think about the entire game screen as a
    single, continuous animation.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数小部件动画可以使用Android中的动画API来处理。标准的动画API旨在处理具有定义的开始和结束的动画，或者形成简单循环的动画。然而，有些动画不适合这种模式；一个很好的例子就是游戏。游戏有许多连续运行的动画，你甚至可以将整个游戏屏幕视为一个单一的、连续的动画。
- en: There are a number of widgets that need to be continuously animated, and your
    standard Android animation API won't work. In these cases, you'll need a `View`
    that can continuously animate and update itself as long as it's visible to the
    user. In these cases, a slightly different design is called for, as the widget
    will always be changing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多小部件需要连续动画化，而你标准的Android动画API将不起作用。在这些情况下，你需要一个可以连续动画并更新自己的`View`，只要它对用户可见。在这些情况下，需要稍微不同的设计，因为小部件将始终在变化。
- en: 'To illustrate how to write a widget that has a continuous animation, let''s
    write a `View` class that animates some number of bouncing `Drawable` objects.
    Each `Drawable` will be tracked separately, and when it reaches a side, it will
    "bounce off", and head in the other direction. This class is unrelated to the
    travel claim example code, so you can add it to a new project if you like. Follow
    these steps to write a `BouncingDrawablesView`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明如何编写一个具有连续动画的小部件，让我们编写一个`View`类，该类将动画化一些弹跳的`Drawable`对象。每个`Drawable`将被单独跟踪，当它到达一边时，它将“弹跳”并朝相反方向前进。这个类与旅行索赔示例代码无关，所以如果你喜欢，可以将其添加到新项目中。按照以下步骤编写`BouncingDrawablesView`：
- en: On your default package, select New| Java Class.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的默认包中，选择“新建| Java类”。
- en: Name the class `widget.BouncingDrawablesView`.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将类命名为`widget.BouncingDrawablesView`。
- en: Make the Superclass `android.view.View`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将父类设置为`android.view.View`。
- en: Click on OK to create the new class.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“确定”以创建新的班级。
- en: 'You''ll have some number of bouncing objects in the scene, and you''ll need
    to track both their position and speed vector. For this, you''ll want to encapsulate
    each bouncing `Drawable` in a `Bouncer` object; we''ll write this as an inner
    class:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景中将有若干弹跳对象，你需要跟踪它们的位置和速度向量。为此，你希望将每个弹跳的`Drawable`封装在`Bouncer`对象中；我们将将其编写为内部类：
- en: '[PRE22]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The next thing to do in the `Bouncer` inner class is to create a single `step`
    method, which will set up the `Bouncer` for the next animation frame to be rendered.
    This method will take a parameter that represents the boundaries of the *field*
    it''s being rendered on. If the next position collides with any of the edges of
    the field, the `Bouncer` will avoid crossing the edge and will reverse direction
    on the axis it would have collided with:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Bouncer`内部类中接下来要做的事情是创建一个单独的`step`方法，该方法将为下一个要渲染的动画帧设置`Bouncer`。此方法将接受一个参数，表示它正在渲染的*字段*的边界。如果下一个位置与字段的任何边缘发生碰撞，`Bouncer`将避免越过边缘，并在可能碰撞的轴上反转方向：
- en: '[PRE23]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `Bouncer` class also needs a convenient draw method that will update the
    boundaries of the `Drawable`, before rendering it to a given `Canvas` object.
    The `Bouncer` keeps track of its own boundaries, so that all the `Bouncer` instances
    can actually share the same `Drawable` instance, and simply paint it at different
    locations on the field:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Bouncer`类还需要一个方便的绘制方法，该方法将在将`Drawable`渲染到给定的`Canvas`对象之前更新`Drawable`的边界。`Bouncer`跟踪自己的边界，因此所有`Bouncer`实例实际上可以共享同一个`Drawable`实例，只需在不同的位置在字段上绘制它即可：'
- en: '[PRE24]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, in the `BouncingDrawablesView`, declare an array of `Bouncer` objects
    that will be contained and animated by the `View` implementation:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`BouncingDrawablesView`中，声明一个`Bouncer`对象的数组，这些对象将被`View`实现包含和动画化：
- en: '[PRE25]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `BouncingDrawableView` also needs a status field to track whether it should
    be animating or not:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BouncingDrawableView`还需要一个状态字段来跟踪它是否应该进行动画：'
- en: '[PRE26]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, declare the standard `View` implementation constructors:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，声明标准的`View`实现构造函数：
- en: '[PRE27]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Implement the `onDraw` method by simply telling each of the `Bouncer` objects
    to paint themselves:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过简单地告诉每个`Bouncer`对象绘制自己来实现`onDraw`方法：
- en: '[PRE28]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Next, you''ll need to implement that actual logic to animate each frame. Do
    this by creating an `onNextFrame` method that first checks whether the animation
    should still be running (if it''s not running, we stop the animation), and then
    tells each `Bouncer` to move one step in the animation. After you''ve set up the
    next animation frame, you''ll need to tell the platform to repaint the `BouncingDrawablesView`,
    by calling the `invalidate()` method. Once the `onNextFrame()` method is complete,
    we schedule it to be invoked again in 16 milliseconds time (scheduling just under
    60 frames per second):'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要实现实际逻辑来动画每一帧。通过创建一个 `onNextFrame` 方法来实现，这个方法首先检查动画是否应该继续运行（如果它没有运行，我们停止动画），然后告诉每个
    `Bouncer` 在动画中移动一步。在你设置了下一个动画帧之后，你需要通过调用 `invalidate()` 方法告诉平台重新绘制 `BouncingDrawablesView`。一旦
    `onNextFrame()` 方法完成，我们将它安排在 16 毫秒后再次调用（安排每秒大约 60 帧）：
- en: '[PRE29]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In order to automatically start the animation when the `BouncingDrawablesView`
    becomes visible and make it stop when it''s invisible, you need to know when the
    `BouncingDrawablesView` is attached to the `Window` (when it''s attached to the
    screen components). To do this, you''ll need to override `onAttachedToWindow`
    and invoke `onNextFrame()`. However, `onAttachedToWindow` is invoked before the
    layout is executed, so you''ll schedule `onNextFrame()` to be run at the end of
    the current event queue:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了在 `BouncingDrawablesView` 变得可见时自动开始动画，并在不可见时停止它，你需要知道 `BouncingDrawablesView`
    是何时附加到 `Window`（当它附加到屏幕组件时）。为此，你需要覆盖 `onAttachedToWindow` 并调用 `onNextFrame()`。然而，`onAttachedToWindow`
    在布局执行之前被调用，所以你将 `onNextFrame()` 安排在当前事件队列的末尾运行：
- en: '[PRE30]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, write a setter and getter for the `Bouncer` objects:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为 `Bouncer` 对象编写设置器和获取器：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Setting up the `BouncingDrawablesView` is a very simple process. An `Activity`
    will need to create an array of `Bouncer` objects with some random positions and
    speeds, and then hand them over to the `BouncingDrawablesView` instance to take
    care of them. As soon as the `BouncingDrawablesView` becomes visible on the screen,
    it will start animating the `Drawable` objects around the screen. A simple example
    setup of the `BouncingDrawableView` might look something like this:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 设置 `BouncingDrawablesView` 是一个非常简单的过程。一个 `Activity` 需要创建一个包含一些随机位置和速度的 `Bouncer`
    对象数组，然后将它们传递给 `BouncingDrawablesView` 实例来处理。一旦 `BouncingDrawablesView` 在屏幕上可见，它将开始动画屏幕周围的
    `Drawable` 对象。`BouncingDrawableView` 的简单配置示例可能看起来像这样：
- en: '[PRE32]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Test your knowledge
  id: totrans-122
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试你的知识
- en: When rendering specialized graphics for a custom widget, you need to do which
    of these?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当为自定义小部件渲染专用图形时，你需要做以下哪一项？
- en: Buffer all the rendering in an offscreen `Bitmap`
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在离屏 `Bitmap` 中缓冲所有渲染
- en: Set a custom background `Drawable`
  id: totrans-125
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置自定义背景 `Drawable`
- en: Override the `onDraw` method
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 覆盖 `onDraw` 方法
- en: Where should you create instances of graphics primitives such as `Drawable`,
    `Paint` and `Path` for rendering in `onDraw`?
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该在 `onDraw` 中渲染时创建图形原语实例，如 `Drawable`、`Paint` 和 `Path` 的位置？
- en: On the main thread
  id: totrans-128
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程上
- en: In the `onDraw` method
  id: totrans-129
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `onDraw` 方法中
- en: Anywhere that doesn't affect `onDraw` directly
  id: totrans-130
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 任何不会直接影响 `onDraw` 的地方
- en: What are the two phases involved in the layout process?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 布局过程涉及的两个阶段是什么？
- en: Layout and then measurement
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局然后测量
- en: Measurement and then layout
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量和布局
- en: Measurement and then rendering
  id: totrans-134
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量然后渲染
- en: When painting a `Drawable` object, you need to do which of the following?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当绘制 `Drawable` 对象时，你需要做以下哪一项？
- en: Pass it a valid `Canvas` object
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 传递一个有效的 `Canvas` 对象
- en: Use `Canvas.paintDrawable`
  id: totrans-137
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Canvas.paintDrawable`
- en: Invoke its `onDraw` method
  id: totrans-138
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用它的 `onDraw` 方法
- en: To tell the platform that a widget needs to repaint itself (from the main thread),
    you use which of these?
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了告诉平台一个小部件需要重新绘制自己（从主线程），你使用以下哪个？
- en: '`View.redraw()`'
  id: totrans-140
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.redraw()`'
- en: '`View.invalidate()`'
  id: totrans-141
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.invalidate()`'
- en: '`View.repaint()`'
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.repaint()`'
- en: Apply your knowledge
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用你的知识
- en: Most of what has been covered in this book is a mix of theory (how to go about
    designing a screen) and hard practical knowledge (writing the code to produce
    that screen). When you combine a good theoretical base with practical knowledge
    of the platform you're working on, you have a powerful combination. Being about
    to write great applications isn't just about being able to write code (very little
    in programming is about being able to *just* write code). It's about having an
    eye for detail in the user interface, and always thinking about your users.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本书所涵盖的大部分内容是理论（如何设计屏幕）和硬实践知识（编写代码以生成该屏幕）的结合。当你将良好的理论基础与你在工作的平台上的实践知识结合起来时，你就拥有了一个强大的组合。能够编写出色的应用程序并不仅仅是能够编写代码（编程中很少有关于仅仅能够编写代码的事情）。它还涉及到对用户界面的细节的关注，并且始终考虑你的用户。
- en: Android is an amazingly powerful platform when used correctly. In this book,
    you've learned to use APIs such as data binding, the Room data storage system,
    and `LiveData`. This mix of APIs on the Android Platform doesn't just allow you
    to rapidly develop excellent applications, but it also provides an excellent separation
    between different areas of your code base. They also don't, in any way, reduce
    the power you can leverage from the underlying platforms and systems (such as
    SQLite).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 当正确使用时，Android是一个惊人的强大平台。在这本书中，你已经学会了使用数据绑定、Room数据存储系统和`LiveData`等API。Android平台上的这些API组合不仅允许你快速开发优秀应用程序，而且还提供了代码库不同区域之间优秀的分离。它们也绝不会以任何方式减少你可以从底层平台和系统中利用的权力（如SQLite）。
- en: 'The Android community is massive, and there is plenty to find and work with
    outside of the core platform that can make development even easier. Here are a
    few links to resources, documentation, and APIs, that are especially useful:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: Android社区规模庞大，除了核心平台之外，还有很多可以找到和使用的资源，可以使开发更加容易。以下是一些特别有用的资源、文档和API链接：
- en: 'The official Android platform reference:'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的Android平台参考：
- en: '[https://developer.android.com/reference/packages.html](https://developer.android.com/reference/packages.html)'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://developer.android.com/reference/packages.html](https://developer.android.com/reference/packages.html)'
- en: 'Firebase (handles hosting, push-notifications, database synchronization, authentication,
    and much more):'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Firebase（处理托管、推送通知、数据库同步、身份验证以及更多）：
- en: '[https://firebase.google.com/](https://firebase.google.com/)'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://firebase.google.com/](https://firebase.google.com/)'
- en: 'The Android Arsenal, an unofficial list of third-party APIs and widgets:'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Arsenal，一个非官方的第三方API和小部件列表：
- en: '[https://android-arsenal.com/](https://android-arsenal.com/)'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://android-arsenal.com/](https://android-arsenal.com/)'
- en: 'Joda-Time API, the de-facto standard time API before Java 8 on the core Java
    platform, still useful on Android, though:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Joda-Time API，在Java 8之前在Java核心平台上的事实标准时间API，虽然在Android上仍然有用：
- en: '[http://www.joda.org/joda-time/](http://www.joda.org/joda-time/)'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.joda.org/joda-time/](http://www.joda.org/joda-time/)'
- en: 'The official SQLite website:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的SQLite网站：
- en: '[https://sqlite.org/](https://sqlite.org/)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://sqlite.org/](https://sqlite.org/)'
- en: 'Finally, here are some fun ideas for projects that you might want to try implementing
    once you''ve finished this book:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这里有一些有趣的项目想法，你可以在完成这本书后尝试实现：
- en: Try expanding the travel claim example to allow for multiple trips.
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试扩展旅行报销示例，以允许进行多次旅行。
- en: Write a simple expense tracker to allow your user to enter and track their spending.
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写一个简单的支出跟踪器，允许用户输入并跟踪他们的支出。
- en: A packing/moving organizer app, allowing the user to photograph the contents
    of boxes and record their contents for when they are moving their house.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个打包/搬家组织应用程序，允许用户拍摄箱子的内容并记录它们的物品，以便他们在搬家时使用。
- en: A to-do list application, allowing the user to create various lists of things
    they need to do and check them off when done. To make this more interesting, you
    can add reminders and deadlines (items that must be completed by a certain date
    and time).
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个待办事项列表应用程序，允许用户创建他们需要完成的各项事务的列表，并在完成后勾选。为了让这更有趣，你可以添加提醒和截止日期（必须在特定日期和时间完成的项目）。
- en: A real-time chat application, which is a bit more complex; use the Firebase
    Real-time database to store and synchronize the chat messages.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个实时聊天应用程序，这要复杂一些；使用Firebase实时数据库来存储和同步聊天消息。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Building your own custom components can be a lot of work, but can also be extremely
    rewarding. Having complete control over the measurement, layout, and rendering
    cycle provides you with an amazing amount of power to virtually build any widget
    that you can imagine. Android also has some excellent defaults defined, allowing
    you to focus on how your widget should look and work, rather than getting stuck
    on the intricacies of the rendering pipeline.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 构建自己的自定义组件可能是一项大量工作，但也可以非常有益。对测量、布局和渲染周期拥有完全的控制权，为你提供了几乎可以构建任何你想象中的小部件的惊人力量。Android还定义了一些优秀的默认值，让你可以专注于你的小部件应该如何看起来和工作，而不是陷入渲染管道的复杂性中。
- en: The `Drawable` class is one of the most powerful graphics primitives Android
    has. It's difficult to call it a primitive due to how powerful they actually are.
    Wherever possible, use them instead of a `Bitmap` or `Path`, as they make future
    improvements much simpler, and easily integrate with the resources system.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drawable`类是Android中最强大的图形原语之一。由于它们实际上非常强大，所以很难称它们为原语。尽可能使用它们而不是`Bitmap`或`Path`，因为它们使得未来的改进更加简单，并且可以轻松地与资源系统集成。'
- en: Using the `Handler` class to animate a widget is also a very powerful and low-level
    mechanism. It's often a good idea to introduce a sense of real time into these
    sorts of animations so that frames that take slightly longer, or shorter, to render
    don't affect the overall feel of the application. This can be done simply by using
    the timestamp in each frame and moving values according to that, instead of having
    fixed values. In this case, the speed of the `Bouncer` will become the number
    of `pixels/time` instead of a fixed number of pixels per frame.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`Handler`类来动画化小部件也是一个非常强大且底层的机制。在这些类型的动画中引入实时感通常是一个好主意，这样渲染时间稍长或稍短的画面就不会影响应用程序的整体感觉。这可以通过简单地使用每一帧的时间戳并根据该时间戳移动值来实现，而不是使用固定值。在这种情况下，`Bouncer`的速度将变为`像素/时间`的数量，而不是每帧固定数量的像素。
- en: Before building your own widgets or layouts, you should always look around on
    the internet to see whether there is an existing project that does what you are
    looking for. Knowing how widgets are actually built and fit together is useful
    knowledge, and should give you the confidence to not just create your own, but
    also help others build theirs.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建自己的小部件或布局之前，你应该始终在网上四处看看，看看是否已经有一个现有的项目做了你想要的事情。了解小部件是如何实际构建和组合的，这是一项有用的知识，应该让你有信心不仅创建自己的，还可以帮助他人构建他们的。
