- en: Functional Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式编程
- en: 'In this chapter, we''re going to discuss basic principles of functional programming,
    and how they fit into the Kotlin programming language. We won''t introduce much
    new syntax, as you''ll soon see. It would have been hard to discuss benefits of
    the language in the previous chapters without touching on concepts such as *data
    immutability* and *functions as first-class values*. But, as we did before, we''ll
    look at those features from a different angle: not how to use them to implement
    well-known design patterns in a better way, but their purpose.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论函数式编程的基本原则，以及它们如何融入 Kotlin 编程语言。我们不会介绍很多新的语法，正如你很快就会看到的。在前面几章中，如果不涉及诸如
    *数据不可变性* 和 *函数作为一等值* 等概念，很难讨论该语言的好处。但就像我们之前做的那样，我们将从不同的角度来审视这些特性：不是如何用它们以更好的方式实现已知的设计模式，而是它们的用途。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why functional programming?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么选择函数式编程？
- en: Immutability
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不可变性
- en: Functions as values
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为值的函数
- en: Expressions, not statements
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表达式，而不是语句
- en: Recursion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归
- en: Why functional programming?
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择函数式编程？
- en: 'Functional programming has been around for almost as long as other programming
    paradigms, such as procedural and object-oriented programming, if not longer.
    But in the past 10 years, it has gained major momentum. The reason for that is
    because something else stalled: CPU speeds. We cannot speed up our CPUs as much
    as we did in the past, so we must parallelize our programs. And it turns out that
    the functional programming paradigm is exceptional at running parallel tasks.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程几乎与其他编程范式一样历史悠久，比如过程式编程和面向对象编程，如果不是更久。但近10年来，它已经取得了巨大的进展。原因在于其他一些事情停滞了：CPU速度。我们不能再像过去那样大幅提高CPU速度，因此我们必须并行化我们的程序。结果证明，函数式编程范式在运行并行任务方面非常出色。
- en: The evolution of multicore processors is a very interesting topic by itself,
    but we'll be able to cover it only briefly. Workstations had multiple processors
    since the 1980s at least, to support running tasks from different users in parallel.
    Since workstations were huge anyway, they didn't need to worry about cramming
    everything into one chip. But with multiprocessors coming to the consumer market
    around 2005, it was necessary to have one physical unit that could do work in
    parallel. That's the reason we have multiple cores on one chip in our PC or laptop.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 多核处理器的演变本身就是一个非常有趣的话题，但我们只能简要地介绍。工作站自20世纪80年代以来至少就有多个处理器，以支持并行运行来自不同用户的任务。由于工作站本身就很大，它们不需要担心将所有东西都挤在一个芯片上。但到了2005年左右，消费市场出现了多处理器，就需要一个能够并行工作的物理单元。这就是为什么我们的PC或笔记本电脑上有一个芯片上有多个核心的原因。
- en: 'But that''s not the only reason some swear by functional programming. Here
    are a few more:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 但这并不是一些人坚信函数式编程的唯一原因。这里还有更多：
- en: Functional programming favors pure functions, and pure functions are usually
    easier to reason about and to test
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数式编程倾向于纯函数，而纯函数通常更容易推理和测试
- en: Code written in a functional way is often more declarative than imperative,
    dealing with the *what* and not the *how*
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以函数方式编写的代码通常比命令式代码更具声明性，处理的是 *what* 而不是 *how*
- en: Immutability
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变性
- en: 'One of the key concepts of functional programming is immutability. It means
    that from the moment the function receives input to the moment the function returns
    output, the object doesn''t change. How could it change, you wonder? Let''s see
    a simple example:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 函数式编程的一个关键概念是不可变性。这意味着从函数接收输入的那一刻起，到函数返回输出的那一刻止，对象不会改变。你怎么可能改变呢？让我们看看一个简单的例子：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The output would be first `"a"`, then we'll receive `ConcurrentModificationException`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 输出将会是首先 `"a"`，然后我们会收到`ConcurrentModificationException`。
- en: Wouldn't it be great if we could protect ourselves from such runtime exceptions
    in the first place?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们一开始就能保护自己免受此类运行时异常的侵害，那岂不是很好？
- en: Tuples
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 元组
- en: 'In functional programming, a tuple is a piece of data that cannot be changed
    after it is created. One of the most basic tuples in Kotlin is Pair:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数式编程中，元组是在创建后无法更改的数据片段。Kotlin中最基本的元组之一是 Pair：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Pair contains two properties, first and second, and is immutable:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一对包含两个属性，第一个和第二个，且是不可变的：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We can destructure a Pair into two separate values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将一对拆分为两个单独的值：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When iterating over a map, we receive another tuple, `Map.Entry`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当遍历映射时，我们会收到另一个元组，`Map.Entry`：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In general, *data classes* are usually a good implementation for tuples. But,
    as we'll see in the *Value Mutation* section, not every data class is a proper
    tuple.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，*数据类*通常是元组的良好实现。但是，正如我们将在*值突变*部分中看到的，并非每个数据类都是合适的元组。
- en: Value mutation
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值突变
- en: 'In Maronic, we would like to count the average score over one thousand games.
    For that, we have the following data class:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Maronic 中，我们希望计算一千场比赛的平均分。为此，我们有一个以下的数据类：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We were smart: we protected ourselves from any invalid output by checking for
    divisions by zero.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们很聪明：我们通过检查除以零来保护自己免受任何无效输出的影响。
- en: But what will happen when we write the following code?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 但当我们编写以下代码时会发生什么？
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Soon enough, you'll receive `ArithmeticException` anyway. Our counter somehow
    becomes zero.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 很快，你将不可避免地收到 `ArithmeticException`。我们的计数器不知何故变成了零。
- en: If you want your data classes to be immutable, be sure to specify all their
    properties as `val` (values), and not `var` (variables).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的数据类是不可变的，请确保将所有属性指定为 `val`（值），而不是 `var`（变量）。
- en: Immutable collections
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可变集合
- en: 'I think that our junior developer learned their lesson. Instead, they produced
    this code, which is not very efficient, but which gets rid of those variables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我想我们的初级开发者已经吸取了教训。相反，他们产生了以下代码，虽然效率不高，但去掉了那些变量：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'But the maleficent thread strikes again:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 但邪恶的线程再次发动攻击：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We again receive `ArithmeticException`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次收到 `ArithmeticException`。
- en: 'It''s not enough that your data class contains only values. If its value is
    a collection, it must be immutable in order for the data class to be considered
    immutable. The same rule is applied to classes contained within other data classes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的数据类只包含值，那就不够了。如果它的值是一个集合，那么为了使数据类被认为是不可变的，这个集合必须是不可变的。同样的规则也适用于其他数据类中包含的类：
- en: '[PRE9]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Now the maleficent thread cannot even call `clear()` on this collection. But
    how should we add scores to it?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，邪恶的线程甚至不能调用这个集合上的 `clear()`。但我们该如何向其中添加分数呢？
- en: 'One option is to pass the entire list in the constructor:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 一种选择是将整个列表传递给构造函数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Functions as values
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数作为值
- en: We already covered some of the functional capabilities of Kotlin in the chapters
    dedicated to Design Patterns. The **Strategy** and **Command** design patterns
    are but a few that heavily rely on the ability to accept functions as arguments,
    return functions, store them as values, or put them inside collections. In this
    section, we'll cover some other aspects of functional programming in Kotlin, such
    as function purity and currying.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在专门介绍设计模式的章节中涵盖了 Kotlin 的一些功能特性。其中，**策略**和**命令**设计模式只是少数几个大量依赖接受函数作为参数、返回函数、将它们作为值存储或将它们放入集合中的能力。在本节中，我们将介绍
    Kotlin 中函数式编程的一些其他方面，例如函数纯度和柯里化。
- en: Higher-order functions
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高阶函数
- en: 'As we discussed previously, in Kotlin, it''s possible for a function to return
    another function:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前讨论的，在 Kotlin 中，一个函数可以返回另一个函数：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Functions can also be assigned to a variable or value to be invoked later on:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 函数也可以分配给变量或值，稍后调用：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The function assigned to a variable is usually called a *literal function*.
    It''s also possible to specify a function as a parameter:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 分配给变量的函数通常被称为*字面函数*。也可以将函数指定为参数：
- en: '[PRE13]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'If a function is the last parameter, it can also be supplied ad hoc, outside
    of the brackets:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果函数是最后一个参数，它也可以在括号外以特定方式提供：
- en: '[PRE14]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In general, a function without a name is called an *anonymous* function. If
    a function without a name uses short syntax, it''s called a lambda:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有名称的函数被称为*匿名函数*。如果一个没有名称的函数使用简短语法，它被称为 lambda：
- en: '[PRE15]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Pure functions
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纯函数
- en: 'A pure function is a function without any side effects. Take the following
    function, for example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是没有副作用的函数。以下函数就是一个例子：
- en: '[PRE16]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How do you test to see whether `"Hello"` is indeed printed? The task is not
    as simple as it seems, as we'll need some means to capture the standard output,
    the same console where we usually see stuff printed.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何测试 `"Hello"` 是否确实被打印出来？这个任务并不像看起来那么简单，因为我们需要某种方法来捕获标准输出，即我们通常看到打印内容的同一个控制台。
- en: 'Compare it to the following function:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 将它与以下函数进行比较：
- en: '[PRE17]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The following function doesn''t have any side effects. That makes it a lot
    easier to test:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 以下函数没有任何副作用。这使得它更容易测试：
- en: '[PRE18]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Does the `hello()` function look a bit meaningless to your eyes? That's actually
    one of the properties of pure functions. Their invocation could be replaced by
    their result (if we knew all their results, that is). This is often called *referential
    transparency*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: “hello()”函数看起来有点无意义吗？这实际上是纯函数的一个特性。它们的调用可以被它们的结果所替代（如果我们知道所有结果的话）。这通常被称为*引用透明性*。
- en: 'Not every function written in Kotlin is pure:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有用 Kotlin 编写的函数都是纯函数：
- en: '[PRE19]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'If we call the function twice on the same list, it will return different results:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在同一个列表上两次调用该函数，它将返回不同的结果：
- en: '[PRE20]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Try this one:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试这个：
- en: '[PRE21]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now our function is totally predictable, no matter how many times we invoke
    it:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在函数是完全可预测的，无论我们调用多少次：
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, we used an immutable interface this time, `List<T>`, which helps
    us by preventing even the possibility of mutating our input. Together with immutable
    values from the previous section, pure functions provide a very strong tool that
    allows easier testing by providing predictable results and parallelization of
    our algorithms.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们这次使用了一个不可变接口 `List<T>`，它通过防止我们甚至有可能修改输入来帮助我们。与上一节中的不可变值一起，纯函数提供了一种非常强大的工具，它通过提供可预测的结果和算法的并行化，使我们更容易进行测试。
- en: Currying
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 柯里化
- en: 'Currying is a way to translate a function that takes a number of arguments
    into a chain of functions that each take a single argument. This may sound confusing,
    so let''s look at a simple example:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化是将接受多个参数的函数转换为一系列每个函数只接受一个参数的函数的方法。这听起来可能有些令人困惑，所以让我们看看一个简单的例子：
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a function that returns two arguments. The result is quite obvious.
    But maybe we would like to invoke this function with the following syntax instead:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个返回两个参数的函数。结果非常明显。但也许我们希望用以下语法调用这个函数：
- en: '[PRE24]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We''ve already seen how we can return a function from another function:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何从一个函数中返回另一个函数：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Here it is in the shorter form:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它的简短形式：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'And here it is in an even shorter form:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个更简短的形式：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Although not very useful by itself, it's still an interesting concept to grasp.
    And if you're a JavaScript developer looking for a new job, make sure you understand
    it really well, since it's being asked about in nearly every interview.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然它本身可能不太有用，但掌握这个概念仍然很有趣。如果你是一位正在寻找新工作的 JavaScript 开发者，确保你真正理解它，因为几乎在每次面试中都会问到它。
- en: Memoization
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 记忆化
- en: 'If our function always returns the same output for the same input, we could
    easily map between previous input and output, and use it as a cache. That technique
    is called *memoization*:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的函数总是对相同的输入返回相同的输出，我们就可以轻松地在先前的输入和输出之间建立映射，并将其用作缓存。这种技术被称为*记忆化*：
- en: '[PRE28]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We use a method reference operator, `::`, to tell `computeIfAbsent` to use the `sum()`
    method in the event that input wasn't cached yet.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用方法引用操作符 `::` 来告诉 `computeIfAbsent` 在输入尚未缓存的情况下使用 `sum()` 方法。
- en: 'Note that `sum()` is a pure function, while `summarize()` is not. The latter
    will behave differently for the same input. But that''s exactly what we want in
    this case:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`sum()` 是一个纯函数，而 `summarize()` 则不是。后者对相同的输入会有不同的行为。但这正是我们想要的：
- en: '[PRE29]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The combination of immutable objects, pure functions, and plain old classes
    provides us with a powerful tool for performance optimizations. Just remember,
    nothing is free. We only trade one resource, CPU time, for another resource, memory.
    And it's up to you to decide which resource is more expensive for you in each
    case.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 不变对象、纯函数和平凡的类的组合为我们提供了一种强大的性能优化工具。只需记住，没有什么是免费的。我们只是用 CPU 时间交换另一种资源，即内存。而决定哪种资源对你来说更贵，则取决于你。
- en: Expressions, not statements
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表达式，而不是语句
- en: A statement is a block of code that doesn't return anything. An expression,
    on the other hand, returns a new value. Since statements produce no results, the
    only way for them to be useful is to mutate state. And functional programming
    tries to avoid mutating the state as much as possible. Theoretically, the more
    we rely on expressions, the more our functions will be pure, with all the benefits
    of functional purity.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 语句是一段不返回任何内容的代码块。另一方面，表达式返回一个新的值。由于语句不产生结果，它们唯一有用的方式就是改变状态。而函数式编程试图尽可能避免改变状态。理论上，我们越依赖表达式，我们的函数就越纯，从而获得所有函数式纯度的益处。
- en: 'We''ve used the `if` expression many times already, so one of its benefits
    should be clear: it''s less verbose and, for that reason, less error-prone than
    the `if` statement.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经多次使用了`if`表达式，因此它的一些好处应该很清楚：它比`if`语句更简洁，因此更不容易出错。
- en: Pattern matching
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模式匹配
- en: The concept of pattern matching is like `switch/case` on steroids for someone
    who comes from Java. We've already seen how `when` expression can be used, in
    [Chapter 1](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7), *Getting Started
    with Kotlin*, so let's briefly discuss why this concept is important for the functional
    paradigm.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 模式匹配的概念对于来自Java的人来说就像“switch/case”的强化版。我们已经在[第1章](part0020.html#J2B80-6704093aa34748cfa77c54bdc1a20dc7)，“Kotlin入门”，中看到了`when`表达式是如何使用的，所以让我们简要讨论一下为什么这个概念对于函数式范式来说很重要。
- en: As you may know, `switch` in Java accepts only some primitive types, strings,
    or enums.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，Java中的`switch`只能接受一些原始类型、字符串或枚举。
- en: 'Consider the following code in Java:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下Java代码：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'If we were to decide which of the functions to call, we would need something
    like this:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们要决定调用哪个函数，我们需要像这样：
- en: '[PRE32]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This method could be shortened by introducing multiple returns, but in real
    projects, multiple returns are usually bad practice.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法可以通过引入多个返回来简化，但在实际项目中，通常不推荐使用多个返回。
- en: Since we don't have a `switch` statement for classes, we need to use an `if`
    statement instead.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有为类提供`switch`语句，我们需要使用`if`语句代替。
- en: 'Compare that with the following Kotlin code:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 与下面的Kotlin代码比较一下：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Since `when` is an expression, we avoided the intermediate variable altogether.
    But what's more, using pattern matching, we can also avoid most of the code that
    concerns type checks and casts.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`when`是一个表达式，我们完全避免了中间变量的使用。更重要的是，使用模式匹配，我们还可以避免大部分与类型检查和转换相关的代码。
- en: Recursion
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 递归
- en: 'Recursion is a function invoking itself with new arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 递归是一个函数用新的参数调用自己：
- en: '[PRE34]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We usually avoid recursion, due to **Stack Overflow** error that we may receive
    if our call stack is too deep. You can call this function with a list that contains
    a million numbers to experience it:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常避免递归，因为如果我们的调用栈太深，我们可能会收到**栈溢出**错误。你可以用一个包含一百万个数字的列表调用这个函数来体验它：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: One of the great benefits of tail recursion is that it avoids the dreaded stack
    overflow exception.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 尾递归的一个巨大好处是它避免了可怕的栈溢出异常。
- en: 'Let''s rewrite our recursive function using a new keyword, `tailrec`, to avoid
    that problem:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用一个新的关键字`tailrec`重写我们的递归函数，以避免这个问题：
- en: '[PRE36]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now the compiler will optimize our call and avoid exception completely.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译器将优化我们的调用并完全避免异常。
- en: Summary
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a better understanding of functional programming and its
    benefits.  We've discussed the concepts of immutability and pure functions. A
    combination of the two often results in more testable code, which is easier to
    maintain.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在应该对函数式编程及其好处有了更好的理解。我们讨论了不可变性和纯函数的概念。两者的结合通常会产生更易于测试的代码，也更容易维护。
- en: Currying and memoization are two useful patterns that originate from functional
    programming.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 柯里化和记忆化是两个源自函数式编程的有用模式。
- en: Kotlin has a `tailrec` keyword that allows the compiler to optimize *tail recursion*.
    We also looked at higher-order functions, expressions versus statements, and pattern
    matching.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin有一个`tailrec`关键字，允许编译器优化*尾递归*。我们还探讨了高阶函数、表达式与语句的区别，以及模式匹配。
- en: In the next chapter, we'll put this knowledge to practical use, and discover
    how reactive programming builds upon functional programming in order to create
    scalable and resilient systems.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把所学知识应用于实践，并了解如何通过在函数式编程的基础上构建，来创建可扩展和健壮的系统。
