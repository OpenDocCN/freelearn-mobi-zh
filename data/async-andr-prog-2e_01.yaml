- en: Chapter 1. Asynchronous Programming in Android
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Android中的异步编程
- en: Asynchronous programming has become an important topic of discussion in the
    past few years, especially when using the concurrent processing capabilities available
    on the most recent mobile hardware.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，异步编程已经成为一个重要的讨论话题，尤其是在使用最新移动硬件上可用的并发处理能力时。
- en: In recent years, the number of independent processing units (cores) available
    on the CPU have increased, so to benefit from this new processing power, a new
    programming model called asynchronous programming has appeared to orchestrate
    the work between the several independent hardware-processing units available on
    the device. Asynchronous programming comes to the rescue to solve the problems
    that could arise from this new processing paradigm.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，CPU上可用的独立处理单元（核心）数量有所增加，为了利用这种新的处理能力，出现了一种新的编程模型，称为异步编程，以协调设备上几个独立硬件处理单元之间的工作。异步编程应运而生，以解决可能由此新处理范式引发的问题。
- en: Android applications, since they mostly run on devices with multiple units of
    processing, should take advantage of asynchronous programming to scale and improve
    the application performance when blocking operations, and when CPU-intensive tasks
    are required.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序，由于它们主要运行在拥有多个处理单元的设备上，应该利用异步编程来在阻塞操作和需要CPU密集型任务时进行扩展和提升应用性能。
- en: Android is an open source operating system (OS) based on Linux kernel that was
    devised in 2003 by Andy Rubin, Nick Sears, Chris White, and Rick Miner, and then
    acquired by Google in July, 2005.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Android是一个基于Linux内核的开源操作系统（OS），由Andy Rubin、Nick Sears、Chris White和Rick Miner于2003年设计，并于2005年7月被谷歌收购。
- en: The Android OS, actually maintained by Google and the Open Handset Alliance,
    was created to provide an open mobile-device platform for devices with limited
    resources of computation, memory, and energy.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: Android操作系统，实际上由谷歌和开放手机联盟维护，是为了为计算、内存和能源资源有限的设备提供一个开放的移动设备平台而创建的。
- en: The platform has been incorporating advanced mobile devices standards, such
    as NFC and Bluetooth LE, and its scope has grown from a pure smartphone platform
    to a broader software platform for smart watches, TVs, tablets, and consoles.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 该平台已经纳入了高级移动设备标准，如NFC和蓝牙低功耗（LE），其范围已从纯智能手机平台扩展到更广泛的软件平台，包括智能手表、电视、平板电脑和游戏机。
- en: The maintainers have been regularly updating the platform with great features
    and some improvements over minor and major releases since the first release.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 自从首次发布以来，维护者一直在定期更新平台，带来了许多新特性和对次要和主要版本的改进。
- en: 'The following diagram displays the Android versions over time:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示了Android版本随时间的变化：
- en: '![Asynchronous Programming in Android](img/Image_B05062_01_01a.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![Android中的异步编程](img/Image_B05062_01_01a.jpg)'
- en: Android software stack
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android软件栈
- en: Android software stack (C libraries and Java frameworks), orchestrated by the
    Android runtime (Dalvik VM, and most recently, ART) was created around the Linux
    kernel to provide highly interactive user experiences over a well-proven group
    of technologies.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Android软件栈（C库和Java框架），由Android运行时（Dalvik VM，最近还有ART）编排，围绕Linux内核创建，旨在在经过充分验证的一组技术之上提供高度交互的用户体验。
- en: In each new OS version, a well-defined application interface (API) is provided
    to the developer in order to create applications around the new features and standards
    introduced with the release.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个新的操作系统版本中，都会为开发者提供一个明确的应用程序接口（API），以便围绕发布时引入的新特性和标准创建应用程序。
- en: The Android application compiled code (bytecode), typically a Java compiled
    code, runs on a virtual machine based on Dalvik or ART.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序的编译代码（字节码），通常是Java编译代码，在基于Dalvik或ART的虚拟机上运行。
- en: Dalvik runtime
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Dalvik运行时
- en: The **Dalvik VM** (**DVM**) runtime, created by **Dan Borstein**, was the first
    runtime for the platform and is a register-based virtual machine that was created
    to run the Java code efficiently in a constrained runtime with a limited amount
    of power processing, RAM, and electric power.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 由**丹·博斯坦**创建的**Dalvik虚拟机**（**DVM**）运行时是平台上的第一个运行时，它是一个基于寄存器的虚拟机，旨在在有限的运行时、有限的电源处理、RAM和电力下有效地运行Java代码。
- en: Dalvik's creators claim that the DVM is, on an average, around 30% more efficient
    than the standard Java VM (Oracle). According to Bornstein, it requires 30% less
    instructions and 35 % less coding units.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Dalvik的创造者声称，DVM平均比标准Java VM（Oracle）高效约30%。根据Bornstein的说法，它需要30% fewer instructions和35%
    fewer coding units。
- en: Clearly, Google has gone to great lengths to squeeze every drop of performance
    out of each mobile device to help developers build responsive applications.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，谷歌已经竭尽全力从每一款移动设备中榨取性能，以帮助开发者构建响应式应用程序。
- en: The virtual machine, which runs the Java code compiled and transformed to the
    dex format over the dx tool, runs on a Linux process with its own memory space
    and file descriptors. It also manages its own group of threads.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虚拟机在Linux进程中运行，具有自己的内存空间和文件描述符，并管理自己的线程组。它还管理自己的线程组。
- en: In more advanced architectures, an Android application might run a service in
    a separate process and communicate over the IPC mechanism, but most of the time,
    it runs on a single self-contained process.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在更高级的架构中，Android应用程序可能在单独的进程中运行服务并通过IPC机制进行通信，但大多数时候，它在一个自包含的进程中运行。
- en: The dex file and application resources are packed in an **Android application
    package** (**APK**) by the AAPT and installed over Google Play in the end user
    devices.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: dex文件和应用程序资源由AAPT打包成**Android应用程序包**（**APK**），最终在终端用户的设备上通过Google Play安装。
- en: Note
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The application store distribution model has become extremely popular on the
    mobile platforms since the launch of the Apple iPhone in 2007.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 自2007年苹果iPhone发布以来，应用程序商店的分布模式在移动平台上变得极为流行。
- en: Since Android 2.2 the DVM comes with a trace-based **Just-In-Time** (**JIT**)
    compilation feature that actively optimizes every time the application runs some
    short segments of frequently used bytecode called traces.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 2.2以来，DVM自带基于跟踪的**即时编译**（**JIT**）功能，该功能在应用程序运行频繁使用的字节码段（称为跟踪）时进行主动优化。
- en: The generated machine code provides significant performance improvements in
    the application execution and on the time spent on some intensive CPU tasks, and
    thereafter, decreases the battery power used.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 生成的机器代码在应用程序执行和某些密集型CPU任务上提供了显著的性能改进，并因此降低了电池消耗。
- en: ART runtime
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ART运行时
- en: The ART runtime is a new version of the DVM and was introduced to improve the
    runtime performance and memory consumption. The new runtime was introduced in
    Android 4.4 KitKat as an experimental runtime, and since the Android 5.0 Lollipop,
    it has become the main Android runtime.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ART运行时是DVM的新版本，旨在提高运行时性能和内存消耗。新的运行时在Android 4.4 KitKat中作为实验性运行时引入，自Android 5.0
    Lollipop以来，它已成为主要的Android运行时。
- en: This new runtime, making use of the **ahead-of-time** (**AOT**) compilation,
    brings new app-performance optimizations on startup time and application execution.
    The AOT, as opposed to DVM JIT (Just in Time), compiles the dex files during the
    installation time using the device dex2oat tool. The compiled code generated from
    the dex2oat tool generates system-dependent code for the target device and removes
    the delay introduced by the JIT compilation during each application execution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种新的运行时利用**预编译**（**AOT**）编译，在启动时间和应用程序执行上带来了新的性能优化。与DVM JIT（即时）相反，AOT在安装时使用设备上的dex2oat工具编译dex文件。由dex2oat工具生成的编译代码为目标设备生成系统依赖代码，并消除了每次应用程序执行时JIT编译引入的延迟。
- en: The AOT compiler also reduces the number of processor cycles used by the application
    as it removes the time spent by the JIT compiler to convert the code into machine
    code, and then uses less battery power to run the application.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译器还减少了应用程序使用的处理器周期数，因为它消除了JIT编译器将代码转换为机器代码所花费的时间，并且使用更少的电池电量来运行应用程序。
- en: One of the drawbacks of the AOT compilation is the larger memory footprint in
    comparison with the JIT used by DVM.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: AOT编译的一个缺点是与DVM使用的JIT相比，内存占用更大。
- en: With the new runtime, some improvements were also introduced in the memory allocation
    and on **Garbage Collection** (**GC**), resulting in a more responsive UI and
    better application experience.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 新的运行时还在内存分配和**垃圾回收**（**GC**）方面引入了一些改进，从而实现了更响应的UI和更好的应用程序体验。
- en: Memory sharing and Zygote
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存共享和Zygote
- en: Basically, the platform runs an instance of DVM/ART for each application, but
    large optimization of the platform is brought about by the way a new DVM instance
    is created and managed.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，该平台为每个应用程序运行一个DVM/ART实例，但平台的大规模优化是通过创建和管理新的DVM实例的方式实现的。
- en: A special process called the Zygote (first life cell in an animal's reproduction)—the
    process that all the Android applications are based on—is launched when an Android
    device initially boots.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当安卓设备首次启动时，会启动一个称为Zygote的特殊进程（动物繁殖中的第一个生命细胞）——所有安卓应用程序都是基于此进程的。
- en: The Zygote starts up a virtual machine, preloads the core libraries, and initializes
    various shared structures. It then waits for instructions by listening on a socket.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Zygote启动一个虚拟机，预加载核心库，并初始化各种共享结构。然后它通过监听套接字等待指令。
- en: When a new Android application is launched, the Zygote receives a command to
    create a virtual machine to run the application on. It does this by forking its
    pre-warmed VM process and creating a new child process that shares some memory
    portions with the parent, using a technique called **copy-on-write** (**COW**).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新的安卓应用程序启动时，Zygote接收一个命令来创建一个虚拟机以运行该应用程序。它是通过复制其预热好的VM进程并创建一个新的子进程来实现的，该子进程与父进程共享一些内存部分，使用的技术称为**写时复制**（**COW**）。
- en: The COW technique, available on most Unix systems, only allocates new memory
    on the child process when the process tries to change the memory cloned from the
    parent process.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 可在大多数Unix系统上使用的COW技术仅在进程尝试更改从父进程克隆的内存时才在子进程中分配新内存。
- en: 'This technique has some fantastic benefits, as listed in the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有一些非常显著的好处，如下所示：
- en: First, the virtual machine and core libraries are already loaded into the memory.
    Not having to read this significant chunk of data from the filesystem to initialize
    the virtual machine drastically reduces the startup overhead.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，虚拟机和核心库已经加载到内存中。无需从文件系统读取这块重要数据来初始化虚拟机，这极大地减少了启动开销。
- en: Second, the memory in which these core libraries and common structures reside
    is shared by the Zygote with all other applications, resulting in saving a lot
    of memory when the user is running multiple apps.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其次，这些核心库和常见结构所在的内存由Zygote与其他所有应用程序共享，当用户运行多个应用程序时，这可以节省大量内存。
- en: Android process model
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安卓进程模型
- en: Android is a multiuser, multitasking system that can run multiple applications
    in parallel, where all the applications attempt to acquire CPU time to execute
    its job.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓是一个多用户、多任务系统，可以并行运行多个应用程序，其中所有应用程序都试图获取CPU时间来执行其任务。
- en: Each application runs independently on an isolated Linux process cloned from
    the Zygote process, and by default, all the Android components run within the
    same process with the same name as the application package specified in **Android
    Application Manifest** (**AAM**).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 每个应用程序都在一个独立的Linux进程中独立运行，该进程是从Zygote进程克隆出来的，并且默认情况下，所有安卓组件都在与应用程序包中指定的相同名称的进程中运行，该名称在**安卓应用程序清单**（**AAM**）中指定。
- en: The Linux kernel will fairly allocate small amounts of CPU time for application
    execution called CPU time slices. This time-slicing approach means that even a
    single-processor device can appear to be actively working in more than one application
    at the same time, when in fact, each application is taking very short turns on
    the CPU.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: Linux内核将为应用程序执行分配少量CPU时间，称为CPU时间片。这种时间片方法意味着即使单处理器设备也能同时看起来在多个应用程序中积极工作，而实际上，每个应用程序都在CPU上轮流执行非常短暂的时间。
- en: Process ranks
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程优先级
- en: The Android operating system tries to maintain the application running for as
    long as possible, but when the available memory is low, it will try to free resources
    in the system by killing the processes with lower importance first.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 安卓操作系统试图尽可能长时间地保持应用程序运行，但当可用内存低时，它将通过首先终止重要性较低的过程来尝试通过释放系统资源。
- en: 'This is when process ranking comes into the picture; the Android processes
    are ranked in the next five categories from the higher priority to the lower priorities:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是进程优先级发挥作用的时候；安卓进程按照以下五个类别从高优先级到低优先级进行排序：
- en: '**Foreground process**: This is a process that hosts an activity or service
    that the user is currently interacting with: a service started in the foreground
    or service running its life cycle callbacks'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**前台进程**：这是一个托管用户当前与之交互的活动或服务的进程：在前台启动的服务或正在运行其生命周期回调的服务'
- en: '**Visible process**: This is a process that hosts a paused activity or service
    bounded to a visible activity'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见进程**：这是一个托管暂停活动或与可见活动绑定的服务的进程'
- en: '**Service process**: This is a process that hosts a service not bound to a
    visible activity'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**服务进程**：这是一个托管未绑定到可见活动的服务的进程'
- en: '**Background process**: This is a process that hosts a non-visible activity;
    all background processes are sorted over a **Least-Recently-Used** (**LRU**) list,
    therefore, the most recently used processes are the last killed processes when
    they have the same rank'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**后台进程**：这是一个承载非可见活动的进程；所有后台进程都按**最近最少使用**（**LRU**）列表排序，因此，最近使用的进程是当它们具有相同排名时最后被杀死的进程。'
- en: '**Empty process**: This is a process used to cache inactive Android components
    and to improve any component startup time'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**空进程**：这是一个用于缓存不活跃的Android组件并提高任何组件启动时间的进程。'
- en: When the system reaches a point that it needs to release resources, the processes
    available to be killed will be sorted, taking into account the process rank, last
    used processes, and components running.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统达到需要释放资源的状态时，可被杀死的进程将按进程排名、最后使用进程和运行的组件等因素进行排序。
- en: Process sandboxing
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进程沙箱化
- en: The Android application always runs under a unique **Linux** **user ID** (**UID**)
    assigned to the application during the application installation so that the process
    runs on a sandboxed environment, which by default, isolates your data and code
    execution from other apps.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序始终在安装应用程序期间分配给应用程序的唯一**Linux** **用户ID**（**UID**）下运行，以便进程在沙箱环境中运行，默认情况下，将隔离您的数据和代码执行与其他应用程序。
- en: 'In some cases, a user could explicitly be required to share the UID with another
    application to have access to their data:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，可能需要用户明确地与其他应用程序共享UID以访问其数据：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The preceding table that results from running the `adb shell ps` command in
    the computer with Android SDK Table is a list of Android running processes.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android SDK Table计算机上运行`adb shell ps`命令生成的先前表格是Android运行进程的列表。
- en: The first column shows the **user identifier** (**UID**) assigned at the time
    of installation, the second column is the **process ID** (**PID**), the third
    column shows the **parent process ID** (**PPID**) that for Android applications
    is the Zygote process, and the last column shows the application package.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 第一列显示了在安装时分配的**用户标识符**（**UID**），第二列是**进程ID**（**PID**），第三列显示了**父进程ID**（**PPID**），对于Android应用来说，这是Zygote进程，最后一列显示了应用程序包。
- en: From this list, we can assure that the WhatsApp application is running under
    the user ID `u0_a221` with the process ID `5993` and the parent process is the
    Zygote process with the PID `319`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 从这个列表中，我们可以确认WhatsApp应用程序正在用户ID `u0_a221`下运行，进程ID为`5993`，父进程是Zygote进程，PID为`319`。
- en: Android thread model
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android线程模型
- en: Within an Android process, there may be many threads of execution. Each thread
    is a separate sequential flow of control within the overall program—it executes
    its instructions in order, one after the other, and they also share allocated
    slices of CPU time managed by the operating system task scheduler.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android进程中，可能有多个执行线程。每个线程都是整体程序中的一个独立的顺序控制流——它按顺序执行其指令，一个接一个，它们还共享由操作系统任务调度器管理的分配的CPU时间片。
- en: While the application process is started by the system and prevented from directly
    interfering with data in the memory address space of other processes, the threads
    may be started by an application code and can communicate and share data with
    other threads within the same process. Apart from the shared data that all the
    threads share in the same process, a thread can use its own memory cache to store
    its data in its own memory space.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当系统启动应用程序进程并阻止其直接干扰其他进程的内存地址空间中的数据时，线程可能由应用程序代码启动，并且可以与同一进程内的其他线程进行通信和共享数据。除了在同一进程中共享的所有线程共享的数据外，一个线程可以使用其自己的内存缓存来存储其数据在自己的内存空间中。
- en: The main thread
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 主线程
- en: When the application process starts, apart from DVM housekeeping threads, the
    system creates a thread of execution called `main`. This thread, as the name explains,
    plays a crucial role in the application lifetime as it is the thread that interacts
    with the Android UI components, updating the state and their look on the device
    screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序进程启动时，除了DVM维护线程外，系统还会创建一个名为`main`的执行线程。这个线程，正如其名所解释的，在应用程序生命周期中扮演着至关重要的角色，因为它是与Android
    UI组件交互、更新设备屏幕上状态和外观的线程。
- en: 'Moreover, by default, all the Android application components (`Activity`, `Service`,
    `ContentProvider`, and `BroadcastsReceiver`) are also executed over the main thread
    line of execution. The following image shows the lists of threads running inside
    an application process with the main thread at the top of the list with a unique
    **thread ID** (**TID**) assigned by the system:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，默认情况下，所有Android应用程序组件（`Activity`、`Service`、`ContentProvider`和`BroadcastsReceiver`）也是通过主线程执行线执行的。以下图像显示了应用程序进程内运行的线程列表，其中主线程位于列表顶部，并分配了一个系统指定的唯一**线程ID**（**TID**）：
- en: '![The main thread](img/Image_B05062_01_02.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![主线程](img/Image_B05062_01_02.jpg)'
- en: 'The main thread, also known as UI Thread, is also the thread where your UI
    event handling occurs, so to keep your application as responsible as possible,
    you should:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 主线程，也称为UI线程，是处理UI事件发生的线程，因此为了尽可能保持应用程序的响应性，你应该：
- en: Avoid any kind of long execution task, such as **input/output** (**I/O**) that
    could block the processing for an indefinite amount of time
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免任何可能长时间阻塞处理的长执行任务，例如可能无限期阻塞处理的**输入/输出**（**I/O**）任务
- en: Avoid CPU-intensive tasks that could make this thread occupied for a long time
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免可能导致此线程长时间占用的CPU密集型任务
- en: 'The following diagram displays the main interactions and components involved
    in the `Looper` line of execution thread:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了`Looper`执行线程中的主要交互和组件：
- en: '![The main thread](img/Image_B05062_01_03.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![主线程](img/Image_B05062_01_03.jpg)'
- en: The **UI/Main** thread, which has a `Looper` facility attached to it, holds
    a queue of messages (`MessageQueue`) with some unit of work to be executed sequentially.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**UI/Main**线程，它附加了一个`Looper`设施，持有要按顺序执行的一些工作单元的消息队列（`MessageQueue`）。'
- en: When a message is ready to be processed on the queue, the **Looper Thread**
    pops the message from the queue and forwards it synchronously to the target handler
    specified on the message.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当队列中有消息准备好被处理时，**Looper线程**从队列中弹出消息并将其同步地转发到消息上指定的目标处理器。
- en: When the target `Handler` finishes its work with the current message, the `Looper`
    thread will be ready to process the next message available on the queue. Hence,
    if the `Handler` spent a noticeable amount of time processing the message, it
    will prevent `Looper` from processing other pending messages.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当目标`Handler`完成当前消息的处理后，`Looper`线程将准备好处理队列中可用的下一个消息。因此，如果`Handler`花费了显著的时间处理消息，它将阻止`Looper`处理其他挂起的消息。
- en: For example, when we write the code in an `onCreate()` method in the `Activity`
    class, it will be executed on the main thread. Likewise, when we attach listeners
    to user-interface components to handle taps and other user-input gestures, the
    listener callback executes on the main thread.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们在一个`Activity`类的`onCreate()`方法中编写代码时，它将在主线程上执行。同样，当我们向用户界面组件附加监听器以处理点击和其他用户输入手势时，监听器回调将在主线程上执行。
- en: For apps that do little I/O or processing, such as applications that don't do
    complex math calculations, don't use the network to implement features, or don't
    use filesystem resources, this single thread model is fine. However, if we need
    to perform CPU-intensive calculations, read or write files from permanent storage,
    or talk to a web service, any further events that arrive while we're doing this
    work will be blocked until we're finished.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于执行少量I/O或处理的应用程序，例如不进行复杂数学计算的应用程序，不使用网络实现功能，也不使用文件系统资源的应用程序，这种单线程模型是可行的。然而，如果我们需要执行CPU密集型计算，从持久存储中读取或写入文件，或与网络服务通信，那么在我们完成这项工作期间到达的任何进一步的事件都将被阻塞。
- en: Note
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since the Android 5.0 (Lollipop), a new important thread named **RenderThread**
    was introduced to keep the UI animations smooth even when the main thread is occupied
    doing stuff.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 自Android 5.0（Lollipop）以来，引入了一个名为**RenderThread**的新重要线程，以保持UI动画的平滑，即使主线程正忙于执行任务。
- en: The Application Not Responding (ANR) dialog
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序无响应（ANR）对话框
- en: As you can imagine, if the main thread is busy with a heavy calculation or reading
    data from a network socket, it cannot immediately respond to user input such as
    a tap or swipe.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，如果主线程正忙于进行繁重的计算或从网络套接字读取数据，它无法立即响应用户输入，如点击或滑动。
- en: An application that doesn't respond quickly to user interaction will feel unresponsive—anything
    more than a couple of hundred milliseconds delay is noticeable. This is such a
    pernicious problem that the Android platform protects users from applications
    that do too much on the main thread.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一个对用户交互反应不快的应用程序会感觉不响应——超过几百毫秒的延迟都是可以察觉的。这是一个非常有害的问题，Android平台通过保护用户免受在主线程上执行过多操作的应用程序的侵害来解决这个问题。
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If an app does not respond to user input within five seconds, the user will
    see the **Application Not Responding** (**ANR**) dialog and will be offered the
    option to quit the application.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用程序在五秒内没有响应用户输入，用户将看到**应用程序无响应**（**ANR**）对话框，并可以选择退出应用程序。
- en: 'The following screenshot shows a typical Android ANR dialog:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了典型的Android ANR对话框：
- en: '![The Application Not Responding (ANR) dialog](img/Image_B05062_01_04.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![应用程序无响应（ANR）对话框](img/Image_B05062_01_04.jpg)'
- en: Android works hard to synchronize the user interface redraws with the hardware-refresh
    rate. This means that it aims to redraw at the rate of 60 frames per second—that's
    just 16.67 ms per frame. If we do work on the main thread that takes anywhere
    near 16 ms, we risk affecting the frame rate, resulting in jank—stuttering animations,
    jerky scrolling, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Android努力同步用户界面重绘与硬件刷新率。这意味着它旨在以每秒60帧的速率重绘——即每帧16.67毫秒。如果我们主线程上的工作需要接近16毫秒，我们就有可能影响帧率，导致卡顿——动画卡顿、滚动不流畅等等。
- en: 'Ideally, of course, we don''t want to drop a single frame. Jank, unresponsiveness,
    and especially the ANR, offer a very poor user experience, which translates into
    bad reviews and unpopular applications. A rule to live by when building Android
    applications is: do not block the main thread!'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，理想情况下，我们不想丢掉任何一帧。卡顿、不响应，尤其是ANR，提供了一个非常糟糕的用户体验，这转化为差评和不受欢迎的应用程序。在构建Android应用程序时遵循的一个规则是：不要阻塞主线程！
- en: Note
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Android provides a helpful strict mode setting in **Developer Options** on each
    device, which will flash on the screen when applications perform long-running
    operations on the main thread.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Android在每个设备上的**开发者选项**中提供了一个有用的严格模式设置，当应用程序在主线程上执行长时间运行的操作时，它会在屏幕上闪烁。
- en: Further protection was added to the platform in Honeycomb (API level 11) with
    the introduction of a new `Exception` class, `NetworkOnMainThreadException`, a
    subclass of `RuntimeException` that is thrown if the system detects network activity
    initiated on the main thread.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在Honeycomb（API级别11）中，平台增加了额外的保护措施，引入了一个新的`Exception`类，`NetworkOnMainThreadException`，它是`RuntimeException`的子类，当系统检测到在主线程上发起的网络活动时会被抛出。
- en: Maintaining responsiveness
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护响应性
- en: Ideally then, we may want to offload any long-running operations from the main
    thread so that they can be handled in the background by another thread, and the
    main thread can continue to process user-interface updates smoothly and respond
    in a timely fashion to user interactions.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，理想情况下，我们可能希望将任何长时间运行的操作从主线程卸载，以便它们可以在后台由另一个线程处理，而主线程可以继续平滑地处理用户界面更新，并及时响应用户交互。
- en: 'The typical time-consuming tasks that should be handled on a background thread
    include the following:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在后台线程中处理的典型耗时任务包括以下内容：
- en: Network communications
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络通信
- en: Input and output file operations on the local filesystem
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地文件系统上的输入和输出文件操作
- en: Image and video processing
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图像和视频处理
- en: Complex math calculations
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 复杂的数学计算
- en: Text processing
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本处理
- en: Data encoding and decoding
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据编码和解码
- en: For this to be useful, we must be able to coordinate the work and safely pass
    data between cooperating threads—especially between background threads and the
    main thread, and it is exactly to solve this problem that asynchronous programming
    is used.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使其有用，我们必须能够协调工作并安全地在协作线程之间传递数据——特别是在后台线程和主线程之间，这正是异步编程被用来解决这个问题的原因。
- en: 'Let''s get started with the synchronous versus asynchronous diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从同步与异步的对比图开始：
- en: '![Maintaining responsiveness](img/Image_B05062_01_05.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![维护响应性](img/Image_B05062_01_05.jpg)'
- en: The preceding example graphically shows the main differences between the two
    models of processing. On the left-hand side, the data download task occurs on
    the main thread, keeping the thread busy until the download data is finished.
    So if the user interacts with the UI and generates an event such as a touch event,
    the application will suffer a lag or will become unresponsive if the download
    task takes a substantial amount of time to finish.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例直观地显示了两种处理模型之间的主要区别。在左侧，数据下载任务在主线程上执行，直到下载数据完成，使线程保持忙碌。因此，如果用户与UI交互并生成一个事件，例如触摸事件，如果下载任务需要大量时间才能完成，应用程序将出现延迟或无响应。
- en: On the right-hand side, the asynchronous model will hand over the download data
    task to another background thread, keeping the main thread available to process
    any event coming from the UI interaction. When the downloaded data is available,
    the background task could post the result to the main thread if the data handling
    needs to update any UI state.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在右侧，异步模型会将下载数据任务交给另一个后台线程，保持主线程可用以处理来自UI交互的任何事件。当下载的数据可用时，后台任务可以将结果发布到主线程，如果数据处理需要更新任何UI状态。
- en: When we use an asynchronous model to program our application, the Android OS
    will also take advantage of additional CPU cores available in the most recent
    devices to execute multiple background threads at the same time and increase the
    application's power efficiency.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用异步模型来编程我们的应用程序时，Android操作系统也会利用最新设备中可用的额外CPU核心同时执行多个后台线程，从而提高应用程序的电源效率。
- en: Note
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This simultaneous execution of separate code paths that potentially interact
    with each other is known as **concurrency**.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这种可能相互交互的独立代码路径的并行执行称为**并发**。
- en: The simultaneous execution of subunits of work in parallel to complete one unit
    of work is known as **parallelism**.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 将工作子单元并行执行以完成一个工作单元的操作称为**并行性**。
- en: Concurrency in Android
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android中的并发
- en: As explained before, in order to achieve a scalable application in a multicore
    device environment, the Android developer should be capable of creating concurrent
    lines of execution that combine and aggregate data from multiple resources.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，为了在多核设备环境中实现可扩展的应用程序，Android开发者应该能够创建并发执行行，这些执行行从多个资源中组合和汇总数据。
- en: The Android SDK, as it is based on a subset of Java SDK, derived from the Apache
    Harmony project, provides access to low-level concurrency constructs such as `java.lang.Thread`,
    `java.lang.Runnable`, and the `synchronized` and `volatile` keywords.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK，因为它基于Java SDK的一个子集，源自Apache Harmony项目，提供了对低级并发构造的访问，例如`java.lang.Thread`、`java.lang.Runnable`以及`synchronized`和`volatile`关键字。
- en: These constructs are the most basic building blocks to achieve concurrency and
    parallelism, and all the high-level asynchronous constructs are created around
    these building blocks.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构造是实现并发和并行性的最基本构建块，所有高级异步构造都是围绕这些构建块创建的。
- en: 'The most basic one, `java.lang.Thread`, is the class that is mostly used and
    is the construct that creates a new independent line of execution in a Java program:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 最基本的一个是`java.lang.Thread`，这是最常使用的类，也是创建Java程序中新的独立执行线的构造。
- en: '[PRE1]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the preceding code, we subclassed `java.lang.Thread` to create our own independent
    line of execution. When `Thread` is started, the run method will be called automatically
    and it will print the message on the Android log:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们继承了`java.lang.Thread`以创建我们自己的独立执行线。当`Thread`启动时，将自动调用run方法，并在Android日志上打印消息。
- en: '[PRE2]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At this time, we will create an instance of our `MyThread`, and when we start
    it in the second line, the system creates a thread inside the process and executes
    the `run()` method.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在此时，我们将创建我们的`MyThread`实例，并在第二行启动它时，系统将在进程内部创建一个线程并执行`run()`方法。
- en: 'Other helpful thread-related methods include the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 其他有用的线程相关方法包括以下内容：
- en: '`Thread.currentThread()`: This retrieves the current running instance of the
    thread'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.currentThread()`：这检索当前运行的线程实例。'
- en: '`Thread.sleep(time)`: This pauses the current thread from execution for the
    given period of time'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.sleep(time)`：这将在给定时间段内暂停当前线程的执行。'
- en: '`Thread.getName()` and `Thread.getId()`: These get the name and TID, respectively
    so that they can be useful for debugging purposes'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.getName()`和`Thread.getId()`：这些分别获取名称和TID，以便它们在调试目的上是有用的。'
- en: '`Thread.isAlive()`: This checks whether the thread is currently running or
    it has already finished its job'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.isAlive()`: 这检查线程是否目前正在运行，或者它是否已经完成了其工作。'
- en: '`Thread.join()`: This blocks the current thread and waits until the accessed
    thread finishes its execution or dies'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Thread.join()`: 这将阻塞当前线程，直到被访问的线程完成其执行或死亡。'
- en: 'The `Runnable` interface, which is another building block that comes from the
    Java API, is an interface defined to specify and encapsulate code that is intended
    to be executed by a Java thread instance or any other class that handles this
    `Runnable`:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`Runnable` 接口，这是来自 Java API 的另一个构建块，是一个定义了用于指定和封装旨在由 Java 线程实例或任何其他处理此 `Runnable`
    的类执行的代码的接口：'
- en: '[PRE3]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the following code, we basically created the `Runnable` subclass so that
    it implements the `run()` method and can be passed and executed by a thread:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下代码中，我们基本上创建了 `Runnable` 子类，以便它实现 `run()` 方法，可以被线程传递并执行：
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now our `Runnable` subclass can be passed to `Thread` and is executed independently
    in the concurrent line of execution:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `Runnable` 子类可以被传递给 `Thread`，并在并发执行行中独立执行：
- en: '[PRE5]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'While starting new threads is easy, concurrency is actually a very difficult
    thing to do. Concurrent software faces many issues that fall into two broad categories:
    correctness (producing consistent and correct results) and liveness (making progress
    towards completion). `Thread` creation could also cause some performance overhead,
    and too many threads can reduce the performance, as the OS will have switch between
    these lines of execution.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然启动新线程很容易，但并发实际上是一个非常困难的事情。并发软件面临许多问题，可以分为两大类：正确性（产生一致和正确的结果）和活性（向完成迈进）。`Thread`
    创建也可能导致一些性能开销，过多的线程可能会降低性能，因为操作系统将在这些执行行之间切换。
- en: Correctness issues in concurrent programs
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发程序中的正确性问题
- en: A common example of a correctness problem occurs when two threads need to modify
    the value of the same variable based on its current value. Let's consider that
    we have a `myInt` integer variable with the current value of 2.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 正确性问题的一个常见例子是当两个线程需要根据其当前值修改相同变量的值时。让我们考虑我们有一个 `myInt` 整数变量，其当前值为 2。
- en: In order to increment `myInt`, we first need to read its current value and then
    add 1 to it. In a single-threaded world, the two increments would happen in a
    strict sequence—we will read the initial value 2, add 1 to it, set the new value
    back to the variable, and then repeat the sequence. After the two increments,
    `myInt` holds the value 4.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 为了增加 `myInt` 的值，我们首先需要读取它的当前值，然后将其加 1。在单线程世界中，这两个增加操作将按严格的顺序发生——我们将读取初始值 2，将其加
    1，然后将新值设置回变量，并重复此过程。在两次增加之后，`myInt` 保持值为 4。
- en: 'In a multithreaded environment, we will run into potential timing issues. It
    is possible that two threads trying to increment the variable would both read
    the same initial value 2, add 1 to it, and set the result (in both cases, 3) back
    to the variable:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在多线程环境中，我们将遇到潜在的时间问题。可能两个尝试增加变量的线程都会读取相同的初始值 2，将其加 1，并将结果（在两种情况下都是 3）设置回变量：
- en: '[PRE6]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Both threads behaved correctly in their localized view of the world, but in
    terms of the overall program, we will clearly have a correctness problem; 2 +
    2 should not equal 3! This kind of timing issue is known as a race condition.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 两个线程在其局部世界的视角中表现正确，但在整体程序方面，我们显然会存在一个正确性问题；2 + 2 不应该等于 3！这种时间问题被称为竞态条件。
- en: A common solution to correctness problems, such as race conditions, is mutual
    exclusion—preventing multiple threads from accessing certain resources at the
    same time. Typically, this is achieved by ensuring that threads acquire an exclusive
    lock before reading or updating shared data.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 解决如竞态条件等正确性问题的常见方法是互斥——防止多个线程同时访问某些资源。通常，这是通过确保线程在读取或更新共享数据之前获取独占锁来实现的。
- en: 'To achieve this correctness, we can make use of the `synchronized` construct
    to solve the correctness issue on the following piece of code:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种正确性，我们可以使用 `synchronized` 构造来在以下代码片段上解决正确性问题：
- en: '[PRE7]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding code, we used the intrinsic lock available in each Java object
    to create a mutually exclusive scope of code that will enforce that the increment
    sentence will work properly and will not suffer from correctness issues as explained
    previously. When one of the threads gets access to the protected scope, it is
    said that the thread acquired the lock, and after the thread gets out of the protected
    scope, it releases the lock that could be acquired by another thread.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用了每个Java对象中可用的内建锁来创建一个互斥代码区域，这将确保增量语句能够正确工作，并且不会像之前解释的那样出现正确性问题。当一个线程获得对受保护区域的访问时，我们说该线程获得了锁，当线程离开受保护区域后，它释放了可以被另一个线程获得的锁。
- en: 'Another way to create mutually exclusive scopes is to create a method with
    a synchronized method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 创建互斥作用域的另一种方法是创建一个带有同步方法的函数：
- en: '[PRE8]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The synchronized method will use the object-intrinsic lock, where `myInt` is
    defined to create a mutually exclusive zone so `IncrementThread`, incrementing
    `myInt` through the `increment()`, will prevent any thread interference and memory
    consistency errors.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 同步方法将使用对象内建的锁，其中`myInt`被定义为创建一个互斥区域，这样`IncrementThread`通过`increment()`方法增加`myInt`将防止任何线程干扰和内存一致性错误。
- en: Liveness issues in concurrent programs
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发程序中的活性问题
- en: Liveness can be thought of as the ability of the application to do useful work
    and make progress towards goals. Liveness problems tend to be an unfortunate side
    effect of the solution to the correctness problems.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 活性可以理解为应用程序执行有用工作并朝着目标前进的能力。活性问题往往是解决正确性问题时的不幸副作用。
- en: Both properties should be achieved in a proper concurrent program, notwithstanding
    the correctness is concerned with making progress in a program preventing a deadlock,
    livelock, or starvation from happening, and the correctness is concerned with
    making consistent and correct results.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在适当的并发程序中，应同时实现这两个属性，尽管正确性关注的是防止程序在进展中发生死锁、活锁或饥饿，而正确性关注的是产生一致和正确的结果。
- en: Note
  id: totrans-147
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Deadlock is a situation where two or more threads are unable to proceed because
    each is waiting for the others to do something. Livelock is a situation where
    two or more threads continuously change their states in response to the changes
    in the other threads without doing any useful work.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁是一种情况，其中两个或更多线程无法继续前进，因为每个线程都在等待其他线程做某事。活锁是一种情况，其中两个或更多线程在响应其他线程状态的变化时不断改变自己的状态，但没有做任何有用的工作。
- en: By locking access to data or system resources, it is possible to create bottlenecks
    where many threads are contending to access a single lock, leading to potentially
    significant delays.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 通过锁定对数据或系统资源的访问，可能会创建瓶颈，其中许多线程都在争夺访问单个锁，导致潜在的显著延迟。
- en: Worse, where multiple locks are used, it is possible to create a situation where
    no thread can make progress because each requires exclusive access to a lock that
    another thread currently owns—a situation known as a deadlock.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更糟糕的是，当使用多个锁时，可能会出现一种情况，即没有任何线程可以继续前进，因为每个线程都需要对另一个线程当前拥有的锁进行独占访问——这种情况被称为死锁。
- en: Thread coordination
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 线程协调
- en: 'Thread coordination is an important topic in concurrent programming, especially
    when we want to perform the following tasks:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 线程协调是并发编程中的一个重要主题，尤其是在我们想要执行以下任务时：
- en: 'Synchronize access of threads to shared resources or shared memory:'
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步线程对共享资源或共享内存的访问：
- en: Shared database, files, system services, instance/class variables, or queues
  id: totrans-154
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享数据库、文件、系统服务、实例/类变量或队列
- en: 'Coordinate work and execution within a group of threads:'
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一组线程内协调工作和执行：
- en: Parallel execution, pipeline executions, inter-dependent tasks, and so on
  id: totrans-156
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并行执行、流水线执行、相互依赖的任务等
- en: When we want to coordinate thread efforts to achieve a goal, we should try to
    avoid waiting or polling mechanisms that keep the CPU busy while we wait for an
    event in another thread.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要协调线程的努力以实现目标时，我们应该尽量避免等待或轮询机制，这些机制在等待另一个线程中的事件时会让CPU保持忙碌。
- en: 'The following example shows us a small loop where we will continuously occupy
    the CPU while we wait for a certain state change to happen:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了一个小循环，我们将在此循环中持续占用CPU，同时等待某个状态变化发生：
- en: '[PRE9]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To overcome the coordination issue, and to implement our own constructs, we
    should use some low-level signals or messaging mechanisms to communicate between
    threads and coordinate the interaction.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 为了克服协调问题并实现我们自己的结构，我们应该使用一些低级信号或消息机制在线程之间进行通信并协调交互。
- en: In Java, every object has the `wait()`, `notify()`, and `notifyAll()`methods
    that provide low-level mechanisms to send thread signals between a group of threads
    and put a thread in a waiting state until a condition is met.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，每个对象都有`wait()`、`notify()`和`notifyAll()`方法，这些方法提供了低级机制在多个线程之间发送信号并将线程置于等待状态，直到满足条件。
- en: This mechanism, also known as *monitor* or *guard*, is a design pattern commonly
    used in another languages and it ensures that only one thread can enter a given
    section of code at any given time with an ability to wait until a condition happens.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这种机制，也称为*监控器*或*守卫*，是在其他语言中常用的一种设计模式，它确保在任何给定时间只有一个线程可以进入代码的特定部分，并且能够等待直到条件发生。
- en: This design pattern, in comparison with our previous example, delivers a better
    and efficient CPU-cycle management while waiting for any particular situation
    to happen on another thread, and is generally used in situations where we need
    to coordinate work between different lines of execution.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前的示例相比，这种设计模式在等待另一个线程发生特定情况时，提供了更好的和高效的CPU周期管理，并且通常用于需要在不同执行线路之间协调工作的情况。
- en: In the following code example, we are going to explain how to use this construct
    to create a basic multithreaded `Logger` with 10 threads that will wait in the
    monitor section until a message is pushed (condition) by any other thread in the
    application.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码示例中，我们将解释如何使用这个结构创建一个基本的具有10个线程的多线程`Logger`，这些线程将在监控区域等待，直到其他线程在应用程序中推送（条件）消息。
- en: 'The `Logger`, which is responsible for logging on to the output, has a queue
    with a maximum of 20 positions to store the new logging text messages:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 负责记录输出的`Logger`有一个最多20个位置的队列来存储新的日志文本消息：
- en: '[PRE10]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the next code, we will create a `Runnable` unit of work that runs indefinitely
    and retrieves a message from the queue to print the message on the Android log.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的代码中，我们将创建一个无限运行的`Runnable`工作单元，从队列中检索消息并在Android日志上打印消息。
- en: 'After that, we will create and start 10 threads that are going to execute the
    `Runnable` unit of work `task`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们将创建并启动10个线程，这些线程将执行`Runnable`工作单元`task`：
- en: '[PRE11]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `pullMessage()`, which is a `synchorized` method, runs a mutual exclusion
    and puts the thread in the waiting state when it reaches the `wait()` method.
    All the created threads will stay in this state until another thread calls `notifyAll()`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`pullMessage()`，这是一个`synchorized`方法，当它达到`wait()`方法时运行互斥并将线程置于等待状态。所有创建的线程都将保持这种状态，直到另一个线程调用`notifyAll()`：'
- en: '[PRE12]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: When any thread is in the waiting state, it releases the lock temporarily and
    gives a chance to another thread to enter the mutual exclusion to push new messages
    or enter into the wait state.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何线程处于等待状态时，它会暂时释放锁，给其他线程一个进入互斥区域以推送新消息或进入等待状态的机会。
- en: In the following snippet, we will first create the `Logger` instance and then
    we will call the start method to start the working threads and we will push 10
    messages into a queue of work to be processed.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们首先创建`Logger`实例，然后调用start方法来启动工作线程，并将10条消息推入待处理的工作队列。
- en: When the `pushMessage()`method is invoked, a new logging message is inserted
    at the end of the queue and `notifiyAll()` is invoked to notify all the available
    threads.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用`pushMessage()`方法时，一个新的日志消息会被插入到队列的末尾，并且调用`notifyAll()`来通知所有可用的线程。
- en: 'As the `pullMessage()` method runs in a mutual-exclusion (synchronized) zone,
    only one thread will wake up and return from the `pull` method. Once `pullMessage()`
    returns, the logging message is printed:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`pullMessage()`方法在互斥（同步）区域运行，只有一个线程会被唤醒并从`pull`方法返回。一旦`pullMessage()`返回，日志消息就会被打印：
- en: '[PRE13]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the following console output, we have an example of the output that this
    code will generate and the logging messages are processed by any available threads
    in an ordered manner:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的控制台输出中，我们有一个这个代码将生成的输出示例，并且日志消息是由任何可用的线程以有序的方式处理的：
- en: '[PRE14]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This kind of low-level construct can also be used to control shared resources
    (polling) to manage background execution (parallelism) and control thread pools.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这种低级结构也可以用来控制共享资源（轮询）以管理后台执行（并行性）和控制线程池。
- en: Concurrent package constructs
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并发包结构
- en: 'Other Java concurrent constructs provided by `java.util.concurrent`, which
    are also available on Android SDK are as follows:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由`java.util.concurrent`提供的其他Java并发结构，在Android SDK中也可用，如下所示：
- en: '**Lock objects** (`java.util.concurrent`): They implement locking behaviors
    with a higher level idiom.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锁对象**（`java.util.concurrent`）：它们通过更高级别的惯用语实现锁定行为。'
- en: '**Executors**: These are high-level APIs to launch and manage a group of thread
    executions (`ThreadPool`, and so on).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Executors**：这些是用于启动和管理一组线程执行的高级API（`ThreadPool`等）。'
- en: '**Concurrent collections**: These are the collections where the methods that
    change the collection are protected from synchronization issues.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发集合**：这些是更改集合的方法受到同步问题保护的集合。'
- en: '**Synchronizers**: These are high-level constructs that coordinate and control
    thread execution (Semaphore, Cyclic Barrier, and so on).'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**同步器**：这些是高级结构，用于协调和控制线程执行（信号量、循环屏障等）。'
- en: '**Atomic variables** (`java.util.concurrent.atomic`): These are classes that
    provide thread-safe operations on single variables. One example of it is `AtomicInteger`
    that could be used in our example to solve the correctness issue.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**原子变量**（`java.util.concurrent.atomic`）：这些是提供对单个变量线程安全操作的类。一个例子是`AtomicInteger`，可以在我们的示例中用来解决正确性问题。'
- en: Some Android-specific constructs use these classes as basic building blocks
    to implement their concurrent behavior, although they could be used by a developer
    to build custom concurrent constructs to solve a specific use case.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一些Android特定的结构将这些类用作基本构建块来实现它们的并发行为，尽管开发者也可以使用这些类来构建自定义并发结构以解决特定用例。
- en: Executor framework
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Executor框架
- en: 'The `Executor` framework is another framework available on `java.util.concurrent`
    that provides an interface to submit `Runnable` tasks, decoupling the task submission
    from the way the task will run:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`Executor`框架是`java.util.concurrent`上可用的另一个框架，它提供了一个提交`Runnable`任务的接口，将任务提交与任务运行方式解耦：'
- en: '[PRE15]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Each `Executor`, which implements the interface that we defined earlier, can
    manage the asynchronous resources, such as thread creation destruction and caching,
    and task queueing in a variety of ways to achieve the perfect behavior to a specific
    use case.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 每个`Executor`，它实现了我们之前定义的接口，可以通过多种方式管理异步资源，如线程创建、销毁和缓存，以及任务排队，以实现针对特定用例的完美行为。
- en: 'The `java.util.concurrent` comes with a group of implementations available
    out of the box that cover most generic use cases, as follows:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '`java.util.concurrent`提供了一组开箱即用的实现，涵盖了大多数通用用例，如下所示：'
- en: '`Executors.newCachedThreadPool()`: This is a thread poll that could grow and
    reuse previously created threads'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newCachedThreadPool()`: 这是一个可以增长和重用先前创建的线程的线程池'
- en: '`Executors.newFixedThreadPool` (`nThreads`): This is a thread pool with a fixed
    number of threads and a message queue for store work'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newFixedThreadPool`（`nThreads`）：这是一个具有固定线程数和用于存储工作的消息队列的线程池'
- en: '`Executors.newSingleThreadPool()`: This is similar to newFixedThreadPool, but
    with only one working thread'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Executors.newSingleThreadPool()`: 这与`newFixedThreadPool`类似，但只有一个工作线程'
- en: 'To run a task on `Executor`, the developer has to invoke `execute()` by passing
    `Runnable` as an argument:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`Executor`上运行任务，开发者必须通过传递`Runnable`作为参数来调用`execute()`：
- en: '[PRE16]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we created `ThreadPool` over the factory methods with
    a fixed number of five threads ready to process work.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们使用固定数量的五个线程的工厂方法创建了`ThreadPool`，以便处理工作。
- en: After the `ExecutorService` instance creation, new `Runnable` tasks are posted
    for asynchronous processing.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建`ExecutorService`实例后，新的`Runnable`任务被提交以进行异步处理。
- en: When a new unit of work is submitted, a thread that is free to work is chosen
    to handle the task; but when all the threads are occupied, `Runnable` will wait
    in a local queue until a thread is ready to work.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当提交新的工作单元时，选择一个空闲的线程来处理任务；但当所有线程都忙碌时，`Runnable`将在本地队列中等待，直到有线程准备好工作。
- en: Android primary building blocks
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android主要构建块
- en: 'A typical Android application is composed of the following four main building
    blocks:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的Android应用程序由以下四个主要构建块组成：
- en: '`android.app.Activity`'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.Activity`'
- en: '`android.app.Service`'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.app.Service`'
- en: '`android.content.BroadcastReceiver`'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.content.BroadcastReceiver`'
- en: '`android.content.ContentProvider`'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`android.content.ContentProvider`'
- en: The Activity, Service, and `BroadcastReceiver` are activated explicitly or implicitly
    over an asynchronous message called `Intent`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 活动、服务和`BroadcastReceiver`可以通过异步消息`Intent`显式或隐式地激活。
- en: Each of these building blocks have their own life cycle, so they could be exposed
    to different concurrency issues if an asynchronous architecture is used to offload
    work from the main thread.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这些构建块各自都有自己的生命周期，因此如果使用异步架构从主线程卸载工作，它们可能会遇到不同的并发问题。
- en: Activity concurrent issues
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动并发问题
- en: The Activity building block has a tight connection with a presentation layer
    because it's the entity that manages the UI view over a defined tree of fragments
    and views that display information and respond to user interactions.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: Activity构建块与表示层有紧密的联系，因为它管理着在定义的片段和视图树上的UI视图，这些视图显示信息并响应用户交互。
- en: Android applications are typically composed of one or more subclasses of `android.app.Activity`.
    An Activity instance has a very well-defined lifecycle that the system manages
    through the execution of lifecycle method callbacks, all of which are executed
    on the main thread.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: Android应用程序通常由一个或多个`android.app.Activity`的子类组成。Activity实例有一个非常明确的生命周期，系统通过执行生命周期方法回调来管理它，所有这些回调都是在主线程上执行的。
- en: To keep the application responsive and reactive, and the activity transition
    smooth, the developer should understand the nature of each Activity lifecycle
    callback.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持应用程序的响应性和反应性，以及活动转换的平滑，开发者应该了解每个Activity生命周期回调的本质。
- en: 'The most important callbacks on the Activity lifecycle are as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Activity生命周期中最重要的回调如下：
- en: '`onCreate()`: At this state, Activity is not visible, but it is here where
    all the private Activity resources (views and data) are created. The long and
    intensive computations should be done asynchronously in order to decrease the
    time when the users don''t get a visual feedback during an Activity transition.'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onCreate()`: 在此状态下，Activity不可见，但所有私有Activity资源（视图和数据）都是在这里创建的。为了减少用户在Activity转换期间得不到视觉反馈的时间，应异步执行长时间和密集的计算。'
- en: '`onStart()`: This is the callback called when the UI is visible, but not able
    to interact on the screen. Any lag here could make the user angry as any touch
    event generated at this stage is going to be missed by the system.'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStart()`: 当UI可见但无法在屏幕上交互时，会调用此回调。任何在此处产生的触摸事件都会被系统错过，这可能会让用户感到愤怒。'
- en: '`onResume()`: This is the callback called when Activity is going to be in the
    foreground and at an interactable state.'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onResume()`: 当Activity即将进入前台并处于可交互状态时，会调用此回调。'
- en: '`onPause()`: This is a callback called when Activity is going to the background
    and is not visible. Computations should end quickly as the next Activity will
    not resume until this method ends.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPause()`: 当Activity即将进入后台且不可见时，会调用此回调。计算应该迅速结束，因为下一个Activity不会在当前方法结束之前恢复。'
- en: '`onStop()`: This is a callback called when Activity is no longer visible, but
    can be restarted.'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onStop()`: 当Activity不再可见但可以重新启动时，会调用此回调。'
- en: '`onDestroy()`: This is a callback called when the Activity instance is going
    to be destroyed in the background. All the resources and references that belong
    to this instance have to be released.'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onDestroy()`: 当Activity实例即将在后台被销毁时，会调用此回调。属于此实例的所有资源和引用都必须被释放。'
- en: An Activity instance that is completed should be eligible for garbage collection,
    but background threads that refer to Activity or part of its view hierarchy can
    prevent garbage collection and create a memory leak.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 完成的Activity实例应该有资格进行垃圾回收，但引用Activity或其视图层次结构一部分的后台线程可以防止垃圾回收并造成内存泄漏。
- en: Similarly, it is easy to waste CPU cycles (and battery life) by continuing to
    do background work when the result can never be displayed as Activity is completed.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果结果永远不会显示，因为Activity已完成，继续进行后台工作很容易浪费CPU周期（以及电池寿命）。
- en: Finally, the Android platform is free at any time to kill processes that are
    not the user's current focus. This means that if we have long-running operations
    to complete, we need some way of letting the system know not to kill our process
    yet.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Android平台可以在任何时间自由地杀死不是用户当前焦点的进程。这意味着如果我们有长时间运行的操作需要完成，我们需要某种方式让系统知道不要杀死我们的进程。
- en: All of this complicates the do-not-block–the-main-thread rule as we need to
    worry about canceling background work in a timely fashion or decoupling it from
    the Activity lifecycle where appropriate.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都使得“不要阻塞主线程”规则变得更加复杂，因为我们需要及时取消后台工作或在适当的时候将其与Activity生命周期解耦。
- en: Manipulating the user interface
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作用户界面
- en: The other Android-specific problem lies not in what you can do with the UI thread,
    but in what you cannot do.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个Android特有的问题不在于您可以使用UI线程做什么，而在于您不能做什么。
- en: Note
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You cannot manipulate the user interface from any thread other than the main
    thread.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 您不能从除主线程以外的任何线程操作用户界面。
- en: This is because the user interface toolkit is not thread-safe, that is, accessing
    it from multiple threads may cause correctness problems. In fact, the user interface
    toolkit protects itself from potential problems by actively denying access to
    user interface components from threads other than the one that originally created
    these components.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为用户界面工具包不是线程安全的，也就是说，从多个线程访问它可能会导致正确性问题。实际上，用户界面工具包通过积极拒绝从创建这些组件以外的线程访问用户界面组件来保护自己免受潜在问题的侵害。
- en: If the system detects this, it will instantly notify the application by throwing
    `CalledFromWrongThreadException`.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果系统检测到这一点，它将通过抛出`CalledFromWrongThreadException`立即通知应用程序。
- en: The final challenge then lies in safely synchronizing background threads with
    the main thread so that the main thread can update the user interface with the
    results of the background work.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的挑战在于安全地同步后台线程与主线程，以便主线程可以使用后台工作的结果更新用户界面。
- en: If the developer has access to an `Activity` instance, the `runOnUiThread` instance
    method can be used to update the UI from a background thread.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 如果开发者可以访问`Activity`实例，可以使用`runOnUiThread`实例方法从后台线程更新UI。
- en: 'The method accepts a `Runnable` object like the one used to create an execution
    task for a thread:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个`Runnable`对象，就像用于创建线程执行任务的执行任务一样：
- en: '[PRE17]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: In the following example, we are going to use this facility to publish the result
    from a synonym search that was processed by a background thread.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将使用这个设施来发布由后台线程处理的同义词搜索的结果。
- en: 'To accomplish the goal during the `OnCreate` activity callback, we will set
    up `onClickListener` to run `searchTask` on a created thread:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在`OnCreate`活动回调期间实现目标，我们将设置`onClickListener`在创建的线程上运行`searchTask`：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When the user clicks on the **Search** button, we will create a `Runnable` anonymous
    class that searches for the word typed in `R.id.wordEt EditText` and starts the
    thread to execute `Runnable`.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**搜索**按钮时，我们将创建一个用于搜索在`R.id.wordEt EditText`中输入的单词的`Runnable`匿名类，并启动线程来执行`Runnable`。
- en: 'When the search completes, we will create an instance of `Runnable` `SetSynonymResult`
    to publish the result back on the synonym `TextView` over the UI thread:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 当搜索完成后，我们将创建一个`Runnable`实例`SetSynonymResult`，在UI线程上发布结果到同义词`TextView`：
- en: '[PRE19]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This technique is sometime not the most convenient one, especially when we don't
    have access to an Activity instance; therefore, in the following chapters, we
    are going to discuss simpler and cleaner techniques to update the UI from a background
    computing task.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术有时并不是最方便的，尤其是在我们没有访问Activity实例的情况下；因此，在接下来的章节中，我们将讨论更简单、更干净的从后台计算任务更新UI的技术。
- en: Service concurrent issues
  id: totrans-241
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 服务并发问题
- en: These are the Android entities that run in the background, which usually perform
    tasks in the `name` application that does not require any user interaction.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是在后台运行的Android实体，通常在不需要任何用户交互的`name`应用程序中执行任务。
- en: '`Service`, by default, runs in the main thread of the application process.
    It does not create its own thread, so if your `Service` is going to do any blocking
    operation, such as downloading an image, play a video, or access a network API,
    the user should design a strategy to offload the time of the work from the main
    thread into another thread.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Service`在应用程序进程的主线程中运行。它不会创建自己的线程，因此如果您的`Service`要进行任何阻塞操作，例如下载图片、播放视频或访问网络API，用户应该设计一种策略将工作的时间从主线程卸载到另一个线程。
- en: As `Service` could have its own concurrent strategy, it should also take into
    account that, like Activity, it should update the UI over the main thread, so
    a strategy to post back the results from the background into the main loop is
    imperative.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`Service`可以有自己的并发策略，它还应该考虑到，就像Activity一样，它应该通过主线程更新UI，因此从后台将结果回传到主循环的策略是必不可少的。
- en: 'In the Android services domain, the way the service is started distinguishes
    the nature of `Service` into the following two groups:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android服务领域，启动服务的方式将`Service`的性质分为以下两组：
- en: '**Started services**: This is the service that is started by `startService()`
    that can run definitively even if the component that started it was destroyed.
    A started service does not interact directly with the component that started it.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**已启动服务**：这是通过`startService()`启动的服务，即使启动它的组件被销毁，它也可以持续运行。已启动的服务不会直接与启动它的组件交互。'
- en: '**Bound services**: This service exists while at least one Android component
    is bounded to it by calling `bindService()`. It provides a two-way (client-server)
    communication channel for communication between components.'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绑定服务**：此服务在至少有一个Android组件通过调用`bindService()`绑定到它时存在。它为组件之间的通信提供了一个双向（客户端-服务器）通信通道。'
- en: Started services issues
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 已启动服务问题
- en: When we implement a started service, any application component is able to start
    it when it invokes the `startService(Intent)` method. Once the system receives
    `startService(Intent)` and the service is not yet started, the system calls `onCreate()`
    and then `onStartCommand()` with the arguments encapsulated on an Intent object.
    If the `Service` already exists, only `onStartCommand()` is invoked.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们实现已启动服务时，任何应用程序组件都可以在调用`startService(Intent)`方法时启动它。一旦系统收到`startService(Intent)`并且服务尚未启动，系统会调用`onCreate()`然后调用`onStartCommand()`，并将封装在Intent对象上的参数传递给它们。如果`Service`已经存在，则只调用`onStartCommand()`。
- en: 'The callbacks used by a started service are as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 已启动服务使用的回调如下：
- en: '[PRE20]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the `onStartCommand()` callback, once a long computing task is required
    to handle the service request, a handover to the background threads should be
    explicitly implemented and coordinated in order to avoid an undesired ANR:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 在`onStartCommand()`回调中，一旦需要处理服务请求的长时间计算任务，应明确实现并协调向后台线程的移交，以避免不希望的ANR：
- en: '[PRE21]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: When the service is done, and it needs to publish results to the UI, a proper
    technique to communicate with the main thread should be used.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务完成时，并且需要将结果发布到UI，应使用适当的技巧与主线程进行通信。
- en: Bound services issues
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 绑定服务问题
- en: A bound service generally used when a strong interaction between an Android
    component and a service is required.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定服务通常在需要Android组件与服务之间强交互时使用。
- en: 'When the service runs on the same process, the interaction between the Android
    component (client) and the bound service (server) is always provided by a `Binder`
    class returned on `onBind()`. With the `Binder` instance on hand, the client has
    access to the service''s public methods, so when any component invokes the bound
    service public methods, the component should be aware of the following:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务在同一个进程中运行时，Android组件（客户端）与绑定服务（服务器）之间的交互始终由`onBind()`返回的`Binder`类提供。有了`Binder`实例，客户端可以访问服务公开的方法，因此当任何组件调用绑定服务的公共方法时，该组件应该意识到以下内容：
- en: When a long running operation is expected to take place during the method invocation,
    the invocation must occur in a separate thread
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当预期在方法调用期间发生长时间运行的操作时，调用必须在单独的线程中发生
- en: 'If the method is invoked in a separated thread, and the service wants to update
    the UI, the service must run the update over the main thread:'
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果方法在分离的线程中调用，并且服务想要更新UI，服务必须在主线程上运行更新：
- en: '[PRE22]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Service in a separate process
  id: totrans-261
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在单独的进程中提供服务
- en: 'When an Android service runs on its own process, it runs in an independent
    process, with its own address space, making the communication with the main process
    UI thread harder to implement the following:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 当Android服务在其自己的进程中运行时，它在一个独立的进程中运行，有自己的地址空间，这使得与主进程UI线程的通信更难实现以下内容：
- en: '[PRE23]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: To implement a service in a different process, we need to use an **inter-process
    communication** (**IPC**) technique to send messages between your application
    and the service.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要在不同的进程中实现服务，我们需要使用**进程间通信**（**IPC**）技术来在您的应用程序和服务之间发送消息。
- en: Note
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: IPC is the activity of sharing data across multiple processes, usually using
    a well-defined communication protocol. It typically has a process that acts as
    the client and a process that acts as the server.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: IPC（进程间通信）是在多个进程之间共享数据的活动，通常使用一个定义良好的通信协议。它通常包括一个充当客户端的进程和一个充当服务器的进程。
- en: 'There are two technologies available on the Android SDK to implement this,
    as follows:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: Android SDK中提供了两种技术来实现这一点，如下所示：
- en: '**AIDL** (**Android Interface Definition Language**): This allows you to define
    an interface over a set of primitive types. It allows you create multithreaded
    processing services, but it adds other levels of complexity to your implementation.
    This is only recommended to advanced programmers.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AIDL（Android接口定义语言**）：这允许你在一系列原始类型上定义一个接口。它允许你创建多线程处理服务，但也会给你的实现增加其他复杂度。这仅推荐给高级程序员。'
- en: '**Messenger**: This is a simple interface that creates a queue of work for
    you in the service side. This executes all the tasks sequentially on single thread
    managed by a `Handler`.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信使（Messenger）**：这是一个简单的接口，在服务端为你创建一个工作队列。它会在一个由`Handler`管理的单线程上顺序执行所有任务。'
- en: We haven't given more details about these techniques yet; however, an example
    of this construct is going to be presented later in a more advanced chapter where
    all the concepts involved are more mature.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有对这些技术给出更多细节；然而，这个结构的一个示例将在更高级的章节中展示，其中涉及的所有概念都更加成熟。
- en: Broadcast receiver concurrent issues
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 广播接收器并发问题
- en: This building block is a component that subscribes to system and application
    events and is notified when these events occur on the system. The broadcast receivers
    are defined statically in the application manifest or dynamically via the `Context.registerReceiver()`.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 这个构建块是一个订阅系统和应用事件的组件，当这些事件在系统上发生时，它会收到通知。广播接收器在应用程序清单中静态定义，或者通过`Context.registerReceiver()`动态定义。
- en: The broadcast received is activated though the `onReceive()`callback and this
    method runs on the main thread, blocking another Android component from running
    if we try to execute time-consuming tasks.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 广播接收器通过`onReceive()`回调激活，此方法在主线程上运行，如果我们尝试执行耗时任务，会阻塞另一个Android组件的运行。
- en: Once `onReceive()` finishes, the system considers the object inactive and can
    release the resources attached to this instance and recycle the whole object.
    This behavior has a tremendous impact on what we can do inside, because if we
    hand over some processing to a concurrent thread, the resources that belong to
    `BroadcastReceiver` might be recycled and are no longer available, or in an extreme
    case, the process could be killed if there were no important components running
    on it.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`onReceive()`方法执行完毕，系统会认为该对象不再活跃，可以释放与该实例关联的资源，并回收整个对象。这种行为对我们内部能做什么有着巨大的影响，因为如果我们将一些处理任务交给一个并发线程，属于`BroadcastReceiver`的资源可能会被回收，从而不再可用，或者在极端情况下，如果没有在它上面运行重要组件，进程可能会被终止。
- en: Tip
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Android version 11 introduced the `goAsync()`method on the broadcast receiver
    to keep the broadcast active after returning from the `onReceive()` function.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: Android 11版本在广播接收器中引入了`goAsync()`方法，以便在从`onReceive()`函数返回后保持广播活跃。
- en: Android concurrency constructs
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Android并发结构
- en: The good news is that the Android platform provides specific constructs to address
    the concurrency general issues and to solve the specific problems presented by
    Android.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，Android平台提供了特定的结构来解决并发一般问题和解决Android提出的特定问题。
- en: There are constructs that allow us to defer tasks to run later on the main thread,
    communicate easily between cooperating threads, and issue work to the managed
    pools of worker threads and reintegrate the results back in the main thread.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 存在一些结构允许我们将任务推迟到稍后主线程上运行，便于协作线程之间的通信，并将工作分配给管理的工作线程池，并将结果重新集成到主线程中。
- en: There are solutions to the constraints of the Activity lifecycle, both for medium-term
    operations that closely involve the user interface and longer-term work that must
    be completed even if the user leaves the application.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 有解决方案可以解决Activity生命周期的限制，无论是涉及用户界面的中期操作，还是即使用户离开应用程序也必须完成的长久期工作。
- en: While some of these constructs were only introduced with newer releases of the
    Android platform, they are available through the support libraries, and with a
    few exceptions, the examples in this book target devices that run API level 8
    (Android 2.2) and higher versions.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然其中一些结构仅在新版本的Android平台上引入，但它们可以通过支持库使用，并且除了少数例外，本书中的示例针对的是运行API级别8（Android
    2.2）及更高版本的设备。
- en: Summary
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we took a detailed look at the available Android runtimes,
    Android processes, and thread models.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细探讨了可用的Android运行时、Android进程和线程模型。
- en: We then introduced the concurrent issues that we would cope with when we try
    to implement robust concurrent programs.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了在尝试实现健壮的并发程序时可能会遇到的并发问题。
- en: Finally, we listed the basic concurrent building blocks available on the SDK
    to design concurrent programs.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们列出了SDK上可用的基本并发构建块，以设计并发程序。
- en: 'In the next chapter, we''ll take a look at some Android-specific low-level
    building blocks on which the other concurrency mechanisms are built: `Handler`,
    `Looper`, and `LooperThread`.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨一些特定于Android的低级构建块，其他并发机制都是基于这些构建块构建的：`Handler`、`Looper`和`LooperThread`。
