- en: Chapter 7. Multimedia Resources
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 多媒体资源
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Selecting images and videos
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择图像和视频
- en: Capturing media with the camera
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用相机捕获媒体
- en: Playing videos
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放视频
- en: Playing music and sounds
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 播放音乐和声音
- en: Recording with the microphone
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用麦克风录制
- en: Managing album items directly
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 直接管理相册项目
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: One of the most important features of today's smartphones and tablets is their
    ability to capture and manage multimedia resources. Be it photos, videos, or audio,
    an app targeted at these devices that can handle multimedia effectively is very
    important.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 今天智能手机和平板电脑最重要的功能之一是它们捕获和管理多媒体资源的能力。无论是照片、视频还是音频，针对这些设备且能有效处理多媒体的应用程序非常重要。
- en: In this chapter, we will see how to manage media stored on the device. We will
    also learn how to use the device's multimedia capturing devices (a camera and
    microphone) to capture content and create an app that will provide a rich experience
    to the user.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解如何管理设备上存储的媒体。我们还将学习如何使用设备的多媒体捕获设备（相机和麦克风）来捕获内容并创建一个将为用户提供丰富体验的应用程序。
- en: 'More specifically, we will discuss the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将讨论以下主题：
- en: '`UIImagePickerController`: This is a controller that provides access to the
    saved photos and videos on the device through a user interface, but also a camera
    interface for capturing photos through the device''s camera hardware.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIImagePickerController`：这是一个控制器，它通过用户界面提供对设备上保存的照片和视频的访问权限，同时也提供了一个相机界面，可以通过设备的相机硬件捕获照片。'
- en: '`MPMoviePlayerController`: This is a controller that allows us to play and
    stream video files.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMoviePlayerController`：这是一个控制器，允许我们播放和流式传输视频文件。'
- en: '`MPMediaPickerController`: This is the default user interface to access the
    saved content managed by the native iPod app.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMediaPickerController`：这是访问由原生iPod应用程序管理的保存内容的默认用户界面。'
- en: '`MPMusicPlayerController`: This is the object that is responsible for playing
    the iPod content.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MPMusicPlayerController`：这是一个负责播放iPod内容的对象。'
- en: '`AVAudioPlayer`: This is the class that allows us to play sound files.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVAudioPlayer`：这是一个类，允许我们播放声音文件。'
- en: '`AVAudioRecorder`: This is the class that allows us to use the microphone to
    record audio.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AVAudioRecorder`：这是一个类，允许我们使用麦克风录制音频。'
- en: '`ALAssetsLibrary`: This is the class that provides access to the device''s
    available assets and their metadata.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ALAssetsLibrary`：这是一个类，提供对设备上可用资产及其元数据的访问权限。'
- en: Selecting images and videos
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择图像和视频
- en: In this recipe, we will learn how to provide the user with the ability to import
    images and videos from the device album.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何为用户提供从设备相册导入图像和视频的能力。
- en: Getting ready
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ImagePickerApp`.
    For this recipe, we will need some images to be stored in the simulator's photo
    albums.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ImagePickerApp`。对于本食谱，我们需要一些图像存储在模拟器的相册中。
- en: An easy way to add images to the simulator is by navigating to a web page with
    Safari. Long-tapping (click + hold) on any image in Safari will show us an action
    sheet with a **Save** option. Tapping the option saves the image to the photo
    albums.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 向模拟器添加图像的一个简单方法是通过Safari导航到一个网页。在Safari中长按（点击并按住）任何图像将显示一个包含**保存**选项的操作表。点击该选项将图像保存到相册中。
- en: How to do it...
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Open the `ImagePickerAppViewController.xib` file in Interface Builder and add
    `UIImageView` and `UIButton` to it.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`ImagePickerAppViewController.xib`文件，并向其中添加`UIImageView`和`UIButton`。
- en: 'Enter the following code in the `ViewDidLoad` method:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewDidLoad`方法中输入以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Implement the handler methods for the `FinishedPickingMedia` and `Canceled`
    events as shown in the following code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下代码中的`FinishedPickingMedia`和`Canceled`事件处理程序：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the app on the simulator. Tap on the button you added in the
    initial steps to present the image picker and select an image by tapping on its
    thumbnail. The image will be displayed in the image view. The `UIImagePickerController`
    is shown in the following screenshot:![How to do it...](img/8924OT_07_01.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击在初始步骤中添加的按钮以显示图片选择器，并通过点击其缩略图来选择一个图像。图像将在图像视图中显示。`UIImagePickerController`在以下屏幕截图中显示：![如何操作...](img/8924OT_07_01.jpg)
- en: Note
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just before the first time `UIImagePickerController` is shown in an app, iOS
    will display an alert, asking the user for permission to access the photo albums.
    Handling this situation is described in the *Managing album items directly* recipe
    later in this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中第一次显示 `UIImagePickerController` 之前，iOS 将显示一个警报，请求用户允许访问照片库。处理这种情况将在本章后面的
    *直接管理相册项目* 食谱中描述。
- en: How it works...
  id: totrans-34
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: '`UIImagePickerController` is a special view controller that iOS provides to
    select images and videos that are saved on the device album or even to capture
    new media from the camera.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImagePickerController` 是 iOS 提供的一个特殊视图控制器，用于选择保存在设备相册中的图像和视频，甚至可以从相机捕获新的媒体。'
- en: 'After initializing the image picker object, we need to subscribe to its `FinishedPickingMedia`
    event, which provides us with the media that the user has selected. In the handler
    we assign to it, we get the selected image:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在初始化图像选择器对象后，我们需要订阅其 `FinishedPickingMedia` 事件，该事件为我们提供了用户所选的媒体。在分配给它的处理程序中，我们获取所选的图像：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The `Info` property returns an `NSDictionary` object that contains various
    kinds of information about the picked media. We retrieve the image, passing the
    `UIImagePickerController.OriginalImage` constant as key. As the values of the
    dictionary are of the `NSObject` type, we cast the return value to `UIImage`.
    After we assign the image to the `UIImageView` to be displayed, we dismiss the
    controller by using the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`Info` 属性返回一个包含有关所选媒体各种信息的 `NSDictionary` 对象。我们通过传递 `UIImagePickerController.OriginalImage`
    常量作为键来检索图像。由于字典的值是 `NSObject` 类型，我们将返回值转换为 `UIImage`。在我们将图像分配给要显示的 `UIImageView`
    之后，我们使用以下代码关闭控制器：'
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Canceled` event is triggered when the user taps on the controller's **Cancel**
    button. We must subscribe to it to dismiss the controller, because it will not
    be dismissed automatically when the user taps on the **Cancel** button.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击控制器的 **取消** 按钮时，会触发 `Canceled` 事件。我们必须订阅它以关闭控制器，因为它在用户点击 **取消** 按钮时不会自动关闭。
- en: There's more...
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can define the source of the images/videos the image picker will read from
    through its `SourceType` property. In this example, we use `UIImagePickerController.PhotoLibrary`
    because the simulator does not support the camera hardware.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过图像选择器的 `SourceType` 属性定义它将从中读取的图像/视频的来源。在这个例子中，我们使用 `UIImagePickerController.PhotoLibrary`，因为模拟器不支持相机硬件。
- en: Picking videos
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择视频
- en: '`UIImagePickerController` displays only images by default. To support videos,
    its `MediaType` property must be set. It accepts a `string[]` parameter, with
    the specified media names as shown in the following code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIImagePickerController` 默认只显示图像。要支持视频，其 `MediaType` 属性必须被设置。它接受一个 `string[]`
    参数，其中包含指定的媒体名称，如下面的代码所示：'
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To determine the media type the user has picked, we check the `MediaType` key
    of the dictionary in the `FinishedPickingMedia` handler. If it is a video, we
    get its URL with the `MediaUrl` key, as shown in the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定用户选择的媒体类型，我们在 `FinishedPickingMedia` 处理器中的字典中检查 `MediaType` 键。如果是视频，我们使用
    `MediaUrl` 键获取其 URL，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: See also
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Capturing media with the camera* recipe
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用相机捕捉媒体* 的食谱'
- en: The *Managing album items directly* recipe
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*直接管理相册项目* 的食谱'
- en: Capturing media with the camera
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用相机捕捉媒体
- en: In this recipe, we will learn how to use the device camera to capture the media.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用设备相机来捕捉媒体。
- en: Getting ready
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the `ImagePickerApp` project that we created in the previous recipe.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在上一个食谱中创建的 `ImagePickerApp` 项目。
- en: Note
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The camera functionality is not available on iOS Simulator. This example can
    only run on the device. Refer to [Chapter 14](ch14.html "Chapter 14. Deploying"),
    *Deploying*, for more information.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 相机功能在 iOS 模拟器上不可用。此示例只能在设备上运行。有关更多信息，请参阅第 14 章，*部署*。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'In the ViewDidLoad method of the controller class, replace `this.imagePicker.SourceType
    = UIImagePickerControllerSourceType.PhotoLibrary;` with the following code block:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器类的 `ViewDidLoad` 方法中，将 `this.imagePicker.SourceType = UIImagePickerControllerSourceType.PhotoLibrary;`
    替换为以下代码块：
- en: '[PRE6]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the `FinishedPickingMedia` handler, add the following code before the dismissal
    of the image picker:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FinishedPickingMedia` 处理程序中，在关闭图像选择器之前添加以下代码：
- en: '[PRE7]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and run the app on the device. Tap the button to open the camera and
    take a picture. The picture will be saved to the device album.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用。点击按钮打开相机并拍照。照片将被保存到设备相册中。
- en: How it works...
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Before presenting the camera viewfinder, we have to make sure that the device
    that the app is running on actually has the appropriate hardware. We do this by
    calling the static `IsSourceTypeAvailable` method of the `UIImagePickerController`
    class as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示相机取景器之前，我们必须确保应用运行在具有适当硬件的设备上。我们通过调用 `UIImagePickerController` 类的静态 `IsSourceTypeAvailable`
    方法来完成此操作，如下所示：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If this returns `true`, we set the source type to `Camera` by using the following
    code:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果此返回 `true`，我们使用以下代码将源类型设置为 `Camera`：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will cause the image picker controller to start the camera device instead
    of loading the device albums.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致图像选择器控制器启动相机设备而不是加载设备相册。
- en: 'When the user takes a photo (or video) through our application, it is not automatically
    saved on the device. To save it, we use the `SaveToPhotosAlbum` method of the
    `UIImage` class. This method accepts a delegate of the `UIImage.SaveStatus` type,
    which will report an error if something goes wrong:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户通过我们的应用程序拍照（或录像）时，它不会自动保存在设备上。要保存它，我们使用 `UIImage` 类的 `SaveToPhotosAlbum`
    方法。此方法接受 `UIImage.SaveStatus` 类型的委托，如果发生错误将报告错误：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There's more...
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The camera view can also be customized. To disable the default camera controls,
    set the `ShowsCameraControls` property to `false`. Then, pass a custom view with
    the controls you want to the `CameraOverlayView` property. To trigger the shutter
    of the camera, call the `TakePicture` method.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 相机视图也可以进行自定义。要禁用默认的相机控件，将 `ShowsCameraControls` 属性设置为 `false`。然后，将您想要的控件的自定义视图传递给
    `CameraOverlayView` 属性。要触发相机的快门，请调用 `TakePicture` 方法。
- en: Image editing
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像编辑
- en: 'The camera supports a simple editing function after capturing an image. This
    editing function allows the user to select a specific part of the image and even
    zoom to a specific area. To present the editing controls, set the `AllowsEditing`
    property to `true`. The edited image can be retrieved from the dictionary in the
    `FinishedPickingMedia` handler, passing the `UIImagePickerController.EditedImage`
    key. The editing interface is shown in the following screenshot:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在捕获图像后，相机支持简单的编辑功能。此编辑功能允许用户选择图像的特定部分，甚至可以放大到特定区域。要显示编辑控件，将 `AllowsEditing`
    属性设置为 `true`。编辑后的图像可以从 `FinishedPickingMedia` 处理器中的字典中检索，传递 `UIImagePickerController.EditedImage`
    键。编辑界面如下截图所示：
- en: '![Image editing](img/8924OT_07_02.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图像编辑](img/8924OT_07_02.jpg)'
- en: See also
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Selecting images and videos* recipe
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择图像和视频* 菜谱'
- en: Playing videos
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放视频
- en: In this recipe, we will learn how to display a video player interface and play
    video files.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何显示视频播放器界面并播放视频文件。
- en: Getting ready
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `PlayVideoApp`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **Single View Application**，并将其命名为 `PlayVideoApp`。
- en: How to do it...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button to the main view of the controller.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的主视图中添加一个按钮。
- en: Add a video file to the project and set its **Build Action** to **Content**.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视频文件添加到项目中，并将其 **Build Action** 设置为 **Content**。
- en: 'Add the following code to the `ViewDidLoad` method of the controller class:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到控制器类中的 `ViewDidLoad` 方法：
- en: '[PRE11]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter the following methods in the `MainController` class:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类中输入以下方法：
- en: '[PRE12]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run the app on the simulator. Tap on the button and the video will
    load and start playing. Watch the messages displayed in the **Application Output**
    pad in Xamarin Studio. The following screenshot shows us the video that is playing
    on the simulator:![How to do it...](img/8924OT_07_03.jpg)
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。点击按钮，视频将加载并开始播放。在 Xamarin Studio 的 **Application Output** 面板中查看显示的消息。以下截图显示了在模拟器上播放的视频：![如何操作...](img/8924OT_07_03.jpg)
- en: How it works...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `MPMoviePlayerController` controller plays video files stored locally or
    streamed from the network. We initialize the controller with the constructor that
    accepts an `NSUrl` parameter, as shown in the following code:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMoviePlayerController` 控制器播放存储在本地的或从网络流式传输的视频文件。我们使用接受 `NSUrl` 参数的构造函数初始化控制器，如下面的代码所示：'
- en: '[PRE13]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `NSUrl` class is the standard iOS class for URLs.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSUrl` 类是标准的 iOS URL 类。'
- en: 'After creating the instance, we define a frame for its view and add it to our
    view by using the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建实例后，我们使用以下代码为其视图定义一个框架并将其添加到我们的视图中：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The highlighted code in the preceding section adds observers to the default
    notification center so that we will be notified when the state of the playback
    changes or finishes. Then, we call its `Play` method and the `MPMoviePlayerController`
    controller's view is displayed, and the video starts playing.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中突出显示的代码向默认通知中心添加了观察者，以便在播放状态改变或结束时通知我们。然后，我们调用它的 `Play` 方法，并显示 `MPMoviePlayerController`
    控制器的视图，视频开始播放。
- en: 'Inside the `MoviePlayer_PlaybackStateChanged` method, we output the `PlaybackState`
    property by using the following code:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MoviePlayer_PlaybackStateChanged` 方法中，我们使用以下代码输出 `PlaybackState` 属性：
- en: '[PRE15]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This property informs us about the status of the playback, for example, `Paused`,
    `Playing`, `SeekingForward`, and `SeekingBackward`.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性告诉我们播放状态，例如，`Paused`、`Playing`、`SeekingForward` 和 `SeekingBackward`。
- en: There's more...
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Apart from the ones used in this example, we can add observers for more notifications
    of an `MPMoviePlayerController` controller, some of which are as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 除了本例中使用的那些之外，我们还可以为 `MPMoviePlayerController` 控制器的更多通知添加观察者，其中一些如下：
- en: '`DidEnterFullscreenNotification`: This notifies us that the user has tapped
    the fullscreen control and the controller has entered the fullscreen mode'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidEnterFullscreenNotification`：它通知我们用户已点击全屏控制，控制器已进入全屏模式'
- en: '`DidExitFullscreenNotification`: It notifies that the controller has left fullscreen
    mode'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DidExitFullscreenNotification`：它通知控制器已离开全屏模式'
- en: '`DurationAvailableNotification`: This notifies us that the controller has received
    information on the duration of the video'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DurationAvailableNotification`：这通知我们控制器已收到关于视频持续时间的详细信息'
- en: '`LoadStateDidChangeNotification`: This is useful for network playback; it is
    triggered when the controller has finished preloading the media in the buffer'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LoadStateDidChangeNotification`：这在网络播放中很有用；当控制器完成缓冲区中媒体的预加载时，它会触发。'
- en: '`NaturalSizeAvailableNotification`: This is triggered when the dimensions of
    the movie frame are made available. The size can be retrieved through the player''s
    `NaturalSize` property'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NaturalSizeAvailableNotification`：当电影框架的尺寸可用时，它会触发。大小可以通过播放器的 `NaturalSize`
    属性检索'
- en: '`NowPlayingMovieDidChangeNotification`: This is triggered when the video content
    of the player has changed. The current content is available through its `ContentUrl`
    property'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NowPlayingMovieDidChangeNotification`：当播放器的视频内容发生变化时，它会触发。当前内容可以通过其 `ContentUrl`
    属性获取'
- en: Wireless streaming
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无线流媒体
- en: Starting from iOS Version 4.3, `MPMoviePlayerController` can be used to stream
    video to Apple's AirPlay-enabled devices. To enable wireless streaming, set the
    `MPMoviePlayerController` instance's `AllowsAirPlay` property to `true`. When
    `controller` is displayed, it will present an interface that will allow the user
    to select the devices it detects.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 从 iOS 版本 4.3 开始，`MPMoviePlayerController` 可以用于将视频流式传输到 Apple 的 AirPlay 兼容设备。要启用无线流媒体，将
    `MPMoviePlayerController` 实例的 `AllowsAirPlay` 属性设置为 `true`。当 `controller` 显示时，它将提供一个界面，允许用户选择它检测到的设备。
- en: See also
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Playing music and sounds* recipe
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放音乐和声音* 菜单'
- en: Playing music and sounds
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 播放音乐和声音
- en: In this recipe, we will learn how to play both simple audio files and songs
    stored on the device.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何播放简单的音频文件和存储在设备上的歌曲。
- en: Getting ready
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a new **Single View Application** in Xamarin Studio and name it `PlayMusicApp`.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序** 并将其命名为 `PlayMusicApp`。
- en: Note
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example will not work on the simulator. You will also need at least one
    song stored on the device's iTunes library.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在模拟器上无法工作。您还需要在设备上的 iTunes 库中至少存储一首歌曲。
- en: How to do it...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add three buttons to the view of the controller.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向控制器的视图中添加三个按钮。
- en: 'Add the following `using` directive in the `PlayMusicAppViewController.cs`
    file:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PlayMusicAppViewController.cs` 文件中添加以下 `using` 指令：
- en: '[PRE16]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following two fields in the class:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下两个字段：
- en: '[PRE17]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE18]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Add the following methods in the class:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE19]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile and run the app on the device. Tap the **Select songs** button and select
    one or more songs.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击 **选择歌曲** 按钮并选择一首或多首歌曲。
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MPMediaPickerController` controller provides the same user interface as
    the native *Music* app for selecting songs. The `MPMusicPlayerController` controller
    is responsible for playing the songs stored on the device.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMediaPickerController`控制器提供了与原生*音乐*应用相同的用户界面，用于选择歌曲。`MPMusicPlayerController`控制器负责播放设备上存储的歌曲。'
- en: 'We first initialize the media picker, passing the type of media we want it
    to look for in its constructor by using the following code:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先初始化媒体选择器，通过在构造函数中使用以下代码通过其构造函数传递我们想要它查找的媒体类型：
- en: '[PRE20]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'After this, we subscribe to its `ItemsPicked` and `DidCancel` events so that
    we can capture the feedback from the user by using the following code:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们订阅其`ItemsPicked`和`DidCancel`事件，以便我们可以通过以下代码捕获用户的反馈：
- en: '[PRE21]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The highlighted code in the preceding section shows us how to initialize the
    music player object. The option demonstrated here, `MPMusicPlayerController.ApplicationMusicPlayer`,
    creates an instance that is specific only to the app. The other option that is
    available, `MPMusicPlayerController.iPodMusicPlayer`, creates an instance that
    allows the media to be played even if the app is in the background, similar to
    the native *Music* app.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 上一节中突出显示的代码显示了如何初始化音乐播放器对象。这里演示的选项`MPMusicPlayerController.ApplicationMusicPlayer`创建了一个仅适用于应用的实例。另一个可用的选项`MPMusicPlayerController.iPodMusicPlayer`创建了一个实例，允许在应用处于后台时播放媒体，类似于原生的*音乐*应用。
- en: 'In the `MediaPicker_ItemsPicked` handler, we set the songs that were picked
    by the user to the music player through its `SetQueue` method, as shown in the
    following code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MediaPicker_ItemsPicked`处理程序中，我们通过其`SetQueue`方法将用户选择的歌曲设置到音乐播放器中，如下所示：
- en: '[PRE22]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: After this, we dismiss the modal media picker controller. Playing and stopping
    songs is achieved through the `Play()` and `Stop()` methods of `MPMusicPlayerController`,
    respectively.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们关闭模态媒体选择器控制器。播放和停止歌曲分别通过`MPMusicPlayerController`的`Play()`和`Stop()`方法实现。
- en: There's more...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: '`MPMusicPlayerController` holds information on the item that is being played
    currently. This information can be accessed through its `NowPlayingItem` property.
    It is of the `MPMediaItem` type and holds various types of information of the
    media that is being played currently. The following example outputs the title
    of the song that is being played:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMusicPlayerController`包含正在播放的项目信息。这些信息可以通过其`NowPlayingItem`属性访问。它属于`MPMediaItem`类型，并包含正在播放的媒体的各种类型信息。以下示例输出正在播放的歌曲的标题：'
- en: '[PRE23]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Playing sound files
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 播放声音文件
- en: The `MPMusicPlayerController` controller is an object that is specifically designed
    to manage and play items and playlists stored on the device's music library.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`MPMusicPlayerController`控制器是一个专门设计来管理和播放设备音乐库中存储的项目和播放列表的对象。'
- en: 'To play simple sound files, Xamarin.iOS provides another wrapper to the iOS''s
    class, `AVAudioPlayer`. The following code is an example of its most simple usage:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 要播放简单的声音文件，Xamarin.iOS提供了对iOS的`AVAudioPlayer`类的另一个包装器。以下代码是其最简单使用的示例：
- en: '[PRE24]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Playing videos* recipe
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放视频*菜谱'
- en: Recording with the microphone
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用麦克风录制
- en: In this recipe, we will learn how to use the device's microphone to record sounds.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将学习如何使用设备的麦克风来录制声音。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Xamarin Studio and name it `RecordSoundApp`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的项目，并将其命名为`RecordSoundApp`。
- en: Note
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example will not work on the simulator.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在模拟器上无法工作。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add two buttons and a label to the view of the controller.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个按钮和一个标签添加到控制器的视图中。
- en: 'Enter the following `using` directives in the `RecordSoundAppViewController.cs`
    file:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecordSoundAppViewController.cs`文件中输入以下`using`指令：
- en: '[PRE25]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Override the `ViewDidLoad` method and add the following code to it:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重写`ViewDidLoad`方法并向其中添加以下代码：
- en: '[PRE26]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Compile and run the app on the device. Tap the **Start** recording button to
    start recording the audio, for example, say something in order to record your
    voice. Tap the **Stop** **recording** button to stop recording and listen to the
    playback.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击**开始**录音按钮开始录音，例如，说出一些话以录制你的声音。点击**停止****录音**按钮停止录音并播放。
- en: How it works...
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The `AVAudioRecorder` class provides the recording functionality. It does this
    by streaming the captured audio directly to the filesystem. Prior to starting
    the actual recording, we need to prepare the shared audio session by using the
    following code:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVAudioRecorder`类提供了录音功能。它是通过将捕获的音频直接流式传输到文件系统来实现的。在开始实际录音之前，我们需要使用以下代码准备共享音频会话：'
- en: '[PRE27]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We need to adjust the audio session according to our app's needs so that the
    system *knows* how to handle the audio from other sources. By setting the category
    to `AVAudioSession.CategoryPlayAndRecord`, we state that our app will be able
    to play back the audio while it is getting recorded.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要根据应用程序的需求调整音频会话，以便系统知道如何处理来自其他源的声音。通过将类别设置为`AVAudioSession.CategoryPlayAndRecord`，我们声明我们的应用程序在录音的同时能够播放音频。
- en: 'The first time we set the shared audio session''s category to any value that
    requires the usage of the microphone, iOS automatically prompts the user to give
    permission to the app. By calling the `RequestRecordPermission` method, we can
    determine whether the user has granted microphone access to our app, as shown
    in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次将共享音频会话的类别设置为任何需要使用麦克风的值时，iOS会自动提示用户允许应用程序使用麦克风。通过调用`RequestRecordPermission`方法，我们可以确定用户是否已经允许我们的应用程序访问麦克风，如下面的代码所示：
- en: '[PRE28]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now that we have prepared the shared audio session, it''s time to initialize
    an instance of `AVAudioRecorder` by using the following code:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了共享音频会话，是时候通过以下代码初始化一个`AVAudioRecorder`实例了：
- en: '[PRE29]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: If the file that corresponds to the `NSUrl` variable already exists, it will
    be overwritten.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果与`NSUrl`变量对应的文件已经存在，它将被覆盖。
- en: 'The `recordingSettings` variable is of the `NSDictionary` type and contains
    the settings for the output sound file. We must provide at least some minimal
    settings to the `AVAudioRecorder` upon the initialization. Here, we set the sound
    format to plain WAV by using the following code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`recordingSettings`变量是`NSDictionary`类型，包含输出声音文件的设置。在初始化`AVAudioRecorder`时，我们必须提供至少一些最小设置。在这里，我们通过以下代码将声音格式设置为纯WAV：'
- en: '[PRE30]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'To instruct the recorder to start recording, we just call its `Record()` method
    by using the following line of code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要指示录音器开始录音，我们只需通过以下代码行调用其`Record()`方法：
- en: '[PRE31]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'When the user taps on the **Stop recording** button, the recording stops and
    the saved sound starts playing with the `AVAudioPlayer`:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**停止录音**按钮时，录音停止，并使用`AVAudioPlayer`播放保存的声音：
- en: '[PRE32]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: There's more...
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The `AVAudioRecorder` class provides sound metering options as well. To enable
    the sound metering, set its `MeteringEnabled` property to `true`. We can then
    output the peak power in decibels on a specific channel. To do this for the first
    channel of our recording, add the following code right after the `Record()` method
    call:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`AVAudioRecorder`类还提供了声音计权选项。要启用声音计权，将它的`MeteringEnabled`属性设置为`true`。然后我们可以输出特定通道的峰值功率（分贝）。为了对录音的第一个通道执行此操作，在`Record()`方法调用后立即添加以下代码：'
- en: '[PRE33]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `PeakPower` method accepts the zero-based index of the channel and returns
    the peak of the channel in decibels. Call `UpdateMeters()` right before calling
    the `PeakPower` method to get the most recent reading.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '`PeakPower`方法接受通道的零基索引并返回该通道的峰值（分贝）。在调用`PeakPower`方法之前调用`UpdateMeters()`以获取最新的读数。'
- en: Note that enabling the metering on the recorder requires using the CPU resources.
    Do not enable it if you do not intend on using the metering values.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在录音器上启用计权需要使用CPU资源。如果你不打算使用计权值，请不要启用它。
- en: Recording for a predefined amount of time
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 记录预定义的时间长度
- en: To record the audio for a predefined amount of time without the need for the
    user to stop the recording, call the `RecordFor(double)` method. Its parameter
    is the amount of time in seconds for which we want to record.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要记录预定义时间长度的音频，而无需用户停止录音，请调用`RecordFor(double)`方法。它的参数是我们想要记录的秒数。
- en: See also
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Playing music and sounds* recipe
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*播放音乐和声音*食谱'
- en: Managing album items directly
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 直接管理专辑项目
- en: In this recipe, we will discuss how to programmatically access the device's
    photo album.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何通过编程方式访问设备的照片库。
- en: Getting ready
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `ManageAlbumApp`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`ManageAlbumApp`。
- en: Note
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: This example works on the simulator. At least one image must exist in the simulator's
    photo album.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例在模拟器上工作。模拟器的照片库中必须至少存在一个图像。
- en: How to do it...
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add a button on the main view of the controller.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器的主视图中添加一个按钮。
- en: 'Enter the following `using` directive in the `MainController.cs` file:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController.cs` 文件中输入以下 `using` 指令：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Add the following methods in the class:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中添加以下方法：
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Compile and run the app. Tap the **Enumerate** button and watch the URLs of
    the saved photos get displayed in the **Application Output** pad.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用。点击 **Enumerate** 按钮，观察保存照片的 URL 在 **Application Output** 面板中显示。
- en: How it works...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ALAssetsLibrary` class provides access to the album items of the device.
    These items are represented by the `ALAsset` class and are divided into groups,
    represented by the `ALAssetGroup` class.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALAssetsLibrary` 类提供了对设备相册项的访问。这些项由 `ALAsset` 类表示，并按组划分，由 `ALAssetGroup` 类表示。'
- en: 'The first thing we need to do is enumerate the asset groups. To do this, call
    the `Enumerate` method by using the following code:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是枚举资产组。为此，使用以下代码调用 `Enumerate` 方法：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The first parameter is of the `ALAssetGroupTypes` type, and it instructs the
    assets library on the asset groups to be enumerated. Passing `ALAssetGroupTypes.All`
    means that we want to enumerate all the asset groups. The other two parameters
    are delegate types. The `GroupsEnumeration` method is where we read the group's
    data, while the `GroupsEnumerationFailure` method will be triggered if an error
    occurs. When the `Enumerate` method is called for the first time, the user is
    asked to grant access to the app to access the device's assets. If the user denies
    the access, the failure method will be triggered. The next time the `Enumerate`
    method gets called, the access message appears again.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是 `ALAssetGroupTypes` 类型，它指示要枚举的资产组。传递 `ALAssetGroupTypes.All` 表示我们想要枚举所有资产组。其他两个参数是委托类型。`GroupsEnumeration`
    方法是我们读取组数据的地方，而 `GroupsEnumerationFailure` 方法将在发生错误时被触发。当第一次调用 `Enumerate` 方法时，用户会被要求授权应用访问设备的资产。如果用户拒绝访问，将触发失败方法。下次调用
    `Enumerate` 方法时，访问消息将再次出现。
- en: 'The signature of the `GroupsEnumeration` method is as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`GroupsEnumeration` 方法的签名如下：'
- en: '[PRE38]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `assetGroup` parameter contains the group's information.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '`assetGroup` 参数包含组的信息。'
- en: 'Note the `stop` parameter, which is declared as a `ref` parameter. When the
    enumeration occurs, the method is being triggered once to return the first group
    and does not get called for the second time, no matter how many more groups exist.
    To force it to keep getting called to enumerate all the groups, we have to set
    the `stop` variable to `false`. When all groups have been enumerated, the method
    gets called one last time, with the `assetGroup` variable set to `null`. So we
    need to check this. To put all this in code, take a look at the following example:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `stop` 参数，它被声明为一个 `ref` 参数。当枚举发生时，该方法被触发一次以返回第一个组，并且无论存在多少更多组，都不会再次被调用。为了强制它继续被调用以枚举所有组，我们必须将
    `stop` 变量设置为 `false`。当所有组都已枚举后，该方法最后一次被调用，此时 `assetGroup` 变量设置为 `null`。因此，我们需要检查这一点。要将所有这些放入代码中，请查看以下示例：
- en: '[PRE39]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'After calling the `SetAssetsFilter` method on the instance of the `ALAssetGroup`
    class, we instruct it to filter what types of assets we want it to look for. After
    this, the process becomes similar to the group''s enumeration. The `ALAssetGroup`
    class also contains an `Enumerate` method. It accepts a parameter of a delegate
    type, represented here by the `AssetsEnumeration` method. Its implementation is
    similar to the `GroupsEnumeration` method, as shown in the following code:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在对 `ALAssetGroup` 类的实例调用 `SetAssetsFilter` 方法之后，我们指示它过滤我们希望它查找的资产类型。之后，这个过程与组枚举类似。`ALAssetGroup`
    类还包含一个 `Enumerate` 方法。它接受一个委托类型参数，在此处由 `AssetsEnumeration` 方法表示。其实现与 `GroupsEnumeration`
    方法类似，如下所示：
- en: '[PRE40]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The `ALAsset` class contains various kinds of information and properties. Most
    of the information is stored in its `DefaultRepresentation` property, which is
    of the `ALAssetRepresentation` type.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ALAsset` 类包含各种信息和属性。大部分信息存储在其 `DefaultRepresentation` 属性中，该属性为 `ALAssetRepresentation`
    类型。'
- en: There's more...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'If the asset we are interested in is an image, we can get the actual image
    through the `DefaultRepresentation` property by using the following code:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们感兴趣的资产是一张图片，我们可以通过以下代码通过 `DefaultRepresentation` 属性获取实际图片：
- en: '[PRE41]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Reading EXIF data
  id: totrans-221
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取 EXIF 数据
- en: 'We can read a photo''s **EXchangeable Image File** (**EXIF**) format metadata
    through the `Metadata` property of `ALAssetRepresentation`, which is of the `NSDictionary`
    type, as shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ALAssetRepresentation` 的 `Metadata` 属性读取照片的 **可交换图像文件** （**EXIF**）格式元数据，该属性是
    `NSDictionary` 类型，如下面的代码所示：
- en: '[PRE42]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Retrieving individual assets
  id: totrans-224
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 获取单个资源
- en: We can also retrieve an individual asset, if we know the asset's URL, through
    the `AssetForUrl` method of `ALAssetLibrary`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道资源的 URL，我们也可以通过 `ALAssetLibrary` 的 `AssetForUrl` 方法检索单个资源。
- en: Checking for permission
  id: totrans-226
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查权限
- en: 'We can check whether the user has granted access to the asset library through
    the `ALAssetsLibrary.AuthorizationStatus` static property. The possible values
    of the `ALAuthorizationStatus` enumeration are the following:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `ALAssetsLibrary.AuthorizationStatus` 静态属性检查用户是否已授予对资源库的访问权限。`ALAuthorizationStatus`
    枚举的可能值如下：
- en: '`Authorized`: This means that the user has authorized our app.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Authorized`：这意味着用户已授权我们的应用程序。'
- en: '`Denied`: This means that the user has denied access to the albums.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Denied`：这意味着用户已拒绝访问相册。'
- en: '`NotDetermined`: This means that our app never requested access to the albums.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotDetermined`：这意味着我们的应用程序从未请求访问相册。'
- en: '`Restricted`: This means that the app is not authorized to access the albums
    and the user cannot grant access, possibly due to parental restrictions.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Restricted`：这意味着应用程序未经授权访问相册，并且用户无法授予访问权限，可能由于家长控制限制。'
- en: Note that accessing the `AuthorizationStatus` property does not prompt the user
    for permission. When we actually try to access the library in this example, by
    calling the `Enumerate` method, is when iOS prompts the user for permission.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，访问 `AuthorizationStatus` 属性不会提示用户请求权限。当我们实际上尝试通过调用 `Enumerate` 方法访问库时，iOS
    才会提示用户请求权限。
- en: See also
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Selecting images and videos* recipe
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*选择图片和视频* 菜单'
