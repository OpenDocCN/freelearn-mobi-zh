- en: Chapter 3. Testing and Identifying Slow Code with the Swift Toolkit
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 使用 Swift Toolkit 测试和识别慢速代码
- en: 'The process of application development can usually be split into three phases:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序开发的过程通常可以分为三个阶段：
- en: Trying out new ideas
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试新想法
- en: Implementing code and checking whether it works correctly
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现代码并检查其是否正确工作
- en: Measuring the performance of the result obtained
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测量获得的结果的性能
- en: The first phase involves trying out a new idea. Let's say you would like to
    implement a sorting algorithm and you want to quickly prototype a solution.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 第一阶段涉及尝试一个新想法。比如说，你想要实现一个排序算法，并且希望快速地原型化一个解决方案。
- en: In the second phase, you would actually implement the solution and check whether
    it is working correctly. In this chapter, we will cover how we can test and check
    whether a solution is implemented correctly.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段，你将实际实现解决方案并检查它是否正确工作。在本章中，我们将介绍如何测试和检查解决方案是否正确实现。
- en: The third and final phase involves measuring the performance of the software
    created. You would do this when you have developed enough code to test, or if
    you see bad performance characteristics while developing.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段和最终阶段涉及测量创建的软件的性能。当你已经编写了足够多的代码以进行测试，或者在你开发过程中看到不良的性能特征时，你会这样做。
- en: REPL
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL
- en: '**REPL** stands for **read-eval-print-loop**. Swift REPL is an interactive
    Swift code interpreter that executes code immediately. To launch Swift REPL, open
    Terminal. app and execute this command:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**REPL** 代表 **read-eval-print-loop**。Swift REPL 是一个交互式的 Swift 代码解释器，它立即执行代码。要启动
    Swift REPL，打开 Terminal 应用程序并执行以下命令：'
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, you can start typing Swift code and see the result. A nice thing about
    evaluating code in REPL is that if you make an error that would eventually stop
    the application execution if you compile and run it, you can still continue evaluating
    the code and preserve all of the progress. Let''s play around and try this code
    in Swift REPL:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以开始输入 Swift 代码并查看结果。在 REPL 中评估代码的一个好处是，如果你犯了一个错误，这个错误如果编译并运行程序最终会停止应用程序的执行，你仍然可以继续评估代码并保留所有进度。让我们在
    Swift REPL 中尝试这段代码：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![REPL](img/00006.jpeg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![REPL](img/00006.jpeg)'
- en: Writing code in the REPL console is not as convenient as in the modern Xcode
    IDE, but being familiar with it is a useful skill. On top of the Swift REPL, Apple
    has built more powerful tools, such as Playgrounds, which has a nice source code
    editor and flexibility of Swift REPL.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 REPL 控制台中编写代码不如在现代 Xcode IDE 中方便，但熟悉它是一项有用的技能。在 Swift REPL 的基础上，Apple 开发了更强大的工具，例如
    Playgrounds，它拥有一个不错的源代码编辑器和 Swift REPL 的灵活性。
- en: Playgrounds
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Playgrounds
- en: Playgrounds is a powerful tool for trying out code and getting the result. As
    its name suggests, it's a place to play. In a playground, Swift code is evaluated
    immediately, which is the same as in REPL. You can create a new playground by
    going to **File** | **New** | **Playground**. Enter the file name and create it.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds 是一个强大的尝试代码并获取结果的工具。正如其名所示，它是一个玩耍的地方。在 Playgrounds 中，Swift 代码会立即被评估，这与
    REPL 中的情况相同。你可以通过访问 **文件** | **新建** | **Playground** 来创建一个新的 Playgrounds。输入文件名并创建它。
- en: 'A playground consists of two parts, which are shown in the next screenshot:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds 由两部分组成，下一张截图将展示：
- en: Editor
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑器
- en: Result
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 结果
- en: '![Playgrounds](img/00007.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![Playgrounds](img/00007.jpeg)'
- en: 'Almost all the code examples shown in this book were created in playgrounds.
    As an example, let''s create an array and play with it. We can apply filter and
    map functions and print the count of objects in an array:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本书展示的大多数代码示例都是在 Playgrounds 中创建的。例如，让我们创建一个数组并与之互动。我们可以应用过滤和映射函数，并打印数组中对象的数量：
- en: '![Playgrounds](img/00008.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![Playgrounds](img/00008.jpeg)'
- en: 'You will see the result of the evaluated code appearing as you type. If you
    move the cursor to the one of the lines in the result section, it will become
    highlighted and two buttons will appear:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你会看到评估后的代码结果随着你的输入而出现。如果你将光标移到结果部分的一行，它将被突出显示，并出现两个按钮：
- en: '**Quick Look**'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**快速查看**'
- en: '**Show / Hide result**'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显示/隐藏结果**'
- en: '**Quick Look** will display more details about the executed operation. This
    functionality is particularly interesting for functions. As an example, if you
    click on the `filter` function, you can see the result of every iteration; the
    results are `true` or `false` values. If you show the details of a function that
    has a numerical result, a `map` function, for example, it can show a nice graph.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**快速查看**将显示关于执行操作的更多详细信息。此功能对于函数尤其有趣。例如，如果您点击 `filter` 函数，您可以看到每次迭代的每个结果；结果是
    `true` 或 `false` 值。如果您显示具有数值结果的函数的详细信息，例如 `map` 函数，它可以显示一个漂亮的图表。'
- en: '**Show / Hide Result** allows you to add a **Quick Look** result directly to
    the playground editor. It will always be visible and refresh the data unless you
    hide it.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**显示/隐藏结果**允许您将**快速查看**结果直接添加到操场编辑器中。除非您将其隐藏，否则它将始终可见并刷新数据。'
- en: 'Showing the Result View of a function with a numerical return type is very
    useful when you are working with the math functions and you want to see the results
    in a visual representation. As an example, let''s show the result of the `sin`
    and `pow` functions, as you can see in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用数学函数并希望以视觉表示形式查看结果时，显示具有数值返回类型的函数的结果视图非常有用。例如，让我们显示 `sin` 和 `pow` 函数的结果，如以下截图所示：
- en: '![Playgrounds](img/00009.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![操场](img/00009.jpeg)'
- en: 'The other useful use case is for displaying the result of an algorithm. We
    will create a selection sort algorithm. It is often very useful to see the result
    of the algorithm at every step. You can easily inspect it in a playground:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的用例是用于显示算法的结果。我们将创建一个选择排序算法。在每一步看到算法的结果通常非常有用。您可以在操场中轻松检查它：
- en: '![Playgrounds](img/00010.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![操场](img/00010.jpeg)'
- en: Interactive documentation
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互式文档
- en: The other use case for playgrounds is in making interactive documentation. You
    can add markup-formatted text to the playgrounds. In this way, you can combine
    interactive code examples that run in the playground with rich-formatted text
    descriptions.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 操场的另一个用例是在制作交互式文档。您可以将标记格式化的文本添加到操场中。这样，您可以将操场中运行的交互式代码示例与丰富的文本描述相结合。
- en: 'The markup syntax is based on the well-known Markdown syntax:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 标记语法基于众所周知的 Markdown 语法：
- en: '**Heading**: `# Heading`'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标题**: `# 标题`'
- en: '**Strong**: `**Bold Text**` or `__Bold Text__`'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**粗体**: `**粗体文本**` 或 `__粗体文本__`'
- en: '**Inline code**: `` `Int` ``'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内联代码**: `` `Int` ``'
- en: The complete Markdown documentation can be found at [http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的 Markdown 文档可以在[http://daringfireball.net/projects/markdown/syntax](http://daringfireball.net/projects/markdown/syntax)找到。
- en: 'There are two markup text styles in Playgrounds:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 操场中有两种标记文本样式：
- en: '**One line**: One line markup text style is as follows:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单行**: 单行标记文本样式如下：'
- en: '[PRE2]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '**Multiline**: The multiline markup text style is as follows:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**多行**: 多行标记文本样式如下：'
- en: '[PRE3]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s now add some markup text to playgrounds:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们向操场添加一些标记文本：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The markup text can be presented in a playground in two modes, raw and rendered:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 标记文本可以在操场中以两种模式呈现，原始模式和渲染模式：
- en: '![Interactive documentation](img/00011.jpeg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![交互式文档](img/00011.jpeg)'
- en: 'To switch between raw mode and rendered mode, go to **Editor** | **Show Rendered
    Markup / Show Raw Markup**. You can also switch between these modes by enabling
    the **Render Documentation** checkbox in the **Playground Settings** section in
    the **Utility** panel, as shown here:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要在原始模式和渲染模式之间切换，请转到**编辑器** | **显示渲染标记/显示原始标记**。您也可以通过在**实用工具**面板中的**操场设置**部分启用**渲染文档**复选框来在这些模式之间切换，如图所示：
- en: '![Interactive documentation](img/00012.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![交互式文档](img/00012.jpeg)'
- en: The full documentation of the Playgrounds markup format can be found at [https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Playgrounds 标记格式的完整文档可以在[https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref](https://developer.apple.com/library/ios/documentation/Xcode/Reference/xcode_markup_formatting_ref)找到。
- en: The folder structure
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: The playground file is actually not a simple file but a package that contains
    multiple files. You can explore its full contents by opening it in **Finder**.
    Right-click on **Show Package Contents**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 操场文件实际上不是一个简单的文件，而是一个包含多个文件的包。您可以通过在**Finder**中打开它来探索其全部内容。右键点击**显示包内容**。
- en: 'In Xcode, you can expand a playground file in **Project Navigator**. It contains
    three items:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xcode 中，你可以在 **项目导航器** 中展开 playground 文件。它包含三个项目：
- en: '**Source**: A folder for additional Swift source files for the Playground'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**源**：用于 playground 的额外 Swift 源文件文件夹'
- en: '**Resources**: A folder for additional resources for Playground such as images,
    text files, and other things'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**资源**：用于 playground 的额外资源文件夹，例如图像、文本文件和其他内容'
- en: '**Pages**: A collection of playground files of a parent playground'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面**：父 playground 的 playground 文件集合'
- en: The source folder
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 源文件夹
- en: By splitting a playground's source code into several Swift source code files,
    you can make the playground cleaner and faster. Every time you make a change in
    the playground, it will rerun the entire code in that playground. The more code
    you put into the playground, the slower it gets. The Swift source files in the
    `source` folder don't rerun every time you make a change in the playground file;
    they rerun only when you make a change to the content of that file. As an example,
    when we were playing with `Person`, it's the perfect use case for adding a `Person`
    type to a separate Swift source file in the `source` folder.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将 playground 的源代码拆分为多个 Swift 源代码文件，你可以使 playground 更干净、更快。每次你在 playground
    中进行更改时，它都会重新运行该 playground 中的所有代码。你放入 playground 的代码越多，它就越慢。`source` 文件夹中的 Swift
    源文件不会在每次更改 playground 文件时重新运行；它们仅在更改该文件的内容时重新运行。例如，当我们与 `Person` 玩耍时，将 `Person`
    类型添加到 `source` 文件夹中的单独 Swift 源文件是完美的用例。
- en: Tip
  id: totrans-59
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The Swift files in the source folder are compiled into the framework. In the
    framework, you have to mark your types and functions with a `public` keyword to
    make them visible outside the framework, in our case in the playground.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`source` 文件夹中的 Swift 文件被编译到框架中。在框架中，你必须使用 `public` 关键字标记你的类型和函数，以便它们在框架外部可见，在我们的例子中是在
    playground 中。'
- en: Resources
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 资源
- en: 'By including assets in the `Resources` folder, you can reference them in the
    playground. The simplest example would be adding a `circle.png` image file:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在 `Resources` 文件夹中包含资产，你可以在 playground 中引用它们。最简单的例子是添加一个 `circle.png` 图像文件：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The files in the `Resources` folder are available via `NSBundle.mainBundle`.
    Let''s create the same circle, `UIImage`, but this time with the `NSBundle` API:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '`Resources` 文件夹中的文件可以通过 `NSBundle.mainBundle` 获取。让我们创建相同的圆，`UIImage`，但这次使用
    `NSBundle` API：'
- en: '[PRE6]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Pages
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 页面
- en: A playground file can contain many sub-playground files, called pages. A page
    is a fully functional playground file with its own sources and resources folders.
    A playground can contain many pages. To add a new page, go to **File** | **New**
    | **Playground Page**, or simply right-click on the playground file and select
    **New Playground Page**.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 playground 文件可以包含许多子 playground 文件，称为页面。一个页面是一个具有自己的源和资源文件夹的完整功能的 playground
    文件。一个 playground 可以包含许多页面。要添加新页面，请转到 **文件** | **新建** | **Playground 页面**，或者简单地右键单击
    playground 文件并选择 **新建 Playground 页面**。
- en: Playground pages are great for splitting content into separate parts, such as
    a page or section of a book.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Playground 页面非常适合将内容拆分为单独的部分，例如一本书的页面或章节。
- en: 'For easy navigation among the pages in a playground, there is a page navigation
    markup. You can jump to the first, last, next, previous, or any specific page.
    The page navigation markup consists of two parts: `[Visible text]` and `(page-link)`.
    Let''s see some examples of this markup:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 playground 中的页面之间轻松导航，有一个页面导航标记。你可以跳转到第一个、最后一个、下一个、上一个或任何特定的页面。页面导航标记由两部分组成：`[可见文本]`
    和 `(page-link)`。让我们看看这个标记的一些示例：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Many code examples in this book are created using playground pages.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的许多代码示例都是使用 playground 页面创建的。
- en: XCPlayground
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: XCPlayground
- en: '`XCPlayground` is a module specially created for working with playgrounds.
    It''s a very small module, with four main functions:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPlayground` 是一个专门为与 playground 一起工作而创建的模块。它是一个非常小的模块，有四个主要功能：'
- en: '`XCPCaptureValue`'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCPCaptureValue`'
- en: '`XCPShowView`'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCPShowView`'
- en: '`XCPSetExecutionShouldContinueIndefinitely`'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCPSetExecutionShouldContinueIndefinitely`'
- en: '`XCPSharedDataDirectoryPath`'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`XCPSharedDataDirectoryPath`'
- en: Let take a quick look at these functions. The results of all of these functions
    are shown in the Playground timeline. To see it, go to **View** | **Assistant
    Editor** | **Show Assistant Editor**, and select the timeline for the current
    playground.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们快速查看这些函数。所有这些函数的结果都显示在 Playground 时间轴上。要查看它，请转到 **视图** | **辅助编辑器** | **显示辅助编辑器**，然后选择当前
    playground 的时间轴。
- en: '`XCPCaptureValue` allows you to manually capture a value and display it in
    the timeline view. In this way, you can create your own graph results:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPCaptureValue` 允许你手动捕获一个值并在时间轴视图中显示它。这样，你可以创建自己的图形结果：'
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '`XCPShowView` displays a view in the playground timeline:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPShowView`在playground时间轴中显示一个视图：'
- en: '[PRE9]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`XCPSetExecutionShouldContinueIndefinitely` is very useful for asynchronous
    code execution in a playground. It tells playground to keep executing its run
    loop infinitely after the last instruction completes, and in this way, we can
    wait for asynchronous callbacks.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPSetExecutionShouldContinueIndefinitely`对于在playground中执行异步代码非常有用。它告诉playground在最后一条指令完成后无限期地继续执行其运行循环，这样我们就可以等待异步回调。'
- en: '`XCPSharedDataDirectoryPath` returns a path to the directory that is shared
    between all the playgrounds. In this way, you can save and share data between
    playgrounds and between each playground run.'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCPSharedDataDirectoryPath`返回一个指向所有playgrounds之间共享的目录的路径。这样，你可以在playgrounds之间以及每个playground运行之间保存和共享数据。'
- en: LLDB
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: LLDB
- en: LLDB is a high-performance command-line debugger. It is available in Xcode.
    The easiest way to start it is to set a breakpoint and run the application. In
    the Xcode debug area view, you will find a console in which you can execute LLDB
    commands. Because we made an iOS app, we will set a breakpoint in the AppDelegate's
    `didFinishLaunchingWithOptions` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB是一个高性能的命令行调试器。它在Xcode中可用。启动它的最简单方法是设置断点并运行应用程序。在Xcode的调试区域视图中，你会找到一个可以执行LLDB命令的控制台。因为我们制作了一个iOS应用程序，我们将在AppDelegate的`didFinishLaunchingWithOptions`方法中设置断点。
- en: 'To print the content of a variable, we can use the `p` LLDB command. Just run
    `p` with the variable name, for example, `p name`, as shown here:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印变量的内容，我们可以使用`p` LLDB命令。只需运行`p`并带上变量名，例如，`p name`，如下所示：
- en: '![LLDB](img/00013.jpeg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![LLDB](img/00013.jpeg)'
- en: LLDB is a very powerful debugger. You can read more about the LLDB debugger
    at [www.objc.io/issues/19-debugging/lldb-debugging/](http://www.objc.io/issues/19-debugging/lldb-debugging/)
    and [https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: LLDB是一个非常强大的调试器。你可以在[www.objc.io/issues/19-debugging/lldb-debugging/](http://www.objc.io/issues/19-debugging/lldb-debugging/)和[https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide](https://developer.apple.com/library/ios/documentation/IDEs/Conceptual/gdb_to_lldb_transition_guide)了解更多关于LLDB调试器的信息。
- en: REPL in Xcode
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Xcode中的REPL
- en: One of the more interesting functionalities available in the Xcode LLDB console
    is that you can run Swift REPL there. You can enter and execute Swift code when
    you stop the application execution in the debugger. This is very useful for debugging
    purposes.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode LLDB控制台提供的一些更有趣的功能之一是你可以在这里运行Swift REPL。当你停止应用程序执行时，你可以输入并执行Swift代码。这对于调试非常有用。
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: REPL can only access public types, functions, and public global variables. Local
    variables are not visible in REPL. If you need to work with local variables, use
    LLDB commands instead.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: REPL只能访问公共类型、函数和公共全局变量。局部变量在REPL中不可见。如果你需要与局部变量一起工作，请使用LLDB命令。
- en: 'To enter an REPL console, we first have to stop the program execution and enter
    the LLDB debugger. There are three commands for interacting with REPL:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入REPL控制台，我们首先必须停止程序执行并进入LLDB调试器。有三个命令用于与REPL交互：
- en: '**Enter REPL**: `repl`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**进入REPL**：`repl`'
- en: '**Exit REPL**: `:`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**退出REPL**：`:`'
- en: '**Execute the LLDB** **command in REPL**: `: command`, for example, `:p name`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**在REPL中执行LLDB命令**：`: command`，例如，`:p name`'
- en: 'We can execute the same function as before, but now use REPL commands in the
    debug console, as shown here:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以执行之前相同的功能，但现在使用调试控制台中的REPL命令，如下所示：
- en: '![REPL in Xcode](img/00014.jpeg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![Xcode中的REPL](img/00014.jpeg)'
- en: Now let's look at more interesting use cases of REPL. When you enter REPL, you
    can enter and execute Swift code. You also have access to publicly declared Swift
    code in your application in REPL. To summarize, you can run existing code and
    add new code as well.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一些更有趣的REPL使用案例。当你进入REPL时，你可以输入并执行Swift代码。你还可以在REPL中访问应用程序中公开声明的Swift代码。总结一下，你可以运行现有代码，也可以添加新代码。
- en: 'A great use case here is adding test code directly to REPL while debugging
    the application. As an example, let''s implement a function for skipping negative
    numbers in an array:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 一个很好的用例是在调试应用程序的同时直接将测试代码添加到REPL中。作为一个例子，让我们实现一个跳过数组中负数的函数：
- en: '[PRE10]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `skipNegatives` function's implementation is very simple, and it is easy
    to check whether it works correctly in this example, but your other functions
    could be much bigger and harder to understand. Also, the `numbers` array contains
    only three elements and the result should contain two elements. We can easily
    check this by looking out for it in the debugger view.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`skipNegatives`函数的实现非常简单，在这个例子中很容易检查它是否正确工作，但你的其他函数可能更大且更难理解。此外，`numbers`数组只包含三个元素，而结果应该包含两个元素。我们可以通过在调试器视图中查找它来轻松检查这一点。'
- en: 'But what if our numbers array contained 1,000 elements? It would be harder
    to go through the array and verify that it doesn''t contain negative elements.
    In this example, we have 505 non-negative elements in the array:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们的人数数组包含1,000个元素呢？遍历数组并验证它不包含负数元素会更困难。在这个例子中，数组中有505个非负元素：
- en: '[PRE11]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We could write a test function in REPL to check whether all the elements are
    positive. Let''s do that, as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在REPL中编写一个测试函数来检查所有元素是否为正。让我们这样做，如下所示：
- en: '![REPL in Xcode](img/00015.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![REPL in Xcode](img/00015.jpeg)'
- en: 'First, as usual, run the program and stop at a breakpoint. The next step is
    to enter REPL and write an `isAllPositive` function to check whether all the numbers
    are positive. Then, just call `skipNegatives` and `isAllPositive`, and see whether
    the result is `true`:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，像往常一样，运行程序并在断点处停止。下一步是进入REPL并编写一个`isAllPositive`函数来检查所有数字是否为正。然后，只需调用`skipNegatives`和`isAllPositive`，看看结果是否为`true`：
- en: '[PRE12]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are going to use a test function more than once in REPL, it is better
    to create a Swift source file for debugging purposes and add it there. Then, you
    can call it from REPL.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你打算在REPL中多次使用测试函数，最好创建一个Swift源文件用于调试目的，并将其添加到那里。然后，你可以在REPL中调用它。
- en: Console logs
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台日志
- en: 'The other powerful debugging tool, which you should already be familiar with,
    is the console log. Console logs can be used to log all types of information,
    including:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个强大的调试工具，你可能已经熟悉，是控制台日志。控制台日志可以用来记录所有类型的信息，包括：
- en: Operation results
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作结果
- en: Activities
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 活动
- en: Performance measurement
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能测量
- en: 'To log a statement to the console, you can use one of these functions:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 要将语句记录到控制台，你可以使用以下这些函数之一：
- en: '`print`'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`print`'
- en: '`debugPrint`'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debugPrint`'
- en: Both of these functions accept any type.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个函数接受任何类型。
- en: 'To provide custom text formatting for print functions, you must conform to
    the `CustomStringConvertible` protocol, and for `debugPrint`, the `CustomDebugStringConvertible`
    protocol. Both of these protocols require the implementation of only one property.
    Let''s create a simple `Person` type and implement custom log formatting:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 要为打印函数提供自定义文本格式，你必须遵守`CustomStringConvertible`协议，对于`debugPrint`，遵守`CustomDebugStringConvertible`协议。这两个协议都只需要实现一个属性。让我们创建一个简单的`Person`类型并实现自定义日志格式：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Now, when `print` or `debugPrint` is called with an instance of a `Person` type,
    it will show a custom description.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当使用`print`或`debugPrint`调用`Person`类型的实例时，它将显示自定义描述。
- en: A more interesting use case of console logs is a method's performance logging.
    We would like to know how much time a particular method or piece of code took
    to run.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台日志的一个更有趣的使用案例是方法性能日志。我们想知道特定方法或代码片段运行了多长时间。
- en: 'The first idea would be to use `NSDate` to measure time. `NSDate` works well,
    but there is a better solution for this in the `QuartzCore` framework—a `CACurrentMediaTime`
    function. It returns the result based on `mach_absolute_time`. The base pseudocode
    for our case would be as follows:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个想法可能是使用`NSDate`来测量时间。`NSDate`工作得很好，但在`QuartzCore`框架中有一个更好的解决方案——`CACurrentMediaTime`函数。它基于`mach_absolute_time`返回结果。我们案例的基础伪代码如下：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We would like to use this performance-measuring function very often, and it
    would be very useful to extract this code into a separate reusable function. Because
    Swift supports the functional programming style, we can easily do this.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望非常频繁地使用这个性能测量函数，将其提取到单独的可重用函数中将会非常有用。因为Swift支持函数式编程风格，我们可以轻松做到这一点。
- en: 'We will create a measure function. It will take another function that will
    perform a task for which we need to measure time:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个测量函数。它将接受另一个执行我们需要测量时间的任务的函数：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, let''s say we want to find out how much time it takes to create 1,000
    instances of a `Person` type:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要找出创建1,000个`Person`类型实例所需的时间：
- en: '[PRE16]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'What we need to do is simply wrap this code into a closure and pass it to the
    measure function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的就是简单地将这段代码封装成一个闭包，并将其传递给`measure`函数：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Running this measurement in the playground would give us the following result:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在playground中运行此测量将给出以下结果：
- en: '[PRE18]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Performance measuring in unit tests
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试中的性能测量
- en: When you create a new project, Xcode creates a unit test target for that project
    with the name `ProjectName` + `Tests`. If you are not familiar with unit testing,
    you can read about testing in Xcode at [https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode).
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的项目时，Xcode会为该项目创建一个名为`ProjectName` + `Tests`的单元测试目标。如果你不熟悉单元测试，你可以在Xcode中阅读有关测试的文档，链接为[https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/testing_with_xcode)。
- en: 'Xcode will also create a simple unit test file for you. In our project, it''s
    `Swift_ToolkitTests.swift`. The unit test has three main methods, with different
    purposes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Xcode还会为你创建一个简单的单元测试文件。在我们的项目中，它是`Swift_ToolkitTests.swift`。单元测试有三个主要方法，具有不同的目的：
- en: '`setup`'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`setup`'
- en: '`teardown`'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`teardown`'
- en: '`test`'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`test`'
- en: Note
  id: totrans-142
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The unit test function must begin with the `test` prefix, like this for example:'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 单元测试函数必须以`test`前缀开始，例如：
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The names of these functions reflect their purposes. The `setup` function performs
    additional setup before the unit test is run, and `teardown` performs a cleanup,
    but the most interesting function for us is `test`, which performs testing.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数的名称反映了它们的作用。`setup`函数在运行单元测试之前执行额外的设置，`teardown`函数执行清理工作，但对我们来说最有趣的是`test`函数，它执行测试。
- en: The `XCTestCase` unit test class has a `measureBlock` function that works in
    a way similar to the `measure` function that we have implemented. Let's implement
    a unit test to measure the performance for creating 1,000 people.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '`XCTestCase`单元测试类有一个`measureBlock`函数，其工作方式与我们实现的`measure`函数类似。让我们实现一个单元测试来测量创建1,000个人的性能。'
- en: 'First, we need to make a `Person` type and other types in our application available
    to the unit test target. To do so, we need to import an app module with the `@testable
    attribute`—`@testable import {ModuleName}`. Now, all the `public` and `internal`
    types and methods in that module become available in the unit test target:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要使我们的应用程序中的`Person`类型和其他类型对单元测试目标可用。为此，我们需要导入一个带有`@testable`属性的app模块——`@testable
    import {ModuleName}`。现在，该模块中的所有`public`和`internal`类型和方法都可在单元测试目标中使用：
- en: Note
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To enable `@testable`, the **Enable Testability** project build setting must
    be set to **Yes**. Xcode sets it to **Yes** for the **Debug** mode by default.
    You should never enable it for release mode.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用`@testable`，必须将**Enable Testability**项目构建设置设置为**是**。Xcode默认将其设置为**是**，用于**调试**模式。你永远不应该在发布模式下启用它。
- en: '[PRE20]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: When you run the unit tests, by going to **Product** | **Test** or using the
    *CMD* + *U* shortcut, you will see the performance characteristics on the right-hand
    side of the function name. When you click on it, you will see more details and
    a button for setting the baseline performance values, which will be used to compare
    future measurements.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行单元测试时，通过访问**Product** | **Test**或使用*CMD* + *U*快捷键，你将在函数名称的右侧看到性能特征。当你点击它时，你将看到更多详细信息以及设置基线性能值的按钮，这些值将用于比较未来的测量。
- en: 'The `measureBlock` runs a block of code a few times and shows an average time.
    You can see the performance for 10 different iterations in a detailed popup, as
    shown in this screenshot:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`measureBlock`运行几块代码并显示平均时间。你可以在详细弹出窗口中看到10次不同迭代的性能，如图所示：'
- en: '![Performance measuring in unit tests](img/00016.jpeg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![单元测试中的性能测量](img/00016.jpeg)'
- en: Let's now set a baseline and run the unit test again. The test passes!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们设置一个基线并再次运行单元测试。测试通过了！
- en: 'The purpose of performance unit tests is to measure performance and make sure
    that it doesn''t decrease dramatically. By default, the allowed standard deviation
    is 10%. This means that if the performance for code decreases by more than 10%,
    the test fails. Let''s try to simulate this and see what happens. To simulate
    the extra work, we will add a delay in the `person` initializer:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 性能单元测试的目的是测量性能并确保它不会大幅下降。默认情况下，允许的标准偏差为10%。这意味着如果代码的性能下降超过10%，则测试失败。让我们尝试模拟这种情况并看看会发生什么。为了模拟额外的工作，我们将在`person`初始化器中添加延迟：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Now let's run the test again. You will see that test fails and shows a red sign
    next to the test function's name.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再次运行测试。你会看到测试失败，并在测试函数名称旁边显示一个红色的标志。
- en: In this way, unit testing allows you to both measure performance and make sure
    that it doesn't decrease while you are working on the application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，单元测试不仅可以帮助你测量性能，还可以确保你在开发应用时性能不会下降。
- en: Instruments
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪器
- en: 'The last tool that we are going to take a look at in this chapter is instruments.
    Although we are mentioning it towards the end of the chapter, it''s is the most
    powerful tool for measuring all sorts of characteristics of an application: performance,
    memory usage and leaks, networking, monitoring, animation, hard drive, and file
    activity.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将要探讨的最后一种工具是仪器。虽然我们是在章节的末尾提到它，但它却是测量应用各种特性的最强大工具：性能、内存使用和泄漏、网络、监控、动画、硬盘和文件活动。
- en: 'The easiest way to launch Instruments for the application is by going to **Product**
    | **Profile** or by using the *CMD* + *I* keyboard shortcut. This will launch
    the instrument for the current target and show you the available instrument measurement
    templates. We will choose a **Time Profiler** template and click on **Record**.
    This will start the application and record the performance for every called function.
    Now we can analyze the functions'' performance:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 启动Instruments进行应用的 simplest way 是通过转到**产品** | **分析**或使用*CMD* + *I*键盘快捷键。这将启动当前目标的仪器，并显示可用的仪器测量模板。我们将选择一个**时间分析器**模板，并点击**记录**。这将启动应用并记录每个被调用函数的性能。现在我们可以分析函数的性能：
- en: '![Instruments](img/00017.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![仪器](img/00017.jpeg)'
- en: Instruments is a very powerful tool, and it would take a separate chapter to
    cover its functionality completely. If you are not familiar with Instruments,
    you should read more about it at [https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments是一个非常强大的工具，要完全介绍其功能需要单独的一章。如果你不熟悉Instruments，你应该阅读更多关于它的信息，请参阅[https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide](https://developer.apple.com/library/ios/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide)。
- en: A reminder
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提醒
- en: Whenever you are doing any performance measurement, do it in release mode. The
    Swift compiler performs many optimization steps in the release mode and dramatically
    increases performance. To set release mode, go to **Product** | **Scheme** | **Edit
    Scheme** | **Run**, and adjust the **Build Configuration** setting to **Release**.
    Always use release mode for performance testing.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时进行任何性能测量，都应该在发布模式下进行。Swift编译器在发布模式下执行许多优化步骤，从而显著提高性能。要设置发布模式，请转到**产品** |
    **方案** | **编辑方案** | **运行**，并将**构建配置**设置调整为**发布**。始终使用发布模式进行性能测试。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered many tools that would boost your productivity. REPL
    and Playgrounds are perfect for trying out new code and quick code prototyping.
    Playgrounds can also be used to create interactive documentation and tutorials.
    Then we covered debugging tools (such as LLDB and REPL) in Xcode, which are very
    useful for checking the results of operations performed at runtime. The performance
    of an application can be measured in Instruments or using the console log. To
    make sure that the performance doesn't decrease, you should use unit testing.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了许多可以提升你生产力的工具。REPL和Playgrounds非常适合尝试新代码和快速代码原型设计。Playgrounds还可以用来创建交互式文档和教程。然后我们介绍了Xcode中的调试工具（如LLDB和REPL），这些工具对于检查运行时操作的结果非常有用。应用性能可以在仪器或使用控制台日志中进行测量。为了确保性能不会下降，你应该使用单元测试。
- en: Basically, in this chapter, you learned many tools for discovering slow and
    problematic code, and in the next chapter, you will learn how to improve and optimize
    it.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了众多用于发现缓慢和问题代码的工具，而在下一章中，你将学习如何改进和优化它们。
