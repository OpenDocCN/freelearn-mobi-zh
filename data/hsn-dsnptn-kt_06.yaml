- en: Streaming Your Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据流
- en: In this chapter, we'll discuss higher-order functions for collections. For Java
    developers, they first appeared in Java 8 with the introduction of Stream API.
    But they were around for much longer in functional languages.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论集合的高级函数。对于Java开发者来说，它们首次出现在Java 8中，随着Stream API的引入。但在函数式语言中，它们已经存在很长时间了。
- en: First, since we expect that many of our readers are familiar with Java 8, let's
    cover what Stream API is in Java briefly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，由于我们预计许多读者都熟悉Java 8，让我们简要介绍一下Java中的Stream API是什么。
- en: Streams from Java8 are not to be confused with some of the I/O classes with
    similar names, such as `InputStream` or `OutputStream`. While the latter represent
    data, the former are sequences of elements of the same type.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Java8中的流与一些具有相似名称的I/O类（如`InputStream`或`OutputStream`）不可混淆。后者表示数据，而前者是相同类型元素的序列。
- en: If those are sequences, and they all have the same type, how are they different
    from `Lists`? Well, streams can be infinite, unlike collections.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些是序列，并且它们都具有相同的类型，那么它们与`Lists`有何不同？嗯，流可以是无限的，而集合不是。
- en: There is also a set of actions defined for Java streams. Not only are those
    actions the same for any kind of stream, they also have familiar names for those
    that come from totally different languages. There's the `map()` function in JavaScript,
    which does the same as the `map()` method in Java.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 为Java流定义了一系列操作。这些操作不仅对任何类型的流都是相同的，而且对于那些来自完全不同语言的操作，它们还有熟悉的名字。例如，JavaScript中的`map()`函数与Java中的`map()`方法做的是相同的事情。
- en: The idea of making extensive use of small, reusable, and composable functions
    comes directly from functional programming, which we discussed in the previous
    chapter. They allow us to write code in a manner that tells *what* we want to
    do, instead of *how* we want to do it.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 大量使用小型、可重用和可组合函数的想法直接来自我们在上一章讨论的函数式编程。它们允许我们以描述*我们想要做什么*的方式编写代码，而不是*我们想要如何做*。
- en: But in Java, to use those functions, we have to either receive a stream or create
    a stream from a collection.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 但在Java中，要使用这些函数，我们必须接收一个流或从集合创建一个流。
- en: 'In Java, in order to get to all this functional goodness for collections, we
    can do the following:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，为了获取集合的所有这些功能，我们可以做以下操作：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Kotlin, you can do the same:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在Kotlin中，你可以做同样的事情：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'But all those methods and more are available directly on collections:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 但所有这些方法以及更多方法都直接在集合上可用：
- en: '[PRE2]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That's all; there is no need to convert from the stream and back unless you
    plan to operate on *infinite data* in the first place.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是全部；除非您最初计划操作*无限数据*，否则不需要从流转换回集合。
- en: Of course, it's not as simple as that, but we cover the differences and pitfalls near
    the end of this chapter, in the *Streams are lazy, collections are not* section.
    Let's start by understanding what those weird functions actually do.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，事情并没有那么简单，但我们在本章末尾的*流是懒的，集合不是*部分中涵盖了差异和陷阱。让我们先了解那些奇怪函数实际上做什么。
- en: In this chapter, we won't be able to cover all the functions available on collections,
    but we'll cover the most widely used ones.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们无法涵盖集合上所有可用的函数，但我们将介绍最常用的那些。
- en: The examples will be somewhat boring, mostly lists of numbers, letters, and
    people. That's to let you focus on how each function actually works. We'll go
    back to some crazy examples in the next chapter. Stay tuned.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 示例将相对无聊，主要是数字、字母和人的列表。这样可以让您专注于每个函数的实际工作方式。我们将在下一章回到一些疯狂示例。敬请期待。
- en: The it notation
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: it表示法
- en: We glanced at the notion of `it` briefly in previous chapters, but for this
    chapter, we need to understand it a bit more (pun intended).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前几章中简要地提到了`it`的概念，但为了本章，我们需要更深入地理解它（有意为之）。
- en: 'Kotlin is all about brevity. First, if our lambda doesn''t have an argument,
    we don''t need to specify anything:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的一切都关于简洁。首先，如果我们的lambda没有参数，我们就不需要指定任何内容：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'But what if we have a function that takes another function as an argument (and
    doesn''t do anything with it for simplicity)? See the following code:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们有一个接受另一个函数作为参数（为了简单起见，我们不对其做任何操作）的函数呢？请看以下代码：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We can specify both the argument name and type explicitly, and wrap them in
    brackets, like any other function invocation:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以明确指定参数名称和类型，并将它们放在括号中，就像调用其他任何函数一样：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'But since the lambda is the last parameter (and the only one, in this case),
    we can omit the brackets:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 但由于lambda是最后一个参数（在这种情况下，也是唯一的参数），我们可以省略括号：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'And since the compiler can infer the type of parameter, we can omit it too:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 由于编译器可以推断参数的类型，我们也可以省略它：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'And since `x` is the only parameter, we can use the implicit name for it, which
    is `it`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `x` 是唯一的参数，我们可以使用它的隐含名称，即 `it`：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We'll use the shortest notation in most of the following examples.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的大多数示例中，我们将使用最简短的表示法。
- en: The map() function
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`map()` 函数'
- en: One of the most well known higher-order functions on collections is `map()`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 集合中最知名的高阶函数之一是 `map()`。
- en: 'Let''s say you have a function that receives a list of strings and returns
    a new list of the same size containing each string concatenated to itself:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个函数，它接收一个字符串列表并返回一个新列表，其大小与原列表相同，每个字符串都与其自身连接：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The task is quite trivial:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这个任务相当简单：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'But for such a trivial task, we had to write quite a lot of code. What would
    we have to change in order to capitalize each string instead of repeating it twice?
    We would like to change only this line:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 但对于这样一个简单的任务，我们不得不写很多代码。为了将每个字符串改为大写而不是重复两次，我们需要做些什么改变？我们只想改变这一行：
- en: '[PRE11]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: But we have to create another function for that.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 但我们必须为这个创建另一个函数。
- en: 'Of course, in Kotlin, we could pass a function as a second parameter. And since
    we don''t actually care what the type is, as long as it''s the same for both input
    and output, we can use generics:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在 Kotlin 中，我们可以将一个函数作为第二个参数传递。由于我们实际上并不关心类型是什么，只要输入和输出相同即可，我们可以使用泛型：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now we can call our *generified* function as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以这样调用我们的 *泛型化* 函数：
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'And that''s almost exactly what `.map()` does:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这几乎就是 `.map()` 所做的：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Another variation of `map()` is `mapTo()`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`map()` 的另一种变体是 `mapTo()`。'
- en: In addition to the lambda, it receives the destination where the results should
    be incorporated.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 lambda，它还接收一个目的地，结果应该被合并到那里。
- en: 'You could do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样做：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But `mapTo()` lets you do this:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但 `mapTo()` 允许你这样做：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the second option, we use the results list as an argument, which allows us
    to reduce code nesting.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，我们使用结果列表作为参数，这允许我们减少代码嵌套。
- en: Filter family
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤家族
- en: 'Another common task is filtering a collection. You know the drill. You iterate
    over it and put only values that fit your criteria in a new collection. For example,
    if given a range of numbers between 1-10, we would like to return only odd ones.
    Of course, we''ve already learned this lesson from the previous example, and wouldn''t
    simply create a function called `filterOdd()`, as later we would be required to also
    implement `filterEven()`, `filterPrime()`, and so on. We''ll receive a lambda
    as the second argument right away:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见任务是过滤集合。你知道该怎么做。你遍历它，只将符合你标准的值放入新的集合中。例如，如果给定 1-10 的数字范围，我们只想返回奇数。当然，我们已经从上一个例子中学到了这个教训，不会简单地创建一个名为
    `filterOdd()` 的函数，因为后来我们还需要实现 `filterEven()`、`filterPrime()` 等等。我们将立即接收到一个 lambda
    作为第二个参数：
- en: '[PRE17]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Invoking it will print only odd numbers. How odd:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 调用它将只打印奇数。多么奇怪：
- en: '[PRE18]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And, of course, we have a built-in function that does exactly that already:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们已经有了一个内置的函数，它正好做这件事：
- en: '[PRE19]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Find family
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查找家族
- en: 'Say you have an unordered list of objects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个无序的对象列表：
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'And would like to find a first object that matches *some criteria*. Using extension
    functions, you could write something like this:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 并且你想找到第一个符合 *某些标准* 的对象。使用扩展函数，你可以编写如下内容：
- en: '[PRE21]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'And then, when you have a list of objects, you can simply call `find()` on
    it:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当你有一个对象列表时，你可以简单地调用 `find()`：
- en: '[PRE22]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Luckily, you don't have to implement anything. This method is already implemented
    for you in Kotlin.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不需要实现任何内容。这个方法已经在 Kotlin 中为你实现了。
- en: 'There''s also an accompanying `findLast()` method, which does the same, but
    which starts with the last element of the collection:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个配套的 `findLast()` 方法，它执行相同的操作，但以集合的最后一个元素开始：
- en: '[PRE23]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Drop family
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除家族
- en: 'OK, this is cool if you have to iterate over all elements in your collection
    anyway. But with the `for` loops in Java, you could do something like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，如果你必须遍历集合中的所有元素，这很酷。但在 Java 的 `for` 循环中，你可以这样做：
- en: '[PRE24]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: How are you going to achieve that with your funky functions, huh?
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你打算用你那些古怪的功能如何实现这一点，嗯？
- en: 'Well, for that there''s `drop()`:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，为此我们有 `drop()`：
- en: '[PRE25]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Do note that this doesn''t modify the original collection in any way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这不会以任何方式修改原始集合：
- en: '[PRE26]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If you would like to stop your *loop* earlier, there''s `dropLast()` for that:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提前停止你的 *循环*，可以使用 `dropLast()`：
- en: '[PRE27]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Another interesting function is `dropWhile()`, in which it receives a predicate
    instead of a number. It skips until the predicate returns true for the first time:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有趣的功能是`dropWhile()`，它接收一个谓词而不是数字。它跳过直到谓词第一次返回true：
- en: '[PRE28]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: And there's the accompanying `dropLastWhile()`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 并且还有相应的`dropLastWhile()`。
- en: Sort family
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 排序家族
- en: Don't worry, we won't have to implement our own sort algorithm. This is not
    CS 101.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 别担心，我们不需要实现自己的排序算法。这不是计算机科学101。
- en: 'Having the list of people from the preceding `find()` example, we would like
    to sort them by age:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在拥有前一个`find()`示例中的人员列表的情况下，我们希望按年龄对他们进行排序：
- en: '[PRE29]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'It is easily achieved with `sortedBy()`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`sortedBy()`轻松实现：
- en: '[PRE30]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code prints the following output:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码打印以下输出：
- en: '[PRE31]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'There''s also `sortedByDescending()`, which will reverse the order of the results:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`sortedByDescending()`，它将反转结果的顺序：
- en: '[PRE32]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The preceding code prints the following output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码打印以下输出：
- en: '[PRE33]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And if you want to compare by more than one parameter, use the combination
    of `sortedWith` and `compareBy`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要根据多个参数进行比较，请使用`sortedWith`和`compareBy`的组合：
- en: '[PRE34]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: ForEach
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ForEach
- en: This is the first *terminator* we'll see. Terminator functions return something
    other than a new collection, so you can't chain the result of this call to other
    calls.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们将要看到的第一个 *终止符*。终止符函数返回的不是新集合，因此你不能将此调用的结果链式调用到其他调用中。
- en: 'In the case of `forEach()`, it returns Unit. So it''s like the plain, old `for`
    loop:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在`forEach()`的情况下，它返回`Unit`。所以它就像普通的旧`for`循环：
- en: '[PRE35]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Do note that `forEach()` has some minor performance impacts compared to the
    traditional `for` loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`forEach()`与传统的`for`循环相比，有一些轻微的性能影响。
- en: 'There''s also `forEachIndexed()`, which provides an index in the collection
    alongside the actual value:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`forEachIndexed()`，它提供了集合中的索引和实际值：
- en: '[PRE36]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The output for the preceding code will be as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码的输出将如下所示：
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Since Kotlin 1.1, there''s also the `onEach()` function, which is a bit more
    useful, since it returns the collection again:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Kotlin 1.1以来，还有一个`onEach()`函数，它更有用一些，因为它会再次返回集合：
- en: '[PRE38]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Join family
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接家族
- en: 'In the previous example, we used the side effect of printing to the console,
    which is not favorable in terms of functional programming. What''s more, we also
    have this ugly comma at the end of our output as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在先前的例子中，我们使用了打印到控制台的外部效应，这在函数式编程中并不理想。更重要的是，我们还在输出末尾有一个难看的逗号，如下所示：
- en: '[PRE39]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: There must be a better way.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 肯定有更好的方法。
- en: 'How many times have you had to actually write code to simply concatenate some
    list of values into a string? Well, Kotlin has a function for that:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次不得不实际编写代码来简单地将一些值列表连接成一个字符串？好吧，Kotlin有一个函数可以做到这一点：
- en: '[PRE40]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'The preceding code will give the following output:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码将给出以下输出：
- en: '[PRE41]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Simply beautiful, isn't it?
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 简直太美了，不是吗？
- en: 'And if you want to separate it with other characters, or don''t want spaces,
    there''s a way to configure it:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要用其他字符分隔，或者不想有空格，有一种方法可以配置它：
- en: '[PRE42]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码的输出将如下所示：
- en: '[PRE43]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Fold/Reduce
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Fold/Reduce
- en: Much like `forEach()`, both `fold()` and `reduce()` are terminating functions.
    But instead of terminating with Unit, which is not useful, they terminate with
    a single value of the same type.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 与`forEach()`类似，`fold()`和`reduce()`都是终止函数。但它们不是以无用的`Unit`终止，而是以相同类型的单个值终止。
- en: 'The most common example of `reduce` is, of course, for adding up stuff. With
    the list of people from the previous example, we can do the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`reduce`最常用的例子当然是累加。在先前的例子中的人员列表中，我们可以做以下操作：'
- en: '[PRE44]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'The output of the preceding code will be as follows:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个代码的输出将如下所示：
- en: '[PRE45]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Well, combining a lot of people into one doesn't make much sense, unless you're
    a fan of some horror movies.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，把很多人合并成一个没有太多意义，除非你是某些恐怖电影的粉丝。
- en: 'But with reduce, we can also compute who''s the oldest or the youngest in the
    list:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 但使用`reduce`，我们还可以计算列表中最老或最年轻的人：
- en: '[PRE46]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The second function we''re about to discuss, `fold()`, is much like `reduce`,
    but it takes another argument, which is the initial value. It''s useful when you''ve
    already computed something, and now want to use this intermediate result:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要讨论的第二个函数`fold()`与`reduce()`非常相似，但它还接受另一个参数，即初始值。当你已经计算了一些东西，现在想使用这个中间结果时，它很有用：
- en: '[PRE47]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Flat family
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 平铺家族
- en: 'Say you have a list of other lists. You probably got it from different database
    queries, or maybe from different configuration files:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一系列其他列表。你可能从不同的数据库查询中得到了它，或者可能来自不同的配置文件：
- en: '[PRE48]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'And you want to turn them into a single list such as the following:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 而您希望将它们转换成一个如下的单列表：
- en: '[PRE49]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'One way to merge those lists is to write some imperative code:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 合并这些列表的一种方法是通过编写一些命令式代码：
- en: '[PRE50]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'But calling `flatten()` will do the same for you:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 但调用 `flatten()` 会为您做同样的事情：
- en: '[PRE51]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'You can also control what happens with those results using `flatMap()`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用 `flatMap()` 控制这些结果的处理：
- en: '[PRE52]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Note that in this case, it refers to one of the sublists.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这种情况下，它指的是其中一个子列表。
- en: 'You can also decide to use `flatMap()` for type conversions:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以选择使用 `flatMap()` 进行类型转换：
- en: '[PRE53]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The preceding code prints the following output:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下输出：
- en: '[PRE54]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: We converted all integers to doubles, and then merged them into a single list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将所有整数转换为双精度浮点数，然后合并到一个列表中。
- en: Note how the first `it` refers to one of the lists, while the second `it` refers
    to a single item inside the current list.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一个 `it` 指的是列表中的一个，而第二个 `it` 指的是当前列表中的一个单独的项目。
- en: 'As far as `flatten()` goes, it flattens only one level down. To demonstrate
    that, we''ll use `Set` for the first level of nesting, `List` for the second level
    of nesting, and `Set` again for the third level of nesting:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 就 `flatten()` 而言，它只会扁平化一层。为了证明这一点，我们将使用 `Set` 作为第一层嵌套，`List` 作为第二层嵌套，再次使用 `Set`
    作为第三层嵌套：
- en: '[PRE55]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'If we call `flatten` once, we receive only the first level flattened:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们只调用一次 `flatten`，我们只会收到第一层扁平化：
- en: '[PRE56]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding code prints the following output:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下输出：
- en: '[PRE57]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'To completely flatten the list, we need to call `flatten()` twice:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要完全扁平化列表，我们需要调用 `flatten()` 两次：
- en: '[PRE58]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'The preceding code prints the following output:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下输出：
- en: '[PRE59]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Kotlin prevents us from calling `flatten()` three times, as it recognizes the
    amount of nesting we have:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 阻止我们三次调用 `flatten()`，因为它识别出我们有多少嵌套：
- en: '[PRE60]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Slice
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Slice
- en: 'Say we have a list of elements, as follows:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个元素列表，如下所示：
- en: '[PRE61]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'We can take only part of this list using `slice()`:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `slice()` 只取列表的一部分：
- en: '[PRE62]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We're using Kotlin ranges, which is a nice syntax.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 我们正在使用 Kotlin 范围，这是一个很好的语法。
- en: 'In Java, there''s a `subList()` method, which is similar, but not inclusive:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 中，有一个 `subList()` 方法，它与它类似，但不包含：
- en: '[PRE63]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Chunked
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Chunked
- en: It's very common to see this chunking logic in production code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产代码中，这种分块逻辑非常常见。
- en: 'You have a huge list of identifiers that you read from somewhere and you need
    to check whether your database or some remote service contains them. But there
    are limitations on how many identifiers you can pass with a single request. Databases,
    for example, often have limitations of the number of arguments to a query and
    on the total query length:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 您从某处读取了一个庞大的标识符列表，您需要检查您的数据库或某些远程服务是否包含它们。但是，对单个请求中可以传递的标识符数量有限制。例如，数据库通常对查询的参数数量和总查询长度有限制：
- en: '[PRE64]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'We can''t simply pass an entire list to our function:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能简单地将整个列表传递给我们的函数：
- en: '[PRE66]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'So, we write large piles of imperative code:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们编写了大量命令式代码：
- en: '[PRE67]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Luckily, since Kotlin 1.2, there''s the `chunked()` function for that:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，自从 Kotlin 1.2 以来，有 `chunked()` 函数可以做到这一点：
- en: '[PRE68]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Zip/Unzip
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Zip/Unzip
- en: Not related to archiving in any way, `zip()` allows us to create pairs out of
    two lists based on their indexes. That may sound confusing, so let's look at an
    example.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 与存档无关，`zip()` 允许我们根据索引从两个列表中创建对。这可能听起来有些令人困惑，所以让我们看看一个例子。
- en: 'We have two functions, one fetching all active employees, and the other for
    how many days the employee was employed in our startup:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个函数，一个用于获取所有活跃的员工，另一个用于员工在我们初创公司工作的天数：
- en: '[PRE69]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Calling `zip()` between the two of them will produce the following result:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在两者之间调用 `zip()` 将产生以下结果：
- en: '[PRE70]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The preceding code prints the following output:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下输出：
- en: '[PRE71]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Note that since we had a bug in our second function, and returned the days
    for the employees that had already left our startup, the length of the two lists
    wasn''t equal, to begin with. Calling `zip()` will always produce the shortest
    list of pairs:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于我们在第二个函数中有一个错误，返回了已经离开我们初创公司的员工的日期，因此两个列表的长度一开始就不相等。调用 `zip()` 总是会产生最短的对列表：
- en: '[PRE72]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'The preceding code prints the following output:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下输出：
- en: '[PRE73]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note that this is not a map, but a list of pairs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这不是一个映射，而是一对列表。
- en: 'Having such a list, we can also unzip it:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 有这样一个列表，我们还可以将其解包：
- en: '[PRE74]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The preceding code prints the following:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码打印出以下内容：
- en: '[PRE75]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Streams are lazy, collections are not
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 流是懒加载的，集合不是
- en: Be careful with those functions on large collections, though. Most of them will
    copy the collection for the sake of immutability.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然要对大型集合上的那些函数小心谨慎。大多数函数都会为了不可变性而复制集合。
- en: 'Functions starting with `as` won''t do that, though:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 以 `as` 开头的函数不会这样做：
- en: '[PRE76]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'To understand the difference, check the following code:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解差异，请检查以下代码：
- en: '[PRE77]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You'll notice that code using `stream()` actually never executes. Streams, being
    lazy, wait for a terminating function call. Functions on collections, on the other
    hand, execute one after the other.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到使用 `stream()` 的代码实际上从未执行。流是惰性的，它们等待一个终止函数调用。另一方面，集合上的函数是依次执行的。
- en: 'If we add the terminating call though, we''ll see totally different numbers:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们添加终止调用，我们会看到完全不同的数字：
- en: '[PRE78]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Converting from the stream back to the list is an expensive operation. Take
    those points into consideration when deciding which approach to use.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 将流转换回列表是一个昂贵的操作。在决定使用哪种方法时，请考虑这些要点。
- en: Sequences
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 序列
- en: Since streams were introduced only in Java 8, but Kotlin is backward-compatible
    down to Java 6, it needed to provide another solution for the possibility of infinite
    collections. This solution was named *sequenced*, so it won't clash with Java
    streams when they're available.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 由于流仅在 Java 8 中引入，但 Kotlin 与 Java 6 兼容，因此需要提供另一种解决方案以处理无限集合的可能性。这个解决方案被命名为 *sequenced*，因此当
    Java 流可用时，它不会与之冲突。
- en: 'You can generate an infinite sequence of numbers, starting with `1`:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从 `1` 开始生成一个无限序列：
- en: '[PRE79]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'To take only the first `100`, we use the `take()` function:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要只取前 `100` 个，我们使用 `take()` 函数：
- en: '[PRE80]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'A finite number of sequences can be created by returning `null`:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 通过返回 `null` 可以创建有限数量的序列：
- en: '[PRE81]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'A finite number of sequences can be created from ranges or collections by calling
    `asSequence()`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用 `asSequence()` 可以从范围或集合创建有限数量的序列：
- en: '[PRE82]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Summary
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter was dedicated to practicing functional programming principles and
    learning the building blocks of functional programming in Kotlin.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 本章致力于练习函数式编程原则，并学习 Kotlin 中函数式编程的构建块。
- en: Now you should know how to transform your data with `map()`/`mapTo()`, how to `filter()`
    collections, and `find()` elements by criteria.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该知道如何使用 `map()`/`mapTo()` 转换你的数据，如何 `filter()` 集合，以及根据标准 `find()` 元素。
- en: You should also be familiar with how to `drop()` elements to skip them, how
    to `sort()` collections, and how to iterate over them using `forEach()` and `onEach()`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你还应该熟悉如何使用 `drop()` 跳过元素，如何 `sort()` 集合，以及如何使用 `forEach()` 和 `onEach()` 迭代它们。
- en: Use `join()` to stringify collections, `fold()` and `reduce()` to total collections
    up, and `flatten()` and `flatTo()` to reduce collection nesting.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `join()` 将集合转换为字符串，使用 `fold()` 和 `reduce()` 对集合求和，使用 `flatten()` 和 `flatTo()`
    减少集合嵌套。
- en: '`slice()` is a way to get only a portion of a collection, while `chunked()`
    is used to break a collection into even portions.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`slice()` 是获取集合一部分的方法，而 `chunked()` 用于将集合分成相等的部分。'
- en: Finally, `zip()` and `unzip()` combine two collections into a pair, or split
    the pair back into two parts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`zip()` 和 `unzip()` 将两个集合组合成一对，或者将一对拆分成两部分。
- en: In the next chapter, we'll discuss how familiarity with those methods helps
    us to become truly reactive.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论熟悉这些方法如何帮助我们真正地实现响应式编程。
