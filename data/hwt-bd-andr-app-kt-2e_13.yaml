- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Dependency Injection with Dagger, Hilt, and Koin
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Dagger、Hilt和Koin进行依赖注入
- en: This chapter covers the concept of dependency injection and the benefits it
    provides to an Android application. We will look at how we can perform dependency
    injection manually with the help of container classes. We will also cover some
    of the frameworks available for Android, Java, and Kotlin that can help developers
    when it comes to applying this concept. By the end of this chapter, you will be
    able to use Dagger 2 and Koin to manage your app’s dependencies and know how to
    organize them efficiently.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了依赖注入的概念及其对Android应用程序提供的益处。我们将探讨如何借助容器类手动执行依赖注入。我们还将介绍一些可用于Android、Java和Kotlin的框架，这些框架可以帮助开发者应用这一概念。在本章结束时，你将能够使用Dagger
    2和Koin来管理你的应用程序依赖，并了解如何有效地组织它们。
- en: In the previous chapter, we looked at how to structure code into different components,
    including ViewModels, API components, and persistence components. One of the difficulties
    that always emerged was the dependencies between all of these components, especially
    when it came to how we approached the unit tests for them.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何将代码结构化成不同的组件，包括ViewModels、API组件和持久化组件。其中一直存在的困难之一是所有这些组件之间的依赖关系，尤其是在进行单元测试时。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Manual DI
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动依赖注入
- en: Dagger 2
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Dagger 2
- en: Hilt
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Hilt
- en: Koin
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Koin
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete code for all the exercises and the activity in this chapter is
    available on GitHub at [https://packt.link/IIQmX](https://packt.link/IIQmX)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中所有练习和活动的完整代码可在GitHub上找到，链接为[https://packt.link/IIQmX](https://packt.link/IIQmX)
- en: The necessity of dependency injection
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入的必要性
- en: We have constantly used the `Application` class to create instances of these
    components and pass them in the constructors of the components one layer above
    (we created the API and Room instances, then the Repository instances, and so
    on). What we were doing was a simplistic version of dependency injection.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用`Application`类来创建这些组件的实例，并将它们传递给组件上层构造函数（我们创建了API和Room实例，然后是Repository实例，等等）。我们所做的是依赖注入的简化版本。
- en: '`ViewModels`). The reason for this is to increase the reusability and testability
    of the code and to shift the responsibility for creating instances from our components
    to the `Application` class.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModels`）。这样做的原因是为了提高代码的可重用性和可测试性，并将创建实例的责任从我们的组件转移到`Application`类。'
- en: One of the benefits of DI concerns how objects are created across the code base.
    DI separates the creation of an object from its usage. In other words, one object
    shouldn’t care how another object is created; it should only be concerned with
    the interaction with the other object.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入的一个好处是涉及代码库中对象的创建方式。依赖注入将对象的创建与其使用分离。换句话说，一个对象不应该关心另一个对象是如何创建的；它只应该关注与其他对象的交互。
- en: 'In this chapter, we will analyze three ways to inject dependencies in Android:
    Manual DI, Dagger, and Koin:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析三种在Android中注入依赖的方法：手动依赖注入、Dagger和Koin：
- en: '**Manual DI**: This is a technique in which developers handle DI manually by
    creating container classes. In this chapter, we will examine how we can do this
    in Android. By studying how we manually manage dependencies, we will get some
    insight into how other DI frameworks operate and get a basis for how we can integrate
    these frameworks.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**手动依赖注入（Manual DI）**：这是一种开发者通过创建容器类来手动处理依赖注入的技术。在本章中，我们将探讨如何在Android中实现这一过程。通过研究我们如何手动管理依赖关系，我们将深入了解其他依赖注入框架的工作原理，并为我们如何集成这些框架打下基础。'
- en: '**Dagger**: This is a DI framework developed for Java. It allows you to group
    your dependencies into different modules. You can also define components, where
    the modules are added to create the dependency graph, and which Dagger automatically
    implements to perform the injection. It relies on annotation processors to generate
    the necessary code to perform the injection. A specialized implementation of Dagger
    called **Hilt** is useful for Android applications because it removes a lot of
    boilerplate code and simplifies the process.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Dagger**：这是一个为Java开发的依赖注入框架。它允许你将依赖分组到不同的模块中。你还可以定义组件，其中模块被添加以创建依赖图，Dagger会自动实现以执行注入。它依赖于注解处理器来生成执行注入所需的代码。Dagger的一个专门实现**Hilt**对Android应用程序非常有用，因为它消除了大量样板代码并简化了过程。'
- en: '**Koin**: This is a lightweight DI library developed for Kotlin. It doesn’t
    rely on annotation processors; it relies on Kotlin’s mechanisms to perform the
    injection. Here we can also split dependencies into modules.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Koin**：这是一个为 Kotlin 开发的轻量级依赖注入库。它不依赖于注解处理器；它依赖于 Kotlin 的机制来执行注入。在这里，我们还可以将依赖项拆分为模块。'
- en: In this chapter, we will explore how both these libraries work and the steps
    required to add them to a simple Android application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨这两个库是如何工作的，以及将它们添加到简单 Android 应用程序所需的步骤。
- en: Manual DI
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动依赖注入
- en: In order to understand how DI works, we can first analyze how we can manually
    inject dependencies into different objects across an Android application. This
    can be achieved by creating container objects containing the dependencies required
    across the app.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解依赖注入是如何工作的，我们首先可以分析如何在 Android 应用程序的不同对象中手动注入依赖项。这可以通过创建包含整个应用程序所需依赖项的容器对象来实现。
- en: You can also create multiple containers representing different scopes required
    across the application. Here, you can define dependencies that will only be required
    as long as a particular screen is displayed, and when the screen is destroyed,
    the instances can also be garbage collected.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以创建多个容器，代表应用程序中所需的不同作用域。在这里，您可以定义仅在特定屏幕显示时才需要的依赖项，当屏幕被销毁时，实例也可以被垃圾回收。
- en: 'A sample of a container that will hold instances as long as an application
    lives is shown here:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这里展示了一个容器示例，该容器将保持实例，直到应用程序的生命周期结束：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'An `Application` class using that container looks something like the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用该容器的 `Application` 类看起来如下所示：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'As you can see in the preceding example, the responsibility for creating the
    dependencies shifted from the `Application` class to the `Container` class. Activities
    across the code base can still access the dependencies using the following command:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，创建依赖项的责任已从 `Application` 类转移到 `Container` 类。代码库中的活动仍然可以使用以下命令访问依赖项：
- en: '[PRE2]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Modules with a limited scope could be used for something such as creating the
    `ViewModel` factories, which, in turn, are used by the framework to create `ViewModel`:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 范围有限的模块可以用于创建 `ViewModel` 工厂，这些工厂反过来被框架用来创建 `ViewModel`：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'An activity or fragment can use this particular container to initialize `ViewModel`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个活动或片段可以使用这个特定的容器来初始化 `ViewModel`：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Again, we can see here that the responsibility of creating the `Factory` class
    was shifted from the `Activity` class to the `Container` class. `MyContainer`
    could be expanded to provide instances required by `MyActivity` in situations
    where the lifecycle of those instances should be the same as the activity, or
    the constructor could be expanded to provide instances with a different lifecycle.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，我们可以看到创建 `Factory` 类的责任已从 `Activity` 类转移到 `Container` 类。`MyContainer` 可以扩展以提供
    `MyActivity` 所需的实例，在这些实例的生命周期应与活动相同的情况下，或者构造函数可以扩展以提供具有不同生命周期的实例。
- en: Now, let’s apply some of these examples to an exercise.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将这些示例应用到练习中。
- en: Exercise 13.01 – manual injection
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.01 – 手动注入
- en: In this exercise, we will write an Android application that will apply the concept
    of manual DI. The application will have a Repository, which will generate a random
    number, and a `ViewModel` object with a `LiveData` object responsible for retrieving
    the number generated by the Repository and publishing it in the `LiveData` object.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个 Android 应用程序，该应用程序将应用手动依赖注入的概念。该应用程序将有一个仓库，它将生成一个随机数，以及一个带有 `LiveData`
    对象的 `ViewModel` 对象，该对象负责检索仓库生成的数字并在 `LiveData` 对象中发布它。
- en: 'In order to do so, we will need to create two containers that will manage the
    following dependencies:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们需要创建两个容器来管理以下依赖项：
- en: Repository
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仓库
- en: A `ViewModel` factory responsible for creating `ViewModel`
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负责创建 `ViewModel` 的 `ViewModel` 工厂
- en: 'The app itself will display the randomly generated number each time a button
    is clicked:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身将在每次点击按钮时显示随机生成的数字：
- en: Create a new Android Studio Project with an empty activity.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目，并包含一个空活动。
- en: 'Let’s start by adding the `ViewModel` and `LiveData` libraries to the `app/build.gradle`
    file:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们将 `ViewModel` 和 `LiveData` 库添加到 `app/build.gradle` 文件中：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Next, let’s write a `NumberRepository` interface in the `main/java` folder
    in the root package, which will contain a method to retrieve an integer:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在根包的 `main/java` 文件夹中编写一个 `NumberRepository` 接口，它将包含一个获取整数的函数：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we will provide the implementation for this in the `main/java` folder
    in the root package. We can use the `java.util.Random` class to generate a random
    number:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在这个根包的`main/java`文件夹中提供这个实现的实现。我们可以使用`java.util.Random`类来生成随机数：
- en: '[PRE7]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will now move on to the `MainViewModel` class in the `main/java` folder
    in the root package, which will contain a `LiveData` object containing each generated
    number from the repository:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将转到根包的`main/java`文件夹中的`MainViewModel`类，它将包含一个包含从仓库生成的每个数字的`LiveData`对象：
- en: '[PRE8]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Next, let’s move on to create our `TextView` for displaying the number and
    `Button` for generating the next random number. This will be part of the `res/layout/activity_main.xml`
    file:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们继续创建用于显示数字的`TextView`和用于生成下一个随机数的`Button`。这将是`res/layout/activity_main.xml`文件的一部分：
- en: '[PRE9]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The complete code for this step can be found at [https://packt.link/lr5Fx](https://packt.link/lr5Fx).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/lr5Fx](https://packt.link/lr5Fx)找到。
- en: 'Make sure to add the string for the button to the `res/values/strings.xml`
    file:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保将按钮的字符串添加到`res/values/strings.xml`文件中：
- en: '[PRE10]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, let’s create our `Application` class in the `main/java` folder in the
    root package:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的`main/java`文件夹中创建我们的`Application`类：
- en: '[PRE11]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let’s also add the `Application` class to the `AndroidManifest.xml` file in
    the `application` tag:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们也将`Application`类添加到`AndroidManifest.xml`文件中的`application`标签下：
- en: '[PRE12]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, let’s create our first container responsible for managing the `NumberRepository`
    dependency in the `main/java` folder in the root package:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的`main/java`文件夹中创建我们的第一个容器，该容器负责管理`NumberRepository`依赖项：
- en: '[PRE13]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let’s add this container to the `RandomApplication` class:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们将这个容器添加到`RandomApplication`类中：
- en: '[PRE14]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We now move on to creating `MainContainer` in the `main/java` folder in the
    root package, which will need a reference to the `NumberRepository` dependency
    and will provide a dependency to the `ViewModel` factory required to create `MainViewModel`:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在继续在根包的`main/java`文件夹中创建`MainContainer`，它需要一个对`NumberRepository`依赖项的引用，并将提供创建`MainViewModel`所需的`ViewModel`工厂的依赖项：
- en: '[PRE15]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we can modify `MainActivity` to inject our dependencies from our containers
    and connect the UI elements to display the output:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以修改`MainActivity`以从我们的容器中注入依赖项，并将UI元素连接起来以显示输出：
- en: '[PRE16]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the highlighted code, we can see that we are using the repository defined
    in `ApplicationContainer` and injecting it into `MainContainer`, which will then
    inject it into `ViewModel` through `ViewModelProvider.Factory`. The preceding
    example should render the output presented in *Figure 13**.1*:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在高亮显示的代码中，我们可以看到我们正在使用在`ApplicationContainer`中定义的仓库并将其注入到`MainContainer`中，然后它将通过`ViewModelProvider.Factory`将其注入到`ViewModel`中。前面的示例应该会呈现*图13.1*.1*中的输出：
- en: '![Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated
    number](img/B19411_13_01.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图13.1 – 练习13.01的模拟器输出，显示随机生成的数字](img/B19411_13_01.jpg)'
- en: Figure 13.1 – Emulator output of exercise 13.01 displaying a randomly generated
    number
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.1 – 练习13.01的模拟器输出，显示随机生成的数字
- en: Manual DI is an easy way to set up your dependencies in situations where the
    app is small, but it can become extremely difficult as the app grows. Imagine
    if, in *Exercise 13.01*, *Manual injection*, we had two classes that extended
    from `NumberRepository`. How would we handle such a scenario? How would developers
    know which one went in what activity? These types of questions have become very
    common in most of the well-known apps on Google Play, which is why manual DI is
    rarely used. When used, it normally takes the form of a DI framework similar to
    the ones we will look over next.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 手动依赖注入是设置小型应用程序依赖项的一种简单方法，但随着应用程序的增长，它可能会变得极其困难。想象一下，如果在*练习13.01*的*手动注入*中，我们有两个从`NumberRepository`扩展的类。我们将如何处理这种情况？开发者将如何知道哪个被用于哪个活动？这些问题在Google
    Play上大多数知名应用程序中变得非常普遍，这就是为什么手动依赖注入很少使用。当使用时，它通常采用类似于我们接下来将要查看的依赖注入框架的形式。
- en: Dagger 2
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Dagger 2
- en: '**Dagger 2** offers a comprehensive way to organize your application’s dependencies.
    It has the advantage of being adopted first on Android by the developer community
    before Kotlin was introduced. This is one of the reasons that many Android applications
    use Dagger as their DI framework.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**Dagger 2**提供了一种全面的方式来组织应用程序的依赖项。它具有首先在Android上被开发社区采用的优势，在Kotlin引入之前。这是许多Android应用程序使用Dagger作为其依赖注入框架的原因之一。'
- en: Another advantage the framework holds is for Android projects written in Java
    because the library is developed in the same language. The framework was initially
    developed by Square (Dagger 1) and later transitioned to Google (Dagger 2). We
    will cover Dagger 2 in this chapter and describe its benefits.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架的另一个优势是针对用Java编写的Android项目，因为库是用相同的语言开发的。该框架最初由Square（Dagger 1）开发，后来过渡到Google（Dagger
    2）。在本章中，我们将介绍Dagger 2及其优势。
- en: 'Some of the key functionality that Dagger 2 provides is listed here:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger 2提供的一些关键功能如下所示：
- en: Injection
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注入
- en: Dependencies grouped in modules
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模块中分组的依赖项
- en: Components used to generate dependency graphs
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于生成依赖图的组件
- en: Qualifiers
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准化
- en: Scopes
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 范围
- en: Subcomponents
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 子组件
- en: 'Annotations are the key elements when dealing with Dagger because it generates
    the code required to perform the DI through an annotation processor. The main
    annotations can be grouped as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理Dagger时，注解是关键元素，因为它通过注解处理器生成执行DI所需的代码。主要注解可以按以下方式分组：
- en: '`@Module` are responsible for providing an object (dependent object) that can
    be injected'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Module`负责提供可以注入的对象（依赖对象）'
- en: '`@Inject` annotation is used to define a dependency'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@Inject`注解用于定义依赖项'
- en: '`@Component`-annotated interface defines the connection between the provider
    and the consumer'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 被`@Component`注解的接口定义了提供者和消费者之间的连接
- en: 'You will need to add the following dependencies in the `app/build.gradle` file
    to add Dagger to your project:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在`app/build.gradle`文件中添加以下依赖项，以将Dagger添加到你的项目中：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Since we are dealing with annotation processors, in the same `build.gradle`
    file, you will need to add the plugin for them:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在处理注解处理器，在同一个`build.gradle`文件中，你需要为它们添加插件：
- en: '[PRE18]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We should now have an idea of how Dagger 2 goes about performing DI. Next, we
    will look at each group of annotations Dagger 2 offers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在应该对Dagger 2如何执行DI有一个概念。接下来，我们将查看Dagger 2提供的每个注解组。
- en: Consumers
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费者
- en: 'Dagger uses `javax.inject.Inject` to identify objects that require injection.
    There are multiple ways to inject dependencies, but the recommended ways are through
    constructor injection and field injection. Constructor injection looks similar
    to the following code:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger使用`javax.inject.Inject`来识别需要注入的对象。有多种注入依赖项的方法，但推荐的方法是通过构造函数注入和字段注入。构造函数注入的代码可能如下所示：
- en: '[PRE19]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: When constructors are annotated with `@Inject`, Dagger will generate the `Factory`
    classes responsible for instantiating the objects. In the example of `ClassB`,
    Dagger will try to find the appropriate dependencies that fit the signature of
    the constructor, which, in this example, is `ClassA`, which Dagger already created
    an instance for.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当构造函数被`@Inject`注解时，Dagger将生成负责实例化对象的`Factory`类。在`ClassB`的例子中，Dagger将尝试找到适合构造函数签名的适当依赖项，在这个例子中是`ClassA`，Dagger已经为其创建了一个实例。
- en: 'If you do not want Dagger to manage the instantiation of `ClassB` but still
    have the dependency on `ClassA` injected, you can use field injection, which will
    look something like this:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不想让Dagger管理`ClassB`的实例化，但仍然需要将`ClassA`的依赖注入，你可以使用字段注入，其形式可能如下所示：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this case, Dagger will generate the necessary code just to inject the dependency
    between `ClassB` and `ClassA`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Dagger将生成必要的代码，仅用于在`ClassB`和`ClassA`之间注入依赖。
- en: Providers
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供者
- en: You will find yourself in situations where your application uses external dependencies.
    That means that you cannot provide instances through constructor injections. Another
    situation where constructor injection is not possible is when interfaces or abstract
    classes are used.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会遇到应用程序使用外部依赖项的情况。这意味着你不能通过构造函数注入来提供实例。构造函数注入不可行的情况还包括使用接口或抽象类。
- en: 'In this situation, Dagger can provide the instance using the `@Provides` annotation.
    You will then need to group the methods where instances are provided into modules
    annotated with `@Module`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，Dagger可以使用`@Provides`注解提供实例。然后你需要将提供实例的方法分组到被`@Module`注解的模块中：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As you can see in the preceding example, `ClassA` and `ClassB` don’t have any
    Dagger annotations. A module was created that will provide the instance for `ClassA`,
    which will then be used to provide the instance for `ClassB`. In this case, Dagger
    will generate a `Factory` class for each of the `@Provides` annotated methods.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如前例所示，`ClassA` 和 `ClassB` 没有任何 Dagger 注解。创建了一个模块，它将为 `ClassA` 提供实例，然后将被用来为 `ClassB`
    提供实例。在这种情况下，Dagger 将为每个 `@Provides` 注解的方法生成一个 `Factory` 类。
- en: Connectors
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接器
- en: Assuming we will have multiple modules, we must combine them in a graph of dependencies
    that can be used across the application. Dagger offers the `@Component` annotation.
    This is usually used for an interface or an abstract class that will be implemented
    by Dagger.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们将有多个模块，我们必须将它们组合成一个可以在应用程序中使用的依赖关系图。Dagger 提供了 `@Component` 注解。这通常用于将被 Dagger
    实现的接口或抽象类。
- en: 'Along with assembling the dependency graph, components also offer the functionality
    to add methods to inject dependencies into a certain object’s members. In components,
    you can specify provision methods that return dependencies provided in the modules:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 除了组装依赖关系图之外，组件还提供了向特定对象的成员中注入依赖项的功能。在组件中，你可以指定提供方法，这些方法返回模块中提供的依赖项：
- en: '[PRE22]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'For the preceding `Component`, Dagger will generate a `DaggerMyComponent` class,
    and we can build it as described in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 对于前面的 `Component`，Dagger 将生成一个 `DaggerMyComponent` 类，我们可以按照以下代码所述构建它：
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `Application` class will create the Dagger dependency graph and component.
    The `inject` method in `Component` allows us to perform DI on the variables in
    the `Application` class annotated with `@Inject`, giving us access to the `ClassB`
    object defined in the module.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`Application` 类将创建 Dagger 依赖图和组件。`Component` 中的 `inject` 方法允许我们对 `Application`
    类中用 `@Inject` 注解的变量执行依赖注入，从而让我们访问模块中定义的 `ClassB` 对象。'
- en: Qualifiers
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限定符
- en: 'You can use qualifiers if you want to provide multiple instances of the same
    class (such as injecting different strings or integers across an application).
    These are annotations that can help you identify instances. One of the most common
    ones is the `@Named` qualifier, as described in the following code:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要提供同一类的多个实例（例如，在应用程序中注入不同的字符串或整数），可以使用限定符。这些是帮助你识别实例的注解。其中最常见的一个是 `@Named`
    限定符，如下面的代码所述：
- en: '[PRE24]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, we create two instances of `ClassA` and give them different
    names. We then use the first instance whenever possible to create `ClassB`. We
    can also create custom qualifiers instead of the `@Named` annotation, as described
    in the following code:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们创建了两个 `ClassA` 的实例，并给它们不同的名称。然后，尽可能使用第一个实例来创建 `ClassB`。我们还可以创建自定义限定符，而不是使用
    `@Named` 注解，如下面的代码所述：
- en: '[PRE25]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The module can be updated like this:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 模块可以像这样更新：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Scopes
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 范围
- en: If you want to keep track of the lifecycle of your components and your dependencies,
    you can use scopes. Dagger offers a `@Singleton` scope. This usually indicates
    that your component will live as long as your application.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要跟踪你的组件和依赖项的生存周期，你可以使用范围。Dagger 提供了 `@Singleton` 范围。这通常表示你的组件将与你的应用程序一样长存。
- en: Scoping has no impact on the lifecycle of the objects; they are built to help
    developers identify the lifecycles of objects. Giving your components one scope
    and grouping your code to reflect that scope is recommended.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 范围定义对对象的生存周期没有影响；它们被构建来帮助开发者识别对象的生存周期。建议为你的组件指定一个范围，并将代码分组以反映该范围。
- en: 'Some common Dagger scopes on Android are related to the activity or fragment:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 一些常见的 Android 上 Dagger 的范围与活动或片段相关：
- en: '[PRE27]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The annotation can be used in the module where the dependency is provided:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 该注解可以在提供依赖项的模块中使用：
- en: '[PRE28]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code for `Component` will be as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`Component` 的代码如下：'
- en: '[PRE29]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The preceding example indicates that `Component` can only use objects with the
    same scope. If any of the modules that are part of `Component` contain dependencies
    with different scopes, Dagger will throw an error indicating that there is something
    wrong with the scopes.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的例子表明，`Component` 只能使用具有相同范围的对象。如果 `Component` 的任何模块包含具有不同范围的依赖项，Dagger 将抛出一个错误，指示范围存在问题。
- en: Subcomponents
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 子组件
- en: Something that goes hand-in-hand with scopes is subcomponents. They allow you
    to organize your dependencies for smaller scopes. One common use case on Android
    is to create subcomponents for activities and fragments. Subcomponents inherit
    dependencies from the parent, and they generate a new dependency graph for the
    scope of the subcomponent.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 与作用域密切相关的是子组件。它们允许你为较小的作用域组织依赖项。在 Android 中，一个常见的用例是为活动和片段创建子组件。子组件继承父组件的依赖项，并为子组件的作用域生成一个新的依赖图。
- en: 'Let’s assume we have a separate module, as shown here:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个独立的模块，如下所示：
- en: '[PRE30]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'A `Subcomponent` that will generate a dependency graph for that module would
    look something like the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 一个将为此模块生成依赖图的 `Subcomponent` 可能看起来如下所示：
- en: '[PRE31]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'The parent component would need to declare the new component, as shown in the
    following code snippet:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 父组件需要声明新的组件，如下面的代码片段所示：
- en: '[PRE32]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And you can inject `ClassC` into your activity as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式将 `ClassC` 注入到你的活动中：
- en: '[PRE33]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: With this knowledge, let’s move on to the exercise.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 基于这些知识，让我们继续进行练习。
- en: Exercise 13.02 – Dagger injection
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 13.02 – Dagger 注入
- en: In this exercise, we will write an Android application that will apply the concept
    of DI with Dagger. The application will have the same `Repository` and `ViewModel`
    defined in *Exercise 13.01*, *Manual injection*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将编写一个 Android 应用程序，该程序将使用 Dagger 应用 DI 概念。该应用程序将具有与 *练习 13.01*，*手动注入*
    中定义相同的 `Repository` 和 `ViewModel`。
- en: 'We will need to use Dagger to expose the same two dependencies:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要使用 Dagger 来公开相同的两个依赖项：
- en: '`Repository`: This will have the `@Singleton` scope and will be provided by
    `ApplicationModule`. Now, `ApplicationModule` will be exposed as part of `ApplicationComponent`.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：这将具有 `@Singleton` 作用域，并由 `ApplicationModule` 提供。现在，`ApplicationModule`
    将作为 `ApplicationComponent` 的一部分公开。'
- en: '`ViewModelProvider.Factory`: This will have the custom-defined scope named
    `MainScope` and will be provided by `MainModule`. Now, `MainModule` will be exposed
    by `MainSubComponent`. Also, `MainSubComponent` will be generated by `ApplicationComponent`.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModelProvider.Factory`：这将具有自定义定义的作用域名称 `MainScope`，并由 `MainModule` 提供。现在，`MainModule`
    将由 `MainSubComponent` 公开。此外，`MainSubComponent` 将由 `ApplicationComponent` 生成。'
- en: 'The app itself will display a randomly generated number each time a button
    is clicked. To achieve this, take the following steps:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序本身将在每次点击按钮时显示一个随机生成的数字。为了实现这一点，请执行以下步骤：
- en: Create a new Android Studio Project with Empty Activity.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Android Studio 项目，包含空活动。
- en: 'Let’s start by adding Dagger and the `ViewModel` libraries to the `app/build.gradle`
    file:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将 Dagger 和 `ViewModel` 库添加到 `app/build.gradle` 文件中：
- en: '[PRE34]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We also need the `kapt` plugin in the `app/build.gradle` module. Attach the
    plugin as shown here:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在 `app/build.gradle` 模块中添加 `kapt` 插件。按照以下方式附加插件：
- en: '[PRE35]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: We now need to add the `NumberRepository`, `NumberRepositoryImpl`, `Main` **ViewModel**,
    and `RandomApplication` classes and build our UI with `Main` **Activity**. This
    can be done by following *steps 2–9* from *Exercise 13.01*, *Manual injection*.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在需要添加 `NumberRepository`、`NumberRepositoryImpl`、`Main` **ViewModel** 和 `RandomApplication`
    类，并使用 `Main` **Activity** 构建我们的 UI。这可以通过遵循 *练习 13.01*，*手动注入* 中的 *步骤 2–9* 来完成。
- en: 'Now, let’s move on to `ApplicationModule` in the `main/java` folder in the
    root package, which will provide the `NumberRepository` dependency:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们转向根包的 `main/java` 文件夹中的 `ApplicationModule`，它将提供 `NumberRepository` 依赖项：
- en: '[PRE36]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Now, let’s create `MainModule` in the `main/java` folder in the root package,
    which will provide the instance of `ViewModel.Factory`:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的 `main/java` 文件夹中创建 `MainModule`，它将提供 `ViewModel.Factory` 的实例：
- en: '[PRE37]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now, let’s create `MainScope` in the `main/java` folder in the root package:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在根包的 `main/java` 文件夹中创建 `MainScope`：
- en: '[PRE38]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We will need `MainSubcomponent` in the `main/java` folder in the root package,
    which will use the preceding scope:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在根包的 `main/java` 文件夹中创建 `MainSubcomponent`，它将使用前面的作用域：
- en: '[PRE39]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Next, we will require `ApplicationComponent` in the `main/java` folder in the
    root package:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在根包的 `main/java` 文件夹中引入 `ApplicationComponent`：
- en: '[PRE40]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Next, we modify the `RandomApplication` class to add the code required to initialize
    the Dagger dependency graph:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们修改 `RandomApplication` 类以添加初始化 Dagger 依赖图的代码：
- en: '[PRE41]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'We now modify the `MainActivity` class to inject `ViewModelProvider.Factory`
    and initialize `ViewModel` so that we can display the random number:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们修改 `MainActivity` 类以注入 `ViewModelProvider.Factory` 并初始化 `ViewModel`，以便我们可以显示随机数：
- en: '[PRE42]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The complete code for this step can be found at [https://packt.link/A7ozE](https://packt.link/A7ozE).
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 本步骤的完整代码可以在 [https://packt.link/A7ozE](https://packt.link/A7ozE) 找到。
- en: We will need to navigate to `Build` and click on `Rebuild project` in Android
    Studio so that Dagger will generate the code for performing the DI.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要导航到 `Build` 并在 Android Studio 中点击 `Rebuild project`，以便 Dagger 生成执行 DI 的代码。
- en: 'If you run the preceding code, it will build an application that will display
    a different random output when you click the button:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您运行前面的代码，它将构建一个应用程序，当您点击按钮时将显示不同的随机输出：
- en: '![Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated
    number](img/B19411_13_02.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.2 – 练习 13.02 的模拟器输出，显示随机生成的数字](img/B19411_13_02.jpg)'
- en: Figure 13.2 – Emulator output of exercise 13.02 displaying a randomly generated
    number
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.2 – 练习 13.02 的模拟器输出，显示随机生成的数字
- en: '*Figure 13**.3* shows what the application looks like. You can view the generated
    Dagger code in the `app/build` folder:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*图 13*.3 显示了应用程序的外观。您可以在 `app/build` 文件夹中查看生成的 Dagger 代码：'
- en: "![Figure 13.3 – Generated Dagger code for \uFEFFExercise 13.02](img/B19411_13_03.jpg)"
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 13.3 – 为练习 13.02 生成的 Dagger 代码](img/B19411_13_03.jpg)'
- en: Figure 13.3 – Generated Dagger code for Exercise 13.02
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3 – 为练习 13.02 生成的 Dagger 代码
- en: In *Figure 13**.3*, we can see the code that Dagger generated to satisfy the
    relationship between dependencies. For every dependency that needs to be injected,
    Dagger will generate an appropriate `Factory` class (based on the `Factory` design
    pattern), which will be responsible for creating the dependency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 13*.3 中，我们可以看到 Dagger 生成的代码，以满足依赖项之间的关系。对于每个需要注入的依赖项，Dagger 将生成一个适当的 `Factory`
    类（基于 `Factory` 设计模式），该类将负责创建依赖项。
- en: Dagger also looks at the places where dependencies will need to be injected
    and generates an `Injector` class, which will have the responsibility of assigning
    the value to the dependency (in this case, it will assign the value to the members
    annotated with `@Inject` in the `MainActivity` class).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: Dagger 还会查看需要注入依赖的地方，并生成一个 `Injector` 类，该类将负责将值分配给依赖项（在这种情况下，它将分配给 `MainActivity`
    类中注解了 `@Inject` 的成员）。
- en: Finally, Dagger creates implementations for the interfaces that have the `@Component`
    annotation. In the implementation, Dagger will handle how the modules are created
    and also provide a builder in which developers can specify how modules can be
    built.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Dagger 为带有 `@Component` 注解的接口创建实现。在实现中，Dagger 将处理模块的创建，并提供一个构建器，开发者可以指定如何构建模块。
- en: 'A common setup you will find for Android applications when it comes to organizing
    their dependencies is as follows:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当组织 Android 应用程序的依赖项时，您会发现的一个常见设置如下：
- en: '`ApplicationModule`: This is where dependencies common for the entire project
    are defined. Objects such as context, resources, and other Android framework objects
    can be provided here.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplicationModule`：这是定义整个项目共通依赖的地方。可以在此提供如 context、资源和其他 Android 框架对象。'
- en: '`NetworkModule`: This is where dependencies related to API calls are stored.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NetworkModule`：这是存储与 API 调用相关的依赖的地方。'
- en: '`StorageModule`: This is where dependencies related to persistence are stored.
    It can be split into `DatabaseModule`, `FilesModule`, `SharedPreferencesModule`,
    and so on.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StorageModule`：这是存储与持久化相关的依赖的地方。它可以分为 `DatabaseModule`、`FilesModule`、`SharedPreferencesModule`
    等。'
- en: '`ViewModelsModule`: This is where dependencies to `ViewModels` or the `ViewModel`
    factories are stored.'
  id: totrans-178
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModelsModule`：这是存储 `ViewModel` 或 `ViewModel` 工厂依赖的地方。'
- en: '`FeatureModule`: This is where dependencies are organized for a particular
    activity or fragment with their own `ViewModel`. Here, either subcomponents or
    Android injectors are used for this purpose.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FeatureModule`：这是为具有自己 `ViewModel` 的特定活动或片段组织依赖的地方。在这里，可以使用子组件或 Android 注入器来完成此目的。'
- en: We’ve raised some questions about how manual DI can go wrong. Now we have seen
    how Dagger can address these issues. Although it does the job, and it does it
    quickly when it comes to performance, it is also a complex framework with a very
    steep learning curve.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提出了一些关于手动 DI 可能出错的问题。现在我们已经看到 Dagger 如何解决这些问题。尽管它完成了工作，并且在性能方面做得很快，但它也是一个复杂且学习曲线非常陡峭的框架。
- en: Hilt
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Hilt
- en: When we use Dagger in an Android application, there is a bit of boilerplate
    code we are forced to write. Some of it is around dealing with the lifecycles
    of objects linked with Activities and Fragments, which leads us to create subcomponents;
    other parts are around the usage of ViewModels.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Android 应用程序中使用 Dagger 时，我们被迫编写一些模板代码。其中一些是关于处理与 Activities 和 Fragments
    链接的对象的生命周期，这导致我们创建子组件；其他部分是关于 ViewModels 的使用。
- en: An attempt to simplify Dagger for Android was made with the Dagger-Android library,
    but later on, a new library was developed on top of Dagger called **Hilt**. This
    library simplifies much of the Dagger usage through the usage of new annotations,
    which leads to more boilerplate code that can be generated.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化 Android 中的 Dagger，曾尝试使用 Dagger-Android 库，但后来在 Dagger 的基础上开发了一个新的库，称为 **Hilt**。这个库通过使用新的注解简化了大部分的
    Dagger 使用，这导致产生了更多的模板代码，这些代码可以被生成。
- en: 'To use Hilt in a project, we will need the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要在项目中使用 Hilt，我们需要以下内容：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Or depending on how your project uses Gradle, you might need to use the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 或者根据你的项目如何使用 Gradle，你可能需要使用以下内容：
- en: '[PRE44]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: In both cases, you need a plugin to process annotations and a separate plugin
    to process Hilt in your project.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你都需要一个插件来处理注解，以及一个单独的插件来处理项目中的 Hilt。
- en: 'To add Hilt to your project you need the following:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要将 Hilt 添加到你的项目中，你需要以下内容：
- en: '[PRE45]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'The first change Hilt makes is in the `Application` class. Instead of needing
    to invoke a particular Dagger component to be initialized, with Hilt, you can
    just use the `@``HiltAndroidApp` annotation:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: Hilt 首先在 `Application` 类中做出的改变是，不再需要调用特定的 Dagger 组件来初始化，使用 Hilt，你只需使用 `@HiltAndroidApp`
    注解即可：
- en: '[PRE46]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The preceding snippet will let Hilt know the entry point into your application
    and it will start generating the dependency graph.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段将让 Hilt 知道你的应用程序的入口点，并开始生成依赖图。
- en: 'Another benefit of Hilt comes when interacting with Android components such
    as `Activities`, `Fragments`, `Views`, `Services`, and `BroadcastReceivers`. For
    these we can use the `@AndroidEntryPoint` annotation to inject dependencies into
    each of these classes, which looks like the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: Hilt 的另一个好处在于与 Android 组件（如 `Activities`、`Fragments`、`Views`、`Services` 和 `BroadcastReceivers`）交互时。对于这些组件，我们可以使用
    `@AndroidEntryPoint` 注解将依赖注入到每个这些类中，如下所示：
- en: '[PRE47]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the above snippet, the usage of `@AndroidEntryPoint` allows Hilt to inject
    `myObject` into `MyActivity`. A similar approach can be used for injecting dependencies
    into `ViewModels`, through the `@``HiltViewModel` annotation:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`@AndroidEntryPoint` 的使用允许 Hilt 将 `myObject` 注入到 `MyActivity` 中。类似的方法也可以用于通过
    `@HiltViewModel` 注解将依赖注入到 `ViewModels` 中：
- en: '[PRE48]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In the above snippet, the `@HiltViewModel` annotation allows Hilt to inject
    `myObject` into `MyViewModel`. We can also observe the `@Inject` annotation, carried
    over from Dagger, not requiring the usage of modules.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，`@HiltViewModel` 注解允许 Hilt 将 `myObject` 注入到 `MyViewModel` 中。我们还可以观察从
    Dagger 继承而来的 `@Inject` 注解，不需要使用模块。
- en: 'When it comes to modules, Hilt continues the approach from Dagger with one
    minor addition: the usage of the `@InstallIn` annotation. This associates the
    annotated module with a particular component. Hilt provides a set of prebuilt
    components such as `SingletonComponent`, `ViewModelComponent`, `ActivityComponent`,
    `FragmentComponent`, `ViewComponent`, and `ServiceComponent`.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到模块时，Hilt 继续采用 Dagger 的方法，增加了一个小的改进：使用 `@InstallIn` 注解。这会将注解模块与特定的组件关联起来。Hilt
    提供了一系列预构建的组件，例如 `SingletonComponent`、`ViewModelComponent`、`ActivityComponent`、`FragmentComponent`、`ViewComponent`
    和 `ServiceComponent`。
- en: 'Each of these components links the lifecycle of the dependencies inside the
    annotated module to the lifecycles of the application, `ViewModel`, `Activity`,
    `Fragment`, `View`, and `Service`:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件中的每一个都将注解模块中依赖项的生命周期与应用程序、`ViewModel`、`Activity`、`Fragment`、`View` 和 `Service`
    的生命周期相链接：
- en: '[PRE49]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In the preceding snippet, we can see what a `@Module` looks like in Hilt and
    how we can use the `@InstallIn` annotation to specify that `MyObject` lives as
    long as our application lives.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在上述代码片段中，我们可以看到 Hilt 中的 `@Module` 的样子以及我们如何使用 `@InstallIn` 注解来指定 `MyObject`
    的生命周期与我们的应用程序的生命周期相同。
- en: 'When it comes to instrumented tests, Hilt provides useful annotations for changing
    the dependencies for the tests. If we want to take advantage of these features,
    then we need the following dependencies for tests:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到仪器化测试时，Hilt 提供了有用的注解来更改测试的依赖项。如果我们想利用这些功能，那么我们需要以下测试依赖项：
- en: '[PRE50]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'We can then go to our test and introduce Hilt into it as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以进入我们的测试，并按照以下方式引入 Hilt：
- en: '[PRE51]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In the preceding snippet, the `@HiltAndroid` test and `hiltRule` are used to
    swap the dependencies used in the application with the test dependencies. The
    call to inject is what allows us to inject the `MyObject` dependency into the
    test class. To provide the test dependencies, we can write a new module in the
    `androidTest` folder as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用了`@HiltAndroid`测试和`hiltRule`来交换应用程序中使用的依赖项与测试依赖项。注入调用使我们能够将`MyObject`依赖项注入到测试类中。为了提供测试依赖项，我们可以在`androidTest`文件夹中编写一个新的模块，如下所示：
- en: '[PRE52]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Here, we are using the `@TestInstallIn` annotation, which will replace the existing
    `MyModule` from the dependency graph with `MyTestModule`, which can provide a
    different sub-class of the dependency we want to swap.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用`@TestInstallIn`注解，该注解将用`MyTestModule`替换依赖图中现有的`MyModule`，从而提供我们想要交换的依赖项的不同子类。
- en: 'For Hilt to be initialized for the instrumented tests, we will need to define
    a custom test runner to provide a test application from the Hilt library. The
    runner might look like the following:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使Hilt能够初始化用于测试的仪器，我们需要定义一个自定义测试运行器，以从Hilt库提供一个测试应用程序。该运行器可能看起来如下所示：
- en: '[PRE53]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'This runner will need to be registered in `build.gradle` of the module running
    the test:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 此运行器需要在运行测试的模块的`build.gradle`中注册：
- en: '[PRE54]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this section, we studied the Hilt library and its benefits when it comes
    to removing boilerplate code that was required using Dagger.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们研究了Hilt库及其在移除使用Dagger所需的样板代码方面的优势。
- en: Exercise 13.03 – Hilt injection
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.03 – Hilt注入
- en: 'Modify *Exercise 13.02*, *Dagger injection*, such that the `@Component` and
    `@Subcomponent` classes are removed and Hilt is used instead:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 修改*练习13.02*、*Dagger注入*，以便删除`@Component`和`@Subcomponent`类，并使用Hilt：
- en: 'Add the Hilt plugin in the top-level `build.gradle` file:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在顶级`build.gradle`文件中添加Hilt插件：
- en: '[PRE55]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Add the Hilt plugin in `app/build.gradle`:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app/build.gradle`中添加Hilt插件：
- en: '[PRE56]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'In the same file, replace the Dagger dependencies with Hilt dependencies and
    add the fragments extension library used for generating `ViewModel`:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件中，将Dagger依赖项替换为Hilt依赖项，并添加用于生成`ViewModel`的片段扩展库：
- en: '[PRE57]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Delete `ApplicationComponent`, `MainModule`, `MainScope`, and `MainSubcomponent`
    from the project.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目中删除`ApplicationComponent`、`MainModule`、`MainScope`和`MainSubcomponent`。
- en: 'Add the `@InstallIn` annotation to `ApplicationModule`:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`@InstallIn`注解添加到`ApplicationModule`：
- en: '[PRE58]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Remove all the code from inside `RandomApplication` and add the `@HiltAndroid``App`
    annotation:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`RandomApplication`内部删除所有代码并添加`@HiltAndroidApp`注解：
- en: '[PRE59]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Modify `MainViewModel` to add the `@HiltViewModel` and `@``Inject` annotations:'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainViewModel`以添加`@HiltViewModel`和`@Inject`注解：
- en: '[PRE60]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Modify `MainActivity` to instead inject `MainViewModel`, remove all the component
    dependencies that were deleted previously, and add the `@``AndroidEntryPoint`
    annotation:'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`MainActivity`以注入`MainViewModel`，删除之前删除的所有组件依赖项，并添加`@AndroidEntryPoint`注解：
- en: '[PRE61]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The complete code for this step can be found at [https://packt.link/k7hs7](https://packt.link/k7hs7).
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/k7hs7](https://packt.link/k7hs7)找到。
- en: In the preceding snippet, we use the `viewModels` method to obtain the `MainViewModel`
    dependency. This is a mechanism built into the extension functions from `androidx.fragment:fragment-ktx:1.5.5`,
    which will look for factories that will obtain the instance of our `ViewModel`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们使用`viewModels`方法来获取`MainViewModel`依赖项。这是`androidx.fragment:fragment-ktx:1.5.5`扩展函数中内置的一种机制，它将寻找获取我们`ViewModel`实例的工厂。
- en: 'If we run the code, we should see the following output:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行代码，我们应该看到以下输出：
- en: '![Figure 13.4 – Output of exercise 13.03](img/B19411_13_04.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_IMG
  zh: '![图13.4 – 练习13.03的输出](img/B19411_13_04.jpg)'
- en: Figure 13.4 – Output of exercise 13.03
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.4 – 练习13.03的输出
- en: We can see how much we can simplify an application’s code using Hilt instead
    of Dagger. For example, we no longer have to deal with the `@Component` and `@Subcomponent`
    annotated classes and managing subcomponents in the application component, and
    also, we don’t need to manually initialize the dependency graph from the `Application`
    class because Hilt handles this for us. These are some of the main reasons why
    Hilt became the most adopted library for dependency injection in Android applications.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，使用Hilt而不是Dagger可以简化应用程序代码的程度。例如，我们不再需要处理被`@Component`和`@Subcomponent`注解的类，以及在应用程序组件中管理子组件，而且我们也不需要从`Application`类手动初始化依赖图，因为Hilt为我们处理了这一点。这些都是Hilt成为Android应用程序中依赖注入最广泛采用的库的主要原因之一。
- en: Koin
  id: totrans-238
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Koin
- en: Koin is a lighter framework that is suitable for smaller apps. It requires no
    code generation and is built based on Kotlin’s functional extensions. It is also
    a **domain-specific language** (**DSL**). You may have noticed that when using
    Dagger, a lot of code must be written to set up the DI. Koin’s approach to DI
    solves most of those issues, allowing faster integration.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: Koin是一个适合小型应用程序的轻量级框架。它不需要代码生成，并且基于Kotlin的功能扩展构建。它也是一个**领域特定语言**（**DSL**）。您可能已经注意到，当使用Dagger时，必须编写大量代码来设置DI。Koin对DI的方法解决了这些问题中的大多数，允许更快地集成。
- en: 'Koin can be added to your project by adding the following dependency to your
    `build.gradle` file:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将以下依赖项添加到`build.gradle`文件中来将Koin添加到您的项目中：
- en: '[PRE62]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'To set up Koin in your application, you need the `startKoin` call with the
    DSL syntax:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 要在您的应用程序中设置Koin，您需要使用DSL语法调用`startKoin`：
- en: '[PRE63]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Here, you can configure what your application context is (in the `androidContext`
    method), specify property files to define Koin configurations (in `androidFileProperties`),
    state the Logger Level for Koin, which will output in `LogCat` results of Koin
    operations depending on the Level (in the `androidLogger` method), and list the
    modules your application uses. A similar syntax is used to create the modules:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以配置您的应用程序上下文是什么（在`androidContext`方法中），指定属性文件来定义Koin配置（在`androidFileProperties`中），声明Koin的日志级别，这将根据级别（在`androidLogger`方法中）在`LogCat`结果中输出Koin操作的结果，并列出应用程序使用的模块。创建模块时使用类似的语法：
- en: '[PRE64]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: In the preceding example, the two objects will have two different lifecycles.
    When a dependency is provided using the **single** notation, only one instance
    will be used across the entire application lifecycle. This is useful for repositories,
    databases, and API components, where multiple instances will be costly for the
    application.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，两个对象将有两个不同的生命周期。当使用**单例**符号提供依赖项时，整个应用程序生命周期中只会使用一个实例。这对于仓库、数据库和API组件很有用，因为多个实例对应用程序来说成本高昂。
- en: The **factory** notation will create a new object every time an injection is
    performed. This may be useful in situations when an object needs to live as long
    as an activity or fragment.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂**符号将在每次执行注入时创建一个新的对象。在对象需要像活动或片段一样长时间存活的情况下，这可能很有用。'
- en: 'The dependency can be injected using the `by inject()` method or the `get()`
    method, as shown in the following code:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`by inject()`方法或`get()`方法注入依赖项，如下面的代码所示：
- en: '[PRE65]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Koin also offers the possibility of using qualifiers with the help of the `named()`
    method when the module is created. This allows you to provide multiple implementations
    of the same type (for example, providing two or more list objects with different
    content):'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建模块时，Koin还提供了使用`named()`方法添加限定符的可能性。这允许您提供同一类型的多个实现（例如，提供具有不同内容的两个或多个列表对象）：
- en: '[PRE66]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'One of Koin’s main features for Android applications is scopes for activities
    and fragments, and can be defined as shown in the following code snippet:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: Koin为Android应用程序的主要功能之一是活动片段的作用域，如下面的代码片段所示：
- en: '[PRE67]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'The preceding example connects the lifecycle of the `ClassB` dependency to
    the lifecycle of `MainActivity`. In order for you to inject your instance into
    your activity, you will need to extend the `ScopeActivity` class. This class is
    responsible for holding a reference as long as the activity lives. Similar classes
    exist for other Android components such as Fragments (`ScopeFragment`) and services
    (`ScopeService`):'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例将`ClassB`依赖项的生命周期连接到`MainActivity`的生命周期。为了将您的实例注入到活动中，您需要扩展`ScopeActivity`类。这个类负责在活动存活期间保持引用。类似类存在于其他Android组件中，例如片段（`ScopeFragment`）和服务（`ScopeService`）：
- en: '[PRE68]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You can inject the instance into your activity using the `inject()` method.
    This is useful when you wish to limit who gets to access the dependency. In the
    preceding example, if another activity had wanted to access the reference to `ClassB`,
    then it wouldn’t be able to find it in the scope.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用`inject()`方法将实例注入到您的活动中。这在您希望限制谁可以访问依赖项时很有用。在先前的示例中，如果另一个活动想要访问`ClassB`的引用，那么它将无法在作用域中找到它。
- en: 'Another feature that comes in handy for Android is the `ViewModel` injections.
    To set this up, you will need to add the library to `build.gradle`:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Android来说，另一个有用的功能是`ViewModel`注入。要设置此功能，您需要在`build.gradle`中添加库：
- en: '[PRE69]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'If you recall, `ViewModels` require `ViewModelProvider.Factories` in order
    to be instantiated. Koin automatically solves this, allowing `ViewModels` to be
    injected directly and to handle the factory work:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你记得，`ViewModels`需要`ViewModelProvider.Factories`才能实例化。Koin自动解决这个问题，允许`ViewModels`直接注入并处理工厂工作：
- en: '[PRE70]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'To inject the dependency of `ViewModel` into your activity, you can use the
    `viewModel()` method:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 要将`ViewModel`的依赖注入到你的活动中，你可以使用`viewModel()`方法：
- en: '[PRE71]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Alternatively, you can use the method directly:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以直接使用该方法：
- en: '[PRE72]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: As we can see in the preceding setup, Koin takes full advantage of Kotlin’s
    language features and reduces the amount of boilerplate required to define your
    modules and their scopes.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们前面设置中看到的那样，Koin充分利用了Kotlin的语言特性，并减少了定义你的模块及其作用域所需的样板代码量。
- en: Exercise 13.04 – Koin injection
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习13.04 – Koin注入
- en: 'Here, we will write an Android application that will perform DI using Koin.
    The application will be based on *Exercise 13.01*, *Manual injection*, by keeping
    `NumberRepository`, `NumberRepositoryImpl`, `MainViewModel`, and `MainActivity`.
    The following dependencies will be injected:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将编写一个Android应用，该应用将使用Koin执行依赖注入。该应用将基于*练习13.01*，*手动注入*，保留`NumberRepository`，`NumberRepositoryImpl`，`MainViewModel`和`MainActivity`。以下依赖项将被注入：
- en: '`Repository`: As part of a module named `appModule`.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Repository`：作为名为`appModule`的模块的一部分。'
- en: '`MainViewModel`: This will rely on Koin’s specialized implementation for `ViewModels`.
    This will be provided as part of a module named `mainModule` and will have the
    `MainActivity` scope.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MainViewModel`：这将依赖于Koin为`ViewModels`提供的专用实现。这将作为名为`mainModule`的模块的一部分提供，并将具有`MainActivity`的作用域。'
- en: 'Perform the following steps to complete the exercise:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成练习：
- en: 'The app will display a randomly generated number each time a button is clicked.
    Let’s start by adding the Koin libraries:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每次点击按钮时，应用都会显示一个随机生成的数字。让我们先添加Koin库：
- en: '[PRE73]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Next, define the `appModule` variable inside the `RandomApplication` class.
    This will have a similar structure to `AppModule` with the Dagger setup:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在`RandomApplication`类中定义`appModule`变量。这将与Dagger设置中的`AppModule`有类似的结构：
- en: '[PRE74]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let’s add the activity module variable after `appModule`:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在`appModule`之后添加活动模块变量：
- en: '[PRE75]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Next, let’s initialize `Koin` in the `onCreate()` method of `RandomApplication`:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们在`RandomApplication`的`onCreate()`方法中初始化`Koin`：
- en: '[PRE76]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Finally, let’s inject the dependencies into the activity:'
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将依赖注入到活动中：
- en: '[PRE77]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: The complete code for this step can be found at [https://packt.link/0Njdv](https://packt.link/0Njdv).
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤的完整代码可以在[https://packt.link/0Njdv](https://packt.link/0Njdv)找到。
- en: 'If you run the preceding code, the app should work as per the previous examples.
    However, if you check `LogCat`, you will see a similar output to this:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你运行前面的代码，应用应该按照之前的示例工作。然而，如果你检查`LogCat`，你会看到与此类似的输出：
- en: '[PRE78]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'In *Figure 13**.5*, we can see the same output as in previous exercises:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图13.5*中，我们可以看到与之前练习相同的输出：
- en: '![Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated
    number](img/B19411_13_05.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图13.5 – 练习13.04的模拟器输出，显示随机生成的数字](img/B19411_13_05.jpg)'
- en: Figure 13.5 – Emulator output of exercise 13.04 displaying a randomly generated
    number
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图13.5 – 练习13.04的模拟器输出，显示随机生成的数字
- en: As we can see from this exercise, Koin is much faster and easier to integrate,
    especially with its `ViewModel` library. This comes in handy for small projects,
    but its performance will be impacted once projects grow.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从本练习中看到的那样，Koin集成得更快、更简单，特别是与其`ViewModel`库一起使用。这对于小型项目来说很有用，但一旦项目规模扩大，其性能将受到影响。
- en: Activity 13.01 – injected repositories
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动13.01 – 注入仓库
- en: In this activity, you are going to create an app in Android Studio that connects
    to a sample API, [https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts),
    using the Retrofit library and retrieves a list of posts from the web page, which
    will then be displayed on the screen.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将在Android Studio中创建一个应用，该应用通过Retrofit库连接到示例API，[https://jsonplaceholder.typicode.com/posts](https://jsonplaceholder.typicode.com/posts)，从网页上检索帖子列表，然后将其显示在屏幕上。
- en: You will then need to set up a UI test in which you will check whether the data
    is asserted correctly on the screen, but instead of connecting to the actual endpoint,
    you will provide dummy data for the test to display on the screen. You will use
    the DI concept to swap the dependencies using Hilt when the app is executed as
    opposed to when the app is being tested.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要设置一个UI测试，检查数据是否正确地显示在屏幕上，但不是连接到实际端点，而是为测试提供用于在屏幕上显示的虚拟数据。你将使用DI概念，在应用执行时而不是在测试应用时，使用Hilt交换依赖。
- en: 'In order to achieve this, you will need to build the following:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，你需要构建以下内容：
- en: A network component that is responsible for downloading and parsing the JSON
    file
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个负责下载和解析JSON文件的网络组件
- en: A repository that accesses the data from the API layer
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问API层的数据的仓库
- en: A `ViewModel` instance that accesses the Repository
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个访问仓库的`ViewModel`实例
- en: An activity with `RecycleView` that displays the data
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个带有`RecycleView`的活动，用于显示数据
- en: One UI test that will assert the rows and use a dummy object to generate the
    API data
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个UI测试，将断言行并使用虚拟对象生成API数据
- en: Note
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Error handling can be avoided for this activity.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这项活动，可以避免错误处理。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: In Android Studio, create an application with `Empty Activity` (`MainActivity`)
    and add an `api` package where your API calls are stored.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，创建一个带有`Empty Activity`（`MainActivity`）的应用程序，并添加一个`api`包，其中存储你的API调用。
- en: Define a class responsible for the API calls.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个负责API调用的类。
- en: Create a `repository` package.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`repository`包。
- en: Define a `repository` interface with one method, returning `LiveData` with the
    list of posts.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个包含一个方法、返回包含帖子列表的`LiveData`的`repository`接口。
- en: Create the implementation for the `repository` class.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为`repository`类创建实现。
- en: Create a `ViewModel` instance to call the `repository` to retrieve the data.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`ViewModel`实例来调用`repository`以检索数据。
- en: Create an adapter for the rows of the UI.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为UI的行创建适配器。
- en: Create the activity that will render the UI.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建将渲染UI的活动。
- en: Set up a Hilt module that will initialize the network-related dependencies.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置一个初始化网络相关依赖的Hilt模块。
- en: Create a Hilt module that will be responsible for defining the dependencies
    required for the activity.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个负责定义活动所需依赖的Hilt模块。
- en: Set up the UI tests and a test application and provide a separate `RepositoryModule`
    class, which will return a dependency holding dummy data.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置UI测试和测试应用程序，并提供一个单独的`RepositoryModule`类，该类将返回包含虚拟数据的依赖项。
- en: Implement the UI test.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现UI测试。
- en: Note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/3xfkt](https://packt.link/3xfkt).
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在[https://packt.link/3xfkt](https://packt.link/3xfkt)找到。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the concept of DI and how it should be applied
    to separate concerns and prevent objects from having the responsibility of creating
    other objects and how this is of great benefit for testing. We started the chapter
    by analyzing the concept of manual DI. This served as a good example of how DI
    works and how it can be applied to an Android application; it served as the baseline
    when comparing the DI frameworks.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了DI的概念以及它应该如何应用于分离关注点，防止对象承担创建其他对象的责任，以及这对测试的巨大好处。我们通过分析手动DI的概念开始本章；这作为一个很好的例子，说明了DI是如何工作的以及它如何应用于Android应用程序；它作为比较DI框架的基准。
- en: We also analyzed two of the most popular frameworks that help developers inject
    dependencies. We started with a powerful and fast framework called Dagger 2, which
    relies on annotation processors to generate code to perform an injection. We then
    looked at how Hilt reduced the complexity of Dagger for Android applications.
    We also investigated Koin, a lightweight framework written in Kotlin with slower
    performance but simpler integration and a lot of focus on Android components.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还分析了两个最受欢迎的框架，这些框架帮助开发者注入依赖。我们从名为Dagger 2的强大且快速的框架开始，它依赖于注解处理器来生成执行注入的代码。然后我们研究了Hilt如何简化Android应用的Dagger复杂性。我们还调查了Koin，这是一个用Kotlin编写的轻量级框架，性能较慢但集成简单，并且大量关注Android组件。
- en: The exercises in this chapter were intended to explore how the same problem
    can be solved using multiple solutions and compare the degrees of difficulty between
    the solutions. In the activities for this chapter, we leveraged Dagger’s, Hilt’s,
    and Koin’s modules to inject certain dependencies when running the app and other
    dependencies when running the tests on an application that uses `ViewModels`,
    repositories, and APIs to load data.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的练习旨在探索如何使用多种解决方案来解决相同的问题，并比较这些解决方案的难度级别。在本章的活动实践中，我们利用Dagger、Hilt和Koin的模块在运行应用程序时注入某些依赖项，在运行使用`ViewModels`、仓库和API加载数据的应用程序的测试时注入其他依赖项。
- en: This is designed to show the seamless integration of multiple frameworks that
    achieve different goals. In the chapter’s activity, we looked at how we can use
    Hilt to swap dependencies for testing purposes and inject dummy data that we can
    then assert whether it is displayed on the screen.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分旨在展示多个框架无缝集成的过程，这些框架实现不同的目标。在章节的活动中，我们探讨了如何使用Hilt在测试目的下交换依赖项，并注入我们可以断言是否显示在屏幕上的模拟数据。
- en: In the following chapters, you will have the opportunity to build upon the knowledge
    acquired thus far by adding concepts related to threading and how to handle background
    operations. In addition, you will get the opportunity to explore libraries such
    as RxJava and its reactive approach to threading, and you will also learn about
    coroutines, which take a different approach to threading.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，你将有机会通过添加与线程处理和后台操作相关的概念来构建迄今为止获得的知识。此外，你将有机会探索RxJava及其对线程的响应式方法，你还将了解协程，它采用不同的线程处理方法。
- en: You will also observe how coroutines and RxJava can combine very effectively
    with libraries such as Room and Retrofit. Finally, you will be able to combine
    all of these concepts in a robust application that will have a high degree of
    scalability for the future.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你还将观察到协程和RxJava如何与Room和Retrofit等库非常有效地结合。最后，你将能够将这些概念结合到一个健壮的应用程序中，该应用程序将具有很高的未来可扩展性。
- en: 'Part 4: Polishing and Publishing an App'
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4部分：打磨和发布应用
- en: In this part, we will look at how we can load data asynchronously with coroutines
    and flows and how we can integrate them into different architecture patterns,
    which further helps with how we can structure an application’s code.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在这部分中，我们将探讨如何使用协程和流异步加载数据，以及如何将它们集成到不同的架构模式中，这进一步有助于我们如何构建应用程序的代码结构。
- en: Next, we will look at how we can render animations in the user interface with
    `CoordinatorLayout` and `MotionLayout`. Finally, we will learn about the process
    involved in publishing an application on Google Play.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何使用`CoordinatorLayout`和`MotionLayout`在用户界面中渲染动画。最后，我们将了解在Google Play上发布应用程序的过程。
- en: 'We will cover the following chapters in this section:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将涵盖以下章节：
- en: '[*Chapter 14*](B19411_14.xhtml#_idTextAnchor751), *Coroutines and Flow*'
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第14章*](B19411_14.xhtml#_idTextAnchor751)，*协程和流*'
- en: '[*Chapter 15*](B19411_15.xhtml#_idTextAnchor789), *Architecture Patterns*'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第15章*](B19411_15.xhtml#_idTextAnchor789)，*架构模式*'
- en: '[*Chapter 16*](B19411_16.xhtml#_idTextAnchor826), *Animations and Transitions
    with CoordinatorLayout and MotionLayout*'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第16章*](B19411_16.xhtml#_idTextAnchor826)，*使用CoordinatorLayout和MotionLayout进行动画和过渡*'
- en: '[*Chapter 17*](B19411_17.xhtml#_idTextAnchor918), *Launching Your App on Google
    Play*'
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第17章*](B19411_17.xhtml#_idTextAnchor918)，*在Google Play上发布您的应用*'
