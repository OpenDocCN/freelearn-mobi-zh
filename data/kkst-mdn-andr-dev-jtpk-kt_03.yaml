- en: '*Chapter 2*: Handling UI State with Jetpack ViewModel'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：使用 Jetpack ViewModel 处理 UI 状态'
- en: 'In this chapter, we will cover one of the most important libraries in Jetpack:
    `ViewModel` architecture component. We will see what it is, why we need it in
    our apps, and how we can implement one in our Restaurants app, which we started
    in the previous chapter.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们将介绍 Jetpack 中最重要的库之一：`ViewModel` 架构组件。我们将了解它是什么，为什么我们需要在我们的应用中使用它，以及我们如何在上一章开始的项目“Restaurants”中实现它。
- en: In the next section, *Defining and handling state with Compose*, we will study
    how state is managed in Compose and exemplify usages of state inside our project.
    Afterward, in the *Hoisting state in Compose* section, we will understand what
    state hoisting is, why we need to achieve it, and then we will apply it to our
    app.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节 *使用 Compose 定义和处理状态* 中，我们将研究状态在 Compose 中的管理方式，并在我们的项目中展示状态的使用示例。之后，在 *在
    Compose 中提升状态* 部分，我们将了解状态提升是什么，为什么我们需要实现它，然后我们将将其应用到我们的应用中。
- en: Finally, in the *Recovering from system-initiated process death* section, we
    will cover what a system-initiated process death is, how it occurs, and how essential
    it is for our applications to be able to recover from it by restoring the previous
    state details.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 *从系统触发的进程死亡中恢复* 部分，我们将介绍什么是系统触发的进程死亡，它是如何发生的，以及对于我们应用能够通过恢复先前的状态细节来从其中恢复，这是多么重要。
- en: 'To summarize, in this chapter, we''re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在这一章中，我们将涵盖以下主要主题：
- en: Understanding the Jetpack ViewModel
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Jetpack ViewModel
- en: Defining and handling state with Compose
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Compose 定义和处理状态
- en: Hoisting state in Compose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Compose 中提升状态
- en: Recovering from system-initiated process death
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从系统触发的进程死亡中恢复
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入之前，让我们为这一章设置技术要求。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'When building Compose-based Android projects with Jetpack ViewModel, you usually
    require your day-to-day tools. However, to follow along smoothly, make sure you
    have the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用 Jetpack ViewModel 构建基于 Compose 的 Android 项目时，你通常需要你的日常工具。然而，为了顺利跟进，请确保你具备以下条件：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds but note that IDE interface and other
    generated code files might differ from the ones used throughout this book.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1 版本的 Android Studio。你也可以使用更新的 Android Studio 版本，甚至是 Canary
    构建，但请注意，IDE 界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer plugin installed in Android Studio.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Android Studio 中安装了 Kotlin 1.6.10 或更新的插件。
- en: The Restaurants app code from the previous chapter.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的“Restaurants”应用代码。
- en: The starting point for this chapter is represented by the Restaurants app that
    we developed in the previous chapter. If you haven't followed the implementation
    side by side, access the starting point for this chapter by navigating to the
    `Chapter_01` directory of this book's GitHub repository and importing the Android
    project entitled `chapter_1_restaurants_app`.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是我们上一章开发的“Restaurants”应用。如果你没有跟随实现过程，可以通过导航到本书 GitHub 仓库的 `Chapter_01`
    目录并导入名为 `chapter_1_restaurants_app` 的 Android 项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_02`
    folder:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到 `Chapter_02` 文件夹：
- en: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_02/chapter_2_restaurants_app)。'
- en: The project coding solution for the Restaurants app that we will develop throughout
    this chapter can be found in the `chapter_2_restaurants_app` Android project folder,
    which you can import.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中开发的“Restaurants”应用的代码解决方案可以在 `chapter_2_restaurants_app` Android 项目文件夹中找到，你可以导入。
- en: Understanding the Jetpack ViewModel
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Jetpack ViewModel
- en: While developing Android applications, you must have heard of the term **ViewModel**.
    If you haven't heard of it, then don't worry – this section aims to clearly illustrate
    what this component represents and why we need it in the first place.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发 Android 应用程序时，你一定听说过“ViewModel”这个术语。如果你还没有听说过，那么不要担心——本节旨在清楚地说明这个组件代表什么，以及我们为什么一开始就需要它。
- en: 'To summarize, this section will cover the following topics:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，本节将涵盖以下主题：
- en: What is a ViewModel?
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是ViewModel？
- en: Why do you need ViewModels?
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么你需要ViewModels？
- en: Introducing Android Jetpack ViewModel
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Android Jetpack ViewModel
- en: Implementing your first ViewModel
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现你的第一个ViewModel
- en: 'Let''s start with the first question: what is this `ViewModel` that we keep
    hearing about in Android?'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从第一个问题开始：我们一直在Android中听到的这个`ViewModel`是什么？
- en: What is a ViewModel?
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是ViewModel？
- en: Initially, the `ViewModel` was designed to allow developers to persist UI state
    across configuration changes. In time, the `ViewModel` became a way to also recover
    from edge cases such as system-initiated process death.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，`ViewModel`被设计成允许开发者跨配置更改持久化UI状态。随着时间的推移，`ViewModel`成为了一种从边缘情况（如系统启动的进程死亡）中恢复的方法。
- en: However, often, Android apps require you to write code that is responsible for
    getting the data from the server, transforming it, caching it, and then displaying
    it. To delegate some work, developers made use of this separate component, which
    should model the UI (also called the **View**) – the *ViewModel*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常，Android应用需要你编写负责从服务器获取数据、转换它、缓存它，然后显示它的代码。为了委托一些工作，开发者使用了这个单独的组件，该组件应该模拟UI（也称为**View**）——即*ViewModel*。
- en: 'So, we can perceive a `ViewModel` class as a component that manages and caches
    the UI''s state:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以将`ViewModel`类视为一个管理和缓存UI状态的组件：
- en: '![](img/B17788_02_01.jpg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17788_02_01.jpg)'
- en: Figure 2.1 – ViewModel stores the state and receives interactions
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – ViewModel存储状态并接收交互
- en: As we can see, `ViewModel` not only handles the UI state and provides it to
    the UI but also receives user interaction events from `View` and updates the state
    accordingly.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`ViewModel`不仅处理UI状态并将其提供给UI，而且还从`View`接收用户交互事件并相应地更新状态。
- en: In Android, the views are usually represented by `Activity`, `Fragment`, or
    `Composable` since they are intended to display the UI data. These components
    are prone to being recreated when configuration changes occur, so `ViewModel`
    must find a way to cache and then restore the UI state – more on this in the next
    section, *Why do you need ViewModels?*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android中，视图通常由`Activity`、`Fragment`或`Composable`表示，因为它们旨在显示UI数据。这些组件在配置变化发生时容易重新创建，所以`ViewModel`必须找到一种方法来缓存并恢复UI状态——更多内容将在下一节*为什么你需要ViewModels？*中介绍。
- en: Note
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ViewModel` oversees what data is sent back to the UI controllers and how the
    UI state reacts to user-generated events. That''s why we can call `ViewModel`
    as a master of the UI controller – since it represents the authority that performs
    decision-making for UI-related events.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel`监督发送回UI控制器的数据以及UI状态如何对用户生成的事件做出反应。这就是为什么我们可以称`ViewModel`为UI控制器的“大师”——因为它代表了执行UI相关事件决策的权威。'
- en: 'We can try to enumerate some core activities that a `ViewModel` should perform.
    `ViewModel` should be able to do the following:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试列举一些`ViewModel`应该执行的核心活动。`ViewModel`应该能够做到以下几点：
- en: Hold, manage, and preserve the entire UI state.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持、管理和保存整个UI状态。
- en: Request data or reload content from the server or other sources.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从服务器或其他来源请求数据或重新加载内容。
- en: Prepare data to be displayed by applying various transformations (such as map,
    sort, filter, and so on).
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过应用各种转换（如map、sort、filter等）来准备要显示的数据。
- en: Accept user interaction events and change the state based on those events.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受用户交互事件并根据这些事件改变状态。
- en: Even though you now understand what a `ViewModel` is, you might be wondering,
    why do we need a separate class that holds the UI state or that prepares data
    to be displayed? Why can't we do that directly in the UI, in `Activity`, `Fragment`,
    or even inside the Composable? We'll address this question next.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你现在已经理解了什么是`ViewModel`，但你可能还在想，为什么我们需要一个单独的类来保存UI状态或准备要显示的数据？为什么我们不能直接在UI、`Activity`、`Fragment`或Composable中做这件事？我们将在下一节中解答这个问题。
- en: Why do you need ViewModels?
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么你需要ViewModels？
- en: Imagine that we put all the state-handling logic inside the UI classes. Following
    this approach, we may soon add other logic for handling network requests, caching,
    or any other implementation details – everything will be inside the UI layer.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，如果我们把所有状态处理逻辑都放在UI类中。按照这种方法，我们很快就会添加其他逻辑来处理网络请求、缓存或任何其他实现细节——所有这些都会在UI层内部。
- en: Obviously, this is not a great approach. If we do that, we will end up with
    an `Activity`, `Fragment`, or `composable` function that has way too many responsibilities.
    In other words, our UI components will become bloated with so much code and so
    many responsibilities, thus making the entire project difficult to maintain, fix,
    or extend.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这不是一个好的方法。如果我们这样做，最终会得到一个拥有过多责任的 `Activity`、`Fragment` 或 `composable` 函数。换句话说，我们的
    UI 组件将变得臃肿，充斥着大量代码和责任，从而使整个项目难以维护、修复或扩展。
- en: '`ViewModel` is an architecture component that alleviates these potential issues.
    By adding `ViewModel` components to our projects, we are taking the first step
    toward a solid *architecture* since we can delegate the responsibilities of a
    UI controller to components such as `ViewModel`.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 是一个架构组件，可以缓解这些潜在问题。通过将 `ViewModel` 组件添加到我们的项目中，我们迈出了迈向坚实**架构**的第一步，因为我们可以将
    UI 控制器的责任委托给 `ViewModel` 等组件。'
- en: Note
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ViewModel` should not have a reference to a UI controller and should run independently
    of it. This reduces coupling between the UI layer and `ViewModel` and allows multiple
    UI components to reuse the same `ViewModel`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 不应引用 UI 控制器，并且应独立于它运行。这减少了 UI 层与 `ViewModel` 之间的耦合，并允许多个 UI 组件重用相同的
    `ViewModel`。'
- en: Preventing multiple responsibilities in UI controllers is the cornerstone of
    a good system architecture since it promotes a very simple principle called **separation
    of concerns**. This principle states that every component/module within our app
    should have and handle one concern.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 防止 UI 控制器承担多重责任是良好系统架构的基石，因为它促进了一个非常简单的原则，即**关注点分离**。这个原则指出，我们应用中的每个组件/模块都应该有一个并处理一个关注点。
- en: 'If, in our case, we add the entire application logic inside `Activity`, `Fragment`,
    or `composable`, these components will become huge pieces of code that violate
    the separation of concerns principle, simply because they know how to do everything:
    from displaying the UI to getting data and serving their UI states. To alleviate
    this, we can start implementing ViewModels.'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在我们的情况下，我们将整个应用程序逻辑放入 `Activity`、`Fragment` 或 `composable` 中，这些组件将变成巨大的代码块，违反了关注点分离原则，因为它们知道如何做任何事情：从显示
    UI 到获取数据并服务其 UI 状态。为了缓解这个问题，我们可以开始实现 ViewModels。
- en: Next, we'll see how ViewModels are designed in Android.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在 Android 中设计 ViewModels。
- en: Introducing Android Jetpack ViewModel
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍 Android Jetpack ViewModel
- en: Creating a `ViewModel` class to govern the UI state of a `View` is doable and
    straightforward. We can simply create a separate class and move the corresponding
    logic there.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个用于管理 `View` 的 UI 状态的 `ViewModel` 类是可行且直接的。我们只需创建一个单独的类并将相应的逻辑移动到那里。
- en: 'However, as we mentioned previously, UI controllers have their own lifecycle:
    the `Activity` or `Fragment` objects have their own lifecycles, while composables
    have a composition cycle. That''s why UI controllers are usually fragile and end
    up being recreated when different events occur, such as a configuration change
    or a process death. When this happens, any UI state information is lost.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如我们之前提到的，UI 控制器有自己的生命周期：`Activity` 或 `Fragment` 对象有自己的生命周期，而可组合项有自己的组合周期。这就是为什么
    UI 控制器通常是脆弱的，并在发生不同事件（如配置更改或进程死亡）时被重新创建。当这种情况发生时，任何 UI 状态信息都会丢失。
- en: Moreover, UI controllers usually need to make async calls (to obtain data from
    the server, for example) that have to be managed correctly. This means that when
    the system destroys UI controllers (such as by calling `onDestroy()` on an `Activity`),
    you need to manually interrupt or cancel any pending or ongoing work. Otherwise,
    your application can leak memory since your UI controller's memory reference cannot
    be freed up by the system. This is because it's still trying to finish some asynchronous
    work.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，UI 控制器通常需要进行异步调用（例如从服务器获取数据），这些调用必须得到正确管理。这意味着当系统销毁 UI 控制器（例如通过在 `Activity`
    上调用 `onDestroy()`）时，您需要手动中断或取消任何挂起或正在进行的操作。否则，由于您的 UI 控制器的内存引用无法由系统释放，您的应用程序可能会泄漏内存。这是因为它仍在尝试完成一些异步工作。
- en: To preserve the UI state and to manage async work easier, our `ViewModel` class
    should be able to get around these *downsides*. But how?
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保留 UI 状态并更容易管理异步工作，我们的 `ViewModel` 类应该能够克服这些**缺点**。但如何做到呢？
- en: '`ViewModel` is lifecycle aware, this means that it knows how to outlive events
    such as configuration changes, which are triggered by the user.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 具有生命周期感知性，这意味着它知道如何超越由用户触发的配置更改等事件。'
- en: 'It does that by having a *lifecycle scope* tied to the lifecycle of its UI
    controller. Let''s see how the lifecycle of an `Activity` and a `composable` are
    defined as opposed to the one of `ViewModel`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 它通过将一个**生命周期范围**与UI控制器的生命周期绑定来实现这一点。让我们看看`Activity`和`composable`的生命周期是如何定义的，与`ViewModel`的生命周期相比：
- en: '![](img/B17788_02_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_02_02.jpg)'
- en: Figure 2.2 – The ViewModel's lifecycle in comparison to UI controller's lifecycle
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.2 – 与UI控制器生命周期相比的ViewModel生命周期
- en: Important note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: When the `ViewModel` is used in Compose, it lives by default for as long as
    the parent `Fragment` or `Activity` does. For the `ViewModel` to live as long
    as a top-level composable (or screen composable) function does, as shown in the
    previous diagram, the composable must be used in conjunction with a navigation
    library. More granular composables can have smaller lifetimes. Don't worry, we
    will cover the aspect of scoping the lifetime of a ViewModel to the lifetime of
    a screen composable in [*Chapter 5*](B17788_05_ePub.xhtml#_idTextAnchor147), *Adding
    Navigation in Compose with Jetpack Navigation*.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 当在Compose中使用`ViewModel`时，它默认与父`Fragment`或`Activity`的生存期一样长。为了使`ViewModel`的生存期与顶级`composable`（或屏幕`composable`）函数一样长，如前图所示，必须将`composable`与导航库结合使用。更细粒度的`composable`可以具有更短的生存期。不用担心，我们将在[*第5章*](B17788_05_ePub.xhtml#_idTextAnchor147)，*在Compose中使用Jetpack
    Navigation添加导航*中介绍如何将`ViewModel`的生存期范围限定在屏幕`composable`的生存期上。
- en: When the UI is recreated or recomposed because of such events, the `ViewModel`'s
    lifecycle awareness allows it to outlive those events and avoid being destroyed,
    thus allowing the state to be preserved. When the entire lifecycle is finalized,
    the `ViewModel`'s `onCleared()` method is called to allow you to easily clean
    up any pending async work.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当UI因为此类事件被重新创建或重新组合时，`ViewModel`的生命周期感知能力允许它比这些事件存活得更久，避免被销毁，从而允许状态得以保留。当整个生命周期最终结束时，将调用`ViewModel`的`onCleared()`方法，以便你可以轻松地清理任何挂起的异步工作。
- en: 'Yet one question arises: how can the Jetpack ViewModel do that?'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，又出现了一个问题：Jetpack的`ViewModel`是如何做到这一点的？
- en: By design, the `ViewModel` classes outlive specific instantiations of `LifecycleOwners`.
    In our case, UI controllers are `LifecycleOwners` since they have a designated
    lifecycle, and they can be `Activity` or `Fragment` objects.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 按设计，`ViewModel`类比特定实例化的`LifecycleOwner`存活得更久。在我们的例子中，UI控制器是`LifecycleOwner`，因为它们有一个指定的生命周期，并且可以是`Activity`或`Fragment`对象。
- en: 'To understand how `ViewModel` components are scoped to a specific `Lifecycle`,
    let''s have a look at a traditional way of getting a reference to a `ViewModel`
    instance:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解`ViewModel`组件是如何针对特定的`Lifecycle`进行范围划分的，让我们看看获取`ViewModel`实例的传统方法：
- en: '[PRE0]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To obtain an instance of `MyViewModel`, we pass a `ViewModelStoreOwner` to the
    `ViewModelProvider` constructor. We used to get our `ViewModel` like this in `Activity`
    or `Fragment` classes, so this is a reference to the current `ViewModelStoreOwner`.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取`MyViewModel`的实例，我们将一个`ViewModelStoreOwner`传递给`ViewModelProvider`构造函数。我们过去在`Activity`或`Fragment`类中是这样获取我们的`ViewModel`的，所以这是一个对当前`ViewModelStoreOwner`的引用。
- en: To control the lifetime of the instance of our `MyViewModel`, `ViewModelProvider`
    needs an instance of `ViewModelStoreOwner` because when it creates an instance
    of `MyViewModel`, it will link the lifetime of this instance to the lifetime of
    `ViewModelStoreOwner` – that is, of our `Activity`.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 要控制`MyViewModel`实例的生存期，`ViewModelProvider`需要一个`ViewModelStoreOwner`实例，因为当它创建`MyViewModel`的实例时，它将这个实例的生存期与`ViewModelStoreOwner`的生存期绑定——也就是说，与我们的`Activity`的生存期绑定。
- en: The `Activity` or `Fragment` components are `LifecycleOwners` with a lifecycle,
    meaning that every time you get a reference to your `ViewModel`, the object you
    receive is scoped to the `LifecycleOwner`'s lifecycle. This means that your `ViewModel`
    remains alive in memory until the `LifecycleOwner`'s lifecycle is finished.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Activity`或`Fragment`组件是具有生命周期的`LifecycleOwner`，这意味着每次你获取对`ViewModel`的引用时，你收到的对象都是针对`LifecycleOwner`的生命周期进行范围划分的。这意味着你的`ViewModel`将一直存活在内存中，直到`LifecycleOwner`的生命周期结束。'
- en: Note
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: We will explain the inner workings of `ViewModel` components and how they are
    scoped to the lifecycle of a `LifecycleOwner` in more detail in [*Chapter 12*](B17788_12_ePub.xhtml#_idTextAnchor327),
    *Exploring the Jetpack Lifecycle Components*.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在[*第12章*](B17788_12_ePub.xhtml#_idTextAnchor327)，*探索Jetpack生命周期组件*中更详细地解释`ViewModel`组件的内部工作原理以及它们是如何针对`LifecycleOwner`的生命周期进行范围划分的。
- en: In Compose, the `ViewModel` objects are instantiated differently by using a
    special inline function called `viewModel()`, which abstracts all the boilerplate
    code that was needed previously.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Compose 中，使用一个名为 `viewModel()` 的特殊内联函数来实例化 `ViewModel` 对象，该函数抽象了之前需要的所有样板代码。
- en: Note
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Optionally, if you need to pass parameters whose values are decided at runtime
    to your `ViewModel`, you can create and pass a `ViewModelFactory` instance to
    the `viewModel()` constructor. `ViewModelFactory` is a special class that allows
    you to control the way your `ViewModel` is instantiated.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，如果您需要传递在运行时决定值的参数到您的 `ViewModel` 中，您可以在 `viewModel()` 构造函数中创建并传递一个 `ViewModelFactory`
    实例。`ViewModelFactory` 是一个特殊类，它允许您控制 `ViewModel` 的实例化方式。
- en: Now that we have provided an overview of how the Android `ViewModel` works,
    let's create one!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经概述了 Android `ViewModel` 的工作原理，让我们创建一个吧！
- en: Implementing your first ViewModel
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现您的第一个 ViewModel
- en: 'It''s time to create a `ViewModel` inside the Restaurants application that
    we created in the previous chapter. To do this, follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候在上一章中创建的餐厅应用程序中创建一个 `ViewModel` 了。为此，请按照以下步骤操作：
- en: 'First, create a new file by left-clicking the application package, selecting
    `RestaurantsViewModel` as the name and select **File** as the type. Inside the
    newly created file, add the following code:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过左键单击应用程序包，选择 `RestaurantsViewModel` 作为名称，并选择 **文件** 作为类型来创建一个新文件。在新建的文件中，添加以下代码：
- en: '[PRE1]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Our `RestaurantsViewModel` inherits from the `ViewModel` class (previously referenced
    as the Jetpack ViewModel) that's defined in `androidx.lifecycle.ViewModel`, so
    it becomes lifecycle aware of the components that instantiate it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `RestaurantsViewModel` 继承自 `ViewModel` 类（之前被称为 Jetpack ViewModel），该类定义在
    `androidx.lifecycle.ViewModel` 中，因此它能够感知到实例化它的组件的生命周期。
- en: Moreover, we've added the `getRestaurants()` method to our `ViewModel`, allowing
    it to be the provider of our `dummyRestaurants` list – a first and shy step toward
    giving it responsibility for governing the UI state.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们在 `ViewModel` 中添加了 `getRestaurants()` 方法，使其能够成为我们 `dummyRestaurants` 列表的提供者——这是向其赋予管理
    UI 状态责任的第一步和初步尝试。
- en: Next, it's time to prepare to instantiate our `RestaurantsViewModel`. In Compose,
    we can't use the previous syntax for instantiating `ViewModel` objects, so we
    will use a special and dedicated syntax instead.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候准备实例化我们的 `RestaurantsViewModel` 了。在 Compose 中，我们不能使用之前实例化 `ViewModel`
    对象的语法，因此我们将使用一种特殊且专用的语法。
- en: 'To gain access to this special syntax, go to the `build.gradle` file in the
    app module and inside the `dependencies` block, add the ViewModel-Compose dependency:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取此特殊语法，请转到应用程序模块中的 `build.gradle` 文件，并在 `dependencies` 块内添加 ViewModel-Compose
    依赖项：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by clicking on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新 `build.gradle` 文件后，请确保将您的项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **同步项目与
    Gradle 文件** 来完成此操作。
- en: 'Going back to the `RestaurantsScreen` file, we want to instantiate our `RestaurantsViewModel`
    inside our `RestaurantsScreen` composable function. We can do this using the `viewModel()`
    inline function syntax and specifying the type of `ViewModel` that we expect;
    that is, `RestaurantsViewModel`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 回到 `RestaurantsScreen` 文件，我们希望在 `RestaurantsScreen` 可组合函数内部实例化 `RestaurantsViewModel`。我们可以通过使用
    `viewModel()` 内联函数语法并指定我们期望的 `ViewModel` 类型来实现这一点；即 `RestaurantsViewModel`：
- en: '[PRE3]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Behind the scenes, the `viewModel()` function gets the default `ViewModelStoreOwner`
    for our `RestaurantsScreen()` composable. Since we haven't implemented a navigation
    library, the default `ViewModelStoreOwner` will be the calling parent of our composable
    – the `MainActivity` component. This means that for now, even though our `RestaurantsViewModel`
    has been instantiated inside a composable, it will live for as long as our `MainActivity`
    does.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在幕后，`viewModel()` 函数获取 `RestaurantsScreen()` 可组合组件的默认 `ViewModelStoreOwner`。由于我们尚未实现导航库，默认的
    `ViewModelStoreOwner` 将是我们的可组合组件的调用父组件——`MainActivity` 组件。这意味着，目前，尽管我们的 `RestaurantsViewModel`
    已在可组合组件内部实例化，但它将像 `MainActivity` 一样持续存在。
- en: In other words, our `RestaurantsViewModel` is scoped to the lifecycle of our
    `MainActivity`, thereby outliving our `RestaurantsScreens` composable, or any
    other composable we would pass to the `setContent()` method call from within `MainActivity`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们的 `RestaurantsViewModel` 的作用域是 `MainActivity` 的生命周期，因此它比 `RestaurantsScreens`
    可组合组件或任何其他我们通过 `MainActivity` 内部的 `setContent()` 方法调用传递给的可组合组件存在的时间更长。
- en: To make sure that our `ViewModel` lives for as long as the composable function
    that needs it does, we will implement a navigation library in [*Chapter 5*](B17788_05_ePub.xhtml#_idTextAnchor147),
    *Adding Navigation in Compose with Jetpack Navigation*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保我们的`ViewModel`在需要它的可组合函数存在期间保持活跃，我们将在[*第5章*](B17788_05_ePub.xhtml#_idTextAnchor147)中实现导航库，*在Compose中使用Jetpack
    Navigation添加导航*。
- en: We also made sure that we now get the restaurants to be displayed from our `RestaurantsViewModel`
    by calling `getRestaurants()` on the `viewModel` variable.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确保现在通过在`viewModel`变量上调用`getRestaurants()`来从我们的`RestaurantsViewModel`获取要显示的餐厅。
- en: Note
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: From this point on, on certain older Compose versions, the Compose Preview functionality
    might not work as expected anymore. As the `RestaurantsScreen` composable now
    depends on a `RestaurantsViewModel` object, Compose can fail to infer the data
    that is passed to the previewed composable, thereby not being able to show us
    the content. That's why directly referencing a `ViewModel` inside your screen
    composable isn't a good practice. We will fix this in [*Chapter 8*](B17788_08_ePub.xhtml#_idTextAnchor285),
    *Getting Started with Clean Architecture in Android*. Alternatively, to see any
    changes in your code, you can just run the application on your emulator or physical
    device.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，在某些较旧的Compose版本中，Compose预览功能可能不再按预期工作。由于`RestaurantsScreen`可组合函数现在依赖于`RestaurantsViewModel`对象，Compose可能无法推断传递给预览可组合函数的数据，因此无法显示内容。这就是为什么在屏幕可组合函数中直接引用`ViewModel`不是一种好做法。我们将在[*第8章*](B17788_08_ePub.xhtml#_idTextAnchor285)中修复这个问题，*在Android中使用Clean
    Architecture入门*。或者，为了查看代码中的任何更改，您可以直接在模拟器或物理设备上运行应用程序。
- en: Getting back to our Restaurants app, we have successfully added a `ViewModel`,
    yet our `RestaurantsViewModel` doesn't handle any state for our UI. It only sends
    a hardcoded list of restaurants, which has no state. We envisioned that its purpose
    is to govern the state of the UI, so let's take a break from `ViewModel` and work
    on understanding state.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的餐厅应用程序，我们已经成功添加了一个`ViewModel`，但我们的`RestaurantsViewModel`并没有处理任何UI状态。它只发送一个硬编码的餐厅列表，没有任何状态。我们设想它的目的是管理UI的状态，所以让我们暂时放下`ViewModel`，专注于理解状态。
- en: Defining and handling state with Compose
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Compose定义和处理状态
- en: State and events are essential to any application since their existence implies
    that the UI can change over time as you interact with it.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 状态和事件对于任何应用程序都是基本的，因为它们的存续意味着UI可以随着您的交互而随时间改变。
- en: In this section, we will cover the concept of state and events and then integrate
    them into our Restaurants app.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍状态和事件的概念，然后将它们集成到我们的餐厅应用程序中。
- en: 'To summarize, this section will cover the following topics:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 总结，本节将涵盖以下主题：
- en: Understanding state and events
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解状态和事件
- en: Adding state to our Restaurants app
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的餐厅应用程序添加状态
- en: Let's start by exploring the basic concepts of state and events in Android applications.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从探索Android应用程序中状态和事件的基本概念开始。
- en: Understanding state and events
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解状态和事件
- en: '**State** represents a possible form of the UI at a certain point in time.
    This form can change or mutate. When the user interacts with the UI, an event
    is created that triggers a change in the state of the UI. So, an **event** is
    represented by different interactions that are initiated by the user that target
    the app and that consequently cause its state to update.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**状态**代表在某个时间点UI的可能形式。这种形式可以改变或变异。当用户与UI交互时，会创建一个事件，该事件触发UI状态的改变。因此，**事件**由用户发起的不同交互表示，这些交互针对应用程序，并导致其状态更新。'
- en: 'In simple terms, state changes over time because of events. The UI, on the
    other hand, should observe the changes within the state so that it can update
    accordingly:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，状态因事件而随时间变化。另一方面，UI应该观察状态中的变化，以便相应地更新：
- en: '![](img/B17788_02_03.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_02_03.jpg)'
- en: Figure 2.3 – UI update flow
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – UI更新流程
- en: In Compose, composable functions are, by default, stateless. That's why, when
    we tried to use a `TextField` composable in the previous chapter, it didn't present
    anything to the UI that we typed in with the keyboard. This happened because the
    composable had no state defined and it didn't get recomposed with the new values
    that had to be displayed!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在Compose中，默认情况下，可组合函数是无状态的。这就是为什么当我们试图在前一章中使用`TextField`可组合函数时，它没有将我们在键盘上输入的内容显示在UI上。这是因为可组合函数没有定义状态，并且它没有与新值重新组合以显示新内容！
- en: This is why, in Compose, it's our job to define state objects for our composables.
    With the help of *state* objects, we make sure that recomposition is triggered
    every time a state object's value is changed.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么在 Compose 中，我们的任务是定义我们可组合组件的状态对象。借助 *状态* 对象，我们确保每次状态对象的值发生变化时都会触发重新组合。
- en: 'To make such a `TextField` display the text that we are typing in, remember
    that we added a `textState` variable. Our `TextField` needed such a state object
    that holds a `String` value. This value represents the text that''s written by
    us, which can change as we keep on typing:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这样的 `TextField` 显示我们正在输入的文本，请记住我们添加了一个 `textState` 变量。我们的 `TextField` 需要这样一个包含
    `String` 值的状态对象。这个值代表我们输入的文本，它可以随着我们继续输入而改变：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Let''s have a closer look at how we defined a state object for our `TextField`:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们是如何定义我们的 `TextField` 的状态对象的：
- en: First, we created a variable to hold our state object and made sure that its
    value can change over time by making it `MutableState`. We did that by defining
    a `textState` variable that is of type `MutableState`, which, in turn, holds data
    of type `String`.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们创建了一个变量来保存我们的状态对象，并确保其值可以随时间改变，通过将其定义为 `MutableState`。我们通过定义一个类型为 `MutableState`
    的 `textState` 变量来实现这一点，它反过来又持有类型为 `String` 的数据。
- en: At its core, `textState` is a `androidx.compose.runtime.State` object, yet since
    we want to be able to change its value over time, we directly used a `MutableState`
    that implements `State`.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，`textState` 是一个 `androidx.compose.runtime.State` 对象，但由于我们希望能够在时间上改变其值，我们直接使用了一个实现了
    `State` 接口的 `MutableState`。
- en: 'We instantiated `textState` with the `mutableStateOf("")` constructor to create
    a state object and passed an initial value of the data that it holds: an empty
    string.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用 `mutableStateOf("")` 构造函数实例化了 `textState` 以创建一个状态对象，并传递了它所持有的数据的初始值：一个空字符串。
- en: We also wrapped the `mutableStateOf("")` constructor inside a `remember { }`
    block. The `remember` block.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在 `remember { }` 块内部包装了 `mutableStateOf("")` 构造函数。`remember` 块。
- en: 'Now that we''ve covered how state objects are defined, some questions remain:
    how can we alter the state to retrigger recomposition and how can we make sure
    our `TextField` accesses the updated values from our `textState`? Let''s add these
    missing pieces:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经涵盖了如何定义状态对象，一些问题仍然存在：我们如何更改状态以重新触发重新组合，以及我们如何确保我们的 `TextField` 访问来自 `textState`
    的更新值？让我们添加这些缺失的部分：
- en: '[PRE5]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Let''s have a closer look at how we wired everything up inside `TextField`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看我们如何在 `TextField` 内部连接一切：
- en: For `TextField` to always have access to the latest value of the `textState`
    state object, we obtained the current state value with the `.value` accessor using
    `textState.value`. Then, we passed it to the `TextField`'s `value` parameter to
    display it.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为了使 `TextField` 总是能够访问 `textState` 状态对象的最新值，我们使用 `textState.value` 通过 `.value`
    访问器获取当前状态值，然后将其传递给 `TextField` 的 `value` 参数以显示它。
- en: To change the state value, we made use of the `onValueChange` callback, which
    can be portrayed as an *event*. Inside this callback, we updated the `textState`
    state value by using the same `.value` accessor and set the new value that was
    received, called `newValue`. Since we updated a `State` object, the UI should
    recompose and our `TextField` should render the new input value from the keyboard.
    This will repeat for as long as we keep on writing.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改状态值，我们使用了 `onValueChange` 回调，这可以被视为一个 *事件*。在这个回调内部，我们通过使用相同的 `.value` 访问器来更新
    `textState` 状态值，并设置接收到的新的值，称为 `newValue`。由于我们更新了一个 `State` 对象，UI 应该重新组合，我们的 `TextField`
    应该渲染从键盘输入的新输入值。只要我们继续写作，这个过程就会重复。
- en: Now that we have got the hang of defining and altering state in Compose, it's
    time to add such state functionality to our Restaurants app.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经掌握了在 Compose 中定义和修改状态的方法，是时候将这种状态功能添加到我们的餐厅应用中了。
- en: Adding state to our Restaurants app
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将状态添加到我们的餐厅应用中
- en: 'Let''s imagine that the user can scroll through the list of restaurants and
    then tap a particular one, thereby marking it as a favorite. For this to be more
    suggestive, we will add a heart icon for each restaurant. To do this, follow these
    steps:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，用户可以滚动浏览餐厅列表，然后点击特定的一个，从而将其标记为收藏。为了使这个过程更具提示性，我们将为每个餐厅添加一个爱心图标。为此，请按照以下步骤操作：
- en: 'Inside the `RestaurantsScreen.kt` file, add another composable inside `RestaurantItem`
    called `FavoriteIcon`. Then, pass a weight of `0.15f` to make it occupy 15% of
    the parent `Row`:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreen.kt` 文件中，在 `RestaurantItem` 内部添加另一个可组合组件，称为 `FavoriteIcon`。然后传递一个权重
    `0.15f` 以使其占用父 `Row` 的 15%。
- en: '[PRE6]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We have also made sure to decrease the weight of `RestaurantDetails` from 85%
    to 70%.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还确保将 `RestaurantDetails` 的权重从 85% 降低到 70%。
- en: 'Still inside the `RestaurantsScreen.kt` file, define the missing `FavoriteIcon`
    composable, which receives an `imageVector` as a predefined icon with `Icons.Filled.FavoriteBorder`.
    Also, make it receive a `Modifier` object with `8.dp` of padding:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在 `RestaurantsScreen.kt` 文件中，定义缺失的 `FavoriteIcon` 组合组件，该组件接收一个 `imageVector`
    作为预定义图标 `Icons.Filled.FavoriteBorder`。同时，让它接收一个具有 `8.dp` 填充的 `Modifier` 对象：
- en: '[PRE7]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'If we try to refresh the preview or run the app, we can see several `RestaurantItem`
    composables similar to the following:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们尝试刷新预览或运行应用，我们可以看到几个类似于以下的 `RestaurantItem` 组合组件：
- en: '![](img/B17788_02_04.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_02_04.jpg)'
- en: Figure 2.4 – The RestaurantItem composable with a favorite icon
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 带有收藏图标的 RestaurantItem 组合组件
- en: Our `RestaurantItem` composable now has a favorite icon. However, when we click
    it, nothing happens. Clicking it should change the heart icon into a filled one,
    marking the restaurant as a favorite. To fix this, we must add a state that allows
    us to hold the favorite status of a restaurant.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `RestaurantItem` 组合组件现在有一个收藏图标。然而，当我们点击它时，什么也没有发生。点击它应该将心形图标变为实心，标记餐厅为收藏。为了修复这个问题，我们必须添加一个状态，使我们能够保持餐厅的收藏状态。
- en: 'Add state to the `FavoriteIcon` composable by adding the following code:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下代码向 `FavoriteIcon` 组合组件添加状态：
- en: '[PRE8]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'To hold the state of being a favorite or not and to trigger a change in this
    state value, we''ve done the following:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持是否收藏的状态并触发这个状态值的改变，我们做了以下操作：
- en: We added a `favoriteState` variable that holds a `MutableState` of type `Boolean`
    with an initial value of `false`. As usual, we wrap the `mutableStateOf` constructor
    inside a `remember` block to preserve the state's value across recompositions.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `favoriteState` 变量，它持有类型为 `Boolean` 的 `MutableState`，初始值为 `false`。像往常一样，我们将
    `mutableStateOf` 构造函数包裹在一个 `remember` 块中，以在重新组合之间保留状态值。
- en: We defined an `icon` variable that can hold a value of `Icons.Filled.Favorite`,
    which means that the restaurant is your favorite, or a value of `Icons.Filled.FavoriteBorder`,
    which means that the restaurant is not your favorite.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们定义了一个 `icon` 变量，它可以持有 `Icons.Filled.Favorite` 的值，这意味着该餐厅是您的收藏，或者持有 `Icons.Filled.FavoriteBorder`
    的值，这意味着该餐厅不是您的收藏。
- en: We passed the value of `icon` value to the `imageVector` parameter of our `Image`
    composable.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将 `icon` 值传递给 `Image` 组合组件的 `imageVector` 参数。
- en: We added a `clickable` modifier that's chained after the `padding` one. In this
    callback, we made sure to update `favoriteState` with the `.value` accessor by
    obtaining it and writing the previously negated value.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们添加了一个 `clickable` 修饰符，它在 `padding` 修饰符之后链式使用。在这个回调中，我们确保通过获取并写入先前取反的值来更新 `favoriteState`。
- en: Note
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'When defining state objects in Compose, you can replace the assignment (`=`)
    operator with property delegation, which can be achieved with the `by` operator:
    `val favoriteState by remember { … }`. By doing this, you will not need to use
    the `.value` accessor anymore as it is delegated.'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 Compose 中定义状态对象时，可以用属性委托替换赋值运算符（`=`），这可以通过 `by` 运算符实现：`val favoriteState by
    remember { … }`。通过这样做，您将不再需要使用 `.value` 访问器，因为它被委托了。
- en: 'When we''re running or live previewing the application, we can see that upon
    clicking the empty heart icon of each restaurant, it becomes filled, marking the
    restaurant as a favorite:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在运行或实时预览应用程序时，我们可以看到，当我们点击每个餐厅的空心形图标时，它变成了实心，标记餐厅为收藏：
- en: '![](img/B17788_02_05.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_02_05.jpg)'
- en: Figure 2.5 – The RestaurantsScreen composable with a favorite state for its
    items
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 带有项目收藏状态的 RestaurantsScreen 组合组件
- en: Most of the time, keeping state and state handling logic inside composable functions
    is not recommended. Let's explore why this is not the best practice and how we
    can improve the way we manage state with the help of state hoisting.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，不建议在组合函数内部保持状态和处理状态逻辑。让我们探讨为什么这不是最佳实践，以及我们如何借助状态提升来改进我们管理状态的方式。
- en: Hoisting state in Compose
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Compose 中提升状态
- en: 'Composable functions are usually categorized in terms of state handling in
    two main categories:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 组合函数通常根据状态处理分为两大类：
- en: '`State` object.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`State` 对象。'
- en: '`ViewModel` component can be the only source of truth for their state to control
    and manage UI changes but also to avoid illegal states.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel` 组件可以是它们状态的唯一真相来源，以控制和管理 UI 变化，同时避免非法状态。'
- en: In our case, state changes when a restaurant is marked as a favorite or not.
    Since we want to control this interaction at the presentation level in the `ViewModel`
    class to keep track of which restaurants have been favorited, we need to move
    the state up from the `FavoriteIcon` composable.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，当餐厅被标记为收藏或未收藏时，状态会发生变化。由于我们希望在`ViewModel`类中控制这种交互以跟踪哪些餐厅已被收藏，因此我们需要将状态从`FavoriteIcon`可组合组件提升上来。
- en: 'The pattern of moving state up from a composable to its caller composable is
    called `State` object with two parameters:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 将状态从可组合组件向上移动到其调用者可组合组件的模式被称为具有两个参数的`状态`对象：
- en: One `value` parameter for the data that defines the current state
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个用于定义当前状态的`value`参数
- en: A callback function that is triggered as an event when a new value is emitted
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当发出新值时触发的回调函数
- en: 'By receiving data as input and forwarding events to the parent composable,
    we make sure that our Compose UI obeys the previously introduced concept of the
    unidirectional flow of state and events. This concept defines how state values
    and events should only flow in one direction: the events upwards and the state
    downwards, and with state hoisting, we enforce just that.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过接收数据作为输入并将事件转发给父可组合组件，我们确保我们的 Compose UI 遵循之前引入的状态和事件单向流动的概念。这个概念定义了状态值和事件应该只在一个方向上流动：事件向上流动，状态向下流动，并且通过状态提升，我们强制执行这一点。
- en: 'The benefits of state hoisting are as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 状态提升的好处如下：
- en: '`ViewModel`. Composables can be decoupled from their state to avoid illegal
    states in your UI.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`。可组合组件可以从其状态中解耦，以避免在 UI 中出现非法状态。'
- en: '**Reusability**: Since composables only render the data that''s received as
    input, it''s much easier to reuse them within other composables as you can simply
    pass different values.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性**：由于可组合组件只渲染接收到的输入数据，因此它们在其它可组合组件中的重用要容易得多，因为你只需传递不同的值即可。'
- en: '**Encapsulation limitation**: Only stateful composables can change their state
    internally. This means that you can limit the number of composables that handle
    their state, which could lead to illegal UI states.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**封装限制**：只有有状态的可组合组件可以内部更改其状态。这意味着你可以限制处理其状态的可组合组件的数量，这可能导致非法的 UI 状态。'
- en: 'Now that we''ve briefly covered what state hoisting is and why it is beneficial,
    it''s time to hoist the state within our Restaurants application:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们简要介绍了状态提升的概念及其好处，是时候在我们的 Restaurants 应用程序中提升状态了：
- en: 'First, lift the state from the `FavoriteIcon` composable by removing the existing
    `favoriteState` and `icon` variables along with their instantiation logic from
    the top of the body of the function. At the same time, update the `FavoriteIcon`
    composable to accept an `icon` parameter for receiving input data and also an
    `onClick` event callback for forwarding upwards events:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过从函数体顶部移除现有的`favoriteState`和`icon`变量及其实例化逻辑，将状态从`FavoriteIcon`可组合组件提升出来。同时，更新`FavoriteIcon`可组合组件以接受一个`icon`参数来接收输入数据，以及一个`onClick`事件回调来向上转发事件：
- en: '[PRE9]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Additionally, we passed `icon` to the `imageVector` parameter of the `Image`
    composable and triggered the `onClick` callback function whenever the `clickable`
    event is triggered. By applying these changes, we lifted the state up and transformed
    `FavoriteIcon` from a stateful composable into a stateless one.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将`icon`传递给`Image`可组合组件的`imageVector`参数，并在`clickable`事件触发时调用`onClick`回调函数。通过应用这些更改，我们将状态提升上来，并将`FavoriteIcon`从有状态的组件转换为无状态的组件。
- en: 'Now, move the `favoriteState` variable in the `RestaurantItem` parent composable
    of `FavoriteIcon`. The `RestaurantItem` composable provides the state to `FavoriteIcon`
    and is also in charge of updating its state over time:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将`favoriteState`变量移动到`FavoriteIcon`的父可组合组件`RestaurantItem`中。`RestaurantItem`可组合组件为`FavoriteIcon`提供状态，并负责随时间更新其状态：
- en: '[PRE10]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The corresponding `icon` for each state is now passed to `FavoriteIcon`. Additionally,
    `RestaurantItem` is now listening for `onClick` events in the trailing lambda
    block, where it mutates the `favoriteState` object, triggering recomposition upon
    every click.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 每个状态的对应`图标`现在传递给`FavoriteIcon`。此外，`RestaurantItem`现在在尾随的 lambda 块中监听`onClick`事件，在该事件中它修改`favoriteState`对象，每次点击都会触发重新组合。
- en: Yet, looking at `FavoriteIcon` and `RestaurantIcon`, we can see many similarities.
    Both are stateless composables that receive an `ImageVector` as a parameter. Since
    they are stateless and perform similar functions, let's reuse one of them and
    delete the other.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，查看`FavoriteIcon`和`RestaurantIcon`，我们可以看到许多相似之处。它们都是无状态的组合组件，接收一个`ImageVector`作为参数。由于它们是无状态的并且执行类似的功能，让我们重用其中一个并删除另一个。
- en: 'Inside `RestaurantIcon`, add a similar `onClick` function parameter (just like
    `FavoriteIcon` has) and bind it to the `clickable` modifier''s callback:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantIcon`内部，添加一个类似的`onClick`函数参数（就像`FavoriteIcon`有的一样）并将其绑定到`clickable`修饰符的回调：
- en: '[PRE11]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Since we don't want to execute anything on click events for the restaurant profile
    icon, we provided a default empty function (`{ }`) value to the `onClick` parameter.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们不想在餐厅配置文件图标上执行点击事件，我们为`onClick`参数提供了一个默认的空函数（`{ }`）值。
- en: Once you've done this, you can delete the `FavoriteIcon` composable since we
    won't need it anymore.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，你可以删除`FavoriteIcon`组合组件，因为我们不再需要它了。
- en: 'Inside the `RestaurantItem` composable, replace `FavoriteIcon` with `RestaurantIcon`:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantItem`组合组件内部，将`FavoriteIcon`替换为`RestaurantIcon`：
- en: '[PRE12]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You have now hoisted the state from `RestaurantIcon` to the `RestaurantItem`
    composable.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经将状态从`RestaurantIcon`提升到了`RestaurantItem`组合组件。
- en: Let's keep on hoisting the state even further uphill, into the `RestaurantsScreen`
    composable. However, we cannot keep individual `State` objects for each `RestaurantItem`
    inside this composable, so we will have to change the `State` object to hold a
    list of `Restaurant` objects, each having a separate `isFavorite` value.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续提升状态，将其提升到`RestaurantsScreen`组合组件。然而，我们无法在这个组合组件内部为每个`RestaurantItem`保留单独的`State`对象，因此我们必须将`State`对象更改为包含一系列`Restaurant`对象，每个对象都有一个单独的`isFavorite`值。
- en: 'Inside the `Restaurant.kt` file, add another property for `Restaurant` called
    `isFavorite`. It should have a default value of `false` since, by default, restaurants
    are not marked as favorites when the application starts:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Restaurant.kt`文件内部，为`Restaurant`添加另一个属性`isFavorite`。它应该有一个默认值`false`，因为默认情况下，当应用程序启动时，餐厅不会被标记为收藏：
- en: '[PRE13]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Going back inside the `RestaurantsScreen.kt` file, hoist the state up again,
    this time from `RestaurantItem`, by adding an `onClick` function parameter that''s
    triggered inside the `RestaurantIcon`''s callback function parameter. We won''t
    add a new argument for the input data since we already have the `item` argument
    of type `Restaurant`, and you can also safely remove the `favoriteState` variable
    since we won''t be needing it anymore:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到`RestaurantsScreen.kt`文件内部，再次提升状态，这次是从`RestaurantItem`开始的，通过添加一个在`RestaurantIcon`的回调函数参数内部被触发的`onClick`函数参数。由于我们已经有类型为`Restaurant`的`item`参数，因此我们不需要为输入数据添加新的参数，并且可以安全地移除`favoriteState`变量，因为我们不再需要它了：
- en: '[PRE14]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This time, the `item` parameter will be our `Restaurant` object. `Restaurant`
    now holds an `isFavorite: Boolean` property that states whether the restaurant
    is favorited or not. That''s why we set the correct value for the `icon` variable
    based on the item''s field by checking the `item.isFavorite` value.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '这次，`item`参数将是我们的`Restaurant`对象。`Restaurant`现在包含一个`isFavorite: Boolean`属性，表示餐厅是否被收藏。这就是为什么我们根据项的字段设置`icon`变量的正确值，通过检查`item.isFavorite`的值。'
- en: Now, `RestaurantItem` is a stateless composable, so it's time to add a `State`
    object to its parent.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`RestaurantItem`是一个无状态的组合组件，因此是时候向其父组件添加一个`State`对象了。
- en: 'Inside `RestaurantsScreen`, add a `state` variable that will hold our list
    of restaurants. Its type will be `MutableState<List<Restaurant>>` and we will
    set the restaurants from `viewModel` as it initial value, finally passing the
    state''s `value` to the `items` constructor of `LazyColumn`:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen`内部，添加一个`state`变量，它将保存我们的餐厅列表。其类型将是`MutableState<List<Restaurant>>`，我们将从`viewModel`设置餐厅作为其初始值，最后将状态对象的`value`传递给`LazyColumn`的`items`构造函数：
- en: '[PRE15]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside `RestaurantItem`''s `onClick` trailing lambda block, we must toggle
    the favorite status of the corresponding restaurant and update the state. Because
    of this, we did the following:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RestaurantItem`的`onClick`尾随lambda块内部，我们必须切换相应餐厅的收藏状态并更新状态。正因为如此，我们做了以下操作：
- en: We obtained the current list of restaurants by calling `state.value` and converting
    it into a mutable list so that we could replace the item whose `isFavorite` field's
    value should be updated.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过调用`state.value`并将其转换为可变列表来获取当前的餐厅列表，以便我们可以替换需要更新`isFavorite`字段值的项。
- en: We obtained the index of the item whose `isFavorite` field should be updated
    via the `indexOfFirst` function, where we matched the `id` property of the `Restaurant`
    objects.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们通过`indexOfFirst`函数获得了应该更新`isFavorite`字段的项的索引，其中我们匹配了`Restaurant`对象的`id`属性。
- en: Having found `itemIndex`, we obtained the `item` object of type `Restaurant`
    and applied the `copy()` constructor, where we negated the `isFavorite` field.
    The resulting value replaced the existing `item` at `itemIndex`.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到`itemIndex`后，我们获得了类型为`Restaurant`的`item`对象，并应用了`copy()`构造函数，其中我们取反了`isFavorite`字段。结果值替换了`itemIndex`处的现有`item`。
- en: Finally, we passed the updated `restaurants` list back to the `state` object
    with the `.value` accessor.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们使用`.value`访问器将更新后的`restaurants`列表返回给`state`对象。
- en: Note
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: For Compose to observe changes within a list of objects of type `T` called `List<T>,`
    where `T` is a data class, you must update the memory reference of the updated
    item. You can do that by calling the `copy()` constructor of `T` so that when
    the updated list is passed back to your `State` object, Compose triggers a recomposition.
    Alternatively, you can use `mutableStateListOf<Restaurant>()` to have easier recomposition
    events triggered.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于`Compose`要观察类型为`T`的对象列表中的变化，其中`T`是一个数据类，称为`List<T>`，你必须更新更新项的内存引用。你可以通过调用`T`的`copy()`构造函数来实现这一点，这样当更新的列表返回到你的`State`对象时，`Compose`会触发重组。或者，你可以使用`mutableStateListOf<Restaurant>()`来更容易地触发重组事件。
- en: If we try to run the app, we should notice that the functionality is the same,
    yet the state was hoisted and that we can now reuse composables such as `RestaurantItem`
    or `RestaurantIcon` much easier.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行应用程序，我们应该注意到功能相同，但状态已经提升，我们现在可以更容易地重用`RestaurantItem`或`RestaurantIcon`等可组合组件。
- en: But what happens if we toggle a couple of restaurants that are favorites and
    then rotate the device, thereby changing the screen orientation?
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们切换了几家收藏餐厅，然后旋转设备，从而改变屏幕方向会发生什么呢？
- en: Even though we used the `remember` block to preserve the state across recompositions,
    our selections were lost, and all the restaurants are marked as not favorites
    again. This is because the `MainActivity` host of our `RestaurantsScreen` composable
    has been recreated, so any state was also lost when the configuration change occurred.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们使用了`remember`块来在重组之间保留状态，但我们的选择丢失了，所有餐厅都被标记为非收藏。这是因为我们的`RestaurantsScreen`可组合组件的宿主`MainActivity`已被重新创建，因此当配置更改发生时，任何状态也丢失了。
- en: 'To fix this, we can do the following:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们可以做以下操作：
- en: Replace the `remember` block with `rememberSaveable`. This will allow the state
    to be automatically saved across configuration changes of the host `Activity`.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`remember`块替换为`rememberSaveable`。这将允许状态在宿主`Activity`的配置更改之间自动保存。
- en: Hoist the state to `ViewModel`. We know that `RestaurantsViewModel` is not scoped
    to the lifecycle of our `RestaurantsScreen` yet since no navigation library was
    used, so this means it's scoped to `MainActivity`, which allows it to survive
    configuration changes.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将状态提升到`ViewModel`。我们知道`RestaurantsViewModel`尚未限定于我们的`RestaurantsScreen`的生命周期，因为尚未使用导航库，这意味着它限定于`MainActivity`，这允许它在配置更改中存活。
- en: 'You can try replacing the `remember` block with `rememberSaveable` and then
    rotate the screen to see that the state is now preserved across configuration
    changes. However, we want to take the high road and make sure `ViewModel` is the
    only source of truth for our state. Let''s get started:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试将`remember`块替换为`rememberSaveable`，然后旋转屏幕以查看状态现在在配置更改之间得到了保留。然而，我们希望走正道，确保`ViewModel`是我们状态的唯一真相来源。让我们开始吧：
- en: 'To lift the state to `ViewModel`, we must move the `State` object from the
    `RestaurantsScreen` composable to the `RestaurantsViewModel` and we must also
    create a new method called `toggleFavorite` that will allow the `RestaurantsViewModel`
    to mutate the value of the `state` variable every time we try to toggle the favorite
    status of a restaurant:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将状态提升到`ViewModel`，我们必须将`State`对象从`RestaurantsScreen`可组合组件移动到`RestaurantsViewModel`，并且我们必须创建一个新的方法`toggleFavorite`，该方法将允许`RestaurantsViewModel`在尝试切换餐厅的收藏状态时每次都修改`state`变量的值：
- en: '[PRE16]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The new method called `toggleFavorite` accepts the `id` property of the targeted
    restaurant. Inside this method, we moved the code from the `RestaurantItem`'s
    `onClick` trailing lambda block, where we toggle the favorite status of the corresponding
    item and update its state.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 新的`toggleFavorite`方法接受目标餐厅的`id`属性。在这个方法内部，我们将`RestaurantItem`的`onClick`尾随lambda块中的代码移动出来，在那里我们切换对应项的收藏状态并更新其状态。
- en: By this time, you can safely remove the `getRestaurants()` method from the `RestaurantsViewModel`
    class since we won't be needing it anymore.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可以安全地从`RestaurantsViewModel`类中移除`getRestaurants()`方法，因为我们不再需要它了。
- en: Note
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `State` object that's contained within the `ViewModel` should not be publicly
    available for other classes to modify it, since we want it to be encapsulated
    and allow only the `ViewModel` to update it. We will fix this in [*Chapter 7*](B17788_07_ePub.xhtml#_idTextAnchor249)*,
    Introducing Presentation Patterns in Android*.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 包含在`ViewModel`中的`State`对象不应公开供其他类修改，因为我们希望它被封装，并且只允许`ViewModel`更新它。我们将在[*第7章*](B17788_07_ePub.xhtml#_idTextAnchor249)*，介绍Android中的呈现模式中修复这个问题。
- en: 'Inside the `RestaurantsScreen` composable, remove the `state` variable and
    pass the restaurants from `RestaurantsViewModel` by accessing the value of its
    state through the `.value` accessor with `viewModel.state.value`:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen`可组合组件内部，移除`state`变量，并通过访问`.value`访问器使用`viewModel.state.value`从`RestaurantsViewModel`传递餐厅：
- en: '[PRE17]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We also removed the old code from the `RestaurantItem`'s `onClick` trailing
    lambda block and replaced it with a call to our `ViewModel`'s `toggleFavorite`
    method.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还从`RestaurantItem`的`onClick`尾随lambda块中移除了旧代码，并用对`ViewModel`的`toggleFavorite`方法的调用替换了它。
- en: If you run the application, the UI should perform as expected, so you should
    be able to toggle any restaurants as favorite and your selections should be saved
    upon events like orientation change.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行应用程序，UI应该按预期执行，因此你应该能够切换任何餐厅为收藏，并在事件如方向改变时保存你的选择。
- en: The only difference is that now, `RestaurantsViewModel` is the only source of
    truth for the state of `RestaurantsScreen` and we no longer need to hold or save
    the UI state inside the composables themselves.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是现在，`RestaurantsViewModel`是`RestaurantsScreen`状态的唯一真相来源，我们不再需要在可组合组件内部持有或保存UI状态。
- en: We now know how to hoist the state up into the `ViewModel`. Now, let's cover
    a very important scenario in the world of Android that's related to process death.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们知道如何将状态提升到`ViewModel`中。接下来，让我们探讨一个与Android世界中的进程死亡相关的重要场景。
- en: Recovering from system-initiated process death
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从系统触发的进程死亡中恢复
- en: We've already learned how, whenever a configuration change occurs, our `Activity`
    is recreated, which can cause our UI to lose its state. To bypass this issue and
    to preserve the UI's state, we ended up implementing a `ViewModel` component and
    hoisted the UI state there.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解到，每当发生配置更改时，我们的`Activity`都会被重新创建，这可能导致我们的UI丢失状态。为了绕过这个问题并保留UI的状态，我们最终实现了`ViewModel`组件并将UI状态提升到那里。
- en: But what would happen in the case of a system-initiated process death?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 但在系统触发的进程死亡的情况下会发生什么？
- en: A **system-initiated process death** happens when the user places our application
    in the background and decides to use other apps for a while – in the meantime,
    though, the system decides to kill our app's process to free up system resources,
    which initiates process death.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将我们的应用程序置于后台并决定暂时使用其他应用时，会发生**系统触发的进程死亡**。然而，在此期间，系统决定杀死我们的应用程序进程以释放系统资源，从而触发进程死亡。
- en: 'Let''s try to simulate such an event and see what happens:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试模拟这样一个事件并看看会发生什么：
- en: 'Start the Restaurants app using the IDE''s **Run** button and mark some restaurants
    as favorites:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用IDE的**运行**按钮启动Restaurants应用程序，并将一些餐厅标记为收藏：
- en: '![Figure 2.6 – The RestaurantsScreen composable with favorite selections made'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.6 – The RestaurantsScreen composable with favorite selections made'
- en: '](img/B17788_02_06.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_02_06.jpg)'
- en: Figure 2.6 – The RestaurantsScreen composable with favorite selections made
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.6 – 已制作收藏选择的RestaurantsScreen可组合组件
- en: Place the app in the background by pressing the **Home** button on the device/emulator.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按设备/模拟器的**主页**按钮将应用置于后台。
- en: 'In Android Studio, select the **Logcat** window and then press the red square
    button on the left-hand side to terminate the application:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Android Studio中，选择**Logcat**窗口，然后按左侧的红色方块按钮来终止应用程序：
- en: '![Figure 2.7 – Killing the process in Logcat to simulate system-initiated process
    death'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.7 – Killing the process in Logcat to simulate system-initiated process
    death'
- en: '](img/B17788_02_07.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_02_07.jpg)'
- en: Figure 2.7 – Killing the process in Logcat to simulate system-initiated process
    death
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – 在Logcat中杀死进程以模拟系统触发的进程死亡
- en: 'Relaunch the application from the application drawer:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从应用抽屉中重新启动应用程序：
- en: '![Figure 2.8 – The RestaurantsScreen composable with favorite selections lost'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.8 – The RestaurantsScreen composable with favorite selections lost'
- en: '](img/B17788_02_08.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_02_08.jpg)'
- en: Figure 2.8 – The RestaurantsScreen composable with favorite selections lost
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – 收藏选择丢失的餐厅屏幕组件
- en: We have now simulated a situation where the system would kill our process. When
    we return to the app, we can see that our selections are now gone and that the
    restaurants that were favorited are now in their default states.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在模拟了一个系统会杀死我们的进程的情况。当我们返回到应用程序时，我们可以看到我们的选择现在消失了，而且被收藏的餐厅现在处于默认状态。
- en: To restore state upon system-initiated process death, we used to use the `onSaveInstanceState()`
    callback of our activity.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在系统启动进程死亡时恢复状态，我们曾经使用过活动的 `onSaveInstanceState()` 回调。
- en: Similarly, every `ViewModel` that uses the default `ViewModelFactory` (like
    we did with the `viewModel()` inline syntax previously) can access a `SavedStateHandle`
    object through its constructor. If you use a custom `ViewModelFactory`, make sure
    that it extends `AbstractSavedStateViewModelFactory`.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，每个使用默认 `ViewModelFactory` 的 `ViewModel`（就像我们之前使用 `viewModel()` 内联语法所做的那样）都可以通过其构造函数访问一个
    `SavedStateHandle` 对象。如果你使用自定义 `ViewModelFactory`，请确保它扩展 `AbstractSavedStateViewModelFactory`。
- en: The `SavedStateHandle` object is a key-value map that allows you to save and
    then restore objects that are crucial to your state. This map survives the event
    of process death when this event is initiated by the system, which allows you
    to retrieve and restore your saved objects.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`SavedStateHandle` 对象是一个键值映射，允许你保存并恢复对状态至关重要的对象。当系统启动此事件时，此映射在进程死亡事件发生时仍然存在，这允许你检索和恢复保存的对象。'
- en: Note
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: When we're saving state-related data, it's crucial to save lightweight objects
    that define the state and not the entire data that is described on the screen.
    For large data, we should use local persistence.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们保存状态相关数据时，保存定义状态的轻量级对象而不是屏幕上描述的整个数据至关重要。对于大量数据，我们应该使用本地持久化。
- en: Let's try to do this in our application by saving a list of `id` values of the
    restaurants that were toggled as favorites in `SavedStateHandle`. Saving the `id`
    values is better than saving the entire list of restaurants since a list of `Int`
    values is lightweight. And since we can always get the restaurant list back at
    runtime, the only thing that's missing is to remember which of them were favorited.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中尝试这样做，通过保存被切换为收藏的餐厅的 `id` 值列表到 `SavedStateHandle`。保存 `id` 值比保存整个餐厅列表更好，因为
    `Int` 值列表更轻量。而且，由于我们可以在运行时始终获取餐厅列表，唯一缺少的是记住哪些被收藏了。
- en: Note
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Usually, `SavedStateHandle` is used for saving transient data like sorting or
    filtering selections performed by the user, or other selections that you need
    to restore upon system-initiated process death. In our case though, favorited
    restaurants should be restored not only upon system-initiated process death but
    also upon a simple application restart. That's why we will save these selections
    as part of the domain data of the app inside a local database later in [*Chapter
    6*](B17788_06_ePub.xhtml#_idTextAnchor186), *Adding Offline Capabilities with
    Jetpack Room*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`SavedStateHandle` 用于保存用户执行的操作，如排序或筛选选择，或其他需要在系统启动进程死亡时恢复的选择。然而，在我们的案例中，收藏的餐厅不仅需要在系统启动进程死亡时恢复，还需要在简单的应用程序重启时恢复。这就是为什么我们将在[第
    6 章](B17788_06_ePub.xhtml#_idTextAnchor186)“使用 Jetpack Room 添加离线功能”中稍后，将这些选择作为应用程序在本地数据库中的域数据保存。
- en: 'Let''s use a `SavedStateHandle` object to recover from system-initiated process
    death:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使用 `SavedStateHandle` 对象从系统启动进程死亡中恢复：
- en: 'Add the `SavedStateHandle` parameter to your `RestaurantsViewModel`:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SavedStateHandle` 参数添加到你的 `RestaurantsViewModel`：
- en: '[PRE18]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Call a `storeSelection` method whenever we toggle the favorite status of a
    restaurant inside the `toggleFavorite` method and pass the respective restaurant:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `toggleFavorite` 方法中切换餐厅的收藏状态时，调用 `storeSelection` 方法，并传递相应的餐厅：
- en: '[PRE19]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This code won't compile though because we haven't yet defined the `storeSelection`
    method. Let's do that up next.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码无法编译，因为我们还没有定义 `storeSelection` 方法。让我们接下来定义它。
- en: 'Inside `RestaurantsViewModel`, create a new `storeSelection` method that receives
    a `Restaurant` object whose `isFavorite` property has just been altered, and saves
    that selection inside the `SavedStateHandle` object provided by the `RestaurantsViewModel`
    class:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsViewModel` 中，创建一个新的 `storeSelection` 方法，该方法接收一个 `Restaurant` 对象，其
    `isFavorite` 属性刚刚被更改，并将该选择保存到 `RestaurantsViewModel` 类提供的 `SavedStateHandle` 对象中：
- en: '[PRE20]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This new method will try to save the `id` value of a restaurant in our `stateHandle`
    object every time we toggle its favorite status. It does this as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个新方法将尝试在每次切换餐厅的收藏状态时在我们的`stateHandle`对象中保存餐厅的`id`值。它是这样做的：
- en: It obtains a list containing the IDs of the previously favorited restaurants
    from `stateHandle` by accessing the `FAVORITES` key inside the map. It stores
    the result in a `savedToggle` mutable list. If no restaurants were favorited,
    the list will be empty.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它通过访问映射中的`FAVORITES`键从`stateHandle`获取包含之前收藏的餐厅ID的列表。结果存储在`savedToggle`可变列表中。如果没有餐厅被收藏，列表将为空。
- en: If this restaurant was marked as favorite, it adds the ID of the restaurant
    to the `savedToggle` list. Otherwise, it removes it.
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果这个餐厅被标记为收藏，它将餐厅的ID添加到`savedToggle`列表中。否则，它将其从列表中移除。
- en: Saves the updated list of favorited restaurants with the `FAVORITES` key inside
    the `stateHandle` map.
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`stateHandle`映射中使用`FAVORITES`键保存更新后的收藏餐厅列表。
- en: We have also added a `companion object` construct to the `RestaurantsViewModel`
    class as a static extension object. We used this `companion object` to define
    a constant value for the key used to save the restaurant's selection inside our
    `stateHandle` map.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在`RestaurantsViewModel`类中添加了一个`companion object`构造，作为静态扩展对象。我们使用这个`companion
    object`定义了一个用于在`stateHandle`映射中保存餐厅选择的键的常量值。
- en: Now, we've made sure to cache the selections of favorite restaurants before
    process death, so our next step is to find a way to restore these selections after
    the app recovers from a system-initiated process death event.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经确保在进程死亡之前缓存了收藏餐厅的选择，因此我们的下一步是找到一种方法在应用从系统启动的进程死亡事件中恢复后恢复这些选择。
- en: 'Call a `restoreSelections()` extension method on the `dummyRestaurants` list
    that we are passing as an initial value to our `state` object. This call should
    restore the UI selections:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们传递给`state`对象的初始值`dummyRestaurants`列表上调用`restoreSelections()`扩展方法。这个调用应该恢复UI选择：
- en: '[PRE21]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This code won't compile though because we haven't yet defined the `restoreSelections`
    method. Let's do that up next.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这段代码无法编译，因为我们还没有定义`restoreSelections`方法。让我们接下来定义它。
- en: 'Inside `RestaurantsViewModel`, define the `restoreSelections` extension function
    that will allow us to retrieve the restaurants that were favorited upon process
    death:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantsViewModel`内部，定义一个`restoreSelections`扩展函数，这将允许我们在进程死亡时检索被收藏的餐厅：
- en: '[PRE22]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'This extension function will allow us to mark those restaurants that were marked
    by the user previously as favorites upon system-initiated process death. The `restoreSelections`
    extension function achieves that in the following way:'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展函数将允许我们标记那些在系统启动进程死亡时用户之前标记为收藏的餐厅。`restoreSelections`扩展函数通过以下方式实现这一点：
- en: First, by obtaining the list with the unique identifiers of the previously favorited
    restaurants from `stateHandle` by accessing the `FAVORITES` key inside the map.
    If the list is not `null`, this means that a process death occurred, and it references
    the list as `selectedIds`; otherwise, it will return the list without any modifications.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过从`stateHandle`中获取包含之前收藏的餐厅唯一标识符的列表，通过访问映射中的`FAVORITES`键。如果列表不是`null`，这意味着发生了进程死亡，它将列表引用为`selectedIds`；否则，它将返回未做任何修改的列表。
- en: Then, by creating a map from the input list of restaurants with the key being
    the `id` value of the restaurant and the value the `Restaurant` object itself.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，通过创建一个映射，其键是餐厅的`id`值，值是`Restaurant`对象本身，从输入的餐厅列表中创建一个映射。
- en: By iterating over the unique identifiers of the favorited restaurants and for
    each of them, by trying to access the respective restaurant from our new list
    and sets its `isFavorite` value to `true`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过遍历收藏餐厅的唯一标识符，并为每个标识符尝试从我们的新列表中访问相应的餐厅，并将它的`isFavorite`值设置为`true`。
- en: By returning the modified restaurants list from `restaurantMap`. This list should
    now contain the restored `isFavorite` values from before the death process occurred.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过从`restaurantMap`返回修改后的餐厅列表。这个列表现在应该包含在死亡过程发生之前恢复的`isFavorite`值。
- en: 6. Finally, build the app and then repeat *steps 1*, *2*, *3*, and *4* from
    when we simulated a system-initiated process death.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 6. 最后，构建应用，然后重复之前模拟系统启动进程死亡时的*步骤1*、*步骤2*、*步骤3*和*步骤4*。
- en: The application should now correctly display the UI state with the previously
    favorited restaurants from before the system-initiated process death.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序现在应该能够正确显示UI状态，包括在系统启动进程死亡之前之前收藏的餐厅。
- en: With that, we've made sure that our application not only stores the UI state
    at the `ViewModel` level but that it also can recover from extraordinary events,
    such as system-initiated process death.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样，我们确保了我们的应用程序不仅存储了UI状态在`ViewModel`级别，而且还可以从系统启动的进程死亡等异常事件中恢复。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we learned what a `ViewModel` class is, we explored the concepts
    that define it, and we learned how to instantiate one. We tackled why a `ViewModel`
    is useful as a single source of truth for the UI''s *state*: to avoid illegal
    and undesired states.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了`ViewModel`类是什么，我们探讨了定义它的概念，并学习了如何实例化一个。我们探讨了为什么`ViewModel`作为UI的*状态*的单个真实来源是有用的：为了避免非法和不希望的状态。
- en: For that to make sense, we explored how a UI is defined by its state and how
    to define such a state in Compose. We then understood what *state hoisting* is
    and how to separate widgets between *stateless* and *stateful* composables.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让这有意义，我们探讨了UI是如何通过其状态定义的，以及如何在Compose中定义这样的状态。然后我们理解了*状态提升*是什么，以及如何将widget在*无状态*和*有状态*的composable之间分离。
- en: Finally, we put all these new concepts into practice by defining state in our
    Restaurants app, hoisting it, and then lifting it even higher into the newly created
    `ViewModel`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将所有这些新概念付诸实践，通过在我们的餐厅应用中定义状态，提升它，然后将它提升到新创建的`ViewModel`中。
- en: Finally, we learned how system-initiated process death occurs and how to allow
    the app to recover by restoring the previous state with the help of `SavedStateHandle`.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了系统启动的进程死亡发生的方式以及如何通过使用`SavedStateHandle`恢复之前的状态来允许应用恢复。
- en: In the next chapter, we will add real data to our Restaurants app by connecting
    it to our database using Retrofit.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将通过使用Retrofit将其连接到我们的数据库来向我们的餐厅应用添加真实数据。
- en: Further reading
  id: totrans-270
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: Working with ViewModels and handling state changes in Compose represent two
    essential topics for reliable projects. Let's see what other subjects revolve
    around them.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在Compose中与ViewModel一起工作并处理状态变化是可靠项目的两个基本主题。让我们看看围绕它们的其他主题是什么。
- en: Exploring ViewModel with runtime-provided arguments
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索使用运行时提供的参数的ViewModel
- en: In most cases, you can declare and provide dependencies to your `ViewModel`
    inside the constructor, at compile time. In some cases, though, you might need
    to initialize a `ViewModel` instance with a parameter that's only known at runtime.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，你可以在构造函数中声明并提供依赖项给`ViewModel`，在编译时。然而，在某些情况下，你可能需要使用仅在运行时才知道的参数来初始化`ViewModel`实例。
- en: For example, when we're adding a composable screen that displays the details
    of a restaurant, instead of sending the ID of the target restaurant from the composable
    to `ViewModel` through a function call, we can provide it directly to the `ViewModel`
    constructor through **ViewModelFactory**.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当我们添加一个显示餐厅详细信息的composable屏幕时，而不是通过函数调用从composable将目标餐厅的ID发送到`ViewModel`，我们可以通过**ViewModelFactory**直接将其提供给`ViewModel`构造函数。
- en: 'To explore the process of building a `ViewModelFactory`, check out the following
    Codelab: [https://developer.android.com/codelabs/kotlin-android-training-view-model#7](https://developer.android.com/codelabs/kotlin-android-training-view-model#7).'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 要探索构建`ViewModelFactory`的过程，请查看以下Codelab：[https://developer.android.com/codelabs/kotlin-android-training-view-model#7](https://developer.android.com/codelabs/kotlin-android-training-view-model#7)。
- en: Exploring ViewModel for Kotlin Multiplatform projects
  id: totrans-276
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索Kotlin Multiplatform项目的ViewModel
- en: While this chapter covered the Jetpack ViewModel for Compose in pure Android
    apps, if you're aiming to build cross-platform projects using **Kotlin Multiplatform**
    (**KMP**) or **Kotlin Multiplatform Mobile** (**KMM**), the Jetpack ViewModel
    might not be your best option.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章涵盖了纯Android应用中的Jetpack ViewModel for Compose，但如果你的目标是使用**Kotlin Multiplatform**
    (**KMP**) 或 **Kotlin Multiplatform Mobile** (**KMM**)来构建跨平台项目，Jetpack ViewModel可能不是最佳选择。
- en: When we're building cross-platform projects, we should try to avoid platform-specific
    dependencies. The Jetpack ViewModel is suited for Android and therefore is an
    Android dependency, so we might need to build or define a ViewModel.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在构建跨平台项目时，我们应该尽量避免平台特定的依赖。Jetpack ViewModel适用于Android，因此是一个Android依赖项，所以我们可能需要构建或定义一个ViewModel。
- en: 'To learn more about KMM and platform-agnostic ViewModels, check out the following
    GitHub example: [https://github.com/dbaroncelli/D-KMP-sample](https://github.com/dbaroncelli/D-KMP-sample).'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于KMM和平台无关的ViewModel的信息，请查看以下GitHub示例：[https://github.com/dbaroncelli/D-KMP-sample](https://github.com/dbaroncelli/D-KMP-sample)。
- en: Understanding how to minimize the number of recompositions
  id: totrans-280
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解如何最小化重组次数
- en: In this chapter, we learned how to trigger recompositions by using `State` objects.
    While in Compose, recompositions happen often, we haven't had a chance to optimize
    the performance of our Compose-based screens.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何通过使用`State`对象来触发重组。虽然在使用Compose时重组经常发生，但我们还没有机会优化基于Compose的屏幕的性能。
- en: We can reduce the number of recompositions by ensuring that the input of the
    composables is deeply stable. To learn more about how to achieve this, go to [https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&skip_cache=true#skipping](https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&skip_cache=true#skipping).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过确保可组合组件的输入是深度稳定的来减少重组的次数。要了解更多关于如何实现这一点，请访问[https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&skip_cache=true#skipping](https://developer.android.com/jetpack/compose/lifecycle?hl=bn-IN&skip_cache=true#skipping)。
