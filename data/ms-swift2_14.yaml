- en: Chapter 14. Concurrency and Parallelism in Swift
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 14 章. Swift 中的并发与并行
- en: When I first started learning Objective-C, I already had a good understanding
    of concurrency and multitasking with my background in other languages such as
    C and Java. This background made it very easy for me to create multithreaded applications
    using threads in Objective-C. Then, Apple changed everything for me when they
    released **Grand Central Dispatch** (**GCD**) with OS X 10.6 and iOS 4\. At first,
    I went into denial; there was no way GCD could manage my application's threads
    better than I could. Then I entered the anger phase, GCD was hard to use and understand.
    Next was the bargaining phase, maybe I can use GCD with my threading code, so
    I could still control how the threading worked. Then there was the depression
    phase, maybe GCD does handle the threading better than I can. Finally, I entered
    the wow phase; this GCD thing is really easy to use and works amazingly well.
    After using Grand Central Dispatch and Operation Queues with Objective-C, I do
    not see a reason for using manual threads with Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我开始学习 Objective-C 时，我已经对并发和多任务处理有了很好的理解，这得益于我在 C 和 Java 等其他语言中的背景知识。这个背景使我能够很容易地使用
    Objective-C 中的线程创建多线程应用程序。然后，当苹果在 OS X 10.6 和 iOS 4 中发布 **Grand Central Dispatch**
    (**GCD**) 时，他们为我改变了一切。起初，我感到否认；GCD 根本不可能比我更好地管理我的应用程序的线程。然后我进入了愤怒阶段，GCD 难以使用和理解。接下来是讨价还价阶段，也许我可以使用
    GCD 与我的线程代码一起使用，这样我仍然可以控制线程的工作方式。然后是抑郁阶段，也许 GCD 确实比我更好地处理线程。最后，我进入了哇哦阶段；这个 GCD
    真的很容易使用，并且工作得非常出色。在使用了 Grand Central Dispatch 和 Operation Queues 与 Objective-C
    一起之后，我看不到使用 Swift 中的手动线程的理由。
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Basics of concurrency and parallelism
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并发与并行的基础知识
- en: How to use GCD to create and manage concurrent dispatch queues
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GCD 创建和管理并发调度队列
- en: How to use GCD to create and manage serial dispatch queues
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 GCD 创建和管理串行调度队列
- en: How to use various GCD functions to add tasks to the dispatch queues
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用各种 GCD 函数将任务添加到调度队列中
- en: How to use `NSOperation` and `NSOperationQueues` to add concurrency to our applications
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 `NSOperation` 和 `NSOperationQueues` 为我们的应用程序添加并发
- en: Concurrency and parallelism
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发与并行
- en: Concurrency is the concept of multiple tasks starting, running, and completing
    within the same time period. This does not necessarily mean that the tasks are
    executing simultaneously. In order for tasks to be run simultaneously, our application
    needs to be running on a multicore or multiprocessor system. Concurrency allows
    us to share the processor or cores with multiple tasks; however, a single core
    can only execute one task at a given time.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 并发是多个任务在同一时间段内启动、运行和完成的理念。这并不一定意味着任务是在同时执行的。为了使任务能够同时执行，我们的应用程序需要在多核或多处理器系统上运行。并发使我们能够与多个任务共享处理器或核心；然而，单个核心一次只能执行一个任务。
- en: Parallelism is the concept of two or more tasks running simultaneously. Since
    each core of our processor can only execute one task at a time, the number of
    tasks executing simultaneously is limited to the number of cores within our processors.
    Therefore, if we have, for example, a four-core processor, then we are limited
    to only four tasks running simultaneously. Today's processors can execute tasks
    so quickly that it may appear that larger tasks are executing simultaneously.
    However, within the system, the larger tasks are actually taking turns executing
    subtasks on the cores.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 并行是两个或更多任务同时运行的概念。由于我们的处理器每个核心一次只能执行一个任务，因此同时执行的任务数量限制在我们处理器中的核心数量。因此，如果我们有一个四核处理器，那么我们只能同时运行四个任务。今天的处理器可以非常快速地执行任务，这可能会让人误以为更大的任务是在同时执行。然而，在系统中，较大的任务实际上是在核心上轮流执行子任务。
- en: In order to understand the difference between concurrency and parallelism, let's
    look at how a juggler juggles balls. If you watch a juggler, it seems they are
    catching and throwing multiple balls at any given time; however, a closer look
    reveals that they are, in fact, only catching and throwing one ball at a time.
    The other balls are in the air waiting to be caught and thrown. If we want to
    be able to catch and throw multiple balls simultaneously, we need to add multiple
    jugglers.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解并发与并行的区别，让我们看看一个杂技演员如何抛接球。如果你观察一个杂技演员，他们似乎在任何给定时间都在同时接住和抛出多个球；然而，仔细观察会发现，他们实际上每次只接住和抛出一个球。其他球在空中等待被接住和抛出。如果我们想要能够同时接住和抛出多个球，我们需要添加多个杂技演员。
- en: This example is really good because we can think of jugglers as the cores of
    a processer. A system with a single core processor (one juggler), regardless of
    how it seems, can only execute one task (catch and throw one ball) at a time.
    If we want to execute more than one task at a time, we need to use a multicore
    processor (more than one juggler).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子非常好，因为我们可以把杂技演员看作是处理器的核心。拥有单核处理器的系统（一个杂技演员），无论看起来如何，一次只能执行一个任务（接住并抛出一个球）。如果我们想同时执行多个任务，我们需要使用多核处理器（多个杂技演员）。
- en: Back in the old days when all the processors were single core, the only way
    to have a system that executed tasks simultaneously was to have multiple processors
    in the system. This also required specialized software to take advantage of the
    multiple processors. In today's world, just about every device has a processor
    that has multiple cores, and both the iOS and OS X operating systems are designed
    to take advantage of the multiple cores to run tasks simultaneously.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在那些处理器都是单核的古老日子里，要有一个能够同时执行任务的系统，唯一的办法是在系统中拥有多个处理器。这也需要专门的软件来利用多个处理器。在当今世界，几乎每个设备都有一个拥有多个核心的处理器，iOS
    和 OS X 操作系统都是设计用来利用多个核心来同时运行任务的。
- en: Traditionally, the way applications added concurrency was to create multiple
    threads; however, this model does not scale well to an arbitrary number of cores.
    The biggest problem with using threads was that our applications ran on a variety
    of systems (and processors), and in order to optimize our code, we needed to know
    how many cores/processors could be efficiently used at a given time, which is
    sometimes not known at the time of development.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，应用程序添加并发的方式是创建多个线程；然而，这种模型在任意数量的核心上扩展性不好。使用线程的最大问题是我们的应用程序运行在各种各样的系统（和处理器的）上，为了优化我们的代码，我们需要知道在给定时间可以高效使用多少核心/处理器，这有时在开发时是未知的。
- en: In order to solve this problem, many operating systems, including iOS and OS
    X, started relying on asynchronous functions. These functions are often used to
    initiate tasks that could possibly take a long time to complete, such as making
    an HTTP request or writing data to disk. An asynchronous function typically starts
    the long running task and then returns prior to the task completion. Usually,
    this task runs in the background and uses a callback function (such as closure
    in Swift) when the task completes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，许多操作系统，包括 iOS 和 OS X，开始依赖异步函数。这些函数通常用于启动可能需要很长时间才能完成的任务，例如发起 HTTP 请求或写入数据到磁盘。异步函数通常在长时间运行的任务开始后立即返回，在任务完成之前。通常，这个任务在后台运行，并在任务完成时使用回调函数（例如
    Swift 中的闭包）。
- en: These asynchronous functions work great for the tasks that the OS provides them
    for, but what if we needed to create our own asynchronous functions and do not
    want to manage the threads ourselves? For this, Apple provides a couple of technologies.
    In this chapter, we will be covering two of these technologies. These are GCD
    and operation queues.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这些异步函数对于操作系统提供的任务非常有效，但如果我们需要创建自己的异步函数而不想自己管理线程呢？为此，Apple 提供了一些技术。在本章中，我们将介绍其中两种技术。这些是
    GCD 和操作队列。
- en: GCD is a low-level C-based API that allows specific tasks to be queued up for
    execution and schedules the execution on any of the available processor cores.
    Operation queues are similar to GCD; however, they are Cocoa objects and are internally
    implemented using GCD.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 是一个基于 C 的低级 API，允许将特定任务排队执行，并在任何可用的处理器核心上调度执行。操作队列与 GCD 类似；然而，它们是 Cocoa
    对象，并且内部使用 GCD 实现。
- en: Let's begin by looking at GCD.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从查看最大公约数（GCD）开始。
- en: Grand Central Dispatch
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 大中枢调度（Grand Central Dispatch）
- en: Grand Central Dispatch provides what is known as dispatch queues to manage submitted
    tasks. The queues manage these submitted tasks and execute them in a **first-in,
    first-out** (**FIFO**) order. This ensures that the tasks are started in the order
    they were submitted.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 大中枢调度提供了所谓的调度队列来管理提交的任务。队列管理这些提交的任务，并以**先进先出**（**FIFO**）的顺序执行它们。这确保了任务是以它们提交的顺序开始的。
- en: A task is simply some work that our application needs to perform. As examples,
    we can create tasks that perform simple calculations, read/write data to disk,
    make an HTTP request, or anything else that our application needs to do. We define
    these tasks by placing the code inside either a function or a closure and adding
    it to a dispatch queue.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 任务只是我们应用程序需要执行的一些工作。例如，我们可以创建执行简单计算、读取/写入磁盘数据、发起 HTTP 请求或我们应用程序需要做的任何其他任务的作业。我们通过将代码放在函数或闭包内部并将它们添加到调度队列中来定义这些任务。
- en: 'GCD provides three types of queues:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: GCD 提供了三种类型的队列：
- en: '**Serial queues**: Tasks in a serial queue (also known as a **private queue**)
    are executed one at a time in the order they were submitted. Each task is started
    only after the preceding task is completed. Serial queues are often used to synchronize
    access to specific resources because we are guaranteed that no two tasks in a
    serial queue will ever run simultaneously. Therefore, if the only way to access
    the specific resource is through the tasks in the serial queue, then no two tasks
    will attempt to access the resource at the same time or be out of order.'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**串行队列**：串行队列中的任务（也称为**私有队列**）按提交顺序逐个执行。只有在先前的任务完成后，才会启动每个任务。串行队列通常用于同步访问特定资源，因为我们有保证，串行队列中的两个任务永远不会同时运行。因此，如果访问特定资源的唯一方式是通过串行队列中的任务，那么两个任务将不会同时尝试访问该资源或出现顺序混乱。'
- en: '**Concurrent queues**: Tasks in a concurrent queue (also known as a **global
    dispatch queue**) execute concurrently; however, the tasks are still started in
    the order that they were added to the queue. The exact number of tasks that can
    be executing at any given instance is variable and is dependent on the system''s
    current conditions and resources. The decision on when to start a task is up to
    GCD and is not something that we can control within our application.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并发队列**：并发队列中的任务（也称为**全局调度队列**）是并发执行的；然而，任务的启动顺序仍然是它们被添加到队列中的顺序。在任何给定时刻可以执行的任务的确切数量是可变的，并且取决于系统的当前条件和资源。何时启动任务的决定权在
    GCD，而不是我们可以在应用程序内部控制的事情。'
- en: '**Main dispatch queue**: The main dispatch queue is a globally available serial
    queue that executes tasks on the application''s main thread. Since tasks put into
    the main dispatch queue run on the main thread, it is usually called from a background
    queue when some background processing has finished and the user interface needs
    to be updated.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主调度队列**：主调度队列是一个全局可用的串行队列，它在应用程序的主线程上执行任务。由于放入主调度队列的任务在主线程上运行，因此它通常在后台处理完成并且用户界面需要更新时从后台队列中调用。'
- en: Dispatch queues offer a number of advantages over traditional threads. The first
    and foremost advantage is, with dispatch queues, the system handles the creation
    and management of threads rather than the application itself. The system can scale
    the number of threads, dynamically based on the overall available resources of
    the system and the current system conditions. This means that dispatch queues
    can manage the threads with greater efficiency than we could.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 调度队列相对于传统线程提供了许多优势。首要的优势是，使用调度队列时，系统处理线程的创建和管理，而不是应用程序本身。系统可以根据系统的总体可用资源和当前系统条件动态地调整线程的数量。这意味着调度队列可以比我们更有效地管理线程。
- en: Another advantage of dispatch queues is we are able to control the order that
    our tasks are started. With serial queues, not only do we control the order in
    which tasks are started, but also ensure that one task does not start before the
    preceding one is complete. With traditional threads, this can be very cumbersome
    and brittle to implement, but with dispatch queues, as we will see later in this
    chapter, it is quite easy.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 调度队列的另一个优点是我们能够控制任务启动的顺序。使用串行队列，我们不仅控制了任务启动的顺序，还确保在先前的任务完成之前不会启动下一个任务。使用传统的线程，这可能会非常繁琐且难以实现，但正如我们在本章后面将看到的，使用调度队列则相当容易。
- en: Creating and managing dispatch queues
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和管理调度队列
- en: 'Let''s look at how to create and use a dispatch queue. The following three
    functions are used to create or retrieve queues. These functions are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何创建和使用调度队列。以下三个函数用于创建或检索队列。这些函数如下：
- en: '`dispatch_queue_create`: This creates a dispatch queue of either the concurrent
    or serial type'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_queue_create`: 这将创建一个并发或串行类型的调度队列'
- en: '`dispatch_get_global_queue`: This returns a system-defined global concurrent
    queue with a specified quality of service'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_get_global_queue`: 这返回一个具有指定服务质量系统定义的全局并发队列'
- en: '`dispatch_get_main_queue`: This returns the serial dispatch queue associated
    with the application''s main thread'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_get_main_queue`: 这返回与应用程序主线程关联的串行调度队列'
- en: 'We will also be looking at several functions that submit tasks to a queue for
    execution. These functions are as follows:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将查看几个将任务提交到队列以执行的功能。这些函数如下：
- en: '`dispatch_async`: This submits a task for asynchronous execution and returns
    immediately.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_async`: 这提交一个任务以异步执行并立即返回。'
- en: '`dispatch_sync`: This submits a task for synchronous execution and waits until
    it is complete before it returns.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_sync`: 这提交一个任务以同步执行，并在返回之前等待其完成。'
- en: '`dispatch_after`: This submits a task for execution at a specified time.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_after`: 这提交一个任务以在指定时间执行。'
- en: '`dispatch_once`: This submits a task to be executed once and only once while
    this application is running. It will execute the task again if the application
    restarts.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dispatch_once`: 这提交一个任务，在应用程序运行期间只执行一次。如果应用程序重新启动，它将再次执行该任务。'
- en: 'Before we look at how to use the dispatch queues, we need to create a class
    that will help us demonstrate how the various types of queues work. This class
    will contain two basic functions. The first function will simply perform some
    basic calculations and then return a value. Here is the code for this function,
    which is named `doCalc()`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看如何使用调度队列之前，我们需要创建一个类来帮助我们演示各种类型队列的工作方式。此类将包含两个基本函数。第一个函数将简单地执行一些基本计算，然后返回一个值。以下是此函数的代码，该函数名为
    `doCalc()`：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The other function, which is named `performCalculation()`, accepts two parameters.
    One is an integer named `iterations`, and the other is a string named `tag`. The
    `performCalculation()` function calls the `doCalc()` function repeatedly until
    it calls the function the same number of times as defined by the iterations parameter.
    We also use the `CFAbsoluteTimeGetCurrent()` function to calculate the elapsed
    time it took to perform all of the iterations and then print the elapse time with
    the `tag` string to the console. This will let us know when the function completes
    and how long it took to complete it. The code for this function looks similar
    to this:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个名为 `performCalculation()` 的函数接受两个参数。一个是名为 `iterations` 的整数，另一个是名为 `tag` 的字符串。`performCalculation()`
    函数会重复调用 `doCalc()` 函数，直到调用的次数与迭代参数定义的次数相同。我们还使用 `CFAbsoluteTimeGetCurrent()` 函数来计算执行所有迭代所需的时间，然后使用
    `tag` 字符串将经过的时间打印到控制台。这将让我们知道函数何时完成以及完成它所需的时间。此函数的代码看起来类似于以下内容：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: These functions will be used together to keep our queues busy, so we can see
    how they work. Let's begin by looking at the GCD functions by using the `dispatch_queue_create()`
    function to create both concurrent and serial queues.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数将一起使用以保持我们的队列忙碌，这样我们就可以看到它们是如何工作的。让我们首先通过使用 `dispatch_queue_create()` 函数来创建并发和串行队列来查看
    GCD 函数。
- en: Creating queues with the dispatch_queue_create() function
  id: totrans-43
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 dispatch_queue_create() 函数创建队列
- en: 'The `dispatch_queue_create()` function is used to create both concurrent and
    serial queues. The syntax of the `dispatch_queue_create()` function looks similar
    to this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch_queue_create()` 函数用于创建并发和串行队列。`dispatch_queue_create()` 函数的语法看起来类似于以下内容：'
- en: '[PRE2]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'It takes the following parameters:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 它需要以下参数：
- en: '`label`: This is a string label that is attached to the queue to uniquely identify
    it in debugging tools, such as Instruments and crash reports. It is recommended
    that we use a reverse DNS naming convention. This parameter is optional and can
    be nil.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`label`: 这是一个附加到队列上的字符串标签，用于在调试工具（如 Instruments 和崩溃报告）中唯一标识它。建议我们使用反向 DNS 命名约定。此参数是可选的，可以是
    nil。'
- en: '`attr`: This specifies the type of queue to make. This can be `DISPATCH_QUEUE_SERIAL,
    DISPATCH_QUEUE_CONCURRENT` or nil. If this parameter is nil, a serial queue is
    created.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`attr`: 这指定了要创建的队列类型。这可以是 `DISPATCH_QUEUE_SERIAL, DISPATCH_QUEUE_CONCURRENT`
    或 nil。如果此参数为 nil，则创建一个串行队列。'
- en: The return value for this function is the newly created dispatch queue. Let's
    see how to use the `dispatch_queue_create()` function by creating a concurrent
    queue and seeing how it works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数的返回值是新创建的调度队列。让我们通过创建一个并发队列并查看其工作方式来了解如何使用 `dispatch_queue_create()` 函数。
- en: Note
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Some programming languages use the reverse DNS naming convention to name certain
    components. This convention is based on a registered domain name that is reversed.
    As an example, if we worked for company that had a domain name `mycompany.com`
    with a product called `widget`, the reverse DNS name will be `com.mycompany.widget`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 一些编程语言使用反向DNS命名约定来命名某些组件。这个约定基于一个反转的已注册域名。例如，如果我们为名为`mycompany.com`的公司工作，该公司有一个名为`widget`的产品，那么反向DNS名称将是`com.mycompany.widget`。
- en: Creating concurrent dispatch queues with the dispatch_queue_create() function
  id: totrans-52
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`dispatch_queue_create()`函数创建并发调度队列
- en: 'The following line creates a concurrent dispatch queue with the label of `cqueue.hoffman.jon`:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下行创建了一个带有标签`cqueue.hoffman.jon`的并发调度队列：
- en: '[PRE3]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'As we saw in the beginning of this section, there are several functions that
    we can use to submit tasks to a dispatch queue. When we work with queues, we generally
    want to use the `dispatch_async()` function to submit tasks because when we submit
    a task to a queue, we usually do not want to wait for a response. The `dispatch_async()`
    function has the following signature:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本节开始时看到的，我们可以使用几个函数将任务提交到调度队列。当我们与队列一起工作时，我们通常希望使用`dispatch_async()`函数来提交任务，因为我们通常不希望等待响应。`dispatch_async()`函数具有以下签名：
- en: '[PRE4]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The following example shows how to use the `dispatch_async()` function with
    the concurrent queue we just created:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例显示了如何使用我们刚刚创建的并发队列的`dispatch_async()`函数：
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding code, we created a closure, which represents our task, that
    simply calls the `performCalculation()` function of the `DoCalculation` instance
    requesting that it runs through 1000 iterations of the `doCalc()` function. Finally,
    we use the `dispatch_async()` function to submit the task to the concurrent dispatch
    queue. This code will execute the task in a concurrent dispatch queue, which is
    separate from the main thread.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个闭包，它代表我们的任务，简单地调用`DoCalculation`实例的`performCalculation()`函数，请求它运行`doCalc()`函数的1000次迭代。最后，我们使用`dispatch_async()`函数将任务提交到并发调度队列。此代码将在并发调度队列中执行任务，该队列与主线程分开。
- en: 'While the preceding example works perfectly, we can actually shorten the code
    a little bit. The next example shows that we do not need to create a separate
    closure as we did in the preceding example; we can also submit the task to execute
    like this:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管前面的例子工作得很好，但实际上我们可以稍微缩短代码。下一个例子显示，我们实际上不需要像前面例子中那样创建一个单独的闭包；我们也可以像这样提交任务来执行：
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This shorthand version is how we usually submit small code blocks to our queues.
    If we have larger tasks, or tasks that we need to submit multiple times, we will
    generally want to create a closure and submit the closure to the queue as we showed
    originally.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种简写版本是我们通常提交到队列的小代码块的方式。如果我们有更大的任务，或者需要多次提交的任务，我们通常希望创建一个闭包，并将闭包提交到队列，就像我们最初展示的那样。
- en: 'Let''s see how the concurrent queue actually works by adding several items
    to the queue and looking at the order and time that they return. The following
    code will add three tasks to the queue. Each task will call the `performCalculation()`
    function with various iteration counts. Remember that the `performCalculation()`
    function will execute the calculation routine continuously until it is executed
    the number of times as defined by the iteration count passed in. Therefore, the
    larger the iteration count we pass into the `performCalculation()` function, the
    longer it should take to execute. Let''s take a look at the following code:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向队列中添加几个项目并查看它们的返回顺序和时间来查看并发队列实际上是如何工作的。以下代码将向队列添加三个任务。每个任务都会用不同的迭代次数调用`performCalculation()`函数。记住，`performCalculation()`函数将连续执行计算例程，直到执行次数等于传入的迭代次数。因此，我们传递给`performCalculation()`函数的迭代次数越大，它应该执行的时间就越长。让我们看一下以下代码：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Notice that each of the functions is called with a different value in the `tag`
    parameter. Since the `performCalculation()` function prints out the `tag` variable
    with the elapsed time, we can see the order in which the tasks complete and the
    time it took to execute. If we execute the preceding code, we should see the following
    results:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到每个函数都是用不同的值在`tag`参数中调用的。由于`performCalculation()`函数会打印出带有经过时间的`tag`变量，我们可以看到任务完成的顺序以及执行所需的时间。如果我们执行前面的代码，我们应该看到以下结果：
- en: '[PRE8]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The elapse time will vary from one run to the next and from system to system.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 经过的时间会因运行而异，也会因系统而异。
- en: Since the queues function in a FIFO order, the task that had the tag of `async1`
    was executed first. However, as we can see from the results, it was the last task
    to finish. Since this is a concurrent queue, if it is possible (if the system
    has available resources), the blocks of code will execute concurrently. This is
    why the tasks with the tags of `async2` and `async3` completed prior to the task
    that had the `async1` tag, even though the execution of the `async1` task began
    before the other two.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 由于队列以FIFO（先进先出）顺序工作，标签为`async1`的任务首先执行。然而，正如我们从结果中看到的，它是最后一个完成的任务。由于这是一个并发队列，如果可能（如果系统有可用资源），代码块将并发执行。这就是为什么标签为`async2`和`async3`的任务在标签为`async1`的任务之前完成，尽管`async1`任务的执行开始在其他两个任务之前。
- en: Now, let's see how a serial queue executes tasks.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看串行队列是如何执行任务的。
- en: Creating a serial dispatch queue with the dispatch_queue_create() function
  id: totrans-71
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用`dispatch_queue_create()`函数创建串行调度队列
- en: 'A serial queue functions is a little different than a concurrent queue. A serial
    queue will only execute one task at a time and will wait for one task to complete
    before starting the next task. This queue, like the concurrent dispatch queue,
    follows a first-in first-out order. The following line of code will create a serial
    queue with the label of `squeue.hoffman.jon`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 串行队列的功能与并发队列略有不同。串行队列一次只会执行一个任务，并在开始下一个任务之前等待当前任务完成。这个队列，就像并发调度队列一样，遵循先入先出的顺序。以下代码行将创建一个标签为`squeue.hoffman.jon`的串行队列：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Notice that we create the serial queue with the `DISPATCH_QUEUE_SERIAL` attribute.
    If you recall, when we created the concurrent queue, we created it with the `DISPATCH_QUEUE_CONCURRENT`
    attribute. We can also set this attribute to `nil`, which will create a serial
    queue by default. However, it is recommended to always set the attribute to either
    `DISPATCH_QUEUE_SERIAL` or `DISPATCH_QUEUE_CONCURRENT` to make it easier to identify
    which type of queue we are creating.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用`DISPATCH_QUEUE_SERIAL`属性创建串行队列。如果你还记得，当我们创建并发队列时，我们使用的是`DISPATCH_QUEUE_CONCURRENT`属性。我们也可以将此属性设置为`nil`，这将默认创建一个串行队列。然而，建议始终将属性设置为`DISPATCH_QUEUE_SERIAL`或`DISPATCH_QUEUE_CONCURRENT`，以便更容易识别我们正在创建哪种类型的队列。
- en: As we saw with the concurrent dispatch queues, we generally want to use the
    `dispatch_async()` function to submit tasks because when we submit a task to a
    queue, we usually do not want to wait for a response. If, however, we did want
    to wait for a response, we would use the `dispatch_synch()` function.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们通过并发调度队列所看到的，我们通常想使用`dispatch_async()`函数来提交任务，因为当我们向队列提交任务时，我们通常不希望等待响应。然而，如果我们确实想等待响应，我们会使用`dispatch_synch()`函数。
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Just like with the concurrent queues, we do not need to create a closure to
    submit a task to the queue. We can also submit the task like this:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 就像并发队列一样，我们不需要创建闭包来向队列提交任务。我们也可以这样提交任务：
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s see how the serial queues works by adding several items to the queue
    and looking at the order and time that they complete. The following code will
    add three tasks, which will call the `performCalculation()` function with various
    iteration counts, to the queue:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过向队列添加几个项目并查看它们的完成顺序和时间来了解串行队列的工作原理。以下代码将添加三个任务，这些任务将使用不同的迭代次数调用`performCalculation()`函数：
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Just like with the concurrent queue example, we call the `performCalculation()`
    function with various iteration counts and different values in the `tag` parameter.
    Since the `performCalculation()` function prints out the `tag` string with the
    elapsed time, we can see the order that the tasks complete in and the time it
    takes to execute. If we execute this code, we should see the following results:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 就像并发队列示例一样，我们使用不同的迭代次数和不同的`tag`参数值调用`performCalculation()`函数。由于`performCalculation()`函数会打印出带有经过时间的`tag`字符串，我们可以看到任务的完成顺序和执行时间。如果我们执行此代码，我们应该看到以下结果：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The elapse time will vary from one run to the next and from system to system.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 经过时间会因运行而异，也会因系统而异。
- en: Unlike the concurrent queues, we can see that the tasks completed in the same
    order that they were submitted, even though the `sync2` and `sync3` tasks took
    considerably less time to complete. This demonstrates that a serial queue only
    executes one task at a time and that the queue waits for each task to complete
    before starting the next one.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 与并发队列不同，我们可以看到，尽管`sync2`和`sync3`任务完成所需时间明显更短，但完成的任务顺序与提交的顺序相同。这表明串行队列一次只执行一个任务，并且队列在开始下一个任务之前会等待每个任务完成。
- en: Now that we have seen how to use the `dispatch_queue_create()` function to create
    both concurrent and serial queues, let's look at how we can get one of the four
    system-defined, global concurrent queues using the `dispatch_get_global_queue()`
    function.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用`dispatch_queue_create()`函数创建并发和串行队列，让我们看看如何使用`dispatch_get_global_queue()`函数获取四个系统定义的全局并发队列之一。
- en: Requesting concurrent queues with the dispatch_get_global_queue() function
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`dispatch_get_global_queue()`函数请求并发队列
- en: 'The system provides each application with four concurrent global dispatch queues
    of different priority levels. The different priority levels are what distinguish
    these queues. The four priorities are:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 系统为每个应用程序提供四个不同优先级级别的并发全局调度队列。不同的优先级级别是区分这些队列的因素。四个优先级如下：
- en: '`DISPATCH_QUEUE_PRIORITY_HIGH`: The items in this queue run with the highest
    priority and are scheduled before items in the default and low priority queues'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISPATCH_QUEUE_PRIORITY_HIGH`：此队列中的项目以最高优先级运行，并且会在默认和低优先级队列的项目之前进行调度'
- en: '`DISPATCH_QUEUE_PRIORITY_DEFAULT`: The items in this queue run at the default
    priority and are scheduled before items in the low priority queue but after items
    in the high priority queue'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISPATCH_QUEUE_PRIORITY_DEFAULT`：此队列中的项目以默认优先级运行，并且会在低优先级队列的项目之前，但在高优先级队列的项目之后进行调度'
- en: '`DISPATCH_QUEUE_PRIORITY_LOW`: The items in this queue run with a low priority
    and are schedule only after items in the high and default queues'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISPATCH_QUEUE_PRIORITY_LOW`：此队列中的项目以低优先级运行，并且只有在高优先级和默认队列的项目之后才会进行调度'
- en: '`DISPATCH_QUEUE_PRIORITY_BACKGROUND`: The items in this queue run with a background
    priority, which has the lowest priority'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DISPATCH_QUEUE_PRIORITY_BACKGROUND`：此队列中的项目以后台优先级运行，优先级最低'
- en: 'Since these are global queues, we do not need to actually create them; instead,
    we ask for a reference to the queue with the priority level needed. To request
    a global queue, we use the `dispatch_get_global_queue()` function. This function
    has the following syntax:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些是全局队列，我们实际上不需要创建它们；相反，我们请求具有所需优先级的队列的引用。要请求全局队列，我们使用`dispatch_get_global_queue()`函数。此函数具有以下语法：
- en: '[PRE14]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here, the following parameters are defined:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，以下参数被定义：
- en: '`identifier`: This is the priority of the queue we are requesting'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identifier`：这是我们请求的队列的优先级'
- en: '`flags`: This is reserved for future expansion and should be set to zero at
    this time'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`flags`：此参数保留供将来扩展使用，目前应设置为零'
- en: 'We request a queue using the `dispatch_get_global_queue()` function, as shown
    in the following example:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`dispatch_get_global_queue()`函数请求一个队列，如下面的示例所示：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In this example, we are requesting the global queue with the default priority.
    We can then use this queue exactly as we used the concurrent queues that we created
    with the `dispatch_queue_create()` function. The difference between the queues
    returned with the `dispatch_get_global_queue()` function and the ones created
    with the `dispatch_create_queue()` function is that with the `dispatch_create_queue()`
    function, we are actually creating a new queue. The queues that are returned with
    the `dispatch_get_global_queue()` function are global queues that are created
    when our application first starts; therefore, we are requesting a queue rather
    than creating a new one.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们请求具有默认优先级的全局队列。然后我们可以像使用我们使用`dispatch_queue_create()`函数创建的并发队列一样使用此队列。使用`dispatch_get_global_queue()`函数返回的队列与使用`dispatch_create_queue()`函数创建的队列之间的区别在于，使用`dispatch_create_queue()`函数时，我们实际上是在创建一个新的队列。使用`dispatch_get_global_queue()`函数返回的队列是在我们的应用程序首次启动时创建的全局队列；因此，我们是在请求一个队列而不是创建一个新的队列。
- en: When we use the `dispatch_get_global_queue()` function, we avoid the overhead
    of creating the queue; therefore, I recommend using the `dispatch_get_global_queue()`
    function unless you have a specific reason to create a queue.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`dispatch_get_global_queue()`函数时，我们避免了创建队列的开销；因此，除非你有特定的理由来创建队列，否则我建议使用`dispatch_get_global_queue()`函数。
- en: Requesting the main queue with the dispatch_get_main_queue() function
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`dispatch_get_main_queue()`函数请求主队列
- en: The `dispatch_get_main_queue()` function returns the main queue for our application.
    The main queue is automatically created for the main thread when the application
    starts. This main queue is a serial queue; therefore, items in this queue are
    executed one at a time, in the order that they were submitted. We will generally
    want to avoid using this queue unless we have a need to update the user interface
    from a background thread.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch_get_main_queue()`函数返回我们的应用程序的主队列。当应用程序启动时，为主线程自动创建主队列。这个主队列是一个串行队列；因此，队列中的项目将按它们提交的顺序逐个执行。我们通常想要避免使用这个队列，除非我们需要从后台线程更新用户界面。'
- en: 'The `dispatch_get_main_queue()` function has the following syntax:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch_get_main_queue()`函数的语法如下：'
- en: '[PRE16]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following code example shows how to request the main queue:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码示例展示了如何请求主队列：
- en: '[PRE17]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We will then submit tasks to the main queue exactly as we would any other serial
    queue. Just remember that anything submitted to this queue will run on the main
    thread, which is the thread that all the user interface updates run on; therefore,
    if we submitted a long running task, the user interface will freeze until that
    task is completed.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像提交任何其他串行队列一样将任务提交到主队列。只需记住，提交到这个队列的任何内容都将运行在主线程上，这是所有用户界面更新运行的线程；因此，如果我们提交了一个长时间运行的任务，用户界面将冻结，直到该任务完成。
- en: In the previous sections, we saw how the `dispatch_async()` functions submit
    tasks to concurrent and serial queues. Now, let's look at two additional functions
    that we can use to submit tasks to our queues. The first function we will look
    at is the `dispatch_after()` function.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们看到了`dispatch_async()`函数是如何将任务提交到并发和串行队列中的。现在，让我们看看两个额外的函数，我们可以使用它们将任务提交到我们的队列中。我们将首先查看的函数是`dispatch_after()`函数。
- en: Using the dispatch_after() function
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`dispatch_after()`函数
- en: 'There will be times that we need to execute tasks after a delay. If we were
    using a threading model, we would need to create a new thread, perform some sort
    of delay or sleep function, and execute our task. With GCD, we can use the `dispatch_after()`
    function. The `dispatch_after()` function takes the following syntax:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候我们需要在延迟后执行任务。如果我们使用线程模型，我们需要创建一个新的线程，执行某种延迟或睡眠函数，然后执行我们的任务。使用GCD，我们可以使用`dispatch_after()`函数。`dispatch_after()`函数的语法如下：
- en: '[PRE18]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, the `dispatch_after()` function takes the following parameters:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dispatch_after()`函数接受以下参数：
- en: '`when`: This is the time that we wish the queue to execute our task in'
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when`：这是我们希望队列执行我们的任务的时间'
- en: '`queue`: This is the queue that we want to execute our task in'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`queue`：这是我们想要在队列中执行我们的任务。'
- en: '`block`: This is the task to execute'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`block`：这是要执行的任务'
- en: As with the `dispatch_async()` and `dispatch_synch()` functions, we do not need
    to include our task as a parameter. We can include our task to execute between
    two curly brackets exactly as we did previously with the `dispatch_async()` and
    `dispatch_synch()` functions.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与`dispatch_async()`和`dispatch_synch()`函数一样，我们不需要将任务作为参数包含。我们可以在两个大括号之间包含要执行的任务，就像我们之前在`dispatch_async()`和`dispatch_synch()`函数中做的那样。
- en: 'As we can see from the `dispatch_after()` function, we use the `dispatch_time_t`
    type to define the time to execute the task. We use the `dispatch_time()` function
    to create the `dispatch_time_t` type. The `dispatch_time()` function has the following
    syntax:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从`dispatch_after()`函数中看到的，我们使用`dispatch_time_t`类型来定义执行任务的时间。我们使用`dispatch_time()`函数来创建`dispatch_time_t`类型。`dispatch_time()`函数的语法如下：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Here, the `dispatch_time()` function takes the following parameter:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`dispatch_time()`函数接受以下参数：
- en: '`when`: This value is used as the basis for the time to execute the task. We
    generally pass the `DISPATCH_TIME_NOW` value to create the time, based on the
    current time.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`when`：这个值用作执行任务的时间基础。我们通常传递`DISPATCH_TIME_NOW`值来创建基于当前时间的时。'
- en: '`delta`: This is the number of nanoseconds to add to the `when` parameter to
    get our time.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delta`：这是要添加到`when`参数中的纳秒数，以获取我们的时间。'
- en: 'We will use the `dispatch_time()` and `dispatch_after()` functions like this:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将像这样使用`dispatch_time()`和`dispatch_after()`函数：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The preceding code will execute the task after a two-second delay. In the `dispatch_
    time()` function, we create a `dispatch_time_t` type that is two seconds in the
    future. The `NSEC_PER_SEC` constant is use to calculate the nanoseconds from seconds.
    After the two-second delay, we print the message, `Times Up`, to the console.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码将在两秒后执行任务。在`dispatch_time()`函数中，我们创建了一个`dispatch_time_t`类型，表示未来两秒。`NSEC_PER_SEC`常量用于从秒计算纳秒。在两秒的延迟后，我们将消息“Times
    Up”打印到控制台。
- en: 'There is one thing to watch out for with the `dispatch_after()` function. Let''s
    take a look at the following code:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`dispatch_after()`函数时要注意的一件事是。让我们看一下以下代码：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In this code, we begin by creating a serial queue and then adding two tasks
    to the queue. The first task uses the `dispatch_after()` function, and the second
    task uses the `dispatch_sync()` function. Our initial thought would be that when
    we executed this code within the serial queue, the first task would execute after
    a two-second delay and then the second task would execute; however, this would
    not be correct. The first task is submitted to the queue and executed immediately.
    It also returns immediately, which lets the queue execute the next task while
    it waits for the correct time to execute the first task. Therefore, even though
    we are running the tasks in a serial queue, the second task completes before the
    first task. The following is an example of the output if we run the preceding
    code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建了一个串行队列，然后向队列中添加了两个任务。第一个任务使用了`dispatch_after()`函数，第二个任务使用了`dispatch_sync()`函数。我们最初的设想可能是，当我们在这个串行队列中执行这段代码时，第一个任务会在两秒后执行，然后才是第二个任务；然而，这并不正确。第一个任务被提交到队列中并立即执行。它也立即返回，这使得队列在等待第一个任务正确执行的时间的同时执行下一个任务。因此，尽管我们在串行队列中运行任务，第二个任务却在第一个任务之前完成。以下是在运行前面的代码时的输出示例：
- en: '[PRE22]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The final GCD function that we are going to look at is `dispatch_once()`.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的最后一个GCD函数是`dispatch_once()`。
- en: Using the dispatch_once() function
  id: totrans-131
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用`dispatch_once()`函数
- en: The `dispatch_once()` function will execute a task once, and only once, for
    the lifetime of the application. What this means is that the task will be executed
    and marked as executed, then that task will not be executed again unless the application
    restarts. While the `dispatch_once()` function can be and has been used to implement
    the singleton pattern, there are other easier ways to do this. Refer to [Chapter
    17](ch17.html "Chapter 17. Adopting Design Patterns in Swift"), *Adopting Design
    Patterns in Swift*, for examples on how to implement the singleton design pattern.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch_once()`函数将只在应用程序的生命周期内执行一次任务，并且只执行一次。这意味着任务将被执行并标记为已执行，然后除非应用程序重新启动，否则该任务将不再执行。虽然`dispatch_once()`函数可以，并且已经被用来实现单例模式，但还有其他更简单的方法可以做到这一点。请参阅[第17章](ch17.html
    "第17章。在Swift中采用设计模式")，*在Swift中采用设计模式*，了解如何实现单例设计模式的示例。'
- en: 'The `dispatch_once()` function is great for executing initialization tasks
    that need to run when our application initially starts. These initialization tasks
    can consist of initializing our data store or variables and objects. The following
    code shows the syntax for the `dispatch_once()` function:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`dispatch_once()`函数非常适合执行在应用程序最初启动时需要运行的任务。这些初始化任务可以包括初始化我们的数据存储或变量和对象。以下代码显示了`dispatch_once()`函数的语法：'
- en: '[PRE23]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Let''s look at how to use the `dispatch_once()` function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用`dispatch_once()`函数：
- en: '[PRE24]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this example, the line that prints the message, `Printed only on the first
    call`, will be executed only once, no matter how many times the function is called.
    However, the line that prints the `Printed for each call` message will be executed
    each time the function is called. Let''s see this in action by calling this function
    four times, like this:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，打印消息“仅在第一次调用时打印”的行只会执行一次，无论函数被调用多少次。然而，打印“每次调用都打印”消息的行会在每次函数调用时执行。让我们通过四次调用这个函数来观察这个行为，如下所示：
- en: '[PRE25]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'If we execute this example, we should see the following output:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们执行这个示例，我们应该看到以下输出：
- en: '[PRE26]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Notice, in this example, that we only see the `Printed only on the first call`
    message once whereas we see the `Printed for each call` message all the four times
    that we call the function.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个例子中，我们只看到了一次“仅在第一次调用时打印”的消息，而“每次调用都打印”的消息在四次调用函数时都出现了。
- en: Now that we have looked at GCD, let's take a look at operation queues.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经了解了GCD，让我们来看看操作队列。
- en: Using NSOperation and NSOperationQueue types
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 NSOperation 和 NSOperationQueue 类型
- en: The `NSOperation` and `NSOperationQueues` types, working together, provide us
    with an alternative to GCD for adding concurrency to our applications. Operation
    queues are Cocoa objects that function like dispatch queues and internally, operation
    queues are implemented using GCD. We define the tasks (`NSOperations`) that we
    wish to execute and then add the task to the operation queue (`NSOperationQueue`).
    The operation queue will then handle the scheduling and execution of tasks. Operation
    queues are instances of the `NSOperationQueue` class and operations are instances
    of the `NSOperation` class.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperation` 和 `NSOperationQueues` 类型协同工作，为我们提供了在应用程序中添加并发的替代方案。操作队列是 Cocoa
    对象，其功能类似于调度队列，并且内部，操作队列使用 GCD 实现。我们定义要执行的任务（`NSOperations`），然后将任务添加到操作队列（`NSOperationQueue`）。然后，操作队列将处理任务的调度和执行。操作队列是
    `NSOperationQueue` 类的实例，操作是 `NSOperation` 类的实例。'
- en: The operation represents a single unit of work or task. The `NSOperation` type
    is an abstract class that provides a thread-safe structure for modeling the state,
    priority, and dependencies. This class must be subclassed in order to perform
    any useful work.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 操作代表一个单独的工作单元或任务。`NSOperation` 类型是一个抽象类，它提供了一个线程安全的结构来模拟状态、优先级和依赖关系。为了执行任何有用的操作，必须对该类进行子类化。
- en: Apple does provide two concrete implementations of the `NSOperation` type that
    we can use as-is for situations where it does not make sense to build a custom
    subclass. These subclasses are `NSBlockOperation` and `NSInvocationOperation`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 苹果确实提供了两种 `NSOperation` 类型的具体实现，我们可以直接使用，对于不需要构建自定义子类的情况。这些子类是 `NSBlockOperation`
    和 `NSInvocationOperation`。
- en: More than one operation queue can exist at the same time, and actually, there
    is always at least one operation queue running. This operation queue is known
    as the **main queue**. The main queue is automatically created for the main thread
    when the application starts and is where all the UI operations are performed.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 同时可以存在多个操作队列，实际上，总是至少有一个操作队列在运行。这个操作队列被称为 **主队列**。当应用程序启动时，主队列会自动为主线程创建，并且所有
    UI 操作都在这里执行。
- en: There are several ways that we can use the `NSOperation` and `NSOperationQueues`
    classes to add concurrency to our application. In this chapter, we will look at
    three different ways. The first one we will look at is using the `NSBlockOperation`
    implementation of the `NSOperation` abstract class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有几种方法可以使用 `NSOperation` 和 `NSOperationQueues` 类来为我们的应用程序添加并发。在本章中，我们将探讨三种不同的方法。我们将首先查看的是使用
    `NSOperation` 抽象类的 `NSBlockOperation` 实现方式。
- en: Using the NSBlockOperation implementation of NSOperation
  id: totrans-149
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 NSOperation 的 NSBlockOperation 实现方式
- en: In this section, we will be using the same `DoCalculation` class that we used
    in the *Grand Central Dispatch* section to keep our queues busy with work so that
    we can see how the `NSOpererationQueues` class work.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用与 *Grand Central Dispatch* 部分中相同的 `DoCalculation` 类，以保持我们的队列忙碌于工作，这样我们就可以看到
    `NSOperationQueues` 类的工作原理。
- en: The `NSBlockOperation` class is a concrete implementation of the `NSOperation`
    type that can manage the execution of one or more blocks. This class can be used
    to execute several tasks at once without the need to create separate operations
    for each task.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSBlockOperation` 类是 `NSOperation` 类型的具体实现，可以管理一个或多个块的执行。这个类可以用来同时执行多个任务，而无需为每个任务创建单独的操作。'
- en: 'Let''s see how to use the `NSBlockOperation` class to add concurrency to our
    application. The following code shows how to add three tasks to an operation queue
    using a single `NSBlockOperation` instance:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `NSBlockOperation` 类来为我们的应用程序添加并发。以下代码展示了如何使用单个 `NSBlockOperation`
    实例将三个任务添加到操作队列中：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this code, we begin by creating an instance of the `DoCalculation` class
    and an instance of the `NSOperationQueue` class. Next, we created an instance
    of the `NSBlockOperation` class using the `init` constructor. This constructor
    takes a single parameter, which is a block of code that represents one of the
    tasks we want to execute in the queue. Next, we add two additional tasks to the
    `NSBlockOperation` instance using the `addExecutionBlock()` method.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建 `DoCalculation` 类的一个实例和 `NSOperationQueue` 类的一个实例。接下来，我们使用 `init`
    构造函数创建 `NSBlockOperation` 类的一个实例。这个构造函数接受一个参数，它是一个代码块，代表我们想在队列中执行的任务之一。然后，我们使用
    `addExecutionBlock()` 方法向 `NSBlockOperation` 实例添加两个额外的任务。
- en: This is one of the differences between dispatch queues and operations. With
    dispatch queues, if resources are available, the tasks are executed as they are
    added to the queue. With operations, the individual tasks are not executed until
    the operation itself is submitted to an operation queue.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是调度队列和操作之间的一种区别。在调度队列中，如果资源可用，任务会按照它们被添加到队列的顺序执行。在操作中，各个任务不会执行，直到操作本身被提交到操作队列。
- en: Once we add all of the tasks to the `NSBlockOperation` instance, we then add
    the operation to the `NSOperationQueue` instance that we created at the beginning
    of the code. At this point, the individual tasks within the operation start to
    execute.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将所有任务添加到 `NSBlockOperation` 实例中，我们接着将操作添加到我们在代码开头创建的 `NSOperationQueue`
    实例中。此时，操作内的各个任务开始执行。
- en: 'This example shows how to use `NSBlockOperation` to queue up multiple tasks
    and then pass the tasks to the operation queue. The tasks are executed in a FIFO
    order; therefore, the first task that is added to the `NSBlockOperation` instance
    will be the first task executed. However, since the tasks can be executed concurrently
    if we have the available resources, the output from this code should look similar
    to this:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子展示了如何使用 `NSBlockOperation` 将多个任务排队，然后将任务传递给操作队列。任务按照先进先出的顺序执行；因此，第一个添加到
    `NSBlockOperation` 实例的任务将是第一个执行的任务。然而，由于如果我们有可用资源，任务可以并发执行，所以这段代码的输出应该看起来像这样：
- en: '[PRE28]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'What if we do not want our tasks to run concurrently? What if we wanted them
    to run serially like the serial dispatch queue? We can set a property in our operation
    queue that defines the number of tasks that can be run concurrently in the queue.
    The property is called `maxConcurrentOperationCount` and is used like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不希望我们的任务并发运行呢？如果我们希望它们像串行调度队列一样按顺序运行呢？我们可以在我们的操作队列中设置一个属性，该属性定义了队列中可以并发运行的任务数量。这个属性叫做
    `maxConcurrentOperationCount`，其使用方式如下：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: However, if we added this line to our previous example, it will not work as
    expected. To see why this is, we need to understand what the property actually
    defines. If we look at Apple's `NSOperationQueue` class reference, the definition
    of the property says, "The maximum number of queued operations that can execute
    at the same time."
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们把这一行添加到之前的例子中，它将不会按预期工作。为了了解为什么，我们需要理解这个属性实际上定义了什么。如果我们查看苹果的 `NSOperationQueue`
    类参考，属性的说明是：“可以同时执行的最大队列操作数。”
- en: What this tells us is that the `maxConcurrentOperationCount` property defines
    the number of operations (this is the key word) that can be executed at the same
    time. The `NSBlockOperation` instance, which we added all of our tasks to, represents
    a single operation; therefore, no other `NSBlockOperation` added to the queue
    will execute until the first one is complete, but the individual tasks within
    the operation will execute concurrently. To run the tasks serially, we would need
    to create a separate instance of the `NSBlockOperations` for each task.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们，`maxConcurrentOperationCount` 属性定义了可以同时执行的操作数量（这是关键词）。我们添加所有任务到的 `NSBlockOperation`
    实例代表了一个单一的操作；因此，不会执行添加到队列中的其他 `NSBlockOperation`，直到第一个完成，但操作内的各个任务可以并发执行。如果我们想按顺序执行任务，我们需要为每个任务创建一个单独的
    `NSBlockOperations` 实例。
- en: Using an instance of the `NSBlockOperation` class good if we have a number of
    tasks that we want to execute concurrently, but they will not start executing
    until we add the operation to an operation queue. Let's look at a simpler way
    of adding tasks to an operation queue using the queues `addOperationWithBlock()`
    methods.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一系列想要并发执行的任务，使用 `NSBlockOperation` 类的实例是好的，但它们不会开始执行，直到我们将操作添加到操作队列中。让我们看看使用队列的
    `addOperationWithBlock()` 方法将任务添加到操作队列的更简单方法。
- en: Using the addOperationWithBlock() method of the operation queue
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用操作队列的 `addOperationWithBlock()` 方法
- en: 'The `NSOperationQueue` class has a method named `addOperationWithBlock()` that
    makes it easy to add a block of code to the queue. This method automatically wraps
    the block of code in an operation object and then passes that operation to the
    queue itself. Let''s see how to use this method to add tasks to a queue:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperationQueue` 类有一个名为 `addOperationWithBlock()` 的方法，这使得向队列中添加代码块变得简单。此方法会自动将代码块包装在操作对象中，然后将该操作传递给队列本身。让我们看看如何使用此方法将任务添加到队列中：'
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `NSBlockOperation` example, earlier in this chapter, we added the tasks
    that we wished to execute into an `NSBlockOperation` instance. In this example,
    we are adding the tasks directly to the operation queue, and each task represents
    one complete operation. Once we create the instance of the operation queue, we
    then use the `addOperationWithBlock()` method to add the tasks to the queue.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章前面的`NSBlockOperation`示例中，我们将希望执行的任务添加到了一个`NSBlockOperation`实例中。在这个示例中，我们直接将任务添加到操作队列中，每个任务代表一个完整的操作。一旦我们创建了操作队列的实例，我们就使用`addOperationWithBlock()`方法将任务添加到队列中。
- en: Also, in the `NSBlockOperation` example, the individual tasks did not execute
    until all of the tasks were added to the `NSBlockOperation` object and then that
    operation was added to the queue. This `addOperationWithBlock()` example is similar
    to the GCD example where the tasks begin executing as soon as they are added to
    the operation queue.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在`NSBlockOperation`示例中，各个任务在所有任务都添加到`NSBlockOperation`对象并且该操作被添加到队列之前不会执行。这个`addOperationWithBlock()`示例与GCD示例类似，其中任务在添加到操作队列后立即开始执行。
- en: 'If we run the preceding code, the output should be similar to this:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行前面的代码，输出应该类似于以下内容：
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'You will notice that the operations are executed concurrently. With this example,
    we can execute the tasks serially by using the `maxConcurrentOperationCount` property
    that we mentioned earlier. Let''s try this by initializing the `NSOperationQueue`
    instance like this:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到操作是并发执行的。使用这个示例，我们可以通过使用我们之前提到的`maxConcurrentOperationCount`属性来按顺序执行任务。让我们通过以下方式初始化`NSOperationQueue`实例来尝试这一点：
- en: '[PRE32]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, if we run the example, the output should be similar to this:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们运行这个示例，输出应该类似于以下内容：
- en: '[PRE33]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In this example, we can see that each task waited for the previous task to complete
    prior to starting.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们可以看到每个任务在开始之前都等待前一个任务完成。
- en: Using the `addOperationWithBlock()` method to add tasks, the operation queue
    is generally easier than using the `NSBlockOperation` method; however, the tasks
    will begin as soon as they are added to the queue, which is usually the desired
    behavior.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`addOperationWithBlock()`方法添加任务，通常比使用`NSBlockOperation`方法更容易；然而，任务将在它们被添加到队列后立即开始执行，这通常是期望的行为。
- en: Now, let's look at how we can subclass the `NSOperation` class to create an
    operation that we can add directly to an operation queue.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们如何继承`NSOperation`类来创建一个可以直接添加到操作队列中的操作。
- en: Subclassing the NSOperation class
  id: totrans-178
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 继承`NSOperation`类
- en: The previous two examples showed how to add small blocks of code to our operation
    queues. In these examples, we called the `performCalculations` method in the `DoCalculation`
    class to perform our tasks. These examples illustrate two really good ways to
    add concurrency for functionally that is already written, but what if, at design
    time, we want to design our `DoCalculation` class for concurrency? For this, we
    can subclass the `NSOperation` class.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个示例展示了如何将小块代码添加到我们的操作队列中。在这些示例中，我们调用了`DoCalculation`类中的`performCalculations`方法来执行我们的任务。这些示例说明了两种非常好的方法来为已经编写的功能添加并发性，但如果我们希望在设计时为`DoCalculation`类设计并发性，那会怎样呢？为此，我们可以继承`NSOperation`类。
- en: 'The `NSOperation` abstract class provides a significant amount of infrastructure.
    This allows us to very easily create a subclass without a lot of work. We should
    at least provide an `initialization` method and a `main` method. The `main` method
    will be called when the queue begins executing the operation:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`NSOperation`抽象类提供了大量的基础设施。这使得我们能够非常容易地创建一个子类而不需要做很多工作。我们至少应该提供一个`initialization`方法和一个`main`方法。`main`方法将在队列开始执行操作时被调用：'
- en: 'Let''s see how to implement the `DoCalculation` class as a subclass of the
    `NSOperation` class; we will call this new class `MyOperation`:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将`DoCalculation`类实现为`NSOperation`类的子类；我们将这个新类称为`MyOperation`：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We begin by defining that the `MyOperation` class is a subclass of the `NSOperation`
    class. Within the implementation of the class, we define two class constants,
    which represent the iteration count and the tag that the `performCalculations()`
    method uses. Keep in mind that when the operation queue begins executing the operation,
    it will call the `main()` method with no parameters; therefore, any parameters
    that we need to pass in must be passed in through the initializer.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义 `MyOperation` 类是 `NSOperation` 类的子类。在类的实现中，我们定义了两个类常量，它们代表 `performCalculations()`
    方法使用的迭代次数和标签。请记住，当操作队列开始执行操作时，它将不带参数调用 `main()` 方法；因此，我们需要传递的任何参数都必须通过初始化器传递。
- en: In this example, our initializer takes two parameters that are used to set the
    `iterations` and `tag` classes constants. Then the `main()` method, that the operation
    queue is going to call to begin execution of the operation, simply calls the `performCalculation()`
    method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们的初始化器接受两个参数，用于设置 `iterations` 和 `tag` 类常量。然后 `main()` 方法，操作队列将要调用来开始执行操作，简单地调用
    `performCalculation()` 方法。
- en: 'We can now very easily add instances of our `MyOperation` class to an operation
    queue, like this:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以非常容易地将我们的 `MyOperation` 类的实例添加到操作队列中，如下所示：
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'If we run this code, we will see the following results:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行此代码，我们将看到以下结果：
- en: '[PRE36]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'As we saw earlier, we can also execute the tasks serially by adding the following
    line, which sets the `maxConcurrentOperationCount` property of the operation queue:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们之前所见，我们也可以通过添加以下行来顺序执行任务，该行设置操作队列的 `maxConcurrentOperationCount` 属性：
- en: '[PRE37]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If we know that we need to execute some functionality concurrently prior to
    writing the code, I will recommend subclassing the `NSOperation` class, as shown
    in this example, rather than using the previous examples. This gives us the cleanest
    implementation; however, there is nothing wrong with using the `NSBlockOperation`
    class or the `addOperationWithBlock()` methods described earlier in this section.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们知道在编写代码之前需要并发执行某些功能，我建议像这个例子一样对 `NSOperation` 类进行子类化，而不是使用之前的例子。这给我们提供了最干净的实现；然而，使用
    `NSBlockOperation` 类或本节之前描述的 `addOperationWithBlock()` 方法并没有什么问题。
- en: Summary
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Before we consider adding concurrency to our application, we should make sure
    that we understand why we are adding it and ask ourselves whether it is necessary.
    While concurrency can make our application more responsive by offloading work
    from our main application thread to a background thread, it also adds extra complexity
    to our code and overhead to our application. I have even seen numerous applications,
    in various languages, which actually run better after we pulled out some of the
    concurrency code. This is because the concurrency was not well thought out or
    planned. With this in mind, it is always a good idea to think and talk about concurrency
    while we are discussing the application's expected behavior.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们考虑将并发性添加到我们的应用程序之前，我们应该确保我们理解为什么我们要添加它，并问自己这是否是必要的。虽然并发性可以通过将工作从主应用程序线程卸载到后台线程来使我们的应用程序更响应，但它也增加了我们代码的额外复杂性和应用程序的开销。我甚至看到过许多在各种语言中运行得更好的应用程序，在移除一些并发代码之后。这是因为并发性没有经过深思熟虑或计划。考虑到这一点，在我们讨论应用程序预期行为时，思考和讨论并发性总是一个好主意。
- en: At the start of this chapter, we had a discussion about running tasks concurrently
    compared to running tasks in parallel. We also discussed the hardware limitation
    that limits how many tasks can run in parallel on a given device. Having a good
    understanding of those concepts is very important to understanding how and when
    to add concurrency to our projects.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开始，我们讨论了与顺序运行任务相比并行运行任务。我们还讨论了限制特定设备上可以并行运行多少任务的硬件限制。对这些概念有良好的理解对于理解如何在何时将并发性添加到我们的项目中非常重要。
- en: While GCD is not limited to system-level applications, before we use it in our
    application, we should consider whether operation queues would be easier and more
    appropriate for our needs. In general, we should use the highest level of abstraction
    that meets our needs. This will usually point us to using operation queues; however,
    there really is nothing preventing us from using GCD, and it may be more appropriate
    for our needs.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 GCD 并不仅限于系统级应用，但在我们将其应用于我们的应用程序之前，我们应该考虑操作队列是否会更简单、更适合我们的需求。一般来说，我们应该使用满足我们需求的最高级别的抽象。这通常会将我们引向使用操作队列；然而，实际上并没有什么阻止我们使用
    GCD，它可能更适合我们的需求。
- en: One thing to keep in mind with operation queues is that they do add additional
    overhead because they are Cocoa objects. For the large majority of applications,
    this little extra overhead should not be an issue or even noticed; however, for
    some projects, such as games that need every last resource that they can get,
    this extra overhead might very well be an issue.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在操作队列中需要注意的一点是，由于它们是 Cocoa 对象，因此确实会增加额外的开销。对于大多数应用程序来说，这微小的额外开销不应成为问题，甚至可能不会被察觉；然而，对于一些项目，例如需要获取所有可用资源的游戏，这额外的开销可能确实成为一个问题。
