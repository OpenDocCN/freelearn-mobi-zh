- en: Chapter 9. Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章 优化
- en: '*In the previous chapter, we learned about special effects for our games. We
    added background music to our Space Fighter game. We also created engine trails
    for our ship. Combining both audio effects and particle systems, we created some
    explosions and gun blasts. Together, this rounds out the game experience and gives
    us a very complete-looking game.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在前一章中，我们学习了关于我们游戏的特效。我们在太空战斗机游戏中添加了背景音乐。我们还为我们的飞船创建了引擎尾迹。通过结合音频效果和粒子系统，我们创建了一些爆炸和枪炮声。这一切共同完善了游戏体验，使我们拥有了一个看起来非常完整的游戏。*'
- en: '*In this chapter, we explore our options for optimization. We start by looking
    at the application footprint, and how to reduce it. We move on to look at the
    game''s performance. We look at the tools that Unity provides and create another
    one ourselves. With the use of occlusion culling, we can improve the game''s performance
    even further. Finally, we will explore some key areas that can cause lag and how
    to minimize their effects.*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*在本章中，我们探讨了我们的优化选项。我们首先查看应用程序的占用空间，以及如何减少它。然后我们转向查看游戏性能。我们查看Unity提供的工具，并自己创建了一个。通过使用遮挡剔除，我们可以进一步提高游戏性能。最后，我们将探讨一些可能导致延迟的关键区域以及如何最小化它们的影响。*'
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Minimizing the application footprint
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化应用程序占用空间
- en: Tracking performance
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 跟踪性能
- en: Minimizing lag
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最小化延迟
- en: Occlusion
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遮挡
- en: We will be working on both our Space Fighter and Tank Battle games, for this
    chapter. Start by opening the Space Fighter project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，我们将同时处理我们的太空战斗机和坦克大战游戏。首先打开太空战斗机项目。
- en: Minimizing the application footprint
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最小化应用程序占用空间
- en: One of the keys to a successful game is the size of the game itself. Many users
    will quickly uninstall any application that appears to be unnecessarily large.
    Also, all of the mobile app stores have limits to how your game will be supplied
    to users based on the size of the application itself. Becoming familiar with the
    options you have for minimizing the size of your game is the key to control how
    your game will be distributed.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏成功的关键之一是游戏本身的大小。许多用户会迅速卸载任何看起来不必要的应用程序。此外，所有移动应用商店都对根据应用程序本身的大小向用户供应游戏有大小限制。熟悉您用于最小化游戏大小的选项是控制游戏分发方式的关键。
- en: The first thing to note when working to minimize the footprint is how Unity
    handles assets as it builds the game. Only assets that are used somewhere in one
    of the scenes for the build are actually included in the game. If it is not in
    the scene itself or referenced by an asset that is in the scene, it will not be
    included. This means you could have test versions of assets, or incomplete versions;
    as long as they are not referenced, they will not affect the final build size
    of your game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试最小化占用空间时，首先要注意的是Unity在构建游戏时如何处理资产。只有用于构建中某个场景的资产才会实际包含在游戏中。如果它不在场景本身中，或者没有由场景中的资产引用，它将不会被包含。这意味着您可能有资产的测试版本或不完整的版本；只要它们没有被引用，它们就不会影响您游戏最终构建的大小。
- en: Unity also allows you to keep your assets in the format you need for working
    on them. When the final build is made, all assets are converted to an appropriate
    version for their type. This means you can keep models in the format native to
    your modeling program. Or keep your images as Photoshop files, or any other format
    you work in, and they will be converted to `JPG` or `PNG` appropriately when the
    game is built.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: Unity还允许您以您需要用于工作的格式保存您的资产。当最终构建完成时，所有资产都会转换为适合其类型的适当版本。这意味着您可以保持模型为建模程序的原始格式。或者保持您的图像为Photoshop文件，或者您工作的任何其他格式，当游戏构建时，它们将被适当地转换为`JPG`或`PNG`。
- en: Editor log
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器日志
- en: When you are finally ready to work with the footprint of your game, it is possible
    to find out exactly what is causing your game to be larger than desired. In the
    top-right corner of the **Console** window is a drop-down menu button. Inside
    this menu is **Open Editor Log**.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当您最终准备好处理游戏占用空间时，您可以找出确切是什么导致您的游戏比预期要大。在**控制台**窗口的右上角有一个下拉菜单按钮。在这个菜单内部是**打开编辑器日志**。
- en: '![Editor log](img/2014OT_09_07.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器日志](img/2014OT_09_07.jpg)'
- en: The editor log is the location where Unity outputs information while it is running.
    This includes information about the current version, license checks, and any asset
    importing. The log will also contain detailed information about the file size
    and assets included in the game, after it has been built.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器日志是Unity在运行时输出信息的位置。这包括有关当前版本、许可证检查以及任何资产导入的信息。在构建完成后，日志还将包含有关游戏文件大小和包含的资产的相关详细信息。
- en: '![Editor log](img/2014OT_09_08.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器日志](img/2014OT_09_08.jpg)'
- en: We can see a breakdown of the aspects of the final build. Every asset category
    has a size and percentage of the total build size. We are also supplied with a
    list of every asset that is actually included in the game, organized by their
    file size before being added to the build. This information becomes very useful
    when looking for assets that can stand to be made smaller.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到最终构建方面的分解。每个资产类别都有一个大小和总构建大小的百分比。我们还提供了一份实际包含在游戏中的每个资产的列表，按其文件大小排序，在添加到构建之前。当寻找可以缩小尺寸的资产时，这些信息变得非常有用。
- en: Asset compression
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 资产压缩
- en: Inside the **Import Settings** for models, textures, and audio there are options
    that affect the size and quality of imported assets. In general, the affected
    change is a reduction in quality. However, especially when working on mobile devices,
    asset quality can be reduced well below the levels required for a computer before
    the difference is noticeable on the device. Once you understand the options available
    for each type of asset, you will be able to make optimal decisions regarding the
    quality of your game. When working with any of these options, look for a setting
    that minimizes the size before introducing undesired artifacts.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在模型的导入设置中，包括纹理和音频，有影响导入资产大小和质量的选项。一般来说，受影响的变化是质量的降低。然而，尤其是在移动设备上工作时，资产质量可以降低到低于计算机所需的水平，而在设备上差异不明显。一旦你了解了每种类型资产可用的选项，你将能够就你游戏的质量做出最佳决策。在使用这些选项中的任何一项时，寻找一个在引入不希望出现的失真之前最小化大小的设置。
- en: Models
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型
- en: No matter what program or method you use to create your models, ultimately they
    are always a list of vertex positions and triangles, with a few references to
    textures. Most of the file size of a model comes from the list of vertex positions.
    To make sure the models in your game are of the highest quality, start in the
    modeling program of your choice. Delete any and all extra vertexes and faces.
    Not only will this result in a smaller file when building your final game, it
    will also reduce the import time when working in the editor.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你使用什么程序或方法来创建你的模型，最终它们始终是一系列顶点位置和三角形，以及一些纹理的引用。模型的大部分文件大小来自顶点位置的列表。为了确保你游戏中的模型具有最高质量，从你选择的建模程序开始。删除任何额外的顶点和面。这不仅会在构建最终游戏时导致文件更小，还会在编辑器中工作时减少导入时间。
- en: The **Import Settings** for models consists of three pages, resulting in more
    options to adjust the quality. Each page tab corresponds to the relevant part
    of the model, allowing us to fine-tune each one of them.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 模型的**导入设置**由三个页面组成，从而提供了更多调整质量的选项。每个页面选项卡对应于模型的相应部分，使我们能够精细调整每一个。
- en: Model tab
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 模型选项卡
- en: 'On the **Model** tab, we are able to affect how the mesh is imported. When
    it comes to optimizing our use of the models, there are many options here that
    are key to success. Once your game is looking and playing the way you want it
    to, we should have a good look at the settings shown in the following screenshot:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在**模型**选项卡上，我们可以影响网格的导入方式。当涉及到优化模型的使用时，这里有许多关键成功的选择。一旦你的游戏看起来和玩起来是你想要的样子，我们应该仔细查看以下截图所示的设置：
- en: '![Model tab](img/2014OT_09_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![模型选项卡](img/2014OT_09_03.jpg)'
- en: 'The settings available under the **Model** tab are explained as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在**模型**选项卡下可用的设置解释如下：
- en: '**Mesh Compression**: This option lets us select how much compression should
    be applied to the model. The effect amounts to combining vertexes to reduce the
    overall amount of detail that has to be stored for the mesh. This setting is likely
    to introduce undesired oddities in the mesh. So, always pick the highest setting
    that does not introduce any artifacts.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格压缩**：此选项让我们选择应该应用于模型的多大压缩量。效果相当于合并顶点以减少存储网格所需的总细节量。此设置可能会在网格中引入不希望出现的奇异性。因此，始终选择不会引入任何失真的最高设置。'
- en: '**Read/Write Enabled**: This option is only useful when you want to manipulate
    the mesh while the game is running, through the script. If you never touch the
    mesh with any of your scripts, uncheck this box. While not affecting the final
    build size, this will affect how much memory is required to run your game.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**读写启用**：这个选项仅在您希望在游戏运行时通过脚本操作网格时才有用。如果您永远不会用任何脚本触摸网格，请取消选中此框。虽然不会影响最终构建的大小，但这将影响运行游戏所需的内存量。'
- en: '**Optimize Mesh**: This option causes Unity to reorder the triangles list that
    describes the model. This is always a good one to leave checked. The only reason
    you might want to uncheck it is if you are manipulating the game or mesh based
    on the specific order of the triangles.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格**：这个选项会导致Unity重新排序描述模型的三角形列表。这始终是一个值得勾选的好选项。您可能想要取消勾选的唯一原因是如果您正在根据三角形的特定顺序操作游戏或网格。'
- en: '**Generate Colliders**: This option is almost always a candidate to leave off.
    This option will add Mesh Collider components to every mesh in your model. These
    are relatively expensive to calculate when working with physics in your game.
    If possible, you should always use a group of the significantly simpler Box Colliders
    and Sphere Colliders.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成碰撞器**：这个选项几乎总是可以省略的。这个选项会将网格碰撞器组件添加到模型中的每个网格上。当在游戏中处理物理时，这些计算相对昂贵。如果可能的话，你应该始终使用一组显著更简单的盒子碰撞器和球体碰撞器。'
- en: '**Generate Lightmap UVs**: This option should only be used when working with
    objects that need static shadows. If the object does not, it will introduce excess
    vertex information and bloat the asset.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成光照贴图UV**：这个选项仅在处理需要静态阴影的对象时使用。如果对象不需要，它将引入多余的顶点信息并使资产膨胀。'
- en: '**Normals**: This option is used by materials for determining which direction
    a vertex faces and how lighting should affect it. If the mesh never uses a material
    needing **Normals** information, be sure to set this to **None**.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线**：这个选项用于材料确定顶点面向哪个方向以及光照应该如何影响它。如果网格从未使用需要**法线**信息的材料，请确保将其设置为**无**。'
- en: '**Tangents**: This option is used by materials for faking detail with bump
    maps and similar special effects. Just as with the **Normals** setting, if you
    don''t need them, don''t import them. If **Normals** is set to **None**, this
    setting will automatically be grayed out and no longer imported.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切线**：这个选项用于材料使用凹凸贴图和类似特殊效果来模拟细节。就像**法线**设置一样，如果您不需要它们，请不要导入它们。如果**法线**设置为**无**，此设置将自动变为灰色，并且不再导入。'
- en: Rig tab
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Rig标签
- en: 'The following is a screenshot that displays the **Rig** tab:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个显示**Rig**标签的截图：
- en: '![Rig tab](img/2014OT_09_09.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![Rig标签](img/2014OT_09_09.jpg)'
- en: There are really only two things to keep in mind when working to optimize your
    animation rig. The first is, if the asset does not animate, then don't import
    it. By setting **Animation Type** to **None**, Unity will not try to import the
    rig or any useless animations. The second thing to keep in mind is to remove any
    unnecessary bones. Once imported to Unity, delete any and all objects from the
    rig that do not actually have an effect on the animation or character. Unity converts
    any inverse kinematics that you might use for animating into forward kinematics,
    so the guides used for it can be deleted once in Unity.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当优化动画骨架时，实际上只有两件事需要考虑。首先，如果资产没有动画，则不要导入它。通过将**动画类型**设置为**无**，Unity将不会尝试导入骨架或任何无用的动画。其次，要考虑的是删除任何不必要的骨骼。一旦导入Unity，删除任何对动画或角色没有实际影响的对象。
- en: Animations tab
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动画标签
- en: As with with the **Rig** tab, if the model does not animate, do not import animations.
    Unchecking the **Import Animation** box, when first importing the asset, will
    avoid any extra components being added to your GameObjects in Unity. Also, if
    any extra animations get added to your final build accidentally, they can quickly
    make your application over-sized.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在**Rig**标签中一样，如果模型没有动画，则不要导入动画。在首次导入资产时取消选中**导入动画**框，将避免向Unity中的GameObject添加任何额外的组件。此外，如果意外添加了任何额外的动画，它们会迅速使你的应用程序变得过大。
- en: '![Animations tab](img/2014OT_09_06.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![动画标签](img/2014OT_09_06.jpg)'
- en: 'The settings available under the **Animations** tab are explained as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**动画**标签下的设置解释如下：'
- en: '**Anim. Compression**: This option adjusts how Unity handles excess keyframes
    in your animations. For most situations, the default option works well.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画压缩**: 此选项调整Unity处理动画中多余关键帧的方式。对于大多数情况，默认选项效果良好。'
- en: '**Off**: This option should only be used if you need a high-precision animation.
    This is the largest and most costly setting to choose.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关闭**: 此选项仅应在需要高精度动画时使用。这是选择中最大且成本最高的设置。'
- en: '**Keyframe Reduction**: This option will reduce the number of keyframes used
    by the animation based on the Error settings that follow. Essentially, if a keyframe
    does not have a noticeable effect upon the animation, it is ignored.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键帧减少**: 此选项将根据以下错误设置减少动画使用的关键帧数量。本质上，如果一个关键帧对动画没有明显的影响，它将被忽略。'
- en: '**Keyframe Reduction and Compression**: This option does the same as the previous
    option but additionally compresses the file size of the animations. At runtime,
    though, the animation will still require the same amount of processor resources
    to calculate as the previous option.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关键帧减少和压缩**: 此选项与上一个选项相同，但还会压缩动画的文件大小。然而，在运行时，动画仍然需要与上一个选项相同数量的处理器资源来计算。'
- en: '**Rotation Error**: This option is the number of degrees different between
    keyframes that will be ignored when performing keyframe reduction.'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转误差**: 此选项是在执行关键帧减少时将被忽略的关键帧之间度数差异的数量。'
- en: '**Position Error**: This option is the movement distance that will be ignored
    between keyframes when performing the keyframe reduction.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置误差**: 此选项是在执行关键帧减少时将被忽略的移动距离。'
- en: '**Scale Error**: This option is the amount of size adjustment in the animation
    that will be ignored between keyframes when performing the keyframereduction.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缩放误差**: 此选项是动画中在执行关键帧减少时将被忽略的大小调整量。'
- en: Textures
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纹理
- en: When working with textures in computer graphics, it is always better to work
    in **Powers of 2**. A Power of 2 is any value where it and its subsequent halves
    can be evenly divided by two until one is reached. This is important because they
    are faster for the computer to calculate and process. By default, Unity will convert
    any textures that do not meet this requirement by scaling them to the nearest
    Power of 2.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中处理纹理时，始终在**2的幂**下工作更好。2的幂是指任何值，其中它及其后续的一半可以均匀地除以2，直到达到1。这是因为它们对计算机来说计算和处理速度更快。默认情况下，Unity会将不符合此要求的任何纹理通过缩放调整到最接近的2的幂。
- en: '![Textures](img/2014OT_09_04.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![纹理](img/2014OT_09_04.jpg)'
- en: 'The various **Texture** settings available in Unity are explained as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中可用的各种**纹理**设置如下所述：
- en: '**Texture Type**: This option affects what type of texture this image will
    be treated as. It is always best to select the type most appropriate for the intended
    use of the image.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理类型**: 此选项影响此图像将被视为哪种类型的纹理。始终最好选择最适合图像预期用途的类型。'
- en: '**Texture**: This option is the most common and default setting. This should
    be used for your normal model textures.'
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**纹理**: 此选项是最常见和默认的设置。应将其用于您的普通模型纹理。'
- en: '**Normal Map**: This option is used for special effects such as bump maps.
    Materials using this type of texture will also need the normal and tangent information
    from the model import settings.'
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**法线贴图**: 此选项用于特殊效果，如凹凸贴图。使用此类型纹理的材料还需要从模型导入设置中获取法线和切线信息。'
- en: '**GUI**: This option should be used if the image is going to appear in the
    GUI and not on any models.'
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GUI**: 如果图像将出现在GUI中而不是任何模型上，应使用此选项。'
- en: '**Reflection**: These textures are used for creating cube maps that imitate
    the reflective properties of real objects.'
  id: totrans-58
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**反射**: 这些纹理用于创建模仿真实物体反射特性的立方体贴图。'
- en: '**Cookie**: These textures are used on lights, changing how the light is emitted
    from the light object.'
  id: totrans-59
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cookie**: 这些纹理用于灯光，改变从灯光对象发出的光线。'
- en: '**Advanced**: This option gives full control over all of the settings concerned
    with importing images. You will only need this setting if you have special purposes
    for your textures.'
  id: totrans-60
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高级**: 此选项提供了对所有与导入图像相关的设置的完全控制。您只有在纹理有特殊用途时才需要此设置。'
- en: When the **Texture Type** option is set to **Advanced**, the **Read / Write
    Enabled** box becomes available. This should only be left checked if you plan
    on manipulating the texture from your scripts while the game is running. If unchecked,
    Unity does not maintain a copy of the data in the CPU, freeing memory for other
    parts of the game.
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当**纹理类型**选项设置为**高级**时，**读写启用**框变为可用。如果计划在游戏运行时从脚本中操作纹理，则应保留勾选。如果未勾选，Unity不会在CPU中维护数据副本，从而为游戏的其他部分释放内存。
- en: '**Generate Mip Maps**: This option is another **Advanced** setting that lets
    you control the creation of smaller versions of the texture. These are then used
    when the texture is small on the screen, reducing the amount of processing needed
    to draw the texture and the object using it on the screen.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成Mip贴图**: 此选项是另一个**高级**设置，允许您控制纹理较小版本的创建。当纹理在屏幕上较小时，这些版本将被使用，从而减少绘制屏幕上纹理及其使用对象所需的处理量。'
- en: '**Filter Mode**: This option is available for all of the texture types. It
    affects how the image will look when you are very close to it. **Point** will
    make the image look blocky, while **Bilinear** and **Trilinear** will blur the
    pixels. In general, **Point** is the fastest; **Trilinear** is the slowest but
    gives the best looking effect.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**过滤模式**: 此选项适用于所有纹理类型。它影响您非常接近图像时图像的外观。"**点**"会使图像看起来像块状，而"**双线性**"和"**三线性**"会模糊像素。一般来说，"**点**"是最快的；"**三线性**"是最慢的，但提供最佳的外观效果。'
- en: '**Max Size**: This option adjusts how large the image can be when it is used
    in the game. This allows you to work with images that are very large but import
    them to Unity in an appropriately small size. In general, values greater than
    **1024** are poor choices; not just because of the increased memory requirement,
    but also because the video cards on most mobile devices cannot handle textures
    that are any larger. Choosing the smallest size possible will have a great effect
    on the footprint size of the textures in your final build.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大尺寸**: 此选项调整图像在游戏中使用时可以有多大。这允许您使用非常大的图像，但以适当小的尺寸导入Unity。一般来说，大于**1024**的值是较差的选择；不仅因为增加了内存需求，而且因为大多数移动设备的显卡无法处理任何更大的纹理。选择可能的最小尺寸将对最终构建中纹理的足迹大小产生重大影响。'
- en: '**Format**: This option adjusts how the image should be imported and how much
    detail each pixel can hold. **Compressed** is the smallest, while **Truecolor**
    provides the most detail.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**格式**: 此选项调整图像的导入方式以及每个像素可以保留的细节程度。"**压缩**"是最小的，而"**真彩色**"提供最详细的细节。'
- en: Audio
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 音频
- en: Giving a game quality sound always adds a lot to the final size of the game.
    It is one of those assets that a game cannot do without, but can be hard to include
    at a suitable level. When working on them in your audio program, keep them as
    short as possible to minimize their size. The audio import settings all have an
    effect on either their footprint in the build size, or the memory required to
    run the game.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 总是为游戏提供高质量的声音总是会增加游戏最终的大小。这是那些游戏无法没有的资产之一，但可能很难在合适的水平上包含。当在音频程序中处理它们时，尽量使它们尽可能短，以最小化其大小。音频导入设置都会对它们的构建大小或运行游戏所需的内存产生影响。
- en: '![Audio](img/2014OT_09_05.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![音频](img/2014OT_09_05.jpg)'
- en: 'The various **Audio** settings available in Unity are explained as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中可用的各种**音频**设置如下所述：
- en: '**Audio Format**: This setting changes how the file will be stored in your
    game. **Native** offers higher quality while **Compressed** results in a smaller
    file size. As a special feature of mobile platforms, compressed audio can be retrieved
    relatively faster than on other platforms because of some special hardware in
    the mobile devices.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音频格式**: 此设置更改文件在游戏中的存储方式。"**原生**"提供更高的质量，而"**压缩**"则导致文件大小更小。作为移动平台的一个特殊功能，由于移动设备中的一些特殊硬件，压缩音频可以在其他平台上相对更快地检索。'
- en: '**3D Sound**: This setting dictates whether or not the file will be affected
    by its position in the game relative to the **Audio Listener**. If this is unchecked,
    some calculations can be avoided, reducing the processing required in each frame
    of your game.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D Sound**: 此设置决定文件是否受其在游戏中的位置相对于**音频监听器**的影响。如果未勾选，可以避免一些计算，从而减少每帧游戏中所需的处理量。'
- en: '**Force to mono**: This setting converts stereo audio into mono. While most
    devices are technically capable of playing stereo sounds, they do not always have
    the multiple speakers required for it to make a difference. Checking this box
    can significantly reduce the file size of the audio, by removing that extra audio
    channel.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**强制单声道**：此设置将立体声音频转换为单声道。虽然大多数设备在技术上能够播放立体声音频，但它们并不总是拥有多个扬声器以产生差异。勾选此框可以显著减小音频文件的大小，通过移除额外的音频通道。'
- en: '**Load type**: This setting affects how much of the system''s memory is used,
    while the game is running, to handle loading audio files. **Decompress on load**
    uses the most memory, and is best for small, short sounds. **Compressed in memory**
    only decompresses the file while it is playing, using a medium amount of memory,
    and is best for medium-sized files. **Stream from disc** means that only the part
    of the file currently being played is stored in the runtime memory. This is like
    streaming video or music from the Internet. This option is best for large files
    but should only be used by a few at one time.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**加载类型**：此设置影响游戏运行时用于处理音频文件的系统内存量。**加载时解压缩**使用最多的内存，最适合小型短声音。**内存中压缩**仅在文件播放时解压缩文件，使用中等数量的内存，最适合中等大小的文件。**从磁盘流式传输**意味着只有当前正在播放的文件部分存储在运行时内存中。这就像从互联网上流式传输视频或音乐一样。此选项最适合大型文件，但一次只能由少数人使用。'
- en: '**Compression (kbps)**: This setting adjusts the amount of detail in the audio
    file. A smaller value will reduce the file size, but also reduce quality. A larger
    value will result in a larger file size and greater quality. If the amount of
    compression already applied by your audio is smaller than the value here, the
    setting will have no effect on the sound. In general, it is best to pick the smallest
    size while maintaining the desired level of quality.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩率（kbps）**：此设置调整音频文件中的细节量。较小的值会减小文件大小，但也会降低音质。较大的值会导致文件大小更大，音质更好。如果您的音频已经应用的压缩量小于此处设置的值，则此设置对声音没有影响。通常，在保持所需音质水平的同时，选择最小的尺寸为最佳。'
- en: Player settings
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 玩家设置
- en: Open your game's **Player Settings** by going to Unity's toolbar and navigating
    to **Edit** | **Project Settings** | **Player**. In the **Per-Platform Settings**,
    for Android, we have another few options under **Other Settings** that will affect
    the final size and speed of our game.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通过访问Unity的工具栏并导航到**编辑** | **项目设置** | **玩家**来打开您的游戏**玩家设置**。在**平台设置**中，对于Android，我们在**其他设置**下有其他一些选项，这些选项会影响我们游戏的最终大小和速度。
- en: Rendering
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 渲染
- en: 'The following is the screenshot that displays the **Rendering** settings:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了**渲染**设置：
- en: '![Rendering](img/2014OT_09_10.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![渲染](img/2014OT_09_10.jpg)'
- en: 'The various **Rendering** settings available in Unity are explained as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中可用的各种**渲染**设置解释如下：
- en: When we worked with making lightmaps, we had to set some objects as static.
    This told Unity that the objects will never be moving and allows them to be lightmapped.
    It also allows Unity Pro users to utilize **Static Batching** that allows Unity
    to significantly speed up rendering times by grouping identical objects. For each
    group it then renders one object in multiple places, rather than each object individually.
    Potentially, this setting can add some extra girth to your final build size, because
    Unity will need to save extra information about your static objects to make it
    work.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们制作光照贴图时，我们必须将一些对象设置为静态。这告诉Unity这些对象永远不会移动，并允许它们进行光照贴图。它还允许Unity Pro用户利用**静态批处理**，这可以让Unity通过将相同对象分组来显著加快渲染时间。然后它会在多个位置渲染一个对象，而不是单独渲染每个对象。潜在地，此设置可能会增加您最终构建的大小，因为Unity需要保存有关您静态对象的额外信息以使其工作。
- en: '**Dynamic Batching** works the same as **Static Batching**, with two major
    differences. First, it is available to both Unity Pro and Basic users. Second,
    it groups objects that are not marked as static.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态批处理**与**静态批处理**的工作方式相同，但有两大主要区别。首先，它对Unity Pro和基本用户都可用。其次，它将未标记为静态的对象分组。'
- en: Optimization
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化
- en: 'The **Optimization** settings are shown in the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化**设置如下截图所示：'
- en: '![Optimization](img/2014OT_09_11.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![优化](img/2014OT_09_11.jpg)'
- en: 'The various **Optimization** settings available in Unity are explained as follows:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中可用的各种**优化**设置解释如下：
- en: '**Api Compatibility Level**: This setting determines which set of the .Net
    functions to include in the final build. **.Net 2.0** will include all of the
    available functions, making the largest footprint. **.Net 2.0 Subset** is a smaller
    portion of the functions, including only those that your programming is most likely
    to use. Unless you need some special functionality, **.Net 2.0 Subset** should
    always be the option you choose.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API 兼容级别**：此设置确定最终构建中包含哪个 .Net 函数集。**.Net 2.0** 将包含所有可用函数，从而产生最大的足迹。**.Net
    2.0 子集**是函数集的一个较小部分，仅包括你编程最可能使用的那些函数。除非你需要一些特殊功能，否则**.Net 2.0 子集**应该是你始终选择的选项。'
- en: '**The Stripping Level**: This setting is a Unity Pro only feature. It allows
    you to reduce the size of your final build by removing all of the excess code
    before compiling it. System functions are grouped into what are called libraries
    for easy reference. **Strip Assemblies** removes the unused libraries from the
    final build. The **Use micro mscorlib** option performs the same function as the
    previous option, but utilizes a minimized form of the libraries. While significantly
    smaller, this library possesses fewer functions for your code to use. However,
    unless your game is complex, it should not make a difference.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**剥离级别**：此设置是 Unity Pro 独有的功能。它允许你在编译之前移除所有多余的代码，从而减小最终构建的大小。系统函数被分组到称为库的内容中，以便于参考。**剥离程序集**将从最终构建中移除未使用的库。**使用微型
    mscorlib**选项与前面的选项执行相同的功能，但使用库的最小化形式。虽然库的大小显著减小，但可供代码使用的功能更少。然而，除非你的游戏非常复杂，否则这不应造成差异。'
- en: '**Optimize Mesh Data**: This setting will remove extra information from all
    of your meshes that are not being used by any materials applied to them. This
    includes the **Normals**, **Tangents**, and a few other bits of information. Unless
    you have a very special case, this is a good box to always check.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化网格数据**：此设置将从所有未使用任何材料应用到的网格中移除额外信息。这包括**法线**、**切线**和少量其他信息。除非你有非常特殊的情况，否则始终勾选此框是个好主意。'
- en: Tracking performance
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪性能
- en: Unity provides us with many tools that allow us to determine how well our game
    is running. The first we will be covering is readily available for both Unity
    Pro and Basic users. However, the information is rather limited, though still
    useful. The second is only available to Unity Pro users. It provides significantly
    more detail and information on performance. Finally, we will create our own tool,
    allowing us to view the performance of our scripts in detail.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 为我们提供了许多工具，使我们能够确定游戏运行的好坏。我们将首先介绍的是 Unity Pro 和基本用户都 readily 可用的工具。然而，信息相当有限，尽管仍然有用。第二个工具仅适用于
    Unity Pro 用户。它提供了关于性能的更多详细信息和数据。最后，我们将创建自己的工具，使我们能够详细查看脚本的性能。
- en: Editor statistics
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编辑器统计信息
- en: In the top-right of the **Game** window, there is a button labeled **Stats**.
    Clicking on this button will open a window, giving us information about how the
    game is running. There is little bit of information about how fast the game is
    running. Most of the information in this window concerns how well the game is
    being rendered, largely amounting to how many objects are currently on the screen,
    how many are animating, and how much memory they take up.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **游戏** 窗口的右上角，有一个标有 **Stats** 的按钮。点击此按钮将打开一个窗口，显示有关游戏运行情况的信息。其中有一点点关于游戏运行速度的信息。窗口中的大部分信息都关注游戏的渲染效果，主要涉及当前屏幕上的对象数量、动画对象数量以及它们占用的内存量。
- en: '![Editor statistics](img/2014OT_09_02.jpg)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![编辑器统计信息](img/2014OT_09_02.jpg)'
- en: 'The various statistics in Unity Editor are explained as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 编辑器中的各种统计数据解释如下：
- en: At the top-right of the Unity Editor **Statistics** window is the current **FPS**
    (**Frames Per Second**) and the time in milliseconds that the last frame took
    to render. These values are unaffected by the rendering of the rest of the Unity
    Editor, though there is a slight performance hit by running the game in the Editor.
    In general, if you can keep your game running at more than 60 FPS, your game will
    run pretty well on your target platform.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器 **统计信息** 窗口的右上角是当前的 **FPS**（每秒帧数）和最后一帧渲染所需的时间（以毫秒计）。这些值不受 Unity
    编辑器其他渲染的影响，尽管在编辑器中运行游戏会有轻微的性能损失。一般来说，如果你能保持游戏运行在 60 FPS 以上，你的游戏将在目标平台上运行得相当好。
- en: The **Main Thread** statistic provides us with the time in milliseconds that
    it took to run through the code for the frame and render everything to the screen.
    This is the total amount of time it takes to process a single frame of your game.
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主线程**统计提供了运行帧代码并渲染到屏幕所需的时间（以毫秒为单位）。这是处理你游戏单帧所需的总时间。'
- en: To the right of **Main Thread**, we have **Renderer**. This statistic is the
    number of milliseconds the rendering of the frame alone took. This time is already
    included in the **Main Thread** statistic.
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在**主线程**的右侧，我们有**渲染器**。这个统计数字表示仅渲染帧所花费的毫秒数。这个时间已经包含在**主线程**的统计中。
- en: The **Draw Calls** statistic is the number of unique objects that had to be
    drawn on screen. This is roughly equal to the number of objects that are currently
    visible to the camera. So, things behind the camera are not drawn and do not add
    to this value.
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**绘制调用**统计是必须绘制到屏幕上的唯一对象的数量。这大约等于当前相机可见的对象数量。所以，相机后面的东西不会被绘制，也不会增加这个值。'
- en: The **Saved by batching** statistic is closely related to the number of **Draw
    Calls**. We will learn more about batching later. But, suffice it to say for now,
    batching is a special grouping process that reduces the number of **Draw Calls**,
    making the game render faster.
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**批处理节省**统计与**绘制调用**的数量密切相关。我们将在稍后了解更多关于批处理的内容。但就现在而言，批处理是一种特殊的分组过程，可以减少**绘制调用**的数量，使游戏渲染更快。'
- en: Ultimately, every model in 3D graphics is made from a series of triangles. **Tris**
    is the total number of triangles seen and being rendered by the camera.
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最终，3D图形中的每个模型都是由一系列三角形组成的。**三角形**是相机看到的和正在渲染的总三角形数。
- en: Most of the information in a model file is concerned with the position of each
    vertex. **Verts** is the total number of vertexes seen and rendered by the camera.
    The lower the number of vertexes for each model, the faster it will be rendered
    to the screen.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模型文件中的大部分信息都与每个顶点的位置有关。**顶点**是相机看到的和渲染的总顶点数。每个模型的顶点数越少，渲染到屏幕上的速度就越快。
- en: The first number for the **Used Textures** statistic is the total number of
    unique textures that are being used in this frame. The second is the total amount
    of memory they take up. By reducing texture quality or by combining textures,
    this statistic can be reduced, allowing the game to run faster.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用纹理**的第一个数字是当前帧中使用的唯一纹理的总数。第二个是它们占用的总内存量。通过降低纹理质量或合并纹理，这个统计数字可以减少，从而使游戏运行更快。'
- en: The **Render Textures** statistic is a special type of texture used for special
    effects such as security cameras and real-time reflections. This statistic displays
    the total number visible and the amount of memory needed for them.
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**渲染纹理**统计是一种用于特殊效果的特殊纹理，如安全摄像头和实时反射。这个统计数字显示了它们的总可见数和所需的内存量。'
- en: The **switches** statistic essentially amounts to how much work the **Render
    Textures** statistic is doing. Fewer **Render Textures** and simpler materials
    will reduce this number and the resulting cost to rendering time.
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开关**统计基本上等同于**渲染纹理**统计所做的工作量。更少的**渲染纹理**和更简单的材质将减少这个数字，从而减少渲染时间。'
- en: '**Screen** is the current width and height, in pixels, of the **Game** window.
    It also displays the amount of memory needed for rendering at that size. A smaller
    size results in less detail for your game, but also makes the game easier to render.'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**屏幕**是**游戏**窗口当前宽度和高度的像素值。它还显示了渲染该尺寸所需的内存量。较小的尺寸会导致你的游戏细节更少，但同时也使得游戏更容易渲染。'
- en: The **VRAM usage** statistic gives the approximate minimum and maximum video
    memory currently being used. It also provides the current total amount of video
    memory available in parentheses. With this statistic and knowing the amount of
    video memory available in your target device, you can determine whether graphics
    of your game are simple enough to run on that device.
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VRAM 使用**统计提供了当前使用的视频内存的大致最小值和最大值。它还提供了当前可用的总视频内存量（括号内）。有了这个统计数字和了解目标设备中可用的视频内存量，你可以确定你游戏的图形是否足够简单，可以在该设备上运行。'
- en: The **VBO Total** statistic is the total number of unique meshes currently being
    rendered by your game. Every distinct model you might use will add to this statistic.
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**VBO 总数**统计是当前由你的游戏渲染的唯一网格的总数。你可能会使用的每个不同模型都会增加这个统计数字。'
- en: The **Shadow Casters** statistic is used when making use of real-time shadows.
    Real-time shadows are expensive. If possible, they should not be used on mobile
    devices. But, if you have to have them, minimize the number of objects that cast
    those shadows. Limit it to moving objects that are large enough for the user to
    see the shadow. Small, static objects especially do not need to cast shadows.
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影投射器**统计用于使用实时阴影时。实时阴影成本很高。如果可能的话，它们不应该在移动设备上使用。但是，如果你必须使用它们，请尽量减少投射这些阴影的对象数量。限制到足够大以至于用户可以看到阴影的移动对象。特别是小型静态对象不需要投射阴影。'
- en: The **Visible Skinned Meshes** statistic is the total number of rigged objects
    currently in the view of the camera. **Skinned Meshes** are most often going to
    be your characters and just about anything else that animates.
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可见骨骼网格**统计是当前在摄像机视图中可见的绑定对象总数。**骨骼网格**通常会是你的角色以及几乎所有其他需要动画的对象。'
- en: The **Animations** statistic provides the current total number of animations
    playing in the scene.
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动画**统计提供了场景中当前正在播放的动画总数。'
- en: The **Network** group of statistics only becomes visible when connected to other
    players in a multiplayer game. The information generally amounts to how many people
    the game is connected to and how fast those connections are.
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**统计组仅在多人游戏中连接到其他玩家时才会可见。信息通常包括游戏连接了多少人以及这些连接的速度有多快。'
- en: The Profiler
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析器
- en: The **Profiler** window, found in Unity's toolbar under **Window** | **Profiler**,
    is a great tool for analyzing how your game is running. It gives us a colorful
    breakdown of each part of our system and how much work it is doing. The only really
    unfortunate part of this tool is that it is only available for Unity Pro users.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity的**窗口**|**分析器**工具栏下找到的**分析器**窗口是一个分析游戏运行情况的优秀工具。它为我们提供了系统每个部分的彩色分解以及它们正在做多少工作。这个工具唯一真正不幸的部分是它仅适用于Unity
    Pro用户。
- en: '![The Profiler](img/2014OT_09_12.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![分析器](img/2014OT_09_12.jpg)'
- en: By first opening the **Profiler** window, we can then play our game in the window
    and watch the tool give us a fairly detailed breakdown of what is going on. We
    can click on any point and see detailed information about that frame in the bottom
    of the window. The information provided is specific to the lane that you clicked
    on, **CPU Usage**, **Rendering**, **Memory**, and so on.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 通过首先打开**分析器**窗口，我们可以在窗口中播放游戏并观察工具为我们提供一个相当详细的分解，说明正在发生什么。我们可以点击任何一点，在窗口底部查看关于该帧的详细信息。提供的信息是针对你点击的通道的，**CPU
    使用率**、**渲染**、**内存**等等。
- en: The **CPU Usage** information is particularly useful when trying to find parts
    of our game that are taking too long to process. Spikes in processing cost stand
    out pretty easily. By clicking on a spike, we can see the breakdown of what each
    part of the game played in making that frame expensive. For most of these parts
    we can dig down to the exact object or function that is causing the issue. However,
    we can only get down to the function level. Just because we know where an issue
    in the code generally is, the Profiler will not tell us exactly which part of
    that function is causing the issue.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '**CPU 使用率**信息在尝试找出游戏处理时间过长的部分时特别有用。处理成本的峰值很容易突出。通过点击峰值，我们可以看到导致该帧昂贵的每个游戏部分是如何分解的。对于这些部分中的大多数，我们可以深入到导致问题的确切对象或函数。然而，我们只能追溯到函数级别。仅仅因为我们知道代码中问题的一般位置，分析器也不会告诉我们该函数的哪个部分导致了问题。'
- en: In order to actually work, the Profiler needs to hook into every part of your
    game. This introduces a little extra cost in the speed of your game. Therefore,
    when analyzing the information provided, it is best to consider the relative costs
    rather than hold each cost as an exact value.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了真正工作，分析器需要钩入你游戏的每个部分。这会在你游戏的速度上引入一点额外的成本。因此，在分析提供的信息时，最好考虑相对成本，而不是将每个成本视为一个确切值。
- en: Tracking script performance
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 跟踪脚本性能
- en: All of these tools that Unity provides are great, but not always the right solution.
    The Unity Basic user does not have access to the Profiler. Also, both the Profiler
    and the Editor Statistics are fairly generalized. We can get a little more detail
    with the Profiler, but not always enough. In this next part, we will be creating
    a special script capable of tracking the performance of specific parts of any
    script. It should definitely become a regular piece of your developer kit.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供的所有这些工具都很棒，但并不总是正确的解决方案。Unity 基础用户无法访问 Profiler。此外，Profiler 和编辑器统计信息相当通用。我们可以通过
    Profiler 获取更多细节，但并不总是足够。在接下来的部分，我们将创建一个特殊的脚本，能够跟踪任何脚本特定部分的性能。这绝对应该成为你开发者工具包的常规部分。
- en: Time for action – tracking scripts
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 跟踪脚本
- en: 'We will be creating this script in the Space Fighter game:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在《太空战士》游戏中创建这个脚本：
- en: First, we will need a special class that will keep track of our performance
    statistics. Create a new script and name it `TrackerStat`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一个特殊的类来跟踪我们的性能统计信息。创建一个新的脚本并将其命名为 `TrackerStat`。
- en: 'To begin this script, we first need to change the class definition line. We
    do not want or need to extend the `MonoBehaviour` class. So, find the following
    line of code:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要开始这个脚本，我们首先需要更改类定义行。我们不想也不需要扩展 `MonoBehaviour` 类。所以，找到以下代码行：
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'And, change it to the following:'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，将其更改为以下内容：
- en: '[PRE1]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This script starts with four variables. The first will be used as an ID, allowing
    us to track multiple scripts at once by supplying different key values. The second
    will keep track of the average amount of time that the tracked bits of code are
    taking. The third is just the total number of times the tracked code has been
    called. The fourth is the longest time the code has taken to execute.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本开始时有四个变量。第一个将用作 ID，允许我们通过提供不同的键值来同时跟踪多个脚本。第二个将跟踪跟踪的代码片段所花费的平均时间。第三个是跟踪代码被调用的总次数。第四个是代码执行所花费的最长时间。
- en: '[PRE2]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Next, we have two more variables. These will do the work of actually tracking
    how long the script takes to execute. The first is the time when the tracking
    starts. The second is a flag marking that tracking has started.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们还有两个额外的变量。这些变量将负责跟踪脚本执行所需的时间。第一个是跟踪开始的时间。第二个是一个标记，表示跟踪已经开始。
- en: '[PRE3]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The first function for this script is `Open`. This function is called when we
    want to start tracking a bit of code. It first checks to see if the code is already
    being tracked. It uses `Debug.LogWarning` to send a warning to the **Console**
    window, if it is. Next, it sets the flag marking that code is being tracked. Finally,
    the function tracks the time it was called by using `Time.realtimeSinceStartup`,
    which is the actual number of seconds since the game started.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的第一个函数是 `Open`。当我们想要开始跟踪一段代码时调用这个函数。它首先检查代码是否已经在跟踪中。如果代码正在跟踪，它使用 `Debug.LogWarning`
    向 **控制台** 窗口发送警告。接下来，它设置标记表示代码正在被跟踪。最后，该函数使用 `Time.realtimeSinceStartup` 跟踪代码被调用的时间，这是游戏开始以来的实际秒数。
- en: '[PRE4]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The next function, `Close`, acts as the opposite of the previous one. It is
    called when we have reached the end of the code we want to track. The time when
    the tracking should stop is passed to it. This is done to minimize the amount
    of excess code being executed. As with the previous function, it checks to see
    if tracking is being done, sending out another warning and exiting early if it
    is not. Next, the `isOpen` flag is cleared by setting it to `false`. Finally,
    the amount of time since tracking was opened is calculated and the `AddValue`
    function is called.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个函数 `Close` 是上一个函数的相反。当达到我们想要跟踪的代码的末尾时调用它。将跟踪应该停止的时间传递给它。这样做是为了最小化执行多余代码的数量。与上一个函数一样，它检查是否正在进行跟踪，如果正在跟踪，则使用
    `Debug.LogWarning` 向 **控制台** 窗口发送警告，并提前退出。接下来，将 `isOpen` 标志清除，设置为 `false`。最后，计算自跟踪开始以来经过的时间，并调用
    `AddValue` 函数。
- en: '[PRE5]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: This last function for this script is `AddValue`. This function is passed `callLength`,
    the length of time that the tracked bit of code took. It then uses some math to
    add the value to `averageTime`. Next, the function compares the current `longestCall`
    with the new value and selects the longest. Finally, the function increments `totalCalls`.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个脚本的最后一个函数是 `AddValue`。这个函数接收 `callLength` 参数，即跟踪的代码片段所花费的时间长度。然后它使用一些数学运算将值添加到
    `averageTime`。接下来，函数将当前的 `longestCall` 与新值进行比较，并选择最长的值。最后，函数增加 `totalCalls` 的值。
- en: '[PRE6]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Next, we need to create another new script and name it `ScriptTracker`. This
    script will allow us to do actual performance tracking.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建另一个新的脚本，并将其命名为 `ScriptTracker`。此脚本将允许我们进行实际性能跟踪。
- en: This script starts off with a single variable. This variable maintains all of
    the stats that are currently being tracked. Note the use of `static` here; it
    allows us to easily update the list from anywhere in the game.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本从单个变量开始。此变量维护所有当前正在跟踪的统计数据。注意这里使用 `static` 的用法；它允许我们轻松地从游戏的任何位置更新列表。
- en: '[PRE7]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first function for this script, `Open`, allows us to start tracking the
    code execution. It uses the `static` flag, so the function can be called easily
    by any script. A `key` value is passed to the function, allowing us to group track
    calls. The function starts by creating a variable to hold the `index` of the stat
    to start tracking. Next, it loops through the current set of `stats` to find a
    matching `key` value. If one is found, the `index` variable is updated with the
    value and the loop is exited.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本的第一函数 `Open` 允许我们开始跟踪代码执行。它使用 `static` 标志，因此可以从任何脚本轻松调用此函数。函数接收一个 `key` 值，允许我们分组跟踪调用。函数首先创建一个变量来保存开始跟踪的统计数据的
    `index`。接下来，它遍历当前的一组 `stats` 以查找匹配的 `key` 值。如果找到，则更新 `index` 变量并退出循环。
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `Open` function continues by checking if a stat was found. The `index` variable
    will only be less than zero if we make it through the whole loop of current `stats`
    and are unable to find a matching `key`. If one is not found, we call `AddNewStat`,
    which will be created shortly, to create the new stat for tracking. The `index`
    is then set to that of the new stat. Finally, the stat is triggered to start tracking
    by using the stat's `Open` function.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Open` 函数继续检查是否找到了统计数据。如果我们在当前 `stats` 的整个循环中遍历并且无法找到匹配的 `key`，则 `index` 变量将只会小于零。如果没有找到，我们调用
    `AddNewStat`（稍后创建），以创建用于跟踪的新统计数据。然后，将 `index` 设置为新统计数据的索引。最后，通过使用统计数据的 `Open`
    函数来触发统计数据开始跟踪。'
- en: '[PRE9]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `AddNewStat` function is passed the `key` of the stat that is to be created.
    It starts by storing the list of `stats` in a temporary variable and increasing
    the size of the `stats` list by one. Each value is then transferred from the `temp`
    list to the larger `stats` list. Finally, a new stat is created, it is assigned
    to the last slot in the `stats` list, and the `key` is set.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddNewStat` 函数接收要创建的统计数据的 `key`。它首先将 `stats` 列表存储在一个临时变量中，并将 `stats` 列表的尺寸增加一个。然后，将每个值从
    `temp` 列表转移到更大的 `stats` 列表中。最后，创建一个新的统计数据，将其分配给 `stats` 列表的最后一个槽位，并设置 `key`。'
- en: '[PRE10]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Next, we have the `Close` function. This function is passed the `key` value
    of the stat to be closed. It starts by finding the time that the function was
    called, minimizing the amount of excess code being tracked. It continues by looping
    through the list of `stats` to find a matching `key`. If one is found, the stat's
    `Close` function is called and the function is exited. If a match is not found,
    `Debug.LogError` is called to send an error message to the **Console** window.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们有 `Close` 函数。此函数接收要关闭的统计数据的 `key` 值。它首先找到函数被调用的时刻，以最小化跟踪的额外代码量。然后，它通过遍历
    `stats` 列表来查找匹配的 `key`。如果找到，调用统计数据的 `Close` 函数并退出函数。如果没有找到匹配项，调用 `Debug.LogError`
    向 **控制台** 窗口发送错误消息。
- en: '[PRE11]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The last static function for this script is `Clear`. It only empties the stats
    list, making it ready for fresh tracking.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此脚本的最后一个静态函数是 `Clear`。它仅清空统计数据列表，使其准备好进行新的跟踪。
- en: '[PRE12]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The last step for the script is the `OnGUI` function. This function will let
    us see our statistics while the game is playing. In it we make heavy use of the
    `GUILayout` class and its functions. `GUILayout` automatically arranges the various
    GUI elements, allowing us to spend less time arranging and more time analyzing.
    We first use `BeginVertical` to start a vertical list of elements. `BeginHorizontal`
    is used to start a horizontal list of elements. The `Label` function is then used
    to create titles for each row of our statistics. We are using the `GUILayout.Width`
    function to give each label a specific width, making the layout look much nicer.
    Next, `EndHorizontal` is called to close the horizontal list. Every call to `BeginHorizontal`
    must be paired with an `EndHorizontal` else Unity will make many complaints.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 脚本的最后一步是 `OnGUI` 函数。这个函数将允许我们在游戏进行时查看我们的统计数据。在其中，我们大量使用 `GUILayout` 类及其函数。`GUILayout`
    自动排列各种 GUI 元素，使我们能够花费更少的时间排列，更多的时间分析。我们首先使用 `BeginVertical` 开始一个元素的垂直列表。使用 `BeginHorizontal`
    开始一个元素的水平列表。然后使用 `Label` 函数为我们的统计数据每一行创建标题。我们使用 `GUILayout.Width` 函数为每个标签指定一个特定的宽度，使布局看起来更加美观。接下来，调用
    `EndHorizontal` 来关闭水平列表。每个 `BeginHorizontal` 的调用都必须与一个 `EndHorizontal` 相匹配，否则
    Unity 将会提出许多抱怨。
- en: '[PRE13]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, we loop through our list of stats. For each, we create a horizontal list
    and use `Label` to draw each stat on the screen. The `ToString` function is used
    to convert the numbers to strings, needed by the labels.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们遍历我们的统计数据列表。对于每一个，我们创建一个水平列表，并使用 `Label` 在屏幕上绘制每个统计数据。`ToString` 函数用于将数字转换为字符串，这是标签所需的。
- en: '[PRE14]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `OnGUI` function finishes by creating a button, that calls upon the `Clear`
    function when clicked. And finally, the `EndVertical` function is called to end
    the vertical list of elements. Every call to `BeginVertical` must be paired with
    a call to `EndVertical`, just as the horizontal lists.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnGUI` 函数通过创建一个按钮结束，该按钮在被点击时调用 `Clear` 函数。最后，调用 `EndVertical` 函数来结束元素的垂直列表。每个
    `BeginVertical` 的调用都必须与一个 `EndVertical` 的调用相匹配，就像水平列表一样。'
- en: '[PRE15]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To test these scripts, open up your `PlayerShip` script. To the beginning of
    the `Rotate` function, add the following line to start tracking how long it takes
    to run.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试这些脚本，打开你的 `PlayerShip` 脚本。在 `Rotate` 函数的开始处添加以下行以开始跟踪运行所需的时间。
- en: '[PRE16]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Towards the end of the `Rotate` function, we need to call the `Close` function
    with the same key.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Rotate` 函数的末尾，我们需要调用与相同键的 `Close` 函数。
- en: '[PRE17]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Finally, create an empty game object and add your `ScriptTracker` script to
    it. Start the game and take a look at the results.![Time for action – tracking
    scripts](img/2014OT_09_01.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个空的游戏对象，并将你的 `ScriptTracker` 脚本添加到其中。开始游戏并查看结果。![执行动作 – 跟踪脚本](img/2014OT_09_01.jpg)
- en: '*What just happened?*'
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We created a tool for testing specific parts of code. By wrapping any bit of
    code in calls to the functions and sending a unique ID, we can determine how long
    it takes to execute the code. By averaging out the calls to the script, and wrapping
    different parts of code, we can determine exactly which parts of a script are
    taking the longest to complete. We can also find out if the parts of code have
    been called too many times. Both cases are ideal points to start looking at for
    minimizing processing and lag.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个用于测试代码特定部分的工具。通过将任何代码块包裹在函数调用中并发送一个唯一的 ID，我们可以确定执行代码所需的时间。通过平均调用脚本，并包裹不同的代码部分，我们可以确定脚本中哪些部分完成得最慢。我们还可以找出代码部分是否被调用得太多。这两种情况都是开始寻找以减少处理和延迟的理想点。
- en: Be sure to remove any references to this tool before you deploy your game. If
    left in the final levels, it can add an unnecessary amount of load on the CPU.
    This adverse effect on the game could make the game unplayable. Always remember
    to clear out any uses of tools that are exclusively for Editor debugging.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在部署你的游戏之前，务必删除对这个工具的所有引用。如果留在最终关卡中，它可能会给 CPU 增加不必要的负担。这种对游戏的负面影响可能会使游戏无法玩。始终记得清除任何仅用于编辑器调试的工具的使用。
- en: Minimizing lag
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 减少延迟
- en: Lag is one of those nebulous ideas used to describe an application performing
    slower than expected. As developers, we constantly fight against providing the
    highest quality experience we can, while maintaining the speeds and responsiveness
    that users expect. It essentially amounts to whether or not the processor on the
    user's device can handle the cost of providing the game experience. A few, simple
    objects in your game will result in fast processing. Several complex objects will
    cost the most processing.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 延迟是那些用来描述应用程序运行速度低于预期的不明确概念之一。作为开发者，我们不断努力提供尽可能高质量的用户体验，同时保持用户期望的速度和响应性。这本质上取决于用户设备上的处理器是否能够处理提供游戏体验的成本。你游戏中的一些简单对象会导致快速处理。几个复杂对象将消耗最多的处理资源。
- en: Occlusion
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮挡
- en: Occlusion is great for games with a lot of objects. In its basic form, anything
    off to the sides or behind the camera is not seen and therefore not drawn. In
    Unity Pro, we are able to set up occlusion culling. This will calculate what can
    actually be seen by the camera, not drawing anything that is blocked from view.
    There is a balance that has to be achieved when using these tools. The cost of
    calculating what can not be seen needs to be less than the cost of just drawing
    those objects anyway. As a rule of thumb, if you have many smaller objects that
    are regularly blocked from view by larger objects, occlusion culling is the right
    choice.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡非常适合拥有大量对象的游戏。在其基本形式中，任何在相机两侧或后面的对象都不可见，因此不会被绘制。在Unity Pro中，我们能够设置遮挡剔除。这将计算相机实际上可以看到的内容，不会绘制任何被遮挡的对象。在使用这些工具时，需要达到一个平衡。计算不可见内容的成本需要低于仅绘制这些对象的成本。作为一个经验法则，如果你有很多较小的对象，它们经常被较大的对象遮挡，那么遮挡剔除是正确的选择。
- en: Time for action – occluding tanks
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 隐藏坦克
- en: 'We will add occlusion culling to the Tank Battle game, because it is the only
    one with anything large enough to block objects from view:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将向坦克大战游戏添加遮挡剔除，因为它是有足够大物体可以遮挡视线的唯一游戏：
- en: So, open up the Tank Battle game now. If you completed the challenges and added
    the extra debris and obstacles, this section will be particularly effective for
    you.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，现在打开坦克大战游戏。如果你完成了挑战并添加了额外的碎片和障碍物，这一部分对你尤其有效。
- en: Open the Occlusion window by going to Unity's toolbar and navigate to **Window**
    | **Occlusion Culling**. This window is your primary point of access for modifying
    the various settings associated with occlusion in your game.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过访问Unity的工具栏并导航到**窗口** | **遮挡剔除**来打开遮挡窗口。此窗口是您修改与游戏中的遮挡相关的各种设置的主要访问点。
- en: Switch to the **Bake** page and we can take a look at the options associated
    with occlusion culling.![Time for action – occluding tanks](img/2014OT_09_13.jpg)
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**烘焙**页面，我们可以查看与遮挡剔除相关的选项。![行动时间 – 隐藏坦克](img/2014OT_09_13.jpg)
- en: '**Technique**: This setting will determine what method to use when setting
    up occlusion culling.'
  id: totrans-174
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术**: 此设置将确定在设置遮挡剔除时使用哪种方法。'
- en: '**PVS Only**: This setting will only calculate the static objects of your scene
    to have occlusion culling applied. This option is the least intensive for the
    processor but is only good if there are very few moving objects in the scene.'
  id: totrans-175
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**仅PVS**: 此设置将仅计算场景中的静态对象以应用遮挡剔除。这个选项对处理器的压力最小，但只有在场景中移动对象非常少的情况下才适用。'
- en: '**PVS and dynamic objects**: This setting will precompute what objects can
    be seen by the camera. For dynamic objects, the system will create portals. They
    are used to cull objects that are on opposite sides of the portals from the camera.'
  id: totrans-176
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**PVS和动态对象**: 此设置将预先计算相机可以看到哪些对象。对于动态对象，系统将创建传送门。它们用于剔除位于传送门两侧且从相机视图中不可见的对象。'
- en: '**Automatic Portal Generation**: This setting will cull both static and dynamic
    objects based on portals. While giving the most accuracy, this option also has
    the highest cost for the processor.'
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**自动传送门生成**: 此设置将基于传送门剔除静态和动态对象。虽然提供了最高的准确性，但此选项对处理器的成本也最高。'
- en: '**View Cell Size**: This setting sets how detailed the occlusion calculations
    are. Smaller values will result in better culling but will cause the file size
    to increase to store the extra information.'
  id: totrans-178
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**视图单元格大小**: 此设置设置遮挡计算的详细程度。较小的值将导致更好的剔除，但会导致文件大小增加以存储额外的信息。'
- en: '**Near Clip Plane** and **Far Clip Plane**: These settings are used by the
    system to estimate what a camera can see at any point in space. They should be
    set to the smallest **Near Clip Plane** and largest **Far Clip Plane** of all
    the cameras in your game.'
  id: totrans-179
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**近裁剪面**和**远裁剪面**：这些设置被系统用来估计相机在任何空间点可以看到的内容。它们应该设置为游戏中所有相机中最小的**近裁剪面**和最大的**远裁剪面**。'
- en: '**Memory Limit**: This setting is used when either of the **PVS Techniques**
    have been chosen. It helps guide how much detail can be put into the calculation.'
  id: totrans-180
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**内存限制**：当选择任一**PVS技术**时，此设置会被使用。它有助于指导可以放入计算中的细节程度。'
- en: Select **PVS and dynamic objects** for **Technique** and `5` for **View Cell
    Size**.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**技术**为**PVS和动态对象**，**视图单元格大小**为`5`。
- en: In order to make the occlusion system work with dynamic objects, we need to
    set up a number of occlusion areas. To create them, create an empty **GameObject**
    and add an **Occlusion Area** component, found in Unity's toolbar under **Component**
    | **Rendering** | **Occlusion Area**.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了使遮挡系统与动态对象一起工作，我们需要设置若干遮挡区域。要创建它们，创建一个空的**GameObject**，并在Unity的工具栏下**组件**
    | **渲染** | **遮挡区域**中添加一个**遮挡区域**组件。
- en: They need to cover the area where any dynamic objects will be located. Create
    and position enough areas to cover the streets of our game. Their size can be
    edited just as when working with **Box Collider** components. Be sure to make
    them tall enough to cover all of your targets.![Time for action – occluding tanks](img/2014OT_09_15.jpg)
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们需要覆盖任何动态对象将位于的区域。创建并定位足够多的区域来覆盖我们游戏中的街道。它们的大小可以像使用**盒子碰撞体**组件时一样编辑。务必使它们足够高，以覆盖所有目标。![遮挡坦克的时间
    - 遮挡坦克](img/2014OT_09_15.jpg)
- en: Hit **Bake** at the bottom of the **Occlusion** window. A progress bar will
    appear at the bottom-right of the Unity Editor, telling you how much longer the
    calculations will take. This process usually takes a good amount of time, especially
    as your game becomes more and more complex.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**遮挡**窗口的底部点击**烘焙**。Unity编辑器的右下角将出现一个进度条，告诉你计算还需要多长时间。这个过程通常需要相当长的时间，尤其是当你的游戏变得越来越复杂时。
- en: When the baking process has completed, the **Occlusion** window should have
    switched to the **Visualization** tab and the camera should be selected in your
    **Scene** window. If not, select them now. In the **Scene** view, Unity will give
    us a preview of how occlusion culling is working. Only those objects that can
    be seen will be visible while the rest are turned off.![Time for action – occluding
    tanks](img/2014OT_09_14.jpg)
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当烘焙过程完成后，**遮挡**窗口应该已经切换到**可视化**选项卡，并且你的**场景**窗口中应该已经选择了相机。如果没有，请现在选择它们。在**场景**视图中，Unity将为我们预览遮挡剔除的工作情况。只有那些可以看到的对象才会可见，其余的将被关闭。![遮挡坦克的时间
    - 遮挡坦克](img/2014OT_09_14.jpg)
- en: '*What just happened?*'
  id: totrans-186
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We went through the basic process for setting up occlusion culling. We took
    a look at the **Occlusion** window and learned about the settings available there.
    Occlusion culling is great for reducing the number of draw calls in a scene. However,
    that reduction needs to be balanced against the cost of storing and retrieving
    the occlusion calculations. This balance is achieved by selecting a proper **Technique**
    and an appropriate **View Cell Size**. Play around with the different values now,
    finding a cell size that gives the appropriate amount of detail without supplying
    too much information.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了设置遮挡剔除的基本过程。我们查看**遮挡**窗口，并了解了那里的设置。遮挡剔除对于减少场景中的绘制调用数量非常有用。然而，这种减少需要与存储和检索遮挡计算的成本相平衡。这种平衡是通过选择适当的**技术**和合适的**视图单元格大小**来实现的。现在尝试不同的值，找到一个既提供适当细节又不过度提供信息的单元格大小。
- en: Points to remember
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要记住的要点
- en: 'The following is a list of tips for dealing with and avoiding lag in your games.
    Not all of them will apply to every game you make, but they are good to keep in
    mind for every project:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一份处理和避免游戏中卡顿的技巧列表。并非所有这些技巧都适用于你制作的每个游戏，但它们对于每个项目都是值得记住的：
- en: Avoid the transparent shaders, if possible, when creating your materials. They
    are a little more expensive to render. And, you can save yourself a world of headaches
    dealing with depth sorting, if you avoid them.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建材质时，如果可能的话，避免使用透明着色器。它们渲染起来稍微昂贵一些。而且，如果你避免使用它们，你可以在处理深度排序时节省很多麻烦。
- en: Use one material per object. The greater the number of draw calls in your game,
    the longer each frame will take to render. Every mesh is drawn once per material
    on it, even if the material doesn't appear to do anything. By keeping to one material
    per object, especially on mobile platforms, you minimize the number of draw calls
    and maximize your rendering speed.
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个对象使用一种材料。你的游戏中调用绘制的次数越多，每一帧渲染所需的时间就越长。每个网格都会根据其上的材料绘制一次，即使材料看起来没有做任何事情。通过每个对象使用一种材料，尤其是在移动平台上，你可以最小化调用绘制的次数并最大化渲染速度。
- en: Combine textures when possible. Not every texture you make will utilize the
    whole of the image. Whenever possible, combine the textures of objects that are
    in the same scene. This maximizes your efficient use of the images, while reducing
    the final build size and amount of memory needed to utilize those textures.
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下合并纹理。你制作的每个纹理并不一定会利用整个图像。每当可能时，将同一场景中对象的纹理合并在一起。这最大化了你对图像的有效使用，同时减少了最终构建的大小和利用这些纹理所需的内存量。
- en: Group objects in your **Hierarchy** using empty GameObjects. Though not specific
    to minimizing lag, it will make your project easier to work with. Especially with
    large and complex levels, you will be able to spend less time searching through
    the objects in your scene and more time making a great game.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用空GameObject在**层次结构**中分组对象。虽然这并不是专门用于减少延迟，但它会使你的项目更容易操作。特别是对于大型和复杂的关卡，你将能够花费更少的时间在场景中的对象中搜索，更多的时间制作出优秀的游戏。
- en: The **Console** window is your friend. Before worrying about your game not working,
    first take a look at the **Console** window or the bar at the bottom in Unity.
    Both will display any complaints that Unity might have about the way your game
    is currently set up. The messages here are great for pointing you in the right
    direction to fixing any problems. If you are ever unsure what the messages are
    trying to tell you, perform a Google search for the message and you should be
    able to easily find a solution from one of the many other Unity users. If your
    code ever appears to not be working and Unity isn't complaining about it, use
    the `Debug.Log` function to print messages to the **Console**. This will let you
    find places that your code might be exiting unexpectedly, or values that are not
    what they should be.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**控制台**窗口是你的朋友。在担心你的游戏无法工作之前，首先查看Unity中的**控制台**窗口或底部的栏。两者都会显示Unity可能对你当前游戏设置的任何不满。这里的信息对于指出解决问题的正确方向非常有用。如果你对消息的含义感到不确定，请在Google上搜索该消息，你应该能够轻松地从许多其他Unity用户那里找到解决方案。如果你的代码似乎不起作用，而Unity没有对此提出抱怨，请使用`Debug.Log`函数将消息打印到**控制台**。这将让你找到代码可能意外退出的地方，或者不是应有的值。'
- en: Device testing is important. Working in the Editor is great, but there is nothing
    quite like testing on the target device. You can get a much better feel for how
    your game is performing when it is on the device. The Editor always introduces
    a small amount of additional processing overhead. Also, the computer you are working
    on will always be more powerful than the mobile devices you might intend on deploying
    to.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设备测试很重要。在编辑器中工作很棒，但没有什么能比在目标设备上测试更接近真实情况了。你可以在设备上更好地感受到你的游戏性能。编辑器总是引入一定量的额外处理开销。此外，你正在工作的电脑总是比你可能打算部署的移动设备更强大。
- en: Summary
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about our options for optimization in Unity. We
    first took a look at the various settings, for the assets used in our games, used
    to keep their file size down while maintaining quality. Next, we learned about
    some settings that affect the overall game. After that, we explored options for
    tracking the performance of the game. We first looked at some tools provided by
    Unity for tracking that performance. Then, we created a tool of our own for tracking
    script performance in detail. We then took a look at some options for minimizing
    lag in our games, including utilizing occlusion culling. Now that we know about
    all of these tools and options, go through the games we created and optimize them.
    Make them the best they can be.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了在Unity中进行优化的选项。我们首先查看了一些设置，这些设置用于我们游戏中使用的资产，以在保持质量的同时降低文件大小。接下来，我们了解了一些影响整个游戏的设置。之后，我们探讨了跟踪游戏性能的选项。我们首先查看了一些Unity提供的用于跟踪性能的工具。然后，我们创建了一个用于详细跟踪脚本性能的工具。然后，我们查看了一些减少游戏延迟的选项，包括利用遮挡剔除。现在我们已经了解了所有这些工具和选项，请检查我们创建的游戏并进行优化。让它们变得尽可能好。
- en: In this book we learned a whole lot. We started with learning about Unity, Android,
    and how to make them work together. Our journey continued with an exploration
    of Unity's GUI system and the creation of a Tic-tac-toe game. We then learned
    about the basic assets needed for any game, while starting the creation of a Tank
    Battle game. Our Tank Battle game then expanded with the addition of a few special
    camera effects and some lighting. We concluded the creation of the Tank Battle
    game by introducing some enemies and making them chase the player. The creation
    of our Space Fighter game taught us about the touch and tilt controls that we
    can utilize in our game. A short break from that game saw the creation of an Angry
    Birds clone while learning about physics and the possibilities of a 2D game in
    Unity. We then returned to the Space Fighter game to add some polish with the
    addition of sound and particle effects. Finally, our journey concluded by learning
    about optimizing our games. Thank you for reading this book. Enjoy your experiences
    with Unity and creating the awesome games you have always dreamed about.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们学到了很多。我们从学习Unity、Android以及如何使它们协同工作开始。我们的旅程继续通过探索Unity的GUI系统并创建一个井字棋游戏。然后，我们学习了任何游戏都需要的基本资源，同时开始创建一个坦克大战游戏。我们的坦克大战游戏通过添加一些特殊相机效果和一些光影效果而扩展。通过引入一些敌人并让他们追逐玩家，我们完成了坦克大战游戏的创建。我们的太空战斗机游戏让我们了解了可以在我游戏中利用的触摸和倾斜控制。短暂的休息后，我们创建了一个愤怒的小鸟克隆版，同时学习物理和Unity中2D游戏的可能。然后，我们回到太空战斗机游戏，通过添加声音和粒子效果来增加一些细节。最后，通过学习优化我们的游戏，我们的旅程画上了句号。感谢您阅读这本书。享受您与Unity一起的经历，并创建您一直梦想中的精彩游戏。
