- en: 'Chapter 2: Understanding the Declarative Paradigm'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章：理解声明式范式
- en: Jetpack Compose marks a fundamental shift in Android UI development. While the
    traditional view-based approach is centered around components and classes, the
    new framework follows a declarative approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose标志着Android UI开发的根本性转变。虽然传统的基于视图的方法以组件和类为中心，但新的框架遵循声明式方法。
- en: In [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014), *Building Your First
    Compose App*, I introduced you to composable functions, the basic building blocks
    of a Compose-based UI. In this chapter, we will briefly review how Android UIs
    are implemented with traditional classes and techniques. You will learn about
    some issues of this approach, and how a declarative framework helps overcome them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第1章](B17505_01_ePub.xhtml#_idTextAnchor014)中，*构建您的第一个Compose应用*，我向你介绍了可组合函数，它是基于Compose的UI的基本构建块。在本章中，我们将简要回顾如何使用传统的类和技术实现Android
    UI。你将了解这种方法的一些问题，以及如何通过声明式框架克服这些问题。
- en: 'The main sections of this chapter are as follows:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主要部分如下：
- en: Looking at the Android view system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查看Android视图系统
- en: Moving from components to composable functions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从组件到可组合函数
- en: Examining architectural concepts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查架构概念
- en: We'll start by looking at my second sample app, *Hello View*. It is a re-implementation
    of the *Hello* app from [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*. *Hello View* uses views, an XML **layout file**,
    and **view binding**.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从查看我的第二个示例应用*Hello View*开始。它是[第1章](B17505_01_ePub.xhtml#_idTextAnchor014)中*构建您的第一个Compose应用*的*Hello*应用的重新实现。*Hello
    View*使用视图、XML **布局文件**和**视图绑定**。
- en: Next, we will cover key aspects of **components**, which are UI building blocks
    in the view-based world. You will learn about the similarities and differences
    of composable functions, and we will find out how composable functions can overcome
    some of the limitations of component-centric frameworks.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍**组件**的关键方面，它们是基于视图世界的UI构建块。你将了解可组合函数的相似之处和不同之处，我们将找出可组合函数如何克服以组件为中心的框架的一些局限性。
- en: Finally, we will look at the different layers of the Android framework and how
    they relate to building UIs. By the end of this chapter, you will have gathered
    enough background information to explore the key principles of Jetpack Compose,
    which is the topic of the next chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨Android框架的不同层次以及它们与构建UI的关系。到本章结束时，你将收集到足够的背景信息来探索Jetpack Compose的关键原则，这是下一章的主题。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Please refer to the *Technical requirements* section in [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*, for information about how to install and set
    up Android Studio and how to get the sample app. All the code files for this chapter
    can be found on GitHub at [https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅[第1章](B17505_01_ePub.xhtml#_idTextAnchor014)中的*技术要求*部分，*构建您的第一个Compose应用*，了解如何安装和设置Android
    Studio以及如何获取示例应用。本章的所有代码文件都可以在GitHub上找到：[https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02](https://github.com/PacktPublishing/Android-UI-Development-with-Jetpack-Compose/tree/main/chapter_02)。
- en: Looking at the Android view system
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看Android视图系统
- en: 'The traditional approach to building Android UIs is to define component trees
    and modify them during runtime. While this can be done completely programmatically,
    the preferred way is to create layout files. They use XML tags and attributes
    to define which UI elements should be presented on screen. Let''s take a look:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 传统构建Android UI的方法是定义组件树并在运行时修改它们。虽然这可以完全通过编程实现，但首选的方法是创建布局文件。它们使用XML标签和属性来定义哪些UI元素应该显示在屏幕上。让我们看一下：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Layout files define a hierarchical structure (a tree). In the previous XML snippet,
    the root node (`ConstraintLayout`) contains only one child (`TextView`). The complete
    XML file of *Hello View* has two more children, an `EditText` component and a
    `Button` component. Layout files of real-world apps can be quite nested, containing
    dozens of children.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 布局文件定义了一个层次结构（一棵树）。在前面的XML片段中，根节点（`ConstraintLayout`）只包含一个子节点（`TextView`）。*Hello
    View*的完整XML文件还有两个额外的子节点，一个`EditText`组件和一个`Button`组件。现实世界的应用布局文件可以非常嵌套，包含数十个子节点。
- en: Generally speaking, `...Layout` elements are responsible for sizing and positioning
    their children. While they may have a visual representation (for example, background
    color or a border), they usually don't interact with the user. `ScrollView` is
    one of the exceptions to that rule. All other (non `...Layout`) elements such
    as buttons, checkboxes, and editable text fields not only allow for user interaction
    – it's their purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一般而言，`...Layout` 元素负责调整其子元素的大小和位置。虽然它们可能有视觉表示（例如，背景颜色或边框），但它们通常不与用户交互。`ScrollView`
    是这个规则的例外之一。所有其他（非 `...Layout`）元素，如按钮、复选框和可编辑文本字段不仅允许用户交互——这是它们的目的。
- en: Both layout and non-layout elements are called components. We will return to
    this term in the *Moving from components to composable functions* section. But
    before that, let's see how layout files are used in apps.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 布局和非布局元素统称为组件。我们将在 *从组件到可组合函数的迁移* 部分回到这个术语。但在那之前，让我们看看布局文件在应用中的使用方式。
- en: Inflating layout files
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局文件展开
- en: Activities are one of the core building blocks of an Android app. They implement
    a quite sophisticated lifecycle, which is reflected by a couple of methods we
    can override.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 活动（Activities）是 Android 应用程序的核心构建块之一。它们实现了一个相当复杂的生命周期，这反映在我们可以重写的几个方法中。
- en: 'Typically, `onCreate()` is used to prepare the app and to show the UI by invoking
    `setContentView()`. This method can receive an ID representing a layout file,
    for example, `R.layout.main`. Because of this, you must define variables pointing
    to the UI elements you wish to access. This may look like the following:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，`onCreate()` 方法用于准备应用并通过调用 `setContentView()` 来显示 UI。此方法可以接收一个表示布局文件的 ID，例如，`R.layout.main`。因此，你必须定义指向你希望访问的
    UI 元素的变量。这看起来可能如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'It turned out that this doesn''t scale well for bigger apps. There are two
    important issues to remember:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，这在大应用中扩展性不好。有两个重要的问题需要记住：
- en: You may face crashes during runtime if the variable is accessed before it has
    been initialized.
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在变量初始化之前访问它，你可能会在运行时遇到崩溃。
- en: The code quickly becomes lengthy if you have more than a few components.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多组件，代码会很快变得冗长。
- en: 'Sometimes, you can prevent the first issue by using local variables, as follows:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可以通过使用局部变量来防止第一个问题，如下所示：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This way, you can access the UI element immediately after the declaration. But
    the variable exists only in the scope in which it has been defined – a block or
    a function. This may be problematic because you often need to modify a component
    outside `onCreate()`. That's because in a component-based world, you modify the
    UI by modifying the properties of a component. It turned out that often the same
    set of changes are necessary for different parts of the app, so to avoid code
    duplication, they are refactored into methods, which need to know the component
    to change it.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以在声明后立即访问 UI 元素。但变量只存在于它被定义的作用域内——一个块或一个函数。这可能会带来问题，因为你经常需要在 `onCreate()`
    之外修改组件。这是因为在一个基于组件的世界中，你通过修改组件的属性来修改 UI。结果发现，通常需要对应用的不同部分进行相同的更改集，为了避免代码重复，它们被重构为需要知道要更改的组件的方法。
- en: 'To solve the second issue – that is, to spare the developer from the task of
    keeping references to components – Google introduced view binding. It belongs
    to Jetpack and debuted in Android Studio 3.6\. Let''s see how it is used:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决第二个问题——即，让开发者免于保持组件引用的任务——谷歌引入了视图绑定。它属于 Jetpack，并在 Android Studio 3.6 中首次亮相。让我们看看它是如何使用的：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'No matter how complex the UI of an activity is, we need to keep only one reference.
    This variable is usually called `binding`, which is initialized by invoking `inflate()`
    of a `...Binding` instance. The `MainBinding` class in my example is automatically
    generated and updated, when `main.xml` is modified. Every layout file gets a corresponding
    `...Binding` class. To enable this mechanism, the `viewBinding` build option must
    be set to `true` in the module-level `build.gradle` file:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 无论一个活动的 UI 多么复杂，我们只需要保留一个引用。这个变量通常被称为 `binding`，它通过调用 `...Binding` 实例的 `inflate()`
    方法进行初始化。在我的示例中，`MainBinding` 类在修改 `main.xml` 时会自动生成和更新。每个布局文件都会对应一个 `...Binding`
    类。为了启用此机制，必须在模块级别的 `build.gradle` 文件中将 `viewBinding` 构建选项设置为 `true`：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: So, after you have inflated a layout file by invoking `...Binding.inflate()`
    and assigned it to an instance variable, you can access all of its components
    via their IDs using this variable. IDs are set using the XML attribute `android:id`
    (for example, `android:id="@+id/message"`).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在通过调用 `...Binding.inflate()` 指示一个布局文件并分配给实例变量之后，您可以通过这些变量通过它们的 ID 访问其所有组件。ID
    是使用 XML 属性 `android:id`（例如，`android:id="@+id/message"`）设置的。
- en: Important Note
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: There is an important difference between the old-fashioned `findViewById()`
    and view binding. If you use the latter one, you must pass the root component
    (`binding.root`) to `setContentView()`, rather than an ID representing the layout
    file (`R.layout.main`).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的 `findViewById()` 和视图绑定之间存在一个重要的区别。如果您使用后者，您必须将根组件（`binding.root`）传递给 `setContentView()`，而不是表示布局文件的
    ID（`R.layout.main`）。
- en: In this section, I have shown you how to obtain references to UI elements. The
    next section, *Modifying the UI*, will explain how to make use of this.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我向您展示了如何获取 UI 元素的引用。下一节 *修改 UI* 将解释如何利用这些信息。
- en: Modifying the UI
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改 UI
- en: 'In this section, we will see how to make changes to a View-based UI. Let''s
    start by looking at the `enableOrDisableButton()` function, which is invoked in
    `onCreate()`. Its name gives you a clue regarding its purpose – enabling or disabling
    a button. But why do we need this? *Hello View* is a reimplementation of the *Hello*
    app from [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014), *Building Your
    First Compose App*, but it has one additional feature. As long as the user has
    not entered at least one non-blank character, **Done** can''t be clicked:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解如何更改基于视图的 UI。让我们首先查看在 `onCreate()` 中调用的 `enableOrDisableButton()`
    函数，其名称为您提供了关于其目的的线索——启用或禁用按钮。但我们为什么需要这样做呢？*Hello View* 是 *Hello* 应用（在 [*第 1 章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个
    Compose 应用*）的重新实现，但它有一个额外的功能。只要用户没有输入至少一个非空白字符，**完成** 就不能点击：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '`binding.done` refers to the button during runtime. It can be clicked only
    if `isEnabled` is `true`. The text input field is denoted by `binding.name`. Its
    `text` property reflects what the user has already entered. `isNotBlank()` tells
    us if at least one non-whitespace character is present.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`binding.done` 在运行时引用按钮。只有当 `isEnabled` 为 `true` 时才能点击。文本输入字段用 `binding.name`
    表示。它的 `text` 属性反映了用户已经输入的内容。`isNotBlank()` 告诉我们是否至少有一个非空白字符存在。'
- en: 'In the code I have shown you so far, `enableOrDisableButton()` is called only
    at the end of `onCreate()`. But we also need to invoke the function whenever the
    user has input something. Let''s see how to do this (please note that the following
    code snippets belong inside `onCreate()` so that they are executed when the activity
    is created):'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我向您展示的代码中，`enableOrDisableButton()` 只在 `onCreate()` 的末尾被调用。但我们还需要在用户输入内容时调用该函数。让我们看看如何做到这一点（请注意，以下代码片段属于
    `onCreate()` 内部，以便在活动创建时执行）：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Text input fields can modify certain aspects of the onscreen keyboard. For example,
    to have it show a `android:imeOptions="actionDone"` attribute to the layout file.
    To react to clicks on this key, we need to register code by invoking `setOnEditorActionListener()`.
    Then, `binding.done.performClick()` simulates clicks on the **Done** button. You
    will see shortly why I do this.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 文本输入字段可以修改屏幕键盘的某些方面。例如，为了在布局文件中显示 `android:imeOptions="actionDone"` 属性。为了对此键的点击做出反应，我们需要通过调用
    `setOnEditorActionListener()` 注册代码。然后，`binding.done.performClick()` 模拟对 **完成**
    按钮的点击。您很快就会看到我这样做的原因。
- en: The lambda function we pass to `doAfterTextChanged()` is invoked every time
    the user enters or deletes something in the text input field. When this happens,
    `enableOrDisableButton()` is called, which makes the button clickable if the text
    currently present in the input field is not blank.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们传递给 `doAfterTextChanged()` 的 lambda 函数会在用户在文本输入字段中输入或删除内容时被调用。当这种情况发生时，会调用
    `enableOrDisableButton()`，如果输入字段中当前显示的文本不为空，则使按钮可点击。
- en: Finally, `visibility = VISIBLE` occurs inside `binding.name.run {`, so it makes
    the text input field visible. This is the desired state when the activity is created.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`visibility = VISIBLE` 发生在 `binding.name.run {` 内部，因此使文本输入字段可见。这是活动创建时的期望状态。
- en: 'Now, let''s turn to code related to the **Done** button:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转向与 **完成** 按钮相关的代码：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'When `visibility` property: `visibility = VISIBLE` makes the **Done** button
    visible. This is the desired state when the activity is created.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `visibility` 属性为 `visibility = VISIBLE` 时，会使 **完成** 按钮可见。这是活动创建时的期望状态。
- en: Do you remember that I promised to explain why I invoke `performClick()` inside
    the lambda function for `setOnEditorActionListener`? This way, I can reuse the
    code inside the button listener without refactoring it into a separate function
    and calling it instead, which certainly is a viable alternative.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得我承诺解释为什么在`setOnEditorActionListener`的lambda函数中调用`performClick()`吗？这样，我可以在不重构为单独函数的情况下重用按钮监听器内的代码，这当然是一个可行的替代方案。
- en: 'Before we move on, let''s recap what have we seen so far:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续之前，让我们回顾一下到目前为止我们所看到的内容：
- en: The UI is defined in an XML file.
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI在XML文件中定义。
- en: At runtime, it is inflated to a component tree.
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在运行时，它被填充为组件树。
- en: To change the UI, attributes of all related components must be modified.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要更改UI，必须修改所有相关组件的属性。
- en: Even if a UI element is not visible, it remains part of the component tree.
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 即使UI元素不可见，它仍然是组件树的一部分。
- en: This is why common UI frameworks are called **imperative**. Any change to the
    UI is done by deliberately modifying the attributes of all components involved.
    As you can see in my example, this works quite well for small apps. But the more
    UI elements an app has, the more demanding it will be to keep track of such changes.
    Let me explain. Changes in domain data (adding an item to a list, deleting text,
    or loading an image from a remote service) require changes in the UI. The developer
    needs to know which portion of domain data relates to which UI element and must
    then modify the component tree accordingly. The bigger an app becomes, the more
    difficult this is.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么常见的UI框架被称为**命令式**。任何对UI的更改都是通过故意修改所有相关组件的属性来完成的。正如你在我例子中看到的那样，这对于小型应用来说效果相当好。但随着应用UI元素的增多，跟踪这些更改的要求也会增加。让我来解释一下。领域数据的变化（向列表中添加项目、删除文本或从远程服务加载图像）需要UI的变化。开发者需要知道哪些领域数据部分与哪个UI元素相关，然后必须相应地修改组件树。应用越大，这越困难。
- en: Also, without clear architectural guidance, the code for changing the component
    tree almost always eventually mixes with code that modifies data the app is using.
    This makes it even more demanding and error-prone to maintain and further develop
    the app. In the next section, we will turn to composable functions. You will learn
    how they differ from components and why this helps overcome weaknesses in the
    imperative approach.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果没有明确的架构指导，更改组件树的代码几乎总是最终会与修改应用所使用数据的代码混合。这使得维护和进一步开发应用变得更加困难和容易出错。在下一节中，我们将转向可组合函数。你将了解它们与组件的不同之处以及为什么这有助于克服命令式方法中的弱点。
- en: Moving from components to composable functions
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从组件到可组合函数的转变
- en: So far, I explained the word *component* by saying that it refers to UI elements.
    In fact, the term is used in quite a few other areas. Generally speaking, components
    structure systems by separating distinct portions or parts of them. The inner
    workings of a component are typically hidden from the outside (known as the **black
    box principle**).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我通过说它指的是UI元素来解释单词*组件*。实际上，这个术语在许多其他领域也被使用。一般来说，组件通过分离系统的不同部分或部分来结构化系统。组件的内部工作通常对外部隐藏（称为**黑盒原理**）。
- en: Tip
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: To learn more about the black box principle, please refer to [https://en.wikipedia.org/wiki/Black_box](https://en.wikipedia.org/wiki/Black_box).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 想了解更多关于黑盒原理的信息，请参阅[https://en.wikipedia.org/wiki/Black_box](https://en.wikipedia.org/wiki/Black_box)。
- en: Components communicate with other parts of the system by sending and receiving
    messages. The appearance or behavior of a component is controlled through a set
    of attributes, or **properties**.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 组件通过发送和接收消息与其他系统部分进行通信。组件的外观或行为通过一组属性或**属性**进行控制。
- en: Consider `TextView`. We set text by modifying the `text` property and we control
    its visibility through `visibility`. What about sending and receiving messages?
    Let's look at `Button`. We can react to clicks (receive a message) by registering
    (sending a message) an `OnClickListener` instance. The same principle applies
    to `EditText`. We configure its appearance through setting properties (`text`),
    send a message by invoking `setOnEditorActionListener()`, and receive one through
    the lambda expression we passed as a parameter.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以`TextView`为例。我们通过修改`text`属性来设置文本，并通过`visibility`来控制其可见性。那么发送和接收消息呢？让我们看看`Button`。我们可以通过注册（发送消息）一个`OnClickListener`实例来对点击（接收消息）做出反应。同样的原则也适用于`EditText`。我们通过设置属性（`text`）来配置其外观，通过调用`setOnEditorActionListener()`来发送消息，并通过我们作为参数传递的lambda表达式来接收消息。
- en: 'Message-based communication and configuration via properties make components
    very tool-friendly. In fact, most component-based UI frameworks work well with
    drawing board-like editors. The developer defines a UI using drag and drop. Components
    are configured using property sheets. *Figure 2.1* shows the Layout Editor in
    Android Studio. You can switch between a **Design** view, browse **Code** (an
    XML file), or a combination of both (**Split**):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 基于属性的消息传递和配置使组件非常易于使用工具。事实上，大多数基于组件的UI框架与绘图板式编辑器配合得很好。开发者通过拖放定义UI。组件通过属性表进行配置。*图2.1*显示了Android
    Studio中的布局编辑器。您可以在**设计**视图、浏览**代码**（XML文件）或两者的组合（**分割**）之间切换：
- en: '![Figure 2.1 – The Layout Editor in Android Studio'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.1 – The Layout Editor in Android Studio'
- en: '](img/B17505_02_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_02_01.jpg]'
- en: Figure 2.1 – The Layout Editor in Android Studio
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Android Studio中的布局编辑器
- en: We now have a more precise understanding of how the *component* term is used
    in the context of UIs. Building on this foundation, we will now look at component
    hierarchies.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对在UI上下文中使用“组件”一词有了更精确的理解。在此基础上，我们现在将探讨组件层次结构。
- en: Component hierarchies
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件层次结构
- en: If you compare the XML attributes of `ConstraintLayout`, `TextView`, and `EditText`,
    you will find unique attributes per tag, one example being `android:inputType`.
    On the other hand, `android:layout_width` and `android:layout_height` are present
    in all three tags, defining the size of the corresponding element. Size and position
    are relevant for all components.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你比较`ConstraintLayout`、`TextView`和`EditText`的XML属性，你会发现每个标签都有独特的属性，一个例子是`android:inputType`。另一方面，`android:layout_width`和`android:layout_height`在所有三个标签中都有，定义了相应元素的大小。大小和位置对所有组件都相关。
- en: 'Yet, specific attributes influence visual appearance or behavior; this is *not*
    relevant for all kinds of UI elements, only a subset. Here''s an example: text
    fields and buttons will want to show or receive text. A `FrameLayout` UI element
    won''t. Think of it this way: the *more specialized* an attribute is, the *less
    likely is its reuse* in another component. However, general ones (such as `width`,
    `height`, `location`, or `color`) will be needed in most UI elements.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，特定的属性会影响视觉外观或行为；这并不适用于所有类型的UI元素，而只是其中的一部分。这里有一个例子：文本字段和按钮会显示或接收文本。而`FrameLayout`
    UI元素则不会。可以这样想：属性越专业化，在另一个组件中重用的可能性就越小。然而，一般的属性（如`width`、`height`、`location`或`color`）在大多数UI元素中都是必需的。
- en: Based on its attributes, each component has a level of specialization. For example,
    `EditText` is more specific than `TextView` because it can handle text input.
    `Button` is a general-purpose button; clicking on it triggers some action. On
    the other hand, a `CheckBox` component can be either checked or unchecked. This
    type of button can represent two states. A `Switch` component has two states,
    too. It's a toggle switch widget that can select between two options.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其属性，每个组件都有一个专业化的级别。例如，`EditText`比`TextView`更具体，因为它可以处理文本输入。`Button`是一个通用按钮；点击它将触发某些操作。另一方面，`CheckBox`组件可以是选中的或未选中的。这种按钮可以表示两种状态。`Switch`组件也有两种状态。它是一个可以在这两个选项之间选择的切换开关小部件。
- en: The degree of specialization can be modeled easily in object-oriented programming
    languages through inheritance. A more specialized UI element (class) extends a
    general element. Therefore, many often-used UI frameworks have been implemented
    in Java, C++, or C# (object-oriented languages). It is important to note, though,
    that component-like concepts can be achieved with other types of programming languages
    too. So, object orientation may be considered a benefit, but it's not a necessity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言中，可以通过继承轻松地模拟专业化的程度。一个更专业的UI元素（类）扩展了一个通用元素。因此，许多常用的UI框架都是用Java、C++或C#（面向对象的语言）实现的。然而，需要注意的是，类似组件的概念也可以用其他类型的编程语言实现。所以，面向对象可能是一个优势，但不是必需的。
- en: At this point, you may be thinking, *Didn't he mix two different things? How
    are tags and attributes of Android layout files related to classes?* Allow me
    to explain. Earlier, I said that an XML file is `inflate()` creates a tree of
    objects based on this information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，你可能正在想，*他不是把两件事物混淆了吗？Android布局文件的标签和属性与类有什么关系？* 让我来解释一下。之前我说过，一个XML文件通过`inflate()`方法根据这些信息创建一个对象树。
- en: So, Android layout files describe component trees outside of Java or Kotlin
    files using a different syntax (an XML syntax). But they are not declarative in
    the same way Jetpack Compose is because layout files define a UI regardless of
    the current state. For example, they do not take into account that a button should
    be disabled because a text field is empty. A Compose UI, on the other hand, is
    declared *based* on that.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Android 布局文件使用不同的语法（XML 语法）描述 Java 或 Kotlin 文件之外的组件树，但它们并不像 Jetpack Compose
    那样声明式。因为布局文件定义的 UI 与当前状态无关。例如，它们不考虑按钮应该被禁用，因为文本字段为空。另一方面，Compose UI 是基于那个状态声明的。
- en: 'The remaining part of this section will look closer at some of Android''s UI
    components and how they are related. Before that, let''s recap what we have learned
    so far:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本节剩余部分将更详细地探讨一些 Android 的 UI 组件及其相互关系。在此之前，让我们回顾一下到目前为止我们已经学到了什么：
- en: All Android views are classes.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有 Android 视图都是类。
- en: Tags in layout files represent classes and attributes are their members.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布局文件中的标签代表类，属性则是它们的成员。
- en: '`inflate()` creates an object tree.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`inflate()` 创建一个对象树。'
- en: Changes to the UI are achieved by modifying this tree.
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过修改此树来实现对 UI 的更改。
- en: Some of Android's UI elements are quite specific. `RatingBar`, for example,
    allows the user to rate something by selecting a certain number of stars. Others
    are way more general; for example, `ImageView` just displays image resources,
    and `FrameLayout` blocks out an area on the screen to display a stack of children.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: Android 的某些 UI 元素非常具体。例如，`RatingBar` 允许用户通过选择一定数量的星星来对某物进行评分。其他则更为通用；例如，`ImageView`
    仅显示图像资源，而 `FrameLayout` 则在屏幕上划出一个区域以显示子视图堆栈。
- en: 'To understand how Android''s UI elements are related, let''s look at the ones
    used in *Hello View* in a little more detail. We''ll start with `ConstraintLayout`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解 Android 的 UI 元素是如何相互关联的，让我们更详细地看看在 *Hello View* 中使用的那些。我们将从 `ConstraintLayout`
    开始：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The root of *all* classes in Java is `java.lang.Object`. Significant parts of
    the Android framework are based on Java and its class library. So, all views directly
    or indirectly extend `java.lang.Object`. The immediate parent of `ConstraintLayout`
    is `android.view.ViewGroup`, which in turn is a sibling of `android.view.View`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: Java 中所有类的根是 `java.lang.Object`。Android 框架的许多重要部分基于 Java 和其类库。因此，所有视图都直接或间接地扩展了
    `java.lang.Object`。`ConstraintLayout` 的直接父类是 `android.view.ViewGroup`，而 `android.view.View`
    则是其兄弟。
- en: Now, let's look at `android.widget.Button`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `android.widget.Button`。
- en: '[PRE9]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Its direct ancestor is `android.widget.TextView`, which extends `android.view.View`.
    Are we seeing a pattern here? `android.view.View` seems to be the root of all
    Android UI elements. Let''s check our hypothesis by examining another component:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它的直接祖先是 `android.widget.TextView`，它扩展了 `android.view.View`。这里我们是否看到了一个模式？`android.view.View`
    似乎是一切 Android UI 元素的根源。让我们通过检查另一个组件来验证我们的假设：
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, components showing or receiving text usually extend `android.widget.TextView`,
    whose parent is `android.view.View`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，显示或接收文本的组件通常扩展了 `android.widget.TextView`，其父类是 `android.view.View`。
- en: Important Note
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: '`android.view.View` is the root of all Android UI elements. All components
    that position and size their children extend `android.view.ViewGroup`.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`android.view.View` 是所有 Android UI 元素的根。所有定位和调整子视图大小的组件都扩展了 `android.view.ViewGroup`。'
- en: So far, structuring UI elements in a hierarchy based on specialization seems
    to work well. Unfortunately, this approach does have limitations. We'll turn to
    them in the following section.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，基于专业化的层次结构来组织 UI 元素似乎效果良好。不幸的是，这种方法确实存在局限性。我们将在下一节中探讨它们。
- en: Limitations of component hierarchies
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组件层次结构的局限性
- en: 'Buttons usually show text. Therefore, it seems natural to extend a more general
    text component. As we have seen in the previous section, Android does just that.
    What if your app requires a button that has no text and shows an image instead?
    In such scenarios, you can use `ImageButton`:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮通常显示文本。因此，扩展一个更通用的文本组件似乎是自然的。正如我们在上一节中看到的，Android 正是这样做的。如果你的应用程序需要一个没有文本且显示图像的按钮，在这种情况下，你可以使用
    `ImageButton`：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The class extends `android.widget.ImageView`. This makes sense, as the purpose
    of this component is to show just an image, quite like `Button` and text. But
    what if we want to show a button that contains both text and image? The closest
    common ancestor of `ImageButton` and an ordinary text button is `android.view.View`,
    the root of the Android UI element hierarchy. Therefore, everything `Button` inherits
    from `TextView` is not immediately available to `ImageButton` (and vice versa).
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类扩展了 `android.widget.ImageView`。这很有道理，因为这个组件的目的就是显示一个图像，就像 `Button` 和文本一样。但如果我们想显示一个包含文本和图像的按钮呢？`ImageButton`
    和普通文本按钮最接近的共同祖先是 `android.view.View`，它是 Android UI 元素层次结构的根。因此，`Button` 从 `TextView`
    继承的所有内容并不立即对 `ImageButton`（反之亦然）可用。
- en: The reason is that Java is based upon `Button` wanted to take advantage of the
    features of `TextView` and `ImageView`, it would need to extend both, which it
    can't. Does this mean that things would be different if Java supported **multiple
    inheritance**? We could combine the behavior of several components, but we still
    wouldn't be able to reuse functionality tied to *individual* attributes, methods,
    or sets of them. Let's see why this is important.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 原因是 Java 基于 `Button` 想要利用 `TextView` 和 `ImageView` 的功能，它需要同时扩展这两个类，但它不能这样做。这意味着如果
    Java 支持 **多重继承**，事情会有所不同吗？我们可以组合几个组件的行为，但我们仍然无法重用与 *单个* 属性、方法或它们的集合相关的功能。让我们看看为什么这很重要。
- en: The `View` class knows about padding (providing space to the inside of its bounds)
    but not about margins (space to the outside of its bounds). Margins are defined
    in `ViewGroup`. Hence, if a component wants to use them, it must extend `ViewGroup`.
    But in doing so, it inevitably inherits all other features of this class (for
    example, the ability to layout children), regardless of needing them or not. The
    underlying issue is that in a component-centric framework, the combination of
    *individual features* of one or more components to create a more specialized UI
    element is not possible because you cannot cut out these features. The reason
    for this is that reuse happens at a component level.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`View` 类了解填充（为其边界内部提供空间），但不了解边距（为其边界外部提供空间）。边距在 `ViewGroup` 中定义。因此，如果组件想使用它们，它必须扩展
    `ViewGroup`。但这样做，它不可避免地继承了该类的所有其他功能（例如，布局子元素的能力），无论是否需要。根本问题是，在以组件为中心的框架中，将一个或多个组件的
    *单个功能* 组合起来创建一个更专业的 UI 元素是不可能的，因为你不能去除这些功能。这是因为重用发生在组件级别。'
- en: To make individual features reusable, we need to put aside the notion of components.
    That's what, for example, Flutter (the very successful cross-platform alternative
    to Jetpack Compose) does. Its UI framework is fully declarative, still class-based.
    Flutter relies on a simple principle called `Container`, `Padding`, `Align`, or
    `GestureDetector`, rather than modifying a parent.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要使单个功能可重用，我们需要抛开组件的概念。这就是 Flutter（Jetpack Compose 的非常成功的跨平台替代品）所做的事情。它的 UI 框架完全声明式，仍然是基于类的。Flutter
    依赖于一个简单的原则，称为 `Container`、`Padding`、`Align` 或 `GestureDetector`，而不是修改父元素。
- en: In Jetpack Compose, we combine simple building blocks too. Instead of classes,
    we use composable functions. Before we turn to them, I would like to briefly show
    you another potential issue of components.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中，我们也组合简单的构建块。我们使用可组合函数而不是类。在我们转向它们之前，我想简要地展示组件的另一个潜在问题。
- en: As you have seen, in class-based UI component frameworks, specialization is
    modeled through inheritance. The specialized version of a class (which may have
    new features, a new look, or behave slightly different than the ancestor) extends
    a more general version of the class. However, most object-oriented programming
    languages provide means to prohibit this; for example, if a Java class is marked
    final or a Kotlin class is not open, they cannot be extended.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，在基于类的 UI 组件框架中，专业化是通过继承来建模的。类的专业化版本（可能具有新功能、新外观或行为略有不同）扩展了类的更通用版本。然而，大多数面向对象编程语言提供了禁止这种做法的方法；例如，如果一个
    Java 类被标记为 final 或 Kotlin 类不是开放的，它们就不能被扩展。
- en: So, the framework developer can make a deliberate decision to prevent further
    inheritance. `android.widget.Space`, a lightweight `View` subclass to create gaps
    between UI elements, is final. The same applies to `android.view.ViewStub`. It's
    an invisible, zero-sized `View` used to lazily inflate layout resources at runtime.
    Fortunately, most of Android's UI elements can be extended. And for both examples,
    it seems unlikely that we would want to extend them. Hence, you may not face this
    potential issue at all. The point is that in a framework based upon composition
    rather than inheritance, it doesn't matter.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，框架开发者可以做出明确的决定来防止进一步的继承。`android.widget.Space` 是一个轻量级的 `View` 子类，用于在 UI 元素之间创建间隔，它是最终的。同样适用于
    `android.view.ViewStub`。它是一个不可见的、零大小的 `View`，用于在运行时延迟填充布局资源。幸运的是，Android 的大多数
    UI 元素都可以扩展。对于这两个例子，我们似乎不太可能想要扩展它们。因此，您可能根本不会遇到这个潜在的问题。重点是，在基于组合而不是继承的框架中，这并不重要。
- en: Composing UIs with functions
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数组合 UI
- en: 'Now it''s time to return to composable functions. In this section, we will
    look at my sample app *Factorial* (*Figure 2.2*). When the user picks a number
    between 0 and 9, its factorial (the product of it and all the integers below it
    greater than 0) is computed and output, like so:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候回到可组合函数上了。在本节中，我们将查看我的示例应用 *阶乘* (*图 2.2*)。当用户选择一个介于 0 到 9 之间的数字时，它的阶乘（即它和所有大于
    0 的整数的乘积）将被计算并输出，如下所示：
- en: '![Figure 2.2 – The Factorial app'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 2.2 – The Factorial app'
- en: '](img/B17505_02_02.jpg)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_02_02.jpg]'
- en: Figure 2.2 – The Factorial app
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 阶乘应用
- en: 'Here is the simple function that creates the output text:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个创建输出文本的简单函数：
- en: '[PRE12]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The factorial of an `n` non-negative integer value is the product of all positive
    integers less than or equal to `n`. So, the result can be computed easily by multiplying
    all integers between `1` and `n`. Please note that the maximum value of a Kotlin
    `Long` type is 9,223,372,036,854,775,807\. Hence, my implementation does not work
    if `result` would need to be bigger than that.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非负整数 `n` 的阶乘是所有小于或等于 `n` 的正整数的乘积。因此，结果可以通过乘以 `1` 到 `n` 之间的所有整数来轻松计算。请注意，Kotlin
    `Long` 类型的最大值是 9,223,372,036,854,775,807。因此，如果 `result` 需要大于这个值，我的实现将不起作用。
- en: 'Next, I''ll show you how the UI is composed:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我将向您展示如何组合 UI：
- en: '[PRE13]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `Factorial()` composable function contains one predefined composable, `Box()`,
    which in turn has two children, `Text()` and `DropdownMenu()`. I briefly introduced
    you to `Text()` and `Box()` in [*Chapter 1*](B17505_01_ePub.xhtml#_idTextAnchor014),
    *Building Your First Compose App*. So let's concentrate on `DropdownMenu()`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`Factorial()` 可组合函数包含一个预定义的可组合函数 `Box()`，它又包含两个子元素，`Text()` 和 `DropdownMenu()`。我在
    [*第 1 章*](B17505_01_ePub.xhtml#_idTextAnchor014)，*构建您的第一个 Compose 应用* 中简要介绍了您
    `Text()` 和 `Box()`。所以让我们专注于 `DropdownMenu()`。'
- en: 'A drop-down menu (the equivalent to a `Spinner`) displays a list of entries
    in a compact way. It appears upon interaction with an element, such as the following:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 一个下拉菜单（相当于 `Spinner`）以紧凑的方式显示一系列条目。它在与元素交互时出现，如下所示：
- en: An icon or a button
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个图标或按钮
- en: When the user performs a specific action
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户执行特定操作时
- en: In my example, the `Text()` composable must be clicked.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在我的例子中，必须点击 `Text()` 可组合元素。
- en: The content of a menu can either be provided by a `for` loop statement or by
    adding it one by one. Often, but not necessarily, `DropdownMenuItem()` is used.
    If the menu is expanded (that is, open or visible), it is controlled by the `expanded`
    parameter. `onDismissRequest` is used to react to closing the menu without selecting
    something. `DropdownMenuItem()` receives a click handler via the `onClick` parameter.
    That code is executed when the item is clicked.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单的内容可以由 `for` 循环语句提供，或者逐个添加。通常，但不一定，使用 `DropdownMenuItem()`。如果菜单已展开（即打开或可见），则由
    `expanded` 参数控制。`onDismissRequest` 用于在没有选择任何内容的情况下响应菜单的关闭。`DropdownMenuItem()`
    通过 `onClick` 参数接收点击处理程序。当项目被点击时执行该代码。
- en: 'So far, I have presented quite a lot of information about composable functions
    to you. Before we move on, let''s recap what we know so far:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我已经向您介绍了相当多的关于可组合函数的信息。在我们继续之前，让我们回顾一下我们目前所知道的内容：
- en: The entry point of a Compose UI is a composable function.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Compose UI 的入口是一个可组合函数。
- en: From there, other composable functions are called.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从那里，其他可组合函数被调用。
- en: Often, composable functions receive *content* that is other composables.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通常，可组合函数接收 *内容*，即其他可组合函数。
- en: The order of invocation controls where a UI element will be in relation to other
    UI elements.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用顺序控制 UI 元素相对于其他 UI 元素的位置。
- en: Let's continue with how `Factorial()` works. It defines two variables, `expanded`
    and `text`. But how are they used? While an Android layout file defines a component
    tree in its initial state, a composable UI is always declared using actual data.
    This means that there is no need to set up or prepare the UI before it can be
    displayed for the first time. Whenever it is displayed, it looks the way you want.
    Let's see how this works.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续探讨`Factorial()`的工作原理。它定义了两个变量，`expanded`和`text`。但它们是如何使用的呢？虽然Android布局文件在其初始状态中定义了组件树，但可组合UI总是使用实际数据声明的。这意味着在第一次显示UI之前，不需要设置或准备UI。每次显示时，它看起来都是您想要的。让我们看看它是如何工作的。
- en: Most composable functions are configured by a set of parameters. Some of them
    are mandatory; others can be omitted. The important thing is that the composable
    is always called with actual values. On the other hand, components (that is, views)
    are initialized when they are created. And they remain this way until they are
    deliberately changed by altering the value of properties. That's why an app needs
    to keep references to all components (UI elements) it wishes to modify. But how
    is a Compose UI updated?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数可组合函数通过一组参数进行配置。其中一些是必需的；其他可以省略。重要的是，可组合函数始终使用实际值调用。另一方面，组件（即视图）在创建时初始化。并且它们保持这种方式，直到通过更改属性值故意更改。这就是为什么应用程序需要保留所有希望修改的组件（UI元素）的引用。但Compose
    UI是如何更新的？
- en: The process of updating a Compose UI is called `Text()`, there is no need to
    recompose it. If, on the other hand, you pass something Jetpack Compose knows
    it can change, the Compose runtime will initiate an update, a recomposition, when
    that change happens. Values that change over time are called `mutableStateOf()`.
    To refer to state in a composable, you need to `remember` it in that composable
    function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 更新Compose UI的过程称为`Text()`，不需要重新组合。另一方面，如果您传递Jetpack Compose知道它可以更改的内容，当该更改发生时，Compose运行时会启动更新，即重新组合。随时间变化的价值被称为`mutableStateOf()`。要在一个可组合函数中引用状态，您需要在该函数中`remember`它。
- en: Both `expanded` and `text` contain state. When these variables are used as parameters
    for composable functions, those composables will be recomposed whenever the value
    of these variables changes. Setting `expanded` to `true` brings the drop-down
    menu on screen immediately. This is done inside a lambda function passed to `clickable
    {}`. I will be discussing this in the next section. Giving `text` a new value
    changes the display of `Text()` because we pass the variable `text` as the value
    of the equally named parameter. This happens, for example, inside the code block
    passed to `onClick`.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`expanded`和`text`都包含状态。当这些变量用作可组合函数的参数时，这些可组合函数将在这些变量的值发生变化时重新组合。将`expanded`设置为`true`会立即在屏幕上显示下拉菜单。这是在传递给`clickable
    {}`的lambda函数内部完成的。我将在下一节中讨论这个问题。给`text`赋予新值会改变`Text()`的显示，因为我们传递了与参数同名的变量`text`。例如，这发生在传递给`onClick`的代码块内部。'
- en: Getting rid of a component tree (that needs to be updated deliberately) in favor
    of declaring a UI based on state and thus getting updates upon state changes for
    free is possibly one of the most exciting advantages of the declarative approach.
    In the next section, I will explain a few more architectural principles of component-based
    and declarative UI frameworks.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了声明基于状态和因此免费获得状态变化更新的UI，而不是更新（需要故意更改）组件树，这可能是声明性方法最令人兴奋的优点之一。在下一节中，我将解释更多基于组件和声明性UI框架的架构原则。
- en: Examining architectural aspects
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查架构方面
- en: 'In the *Component hierarchies* section, I showed you that component-based UI
    frameworks rely on specialization. General features and concepts are implemented
    in the root component or one of its immediate successors. Such general features
    include the following:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在*组件层次结构*部分，我向您展示了基于组件的UI框架依赖于专业化。通用特性和概念是在根组件或其直接后继组件中实现的。以下是一些通用特性：
- en: Location and size on screen
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 屏幕上的位置和大小
- en: Basic visual aspects like background (color)
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基本视觉方面，如背景（颜色）
- en: Simple user interactions (reacting to clicks)
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简单的用户交互（对点击做出反应）
- en: Any component will provide these features, either in a specialized way or in
    its basic implementation. Android's view system is class-based, so changing functionality
    is done by overriding the methods of the parent.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 任何组件都会以专门的方式或其基本实现提供这些功能。Android的视图系统是类基于的，所以改变功能是通过覆盖父类的方法来完成的。
- en: Composable functions, on the other hand, do not have a shared set of properties.
    By annotating a function with `@Composable`, we make certain parts of Jetpack
    Compose aware of it. But besides not specifying a return type, composables seem
    to have few things in common. However, this would have been a pretty short-sighted
    architectural decision. In fact, Jetpack Compose makes providing a simple, predictable
    API really easy. The remaining part of this section illustrates this by showing
    you how to react to clicks, and how to size and position UI elements.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，可组合函数没有共享的属性集。通过使用`@Composable`注解一个函数，我们使Jetpack Compose的某些部分能够识别它。但是，除了不指定返回类型外，组合函数似乎很少有共同之处。然而，这将会是一个相当短视的架构决策。事实上，Jetpack
    Compose使得提供简单、可预测的API变得非常容易。本节的剩余部分通过向您展示如何对点击做出反应，以及如何调整UI元素的大小和位置来展示这一点。
- en: Reacting to clicks
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对点击做出反应
- en: Android's `View` class contains a method called `setOnClickListener()`. It receives
    a `View.OnClickListener` instance. This interface contains one method, `onClick(View
    v)`. The implementation of this method provides the code that should be executed
    when the view is clicked. Additionally, there is a view property called `clickable`.
    It is accessed through `setClickable()` and `isClickable()`. If `clickable` is
    set to `false` after the listener has been set, the click event will not be delivered
    (`onClick()` is not called).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Android的`View`类包含一个名为`setOnClickListener()`的方法。它接收一个`View.OnClickListener`实例。此接口包含一个方法，`onClick(View
    v)`。此方法的实现提供了当视图被点击时应执行的代码。此外，还有一个名为`clickable`的视图属性。它通过`setClickable()`和`isClickable()`访问。如果在设置监听器之后将`clickable`设置为`false`，则点击事件将不会传递（`onClick()`不会被调用）。
- en: Jetpack Compose can provide click handling in two ways. Firstly, composable
    functions that require it (because it is a core feature for them) have a dedicated
    `onClick` parameter. Secondly, composables that usually do not require click handling
    can be amended with a modifier. Let's start with the first one.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose可以通过两种方式提供点击处理。首先，需要它的可组合函数（因为它是它们的核心功能）有一个专门的`onClick`参数。其次，通常不需要点击处理的组合函数可以通过修饰符进行修改。让我们从第一个开始。
- en: '[PRE14]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Please note that `onClick` is mandatory; you must provide it.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，`onClick`是强制性的；你必须提供它。
- en: 'If you want to show the button but the user should not be able to click it,
    the code looks like this:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要显示按钮，但用户不应能够点击它，代码看起来是这样的：
- en: '[PRE15]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '*Figure 2.3* shows what the button looks like when `enabled` is either `true`
    or `false`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*图2.3*显示了当`enabled`为`true`或`false`时按钮的外观：'
- en: '![Figure 2.3 – A button with enabled = true or false'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.3 – 当enabled = true或false时的按钮'
- en: '](img/B17505_02_03.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B17505_02_03.jpg]'
- en: Figure 2.3 – A button with enabled = true or false
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.3 – 当enabled = true或false时的按钮
- en: '`Text()` doesn''t have an `onClick` property. If you want to make it clickable
    (like I do in the *Factorial* app), you pass `clickable { ... }` to the `modifier`
    parameter:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`Text()`没有`onClick`属性。如果你想使其可点击（就像我在*阶乘*应用中做的那样），你将`clickable { ... }`传递给`modifier`参数：'
- en: '[PRE16]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Modifiers, as their name suggests, provide an infrastructure for influencing
    both the visual appearance and behavior of composable functions. I will show you
    another example for modifiers in the next section. [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054),
    *Exploring the Key Principles of Compose*, covers them in much greater detail.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，修饰符提供了一种影响可组合函数的视觉外观和行为的基础设施。我将在下一节中展示另一个修饰符的示例。[*第3章*](B17505_03_ePub.xhtml#_idTextAnchor054)，*探索Compose的关键原则*，更详细地介绍了它们。
- en: Sizing and positioning UI elements
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调整UI元素的大小和位置
- en: In component-centric UI frameworks, size and location onscreen (or relative
    to another component) are core properties. They are defined in the root component
    (on Android, the `View` class). Descendants of `ViewGroup` size and position their
    children by changing their corresponding properties. For example, `RelativeLayout`
    is based upon instructions such as `toStartOf`, `toEndOf`, or `below`. `FrameLayout`
    draws its children in a stack. And `LinearLayout` lays out children horizontally
    or vertically. So, `...Layout`s are containers with the ability to size and position
    their children.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在以组件为中心的UI框架中，屏幕上的大小和位置（或相对于另一个组件）是核心属性。它们在根组件中定义（在Android中是`View`类）。`ViewGroup`的子类通过更改相应的属性来调整其子项的大小和位置。例如，`RelativeLayout`基于指令，如`toStartOf`、`toEndOf`或`below`。`FrameLayout`按堆栈绘制其子项。而`LinearLayout`水平或垂直排列其子项。因此，`...Layout`s是具有调整其子项大小和位置能力的容器。
- en: 'Jetpack Compose has a very similar concept. You have already learned about
    `Row()` and `Column()`, which lay out their content horizontally or vertically.
    `Box()` is similar to `FrameLayout`. It organizes its content in the order it
    appears in code. The position inside the box is controlled by `contentAlignment`:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: Jetpack Compose有一个非常类似的概念。你已经学习了`Row()`和`Column()`，它们分别水平或垂直排列其内容。`Box()`类似于`FrameLayout`。它按照代码中出现的顺序组织其内容。盒子内的位置由`contentAlignment`控制：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The content may override this by using `modifier = Modifier.align()`, the result
    of which we can see in *Figure 2.4*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 内容可以使用`modifier = Modifier.align()`来覆盖这一点，结果我们在*图2.4*中可以看到：
- en: '![Figure 2.4 – An invisible box containing two colored boxes and text'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图2.4 – 包含两个彩色框和文本的不可见框'
- en: '](img/B17505_02_04.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17505_02_04.jpg)'
- en: Figure 2.4 – An invisible box containing two colored boxes and text
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.4 – 包含两个彩色框和文本的不可见框
- en: Modifiers can also be used to request a size. In some of my examples, you may
    have spotted `Modifier.fillMaxSize()`, which makes the composable as big as possible.
    `Modifier.size()` requests a particular size. Modifiers can be chained. The root
    of such a chain is the `Modifier` companion object. Subsequent modifiers are added
    using a dot.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 修饰符也可以用来请求一个大小。在我的一些示例中，你可能已经注意到了`Modifier.fillMaxSize()`，它使可组合函数尽可能大。`Modifier.size()`请求一个特定的大小。修饰符可以链式使用。这个链的根是`Modifier`伴随对象。后续修饰符通过点添加。
- en: Before closing this chapter, I would like to emphasize the benefits of the modifier
    concept with one more example. Did you notice the `background()` modifiers of
    the first and second content box? This modifier allows you to set a background
    color for any composable function. When you need something a composable function
    does not offer out of the box, you can add it with a modifier. As you can write
    custom modifiers, the possibilities to adjust a composable to your needs are almost
    endless. I will elaborate on this in the next chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在关闭本章之前，我想通过另一个例子强调修饰符概念的好处。你注意到第一个和第二个内容框的`background()`修饰符了吗？这个修饰符允许你为任何可组合函数设置背景颜色。当你需要某个可组合函数不提供的内容时，你可以通过修饰符添加它。由于你可以编写自定义修饰符，因此调整可组合函数以满足你需求的可能性几乎是无限的。我将在下一章中详细阐述这一点。
- en: Summary
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you have learned about key elements of component-centric UI
    frameworks. We saw some of the limitations of this approach and how the declarative
    paradigm can overcome them. For example, specialization takes place on a component
    level. If the framework is based upon inheritance, the distribution of features
    to children may be too broad. Jetpack Compose tackles this with the modifier mechanism,
    which allows us to amend functionality at a very fine-grained level; this means
    that composables only get the functionality they need (for example, a background
    color).
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了组件中心UI框架的关键元素。我们看到了这种方法的一些局限性以及声明式范式如何克服它们。例如，专业化发生在组件级别。如果框架基于继承，那么将功能分配给子组件可能过于广泛。Jetpack
    Compose通过修饰符机制解决这个问题，这允许我们在非常细粒度的级别上修改功能；这意味着可组合函数只获得它们需要的功能（例如，背景颜色）。
- en: The remaining chapters of this book are solely based on the declarative approach.
    In [*Chapter 3*](B17505_03_ePub.xhtml#_idTextAnchor054), *Exploring the Key Principles
    of Compose*, we will take an even closer look at composable functions and examine
    the concepts of composition and recomposition. And, as promised, we will also
    dive deep into modifiers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 本书剩余的章节完全基于声明式方法。在[*第3章*](B17505_03_ePub.xhtml#_idTextAnchor054) *探索Compose的关键原则*中，我们将更深入地研究可组合函数，并检查组合和重新组合的概念。并且，正如承诺的那样，我们还将深入探讨修饰符。
