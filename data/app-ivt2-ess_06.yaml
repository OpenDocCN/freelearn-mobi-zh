- en: Chapter 6. Introduction to Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章. 数据库简介
- en: Now that we've successfully created the first part of the Event app, it is time
    to make it more functional. In this chapter, we will build onto our Event app
    by adding code that will enable guests to respond to the invitation by sending
    an RSVP (*répondez s'il vous plaît*—*please reply*, in French). The app will aggregate
    all the data and display a guest list so that both guests and party organizers
    can see who is attending.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功创建了事件应用的第一部分，是时候让它更加功能化了。在本章中，我们将通过添加代码来扩展我们的事件应用，使客人能够通过发送RSVP（法语中的“请回复”——*répondez
    s'il vous plaît*）来回应邀请。应用将汇总所有数据并显示宾客名单，以便宾客和派对组织者都能看到谁将参加。
- en: In order for the app to collect all the RSVP data from individuals in a central
    repository, we will have to use an online database. App Inventor has built-in
    support for three online databases, TinyWebDB, and Google Fusion Tables (which
    we will use).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让应用能够从个人中央存储库收集所有RSVP数据，我们必须使用在线数据库。App Inventor内置了对三个在线数据库的支持，包括TinyWebDB和Google融合表（我们将使用它）。
- en: Both, TinyWebDB and Google Fusion Tables have their limitations in aggregating
    data. TinyWebDB, while easy to use, is not secure. This means that anyone has
    access to the database, could by mistake (or on purpose), delete or change the
    data that is collected. On the other hand, Google Fusion Tables is secure, but
    is more complicated to use. In order to integrate Fusion Tables into our app,
    while keeping the design of the app relatively simple, we had to make some tradeoffs.
    The learning objective is to introduce you to the process of building a database
    with a relatively simple app. But, as you will discover, the resulting app is
    challenging to disseminate to a broad public audience. At the time of publication
    for this book, another App Inventor database alternative, FirebaseDB was under
    development. We will offer updates about the adoption of FirebaseDB as it becomes
    available. You can check the supplementary materials on both the Packt Publishing
    and MIT App Inventor websites for new information about FirebaseDB.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TinyWebDB和Google融合表在聚合数据方面都有其局限性。TinyWebDB虽然易于使用，但不安全。这意味着任何人都可以访问数据库，可能会不小心（或故意）删除或更改收集的数据。另一方面，Google融合表是安全的，但使用起来更复杂。为了将融合表集成到我们的应用中，同时保持应用设计相对简单，我们必须做出一些权衡。学习目标是向您介绍使用相对简单的应用构建数据库的过程。但是，正如您将发现的，生成的应用对广泛公众的传播具有挑战性。在本书出版时，另一个App
    Inventor数据库替代品FirebaseDB正在开发中。我们将提供FirebaseDB采用更新的信息，一旦它可用。您可以在Packt Publishing和MIT
    App Inventor网站上检查补充材料，以获取有关FirebaseDB的新信息。
- en: 'In this chapter you will learn:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习：
- en: How to create a Google Fusion Table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建Google融合表
- en: How to establish Google API credentials
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何建立Google API凭证
- en: How to set up an RSVP form
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置RSVP表格
- en: How to push data from an App Inventor app into a Google Fusions Table
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将App Inventor应用中的数据推送到Google融合表
- en: How to request and receive data from a Google Fusion Table into an App Inventor
    app
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何从Google融合表请求和接收数据到App Inventor应用
- en: How to display a guest list
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何显示宾客名单
- en: Creating a database
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建数据库
- en: In this app, invitees will send an RSVP to let the party organizer (and other
    guests) know whether or not they can attend an event. So, naturally, we will have
    to include a mechanism to collate all of that distributed information into one
    central place. To achieve this, we will create an online database using a Google
    Fusion Table. In professional programming, this aspect is often referred to as
    creating the backend.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，受邀者将发送RSVP来告知派对组织者（和其他宾客）他们是否能参加活动。因此，自然地，我们必须包括一个机制来收集所有分散的信息到一个中央位置。为了实现这一点，我们将使用Google融合表创建一个在线数据库。在专业编程中，这个方面通常被称为创建后端。
- en: Creating a Google Fusion Table
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建Google融合表
- en: 'To create a Google Fusion Table, go to the [https://drive.google.com](https://drive.google.com)
    website on your computer and click on the big red button on the top-left side
    of the screen labeled **NEW**. Scroll down the list of options and select **More**
    and select **Google Fusion Tables**:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建Google融合表，请访问您电脑上的[https://drive.google.com](https://drive.google.com)网站，点击屏幕左上角的大红色按钮，按钮上标有**新建**。向下滚动选项列表，选择**更多**，然后选择**Google融合表**：
- en: '![Creating a Google Fusion Table](img/00164.jpeg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![创建Google融合表](img/00164.jpeg)'
- en: 'If you have never used Google Fusion Tables before, chances are, when you click
    on **More**, you will not see the **Google Fusion Tables** option listed. If this
    is the case, select the last option with the plus sign, **Connect more apps**.
    A pop-up window will appear with a lot of apps that you can connect to your Google
    Drive. You should see a view similar to the following screenshot. At the top left
    of this pop-up window you will see a button that by default shows the word **All**.
    This button lets you filter the apps into various categories. Click on it and
    select the second option, **By Google**, from the drop-down menu, as shown in
    the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前从未使用过谷歌融合表，那么当你点击**更多**时，你可能会看不到列出的**谷歌融合表**选项。如果是这种情况，选择带有加号的最后一个选项，**连接更多应用**。一个弹出窗口将出现，其中包含许多你可以连接到你的谷歌驱动器中的应用。你应该会看到一个类似于以下截图的视图。在这个弹出窗口的左上角，你会看到一个默认显示单词**所有**的按钮。这个按钮让你可以按各种类别过滤应用。点击它，并从下拉菜单中选择第二个选项，**按谷歌**，如以下截图所示：
- en: '![Creating a Google Fusion Table](img/00165.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![创建谷歌融合表](img/00165.jpeg)'
- en: Now, you will see a list of all Google-created apps as shown on the right-hand
    side of the preceding screenshot. Find the Google Fusion Tables app in the list
    and click on it. After doing so, the next time you click the red **NEW** button
    in [https://drive.google.com](https://drive.google.com) and select **More**, Google
    **Fusion Tables** will appear as an option.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将看到所有由谷歌创建的应用列表，如前一个截图的右侧所示。在列表中找到谷歌融合表应用，并点击它。完成之后，下次你点击[https://drive.google.com](https://drive.google.com)中的红色**新建**按钮并选择**更多**时，谷歌**融合表**将作为一个选项出现。
- en: When you create a new Fusion Table, you will be given the option to create an
    empty table (along with some other options). For our purpose, select **Create
    empty table**.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个新的融合表时，你将会有选项创建一个空表（以及其他一些选项）。出于我们的目的，选择**创建空表**。
- en: '![Creating a Google Fusion Table](img/00166.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![创建谷歌融合表](img/00166.jpeg)'
- en: 'Next, we will make the format of the table suitable for our app. First, rename
    the table to give it a meaningful name. Click on the current table name, which
    is **New Table**, in the top left corner. This will open a **Table information**
    window. Give your table a descriptive name such as `EventApp Table` and hit the
    **Save** button:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将使表格的格式适合我们的应用。首先，重命名表格以给它一个有意义的名字。点击屏幕左上角的当前表格名称**新表**。这将打开一个**表格信息**窗口。给你的表格起一个描述性的名字，例如`EventApp
    Table`，然后点击**保存**按钮：
- en: '![Creating a Google Fusion Table](img/00167.jpeg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![创建谷歌融合表](img/00167.jpeg)'
- en: 'We will need to make further modifications to the table before it is ready
    to be used as the backend of our Event app. By default, a blank row is inserted
    in Fusion Tables. We want our table to be completely empty. To clear out the table,
    select the **Edit** tab on the top left corner of the screen, below the table
    name. You will see a **Delete all rows** option; click on it and confirm that
    you want to delete all rows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个表格准备好作为我们活动应用的后端使用之前，我们需要对其进行进一步的修改。默认情况下，融合表中会插入一个空白行。我们希望我们的表格是完全空的。为了清空表格，选择屏幕左上角表格名称下方的**编辑**标签。你会看到一个**删除所有行**的选项；点击它并确认你想要删除所有行：
- en: '![Creating a Google Fusion Table](img/00168.jpeg)![Creating a Google Fusion
    Table](img/00169.jpeg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![创建谷歌融合表](img/00168.jpeg)![创建谷歌融合表](img/00169.jpeg)'
- en: Now that we have a clean table, we need to decide what columns to use. For this
    Event app, we want to know who is coming (the name of the guest), how many people
    that person is bringing (the number of guests), and what items that guest is bringing
    to the party (potluck). This information is going to be used by the organizer
    to plan the party.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个干净的表格了，我们需要决定使用哪些列。对于这个活动应用，我们想知道谁会来（宾客的名字），这个人会带来多少人（宾客数量），以及这位宾客会带来哪些物品到派对上（拼盘）。这些信息将被组织者用来计划派对。
- en: Each of these three pieces of information will be saved in a column on the Fusion
    Table. Four columns are automatically included when a Fusion Table is created.
    Since we only need three columns, we are going to delete one of the four default
    columns and modify the other three.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个信息点中的每一个都将保存在融合表的一个列中。创建融合表时自动包含四个列。由于我们只需要三个列，我们将删除四个默认列中的一个，并修改其他三个。
- en: The **Edit** tab that you clicked to delete all the rows and clean up the table
    also contains another option called **Change columns**. We will use that options
    several times now to make all the changes to the columns. The default column names
    are **Text**, **Number**, **Location**, and **Date**. We will change them to **Guest
    Names**, **NumGuests**, and **ItemsBringing**.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你点击以删除所有行并清理表格的**编辑**选项卡还包含另一个名为**更改列**的选项。我们现在将使用该选项多次来对列进行所有更改。默认列名是**文本**、**数字**、**位置**和**日期**。我们将它们更改为**宾客姓名**、**NumGuests**和**ItemsBringing**。
- en: 'To change the first column to **Guest Names**, click on the Edit tab and select
    the **Change columns** option and you will see the following screenshot. The first
    column is selected by default (the gray background on the left panel indicates
    it is active). Change the **Column name** to **Guest Names**. This column is already
    configured to save **Text** data (the **Type** option), hence we do not need to
    make any changes here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 要将第一列更改为**宾客姓名**，点击编辑选项卡并选择**更改列**选项，你将看到以下截图。默认选中第一列（左侧面板上的灰色背景表示它是活动的）。将**列名**更改为**Guest
    Names**。此列已经配置为保存**文本**数据（**类型**选项），因此我们在这里不需要做任何更改：
- en: '![Creating a Google Fusion Table](img/00170.jpeg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Google 融合表](img/00170.jpeg)'
- en: 'Now that we have changed the first column, we will do the same to the second
    column. Select the second column (currently called **Number**). Once you click
    on it, the background will become gray. Now change the **Column name** to **NumGuests**.
    Since, this column is already configured to store numbers, we do not need to make
    any changes here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经更改了第一列，我们将对第二列做同样的操作。选择第二列（目前称为**数字**）。一旦点击它，背景将变为灰色。现在将**列名**更改为**NumGuests**。由于此列已经配置为存储数字，我们在这里不需要做任何更改：
- en: '![Creating a Google Fusion Table](img/00171.jpeg)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Google 融合表](img/00171.jpeg)'
- en: Next, we need to rename the third column (currently called **Location**). Just
    like the previous examples, select that column and change the name to **ItemsBringing**.
    By default this column is preconfigured to store **Location** data. We actually
    want to store **Text** data (items that guests will bring). So we need to change
    the datatype. When you click on **Location** (the **Type** option), a drop-down
    menu will appear as shown in the following screenshot. Select the **Text** option.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要重命名第三列（目前称为**位置**）。就像前面的例子一样，选择该列并将其名称更改为**ItemsBringing**。默认情况下，此列预先配置为存储**位置**数据。我们实际上想要存储**文本**数据（宾客将带来的物品）。因此，我们需要更改数据类型。当你点击**位置**（**类型**选项）时，将出现一个下拉菜单，如下面的截图所示。选择**文本**选项。
- en: '![Creating a Google Fusion Table](img/00172.jpeg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Google 融合表](img/00172.jpeg)'
- en: 'Finally, since we need only three columns, we will delete the fourth column
    by hovering over the fourth column to make it active (gray) and clicking on the
    **x** next to it (as shown in the following screenshot) and confirming the deletion
    in the pop-up box:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，由于我们只需要三列，我们将通过悬停在第四列上使其变为活动状态（灰色）并点击其旁边的**x**（如下面的截图所示）来删除第四列，并在弹出框中确认删除：
- en: '![Creating a Google Fusion Table](img/00173.jpeg)![Creating a Google Fusion
    Table](img/00174.jpeg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Google 融合表](img/00173.jpeg)![创建 Google 融合表](img/00174.jpeg)'
- en: Now that the table is ready to be used, click on the **File** tab in the upper
    left corner and select **About this table** from the drop-down menu.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在表格已准备好使用，点击左上角的**文件**选项卡，并从下拉菜单中选择**关于此表格**。
- en: '![Creating a Google Fusion Table](img/00175.jpeg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![创建 Google 融合表](img/00175.jpeg)'
- en: 'Another page will open with various details of the table. Note the information
    given in the very last piece of information, the **Id**, as shown in the following
    screenshot. Double-click on the alphanumeric string to highlight it, copy/paste
    it in another place on your computer, such as a Notepad file or an empty document.
    (You may have to use your browser''s copy/paste feature to do this, as keyboard
    shortcuts may not work. You can find copy/paste under the **Edit** menu heading
    at the top of your browser window.) You will use this **Id** in the App Inventor
    app to push/pull data to/from this table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个页面将打开，显示表格的详细信息。注意最后一项信息中给出的信息，即**Id**，如下面的截图所示。双击该字母数字字符串以突出显示它，将其复制/粘贴到你的电脑上的另一个位置，例如记事本文件或空白文档。（你可能需要使用浏览器中的复制/粘贴功能来完成此操作，因为键盘快捷键可能不起作用。你可以在浏览器窗口顶部的**编辑**菜单下找到复制/粘贴。）你将在
    App Inventor 应用程序中使用此**Id**将数据推/拉到/从这个表格中：
- en: '![Creating a Google Fusion Table](img/00176.jpeg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![Creating a Google Fusion Table](img/00176.jpeg)'
- en: We will make one small final change to the Fusion Table (to its **Sharing**
    settings) but, we are not ready to do that just yet. So keep the Fusion Table
    window open and start working with App Inventor in the separate browser window.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将对Fusion Table进行一个小小的最终修改（修改其**Sharing**设置），但，我们目前还没有准备好进行这一步。所以请保持Fusion
    Table窗口打开，并在单独的浏览器窗口中开始使用App Inventor。
- en: Designing the RSVP screen
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计RSVP屏幕
- en: For our app, we are asking the invited guests to provide their names, the total
    number of guests, and the food or drink to share at the potluck. Once a guest
    presses the **Send RSVP** button, something magical will happen. We will push
    all the data from the app to the Fusion Table that we created.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的应用，我们要求受邀宾客提供他们的姓名、总宾客数量以及将在野餐中分享的食物或饮料。一旦宾客按下**Send RSVP**按钮，就会发生神奇的事情。我们将把应用中的所有数据推送到我们创建的Fusion
    Table中。
- en: Creating the GUI in the designer window
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在设计窗口中创建GUI
- en: In [Chapter 5](part0033_split_000.html#VF2I1-9c0b907946184095a315b26c8a9b12bc
    "Chapter 5. Building an Event App"), *Building an Event App* we created the `RSVP_Screen`
    and now we will build the GUI (Graphical User Interface) that the guests will
    use. Navigate to the RSVP screen in the **Designer** window. The screen is empty
    except for the background pool image and the navigation buttons that we added
    along the bottom.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0033_split_000.html#VF2I1-9c0b907946184095a315b26c8a9b12bc "第5章。构建活动应用")中，我们在*构建活动应用*中创建了`RSVP_Screen`，现在我们将构建宾客将使用的GUI（图形用户界面）。在**Designer**窗口中导航到RSVP屏幕。屏幕除了背景池图像和底部添加的导航按钮外，其他都是空的。
- en: 'Since you have already gained experience adding various components in the previous
    chapters, we are pretty confident about your abilities. Of course, we will help
    specify which components to use! The guest provides three pieces of data here:
    the name, the number of guests, and the item to bring. We will place all the components
    related to these three pieces of data within a VerticalArrangement for a streamlined
    look. Hence, the first component to add is: **VerticalArrangement**. Drag it to
    the **Viewer** and set its **Height** and **Width** properties to **Fill parent**.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于您在前面章节中已经积累了添加各种组件的经验，我们对您的能力非常有信心。当然，我们也会帮助您指定使用哪些组件！嘉宾在此提供了三份数据：姓名、宾客数量以及需要携带的物品。我们将把与这三份数据相关的所有组件放置在VerticalArrangement中，以实现简洁的外观。因此，首先需要添加的组件是：**VerticalArrangement**。将其拖动到**Viewer**中，并将其**Height**和**Width**属性设置为**Fill
    parent**。
- en: To collect the first piece of data, the name, add a **Label** and below that
    a **Textbox** by dragging them onto the Vertical Arrangement in the **Viewer**.
    Rename the **Label** to `NameLabel` and change the **BackgroundColor** property
    to **Dark Gray**. Check the **FontBold** property and change the **Text** property
    to **Name**.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集第一份数据，即姓名，添加一个**Label**，在其下方通过拖动添加一个**Textbox**到**Viewer**中的Vertical Arrangement中。将**Label**重命名为`NameLabel`，并将**BackgroundColor**属性更改为**Dark
    Gray**。勾选**FontBold**属性，并将**Text**属性更改为**Name**。
- en: Similarly, rename the **Textbox** to `NameTextBox`. Change the **Width** property
    to **Fill parent**. Type **Enter your first and last name** for the **Hint** property.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，将**Textbox**重命名为`NameTextBox`。将**Width**属性更改为**Fill parent**。在**Hint**属性中输入**Enter
    your first and last name**。
- en: For the second piece of data, the number of guests, add a **Label** and another
    component called **ListPicker** (found just below the **Label** component in the
    **User Interface** palette). Drag the Components onto the VerticalArrangement
    underneath the Label and Textbox. Rename this Label to `GuestsLabel`. Change the
    **BackgroundColor** property to **Dark Gray**, check the **FontBold** property
    and change the **Text** property to **Number of guests (including you)**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第二份数据，即宾客数量，添加一个**Label**和另一个名为**ListPicker**的组件（在**User Interface**调色板中的**Label**组件下方找到）。将组件拖动到Label和Textbox下方的VerticalArrangement中。将此Label重命名为`GuestsLabel`。将**BackgroundColor**属性更改为**Dark
    Gray**，勾选**FontBold**属性，并将**Text**属性更改为**Number of guests (including you)**。
- en: We will use the ListPicker Component to track the number of people attending
    when a guest submits an RSVP. The ListPicker is a button that, when clicked, opens
    up a list of items from which a user can select. Rename the **ListPicker** to
    `NumGuestListPicker`. We will make just two changes to the **ListPicker** properties.
    Put `1,2,3,4,5,6,7` as the **ElementsFromString** property. These are the items
    what we want displayed when the user clicks the **NumGuestListPicker**. We are
    assuming the number of guests (including the person who is completing the RSVP)
    is in the range 1-7\. You can add more or fewer guest options as you wish.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 ListPicker 组件来跟踪当客人提交 RSVP 时参加的人数。ListPicker 是一个按钮，点击后会打开一个列表，用户可以从中选择。将
    **ListPicker** 重命名为 `NumGuestListPicker`。我们将对 **ListPicker** 属性进行两项更改。将 `1,2,3,4,5,6,7`
    作为 **ElementsFromString** 属性。这些是我们希望在用户点击 **NumGuestListPicker** 时显示的项目。我们假设客人数量（包括完成
    RSVP 的人）在 1-7 之间。您可以按需添加更多或更少的客人选项。
- en: Just remember that the comma-separated numbers that you specify are the options
    that the users will be able to select from. Finally, make the **Selection** property
    **1**. This means that, if the user does not choose a number from the **NumGuestListPicker**,
    the default value of 1 will be used to count the user who sent the RSVP.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 只需记住，您指定的逗号分隔的数字是用户可以选择的选项。最后，将 **Selection** 属性设置为 **1**。这意味着，如果用户没有从 **NumGuestListPicker**
    中选择数字，则默认值 1 将用于计算发送 RSVP 的用户。
- en: '![Creating the GUI in the designer window](img/00177.jpeg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![在设计师窗口中创建 GUI](img/00177.jpeg)'
- en: Finally, we will add a **Button** and rename it to `SendRSVPButton`. The user
    will click this button to send the RSVP after completing the form. Just as we
    did for the labels, make the **BackgroundColor** dark gray, and insert **Send
    RSVP** as the **Text** property.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将添加一个 **按钮** 并将其重命名为 `SendRSVPButton`。用户在完成表格后点击此按钮发送 RSVP。就像我们对标签所做的那样，将
    **BackgroundColor** 设置为深灰色，并将 **Text** 属性插入为 **发送 RSVP**。
- en: 'Next, drag the **FusiontablesControl** component from the **Storage Palette**
    drawer to the Viewer. (Notice how the **FusiontablesControl1** component drops
    down below the **Viewer**, because it is a non-visible component.) After you have
    added all the components, the `RSVP_Screen` will resemble the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将 **FusiontablesControl** 组件从 **存储面板** 拖动到查看器中。（注意 **FusiontablesControl1**
    组件是如何在 **查看器** 下方展开的，因为它是一个不可见组件。）添加所有组件后，`RSVP_Screen` 将类似于以下截图：
- en: '![Creating the GUI in the designer window](img/00178.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![在设计师窗口中创建 GUI](img/00178.jpeg)'
- en: This completes the GUI for the `RSVP_Screen`. In professional programming lingo,
    this is also called creating the frontend.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了 `RSVP_Screen` 的 GUI。在专业编程术语中，这也称为创建前端。
- en: Setting up Google Authentication
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Google 身份验证
- en: Fusion Tables is software that Google has designed. For various security- and
    privacy-related issues, Google only wants verified software to send/receive data
    to/from Fusion Tables. Hence, we need to establish our identity before our Event
    App can exchange data with Google Fusion Tables. In this section, we will describe
    how to create Google service-level authentication to establish this credential.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: Fusion Tables 是 Google 设计的软件。由于各种安全和隐私相关的问题，Google 只希望经过验证的软件向/从 Fusion Tables
    发送/接收数据。因此，在我们的事件应用与 Google Fusion Tables 交换数据之前，我们需要建立我们的身份。在本节中，我们将描述如何创建 Google
    服务级身份验证以建立此凭证。
- en: 'To establish the service-level authentication credentials, follow these instructions:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要建立服务级身份验证凭证，请按照以下说明操作：
- en: Go to [https://console.developers.google.com/](https://console.developers.google.com/)
    and log in with your Google account if necessary. On the **Getting started** page,
    click on the **Use Google APIs** button as shown in the following screenshot:![Setting
    up Google Authentication](img/00179.jpeg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://console.developers.google.com/](https://console.developers.google.com/)
    并使用您的 Google 账户登录（如有必要）。在 **入门** 页面上，点击 **使用 Google API** 按钮，如图所示：![设置 Google
    身份验证](img/00179.jpeg)
- en: The acronym API stands for **Application Programming Interface**. To describe
    it in a very simple manner, an API defines a way for computers to interact with
    websites (essentially for software programs to interact). Developers at companies
    like Twitter, Facebook, and Google create protocols for their software to enable
    other programs to communicate with it. In this case App Inventor will be communicating
    with the Google Fusion Tables API.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 缩写API代表**应用程序编程接口**。用非常简单的方式描述，API定义了计算机与网站交互的方式（本质上是为了软件程序能够与之交互）。像Twitter、Facebook和Google这样的公司的开发者创建了他们的软件协议，以便其他程序能够与之通信。在这种情况下，App
    Inventor将与Google Fusion Tables API通信。
- en: You will be prompted to create a new project that uses APIs. Name your project
    **Event App Project**. Make the selections shown in the following screenshot,
    and click on **Create**:![Setting up Google Authentication](img/00180.jpeg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将被提示创建一个使用API的新项目。将您的项目命名为**事件应用项目**。进行以下截图所示的选项选择，然后点击**创建**：![设置Google身份验证](img/00180.jpeg)
- en: On the right-hand side, you will see a tab named **Enabled APIs (7)**, as follows.
    Click on that tab:![Setting up Google Authentication](img/00181.jpeg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右侧，您将看到一个名为**已启用API（7）**的标签页，如下所示。点击该标签页：![设置Google身份验证](img/00181.jpeg)
- en: This will show you a list of APIs that are enabled by default. Since we will
    not use these APIs, click on the **Disable** option next to each API and disable
    each one of them.
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将显示默认启用的API列表。由于我们不会使用这些API，请点击每个API旁边的**禁用**选项，并禁用每个API。
- en: '![Setting up Google Authentication](img/00182.jpeg)'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置Google身份验证](img/00182.jpeg)'
- en: 'After you have disabled all APIs, your screen will look like the following
    screenshot:'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在禁用所有API后，您的屏幕将如下截图所示：
- en: '![Setting up Google Authentication](img/00183.jpeg)'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置Google身份验证](img/00183.jpeg)'
- en: Our next goal is to enable the one API that our app will use—the **Fusion Tables
    API**. To do so, look for the **Other popular APIs** column. You will find it
    to the bottom-right group of links (look for the blue hexagon icon), as shown
    in the screenshot that follows:![Setting up Google Authentication](img/00184.jpeg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们下一个目标是启用我们的应用将使用的单一API——**Fusion Tables API**。要做到这一点，请查找**其他流行API**列。您将在以下截图所示的链接底部右边的组中找到它（寻找蓝色菱形图标）：![设置Google身份验证](img/00184.jpeg)
- en: Click on the **Fusion Tables API** listed in this column. And then, in the next
    screen, click on the blue **Enable API** button shown in the following screenshot:![Setting
    up Google Authentication](img/00185.jpeg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击此列中列出的**Fusion Tables API**。然后，在下一个屏幕中，点击以下截图所示的蓝色**启用API**按钮：![设置Google身份验证](img/00185.jpeg)
- en: Now that we have enabled the **Fusion Tables API**, it is time to create credentials
    (ways for software to verify the authenticity of other software). Click on the
    **Credentials** option on the left vertical pane, as shown in the following screenshot:![Setting
    up Google Authentication](img/00186.jpeg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经启用了**Fusion Tables API**，是时候创建凭据（软件验证其他软件真实性的方式）了。点击左侧垂直面板上的**凭据**选项，如下截图所示：![设置Google身份验证](img/00186.jpeg)
- en: This will result in a pop-up window with the blue **Add credentials** button,
    as shown in the following screenshot. Click on that button and select the last
    option—**Service account**.
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将弹出一个带有蓝色**添加凭据**按钮的窗口，如下截图所示。点击该按钮，然后选择最后一个选项——**服务帐户**。
- en: '![Setting up Google Authentication](img/00187.jpeg)'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置Google身份验证](img/00187.jpeg)'
- en: 'In the next window, make the selections shown in the following screenshot and
    click on **Create**:'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下一个窗口中，进行以下截图所示的选项选择，然后点击**创建**：
- en: '![Setting up Google Authentication](img/00188.jpeg)'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置Google身份验证](img/00188.jpeg)'
- en: 'This will create the service account and download a special file onto your
    computer. This file has a `.p12` extension. Depending on your browser''s setting,
    you might see a window such as the following one. This window asks you where to
    save the file. Save the file somewhere on your hard drive and remember the location.
    We will upload this file in to App Inventor later on:'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建服务帐户并将一个特殊的文件下载到您的计算机上。此文件具有`.p12`扩展名。根据您浏览器的设置，您可能会看到一个如下所示的窗口。此窗口询问您将文件保存到何处。将文件保存到您的硬盘上的某个位置，并记住位置。稍后我们将此文件上传到App
    Inventor：
- en: '![Setting up Google Authentication](img/00189.jpeg)'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置Google身份验证](img/00189.jpeg)'
- en: 'If you do not see the pop-up window like the one shown previously, in all likelihood
    your browser is set to download everything to the default `Downloads` folder.
    In that case, the `.p12` file will automatically be saved in that folder:'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有看到之前显示的弹出窗口，那么很可能你的浏览器被设置为将所有内容下载到默认的 `下载` 文件夹。在这种情况下，`.p12` 文件将自动保存在该文件夹中：
- en: '![Setting up Google Authentication](img/00190.jpeg)'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![设置 Google 认证](img/00190.jpeg)'
- en: After this `.p12` file has been downloaded to to your computer, you will see
    a message resembling the one shown previously. Click the **Close** button to dismiss
    the message.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此 `.p12` 文件已下载到您的计算机后，您将看到类似于之前显示的消息。点击 **关闭** 按钮以关闭消息。
- en: Now that we have created the credentials we are going to use, Google will automatically
    generate an e-mail address that goes with this credential. This email address
    is something we will have to specify in App Inventor as well. As shown in the
    following screenshot, a long and complicated email address will be displayed under
    the **Service** accounts. Copy this email and paste it into the document that
    you used to store the ID of the Fusion Table that you created earlier. Just like
    the ID of the Fusion Table, you will need this email address later on:![Setting
    up Google Authentication](img/00191.jpeg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经创建了将要使用的凭证，Google 将自动生成一个与该凭证关联的电子邮件地址。这个电子邮件地址是我们需要在 App Inventor 中指定的内容。如图所示，在
    **服务** 账户下将显示一个长而复杂的电子邮件地址。复制此电子邮件并将其粘贴到您之前用于存储您创建的融合表 ID 的文档中。就像融合表的 ID 一样，您稍后还需要这个电子邮件地址：![设置
    Google 认证](img/00191.jpeg)
- en: The **Fusion Tables API** is now enabled and the credentials are established.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**融合表 API** 现已启用，并且凭证已建立。'
- en: Sharing the Fusion Table with the service account email
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过服务账户电子邮件共享融合表
- en: When you created the Fusion Table in a previous section, you used your own Google
    account to do so. So right now only you can access and change the Fusion Table.
    However, for this app to work, you need all your guests to have the ability to
    insert data into the Fusion Table and read from the Fusion Table.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在前面的部分创建融合表时，你使用的是自己的 Google 账户。所以现在只有你可以访问和更改融合表。然而，为了让这个应用工作，你需要确保所有客人都有能力向融合表插入数据并从融合表读取数据。
- en: The service account email that you created in the previous step will come in
    handy to achieve just that. That email is associated with your app and not any
    individual. Hence, anyone else using the app should be able to access the Fusion
    Table as long as that email address has proper access to the Fusion Table.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一步中创建的服务账户电子邮件将非常有用，以实现这一点。该电子邮件与您的应用相关联，而不是任何个人。因此，只要该电子邮件地址有权访问融合表，任何其他使用该应用的人都应该能够访问融合表。
- en: To enable the service level email access to the Fusion Table, go back to your
    Fusion Table (left open in the separate browser window/tab) and click on the blue
    **Share** button in the top-right corner. This will open the **Sharing settings**
    menu, as shown in the following screenshot.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要启用对融合表的电子邮件级别访问权限，请回到您的融合表（在单独的浏览器窗口/标签页中打开）并点击右上角的蓝色 **共享** 按钮。这将打开 **共享设置**
    菜单，如图所示。
- en: Copy and paste the service email address that you saved earlier into the **Invite
    people** box. Make sure the button next to the box says **Can edit**, and click
    on **Send**.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 将您之前保存的服务电子邮件地址复制并粘贴到 **邀请人员** 框中。确保框旁边的按钮上写着 **可以编辑**，然后点击 **发送**。
- en: '![Sharing the Fusion Table with the service account email](img/00192.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![通过服务账户电子邮件共享融合表](img/00192.jpeg)'
- en: This step ensures that any user of the app (not just you) is able to insert
    data into or receive data from the Fusion Table.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 此步骤确保任何应用用户（而不仅仅是您）都能够向融合表插入数据或接收数据。
- en: Connecting the app to the Google Fusion Table
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将应用连接到 Google 融合表
- en: So far, we have created a Fusion Table and the GUI for the `RSVP_Screen`, and
    established our Google API credentials. Now it is time to create the code for
    `RSVP_Screen`.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经创建了一个融合表和 `RSVP_Screen` 的 GUI，并建立了我们的 Google API 凭证。现在是时候为 `RSVP_Screen`
    创建代码了。
- en: Our goal
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们的目标
- en: 'When the user clicks the **Send RSVP** button:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击 **发送 RSVP** 按钮：
- en: The app takes the name from the **NameTextBox**, the selection from the **NumGuestListPicker**,
    and the contents of the **ItemsBringingTextBox** and inserts them as a single
    row in the appropriate column in the Fusion Table.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用从 **NameTextBox** 中获取名称，从 **NumGuestListPicker** 中获取选择，并将 **ItemsBringingTextBox**
    中的内容作为一个单独的行插入到融合表的相应列中。
- en: Then the app clears textboxes and reset the Listpicker selection to 1.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，应用程序清除文本框并重置Listpicker选择为1。
- en: We created the service-level credentials (the `.p12` file and the service-level
    email address) so that our app is authorized to send or receive information from
    Google Fusion Tables. Next, we need to provide the **FusiontablesControl** component
    in our app with this information. We want to do this when a user opens the `RSVP_Screen`.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了服务级凭证（`.p12`文件和服务级电子邮件地址），以便我们的应用程序有权从Google融合表发送或接收信息。接下来，我们需要将此信息提供给应用程序中的**FusiontablesControl**组件。我们希望在用户打开`RSVP_Screen`时执行此操作。
- en: 'As shown in the following screenshot, once in the **RSVP_Screen** in the Designer,
    select the **FusionTablesControl1** component under the **Components** column.
    This will display all the properties of **FusiontablesControl1**. Under the **KeyFile**
    property, click currently shows **None**. Then click on the **Upload File** button:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下截图所示，在设计师中的**RSVP_Screen**中，在**组件**列下选择**FusionTablesControl1**组件。这将显示**FusiontablesControl1**的所有属性。在**KeyFile**属性下，当前显示为**无**。然后点击**上传文件**按钮：
- en: '![Our goal](img/00193.jpeg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![我们的目标](img/00193.jpeg)'
- en: 'This will open up another pop-up, which will let you select the file that you
    want to upload. The following screenshot shows the pop-up. Select the `.p12` file
    that you earlier downloaded to your computer and click on the **OK** button:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开另一个弹出窗口，允许您选择要上传的文件。以下截图显示了弹出窗口。选择您之前下载到计算机上的`.p12`文件，然后点击**确定**按钮：
- en: '![Our goal](img/00194.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![我们的目标](img/00194.jpeg)'
- en: Next, copy the service-level email address that you have saved in a document
    and paste it into the **ServieAccountEmail** property.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，复制您在文档中保存的服务级电子邮件地址，并将其粘贴到**ServieAccountEmail**属性中。
- en: Finally, check the **UserServiceAuthentication** checkbox.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，勾选**UserServiceAuthentication**复选框。
- en: '![Our goal](img/00195.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![我们的目标](img/00195.jpeg)'
- en: Pushing data to the Fusion Table
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将数据推送到融合表
- en: When using multiple screens, you want to keep your blocks organized according
    to screen in the Blocks editor. Since we are getting ready to program blocks for
    the RSVP_Screen, we need to make sure we are on the RSVP_Screen in the Blocks
    editor.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用多个屏幕时，您希望在块编辑器中根据屏幕组织您的块。由于我们即将为RSVP_Screen编程块，我们需要确保我们在块编辑器中的RSVP_Screen。
- en: 'To check this, look at the first of three buttons in the green menu bar next
    to the EventApp name. If you just finished working on the RSVP_Screen in the Designer
    and switched over to the Blocks editor, you will be on RSVP_Screen. But if not,
    you can easily navigate to RSVP_Screen by clicking the button that displays another
    screen name (Screen1 as shown in the following screenshot) and choosing RSVP_
    Screen from the drop-down menu:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查这一点，请查看EventApp名称旁边绿色菜单栏中的第一个三个按钮。如果你刚刚在设计师中完成了RSVP_Screen的工作并切换到块编辑器，你将位于RSVP_Screen。如果不是，你可以通过点击显示另一个屏幕名称（如下一个截图所示的Screen1）并从下拉菜单中选择RSVP_Screen来轻松导航到RSVP_Screen：
- en: '![Pushing data to the Fusion Table](img/00196.jpeg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![将数据推送到融合表](img/00196.jpeg)'
- en: 'When the user clicks the **Send RSVP** button, we want to insert all three
    pieces of data into the Fusion Table. The following screenshot shows the block
    to achieve just this. This might look intimidating, but is actually quite simple:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击**发送RSVP**按钮时，我们希望将所有三份数据插入到融合表中。以下截图显示了实现这一目标的块。这看起来可能有些吓人，但实际上相当简单：
- en: '![Pushing data to the Fusion Table](img/00197.jpeg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![将数据推送到融合表](img/00197.jpeg)'
- en: Since we want our app to react to the **Send RSVP** button click, we will of
    course need to get a **SendRSVPButton.Click** event. As you might have already
    guessed, you will find this event block in the Blocks Palette in the **SendRSVPButton**
    Blocks drawer.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望应用程序对**发送RSVP**按钮的点击做出反应，我们当然需要获取**SendRSVPButton.Click**事件。正如你可能已经猜到的，你将在**SendRSVPButton**抽屉中的块调色板中找到这个事件块。
- en: The purple **call FusiontablesControl1.InsertRow** block enables an app to insert
    a row into a Fusion Table. In the **Fusiontables1** Blocks drawer, select and
    place the **FusiontablesControl1.InsertRow** block within the **SendRSVPButton.Click**
    event.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 紫色**调用FusiontablesControl1.InsertRow**块使应用程序能够将一行数据插入到融合表中。在**Fusiontables1**块抽屉中，选择并将**FusiontablesControl1.InsertRow**块放置在**SendRSVPButton.Click**事件中。
- en: As you can see, the **InsertRow** block has three empty sockets. The first socket
    is the **Id** of the table that you want to use. Recall that we found the **Id**
    of our table during the last step when creating the table. Copy and paste that
    **Id** here within an empty **Text** block.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，**InsertRow**块有三个空插槽。第一个插槽是你想要使用的表的**Id**。回想一下，我们在上一步创建表时找到了我们表的**Id**。在这里复制并粘贴那个**Id**，在一个空的**Text**块中。
- en: 'In the second socket of the **InsertRow** block, we will specify the column
    names. When inserting a row with multiple pieces (columns) of data into a Fusion
    Table, we need to specify which columns those pieces of data fit into. Recall
    that we named our columns **Guest Names**, **NumGuests**, and **ItemsBringing**.
    In a blank **Text** block, enter the column names within single-quotes, separated
    by commas, as shown in the following screenshot (note there are no spaces):'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在**InsertRow**块的第二个插槽中，我们将指定列名。当将包含多个数据片段（列）的行插入到Fusion Table中时，我们需要指定这些数据片段适合哪些列。回想一下，我们给列命名为**Guest
    Names**、**NumGuests**和**ItemsBringing**。在一个空的**Text**块中，输入列名，用单引号括起来，并用逗号分隔，如下截图所示（注意没有空格）：
- en: '![Pushing data to the Fusion Table](img/00198.jpeg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![将数据推送到Fusion Table](img/00198.jpeg)'
- en: The third and final piece of information that the **InsertRow** block needs
    is the actual values to insert into the Fusion Table. Just like the column names,
    we will be entering multiple pieces of data into a single row in the Fusion Table.
    As with the columns, these three pieces of data must be entered within single
    quotes and separated by commas but we will insert them a little differently. To
    create one single-quoted, comma-separated text from three pieces of information
    that a guest will enters in the three separate fields in the **RSVP_Screen**,
    we will use a **join** block, From the built-in **Text** Block drawer, drag and
    connect the **join** block to the values socket of **InsertRow**.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**InsertRow**块需要的第三和最后一个信息是实际要插入到Fusion Table中的值。就像列名一样，我们将把多个数据片段输入到Fusion
    Table的单行中。与列一样，这三个数据片段必须用单引号括起来，并用逗号分隔，但我们将以不同的方式插入。为了从**RSVP_Screen**中的三个单独字段中收集的三个信息片段创建一个单引号、逗号分隔的文本，我们将使用一个**join**块。从内置的**Text**块抽屉中，将**join**块拖动并连接到**InsertRow**的值插槽。'
- en: 'We will need to join 11 things—three pieces of information, six single quotes
    (one before and one after each piece of information), and two commas to separate
    the three pieces of single-quoted information. By default, the **join** block
    joins two things. So we need to make room for nine more items. Click on the blue
    button on the top left corner of the **join** block, and drag the string block
    on the left of the pop-up into the join block on the right of the pop-up, shown
    as follows. This will create more sockets in the **join** block. Do this nine
    times:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要连接11个东西——三个信息片段、六个单引号（每个信息片段前后各一个）和两个逗号来分隔三个单引号信息片段。默认情况下，**join**块连接两个东西。因此，我们需要为另外九个东西腾出空间。点击**join**块左上角的蓝色按钮，并将弹出窗口左边的字符串块拖动到弹出窗口右边的**join**块中，如下所示。这将创建更多的插槽在**join**块中。这样做九次：
- en: '![Pushing data to the Fusion Table](img/00199.jpeg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![将数据推送到Fusion Table](img/00199.jpeg)'
- en: 'The first, third, fifth, seventh, ninth, and eleventh **join** sockets will
    contain a single quote, entered into a Text box. The fourth and eight sockets
    will contain a comma entered into a Text box. In the second socket, the app will
    get the first set of information that a user enters: their first and last name.
    So, we need a block that allows the user to enter a name. You will find it in
    the **NameTextBox** blocks. Select and connect the light green **NameTextBox.Text**
    block into the second join socket.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个、第三个、第五个、第七个、第九个和第十一个**join**插槽将包含一个单引号，输入到文本框中。第四和第八个插槽将包含一个逗号，输入到文本框中。在第二个插槽中，应用将获取用户输入的第一组信息：他们的名字和姓氏。因此，我们需要一个允许用户输入名字的块。你将在**NameTextBox**块中找到它。选择并连接浅绿色的**NameTextBox.Text**块到第二个**join**插槽。
- en: The sixth socket will get the number of guests that the user selected from the
    list picker. In the **NumGuestListPicker** blocks, select and connect the light-green
    **NumGuestListPicker.Selection** block. And in the tenth socket, the app will
    get the information about which food/drink item the user inputted. In the **ItemsBringingTextBox**
    blocks, select and connect the light green **ItemsBringingTextBox.Text** block.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 第六个插槽将获取用户从列表选择器中选择的客人数量。在 **NumGuestListPicker** 块中，选择并连接浅绿色的 **NumGuestListPicker.Selection**
    块。在第十个插槽中，应用将获取用户输入的哪些食物/饮料项目的信息。在 **ItemsBringingTextBox** 块中，选择并连接浅绿色的 **ItemsBringingTextBox.Text**
    块。
- en: 'Again, recall the first goal that we specified in this section: take the three
    pieces of information that a guest provides and insert them in the Fusion Table.
    The three pieces of data come from the **NameTextBox** text property, the **NumGuestListPicker**
    selection property, and the **ItemsBringingTextBox** text property. This step
    was a complicated one, but it is very important to get this set of blocks right
    because, if not, no data will be inserted into the Fusion Table.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，回想一下我们在本节中指定的第一个目标：获取客人提供的三个信息，并将它们插入到 Fusion 表中。这三个数据来自 **NameTextBox**
    文本属性、**NumGuestListPicker** 选择属性和 **ItemsBringingTextBox** 文本属性。这一步很复杂，但确保这一组块正确设置非常重要，因为如果不这样做，就不会有数据被插入到
    Fusion 表中。
- en: Now that we are done with the **InsertRow** block, all that is left is to clear
    out the textboxes and revert the **ListPicker** selection to the default value
    of `1`. Since blocks are executed from top to bottom and we want to clear out
    the Textboxes and reset the ListPicker after the app sends the information to
    the Fusion Table, insert the next set of blocks after the InsertRow block. Find
    the **set NameTextBox.Text to**, **set ItemsBringingTextBox.Text to**, and **set
    NumGuestListPicker.Selection** blocks and insert them into the bottom of the **when
    SendRSVPButton.Click** block. The first two blocks—**set NameTextBox.Text to**
    and **set ItemsBringingTextBox.Text to**—get blank Text blocks. Setting the textboxes
    to empty strings will clear out the previous data. Since we want the **set NumGuestListPicker.Selection**
    to reset the default selection property of the **NumGuestListPicker** to `1`,
    attach a **Math 0** block and change the number to **1**. Lastly, we will call
    a procedure to make sure any keyboard that might have popped-up when the guest
    was typing in information gets hidden. Find the call **NameTextBox.HideKeyboard**
    block in the **NameTextBox** blocks. Connect it at the very bottom of the blocks.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 **InsertRow** 块，剩下要做的就是清除文本框并将 **ListPicker** 选择重置为默认值 `1`。由于块是从上到下执行的，我们希望在应用将信息发送到
    Fusion 表之后清除文本框并重置 ListPicker，因此将下一组块插入到 InsertRow 块之后。找到 **set NameTextBox.Text
    to**、**set ItemsBringingTextBox.Text to** 和 **set NumGuestListPicker.Selection**
    块，并将它们插入到 **when SendRSVPButton.Click** 块的底部。前两个块——**set NameTextBox.Text to**
    和 **set ItemsBringingTextBox.Text to**——得到空白文本块。将文本框设置为空字符串将清除之前的数据。由于我们希望 **set
    NumGuestListPicker.Selection** 将 **NumGuestListPicker** 的默认选择属性重置为 `1`，附加一个 **Math
    0** 块并将数字改为 **1**。最后，我们将调用一个过程来确保在客人输入信息时可能弹出的任何键盘都被隐藏。在 **NameTextBox** 块中找到调用
    **NameTextBox.HideKeyboard** 块，并将其连接到块的底部。
- en: Ensuring empty rows are not inserted
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确保不插入空白行
- en: Right now, the **InsertRow** does not have any way to tell if the data that
    it is inserting is valid or not. For example, the user might click on the **SendRSVPButton**
    by mistake and that will insert a blank row. We can fix this by checking to make
    sure that the guest has typed in at least the name before we insert anything.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，**InsertRow** 没有任何方法来判断它所插入的数据是否有效。例如，用户可能会不小心点击 **SendRSVPButton**，这将插入一个空白行。我们可以在插入任何内容之前检查确保客人至少输入了名字来解决这个问题。
- en: 'To achieve this, we can place all the blocks that we created within an if /then
    statement. The condition that we will check for is whether the NameTextBox. Text
    is empty or not. If the NameTextBox.Text is not empty, then that means the guest
    must have typed something and we will allow the insertion to happen. "If the NameTextBox.Text
    is empty, then the if statement is not true, and the then set of blocks will not
    fire. As a result, nothing will happen. The following screenshot shows the blocks
    for the if statement:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这一点，我们可以将我们创建的所有块放置在一个 if / then 语句中。我们将检查的条件是 NameTextBox.Text 是否为空。如果
    NameTextBox.Text 不为空，这意味着客人必须已经输入了一些内容，我们将允许插入操作发生。“如果 NameTextBox.Text 为空，则 if
    语句不成立，并且 then 块集将不会触发。结果，什么也不会发生。以下屏幕截图显示了 if 语句的块：
- en: '![Ensuring empty rows are not inserted](img/00200.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![确保不插入空行](img/00200.jpeg)'
- en: 'You can find the lime-green (unequal) block in the **Build In Logic** Block
    drawer. The block will appear with an equals sign, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 **Build In Logic** 块抽屉中找到那块浅绿色的（不等）块。该块将显示一个等号，如下所示：
- en: '![Ensuring empty rows are not inserted](img/00201.jpeg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![确保不插入空行](img/00201.jpeg)'
- en: Click on the arrow and select the unequal option from the drop down menu. In
    the first blank, insert the **NameTextBox.Text** block and, in the second blank,
    insert a blank **Text** block. Now our code indicates that, **if** the name field
    is not blank, **then** it should get the data and insert it into the Fusion Table.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 点击箭头并从下拉菜单中选择不等选项。在第一个空白处插入 **NameTextBox.Text** 块，在第二个空白处插入一个空的 **Text** 块。现在我们的代码表明，**如果**姓名字段不为空，**则**应该获取数据并将其插入到
    Fusion Table 中。
- en: Viewing the guest list
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 查看嘉宾名单
- en: Now that we have implemented the **RSVP_Screen**, we have a way for guests to
    send RSVPs and aggregate all the RSVPs from different guests into the Fusion Table.
    In any event organization app, it is helpful for others to be able to see a list
    of guests who have already RSVP'ed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经实现了 **RSVP_Screen**，我们为客人提供了一个发送 RSVP 的方式，并将不同客人的所有 RSVP 聚集到 Fusion Table
    中。在任何活动组织应用中，让其他人能够看到已经 RSVP 的嘉宾名单是有帮助的。
- en: 'The purpose of the GuestList_Screen is just that—enabling all attendees (and
    the organizer) to see who else is coming to the event. To display information
    gathered in the Fusion Table, we will use a Label. In the Designer window, navigate
    to the **GuestList_Screen**. Just like in the RSVP_Screen, first drag a **VerticalArragment**
    to the top portion of the **GuestList_Screen**, above the **HorizontalArrangement**,
    which contains all the navigation buttons. Make the **BackgroundColor** property
    in **VerticalArrangement** to **None**. Also set both the **Height** and **Width**
    properties to **Fill parent**. Now drag a **Label** component into the **VerticalArrangement**.
    Rename the Label `GuestListLabel`. Change the **BackgroundColor** property of
    **GuestListLabel** to **None**. Change the **FontSize** property to **18** (you
    might have to try various values for this property depending on your device''s
    screen size and screen resolution). Finally, change the **TextColor** property
    to **White**. Then add a **FusiontablesControl** component just like you did in
    the **RSVP_Screen**. You can view the changes in the following screenshot:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: GuestList_Screen 的目的就是——让所有参会者（包括组织者）能够看到还有谁会参加这个活动。为了显示在 Fusion Table 中收集到的信息，我们将使用一个标签。在设计师窗口中，导航到
    **GuestList_Screen**。就像在 RSVP_Screen 中一样，首先将一个 **VerticalArrangement** 拖动到 **GuestList_Screen**
    的顶部区域，位于 **HorizontalArrangement** 之上，该区域包含所有导航按钮。将 **VerticalArrangement** 的
    **BackgroundColor** 属性设置为 **None**。同时设置 **Height** 和 **Width** 属性为 **Fill parent**。现在将一个
    **Label** 组件拖动到 **VerticalArrangement** 中。将标签重命名为 `GuestListLabel`。将 **GuestListLabel**
    的 **BackgroundColor** 属性更改为 **None**。将 **FontSize** 属性更改为 **18**（根据您的设备屏幕大小和屏幕分辨率，您可能需要尝试此属性的多个值）。最后，将
    **TextColor** 属性更改为 **White**。然后添加一个 **FusiontablesControl** 组件，就像在 **RSVP_Screen**
    中做的那样。您可以在以下屏幕截图中查看更改：
- en: '![Viewing the guest list](img/00202.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![查看嘉宾名单](img/00202.jpeg)'
- en: Just like in the **RSVP_Screen**. We will change the three properties of the
    **FusiontablesConrol1** component. Since you already know how to change the three
    **FusiontablesControl1** properties—**KeyFile**, **ServiceAccountEmail**, and
    **UseServiceAuthentication**—we will not go into the details here. Just follow
    the steps that we completed in the *Connecting the app to the Google Fusion Table*
    section.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 就像在 **RSVP_Screen** 中一样。我们将更改 **FusiontablesConrol1** 组件的三个属性。由于您已经知道如何更改三个
    **FusiontablesControl1** 属性——**KeyFile**、**ServiceAccountEmail** 和 **UseServiceAuthentication**——我们在这里不会详细介绍。只需遵循我们在
    *连接应用至 Google Fusion Table* 部分中完成的步骤即可。
- en: Whereas in the RSVP_Screen, the app sends information to the Fusion Table, in
    the GuestList_Screen, the app is requests information from the Fusion Table, receives
    it and then displays it. To program this, head to the **Blocks** editor.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在RSVP_Screen中，应用将信息发送到融合表，而在GuestList_Screen中，应用从融合表请求信息，接收它然后显示。要编程这个，前往**Blocks**编辑器。
- en: Coding the blocks – requesting data
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写块代码 – 请求数据
- en: 'The first code that we need to program is to request data from the Fusion Table.
    Click on **GuestList_Screen** in the Blocks drawer and drag the **when GuestList_Screen.Initialize**
    event. This event is automatically triggered whenever a screen is launched. We
    want to request data from the Fusion Table when the **GuestList** screen is launched.
    Thus, we will add to this event is the **call FusiontablesControl1.GetRows** block.
    This block will let us request data from the Fusion Table. You can find this block
    in the **FusiontablesControl1** blocks drawer. The **GetRows** block needs two
    pieces of information to fetch rows from Fusion Tables: the ID of the table and
    name of the column. We identified the table ID when we were creating the Fusion
    Table. Paste that ID into the **tableId** socket of the **GetRows** block using
    a **Text** block. Use another **Text** block to specify the column name, **''Guest
    Names''**. Note the single quotes; just like in the **InsertRows** block, the
    column names have to be single-quoted here as well. The following screenshot shows
    the completed set of blocks:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要编写的第一个代码是请求从融合表获取数据。在块抽屉中点击**GuestList_Screen**，并拖动**when GuestList_Screen.Initialize**事件。这个事件会在每次屏幕启动时自动触发。我们希望在**GuestList**屏幕启动时从融合表请求数据。因此，我们将添加到这个事件的**call
    FusiontablesControl1.GetRows**块。这个块将允许我们从融合表请求数据。你可以在**FusiontablesControl1**块抽屉中找到这个块。**GetRows**块需要两块信息来从融合表获取行：表的ID和列名。我们在创建融合表时已经识别了表ID。将这个ID粘贴到**GetRows**块的**tableId**插槽中，使用一个**Text**块。使用另一个**Text**块来指定列名，**'Guest
    Names'**。注意单引号；就像在**InsertRows**块中一样，这里的列名也必须用单引号。下面的截图显示了完成的块集：
- en: '![Coding the blocks – requesting data](img/00203.jpeg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![编写块代码 – 请求数据](img/00203.jpeg)'
- en: Coding the blocks – receiving data
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写块代码 – 接收数据
- en: The previous blocks request in data from the Fusion Table, now we need to code
    receiving the information from the Fusion Table. The **when FusiontablesControl1.GotResult**
    block does this. You will find it in the **FusiontablesControl1** blocks. As we
    mentioned before, when data from Fusion Tables is received, this event gets triggered.
    The data is placed in the **result** variable of this event.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的块从融合表请求数据，现在我们需要编写接收从融合表信息的数据。**when FusiontablesControl1.GotResult**块执行这个操作。你可以在**FusiontablesControl1**块中找到它。正如我们之前提到的，当从融合表接收到数据时，这个事件会被触发。数据放置在这个事件的结果变量**result**中。
- en: By default, the data we receive from the Fusion Table is a block of text with
    each row placed on its own line. This data also includes the column header. So,
    let's say the Guest Names column of our Fusion Table has three rows with the names
    Olivienne, Dash, and Eva. Then the data that is placed in the result variable
    has four lines—Guest Names, Olivienne, Dash, and Eva (the column header followed
    by the three names).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们从融合表接收到的数据是一块文本，每行放在自己的行上。这些数据还包括列标题。所以，假设我们的融合表中的Guest Names列有三行，名字分别是Olivienne、Dash和Eva。那么放置在结果变量中的数据有四行——Guest
    Names、Olivienne、Dash和Eva（列标题后面跟着三个名字）。
- en: 'Since we want the **when FusiontablesControl1.GotResult** event to automatically
    display the guest names (and the header), select and connect the **set GuestListLabel.Text
    to** block. What do we want it to display? The **result** variable. Hover your
    cursor over the light orange **result** variable embedded in the gold event block.
    A pop-up with two orange blocks will appear, as shown in the following screenshot.
    Select the **get result** block and attach it to the open socket in the **GuestListLabel.Text**
    block:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们希望**when FusiontablesControl1.GotResult**事件自动显示客人名字（以及标题），选择并连接**set GuestListLabel.Text
    to**块。我们希望它显示什么？**result**变量。将光标悬停在嵌入在金色事件块中的浅橙色**result**变量上。会出现一个带有两个橙色块的弹出窗口，如下面的截图所示。选择**get
    result**块并将其连接到**GuestListLabel.Text**块中的开放插槽：
- en: '![Coding the blocks – receiving data](img/00204.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![编写块代码 – 接收数据](img/00204.jpeg)'
- en: 'That''s it! Now your **GuestList_Screen** will display all the guests who have
    RSVP''ed. The following screenshot shows the completed sets of blocks:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！现在您的 **GuestList_Screen** 将显示所有已 RSVP 的客人。以下截图显示了完成的块集：
- en: '![Coding the blocks – receiving data](img/00205.jpeg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![编码块 - 接收数据](img/00205.jpeg)'
- en: It is time to try your app! Fill out the RSVP form to see if it populates into
    your Fusion Table. Does the app then clear the RSVP screen fields and display
    the names in the **Guest List** screen?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候尝试您的应用了！填写 RSVP 表格以查看它是否填充到您的 Fusion Table 中。然后，应用是否清除 RSVP 屏幕字段并在 **Guest
    List** 屏幕上显示名称？
- en: If you recall, we set up our app to gather other data from the RSVP besides
    the list of guest names. We created fields so guests could input the number of
    people they are bringing and the food/drink item to share. You could also display
    this information for other guests to see, but really that data is for the host,
    who can easily view it along with the names in the Fusion Table columns we created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您还记得，我们设置了我们的应用以收集 RSVP 之外的其他数据，除了客人名单。我们创建了字段，让客人可以输入他们要带的人数以及要分享的食物/饮料项目。您也可以将此信息显示给其他客人查看，但真正重要的是这些数据是为主持人准备的，他可以轻松地查看我们创建的
    Fusion Table 列中的名称。
- en: Sharing the Event App
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 共享事件应用
- en: With the Event App, we wanted to introduce you to the process of collecting
    and retrieving data. Now that you are approaching apps from more of a developer’s
    perspective, you will probably be aware that every time you enter your email address
    or other information into an app, that data is getting stored into a database.
    But, as we mentioned at the beginning of this chapter, Fusion Tables as a database
    has its limitations. If you were to share the Event App as it is with multiple
    event organizers, who start using it on different devices, there will be a problem
    because the app uses a single Fusion Table as the back end. If many people use
    the app for their different events, all of the data from all the different devices
    will be aggregated in to one single Fusion Table. Of course this will create mass
    confusion for the event organizers (and guests) as all of the data for different
    parties will be all mixed up!
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用事件应用，我们希望向您介绍收集和检索数据的过程。现在，您从更多开发者的角度接近应用，您可能已经意识到，每次您将电子邮件地址或其他信息输入到应用中时，这些数据就会被存储到数据库中。但是，正如我们在本章开头提到的，Fusion
    Tables 作为数据库有其局限性。如果您将事件应用的原样与多个活动组织者共享，他们将在不同的设备上开始使用它，那么将出现问题，因为该应用使用单个 Fusion
    Table 作为后端。如果许多人使用该应用为他们的不同活动，所有不同设备的数据都将汇总到一个单独的 Fusion Table 中。当然，这将给活动组织者（和客人）造成极大的混乱，因为不同派对的全部数据都将混合在一起！
- en: Before we outline a possible fix to this problem, lets discuss what we did in
    this app. Since our app accesses and modifies the Fusion Table, we had to create
    Google service level authentication. This step ensures that our app is authorized
    by Google to access Fusion Tables. Then, we inserted the Fusion Table Id into
    our app to let the app know which Fusion Table to access. Additionally, we created
    a service email address for our app and shared the Fusion Table with this service
    email address. These steps ensure that the Fusion Table allows our app to read/write
    data. So we basically had three different entities interacting with each other
    - Google service level authentication, our app, and the Fusion Table.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们概述可能的解决方案之前，让我们讨论一下我们在该应用中做了什么。由于我们的应用访问和修改 Fusion Table，我们必须创建 Google 服务级别身份验证。这一步骤确保我们的应用获得
    Google 授权以访问 Fusion Tables。然后，我们将 Fusion Table Id 插入到我们的应用中，让应用知道要访问哪个 Fusion
    Table。此外，我们为我们的应用创建了一个服务电子邮件地址，并使用此服务电子邮件地址共享 Fusion Table。这些步骤确保 Fusion Table
    允许我们的应用读写数据。因此，我们基本上有三个不同的实体在相互交互 - Google 服务级别身份验证、我们的应用和 Fusion Table。
- en: One way to address the problem of the single Fusion Table associated with the
    Event App is for the developer to create different copies of the app that uses
    different copies of a Fusion Table. This means that each copy of the app will
    have to be updated with the Id of the new copy of the Fusion Table. Additionally,
    this also means the Fusion Table will have to be re-shared with the app's service
    level email (using the original service email address).
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 解决与事件应用关联的单个 Fusion Table 问题的方法之一是，开发者创建不同副本的应用，这些应用使用不同的 Fusion Table 副本。这意味着每个应用副本都必须更新为新副本的
    Fusion Table Id。此外，这也意味着必须将 Fusion Table 重新共享给应用的服务级别电子邮件地址（使用原始服务电子邮件地址）。
- en: It is easier than it sounds. First, open the Fusion Table that you used previously,
    go to the File menu and select, Make a copy. This will create a new copy of the
    original Fusion Table with all of the changes we made to the columns and settings.
    If your previous Fusion Table had any data in it, you will need to clear the data.
    Next, repeat the Fusion Table Id identification step outlined in the last few
    paragraphs of Creating a Google Fusion Table section. (Since you are creating
    a new Fusion Table, you will have to use the Id of this new table.) You will also
    have to repeat the Sharing the Fusion Table with the service account email section
    for this new Fusion Table (using the original service email address).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这比听起来容易。首先，打开你之前使用的融合表，转到文件菜单并选择“制作副本”。这将创建一个包含我们对列和设置所做的所有更改的新融合表副本。如果你的上一个融合表中有任何数据，你需要清除数据。接下来，重复在“创建Google融合表”部分最后几段中概述的融合表ID识别步骤。（由于你正在创建一个新的融合表，你必须使用这个新表的ID。）你还需要为这个新的融合表重复“通过服务账户电子邮件共享融合表”部分（使用原始服务电子邮件地址）。
- en: Lastly, in Blocks editor, paste the new Fusion Table Id into the Text box (attached
    to the TableID slot of the call FusiontablesControl1.InsertRow block) to ensure
    that the app uses the new Fusion Table.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在“块”编辑器中，将新的融合表ID粘贴到文本框中（连接到调用“FusiontablesControl1.InsertRow”块的“TableID”槽），以确保应用程序使用新的融合表。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to share your Event App with 7 people, you will need to repeat these
    steps 7 times, so that each person has a unique version of the app with a unique
    Fusion Table.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要与7个人分享你的事件应用，你需要重复这些步骤7次，以确保每个人都有一个具有唯一融合表的应用版本。
- en: Summary
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we explored a lot of App Inventor advanced features, namely
    a database. Google Fusion Tables makes it possible for us to store data in the
    backend. We learned how to create a new Fusion Table and how to establish Google
    API credentials so that our app is authorized to access Google Fusion Tables.
    Finally we learned how to insert, retrieve, and display data from the Fusion Tables.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探索了许多App Inventor高级功能，特别是数据库。Google融合表使我们能够在后端存储数据。我们学习了如何创建新的融合表，以及如何建立Google
    API凭证，以便我们的应用有权访问Google融合表。最后，我们学习了如何从融合表中插入、检索和显示数据。
- en: You are amassing quite a programming toolkit! And in the next chapter, you will
    learn yet another tool to help expand your coding skills. A loop is a structure
    or sequence of instructions that enables you to iterate or repeat steps until
    certain conditions are met. This is handy because, instead of copying and pasting
    blocks to perform the same function for each item in a long list, we can program
    one set of blocks to execute repeatedly.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在积累一个相当丰富的编程工具包！在下一章中，你将学习另一个可以帮助扩展你的编程技能的工具。循环是一种结构或指令序列，它允许你重复执行步骤，直到满足某些条件。这很方便，因为，我们不需要为长列表中的每个项目复制和粘贴相同的代码块来执行相同的功能，我们可以编写一组代码块来重复执行。
