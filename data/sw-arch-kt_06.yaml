- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '6'
- en: Microservices, Serverless, and Microfrontends
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务、无服务器和微前端
- en: In this chapter, we’ll delve into the architectural styles of microservices,
    serverless, and microfrontends. They have revolutionized the way we design, develop,
    and deploy applications. They also empower organizations to build robust, flexible,
    and scalable systems. We’ll explore the fundamentals, unique features, and tangible
    benefits of each approach. By the end, you’ll have a comprehensive understanding
    of these architectures and their application in modern software engineering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将深入探讨微服务、无服务器和微前端架构风格。它们彻底改变了我们设计、开发和部署应用程序的方式。它们还使组织能够构建强大、灵活和可扩展的系统。我们将探讨每种方法的根本原则、独特特性和实际益处。到本章结束时，您将全面了解这些架构及其在现代软件工程中的应用。
- en: Our exploration begins with describing the traditional monolith, where the entire
    system is designed and developed as a single unit. Then, we’ll discuss the challenges
    of this approach that are faced by many developers to bring about the need to
    break down this monolith into smaller and loosely coupled components.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的探索从描述传统的单体架构开始，其中整个系统被设计和发展为一个单一单元。然后，我们将讨论许多开发者面临此方法带来的挑战，从而产生将单体分解为更小、松散耦合组件的需求。
- en: After, we’ll turn our attention to microservices architecture and examine how
    microservices solve the challenges of monoliths. We’ll cover how a monolith can
    be transformed into microservices before discussing the benefits, challenges,
    and trade-offs that come with this distributed architectural style.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将关注微服务架构，并检查微服务如何解决单体架构的挑战。我们将介绍如何将单体转换为微服务，然后讨论随之而来的分布式架构风格的益处、挑战和权衡。
- en: Next, we’ll discuss how serverless computing helps developers focus on writing
    code without the concerns of infrastructure. We’ll discuss the optimal use cases
    for serverless architectures and address the challenges associated with this paradigm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将讨论无服务器计算如何帮助开发者专注于编写代码，而无需担心基础设施。我们将讨论无服务器架构的最佳用例，并解决与此范式相关的挑战。
- en: Finally, we’ll look at how a monolithic application can be transformed into
    microservices and microfrontends. We’ll discuss how self-contained components
    benefit the developers and integrate with microservices and serverless backends.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将探讨如何将单体应用程序转换为微服务和微前端。我们将讨论自包含组件如何使开发者受益以及如何与微服务和无服务器后端集成。
- en: 'We’ll cover the following topics in this chapter:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Monoliths
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单体架构
- en: Microservices
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务
- en: Nanoservices
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纳微服务
- en: Serverless
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无服务器
- en: Microfrontends
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微前端
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find all the code files used in this chapter on GitHub: [https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-6](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-6%20)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在GitHub上找到本章中使用的所有代码文件：[https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-6](https://github.com/PacktPublishing/Software-Architecture-with-Kotlin/tree/main/chapter-6)
- en: Monoliths
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单体架构
- en: '**Monolith** means *made of one stone*. In the context of software architecture,
    a monolith refers to a large system designed and developed as a single unit. In
    a monolithic architecture, there’s typically a single code base, a unified database,
    and one deployable artifact.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**单体**意味着“由一块石头制成”。在软件架构的背景下，单体指的是作为一个单一单元设计和开发的庞大系统。在单体架构中，通常有一个单一的代码库、统一的数据库和一个可部署的工件。'
- en: Having a single code base means it usually relies on individual developers’
    efforts to keep the code tidy and clean. There’s little room to enforce separation
    of concerns by design since all code is hosted in a single place. This often results
    in all the components, modules, and functionalities of the application being tightly
    coupled and interdependent.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一个单一的代码库意味着它通常依赖于个别开发者的努力来保持代码整洁和干净。由于所有代码都托管在同一个地方，因此很难通过设计来强制实施关注点的分离。这通常会导致应用程序的所有组件、模块和功能紧密耦合和相互依赖。
- en: A unified database, typically relational only, in a monolithic application is
    likely to produce a major – if not only one – schema that contains all the entities
    from all functionalities. Moreover, each entity table will contain all the columns
    that address all business concerns related to the entity. There may also be a
    spiderweb of foreign key constraints among tables. It often combines the concerns
    of a database used for transactions and reporting into one.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在单体应用中，通常只有关系型数据库，可能会产生一个主要的——如果不是唯一的——模式，该模式包含所有功能的所有实体。此外，每个实体表将包含所有涉及实体的业务相关列。表格之间还可能存在一个复杂的键约束网。它通常将用于事务和报告的数据库的担忧合并为一个。
- en: 'While monoliths have a wide range of code quality and database designs, they
    have one thing in common: there’s one deployable artifact for the monolithic application,
    which contains the entire system. It’s big and takes a long time to release. The
    release procedure usually requires all monolithic application instances to shut
    down first, after which infrastructure changes are made, the new deployable artifact
    replaces the old one, and the updated version of the application starts. Each
    release also often requires intensive pre-planning and coordination among teams
    to identify dependencies. The release plan can look like a Gantt chart or a project
    plan, as shown in *Figure 6**.1*:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体在代码质量和数据库设计方面范围很广，但它们有一个共同点：单体应用有一个可部署的工件，包含整个系统。它很大，发布需要很长时间。发布过程通常需要首先关闭所有单体应用实例，然后进行基础设施更改，新的可部署工件替换旧的工件，应用开始更新版本。每次发布通常还需要进行密集的预先规划和团队间的协调，以确定依赖关系。发布计划可能看起来像甘特图或项目计划，如图*6.1*所示：
- en: '![Figure 6.1 – Release plan as a Gantt chart](img/B21737_06_1.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图6.1 – 发布计划作为甘特图](img/B21737_06_1.jpg)'
- en: Figure 6.1 – Release plan as a Gantt chart
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.1 – 发布计划作为甘特图
- en: In this release plan, the dev team shuts down the monolithic application first.
    Then, the database team backs up the database. Afterward, the dev team starts
    deploying the application, while the infrastructure team applies changes such
    as network or middleware upgrades. When this is finished, the dev team starts
    the application. Finally, the QA team verifies the environment and signs off the
    release. Some organizations may have a dedicated release team or operation team
    to formulate a playbook for each release and execute the plan as one team.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个发布计划中，开发团队首先关闭单体应用。然后，数据库团队备份数据库。之后，开发团队开始部署应用，同时基础设施团队应用更改，如网络或中间件升级。当这一切完成时，开发团队启动应用。最后，质量保证团队验证环境并签署发布。一些组织可能有一个专门的发布团队或运营团队，为每次发布制定一个操作手册，并作为一个团队执行计划。
- en: The release plan is visualized as a Gantt chart to show the dependencies among
    teams and show the timeline of the release from left to right.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 发布计划被可视化为一个甘特图，以显示团队之间的依赖关系，并显示从左到右的发布时间线。
- en: Next, we’ll cover the benefits and challenges of the monolithic approach as
    a background for the upcoming three architectural styles.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍单体方法的优点和挑战，作为介绍即将到来的三种架构风格的基础。
- en: Benefits
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: 'Nowadays, few organizations would openly advocate monolithic architecture as
    an optimal style. However, there are still a few benefits that allow it to be
    considered a choice of architecture:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很少有组织会公开倡导单体架构作为最佳风格。然而，还有一些优点使得它被认为是一种架构选择：
- en: '**Simplicity**: Monolithic applications have the simplicity of one code base,
    one database, and one deployable artifact. Once the routines for build, deploy,
    and run are in place, developers can follow that one pattern that repeats over
    time. As we mentioned in [*Chapter 2*](B21737_02.xhtml#_idTextAnchor045), this
    is known as the **You aren’t gonna need it** (**YAGNI**) principle. If this simplicity
    is all we need now, then it’s not a bad idea to run with the monolithic approach
    initially.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单性**：单体应用具有一个代码库、一个数据库和一个可部署工件的简单性。一旦建立构建、部署和运行的常规，开发者就可以遵循这个随着时间的推移重复的模式。正如我们在[*第2章*](B21737_02.xhtml#_idTextAnchor045)中提到的，这被称为**你不是真的需要它**（YAGNI）原则。如果这种简单性是我们现在所需要的，那么最初采用单体方法不是一个坏主意。'
- en: '**Short time to market**: This situation typically resonates with developers
    if they work in a startup company, where time to market is the number one priority
    and nothing else matters. Sometimes, it’s even a do-it-now-or-quit situation.
    It could also go well with experimental applications where sophisticated architecture
    may not be necessary.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上市时间短**：这种情况通常与在初创公司工作的开发者产生共鸣，在初创公司中，上市时间是首要任务，其他一切都不重要。有时，这甚至是一个立即行动或放弃的情况。这也适用于可能不需要复杂架构的实验性应用程序。'
- en: '**Build first, optimize later**: Another benefit of monolithic architecture
    is situational. If the area of business is new and everyone is finding their paths
    on how to build the system as a product, then it’s beneficial to delay any refactoring
    or optimization – that is, until everyone, including technical and non-technical
    stakeholders, has more experience with the subject matter and recognizes the need
    to break down the monolithic application. Also, it’s better to understand the
    business ecosystem before trying to break it down by reasonable boundaries and
    which features naturally go together.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**先构建，后优化**：单体架构的另一个好处是情境性的。如果业务领域是新的，每个人都正在寻找如何将系统构建成产品的路径，那么推迟任何重构或优化是有益的——也就是说，直到包括技术和非技术利益相关者在内的每个人都对这个主题有更多经验，并认识到需要分解单体应用程序的需要。此外，在尝试通过合理的边界将其分解并确定哪些功能自然地一起使用之前，更好地了解业务生态系统是更好的。'
- en: Monolith-first
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**以单体架构为首选**'
- en: This approach of making a conscious choice toward monolithic architecture is
    called **monolith-first**. This term was made popular by Martin Fowler in his
    engineering blog in 2015.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 这种有意识地选择单体架构的方法被称为**以单体架构为首选**。这个术语是由马丁·福勒在2015年的工程博客中推广的。
- en: Challenges
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: 'While monolithic architecture has been widely used, it has some drawbacks.
    The tight coupling between components makes it difficult to update specific parts
    of the application independently. In other words, changing one part of the system
    would affect other parts unintentionally:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单体架构已被广泛使用，但它有一些缺点。组件之间的紧密耦合使得独立更新应用程序的特定部分变得困难。换句话说，改变系统的一部分可能会无意中影响其他部分：
- en: '**Slow development**: This makes any change bigger than it needs to be, and
    therefore increases the risk of release. Since every change is bigger, the probability
    of having code conflicts among engineers is significantly higher. Engineers would
    spend more time reviewing code and resolving code conflicts. More areas of testing
    are required to ensure the system is functional. Combined, these factors lead
    to slower development cycles and reduced flexibility.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓慢的开发过程**：这使得任何变更都比实际需要的更大，因此增加了发布的风险。由于每个变更都更大，工程师之间发生代码冲突的概率显著更高。工程师将花费更多时间审查代码和解决代码冲突。需要更多的测试区域来确保系统功能正常。这些因素共同导致开发周期变慢，灵活性降低。'
- en: '**Difficult to scale and tune performance**: Additionally, scaling resources
    in a monolith can be inefficient since the entire application needs to be replicated
    instead of individual components that require more resources being scaled. It’s
    also harder to tune performance precisely since there could be other processes
    contending with the same resource, which affect the performance to be tuned intentionally.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**难以扩展和调整性能**：此外，在单体架构中扩展资源可能效率低下，因为整个应用程序需要被复制，而不是仅需要更多资源的单个组件。由于可能存在其他进程与同一资源竞争，因此精确调整性能也更加困难。'
- en: '**Time-consuming test suite**: In a monolithic application, the different components
    and modules are tightly coupled, meaning that changes in one part of the application
    can have unintended consequences in other parts. Tests need to verify no unintended
    changes were made for business cases, leading to more complex test scenarios and
    a longer test execution time. The inter-dependencies also make it difficult to
    isolate and run tests independently, limiting the potential for parallel execution
    and shorter test execution times. Even a minor change in a monolithic application
    would need regression testing. This requires a comprehensive suite of test cases,
    which can be time-consuming.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**耗时的测试套件**：在单体应用程序中，不同的组件和模块紧密耦合，这意味着应用程序某一部分的变更可能会在其他部分产生意外的后果。测试需要验证没有对业务案例造成意外的变更，导致测试场景更加复杂，测试执行时间更长。相互依赖性也使得独立隔离和运行测试变得困难，限制了并行执行和缩短测试执行时间的潜力。即使是单体应用程序中的微小变更也需要回归测试。这需要一套全面的测试用例，这可能很耗时。'
- en: '**Risky, long, and big releases**: Releasing a monolithic application usually
    takes a long time because the entire system is deployed as a unit. Even a minor
    change would result in the entire monolith having to be redeployed, which means
    it becomes harder to continuously deliver the system. Worse, it could end up accumulating
    more changes to release periodically since the monolith can’t be deployed quickly
    and continuously. Engineers could be spending a long night aiming to release a
    monolith application, and these long and late hours may introduce more human errors
    due to fatigue.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**风险高、周期长、规模大**：发布单体应用通常需要很长时间，因为整个系统作为一个单元进行部署。即使是微小的更改，也会导致整个单体需要重新部署，这意味着持续交付系统变得更加困难。更糟糕的是，由于单体无法快速和持续地部署，可能会积累更多更改以定期发布。工程师可能会花费一个漫长的夜晚来发布单体应用，而这些漫长和晚上的时间可能会因为疲劳而引入更多人为错误。'
- en: On the contrary, releasing a small application in a distributed system can be
    equally challenging. However, due to the smaller scope of change, it’s possible
    to use modern strategies such as rolling releases, **blue-green releases**, or
    **canary releases**. These release strategies can be performed during business
    hours where most help is available, and thus reduce the risk of human errors.
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 相反，在分布式系统中发布一个小型应用同样具有挑战性。然而，由于更改范围较小，可以使用现代策略，如滚动发布、**蓝绿发布**或**金丝雀发布**。这些发布策略可以在工作时间进行，此时可以获得最多的帮助，从而降低人为错误的风险。
- en: '**Technology lock-in**: A monolithic application usually has a long lifespan.
    That means it may have chosen a technology stack a long time ago. Developers are
    faced with either upgrading the technology, which results in a substantial change
    in the code base or adopting a different technology in some parts of the codebase,
    which results in multiple tools doing the same job. This also means the space
    for experimenting with technology is severely limited.'
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**技术锁定**：单体应用通常具有较长的生命周期。这意味着它可能很久以前就选择了一个技术栈。开发者面临的是要么升级技术，这会导致代码库发生重大变化，要么在某些代码库的部分采用不同的技术，这会导致多个工具做相同的工作。这也意味着在技术上进行实验的空间严重受限。'
- en: '**Total system failure**: A failure in a monolithic application easily results
    in total system failure. Even the operational part may shut down since it’s part
    of one monolith unit. It’s harder to isolate and contain failures because there’s
    no clear separation between components.'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**整个系统故障**：单体应用的故障很容易导致整个系统故障。即使是操作部分也可能关闭，因为它是一个单体单元的一部分。由于组件之间没有明确的分离，因此隔离和限制故障变得更加困难。'
- en: '**Team dependencies**: Lastly, multiple teams sharing one deployable artifact
    and probably one code base create a lot of dependencies. One team may have completed
    a feature that needs to be released as soon as possible, and the other team may
    still be working on a feature that isn’t ready yet.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**团队依赖**：最后，多个团队共享一个可部署的工件，可能还有同一个代码库，这会创建大量的依赖。一个团队可能已经完成了一个需要尽快发布的特性，而另一个团队可能仍在开发一个尚未准备好的特性。'
- en: '**Slow time to market**: As they share one deployable artifact and one monolith,
    the first team may not be able to have their feature land on the market in time
    until other teams have completed theirs. This slow time to market could mean competitors
    may have taken opportunities and customers by the time the monolith is released.
    It hurts the business if the system is constantly catching up with competitors.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上市时间慢**：由于它们共享一个可部署的工件和一个单体，第一个团队可能无法在其他团队完成他们的工作之前及时将他们的功能推向市场。这种缓慢的上市时间可能意味着竞争对手可能已经抓住了机会，并在单体发布时吸引了客户。如果系统不断追赶竞争对手，这对业务是有害的。'
- en: With that, we’ve set the context of the challenges that are faced by engineers
    when implementing monolithic applications. Next, we’re going to look at architectural
    styles that aim to conquer these challenges.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们已经设定了工程师在实施单体应用时面临的挑战的背景。接下来，我们将探讨旨在克服这些挑战的架构风格。
- en: Microservices
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微服务
- en: Before the term microservice architecture was coined, the concept of **service-oriented
    architecture** (**SOA**) became popular in the 2000s as an early response to the
    challenges posed by monolithic architectures.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在微服务架构这个术语被提出之前，**面向服务的架构**（**SOA**）的概念在21世纪初变得流行，作为对单体架构提出的挑战的早期回应。
- en: SOA emphasizes encapsulating business functionality into independent services.
    Each service has a well-defined interface and communicates with other services.
    Standard protocols such as **Enterprise Service Bus** (**ESB**) are used for communication.
    The principles and concepts formalized in SOA to break down monoliths provided
    a basis for the future development of microservices.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: SOA 强调将业务功能封装到独立的服务中。每个服务都有一个明确的接口，并与其他服务通信。用于通信的标准协议如 **企业服务总线**（**ESB**）被使用。SOA
    中正式化的原则和概念为分解单体提供了未来微服务发展的基础。
- en: In 2011, the term microservices was brought up in software architecture workshops
    as the participants increasingly became aware of the emergence of a new architecture.
    In 2012, the term microservices was officially decided. *James Lewis* and *Fred
    George* were the major initial contributors to this style.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 2011年，随着参与者越来越意识到新架构的出现，微服务一词在软件架构研讨会上被提出。2012年，微服务一词正式确定。*詹姆斯·刘易斯* 和 *弗雷德·乔治*
    是这一风格的最初主要贡献者。
- en: Around the same time, companies such as *Netflix* and *Amazon* were also experimenting
    with similar architectural patterns. Netflix played a significant role in popularizing
    microservices through their adoption of the architecture for their scalable streaming
    platform. They shared their experiences and insights at various conferences and
    through blog posts, contributing to the growing interest and understanding of
    microservices.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在同一时期，像 *Netflix* 和 *Amazon* 这样的公司也在尝试类似的架构模式。Netflix 通过采用其可扩展流媒体平台的架构来推广微服务，发挥了重要作用。他们在各种会议和博客文章中分享了他们的经验和见解，从而促进了微服务日益增长的兴趣和理解。
- en: Next, we’re going to cover the key principles of microservices that shape their
    design and implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将介绍塑造微服务设计和实现的核心理念。
- en: Key principles
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心理念
- en: Primarily, a microservice should conform to the **single responsibility principle**
    (**SRP**) at the business capability or functionality level.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个微服务应该在业务能力或功能级别符合 **单一职责原则**（**SRP**）。
- en: Let’s consider the example we’ve used throughout this book about village households
    exchanging services with a contract. Functions such as record-keeping household
    information, negotiating the contract, exercising the contract, and notifying
    households are all microservice candidates.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑一下本书中使用的例子，关于村庄家庭通过合同交换服务的例子。记录家庭信息、谈判合同、执行合同和通知家庭等功能都是微服务的候选者。
- en: 'A microservice should have a well-defined responsibility that handles a single
    concern or business domain. For this example, we can define each microservice
    like so:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个微服务应该有一个明确的责任，处理单个关注点或业务领域。对于这个例子，我们可以这样定义每个微服务：
- en: '**Household service**: Masters the records of households'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家庭服务**：掌握家庭记录'
- en: '**Contract service**: Maintains the workflow of contract negotiation from drafted
    to fully exercised'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同服务**：维护从起草到完全执行的合同谈判工作流程'
- en: '**Notification service**: Sends proxy notification requests to email service
    providers'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：向电子邮件服务提供商发送代理通知请求'
- en: 'The details of how to break down a system into appropriate business domains
    will be discussed in depth in [*Chapter 8*](B21737_08.xhtml#_idTextAnchor289),
    where we’ll cover **domain-driven development** (**DDD**). However, some architectural
    smells indicate whether microservices have well-defined responsibilities:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将系统分解为适当的业务领域的细节将在 [*第八章*](B21737_08.xhtml#_idTextAnchor289) 中深入讨论，我们将涵盖 **领域驱动开发**（**DDD**）。然而，一些架构问题表明微服务是否有明确的责任：
- en: Each microservice shouldn’t be developed by more than one team of engineers.
    However, there could be exceptions, such as if responsibilities aren’t delegated
    to the teams. This takes us back to [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013)
    when **Conway’s law** was mentioned. It’s recommended to re-organize the teams
    so that each team has well-defined responsibilities and those responsibilities
    don’t overlap with other teams. The approach of re-organizing teams to aim for
    a better architecture is called the **Inverse** **Conway Maneuver**.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务不应该由超过一个工程师团队开发。然而，可能会有例外，例如如果责任没有分配给团队。这让我们回到了 [*第一章*](B21737_01.xhtml#_idTextAnchor013)，当时提到了
    **康威定律**。建议重新组织团队，以便每个团队都有明确的责任，并且这些责任不与其他团队重叠。重新组织团队以追求更好架构的方法被称为 **逆向** **康威行动**。
- en: A microservice shouldn’t communicate too often with another to complete its
    feature. What’s worse is if it invokes another microservice’s endpoints iteratively.
    This is likely to indicate a “leak” of the service boundary. Perhaps the part
    that this microservice needs from another should be brought back and owned by
    the microservice.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务不应该频繁地与其他微服务通信以完成其功能。更糟糕的是，如果它迭代地调用另一个微服务的端点。这很可能是服务边界“泄漏”的迹象。也许这个微服务需要从另一个微服务中获取的部分应该被带回并归这个微服务所有。
- en: A microservice shouldn’t depend on another microservice during a release. If
    a microservice is unavailable because other microservices are unavailable, this
    indicates a possible technical dependency.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务在发布过程中不应该依赖于另一个微服务。如果一个微服务因为其他微服务不可用而不可用，这表明可能存在技术依赖。
- en: Two microservices having inter-dependency in terms of exchanging messages could
    indicate that responsibilities haven’t been defined well enough. This is more
    of a problem if the communication is synchronous rather than asynchronous. If
    service A calls service B synchronously, when service B handles the call from
    service A, service B calls service A synchronously. This case would easily exhaust
    all threads in the request handler pool.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个微服务在交换消息方面存在相互依赖性可能表明责任定义得不够充分。如果是同步通信而不是异步通信，这个问题就更大。如果服务A同步调用服务B，当服务B处理来自服务A的调用时，服务B会同步调用服务A。这种情况很容易耗尽请求处理程序池中的所有线程。
- en: Microservices shouldn’t share code repositories, build processes, database schemas,
    and deployable artifacts with other microservices. Sharing them may hint at potential
    dependencies among microservices during build and release. The last thing you
    want is that your microservice can’t be deployed until another microservice is
    deployed.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微服务不应该与其他微服务共享代码库、构建过程、数据库模式以及可部署的工件。共享它们可能会在构建和发布期间暗示微服务之间可能存在依赖关系。你最不希望的是，你的微服务直到另一个微服务部署后才能部署。
- en: Having any of the symptoms discussed so far might suggest these microservices
    have emerged as **distributed monoliths**, which is worse than a traditional monolithic
    application.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 出现之前讨论的任何症状可能表明这些微服务已经变成了**分布式单体**，这比传统的单体应用程序更糟糕。
- en: Communication and integration
  id: totrans-64
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通信和集成
- en: Microservices communicate with each other through well-defined interfaces, namely
    **application programming interfaces** (**APIs**). The communication is either
    synchronous or asynchronous.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务通过定义良好的接口，即**应用程序编程接口**（**APIs**）相互通信。通信是同步的或异步的。
- en: 'The synchronous and asynchronous communications that occur via APIs are specified
    by the popular **Open API** and **Async API** standards, respectively:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 通过API发生的同步和异步通信分别由流行的**Open API**和**Async API**标准指定：
- en: Synchronous communication is often achieved by one microservice sending a request
    to another microservice and waiting for a response before continuing its execution.
    The APIs can be exposed as **Hypertext Transfer Protocol/Secure** (**HTTP/HTTPS)**,
    **Remote Procedure Call** (**RPC**), **Simple Object Access Protocol** (**SOAP**),
    and so on.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同步通信通常是通过一个微服务向另一个微服务发送请求并在继续执行之前等待响应来实现的。API可以公开为**超文本传输协议/安全**（**HTTP/HTTPS**）、**远程过程调用**（**RPC**）、**简单对象访问协议**（**SOAP**）等。
- en: Asynchronous communication usually involves messaging systems so that a microservice
    can send a message and immediately continue its execution. The other microservices
    receive the message when it’s available.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步通信通常涉及消息系统，以便微服务可以发送消息并立即继续其执行。其他微服务在消息可用时接收消息。
- en: '**Webhooks** are an alternative and popular way to communicate among microservices
    asynchronously without the need for messaging systems. Instead of responding to
    a request, a microservice usually sends a message to another microservice via
    the HTTP/REST protocol but doesn’t require a response to continue its execution.
    Webhooks usually require static configuration to be used with the target endpoints.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**Webhooks**是微服务之间异步通信的替代和流行方式，无需消息系统。而不是响应请求，微服务通常通过HTTP/REST协议向另一个微服务发送消息，但不需要响应以继续执行。Webhooks通常需要静态配置才能与目标端点一起使用。'
- en: 'Considering the example of the four potential microservices, they could communicate
    in the following way:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到四个潜在的微服务示例，它们可以以下方式进行通信：
- en: '![Figure 6.2 – An example of microservice communication](img/B21737_06_2.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图6.2 – 微服务通信的示例](img/B21737_06_2.jpg)'
- en: Figure 6.2 – An example of microservice communication
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.2 – 微服务通信的示例
- en: In the preceding diagram, **Contract service** needs to get household data from
    **Household service** to validate requests and manage their workflows. Then, **Contract
    service** sends requests to **Notification service** so that emails can be sent
    to households to inform them of any changes in their workflows.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，**合同服务**需要从**家务服务**获取家庭数据以验证请求并管理其工作流程。然后，**合同服务**向**通知服务**发送请求，以便向家庭发送电子邮件，通知他们工作流程中的任何变化。
- en: Scalability and resilience
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可伸缩性和弹性
- en: Microservice architecture provides inherent scalability due to its modular nature.
    Each microservice can be scaled independently based on its specific resource requirements.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构由于其模块化特性，提供了固有的可伸缩性。每个微服务可以根据其特定的资源需求独立扩展。
- en: 'In our example of microservices, the usage patterns can be hugely different.
    The following may apply:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的微服务示例中，使用模式可能大相径庭。以下是一些可能适用的情况：
- en: '**Household service**: Low traffic as there’s only a limited number of households'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家务服务**：由于家庭数量有限，交通流量较低'
- en: '**Contract service**: Most frequently used by users'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同服务**：用户最常使用的服务'
- en: '**Notification service**: Medium throughput of email requests but no strict
    latency requirements'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：电子邮件请求的处理量中等，但没有严格的延迟要求'
- en: Assuming this is a true reflection of its usage, we might need more instances
    of the **contract service** than any other service. Alternatively, other microservices
    can send asynchronous messages to request notifications, combined with queuing
    and batching mechanisms on the receiver side. Then, the **contract service** will
    be able to process a large volume of email requests in batches; other microservices
    don’t need to wait to get a response from the **contract service** to continue
    their processes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 假设这确实是其使用情况的真实反映，我们可能需要比其他任何服务更多的**合同服务**实例。或者，其他微服务可以发送异步消息请求通知，结合接收端的排队和批处理机制。然后，**合同服务**将能够批量处理大量的电子邮件请求；其他微服务不需要等待从**合同服务**获得响应才能继续其流程。
- en: The **household service** is requested often in getting household data from
    the **contract service**. In other words, the availability of the **household
    service** has become more important than that of other services. However, we can
    also consider having a local cache of household data in the **contract service**.
    The **household service** would need to send asynchronous messages when household
    data is created, updated, and deleted. It can broadcast messages to all interested
    microservices, though the messages can be kept in a **last-value queue** messaging
    structure so that other microservices can copy the data to their local storage.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**家务服务**经常被请求以从**合同服务**获取家庭数据。换句话说，**家务服务**的可用性已经比其他服务更重要。然而，我们也可以考虑在**合同服务**中保留家庭数据的本地缓存。当家庭数据被创建、更新和删除时，**家务服务**需要发送异步消息。它可以向所有感兴趣的微服务广播消息，尽管消息可以保持在**最后值队列**消息结构中，以便其他微服务可以将数据复制到它们的本地存储。'
- en: 'By combining these changes to address the concerns of scalability, performance,
    availability, and resilience, these services may communicate like so:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过结合这些变化来解决可伸缩性、性能、可用性和弹性的问题，这些服务可能会这样通信：
- en: '![Figure 6.3 – Example of updated microservice communication](img/B21737_06_3.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图6.3 – 更新后的微服务通信示例](img/B21737_06_3.jpg)'
- en: Figure 6.3 – Example of updated microservice communication
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.3 – 更新后的微服务通信示例
- en: Note that there are no synchronous request-response messages in the system anymore.
    This implies that each microservice can operate on its own without other microservices
    being available, increasing the resilience of the system. For instance, if **Household
    service** is down, maintenance operations regarding household data are unavailable,
    but all other microservices are still operational as they use the last known household
    kept in their local storage.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，系统中不再有同步请求-响应消息。这意味着每个微服务可以在没有其他微服务可用的情况下独立运行，从而提高了系统的弹性。例如，如果**家务服务**宕机，与家庭数据相关的维护操作将不可用，但所有其他微服务仍然可以正常运行，因为它们使用保存在本地存储中的最后已知家庭数据。
- en: However, it does rely more on messaging systems to provide features such as
    queuing, batching, and last-value queues. Messaging systems are typically configured
    and deployed as infrastructure so that they’re more resilient than microservices.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，它更多地依赖于消息系统来提供如队列、批处理和最后值队列等功能。消息系统通常配置和部署为基础设施，因此它们比微服务更具有弹性。
- en: Even with synchronous communication, there are techniques such as circuit breakers,
    bulkheads, and graceful degradation that can be employed to respond to failures
    gracefully.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有同步通信，也有如断路器、隔舱和优雅降级等技术可以用来优雅地应对故障。
- en: Imagine that it was just a monolithic application of four modules. In that case,
    these concerns can’t be addressed separately. Moreover, if the monolithic application
    is down, instead of having a partial system failure occur, we end up with a total
    system failure. No operation will be available.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，它只是一个由四个模块组成的单体应用。在这种情况下，这些问题无法单独解决。此外，如果单体应用出现故障，我们最终会面临整个系统故障，而不是部分系统故障。将没有任何操作可用。
- en: Maintainability and technology choices
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可维护性和技术选择
- en: Each microservice should have a code repository. A microservice focuses on a
    single responsibility at the business capability level, so it’s unlikely that
    a code change in one microservice would change something in another microservice.
    Moreover, keeping code changes small creates fewer chances of code conflicts among
    engineers, which also reduces the time required to review pull requests. The productivity
    of engineers increases as the code using the microservice style is more maintainable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 每个微服务都应该有一个代码仓库。微服务在业务能力层面专注于单一职责，因此一个微服务的代码更改不太可能改变另一个微服务中的内容。此外，保持代码更改小可以减少工程师之间的代码冲突机会，这也减少了审查拉取请求所需的时间。随着使用微服务风格的代码的可维护性提高，工程师的生产力也会增加。
- en: As each microservice has its own project, build script, and code repository,
    any choice that’s made regarding the use of technology and libraries is confined
    within the project. When it comes to using a new library as a dependency or a
    newer version of the library, engineers can try it in one microservice to start
    with, learn and get familiar with it, prove it’s working with one microservice,
    and then apply the proven approach to other microservices. A dedicated code repository
    for a microservice reduces many risks when experimenting with recent technologies.
    It also increases the chance of them being used in the system and keeps the system
    modern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 由于每个微服务都有自己的项目、构建脚本和代码仓库，因此关于使用技术和库的选择都限制在项目内部。当涉及到使用新库作为依赖项或库的新版本时，工程师可以从一个微服务开始尝试，学习和熟悉它，通过一个微服务证明其工作，然后将经过验证的方法应用到其他微服务中。为微服务专设的代码仓库在尝试新技术时减少了许多风险。它也增加了它们在系统中被使用的可能性，并保持了系统的现代化。
- en: Testing and quality assurance
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试和质量保证
- en: Testing microservices as black boxes has a smaller scope than testing a monolithic
    application. End-to-end test cases may involve a combination of behaviors from
    different modules.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将微服务作为黑盒进行测试的范围比测试单体应用的范围小。端到端测试用例可能涉及来自不同模块的行为组合。
- en: However, in microservice architecture, these modules would have become microservices.
    With well-defined APIs, it’s now possible to mock the behaviors of external interfaces
    so that the test case focuses on testing how it uses and responds to external
    APIs. This simplifies the test suite and each microservice focuses on testing
    its own behaviors instead. The exhaustive combination of behaviors from different
    microservices’ communication can be inferred and thus remove the need for comprehensively
    testing all business cases via end-to-end testing.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在微服务架构中，这些模块已经变成了微服务。有了定义良好的API，现在可以模拟外部接口的行为，从而使测试用例专注于测试它如何使用和响应外部API。这简化了测试套件，每个微服务都专注于测试自己的行为。从不同微服务通信的行为的穷举组合可以推断出来，从而消除了通过端到端测试全面测试所有业务案例的需要。
- en: Having said that, end-to-end testing may still be required to validate the overall
    communication among microservices while considering other factors such as URL
    routing, security controls, and API compatibility. Usually, end-to-end testing
    only contains critical business cases and focuses on overall system correctness.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在考虑URL路由、安全控制和API兼容性等其他因素的同时，端到端测试可能仍然需要验证微服务之间的整体通信。通常，端到端测试只包含关键业务案例，并关注整体系统正确性。
- en: As microservice communication using APIs is vital to ensure the overall system
    is functional, **contract testing** can be brought in to verify that these APIs
    are as per their specifications and that the microservices conform to them. This
    involves testing on both the consumer and provider sides of the APIs.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微服务使用API进行通信对于确保整体系统功能至关重要，**合同测试**可以引入以验证这些API是否符合其规范，以及微服务是否遵守这些规范。这涉及到对API的消费者和提供者两端的测试。
- en: Consumers create contract tests based on their expectations, simulating the
    interactions with the microservice via APIs. These tests verify that the consumer’s
    requirements are met. On the other hand, providers execute the consumer’s contract
    tests against their implementation. These tests ensure that the provider meets
    the API’s requirements and doesn’t introduce any breaking changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者根据他们的期望创建合同测试，通过API模拟与微服务的交互。这些测试验证消费者的需求是否得到满足。另一方面，提供者执行消费者对其实施的合同测试。这些测试确保提供者满足API的要求，并且不会引入任何破坏性变更。
- en: These improvements allow engineers to verify the quality of the system faster
    and thus reduce the time to market of changes. We’ll cover software testing in
    depth in [*Chapter 13*](B21737_13.xhtml#_idTextAnchor418).
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这些改进使得工程师可以更快地验证系统的质量，从而缩短更改的上市时间。我们将在[*第13章*](B21737_13.xhtml#_idTextAnchor418)中深入探讨软件测试。
- en: Deployment and infrastructure
  id: totrans-99
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署和基础设施
- en: One of the key characteristics of monolithic applications is the single major
    deployable artifact. In contrast, one microservice should have its own deployable
    artifact. This allows us to implement the practice of **continuous integration
    and continuous deployment** (**CI/CD**) and, as a result, reduce or even eliminate
    downtime during release.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 单体应用的一个关键特征是单个主要的可部署工件。相比之下，一个微服务应该有自己的可部署工件。这使我们能够实施**持续集成和持续部署（CI/CD**）的实践，从而在发布过程中减少或甚至消除停机时间。
- en: In our real-life example, and with the updated communications among microservices
    shown previously, each microservice can be released in isolation. Together with
    a rolling deployment procedure, it’s possible to keep the system operating while
    the release is ongoing.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的实际生活例子中，以及之前展示的微服务之间的更新通信，每个微服务都可以独立发布。结合滚动部署流程，可以在发布过程中保持系统运行。
- en: Moreover, each microservice can be deployed at its own cadence. There’s no need
    to wait for other microservices to be deployed like in the days of monolithic
    applications. This encourages engineers to deploy microservices if they’re ready
    to go, and thus speed up the time to market of software as products.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每个微服务都可以根据自己的节奏进行部署。无需像在单体应用时代那样等待其他微服务部署。这鼓励工程师在准备就绪时部署微服务，从而加快软件作为产品的上市时间。
- en: Microservice architecture often uses containerization technologies such as **Docker**
    and container orchestration platforms such as **Kubernetes**. Typically, building
    a microservice would generate its own Docker image, in which the dependencies
    and configurations are already set up. This results in consistent, repeatable,
    and predictable deployment, and each microservice has an isolated environment.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构通常使用如**Docker**这样的容器化技术以及如**Kubernetes**这样的容器编排平台。通常，构建微服务会生成其自己的Docker镜像，其中已经设置了依赖项和配置。这导致了一致、可重复和可预测的部署，并且每个微服务都有一个隔离的环境。
- en: Kubernetes provides a declarative approach to managing how microservices are
    deployed. The desired state of each microservice is defined using Kubernetes manifest
    files and includes the Docker image to be used as a running microservice. The
    diverse needs of each microservice, as illustrated in our real-life example, can
    be realized by declaring the number of replicas and resource requirements in these
    manifest files.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes提供了一种声明式方法来管理微服务的部署方式。每个微服务的期望状态是通过Kubernetes清单文件定义的，包括用作运行微服务的Docker镜像。正如我们在实际生活例子中所展示的，每个微服务的多样化需求可以通过在这些清单文件中声明副本数量和资源需求来实现。
- en: The replicas setting defines the desirable number of instances of the **household
    service** that are running. Kubernetes’ **Horizontal Pod Autoscalers** (**HPAs**)
    use this number to scale up and down based on resource utilization.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 复制设置定义了期望运行的**家庭服务**实例的数量。Kubernetes的**水平Pod自动扩展器（HPA**）使用这个数字根据资源利用率进行扩展和缩减。
- en: Kubernetes also provides mechanisms for microservices to discover and communicate
    with each other, such as **Domain Name System** (**DNS**) or environment variables.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: Kubernetes还提供了微服务发现和相互通信的机制，例如**域名系统**（**DNS**）或环境变量。
- en: Overall, these tools allow you to provision, scale, and manage the infrastructure
    needed to deploy and run microservices in an automated fashion.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些工具允许您以自动化的方式配置、扩展和管理部署和运行微服务所需的基础设施。
- en: Team organization
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 团队组织
- en: Microservice architecture goes hand in hand with the modern organization of
    teams. The system is broken down into microservices, and so should the teams.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务架构与现代团队组织紧密相连。系统被分解为微服务，团队也应如此。
- en: The golden rule is that a microservice should be owned by one – and only one
    – team. This team is responsible and accountable for the full development cycle
    of the designated microservice.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 金科玉律是，一个微服务应该由一个——而且只有一个——团队拥有。这个团队对指定微服务的整个开发周期负责并承担责任。
- en: The team should be given the autonomy to make small technical decisions within
    their scope while adhering to broader guidelines on the choice of technology to
    be used in the system.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 团队应在遵守关于系统中所用技术选择的更广泛指南的同时，在其范围内自主做出小的技术决策。
- en: Broader guidelines are there to maintain a certain degree of consistency among
    teams, such as the choice of commercial messaging, so that the firm reduces the
    complexity and cost of having too many technologies. Also, these guidelines provide
    agreed-upon principles and conventions to all teams, but each team has the power
    to decide how to execute and adhere to those guidelines.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有更广泛的指南来保持团队之间一定程度的连贯性，例如选择商业消息传递，这样公司可以减少拥有过多技术的复杂性和成本。此外，这些指南为所有团队提供了达成一致的原则和约定，但每个团队都有权决定如何执行和遵守这些指南。
- en: The drawbacks of microservices
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 微服务的缺点
- en: 'While microservices offer several benefits, such as modularity, maintainability,
    and testability, they also come with some drawbacks that must be considered:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然微服务提供了诸如模块化、可维护性和可测试性等好处，但它们也带来了一些必须考虑的缺点：
- en: '**Increased complexity**: Microservices architecture introduces a distributed
    system with more moving parts. Communication among microservices leads to additional
    complexity in development, testing, and deployment.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增加的复杂性**：微服务架构引入了一个具有更多移动部件的分布式系统。微服务之间的通信导致开发、测试和部署的额外复杂性。'
- en: Engineers will have to consider API versioning and compatibility. Introducing
    a breaking change in an API would break other microservices that stay in the older
    API versions. Maintaining a backward-compatible API or transitioning to a new
    major API version can be a challenge.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工程师必须考虑API版本化和兼容性。在API中引入破坏性更改将破坏仍停留在较旧API版本中的其他微服务。维护向后兼容的API或过渡到新的主要API版本可能是一个挑战。
- en: Multiple microservices are used in the end-to-end test suite, which means these
    services need to be operational before the end-to-end test cases can be run. To
    make things worse, each microservice is usually managed by its own team, which
    means there are multiple streams of changes happening at the same time. There
    are more reasons to fail end-to-end tests now. It could be that one of the microservices
    failed to start, a change in one microservice ended up not being compatible with
    other microservices, and so on. It may end up that the engineering teams spend
    a lot of energy fixing the end-to-end tests.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在端到端测试套件中使用了多个微服务，这意味着在运行端到端测试用例之前，这些服务必须处于运行状态。更糟糕的是，每个微服务通常由其自己的团队管理，这意味着同时有多个变更流在进行。现在有更多失败端到端测试的原因。可能是某个微服务未能启动，一个微服务的更改最终与其它微服务不兼容，等等。最终，工程团队可能花费大量精力来修复端到端测试。
- en: Microservices architecture requires a more complex infrastructure, including
    service routing, load balancing, and container orchestration. This infrastructure
    as configuration can also act as a boilerplate as each microservice may have similar
    configurations but only differ in a few sections. The overhead of managing and
    maintaining this infrastructure can be significant, especially for smaller organizations
    or teams.
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 微服务架构需要更复杂的基础设施，包括服务路由、负载均衡和容器编排。这种基础设施作为配置也可以作为样板，因为每个微服务可能具有相似的配置，但只在少数部分有所不同。管理和维护这种基础设施的开销可能很大，尤其是对于较小的组织或团队。
- en: '**Network latency and overhead**: Breaking down a monolithic application into
    microservices implies local function invocations become remote. This can introduce
    latency and performance issues, especially if the services are geographically
    distributed.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络延迟和开销**：将单体应用分解为微服务意味着本地函数调用变为远程调用。这可能会引入延迟和性能问题，尤其是如果服务在地理上分布的话。'
- en: The overhead of network communication, including protocols, serialization, and
    deserialization, can impact the system’s overall performance.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 网络通信的开销，包括协议、序列化和反序列化，可能会影响系统的整体性能。
- en: '**Distributed data management**: In a microservices architecture, data is often
    distributed across multiple microservices, which brings the challenges of keeping
    data manageable and consistent. Data could be split between two microservices,
    and there could be data that’s represented differently in multiple microservices.
    Worse, there could be data among microservices that isn’t consistent, so it’s
    hard to understand the overall picture.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式数据管理**：在微服务架构中，数据通常分布在多个微服务之间，这带来了保持数据可管理和一致性的挑战。数据可能分布在两个微服务之间，也可能在多个微服务中用不同的方式表示。更糟糕的是，微服务之间可能存在不一致的数据，这使得理解整体情况变得困难。'
- en: '**Monitoring and observability**: Tracing a business journey that travels through
    multiple microservices can be more challenging compared to monolithic applications.
    There are techniques to overcome this problem, but they require additional tooling
    and effort. These techniques will be covered in [*Chapter 11*](B21737_11.xhtml#_idTextAnchor358).'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和可观察性**：与单体应用相比，追踪穿越多个微服务的业务旅程可能更具挑战性。有一些技术可以克服这个问题，但它们需要额外的工具和努力。这些技术将在[*第11章*](B21737_11.xhtml#_idTextAnchor358)中介绍。'
- en: '**Fine-grained, infrequent, on-demand, or small tasks**: The overhead of microservices
    architecture could outweigh the benefits if you’re running specific processes.
    For example, if a summary report of user activities needs to be exported as a
    file and uploaded to an SFTP folder monthly, it can hardly justify standing up
    a long-running microservice that’s only used once per month. Similar situations
    apply to small tasks that are triggered upon request.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**细粒度、不频繁、按需或小型任务**：如果你正在运行特定的流程，微服务架构的开销可能会超过其带来的好处。例如，如果需要将用户活动摘要报告导出为文件并每月上传到SFTP文件夹，那么很难证明建立一个每月只使用一次的长期运行微服务的合理性。类似的情况也适用于按需触发的任务。'
- en: There’s an alternative approach to microservices architecture when the scope
    is too small to justify the overhead. We’ll discuss this in the next section.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当范围太小，无法证明开销的合理性时，微服务架构有另一种方法。我们将在下一节中讨论这一点。
- en: Nanoservices
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纳微服务
- en: Nanoservices architecture, as the name suggests, takes the principles of microservices
    and makes them even more fine-grained. Microservices focus on breaking down monolithic
    applications into small, independent, and loosely coupled services, with one service
    for one business capability. Nanoservices take this concept even further by decomposing
    the system into extremely fine-grained, single-purpose components.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，纳微服务架构将微服务的原则进一步细化。微服务专注于将单体应用分解为小型、独立和松散耦合的服务，每个服务对应一个业务能力。纳微服务通过将系统分解为极其细粒度、单一用途的组件，将这一概念进一步深化。
- en: Nanoservices are designed to handle highly specific, autonomous, independent,
    and atomic functionalities. A nanoservice is often responsible for a single task
    or a tiny piece of logic within the overall system. Each nanoservice has a deployable
    artifact and can be deployed independently. Some of these nanoservices, when combined,
    can be seen as microservices.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 纳微服务旨在处理高度特定、自主、独立和原子化的功能。纳微服务通常负责整体系统中的单个任务或一小块逻辑。每个纳微服务都有一个可部署的工件，并且可以独立部署。其中一些纳微服务组合起来可以被视为微服务。
- en: 'Using the previous example regarding microservices, the **household service**
    can be broken down into several nanoservices:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用关于微服务的先前示例，**家庭服务**可以被分解为几个纳微服务：
- en: Get a Household record by name.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过名称获取家庭记录。
- en: Create or update a Household record.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建或更新一个家庭记录。
- en: These two nanoservices share the same database schema, while only one of them
    focuses on returning a Household record by name. The other nanoservice focuses
    on performing a create/update operation and sending asynchronous messages after
    a Household record is updated.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个纳米服务共享相同的数据库模式，而只有一个专注于通过名称返回家庭记录。另一个纳米服务专注于执行创建/更新操作，并在家庭记录更新后发送异步消息。
- en: Benefits
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优点
- en: Nanoservices have much smaller code bases, fewer dependencies, and less resource
    utilization (CPU, memory, and disk) compared to microservices. This reduced footprint
    results in simpler deployment and configurations. Scaling nanoservices is efficient
    as it only concerns the needs of one function.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 与微服务相比，纳米服务拥有更小的代码库、更少的依赖和更少的资源利用（CPU、内存和磁盘）。这种减少的足迹导致部署和配置更加简单。扩展纳米服务是高效的，因为它只涉及一个函数的需求。
- en: Since nanoservices require less coordination and communication between each
    other, a nanoservice can be seen as a plumbing unit that only focuses on inputs,
    processes, and output.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于纳米服务之间需要的协调和通信较少，纳米服务可以被看作是一个只关注输入、处理和输出的管道单元。
- en: The reduced complexity and overhead of nanoservices can make them particularly
    well-suited for resource-constrained environments, real-time systems, or scenarios
    where fault tolerance and rapid scaling are critical.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 纳米服务的简化复杂性和开销使它们特别适合资源受限的环境、实时系统或对容错和快速扩展至关重要的场景。
- en: Drawbacks
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缺点
- en: Even though managing a nanoservice is easier than managing a microservice, a
    system that’s been broken down into nanoservices has a significantly higher number
    of services to manage. This high number may outweigh the ease of managing one
    nanoservice.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 即使管理纳米服务比管理微服务更容易，但将系统分解成纳米服务后，需要管理的服务数量显著增加。这个数量可能超过了管理单个纳米服务的便利性。
- en: The high number of nanoservices may bring significant network communication
    and collaboration challenges. The small resource footprint of one nanoservice
    may not translate well regarding overall resource consumption (CPU, memory, and
    disks).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 纳米服务数量众多可能会带来显著的网络安全和协作挑战。单个纳米服务的小资源足迹在整体资源消耗（CPU、内存和磁盘）方面可能并不理想。
- en: Moreover, some nanoservices may share the same database schema for different
    operations. In our example of the read and update nanoservices for the **household
    service**, they share the same database schema. If the schema needs to evolve,
    there’s additional complexity regarding how to apply the change in the database
    schema, and then the changes in both nanoservices. It’s due to these fragmental
    concerns that some people would consider nanoservices architecture an anti-pattern.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，一些纳米服务可能为了不同的操作而共享相同的数据库模式。以我们关于**家庭服务**的读取和更新纳米服务的例子来说，它们共享相同的数据库模式。如果模式需要演进，那么如何在数据库模式中应用变更，以及随后在两个纳米服务中的变更，将带来额外的复杂性。正因为这些碎片化的担忧，有些人可能会认为纳米服务架构是一种反模式。
- en: Maintaining data consistency and coherence across a large number of highly autonomous
    nanoservices can be a significant challenge that requires careful design and coordination
    mechanisms. Imagine that there’s one nanoservice for the create operation and
    another for the update operation; keeping the validation logic of the two nanoservices
    consistent can be a challenge.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在大量高度自治的纳米服务之间维护数据一致性和连贯性可能是一个重大的挑战，需要仔细的设计和协调机制。想象一下，有一个纳米服务用于创建操作，另一个用于更新操作；保持两个纳米服务的验证逻辑一致可能是一个挑战。
- en: Deciding between microservices and nanoservices
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在微服务和纳米服务之间做出决定
- en: The decision of whether to have one microservice or multiple nanoservices is
    a balancing act on different overheads. In general, nanoservices work better if
    the function is simple and isolated. Any effort to coordinate with other nanoservices
    should be considered carefully.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 是否采用一个微服务还是多个纳米服务，是在不同开销之间进行权衡的决定。一般来说，如果功能简单且独立，纳米服务会表现得更好。任何与其他纳米服务协调的努力都应该仔细考虑。
- en: In our previous example, the **notification service** has a simple objective
    compared to the other services. It merely translates an internal event into an
    email that contains an address and requests an email service provider to send
    the email. This is a suitable candidate to be a nanoservice as its task is simple.
    If we tweak the **notification service** so that it accepts email requests of
    a universal structure, then it can be an autonomous and independent nanoservice
    that doesn’t depend on other services.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的例子中，**通知服务**与其他服务相比目标简单。它仅仅是将内部事件转换为包含地址的电子邮件，并请求电子邮件服务提供商发送电子邮件。这是一个合适的纳米服务候选者，因为其任务简单。如果我们调整**通知服务**，使其接受具有通用结构的电子邮件请求，那么它就可以成为一个自主且独立的纳米服务，不依赖于其他服务。
- en: The overhead of managing a high number of nanoservices is still a concern to
    many engineers. However, the emergence of serverless architecture may have addressed
    this concern by having nanoservices managed by cloud providers. Next, we’ll consider
    serverless architecture.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 管理大量纳米服务的开销仍然是许多工程师的担忧。然而，无服务器架构的出现可能通过让云服务提供商管理纳米服务来解决了这个问题。接下来，我们将考虑无服务器架构。
- en: Serverless
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无服务器
- en: Serverless architecture is a computing style in which engineers are no longer
    concerned with capacity planning, configuration, management, maintenance, resilience,
    scalability, physical servers, or virtual servers. There are still servers running
    but they’re abstracted away.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构是一种计算风格，在这种风格中，工程师不再需要关注容量规划、配置、管理、维护、弹性、可伸缩性、物理服务器或虚拟服务器。尽管仍然有服务器在运行，但它们被抽象化了。
- en: Deploying web services used to be an expensive process. Physical server machines
    (the **bare-metal** aspect), network cables, and other accessories need to be
    purchased with the correct amount of storage, memory, and bandwidth. Operational
    engineers need to install and keep them on-site in a data center. Physical servers
    need to be set up correctly and connected to the network. Only then can web services
    be deployed to and hosted on these servers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 部署网络服务曾经是一个昂贵的过程。需要购买物理服务器机器（**裸机**方面）、网络电缆和其他配件，并确保有正确的存储、内存和带宽。操作工程师需要将它们安装并保存在数据中心现场。物理服务器需要正确设置并连接到网络。只有这样，网络服务才能部署到并托管在这些服务器上。
- en: Bare-metal servers come with not only the initial cost of purchase but also
    ongoing costs such as electricity, renting from data centers, and visits by engineers
    to keep your server up and online every time. There are also security concerns
    as these physical machines are at risk of being damaged or stolen.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 裸机服务器不仅包括购买时的初始成本，还包括持续成本，如电力、从数据中心租赁以及工程师的访问，以确保服务器始终保持在线状态。此外，由于这些物理机器可能遭到损坏或被盗，还存在安全问题。
- en: Most engineers aren’t server specialists. Companies may need to either train
    their engineers to become system administrators, use hardware and network specialist
    contractors, or hire these specialist engineers to work with the application.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数工程师不是服务器专家。公司可能需要要么培训他们的工程师成为系统管理员，要么使用硬件和网络专业承包商，或者雇佣这些专业工程师与应用程序一起工作。
- en: Every time the system needs to scale, it requires buying new machines or upgrading
    existing ones. They need to be configured so that they fit the other machines
    and be used by the application. Sometimes, purchasing and delivering the new machines
    takes time, so scaling doesn’t happen when it’s needed the most by the system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 每当系统需要扩展时，都需要购买新机器或升级现有机器。它们需要配置，以便与其他机器兼容并被应用程序使用。有时，购买和交付新机器需要时间，因此当系统最需要扩展时，扩展并没有发生。
- en: Today, bare-metal servers are still the main choice for systems that require
    ultra-low latency and high-frequency processing, such as trading systems.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 今天，裸机服务器仍然是需要超低延迟和高频处理系统的首选，例如交易系统。
- en: Serverless architecture aims to solve the issues from the days of bare-metal
    servers. Let’s explore how.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构旨在解决裸机服务器时代的问题。让我们看看它是如何做到的。
- en: The concepts of serverless architecture are deeply rooted in distributed computing.
    The history of evolution can be traced back to **grid computing**, in which computing
    tasks were distributed across a network of machines.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构的概念深深植根于分布式计算。其演化的历史可以追溯到**网格计算**，其中计算任务被分布在一个机器网络中。
- en: Serverless architecture wasn’t popular in commercial systems until *Amazon*
    launched **Amazon Web Services** (**AWS**) in 2006\. AWS provides a set of services
    for businesses to access computing resources over the internet (the **cloud**).
    Initially, AWS offered **Elastic Compute Cloud** (**EC2**) as virtual servers
    to run computation and **Simple Storage Service** (**S3**) as distributed file
    storage.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构在商业系统中并不流行，直到2006年*亚马逊*推出了**亚马逊网络服务**（**AWS**）。AWS为商业提供了一套服务，使企业可以通过互联网（**云**）访问计算资源。最初，AWS提供了**弹性计算云**（**EC2**）作为虚拟服务器来运行计算，以及**简单存储服务**（**S3**）作为分布式文件存储。
- en: In 2010, *Microsoft* launched **Azure** and offered cloud services such as AWS,
    including virtual servers and storage. In 2011, *Google* launched **Google Cloud
    Platform** (**GCP**) to compete with Microsoft and Amazon when it came to cloud
    services. AWS, Azure, and GCP remain the three most popular cloud services nowadays,
    and cloud services are also provided by big companies such as *IBM*, *Oracle*,
    *Alibaba*, and *Tencent*. With the variety of cloud service offerings available,
    serverless architecture has come to fruition and is still evolving.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 2010年，*微软*推出了**Azure**，并提供了包括虚拟服务器和存储在内的云服务。2011年，*谷歌*推出了**谷歌云平台**（**GCP**），以在云服务方面与微软和亚马逊竞争。AWS、Azure和GCP仍然是当今最受欢迎的三个云服务，大公司如*IBM*、*Oracle*、*阿里巴巴*和*腾讯*也提供了云服务。随着云服务提供的多样化，无服务器架构得以实现，并且仍在不断发展。
- en: By using cloud services to run applications, the users are the **tenants** who
    subscribe to the service. Tenants rent and use the computing resources in the
    cloud on an on-demand basis, and hence the cost is arguably more flexible. Cloud
    services replace the need to procure and provision computer hardware and host
    it in a data center.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用云服务来运行应用程序，用户是订阅服务的**租户**。租户按需租用和使用云中的计算资源，因此成本更具灵活性。云服务取代了采购、配置计算机硬件并在数据中心托管的需求。
- en: There are four major categories of serverless services provided by cloud service
    providers. Let’s take a closer look.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商提供了四种主要的无服务器服务类别。让我们更详细地了解一下。
- en: Infrastructure-as-a-Service (IaaS)
  id: totrans-158
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础设施即服务（IaaS）
- en: IaaS offers computing resources in the cloud such as virtual servers, storage,
    and networking on an on-demand basis. It’s like renting an empty space where tenants
    must configure everything in it.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: IaaS提供基于按需的云计算资源，如虚拟服务器、存储和网络。这就像租用一个空旷的空间，租户必须配置其中的所有内容。
- en: Users are given an administrator account so that they can set up the infrastructure
    via a management console graphical interface, **command-line interface** (**CLI**),
    or declarative configuration tools such as **Terraform**.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 用户被赋予管理员账户，以便他们可以通过管理控制台图形界面、**命令行界面**（**CLI**）或如**Terraform**之类的声明性配置工具来设置基础设施。
- en: 'The following typical infrastructures are offered:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些典型的基础设施提供：
- en: '**Virtual servers**: These are virtualized machines that can run anything set
    up by tenants. Tenants need to specify basic requirements such as CPU, RAM, disk
    spaces, and network addresses to reach the servers.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟服务器**：这些是虚拟化的机器，可以运行租户设置的任何内容。租户需要指定基本需求，例如CPU、RAM、磁盘空间和网络地址，以便访问服务器。'
- en: '**Secrets management**: There are various situations where we need to keep
    sensitive data as configuration for an application. This varies from encryption
    keys and API keys to foreign systems or credentials to access a database. With
    IaaS, these secrets can be managed separately and are injected into the runtime
    of the application that runs in, for example, virtual servers. As a result, these
    secrets can be viewed and managed by fewer people and be abstracted out of the
    code base. The cloud providers also offered advanced features such as key rotation
    and expiration for extra security.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密钥管理**：在许多情况下，我们需要将敏感数据作为应用程序的配置来保存。这包括加密密钥和API密钥，以及访问数据库的外部系统或凭证。在IaaS中，这些密钥可以单独管理，并注入到运行在虚拟服务器中的应用程序的运行时中。因此，这些密钥可以由更少的人查看和管理，并从代码库中抽象出来。云提供商还提供了如密钥轮换和过期等高级功能，以提供额外的安全性。'
- en: '**Distributed file storage**: Cloud service providers offer scalable and durable
    storage services that can be accessed by applications. They allow tenants to store
    files of almost any size, and their storage scales as needed. They can replicate
    the files to multiple locations for redundancy and recovery purposes. They also
    support file versioning, so it’s possible to retrieve previous versions of the
    same file object. Finally, they support fine-grained access control to the file
    and grant time-limited access to specific files for download purposes.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式文件存储**：云服务提供商提供可扩展且持久的存储服务，这些服务可以被应用程序访问。它们允许租户存储几乎任何大小的文件，并且存储容量会根据需要扩展。它们可以将文件复制到多个位置，以实现冗余和恢复目的。它们还支持文件版本控制，因此可以检索同一文件对象的先前版本。最后，它们支持对文件的细粒度访问控制，并为特定文件提供下载目的的限时访问。'
- en: '**Databases**: Managed database services are a big category since there’s a
    diverse range of choices. Most cloud providers offer relational and NoSQL databases,
    while some of them offer special types of databases, such as data warehouses.
    There’s also a list of vendors and versions available that provides a smooth path
    for applications to move from bare metal to the cloud. They provide managed services
    that handle infrastructure provisioning, upgrades, scaling, replication, failover,
    and monitoring. Some of them provide advanced features such as data encryption
    for handling sensitive information.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库**：由于有各种各样的选择，托管数据库服务是一个大类别。大多数云服务提供商提供关系型数据库和非关系型数据库，而其中一些还提供特殊类型的数据库，如数据仓库。还有一个供应商和版本列表，为应用程序从裸机迁移到云提供了平滑的路径。它们提供托管服务，处理基础设施配置、升级、扩展、复制、故障转移和监控。其中一些提供高级功能，如数据加密，用于处理敏感信息。'
- en: '**Messaging**: Like databases, managed messaging services also have a big category
    of services per cloud provider. There are four main types of messaging available.
    The first type is a simple queuing service where a message is sent from a sender
    to a recipient. The second type is the **Publish/Subscribe** (**Pub/Sub**) pattern,
    where a message is published to a topic via a broker, and all subscribers to the
    topic receive the message. The third type is streaming, where messages are consumed
    as a continuous flow as they’re sent. The last type is specialized messaging services,
    which target specific use cases such as emails and mobile application notifications.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**消息传递**：与数据库类似，托管消息传递服务在云服务提供商那里也是一个大类别。有四种主要的消息传递类型。第一种是一个简单的队列服务，其中消息从发送者发送到接收者。第二种是**发布/订阅**（**Pub/Sub**）模式，其中消息通过代理发布到主题，所有订阅该主题的订阅者都会收到该消息。第三种是流式传输，其中消息在发送时作为连续的流被消费。最后一种类型是专门的消息传递服务，针对特定的用例，如电子邮件和移动应用程序通知。'
- en: Cloud providers abstract away the complexity of setting up and managing the
    messaging infrastructure required. These managed services scale up and down on
    demand and take care of replication, security, and monitoring concerns.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 云服务提供商抽象化了设置和管理所需的消息基础设施的复杂性。这些托管服务根据需求进行扩展和缩减，并处理复制、安全和监控问题。
- en: In the next section, we’ll discuss another big category of services that serve
    as a platform instead of infrastructure.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论另一个大类别服务，这些服务作为平台而不是基础设施提供服务。
- en: Platform-as-a-Service (PaaS)
  id: totrans-169
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台即服务（PaaS）
- en: PaaS provides engineers with a cloud platform so that they can develop, run,
    and manage applications without setting up the infrastructure themselves. Engineers
    still need to configure and manage their applications, runtimes, data, and services.
    The details of the configuration are abstracted away and specified in a declarative
    way. The cloud provider takes care of the lower-level concerns, such as hardware,
    operating systems, and network settings.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: PaaS为工程师提供了一个云平台，这样他们就可以在不自己设置基础设施的情况下开发、运行和管理应用程序。工程师仍然需要配置和管理他们的应用程序、运行时、数据和服务。配置的细节被抽象化并以声明性方式指定。云服务提供商负责处理底层问题，例如硬件、操作系统和网络设置。
- en: These services support specific programming languages and frameworks that enable
    engineers to focus on the application itself. The service handles the details
    of provisioning servers, load balancing, scaling, and monitoring.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这些服务支持特定的编程语言和框架，使工程师能够专注于应用程序本身。服务处理提供服务器、负载均衡、扩展和监控的细节。
- en: Going further with this, if we don’t want to build systems on a platform, perhaps
    we can simply use and integrate with the existing software available. This is
    the topic of the next section.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 进一步来说，如果我们不想在平台上构建系统，也许我们可以简单地使用并集成现有的软件。这是下一节的主题。
- en: Software-as-a-Service (SaaS)
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 软件即服务（SaaS）
- en: SaaS offers software that’s ready to be used by end users or integrated with
    applications. This service involves tenants just using some software without having
    to code, manage environments, or even possess technical knowledge. Services in
    this category range from complete usable software solutions in the cloud and no-code
    application building to headless systems that can integrate with applications
    via APIs. In the latter case, tenants are still expected to run their applications
    via other means and set up a network connection to the SaaS service.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SaaS提供的是供最终用户使用或与应用程序集成的软件。这项服务涉及租户只需使用一些软件，无需编写代码、管理环境，甚至不需要具备技术知识。这个类别的服务范围从云中的完整可使用软件解决方案和无代码应用程序构建到可以通过API与应用程序集成的无头系统。在后一种情况下，租户仍然需要通过其他方式运行他们的应用程序，并设置与SaaS服务的网络连接。
- en: This category has the largest variety of software applications. Most companies
    would use at least one SaaS service, and a lot of companies aim to provide SaaS
    services in this open space.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类别拥有最多样化的软件应用。大多数公司至少会使用一种SaaS服务，许多公司都希望在这个开放空间中提供SaaS服务。
- en: Using SaaS gives us a holistic package of business functionalities. This is
    particularly popular when the business functionalities are necessities but not
    at the core of the organization.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 使用SaaS（软件即服务）为我们提供了一整套业务功能。当业务功能是必需的但不是组织核心时，这种情况尤为流行。
- en: Now that we’ve discussed bigger units, such as software, we’re going to look
    at smaller units, which are functions in the serverless architecture.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了更大的单元，比如软件，接下来我们将看看更小的单元，即无服务器架构中的函数。
- en: Function-as-a-Service (FaaS)
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数即服务（FaaS）
- en: FaaS allows engineers to write code and deploy it as a function, typically when
    reacting to events or triggers. These functions don’t store states themselves,
    but they can make use of other resources, such as file storage and databases.
    Engineers don’t need to manage any infrastructure. They’re intended to be reusable
    functions so that higher-order functions can be built on top of other functions.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: FaaS（函数即服务）允许工程师编写代码并将其作为函数部署，通常是在响应事件或触发器时。这些函数本身不存储状态，但它们可以利用其他资源，例如文件存储和数据库。工程师不需要管理任何基础设施。它们旨在作为可重用函数，以便在其他函数之上构建高级函数。
- en: Cloud providers scale the runtime environment that’s executing a function based
    on workload. They also charge based on the usage of the function, which is optimized
    for cost. Note that some of the services have restrictions, such as maximum execution
    time, memory usage, and the number of concurrent processes.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 云服务提供商根据工作负载对正在执行函数的运行时环境进行扩展。他们还根据函数的使用情况收费，这有助于优化成本。请注意，一些服务有限制，例如最大执行时间、内存使用量和并发进程数。
- en: With these services, we can drop our functions as code into the cloud environment
    for execution. The cloud providers will do the rest for us.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些服务，我们可以将我们的函数作为代码放入云环境中执行。云服务提供商将为我们完成剩余的工作。
- en: With that, we’ve covered the four categories of cloud computing services that
    enable serverless architecture. Next, we’re going to delve into how to build systems
    using these services. We’ll discuss the benefits of these services and explain
    how to use them to create a modern, scalable, and easy-to-maintain system.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经涵盖了支持无服务器架构的云计算服务的四个类别。接下来，我们将深入探讨如何使用这些服务来构建系统。我们将讨论这些服务的优势，并解释如何使用它们来创建一个现代、可扩展且易于维护的系统。
- en: Benefits
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好处
- en: 'The core value of serverless architecture is infrastructure concerns being
    abstracted and implemented by cloud providers. Here are the benefits that come
    with it:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 无服务器架构的核心价值是基础设施问题被云提供商抽象化和实现。以下是随之而来的好处：
- en: '**Scalability**: Serverless architecture can automatically scale resources
    based on demand. When the application is under a heavy workload, the cloud provider
    dynamically allocates resources to handle the increased load and to ensure optimal
    performance. When the workload decreases or becomes idle, resources are scaled
    down, resulting in optimized cost and efficient resource utilization.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可伸缩性**：无服务器架构可以根据需求自动扩展资源。当应用程序承受重负载时，云服务提供商会动态分配资源来处理增加的负载并确保最佳性能。当工作负载减少或变为空闲时，资源会缩减，从而实现优化成本和有效资源利用。'
- en: '**Cost efficiency**: Cloud providers offer a pay-per-use pricing model where
    tenants are billed by their actual usage. This pricing model optimizes costs and
    eliminates the need to purchase and maintain idle resources. This is attractive
    for organizations looking for cost-efficient solutions, particularly startups
    and small companies.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本效益**：云服务提供商提供按使用付费的定价模式，租户根据其实际使用情况付费。这种定价模式优化了成本，消除了购买和维护闲置资源的需求。这对寻找成本效益解决方案的组织来说很有吸引力，尤其是初创公司和中小企业。'
- en: '**Time to market**: Since it’s a lot quicker to spin up infrastructure to host
    applications, engineers can focus their time on developing business functions
    and specific functions. Plus, infrastructure settings now have a more declarative
    configuration than them having to work on the details of each infrastructure component.
    This results in a faster development and deployment cycle, the ability to continuously
    deploy changes, and a shorter time to market.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上市时间**：由于启动基础设施以托管应用程序的速度很快，工程师可以将时间集中在开发业务功能和特定功能上。此外，基础设施设置现在比处理每个基础设施组件的细节具有更声明性的配置。这导致开发部署周期更快，能够持续部署更改，并且上市时间更短。'
- en: '**Adaptability and migration**: The range of available services allows engineers
    to host from big applications to small functions.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**适应性和迁移**：可用的服务范围允许工程师从大型应用程序托管到小型功能。'
- en: A lot of companies migrate their systems from bare-metal monolithic applications
    to virtual servers in the cloud as the first step is to break them down into microservices
    and functions. This is more cost-efficient and quicker than breaking down monolithic
    applications first and moving to virtual servers afterward due to the comprehensive
    support cloud providers offer regarding infrastructure services.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 许多公司将其系统从裸机单体应用程序迁移到云中的虚拟服务器作为第一步，即将其分解为微服务和功能。由于云服务提供商在基础设施服务方面的全面支持，这种方法比首先分解单体应用程序然后迁移到虚拟服务器更经济高效且更快。
- en: On the other side of the spectrum, there’s a lot of FaaS support to just write
    a small function to perform a small task. The wide range of support from cloud
    providers concerning the size of the application makes it quite easy for engineers
    to adapt and migrate existing systems toward serverless architectures.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在另一端，有许多FaaS支持，只需编写一个小函数来执行小任务。云服务提供商在应用程序大小方面的广泛支持使得工程师适应和迁移现有系统到无服务器架构变得相当容易。
- en: '**Diverse support for business domains**: Serverless architecture is suitable
    for event-driven and highly scalable systems. It’s commonly used for building
    microservices, real-time processing systems, web and mobile backends, **Internet
    of Things** (**IoT**) applications, and more.'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持多种业务领域**：无服务器架构适用于事件驱动和高度可伸缩的系统。它通常用于构建微服务、实时处理系统、Web和移动后端、**物联网**（**IoT**）应用程序等。'
- en: There are many ready-to-use SaaS services that engineers could focus on in their
    business domains. For example, Amazon **Simple Email Service** (**SES**) can be
    used to send emails to customers, Azure Notification Hub can be used to send push
    notifications to mobile devices, and Google Cloud IAM can provide **multi-factor
    authentication** (**MFA**) and reCAPTCHA to verify users’ identities.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有许多现成的SaaS服务，工程师可以在他们的业务领域集中精力。例如，Amazon **简单电子邮件服务**（**SES**）可用于向客户发送电子邮件，Azure通知中心可用于向移动设备发送推送通知，而Google
    Cloud IAM可以提供**多因素认证**（**MFA**）和reCAPTCHA来验证用户的身份。
- en: However, it’s important to note that serverless architecture might not be suitable
    for all use cases. Also, many services are provided by each cloud provider, so
    you need to err on the side of caution to ensure a suitable service is chosen
    to meet the requirements.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，需要注意的是，无服务器架构可能并不适合所有用例。此外，每个云服务提供商都提供了许多服务，因此您需要谨慎行事，以确保选择合适的服务来满足需求。
- en: Cautions
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**注意事项**'
- en: 'While serverless architecture offers numerous benefits, there are important
    drawbacks to consider when adopting this approach:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然无服务器架构提供了许多好处，但在采用这种方法时，还有一些重要的缺点需要考虑：
- en: '**Cold start latency**: FaaS functions are initiated on-demand, meaning that
    when a function is triggered for the first time or after a period of being idle,
    it might take a while to start up. This delay is known as a “cold start” and occurs
    while the cloud provider provisions the necessary resources on the fly.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷启动延迟**：FaaS函数是按需启动的，这意味着当函数首次被触发或经过一段时间的空闲后，可能需要一段时间才能启动。这种延迟被称为“冷启动”，发生在云服务提供商动态分配必要资源的过程中。'
- en: If the function is triggered infrequently, which often causes cold starts, latency
    is increased for normal requests. If the application is expected to respond without
    noticeable delays, then PaaS or virtual servers should be used instead.
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果函数被触发的频率不高，这通常会导致冷启动，那么正常请求的延迟会增加。如果应用程序需要无明显的延迟响应，那么应该使用PaaS或虚拟服务器。
- en: '**Vendor lock-in**: Cloud providers offer a wide range of services, while a
    lot of them provide proprietary APIs, frameworks, runtime environments, and even
    languages. While it’s handy to have support from cloud providers in various areas,
    it’s easy to rely too heavily on a specific cloud provider. This causes vendor
    lock-in, which makes it challenging to migrate to another provider.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**供应商锁定**：云服务提供商提供了一系列服务，其中许多提供了专有的API、框架、运行时环境和甚至语言。虽然从云服务提供商在各个领域的支持是方便的，但过度依赖特定的云服务提供商是很容易发生的。这导致了供应商锁定，使得迁移到另一个提供商变得具有挑战性。'
- en: This creates barriers to migrating to another cloud provider or switching back
    to bare-metal infrastructure. While most cloud providers keep their pricing competitive,
    many companies find it crucial to have the ability to migrate if the situation
    arises. In response to this, some companies choose to use multi-cloud architecture
    with data synchronization processes between different cloud platforms.
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这为迁移到另一个云服务提供商或切换回裸金属基础设施设置了障碍。虽然大多数云服务提供商保持其定价具有竞争力，但许多公司发现，如果出现这种情况，拥有迁移能力至关重要。为此，一些公司选择使用多云架构，并在不同的云平台之间进行数据同步过程。
- en: '**Function granularity**: Decomposing an application into smaller functions
    appropriately is a key aspect of serverless architecture. However, breaking down
    functionality into excessively fine-grained FaaS functions can result in increased
    overhead due to the invocation and coordination of numerous functions, leading
    to release dependency, higher costs, higher latency, and more complex systems.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数粒度**：适当地将应用程序分解成更小的函数是服务器无架构的关键方面。然而，将功能分解成过于细粒度的FaaS函数可能会导致由于大量函数的调用和协调而增加开销，从而导致发布依赖、更高的成本、更高的延迟和更复杂的系统。'
- en: Dividing applications and grouping functions so that they’re the right size
    is the key factor for a scalable and cost-efficient system. We’re going to explore
    this aspect in detail while considering our real-life example shortly.
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 将应用程序分割并分组成适当大小的函数是可扩展和成本效益系统的关键因素。我们将详细探讨这一方面，同时考虑我们即将讨论的现实生活案例。
- en: '**State management**: FaaS functions are typically designed to be stateless,
    meaning they don’t retain their memory of previous executions. When there’s a
    chain of functions and triggers working together with data to share, it poses
    a challenge to how the state is shared across multiple function invocations. This
    pattern often involves other IaaS services, such as queues, databases, or in-memory
    caches. State management must be addressed carefully as it involves concerns such
    as concurrency, data housekeeping, and compatibility while evolving.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**状态管理**：无服务器函数通常设计为无状态，这意味着它们不会保留之前执行的记忆。当有一系列函数和触发器与数据一起协作共享时，如何在多个函数调用之间共享状态就构成了一个挑战。这种模式通常涉及其他IaaS服务，例如队列、数据库或内存缓存。状态管理必须谨慎处理，因为它涉及到并发、数据维护和兼容性等方面的问题。'
- en: '**Monitoring and debugging**: Troubleshooting and monitoring serverless applications
    can be more complex than traditional architectures. When a business workflow is
    distributed among multiple functions and processes, it becomes challenging to
    diagnose, reproduce, and resolve issues. We should invest in observability tools
    such as log aggregation, monitoring, dashboards, and alerting. We also need to
    design the system so that it can handle errors gracefully.'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监控和调试**：与传统架构相比，排查和监控无服务器应用程序可能更加复杂。当业务工作流程分布在多个函数和流程中时，诊断、重现和解决问题变得具有挑战性。我们应该投资于可观察性工具，如日志聚合、监控、仪表板和警报。我们还需要设计系统，使其能够优雅地处理错误。'
- en: '**Cost management**: While serverless architectures often optimize cost due
    to the pay-per-use model, it’s essential to monitor and optimize resource consumption.
    Granular billing based on usage can lead to unexpected costs if the applications
    are designed inefficiently or experience unexpected spikes in traffic. This can
    be caused by inefficient system design or simply because the pattern of usage
    has changed over time. Adequate monitoring, performance testing, and optimization
    strategies need to be in place to control costs effectively. This is also an opportunity
    to discover system inefficiency so that the system can improve with new findings.'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**成本管理**：虽然无服务器架构通常由于按使用付费的模式而优化成本，但监控和优化资源消耗至关重要。基于使用的细粒度计费可能导致意外成本，如果应用程序设计效率低下或经历意外的流量峰值。这可能是由不高效的系统设计或随着时间的推移使用模式的变化引起的。需要适当的监控、性能测试和优化策略，以有效控制成本。这也是发现系统低效的机会，以便系统可以根据新的发现进行改进。'
- en: '**Long-running processes**: FaaS functions are typically execution time limits
    that are imposed by cloud providers. In other words, FaaS functions are meant
    to be small and executed quickly. If an operation requires significant processing
    time or must run continuously, it might be better to look for PaaS or IaaS alternatives,
    such as virtual servers. Careful consideration is needed to decide on the appropriate
    approach.'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长时间运行的过程**：FaaS 函数通常是由云服务提供商设定的执行时间限制。换句话说，FaaS 函数旨在小型化并快速执行。如果某个操作需要大量的处理时间或必须持续运行，那么寻找
    PaaS 或 IaaS 的替代方案可能更好，例如虚拟服务器。在决定适当的方法时需要仔细考虑。'
- en: '**Security and compliance**: Serverless architectures introduce new security
    considerations. Ensuring secure function invocations, managing access controls,
    and protecting sensitive data within the serverless environment are critical.
    Compliance with regulations and industry standards should be thoroughly evaluated
    to ensure proper security measures are in place.'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**安全和合规性**：无服务器架构引入了新的安全考虑。确保安全地调用函数、管理访问控制和保护无服务器环境中的敏感数据至关重要。应彻底评估符合法规和行业标准，以确保适当的安全措施得到实施。'
- en: '**Non-functional requirements (NFRs)**: Even cloud providers offer a wide range
    of services that take away the concerns of infrastructure that are often parts
    of the NFRs. Our choice of serverless service needs to meet these requirements.
    Sometimes, it’s hard to be in control of meeting these requirements since engineers
    can only configure the desired resources, and in the end, it’s the platform that
    provisions the resources to meet the desired resources as configuration.'
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非功能性需求（NFRs）**：即使云服务提供商也提供了一系列服务，这些服务通常包括基础设施的担忧，这些担忧往往是 NFRs 的组成部分。我们选择的無服务器服务需要满足这些要求。有时，由于工程师只能配置所需的资源，最终是平台根据配置提供资源以满足所需资源，因此很难控制满足这些要求。有时，很难控制满足这些要求，因为工程师只能配置所需的资源，最终是平台根据配置提供资源以满足所需资源。'
- en: In an extreme case, it might be justified to go back to bare-metal servers to
    have full control of the hardware and network that could fulfill the high-end
    NFRs.
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在极端情况下，可能有必要回到裸金属服务器，以完全控制硬件和网络，从而满足高端 NFRs。
- en: By understanding and addressing these cautions, organizations can make informed
    decisions when adopting serverless architecture and mitigate potential risks associated
    with its implementation. Next, we’re going to run through an exercise of adopting
    serverless architecture while utilizing the real-life example provided in this
    chapter.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 通过理解和解决这些注意事项，组织在采用无服务器架构时可以做出明智的决定，并减轻其实施过程中可能出现的潜在风险。接下来，我们将通过利用本章提供的实际案例来练习采用无服务器架构。
- en: Adopting serverless architectures in our real-life example
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的实际案例中采用无服务器架构
- en: 'Consider the same real-life example that we used earlier in this chapter, where
    households exchange services with one another. Previously, we identified three
    potential microservices. Let’s recapitulate what they are:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑本章前面用过的相同现实生活示例，其中家庭之间相互交换服务。之前，我们确定了三个潜在的微服务。让我们回顾一下它们是什么：
- en: '**Household service**: Masters the records of households'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家庭服务**：掌握家庭的记录'
- en: '**Contract service**: Maintains the workflow of contract negotiation from drafted
    to fully exercised'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同服务**：维护从起草到完全执行的合同谈判工作流程'
- en: '**Notification service**: Sends proxy notification requests to email service
    providers'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通知服务**：向电子邮件服务提供商发送代理通知请求'
- en: '*Figure 6**.4* shows how these four microservices communicate:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 6**.4* 展示了这四个微服务之间的通信方式：'
- en: '![Figure 6.4 – Recap example of updated microservice communication](img/B21737_06_31.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![图 6.4 – 更新后的微服务通信回顾示例](img/B21737_06_31.jpg)'
- en: Figure 6.4 – Recap example of updated microservice communication
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 图 6.4 – 更新后的微服务通信回顾示例
- en: In this exercise, we’ll assume that we want to have the system hosted in AWS.
    We need to decide which cloud service to use and what the desired setup is.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们假设我们希望系统托管在 AWS 上。我们需要决定使用哪种云服务以及期望的设置是什么。
- en: Function granularity and choosing the computing service
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数粒度和选择计算服务
- en: Previously, we mentioned we need to be cautious about function granularity as
    this will impact system efficiency and cost. We’re going to review how these services
    can be executed and which computing service we might use.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们提到我们需要谨慎考虑函数粒度，因为这会影响系统效率和成本。我们将回顾这些服务如何执行以及我们可能会使用哪种计算服务。
- en: The **household service** provides the classic **Create, Read, Update, and Delete**
    (**CRUD**) operations and connects to a relational database for persistent storage.
    These operations are highly cohesive as they cover the life cycle of households.
    They all assume the same database schema. Moreover, to ensure there’s a way for
    the schema to evolve reliably, it seems reasonable to have the **household service**
    own its schema. This implies that incremental database migration tools such as
    **Flyway** can be used and that the incremental **Data Definition Language** (**DDL**)
    files should be hosted together with the source code that translates into the
    **Structured Query Language** (**SQL**) commands to perform the CRUD operations
    of households.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**家庭服务**提供经典的**创建、读取、更新和删除**（**CRUD**）操作，并连接到关系型数据库进行持久化存储。这些操作高度内聚，因为它们涵盖了家庭的整个生命周期。它们都假设相同的数据库架构。此外，为了确保架构能够可靠地演变，似乎有理由让**家庭服务**拥有自己的架构。这意味着可以使用增量数据库迁移工具，如**Flyway**，并且增量**数据定义语言**（**DDL**）文件应与将转换为执行家庭
    CRUD 操作的**结构化查询语言**（**SQL**）命令的源代码一起托管。'
- en: The incremental database migration runs as part of the service startup. The
    migration tool will check if the latest DDL file is of the same version as the
    version registered in the migration history records. If it’s the same version,
    migration will finish as a **no operation** (**no-op**); if the script version
    is higher than the recorded version, then the tool will run the incremental script
    until the version matches again. With this setup, any evolution in the database
    schema is released in one deployment action, with the schema changes and corresponding
    code changes going in a synchronized manner.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 增量数据库迁移作为服务启动的一部分运行。迁移工具将检查最新的 DDL 文件是否与迁移历史记录中注册的版本相同。如果是相同版本，迁移将以**无操作**（**no-op**）结束；如果脚本版本高于记录的版本，则工具将运行增量脚本，直到版本再次匹配。在这种设置下，数据库架构的任何演变都在一次部署操作中发布，架构更改和相应的代码更改以同步方式进行。
- en: Moreover, there are three operations (Create, Update, and Delete) that would
    need an updated household event to be published. These operations would assume
    a specific message format. If the message format is going to change, it may affect
    all three operations. This also suggests they should be grouped as one deployable
    artifact to ensure smooth, reliable changes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有三个操作（创建、更新和删除）需要发布更新后的家庭事件。这些操作将假设特定的消息格式。如果消息格式将要改变，可能会影响所有三个操作。这也表明它们应该被组合成一个可部署的组件，以确保平稳、可靠的变更。
- en: On the contrary, if the CRUD operations are separated into four FaaS functions
    or nanoservices, any change in data structure or message structure would require
    a coordinated release of these functions. This means function coupling, release
    dependency, downtime, and the risk of partial deployment failures.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果CRUD操作被分离成四个FaaS函数或纳米服务，任何数据结构或消息结构的更改都要求这些函数的协调发布。这意味着函数耦合、发布依赖、停机时间和部分部署失败的风险。
- en: Therefore, in this example, the `GET`, `PUT` (create and update), and `DELETE`
    verbs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个例子中，使用`GET`、`PUT`（创建和更新）和`DELETE`动词。
- en: The messaging technology in this example will be Kafka. We intend to publish
    events on a normal topic and a compacted topic. The normal topic is used to announce
    creation, updates, and soft deletion, while the compacted topic is used as a last-value
    queue to keep the last snapshot of the Household records.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 本例中的消息传递技术将是Kafka。我们打算在正常主题和压缩主题上发布事件。正常主题用于宣布创建、更新和软删除，而压缩主题用作最后值队列，以保持家庭记录的最后快照。
- en: 'The next consideration is about which serverless computing the **household
    service** should use. Here’s an example of using AWS:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个考虑因素是**家庭服务**应该使用哪种无服务器计算。以下是一个使用AWS的示例：
- en: '![Figure 6.5 – The household service using AWS](img/B21737_06_4.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图6.5 – 使用AWS的家庭服务](img/B21737_06_4.jpg)'
- en: Figure 6.5 – The household service using AWS
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.5 – 使用AWS的家庭服务
- en: 'We can use Amazon **Elastic Kubernetes Service** (**EKS**) to run the **household
    service**. This requires us to implement the following infrastructure setup:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用Amazon **弹性Kubernetes服务**（**EKS**）来运行**家庭服务**。这需要我们实现以下基础设施设置：
- en: Specify the AWS region
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定AWS区域
- en: Create a **Virtual Private Cloud** (**VPC**) and subnet
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个**虚拟私有云**（**VPC**）和子网
- en: Create a role in AWS **Identity and Access Management** (**IAM**) for EKS to
    assume a role for the EKS cluster
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在AWS **身份和访问管理**（**IAM**）中为EKS创建一个角色，以便EKS集群假定该角色
- en: Define the EKS cluster that makes use of the VPC, subnet, and the IAM role
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义使用VPC、子网和IAM角色的EKS集群
- en: Create a security group for the EKS cluster
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为EKS集群创建一个安全组
- en: Attach the EKS cluster and EKS service policies to the IAM role
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将EKS集群和EKS服务策略附加到IAM角色
- en: Create an Amazon **Relational Database Service** (**RDS**) with PostgreSQL and
    its subnet
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个带有PostgreSQL及其子网的Amazon **关系数据库服务**（**RDS**）
- en: Configure the Kubernetes provider
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Kubernetes提供者
- en: Configure the Kubernetes namespace and config map
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Kubernetes命名空间和配置映射
- en: Configure the Kubernetes secrets to be imported from AWS Secrets Manager, such
    as passwords
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置Kubernetes密钥，以便从AWS Secrets Manager导入，例如密码
- en: Configure the ingress (incoming traffic route) and **Application Load Balancer**
    (**ALB**) so that the requests can reach the REST endpoints
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置入口（入站流量路由）和**应用程序负载均衡器**（**ALB**），以便请求可以到达REST端点
- en: Configure Amazon **Managed Kafka Service** (**MSK**) on Kafka topics and security
    groups to allow an EKS pod to publish and consume messages
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Kafka主题和安全组上配置Amazon **托管Kafka服务**（**MSK**），以允许EKS pod发布和消费消息
- en: 'Given that the **household service** has the infrastructure set up, we can
    start a Kotlin project. There are many ready-to-go project creators available
    on the internet, including the following:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 由于**家庭服务**已设置基础设施，我们可以开始一个Kotlin项目。互联网上有许多现成的项目创建器可供选择，包括以下内容：
- en: Spring Boot
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Spring Boot
- en: Ktor
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ktor
- en: HTTP4K
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP4K
- en: Vert.x
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Vert.x
- en: 'These tools all create a skeleton project that can be built using their respective
    server frameworks. In this example, we’re using Ktor as the server framework and
    REST endpoint routing. In Ktor, endpoint routing is defined like so:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这些工具都创建了一个可以使用各自服务器框架构建的骨架项目。在这个例子中，我们使用Ktor作为服务器框架和REST端点路由。在Ktor中，端点路由定义如下：
- en: '[PRE0]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We’re using a declarative configuration as Kotlin code, and we’re expected to
    define a payload format and set up corresponding serialization by using Ktor content
    negotiation.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用Kotlin代码的声明性配置，并预期定义一个有效载荷格式，并使用Ktor内容协商设置相应的序列化。
- en: The Kafka topics can be defined using Terraform, which provides a standard declarative
    format for specifying infrastructure. The normal topic will need to set a retention
    policy that determines how long the message should remain on the topic.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: Kafka主题可以使用Terraform定义，它为指定基础设施提供了一个标准的声明性格式。正常主题需要设置一个保留策略，以确定消息应在主题上保留多长时间。
- en: 'The compacted topic has a different setup. The message in the compacted topic
    should be retained for as long as possible. The newer message of the same key
    will replace the older one by compacting the logs. The cleanup policy of compacted
    topics should be set to `"compact"`, with the retention period set to `–1`. Here’s
    an example of how a compacted topic is specified in Terraform:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 压缩主题有不同的设置。压缩主题中的消息应尽可能保留。通过压缩日志，相同键的新消息将替换旧消息。压缩主题的清理策略应设置为`"compact"`，保留期设置为`–1`。以下是在Terraform中指定压缩主题的示例：
- en: '[PRE1]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The updated Household records are going to be sent to both topics. This is
    illustrated in the following code using the **Apache** **Kafka API**:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的家庭记录将被发送到两个主题。以下代码使用**Apache Kafka API**说明了这一点：
- en: '[PRE2]'
  id: totrans-255
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The message that’s sent to the compacted topic contains a key to identify and
    remove older messages of the same key. In this instance, household names are used
    as keys.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到压缩主题的消息包含一个用于识别和删除相同键的旧消息的关键。在这种情况下，使用家庭名称作为键。
- en: 'The **contract service** provides controlled operations on the workflow regarding
    contract negotiation and contract exercise. It uses some form of persistent storage
    to keep a local copy of households and to maintain the state of the contract in
    its workflows. It uses a serverless computing service similar to that of the **household
    service**, as shown in *Figure 6**.6*:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同服务**提供对合同谈判和合同执行的流程的受控操作。它使用某种形式的持久存储来保留家庭的本地副本并维护其工作流程中的合同状态。它使用与**家庭服务**类似的无服务器计算服务，如图*6.6*所示：'
- en: '![Figure 6.6 – The contract service using AWS](img/B21737_06_5.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![图6.6 – 使用AWS的合同服务](img/B21737_06_5.jpg)'
- en: Figure 6.6 – The contract service using AWS
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.6 – 使用AWS的合同服务
- en: The **contract service** receives Household records from the topics published
    by the **household service**. Initially, it consumes all messages in the compacted
    topic to build its local cache of households and subsequently receives updates
    of Household records from the normal topic. It also sends notification requests
    to a topic to be consumed by the **notification service**.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同服务**从**家庭服务**发布的主题接收家庭记录。最初，它消费压缩主题中的所有消息以构建其本地家庭缓存，随后从正常主题接收家庭记录的更新。它还向一个将被**通知服务**消费的主题发送通知请求。'
- en: In this setting, when a household is updated while the `household-v1` and `household-snapshot-v1`
    topics. The event in the queue is now waiting for the **contract service** to
    come back up. One instance of the **contract service** becomes available and takes
    this event for further processing.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种设置下，当在`household-v1`和`household-snapshot-v1`主题更新家庭时，队列中的事件现在正在等待**合同服务**恢复。一个**合同服务**实例变得可用并处理此事件。
- en: The **contract service** uses the same AWS components as the **household service**
    in terms of IAM, Secrets Management, ALB, Kubernetes, and database services.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**合同服务**在IAM、密钥管理、ALB、Kubernetes和数据库服务方面使用与**家庭服务**相同的AWS组件。'
- en: On the other hand, the **notification service** is simple in that it takes a
    notification request and proxies the request to an email service provider. There’s
    no tight requirement to send emails instantly and it’s OK to have the emails be
    sent a couple of minutes late. There’s no need to maintain state either as the
    request message already contains the household email addresses and the content
    of the messages.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，**通知服务**很简单，它接受通知请求并将请求代理到电子邮件服务提供商。没有立即发送电子邮件的严格要求，电子邮件晚几分钟发送是可以接受的。也不需要维护状态，因为请求消息已经包含了家庭电子邮件地址和消息内容。
- en: 'This is a suitable candidate for a FaaS service. While we can use AWS Lambda
    to meet the requirements, a nanoservice is an equally suitable choice. For this
    reason, the **notification service** is called **Email notifier** in physical
    deployment, as shown in *Figure 6**.7*:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个适合FaaS服务的合适候选者。虽然我们可以使用AWS Lambda来满足需求，但纳米服务也是一个同样合适的选择。因此，在物理部署中，**通知服务**被称为**电子邮件通知器**，如图*6.7*所示：
- en: '![Figure 6.7 – The notification service using AWS](img/B21737_06_6.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![图6.7 – 使用AWS的通知服务](img/B21737_06_6.jpg)'
- en: Figure 6.7 – The notification service using AWS
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.7 – 使用AWS的通知服务
- en: We can configure the function so that it’s triggered by a new message in the
    Kafka topic. The function converts a request into email format and passes it to
    Amazon SES so that it can send the email.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以配置函数，使其由Kafka主题中的新消息触发。该函数将请求转换为电子邮件格式，并将其传递给Amazon SES，以便发送电子邮件。
- en: The function must be configured to use a constant Kafka consumer group so that
    multiple instances of the same function don’t consume the same message and effectively
    behave as a queue.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 函数必须配置为使用常量Kafka消费者组，这样同一函数的多个实例就不会消费相同的消息，从而有效地作为队列运行。
- en: The function is stateless, and AWS provides all the means to connect to SQS
    and SES. There’s no concern regarding a cold startup occurring as there’s no tight
    latency requirement. The function also scales automatically based on traffic and
    is controlled by AWS. Similarly, this function uses IAM and Secrets Management
    to control accessible resources and secrets.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 函数是无状态的，AWS提供了连接到SQS和SES的所有手段。由于没有严格的延迟要求，因此无需担心冷启动的发生。该函数还根据流量自动扩展，并由AWS控制。同样，此函数使用IAM和秘密管理来控制可访问的资源机密。
- en: So far, we’ve covered the basic principles of serverless architecture, in conjunction
    with what’s offered by the four major categories of services provided by major
    cloud providers. We’ve also discussed the benefits and cautions of applying serverless
    architecture. Finally, we ran an exercise in adopting serverless architecture
    for the real-life example specified in this chapter.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了无服务器架构的基本原则，并结合了主要云提供商提供的四大类服务所提供的内容。我们还讨论了应用无服务器架构的益处和注意事项。最后，我们针对本章指定的现实生活示例进行了采用无服务器架构的练习。
- en: Next, we’re going to briefly cover the microfrontend architecture, which works
    similarly to microservices in principle.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将简要介绍微前端架构，其原理上与微服务类似。
- en: Microfrontends
  id: totrans-272
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 微前端
- en: The microfrontend architecture aims to enhance modularity, scalability, and
    autonomy by breaking down the UI into smaller, self-contained frontend modules.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构旨在通过将UI分解成更小、自包含的前端模块来增强模块化、可扩展性和自主性。
- en: The term *microfrontend* first appeared in 2016 under Thoughtworks Technology
    Radar with the recommendation of *Assess*. It’s often compared to the concept
    of microservices on the backend. The microfrontend architecture promotes decomposing
    the frontend into independently deployable and maintainable units, each responsible
    for a specific part of the UI.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“微前端”首次于2016年在Thoughtworks技术雷达中出现，由“评估”推荐。它通常与后端上的微服务概念相比较。微前端架构促进将前端分解为独立部署和维护的单位，每个单位负责UI的特定部分。
- en: Same symptoms from the days of monolithic applications
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单体应用程序时代的相同症状
- en: A traditional monolithic frontend application has a single code base that handles
    the entire UI. Usually. There’s more than one team of engineers working on it,
    which causes code conflicts, release dependency, slow build time, limited autonomy
    for each team, and challenges in scaling and maintaining large applications. This
    situation is the same regarding microservices, except this happens in the frontend.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 传统的单体前端应用程序有一个单一的代码库来处理整个UI。通常情况下，有多个工程师团队在开发它，这会导致代码冲突、发布依赖、构建时间慢、每个团队自主性有限，以及在大规模应用中的扩展和维护挑战。这种情况与微服务相同，只是这发生在前端。
- en: The microfrontend architecture addresses these issues by enabling different
    teams to work independently on distinct parts of the UI, allowing them to choose
    their own technologies, frameworks, and release cycles.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构通过允许不同团队独立工作于UI的不同部分，让他们选择自己的技术和框架，以及发布周期来解决这些问题。
- en: Many small frontend modules as individual applications
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 许多小型前端模块作为独立的应用程序
- en: In a microfrontend architecture, the UI is composed of multiple frontend modules.
    Each module is an application that can be developed, tested, deployed, and scaled
    independently. Like microservices, one frontend module should be owned by one
    – and only one – team, but as a common library.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在微前端架构中，UI由多个前端模块组成。每个模块都是一个可以独立开发、测试、部署和扩展的应用程序。像微服务一样，一个前端模块应该由一个——并且只有一个——团队拥有，但作为一个公共库。
- en: 'Each module is a grouping of cohesive functionalities. Considering the real-life
    example provided in this chapter, there should be two frontend applications:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 每个模块是一组功能。考虑到本章提供的现实生活示例，应该有两个前端应用程序：
- en: The **household application**, which manages household account creation, updates,
    and deletion. Each household can manage its own account details via this application.
    This application primarily communicates with the **household service** in the
    backend.
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**家庭应用**，用于管理家庭账户的创建、更新和删除。每个家庭都可以通过此应用管理自己的账户详情。此应用主要与后端的**家庭服务**进行通信。'
- en: The **contract application**, which allows two households to progress from a
    draft contract to an agreement. It supports drafting a contract, similar to the
    screens we saw in [*Chapter 5*](B21737_05.xhtml#_idTextAnchor125). The two households
    that are involved can agree to the contract or amend it until both households
    agree with the details. It also tracks how the agreed-upon contract is exercised
    by the two households involved. Regarding the polymorphic nature of the different
    services that can be mentioned in the contract, as described in [*Chapter 3*](B21737_03.xhtml#_idTextAnchor067),
    there may be multiple screens for households to report the status of the services
    that are exercised based on the contract. This application primarily communicates
    with the **contract service** in the backend.
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**合同应用**，允许两个家庭从草稿合同进展到协议。它支持起草合同，类似于我们在[*第五章*](B21737_05.xhtml#_idTextAnchor125)中看到的屏幕。涉及的两个家庭可以同意合同或修改它，直到两个家庭都同意细节。它还跟踪涉及的两个家庭如何执行约定的合同。关于合同中可能提到的不同服务的多态性，如[*第三章*](B21737_03.xhtml#_idTextAnchor067)中所述，可能存在多个屏幕供家庭报告基于合同的执行服务的状态。此应用主要与后端的**合同服务**进行通信。'
- en: All these applications are bundled as self-contained artifacts that can be launched
    on their own, allowing separate teams to focus on their business domains.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些应用都打包成自包含的工件，可以独立启动，允许不同的团队专注于他们的业务领域。
- en: However, there should be one more application that integrates with all other
    applications. This application doesn’t contain business logic; instead, it’s merely
    an over-delegation module that typically provides a menu for users to access other
    applications. This is the application that creates a unified UI at build time
    or runtime, depending on whether it’s a web or mobile platform.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还应该有一个与其他所有应用集成的应用。此应用不包含业务逻辑；相反，它只是一个过度委派的模块，通常为用户提供一个菜单来访问其他应用。这是在构建时间或运行时创建统一UI的应用，具体取决于它是Web平台还是移动平台。
- en: 'Overall, these frontend applications can be illustrated like so, together with
    the backend services they communicate with:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，这些前端应用可以这样表示，连同它们与之通信的后端服务：
- en: '![Figure 6.8 – The frontend and backend communication of the real-life example](img/B21737_06_7.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图6.8 – 真实案例的前端和后端通信](img/B21737_06_7.jpg)'
- en: Figure 6.8 – The frontend and backend communication of the real-life example
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.8 – 真实案例的前端和后端通信
- en: In the preceding diagram, each frontend application has a primary microservice
    in the backend to communicate with. Each frontend application communicates with
    other frontend applications. Microservices also communicate with each other. The
    roles and responsibilities of each frontend application and each microservice
    are well-defined and clear.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的图中，每个前端应用都有一个后端的主要微服务进行通信。每个前端应用与其他前端应用进行通信。微服务之间也相互通信。每个前端应用和每个微服务的角色和责任都定义得很好，也很清晰。
- en: This architecture enables each frontend application and its primary microservice
    to be owned by only one team. This is coherent with the idea of organizing teams
    by business function, as mentioned in [*Chapter 1*](B21737_01.xhtml#_idTextAnchor013).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 这种架构使得每个前端应用及其主要微服务只能由一个团队拥有。这与[*第一章*](B21737_01.xhtml#_idTextAnchor013)中提到的按业务功能组织团队的想法是一致的。
- en: Communication among frontend modules
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端模块之间的通信
- en: Having communication and coordination among the frontend modules is critical
    in a microfrontend architecture. There are various techniques and patterns to
    facilitate this, such as asynchronous messaging, event-driven architectures, or
    shared state management.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在微前端架构中，前端模块之间的通信和协调至关重要。有各种技术和模式来促进这一点，例如异步消息传递、事件驱动架构或共享状态管理。
- en: In our example, a shared state managed by the collection of backend microservices
    is used to serve each frontend module.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，由后端微服务集合管理的共享状态用于为每个前端模块提供服务。
- en: These techniques enable seamless integration and collaboration between different
    modules while maintaining loose coupling and encapsulation. A well-integrated
    UI with a microfrontend architecture brings a connected and consistent user experience.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这些技术使得不同模块之间能够实现无缝集成和协作，同时保持松散耦合和封装。一个良好集成的UI和微前端架构带来了连接和一致的用户体验。
- en: Design systems for consistent user experiences
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为一致的用户体验设计系统
- en: Visualization is an essential element of any frontend application. While having
    smaller frontend applications autonomously run by their responsible teams, it’s
    paramount to ensure the integration UI has a consistent look and feel. A design
    system provides the common UI components, such as buttons, checkboxes, text fields,
    and interaction styles, that align all frontend modules so that they behave the
    same way. In that sense, end users have a seamless experience with little learning
    required when navigating to another frontend module.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 可视化是任何前端应用程序的一个基本元素。尽管较小的前端应用程序由其负责的团队独立运行，但确保集成UI具有一致的外观和感觉至关重要。设计系统提供了常见的UI组件，例如按钮、复选框、文本字段和交互样式，使所有前端模块保持一致，以便它们以相同的方式表现。从这个意义上说，当用户导航到另一个前端模块时，他们可以享受到无缝的体验，几乎不需要学习。
- en: Benefits
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 好处
- en: The microfrontend architecture offers several benefits to engineering teams
    and organizations. By allowing teams to work autonomously, it promotes faster
    development cycles, easier maintenance, and the ability to adopt new technologies
    and frameworks without affecting the entire application. It results in higher
    productivity and quicker time to market. It also enables scalability by allowing
    individual modules to be scaled independently, providing flexibility in managing
    traffic and resources.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构为工程团队和组织提供了多项好处。通过允许团队独立工作，它促进了更快的开发周期、更简单的维护，以及在不影响整个应用程序的情况下采用新技术和框架的能力。这导致更高的生产率和更快的上市时间。它还通过允许独立扩展单个模块，提供了在管理流量和资源方面的灵活性。
- en: Furthermore, the microfrontend architecture advocates code reusability by reusing
    UI components brought from design systems that can be shared across multiple applications.
    This can lead to improved consistency, reduced duplication, reduced user learning,
    and increased productivity in frontend development.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，微前端架构通过重用来自设计系统的UI组件来倡导代码的可重用性，这些组件可以在多个应用程序之间共享。这可能导致一致性的提高、重复的减少、用户学习的减少以及前端开发生产力的提高。
- en: Challenges
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挑战
- en: While the microfrontend architecture offers numerous advantages, it also introduces
    complexities and challenges such as module communication, versioning, and orchestration
    when integrating all frontend modules into one application. Successful implementation
    requires careful planning, design considerations, and selecting the appropriate
    tools and frameworks.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管微前端架构提供了许多优势，但它也引入了复杂性，例如模块通信、版本控制和编排，当将所有前端模块集成到一个应用程序中时。成功的实施需要仔细规划、设计考虑以及选择适当的工具和框架。
- en: Variations among the web and other platforms
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络和其他平台之间的差异
- en: The web and other platforms have a slight difference when applying the microfrontend
    architecture. The web platform can achieve independent release as frontend modules
    are integrated primarily using hyperlinks.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用微前端架构时，网络和其他平台存在细微的差异。网络平台可以通过使用超链接将前端模块集成来实现独立发布。
- en: Mobile and desktop applications are trickier because they need to generate a
    monolithic artifact for users to download and install. Releasing a frontend module
    would require regenerating the monolithic artifact and bumping the build versions.
    Some organizations might choose to release the application in a specific cadence
    to avoid excessive updates being required by the application.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 移动和桌面应用程序更为复杂，因为它们需要生成一个用于用户下载和安装的单一文件。发布一个前端模块需要重新生成单一文件并更新构建版本。一些组织可能会选择以特定的节奏发布应用程序，以避免应用程序需要过多的更新。
- en: Overall, the microfrontend architecture is a powerful paradigm that empowers
    engineering teams to create scalable, modular, and maintainable frontend applications
    by decomposing the frontend into smaller, independent modules. By embracing this
    architectural style, organizations can achieve greater flexibility, agility, and
    scalability in their frontend development processes.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，微前端架构是一种强大的范式，它通过将前端分解成更小、独立的模块，使工程团队能够创建可扩展、模块化和可维护的前端应用。通过采用这种架构风格，组织可以在其前端开发过程中实现更大的灵活性、敏捷性和可扩展性。
- en: An overall perspective
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体视角
- en: So far, we’ve discussed how monolithic applications evolve from a historical
    perspective. We’ve discussed that the monolithic architecture evolves into the
    SOA, where one big application is decomposed into chunks of smaller applications.
    Then, the era of microservice and microfrontend architectures begins as they’re
    broken down into even smaller applications.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们从历史的角度讨论了单体应用的演变。我们讨论了单体架构如何演变成SOA，其中一个大应用被分解成更小的应用块。然后，随着它们被进一步分解成更小的应用，微服务和微前端架构的时代开始了。
- en: Finally, the serverless architecture emerges, which allows a single function
    to be executed as a unit in the cloud infrastructure. Meanwhile, it still supports
    bigger cloud applications and lets them run.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，无服务器架构出现，它允许单个函数作为云基础设施中的一个单元执行。同时，它仍然支持更大的云应用，并允许它们运行。
- en: 'Putting them all together into one perspective, we can start to see how the
    sizes differ in each architecture:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们综合起来看，我们可以开始看到每种架构的大小差异：
- en: '![Figure 6.9 – A size comparison among covered architecture styles](img/B21737_06_8.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图6.9 – 覆盖的架构风格大小比较](img/B21737_06_8.jpg)'
- en: Figure 6.9 – A size comparison among covered architecture styles
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图6.9 – 覆盖的架构风格大小比较
- en: It’s worth noting that serverless architecture can adapt to all sizes. It can
    even adapt to monolithic applications, though usually, the first step is to break
    the monolithic application into smaller services. This is a typical example of
    “*First make the change easy, then make the* *easy change.*”
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，无服务器架构可以适应所有规模。它甚至可以适应单体应用，尽管通常情况下，第一步是将单体应用分解成更小的服务。这是一个典型的“*先让改变变得容易，然后再让容易的改变变得容易*”的例子。
- en: Note
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: “*First make the change easy, then make the easy change*” is a quote attributed
    to Kent Beck, a pioneer of **Extreme Programming** (**XP**) and Agile methodologies.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: “*先让改变变得容易，然后再让容易的改变变得容易*”这句话被归功于极限编程（**XP**）和敏捷方法论的先驱肯特·贝克（Kent Beck）。
- en: Summary
  id: totrans-314
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a few cases where monolithic architecture is justified.
    We discussed the basic principles of how to divide a monolithic application into
    microservices and nanoservices, as well as how to detect when the division isn’t
    right. We used a real-life example to delve into the thought process of designing
    microservices and nanoservices.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了几种情况下单体架构是合理的。我们讨论了如何将单体应用分解成微服务和纳米服务的基本原则，以及如何检测分解是否正确。我们使用一个真实案例来深入探讨设计微服务和纳米服务的思维过程。
- en: Then, we introduced the serverless architecture and the most popular cloud providers.
    We covered the four major categories of cloud computing services (IaaS, PaaS,
    SaaS, and FaaS) and discussed the benefits and cautions when using serverless
    architecture. After, we conducted an exercise where we adopted serverless architecture
    and chose appropriate cloud computing services to meet the requirements.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们介绍了无服务器架构和最受欢迎的云服务提供商。我们涵盖了云计算服务的四大主要类别（IaaS、PaaS、SaaS和FaaS），并讨论了使用无服务器架构时的益处和注意事项。之后，我们进行了一项练习，采用无服务器架构并选择合适的云计算服务来满足需求。
- en: Finally, we briefly covered the microfrontend architecture, where a monolithic
    frontend application is broken down into frontend applications. We used the same
    real-life example from before to illustrate the decomposition and how each frontend
    module communicates with the backend components. Finally, we covered the need
    for design systems to ensure a consistent user experience and briefly mentioned
    the benefits and challenges of using the microfrontend architecture.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们简要介绍了微前端架构，其中单体前端应用被分解成前端应用。我们使用了之前相同的真实案例来展示分解过程以及每个前端模块如何与后端组件通信。最后，我们讨论了设计系统的重要性，以确保一致的用户体验，并简要提到了使用微前端架构的益处和挑战。
- en: In the next chapter, we’re going to dive into the practice of separating concerns
    using selected methodologies to help drive us toward efficient, scalable, and
    maintainable applications.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将深入探讨使用精选方法来分离关注点，以帮助我们朝着高效、可扩展和可维护的应用程序迈进。
