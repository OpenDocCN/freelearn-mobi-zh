- en: Assessments
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 评估
- en: Chapter 1, Getting Started with Kotlin
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章，Kotlin 入门
- en: Question 1
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What's the difference between `var` and `val` in Kotlin?
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中 `var` 和 `val` 之间的区别是什么？
- en: Answer
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The `val` keyword declares an immutable value that cannot be modified once assigned.
    The `var` keyword declares a mutable variable that can be assigned multiple times.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '`val`关键字声明了一个不可变值，一旦分配后就不能修改。`var`关键字声明了一个可变变量，可以被多次赋值。'
- en: Question 2
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: How do you extend a class in Kotlin?
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何在 Kotlin 中扩展一个类？
- en: Answer
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: To extend a class, you can specify its name and constructor after a semicolon.
    If it's a regular class, it must be declared `open` for your code to be able to
    extend it.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 要扩展一个类，你可以在分号后指定其名称和构造函数。如果它是一个普通类，它必须被声明为`open`，以便你的代码能够扩展它。
- en: Question 3
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: How do you add functionality to a `final` class?
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何向一个`final`类添加功能？
- en: Answer
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: To add functionality to a class that we cannot inherit from, we can use an extension
    function. The extension function will have access only to the class itself and
    to its public fields and functions.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要向一个无法继承的类添加功能，我们可以使用扩展函数。扩展函数将只能访问类本身及其公共字段和函数。
- en: Chapter 2, Working with Creational Patterns
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 2 章，使用创建型模式
- en: Question 1
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: Name two uses for the `object` keyword we learned about in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 列出本章中我们学到的`object`关键字的两个用途。
- en: Answer
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The `object` keyword is used to declare a singleton if it's used in a global
    scope or as a collection of static methods if it's used in a conjunction with
    the `companion` keyword inside a class.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当在全局作用域中使用或在与类内部的`companion`关键字一起使用时，`object`关键字用于声明单例，如果它与`companion`关键字一起使用，则作为静态方法的集合。
- en: Question 2
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is the `apply()` function used for?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`apply()`函数用于什么？'
- en: Answer
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The `apply()` function is used when we want to change the state of an object
    and then return it immediately.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要改变一个对象的状态并立即返回它时，使用`apply()`函数。
- en: Question 3
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: Provide one example of a static factory method that we discussed in this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 提供本章中讨论的静态工厂方法的一个示例。
- en: Answer
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The JVM `valueOf()` method on the `Long` objects is a static factory method.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '`Long`对象的 JVM `valueOf()`方法是静态工厂方法。'
- en: Chapter 3, Understanding Structural Patterns
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章，理解结构型模式
- en: Question 1
  id: totrans-28
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What differences are there between the implementations of the Decorator and
    Proxy design patterns?
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式和代理设计模式的实现之间有什么区别？
- en: Answer
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The Decorator and Proxy design patterns could be implemented in the same manner.
    The only difference is in their intent – the Decorator design pattern adds functionality
    to an object, while the Proxy design pattern may change an object's functionality.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式和代理设计模式可以以相同的方式实现。唯一的区别在于它们的意图——装饰器设计模式向对象添加功能，而代理设计模式可能会改变对象的功能。
- en: Question 2
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is the main goal of the Flyweight design pattern?
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 飞舞设计模式的主要目标是什么？
- en: Answer
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The goal of the Flyweight design pattern is to conserve memory by reusing the
    same immutable state across multiple lightweight objects.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 飞舞设计模式的目标是通过在多个轻量级对象之间重用相同的不可变状态来节省内存。
- en: Question 3
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the difference between the Facade and Adapter design patterns?
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 外观模式和适配器设计模式之间的区别是什么？
- en: Answer
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: The Facade design pattern creates a new interface to simplify working with complex
    code, while the Adapter design pattern allows one interface to substitute another
    interface.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 外观设计模式创建了一个新的接口，以简化与复杂代码的交互，而适配器设计模式允许一个接口替代另一个接口。
- en: Chapter 4, Getting Familiar with Behavioral Patterns
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章，熟悉行为型模式
- en: Question 1
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What's the difference between Mediator and Observer design patterns?
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 中介和观察者设计模式之间的区别是什么？
- en: Answer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: Both serve a similar purpose. Mediator introduces tight coupling between components
    that may serve different purposes, while Observer operates on similar components
    that are loosely coupled.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都服务于类似的目的。中介引入了可能服务于不同目的的组件之间的紧密耦合，而观察者操作的是松散耦合的类似组件。
- en: Question 2
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is a **Domain-Specific Language** (**DSL**)?
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是**领域特定语言**（**DSL**）？
- en: Answer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答
- en: A DSL is a language that focuses on solving problems in a specific domain. This
    is different from a general-purpose language, such as Kotlin, that can be applied
    to different domains. Kotlin encourages developers to create DSLs for their needs.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DSL 是一种专注于解决特定领域问题的语言。这与像 Kotlin 这样的通用语言不同，Kotlin 可以应用于不同的领域。Kotlin 鼓励开发者根据需要创建
    DSL。
- en: Question 3
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What are the benefits of using a sealed class or interface?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用密封类或接口的好处是什么？
- en: Answer
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Since all types of a sealed class are known at compile time, Kotlin compiler
    can verify that the `when` statement covers all cases or, in other words, is exhaustive.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 由于密封类的所有类型在编译时都是已知的，Kotlin 编译器可以验证 `when` 语句涵盖了所有情况，换句话说，是详尽的。
- en: Chapter 5, Introducing Functional Programming
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章，介绍函数式编程
- en: Question 1
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What are higher order functions?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是高阶函数？
- en: Answer
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A higher order function is any function that either receives another function
    as input or returns a function as output.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 任何接收另一个函数作为输入或返回函数作为输出的函数都是高阶函数。
- en: Question 2
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is the `tailrec` keyword in Kotlin?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的 `tailrec` 关键字是什么意思？
- en: Answer
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The purpose of the `tailrec` keyword is to allow the Kotlin compiler to optimize
    tail recursion and avoid stack overflow.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`tailrec` 关键字的目的在于允许 Kotlin 编译器优化尾递归并避免栈溢出。'
- en: Question 3
  id: totrans-62
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What are pure functions?
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是纯函数？
- en: Answer
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Pure functions are functions that don't have any side effects, such as I/O.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 纯函数是没有任何副作用（如 I/O）的函数。
- en: Chapter 6, Threads and Coroutines
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章，线程和协程
- en: Question 1
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What are the different ways to start a coroutine in Kotlin?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，有哪几种方式可以启动协程？
- en: Answer
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A coroutine in Kotlin could be started with either the `launch()` or `async()`
    functions. The difference is that `async()` also returns a value, while `launch()`
    doesn't.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的协程可以用 `launch()` 或 `async()` 函数启动。区别在于 `async()` 也会返回一个值，而 `launch()`
    则不会。
- en: Question 2
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: With structured concurrency, if one of the coroutines fails, all the siblings
    will be canceled as well. How can we prevent that behavior?
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在结构化并发中，如果一个协程失败，所有兄弟协程也会被取消。我们如何防止这种行为？
- en: Answer
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: We can prevent canceling siblings by using `supervisorScope` instead of `coroutineScope`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用 `supervisorScope` 而不是 `coroutineScope` 来防止取消兄弟协程。
- en: Question 3
  id: totrans-75
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the purpose of the `yield()` function?
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield()` 函数的目的是什么？'
- en: Answer
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `yield()` function returns a value and suspends the coroutine until it has
    been resumed.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`yield()` 函数返回一个值并挂起协程，直到它被恢复。'
- en: Chapter 7, Controlling the Data Flow
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章，控制数据流
- en: Question 1
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What is the difference between higher order functions on collections and on
    concurrent data structures?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 集合上的高阶函数与并发数据结构上的高阶函数之间有什么区别？
- en: Answer
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Higher order functions on collections will process the entire collection, creating
    a copy of it, before proceeding to the next step. Higher order functions on concurrent
    data structures are reactive, processing one element after the other.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 集合上的高阶函数会在进行下一步之前处理整个集合，创建其副本。并发数据结构上的高阶函数是反应式的，逐个处理元素。
- en: Question 2
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What is the difference between cold and hot streams of data?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 数据的冷流和热流之间有什么区别？
- en: Answer
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A cold stream repeats itself for each new consumer, while the hot stream will
    only send the available data to the new consumer from the time of subscription.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 冷流会为每个新的消费者重复自身，而热流将只从订阅时开始将可用的数据发送给新的消费者。
- en: Question 3
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: When should a conflated channel/flow be used?
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在什么情况下使用合并通道/流？
- en: Answer
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A conflated flow can be used in situations when the consumer is slower than
    the producer and some of the messages could be dropped, leaving only the most
    recent message for consumption.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当消费者比生产者慢，并且一些消息可能会丢失，只留下最新消息供消费时，可以使用合并流。
- en: Chapter 8, Designing for Concurrency
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 8 章，设计并发
- en: Question 1
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What does it mean when we say that the `select` expression in Kotlin is biased?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们说 Kotlin 中的 `select` 表达式是偏斜的，这意味着什么？
- en: Answer
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A biased `select` expression means that in case of a *draw* between two channels,
    the first channel listed in the `select` expression will always be picked.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 偏斜的 `select` 表达式意味着在两个通道之间发生 *平局* 的情况下，`select` 表达式中列出的第一个通道将始终被选中。
- en: Question 2
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: When should you use a mutex instead of a channel?
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 应该在什么情况下使用互斥锁而不是通道？
- en: Answer
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Mutexes are used to protect a resource shared between multiple coroutines. Channels
    are used to pass data between coroutines.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 互斥锁用于保护多个协程之间共享的资源。通道用于在协程之间传递数据。
- en: Question 3
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: Which of the concurrent design patterns could help you implement **MapReduce**
    or a **divide and conquer** algorithm efficiently?
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 哪种并发设计模式可以帮助你有效地实现 **MapReduce** 或 **分而治之** 算法？
- en: Answer
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: For divide and conquer algorithms, the fan-out design pattern could be used
    to split the data and a fan-in design pattern could be used to combine the results.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于分而治之算法，可以使用扇出设计模式来分割数据，而可以使用扇入设计模式来合并结果。
- en: Chapter 9, Idioms and Anti-Patterns
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章，惯用和反模式
- en: Question 1
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What is the alternative to Java's `try`-with-resources in Kotlin?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中 Java 的 `try`-with-resources 的替代方案是什么？
- en: Answer
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: In Kotlin, the `use()` function works on the `Closeable` interface to make sure
    that resources are released after use.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，`use()` 函数在 `Closeable` 接口上工作，以确保在使用后释放资源。
- en: Question 2
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What are the different options for handling nulls in Kotlin?
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中处理空值的不同选项有哪些？
- en: Answer
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: 'There are multiple options to handle nulls: the Elvis operator, smart casts,
    and the `let` and `run` scope functions can help with that.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 处理空值有多种选择：Elvis 操作符、智能转换以及 `let` 和 `run` 范围函数都可以帮助处理这个问题。
- en: Question 3
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: Which problem can be solved by reified generics?
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 通过具体化泛型可以解决哪些问题？
- en: Answer
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: On JVM, types are erased at runtime. By inlining the generic function body into
    the call site, it allows preservation of the actual types used by the compiler.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JVM 上，类型在运行时被擦除。通过将泛型函数体内联到调用点，它允许保留编译器使用的实际类型。
- en: Chapter 10, Concurrent Microservices with Ktor
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 10 章，使用 Ktor 的并发微服务
- en: Question 1
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: How are the Ktor applications structured and what are their benefits?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 应用是如何构建的，它们有什么好处？
- en: Answer
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Ktor applications are divided into modules, each module being an extension function
    on the `Application` object. Modularizing our application allows us to test different
    aspects of it separately.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 应用被划分为模块，每个模块都是 `Application` 对象上的扩展函数。模块化我们的应用程序允许我们单独测试其不同方面。
- en: Question 2
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What are plugins in Ktor and what are they used for?
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Ktor 中的插件是什么，它们用于什么？
- en: Answer
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: Plugins are a way Ktor addresses cross-cutting concerns. They are used for serializing
    and deserializing requests and responses, and setting headers, and even routing
    itself is a plugin.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 插件是 Ktor 解决横切关注点的一种方式。它们用于序列化和反序列化请求和响应，设置头部，甚至路由本身也是一个插件。
- en: Question 3
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: What is the main problem that the `Exposed` library solves?
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exposed` 库主要解决了什么问题？'
- en: Answer
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The `Exposed` library provides a higher-level API for working with databases.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`Exposed` 库提供了一个高级 API，用于处理数据库。'
- en: Chapter 11, Reactive Microservices with Vert.x
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章，使用 Vert.x 的响应式微服务
- en: Question 1
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 1
- en: What's a verticle in Vert.x?
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 中的 verticle 是什么？
- en: Answer
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: A verticle is a lightweight actor that allows us to separate our business logic
    into small reactive units.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Verticle 是一种轻量级演员，允许我们将业务逻辑分离成小的反应单元。
- en: Question 2
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 2
- en: What's the goal of the Event Bus in Vert.x?
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Vert.x 中的事件总线有什么目标？
- en: Answer
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The Event Bus allows verticles to communicate with each other indirectly by
    sending and consuming messages.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 事件总线允许 verticles 通过发送和消费消息间接地相互通信。
- en: Question 3
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题 3
- en: Why shouldn't we block the event loop?
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们不应该阻塞事件循环？
- en: Answer
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 答案
- en: The event loop uses a limited number of threads to process many requests concurrently.
    If even one of the threads is blocked, it reduces the performance of a Vert.x
    app.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 事件循环使用有限数量的线程来并发处理多个请求。如果任何一个线程被阻塞，它都会降低 Vert.x 应用的性能。
