- en: Chapter 5. Light and Materials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 光与材料
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Implementing the per-vertex ambient light component
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现每顶点环境光分量
- en: Implementing the per-vertex diffuse light component
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现每顶点的漫反射光分量
- en: Implementing the per-vertex specular light component
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现每顶点的镜面光分量
- en: Optimizing the specular light with the halfway vector
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用半向量技术优化镜面光
- en: Gouraud shading – the per-vertex shading technique
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Gouraud着色 - 每顶点着色技术
- en: Phong shading – the per-fragment shading technique
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Phong着色 - 每片段着色技术
- en: Implementing directional and point light
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现方向光和点光源
- en: Implementing multiple lights in a scene
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中实现多个光源
- en: Implementing two-side shading
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现双面着色
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter will introduce the concepts of light and material in 3D graphics.
    We will understand the concept of light from the aspect of physics and its dual
    nature. We will discuss the different types of light components, such as ambient,
    diffuse and specular, with their implementation techniques. Later in this chapter,
    we will cover some important common illumination techniques (such as Phong shading
    and Gouraud shading). This will help us in implementing realistic-looking lighting
    models in computer graphics. In addition, you will learn the difference between
    directional and positional light and see how optimization can be achieved in the
    specular lighting by using the halfway vector technique. At the end of this chapter,
    we will demonstrate how to set up multiple lights in a scene and render objects
    with two-sided shading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将介绍3D图形中光和材料的概念。我们将从物理学的角度理解光的概念及其双重性质。我们将讨论不同类型的光分量，如环境光、漫反射光和镜面光，以及它们的实现技术。在本章的后面部分，我们将介绍一些重要的常见照明技术（如Phong着色和Gouraud着色）。这将帮助我们实现看起来逼真的照明模型。此外，你将了解方向光和位置光之间的区别，并了解如何通过使用半向量技术来优化镜面光。在本章的最后，我们将演示如何在场景中设置多个光源并使用双面着色渲染对象。
- en: 'Light is an electromagnetic radiation; it exists with an enormous range of
    frequencies or wavelengths. Human eyes can only see a portion of this wavelength
    of the electromagnetic spectrum and this range of portion is called visible light.
    Our eye receives these visible wavelengths as colors and the visible light spectrum
    varies from 400 nm (violet) to 700 nm (red):'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 光是一种电磁辐射；它存在一个巨大的频率或波长的范围。人眼只能看到电磁波谱中的一部分波长，这部分波长的范围被称为可见光。我们的眼睛将这些可见波长接收为颜色，可见光光谱从400
    nm（紫色）到700 nm（红色）变化：
- en: '![Introduction](img/5527OT_04_30.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/5527OT_04_30.jpg)'
- en: Light possesses important properties (such as intensity, direction, color, and
    location). In 3D graphics, we use these important properties of light to simulate
    various light models. In this chapter, we will use the OpenGL ES programmable
    pipeline to program various light models using shaders. This chapter will be helpful
    in providing an insight into all of the mathematics and physics required for lighting
    purposes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 光具有重要的特性（如强度、方向、颜色和位置）。在3D图形中，我们使用这些重要的光特性来模拟各种光模型。在本章中，我们将使用OpenGL ES可编程管道通过着色器编程各种光模型。这将有助于深入了解用于照明目的所需的所有数学和物理学。
- en: 'Back in 1600s, colors were believed to be a mixture of light and darkness.
    In 1672, Sir Issac Newton published a series of experiments and provided us with
    the modern understanding of light. He successfully refracted that white light
    consists of a mixture of seven different colors: red, orange, yellow, green, blue,
    indigo, and violet. He also proposed that light is composed of particles or corpuscles.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在17世纪，人们认为颜色是光和黑暗的混合物。在1672年，艾萨克·牛顿爵士发表了一系列实验，并为我们提供了对光的现代理解。他成功地证明了白光是由七种不同颜色的混合物组成的：红、橙、黄、绿、蓝、靛和紫。他还提出了光是由粒子或微粒组成的。
- en: Much later, in 1802, Thomas Young proved that light behaves as a wave through
    one of his experiments. He related colors to wavelength and managed to calculate
    the approximate wavelength of the seven colors discovered by Sir Isaac Newton.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在1802年很久以后，托马斯·杨通过他的一个实验证明了光的行为像波。他将颜色与波长联系起来，并设法计算了由艾萨克·牛顿爵士发现的七种颜色的近似波长。
- en: 'The final proposition of light was given by Albert Einstein in March, 1905\.
    That year, he published his quantum theory of light, where he proposed light as
    particles and named these particles **photons**. In June, 1905, he completed his
    theory of special relativity, which added a twist to his earlier proposal where
    light was believed to be a particle. The special theory of relativity sees light
    as a wave. Such contradiction gave enough proof to Einstein to propose the dual
    nature of light. According to him, light behaves both as a particle and a wave:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 光的最终理论是由阿尔伯特·爱因斯坦在1905年3月提出的。那年，他发表了光的量子理论，其中他提出光作为粒子，并将这些粒子命名为**光子**。1905年6月，他完成了他的狭义相对论理论，这给他的早期关于光被认为是粒子的提议增加了一个转折。狭义相对论将光视为波。这种矛盾为爱因斯坦提供了足够的证据来提出光的二象性。据他所说，光既表现为粒子又表现为波：
- en: '![Introduction](img/5527OT_04_31.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/5527OT_04_31.jpg)'
- en: 'Light has a dual nature; it can behave as a particle and wave at the same time.
    Let''s take a look in more detail:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 光具有二象性；它可以同时表现为粒子又表现为波。让我们更详细地看看：
- en: '**Light as a particle**: Light behaves as particles. These particles are small
    packets of energy that are not same as the small physical particles of atoms.
    These packets of energy have a constant velocity and no mass, which exhibit reflection
    properties that are similar to the billiard balls used in a pool game. When particles
    hit each other, they propagate in the direction of the force and are reflected
    as a result of obstacles. When photon particles hit obstacles, they lose energy
    in the form of absorption. As a result of continuous reflection, these particles
    strike and diminish. As a result of collision, the obstacle from these particles
    gains energy and preserves the law of conservation of energy.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光作为粒子**：光表现为粒子。这些粒子是能量的小包，与原子的小物理粒子不同。这些能量包具有恒定的速度和没有质量，表现出类似于台球游戏中使用的台球反射特性。当粒子相互碰撞时，它们沿着力的方向传播，并由于障碍物而反射。当光子粒子撞击障碍物时，它们以吸收的形式损失能量。由于持续的反射，这些粒子撞击并减小。由于碰撞，这些粒子从障碍物中获取能量并保持能量守恒定律。'
- en: '**Light as waves**: Light behaves as waves. These are electromagnetic waves
    with electric and magnetic properties. The electromagnetic waves do not need any
    medium to travel through space because they are capable of traveling through vacuum.
    Each wave looks like a sine wave. The intensity of the wave is measured with amplitude,
    as shown in the preceding figure. The length of one complete sine wave is called
    as **wavelength**. The greater the wavelength, more visible is the color. Treating
    light as waves in 3D computer graphics opens up many possibilities, which one
    cannot achieve with the particle nature of light. For example, the particle exhibits
    propagation as rays; it cannot simulate diffraction and interference which is
    an important property of waves.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**光作为波**：光表现为波。它们是具有电和磁性质的电磁波。电磁波不需要任何介质来穿越空间，因为它们能够穿越真空。每个波看起来像正弦波。波的强度用振幅来测量，如图所示。一个完整正弦波的长度称为**波长**。波长越大，颜色越明显。将光视为3D计算机图形中的波可以打开许多可能性，这是光粒子性质所不能实现的。例如，粒子表现出以射线形式传播；它不能模拟衍射和干涉，这是波的重要特性。'
- en: In a computer graphic simulation, the wave nature of light is represented by
    wave fronts stored as 2D arrays of complex numbers. The study of light in computer
    graphics in itself is a vast subject; covering wave-based illuminations is beyond
    the scope of this chapter. This chapter will help in modeling particle-based local
    light illumination modeling techniques.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形模拟中，光波的特性由存储为复数二维数组的波前表示。计算机图形中光的研究本身就是一个庞大的主题；涵盖基于波的照明超出了本章的范围。本章将帮助建模基于粒子的局部光照明建模技术。
- en: 'Light is composed of three types of components: ambient (**A**), diffuse (**D**),
    and specular (**S**). They are explained as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 光由三种类型的成分组成：环境光（**A**）、漫反射光（**D**）和镜面反射光（**S**）。它们如下所述：
- en: '**Ambient (A)**: This light component comes from all directions equally and
    is scattered in all the directions equally by the objects on which it falls; this
    makes the objects on the surface appear with constant light intensity.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**环境光（A）**：这种光成分从所有方向均匀地发出，并且被它所落到的物体均匀地散射到所有方向；这使得物体表面看起来具有恒定的光强度。'
- en: '**Diffuse (D)**: This light component comes from a particular direction from
    the light source. It hits the surface of an object with variable intensity, which
    depends on the Lambert law of illumination. In other words, the intensity depends
    on the direction of light appearing on the face of the object and the direction
    of object face point to.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**漫反射（D）**：这个光分量来自光源的特定方向。它以可变强度撞击物体的表面，这取决于朗伯照明定律。换句话说，强度取决于光出现在物体表面的方向和物体表面点的方向。'
- en: '**Specular (S)**: This light component also comes from a particular direction
    and reflects the most in the direction of the camera''s view or the observer''s
    eye. It gives an effect of shininess on the model''s surface:![Introduction](img/5527OT_04_32.jpg)'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**镜面反射（S）**：这个光分量也来自特定的方向，并在相机视角或观察者眼睛的方向上反射得最多。它给模型表面带来光泽效果：![简介](img/5527OT_04_32.jpg)'
- en: 'In computer graphics, light and material are both mathematically treated as
    colors. The color associated with an object is called material and the color associated
    with illumination is called light. The color intensity of light and material are
    specified with RGB (red, blue, green) components. Objects are visible because
    they reflect the light that falls up on them. For example, when sunlight falls
    on a green material color ball, the green material absorbs all other wavelengths
    and reflects the green portion of the light spectrum. As a result, it appears
    green to the viewer. Mathematically, the reflected or resultant color is the product
    of light and material color intensities:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，光和材料都被数学上视为颜色。与物体相关的颜色称为材质，与照明相关的颜色称为光。光和材质的颜色强度用RGB（红、蓝、绿）分量来指定。物体之所以可见，是因为它们反射了落在它们身上的光。例如，当阳光照在一个绿色的材质颜色球上时，绿色材质吸收了所有其他波长，并反射了光光谱中的绿色部分。因此，它对观众来说看起来是绿色的。从数学上讲，反射或最终的颜色是光和材质颜色强度的乘积：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '![Introduction](img/5527OT_04_33.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![简介](img/5527OT_04_33.jpg)'
- en: 'In modern computer graphics, there are two ways in which light shading equations
    can be calculated: per-vertex and per-fragment. They are explained as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代计算机图形学中，有两种计算光照着色方程式的方法：顶点着色和片段着色。它们如下所述：
- en: '**Per-vertex light shading**: In this type of shading, the mathematical equations
    to calculate light shading colors are formulated in the vertex shader. Each vertex
    color is calculated within the vertex shader and then passed on to the fragment
    shader. These vertex colors are then interpolated to the geometry faces to result
    each fragment or pixel color. As the colors are calculated in the vertex shader,
    it''s called per-vertex shading.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**顶点光照着色**：在这种着色类型中，计算光照颜色的数学方程式是在顶点着色器中制定的。每个顶点颜色在顶点着色器内计算，然后传递到片段着色器。这些顶点颜色随后被插值到几何面，以得到每个片段或像素颜色。由于颜色是在顶点着色器中计算的，因此称为顶点着色。'
- en: '**Per-fragment light shading**: This calculates light colors within the fragment
    shader for each fragment. The quality of per-fragment shading is considerably
    better than the vertex shader. The performance of per-fragment shading is slower
    than per-vertex shading. This is because processing fewer vertices, as compared
    to thousands of pixels, is quicker. In today''s modern graphics, processors are
    capable of performing several parallel operations at lightning speed; therefore,
    it may not be very expensive for general purpose application requirements.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**片段光照着色**：这为每个片段在片段着色器内计算光颜色。片段着色的质量比顶点着色好得多。片段着色的性能比顶点着色慢。这是因为处理顶点比处理数千个像素要快。在今天的现代图形中，处理器能够以闪电般的速度执行多个并行操作；因此，对于通用应用需求来说，这可能并不非常昂贵。'
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: One disadvantage of per-vertex light shading is that it may not be helpful for
    specular light to generate shading as expected because fragment colors are calculated
    at each vertex and shared among faces; therefore, instead of generating a smooth
    oval shining surface, it will generate a flat shining surface.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每个顶点光照着色的一个缺点是，它可能对生成预期的镜面反射光着色没有帮助，因为片段颜色是在每个顶点计算的，并在面之间共享；因此，它不会生成平滑的椭圆形发光表面，而会生成一个平坦的发光表面。
- en: Implementing the per-vertex ambient light component
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现顶点环境光分量
- en: 'The ambient light illuminates the object''s surface equally in all directions
    on which it''s applied. All faces receive an equal amount of light; therefore,
    no change in color can be observed on the complete object. Ambient is basically
    a mixture of two components: the color intensity of light and material.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光在应用到的所有方向上均匀照亮物体的表面。所有面都接收相等数量的光线；因此，在整个物体上观察不到颜色的变化。环境光基本上是两个组件的混合：光的颜色强度和材质。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Mathematically, this is the product ambient light (L[a]) and ambient material
    (K[a]).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，这是环境光（L[a]）和环境材质（K[a]）的乘积。
- en: '*I[a] = L[a]K[a]*'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '*I[a] = L[a]K[a]*'
- en: An ambient light plays a vital role in Phong and Gouraud shadings; the diffuse
    and specular color components of these shadings are computed by using the direction
    of the light that falls on the object. Therefore, an object may receive less or
    no light on its side or back faces depending on the direction of light on the
    object. In such cases, the faces may appear invisible because of the black light
    that is generated; choosing the correct ambient light and material color will
    help in making these darkened faces visible.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光在 phong 和 gouraud 渲染中起着至关重要的作用；这些渲染的漫反射和镜面颜色分量是通过使用照射到物体上的光的方向来计算的。因此，物体的一侧或背面可能会因为光的方向而接收较少或没有光线。在这种情况下，由于产生的黑色光线，这些面可能会看起来不可见；选择正确的环境光和材质颜色将有助于使这些暗面变得可见。
- en: Getting ready
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This chapter will make use of the Wavefront 3D mesh models that we implemented
    in [Chapter 4](ch04.html "Chapter 4. Working with Meshes"), *Working with Meshes*.
    We will reuse the ObjLoader recipe from the same chapter to implement new recipes
    in this chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用我们在 [第 4 章](ch04.html "第 4 章。处理网格") 中实现的 Wavefront 3D 网格模型，*处理网格*。我们将重用该章节中的
    ObjLoader 菜谱来实现本章的新菜谱。
- en: How to do it...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'The step-by-step implementation of ambient light is as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 环境光的逐步实现如下：
- en: 'Reuse the ObjLoader recipe from the previous chapter and create a new vertex
    shader file called `AmbientVertex.glsl` and add the following code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重用前一章中的 ObjLoader 菜谱，创建一个新的顶点着色器文件，名为 `AmbientVertex.glsl`，并添加以下代码：
- en: '[PRE1]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Similarly, create the `AmbientFragment.glsl` fragment shader file as:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建 `AmbientFragment.glsl` 片段着色器文件如下：
- en: '[PRE2]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the `InitModel()` of the `ObjLoader` class, compile these shaders and set
    the uniform variable parameters for the ambient light and material:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ObjLoader` 类的 `InitModel()` 中，编译这些着色器并设置环境光和材质的统一变量参数：
- en: '[PRE3]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `Render()` function is the same as before; it uses the VAO to render the
    Wavefront `OBJ` model.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`Render()` 函数与之前相同；它使用 VAO 渲染 Wavefront `OBJ` 模型。'
- en: How it works...
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: When the `ObjLoader` class object is created, it initializes the necessary parameters
    in the constructor. The `InitModel` function compiles the shader program and sets
    any necessary uniform variables; the vertex shader contains two uniform variables
    called `MaterialAmbient` and `LightAmbient`. The former is used to define the
    ambient color property of the material property of the object and the latter is
    used to specify the color of the light.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建 `ObjLoader` 类对象时，它会在构造函数中初始化必要的参数。`InitModel` 函数编译着色器程序并设置任何必要的统一变量；顶点着色器包含两个名为
    `MaterialAmbient` 和 `LightAmbient` 的统一变量。前者用于定义物体的材质属性的环境颜色属性，后者用于指定光的颜色。
- en: These variables are sent to the vertex shader and the ambience color shade is
    calculated as the product of these two variables; the result is stored in a new
    output variable called `FinalColor`. This variable is sent to the fragment shader
    and applied as a final color to each fragment. The `gl_position` is the clip coordinate
    value, which is a product of the vertex position and `ModelViewProjectionMatrix`.
    The `ModelViewProjectionMatrix` uniform variable is a product of the projection,
    view, and model matrix.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这些变量被发送到顶点着色器，环境颜色阴影被计算为这两个变量的乘积；结果存储在一个新的输出变量中，称为 `FinalColor`。该变量被发送到片段着色器，并作为最终颜色应用于每个片段。`gl_position`
    是裁剪坐标值，它是顶点位置和 `ModelViewProjectionMatrix` 的乘积。`ModelViewProjectionMatrix` 统一变量是投影、视图和模型矩阵的乘积。
- en: '![How it works...](img/5527OT_04_34.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_04_34.jpg)'
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: Refer to the *Rendering the wavefront OBJ mesh model* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Meshes"), *Working with Meshes*
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参阅 [第 4 章](ch04.html "第 4 章。处理网格") 中 *渲染 wavefront OBJ 网格模型* 的菜谱。
- en: Refer to the *Managing VBO with Vertex Array Objects* recipe in [Chapter 3](ch03.html
    "Chapter 3. New Features of OpenGL ES 3.0"), *New Features of OpenGL ES 3.0*
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第3章](ch03.html "第3章。OpenGL ES 3.0的新特性")中的*使用顶点数组对象管理VBO*配方，*OpenGL ES 3.0的新特性*
- en: Refer to the *Efficient rendering with Vertex Buffer Object* recipe in [Chapter
    2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请参考[第2章](ch02.html "第2章。OpenGL ES 3.0基础知识")中的*使用顶点缓冲对象进行高效渲染*配方，*OpenGL ES 3.0基础知识*
- en: Implementing the per-vertex diffuse light component
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现每个顶点的漫反射光分量
- en: Diffuse light comes from a particular direction and is reflected in various
    directions after collision with the surface of the object. In this section, we
    model this behavior by using the Phong Reflection Model, which was developed by
    Bui Tuong Phong in 1973\. This model proposed an illumination shading technique
    that uses a normal surface and the direction of incident light. When light strikes
    on an object's surface, some of its parts are reflected and the rest is partially
    absorbed. Therefore, we can calculate either the intensity of light absorbed or
    reflected, if one of the components is given.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 漫反射光来自特定方向，在撞击物体表面后向各个方向反射。在本节中，我们通过使用Bui Tuong Phong于1973年开发的Phong反射模型来模拟这种行为。该模型提出了一种使用正常表面和入射光方向的光照着色技术。当光击中物体的表面时，其中一部分被反射，其余部分部分吸收。因此，如果给出其中一个分量，我们可以计算吸收或反射的光强度。
- en: Note
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Total light intensity = reflection light intensity + absorption light intensity
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 总光强度 = 反射光强度 + 吸收光强度
- en: When 100 percent light intensity falls on a plain surface and 50 percent of
    it is reflected, it's obvious that 50 percent of light intensity is being absorbed
    or lost in the surroundings. In 3D graphics, we are only concerned with the reflected
    light intensity because we see objects as a result of the reflection of light
    on them. The diffuse and specular components of light basically use the Phong
    reflection model as a result of light and surface interaction to model illumination
    techniques.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 当100%的光强度落在平面上，并且其中50%被反射时，很明显有50%的光强度被吸收或损失在周围环境中。在3D图形中，我们只关心反射的光强度，因为我们看到物体是由于光在其表面上的反射。光的漫反射和镜面反射分量基本上使用Phong反射模型，这是由于光和表面相互作用来模拟光照技术。
- en: The Phong reflection model uses the Lambert cosine law to demonstrate the reflection.
    The Lambert cosine law uses the direction of incident light and the direction
    of surface geometry to calculate the intensity of light on the surface of geometry.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Phong反射模型使用拉姆伯特余弦定律来演示反射。拉姆伯特余弦定律使用入射光的方向和表面几何形状的方向来计算几何表面上的光强度。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Lambert cosine law states that the intensity of illumination on a diffuse
    surface is directly proportional to the cosine of the angle made by the surface
    normal vector and the direction of light.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 拉姆伯特余弦定律指出，漫反射表面的光照强度与表面法线向量与光方向所成的角的余弦值成正比。
- en: '![Implementing the per-vertex diffuse light component](img/5527OT_04_49.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![实现每个顶点的漫反射光分量](img/5527OT_04_49.jpg)'
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'The general mathematical equation to calculate diffuse light is:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 计算漫反射光的一般数学方程是：
- en: '*I[d] = L[d]K[d](N.S)*'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*I[d] = L[d]K[d](N.S)*'
- en: The *L[d]* and *K[d]* are the diffuse components of the light and material;
    the (*N.S*) is the dot product used to calculate the cosine of the angle between
    the surface normal (*N*) and the incident light vector (*S*); both these vectors
    must be normalized first before calculating the dot product. A normalized vector
    is a vector whose length is unity; it's also called unit vector. For this recipe,
    we will reuse our first recipe, that is, ambient and make changes, as described
    in the next section.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '*L[d]*和*K[d]*是光和材料的漫反射分量；(*N.S*)是用于计算表面法线(*N*)和入射光向量(*S*)之间角度余弦值的点积；这两个向量在计算点积之前必须先归一化。归一化向量是一个长度为1的向量；它也称为单位向量。对于这个配方，我们将重复使用我们的第一个配方，即环境光，并进行修改，如下一节所述。'
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Use the following instructions to implement the diffuse light component:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下说明来实现漫反射光分量：
- en: 'Reuse the last recipe for the per-vertex ambient light component (Ambient recipe)
    and create a new vertex shader file called `DiffuseVertex.glsl` in it, as shown
    in the following code:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复使用上一个配方中的每个顶点环境光分量（环境光配方），并在其中创建一个新的顶点着色器文件，命名为`DiffuseVertex.glsl`，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: There is no change in the fragment shader; we can reuse it from the last recipe,
    except we will rename it as `DiffuseFragment.glsl`.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 片段着色器没有变化；我们可以从上一个配方中重用它，除了我们将将其重命名为 `DiffuseFragment.glsl`。
- en: 'In the `InitModel` after the shader are compiled successfully, set the configuration
    for diffuse light and material color and specify the position of light in world
    coordinates:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在着色器编译成功后的 `InitModel` 中，设置扩散光和材料颜色的配置，并指定光在世界坐标中的位置：
- en: '[PRE5]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `Render()` function, specify the normal matrix, model view matrix, and
    model view project matrix, along with the generic vertex attributes:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Render()` 函数中，指定法线矩阵、模型视图矩阵和模型视图投影矩阵，以及通用的顶点属性：
- en: '[PRE6]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: How it works...
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: The diffuse light vertex shader uses vertex position, vertex normal, and light
    position to calculate the light shading using the Phong reflection model; each
    `VertexPosition` is transformed into an eye coordinate by multiplying it with
    `ModelViewMatrix`. Similarly, vertex normal also needs to convert to an eye coordinate
    so that the transformation is also applied to normal as well. This is achieved
    by multiplying the `Normal` with the `NormalMatrix`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 扩散光顶点着色器使用顶点位置、顶点法线和光位置，通过使用 Phong 反射模型来计算光照着色；每个 `VertexPosition` 都通过乘以 `ModelViewMatrix`
    转换为眼睛坐标。同样，顶点法线也需要转换为眼睛坐标，以便变换也应用于法线。这是通过将 `Normal` 乘以 `NormalMatrix` 来实现的。
- en: Note
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unlike vertex positions, which are transformed into eye coordinates using the
    `ModelView` matrix, vertex normal are transformed by using the `NormalMatrix`.
    The normal matrix is a submatrix of the model view matrix, but its specialty is
    that it preserves the normal of the geometry when an affine transformation is
    applied. `NormalMatrix` is the inverse transpose of the upper-left 3 x 3 matrix
    of the model view matrix.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与顶点位置不同，顶点法线是通过使用 `NormalMatrix` 来转换的，而顶点位置是通过使用 `ModelView` 矩阵转换成眼睛坐标的。法线矩阵是模型视图矩阵的子矩阵，但它的特点是当应用仿射变换时，它保留了几何体的法线。`NormalMatrix`
    是模型视图矩阵左上角 3x3 矩阵的逆转置。
- en: The `nLight` light vector is calculated by subtracting eye coordinates of the
    `eyeCoord` vertex position from `LightPosition`; the `nLight` direction is calculated
    from the surface to the light source. The `nLight` and `nNormal` must be normalized
    before taking the dot product in order to find the cosine angle between them.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`nLight` 光向量是通过从 `LightPosition` 减去 `eyeCoord` 顶点位置的眼睛坐标来计算的；`nLight` 方向是从表面到光源的方向。在计算它们之间的余弦角之前，`nLight`
    和 `nNormal` 必须被归一化，以便找到它们之间的余弦角。'
- en: Light intensity is stored as the cosine angle between the surface normal vector
    and light vector. The color information of the material and light is specified
    in two uniform variables, namely, `MaterialDiffuse` and `LightDiffuse`; the product
    of these two variables is stored in the new variable called diffuse. The cosine
    angle is calculated as the dot product of the `nLight` and `nNormal` and stored
    in the `cosAngle` variable.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 光强度存储为表面法线向量和光向量之间的余弦角。材料和光的颜色信息指定在两个统一变量中，即 `MaterialDiffuse` 和 `LightDiffuse`；这两个变量的乘积存储在新的变量中，称为扩散。余弦角是通过计算
    `nLight` 和 `nNormal` 的点积并存储在 `cosAngle` 变量中得到的。
- en: Note
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The intensity of light and material are basically used in terms of RGB components,
    which are always non-negative. Each component of R, G, and B is stored as a floating
    point number in the range between `0.0f` and `1.0f`. Light intensity is calculated
    as a cosine function, which can result in a range value between -1 and 1\. We
    do not want negative light intensities because they do not make sense. Therefore,
    we should only consider light intensity within the range of 0.0 and 1.0; for this
    reason, the `max()` function is used in the resultant light intensity.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 光和材料的强度基本上是以 RGB 分量的形式使用的，这些分量总是非负的。R、G 和 B 的每个分量都存储为介于 `0.0f` 和 `1.0f` 之间的浮点数。光强度是作为余弦函数计算的，这可能导致介于
    -1 和 1 之间的范围值。我们不希望有负的光强度，因为它们没有意义。因此，我们应该只考虑 0.0 和 1.0 范围内的光强度；因此，在最终的光强度中使用
    `max()` 函数。
- en: '![How it works...](img/5527OT_04_50.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_04_50.jpg)'
- en: The diffuse color shade is calculated as the product of diffuse and `cosAngle`
    and stored in a new out variable called `FinalColor`. This variable is sent to
    the fragment shader and applied to each fragment. The last line of the vertex
    shader helps to calculate clipped coordinates by multiplying the vertex position
    with the model view projection matrix.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 漫射颜色阴影是漫射和 `cosAngle` 的乘积，并存储在一个新的输出变量 `FinalColor` 中。该变量被发送到片段着色器并应用于每个片段。顶点着色器的最后一行通过将顶点位置与模型视图投影矩阵相乘来帮助计算裁剪坐标。
- en: See also
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: '*Implementing the per-vertex ambient light component*'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现每个顶点的环境光分量*'
- en: Implementing the per-vertex specular light component
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现每个顶点的镜面光分量
- en: Specular light is responsible for producing shininess on the surface of an object.
    Unlike diffuse light, which uses the incident ray and surface normal to find the
    intensity of light, specular light uses the reflected ray and the direction of
    the viewer to find the intensity of light.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 镜面光负责在物体表面产生光泽。与使用入射光线和表面法线来找到光强度的漫射光不同，镜面光使用反射光线和观察者的方向来找到光强度。
- en: Getting ready
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'The following figure illustrates the scenario in which the viewer''s position
    (camera) is brought in to the picture to demonstrate the mathematical calculations
    for specular light. The angle made by the incident ray of light with the normal
    of the surface is always equal to an angle of reflection with the same normal.
    Therefore, both **S** and **R** vectors create a **θ** angle with **N**. The **S**
    vector is represented by the opposite direction (**-S**); this is because we are
    interested in calculating the **R** reflection vector:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下图说明了将观察者的位置（相机）引入画面以演示镜面光数学计算的情景。光线入射角与表面法线的夹角始终等于与同一法线的反射角。因此，**S** 和 **R**
    向量都与 **N** 形成相同的 **θ** 角。**S** 向量表示相反方向（**-S**）；这是因为我们感兴趣的是计算**R**反射向量：
- en: '![Getting ready](img/5527OT_04_36.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![准备中](img/5527OT_04_36.jpg)'
- en: This shininess is dependent on the angle made between the viewer and the reflected
    light; if the angle between the viewer's vector and the reflected vector is small,
    then the surface is shinier.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这种光泽取决于观察者与反射光之间的角度；如果观察者向量与反射向量的夹角小，则表面越亮。
- en: 'Mathematically, in the Phong reflection model, the specular component''s reflection
    vector (**R**) is calculated as:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Phong 反射模型中，数学上，镜面分量的反射向量（**R**）的计算如下：
- en: '*R = 2N (N.S) + (-S)*'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '*R = 2N (N.S) + (-S)*'
- en: 'However, in the OpenGL ES shading language, we can use the `reflect()` function
    to calculate vector `R`:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在 OpenGL ES 着色语言中，我们可以使用 `reflect()` 函数来计算向量 `R`：
- en: '[PRE7]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The *α* angle between the *R* and *V* vectors can be calculated as the dot
    product between these two vectors. The *V* vector is in the eye coordinates; the
    vertices that are closer to the *R* vector in the same direction will cause shininess
    on the surface. Given *R* and *V*, the specular illumination can be calculated
    mathematically as:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*R* 和 *V* 向量之间的 *α* 角度可以通过这两个向量的点积来计算。*V* 向量在眼睛坐标系中；与 *R* 向量方向相同的顶点越接近，表面就会越有光泽。给定
    *R* 和 *V*，镜面照明可以通过数学方法计算如下：'
- en: '*I[s] = L[s]K[s]( R.V )[G]*'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '*I[s] = L[s]K[s]( R.V )[G]*'
- en: The *G* superscript in the preceding formula is used for glossy factor; its
    practical significance is to produce larger or smaller glossy spot on the surface
    of an object. Its value ranges between 1 and 200; the larger the value, smaller
    and brighter and vice versa.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个公式中的 *G* 上标用于光泽因子；其实际意义是在物体表面产生较大或较小的光泽点。其值介于1到200之间；数值越大，光泽点越小越亮，反之亦然。
- en: How to do it...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Reuse the previous implemented recipe for diffuse shading and make necessary
    changes in the shaders and program code, as described in the following steps:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 重用之前实现的漫射着色器配方，并在着色器和程序代码中根据以下步骤进行必要的更改：
- en: 'Create `SpecularVertex.glsl` and use the following instruction for the vertex
    shader; there is no change in the fragment shader. We can reuse the existing code:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `SpecularVertex.glsl` 并使用以下指令进行顶点着色器；片段着色器没有变化。我们可以重用现有的代码：
- en: '[PRE8]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the `InitModel,` load and compile the specular shader and set the configuration
    for specular light and material color. Also, specify the position of light in
    world coordinates:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InitModel,` 中加载并编译镜面着色器，并设置镜面光和材质颜色的配置。同时，指定光在世界坐标系中的位置：
- en: '[PRE9]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: How it works...
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The specular light vertex shader calculates the `nNormal`, `eyeCoord`, and
    `nLight` in the same way we computed it in the previous recipe. Calculate the
    direction of the viewer or the (*V*) camera by normalizing eye coordinates and
    the *R* reflection vector with the help of the reflect() function. The dot product
    of *R* and *V* is clamped by the max function within the range 0.0 and 1.0\. This
    result is used to calculate the power function with `ShininessFactor`, which is
    responsible for producing a glossy spot on the surface; the calculated result
    is stored in sIntensity. The `FinalColor` is calculated as a product of `sIntensity`,
    `MaterialSpecular`, and `LightSpecular`. This color information is sent to the
    fragment shader as an out variable and applied to respective fragments created
    by primitives formed by vertices:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 光滑光顶点着色器以与之前配方中相同的方式计算 `nNormal`、`eyeCoord` 和 `nLight`。通过使用 reflect() 函数，通过归一化眼坐标和
    *R* 反射向量来计算观察者或 (*V*) 相机的方向。*R* 和 *V* 的点积通过 max 函数限制在 0.0 和 1.0 的范围内。这个结果用于计算带有
    `ShininessFactor` 的功率函数，该函数负责在表面上产生光泽点；计算结果存储在 sIntensity 中。`FinalColor` 通过 `sIntensity`、`MaterialSpecular`
    和 `LightSpecular` 的乘积来计算。这些颜色信息作为输出变量发送到片段着色器，并应用于由顶点形成的原语创建的相应片段：
- en: '![How it works...](img/5527OT_04_37.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_04_37.jpg)'
- en: See also
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the per-vertex ambient light component*'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现每个顶点的环境光分量*'
- en: '*Implementing the per-vertex diffuse light component*'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现每个顶点的漫反射光分量*'
- en: Optimizing the specular light with the halfway vector
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用半程向量优化镜面光
- en: 'The specular illumination that we have implemented in the previous recipe uses
    the reflection vector from the incident light ray to demonstrate the spotty illumination.
    This reflection vector is calculated by the `reflect()` function in the GLSL.
    This function is slightly expensive to calculate. Therefore, instead of calculating
    the dot product between the reflection and the (`R.V`) camera vector, we can also
    calculate (`nNormal.H`), which is the dot product between our surface normal vector
    and the halfway vector. The `H` halfway vector is the vector between the camera
    (viewer''s) vector and incident light. In the following figure, you can see the
    resultant of the `V` and `S` vector (Note: not `-S`):'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的配方中实现的镜面反射照明使用入射光线的反射向量来展示点状照明。这个反射向量是通过 GLSL 中的 `reflect()` 函数计算的。这个函数的计算稍微有些昂贵。因此，我们不仅可以计算反射和
    (`R.V`) 相机向量之间的点积，还可以计算 (`nNormal.H`)，即我们的表面法线向量和半程向量之间的点积。`H` 半程向量是相机（观察者）向量与入射光之间的向量。在下面的图中，你可以看到
    `V` 和 `S` 向量的结果（注意：不是 `-S`）：
- en: '![Optimizing the specular light with the halfway vector](img/5527OT_04_38.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![使用半程向量优化镜面光](img/5527OT_04_38.jpg)'
- en: 'Mathematically, the halfway vector is calculated as:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，半程向量是计算如下：
- en: '*Halfway vector (H) = incident light vector (S) + camera vector (V)*'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '*半程向量 (H) = 入射光向量 (S) + 相机向量 (V)*'
- en: 'The equation to calculating the halfway specular light is:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 计算半程镜面光的方程是：
- en: '*H = S + V*'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '*H = S + V*'
- en: '*I[s] = L[s]K[s] ( N.H )[G]*'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*I[s] = L[s]K[s] ( N.H )[G]*'
- en: '![Optimizing the specular light with the halfway vector](img/5527OT_04_39.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![使用半程向量优化镜面光](img/5527OT_04_39.jpg)'
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'Use the previous recipe, *Implementing* *the per-vertex specular light component*,
    and make the following changes in the `SpecularVertex.glsl`. The changes in the
    following code are marked in bold. There is no change required in the fragment
    shader:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 使用之前的配方，*实现* *每个顶点的镜面光分量*，并在 `SpecularVertex.glsl` 中进行以下更改。以下代码中的更改以粗体标注。在片段着色器中不需要进行任何更改：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: How it works...
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this technique, we use the `nLight` incident light vector and the (`V`)
    camera vector to find the (`H`) resultant vector by adding them. Both vectors
    must be in the eye coordinates; the resultant halfway vector must be normalized
    in order to generate correct results. Calculate the dot product between the (`nNormal`)
    normal surface vector and the (`H`) halfway vector and substitute it in the equation
    mentioned previously to calculate specular illumination:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个技术中，我们使用 `nLight` 入射光向量和 (`V`) 相机向量通过相加来找到 (`H`) 结果向量。这两个向量都必须在眼坐标中；结果半程向量必须归一化，以便生成正确的结果。计算
    (`nNormal`) 法线表面向量与 (`H`) 半程向量之间的点积，并将其代入前面提到的方程中计算镜面照明：
- en: '[PRE11]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The current technique is considered to be more efficient as compared to the
    prior specular technique we implemented. The preceding image shows the difference
    between the two techniques. There is no doubt that using the halfway vector technique
    is an approximation and generates less obvious result characteristics in comparison
    to the original technique. This approximation is very close to reality; therefore,
    if you are not too bothered about precise quality, you can use the halfway vector
    to calculate the shininess of the surface.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们之前实现的先前的镜面技术相比，当前技术被认为更高效。前面的图像显示了两种技术之间的差异。毫无疑问，使用中点向量技术是一种近似，与原始技术相比，生成的结果特征不那么明显。这种近似非常接近现实；因此，如果您不太在意精确的质量，可以使用中点向量来计算表面的光泽度。
- en: Note
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to always use (`-S`) to calculate the reflection vector and use (`S`)
    to calculate the (`H`) halfway vector.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 记住始终使用（`-S`）来计算反射向量，并使用（`S`）来计算（`H`）中点向量。
- en: See also
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Implementing the per-vertex specular light component*'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现每顶点的镜面反射光分量*'
- en: Gouraud shading – the per-vertex shading technique
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Gouraud着色 - 每顶点着色技术
- en: This recipe implements the Phong reflection model with all the three components
    of light, that is, ambient (A), diffuse (D), and specular (S), which we looked
    at in the previous recipes. This illumination technique is also known as ADS or
    Gouraud shading. The Gouraud shading technique is per-vertex shading because the
    fragment's color is calculated in the vertex shader by using each vertex's position
    information.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方实现了包含光的三种成分（即周围（A）、漫反射（D）和镜面（S））的Phong反射模型，这些我们在之前的配方中已经探讨过。这种照明技术也称为ADS或Gouraud着色。Gouraud着色技术是每顶点着色，因为片段的颜色是在顶点着色器中通过使用每个顶点的位置信息来计算的。
- en: Getting ready
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe combines the effect of our ambient (A), diffuse (D), and specular
    (S) illumination, which we have implemented in our previous recipes, using the
    Phong reflection model technique. Mathematically, it''s the summation of ambient,
    diffuse, and specular fragment colors:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方结合了我们之前配方中实现的周围（A）、漫反射（D）和镜面（S）照明效果，使用的是Phong反射模型技术。从数学上讲，它是周围、漫反射和镜面片段颜色的总和：
- en: '*Gouraud shading color = ambient color + diffuse color + specular color*'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*Gouraud着色颜色 = 周围颜色 + 漫反射颜色 + 镜面颜色*'
- en: '![Getting ready](img/5527OT_04_40.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![准备工作](img/5527OT_04_40.jpg)'
- en: Before implementing the Gouraud shading, it's advisable to understand ambient,
    diffuse, and specular illumination techniques thoroughly, as mentioned in this
    chapter.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现Gouraud着色之前，建议您彻底理解本章中提到的周围、漫反射和镜面照明技术。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'The Gouraud shading recipe implementation will make use of the existing vertex
    shader files from the ambient, diffuse, and specular recipes in the current vertex
    shader called `GouraudShadeVertex.glsl`. This recipe uses a global function called
    `GouraudShading()` to implement the Gouraud shading technique; the fragment shader
    can be completely reused as it does not require any change. The following code
    snippet describes the Gouraud shading vertex shader:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: Gouraud着色配方实现将使用当前顶点着色器中名为`GouraudShadeVertex.glsl`的现有顶点着色器文件，这些文件来自周围、漫反射和镜面配方。本配方使用一个全局函数`GouraudShading()`来实现Gouraud着色技术；片段着色器可以完全重用，因为它不需要任何更改。以下代码片段描述了Gouraud着色顶点着色器：
- en: '[PRE12]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `GouraudShading()` function calculates the color for each vertex by adding
    the ambient, diffuse, and specular light colors; the resultant color information
    is returned to the `main()` program. The vertex shader then shares this color
    information to the fragment shader. The fragment shader interpolates the entire
    color for each fragment by using the color information received from the vertex
    shader.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '`GouraudShading()`函数通过添加周围、漫反射和镜面光颜色来计算每个顶点的颜色；结果的颜色信息返回到`main()`程序。然后顶点着色器将此颜色信息共享给片段着色器。片段着色器通过使用从顶点着色器接收到的颜色信息，通过插值计算每个片段的整个颜色。'
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The function definitions in OpenGL ES Shading Language is similar to the C language;
    it can return values and pass arguments by value. These do not support pointers
    or reference to send the information by address. For more information on function
    definition in GL Shading Language 3.0, refer to [http://www.khronos.org/files/opengles_shading_language.pdf](http://www.khronos.org/files/opengles_shading_language.pdf).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: OpenGL ES 着色语言中的函数定义与 C 语言类似；它可以返回值并通过值传递参数。它不支持指针或引用通过地址发送信息。有关 GL 着色语言 3.0
    中函数定义的更多信息，请参阅 [http://www.khronos.org/files/opengles_shading_language.pdf](http://www.khronos.org/files/opengles_shading_language.pdf)。
- en: This recipe is implemented using point light; the rays from a point light form
    different angles with vertex when it falls on the object.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本例使用点光实现；点光从不同角度发出光线，当它照射到物体上时与顶点形成不同的角度。
- en: See also
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: '*Implementing directional and point light*'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实现方向光和点光*'
- en: Phong shading – the per-fragment shading technique
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: phong 着色 – 按片段着色技术
- en: This shading technique is also called as smooth shading. In this recipe, we
    will implement Phong shading, which is a per-fragment illumination technique.
    Using the per-fragment technique, light shadings add more realism to the rendering
    scene in comparison to the per-vertex technique. We will compare Gouraud shading
    with Phong shading to see the relative difference between the two techniques.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种着色技术也称为平滑着色。在本例中，我们将实现 phong 着色，它是一种按片段的照明技术。使用按片段技术，与按顶点技术相比，光照着色可以为渲染场景添加更多真实感。我们将比较
    Gouraud 着色与 phong 着色，以查看两种技术之间的相对差异。
- en: In Phong shading, color intensities are directly calculated within the fragment
    shader with the help of light and material properties. The vertex shader is responsible
    for calculating the normal and vertex position in the eye coordinates; these variables
    are then passed on to the fragment shader. The vertex normal and vertex positions
    are interpolated and normalized for every fragment to produce the resultant fragment
    colors.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在 phong 着色中，顶点着色器负责在眼坐标系统中计算法线和顶点位置；然后这些变量传递到片段着色器。顶点法线和顶点位置对每个片段进行插值和归一化，以产生最终的片段颜色。
- en: How to do it...
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Use the following steps to implement and see this technique in action:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用以下步骤实现并查看此技术的实际效果：
- en: 'Create `PhongShadeVertex.glsl` and reuse most of the variables from previous
    recipes. Refer to the following code. The main difference is `normalCoord` and
    `eyeCoord`, which are defined as the out variables. Note: we will not use the
    properties of light and material in vertex shader; instead, these will be used
    in fragment shader:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PhongShadeVertex.glsl` 并重用之前示例中的大多数变量。参考以下代码。主要区别在于 `normalCoord` 和 `eyeCoord`，它们被定义为输出变量。注意：我们不会在顶点着色器中使用光和材质的属性；相反，这些将在片段着色器中使用：
- en: '[PRE13]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create the `PhongShadeFragment.glsl` fragment shader file and add all the light
    and material property variables to the required precision qualifier. We will use
    the medium precision qualifier; this precision qualifier precedes the type in
    the variable declaration:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `PhongShadeFragment.glsl` 片段着色器文件，并将所有光和材质属性变量添加到所需的精度限定符中。我们将使用中等精度限定符；这个精度限定符位于变量声明中的类型之前：
- en: '[PRE14]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: How it works...
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: In Phong shading, the vertex shader calculates the vertex normal (`normalCoord`)
    and vertex position in the eye coordinate system (`eyeCoord`) and sends it to
    the fragment shader. The fragment shader uses these values and interpolates the
    vertex normal and vertex position for each fragment. The interpolated values must
    be normalized in order to produce accurate results. The remaining process to calculate
    ambient, diffuse, and specular light is the same as discussed in the previous
    recipes.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 phong 着色中，顶点着色器计算顶点法线（`normalCoord`）和顶点位置在眼坐标系（`eyeCoord`）中的值，并将其发送到片段着色器。片段着色器使用这些值并对每个片段的顶点法线和顶点位置进行插值。为了产生准确的结果，插值值必须归一化。计算环境光、漫反射和镜面光的剩余过程与前面讨论的相同。
- en: By default, the vertex shader does not require any precision in order to be
    defined (it's optional). If no precision is defined in the vertex shader, then
    it's of the highest precision. In the fragment shader, the precision qualifier
    needs to be defined (it's not optional).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，顶点着色器不需要定义任何精度（它是可选的）。如果在顶点着色器中没有定义精度，则它将使用最高精度。在片段着色器中，需要定义精度限定符（它不是可选的）。
- en: There are three types of precision qualifier, namely, `lowp`, `medium`, and
    `highp`. These precision qualifiers could affect the performance of the application;
    it's therefore advisable to use the correct precision according to the implementation
    requirement. Lower precision may help to increase the FPS and power efficiency;
    however, it may reduce the quality of rendering. In our case, we will use the
    mediump precision for all the variables in the fragment shader.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 有三种精度限定符，分别是`lowp`、`medium`和`highp`。这些精度限定符可能会影响应用程序的性能；因此，建议根据实现要求使用正确的精度。较低的精度可能有助于提高FPS和功耗效率；然而，它可能会降低渲染质量。在我们的案例中，我们将为片段着色器中的所有变量使用`mediump`精度。
- en: '![How it works...](img/5527OT_04_41.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_04_41.jpg)'
- en: There's more...
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We have used the Wavefront OBJ mesh to demonstrate the light shading effects
    on 3D mesh models; you can explore more on meshes in the [Chapter 4](ch04.html
    "Chapter 4. Working with Meshes"), *Working with Meshes*. The same chapter describes
    the flat/smooth shading implementation using normal vectors.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用Wavefront OBJ网格来演示对3D网格模型的光照效果；你可以在[第4章](ch04.html "第4章. 处理网格")*处理网格*中探索更多关于网格的内容。同一章节描述了使用法向量实现的平面/平滑着色。
- en: 'The flat/smooth shading implementation can be enabled by using the `ObjMesh`
    class member function called `ParseObjModel`. This specifies the second argument
    as Boolean `true` (flat shading) or `false` (smooth shading). The comparative
    results for the two shading types are shown in the following figure:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过使用`ObjMesh`类的成员函数`ParseObjModel`来启用平面/平滑着色实现。这指定第二个参数为布尔值`true`（平面着色）或`false`（平滑着色）。两种着色类型的比较结果如图所示：
- en: '![There''s more...](img/5527OT_04_42.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![还有更多...](img/5527OT_04_42.jpg)'
- en: See also
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Rendering the wavefront OBJ* *mesh model* recipe in [Chapter 4](ch04.html
    "Chapter 4. Working with Meshes"), *Working with Meshes*
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第4章[渲染Wavefront OBJ网格模型](ch04.html "第4章. 处理网格")*处理网格*中的配方
- en: Implementing directional and point light
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现方向光和点光
- en: 'Light can be divided into three types, namely point light, directional light,
    and spot light. Let''s take a look in detail:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 光可以分为三种类型，即点光、方向光和聚光灯。让我们详细看看：
- en: '**Point light or positional light**: This type of light comes from a fixed
    position in the 3D space. The position of light and vertices of the object on
    which it falls is used to calculate the direction of the light. Point light emits
    light in all directions. Each vertex can have different directions of light, depending
    on its position from the light source, as shown in the following image.'
  id: totrans-179
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光或位置光**：这种类型的光来自3D空间中的一个固定位置。光的位置和它落下的物体的顶点用于计算光的方向。点光向所有方向发射光。每个顶点可以有不同的光方向，这取决于它从光源的位置，如图所示。'
- en: '**Directional light**: This type of light is a special case of the point light.
    Here, the direction of the light falling on the object is considered as nonvarying.
    This means that the direction of all the light rays are parallel. In directional
    light, the light source is considered infinitely far from the model, on which
    it''s supposed to fall. Sometimes, it''s better to assume the light direction
    to be parallel during the 3D scene rendering process. This is the best way to
    achieve nearly the same effect as point light if the distance between the source
    point and model is appreciably larger.'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**：这种类型的光是点光的一种特殊情况。在这里，考虑物体上落下的光的方向是不变的。这意味着所有光线的方向都是平行的。在方向光中，光源被认为是无限远处的模型，它应该落在上面。有时，在3D场景渲染过程中假设光方向为平行会更好。如果光源点和模型之间的距离明显较大，这是实现与点光几乎相同效果的最佳方式。'
- en: '**Spot light**: This type of light uses the direction of the light and a cutoff
    angle to form a cone-shaped imaginary 3D space, as shown in the following figure.
    The light that falls out of this shape is discarded and the light inside the cone
    forms the spotlight effect:![Implementing directional and point light](img/5527OT_04_43.jpg)'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚光灯**：这种类型的光使用光的方向和一个截止角度来形成一个圆锥形的虚拟3D空间，如图所示。超出这个形状的光被丢弃，而圆锥内的光形成聚光灯效果：![实现方向光和点光](img/5527OT_04_43.jpg)'
- en: Getting ready
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Sometimes, the position of the light source is considerably far from the objects.
    In such cases, it''s advisable to implement the light-shading technique using
    directional lighting. The point light shading technique is a little expensive
    because the light direction needs to be calculated per-vertex. It''s directly
    proportional to the number of vertices in the geometry. In contrast, directional
    light is treated in the constant direction where rays are assumed to be traveling
    in parallel directions. Unlike point light, light direction does not consider
    the vertex position in directional light:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，光源的位置与物体相当远。在这种情况下，建议使用方向光照来实现光照着色技术。点光源着色技术稍微昂贵一些，因为需要为每个顶点计算光线方向。它与几何中的顶点数量成正比。相比之下，方向光被视为在恒定方向上，假设光线以平行方向传播。与点光源不同，方向光中的光线方向不考虑顶点位置：
- en: '| Light type | **Mathematical formulation** | **Light direction** |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 光源类型 | **数学公式** | **光线方向** |'
- en: '| --- | --- | --- |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| Point | Light direction = light position - eye position | Variable |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 点 | 光线方向 = 光源位置 - 眼睛位置 | 可变 |'
- en: '| Directional | Light direction = light position | Constant |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 方向 | 光线方向 = 光源位置 | 常数 |'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'This recipe will demonstrate the difference between point light and directional
    light; all the previous recipes we have implemented so far used point light. In
    fact, with the previous section in this recipe, we understood which light to use
    when. The following instructions in bold are implemented in the fragment shader
    based on Phong shading; similar changes need to be performed in the vertex shader
    if Gouraud shading is implemented:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方将演示点光源与方向光源之间的区别；我们迄今为止已实现的全部配方都使用了点光源。实际上，在本配方的前一节中，我们了解了何时使用哪种光源。以下加粗的指令是在基于Phong着色的片段着色器中实现的；如果实现Gouraud着色，则需要在顶点着色器中执行类似更改：
- en: '**Point light or positional light**: This requires one change to implement
    point light:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点光源或位置光源**: 实现点光源需要做一项更改：'
- en: '[PRE15]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '**Directional light**: Similarly, change the statement marked in bold for directional
    light:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向光**: 类似地，更改加粗标记的方向光语句：'
- en: '[PRE16]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: How it works...
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In point lighting, the light vector is used to calculate the directional vector
    of light, with respect to each eye coordinate of the vertex; this produces variable
    directional vectors, which are responsible for different amount of light intensity
    at each vertex.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在点光源中，光向量用于计算相对于每个顶点的眼睛坐标的光的方向向量；这会产生可变的方向向量，这些向量负责每个顶点不同的光照强度。
- en: 'In contrast, directional light assumes all vertexes at origin (0.0, 0.0, and
    0.0). Hence, all the direction vector for each vertex are parallel. The following
    figure compares the point light technique and the directional light technique:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 相比之下，方向光假设所有顶点都在原点（0.0, 0.0, 和 0.0）。因此，每个顶点的方向向量都是平行的。以下图比较了点光源技术和方向光源技术：
- en: '![How it works...](img/5527OT_04_44.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![它是如何工作的...](img/5527OT_04_44.jpg)'
- en: Implementing multiple lights in a scene
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景中实现多个光源
- en: 'So far, all of our recipes are demonstrated using a single light source. This
    section will help us in implementing multiple lights in a scene. Unlike the fixed
    pipeline architecture, in which only eight lights can be added to the scene, the
    programmable pipeline does not impose any upper limit on the number of multiple
    lights. Adding multiple lights to the scene is very simple. It''s similar to the
    way we added one light position to create one color per-fragment. Now, we add
    *N* number of light sources to generate an average of *N* colors per-fragment:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们所有的配方都是使用单个光源进行演示的。本节将帮助我们实现场景中的多个光源。与只能向场景添加八个光源的固定管线架构不同，可编程管线不对多个光源的数量设置上限。向场景添加多个光源非常简单。这与我们添加一个光源位置以创建每个片段一个颜色的方式相似。现在，我们添加*N*个光源以生成每个片段*N*种颜色的平均值：
- en: '![Implementing multiple lights in a scene](img/5527OT_04_45.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![场景中实现多个光源](img/5527OT_04_45.jpg)'
- en: Mathematically, if light sources such as **L1**, **L2**, and **L3** create **FC1**,
    **FC2**, and **FC3** fragment colors individually, then the combined effect of
    these lights will be a single fragment color as a result of an average weight
    of all fragment colors.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学上讲，如果光源如**L1**、**L2**和**L3**分别创建**FC1**、**FC2**和**FC3**片段颜色，那么这些光源的综合效果将是一个单一的片段颜色，这是所有片段颜色的平均权重结果。
- en: Getting ready
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The vertex shader for this recipe does not require any special changes to the
    source code. Therefore, we can reuse the same vertex shader (which was implemented
    in the Phong shading recipe). This recipe requires a few changes to the fragment
    shader.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱的顶点着色器不需要对源代码进行任何特殊修改。因此，我们可以重用相同的顶点着色器（在Phong着色菜谱中实现）。这个菜谱需要对片段着色器进行一些修改。
- en: How to do it...
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'The steps to implement multiple light recipes are as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 实现多光源菜谱的步骤如下：
- en: 'Create a fragment shader file called `MultiLightFragment.glsl` and highlight
    it, as shown in the following code:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`MultiLightFragment.glsl`的片段着色器文件，并突出显示，如下面的代码所示：
- en: '[PRE17]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'There is no change required for the vertex shader; however, the main program
    specifies four different light positions and four different diffuse color configurations:'
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于顶点着色器不需要进行任何更改；然而，主程序指定了四个不同的灯光位置和四个不同的漫反射颜色配置：
- en: '[PRE18]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: How it works...
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The current recipe uses four lights to demonstrate multiple-light shading in
    a scene. These lights are positioned around the object (left, right, top, and
    bottom). Lights positioned at the left-hand side and the right-hand side use red-diffused
    light color, whereas lights positioned at the bottom and top are set with green-diffused
    light color.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 当前菜谱使用四个灯光来演示场景中的多光源着色。这些灯光位于对象周围（左、右、上、下）。左侧和右侧的灯光使用红色漫反射光颜色，而底部和顶部的灯光设置为绿色漫反射光颜色。
- en: Programmatically, the position of lights and diffuse light colors are defined
    as an array in our shader program with `LightPosition` and `LightDiffuseArray`
    respectively.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的着色器程序中，灯光的位置和漫反射光颜色以数组的形式定义，分别用`LightPosition`和`LightDiffuseArray`表示。
- en: '![How it works...](img/5527OT_04_47.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/5527OT_04_47.jpg)'
- en: The `GouraudShading()` function is modified to accept an argument, which uses
    an index of the position of the light that needs to be processed. The main program
    loops to calculate the average fragment color intensity. This fragment color is
    returned to the main program.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`GouraudShading()`函数被修改为接受一个参数，该参数使用需要处理的灯光位置的索引。主程序循环计算平均片段颜色强度。这个片段颜色返回到主程序。'
- en: Light positions that are closer to the surface of the sphere receive more intensity;
    therefore we can clearly see that the sphere is illuminated with green and red
    color at the top, bottom, left and right faces. The front part of the sphere is
    a mixture of green and red color because the intensities received by the sphere
    at the front face from all four light directions are equal.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 接近球面表面的灯光位置接收更多的强度；因此我们可以清楚地看到，球面在顶部、底部、左侧和右侧用绿色和红色照亮。球面的前部是绿色和红色的混合，因为球面在正面从所有四个光方向接收到的强度是相等的。
- en: Implementing two-side shading
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现双面着色
- en: In [Chapter 2](ch02.html "Chapter 2. OpenGL ES 3.0 Essentials"), *OpenGL ES
    3.0 Essentials*, we looked at the culling technique, which is a quick way to improve
    performance. This technique avoids rendering polygon faces that face backwards;
    it's not always desirable to clip the back faces (objects that are not completely
    enclosed are generally rendered with back faces). Sometimes, it makes sense to
    view these back faces with different colors. This will help the geometry shape
    to define characteristics that may not be visible with the same color on both
    sides of the faces (back and front).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第2章](ch02.html "第2章。OpenGL ES 3.0 基础")中，我们探讨了裁剪技术，这是一种快速提高性能的方法。这项技术避免了渲染面向背面的多边形面；通常不希望裁剪背面（不完全封闭的对象通常使用背面渲染）。有时，用不同的颜色查看这些背面是有意义的。这将有助于定义几何形状的特性，这些特性在面（背面和正面）的同一颜色上可能不可见。
- en: In this recipe, we will render a semi-hollow cylinder with different face colors
    (inside and outside). The first thing we need to do is to turn off the back culling.
    We can turn off the back culling with (`glDisable (GL_CULL_FACE)`).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将渲染一个具有不同面颜色（内部和外部）的半空心圆柱体。我们首先需要做的是关闭背面裁剪。我们可以通过`glDisable (GL_CULL_FACE)`来关闭背面裁剪。
- en: In order to apply different colors on the front and back faces, we need to recognize
    them first. The OpenGL ES shading language provides a simple global-level variable
    called `gl_FrontFacing` in the fragment shader, which helps us to recognize the
    fragments belonging to front facings. This API returns Boolean as `true` if the
    face is front facing and vice versa.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在正面和背面应用不同的颜色，我们首先需要识别它们。OpenGL ES着色语言在片段着色器中提供了一个简单的全局变量`gl_FrontFacing`，它帮助我们识别属于正面面的片段。此API返回布尔值`true`，如果面是正面，反之亦然。
- en: The normal position of the face helps in defining the direction in which it's
    pointing. The normal position of the front face is always in the opposite direction
    of the back face; we will use this clue to shade the front face and the back face
    with different colors.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 面的法线位置有助于定义其指向的方向。正面面的法线位置始终与背面面的方向相反；我们将使用这个线索用不同的颜色着色正面和背面。
- en: Getting ready
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The multiple lights shading recipe can be reused to implement two-side shading.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 多光源着色配方可以重用来实现双面着色。
- en: Note
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that culling is disabled in the program code; otherwise, two-side
    shading will not work.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 确保在程序代码中禁用了剔除；否则，双面着色将不会工作。
- en: How to do it...
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'There is no change required in the vertex shader. Create a fragment shader
    file called `TwoSideShadingFragment.glsl` and make the following changes mentioned
    in bold:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 在顶点着色器中不需要进行任何更改。创建一个名为`TwoSideShadingFragment.glsl`的片段着色器文件，并按照以下加粗内容进行更改：
- en: '[PRE19]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'The working principle for this recipe is very simple; the ideology behind is
    to check whether the primitive fragment belongs to the front face or the back
    face. If it belongs to the front face, assign it with one type of color coding;
    otherwise, chose another type of color. Within the fragment shader, check the
    front facing with `gl_FrontFacing`. Pass the fragment facing type in the `GouraudShading`
    function as an argument. Depending on the front and back facing Boolean value,
    this function will generate the color. We will use `MaterialDiffuseBackFace` and
    `LightDiffuse` for back facing and front facing diffuse light colors respectively.
    In order to calculate the Gouraud shading for back surfaces, we must use negative
    direction normal:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方的原理非常简单；其背后的理念是检查原始片段是否属于正面或背面。如果属于正面，则分配一种类型的颜色编码；否则，选择另一种类型。在片段着色器中，使用`gl_FrontFacing`检查正面。将片段面的类型作为参数传递给`GouraudShading`函数。根据正面和背面的布尔值，此函数将生成颜色。我们将使用`MaterialDiffuseBackFace`和`LightDiffuse`分别用于背面和正面漫反射光颜色。为了计算背面表面的Gouraud着色，我们必须使用负方向法线：
- en: '![How it works...](img/5527OT_04_48.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/5527OT_04_48.jpg)'
- en: See also
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Culling in OpenGL ES 3.0* recipe in [Chapter 2](ch02.html "Chapter 2. OpenGL
    ES 3.0 Essentials"), *OpenGL ES 3.0 Essentials*
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第2章中的*OpenGL ES 3.0中的剔除*配方，*OpenGL ES 3.0基础*
