- en: Chapter 2. Instant Gratification – Your First Application
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第二章. 立即满足感 – 您的第一个应用程序
- en: '*"Dream the impossible, seek the unknown, and achieve greatness."*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*"梦想不可能的事情，探索未知，成就伟大。"*'
- en: '*–*Anonymous**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*–*匿名**'
- en: 'Now that we are all charged up about RubyMotion and have our system set up,
    let''s create a simple RubyMotion application. We will try and keep it simple,
    but sometimes you may feel disconnected by monotonously typing the code. Although,
    going along is enough for now. Remember that mimicry is a powerful form of learning;
    that''s how we have learned most of our skills, such as talking, reading, writing,
    and that is how you will learn to program with RubyMotion. We promise you that
    by the end of this book, you will have sufficient knowledge of RubyMotion to create
    an iOS application and make it live on the App Store. In this chapter we will
    cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们对 RubyMotion 充满热情，并且已经设置了系统，让我们创建一个简单的 RubyMotion 应用程序。我们将尽量保持简单，但有时您可能会因为单调地输入代码而感到脱节。尽管如此，目前跟随进度就足够了。请记住，模仿是一种强大的学习方法；这就是我们学会大多数技能的方式，比如说话、阅读、写作，这也是您学习使用
    RubyMotion 编程的方式。我们向您保证，到这本书的结尾，您将拥有足够的 RubyMotion 知识来创建 iOS 应用程序并将其发布到 App Store。在本章中，我们将涵盖以下主题：
- en: Creating your first RubyMotion application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建您的第一个 RubyMotion 应用程序
- en: Understanding the folder structure
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解文件夹结构
- en: Exploring the command line
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索命令行
- en: Configuring your application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置您的应用程序
- en: REPL – the interactive console
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: REPL – 交互式控制台
- en: The debugger
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试器
- en: Your first application
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您的第一个应用程序
- en: Let's start with the classic `HelloWorld` application. As we have discussed
    in the last chapter, RubyMotion has a terminal-based flow, so let's fire up our
    terminal and create our very first RubyMotion application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从经典的 `HelloWorld` 应用程序开始。正如我们在上一章中讨论的，RubyMotion 有基于终端的流程，所以让我们启动我们的终端并创建我们的第一个
    RubyMotion 应用程序。
- en: '[PRE0]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: If you observe closely the output on the terminal screen, you will see that
    a lot of files and directories have been generated by a single `motion` command,
    which automatically creates standard directories, and you will also see the file
    structure that will quickly bring us onboard with app development, which we can
    work on later and enhance to make a fully functional application. Moreover, since
    the structure is common to all the RubyMotion apps, it's easy to understand.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察终端屏幕上的输出，您将看到单个 `motion` 命令生成了许多文件和目录，它自动创建了标准目录，您还将看到将快速使我们熟悉应用程序开发的文件结构，我们可以在以后对其进行工作并增强以制作一个功能齐全的应用程序。此外，由于结构对所有
    RubyMotion 应用程序都是通用的，因此很容易理解。
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just like the `motion` command, popular frameworks such as Ruby on Rails also
    have commands such as `rails` to create a predefined layout of the application.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `motion` 命令一样，流行的框架如 Ruby on Rails 也有 `rails` 这样的命令来创建预定义的应用程序布局。
- en: 'The following steps automatically compile the code and start the application
    on a simulator:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤会自动编译代码并在模拟器上启动应用程序：
- en: 'Start the application, traverse to the application directory, and type the
    following command:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动应用程序，切换到应用程序目录，并输入以下命令：
- en: '[PRE1]'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '![Your first application](img/5220OT_02_01.jpg)'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![您的第一个应用程序](img/5220OT_02_01.jpg)'
- en: Wow! The `rake` command automatically compiles the code and starts the application
    on a simulator. So far, we have not created any views for our application; that's
    why we can see a blank screen. It looks boring, but remember that we have not
    written a single line of code. So let's write some code, create some views, and
    build our application again.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 哇！`rake` 命令自动编译代码并在模拟器上启动应用程序。到目前为止，我们还没有为我们的应用程序创建任何视图；这就是为什么我们看到一个空白屏幕。看起来很无聊，但请记住，我们还没有编写一行代码。所以让我们写一些代码，创建一些视图，并再次构建我们的应用程序。
- en: Tip
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can open the RubyMotion project in your favorite editor. If you don't have
    an editor yet, you can use either TextEdit or VIM.
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以使用您最喜欢的编辑器打开 RubyMotion 项目。如果您还没有编辑器，您可以使用 TextEdit 或 VIM。
- en: 'Open the file `app_delegate.rb` in the app folder and add the following code
    in it:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序文件夹中打开 `app_delegate.rb` 文件，并在其中添加以下代码：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Let''s re-run our application by traversing to the application directory and
    typing the execute command (`rake`):'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们重新运行我们的应用程序，切换到应用程序目录并输入执行命令（`rake`）：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `rake` command will compile our code and fire up the iPhone simulator.
    We can see a blue pop-up saying **Hello World!** in the following screenshot:'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`rake` 命令将编译我们的代码并启动 iPhone 模拟器。您可以在以下屏幕截图中看到一个蓝色的弹出窗口，上面写着 **Hello World!**：'
- en: '![Your first application](img/5220OT_02_02.jpg)'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![您的第一个应用程序](img/5220OT_02_02.jpg)'
- en: Let's understand the code that we have written in `AppDelegate`. Here the application
    method (`didFinishLaunchingWithOptions:launchOptions`) is called first when our
    application starts. This will be the starting point of our application and the
    right place to define our window.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们了解我们在 `AppDelegate` 中编写的代码。在这里，当我们的应用程序启动时，首先调用应用程序方法（`didFinishLaunchingWithOptions:launchOptions`）。这将是我们应用程序的起点，也是定义我们窗口的正确位置。
- en: RubyMotion functions are a combination of the usual Ruby name method (`didFinishLaunchingWithOptions`)
    with their named parameters; a variable directly follows the function, which it
    refers to, and therefore, we don't need to know the implementation of the function.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RubyMotion 函数是常用 Ruby 方法名（`didFinishLaunchingWithOptions`）与其命名参数的组合；一个变量直接跟在函数后面，它引用了这个函数，因此，我们不需要知道函数的实现。
- en: Note
  id: totrans-31
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Named parameters were added to RubyMotion to preserve the existing Objective-C
    APIs, and the extra symbols are required parts of the method name, for example,
    `didFinishLaunchingWithOptions`:`launchOptions`.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 命名参数被添加到 RubyMotion 中，以保留现有的 Objective-C API，额外的符号是方法名称的必要部分，例如，`didFinishLaunchingWithOptions:``launchOptions`。
- en: As discussed, the code written in `AppDelegate` will be called automatically
    as the application is initialized.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如前所述，在应用程序初始化时，`AppDelegate` 中编写的代码将被自动调用。
- en: 'In the following code snippet, we created an object alert of the `UIAlertView`
    class and then we assigned a `Hello World!` string to the message attribute of
    the object. Now we have our alert object ready. To display this alert on the device
    screen, we call the show method on the alert object as follows:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我们创建了一个 `UIAlertView` 类的 alert 对象，并将一个 `Hello World!` 字符串赋值给对象的 message
    属性。现在我们的 alert 对象已经准备好了。要在设备屏幕上显示这个 alert，我们可以在 alert 对象上调用 show 方法，如下所示：
- en: '[PRE4]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`UIAlertView` is a class that is bundled in the `UIKit` framework of the iOS.
    We can use this class to display an alert message on the screen. This class is
    inherited from `UIView` that is inherited from `UIResponder` that, in turn, is
    inherited from `NSObject`.'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UIAlertView` 是 iOS 的 `UIKit` 框架中捆绑的一个类。我们可以使用这个类在屏幕上显示一个 alert 消息。这个类是从 `UIView`
    继承的，而 `UIView` 又是从 `UIResponder` 继承的，`UIResponder` 又是从 `NSObject` 继承的。'
- en: Note
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Why do we see the NS prefix?**'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**为什么我们看到 NS 前缀？**'
- en: Objective-C is a superset of C and thus doesn't have namespaces like in C++;
    therefore, the symbols must be prefixed with a unique prefix so that they don't
    collide. This is particularly important for symbols defined in a framework. The
    original code for the Cocoa frameworks came from the NextStep libraries, and so
    the NextStep engineers chose to prefix their symbols with NS.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Objective-C 是 C 的超集，因此没有像 C++ 中的命名空间；因此，符号必须使用唯一的前缀来标记，以避免冲突。这对于在框架中定义的符号尤其重要。Cocoa
    框架的原始代码来自 NextStep 库，因此 NextStep 工程师选择使用 NS 前缀来标记他们的符号。
- en: To exit the application, close the simulator by selecting the **exit** option
    or press *Command* + *Q*.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要退出应用程序，通过选择 **退出** 选项或按 *Command* + *Q* 来关闭模拟器。
- en: Tip
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The iOS simulator is a great tool for testing your applications quickly. It
    comes bundled with Xcode. But you can't test everything on the simulator. To test
    the shaking of a device, camera, GPS, Accelerometer, Gyroscope, and other device
    capabilities, you may require additional products to pass device data to the app
    in the simulator.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iOS 模拟器是一个快速测试应用程序的强大工具。它随 Xcode 一起提供。但是，你无法在模拟器上测试所有内容。为了测试设备的摇晃、相机、GPS、加速度计、陀螺仪和其他设备功能，你可能需要额外的产品将设备数据传递到模拟器中的应用程序中。
- en: Folder structure
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件夹结构
- en: 'In this section, we will understand the folder structure of our application
    as we know from the previous section that `motion create <project name>` sets
    up the directory structure with all the essential files to run a simple RubyMotion
    application. Let''s walk through each one of them to have a precise understanding
    of their function:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将了解我们应用程序的文件夹结构，正如我们从前一节中知道的那样，`motion create <project name>` 会设置目录结构，包括运行简单
    RubyMotion 应用程序所需的所有基本文件。让我们逐一了解它们的功能：
- en: 'The `app` folder: This is the core of your application code; you will write
    most of your code in this folder. RubyMotion iterates in this folder and loads
    any `.rb` file that it catches.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app` 文件夹：这是你应用程序代码的核心；你将在这个文件夹中编写大部分代码。RubyMotion 会在这个文件夹中迭代，并加载它捕获的任何 `.rb`
    文件。'
- en: Tip
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to keep your code somewhere else other than the `app` directory,
    add the folder path to the `Rakefile`.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你想在 `app` 目录之外的其他地方保存代码，请将文件夹路径添加到 `Rakefile` 中。
- en: 'The `app_delegate.rb` file in the `app` folder: This file is at the heart of
    the RubyMotion application. If you are a little familiar with iOS development,
    this is the delegate file. A delegate is an object that usually reacts to some
    event in another object and/or can affect how another object behaves. There are
    various methods that can be implemented in `UIApplicationDelegate`. These methods
    are called during the different phases of an application, such as during the finish
    of its launch, during termination, when the application is low on memory, and
    during the occurrence of important changes. While the application is running,
    tracking its state transitions is one of the main jobs of the application delegate.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`app`文件夹中的`app_delegate.rb`文件：这个文件是RubyMotion应用程序的核心。如果您对iOS开发有些了解，这个文件就是代理文件。代理是一个对象，它通常会对另一个对象中的某些事件做出反应，并且/或者可以影响另一个对象的行为。可以在`UIApplicationDelegate`中实现各种方法。这些方法在应用程序的不同阶段被调用，例如在启动完成时、在终止时、当应用程序内存不足时以及发生重要变化时。当应用程序运行时，跟踪其状态转换是应用程序代理的主要任务之一。'
- en: 'App delegates use the method `application:didFinishLaunchingWithOptions` as
    the first entry point. This method is called after your application has been launched.
    When this method is called, your application is in the inactive state. A few other
    methods available are:'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 应用程序代理使用`application:didFinishLaunchingWithOptions`方法作为第一个入口点。当您的应用程序启动后，该方法会被调用。当这个方法被调用时，您的应用程序处于非活动状态。还有一些其他的方法可用：
- en: '`applicationWillEnterForeground`'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicationWillEnterForeground`'
- en: '`applicationWillTerminate`'
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`applicationWillTerminate`'
- en: '`application:shouldSaveApplicationState`'
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application:shouldSaveApplicationState`'
- en: '`application:shouldRestoreApplicationState`'
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`application:shouldRestoreApplicationState`'
- en: A full list of available methods can be obtained from the iOS developer library
    ([http://developer.apple.com/library/ios](http://developer.apple.com/library/ios)).
    The good part here is that most of the methods are self-explanatory by their name.
    For example, `applicationWillEnterForeground` will be called when your application
    is relaunched.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可以从iOS开发者库（[http://developer.apple.com/library/ios](http://developer.apple.com/library/ios)）中获得可用的方法列表。这里的好处是，大多数方法的名字本身就具有自解释性。例如，当您的应用程序重新启动时，会调用`applicationWillEnterForeground`。
- en: Tip
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We see that in some iOS 6 applications, the app is restored to the previous
    state; we can handle this in an application delegate.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们看到在某些iOS 6应用程序中，应用程序被恢复到之前的状态；我们可以在应用程序代理中处理这种情况。
- en: 'The `resources` folder: As the name suggests, the `resources` folder contains
    static content, such as images, sounds, UI layouts, and icons that we use in our
    applications.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources`文件夹：正如其名所示，`resources`文件夹包含静态内容，例如图像、声音、UI布局和我们在应用程序中使用的图标。'
- en: 'The `Spec` folder: This folder contains automated test cases. RubyMotion supports
    a Ruby testing framework, Bacon; it is a small RSpec clone that is used for writing
    unit, functional, and UI tests. By default, it creates `main_spec.rb` as an example.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Spec`文件夹：这个文件夹包含自动测试用例。RubyMotion支持Ruby测试框架Bacon；它是一个小的RSpec克隆，用于编写单元测试、功能测试和UI测试。默认情况下，它创建`main_spec.rb`作为示例。'
- en: '`Rakefile`: With `Rakefile` we can configure our application name, resources,
    gems to be included, and the code location. We will discuss more about `Rakefile`
    later in this chapter.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Rakefile`: 使用`Rakefile`，我们可以配置应用程序名称、资源、要包含的gem以及代码位置。我们将在本章后面更详细地讨论`Rakefile`。'
- en: Some more goodies
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一些额外的功能
- en: We know that it's not so much fun to have only a simple `HelloWorld` pop-up
    as our very first application, so let's jazz up our code by adding some more goodies
    to our alert box; and this time, let's do things in a much better way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道，只有简单的`HelloWorld`弹出窗口作为我们的第一个应用程序并不是很有趣，所以让我们通过向警告框添加一些额外的功能来使我们的代码更加丰富；这次，让我们以更好的方式来做这件事。
- en: Earlier we had added an alert box in the delegate itself. Actually it is not
    a good idea to write code in the application delegate. It is better to write code
    in a Model-View-Controller (MVC) way. Right now we won't cover all three parts
    of the MVC architecture for now let's begin with the controller for our application
    and add three buttons in this alert box, add a title, and add a message for the
    title box.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们在代理本身中添加了一个警告框。实际上，在应用程序代理中编写代码并不是一个好主意。更好的做法是以模型-视图-控制器（MVC）的方式编写代码。现在我们不会涵盖MVC架构的所有三个部分，让我们先从我们的应用程序的控制器开始，在这个警告框中添加三个按钮，添加一个标题，并为标题框添加一条消息。
- en: 'The class `UIAlertView` that we''ve used in the last section has numerous properties,
    such as title, message, delegate, cancelButtonTitle, otherButtonTitles, and many
    more. Let''s use a few of them in our application as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一个章节中使用的`UIAlertView`类有众多属性，例如标题、消息、委托、取消按钮标题、其他按钮等。让我们在我们的应用程序中使用其中的一些，如下所示：
- en: 'Create a file `root_controller.rb` in the `app` folder and add the following
    code:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹中创建一个名为`root_controller.rb`的文件，并添加以下代码：
- en: '[PRE5]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To call this controller, we need to update our `AppDelegate` class. Replace
    the following code in your `app_delegate.rb` `file`:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要调用此控制器，我们需要更新我们的`AppDelegate`类。替换你的`app_delegate.rb`文件中的以下代码：
- en: '[PRE6]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Start the simulator by running the `rake` command from the console inside your
    application directory as follows:![Some more goodies](img/5220OT_02_03.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在应用程序目录内的控制台中运行`rake`命令来启动模拟器，具体操作如下：![更多好东西](img/5220OT_02_03.jpg)
- en: That's cool; our earlier `HelloWorld` pop-up has now been replaced with an alert
    box that has a title, a cancel button, and two other buttons.
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 非常酷；我们之前的`HelloWorld`弹出窗口现在已被替换为具有标题、取消按钮和两个其他按钮的警告框。
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The iOS SDK has been built around the MVC pattern that separates responsibilities
    and ends up with an application that is easy to design and maintain.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: iOS SDK是围绕MVC模式构建的，该模式分离了责任，最终得到一个易于设计和维护的应用程序。
- en: Let's understand the code
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让我们理解代码
- en: When an iPhone application starts, it puts a window on the screen, which we
    have created using the `UIWindow` class. You can think of a window as a drawing
    board where you can put anything, such as a button, textbox or label. The instance
    of the `UIWindow` class manages and coordinates the views of an application, which
    are displayed on a device screen.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当iPhone应用程序启动时，它会在屏幕上放置一个窗口，这是我们使用`UIWindow`类创建的。你可以把窗口想象成一个画布，你可以在上面放置任何东西，比如按钮、文本框或标签。`UIWindow`类的实例管理并协调应用程序在设备屏幕上显示的视图。
- en: A `UIScreen` object contains the bounding rectangle of the device's entire screen.
    So, `UIScreen.mainScreen.bounds` returns the rectangle size according to the screen
    size and orientation of the device.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIScreen`对象包含设备整个屏幕的边界矩形。因此，`UIScreen.mainScreen.bounds`返回根据设备屏幕大小和方向返回的矩形大小。'
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Every iOS application needs at least one window, which is an instance of the
    `UIWindow` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 每个iOS应用程序至少需要一个窗口，它是一个`UIWindow`类的实例。
- en: You might be wondering, should I remember all the properties and methods of
    the Apple iOS SDK, such as `UIAlertView`? It is not necessary to memorize them
    as one can always refer to the properties and methods from the iOS development
    library. Nevertheless, having a basic idea about the usage of a class can come
    in handy at times. The popular IDE, RubyMine, supports RubyMotion. It also has
    a useful autocompletion feature.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道，我是否需要记住所有Apple iOS SDK的属性和方法，例如`UIAlertView`？没有必要记住它们，因为你可以随时从iOS开发库中查阅属性和方法。然而，对类的使用有一个基本的了解有时会很有帮助。流行的IDE，RubyMine，支持RubyMotion。它还拥有一个有用的自动完成功能。
- en: Tip
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The more you understand, the less you have to memorize.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 理解得越多，需要记住的就越少。
- en: Exploring the command line
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索命令行
- en: RubyMotion is based on an underlying principle, "to use the tools which developers
    love". Therefore, to create an application using RubyMotion, we require only two
    tools; the first is your favorite editor and the second is the terminal. While
    developing a RubyMotion application, you will be required to familiarize yourself
    with the command line. Familiarity with the terminal always helps in faster and
    comfortable development.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion基于一个基本原理，“使用开发者喜爱的工具”。因此，要使用RubyMotion创建应用程序，我们只需要两个工具；第一个是你的首选编辑器，第二个是终端。在开发RubyMotion应用程序时，你需要熟悉命令行。熟悉终端总是有助于更快、更舒适地开发。
- en: Now that we have created our `HelloWorld` application, let us explore a few
    commands that we have already used, and remember that RubyMotion uses them considerably.
    These commands are responsible for inaugurating our RubyMotion projects, `motion`
    and `rake`.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经创建了`HelloWorld`应用程序，让我们探索一些我们已经使用过的命令，并记住RubyMotion相当程度上使用它们。这些命令负责启动我们的RubyMotion项目，`motion`和`rake`。
- en: Motion command – one-stopshop
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动作命令 – 一站式商店
- en: As used previously, the `motion` command creates our RubyMotion project and
    also supports various other options. The `motion` command is similar to the popular
    framework Ruby on Rails' `rails` command. Before we go any further, let's fire
    up our terminal and see what can be done using the `motion` command.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`motion` 命令创建我们的 RubyMotion 项目，并支持各种其他选项。`motion` 命令类似于流行的框架 Ruby on Rails
    的 `rails` 命令。在我们继续前进之前，让我们打开终端，看看可以使用 `motion` 命令做什么。
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`motion account`: This displays the account/license information on the browser.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion account`：此命令在浏览器上显示账户/许可证信息。'
- en: '`motion activate`: If you want to activate your RubyMotion framework with a
    new license or if you have not yet activated the framework, `motion activate`
    can be used.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion activate`：如果你想使用新的许可证激活你的 RubyMotion 框架，或者你尚未激活框架，可以使用 `motion activate`。'
- en: '`motion create <project name>`: This command will generate a RubyMotion project''s
    skeleton that will have all the essential files needed to begin developing an
    iOS application.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion create <项目名称>`：此命令将生成一个 RubyMotion 项目的骨架，其中包含开始开发 iOS 应用程序所需的所有基本文件。'
- en: '`motion ri <API-name>`: This command helps us to find the documentation for
    the API that has been mentioned.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion ri <API-name>`：此命令帮助我们找到已提及的 API 的文档。'
- en: '`motion update`: RubyMotion is a fast-moving framework and often requires updates.
    `motion update` updates your framework from the command line itself.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion update`：RubyMotion 是一个快速发展的框架，通常需要更新。`motion update` 命令可以从命令行本身更新你的框架。'
- en: '`motion support`: There may be times when you have questions only an expert
    can answer. `motion` `support` helps you connect with RubyMotion directly, and
    you can ask a question by filling up a form. It can also be used for any feature
    request or for reporting a bug.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`motion support`：有时你可能只有专家才能回答的问题。`motion support` 帮助你直接与 RubyMotion 连接，你可以通过填写表格来提问。它也可以用于任何功能请求或报告错误。'
- en: Rake tasks – get things done fast
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rake 任务 – 快速完成任务
- en: Rake is a simple Ruby build program with capabilities similar to `Make`. RubyMotion's
    `rake` command has many predefined tasks that help you do several trivial jobs,
    such as compiling your code to test in a simulator or creating a package to test
    on a device, with ease. Let's fire up our terminal again and check what tasks
    can be performed using `rake --tasks`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: Rake 是一个简单的 Ruby 构建程序，其功能类似于 `Make`。RubyMotion 的 `rake` 命令拥有许多预定义的任务，可以帮助你轻松完成一些琐碎的工作，例如将你的代码编译以在模拟器中测试，或者创建一个用于设备测试的包。让我们再次打开终端，并检查可以使用
    `rake --tasks` 执行哪些任务。
- en: '[PRE8]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following table elaborates the different Rake tasks:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下表详细说明了不同的 Rake 任务：
- en: '| Rake task | Description |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| Rake task | 描述 |'
- en: '| --- | --- |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| Rake archive | Create a `.ipa` archive |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| Rake archive | 创建 `.ipa` 归档 |'
- en: '| Rake archive:distribution | Create a `.ipa` archive for distribution |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| Rake archive:distribution | 创建用于分发的 `.ipa` 归档 |'
- en: '| Rake build | Build everything |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| Rake build | 构建所有内容 |'
- en: '| Rake build:device | Build the device version |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| Rake build:device | 构建设备版本 |'
- en: '| Rake build:simulator | Build the simulator version |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| Rake build:simulator | 构建模拟器版本 |'
- en: '| Rake clean | Clear build objects |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| Rake clean | 清除构建对象 |'
- en: '| Rake config | Show project config |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| Rake config | 显示项目配置 |'
- en: '| Rake ctags | Generate ctags |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| Rake ctags | 生成 ctags |'
- en: '| Rake default | Build the project, then run the simulator |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| Rake default | 构建项目，然后运行模拟器 |'
- en: '| Rake device | Deploy on the device |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| Rake device | 在设备上部署 |'
- en: '| Rake simulator | Run the simulator |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| Rake simulator | 运行模拟器 |'
- en: '| Rake spec | Same as a `spec:simulator` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| Rake spec | 与 `spec:simulator` 相同 |'
- en: '| Rake spec:device | Run the test/spec suite on the device |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| Rake spec:device | 在设备上运行测试/规范套件 |'
- en: '| Rake spec:simulator | Run the test/spec suite on the simulator |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| Rake spec:simulator | 在模拟器上运行测试/规范套件 |'
- en: '| Rake static | Create a static library |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Rake static | 创建静态库 |'
- en: So Rake has plenty of tasks to do, but most importantly, out of all these tasks,
    if we simply run Rake, it will build and run our application on the iOS simulator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，Rake 有许多任务可以执行，但最重要的是，在所有这些任务中，如果我们简单地运行 Rake，它将在 iOS 模拟器上构建和运行我们的应用程序。
- en: Rake file – configuring your application
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rake 文件 – 配置你的应用程序
- en: RubyMotion applications are highly configurable using different attributes in
    a `Rakefile`. These attributes, by default, come with a sensible value but can
    be overridden with custom values. Let's explore each one of them—this section
    will come in handy, time and again, as we proceed with our application.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion 应用程序可以通过 `Rakefile` 中的不同属性进行高度配置。默认情况下，这些属性具有合理的值，但可以用自定义值覆盖。让我们探索每一个——随着我们继续进行应用程序的开发，这一部分将一次又一次地派上用场。
- en: 'To see your current application configuration, run the `rake config` task,
    and you will be presented with the following list:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看当前应用程序配置，请运行`rake config`任务，您将看到以下列表：
- en: '[PRE9]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'You can see the entire configuration settings for your application. These settings
    can be modified in a `Rakefile`. You may find it easy to understand what these
    properties do by their names, but let us explain a few of them:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以查看应用程序的完整配置设置。这些设置可以在`Rakefile`中修改。您可能通过它们的名称就能轻松理解这些属性的作用，但让我们解释其中的一些：
- en: '`name`: This is where you can specify the name of your project as a string.
    By default, the name of your application will be the attribute that you passed
    during `motion create`.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`name`: 这里您可以指定项目名称，以字符串形式表示。默认情况下，应用程序的名称将是您在`motion create`期间传递的属性。'
- en: '`version`: This variable saves the current application version as a string;
    it is 1.0 by default.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`version`: 此变量以字符串形式保存当前应用程序版本；默认值为1.0。'
- en: '`identifier`: The project identifier is a string that is in reverse DNS—a naming
    convention that is in the reverse order of the domain name notation—such as `com.yourcompany.yourapp`.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`identifier`: 项目标识符是一个字符串，采用反向DNS命名约定——即域名表示法的反向顺序——例如`com.yourcompany.yourapp`。'
- en: '`delegate_class`: This is where you specify your application delegate class
    as a string that is loaded once the application starts. The default value is `AppDelegate`
    and the class is defined in the `app`/`app_delegate.rb` file. However, we can
    rename the `AppDelegate` class to a custom name of our choice and this then has
    to be updated in the `Rakefile`.'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delegate_class`: 这里您指定应用程序代理类，以字符串形式表示，一旦应用程序启动就会加载。默认值是`AppDelegate`，该类在`app`/`app_delegate.rb`文件中定义。然而，我们可以将`AppDelegate`类重命名为我们选择的任何自定义名称，然后必须在`Rakefile`中进行更新。'
- en: '`Files`: This shows every `.rb` file in the `app` directory in an array format.
    The default value is the result of executing the following expression:'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Files`: 以数组格式显示`app`目录中的每个`.rb`文件。默认值是执行以下表达式的结果：'
- en: '[PRE10]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '`framework`: This shows the names of the iOS frameworks that are used in our
    application in an array format. Soon you will be using many iOS frameworks, such
    as CoreFoundation, CoreMotion, and others, with your application. The build system
    is capable of dealing with dependencies, therefore they should be mentioned here.
    The default value is either `UIKit`, `Foundation`, or `CoreGraphics`.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`framework`: 以数组格式显示我们应用程序中使用的iOS框架名称。很快您将使用许多iOS框架，例如CoreFoundation、CoreMotion等，与您的应用程序一起使用。构建系统能够处理依赖项，因此它们应该在这里提及。默认值可以是`UIKit`、`Foundation`或`CoreGraphics`。'
- en: '`libs`: This variable shows the library paths that are to be linked to the
    application in an array format. It contains the path to public system libraries,
    for example, **/usr/lib/libz.dylib**. The default value is `[]`, an empty array.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`libs`: 此变量以数组格式显示要链接到应用程序的库路径。它包含公共系统库的路径，例如**/usr/lib/libz.dylib**。默认值是`[]`，一个空数组。'
- en: '`build_dir`: This variable is used to specify the directory path where you
    want the application build to be created in a string format. It must be relative
    to the project directory. The directory initially gets created automatically.
    In case it is not created, a temporary directory will be used instead. The default
    value is `build`.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`build_dir`: 此变量用于指定要创建应用程序构建的目录路径，以字符串格式表示。它必须是项目目录的相对路径。目录最初会自动创建。如果未创建，将使用临时目录代替。默认值是`build`。'
- en: '`resources_dir`: This variable is used to specify the directory for the resource
    files where all the images and icons go in a string format. It must be relative
    to the project directory. The default value is `resources`.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`resources_dir`: 此变量用于指定资源文件所在的目录，所有图像和图标都放在字符串格式中。它必须是项目目录的相对路径。默认值是`resources`。'
- en: '`spec_dir`: This variable is used to specify the directory of `spec` files
    where all our test cases are present in a String format. The default value is
    `spec`. It should be relative to the project directory.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spec_dir`: 此变量用于指定包含所有测试用例的`spec`文件所在的目录，以字符串格式表示。默认值是`spec`。它应该是项目目录的相对路径。'
- en: '`icons`: This variable lists the icons used for the application present in
    the `resources` folder in an `array` format, for example, `icon.png` and/or `icon-72.png`.
    The files should be in tune with Apple''s **HIG** (**Human Interface Guidelines**).
    By default, the value is `[]`, an empty array.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`icons`：此变量以数组格式列出 `resources` 文件夹中用于应用程序的图标，例如 `icon.png` 和/或 `icon-72.png`。文件应与
    Apple 的 **HIG**（**人类界面指南**）保持一致。默认值为 `[]`，一个空数组。'
- en: '`fonts`: This variable lists the names of the font files present in the `resources`
    directory in an `array` format. These fonts will be taken into account while either
    generating the application bundle or testing on a simulator.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fonts`：此变量以数组格式列出 `resources` 目录中存在的字体文件名称。这些字体将在生成应用程序包或模拟器测试时被考虑。'
- en: '`prerendered_icon`: iOS application icons usually have a reflective shine on
    them. For that purpose, this property is used. If it is false, we will get the
    reflective shine on the icon. By default, the value is false.'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`prerendered_icon`：iOS 应用程序图标通常具有反射光泽。为此目的，使用此属性。如果为 false，则图标上会有反射光泽。默认值为
    false。'
- en: '`device_family`: With this property, we can specify which family of iOS device
    our application supports. The values can be `iphone`, `ipad`, or for universal
    application [`:iphone`, `:ipad`]. By default it is `:iphone`.'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`device_family`：使用此属性，我们可以指定应用程序支持哪种 iOS 设备系列。值可以是 `iphone`、`ipad`，或者对于通用应用程序【`:iphone`、`:ipad`】。默认值为
    `:iphone`。'
- en: '`interface_orientations`: Apple iOS devices support various orientations for
    an application. They can be `portrait`, `landscape_left`, `landscape_right`, or
    `portrait_upside_down`. By default, the value is an array of `:portrait`, `:landscape_left`,
    or `:landscape_right`.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`interface_orientations`：Apple iOS 设备支持应用程序的各种方向。它们可以是 `portrait`、`landscape_left`、`landscape_right`
    或 `portrait_upside_down`。默认值为包含 `:portrait`、`:landscape_left` 或 `:landscape_right`
    的数组。'
- en: '`Xcode_dir`: This configuration tells us where the Xcode is installed.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Xcode_dir`：此配置告诉我们 Xcode 的安装位置。'
- en: Note
  id: totrans-136
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Giving a new value to the `XCode_dir` property should generally be done first,
    before changing other `Rakefile` properties.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 给 `XCode_dir` 属性赋予新值通常应该在更改其他 `Rakefile` 属性之前完成。
- en: '`sdk_version`: This configuration lets us decide which SDK version will be
    used. By default, the value is the most recent version of the supported SDK.'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sdk_version`：此配置让我们决定将使用哪个 SDK 版本。默认值为支持的 SDK 的最新版本。'
- en: '`deployment_target`: This configuration shows which iOS SDK to target for the
    RubyMotion project. By default, the value is of the current SDK version that is
    installed, but this can be changed to any desired version of the iOS SDK, for
    example, 6.0 that will use iOS SDK Version 6.0.'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`deployment_target`：此配置显示 RubyMotion 项目应针对哪个 iOS SDK。默认值为当前安装的 SDK 版本，但可以更改为任何所需的
    iOS SDK 版本，例如，使用 iOS SDK 版本 6.0 的 6.0。'
- en: '`codesign_certificate`: This configuration shows which code-signing certificate
    is used. By default, the value is the first iPhone developer certificate in the
    keychain utility; for example, in our case it is **iPhone developer: Paul Akshat
    (S3KPMT842Z)**.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`codesign_certificate`：此配置显示使用哪个代码签名证书。默认值为密钥链工具中的第一个 iPhone 开发者证书；例如，在我们的案例中是
    **iPhone developer: Paul Akshat (S3KPMT842Z)**。'
- en: '`provisioning_profile`: This configuration variable specifies the path of the
    provisioning profile.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`provisioning_profile`：此配置变量指定配置文件的路径。'
- en: '`seed_id`: The Apple provisioning profile has an identifier. This configuration
    shows us the same, which is usually the first application identifier picked from
    the provisioning profile.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`seed_id`：Apple 配置文件有一个标识符。此配置显示的是相同的标识符，通常是首次从配置文件中选择的第一个应用程序标识符。'
- en: REPL – the interactive console
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: REPL – 交互式控制台
- en: RubyMotion comes with an interactive console that lets us traverse and scan
    the code that we are using in our application. The good thing is that the console
    is connected to the application running on the simulator. This means that if we
    make any changes from the console, it will be reflected on the simulator in real
    time. Let's try this with our `HelloWorld` application.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion 内置了一个交互式控制台，允许我们遍历和扫描我们在应用程序中使用到的代码。好事是控制台连接到了模拟器上运行的应用程序。这意味着如果我们从控制台进行任何更改，它将在模拟器上实时反映。让我们用我们的
    `HelloWorld` 应用程序来试一试。
- en: 'Run the application as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 按以下步骤运行应用程序：
- en: '[PRE11]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'As expected, it will open a simulator and the terminal screen will show:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，它将打开一个模拟器，终端屏幕将显示：
- en: '[PRE12]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now hold the *Command* key and hover the mouse over the simulator. You will
    see a red-bordered box. As we move the mouse pointer over an element, we can see
    its corresponding class object appearing in the terminal window `(UIView:0xc5710c0)?`
    as seen in the following screenshot. Now click the mouse to select the object
    that you want to work on dynamically.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在按住 *Command* 键，将鼠标悬停在模拟器上。你会看到一个红色边框的框。当我们把鼠标指针移到元素上时，我们可以在终端窗口中看到其对应的类对象
    `(UIView:0xc5710c0)?`，如下面的截图所示。现在点击鼠标选择你想要动态工作的对象。
- en: '![REPL – the interactive console](img/5220OT_02_04.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![REPL – 交互式控制台](img/5220OT_02_04.jpg)'
- en: 'Try the following command on the terminal and observe the changes in the simulator:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在终端尝试以下命令并观察模拟器中的变化：
- en: '`self` returns the current object selected by the mouse.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`self` 返回当前鼠标选定的对象。'
- en: '[PRE13]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Create an object `blue` for the `UIColor` class and assign the color blue to
    the variable as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `UIColor` 类创建一个名为 `blue` 的对象，并将蓝色分配给变量，如下所示：
- en: '[PRE14]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'To change the background color of the view, use the `backgroundColor` property
    of the selected view as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改视图的背景颜色，请使用所选视图的 `backgroundColor` 属性，如下所示：
- en: '[PRE15]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Make sure that the background color on the simulator has been changed to blue
    as shown in the following screenshot:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 确保模拟器上的背景颜色已更改为如下截图所示的蓝色：
- en: '![REPL – the interactive console](img/5220OT_02_05.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![REPL – 交互式控制台](img/5220OT_02_05.jpg)'
- en: 'Let''s dismiss the alert box by clicking on any button and put a new alert
    box with the following code:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过点击任何按钮来关闭警告框，并使用以下代码添加一个新的警告框：
- en: '[PRE16]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The simulator shows a new alert box on screen without compiling the code as
    shown in the following screenshot:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器在屏幕上显示一个新的警告框，而无需编译代码，如下面的截图所示：
- en: '![REPL – the interactive console](img/5220OT_02_06.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![REPL – 交互式控制台](img/5220OT_02_06.jpg)'
- en: 'You can dismiss the alert box as follows:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以按照以下方式关闭警告框：
- en: '[PRE17]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We can see how REPL is a great tool for developing applications for iOS and
    how it helps us make changes dynamically. To make these changes permanent we need
    to add the same code to our source code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到 REPL 是一个开发 iOS 应用的优秀工具，以及它如何帮助我们动态地做出更改。为了使这些更改永久化，我们需要将相同的代码添加到我们的源代码中。
- en: Debugger – catch your mistakes!
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试器 – 捕捉你的错误！
- en: 'A typical debugger provides the ability to halt when specific conditions are
    encountered. It also offers sophisticated functions, such as running a program
    step by step, breaking or pausing the program for an examination based on breakpoints,
    and tracking the values of the variables at that state. RubyMotion Version 1.24
    and above support debugging using GDB: the GNU project debugger ([http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/)).'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 一个典型的调试器提供了在遇到特定条件时停止的能力。它还提供了复杂的功能，例如逐步运行程序、根据断点中断或暂停程序以进行检查，以及跟踪该状态下变量的值。RubyMotion
    版本 1.24 及以上支持使用 GDB 进行调试：GNU 项目调试器 ([http://www.gnu.org/software/gdb/](http://www.gnu.org/software/gdb/))。
- en: 'The RubyMotion debugger provides the following inbuilt debugging facilities:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: RubyMotion 调试器提供了以下内置调试功能：
- en: It stops the program at a specific line
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它在特定行停止程序
- en: It examines the problem when the program has stopped
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查程序停止时的问题
- en: It checks the value for the variables at a specific breakpoint
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它检查特定断点处的变量值
- en: Note
  id: totrans-173
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The RubyMotion compiler implements the **DWARF** debugging format's metadata
    for the Ruby language. This allows external programs, such as the debugger in
    our case, to retrieve source-level information about the RubyMotion application.
    The metadata is saved under a `.dSYM` bundle file at the same level as the `.app`
    bundle in the build directory of your project.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: RubyMotion 编译器实现了 Ruby 语言的 **DWARF** 调试格式的元数据。这使得外部程序，例如我们案例中的调试器，能够检索 RubyMotion
    应用程序关于源级别的信息。元数据保存在项目构建目录中与 `.app` 包同一级别的 `.dSYM` 包文件中。
- en: How to start debugging
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何开始调试
- en: There are three ways in which we can start the debugger.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有三种方式可以启动调试器。
- en: While testing on a simulator
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模拟器上进行测试时
- en: We can start the debugger with a simulator. The debugger will directly attach
    itself to the app and replace the interactive shell (REPL).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用模拟器启动调试器。调试器将直接附加到应用上并替换交互式外壳（REPL）。
- en: 'To start, just type:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，只需输入：
- en: '[PRE18]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: While testing on a device
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在设备上进行测试时
- en: We can start debugging with the device running simultaneously. The build system
    will start the iOS debugging server on the device and then remotely attach the
    debugger on your shell right after the application has been deployed on the device.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在设备运行的同时开始调试。构建系统将在设备上启动iOS调试服务器，然后在应用程序部署到设备后立即在您的shell上远程附加调试器。
- en: '[PRE19]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the release mode, local variables might not be accessible in the debugger
    as they are optimized to fit into CPU registers.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在发布模式下，局部变量可能无法在调试器中访问，因为它们被优化以适应CPU寄存器。
- en: Tip
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: To test your application on a device, you are required to enroll for the **Apple
    Developer Program**. We will discuss this in detail in later chapters.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 要在设备上测试您的应用程序，您需要注册 **Apple Developer Program**。我们将在后面的章节中详细讨论。
- en: Entering commands before starting
  id: totrans-187
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在开始之前输入命令
- en: 'We might need some breakpoint before loading the application; we can do this
    as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载应用程序之前，我们可能需要一些断点；我们可以这样做：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: On execution of this command, the GDB will start and we will be able to set
    the breakpoints. This is discussed in more detail in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 执行此命令后，GDB将启动，我们将能够设置断点。这将在下一节中更详细地讨论。
- en: Breakpoint
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: We can put breakpoints at a specific location of our application code using
    the `break` command and then pass the location where the debugger should stop
    the execution of the code using the `file_name:line_number` notation.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `break` 命令在应用程序代码的特定位置设置断点，然后使用 `file_name:line_number` 表示法传递调试器应停止代码执行的位置。
- en: 'Let''s try putting a breakpoint in our current application. To do so, we need
    to start our `HelloWorld` application in debugging mode as follows:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在当前应用程序中尝试设置一个断点。为此，我们需要以调试模式启动我们的 `HelloWorld` 应用程序，如下所示：
- en: '[PRE21]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now let''s set a breakpoint on the eighth line of the file `app_delegate.rb`
    as follows:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在 `app_delegate.rb` 文件的第八行设置一个断点，如下所示：
- en: '[PRE22]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the preceding command, the execution of your application will halt at line
    number 8 of the `app_delegate.rb` file.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 使用前面的命令，您的应用程序将在 `app_delegate.rb` 文件的第8行处停止执行。
- en: Listing breakpoints
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 列出断点
- en: 'To list the breakpoints that have been set up in the current debugging environment,
    we use the `info breakpoint` command as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出当前调试环境中设置的断点，我们使用以下 `info breakpoint` 命令：
- en: '[PRE23]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We can see that the list of breakpoints created in the last section can also
    be seen in the list.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，上一节中创建的断点列表也可以在列表中看到。
- en: Moving between the different breakpoints
  id: totrans-202
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在不同的断点之间移动
- en: The `continue` command will continue the execution of the program until it reaches
    the next breakpoint.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`continue` 命令将继续程序的执行，直到达到下一个断点。'
- en: '[PRE24]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We can also use its alias `c` as follows; it is more handy to use:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用其别名 `c` 如下；这样更方便：
- en: '[PRE25]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The `next` command will continue the execution of the program until the next
    source-level location. This is usually the very next line in the Ruby source code.
    You should have a look at the terminal for the relevant source code line.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`next` 命令将继续程序的执行，直到下一个源级位置。这通常是Ruby源代码中的下一行。您应该查看终端以获取相关的源代码行。'
- en: '[PRE26]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Checking the value of a local variable
  id: totrans-209
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查局部变量的值
- en: This is an important feature of debugging, to check the value of a variable
    at a specific breakpoint.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这是有助于调试的重要功能，可以在特定的断点检查变量的值。
- en: '[PRE27]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows that the alert is an object of the `UIAlertView` class
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明警报是 `UIAlertView` 类的对象
- en: '**Pro** (**print-ruby-object**) accepts two parameters as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**Pro** （**print-ruby-object**）接受以下两个参数：'
- en: The object on which the variable will be retrieved.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检索变量的对象。
- en: The variable name that you want to get.
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要获取的变量名称。
- en: Tip
  id: totrans-216
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'To check the variables available for us to execute, run the following command:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查我们可以执行的变量，请运行以下命令：
- en: '[PRE28]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Checking the value of an instance variable
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查实例变量的值
- en: 'We can also check the value of an instance variable during some breakpoint
    using **pri** (**print-ruby-ivar**) as follows:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在某个断点期间使用 **pri** （**print-ruby-ivar**）检查实例变量的值，如下所示：
- en: '[PRE29]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`pri` accepts two commands as follows:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '`pri` 接受以下两个命令：'
- en: The object on which the instance variable will be retrieved.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检索实例变量的对象。
- en: The instance variable that you want to get. Make sure to include the `@` character
    in the name.
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您想要获取的实例变量。请确保在名称中包含 `@` 字符。
- en: Tip
  id: totrans-225
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can use `pri @tweet` instead of `pri self @tweet`.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用 `pri @tweet` 而不是 `pri self @tweet`。
- en: Disable breakpoint
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 禁用断点
- en: 'To disable a breakpoint, use `disable` followed by the breakpoint number; it
    has to be disabled as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用断点，请使用 `disable` 后跟断点编号；它必须按照以下方式禁用：
- en: '[PRE30]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Exit debugger
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 退出调试器
- en: 'Type `quit` to exit the debugger as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 输入 `quit` 以退出调试器，如下所示：
- en: '[PRE31]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Tip
  id: totrans-233
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the example code**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the example code files for all Packt books you have purchased,
    and the graphics bundle of this book from your account at [http://www.packtpub.com](http://www.packtpub.com).
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从你购买的所有 Packt 书籍的账户中下载示例代码文件，以及本书的图形包，请访问 [http://www.packtpub.com](http://www.packtpub.com)。
- en: If you purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在其他地方购买了这本书，你可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给你。
- en: Summary
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let''s recap what we have done in this chapter:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下本章我们所做的工作：
- en: Created a simple RubyMotion application
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个简单的 RubyMotion 应用程序
- en: Discussed the basic RubyMotion application structure
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论了基本的 RubyMotion 应用程序结构
- en: Explored the commands available with RubyMotion
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索了 RubyMotion 可用的命令
- en: Performed different Rake tasks with RubyMotion
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RubyMotion 执行了不同的 Rake 任务
- en: Learned how to configure your RubyMotion application
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了如何配置你的 RubyMotion 应用程序
- en: Worked with the interactive console—REPL
  id: totrans-244
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用交互式控制台——REPL 进行工作
- en: Debugged your application using the RubyMotion debugger
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 RubyMotion 调试器调试你的应用程序
- en: In the next chapter, we turn our attention to RubyMotion data type objects—such
    as strings and arrays. We will also learn how to interface with C and we will
    focus on memory management in RubyMotion.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将关注 RubyMotion 数据类型对象——例如字符串和数组。我们还将学习如何与 C 进行接口，并重点关注 RubyMotion 中的内存管理。
