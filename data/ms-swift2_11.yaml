- en: Chapter 11. Working with Generics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 11 章。泛型的工作方式
- en: My first experience with generics was back in 2004, when they were first introduced
    in the Java programming language. I can still remember picking up my copy of *The
    Java Programming Language*, *Fourth edition*, which covered Java 5, and reading
    about Java's implementation of generics. Since then, I have used generics in a
    number of projects, not only in Java but in other languages as well. If you are
    familiar with generics in other languages, such as Java, the syntax that Swift
    uses will be familiar to you. Generics allow us to write very flexible and reusable
    code; however, just like with subscripts, we need to make sure that we use them
    properly and do not overuse them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我第一次接触泛型是在 2004 年，当时它们首次在 Java 编程语言中引入。我仍然记得我拿起我的 *The Java Programming Language*
    第四版，它涵盖了 Java 5，并阅读了关于 Java 泛型实现的内容。从那时起，我在许多项目中使用了泛型，不仅是在 Java 中，还在其他语言中也是如此。如果你熟悉其他语言中的泛型，如
    Java，Swift 使用的语法将对你来说很熟悉。泛型允许我们编写非常灵活和可重用的代码；然而，就像与下标一样，我们需要确保我们正确地使用它们，并且不要过度使用它们。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: An introduction to generics
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型的介绍
- en: Creating and using generic functions
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型函数
- en: Creating and using generic classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用泛型类
- en: Using associated types with protocols
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协议中的关联类型
- en: An introduction to generics
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型的介绍
- en: The concept of generics has been around for a while, so it should not be a new
    concept to developers coming from languages such as Java or C#. Swift's implementation
    of generics is very similar to these languages. For those developers coming from
    other languages such as Objective-C, which do not have generics, they might seem
    a bit foreign at first.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的概念已经存在了一段时间，因此对于来自像 Java 或 C# 这样的语言的开发者来说，这应该不是一个新的概念。Swift 对泛型的实现与这些语言非常相似。对于那些来自像
    Objective-C 这样的没有泛型的语言的开发者来说，它们可能一开始会显得有些陌生。
- en: Generics allow us to write very flexible and reusable code that avoids duplication.
    With a type safe language, such as Swift, we often need to write functions or
    types that are valid for multiple types. For example, we might need to write a
    function that swaps the values of two variables; however, we may use this function
    to swap two string types, two int types, and two double types. Without generics,
    we will need to write three separate functions; however, with generics, we can
    write one generic function to provide the swap functionality for multiple types.
    Generics allow us to tell a function or type—I know Swift is a type-safe language,
    but I do not know the type that will be needed yet. I will give you a placeholder
    for now and will let you know what type to enforce later.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型允许我们编写非常灵活和可重用的代码，避免了重复。在像 Swift 这样的类型安全语言中，我们经常需要编写适用于多种类型的函数或类型。例如，我们可能需要编写一个交换两个变量值的函数；然而，我们可能使用这个函数来交换两个字符串类型、两个整型类型和两个双精度浮点类型。没有泛型，我们将需要编写三个单独的函数；但是，有了泛型，我们可以编写一个泛型函数，为多种类型提供交换功能。泛型允许我们告诉一个函数或类型——我知道
    Swift 是一个类型安全语言，但我不知道还需要哪种类型。我现在会给你一个占位符，稍后我会告诉你需要强制执行的类型。
- en: In Swift, we have the ability to define both generic functions and generic types.
    Let's look at generic functions first.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中，我们有能力定义泛型函数和泛型类型。让我们首先看看泛型函数。
- en: Generic functions
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型函数
- en: 'Let''s begin by examining the problem that generics try to solve and then we
    will see how generics solve this problem. Let''s say that we wanted to create
    functions that swapped the values of two variables (as described in the introduction);
    however, for our application, we have a need to swap two ints, two doubles, and
    two strings. Without generics, this would require us to write three separate functions.
    The following code shows what these functions would look similar to:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从检查泛型试图解决的问题开始，然后我们将看到泛型是如何解决这个问题的。假设我们想要创建交换两个变量值的函数（如介绍中所述）；然而，对于我们的应用程序，我们需要交换两个整型、两个双精度浮点型和两个字符串。没有泛型，这将需要我们编写三个单独的函数。以下代码显示了这些函数可能看起来像什么：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With these three functions, we can swap the original values of two ints, two
    doubles, and two strings. Now, let''s say, as we develop our application further,
    we find out that we also need to swap the values of two UInt32, two floats, or
    even a couple of custom types. We might easily end up with eight or nine swap
    functions. The worst part is that each of these functions contains duplicate code.
    The only difference between these functions is the type of variable change. While
    this solution does work, generics offer a much more elegant and simple solution
    that eliminates the duplication of code. Let''s see how we would condense all
    these three preceding functions into a single generic function:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这三个函数，我们可以交换两个整数的原始值、两个双精度浮点数和两个字符串的值。现在，假设，随着我们进一步开发应用程序，我们发现我们还需要交换两个`UInt32`、两个浮点数或甚至是一些自定义类型的值。我们可能会轻易地得到八个或九个交换函数。最糟糕的部分是，这些函数中每个都包含重复的代码。这些函数之间的唯一区别是变量类型的改变。虽然这个解决方案是可行的，但泛型提供了一个更加优雅和简单的解决方案，它消除了代码的重复。让我们看看我们如何将这些三个先前的函数压缩成一个泛型函数：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Let's look at how we defined the `swap()` function. The function itself looks
    pretty similar to a normal function, except for the capital `T`. The capital `T`,
    as used in the `swap()` function, is a placeholder type and tells Swift that we
    will be defining the type later. When we do define the type, the type we define
    will replace all the placeholders.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们是如何定义`swap()`函数的。函数本身看起来与普通函数非常相似，只是有一个大写的`T`。在`swap()`函数中使用的大写`T`是一个占位符类型，它告诉Swift我们将在稍后定义该类型。当我们定义类型时，我们定义的类型将替换所有占位符。
- en: To define a generic function, we include the placeholder type between two angular
    brackets (`<T>`) after the function's name. We can then use that placeholder type
    in place of any type definition within the parameter definitions, the return type,
    or the function itself. The big thing to keep in mind is that, once the placeholder
    is defined as a type, all the other placeholder assume that type. Therefore, any
    variable or constant defined with that placeholder must conform to that type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要定义一个泛型函数，我们在函数名后面包含两个尖括号`<T>`中的占位符类型。然后我们可以使用该占位符类型来代替参数定义、返回类型或函数本身中的任何类型定义。需要牢记的是，一旦占位符被定义为类型，所有其他占位符都会假定该类型。因此，使用该占位符定义的任何变量或常量都必须符合该类型。
- en: 'There is nothing special about the capital `T`, we could use any valid identifier
    in place of `T`. The following definitions are perfectly valid:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 大写的`T`并没有什么特殊之处，我们可以用任何有效的标识符来代替`T`。以下定义是完全有效的：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In most documentation, generic placeholders are defined with either `T` (for
    type) or `E` (for element). For standard purposes, we will use `T` to define generic
    placeholders in this book. It is also good practice to use `T` to define a generic
    placeholder within our code so that the placeholder is easily recognized when
    we are looking at the code at a later time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数文档中，泛型占位符通常使用`T`（表示类型）或`E`（表示元素）来定义。对于标准用途，我们将在本书中使用`T`来定义泛型占位符。在代码中使用`T`来定义泛型占位符也是一个好的实践，这样当我们稍后查看代码时，占位符可以很容易地被识别。
- en: 'If we need to use multiple generic types, we can create multiple placeholders
    by separating them with commas. The following example shows how to define multiple
    placeholders for a single function:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们需要使用多个泛型类型，我们可以通过逗号分隔来创建多个占位符。以下示例展示了如何为单个函数定义多个占位符：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In this example, we are defining two generic placeholders, `T` and `E`. In this
    case, we can set the `T` placeholder to one type and the `E` placeholder to a
    different type.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们定义了两个泛型占位符，`T`和`E`。在这种情况下，我们可以将`T`占位符设置为一种类型，将`E`占位符设置为另一种类型。
- en: 'Let''s look at how to call a generic function. The following code will swap
    two integers using the `swapGeneric<T>(inout a: T, inout b: T)` function:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '让我们看看如何调用一个泛型函数。以下代码将使用`swapGeneric<T>(inout a: T, inout b: T)`函数交换两个整数：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we run this code, the `a: 10 b: 5` line will be printed to the console.
    We can see that we do not have to do anything special to call a generic function.
    The function infers the type from the first parameter and then sets all the remaining
    placeholders to that type. Now, if we need to swap the values of two strings,
    we will call the same function like this:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们运行这段代码，控制台将打印出`a: 10 b: 5`这一行。我们可以看到，调用一个泛型函数不需要做任何特殊的事情。函数会从第一个参数推断类型，然后将所有剩余的占位符设置为该类型。现在，如果我们需要交换两个字符串的值，我们将以这种方式调用相同的函数：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We can see that we call the function in exactly the same way as we called it
    when we wanted to swap two integers. One thing that we cannot do is pass two different
    types into the `swap()` function because we defined only one generic placeholder.
    If we attempt to run the following code, we will receive an error:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，我们调用函数的方式与我们想要交换两个整数时调用的方式完全相同。我们无法做的一件事是将两种不同的类型传递给`swap()`函数，因为我们只定义了一个泛型占位符。如果我们尝试运行以下代码，我们会收到一个错误：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The error that we will receive is `cannot invoke ''swap'' with an argument
    list of type ''(inout Int, b: inout String`, which tells us that we are attempting
    to use a string value with an int value when the function wants only type. The
    reason the function is looking for an Int value is that the first parameter that
    we pass into the function is an Int value; therefore, all the generic types in
    the function became Int types.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将收到的错误是`cannot invoke ''swap'' with an argument list of type ''(inout Int,
    b: inout String)`，这告诉我们我们试图在函数只需要类型时使用一个字符串值和一个整数值。函数寻找Int值的原因是我们传递给函数的第一个参数是一个Int值；因此，函数中的所有泛型类型都变成了Int类型。'
- en: 'Now, let''s say we have the following function that has multiple generic types
    defined:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们有一个以下具有多个泛型类型定义的函数：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This function would accept parameters of different types; however; since they
    are of different types, we would be unable to swap the values because the types
    are different. There are also other limitations on generics. For example, we may
    think that the following generic function would be valid; however, we would receive
    an error if we tried to implement it:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数将接受不同类型的参数；然而，由于它们的类型不同，我们将无法交换值，因为类型不同。泛型还有一些其他限制。例如，我们可能会认为以下泛型函数是有效的；然而，如果我们尝试实现它，我们会收到一个错误：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The error that we receive is `binary operator '==' cannot be applied to two
    'T' operands`. Since the type of the arguments is unknown at the time the code
    is compiled, Swift does not know if it is able to use the equal operator on the
    types; therefore, the error is thrown. We might think that this is a limit that
    will make generics hard to use; however, we have a way to tell Swift that we expect
    the type, represented by the placeholder will have a certain functionality. This
    is done with type constraints.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们收到的错误是`binary operator '==' cannot be applied to two 'T' operands`。由于在编译代码时参数的类型是未知的，Swift不知道它是否能够在这些类型上使用等号运算符；因此，抛出了错误。我们可能会认为这是一个将使泛型难以使用的限制；然而，我们有一种方法可以告诉Swift我们期望由占位符表示的类型将具有某些功能。这是通过类型约束来完成的。
- en: 'A type constraint specifies that a generic type must inherit from a specific
    class or conform to a particular protocol. This allows us to use the methods and
    properties defined by the parent class or protocol within the generic function.
    Let''s look at how to use type constraints by rewriting the `genericEqual()` function
    to use the comparable protocol:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类型约束指定了一个泛型类型必须从特定的类继承或符合特定的协议。这允许我们在泛型函数中使用由父类或协议定义的方法和属性。让我们通过重写`genericEqual()`函数以使用可比较协议来查看如何使用类型约束：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: To specify the type constraint, we put the class or protocol constraint after
    the generic placeholder, where the generic placeholder and the constraint are
    separated by a colon. This new function works as we might expect, and it will
    compare the values of the two parameters and return `true` if they are equal or
    `false` if they are not.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 要指定类型约束，我们在泛型占位符之后放置类或协议约束，其中泛型占位符和约束由冒号分隔。这个新函数按我们预期的方式工作，并且它将比较两个参数的值，如果它们相等则返回`true`，如果不相等则返回`false`。
- en: 'We can declare multiple constraints just like we declare multiple generic types.
    The following example shows how to declare two generic types with different constraints:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以声明多个约束，就像我们声明多个泛型类型一样。以下示例展示了如何声明具有不同约束的两个泛型类型：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In this function, the type defined by the `T` placeholder must inherit from
    the `MyClass` class, and the type defined by the `E` placeholder must implement
    the `MyProtocol` protocol. Now that we have looked at generic functions, let's
    take a look at generic types.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在此函数中，由`T`占位符定义的类型必须继承自`MyClass`类，而由`E`占位符定义的类型必须实现`MyProtocol`协议。现在我们已经了解了泛型函数，让我们来看看泛型类型。
- en: Generic types
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 泛型类型
- en: We have already had a general introduction to how generic types work when we
    looked at Swift arrays and dictionaries. A generic type is a class, structure,
    or enum that can work with any type, just like the way the Swift arrays and dictionaries
    work. As we recall, Swift arrays and dictionaries are written so that they can
    contain any type. The catch is we cannot mix-and-match different types within
    an array or dictionary. When we create an instance of our generic type, we define
    the type that the instance will work with. After we define that type, we cannot
    change the type for that instance.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在查看 Swift 数组和字典时已经对泛型类型的工作方式有了总的介绍。泛型类型是一个类、结构体或枚举，它可以与任何类型一起工作，就像 Swift 数组和字典一样工作。回想起来，Swift
    数组和字典被编写成可以包含任何类型。问题是我们在数组或字典中不能混合使用不同类型。当我们创建泛型类型的实例时，我们定义了实例将与之一起工作的类型。在定义了该类型之后，我们无法更改该实例的类型。
- en: To demonstrate how to create a generic type, let's create a simple `List` class.
    This class will use a Swift array as the backend storage for the list and will
    let us add items to the list or retrieve values from the list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示如何创建泛型类型，让我们创建一个简单的 `List` 类。这个类将使用 Swift 数组作为列表的后端存储，并允许我们向列表中添加项目或从列表中检索值。
- en: 'Let''s begin by seeing how to define our generic list type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看如何定义我们的泛型列表类型：
- en: '[PRE11]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding code defines the generic list type. We can see that we use the
    `<T>` tag to define a generic placeholder, just like we did when we defined a
    generic function. This `T` placeholder can then be used anywhere within the type
    instead of a concrete type definition.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码定义了泛型列表类型。我们可以看到，我们使用 `<T>` 标签来定义一个泛型占位符，就像我们在定义泛型函数时做的那样。这个 `T` 占位符可以然后在类型的任何地方使用，而不是具体的类型定义。
- en: 'To create an instance of this type, we would need to define the type of items
    that our list will hold. The following examples show how to create instances of
    the generic list type for various types:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建此类型的实例，我们需要定义列表将包含的项目类型。以下示例展示了如何为各种类型创建泛型列表类型的实例：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The preceding example creates three instances of the `List` class. The `stringList`
    instance can be used with String types, the `intList` instance can be used with
    Int types, and the `customList` instance can be used with instances of the `MyObject`
    type.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例创建了 `List` 类的三个实例。`stringList` 实例可以用于 String 类型，`intList` 实例可以用于 Int 类型，而
    `customList` 实例可以用于 `MyObject` 类型的实例。
- en: 'We are not limited to using generics only with classes. We can also define
    structures and enums as generics. The following examples show how to define a
    generic structure and a generic enum:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅限于使用泛型与类一起。我们还可以将结构体和枚举定义为泛型。以下示例展示了如何定义泛型结构体和泛型枚举：
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The next step in our `List` class is to add the backend storage array. The
    items stored in this array need to be of the same type as we define when we initiate
    the class; therefore, we will use the `T` placeholder when we define the type
    for the array. The following code shows the `List` class with an array named `items`.
    The `items` array will be defined using the `T` placeholder, so it will hold the
    same types as we defined for the class:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们 `List` 类的下一步是添加后端存储数组。存储在这个数组中的项目需要与我们初始化类时定义的类型相同；因此，当我们定义数组的类型时，我们将使用 `T`
    占位符。以下代码显示了带有名为 `items` 的数组的 `List` 类。`items` 数组将使用 `T` 占位符定义，因此它将包含我们为类定义的相同类型：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This code defines our generic list type and uses `T` as the type placeholder.
    We can then use the `T` placeholder anywhere in the class to define the type of
    an item. That item will then be of the same type that we defined when we created
    the instance of the `List` class. Therefore, if we create an instance of the list
    type like this `var stringList = List<String>()`, the items array will be an array
    of string instances. If we created an instance of the list type like this `var
    intList = List<Int>()`, the item array will be an array of Int instances.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码定义了我们的泛型列表类型，并使用 `T` 作为类型占位符。然后我们可以在类的任何地方使用 `T` 占位符来定义项目的类型。那个项目将是我们在创建
    `List` 类的实例时定义的相同类型。因此，如果我们创建一个类似这样的列表类型实例 `var stringList = List<String>()`，项目数组将是一个字符串实例的数组。如果我们创建一个类似这样的列表类型实例
    `var intList = List<Int>()`，项目数组将是一个 Int 实例的数组。
- en: Now, we will need to add the `addItems()` method that will be used to add an
    item to the list. We will use the `T` placeholder within the method declaration
    to define that the item parameter will be of the same type as we declared when
    we initiated the class. Therefore, if we create an instance of the list type to
    use the string type, we would be required to use the string type as the parameter
    for the `addItems()` method. However, if we create an instance of the list type
    to use the int type, we would be required to use the int type as the parameter
    for the `addItems()` method.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要添加一个`addItems()`方法，该方法将用于向列表中添加一个项目。我们将在方法声明中使用`T`占位符来定义项目参数将与我们在初始化类时声明的类型相同。因此，如果我们创建一个使用字符串类型的列表类型实例，我们就必须使用字符串类型作为`addItems()`方法的参数。然而，如果我们创建一个使用整型类型的列表类型实例，我们就必须使用整型类型作为`addItems()`方法的参数。
- en: 'Here is the code for the `addItems()` function:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是`addItems()`函数的代码：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: To create a standalone generic function, we add the `<T>` declaration after
    the function name to declare that it is a generic function; however, when we use
    a generic method within a generic type, we do not need the `<T>` declaration.
    Instead, all we need to do is to use the type that we defined in the class declaration.
    If we wanted to introduce another generic type, we could define it with the method
    declaration.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个独立的泛型函数，我们在函数名称后添加`<T>`声明来声明它是一个泛型函数；然而，当我们在一个泛型类型中使用泛型方法时，我们不需要`<T>`声明。相反，我们只需要使用我们在类声明中定义的类型。如果我们想引入另一个泛型类型，我们可以在方法声明中定义它。
- en: 'Now, let''s add the `getItemAtIndex()` method that will return the item from
    the backend array, at the specified index:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`getItemAtIndex()`方法，该方法将从后端数组中返回指定索引的项目：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `getItemAtIndex()` method accepts one argument that is the index of the
    item we want to retrieve. We then use the `T` placeholder to specify that our
    return type is an optional that might be of type `T` or `nil`. If the backend
    storage array contains an item at the specified index, we will return that item;
    otherwise, we return no value.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`getItemAtIndex()`方法接受一个参数，即我们要检索的项目索引。然后我们使用`T`占位符来指定我们的返回类型是一个可能为`T`类型或`nil`的可选类型。如果后端存储数组在指定的索引处包含一个项目，我们将返回该项目；否则，我们不返回任何值。'
- en: 'Now, let''s look at our entire generic list class:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们的整个泛型列表类：
- en: '[PRE17]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As we can see, we initially defined the generic `T` placeholder type in the
    class declaration. We then used this placeholder type within our class. In our
    `List` class, we use this placeholder in three places. We use it as the type for
    our items array, as the parameter type for our `addItem()` method, and as the
    associated value for the optional return type in the `getItemAtIndex()` method.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，我们最初在类声明中定义了泛型`T`占位符类型。然后我们在类中使用这个占位符类型。在我们的`List`类中，我们在三个地方使用这个占位符。我们将其用作项目数组的类型，用作`addItem()`方法的参数类型，以及用作`getItemAtIndex()`方法中可选返回类型的关联值。
- en: 'Now, let''s look at how to use the `List` class. When we use a generic type,
    we define the type to be used within the class between angle brackets, such as
    `<type>`. The following code shows how to use the `List` class to store string
    types:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用`List`类。当我们使用泛型类型时，我们将在类内部使用尖括号定义要使用的类型，例如`<type>`。以下代码显示了如何使用`List`类来存储字符串类型：
- en: '[PRE18]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this code, we start off by creating an instance of the list type called `list`
    and set it to store `String` types. We then use the `addItem()` method twice to
    store two items in the list instance. Finally, we use the `getItemAtIndex()` method
    to retrieve the item at index number `1`, which will display `Optional(World)`
    to the console.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，我们首先创建一个名为`list`的列表类型实例，并将其设置为存储`String`类型。然后我们使用`addItem()`方法两次将两个项目存储在列表实例中。最后，我们使用`getItemAtIndex()`方法检索索引号为`1`的项目，它将在控制台显示`Optional(World)`。
- en: 'We can also define our generic types with multiple placeholder types, similar
    to how we use multiple placeholders in our generic methods. To use multiple placeholder
    types, we would separate them with commas. The following example shows how to
    define multiple placeholder types:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用多个占位符类型定义我们的泛型类型，类似于我们在泛型方法中使用多个占位符的方式。要使用多个占位符类型，我们需要用逗号将它们分开。以下示例显示了如何定义多个占位符类型：
- en: '[PRE19]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We then create an instance of the `MyClass` type that uses the `String` and
    `Int` types, such as:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个使用`String`和`Int`类型的`MyClass`类型实例，例如：
- en: '[PRE20]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We can also use type constraints with generic types. Once again, using a type
    constraint for a generic type is exactly the same as using one with a generic
    function. The following code shows how to use a type constraint to ensure that
    the generic type conforms to the comparable protocol:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用泛型类型的类型约束。再次强调，为泛型类型使用类型约束与为泛型函数使用类型约束完全相同。以下代码展示了如何使用类型约束来确保泛型类型符合可比较协议：
- en: '[PRE21]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: So far, in this chapter, we have seen how to use placeholder types with functions
    and types. At times, it can be useful to declare one or more placeholder types
    in a protocol. These types are known as **associated types**.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了如何使用占位符类型与函数和类型一起使用。有时，在协议中声明一个或多个占位符类型可能很有用。这些类型被称为**关联类型**。
- en: Associated types
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关联类型
- en: An associated type declares a placeholder name that can be used instead of a
    type within a protocol. The actual type to be used is not specified until the
    protocol is adopted. While creating generic functions and types, we used a very
    similar syntax. Defining associated types for a protocol, however, is very different.
    We specify an associated type using the `typealias` keyword.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 关联类型声明了一个占位符名称，可以在协议中使用该名称代替类型。实际要使用的类型直到协议被采用时才指定。在创建泛型函数和类型时，我们使用了非常相似的语法。然而，为协议定义关联类型却非常不同。我们使用`typealias`关键字来指定关联类型。
- en: 'Let''s see how to use associated types when we define a protocol. In this example,
    we will define the `QueueProtocol` protocol that will define the capabilities
    that need to be implemented by the queue that implements it:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们定义协议时，让我们看看如何使用关联类型。在这个例子中，我们将定义一个`QueueProtocol`协议，该协议将定义需要由实现它的队列实现的能力：
- en: '[PRE22]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this protocol, we define one associated type named `QueueType`. We then used
    this associated type twice within the protocol—once as the parameter type for
    the `addItem()` method and once when we define the return type of the `getItem()`
    method as an optional type that might return the associated type of `QueueType`
    or a `nil`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个协议中，我们定义了一个名为`QueueType`的关联类型。然后我们在协议中两次使用这个关联类型——一次作为`addItem()`方法的参数类型，一次当我们定义`getItem()`方法的返回类型为一个可能返回关联类型`QueueType`或`nil`的可选类型。
- en: Any type that implements the `QueueProtocol` protocol must be able to specify
    the type to use for the `QueueType` placeholder and must also ensure that only
    items of that type are used where the protocol uses the `QueueType` placeholder.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 任何实现`QueueProtocol`协议的类型都必须能够指定用于`QueueType`占位符的类型，并且必须确保在协议中使用`QueueType`占位符的地方只使用该类型的项。
- en: 'Let''s look at how to implement `QueueProtocol` in a non-generic class called
    `IntQueue`. This class will implement the `QueueProtocol` protocol using the `Int`
    type:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何在非泛型类`IntQueue`中实现`QueueProtocol`。这个类将使用`Int`类型实现`QueueProtocol`协议：
- en: '[PRE23]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In the `IntQueue` class, we begin by defining our backend storage mechanism
    to be an array of `Int` types. We then implement each of the methods defined in
    the `QueueProtocol` protocol, replacing the `QueueType` placeholder defined in
    the protocol with the Int type. In the `addItem()` method, the parameter type
    is defined to be an `Int` type, and in the `getItem()` method the return type
    is defined to be an optional that might return an `Int` type or no value.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`IntQueue`类中，我们首先定义我们的后端存储机制为一个`Int`类型的数组。然后我们实现协议中定义的每个方法，用Int类型替换协议中定义的`QueueType`占位符。在`addItem()`方法中，参数类型被定义为`Int`类型，而在`getItem()`方法中，返回类型被定义为可能返回`Int`类型或无值的可选类型。
- en: 'We use the `IntQueue` class as we would use any other class. The following
    code shows this:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`IntQueue`类的方式就像使用任何其他类一样。以下代码展示了这一点：
- en: '[PRE24]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: We begin by creating an instance of the `IntQueue` class named `intQ`. We then
    call the `addItem()` method twice to add two values of the int type to the `intQ`
    instance. We then retrieve the first item in the `intQ` instance by calling the
    `getItem()` method. This line will print the number `Optional(2)` to the console.
    The final line of code adds another int type to the `intQ` instance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个名为`intQ`的`IntQueue`类实例。然后我们调用`addItem()`方法两次，向`intQ`实例添加两个整型的值。然后我们通过调用`getItem()`方法检索`intQ`实例中的第一个项。这一行将打印数字`Optional(2)`到控制台。代码的最后一行添加了另一个整型到`intQ`实例。
- en: 'In the preceding example, we implemented the `QueueProtocol` protocol in a
    non-generic way. This means that we replaced the placeholder types with an actual
    type (`QueueType` was replaced by the `Int` type). We can also implement the `QueueProtocol`
    protocol with a generic type. Let''s see how to implement the `QueueProtocol`
    protocol in a generic type called `GenericQueue`:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们以非泛型的方式实现了`QueueProtocol`协议。这意味着我们用实际类型替换了占位符类型（`QueueType`被替换为`Int`类型）。我们还可以使用泛型类型实现`QueueProtocol`协议。让我们看看如何以泛型类型`GenericQueue`实现`QueueProtocol`协议：
- en: '[PRE25]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As we can see, the `GenericQueue` implementation is very similar to the `IntQueue`
    implementation, except that we define the type to use as the generic placeholder
    `T`. We can then use the `GenericQueue` class as we would use any generic class.
    Let''s take a look at how to use the `GenericQueue` class:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`GenericQueue`的实现与`IntQueue`的实现非常相似，除了我们定义了要使用的泛型占位符`T`。然后我们可以像使用任何泛型类一样使用`GenericQueue`类。让我们看看如何使用`GenericQueue`类：
- en: '[PRE26]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We begin by creating an instance of the `GenericQueue` class that will use the
    `Int` type. This instance is named `intQ2`. Next, we call the `addItem()` method
    twice to add two Int types to the `intQ2` instance. We then retrieve the first
    `Int` type that was added using the `getItem()` method and print the value to
    the console. This line will print the number `2` to the console.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先创建一个`GenericQueue`类的实例，该实例将使用`Int`类型。这个实例被命名为`intQ2`。接下来，我们调用`addItem()`方法两次，向`intQ2`实例添加两个`Int`类型。然后我们使用`getItem()`方法检索添加的第一个`Int`类型，并将其值打印到控制台。这一行将在控制台打印数字`2`。
- en: One of the things that we should watch out for while using generics is to avoid
    using them when we should be using protocols. This is, in my opinion, one of the
    most common misuses of generics in other languages. Let's take a look at an example
    so that we know what to avoid.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用泛型时，我们应该注意避免在应该使用协议的情况下使用泛型。在我看来，这是在其他语言中泛型最常见误用的一个例子。让我们看看一个例子，以便我们知道要避免什么。
- en: 'Let''s say that we define a protocol called `WidgetProtocol`, which is as follows:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们定义了一个名为`WidgetProtocol`的协议，如下所示：
- en: '[PRE27]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Now, let''s say that we want to create a custom type (or function) that will
    use various implementations of the `WidgetProtocol` protocol. I have seen a couple
    of instances where developers have used generics with a type constraint to create
    custom types like this:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个自定义类型（或函数），该类型将使用`WidgetProtocol`协议的各种实现。我见过一些开发者使用类型约束与泛型一起创建类似这样的自定义类型：
- en: '[PRE28]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'While this is a perfectly valid use of generics, it is recommended that we
    avoid implementations like this. It is a lot cleaner and easier to read if we
    use `WidgetProtocol` without generics. For example, we can write a non-generic
    version of the `MyClass` type like this:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是泛型的一个完全有效的使用，但我们建议避免这种实现方式。如果我们使用`WidgetProtocol`而不使用泛型，代码会更加清晰且易于阅读。例如，我们可以这样编写`MyClass`类型的非泛型版本：
- en: '[PRE29]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The second non-generic version of the `MyClass` type is a lot easier to read
    and understand; therefore, this should be the preferable way to implement the
    class. However, there is nothing preventing us from using either implementation
    of the `MyClass` type.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyClass`类型的第二个非泛型版本更容易阅读和理解；因此，这应该是实现类的首选方式。然而，没有任何阻止我们使用`MyClass`类型的任何实现。'
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Generic types can be incredibly useful, and they are also the basis of the Swift
    standard collection types (array and dictionary); however, as mentioned in the
    introduction to this chapter, we have to be careful to use them correctly.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类型可以非常有用，它们也是Swift标准集合类型（数组和字典）的基础；然而，正如本章引言中提到的，我们必须小心正确地使用它们。
- en: We have seen a couple of examples in this chapter that show how generics can
    make our lives easier. The `swapGeneric()` function that was shown at the beginning
    of the chapter is a good use of a generic function because it allows us to swap
    the two values of any type we choose while only implementing the swap code once.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中看到了几个示例，展示了泛型如何让我们的生活变得更简单。本章开头展示的`swapGeneric()`函数是一个泛型函数的良好应用，因为它允许我们只实现一次交换代码，就能交换任何类型我们选择的两值。
- en: The generic list type is also a good example of how to make custom collection
    types that can be used to hold any type. How we implemented the generic list type
    in this chapter is similar to how Swift implements the array and dictionary with
    generics.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 通用列表类型也是一个很好的例子，说明了如何创建自定义集合类型，这些类型可以用来存储任何类型的元素。在本章中，我们实现通用列表类型的方式与Swift实现泛型数组和大字典的方式相似。
