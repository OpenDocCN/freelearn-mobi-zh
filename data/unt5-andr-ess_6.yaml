- en: Chapter 6. Optimization and Transformation Techniques
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。优化和转换技术
- en: This chapter will introduce you to the usage of **occlusion culling** (**OC**)
    and level of detail in optimization techniques. Also, you will learn to optimize
    Unity C# and Unity JS code. Finally, you will see how to transform Unity C# code
    to Unity JavaScript code and vice versa.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向你介绍**遮挡剔除**（**OC**）和细节级别在优化技术中的使用。此外，你将学习如何优化Unity C#和Unity JS代码。最后，你将看到如何将Unity
    C#代码转换为Unity JavaScript代码，反之亦然。
- en: 'The topics that will be covered in the chapter are as follows:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Occlusion culling and level of detail in optimization techniques
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遮挡剔除和优化技术中的细节级别
- en: Unity C# and Unity JS optimization tips and tricks
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity C#和Unity JS优化技巧和窍门
- en: Transforming Unity C# code to Unity JavaScript code and vice versa
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Unity C#代码转换为Unity JavaScript代码，反之亦然
- en: Occlusion culling and level of detail in optimization techniques
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 遮挡剔除和优化技术中的细节级别
- en: Let's look more closely and carefully at the basic principles of occlusion culling
    in Unity (only Pro license) and how to use them in your projects to achieve excellent
    performance.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看Unity中遮挡剔除的基本原理（仅限Pro许可证）以及如何在项目中使用它们以实现出色的性能。
- en: 'You can open the occlusion culling editor from the Unity menu as shown in the
    following screenshot:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从Unity菜单中打开遮挡剔除编辑器，如以下截图所示：
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_01.jpg)'
  id: totrans-9
  prefs: []
  type: TYPE_IMG
  zh: '![遮挡剔除和优化技术中的细节级别](img/9191OT_06_01.jpg)'
- en: The main aim of the occlusion culling mechanism is sifting and filtering off
    objects that are not visible in the camera area in order to improve optimization.
    This primarily means that the objects will not be using resources, only when necessary,
    with the result that of helping you create a game or app that will work much faster.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 遮挡剔除机制的主要目的是筛选和过滤掉相机区域中不可见的对象，以提高优化效果。这主要意味着对象只有在必要时才会使用资源，从而帮助你创建一个运行速度更快的游戏或应用。
- en: 'Frustum culling is different from occlusion culling because it disables the
    renderers that are outside the view of the camera, but does not disable the renderers
    that overlap other renderers; for example, if a wall hides an object, it will
    be invisible for the camera. Using occlusion culling, you can automatically take
    the advantage of frustum culling. With the usage of visual occlusion culling technique,
    we can see in two examples as shown in the following screenshots:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 棱锥剔除与遮挡剔除不同，因为它禁用了相机视图外的渲染器，但不会禁用与其他渲染器重叠的渲染器；例如，如果一堵墙遮挡了一个对象，它对相机将是不可见的。使用遮挡剔除，你可以自动利用棱锥剔除的优势。通过使用视觉遮挡剔除技术，我们可以在以下两张截图中的两个示例中看到：
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_02.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![遮挡剔除和优化技术中的细节级别](img/9191OT_06_02.jpg)'
- en: 'In the screenshot shown here, you can see occlusion culling in action:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里显示的截图中，你可以看到遮挡剔除的效果：
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_03.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![遮挡剔除和优化技术中的细节级别](img/9191OT_06_03.jpg)'
- en: The occlusion culling process in Unity uses a virtual camera that will scan
    the entire scene and create a hierarchy of potentially visible sets of objects.
    Then, this information will be used by other cameras in your game or in your application
    in real time, in order to reduce the number of draw calls and to improve your
    performance.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Unity中的遮挡剔除过程使用一个虚拟相机来扫描整个场景，并创建一组可能可见的对象的层次结构。然后，这些信息将在你的游戏或应用中实时使用，以减少绘制调用次数并提高性能。
- en: In order to use occlusion culling, you need to set the **Occluder Static** tag
    for each object in the scene to be processed by this optimization mechanism. Also,
    you can use another object's tag, which is called **Occludee Static** as shown
    in the next screenshot. Occludees may be obscured by other objects and will be
    disabled in a similar situation to improve performance, but these objects cannot
    overlap other objects. Therefore, they will increase the performance of your entire
    project.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用遮挡剔除，你需要为场景中要处理的每个对象设置**遮挡静态**标签。此外，你还可以使用另一个对象的标签，称为**被遮挡静态**，如下一张截图所示。被遮挡的对象可能被其他对象遮挡，并在类似情况下被禁用以提高性能，但这些对象不能与其他对象重叠。因此，它们将提高你整个项目的性能。
- en: '![Occlusion culling and level of detail in optimization techniques](img/9191OT_06_04.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![遮挡剔除和优化技术中的细节级别](img/9191OT_06_04.jpg)'
- en: Note
  id: totrans-18
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is also very important to create areas for occlusion culling, only where
    the camera will render objects.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在相机将要渲染对象的地方创建遮挡剔除区域也非常重要。
- en: We just opened the basic and key aspects of the optimization by occlusion culling
    approach. We cannot describe all the details of the settings and features in this
    chapter. The following sections describe the various ideas, methods, approaches,
    and ways to optimize and improve performance. The purpose of the next section
    is to direct you on the right path to improve performance. You will use the desired
    optimization techniques from this chapter, and if it is necessary, you can find
    more detailed information about methods, implementations, and customizations from
    the web. Let's now consider another optimization technique known as **Level Of
    Detail** (**LOD**).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚介绍了通过遮挡剔除方法进行优化的基本和关键方面。我们无法在本章中描述所有设置和功能的细节。以下章节将描述各种想法、方法、方法和优化和改进性能的方式。下一节的目的是指引你走上提高性能的正确道路。你将使用本章中描述的所需优化技术，如果需要，你可以从网络上找到有关方法、实现和定制的更详细信息。现在让我们考虑另一种称为**细节级别**（**LOD**）的优化技术。
- en: Optimizing by LOD
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过LOD进行优化
- en: The LOD optimization technique is a method of reducing the complexity of frame
    rendering by reducing the total number of polygons, textures, and other resources
    in the scene, the general decline in its complexity. A simple example is that
    the main character model consists of 10,000 polygons. In cases where the treated
    stage is located close to the camera, it is important to use all the polygons.
    However, at a great distance from the camera, in the final image, it will take
    only a few pixels; there is no sense in handling all 10,000 polygons. Perhaps,
    in this case, it would be enough for hundreds of polygons, or even a couple of
    pieces and textures, specially prepared for about the same display model. Accordingly,
    at intermediate distances, it makes sense to use a model consisting of a number
    of triangles greater than the simplest model and smaller than the most complex.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: LOD优化技术是一种通过减少场景中总的多边形、纹理和其他资源数量来降低帧渲染复杂性的方法，总体上降低其复杂性。一个简单的例子是，主要角色模型由10,000个多边形组成。在处理阶段靠近相机的情况下，使用所有多边形很重要。然而，在远离相机的地方，在最终图像中，它只占用几个像素；处理所有10,000个多边形是没有意义的。也许在这种情况下，几百个多边形，甚至几块和纹理，专门为大约相同的显示模型准备，就足够了。相应地，在中等距离处，使用由比最简单模型多、比最复杂模型少的三角形组成的模型是有意义的。
- en: The LOD method is commonly used for modeling and rendering three-dimensional
    scenes using multiple difficulty levels (geometric or some other) for the objects
    in proportion to their distance from the camera. Changing complexity, particularly
    in the number of triangles in the model may be performed automatically, is based
    on a three-dimensional model of highest complexity, but can be on the basis of
    several predefined patterns with different levels of detail. Using a model with
    less detail for different distances, you will reduce rendering design complexity,
    almost without compromising the overall image detail.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: LOD方法通常用于使用多个难度级别（几何或其他）来建模和渲染三维场景，这些难度级别与对象与相机之间的距离成比例。改变复杂性，尤其是在模型中的三角形数量，可以自动进行，基于最高复杂性的三维模型，但也可以基于几个预定义的具有不同细节级别的模式。使用具有较少细节的模型在不同距离处，你可以减少渲染设计复杂性，几乎不会影响整体图像的细节。
- en: The method is particularly effective when the number of objects in the scene
    is large, and they are located at different distances from the camera. For example,
    consider a sports game, such as football game or a hockey simulator. Low-poly
    character models are used when they are away from the camera, but when it approaches,
    the models are replaced by a large number of polygons. This example is very simple,
    and it shows that the essence of the method is based on two levels of detail of
    the model, but no one bothers to create multiple levels of detail. In order to
    effect change, the LOD level was not too obvious, so the object detail gradually
    grows.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当场景中的对象数量很大，并且它们位于与相机不同距离的位置时，这种方法特别有效。例如，考虑一个体育游戏，如足球游戏或冰球模拟器。当角色远离相机时，使用低多边形角色模型，但当它靠近时，模型被大量多边形所取代。这个例子非常简单，它表明该方法的核心是基于模型的两个细节级别，但没有人费心创建多个细节级别。为了产生变化，LOD级别不应过于明显，因此对象细节逐渐增加。
- en: 'Consider the following factors that have an effect on the level of detail technique:
    the total number of objects on the screen (when one or two characters in the frame,
    use complex models, and when 10–20, they are switched to a simpler model) or the
    FPS (predetermined limited values of the FPS, which varies with the level of detail,
    such as FPS below 30 reduces the complexity of the models on the screen, while
    60 FPS raises the complexity). Other possible factors that affect the level of
    detail are as follows: the speed of movement of the object (in case of a rocket
    in motion you see it moving fast, but a snail moves slowly), the importance of
    a character from the game''s point of view (for example, in football, the player
    models you see the closest and most often uses more complex geometry and texture).
    It all depends on the desires and capabilities of a particular developer. The
    main thing is to not overdo it; frequent and noticeable changes in the level of
    detail will be annoying.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下影响细节级别技术水平的因素：屏幕上对象的总数（当画面中有一个或两个角色时，使用复杂模型，而当有10-20个角色时，切换到更简单的模型）或帧率（预定的有限帧率值，随着细节级别的变化而变化，例如帧率低于30会降低屏幕上模型的复杂性，而60帧则提高复杂性）。影响细节级别水平的其他可能因素如下：对象移动的速度（例如，对于正在移动的火箭，你看到它快速移动，但蜗牛则缓慢移动），从游戏的角度来看角色的重要性（例如，在足球中，你看到最接近且最常使用的玩家模型通常使用更复杂的几何和纹理）。这都取决于特定开发者的愿望和能力。最重要的是不要过度；频繁且明显的细节级别变化会令人烦恼。
- en: 'We want to remind you that the level of detail does not necessarily refer only
    to the geometry. The method can also be used to save other resources: texturing
    (although GPUs use mipmapping, sometimes it makes sense to change the texture
    on the fly on the other with some detail), lighting technician (close objects
    covered by a complex algorithm, and distant objects covered by a prime), and texturing
    techniques.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想提醒您，细节级别不一定仅指几何形状。此方法还可以用于节省其他资源：纹理（尽管GPU使用米派映射，但有时在动态地改变纹理以保持某些细节方面是有意义的），照明技术（靠近的对象使用复杂算法，而远处的对象使用主照明），以及纹理技术。
- en: Unity C# and Unity JS optimization tips and tricks
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity C#和Unity JS优化技巧和窍门
- en: 'To begin, we will consider some aspects of optimization concerning the JavaScript
    programming language. Try to avoid the use of dynamic typing in JavaScript. The
    best solution for your performance is undoubtedly static typing. The use of dynamic
    typing of variables will be consumed while executing a code to find the appropriate
    data type for a particular variable, which in principle could and should be avoided
    by specifying the data types for all your variables. Bad and good examples are
    shown here:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将考虑与JavaScript编程语言相关的优化方面的某些方面。尽量在JavaScript中避免使用动态类型。无疑，对性能最好的解决方案是静态类型。变量的动态类型使用会在执行代码时消耗，以找到特定变量的适当数据类型，这在原则上可以也应该通过指定所有变量的数据类型来避免。不良和良好的示例如下：
- en: '[PRE0]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following example shows what you should not do if you want to improve your
    performance. This example uses dynamic typing for our variable, `yourVariableName`,
    which in turn affects the performance of the whole system in the negative sense.
    Before calling any function of this object, there will be time spent searching
    for the right object type and checking if the called function is accessible. The
    bad example is shown here:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例展示了如果你想要提高性能，你不应该做什么。这个例子使用动态类型来定义我们的变量`yourVariableName`，这反过来又以负面方式影响了整个系统的性能。在调用此对象任何函数之前，都会花费时间搜索正确的对象类型并检查被调用的函数是否可访问。不良的示例如下：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Instead of wasting CPU time on unnecessary expenses, you should always use
    static typing for all your variables in order to improve performance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在不必要的开销上浪费CPU时间，你应该始终为所有变量使用静态类型以提高性能：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Use Static Typing instead of Dynamic Typing wherever possible**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**尽可能使用静态类型而不是动态类型**'
- en: You can use `#pragma` strict preprocessor directive in order to help you not
    to forget about using static typing instead of dynamic typing everywhere in your
    JavaScript script. You should write this directive at the top of your script before
    any code. In the event of utilizing `#pragma` strict and dynamic typing in your
    script, the compiler will throw errors. Therefore, this preprocessor directive
    forces you to use static typing only.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用`#pragma`严格预处理器指令来帮助你记住在JavaScript脚本中始终使用静态类型而不是动态类型。你应该在脚本顶部，在任意代码之前写入此指令。如果在脚本中使用了`#pragma`严格和动态类型，编译器将抛出错误。因此，这个预处理器指令强制你只使用静态类型。
- en: 'We also want to mention the other techniques to optimize your code. One of
    them is the technique of caching components or variables. During optimization,
    you first need to turn your attention to the functions that are very often performed
    in your code, especially callbacks such as `Update` and `FixedUpdate` and similar
    functions that are called in every frame, or almost each frame, or in other words,
    many times per second. Therefore, reference to any component or variable in such
    risky functions depends on the situation. Of course, there are situations for
    the overall system performance, where such things are not so bad for your performance
    in general, and there are situations where performance drops almost to zero because
    of the many unnecessary expenses. In such functions, it is best not to call the
    Unity method `GetComponent` each time, which will very often look for a component
    or other similar functions of the Unity library to find objects and so on. Instead,
    you can call the function you want, when it is necessary to obtain a desired component
    or desired object(s) and store them in local variables or arrays, as you like.
    The following examples demonstrate this:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想提及其他优化代码的技术。其中之一是缓存组件或变量的技术。在优化过程中，你首先需要关注代码中经常执行的功能，特别是像`Update`和`FixedUpdate`这样的回调函数，以及每帧或几乎每帧都会调用的类似函数。换句话说，这些函数每秒会被调用很多次。因此，在这些高风险函数中对任何组件或变量的引用取决于具体情况。当然，对于整体系统性能来说，有些情况下这些操作对性能影响不大，而有些情况下，由于许多不必要的开销，性能几乎会降到零。在这些函数中，最好每次不要调用Unity方法`GetComponent`，因为这会非常频繁地查找组件或其他Unity库中的类似函数来查找对象等。相反，你可以在需要获取所需组件或对象（s）时调用所需的功能，并将它们存储在局部变量或数组中，就像你喜欢的样子。以下示例展示了这一点：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The code shown in the second example is much faster then the respective code
    in the first example, because Unity will not look up the transform component each
    `Update` cycle or in other words each frame.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个示例中显示的代码比第一个示例中的相应代码快得多，因为Unity不会在每次`Update`周期或每帧查找transform组件。
- en: Tip
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You should call a function only if necessary, not more and not less, just exactly
    when needed.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该只在必要时调用函数，不多也不少，正好在需要的时候。
- en: 'The best optimization for your code and generally for the whole system is when
    the code is as small as possible, or rather when nothing unnecessary is executed
    at all. Unnecessary calculations lead to unnecessary overhead; for mobile devices,
    in general, this question is one of the most acute. A good example of a small
    optimization is shown in the following example, but this example is not the best
    solution for your performance. After each frame, checking the distance between
    the two points will take away your precious time:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 对你的代码和整个系统来说，最好的优化是代码尽可能小，或者说根本不执行任何不必要的操作。不必要的计算会导致不必要的开销；对于移动设备来说，这个问题通常是最尖锐的。以下示例展示了一个小优化示例，但这并不是你性能的最佳解决方案。在每一帧之后，检查两点之间的距离会消耗你宝贵的时间：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To not waste time on unnecessary mistakes, you should use the `OnBecameInvisible`
    and `OnBecameVisible` callbacks. With these callbacks, Unity calls in an event
    in which none of the cameras can see (for `OnBecameInvisible`) or at least one
    camera sees (for `OnBecameVisible`) your renderer. Certainly, these callbacks
    are only good in certain situations and not in others. For example, if your object
    does not contain a renderer component, then you will need to invent a way to enable
    or disable the execution of your code accordingly. A simple example of these two
    callbacks is shown here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了不浪费时间去纠正不必要的错误，你应该使用`OnBecameInvisible`和`OnBecameVisible`回调。有了这些回调，Unity会在没有相机能看到（对于`OnBecameInvisible`）或至少有一个相机能看到（对于`OnBecameVisible`）你的渲染器的事件中调用。当然，这些回调在某些情况下很有用，在其他情况下则不然。例如，如果你的对象不包含渲染器组件，那么你需要想出一个方法来相应地启用或禁用代码的执行。这两个回调的一个简单示例如下：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: To achieve the performance that you need, you will need to take care of many
    details in your code and many other details that are discussed in this book. Code
    optimization in most cases impedes readability and therefore impedes understanding
    of the code. Keep this in mind, or at least do not forget about it. Like everything
    else in life, we need to find a middle ground or, in other words, the golden balance
    between quality and performance.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 为了达到所需的性能，你需要在代码中注意许多细节，以及本书中讨论的其他许多细节。在大多数情况下，代码优化会阻碍可读性，从而阻碍对代码的理解。请记住这一点，或者至少不要忘记。就像生活中的其他事情一样，我们需要找到一个平衡点，换句话说，就是质量和性能之间的黄金平衡。
- en: Let's see how static functions behave and how much time we need for them, since
    the use of these functions significantly reduces the time of the function call
    as compared to call a non-static function. If we examine the question of what
    happens with static functions when you compile your code, it is, however, no secret
    that all the code is translated into machine code or assembler as it is called,
    which is the lowest programming level. If we consider the very assembly instructions
    to call static functions, we see that it requires fewer machine instructions and
    consequently less CPU time than calling a nonstatic function.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看静态函数的行为以及我们需要多少时间来处理它们，因为与调用非静态函数相比，使用这些函数可以显著减少函数调用的时间。如果我们检查编译代码时静态函数会发生什么的问题，然而，这并不是什么秘密，所有的代码都会被转换成机器代码或汇编代码，这是最低的编程级别。如果我们考虑调用静态函数的汇编指令，我们会看到它需要的机器指令比调用非静态函数少，因此CPU时间也更少。
- en: In the call, each function with parameters passed by value requires memory duplication.
    As discussed earlier in text, this may impair your performance. Therefore, it
    is better to call a function with parameters passed by reference rather than by
    value. It is easy to bypass this problem. The best thing for enhancing your performance
    is to use local variables of a class or object that is used in the function. You
    can create a set of variables within a function, which in turn will significantly
    increase the consumption of memory and CPU time of the function call with a lot
    of variables. The function must be remembered in the stack for further opportunities
    to work with these variables. Even if these variables are not used in the function,
    they are still in the stack and they will occupy memory space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用中，每个通过值传递参数的函数都需要内存复制。如前所述，这可能会影响你的性能。因此，最好通过引用而不是值来调用函数。解决这个问题很容易。提高性能的最好方法是使用在函数中使用的类或对象的局部变量。你可以在函数内部创建一组变量，这反过来又会显著增加具有许多变量的函数调用对内存和CPU时间的消耗。函数必须在栈上记住，以便有进一步操作这些变量的机会。即使这些变量在函数中没有使用，它们仍然在栈上，并且会占用内存空间。
- en: The following discussion focuses on the constants. Constants do not require
    RAM allocation, since their values are directly sewed in the instruction stream.
    Using constants instead of creating a large number of local or global variables
    can significantly accelerate the performance of your software, avoiding the overhead
    of memory and CPU time.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 以下讨论将集中在常量上。常量不需要RAM分配，因为它们的值直接嵌入到指令流中。使用常量而不是创建大量局部或全局变量可以显著提高软件的性能，避免内存和CPU时间的开销。
- en: Static variables (variables of a class) as well as static functions (methods
    of a class) require less CPU time, since static variables belong to the whole
    class, rather than to an object of this class. The time spent on searching for
    supplies is declining, which has obvious advantages in optimization. For variables
    or functions of any object machine, instructions will be executed to locate the
    appropriate object to which they belong, which obviously require the overhead
    of CPU time and memory.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态变量（类的变量）以及静态函数（类的方法）需要的 CPU 时间较少，因为静态变量属于整个类，而不是属于此类的一个对象。用于搜索资源的时间正在减少，这在优化中具有明显的优势。对于任何对象的变量或函数，机器指令将被执行以定位它们所属的适当对象，这显然需要
    CPU 时间和内存的开销。
- en: 'The `if` and `switch` statements can be easily changed for each other; for
    example, to increase the understanding and readability of the code or to optimize
    all the same code. If you look at the postcompilation machine instructions and
    directions through any disassembler, you can see the difference between these
    two expressions. The `switch` statement**,** for example, after compiling becomes
    ago-to mechanism, which in turn makes jumping through machine instructions in
    its transition table. It needs to find the desired transition in the first place,
    and then those going to the command assembly. If construction behaves low bit
    differently, it turns normal branching as in high-level programming language;
    for example, in our case, the C# language. In some cases, some `switch` design
    may be executed faster than the same `if`/`else if`/`else` design. Performance
    of these two structures solely depends on their correct application or in other
    words the correct use. For example, let''s consider two simple cases, where in
    the first case will be quicker and faster `switch`, and in the second situation
    the `if` design is better for performance than a `switch` solution, as shown in
    the following code example:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 和 `switch` 语句可以很容易地相互替换；例如，为了提高代码的可理解和可读性，或者优化所有相同的代码。如果你通过任何反汇编器查看编译后的机器指令和方向，你可以看到这两个表达式的区别。例如，`switch`
    语句在编译后成为 ago-to 机制，这反过来又使得在转换表中通过机器指令进行跳转。它首先需要找到所需的转换，然后是那些前往命令汇编的部分。如果构造的行为在低位不同，它将像在高级编程语言中一样表现为正常分支；例如，在我们的案例中，C#
    语言。在某些情况下，某些 `switch` 设计可能比相同的 `if`/`else if`/`else` 设计执行得更快。这些两种结构的性能完全取决于它们的正确应用，换句话说，正确的使用。例如，让我们考虑两个简单的案例，其中第一个案例将会有更快更有效的
    `switch`，而在第二种情况下，`if` 设计在性能上优于 `switch` 解决方案，如下面的代码示例所示：'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing the first example in the
    Unity editor the results were:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 系统上，在 Unity 编辑器中测试第一个示例后，结果如下：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Based on the preceding results, we can say that the design of `switch` affects
    your performance better, but it is not always true. Let''s now consider the second
    case, where the `if` construction turns out to be the best design solution for
    your optimization, as shown in code example here:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于前面的结果，我们可以说 `switch` 的设计对性能的影响更好，但这并不总是正确的。现在让我们考虑第二种情况，其中 `if` 结构证明是优化设计的最佳解决方案，如下面的代码示例所示：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On a Mac OS X, Intel Core i5 2.7 GHz, after testing the second example in the
    Unity editor, the results were:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 系统上，在 Unity 编辑器中测试第二个示例后，结果如下：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Since different situations require different designs, the most important thing
    is for you to understand the true meaning of what is happening in the construction
    machine after compiling your code. Then, it will be much easier to make the right
    choices to improve and enhance your performance. In both examples, discussed earlier,
    we saw that in different situations the `if` and `switch` designs, which at first
    sight are absolutely equivalent, may differ in speed and efficiency with respect
    to performance. We also saw that different situations give a performance advantage
    with different designs, although they have the same semantics, or in other words,
    the same algorithm designed in different forms. However, the meaning does not
    change when dealing with any problems, except for the time of execution, as we
    have already considered earlier.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于不同的情况需要不同的设计，最重要的事情是你在编译代码后要理解在建筑机器中发生的事情的真正含义。然后，你将更容易做出正确的选择来改进和提升你的性能。在前面讨论的两个例子中，我们看到了在不同的情境下，看似完全等价的`if`和`switch`设计，在性能方面可能会有速度和效率上的差异。我们也看到，不同的情境会因不同的设计而获得性能优势，尽管它们具有相同的语义，或者说，以不同形式设计的相同算法。然而，当处理任何问题时，意义不会改变，除了我们已经考虑过的执行时间。
- en: 'The following two-dimensional arrays can be used in the form of one-dimensional
    arrays, and this will increase your performance. For example, we have a two-dimensional
    array with **N** rows and **M** of columns: the table size is N × M:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下二维数组可以用单维数组的形式使用，这将提高你的性能。例如，我们有一个具有**N**行和**M**列的二维数组：表格大小是N × M：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the case of optimization of the two-dimensional array by switching it to
    the one-dimensional array, we can refer to an element (i, j) of our table with
    the size N × M as follows:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在将二维数组优化为单维数组的情况下，我们可以这样引用我们大小为N × M的表格中的元素(i, j)：
- en: '[PRE11]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here is a complete sample code in Unity C# as shown in the following code example:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个完整的Unity C#示例代码，如下所示：
- en: '[PRE12]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，Intel Core i5 2.7 GHz，在Unity编辑器中测试此示例后，得到了以下结果：
- en: '[PRE13]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'As we can see a difference in the implementation of the same ideas, but in
    different forms as two-dimensional and one-dimensional arrays. Also consider the
    next simple example code as shown here, which shows a two-level array in comparison
    with one-dimensional arrays for speed of execution:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，相同思想的实现存在差异，但形式不同，如二维数组和单维数组。也考虑以下简单的示例代码，如下所示，它展示了与单维数组相比的两级数组在执行速度上的比较：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，Intel Core i5 2.7 GHz，在Unity编辑器中测试此示例后，得到了以下结果：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For convenience, you can use the two-level array if you are satisfied with its
    performance. You will need to make the right decision starting from your tasks,
    not forgetting about the middle ground between the readability of the code and
    its performance.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了方便起见，如果你对它的性能满意，你可以使用两级数组。你需要从你的任务开始做出正确的决定，不要忘记代码的可读性和性能之间的平衡点。
- en: 'As for strings and character arrays, let''s see which among them is faster
    and more efficient. In the following code example, we represent our test performance
    between the two variables:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 至于字符串和字符数组，让我们看看它们中哪一个更快、更高效。在下面的代码示例中，我们展示了两个变量之间的测试性能：
- en: '[PRE16]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，Intel Core i5 2.7 GHz，在Unity编辑器中测试此示例后，得到了以下结果：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The difference is obvious, but readability of this optimization falls down
    rapidly. As always everything in life needs a strong balance sheet or, in other
    words, the golden mean. Here is another example, in which we compare the performance
    of `StringBuilder` and character array as shown in the following code example:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 差异很明显，但这个优化的可读性迅速下降。就像生活中的一切都需要一个强大的资产负债表，或者说，黄金法则。下面是另一个例子，其中我们比较了`StringBuilder`和字符数组的表现，如下所示：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在Mac OS X上，Intel Core i5 2.7 GHz，在Unity编辑器中测试此示例后，得到了以下结果：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`StringBuilder` is slightly inferior to the performance of a character array.
    However, do not forget that for the garbage collector, `StringBuilder` is very
    well optimized and does not create a memory leak with large volumes of data. You
    have to solve various problems in the course of software development. If every
    decision will confidently and firmly take any criticism, then success is not far
    away. You should definitely prioritize your tasks for all to see where you need
    to go with compromises.'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`StringBuilder`的性能略逊于字符数组。然而，不要忘记，对于垃圾回收器来说，`StringBuilder`进行了非常好的优化，并且不会因为大量数据而产生内存泄漏。在软件开发过程中，你必须解决各种问题。如果你对每一个决定都充满信心并坚定地接受任何批评，那么成功就不会太远。你绝对应该优先考虑你的任务，让所有人都看到你需要在哪里做出妥协。'
- en: 'In the next step, we will examine and study the performance of collections
    in C#. Collection is very useful in certain situations, but you always have to
    remember that it is a wrapper for ordinary arrays. When using large data, collections
    can utilize significant costs of processing time, which in turn negatively affects
    the whole performance of your code. In the following code example, a list collection
    execution speed is compared with the conventional one-dimensional array:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将检查和研究 C# 中集合的性能。在某些情况下，集合非常有用，但你始终要记住，它是对普通数组的包装。当使用大量数据时，集合可能会利用大量的处理时间成本，这反过来又会对你的代码的整体性能产生负面影响。在以下代码示例中，列表集合的执行速度与传统的单维数组进行了比较：
- en: '[PRE20]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 上，在 Unity 编辑器中测试此示例后，得到了以下结果：
- en: '[PRE21]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'As can be seen from the results discussed earlier in the text, the list collection
    is significantly inferior in performance compared to simple one-dimensional arrays.
    Next, as shown in the following code example, the performance of the `ArrayList`
    class is compared with the same simple one-dimensional array:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述的结果所示，与简单的单维数组相比，列表集合在性能上明显较差。接下来，如下面的代码示例所示，`ArrayList`类的性能与相同的简单单维数组进行了比较：
- en: '[PRE22]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 上，在 Unity 编辑器中测试此示例后，得到了以下结果：
- en: '[PRE23]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The difference is awesome and more than in the previous example, while using
    the class `List`. Thus, we demonstrated the obvious advantages of a simple one-dimensional
    array, compared with collections when large amounts of data can greatly ruin your
    performance. What cannot be said about the simple one-dimensional arrays is which
    of them are the building blocks for a variety of collections. As always, the choice
    is yours. The most important thing is not to forget the basic axioms in optimization
    decisions. Let''s look at another example with the class `Dictionary` as shown
    in code example here:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个示例相比，差异惊人，并且在使用`List`类时更为明显。因此，我们展示了简单单维数组与集合相比的明显优势，当处理大量数据时，这可能会极大地破坏你的性能。对于简单单维数组来说，不能说的就是它们是各种集合的构建块。一如既往，选择权在你。最重要的是不要忘记优化决策中的基本公理。让我们看看另一个示例，这里以`Dictionary`类为例，如代码示例所示：
- en: '[PRE24]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results were obtained:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 上，在 Unity 编辑器中测试此示例后，得到了以下结果：
- en: '[PRE25]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Also, I want to show you the following code example using the `Hashtable` collection
    for our performance testing, as shown in code example here:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我还想向你展示以下使用`Hashtable`集合进行性能测试的代码示例，如代码示例所示：
- en: '[PRE26]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor, the following results were obtained:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X，Intel Core i5 2.7 GHz 上，在 Unity 编辑器中测试此示例后，得到了以下结果：
- en: '[PRE27]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As you can see, all the collections are significantly inferior to the simple
    one-dimensional array in performance, but the benefit in many situations is more
    convenient because of the use of a more readable code. However, you lose a lot
    of CPU time and memory, and have to sacrifice clarity of code. The rest of the
    collection and all other constructions you are interested in, you can easily perform
    your own tests for your system's performance, on the basis of the examples discussed
    earlier.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，所有集合在性能上都显著劣于简单的一维数组，但在许多情况下，由于代码的可读性更好，因此具有优势。然而，你将失去大量的 CPU 时间和内存，并不得不牺牲代码的清晰度。对于其他集合和所有其他你感兴趣的结构，你可以很容易地根据前面讨论的示例对你的系统性能进行自己的测试。
- en: 'We will not leave without attention on loops that are used very often in code-like
    branching structure. Loops `for`, `while`, and `do`-`while` are the fastest compared
    to other cycles such as `foreach`. Another trick when using loops is that we can
    deploy loops for fewer passes as shown in code example here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会忽略在代码分支结构中经常使用的循环。与 `foreach` 等其他循环相比，`for`、`while` 和 `do`-`while` 循环是最快的。使用循环时的另一个技巧是，我们可以像这里的代码示例所示的那样减少循环的迭代次数：
- en: '[PRE28]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz, after testing this example in the Unity
    editor the following results are obtained:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，Intel Core i5 2.7 GHz，在 Unity 编辑器中测试此示例后，得到了以下结果：
- en: '[PRE29]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The results speak for themselves. So, do not forget about optimizing your loops.
    The first step is to draw attention to the cycles with a huge number of passes,
    since they can lower your performance by several orders of magnitude. Before optimizing
    anything, you need to find the bottlenecks in your code and only then decide which
    optimization techniques you prefer or require.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 结果不言而喻。因此，不要忘记优化你的循环。第一步是关注那些有大量迭代的循环，因为它们可能会降低你的性能几个数量级。在优化任何东西之前，你需要找到你代码中的瓶颈，然后才能决定你更喜欢或需要的优化技术。
- en: 'As for the loop `foreach`, we recommend that you use this cycle only in exceptional
    situations. Let''s look at a small sample code for each loop, and the next step
    as it is transformed into a completely different code loop. The next example shows
    a simple `foreach` loop:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 至于 `foreach` 循环，我们建议你只在特殊情况下使用这个循环。让我们看看每个循环的小样本代码，以及它如何转换成完全不同的代码循环。下一个示例展示了一个简单的
    `foreach` 循环：
- en: '[PRE30]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Next, let''s look at what happens to a piece of code **foreach** loop. As we
    can see in the code example here, our cycle turns into a loop while using the
    enumerator object. The code is given here:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看 `foreach` 循环中的一段代码会发生什么。正如我们在这里的代码示例中所看到的，我们的循环在使用了枚举对象后变成了一个 `while`
    循环。代码如下：
- en: '[PRE31]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: As for the characters, it is better to use a single character than a string
    consisting of a single character. A symbol is passed by value, and it is necessary
    and requires only two bytes of memory, while the string with one character requires
    more than 20 bytes of memory, since the string is passed by reference.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 至于字符，最好使用单个字符而不是由单个字符组成的字符串。符号是按值传递的，并且只需要两个字节的内存，而一个字符的字符串则需要超过 20 字节的内存，因为字符串是按引用传递的。
- en: 'I would also like to mention the `ToString` function that is best used only
    when necessary, otherwise you risk degrading your performance. For example, using
    this function for characters is not always exact: there is rarely a decision justified.
    Generally, you should remember one simple and most important axiom of code optimization—with
    less code executed, less CPU time and memory is used that significantly improves
    your productivity. Let''s look at a simple code example shown here, which covers
    one of the simplest options for optimizing the transfer of an integer to a string:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我还想提到 `ToString` 函数，它最好只在必要时使用，否则你可能会降低你的性能。例如，对于字符使用此函数并不总是精确的：很少有合理的决定。一般来说，你应该记住代码优化的一个简单而最重要的公理——执行的代码越少，使用的
    CPU 时间和内存就越少，这会显著提高你的生产力。让我们看看这里展示的一个简单的代码示例，它涵盖了优化整数到字符串转换的简单选项之一：
- en: '[PRE32]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'On Mac OS X, Intel Core i5 2.7 GHz after testing this example in the Unity
    editor I got the following results:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Mac OS X 上，Intel Core i5 2.7 GHz，在 Unity 编辑器中测试此示例后，我得到了以下结果：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Try to build your own tests for your functions on the basis of the preceding
    examples. In optimization, you should often trust your own instincts to find the
    cause of all ills, but to make the right decisions you need to rely on the results
    of the tests, that is, just pure mathematics and well-defined numbers.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试根据前面的示例为你的函数构建自己的测试。在优化过程中，你应该经常依赖自己的直觉来找到所有问题的原因，但要做出正确的决定，你需要依赖测试的结果，即纯粹数学和明确的数字。
- en: Transforming Unity C# code into Unity JavaScript code and vice versa
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将 Unity C# 代码转换为 Unity JavaScript 代码以及相反
- en: The following is an example of how easy it is to convert your Unity C# code
    to Unity JavaScript code and vice versa. You can find on the web a lot of different
    automatic tools that you can use for free in order get conversation between Unity
    Scripts done as early as possible. As an example, you can convert Unity JS to
    Unity C# on this [http://www.m2h.nl/files/js_to_c.php](http://www.m2h.nl/files/js_to_c.php).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例，说明了如何轻松地将你的 Unity C# 代码转换为 Unity JavaScript 代码以及相反。你可以在网上找到很多不同的免费自动工具，你可以使用这些工具尽早完成
    Unity 脚本之间的转换。例如，你可以在 [http://www.m2h.nl/files/js_to_c.php](http://www.m2h.nl/files/js_to_c.php)
    将 Unity JS 转换为 Unity C#。
- en: JavaScript variables and types
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 变量和类型
- en: 'By default, the Unity JS code variables are public and visible in Unity Inspector.
    In order to hide your variables from Unity inspector or from other classes, you
    should mark all those variables with a `private` keyword as shown in the following
    simple examples:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Unity JS 代码中的变量是公共的，在 Unity 检查器中可见。为了将你的变量从 Unity 检查器或其他类中隐藏，你应该使用 `private`
    关键字标记所有这些变量，如下面的简单示例所示：
- en: '[PRE34]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: C# variables and types
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 变量和类型
- en: 'Float values in C# must have a lowercase **f** or an uppercase **F** at the
    end. Otherwise, it will be treated as a double value. Also notice that in JS code,
    the string type should be written with the first letter uppercase. However, in
    C# code with lowercase letters you can see our simple examples here:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，浮点值必须在末尾有一个小写 **f** 或大写 **F**。否则，它将被视为双精度值。另外，注意在 JS 代码中，字符串类型应该用首字母大写。然而，在
    C# 代码中，你可以用小写字母看到我们这里的简单示例：
- en: '[PRE35]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: By default, in Unity C# code, variables are private and invisible in the Unity
    inspector. In order to show your variables in the Unity inspector, you should
    mark all these variables with the `public` keyword as shown in our previous simple
    examples.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，在 Unity C# 代码中，变量是私有的，在 Unity 检查器中不可见。为了在 Unity 检查器中显示你的变量，你应该使用 `public`
    关键字标记所有这些变量，就像我们之前的简单示例中所示。
- en: Converting types in Unity JS
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity JS 中转换类型
- en: 'You can use the following code to convert types in Unity JS:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码在 Unity JS 中转换类型：
- en: '[PRE36]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Converting types in Unity C#
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Unity C# 中转换类型
- en: 'You can use the following code to convert types in Unity C#:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以下代码在 Unity C# 中转换类型：
- en: '[PRE37]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Unity JS function versus Unity C# function
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity JS 函数与 Unity C# 函数
- en: The following code snippet shows the syntax of the code as written in Unity
    JS and Unity C#
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了在 Unity JS 和 Unity C# 中编写的代码的语法：
- en: '[PRE38]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Unity JS return versus Unity C# return
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity JS 返回与 Unity C# 返回
- en: 'In Unity JS, you don''t need to declare return type as shown in a simple function
    example here:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity JS 中，你不需要声明返回类型，就像这里简单函数示例中所示：
- en: '[PRE39]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In Unity C#, you have to always declare a `return` type:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity C# 中，你必须始终声明一个 `return` 类型：
- en: '[PRE40]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Unity JS yielding versus Unity C# yielding
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity JS 中的 yield 与 Unity C# 中的 yield
- en: 'In JS yielding is quite simple, like the `return` keyword. You can just use
    yield statements without any declarations as shown in the simple example here:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JS 中，yield 语句非常简单，就像 `return` 关键字一样。你可以直接使用 yield 语句，无需任何声明，就像这里简单示例中所示：
- en: '[PRE41]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'In C# code, you should declare the `IEnumerator` type in your method declaration
    as shown in the following example:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 代码中，你应该在你的方法声明中声明 `IEnumerator` 类型，如下面的示例所示：
- en: '[PRE42]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Unity JS directives versus Unity C# directives
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity JS 指令与 Unity C# 指令
- en: 'Unity has a number of **script directives**, for example, `AddComponentMenu`.
    The difference in syntax is shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 有许多 **脚本指令**，例如 `AddComponentMenu`。语法差异如下面的代码所示：
- en: '[PRE43]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter introduced different details about occlusion culling and LOD optimization
    techniques. Also, this chapter showed how to optimize Unity C# and Unity JS code.
    Finally, you saw main differences in syntax between Unity C# and Unity JS codes
    and learned how it is easy to transform between them.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 本章介绍了关于遮挡剔除和 LOD 优化技术的不同细节。此外，本章展示了如何优化 Unity C# 和 Unity JS 代码。最后，你看到了 Unity
    C# 和 Unity JS 代码之间的主要语法差异，并学习了如何轻松地在它们之间转换。
- en: In the next chapter, you will explore how to enhance the quality in games and
    applications using different techniques such as physically-based shaders and global
    illumination in Unity 5\. At the end of the chapter, you will know how to optimize
    any shader code.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将探索如何使用不同的技术，如基于物理的着色器和Unity 5中的全局照明，来提高游戏和应用程序的质量。本章结束时，你将了解如何优化任何着色器代码。
