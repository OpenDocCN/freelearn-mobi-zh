- en: Chapter 6. Making Your App Orientation-aware
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章：使您的应用程序方向感知
- en: 'This chapter will walk you through the process of dealing with the Android
    application behavior on device configuration changes. In the course of this chapter,
    we will cover comprehensive details of the theoretical concepts, but we will not
    make any significant changes to the `POIApp`. The following topics will be covered
    in this chapter:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍处理Android应用程序在设备配置变化时的行为的过程。在本章中，我们将涵盖理论概念的全面细节，但不会对`POIApp`进行任何重大更改。本章将涵盖以下主题：
- en: The Android behavior on configuration changes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android在配置变化时的行为
- en: Locking the Android application orientation
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定Android应用程序方向
- en: Saving the activity state for configuration changes
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存活动状态以应对配置变化
- en: Adding alternative resources
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加备用资源
- en: Manually handling the orientation behavior
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动处理方向行为
- en: The Android behavior on configuration changes
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Android在配置变化时的行为
- en: All modern smartphones and tablets switch between portrait and landscape modes
    in response to the way a user rotates the device. The Android application is expected
    to respond to the configuration changes and displays appropriate layouts for the
    current device configuration. The Android device configuration can be changed
    at runtime in many forms, such as device orientation changes, device language
    changes, device font updates, device connected to external displays, device connected
    to docks, and so on. In all of the earlier cases, Android restarts the running
    activity, loads alternative resources if available, to properly load your application
    for the given configurations. The activity goes through a series of life cycle
    methods, such as `OnDestroy()`, followed by `OnCreate()` to deal with the activity
    restart behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 所有现代智能手机和平板电脑都会根据用户旋转设备的方式在纵向和横向模式之间切换。Android应用程序应响应配置变化并显示适合当前设备配置的适当布局。Android设备配置可以在运行时以多种形式更改，例如设备方向变化、设备语言更改、设备字体更新、设备连接到外部显示器、设备连接到坞站等。在所有这些早期情况下，Android都会重新启动正在运行的活动，如果可用，则加载备用资源，以正确加载给定配置的应用程序。活动会经历一系列生命周期方法，例如`OnDestroy()`，然后是`OnCreate()`来处理活动重启行为。
- en: For example, if you are running your application on Nexus 5 device with 1080
    x 1920 resolution in the portrait mode, and while the orientation changes to landscape,
    the application has to respond appropriately to fit the layout and its child views
    for the 1920 x 1080 dimension. You may ask why not just adjust the view in the
    layout to fit to the appropriate size? Why should the activity be restarted? Well,
    Android does this to keep things simple. However, internally, it does many things
    and provides some of the advance features to make the configuration changes smoother.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果您在Nexus 5设备上以1080 x 1920分辨率在纵向模式下运行应用程序，并且当方向变为横向时，应用程序必须适当地响应以适应1920 x
    1080维度的布局及其子视图。您可能会问为什么不在布局中调整视图以适应适当的大小？为什么活动需要重新启动？嗯，Android这样做是为了保持简单。然而，在内部，它做了很多事情，并提供了一些高级功能，以使配置更改更加平滑。
- en: If the device configuration changes, Android destroys and restarts only the
    activity in the foreground, but the application instance still remains unchanged.
    When the activity restarts, the appropriate layout for that configuration is loaded.
    For such events, it is important that your application must restore the state
    of your activity and the user entered data on the UI. This can be possible using
    the `OnSaveInstanceState()` and `OnRestoreInstanceState()` callback methods.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果设备配置发生变化，Android只会销毁并重新启动前台的活动，但应用程序实例保持不变。当活动重新启动时，将加载该配置的适当布局。对于此类事件，确保您的应用程序必须恢复活动状态和用户在UI上输入的数据非常重要。这可以通过使用`OnSaveInstanceState()`和`OnRestoreInstanceState()`回调方法来实现。
- en: This chapter tackles some of the key points to build smooth, responsive, and
    orientation aware applications.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了构建平滑、响应和方向感知应用程序的一些关键点。
- en: Locking the Android application orientation
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定Android应用程序方向
- en: According to the Google design guidelines, the Android application must respond
    to the device orientation and display an appropriate layout for the given orientation.
    However, some kind of applications, such as games, video players, and so on, are
    intended to restrict the orientation to landscape or portrait only. For native
    Android applications, this can be achieved using the `android:screenOrientation`
    property to the `&lt;activity&gt;` declaration in the `AndroidManifest.xml` descriptor
    file. Xamarin makes this even simplified and recommends that you do not to edit
    the `AndroidManifest.xml` file manually at any point of time, instead it allows
    you to set all the application configuration metadata using `[Activity]` attribute
    custom properties to the activity declaration.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 根据谷歌设计指南，Android 应用必须响应用户设备的方向，并为给定的方向显示适当的布局。然而，某些类型的应用，如游戏、视频播放器等，旨在仅限制方向为横幅或纵向。对于原生
    Android 应用，这可以通过在 `AndroidManifest.xml` 描述文件中的 `<activity>` 声明中使用 `android:screenOrientation`
    属性来实现。Xamarin 使这一过程更加简化，并建议你任何时候都不要手动编辑 `AndroidManifest.xml` 文件，而是允许你使用 `[Activity]`
    属性自定义属性来设置活动声明中的所有应用程序配置元数据。
- en: As we recall from Chapter 3, *Creating the Points Of Interest App*, we are already
    using some of the properties of the `[Activity]` attribute, such as `Label`, `MainLauncher`,
    and `Icon`. Now to lock the activity orientation behavior, we can use the **ScreenOrientation**
    property on the activity class declaration. The `ScreenOrientation` property needs
    to be specified statically to each activity that requires control over the orientation
    lock. It cannot be controlled globally for the whole application scope.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们从第 3 章，*创建兴趣点应用* 回忆的那样，我们已经在使用 `[Activity]` 属性的一些属性，例如 `Label`、`MainLauncher`
    和 `Icon`。现在为了锁定活动方向行为，我们可以在活动类声明中使用 `ScreenOrientation` 属性。`ScreenOrientation`
    属性需要静态地指定给每个需要控制方向锁定的活动。它不能在应用程序的全局范围内进行控制。
- en: The `ScreenOrientation` attribute expects any one of the possible constants
    defined in the `Android.Content.PM.ScreenOrientation` enumeration. The `ScreenOrientation`
    enum defines all the set of device configuration constants such as `FullSensor`,
    `FullUser`, `Landscape`, `Locked`, `Nosensor`, `Portrait`, and so on.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`ScreenOrientation` 属性期望 `Android.Content.PM.ScreenOrientation` 枚举中定义的可能常量之一。`ScreenOrientation`
    枚举定义了所有设备配置常量，如 `FullSensor`、`FullUser`、`Landscape`、`Locked`、`Nosensor`、`Portrait`
    等。'
- en: For the complete set of `ScreenOrientation` constants, visit the official Xamarin.Android
    documentation at [http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/](http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看 `ScreenOrientation` 常量的完整集合，请访问官方 Xamarin.Android 文档：[http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/](http://developer.xamarin.com/api/type/Android.Content.PM.ScreenOrientation/)。
- en: 'Note that in this book, we will build the `POIApp` to respond to the device
    orientation and other different configuration''s change events. The following
    code block is used for demonstration purpose only and will not be continued along
    with the `POIApp` example code. You can add the following attributes to lock the
    `POIListActivity` orientation to landscape only:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这本书中，我们将构建 `POIApp` 以响应设备方向和其他不同配置更改事件。以下代码块仅用于演示目的，并且不会与 `POIApp` 示例代码一起继续。你可以添加以下属性来锁定
    `POIListActivity` 的方向为仅横幅：
- en: '[PRE0]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Make the preceding changes to `POIListActivity` and run the app. You will notice
    that the POI list screen overrides the device orientation lock settings and it
    will always be shown in the landscape mode.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的更改应用到 `POIListActivity` 并运行应用。你会注意到 POI 列表屏幕覆盖了设备方向锁定设置，并且它始终以横幅模式显示。
- en: Dynamically requesting the orientation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动态请求方向
- en: 'You can also change the desired activity orientation dynamically by setting
    the `RequestedOrientation` property to your activity. This allows further flexibility
    to dynamically change the orientation anytime as required. Add the following code
    snippet anywhere in your activity to restrict the currently running activity orientation
    to landscape only:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以通过设置 `RequestedOrientation` 属性到你的活动来动态更改所需的活动方向。这允许在需要时随时动态更改方向。在任何地方添加以下代码片段以限制当前运行的活动方向为仅横幅：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The changes made to the `RequestedOrientation` property has an impact on the
    activity in the foreground and a request for the specified orientation is made
    immediately by causing the current activity to restart. You can use the same property
    to obtain the current configuration that is in effect for the current activity.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `RequestedOrientation` 属性的更改会影响前台活动，并立即通过使当前活动重新启动来请求指定的方向。您可以使用相同的属性来获取当前活动生效的配置。
- en: Saving the activity state for configuration changes
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为配置更改保存活动状态
- en: Runtime configuration changes in the Android device cause the activity in the
    foreground to go through a restart process. This behavior is intended to simplify
    the process for the activity to reinitialize with alternative resources for the
    given configuration. As the activity goes through the recreation process, you
    might lose the user entered data or the current state of the activity. For any
    such course of events, all the Android applications must retain the activity state
    quickly and cheaply to avoid undesirable user experience. The following section
    will help you dive deeper to understand the process to retain the activity state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Android 设备的运行时配置更改会导致前台活动经历重启过程。这种行为旨在简化活动使用给定配置的替代资源重新初始化的过程。在活动经历重新创建过程时，您可能会丢失用户输入的数据或活动的当前状态。对于任何此类事件，所有
    Android 应用都必须快速且低成本地保留活动状态，以避免不良的用户体验。以下部分将帮助您深入了解保留活动状态的过程。
- en: 'With the configuration changes, the activity goes through a series of life
    cycle methods, such as `OnDestroy()` followed by `OnCreate()`. On its way, it
    calls `OnSaveInstanceState()` before it destroys the activity so that you can
    save the activity state data. The application state can be retained during the
    `onCreate()` or `OnRestoreInstanceState()` callback methods. To understand the
    whole process, we must recall the activity life cycle methods as described in
    Chapter 1, *The Anatomy of an Android App*. The following figure depicts the activity
    life cycle and the `OnSaveInstanceState` and `OnRestoreInstanceState ()` method''s
    call flow with their respective configuration changes:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在配置更改的情况下，活动会经历一系列生命周期方法，例如 `OnDestroy()` 后跟 `OnCreate()`。在这个过程中，它在销毁活动之前调用
    `OnSaveInstanceState()`，以便您可以保存活动状态数据。应用程序状态可以在 `onCreate()` 或 `OnRestoreInstanceState()`
    回调方法中保留。为了理解整个过程，我们必须回忆起第 1 章“Android 应用解剖”中描述的活动生命周期方法。以下图展示了活动生命周期以及 `OnSaveInstanceState`
    和 `OnRestoreInstanceState()` 方法的调用流程及其相应的配置更改：
- en: '![](img/zHkF0fQQ.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![](img/zHkF0fQQ.jpg)'
- en: A change in the orientation calls the `OnPause()`, `OnSaveInstanceState()`,
    `OnStop()`, and `OnDestroy()` methods followed by `OnCreate()`, `OnStart()`, `OnRestoreInstanceState()`,
    and `OnResume()`. Remember that this sequence is not always true. For example,
    when a user presses the device back button or calls the `Finish()` method, you
    do not need to save the activity state; hence, it just calls `OnPause()`, `OnStop()`,
    and `OnDestroy()`, but the `OnSaveInstanceState()` method is never called.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 方向的改变会调用 `OnPause()`、`OnSaveInstanceState()`、`OnStop()` 和 `OnDestroy()` 方法，然后是
    `OnCreate()`、`OnStart()`、`OnRestoreInstanceState()` 和 `OnResume()`。请记住，这个顺序并不总是正确的。例如，当用户按下设备返回按钮或调用
    `Finish()` 方法时，您不需要保存活动状态；因此，它只会调用 `OnPause()`、`OnStop()` 和 `OnDestroy()`，但 `OnSaveInstanceState()`
    方法永远不会被调用。
- en: The default implementation of `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    takes care of saving and retaining the data on all the Android view input widgets
    (for example, `EditText`, `CheckBox`, `RadioButton`, and so on) that are attached
    to the layout with an `id` property. This means that the Android SDK implements
    the `OnSaveInstanceState()` and the `OnRestoreInstanceState()` methods on each
    of the view controls.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSaveInstanceState()` 和 `OnRestoreInstanceState()` 的默认实现负责保存和保留所有与布局关联并具有
    `id` 属性的 Android 视图输入小部件（例如，`EditText`、`CheckBox`、`RadioButton` 等）上的数据。这意味着 Android
    SDK 在每个视图控件上实现了 `OnSaveInstanceState()` 和 `OnRestoreInstanceState()` 方法。'
- en: Based on two factors, Android decides whether the state of a view attached to
    a view group will be retained in the orientation change. One factor is the `id`
    property and the other is based on the value set for the `view.SaveEnabled` property.
    The `SaveEnabled` property checks whether the `onSaveInstanceState()` method will
    be called on that view. The default value for `SaveEnabled` is `true`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 基于两个因素，Android决定是否在方向更改时保留附加到视图组的视图的状态。一个因素是`id`属性，另一个是基于为`view.SaveEnabled`属性设置的值。`SaveEnabled`属性检查是否会在该视图中调用`onSaveInstanceState()`方法。`SaveEnabled`的默认值是`true`。
- en: Apart from the `SaveEnabled` property, Android provides yet another interesting
    method that allows you to control the save state behavior for the entire hierarchy
    under a view. For example, if you have five different views under a `LinearLayout`,
    and you wish not to save state for all those five views, including `LinearLayout`,
    you can just achieve this by setting the `SaveFromParentEnabled` property of `LinearLayout`
    to `false`.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`SaveEnabled`属性外，Android还提供了一个有趣的方法，允许您控制视图层次结构下整个保存状态的行为。例如，如果您在`LinearLayout`下有五个不同的视图，并且您希望不保存包括`LinearLayout`在内的这五个视图的状态，您只需将`LinearLayout`的`SaveFromParentEnabled`属性设置为`false`即可。
- en: For applications using custom or compound views, you must handle the state restoration
    manually. You need to override the `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    methods in your custom view implementation to store the state of your view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 对于使用自定义或复合视图的应用程序，您必须手动处理状态恢复。您需要在自定义视图实现中重写`OnSaveInstanceState()`和`OnRestoreInstanceState()`方法以存储您视图的状态。
- en: Manually saving the activity state
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动保存活动状态
- en: If you need to manually save the activity state, you must override the following
    methods in your activity and write your own logic to save and restore the activity
    state in data bundles. The `OnSaveInstanceState()` method supplies an instance
    of `Bundle` in which we can dump the data, and the `OnRestoreInstanceState()`
    method returns the previously saved `Bundle`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要手动保存活动状态，您必须在您的活动中重写以下方法，并编写自己的逻辑来在数据包中保存和恢复活动状态。`OnSaveInstanceState()`方法提供了一个`Bundle`实例，我们可以将其用于数据转储，而`OnRestoreInstanceState()`方法返回之前保存的`Bundle`。
- en: '`Bundle` is a special kind of container that provides the key/value maps of
    heterogeneous values. `Bundle` is generally used for parsing data from one activity
    to another or while saving and retrieving the view state. The `Bundle` class provides
    a set of overloaded `PutXXX()` and `GetXXX()` methods to store and retrieve the
    values.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Bundle`是一种特殊的容器，它提供了异构值的键/值映射。`Bundle`通常用于从一个活动解析数据到另一个活动或保存和检索视图状态。`Bundle`类提供了一组重载的`PutXXX()`和`GetXXX()`方法来存储和检索值。'
- en: 'The following code snippet depicts the `OnSaveInstanceState()` and `OnRestoreInstanceState()`
    methods'' prototype:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段描述了`OnSaveInstanceState()`和`OnRestoreInstanceState()`方法的原型：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Retaining the POI list scroll position
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保留POI列表滚动位置
- en: So far, we had quite a lot of ground on the activity life cycle behavior on
    configuration changes. Let's now implement it to `POIApp`. When the POI list grows,
    it allows the user to scroll vertically to see all of the list items. Let's say,
    the user has scrolled till the 10th element in the list, and in the meantime,
    the device orientation changed. Due to the device configuration change request,
    the activity restarted and causes the list to appear from the top. It is a good
    idea to retain the list scroll position for better user experience.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经对配置更改时的活动生命周期行为有了很多了解。现在让我们将其实现到`POIApp`中。当POI列表增长时，它允许用户垂直滚动以查看所有列表项。假设，用户已经滚动到列表中的第10个元素，同时设备方向发生了变化。由于设备配置更改请求，活动重新启动，导致列表从顶部出现。保留列表滚动位置以获得更好的用户体验是一个好主意。
- en: 'Let''s perform the following steps to retain the POI list scroll position when
    the device configuration changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备配置更改时，要保留POI列表滚动位置，请执行以下步骤：
- en: 'Get the index of the first visible list item and save it in `Bundle` in the
    `OnSaveInstanceState()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnSaveInstanceState()`方法中获取第一个可见列表项的索引并将其保存到`Bundle`中：
- en: '[PRE3]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In the preceding code snippet, the string `scroll_position` is used as the key
    to save the current scroll position of `ListView` on orientation change. The same
    key should be used while retrieving the data from the `OnRestoreInstanceState()`
    callback.
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，字符串`scroll_position`用作键，用于在方向更改时保存`ListView`的当前滚动位置。在从`OnRestoreInstanceState()`回调检索数据时，应使用相同的键。
- en: 'Restore the saved list scrolling position in `OnRestoreInstanceState()`. Note
    that we have to use the same key that was used to save the current scroll position:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`OnRestoreInstanceState()`中恢复保存的列表滚动位置。请注意，我们必须使用与保存当前滚动位置相同的键：
- en: '[PRE4]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add the following code snippet to the `DownloadPoisListAsync()` method in the
    `POIListActivity` class and queue the message for scrolling the POI list to the
    last saved scroll position:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码片段添加到`POIListActivity`类的`DownloadPoisListAsync()`方法中，并将滚动POI列表到最后一个保存的滚动位置的队列消息：
- en: '[PRE5]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now run the application and test the POI application by changing the orientation;
    notice that the scroll positions are retained.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行应用程序，通过改变方向来测试POI应用程序；注意滚动位置被保留。
- en: Building the orientation-aware layout
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建方向感知布局
- en: Android allows you to add multiple competing versions of resources to make an
    application compatible with different device configurations. The Android system
    comes handy when it comes to picking up the right resources for a given configuration.
    You don't need to write any code to find what is the current configuration and
    choose the appropriate resources. All you need to do is to add multiple versions
    of resources, such as `string.xml`, `.png` drawable images, or layout XML files,
    so that the best version of resource can be picked up under different circumstances.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Android允许您添加多个竞争版本的资源，以使应用程序与不同的设备配置兼容。在为给定配置选择正确资源时，Android系统非常有用。您不需要编写任何代码来查找当前配置并选择适当的资源。您需要做的只是添加多个版本的资源，例如`string.xml`、`.png`可绘制图像或布局XML文件，以便在不同情况下选择最佳的资源版本。
- en: Imagine that your app was primarily targeted to the U.S. market, but now we
    are looking forward to targeting Russia with the Russian language support. In
    this case, multiple versions of `string.xml` can be added to support the Russian
    language. Or imagine that a user is running the app on a tablet in the portrait
    mode, and now the device rotates to the landscape orientation. The screen width
    gets doubled and provides the opportunity to display more information. In such
    cases, you will need to add multiple versions of activity layouts for different
    orientations. Let's hold our breath till the next chapter to learn more about
    how to build the orientation aware layout for Android tablets.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您的应用程序最初主要针对美国市场，但现在我们期待着针对俄罗斯市场，并支持俄语。在这种情况下，可以添加多个版本的`string.xml`以支持俄语。或者想象一下，用户正在竖屏模式下在平板电脑上运行应用程序，现在设备旋转到横屏方向。屏幕宽度加倍，提供了显示更多信息的机会。在这种情况下，您将需要添加不同方向的活动布局的多个版本。让我们屏住呼吸，期待下一章了解更多关于如何为Android平板电脑构建方向感知布局的信息。
- en: 'All the resources added to the application will be added to various subdirectories
    under the `Resources` directory. The default resource directory structure is shown
    as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 添加到应用程序的所有资源都将添加到`Resources`目录下的各个子目录中。默认资源目录结构如下所示：
- en: '![](img/YRuxqZab.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/YRuxqZab.jpg)'
- en: Any resource that is added as a default resource will be used when there are
    no alternative best match resources available for the given configuration. Alternative
    resources are designed for a specific configuration.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当没有可用的替代最佳匹配资源时，将作为默认资源添加的资源将被使用。替代资源是为特定配置设计的。
- en: To add alternative resources, you just need to use the specific configuration
    qualifier. The configuration qualifiers you can use for device screen sizes are
    small, normal, large, and xlarge. For example, layouts for an extra-large screen,
    such as a tablet layout, should go in the **layout-xlarge** directory. Since Android
    3.2, Android recommends that you use the `sw&lt;N&gt;dp` configuration qualifier
    to define an extra-large layout for the tablet. For example, if your multipane
    tablet layout requires at least 600dp of screen width, you should place it in
    the layout-`sw600dp` directory.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加替代资源，您只需使用特定的配置限定符。您可以为设备屏幕尺寸使用的配置限定符有：小、正常、大和超大。例如，对于超大屏幕的布局，如平板电脑布局，应放在**layout-xlarge**目录下。自Android
    3.2以来，Android建议您使用`sw<N>dp`配置限定符来为平板电脑定义超大布局。例如，如果您的多窗格平板电脑布局至少需要600dp的屏幕宽度，您应将其放置在`layout-sw600dp`目录下。
- en: To provide the translated version of the `strings.xml` file for Russian users,
    you have to place the `string.xml` file in the `Resources/values-ru/` directory.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 要为俄语用户提供`strings.xml`文件的翻译版本，您必须将`string.xml`文件放置在`Resources/values-ru/`目录下。
- en: 'The following table depicts the list of configuration qualifiers that allow
    you to provide special resources for different screen configurations:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了允许您为不同屏幕配置提供特殊资源的配置限定符列表：
- en: Characteristic
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 特征
- en: Qualifier
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 限定符
- en: Description
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 描述
- en: Screen size
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 屏幕尺寸
- en: small, normal, large, and xlarge
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 小号、正常、大号和超大号
- en: Resources for small, normal, large, and extra-large screen sizes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为小号、正常、大号和超大号屏幕尺寸的资源。
- en: l dpi
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: l dpi
- en: Resources for low-density (l dpi) screens (~120 dpi). You can now ignore this
    resource set, as no new Android devices with ldpi density are out in the market.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为低密度（l dpi）屏幕的资源（约120 dpi）。您现在可以忽略这个资源集，因为市场上没有新的Android设备具有ldpi密度。
- en: mdpi
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: mdpi
- en: Resources for medium-density (mdpi) screens (~160 dpi). (This is the baseline
    density.)
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 为中等密度（mdpi）屏幕的资源（约160 dpi）。（这是基准密度。）
- en: hdpi
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: hdpi
- en: Resources for high-density (hdpi) screens (~240 dpi).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为高密度（hdpi）屏幕的资源（约240 dpi）。
- en: xhdpi
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: xhdpi
- en: Resources for extra-high-density (xhdpi) screens (~320 dpi).
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为超高密度（xhdpi）屏幕的资源（约320 dpi）。
- en: xxhdpi
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: xxhdpi
- en: Resources for extra-extra-high-density (xxhdpi) screens (~480 dpi).
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 为超高密度（xxhdpi）屏幕的资源（约480 dpi）。
- en: xxxhdpi
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: xxxhdpi
- en: Resources for extra-extra-extra-high-density (xxxhdpi) use (~640 dpi). Use this
    for the launcher icon only; see the earlier note.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为超高超高超高密度（xxxhdpi）屏幕的资源使用（约640 dpi）。仅用于启动器图标；参见前面的说明。
- en: nodpi
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: nodpi
- en: Resources for all densities. These are density-independent resources. The system
    does not scale resources tagged with this qualifier.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 为所有密度的资源。这些是密度无关的资源。系统不会缩放带有此限定符的资源。
- en: Device orientation
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 设备方向
- en: land
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: land
- en: Resources for screens in the landscape orientation.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为横向方向的屏幕使用的资源。
- en: port
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: port
- en: Resources for screens in the portrait orientation.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 为纵向方向的屏幕使用的资源。
- en: Aspect ratio
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 宽高比
- en: long
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: long
- en: Resources for screens that have a significantly taller or wider aspect ratio
    (when in the portrait or landscape orientation, respectively) than the baseline
    screen configuration.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为具有比基准屏幕配置显著更高或更宽宽高比（在纵向或横向方向时）的屏幕使用的资源。
- en: notlong
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 不长
- en: Resources for use screens that have an aspect ratio that is similar to the baseline
    screen configuration.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为具有与基准屏幕配置相似宽高比的屏幕使用的资源。
- en: In the following Chapter 7, *Designing for Multiple Screen Sizes*, we will make
    use of the alternative layout resource to make the application compatible for
    Android tablets.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的第7章“为多种屏幕尺寸设计”中，我们将使用替代布局资源来使应用程序兼容Android平板电脑。
- en: Manually handling the orientation behavior
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 手动处理方向行为
- en: As described, the Android system automatically takes care of updating appropriate
    resources when the configuration changes. However, at times due to performance
    reasons, you might like to restrict the activity restart and write your own logic
    to update appropriate resources for the given configuration. But remember that
    this is not recommended by the Google guidelines; if you're implementing this
    for your application, do it at your own risk.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 如所述，Android系统会自动处理配置更改时更新适当的资源。然而，有时出于性能原因，您可能希望限制活动重启并编写自己的逻辑来更新给定配置的适当资源。但请记住，Google指南不推荐这样做；如果您正在为您的应用程序实现此功能，请自行承担风险。
- en: 'The following steps will guide you to manually handle the required configuration
    for your app:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将指导您手动处理应用所需的配置：
- en: 'Add the `ConfigurationChanges` attribute to the activity declaration. This
    allows you to declare all possible configurations values defined in `Android.Content.PM.ConfigChanges`
    that you want to handle yourself for your app. At runtime, this adds the `android:configChanges`
    attribute to your activity declaration in the `AndroidManifest.xml` file:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`ConfigurationChanges`属性添加到活动声明中。这允许您声明您想要自己处理的所有在`Android.Content.PM.ConfigChanges`中定义的可能配置值。在运行时，这将在`AndroidManifest.xml`文件中的活动声明中添加`android:configChanges`属性：
- en: '[PRE6]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code syntax, we stated that we will be manually handling the
    configuration for the device orientation and sliding keyboard state changes. Note
    that the preceding declaration bypasses the whole activity destruction process
    and simply returns a callback to let you know about the changes.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码语法中，我们说明了我们将手动处理设备方向和滑动键盘状态变化的配置。请注意，前面的声明绕过了整个活动销毁过程，并简单地返回一个回调以通知您有关变化。
- en: 'Override `OnConfigurationChanged()` in your activity. This method will be called
    when one of the configuration changes, as listed in the `ConfigurationChanges`
    attribute declaration:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的活动中重写`OnConfigurationChanged()`。当配置变化之一（如`ConfigurationChanges`属性声明中列出）发生时，将调用此方法：
- en: '[PRE7]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, in the `OnConfigurationChanged()` method, you need to update the UI so
    that it reflects the orientation change. For our `POIApp`, we allow the system
    to handle the configuration itself. Note that the all the code snippets used in
    this chapter are for demonstration purpose only, and we will not continue with
    these changes to build `POIApp` for rest of the chapters in this book.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，在`OnConfigurationChanged()`方法中，你需要更新UI，以便它反映方向变化。对于我们的`POIApp`，我们允许系统自行处理配置。请注意，本章中使用的所有代码片段仅用于演示目的，我们不会继续使用这些更改来构建本书其余章节中的`POIApp`。
- en: Summary
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground on the behavior of an activity when
    the device configuration is changed, forcing the activity to display a specified
    orientation and to save and restore the activity state. The next chapter will
    guide you to deal with designing applications for various device form factors
    such as Android tablets.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们详细介绍了当设备配置发生变化时，活动行为的变化，迫使活动显示指定的方向并保存和恢复活动状态。下一章将指导你处理为各种设备形态设计应用程序，例如Android平板电脑。
