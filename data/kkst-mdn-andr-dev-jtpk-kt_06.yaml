- en: '*Chapter 5*: Adding Navigation in Compose With Jetpack Navigation'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第五章*: 使用Jetpack导航在Compose中添加导航'
- en: In this chapter, we'll focus on a core Jetpack library, the Navigation component.
    This library is essential to us since it allows us to easily navigate between
    application screens.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将重点关注一个核心的Jetpack库，即导航组件。这个库对我们来说至关重要，因为它允许我们轻松地在应用程序屏幕之间导航。
- en: So far, we have only created a screen in our Restaurants application, where
    we displayed a list of diners. It's time to step up the game and add another screen
    to our application!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只在我们的餐厅应用程序中创建了一个屏幕，其中显示了食客的列表。现在是时候提升游戏水平，并为我们的应用程序添加另一个屏幕！
- en: In the first section, *Introducing the Jetpack Navigation component*, we will
    explore the basic concepts and elements of the Navigation component. In the second
    section, *Creating a new Compose-based screen*, we will create a new screen to
    display the details of a specific restaurant and realize that we don't know how
    to navigate to it.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一部分，*介绍Jetpack导航组件*，我们将探讨导航组件的基本概念和元素。在第二部分，*创建基于Compose的新屏幕*，我们将创建一个新的屏幕来显示特定餐厅的详细信息，并意识到我们不知道如何导航到它。
- en: In the third section, *Implementing navigation with Jetpack Navigation*, we
    will add the Navigation component to the Restaurants application and use it to
    navigate to the second screen. Finally, in the *Adding support for deep links*
    section, we will create a deep link to our newly created screen and make sure
    that our application knows how to handle it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三部分，*使用Jetpack导航实现导航*，我们将向餐厅应用程序添加导航组件，并使用它导航到第二个屏幕。最后，在*添加对深链接的支持*部分，我们将创建一个指向我们新创建的屏幕的深链接，并确保我们的应用程序知道如何处理它。
- en: 'To summarize, in this chapter we''re going to cover the following main topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，在本章中我们将涵盖以下主要主题：
- en: Introducing the Jetpack Navigation component
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍Jetpack导航组件
- en: Creating a new Compose-based screen
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个基于Compose的新屏幕
- en: Implementing navigation with Jetpack Navigation
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Jetpack导航实现导航
- en: Adding support for deep links
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加对深链接的支持
- en: Before jumping in, let's set up the technical requirements for this chapter.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，让我们为本章设置技术要求。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Building Compose-based Android projects with Jetpack Navigation usually requires
    your day-to-day tools. However, to follow along smoothly, make sure you have the
    following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Jetpack导航构建基于Compose的Android项目通常需要您的日常工具。然而，为了顺利跟进，请确保您有以下内容：
- en: The Arctic Fox 2020.3.1 version of Android Studio. You can also use a newer
    Android Studio version or even Canary builds, but note that the IDE interface
    and other generated code files might differ from the ones used throughout this
    book.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Arctic Fox 2020.3.1版本的Android Studio。您也可以使用更新的Android Studio版本，甚至Canary构建，但请注意，IDE界面和其他生成的代码文件可能与本书中使用的不同。
- en: Kotlin 1.6.10 or newer plugin installed in Android Studio
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Android Studio中安装了Kotlin 1.6.10或更高版本的插件
- en: The Restaurants app code from the previous chapter
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 上一章的餐厅应用程序代码
- en: The starting point for this chapter is represented by the Restaurants application
    developed in [*Chapter 4*](B17788_04_ePub.xhtml#_idTextAnchor115), *Handling Async
    Operations with Coroutines*. If you haven't followed the implementation from the
    previous chapter, access the starting point for this chapter by navigating to
    the `Chapter_04` directory of the repository and importing the Android project
    named `chapter_4_restaurants_app`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的起点是上一章开发的餐厅应用程序，[*第4章*](B17788_04_ePub.xhtml#_idTextAnchor115)，*使用协程处理异步操作*。如果您没有跟随上一章的实现，请通过导航到存储库的`Chapter_04`目录并导入名为`chapter_4_restaurants_app`的Android项目来访问本章的起点。
- en: 'To access the solution code for this chapter, navigate to the `Chapter_05`
    directory: [https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问本章的解决方案代码，请导航到`Chapter_05`目录：[https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app](https://github.com/PacktPublishing/Kickstart-Modern-Android-Development-with-Jetpack-and-Kotlin/tree/main/Chapter_05/chapter_5_restaurants_app)。
- en: Introducing the Jetpack Navigation component
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Jetpack导航组件
- en: The **Navigation** component is Jetpack's solution to navigation within Android
    apps. This library allows you to easily implement navigation between the screens
    of your application.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**Navigation**组件是Jetpack针对Android应用程序内导航的解决方案。这个库允许您轻松实现应用程序屏幕之间的导航。'
- en: 'To promote a predictable user experience and consistent manner of handling
    app flows, the Navigation component adheres to a set of principles. The two most
    important principles are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 为了促进可预测的用户体验和一致处理应用程序流程的方式，导航组件遵循一系列原则。其中最重要的两个原则如下：
- en: The application has a fixed start **destination** (screen) – this allows the
    application behavior to be predictable because the app will always present this
    destination first, no matter where it is being launched from.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该应用程序有一个固定的起始**目的地**（屏幕）——这允许应用程序的行为可预测，因为无论从哪里启动，应用程序都会首先展示这个目的地。
- en: In our Restaurants application, we plan to set the start destination as our
    existing screen with the list of restaurants (represented by the `RestaurantsScreen()`
    composable function). In other words, this is the first screen that the user will
    always see when launching the app from the Android launcher screen.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的餐厅应用程序中，我们计划将起始目的地设置为现有的包含餐厅列表的屏幕（由`RestaurantsScreen()`可组合函数表示）。换句话说，这是用户从Android启动器屏幕启动应用程序时始终会看到的第一个屏幕。
- en: 'The navigation state is defined as a stack of destinations, often called the
    **back stack**. When the app is initially started, the stack will contain the
    app''s start destination – let''s call this *Screen A*. If you navigate from *Screen
    A* to *Screen B*, *B* will be added on top of the stack. This applies when navigating
    to *Screen C* too. To better understand how the back stack works, let''s try to
    illustrate it in such a scenario:'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 导航状态被定义为目的地栈，通常称为**后台栈**。当应用程序最初启动时，栈将包含应用程序的起始目的地——让我们称它为*屏幕A*。如果您从*屏幕A*导航到*屏幕B*，*B*将被添加到栈顶。这同样适用于导航到*屏幕C*。为了更好地理解后台栈的工作原理，让我们尝试在以下场景中对其进行说明：
- en: '![Figure 5.1 – Back stack evolution of screens while the user navigates within
    the app'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.1 – 用户在应用程序内导航时屏幕的后台栈演变'
- en: '](img/B17788_05_1.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_05_1.jpg)'
- en: Figure 5.1 – Back stack evolution of screens while the user navigates within
    the app
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1 – 用户在应用程序内导航时屏幕的后台栈演变
- en: At the top of the back stack, you will always have the current screen the user
    is at right now. When navigating back to the previous screen, the top of the back
    stack is popped, just as we did in *Figure 5.1*, where navigating from *Screen
    C* to *Screen B* resulted in the pop of *Screen C* from the back stack.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在后台栈的顶部，您将始终有用户现在所在的当前屏幕。当导航回上一个屏幕时，后台栈的顶部将被弹出，就像我们在*图5.1*中所做的那样，从*屏幕C*导航到*屏幕B*导致从后台栈中弹出*屏幕C*。
- en: All these operations are always done at the top of the stack, while the back
    of the stack will always contain the fixed start destination – in our case, *Screen
    A*.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些操作始终在栈顶进行，而栈底将始终包含固定的起始目的地——在我们的案例中，*屏幕A*。
- en: The Navigation component takes care of handling the back stack operations behind
    the scenes for us.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 导航组件负责在幕后为我们处理后台栈操作。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Initially, the Navigation component specialized in offering navigation mainly
    between `Fragment` components. Today, the library also supports Compose and the
    navigation between composable functions.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最初，导航组件主要专注于在`Fragment`组件之间提供导航。如今，该库也支持Compose以及可组合函数之间的导航。
- en: 'Apart from following clear principles when it comes to UI navigation, the Navigation
    component has three main constituent elements:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在UI导航方面遵循清晰的原则外，导航组件有三个主要组成部分：
- en: '**Navigation graph**: The core source of information related to navigation
    within your app. In the navigation graph, you define all the destinations as well
    as the possible paths that the user can take throughout the app to achieve different
    tasks.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**导航图**：与您应用程序内导航相关的核心信息源。在导航图中，您定义所有目的地以及用户在整个应用程序中可以采取的可能路径以完成不同的任务。'
- en: '**NavHost**: A container composable function that will display the composable
    destinations. As the user navigates between different destinations, the content
    of the navigation host is swapped and recomposed.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**NavHost**：一个容器可组合函数，将显示可组合目的地。随着用户在各个目的地之间导航，导航宿主的内容将被交换和重新组合。'
- en: '`NavHost` as the user starts navigating between screens.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户开始在屏幕之间导航时，`NavHost`作为导航开始。
- en: 'Now, when you implement the Navigation component in your Compose-based Android
    app, you will gain a lot of benefits. The following lists some examples:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当您在基于 Compose 的 Android 应用中实现导航组件时，您将获得许多好处。以下列出了一些示例：
- en: You don't need to handle the complexity of navigation between composable functions.
    The library does that out of the box for you.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无需处理在可组合函数之间导航的复杂性。库会为您自动处理。
- en: You don't need to handle *Up* or *Back* actions on your own. If you press the
    system's **Back** button, the library will automatically pop the current destination
    from the back stack and send the user to the previous destination.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无需自己处理 *向上* 或 *返回* 操作。如果您按下系统的 **返回** 按钮，库将自动从返回栈中弹出当前目的地，并将用户发送到上一个目的地。
- en: You benefit from scoped `ViewModel` components to a specific Navigation graph
    or destination. This means that the `ViewModel` instance used by a composable
    destination will live for as long as the composable screen does.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您可以从特定导航图或目的地受益于作用域内的 `ViewModel` 组件。这意味着用于可组合目的地的 `ViewModel` 实例将和可组合屏幕一样长时间存在。
- en: You don't need to implement deep links from scratch. Deep links allow you to
    directly navigate to a specific destination within the app without having to traverse
    the entire path of screens that get you there. We will see how they work in the
    *Adding support for deep links* section of this chapter.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您无需从头开始实现深链接。深链接允许您直接导航到应用程序中的特定目的地，而无需遍历到达那里的整个屏幕路径。我们将在本章的 *添加对深链接的支持* 部分中看到它们是如何工作的。
- en: Now that we have a basic overview of the elements and advantages of using Jetpack
    Navigation, it's time to create a new screen so we can implement navigation in
    our Restaurants application.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对使用 Jetpack Navigation 的元素和优势有了基本的了解，是时候创建一个新的屏幕，以便我们在餐厅应用中实现导航了。
- en: Creating a new Compose-based screen
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新的基于 Compose 的屏幕
- en: Real-world applications are required to display a lot of content, so one screen
    probably won't suffice. So far, our Restaurants application features a simple
    screen where all the restaurants that we receive from our remote database are
    displayed.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界的应用程序需要显示大量内容，所以一个屏幕可能不够。到目前为止，我们的餐厅应用程序有一个简单的屏幕，显示我们从远程数据库接收到的所有餐厅。
- en: Let's practice all the skills we've learned so far by creating a new screen
    that will display the details of a particular restaurant. The plan is that when
    users press on a particular restaurant from the list inside our `RestaurantsScreen()`
    composable screen, we should take them to a new details screen for that particular
    restaurant.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过创建一个新的屏幕来练习我们迄今为止学到的所有技能，这个屏幕将显示特定餐厅的详细信息。计划是当用户在我们的 `RestaurantsScreen()`
    可组合屏幕中的列表中点击某个特定餐厅时，我们应该带他们到一个新的详情屏幕，显示该特定餐厅的详细信息。
- en: 'Yet to perform navigation between two screens, we need first to build the second
    screen. Unlike with the first composable screen, it''s time to change our tactic
    and build it from top to bottom. Let''s build this second feature first by defining
    the network request, then executing it inside its own `ViewModel`, and finally
    creating the composable UI that will consume the data, as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 要在两个屏幕之间进行导航，我们首先需要构建第二个屏幕。与第一个可组合屏幕不同，现在是时候改变我们的策略，从上到下构建它。让我们首先通过定义网络请求，然后在它自己的
    `ViewModel` 中执行它，最后创建一个将消费数据的可组合 UI，如下所示：
- en: Defining the HTTP request for the contents of a restaurant
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义获取餐厅内容的 HTTP 请求
- en: Getting the contents of a specific restaurant
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取特定餐厅的内容
- en: Building the restaurant details screen
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建餐厅详情屏幕
- en: Let's start!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Defining the HTTP request for the contents of a restaurant
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义获取餐厅内容的 HTTP 请求
- en: We need to know how to obtain the data for our new restaurant details screen.
    Instead of relying on the previously retrieved data (the list of restaurants),
    we want to make every screen in our application as independent as possible. This
    way, we design our application to easily support deep links and we better defend
    ourselves from events such as a system-initiated process death.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要知道如何获取我们新的餐厅详情屏幕的数据。我们不想依赖于之前检索到的数据（餐厅列表），我们希望使我们的应用程序中的每个屏幕尽可能独立。这样，我们设计应用程序以轻松支持深链接，并更好地保护自己免受系统启动的进程死亡等事件的影响。
- en: That's why we will build this new screen so that it gets its own content. In
    other words, in the new screen, we will get the details for a particular restaurant
    from the same database where we've obtained the list of restaurants. But how will
    we do that?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，我们将构建这个新的屏幕，使其有自己的内容。换句话说，在新屏幕中，我们将从我们获取餐厅列表的同一数据库中获取特定餐厅的详细信息。但我们如何做到这一点呢？
- en: 'Remember that the restaurants within our Firebase database have a unique `Integer`
    identifier field called `r_id`, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，我们Firebase数据库中的餐厅有一个唯一的`Integer`标识字段，称为`r_id`，如下截图所示：
- en: '![](img/B17788_05_2.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_05_2.jpg)'
- en: Figure 5.2 – Identifying the unique identifier field for restaurants in Firebase
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2 – 识别Firebase中餐厅的唯一标识字段
- en: 'We can use this field to get the details of one specific restaurant. And since
    `r_id` is mapped to the `id: Int` field of the `Restaurant` object, this means
    that when the user presses on a restaurant in our `RestaurantsScreen` composable,
    we can forward the `id` value to the second screen.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '我们可以使用此字段来获取一个特定餐厅的详细信息。由于`r_id`映射到`Restaurant`对象的`id: Int`字段，这意味着当用户在我们的`RestaurantsScreen`可组合组件上点击餐厅时，我们可以将`id`值传递到第二个屏幕。'
- en: In the second screen, we will execute an API request to our Firebase REST API
    and pass the value of the unique ID of the restaurant within our app that corresponds
    to the `r_id` identifier of the restaurant inside the remote database.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二屏中，我们将向我们的Firebase REST API执行一个API请求，并传递我们应用中对应远程数据库中餐厅`r_id`标识符的唯一ID的餐厅ID值。
- en: 'The Firebase REST API has us covered for such cases. If we want to get the
    details of one element from the restaurants JSON content, we must append two query
    parameters to the same URL used to retrieve the entire restaurants list:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Firebase REST API为我们处理此类情况。如果我们想获取餐厅JSON内容中一个元素的详细信息，我们必须将两个查询参数附加到用于检索整个餐厅列表的相同URL：
- en: '`orderBy=r_id` to instruct Firebase to filter the elements by their `r_id`
    field.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`orderBy=r_id`来指示Firebase根据其`r_id`字段过滤元素。
- en: '`equalTo=2` to let Firebase know the value of the `r_id` field of the restaurant
    element that we''re looking for – in this case `2`.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`equalTo=2`让Firebase知道我们正在寻找的餐厅元素的`r_id`字段值 – 在这种情况下是`2`。
- en: 'To practice, place in your browser address bar the Firebase URL that you''ve
    used to get the restaurants until now and append the previous two query parameters
    as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 为了练习，在您的浏览器地址栏中放置您到目前为止用于获取餐厅的Firebase URL，并附加以下两个查询参数：
- en: '[PRE0]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you access your link, the response will, unfortunately, look like this:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您访问您的链接，不幸的是，响应将如下所示：
- en: '[PRE1]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Firebase needs some additional configuration so that we can get the details
    of only one element within the list, so let''s do that now:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让我们能够获取列表中单个元素的详细信息，Firebase需要一些额外的配置，所以现在让我们来做这件事：
- en: 'Navigate to your Firebase console and log into your Google account by accessing
    this link: [https://console.firebase.google.com/](https://console.firebase.google.com/).'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到您的Firebase控制台，通过访问此链接登录您的Google账户：[https://console.firebase.google.com/](https://console.firebase.google.com/)。
- en: From the list of Firebase projects, select the one you've previously created
    to store the restaurants.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从Firebase项目列表中选择您之前创建的用于存储餐厅的项目。
- en: In the left menu, expand the **Build** tab, search for **Realtime Database**,
    and then select it.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧菜单中，展开**构建**选项卡，搜索**实时数据库**，然后选择它。
- en: Move away from the preselected **Data** tab and select the **Rules** tab.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 离开预先选择的**数据**选项卡，并选择**规则**选项卡。
- en: 'We need to allow Firebase to index the restaurants based on their `r_id` field,
    so update the write `rules` as follows:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要允许Firebase根据其`r_id`字段索引餐厅，因此更新写入规则如下：
- en: '[PRE2]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By doing so, we've instructed Firebase that the JSON array content located at
    the `restaurants` node can be indexed and accessed individually.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们已指示Firebase，位于`restaurants`节点处的JSON数组内容可以被索引并单独访问。
- en: 'Now, try to access the URL with the details for the restaurant with the `id`
    field value of `2` again:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，再次尝试使用具有`id`字段值为`2`的餐厅的详细信息访问URL：
- en: '![Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON
    object'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.3 – 获取Firebase对一个餐厅JSON对象的响应'
- en: '](img/B17788_05_3.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_05_3.jpg)'
- en: Figure 5.3 – Obtaining the response from Firebase for one restaurant JSON object
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.3 – 获取Firebase对一个餐厅JSON对象的响应
- en: 'Note:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: To see the structure of the JSON response in a more readable manner in your
    browser, you can add the `&print=pretty` query parameter at the end of the request
    URL.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在浏览器中以更可读的方式查看JSON响应的结构，你可以在请求URL的末尾添加`&print=pretty`查询参数。
- en: Success! We've obtained the details of the restaurant with the `r_id` field's
    value of `2`.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经获取了具有`r_id`字段值为`2`的餐厅的详细信息。
- en: 'Now, let''s implement this request in our app:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的应用程序中实现这个请求：
- en: 'First, inside the `RestaurantsApiService` interface, define a `suspend` function
    called `getRestaurant()`, which will serve as another `@GET` HTTP method that
    will get the details of one restaurant:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`RestaurantsApiService`接口内部，定义一个名为`getRestaurant()`的`suspend`函数，它将作为另一个`@GET`
    HTTP方法，用于获取一个餐厅的详细信息：
- en: '[PRE3]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code we''ve just added to our second HTTP method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们刚刚添加到第二个HTTP方法中的代码：
- en: The HTTP call defined by this method is an async job that takes some time to
    finish, so we've marked the method as a suspending function by adding the `suspend`
    keyword.
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由该方法定义的HTTP调用是一个异步任务，需要一些时间才能完成，因此我们通过添加`suspend`关键字将方法标记为挂起函数。
- en: Inside the `@GET` annotation, we specified not only that we want to access the
    `restaurants.json` JSON content, but this time we also hardcoded the `orderBy`
    query parameter and specified the `r_id` value so that we filter the elements
    by the value of their `r_id` key.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`@GET`注解内部，我们不仅指定了想要访问`restaurants.json` JSON内容，这次我们还硬编码了`orderBy`查询参数并指定了`r_id`值，以便通过它们的`r_id`键的值来过滤元素。
- en: 'This method receives one essential parameter – `id: Int` that represents the
    unique ID of the restaurant corresponding to the `r_id` field in the database.
    To tell Retrofit that this method parameter is a query parameter in the required
    HTTP call, we''ve annotated it with the `@Query` annotation and passed the `"equalTo"`
    value.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '此方法接收一个基本参数 – `id: Int`，它代表与数据库中`r_id`字段对应的餐厅的唯一ID。为了告诉Retrofit此方法参数是所需HTTP调用中的查询参数，我们用`@Query`注解了它，并传递了`"equalTo"`值。'
- en: 'Yet our HTTP call defined by our `getRestaurant()` method is missing something
    crucial: the response type. We''ve set `Unit` as the response type, but we need
    to receive a proper response object. To see what to expect, let''s have a closer
    look at the response we received earlier on inside our browser:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们由`getRestaurant()`方法定义的HTTP调用缺少一个关键的部分：响应类型。我们已经将`Unit`设置为响应类型，但我们需要接收一个合适的响应对象。为了了解我们期望的内容，让我们更仔细地查看我们在浏览器中之前收到的响应：
- en: '![Figure 5.4 – The JSON response structure of the restaurant object'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 –餐厅对象的JSON响应结构'
- en: '](img/B17788_05_4.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_05_4.jpg)'
- en: Figure 5.4 – The JSON response structure of the restaurant object
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.4 –餐厅对象的JSON响应结构'
- en: If we look at these fields, `is_shutdown`, `r_description`, `r_id`, and `r_title`,
    we can easily identify the response JSON object as the same JSON object that we
    receive in the existing HTTP request that gets all the restaurants.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看这些字段，`is_shutdown`、`r_description`、`r_id`和`r_title`，我们可以很容易地识别出响应JSON对象与我们在现有HTTP请求中接收到的所有餐厅的JSON对象相同。
- en: And since we've mapped such a JSON object in the past to our `Restaurant` data
    class using the `@Serialized` annotations, we could very well say our new `getRestaurant()`
    HTTP call will receive a simple `Restaurant` object as a response.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们过去已经使用`@Serialized`注解将这样的JSON对象映射到我们的`Restaurant`数据类中，所以我们可以说我们的新`getRestaurant()`
    HTTP调用将接收一个简单的`Restaurant`对象作为响应。
- en: We wouldn't be far from the truth, yet this response wouldn't be fully correct.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会离真理太远，但这个响应不会完全正确。
- en: 'If we look closer at the previous JSON response, we notice that the restaurant
    JSON object is a value object that corresponds to a `String` key with the value
    of `2`:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更仔细地查看之前的JSON响应，我们会注意到餐厅JSON对象是一个值对象，对应于一个值为`2`的`String`键：
- en: '![Figure 5.5 –Identifying the key field for the restaurant object'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 –识别餐厅对象的键字段'
- en: '](img/B17788_05_5.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_05_5.jpg](img/B17788_05_5.jpg)'
- en: Figure 5.5 –Identifying the key field for the restaurant object
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.5 –识别餐厅对象的键字段'
- en: This key corresponds to an internal index generated by Firebase that represents
    the order number in which the corresponding restaurant was added to the database.
    This response structure isn't typical for most REST API responses, yet Firebase
    has this quirk of wrapping your JSON object in a key that is unknown at compile
    time.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这个键对应于Firebase生成的内部索引，它表示相应餐厅被添加到数据库中的顺序号。这种响应结构对于大多数REST API响应来说并不典型，但Firebase有一个怪癖，即在编译时未知的关键字中包装你的JSON对象。
- en: 'To get around this, inside the `RestaurantsApiService` interface, update the
    `getRestaurant()` method to return a `Map` object with an unknown `String` key
    and a `Restaurant` data type as the value:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，在`RestaurantsApiService`接口内部，更新`getRestaurant()`方法以返回一个包含未知`String`键和`Restaurant`数据类型值的`Map`对象：
- en: '[PRE4]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Great work! We have our app ready to execute a second network request that obtains
    the details about a specific restaurant, so it's time to call this request.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！我们的应用程序已经准备好执行第二个网络请求，以获取特定餐厅的详细信息，所以现在是调用这个请求的时候了。
- en: Getting the contents of a specific restaurant
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取特定餐厅的内容
- en: Now that we know how to obtain the details about a specific restaurant, it's
    time to execute our newly defined network request.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何获取特定餐厅的详细信息，现在是时候执行我们新定义的网络请求了。
- en: 'Our existing `RestaurantsScreen` composable delegates the responsibility of
    requesting the list of restaurants that must be displayed to a `ViewModel` class,
    so let''s create another `ViewModel` so that our second screen can do the same:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现有的`RestaurantsScreen`可组合委托将请求显示必须显示的餐厅列表的责任委托给一个`ViewModel`类，因此让我们创建另一个`ViewModel`，以便我们的第二个屏幕也能做到同样的事情：
- en: 'Create a new file by left-clicking the application package, selecting `RestaurantDetailsViewModel`
    as the name and select **File** as the type. Inside the newly created file, add
    the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过左键单击应用程序包，将`RestaurantDetailsViewModel`作为名称，并选择**文件**作为类型来创建一个新文件。在新建的文件中，添加以下代码：
- en: '[PRE5]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the preceding snippet, we've created a `ViewModel` class where we instantiated
    a Retrofit client of type `RestaurantsApiService`, just like we did in the `RestaurantsViewModel`
    class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们创建了一个`ViewModel`类，在其中实例化了一个`RestaurantsApiService`类型的Retrofit客户端，就像我们在`RestaurantsViewModel`类中所做的那样。
- en: The block of code that initializes a Retrofit client is indeed duplicated in
    both our `ViewModel` classes, but don't worry because you will be able to fix
    this during [*Chapter 9*](B17788_09_ePub.xhtml#_idTextAnchor293), *Implementing
    Dependency Injection with Jetpack Hilt*.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化Retrofit客户端的代码确实在我们两个`ViewModel`类中都重复了，但不用担心，因为您将在[*第9章*](B17788_09_ePub.xhtml#_idTextAnchor293)中修复它，*使用Jetpack
    Hilt实现依赖注入*。
- en: Note
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember to pass your Firebase database URL to the `baseUrl()` method. This
    URL should be identical to the one used in the `RestaurantsViewModel` class and
    should correspond to your Firebase Realtime Database project.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将您的Firebase数据库URL传递给`baseUrl()`方法。这个URL应该与`RestaurantsViewModel`类中使用的URL相同，并且应该对应于您的Firebase实时数据库项目。
- en: 'Inside the newly created `ViewModel`, create a `getRemoteRestaurant()` method
    that receives an `id` parameter and takes care of executing the network request
    to get the details of a specific restaurant:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新建的`ViewModel`中，创建一个`getRemoteRestaurant()`方法，该方法接收一个`id`参数，并负责执行网络请求以获取特定餐厅的详细信息：
- en: '[PRE6]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Let''s break down what happens inside the `getRemoteRestaurant()` method:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解`getRemoteRestaurant()`方法内部发生的事情：
- en: It receives an `id` parameter corresponding to the restaurant whose details
    we need and returns the specific `Restaurant` object.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它接收一个`id`参数，对应于我们需要详细信息的餐厅，并返回特定的`Restaurant`对象。
- en: It is marked by the `suspend` keyword since the job of executing a network request
    is a suspending work that shouldn't block the main thread.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于执行网络请求的工作是会阻塞主线程的挂起工作，因此该方法被标记为`suspend`关键字。
- en: It is wrapped in a `withContext()` block that specifies the `Dispatchers.IO`
    dispatcher since the suspending work should be run on the specialized IO thread.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它被包裹在一个指定了`Dispatchers.IO`调度器的`withContext()`块中，因为挂起工作应该在专门的IO线程上运行。
- en: It executes the network request to obtain the details of a restaurant by calling
    the `getRestaurant()` suspending function on `restInterface` while passing `id`
    of the specific restaurant.
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过在`restInterface`上调用`getRestaurant()`挂起函数并传递特定餐厅的`id`来执行网络请求以获取餐厅的详细信息。
- en: Finally, it obtains `Map<String, Restaurant>` from the REST API. To unwrap this
    and obtain the restaurant, we call the `values()` function of `Map` and get the
    first `Restaurant` object with the `.first()` extension function.
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，它从REST API获取`Map<String, Restaurant>`。为了解包并获取餐厅，我们调用`Map`的`values()`函数，并使用`.first()`扩展函数获取第一个`Restaurant`对象。
- en: 'Note:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：
- en: The `first()` extension function is called on the `Collection<Restaurant>` object
    returned by the `values()` function of `Map`. With this extension function, we
    are obtaining the first element, that is, the `Restaurant` object we're interested
    in. However, the `first()` extension function can throw a `NoSuchElementException`
    if for some reason we query for a non-existent restaurant. In production, you
    should cover this case as well by catching such an exception.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Map` 的 `values()` 函数返回的 `Collection<Restaurant>` 对象上调用 `first()` 扩展函数。使用这个扩展函数，我们正在获取第一个元素，即我们感兴趣的
    `Restaurant` 对象。然而，如果由于某种原因查询了一个不存在的餐厅，`first()` 扩展函数可能会抛出 `NoSuchElementException`。在生产环境中，你也应该通过捕获此类异常来处理这种情况。
- en: 'Since `RestaurantDetailsViewModel` will hold the state of the restaurant details
    screen, add a `MutableState` object that will hold a `Restaurant` object and initialize
    it with a `null` value until we finish executing the network request that retrieves
    it:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `RestaurantDetailsViewModel` 将持有餐厅详情屏幕的状态，添加一个 `MutableState` 对象来持有 `Restaurant`
    对象，并用 `null` 值初始化它，直到我们完成检索它的网络请求：
- en: '[PRE7]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `init` block of `RestaurantDetailsViewModel`, below the instantiation
    of the Retrofit client, launch a coroutine with the help of the `viewModelScope`
    builder:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantDetailsViewModel` 的 `init` 块中，在 Retrofit 客户端实例化之后，使用 `viewModelScope`
    构建器启动一个协程：
- en: '[PRE8]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We needed to launch a coroutine because the job of getting a `Restaurant` object
    from our remote Firebase API would have blocked the main thread. We''ve used the
    built-in `viewModelScope` coroutine builder to make sure that the launched coroutine
    will live as long as the `RestaurantDetailsViewModel` instance does. Inside the
    coroutine, we did the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要启动一个协程，因为从我们的远程 Firebase API 获取 `Restaurant` 对象的任务可能会阻塞主线程。我们使用了内置的 `viewModelScope`
    协程构建器来确保启动的协程将像 `RestaurantDetailsViewModel` 实例一样长时间存在。在协程内部，我们做了以下操作：
- en: We first called the suspending `getRemoteRestaurants()` function and passed
    a hardcoded value of `2` as the `id` of the restaurant. At this time, `RestaurantsViewModel`
    has no idea what's the `id` of the restaurant that it's looking for – we will
    fix this soon when we perform the navigation.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先调用了挂起函数 `getRemoteRestaurants()` 并将硬编码的值 `2` 作为餐厅的 `id` 传递。此时，`RestaurantsViewModel`
    还不知道它正在寻找的餐厅的 `id` 是什么——我们将在执行导航时很快解决这个问题。
- en: We stored the obtained `Restaurant` inside the `restaurant` variable and passed
    it to the `state` variable of the `RestaurantDetailsViewModel` class so that the
    UI will be recomposed with the freshly received restaurant content.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将获取到的 `Restaurant` 存储在 `restaurant` 变量中，并将其传递给 `RestaurantDetailsViewModel`
    类的 `state` 变量，以便 UI 将使用新接收到的餐厅内容重新组合。
- en: We've executed the network request to obtain the details about a restaurant
    and prepared the state so that a Compose-based screen can display its contents.
    Let's build the new screen up next.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已执行网络请求以获取有关餐厅的详细信息，并准备了状态，以便基于 Compose 的屏幕可以显示其内容。接下来，让我们构建新的屏幕。
- en: Building the restaurant details screen
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建“餐厅详情”屏幕
- en: 'We need to create a new composable screen that will display the details about
    a specific restaurant:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个新的可组合屏幕，用于显示特定餐厅的详细信息：
- en: 'Create a new file inside the application package called `RestaurantDetailsScreen`
    and create the `RestaurantDetailsScreen` composable:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用程序包内创建一个名为 `RestaurantDetailsScreen` 的新文件，并创建一个 `RestaurantDetailsScreen`
    可组合组件：
- en: '[PRE9]'
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Inside of it, we've instantiated its corresponding `ViewModel` and accessed
    the `State` object, just like we previously did in the `RestaurantsScreen` composable.
    The `State` object holds the `Restaurant` object, which we're storing inside the
    `item` variable. If `item` is not `null`, we will display the details about the
    restaurant by passing a composable hierarchy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在其中，我们实例化了其对应的 `ViewModel` 并访问了 `State` 对象，就像我们在之前的 `RestaurantsScreen` 可组合组件中所做的那样。`State`
    对象持有 `Restaurant` 对象，我们将其存储在 `item` 变量中。如果 `item` 不是 `null`，我们将通过传递一个可组合层次结构来显示有关餐厅的详细信息。
- en: Since we plan to reuse some composable functions from the first screen, head
    back inside the `RestaurantsScreen.kt` file and mark the `RestaurantIcon` and
    `RestaurantDetails` composables as public for use by removing their `private`
    keywords.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们计划重用第一个屏幕中的一些可组合函数，请返回 `RestaurantsScreen.kt` 文件，并将 `RestaurantIcon` 和 `RestaurantDetails`
    可组合组件标记为公共，以便通过移除它们的 `private` 关键字来使用。
- en: 'Add a new parameter to the `RestaurantDetails` composable called `horizontalAlignment`
    and pass it to the column''s `horizontalAlignment` parameter:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向`RestaurantDetails`可组合组件添加一个名为`horizontalAlignment`的新参数，并将其传递给列的`horizontalAlignment`参数：
- en: '[PRE10]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By doing so, we can control how the `Column` children are horizontally aligned
    so we can change this behavior in the new screen. Since we want `Column` to position
    its children horizontally to the left by default (so that its effect in the `RestaurantsScreen`
    composable won't differ), we passed `Alignment.Start` as the default value.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以控制`Column`子项的水平对齐方式，以便我们可以在新屏幕中更改此行为。由于我们希望`Column`默认将其子项水平向左对齐（这样在`RestaurantsScreen`可组合组件中的效果不会不同），因此我们将`Alignment.Start`作为默认值传递。
- en: 'Inside the `RestaurantDetailsScreen` composable, add a `Column` instance that
    contains `RestaurantIcon`, `RestaurantDetails`, and `Text` composables, all positioned
    vertically and centered horizontally:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantDetailsScreen`可组合组件内，添加一个包含`RestaurantIcon`、`RestaurantDetails`和`Text`可组合组件的`Column`实例，所有这些组件都垂直排列并水平居中：
- en: '[PRE11]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: To prove how simple it is to reuse composables, we've passed the same `RestaurantIcon`
    and `RestaurantDetails` composables used in the first screen to our `Column`.
    We've configured them with different `Modifier` objects and additionally passed
    `Alignment.centerHorizontally` to the `RestaurantDetails` composable's new alignment
    parameter added previously.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明重用可组合组件有多简单，我们将第一个屏幕中使用的相同`RestaurantIcon`和`RestaurantDetails`可组合组件传递给了我们的`Column`。我们使用不同的`Modifier`对象配置了它们，并且还向之前添加的新对齐参数`RestaurantDetails`可组合组件传递了`Alignment.centerHorizontally`。
- en: 'To test that everything works fine, and our new screen renders the details
    of the hardcoded restaurant with an `id` value of `2`, navigate back to `MainActivity`
    and inside the `setContent` method, replace the `RestaurantsScreen` composable
    with `RestaurantDetailsScreen`:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了测试一切是否正常工作，并且我们的新屏幕能够渲染具有`id`值为`2`的硬编码餐厅的详细信息，导航回`MainActivity`并在`setContent`方法内，将`RestaurantsScreen`可组合组件替换为`RestaurantDetailsScreen`：
- en: '[PRE12]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Run the application and we get the following screenshot:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序，我们得到以下截图：
- en: '![Figure 5.6 – Displaying the RestaurantDetailsScreen() composable'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.6 – 显示 RestaurantDetailsScreen() 可组合组件'
- en: '](img/B17788_05_6.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_05_6.jpg]'
- en: Figure 5.6 – Displaying the RestaurantDetailsScreen() composable
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 显示 RestaurantDetailsScreen() 可组合组件
- en: Awesome! We have now created our second screen, the restaurant details screen.
    We can now start thinking about the navigation between our two screens.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在已经创建了第二个屏幕，即餐厅详情屏幕。我们现在可以开始考虑两个屏幕之间的导航。
- en: Implementing navigation with Jetpack Navigation
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Jetpack 导航实现导航
- en: Navigation within apps represents those interactions that allow the user to
    navigate back and forth between several screens.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序内的导航表示那些允许用户在几个屏幕之间导航来回的交互。
- en: 'In our Restaurants application, we now have two screens, and we want to navigate
    from the first one to the second one. In the first screen, we display a list of
    restaurants and when the users press on one restaurant item from the list, we
    want to take them to the second screen, the details screen:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的餐厅应用程序中，我们现在有两个屏幕，我们想要从第一个屏幕导航到第二个屏幕。在第一个屏幕中，我们显示餐厅列表，当用户按下列表中的某个餐厅项时，我们希望将他们带到第二个屏幕，即详情屏幕：
- en: '![Figure 5.7 – Navigation from list screen to details screen'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 从列表屏幕导航到详情屏幕'
- en: '](img/B17788_05_7.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B17788_05_7.jpg]'
- en: Figure 5.7 – Navigation from list screen to details screen
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.7 – 从列表屏幕导航到详情屏幕'
- en: Basically, we want to perform a simple navigation action from the `RestaurantsScreen`
    composable to the `RestaurantDetailsScreen` composable. To achieve a simple navigation
    action, we need to implement a navigation library that will not only allow us
    to transition from the first screen to the second screen but should also allow
    us to return to the previous screen with the press of the **Back** button.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们想要执行一个简单的导航操作，从`RestaurantsScreen`可组合组件导航到`RestaurantDetailsScreen`可组合组件。为了实现简单的导航操作，我们需要实现一个导航库，这个库不仅允许我们从第一个屏幕切换到第二个屏幕，而且还应该允许我们通过按下**返回**按钮返回上一个屏幕。
- en: 'As we already know, the Jetpack Navigation component comes to our rescue as
    it will help us implement such a behavior! Let''s start with the following steps:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，Jetpack 导航组件会帮助我们解决问题，因为它将帮助我们实现这种行为！让我们从以下步骤开始：
- en: 'Inside the `build.gradle` file in the app module, add the dependency for the
    Navigation component with Compose inside the dependencies block:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在应用模块中的`build.gradle`文件内，在依赖项块内添加对包含 Compose 的导航组件的依赖项：
- en: '[PRE13]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: After updating the `build.gradle` file, make sure to sync your project with
    its Gradle files. You can do that by pressing on the **File** menu option and
    then by selecting **Sync Project with Gradle Files**.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新 `build.gradle` 文件后，请确保将项目与其 Gradle 文件同步。您可以通过点击 **文件** 菜单选项，然后选择 **与 Gradle
    文件同步项目** 来完成此操作。
- en: 'Inside the `MainActivity` class, create a new empty composable function called
    `RestaurantsApp()`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainActivity` 类中，创建一个新的空组合函数，名为 `RestaurantsApp()`：
- en: '[PRE14]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This composable function will act as the parent composable function of our Restaurants
    application. Here, all the screens of the app will be defined.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此组合函数将作为我们餐厅应用程序的父组合函数。在这里，将定义应用程序的所有屏幕。
- en: 'Inside the `onCreate()` method, replace the `RestaurantsDetailsScreen()` composable
    that is passed to the `setContent` method with the `RestaurantsApp()` composable:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `onCreate()` 方法中，将传递给 `setContent` 方法的 `RestaurantsDetailsScreen()` 组合可替换为
    `RestaurantsApp()` 组合可：
- en: '[PRE15]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Inside the `RestaurantsApp()` composable function, instantiate `NavController`
    via the `rememberNavController()` method:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsApp()` 组合函数内部，通过 `rememberNavController()` 方法实例化 `NavController`：
- en: '[PRE16]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `NavController` object handles the navigation between composable screens
    – it operates on the back stack of composable destinations. This means that across
    recompositions, it must keep the current state of the navigation stack. For that
    to happen, it must be a stateful object – that's why we used the `rememberNavController`
    syntax, which is similar to the `remember` block we've been using when defining
    `State` objects.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '`NavController` 对象处理组合屏幕之间的导航 – 它在组合目的地的回退栈上操作。这意味着在重新组合之间，它必须保持导航栈的当前状态。为了实现这一点，它必须是一个有状态的对象
    – 这就是为什么我们使用了 `rememberNavController` 语法，这与我们在定义 `State` 对象时使用的 `remember` 块类似。'
- en: Next up, we need to create a `NavHost` container composable that will display
    the composable destinations. Every time a navigation action between composables
    is done, the content within `NavHost` is recomposed automatically.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个将显示组合目的地的 `NavHost` 容器组合可。每次在组合可之间完成导航操作时，`NavHost` 内的内容会自动重新组合。
- en: 'Add a `NavHost` composable and pass both, the `NavController` instance created
    previously and an empty `String` to the `startDestination` parameter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个 `NavHost` 组合可，并将之前创建的 `NavController` 实例以及一个空的 `String` 传递给 `startDestination`
    参数：
- en: '[PRE17]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Among other parameters, `NavHost` specifies three mandatory parameters:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他参数中，`NavHost` 指定了三个强制参数：
- en: 'A `navController: NavHostController` object that is associated with a single
    `NavHost` composable. `NavHost` links `NavController` with a navigation graph
    that defines the possible destinations of the application. In our case, we''ve
    passed the `navController` variable to this parameter.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个与单个 `NavHost` 组合可关联的 `navController: NavHostController` 对象。`NavHost` 将 `NavController`
    与定义应用程序可能目的地的导航图连接起来。在我们的例子中，我们将 `navController` 变量传递给了这个参数。'
- en: 'A `startDestination: String` object that defines the entry-point `String`,
    which defines the path to a specific destination (composable screen). Every destination
    should have a unique route. In our case, since we haven''t defined any routes,
    we''ve passed an empty `String` to `startDestination`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一个 `startDestination: String` 对象，它定义了入口点 `String`，它定义了到达特定目的地（组合屏幕）的路径。每个目的地都应该有一个唯一的路由。在我们的例子中，因为我们还没有定义任何路由，所以我们已将一个空的
    `String` 传递给 `startDestination`。'
- en: 'The `builder: NavGraphBuilder.() -> Unit` trailing lambda parameter, which
    uses the lambda syntax from the Navigation Kotlin DSL (just like `LazyColumn`
    or `LazyRow` did with their own DSL) to construct a navigation graph. In here,
    we should define routes and set corresponding composables, yet so far we''ve set
    an empty body `{ }` function to the trailing lambda parameter.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`builder: NavGraphBuilder.() -> Unit` 后置 lambda 参数，它使用了来自导航 Kotlin DSL 的 lambda
    语法（就像 `LazyColumn` 或 `LazyRow` 使用它们自己的 DSL 一样）来构建导航图。在这里，我们应该定义路由并设置相应的组合可，但到目前为止，我们已将一个空的
    `{ }` 函数设置到后置 lambda 参数中。'
- en: To build the navigation graph, we must make use of the `builder` parameter and
    instead of passing only an empty function, inside of it, we need to start adding
    routes that specify composable destinations.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要构建导航图，我们必须使用 `builder` 参数，而不是只传递一个空函数，在它内部，我们需要开始添加指定组合目的地的路由。
- en: 'To do that, make use of the DSL function called `composable()` where you can
    provide a route string to the `route` parameter and a composable function corresponding
    to the desired destination to the trailing lambda `content` parameter:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请使用名为 `composable()` 的 DSL 函数，您可以为 `route` 参数提供一个路由字符串，并将对应于所需目的地的可组合函数传递给尾随的
    lambda `content` 参数：
- en: '[PRE18]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Through the `composable()` DSL function, we've created a route with the value
    of `"restaurants"` that navigates to the `RestaurantsScreen()` composable.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 `composable()` DSL 函数，我们创建了一个导航到 `RestaurantsScreen()` 可组合组件的 `"restaurants"`
    值的路由。
- en: Additionally, we've passed the same route to the `startDestination` parameter
    of `NavHost`, thereby making our `RestaurantsScreen()` composable the unique entry
    point of our application.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将相同的路由传递给 `NavHost` 的 `startDestination` 参数，从而使我们的 `RestaurantsScreen()`
    可组合组件成为我们应用程序的唯一入口点。
- en: 'By calling the `composable()` DSL function again inside the navigation graph
    builder, add another route that points to the `RestaurantDetailsScreen()` destination
    and that derives from the `"restaurants"` route by appending the `{restaurant_id}`
    argument placeholder:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在导航图构建器内部再次调用 `composable()` DSL 函数，添加另一个指向 `RestaurantDetailsScreen()` 目标的路由，并且通过附加
    `{restaurant_id}` 参数占位符从 `"restaurants"` 路由派生：
- en: '[PRE19]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We want to navigate from the `"restaurants"` route to this new route that points
    to the `RestaurantDetailsSreen()` composable, so the `{restaurant_id}` placeholder
    will take the `id` value of the restaurant to which we are trying to navigate.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望从 `"restaurants"` 路由导航到指向 `RestaurantDetailsSreen()` 可组合组件的新路由，因此 `{restaurant_id}`
    占位符将取我们试图导航的餐厅的 `id` 值。
- en: In practice, this route branches off the `"restaurants"` route, and while being
    structured similarly to a URL (because of the `"/"` element that delimitates a
    new path), we can say that this route can have multiple values, depending on `id`
    of the restaurant we're looking to navigate to. For example, this route can have
    values at runtime such as `"restaurants/0"` or `"restaurants/2"`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，此路由从 `"restaurants"` 路由分支出来，并且虽然其结构类似于 URL（因为 `""/` 元素分隔了新的路径），但我们可以这样说，此路由可以具有多个值，具体取决于我们想要导航到的餐厅的
    `id`。例如，此路由在运行时可以具有 `"restaurants/0"` 或 `"restaurants/2"` 等值。
- en: Inside the navigation graph, we've defined the routes and their corresponding
    destinations, but we haven't really performed the actual navigation between the
    two screens. To do that, we first need to have a trigger or callback that notifies
    us when the user pressed on a restaurant item within the restaurant list, so we
    can navigate to the restaurant details screen.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导航图中，我们已经定义了路由及其对应的目标，但我们还没有真正执行两个屏幕之间的实际导航。为此，我们首先需要一个触发器或回调来通知我们用户在餐厅列表中点击了餐厅项，这样我们就可以导航到餐厅详情屏幕。
- en: 'Inside the `RestaurantsScreen.kt` file, modify the `RestaurantItem` composable
    to expose an `onItemClick` callback function that provides us with `id` of the
    restaurant that is clicked, and also call it when the entire restaurant''s `Card`
    is pressed on:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreen.kt` 文件内部，修改 `RestaurantItem` 可组合组件以公开一个提供被点击餐厅 `id` 的 `onItemClick`
    回调函数，并在整个餐厅的 `Card` 被按下时调用它：
- en: '[PRE20]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To prevent confusion, refactor the `RestaurantItem` composable by renaming
    the old `onClick` parameter to a more suggestive name, such as `onFavoriteClick`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免混淆，通过将旧的 `onClick` 参数重命名为更具说明性的名称，如 `onFavoriteClick` 来重构 `RestaurantItem`
    可组合组件：
- en: '[PRE21]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Inside the `RestaurantsScreen()` composable, add a similar `onItemClick` callback
    function as a parameter, and call it when the `onItemClick` callback comes from
    the `RestaurantItem` composable:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RestaurantsScreen()` 可组合组件内部，添加一个类似的 `onItemClick` 回调函数作为参数，并在 `onItemClick`
    回调来自 `RestaurantItem` 可组合组件时调用它：
- en: '[PRE22]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Additionally, we've changed the `onClick` parameter name of the `RestaurantItem`
    composable call to match its signature of `onFavoriteClick`.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们将 `RestaurantItem` 可组合调用中的 `onClick` 参数名称更改为与其签名更匹配的名称，例如 `onFavoriteClick`。
- en: What we are essentially doing is propagating events through callbacks from child
    composables to parent composables.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们本质上是在通过从子可组合组件到父可组合组件的回调来传播事件。
- en: 'Inside `NavHost`, update the `RestaurantsScreen()` composable destination to
    listen for navigation callbacks and then, inside the callback, trigger the navigation
    between composables by calling the `navigate()` method, which expects `route`
    as a parameter:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `NavHost` 内部，更新 `RestaurantsScreen()` 可组合目标以监听导航回调，然后在回调内部，通过调用 `navigate()`
    方法来触发可组合组件之间的导航，该方法期望 `route` 作为参数：
- en: '[PRE23]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Inside the new trailing lambda function of `RestaurantsScreen`, we now receive
    the `id` value of the restaurant we need to navigate to. To trigger the navigation,
    we called the `navigate()` method, and to its `route` parameter, we passed the
    `"restaurants/$id"` string to match the route of our other composable destination,
    `RestaurantDetailsScreen()`.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在`RestaurantsScreen`的新尾随lambda函数中，我们现在接收需要导航到的餐厅的`id`值。为了触发导航，我们调用了`navigate()`方法，并将其`route`参数传递为`"restaurants/$id"`字符串，以匹配我们其他可组合目标`RestaurantDetailsScreen()`的路线。
- en: Try running the application and verify the following.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试运行应用程序并验证以下内容。
- en: 'When the app is launched, the `RestaurantsScreen()` composable is composed
    and displayed. In other words, you are at the `"restaurants"` route because we''ve
    set this route as `startDestination` for our navigation graph. On the navigation
    back stack, this destination will be added:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，`RestaurantsScreen()`可组合组件被组合并显示。换句话说，你处于`"restaurants"`路由，因为我们已经将此路由设置为导航图的`startDestination`。在导航回退栈中，此目标将被添加：
- en: '![Figure 5.8 – Back stack with the start destination'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.8 – 包含起始目标的回退栈'
- en: '](img/B17788_05_8.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_05_8.jpg)'
- en: Figure 5.8 – Back stack with the start destination
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.8 – 包含起始目标的回退栈
- en: 'When pressing on one of the restaurants on the list, navigation is triggered
    and you arrive at the `RestaurantDetailsScreen()` composable destination. On top
    of the navigation back stack this destination will be added:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击列表中的某个餐厅时，会触发导航，并到达`RestaurantDetailsScreen()`可组合目标。在导航回退栈顶部，此目标将被添加：
- en: '![Figure 5.9 – Back stack after navigating to another destination'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.9 – 导航到另一个目标后的回退栈'
- en: '](img/B17788_05_9.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_05_9.jpg)'
- en: Figure 5.9 – Back stack after navigating to another destination
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.9 – 导航到另一个目标后的回退栈
- en: 'When pressing the system''s `RestaurantDetailsScreen()` destination, you are
    sent back to the existing destination in the back stack, `RestaurantsScreen()`.
    This means that on the back stack, the top destination is popped, and only the
    root destination remains:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当点击系统的`RestaurantDetailsScreen()`目标时，你将被发送回回退栈中的现有目标，即`RestaurantsScreen()`。这意味着在回退栈中，顶部目标将被弹出，只剩下根目标：
- en: '![](img/B17788_05_10.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17788_05_10.jpg)'
- en: Figure 5.10 – Back stack after returning to start destination
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.10 – 返回起始目标后的回退栈
- en: 'The navigation works, but if you noticed, it always points to the same restaurant.
    This happens because of two reasons:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 导航是有效的，但如果你注意到了，它总是指向同一个餐厅。这有两个原因：
- en: While we defined the `{restaurant_id}` placeholder argument in the route that
    points to `RestaurantDetailsScreen()`, we didn't define this argument inside the
    DSL `composable()` function as a navigation argument, so the Navigation component
    has no idea how to send it to the route's composable destination.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然我们在指向`RestaurantDetailsScreen()`的路线中定义了`{restaurant_id}`占位符参数，但我们没有在`composable()`函数内部将其定义为导航参数，因此导航组件不知道如何将其发送到路线的可组合目标。
- en: Inside `RestaurantDetailsViewModel`, we've hardcoded the id of the restaurant
    to the value of `2`.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`RestaurantDetailsViewModel`中，我们硬编码了餐厅的id为值`2`。
- en: We want the user to see details about the restaurant that is pressed on, so
    let's fix these issues and pass the ID of the restaurant dynamically.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望用户能够看到被点击的餐厅的详细信息，所以让我们修复这些问题，并动态地传递餐厅的ID。
- en: 'For the `RestaurantDetailsScreen()` destination, apart from `route`, add the
    `arguments` parameter that expects a list of `NamedNavArgument` objects, and pass
    such an argument using the `navArgument` function:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于`RestaurantDetailsScreen()`目标，除了`route`之外，还需要添加一个期望接收`NamedNavArgument`对象列表的`arguments`参数，并使用`navArgument`函数传递这样的参数：
- en: '[PRE24]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This argument specifies the same `"restaurant_id"` key that we've added as a
    place holder within `route` and allows the Navigation library to expose this argument
    to the destination composable. Additionally, the `navArgument` function exposes
    `NavArgumentBuilder`, where we specified the type of the argument to be `IntType`.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 此参数指定了我们在`route`中添加的相同的`"restaurant_id"`键，这允许Navigation库将此参数暴露给目标可组合组件。此外，`navArgument`函数暴露了`NavArgumentBuilder`，我们在其中指定了参数的类型为`IntType`。
- en: 'To obtain the argument''s value inside the `RestaurantDetailsScreen()` destination,
    the `composable()` DSL function exposes a `NavBackStackEntry` object that allows
    us to get the value as follows:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要在`RestaurantDetailsScreen()`目标内部获取参数的值，`composable()` DSL函数暴露了一个`NavBackStackEntry`对象，允许我们按以下方式获取值：
- en: '[PRE25]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Yet our `RestaurantDetailsScreen()` destination doesn't expect the `id` of a
    restaurant, but `RestaurantDetailsViewModel` does, so we will not perform the
    previous changes where we access `navStackEntry`; instead, we will do something
    similar in the `ViewModel` soon enough.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们的 `RestaurantDetailsScreen()` 目标不期望餐厅的 `id`，但 `RestaurantDetailsViewModel`
    需要，所以我们不会执行之前访问 `navStackEntry` 的更改；相反，我们将在 `ViewModel` 中尽快进行类似的操作。
- en: Behind the scenes, the Navigation component saves the navigation arguments stored
    in `NavStackEntry` into `SavedStateHandle`, which our VM exposes. This means that
    we can take advantage of that, and instead of obtaining the ID of the restaurant
    inside the `RestaurantDetailsScreen()` composable, we can directly obtain it in
    `RestaurantDetailsViewModel`.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在幕后，导航组件将存储在 `NavStackEntry` 中的导航参数保存到 `SavedStateHandle` 中，这是我们的 VM 暴露的。这意味着我们可以利用这一点，而不是在
    `RestaurantDetailsScreen()` 可组合函数内部获取餐厅的 ID，我们可以在 `RestaurantDetailsViewModel`
    中直接获取它。
- en: 'First, add the `SavedStateHandle` parameter to the `RestaurantDetailsViewModel`
    constructor, just like we did within `RestaurantsViewModel`:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将 `SavedStateHandle` 参数添加到 `RestaurantDetailsViewModel` 构造函数中，就像我们在 `RestaurantsViewModel`
    中做的那样：
- en: '[PRE26]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Inside of the `init { }` block of `ViewModel`, below the instantiation of the
    Retrofit client, store the ID of the restaurant inside a new `id` variable while
    obtaining it dynamically from the `SavedStateHandle` object, and then pass it
    to the `getRemoteRestaurant()` method call:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModel` 的 `init { }` 块中，在实例化 Retrofit 客户端下方，将餐厅的 ID 存储在一个新的 `id` 变量中，同时从
    `SavedStateHandle` 对象中动态获取它，然后将它传递给 `getRemoteRestaurant()` 方法调用：
- en: '[PRE27]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We've instructed `navArgument` that the argument is of type `Int`, so we've
    obtained it as an `Int` value from `stateHandle` and passed the same `"restaurant_id"`
    key that we've used to define `navArgument`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已指示 `navArgument` 该参数的类型为 `Int`，因此我们从 `stateHandle` 中获取它作为 `Int` 值，并传递了相同的
    `"restaurant_id"` 键，我们曾用它来定义 `navArgument`。
- en: This approach will protect us from system-initiated process death scenarios
    as well. The user could navigate to the `RestaurantDetailsScreen()` destination
    of a restaurant with an `id` value of `2`, and then minimize the app for a while.
    In the meantime, the system could decide to kill the process of the app to free
    up memory, so when the user resumes the app, the system would restore it and provide
    us with a `SavedStateHandle` object that contains the ID of the restaurant with
    the value of `2`.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法还可以保护我们免受系统引起的进程死亡场景。用户可以导航到具有 `id` 值为 `2` 的餐厅的 `RestaurantDetailsScreen()`
    目标，然后暂时最小化应用。在此期间，系统可能会决定杀死应用进程以释放内存，因此当用户恢复应用时，系统会将其恢复，并为我们提供一个包含具有 `2` 值的餐厅
    ID 的 `SavedStateHandle` 对象。
- en: In conclusion, the app would know to obtain the details of the restaurant the
    user initially navigated to, so the application behaves correctly for this edge
    case.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，应用将知道获取用户最初导航到的餐厅的详细信息，因此应用对于这种边缘情况的行为是正确的。
- en: Run the app again and verify that this time when pressing on one restaurant
    item in the `RestaurantsScreen()`start destination, the details about this restaurant
    are displayed in the second destination, `RestaurantDetailsScreen()`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行应用，并验证这次当在 `RestaurantsScreen()` 起始目标中点击一个餐厅项时，该餐厅的详细信息将在第二个目标 `RestaurantDetailsScreen()`
    中显示。
- en: Note
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: We used the Navigation component with destinations that are composable functions.
    Inside these composables, we instantiate `ViewModel` objects. Since these composables
    are in a back stack of destinations, their `ViewModel` objects become scoped to
    the lifetime of the composables. In other words, with the addition of the Navigation
    component, the `ViewModel` objects have the same lifetime as the composable screen
    that they are attached to.
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们使用了具有可组合函数目标的导航组件。在这些可组合函数内部，我们实例化 `ViewModel` 对象。由于这些可组合函数位于目标的后退栈中，它们的 `ViewModel`
    对象的范围限定在可组合函数的生命周期内。换句话说，随着导航组件的添加，`ViewModel` 对象的生命周期与它们附加的可组合屏幕相同。
- en: Perfect! Now our Restaurants app has two screens that you can navigate between
    whenever the user presses on a restaurant from within our list. It's time to explore
    another type of navigation event.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 完美！现在我们的餐厅应用有两个屏幕，用户可以在点击列表中的任何餐厅时在这些屏幕之间导航。是时候探索另一种导航事件了。
- en: Adding support for deep links
  id: totrans-229
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对深度链接的支持
- en: '**Deep links** allow you to redirect users to specific parts of your application
    without having them go through all the intermediary screens. This technique is
    especially useful for marketing campaigns because it can boost user engagement
    while also providing a good user experience.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**深度链接**允许您将用户重定向到应用程序的特定部分，而无需他们通过所有中间屏幕。这种技术对于营销活动特别有用，因为它可以提高用户参与度，同时提供良好的用户体验。'
- en: Deep links are usually incorporated within URI schemes or custom schemes. This
    allows you to configure anything from an image advertisement, text advertisement,
    or even a QR code that when clicked or scanned redirects you to a specific page
    of the app. If your app is configured to know how to handle such schemes, the
    user will be able to open that particular link with your application.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 深度链接通常包含在URI方案或自定义方案中。这允许您配置从图片广告、文本广告，甚至二维码，当点击或扫描时，会将其重定向到应用程序的特定页面。如果您的应用程序配置为知道如何处理此类方案，用户将能够使用您的应用程序打开该特定链接。
- en: 'For example, say that for our Restaurants application, we start a marketing
    campaign where we include some advertisements on the internet that showcase some
    special restaurants. We configure the advertisements to be clickable and to redirect
    to the following link, which contains the ID of the advertised restaurant, such
    as `2`: `https://www.restaurantsapp.details.com/2`.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设对于我们的餐厅应用程序，我们启动一项营销活动，其中在互联网上包含一些展示一些特色餐厅的广告。我们配置广告使其可点击，并重定向到以下链接，其中包含广告餐厅的ID，例如`2`：`https://www.restaurantsapp.details.com/2`。
- en: This URI will not work when loaded into a browser application (because there
    is no such website), yet we can configure our app to know how to interpret it
    as a deep link.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 当将此URI加载到浏览器应用程序中时（因为没有这样的网站），它将无法工作，但我们可以配置我们的应用程序以了解如何将其解释为深度链接。
- en: 'When a user is browsing a search engine and presses on a campaign advertisement
    for one of our restaurants, the app should know how to handle these actions and
    should allow the user to be redirected to our application:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户在搜索引擎中浏览并点击我们餐厅之一的活动广告时，应用程序应知道如何处理这些操作，并允许用户被重定向到我们的应用程序：
- en: '![Figure 5.11 – Inefficient redirect to our Restaurants app'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '![图5.11 – 不高效的跳转到我们的餐厅应用程序'
- en: '](img/B17788_05_11.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B17788_05_11.jpg)'
- en: Figure 5.11 – Inefficient redirect to our Restaurants app
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.11 – 不高效的跳转到我们的餐厅应用程序
- en: Our application has as the start destination the `RestaurantsScreen()` composable,
    so the user should manually find the restaurant that was initially presented on
    the advertisement, and press on it to navigate to the `RestaurantDetailsScreen()`
    destination.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序以`RestaurantsScreen()`可组合组件作为起始目的地，因此用户应手动找到最初在广告中展示的餐厅，并点击它以导航到`RestaurantDetailsScreen()`目的地。
- en: This is obviously a bad practice because we don't want the user to perform manual
    navigations within our app to get to the advertised restaurant. Imagine if other
    apps required the user to navigate not through one or two screens as per our application,
    but more screens – this would result in a bad user experience and the campaign
    would be ineffective.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是一种不良做法，因为我们不希望用户在我们的应用程序中进行手动导航以到达广告中的餐厅。想象一下，如果其他应用程序要求用户按照我们的应用程序那样通过一个或两个屏幕，而是更多屏幕进行导航——这将导致糟糕的用户体验，并且活动将无效。
- en: 'Deep links, however, allow you to automatically redirect the user to your desired
    destination:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，深度链接允许您自动将用户重定向到您希望的目的地：
- en: '![](img/B17788_05_12.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B17788_05_12.jpg)'
- en: Figure 5.12 – Direct deep link to the screen of interest
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.12 – 直接深度链接到感兴趣的屏幕
- en: By redirecting the user directly to the screen of interest, we improve the user
    experience and expect our advertising campaign to perform better.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 通过直接将用户重定向到感兴趣的屏幕，我们改善了用户体验，并期望我们的广告活动表现更好。
- en: 'Let''s implement such a deep link in our Restaurants application with the help
    of the Navigation component library:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们借助导航组件库在我们的餐厅应用程序中实现这样的深度链接：
- en: 'Inside the `RestaurantDetailsScreen()` DSL `composable()` function, apart from
    `route` and `arguments`, add another parameter called `deepLinks` that expects
    a list of `NavDeepLink` objects, and pass such an argument using the `navDeepLink`
    function:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RestaurantDetailsScreen()` DSL `composable()`函数内部，除了`route`和`arguments`之外，添加另一个名为`deepLinks`的参数，它期望一个`NavDeepLink`对象的列表，并使用`navDeepLink`函数传递这样的参数：
- en: '[PRE28]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `navDeepLink` function expects in turn a `NavDeepLinkDslBuilder` extension
    function that exposes its own DSL. We've set the `uriPattern` DSL variable to
    expect our custom URI of `www.restaurantsapp.details.com` but also added our placeholder
    `"restaurant_id"` argument that will allow the Navigation component to parse and
    provide us with the ID of the restaurant from the deep link.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`navDeepLink` 函数依次期望一个 `NavDeepLinkDslBuilder` 扩展函数，该函数暴露了自己的 DSL。我们已将 `uriPattern`
    DSL 变量设置为期望我们的自定义 URI `www.restaurantsapp.details.com`，同时添加了占位符 `"restaurant_id"`
    参数，这将允许导航组件解析并提供我们从深度链接中获取的餐厅 ID。'
- en: Right now, our application knows how to handle a deep link, but only internally.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的应用程序知道如何处理深度链接，但仅限于内部。
- en: 'To make our deep link available externally, inside the `AndroidManifest.xml`
    file, add the following `<intent-filter>` element within our `MainActivity`''s
    `<activity>` element:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使我们的深度链接对外可用，在 `AndroidManifest.xml` 文件中，在 `MainActivity` 的 `<activity>` 元素内添加以下
    `<intent-filter>` 元素：
- en: '[PRE29]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Let''s break up what we''ve just added inside the new `<intent-filter>` element:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下新 `<intent-filter>` 元素中我们刚刚添加的内容：
- en: 'A `<data>` element that specifies the following:'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个指定以下内容的 `<data>` 元素：
- en: The `host` parameter as the deep link URI that we've set previously in our navigation
    graph. This is the URI that our ads should link to.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`host` 参数作为我们在导航图中之前设置的深度链接 URI。这是我们广告应该链接到的 URI。'
- en: The `scheme` parameter of the deep link as `https`. Every `<data>` element should
    define a scheme so that the URI is recognized.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 深度链接的 `scheme` 参数为 `https`。每个 `<data>` 元素都应该定义一个方案，以便识别 URI。
- en: A `<category>` element of `BROWSABLE` that is required for the intent filter
    to be accessed from web browser apps.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `BROWSABLE` 类别的 `<category>` 元素，这是必需的，以便从网络浏览器应用中访问意图过滤器。
- en: A `<category>` element of `DEFAULT` that makes the app intercept the deep link's
    intents implicitly. Without it, the app could be started only if the deep link
    intent specified the application component name.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个 `DEFAULT` 类别的 `<category>` 元素，使应用隐式拦截深度链接的意图。如果没有它，应用只能在深度链接意图指定了应用程序组件名称时启动。
- en: 'To test the deep link, we need to simulate a deep link action. Let''s imagine
    that we want to test a deep link that points to a restaurant that has the ID with
    the value of `2`. The deep link would look like this: `https://www.restaurantsapp.details.com/2`.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试深度链接，我们需要模拟一个深度链接动作。让我们假设我们想测试一个指向 ID 值为 `2` 的餐厅的深度链接。深度链接看起来像这样：`https://www.restaurantsapp.details.com/2`。
- en: 'Since we don''t have any advertisements that refer to our deep link, we have
    two options:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们没有任何指向我们的深度链接的广告，我们有两种选择：
- en: Create a QR code with this URL and then scan it with our device.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用此 URL 创建一个二维码，然后用我们的设备扫描它。
- en: Launch an intent from the command line that simulates the deep link.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从命令行启动一个意图来模拟深度链接。
- en: Let's go with the second option.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们选择第二种方案。
- en: Build the project and run the application on an emulator or physical device.
    This step is needed so that the installed application knows how to respond to
    our deep link.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目并在模拟器或物理设备上运行应用程序。这一步是必要的，以便安装的应用程序知道如何响应我们的深度链接。
- en: Close the app or minimize it, but make sure you leave your emulator or device
    connected to Android Studio.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 关闭应用或将其最小化，但请确保您的模拟器或设备连接到 Android Studio。
- en: 'Open the terminal inside Android Studio, paste the following command and enter
    it:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Android Studio 中的终端，粘贴以下命令并输入：
- en: '[PRE30]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The emulator/device that you have connected to Android Studio should now prompt
    a disambiguation dialog asking you what app you''d like to open the deep link
    with:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 连接到 Android Studio 的模拟器/设备现在应该会提示一个歧义对话框，询问您想用哪个应用打开深度链接：
- en: '![Figure 5.13 – Disambiguation dialog displayed when launching a deep link'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 5.13 – 启动深度链接时显示的歧义对话框](img/B17788_05_13.jpg)'
- en: '](img/B17788_05_13.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B17788_05_13.jpg)'
- en: Figure 5.13 – Disambiguation dialog displayed when launching a deep link
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.13 – 启动深度链接时显示的歧义对话框
- en: Our application is one of those apps and this means that it has been correctly
    configured to intercept our deep links.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序是那些应用程序之一，这意味着它已经被正确配置为拦截我们的深度链接。
- en: Select `RestaurantDetailsScreen()` destination and show the details of the desired
    restaurant.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `RestaurantDetailsScreen()` 目标并显示所需餐厅的详细信息。
- en: Optionally, you can try pressing the system's `RestaurantsScreen` composable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 可选地，您可以尝试按系统中的 `RestaurantsScreen` 组合式。
- en: Now that we've also successfully added deep link functionality to our Restaurant
    application, it's time to wrap this chapter up.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功地将深度链接功能添加到我们的餐厅应用中，是时候结束这一章了。
- en: Summary
  id: totrans-274
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned how to navigate between screens within our Restaurants
    application. We did that easily with the help of the Jetpack Navigation component
    library.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了如何在餐厅应用内部导航屏幕。我们借助 Jetpack Navigation 组件库轻松地做到了这一点。
- en: We started off by learning the basics of the Jetpack Navigation library and
    understood how easy our life becomes when having to handle navigation back stacks.
    Afterward, we created a new screen, implemented the Navigation library, and explored
    how seamless it is to add navigation between composables. Finally, we added support
    for deep links and made sure to test such a deep link within our app.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从学习 Jetpack Navigation 库的基础知识开始，并了解到在处理导航回退栈时生活变得多么简单。之后，我们创建了一个新的屏幕，实现了 Navigation
    库，并探索了在可组合组件之间添加导航的流畅性。最后，我们添加了对深度链接的支持，并确保在我们的应用中测试了这样的深度链接。
- en: Next up, it's time to focus on improving the quality and architecture of our
    Restaurants application.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，是时候专注于提升我们餐厅应用的质量和架构了。
