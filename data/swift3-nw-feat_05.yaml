- en: Chapter 5. Function and Operator Changes – New Ways to Get Things Done
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 函数和运算符变化 – 以新的方式完成任务
- en: If you want to write useful code in Swift, or in any programming language, you
    have to, at the very least, create functions and use operators. In this chapter,
    we will examine what's changed in function declaration and usage and how those
    changes translate into better Swift code. We will also explain operator changes
    and highlight several that have been removed from the language.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在 Swift 中编写有用的代码，或者在任何编程语言中，你至少需要创建函数和使用运算符。在本章中，我们将探讨函数声明和使用方面的变化，以及这些变化如何转化为更好的
    Swift 代码。我们还将解释运算符的变化，并突出一些已被从语言中移除的运算符。
- en: Continuing the theme from the last chapter, I will provide you the Swift Evolution
    proposal numbers. Let's get started!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 继续上一章的主题，我将提供 Swift 进化提案编号。让我们开始吧！
- en: Function declaration changes
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数声明变化
- en: Swift provides a very flexible set of rules for defining functions. You can
    create functions with no parameters, with parameters, or even with argument labels.
    Every Swift function has a type, parameters (or no parameters), and a return type.
    For Swift 3, the language has been tweaked to make things more consistent and
    less complex.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 提供了一套非常灵活的规则来定义函数。你可以创建没有参数、有参数，甚至有参数标签的函数。每个 Swift 函数都有一个类型、参数（或没有参数）以及返回类型。对于
    Swift 3，语言经过调整以使事物更加一致和简单。
- en: Consistent parameter labeling [SE-0046]
  id: totrans-5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 一致的参数命名 [SE-0046]
- en: Parameter labels are used for naming each argument in the function definition.
    In Swift 2.2 and earlier, function parameters could be defined with a local and
    an external label. The local argument label is required as this label is used
    to refer to the parameter in the body of the function. The external argument label,
    when provided, was used in the actual function call. You can think of the external
    label as your *shiny descriptive name at the call site* to provide good insight
    into what the argument represents. The internal label is, as the name implies,
    the name your function uses in the implementation of your logic. Since no one
    sees that local parameter, you could make it shorter to save some keystrokes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 参数命名用于在函数定义中为每个参数命名。在 Swift 2.2 及更早版本中，函数参数可以同时定义本地和外部标签。本地参数标签是必需的，因为这个标签用于在函数体中引用参数。当提供外部参数标签时，它用于实际的函数调用中。你可以将外部标签视为在调用位置的*闪亮的描述性名称*，以提供对参数表示的深入了解。内部标签，正如其名称所暗示的，是函数在逻辑实现中使用的名称。由于没有人会看到这个本地参数，你可以将其缩短以节省一些按键。
- en: Here's where things get interesting. By default, Swift 2.2 drops your external
    name when your function is called. Further adding to the confusion, Swift uses
    your local name as the external name for any remaining parameters, when external
    names are not present. The truly odd thing is that Swift only does this for functions.
    When you create a class, structure, or enumeration initializer (a special type
    of function to set initial values), Swift will create an external name for every
    parameter.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这里事情变得有趣了。默认情况下，Swift 2.2 在调用函数时会丢弃你的外部名称。进一步增加混乱的是，当外部名称不存在时，Swift 使用你的本地名称作为任何剩余参数的外部名称。真正奇怪的是，Swift
    只对函数这样做。当你创建一个类、结构体或枚举初始化器（一种设置初始值的特殊类型的函数）时，Swift 将为每个参数创建一个外部名称。
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Swift Enumerations can be defined using a raw-value type. When you create a
    Swift enum using a raw-value, you will either get an initialized enum or nil.
    You can read more about Swift enums at [https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145](https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 枚举可以使用原始值类型定义。当你使用原始值创建 Swift 枚举时，你将得到一个初始化的枚举或 nil。你可以在 [https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145](https://developer.apple.com/library/prerelease/content/documentation/Swift/Conceptual/Swift_Programming_Language/Enumerations.html#//apple_ref/doc/uid/TP40014097-CH12-ID145)
    上了解更多关于 Swift 枚举的信息。
- en: The main reason for dropping the first argument name seems to be for historical
    correctness with Objective-C. Objective-C developers were instructed to incorporate
    the first parameter name into the function name. This same behavior was adopted
    by Swift and may have been a side effect of the initial translation of Objective-C
    libraries to Swift via the migrator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 删除第一个参数名称的主要原因似乎是为了与 Objective-C 保持历史正确性。Objective-C 开发者被指示将第一个参数名称纳入函数名称中。Swift
    也采用了这种行为，这可能是通过 migrator 将 Objective-C 库最初翻译成 Swift 的副作用。
- en: Swift is an evolving language and is getting better with each new version. To
    stay consistent with the new API naming guidelines, Swift 3 now defaults to using
    the local names as the external names for all arguments including the first one.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 是一种不断发展的语言，并且随着每个新版本的发布而变得越来越好。为了与新的 API 命名指南保持一致，Swift 3 现在默认使用局部名称作为所有参数的外部名称，包括第一个参数。
- en: 'In Swift 2.2:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2.2 中：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In Swift 3:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-16
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Last thought — if you prefer to not use argument labels in your function calls,
    you can suppress them using an underscore as the external name. This works for
    any of the argument positions.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最后的想法——如果您在函数调用中不喜欢使用参数标签，您可以使用下划线作为外部名称来抑制它们。这对于任何参数位置都适用。
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at the following link [https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md](https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md)
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读提案 [https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md](https://github.com/apple/swift-evolution/blob/master/proposals/0046-first-label.md)
- en: Removing currying func syntax in declaration [SE0002]
  id: totrans-21
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除声明中的柯里化函数语法 [SE0002]
- en: 'In Swift 2, you had the ability to create curried functions; which were rather
    confusing and seem to have little value in Swift. Much of the developer confusion
    in using them centers on whether the curried arguments are part of the main argument
    list or if the curried arguments signify the beginning of the argument list for
    a new function. Let''s consider the following example that uses curried arguments:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，您有创建柯里化函数的能力；这些函数相当令人困惑，在 Swift 中似乎也没有多少价值。许多开发者在使用它们时产生的困惑主要集中在柯里化参数是否是主参数列表的一部分，或者柯里化参数是否表示新函数参数列表的开始。让我们考虑以下使用柯里化参数的示例：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'It''s extremely confusing to tell if the `(siny: Int)-> Float` is part of the
    argument. The Swift team ultimately decided that we just don''t need this in the
    language. Therefore, Swift 3 removes this syntax and suggests that you re-write
    your function to return a closure instead:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '判断 `(siny: Int)-> Float` 是否是参数的一部分非常令人困惑。Swift 团队最终决定我们根本不需要这种语法。因此，Swift 3
    删除了这种语法，并建议您将函数重写为返回闭包：'
- en: '[PRE4]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In our revised example, we define our function to return a closure. We then
    assign the result of this initial call to a variable named `intermediateFunctionReturn`.
    Last, we call the `intermediateFunctionReturn` closure, passing our Int argument,
    to get our final result.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修订的示例中，我们定义了一个返回闭包的函数。然后，我们将这个初始调用的结果赋值给名为 `intermediateFunctionReturn` 的变量。最后，我们调用
    `intermediateFunctionReturn` 闭包，传递我们的 Int 参数，以获取最终结果。
- en: Note
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md](https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下链接中阅读提案 [https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md](https://github.com/apple/swift-evolution/blob/master/proposals/0002-remove-currying.md)
- en: Warning on Unused Results by Default [SE-0047]
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认情况下对未使用结果的警告 [SE-0047]
- en: Attributes are special constructs that you apply to a declaration or type. You
    specify an attribute using the `@` symbol followed by a name and optionally any
    attribute arguments in parentheses.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 属性是应用于声明或类型的特殊构造。您使用 `@` 符号后跟一个名称以及可选的任何属性参数（括号内）来指定属性。
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In Swift 2, the `@warn_unused_result` attribute is applied to a function or
    method to let the compiler know that it should provide a warning to the user if
    the attributed method or function is called without using the result. The `@warn_unused_result`
    attribute also allows you to provide either a message or `mutable_variant` attribute
    argument. The `mutable_variant` option is used when you want to let the developer
    know the name of the mutating method that accomplishes the same thing. The intent
    of using the attribute is to give guidance to the developer using your method,
    that the returned value is important and should be used.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，`@warn_unused_result` 属性应用于函数或方法，以让编译器知道如果未使用结果就调用属性或方法，则应向用户发出警告。`@warn_unused_result`
    属性还允许你提供消息或 `mutable_variant` 属性参数。当你想让开发者知道完成相同任务的 mutating 方法的名称时，使用 `mutable_variant`
    选项。使用该属性的目的在于为使用你的方法的开发者提供指导，即返回值很重要，应该使用。
- en: For example, Swift 2 provides a `sort()` method and a `sortInPlace()` method
    (mutating) on the Foundation collection classes. If you were to call `sort()`(non-mutating)
    on an array but not use the result, then the compiler would warn you that you
    might really need the `sortInPlace()` method, which mutates the array and doesn't
    return anything. You can see an example usage of the `@warn_unused_result` below.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Swift 2 为 Foundation 集合类提供了 `sort()` 方法和一个 `sortInPlace()` 方法（mutating）。如果你对一个数组调用
    `sort()`（非 mutating）但没有使用结果，编译器会警告你可能真的需要 `sortInPlace()` 方法，该方法会修改数组且不返回任何内容。下面你可以看到
    `@warn_unused_result` 的一个示例用法。
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The main issue that developers have with `@warn_unused_result` is that it is
    only helpful if you apply the attribute to all of the relevant places (i.e. it
    is a proactive strategy on your part). If you forget to add the attribute, then
    no warnings will be sent. In Swift 3, the logic is reversed and you now get a
    warning on unused results by default. If you want to explicitly let the compiler
    know that the return value can safely be ignored, you can use the `@discardableResult`
    attribute. Here is an example that demonstrates its usage.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者对 `@warn_unused_result` 的主要问题是，它只有在将属性应用于所有相关位置时才有所帮助（即这是你主动采取的策略）。如果你忘记添加属性，则不会发出警告。在
    Swift 3 中，逻辑相反，现在默认情况下你会收到关于未使用结果的警告。如果你想明确地让编译器知道返回值可以安全地忽略，你可以使用 `@discardableResult`
    属性。下面是一个演示其用法的示例。
- en: '[PRE7]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In Swift 3, the mutating method `sortInPlace()` became `sort()` and the non-mutating
    version changed from `sort()` to `sorted()`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中，mutating 方法 `sortInPlace()` 变成了 `sort()`，而非 mutating 版本则从 `sort()`
    变成了 `sorted()`。
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md](https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md)
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md](https://github.com/apple/swift-evolution/blob/master/proposals/0047-nonvoid-warn.md)
    上阅读更多关于该提案的信息。
- en: Removing var from function parameter lists [SE-0003]
  id: totrans-41
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从函数参数列表中移除 var [SE-0003]
- en: 'Using var in a function parameter list was valid in Swift 2\. Since parameter
    types are immutable by default, developers attempted to use var in the parameter
    list to pass a mutable parameter to their function implementation. While you could
    do this in Swift, it actually proved to be a fairly useless tactic. Let me explain.
    Yes, you can use the var keyword to pass a mutable variant to your function body.
    However, any changes you make to the variable are not propagated back to the original
    type. Therefore, you are using a mutable copy that is scoped to the function''s
    body. Let''s examine how this works in practice with an example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中，在函数参数列表中使用 var 是有效的。由于参数类型默认是不可变的，开发者尝试在参数列表中使用 var 来向函数实现传递一个可变参数。虽然你可以在
    Swift 中这样做，但实际上这证明是一个相当无用的策略。让我来解释一下。是的，你可以使用 var 关键字将一个可变变体传递到函数体中。然而，你对变量所做的任何更改都不会传播回原始类型。因此，你使用的是一个作用域限于函数体的可变副本。让我们通过一个示例来查看这在实践中是如何工作的：
- en: '[PRE8]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'You could have, just as easily, accomplished the same objective by assigning
    the passed in parameter to a local copy within the function body. See below for
    the equivalent function definition:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 你同样可以轻松地通过在函数体内部将传入的参数赋值给一个局部副本来实现相同的目标。下面是等效的函数定义：
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, many developers were confusing var parameters with those marked as
    inout. Either version will give a mutable local copy but only the inout variant
    will propagate changes back to function caller. Given the overall confusion, var
    as a parameter modifier has been removed in Swift 3\. In the following example,
    the `howManyTimes` variable is updated with its value propagated back to the function
    caller because it is marked as an inout parameter:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，许多开发者会将 `var` 参数与标记为 `inout` 的参数混淆。两种版本都会提供一个可变的局部副本，但只有 `inout` 变体才会将更改传播回函数调用者。鉴于整体上的混淆，Swift
    3 中已经移除了 `var` 作为参数修饰符。在以下示例中，`howManyTimes` 变量通过将其值传播回函数调用者而更新，因为它被标记为 `inout`
    参数：
- en: '[PRE10]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-48
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md](https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md](https://github.com/apple/swift-evolution/blob/master/proposals/0003-remove-var-parameters.md)
- en: Removing ++ and -- operators [SE-0004]
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除 `++` 和 `--` 运算符 [SE-0004]
- en: The increment (`++`) and decrement (`--`) operators were added to Swift because
    they existed in C. In addition, many developers coming to Swift are used to seeing
    them in the other languages. Let's examine how these operators work and then we
    can cover the gotchas.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 增量（`++`）和减少（`--`）运算符被添加到 Swift 中，因为它们在 C 语言中存在。此外，许多转向 Swift 的开发者习惯于在其他语言中看到它们。让我们来检查这些运算符是如何工作的，然后我们可以讨论一些需要注意的问题。
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Disadvantages /Gotchas:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 不利之处/需要注意的问题：
- en: It's easy to get the pre and post part of the increment/decrement operator wrong,
    which gives you an incorrect output
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 很容易弄错增量/减量运算符的前置和后置部分，这会导致你得到错误的结果
- en: The syntax is shorthand for `+=` or `-=`, which doesn't save you that many keystrokes
    over `+= 1` or `-= 1`
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语法是 `+=` 或 `-=` 的简写，这并没有节省你多少按键，与 `+= 1` 或 `-= 1` 相比
- en: The operators are largely used in C style `for…loops`, where the return value
    is ignored. Since we have `for…loops` loops, ranges, maps, and enumerate/iterate
    functions, we don't need these operators
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些运算符主要在 C 风格的 `for…in` 循环中使用，其中返回值被忽略。由于我们已经有 `for…in` 循环、范围、映射以及 `enumerate/iterate`
    函数，我们不需要这些运算符
- en: You can only use these operators with a small set of types (such as integers
    and floating point scalars)
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你只能使用这些运算符与一组有限的类型（例如整数和浮点标量）一起使用
- en: If you are learning your first programming language, these operators increase
    the amount of stuff you have to learn without providing meaningful value you couldn't
    get through other features that Swift offers
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你正在学习你的第一门编程语言，这些运算符会增加你需要学习的内容量，而没有提供通过 Swift 提供的其他功能无法获得的有意义的价值
- en: Essentially, the Swift team felt the disadvantages of keeping these operators
    outweighed the advantages and opted to remove them in Swift 3.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，Swift 团队认为保留这些运算符的缺点超过了优点，因此决定在 Swift 3 中移除它们。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read the proposal here: [https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md](https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里阅读提案：[https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md](https://github.com/apple/swift-evolution/blob/master/proposals/0004-remove-pre-post-inc-decrement.md)
- en: Removing C-style for loops [SE-0007]
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 移除 C 风格的 `for` 循环 [SE-0007]
- en: Similar to the increment and decrement operators we just discussed, the C-style
    `for…in` loop also seems to have been added to Swift for its C language ancestry.
    Swift offers several *Swifty* conventions for iterating and looping that are better
    options than the C-style loop. In fact, C-style loops really aren't used all that
    much. Once a developer starts to master Swift concepts, the developer generally
    chooses not to use C-style loops. When considering the iteration of a collection,
    `for…in` loops are considerably harder to implement than `for…in` statements.
    Finally, if C-style `for` loops did not already exist in Swift; no one would miss
    them or beg for their inclusion into the language. With Swift 3, C-style for loops
    are officially eliminated from the language.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们刚才讨论的增量/减量运算符类似，C 风格的 `for…in` 循环似乎也是为了其 C 语言血统而被添加到 Swift 中的。Swift 提供了几个比
    C 风格循环更好的 *Swifty* 迭代和循环约定。事实上，C 风格的循环并不常用。一旦开发者开始精通 Swift 概念，他们通常会选择不使用 C 风格的循环。在考虑集合的迭代时，`for…in`
    循环比 `for…in` 语句更难实现。最后，如果 C 风格的 `for` 循环在 Swift 中原本就不存在，没有人会想念它们或请求将它们包含到语言中。在
    Swift 3 中，C 风格的 `for` 循环正式从语言中移除。
- en: Note
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md)
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md](https://github.com/apple/swift-evolution/blob/master/proposals/0007-remove-c-style-for-loops.md)
    阅读更多关于该提案的信息。
- en: Removing implicit tuple splat from functions [SE-0029]
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从函数中移除隐式元组展开 [SE-0029]
- en: In previous versions of Swift, function calls allowed developers to pass an
    argument list in the form of a tuple, commonly referred to as a *tuple splat*.
    A *tuple splat* could be defined in one place and then passed to a function as
    one object, removing the need to pass individual arguments to a function. Let's
    take a look at an example to make this concept clearer.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 的早期版本中，函数调用允许开发者以元组的形式传递参数列表，这通常被称为 *元组展开*。一个 *元组展开* 可以在某个地方定义，然后作为一个对象传递给函数，从而无需将单个参数传递给函数。让我们通过一个例子来更清楚地说明这个概念。
- en: '[PRE12]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'In our example, we create the `fooTastic()` function to accept two String array
    arguments. We then created a tuple that encapsulates the arguments we want to
    pass to our function. Last, we call `fooTastic()` passing in our foo tuple. This
    works, but here are some disadvantages to consider:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们创建了 `fooTastic()` 函数来接受两个 String 数组参数。然后我们创建了一个封装我们想要传递给函数的参数的元组。最后，我们调用
    `fooTastic()` 并传递我们的 foo 元组。这可以工作，但这里有一些需要考虑的缺点：
- en: 'Our `foo` tuple has to mirror the way the arguments are represented in the
    function: meaning we have to drop the members parameter label. We must include
    the instruments label in our tuple or the compiler will complain when we pass
    the tuple as an argument.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的 `foo` 元组必须与函数中参数表示的方式相匹配：这意味着我们必须去掉成员参数标签。我们必须在我们的元组中包含乐器标签，否则当我们将元组作为参数传递时，编译器会报错。
- en: Passing just a tuple to the function makes our method appear to have overloads,
    which is confusing to anyone tasked with maintaining this code.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只传递一个元组给函数会使我们的方法看起来有重载，这对负责维护此代码的人来说很困惑。
- en: The current implement of tuple splats is inconsistent and buggy in terms of
    implementation.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组展开的当前实现不一致且存在错误。
- en: All things considered, we just don't need this added complexity in the language
    and hence this feature has been removed from Swift 3.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到所有这些因素，我们根本不需要在语言中添加这种额外的复杂性，因此这个特性已被从 Swift 3 中移除。
- en: Note
  id: totrans-74
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md](https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md)
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md](https://github.com/apple/swift-evolution/blob/master/proposals/0029-remove-implicit-tuple-splat.md)
    阅读更多关于该提案的信息。
- en: Adjusting inout declarations for type decoration [SE-0031]
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 调整 `inout` 声明以进行类型装饰 [SE-0031]
- en: This is a minor change for Swift 3\. The *inout* keyword has been moved to the
    right of the colon (:) and next to the type in function definitions. Nothing has
    changed about how `inout` variables behave in code. You are still giving the parameter
    decorated with `inout `the ability to mutate the value within the body of the
    function. The change is meant to move the decoration name closer to the type it
    is actually modifying. Since we are modifying the type and not the label, it makes
    more sense for the keyword to be next to the type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对 Swift 3 的一个微小改动。`inout` 关键字已经被移动到冒号（:）的右边，并在函数定义中紧邻类型。关于 `inout` 变量在代码中的行为没有任何改变。你仍然在函数体内赋予带有
    `inout` 装饰的参数修改值的能力。这个改动是为了让装饰名称更靠近它实际修改的类型。由于我们修改的是类型而不是标签，所以将关键字放在类型旁边更有意义。
- en: 'In Swift 2:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In Swift 3:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Note
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md](https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md](https://github.com/apple/swift-evolution/blob/master/proposals/0031-adjusting-inout-declarations.md)
    阅读该提案。
- en: Replacing equal signs with colons for attribute arguments [SE-0040]
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将属性参数中的等号替换为冒号 [SE-0040]
- en: 'As we discussed in *[SE-0047]*, attributes are special constructs that you
    apply to a declaration or type. You specify an attribute using the `@` symbol
    followed by a name and optionally any attribute arguments in parentheses:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在 *[SE-0047]* 中讨论的那样，属性是应用于声明或类型的特殊构造。你使用 `@` 符号后跟一个名称来指定属性，并可选地使用括号中的任何属性参数：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Unlike regular functions and parameter labels, you use `=` instead of a colon
    to separate the argument name from its value. This is inconsistent with our standard
    mode of operation in the rest of Swift. Therefore, in Swift 3, attribute arguments
    will receive the same treatment as other Swift arguments, using the colon over
    and equal sign.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与常规函数和参数标签不同，你使用 `=` 而不是冒号来分隔参数名和它的值。这与 Swift 中其他标准操作模式不一致。因此，在 Swift 3 中，属性参数将与其他
    Swift 参数一样接受相同的处理，使用冒号而不是等于号。
- en: 'In Swift 2:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中：
- en: '[PRE16]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In Swift 3:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3：
- en: '[PRE17]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md](https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md](https://github.com/apple/swift-evolution/blob/master/proposals/0040-attributecolons.md)阅读这个提议。
- en: Standardizing function type argument syntax to require parentheses [SE-0066]
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准化函数类型参数语法以要求使用括号 [SE-0066]
- en: 'Functions are defined in Swift to use parentheses to enclose their argument
    lists. The purpose is to make it clear where the function declaration begins and
    ends. However, Swift 2 allowed you to call a function, under certain conditions,
    without using the parentheses. Let''s look at an example to make this concept
    clearer. In the following example, we define functions using parentheses and their
    equivalents by dropping the parentheses:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中定义函数时，使用括号来包围它们的参数列表。其目的是使函数声明开始和结束的位置清晰。然而，Swift 2 允许你在某些条件下调用函数而不使用括号。让我们通过一个例子来使这个概念更清晰。在下面的例子中，我们使用括号和它们的等效方式（省略括号）来定义函数：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'This can also be written without parentheses as:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这也可以写成不带括号的形式：
- en: '[PRE19]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Granted, the second form is a bit shorter since it omits the parentheses. However,
    the trade-off introduces code that is not consistent with the way the function
    types are defined in the rest of the language. Frankly, you don't get any real
    value or expressive components by omitting the parentheses. Crafting function
    types this way is only syntactic sugar with no substance. In Swift 3, you will
    no longer be able to use this shortcut form when defining function types.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，第二种形式由于省略了括号而略短。然而，这种权衡引入了与语言中其他函数类型定义方式不一致的代码。坦白说，省略括号并没有带来任何真正的价值或表达性组件。以这种方式构建函数类型只是语法糖，没有实质内容。在
    Swift 3 中，你将无法在定义函数类型时使用这种快捷形式。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read more about the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md](https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md](https://github.com/apple/swift-evolution/blob/master/proposals/0066-standardize-function-type-syntax.md)了解更多关于这个提议的信息。
- en: Enforcing the order of defaulted parameters [SE-0060]
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 强制默认参数的顺序 [SE-0060]
- en: Order matters when you call a function in Swift, but there is one exception
    to this rule for functions that contain parameters with default arguments. Under
    this edge case, you can call this type of function using only a portion of the
    argument names. Let's look at some examples of how you can call a function that
    contains default parameters.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 中调用函数时，顺序很重要，但对于包含默认参数的函数来说，有一个例外。在这种情况下，你可以只使用部分参数名称来调用这类函数。让我们看看一些如何调用包含默认参数的函数的例子。
- en: 'In Swift 2:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 2 中：
- en: '[PRE20]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The first way to call the `shifty()` function is to use all of the default
    parameters, meaning we don''t pass anything at the call site. This is valid in
    Swift 2 and is generally expected behavior. See below for an example using just
    the function with all default parameter values:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `shifty()` 函数的第一种方式是使用所有默认参数，这意味着在调用位置不传递任何内容。这在 Swift 2 中是有效的，并且通常是预期的行为。下面是一个仅使用具有所有默认参数值的函数的例子：
- en: '[PRE21]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Another way to call the `shifty()` would be to omit the arguments we don''t
    care about and only pass in the ones we do. We could pass in just one argument
    such as arg2 or arg3 and our function would continue to work. In the following
    example, we demonstrate calling our shifty function while omitting some of the
    parameters:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种调用 `shifty()` 的方式是省略我们不关心的参数，只传递我们关心的参数。我们可以只传递一个参数，比如 arg2 或 arg3，而我们的函数仍然可以正常工作。在下面的例子中，我们展示了在省略一些参数的情况下调用我们的
    shifty 函数：
- en: '[PRE22]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, we could call the function with multiple arguments. See below for
    example usage of the shifty function with multiple arguments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以使用多个参数来调用函数。以下是一个使用多个参数调用 shifty 函数的示例用法：
- en: '[PRE23]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Allowing this behavior is actually a bit confusing to developers and goes against
    the strict ordering that is enforced throughout the rest of the language. Swift
    3 removes this behavior and forces you to maintain the parameter ordering when
    using default parameters. Let's see how our `shifty()` function works now in Swift
    3.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 允许这种行为实际上会让开发者感到有些困惑，并且与语言其他部分强制执行的严格顺序相矛盾。Swift 3 移除了这种行为，并强制您在使用默认参数时保持参数顺序。让我们看看我们的
    `shifty()` 函数在 Swift 3 中的工作方式。
- en: 'In Swift 3:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Swift 3 中：
- en: '[PRE24]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'There is no change to how we call a function using all defaulted arguments:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 使用所有默认参数调用函数的方式没有变化：
- en: '[PRE25]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: When we call a function with just one argument, we have to use the argument
    label for our parameter. The other difference is that we can not just call the
    arguments in any order we choose. We can omit defaulted parameters but we can
    not call them in any order we choose. Let's examine some of the ways we can call
    our `shifty()` function in Swift 3.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们用一个参数调用函数时，我们必须使用参数标签。另一个区别是我们不能随意选择调用参数的顺序。我们可以省略默认参数，但不能随意调用它们。让我们看看在 Swift
    3 中我们可以如何调用我们的 `shifty()` 函数。
- en: '[PRE26]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: If you think about this for a while, I bet you could see why the Swift team
    made this change. We sacrifice a shorter syntax for enhanced readability.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细思考一下，我敢打赌您能看出 Swift 团队做出这一改变的原因。我们牺牲了更短的语法以增强可读性。
- en: Note
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md](https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md](https://github.com/apple/swift-evolution/blob/master/proposals/0060-defaulted-parameter-order.md)阅读该提案
- en: Making optional requirements Objective-C only [SE-0070]
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将可选要求仅限于 Objective-C [SE-0070]
- en: Objective-C protocols have a feature that allows the developer to mark some
    of the behavior as optional. While this makes sense for Objective-C, it would
    not make sense as a Swift feature. In Swift, the protocol author could provide
    a default implementation using protocol extensions and protocol inheritance. Similarly,
    with protocol inheritance, the author could add the optional methods to a separate
    protocol that a developer could adopt if the optional behavior is of interest
    and not make it a requirement for all users of the protocol. The main takeaway
    is that you have better options in Swift for tackling optional protocol requirements
    and, therefore, adding Objective-C optional features on protocols to Swift is
    not necessary.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Objective-C 协议有一个功能，允许开发者标记一些行为作为可选的。虽然这对于 Objective-C 来说是合理的，但它不会作为 Swift 功能有意义。在
    Swift 中，协议作者可以使用协议扩展和协议继承提供默认实现。同样，使用协议继承，作者可以将可选方法添加到单独的协议中，开发者可以选择采用该协议以实现可选行为，而不是将其作为所有协议用户的必需要求。主要收获是，在
    Swift 中处理可选协议要求有更好的选择，因此，在协议上添加 Objective-C 可选功能对 Swift 来说不是必要的。
- en: Now that we know why the Swift team opted not to include this as a Swift feature,
    let's discuss how to handle Objective-C optional in Swift 3\. Basically, we use
    the `@objc` attribute to decorate the parts of the protocol we want to distinguish
    as an Objective-C only requirement. We also add the optional keyword to each of
    the function signatures. For the most part, you won't have to change anything
    on your end in Swift. You also don't have to modify your Objective-C code. The
    migrator handles all of the work for you.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道为什么 Swift 团队选择不将此作为 Swift 功能包含在内，让我们讨论如何在 Swift 3 中处理 Objective-C 可选参数。基本上，我们使用
    `@objc` 属性来装饰我们想要区分的作为 Objective-C 仅需要求的协议部分。我们还为每个函数签名添加了可选关键字。在大多数情况下，您不需要在
    Swift 中进行任何更改。您也不必修改您的 Objective-C 代码。迁移器会为您处理所有工作。
- en: 'In Objective-C:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Objective-C 中：
- en: '[PRE27]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Our code snippets above show the Objective-C protocol (with optional methods)
    and the Swift version once it is passed through the migrator.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们上面的代码片段显示了 Objective-C 协议（带有可选方法）以及通过迁移器转换后的 Swift 版本。
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can read the proposal at [https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md](https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md](https://github.com/apple/swift-evolution/blob/master/proposals/0070-optional-requirements.md)阅读该提案
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter we covered how functions are created and called. We touched
    on several features that weren't very *Swifty* and have been removed in Swift
    3\. We also explored attributes and attribute arguments, focusing on syntax changes,
    and new additions and subtractions from the language. In the next chapter, we
    will do a deep dive into closures and collections.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了函数的创建和调用方法。我们提到了一些不太**Swift**的特性，这些特性在Swift 3中被移除了。我们还探讨了属性和属性参数，重点关注语法变化，以及语言中的新增和删除功能。在下一章中，我们将深入探讨闭包和集合。
