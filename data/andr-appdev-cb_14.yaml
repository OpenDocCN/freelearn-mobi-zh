- en: Chapter 14. Getting your app ready for the Play Store
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第14章。让你的应用为Play Store做好准备
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The new Android 6.0 Run-Time permission model
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 新的Android 6.0运行时权限模型
- en: How to schedule an alarm
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何安排闹钟
- en: Receive notification of device boot
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收设备启动通知
- en: Using AsyncTask for background work
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用AsyncTask进行后台工作
- en: Adding speech recognition to your app
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将语音识别添加到你的应用中
- en: Push Notification using Google Cloud Messaging
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Google Cloud Messaging进行推送通知
- en: How to add Google sign-in to your app
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何将Google sign-in添加到你的应用
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: As we approach the end of this book, it's time to add the finishing touches
    to your application before releasing it to the Play Store. The recipes in this
    chapter cover the topics that can make a difference between users keeping your
    app or removing it.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们接近本书的结尾，是时候在你将应用发布到Play Store之前，给你的应用添加一些最后的修饰了。本章中的菜谱涵盖了那些可能让用户保留还是删除你的应用的话题。
- en: Our first recipe, *The new Android 6.0 Run-Time permission model*, is certainly
    an important topic, possibly being the primary reason Android went from version
    5.x to version 6! Changes to the Android permission model have been requested
    for some time, so this new model is a welcome change, at least for users.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一道菜谱，*新的Android 6.0运行时权限模型*，无疑是一个重要的话题，可能是Android从5.x版本跃升至6.0版本的主要原因！对Android权限模型的改变已经呼吁了一段时间，所以这个新模型是一个受欢迎的改变，至少对于用户来说是这样。
- en: Next, we'll take a look at using alarms in Android. One of the primary benefits
    of alarms is that the OS is responsible for maintaining the alarm, even when your
    application is not running. Since alarms do not persist after rebooting the device,
    we'll also look at how to detect a device reboot so you can recreate your alarms
    in *Receive notification of device boot*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨在Android中使用闹钟。闹钟的主要好处之一是操作系统负责维护闹钟，即使你的应用没有运行。由于闹钟在设备重启后不会持续存在，我们还将探讨如何检测设备重启，这样你就可以在*接收设备启动通知*中重新创建你的闹钟。
- en: Almost any serious Android application will need a way to perform potentially
    blocking tasks off the main thread. Otherwise, your app runs the risk of being
    perceived as sluggish, or worse, completely nonresponsive. `AsyncTask` was designed
    to make it easier to create a background worker task as we'll demonstrate in the
    *Using the AsyncTask for background work* recipe.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何严肃的Android应用都需要一种方法来在主线程之外执行可能阻塞的任务。否则，你的应用可能会被认为运行缓慢，或者更糟，完全无响应。`AsyncTask`就是为了使创建后台工作任务变得更加容易而设计的，正如我们将在*使用AsyncTask进行后台工作*菜谱中所展示的那样。
- en: If you want your app to benefit from hands-free typing or voice recognition,
    take a look at the *Adding Speech Recognition to your app* recipe in which we'll
    explore the Google Speech API.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望你的应用能够从免提输入或语音识别中受益，请查看*将语音识别添加到你的应用中*菜谱，我们将探讨Google语音API。
- en: Possibly one of the most interesting features for communicating with your users
    is Push Notification or **Google Cloud Messaging** (**GCM**) as Google calls it.
    The *Push Notification using Google Cloud Messaging* recipe will walk you through
    the adding of GCM to your application as well as explain the bigger picture.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 与用户通信的最有趣的功能之一可能是推送通知或**Google Cloud Messaging**（**GCM**），正如谷歌所称呼的。*使用Google
    Cloud Messaging进行推送通知*菜谱将指导你如何将GCM添加到你的应用中，并解释更大的背景。
- en: Finally, we'll end the chapter with a recipe showing how to make your app more
    comfortable and encourage users to log in with the *How to add Google Sign-In
    to your app* recipe
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将以一个菜谱结束本章，展示如何让你的应用更加舒适，并鼓励用户使用*如何将Google Sign-In添加到你的应用*菜谱进行登录。
- en: The new Android 6.0 Run-Time permission model
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 新的Android 6.0运行时权限模型
- en: The old security model was a sore point for many in Android. It's common to
    see reviews commenting on the permissions an app requires. Sometimes, permissions
    were out of the line (like a Flashlight app requiring internet permission), but
    other times, the developer had good reasons to request certain permissions. The
    main problem was that it was an all-or-nothing prospect.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 旧的安全模型是Android中许多人的痛点。经常可以看到评论中提到应用所需的权限。有时，权限超出了界限（比如手电筒应用需要互联网权限），但有时，开发者有很好的理由请求某些权限。主要问题是这是一个全有或全无的选择。
- en: This finally changed with the Android 6 Marshmallow (API 23) release. The new
    permission model still declares permissions in the manifest as before, but users
    have the option of selectively accepting or denying each permission. Users can
    even revoke a previously granted permission.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这最终随着 Android 6 Marshmallow（API 23）的发布而改变。新的权限模型仍然在清单中声明权限，就像之前一样，但用户可以选择性地接受或拒绝每个权限。用户甚至可以撤销之前授予的权限。
- en: Although this is a welcome change for many; however, for a developer, it has
    the potential to break the code that was working before. We've talked about this
    permission change in the previous recipes, as it has far reaching implications.
    This recipe will put it all together to serve as a single point of reference when
    implementing this change in your own apps.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这对许多人来说是一个受欢迎的变革；然而，对于开发者来说，它有可能破坏之前正常工作的代码。我们已经在之前的菜谱中讨论了此权限变更，因为它具有深远的影响。这个菜谱将把所有这些放在一起，以便在您自己的应用中实施此更改时作为一个单独的参考点。
- en: One important point to remember is that this change only affects users of Android
    6.0 (API 23) and above.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 一个需要记住的重要点是，此更改仅影响 Android 6.0（API 23）及以上的用户。
- en: Getting ready
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `RuntimePermission`. Use
    the default **Phone & Tablet** option and select **Empty Activity** when prompted
    for **Activity Type**.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `RuntimePermission`。使用默认的 **Phone & Tablet**
    选项，并在提示 **Activity Type** 时选择 **Empty Activity**。
- en: The sample source code sets the minimum API to 23, but this is not required.
    If your `compileSdkVersion` is API 23 or above, the compiler will flag your code
    for the new security model.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 示例源代码将最小 API 设置为 23，但这不是必需的。如果您的 `compileSdkVersion` 是 API 23 或更高，编译器将标记您的代码以使用新的安全模型。
- en: How to do it...
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'We need to start by adding our required permission to the manifest, then we''ll
    add a button to call our check permission code. Open the Android Manifest and
    follow these steps:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要首先将所需的权限添加到清单中，然后我们将添加一个按钮来调用检查权限的代码。打开 Android 清单并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with this button:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的 `TextView` 替换为以下按钮：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Open `MainActivity.java` and add the following constant to the class:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并将以下常量添加到类中：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Add this method for permission check:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法以进行权限检查：
- en: '[PRE3]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add this method to show the explanation dialog:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法以显示解释对话框：
- en: '[PRE4]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Add this method to request the permission:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加此方法以请求权限：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the method for button click:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮点击的方法：
- en: '[PRE6]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Override `onRequestPermissionsResult()` as follows:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下重写 `onRequestPermissionsResult()`：
- en: '[PRE7]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, you're ready to run the application on a device or emulator.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，您已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'Using the new runtime permission model involves the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用新的运行时权限模型涉及以下步骤：
- en: Check to see whether you have the desired permissions.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查您是否具有所需的权限。
- en: If not, check whether we should display the rationale (meaning, the request
    was previously denied).
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果不是，检查是否应该显示理由（即，请求之前已被拒绝）。
- en: Request the permission; only the OS can display the permission request.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求权限；只有操作系统可以显示权限请求。
- en: Handle the request response.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理请求响应。
- en: 'Here are the corresponding methods:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是相应的函数：
- en: '`ContextCompat.checkSelfPermission`'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ContextCompat.checkSelfPermission`'
- en: '`ActivityCompat.requestPermissions`'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityCompat.requestPermissions`'
- en: '`ActivityCompat.shouldShowRequestPermissionRationale`'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ActivityCompat.shouldShowRequestPermissionRationale`'
- en: '`onRequestPermissionsResult`'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onRequestPermissionsResult`'
- en: Note
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Even though you are requesting permissions at runtime, the desired permission
    must be listed in the Android Manifest. If the permission is not specified, the
    OS will automatically deny the request.
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管您是在运行时请求权限，但所需的权限必须在 Android 清单中列出。如果没有指定权限，操作系统将自动拒绝请求。
- en: There's more...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'You can grant/revoke permissions through the ADB with the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下方式使用 ADB 授予/撤销权限：
- en: '[PRE8]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Here''s an example to grant the SEND_SMS permission for our test app:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个示例，为我们的测试应用授予发送短信权限：
- en: '[PRE9]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: See also
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Developer Docs: System Permissions** at [https://developer.android.com/guide/topics/security/permissions.html](https://developer.android.com/guide/topics/security/permissions.html)'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：系统权限** 在 [https://developer.android.com/guide/topics/security/permissions.html](https://developer.android.com/guide/topics/security/permissions.html)'
- en: How to schedule an alarm
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何安排闹钟
- en: 'Android provides `AlarmManager` to create and schedule alarms. Alarms offer
    the following features:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: Android 提供了 `AlarmManager` 来创建和安排闹钟。闹钟提供以下功能：
- en: Schedule alarms for a set time or interval
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排特定时间或间隔的警报
- en: Maintained by the OS, not your application, so alarms are triggered even if
    your application is not running, or the device is asleep
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由操作系统维护，而不是您的应用程序，因此即使您的应用程序没有运行或设备处于睡眠状态，警报也会被触发
- en: Can be used to trigger periodic tasks (such as an hourly news update), even
    if your application is not running
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可以用来触发周期性任务（如每小时新闻更新），即使应用程序没有运行
- en: Your app does not use resources (such as timers or background services), since
    the OS manages the scheduling
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序不使用资源（如计时器或后台服务），因为操作系统管理调度
- en: Alarms are not the best solution if you need a simple delay while your application
    is running, for example, a short delay for a UI event. For short delays, it's
    easier and more efficient to use a Handler, as we've done in several previous
    recipes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在应用程序运行时需要简单的延迟，例如对UI事件的短暂延迟，警报并不是最佳解决方案。对于短暂的延迟，使用处理器（Handler）会更简单、更高效，正如我们在之前的几个菜谱中做的那样。
- en: 'When using alarms, keep these best practices in mind:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用警报时，请记住以下最佳实践：
- en: Use as infrequent alarm timing as possible
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用不频繁的警报时间
- en: Avoid waking up the device
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免唤醒设备
- en: Use as imprecise timing as possible—the more precise the timing, the more resources
    required
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽可能使用不精确的时间——时间越精确，所需的资源就越多
- en: Avoid setting alarm times based on clock time (such as 12:00); add random adjustments
    if possible to avoid congestion on servers (especially important when checking
    for new content, such as weather or news)
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免基于时钟时间设置警报时间（如12:00）；如果可能，添加随机调整以避免服务器（尤其是在检查新内容，如天气或新闻时）拥堵
- en: 'Alarms have three properties, as follows:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 警报有三个属性，如下所示：
- en: Alarm type (see in the following list)
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报类型（见以下列表）
- en: Trigger time (if the time has already passed, the alarm is triggered immediately)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发时间（如果时间已经过去，警报将立即触发）
- en: Pending Intent
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂意图（Pending Intent）
- en: 'A repeating alarm has the same three properties, plus an Interval:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 重复警报具有相同的三个属性，加上一个间隔：
- en: Alarm type (see in the following list)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 警报类型（见以下列表）
- en: Trigger time (if the time has already passed, it triggers immediately)
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发时间（如果时间已经过去，它将立即触发）
- en: Interval
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 间隔
- en: Pending Intent
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 悬挂意图
- en: 'There are four alarm types:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 有四种警报类型：
- en: '`RTC` (**Real Time Clock**): This is based on the wall clock time. This does
    not wake the device.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC`（**实时时钟**）：这是基于墙上的时钟时间。这不会唤醒设备。'
- en: '`RTC_WAKEUP`: This is based on the wall clock time. This wakes the device if
    it is sleeping.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RTC_WAKEUP`：这是基于墙上的时钟时间。如果设备处于睡眠状态，则会唤醒设备。'
- en: '`ELAPSED_REALTIME`: This is based on the time elapsed since the device boot.
    This does not wake the device.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELAPSED_REALTIME`：这是基于设备启动以来经过的时间。这不会唤醒设备。'
- en: '`ELAPSED_REALTIME_WAKEUP`: This is based on the time elapsed since the device
    boot. This wakes the device if it is sleeping.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ELAPSED_REALTIME_WAKEUP`：这是基于设备启动以来经过的时间。如果设备处于睡眠状态，则会唤醒设备。'
- en: Elapsed Real Time is better for time interval alarms—such as every 30 minutes.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 实际经过的时间（Elapsed Real Time）更适合时间间隔警报——例如每30分钟一次。
- en: Tip
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Alarms do not persist after device reboots. All alarms are cancelled when a
    device shuts down, so it is your app's responsibility to reset the alarms on device
    boot. (See *Receive notification of device boot* for more information.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 警报在设备重启后不会持久化。当设备关闭时，所有警报都会被取消，因此，在设备启动时重置警报是您应用程序的责任。（有关更多信息，请参阅 *接收设备启动通知*。）
- en: The following recipe will demonstrate how to create alarms with `AlarmManager`.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下菜谱将演示如何使用 `AlarmManager` 创建警报。
- en: Getting ready
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `Alarms`. Use the default
    **Phone & Tablet** option and select **Empty Activity** when prompted for **Activity
    Type**.'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为：`Alarms`。使用默认的 **手机和平板电脑** 选项，并在提示 **活动类型**
    时选择 **空活动**。
- en: How to do it...
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Setting an alarm requires a Pending Intent, which Android sends when the alarm
    is triggered. Therefore, we need to set up a Broadcast Receiving to capture the
    alarm intent. Our UI will consist of just a simple button to set the alarm. To
    start, open the Android Manifest and follow these steps:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 设置警报需要悬挂意图（Pending Intent），当警报被触发时，Android会发送它。因此，我们需要设置广播接收器来捕获警报意图。我们的UI将仅包含一个简单的按钮来设置警报。首先，打开AndroidManifest.xml，并按照以下步骤操作：
- en: 'Add the following `<receiver>` to the `<application>` element at the same level
    as the existing `<activity>` element:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `<receiver>` 添加到 `<application>` 元素中，与现有的 `<activity>` 元素处于同一级别：
- en: '[PRE10]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Open `activity_main.xml` and replace the existing TextView with the following
    button:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `activity_main.xml` 并将现有的TextView替换为以下按钮：
- en: '[PRE11]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Create a new Java class called `AlarmBroadcastReceiver` using the following
    code:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个新的 Java 类 `AlarmBroadcastReceiver`：
- en: '[PRE12]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Open `ActivityMain.java` and add the method for the button click:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ActivityMain.java` 并添加按钮点击的方法：
- en: '[PRE13]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Creating the alarm is done with this line of code:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 创建闹钟是通过这一行代码完成的：
- en: '[PRE14]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Here''s the method signature:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是方法签名：
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to Android 4.4 KitKat (API 19), this was the method to request an exact
    time. Android 4.4 and later will consider this as an inexact time for efficiency,
    but will not deliver the intent prior to the requested time. (See `setExact()`
    as follows if you need an exact time.)
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 4.4 KitKat（API 19）之前，这是请求精确时间的方法。Android 4.4 及以后的版本将考虑这为效率而近似的时间，但不会在请求时间之前传递意图。（如果你需要精确时间，请参见以下
    `setExact()`。）
- en: 'To set the alarm, we create a Pending Intent with our previously defined alarm
    action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置闹钟，我们创建一个带有我们之前定义的闹钟动作的 Pending Intent：
- en: '[PRE16]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: (This is an arbitrary string and could be anything we want, but it needs to
    be unique, so we prepend our package name.) We check for this action in the Broadcast
    Receiver's `onReceive()` callback.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: （这是一个任意的字符串，可以是任何我们想要的，但它需要是唯一的，因此我们在包名前加上。）我们在广播接收器的 `onReceive()` 回调中检查这个动作。
- en: There's more...
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: If you click the **Set Alarm** button and wait for thirty minutes, you will
    see the Toast when the alarm triggers. If you are too impatient to wait and click
    the **Set Alarm** button again before the first alarm is triggered, you wouldn't
    get two alarms. Instead, the OS will replace the first alarm with the new alarm,
    since they both use the same Pending Intent. (If you need multiple alarms, you
    need to create different Pending Intents, such as using different Actions.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击 **Set Alarm** 按钮并等待三十分钟，你将在闹钟触发时看到 Toast。如果你太急躁，在第一个闹钟触发之前再次点击 **Set Alarm**
    按钮，你不会得到两个闹钟。相反，操作系统将用新的闹钟替换第一个闹钟，因为它们都使用了相同的 Pending Intent。（如果你需要多个闹钟，你需要创建不同的
    Pending Intent，例如使用不同的 Actions。）
- en: Cancel the alarm
  id: totrans-119
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消闹钟
- en: 'If you want to cancel the alarm, call the `cancel()` method by passing the
    same Pending Intent you have used to create the alarm. If we continue with our
    recipe, this is how it would look:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想取消闹钟，通过传递创建闹钟时使用的相同的 Pending Intent 来调用 `cancel()` 方法。如果我们继续我们的配方，它看起来会是这样：
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Repeating alarm
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重复闹钟
- en: 'If you want to create a repeating alarm, use the `setRepeating()` method. The
    Signature is similar to the `set()` method, but with an interval. This is shown
    as follows:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要创建一个重复的闹钟，请使用 `setRepeating()` 方法。签名与 `set()` 方法类似，但有一个间隔。如下所示：
- en: '[PRE18]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'For the Interval, you can specify the interval time in milliseconds or use
    one of the predefined `AlarmManager` constants:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于间隔，你可以指定以毫秒为单位的间隔时间，或者使用预定义的 `AlarmManager` 常量之一：
- en: '`INTERVAL_DAY`'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_DAY`'
- en: '`INTERVAL_FIFTEEN_MINUTES`'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_FIFTEEN_MINUTES`'
- en: '`INTERVAL_HALF_DAY`'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HALF_DAY`'
- en: '`INTERVAL_HALF_HOUR`'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HALF_HOUR`'
- en: '`INTERVAL_HOUR`'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`INTERVAL_HOUR`'
- en: See also
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Developer Docs: AlarmManager** at [https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：AlarmManager** 在 [https://developer.android.com/reference/android/app/AlarmManager.html](https://developer.android.com/reference/android/app/AlarmManager.html)'
- en: Receive notification of device boot
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收设备启动通知
- en: Android sends out many intents during its lifetime. One of the first intents
    sent is `ACTION_BOOT_COMPLETED`. If your application needs to know when the device
    boots, you need to capture this intent.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: Android 在其生命周期中发送出许多意图。最早发送的意图之一是 `ACTION_BOOT_COMPLETED`。如果你的应用程序需要知道设备何时启动，你需要捕获这个意图。
- en: This recipe will walk you through the steps required to be notified when the
    device boots.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方将指导你完成在设备启动时接收通知所需的步骤。
- en: Getting ready
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `DeviceBoot`. Use the default
    **Phone & Tablet** option and select **Empty Activity** when prompted for **Activity
    Type**.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `DeviceBoot`。使用默认的 **Phone & Tablet** 选项，并在提示
    **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To start, open the Android Manifest and follow these steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，打开 AndroidManifest.xml 并按照以下步骤操作：
- en: 'Add the following permission:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下权限：
- en: '[PRE19]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add the following `<receiver>` to the `<application>` element, at the same
    level as the existing `<activity>` element:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `<receiver>` 添加到 `<application>` 元素中，与现有的 `<activity>` 元素处于同一级别：
- en: '[PRE20]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Create a new Java class called `BootBroadcastReceiver` using the following
    code:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码创建一个新的 Java 类 `BootBroadcastReceiver`：
- en: '[PRE21]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Reboot the device to see the Toast.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动设备以查看 Toast。
- en: How it works...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the device boots, Android will send the `BOOT_COMPLETED` intent. As long
    as our application has the permission to receive the intent, we will receive notifications
    in our Broadcast Receiver.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备启动时，Android 会发送 `BOOT_COMPLETED` 意图。只要我们的应用程序有接收意图的权限，我们就会在我们的广播接收器中收到通知。
- en: 'There are three aspects to make this work:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 要使此功能正常工作，有三个方面需要考虑：
- en: A permission for `RECEIVE_BOOT_COMPLETED`
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RECEIVE_BOOT_COMPLETED` 的权限'
- en: Adding `BOOT_COMPLETED` to the receiver intent filter
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 `BOOT_COMPLETED` 添加到接收器意图过滤器
- en: Checking for the `BOOT_COMPLETED` action in the Broadcast Receiver
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在广播接收器中检查 `BOOT_COMPLETED` 动作
- en: Obviously, you'll want to replace the Toast message with your own code, such
    as for recreating any alarms you might need.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，您会想用您自己的代码替换 Toast 消息，例如，用于重新创建您可能需要的任何闹钟。
- en: There's more...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'If you followed the previous recipe, then you already have a Broadcast Receiver.
    You don''t need a separate `BroadcastReceiver` for each action, just check for
    each action as needed. Here''s an example if we need to handle another action:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您遵循了前面的食谱，那么您已经有一个广播接收器。您不需要为每个动作创建单独的 `BroadcastReceiver`，只需按需检查每个动作即可。以下是一个示例，如果我们需要处理另一个动作：
- en: '[PRE22]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: See also
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Developer Docs: Intent** at [https://developer.android.com/reference/android/content/Intent.html](https://developer.android.com/reference/android/content/Intent.html)'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：Intent** 在 [https://developer.android.com/reference/android/content/Intent.html](https://developer.android.com/reference/android/content/Intent.html)'
- en: Using the AsyncTask for background work
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 AsyncTask 进行后台工作
- en: Throughout this book, we have mentioned the importance of not blocking the main
    thread. Performing long running operations on the main thread can cause your application
    to appear sluggish, or worse, hang. If your application doesn't respond within
    about 5 seconds, the system will likely display the **Application Not Responding**
    (**ANR**) dialog with the option to terminate your app. (This is something you
    will want to avoid as it's a good way to get your app uninstalled.)
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们提到了不阻塞主线程的重要性。在主线程上执行长时间运行的操作可能会导致您的应用程序看起来反应迟缓，或者更糟，挂起。如果您的应用程序在约 5
    秒内没有响应，系统可能会显示 **应用程序未响应** (**ANR**) 对话框，并提供终止您的应用程序的选项。（您会希望避免这种情况，因为这可能是您的应用程序被卸载的好方法。）
- en: 'Android applications use a single thread model with two simple rules, as follows:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: Android 应用程序使用单线程模型，有两个简单的规则，如下所示：
- en: Don't block the main thread
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要阻塞主线程
- en: Perform all UI operations *on* the main thread
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在主线程上执行所有 UI 操作
- en: When Android starts your application, it automatically creates the main (or
    UI) thread. This is the thread from which all UI operations must be called. The
    first rule is "Don't block the main thread". This means that you need to create
    a background, or a worker, thread for any long-running or potentially-blocking
    task. This is why all network based tasks should be performed off the main thread.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 当 Android 启动您的应用程序时，它会自动创建主（或 UI）线程。这是所有 UI 操作必须调用的线程。第一条规则是“不要阻塞主线程”。这意味着您需要为任何长时间运行或可能阻塞的任务创建一个后台或工作线程。这就是为什么所有基于网络的任务都应该在主线程之外执行。
- en: 'Android offers the following options when working with background threads:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理后台线程时，Android 提供以下选项：
- en: '`Activity.runOnUiThread()`'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Activity.runOnUiThread()`'
- en: '`View.post()`'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.post()`'
- en: '`View.postDelayed()`'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`View.postDelayed()`'
- en: '`Handler`'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Handler`'
- en: '`AsyncTask`'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AsyncTask`'
- en: This recipe will explore the `AsyncTask` class; since it was created previously,
    you wouldn't have to use the Handler or post methods directly.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将探讨 `AsyncTask` 类；由于它已经被创建，您就不必直接使用 Handler 或 post 方法。
- en: Getting ready
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Create a new project in Android Studio and call it: `AsyncTask`. Use the default
    **Phone & Tablet** option and select **Empty Activity** when prompted for **Activity
    Type**.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为：`AsyncTask`。使用默认的 **Phone & Tablet** 选项，并在提示
    **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We only need a single button for this example. Open `activity_main.xml` and
    follow these steps:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们只需要一个按钮。打开 `activity_main.xml` 并按照以下步骤操作：
- en: 'Replace the existing TextView with the following button:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下按钮替换现有的 TextView：
- en: '[PRE23]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Open `MainActivity.java` and add the following global variable:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainActivity.java` 并添加以下全局变量：
- en: '[PRE24]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Add the `AsyncTask` class:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `AsyncTask` 类：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following code to the `onCreate()` to initialize the button:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `onCreate()` 中以初始化按钮：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Add the method for the button click:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮点击的方法：
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您现在可以开始在设备或模拟器上运行应用程序。
- en: How it works...
  id: totrans-187
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This is a very simple example of the `AsyncTask` just to get it working. Technically,
    only `doInBackground()` is required, but usually, you may want to receive notifications
    via `onPostExecute()` when it finishes.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `AsyncTask` 的非常简单的例子，只是为了让它工作。技术上，只需要 `doInBackground()`，但通常，你可能希望在它完成时通过
    `onPostExecute()` 接收通知。
- en: The `AsyncTask` works by creating a worker thread for the `doInBackground()`
    method, then responds back on the UI thread in the `onPostExecute()` callback.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`AsyncTask` 通过为 `doInBackground()` 方法创建一个工作线程来工作，然后在 `onPostExecute()` 回调中在
    UI 线程上做出响应。'
- en: Notice how we have waited until `onPostExecute()` is called before we do any
    UI actions such as enabling the button. If we attempt to modify the UI in the
    worker thread, it would either not compile or throw a runtime exception. You should
    also note how we instantiated a new `CountingTask` object on each button click.
    This is because an `AsyncTask` can only execute once. Attempting to call execute
    again will also throw an exception.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们是如何等待 `onPostExecute()` 被调用之后才执行任何 UI 操作，例如启用按钮。如果我们尝试在工作线程中修改 UI，则要么无法编译，要么抛出运行时异常。你还应该注意我们是如何在每次按钮点击时实例化一个新的
    `CountingTask` 对象。这是因为 `AsyncTask` 只能执行一次。再次调用 execute 也会抛出异常。
- en: There's more...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: At its minimum, the `AsyncTask` can be very simple but it is still very flexible
    with more options available if you need them. When using an `AsyncTask` with an
    Activity, it's important to understand whether the Activity is destroyed and recreated
    (such as during an orientation change), or the `AsyncTask` continues to run. This
    can leave your `AsyncTask` orphaned and it might respond back to the now destroyed
    activity (causing a `NullPointer` exception). For this reason, it's common to
    use the `AysncTask` with a Fragment (which is not destroyed on screen rotation),
    or use a Loader instead. (See the link for Loaders in the following section.)
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在其最简单的情况下，`AsyncTask` 可以非常简单，但如果需要，它仍然非常灵活。当使用 `AsyncTask` 与 Activity 时，了解 Activity
    是否被销毁并重新创建（例如在方向改变期间）或 `AsyncTask` 是否继续运行是很重要的。这可能会导致你的 `AsyncTask` 成孤儿，并且它可能会对现在已销毁的活动做出响应（导致
    `NullPointer` 异常）。因此，通常使用 `AsyncTask` 与 Fragment（在屏幕旋转时不会被销毁）一起使用，或者使用 Loader
    代替。（有关下一节中 Loaders 的链接，请参阅链接。）
- en: Parameter types
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 参数类型
- en: 'For many people, the most confusing aspect of the `AsyncTask` is the parameters
    when creating their own class. If you look at our class declaration, there are
    three parameters for the `AsyncTask`; they are defined as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多人来说，`AsyncTask` 最令人困惑的方面是在创建自己的类时参数的使用。如果你查看我们的类声明，`AsyncTask` 有三个参数；它们如下定义：
- en: '[PRE28]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The parameters are generic types and used as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 参数是泛型类型，如下使用：
- en: '**Params**: This is the parameter type to call `doInBackground()`'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Params**：这是调用 `doInBackground()` 的参数类型'
- en: '**Progress**: This is the parameter type to post updates'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Progress**：这是用于发布更新的参数类型'
- en: '**Result**: This is the parameter type to post results'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Result**：这是用于发布结果的参数类型'
- en: When you declare your own class, substitute the parameters with the variable
    type you need.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当你声明自己的类时，用你需要的变量类型替换参数。
- en: 'Here''s the process flow for the `AsyncTask` and how the preceding parameters
    are used:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 `AsyncTask` 的流程和如何使用先前参数的示例：
- en: '`onPreExecute()`: This is called before `doInBackground()` begins'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPreExecute()`：在 `doInBackground()` 开始之前被调用'
- en: '`doInBackground(Params)`: This executes in a background thread'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`doInBackground(Params)`：在后台线程中执行'
- en: '`onProgressUpdate(Progress)`: This is called (on the UI thread) in response
    to the calling `publishProgress(Progress)` in the worker thread'
  id: totrans-204
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onProgressUpdate(Progress)`：在响应工作线程中调用的 `publishProgress(Progress)` 时（在 UI
    线程上）被调用'
- en: '`onPostExecute(Result)`: This is called (on the UI thread) when the worker
    thread finishes'
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onPostExecute(Result)`：当工作线程完成时（在 UI 线程上）被调用'
- en: Cancel the task
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 取消任务
- en: 'To cancel the task, call the cancel method on the object as follows:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 要取消任务，请按照以下方式在对象上调用 cancel 方法：
- en: '[PRE29]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: You will need to have the object instance to access the `cancel()` method. (We
    did not save the object in our previous example.) After setting `cancel(true)`,
    the calling `isCancelled()` in `doInBackground()` will return `true`, allowing
    you to exit a loop. If cancelled, `onCancelled()` will be called instead of `onPostExecute()`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要对象实例来访问 `cancel()` 方法。（在我们的前一个例子中我们没有保存对象。）在设置 `cancel(true)` 之后，`doInBackground()`
    中的调用 `isCancelled()` 将返回 `true`，允许你退出循环。如果取消，将调用 `onCancelled()` 而不是 `onPostExecute()`。
- en: See also
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Access data in the background using a Loader* recipe, in [Chapter
    6](ch06.html "Chapter 6. Working with Data"), *Working with Data*
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考第 6 章 [“使用数据”](ch06.html "第 6 章。使用数据") 中的 *使用 Loader 在后台访问数据* 菜谱，*使用数据*
- en: '**Developer Docs: AsyncTask** at [http://developer.android.com/reference/android/os/AsyncTask.html](http://developer.android.com/reference/android/os/AsyncTask.html)'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：AsyncTask** 在 [http://developer.android.com/reference/android/os/AsyncTask.html](http://developer.android.com/reference/android/os/AsyncTask.html)'
- en: Adding speech recognition to your app
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将语音识别添加到你的应用程序中
- en: Android 2.2 (API 8) introduced speech recognition in Android, and it continues
    to improve with almost every new major Android release. This recipe will demonstrate
    how to add speech recognition to your app using the Google Speech service.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: Android 2.2（API 8）在 Android 中引入了语音识别，并且几乎在每个新的主要 Android 版本中都得到了改进。这个菜谱将演示如何使用
    Google 语音服务将语音识别添加到你的应用程序中。
- en: Getting ready
  id: totrans-215
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new project in Android Studio and call it `SpeechRecognition`. Use
    the default **Phone & Tablet** option and select **Empty Activity** when prompted
    for **Activity Type**.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `SpeechRecognition`。使用默认的 **Phone & Tablet**
    选项，并在提示 **Activity Type** 时选择 **Empty Activity**。
- en: How to do it...
  id: totrans-217
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'We''ll start by adding a Speak Now (or microphone) button to the layout, then
    we''ll add the necessary code to call the speech recognizer. Open `activity_main.xml`
    and follow these steps:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将在布局中添加一个“现在说话”（或麦克风）按钮，然后我们将添加必要的代码来调用语音识别器。打开 `activity_main.xml` 并按照以下步骤操作：
- en: 'Replace the existing `TextView` with the following XML:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下 XML 替换现有的 `TextView`：
- en: '[PRE30]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Define the `REQUEST_SPEECH` constant:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义 `REQUEST_SPEECH` 常量：
- en: '[PRE31]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 回调中：
- en: '[PRE32]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the button click method:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加按钮点击方法：
- en: '[PRE33]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code to override the `onActivityResult()` callback:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到重写 `onActivityResult()` 回调：
- en: '[PRE34]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你已经准备好在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The work here is done by the Google Speech Recognizer included in Android. To
    make sure the service is available on the device, we call `PackageManager` in
    `onCreate()`. If at least one activity is registered to handle the `RecognizerIntent.ACTION_RECOGNIZE_SPEECH`
    intent, then we know it's available. If no activities are available, we display
    a Toast indicating speech recognition is not available and disable the mic button.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的工作是由 Android 中的 Google 语音识别器完成的。为了确保服务在设备上可用，我们在 `onCreate()` 中调用 `PackageManager`。如果至少有一个活动注册来处理
    `RecognizerIntent.ACTION_RECOGNIZE_SPEECH` 意图，那么我们知道它是可用的。如果没有活动可用，我们将显示一个 Toast
    提示语音识别不可用，并禁用麦克风按钮。
- en: The button click starts the recognition process by calling an intent created
    with `RecognizerIntent.ACTION_RECOGNIZE_SPEECH`.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 按钮点击通过调用使用 `RecognizerIntent.ACTION_RECOGNIZE_SPEECH` 创建的意图来启动识别过程。
- en: 'The `EXTRA_LANGUAGE_MODEL` parameter is required and has the following two
    choices:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`EXTRA_LANGUAGE_MODEL` 参数是必需的，有两个选择：'
- en: '`LANGUAGE_MODEL_FREE_FORM`'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE_MODEL_FREE_FORM`'
- en: '`LANGUAGE_MODEL_WEB_SEARCH`'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LANGUAGE_MODEL_WEB_SEARCH`'
- en: We get the result back in the `onActivityResult()` callback. If we get back
    `RESULT_OK`, then we should have a list of words recognized, which we can retrieve
    using `getStringArrayListExtra()`. The array list will be ordered starting with
    the highest recognition confidence.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 `onActivityResult()` 回调中获取结果。如果我们得到 `RESULT_OK`，那么我们应该有一个识别出的单词列表，我们可以使用
    `getStringArrayListExtra()` 来检索它。数组列表将按识别置信度从高到低排序。
- en: 'If you want to retrieve the confidence rating, retrieve the float array using
    `EXTRA_CONFIDENCE_SCORES`. Here''s an example:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检索置信度评分，请使用 `EXTRA_CONFIDENCE_SCORES` 检索浮点数组。以下是一个示例：
- en: '[PRE35]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The confidence rating is optional and may not be present. A score of 1.0 indicates
    highest confidence, while 0.0 indicates lowest confidence.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 置信度评分是可选的，可能不存在。1.0 分表示最高置信度，而 0.0 分表示最低置信度。
- en: There's more...
  id: totrans-240
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Using the intent is a quick and easy way to get speech recognition; however,
    if you would prefer not to use the default Google activity, you can call the `SpeechRecognizer`
    class directly. Here''s an example of how to instantiate the class:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用意图是获取语音识别的一种快速简单的方法；然而，如果你不想使用默认的 Google 活动，你可以直接调用 `SpeechRecognizer` 类。以下是如何实例化类的示例：
- en: '[PRE36]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: You will need to add the `RECORD_AUDIO` permission and implement the `RecognitionListener`
    class to handle the speech events. (See the following links for more information.)
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要添加 `RECORD_AUDIO` 权限并实现 `RecognitionListener` 类来处理语音事件。（有关更多信息，请参阅以下链接。）
- en: See also
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '**Developer Docs: RecognizerIntent** at [http://developer.android.com/reference/android/speech/RecognizerIntent.html](http://developer.android.com/reference/android/speech/RecognizerIntent.html)'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：RecognizerIntent** 在 [http://developer.android.com/reference/android/speech/RecognizerIntent.html](http://developer.android.com/reference/android/speech/RecognizerIntent.html)'
- en: '**Developer Docs: SpeechRecognizer** at [http://developer.android.com/reference/android/speech/SpeechRecognizer.html](http://developer.android.com/reference/android/speech/SpeechRecognizer.html)'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：SpeechRecognizer** 在 [http://developer.android.com/reference/android/speech/SpeechRecognizer.html](http://developer.android.com/reference/android/speech/SpeechRecognizer.html)'
- en: '**Developer Docs: RecognitionListener** at [http://developer.android.com/reference/android/speech/RecognitionListener.html](http://developer.android.com/reference/android/speech/RecognitionListener.html)'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发者文档：RecognitionListener** 在 [http://developer.android.com/reference/android/speech/RecognitionListener.html](http://developer.android.com/reference/android/speech/RecognitionListener.html)'
- en: Push Notification using GCM
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用GCM的推送通知
- en: 'GCM, Google''s version of Push Notification, allows your application to receive
    messages. The idea is similar to SMS messages, but much more flexible. There are
    three components to GCM:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: GCM，即谷歌的推送通知版本，允许您的应用程序接收消息。其理念类似于短信，但更加灵活。GCM有三个组成部分：
- en: Your server (this is where you initiate the message)
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的服务器（这是您启动消息的地方）
- en: Google's GCM server
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 谷歌的GCM服务器
- en: Android device (although GCM is also available on other platforms)
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安卓设备（尽管GCM也适用于其他平台）
- en: When the user starts your application, your code needs to connect to the GCM
    server and obtain a device token, then send that token to your server. Your server
    is responsible for initiating the message and passing it to the GCM server. Your
    server needs to track the device tokens that have to be sent when initiating the
    message. (Your server tells the GCM server which device tokens needs to be sent.)
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户启动您的应用程序时，您的代码需要连接到GCM服务器并获取设备令牌，然后将该令牌发送到您的服务器。您的服务器负责启动消息并将其传递给GCM服务器。您的服务器需要跟踪在启动消息时需要发送的设备令牌。（您的服务器告诉GCM服务器需要发送哪些设备令牌。）
- en: You can implement your own server or choose to use one of many services available.
    The next chapter, *Backend Service Options*, will look at several BaaS options,
    many of which also offer Push Notification. (The *Simple Testing Option* section
    offers an option to verify that your code is working.)
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以实施自己的服务器或选择使用众多可用的服务之一。下一章“后端服务选项”将探讨几个BaaS选项，其中许多也提供推送通知。（“简单测试选项”部分提供了一个验证您的代码是否正常工作的选项。）
- en: This recipe will walk you through the steps to add GCM using the current (Version
    8.3) Google Services library. Before getting to the steps, it's worth noting that
    GCM is supported all the way back to API 8, as long as the user has a Google account.
    A Google account is not required after Android 4.0.4.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱将指导您使用当前（版本8.3）的Google Services库添加GCM的步骤。在进入步骤之前，值得注意的是，GCM一直支持到API 8，只要用户有谷歌账户即可。从Android
    4.0.4开始，不需要谷歌账户。
- en: Getting ready
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Create a new project in Android Studio and call it `GCM`. Use the default **Phone
    & Tablet** option and select **Empty Activity** when prompted for **Activity Type**.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android Studio中创建一个新的项目，并将其命名为“GCM”。使用默认的**手机和平板**选项，并在提示**活动类型**时选择**空活动**。
- en: 'GCM uses the Google Services plugin, which requires a Google Services configuration
    file available from the Google Developer Console. To create the configuration
    file, you will need the following information:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: GCM使用Google Services插件，该插件需要从谷歌开发者控制台获取的Google Services配置文件。要创建配置文件，您需要以下信息：
- en: Your application package name
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序包名
- en: 'When you have the information, log in to this Google link and follow the wizard
    to enable GCM for your app: [https://developers.google.com/mobile/add](https://developers.google.com/mobile/add)'
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当您拥有这些信息时，请登录到以下谷歌链接并按照向导操作以启用您的应用程序的GCM：[https://developers.google.com/mobile/add](https://developers.google.com/mobile/add)
- en: Note
  id: totrans-261
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you download the source files, you will need to create a new package name
    when following the preceding steps, as the existing package name has already been
    registered.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您下载了源文件，在遵循前面的步骤时，您需要创建一个新的包名，因为现有的包名已经被注册。
- en: How to do it...
  id: totrans-263
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After completing the preceding Getting Ready section, follow these steps:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前面的“准备就绪”部分后，请按照以下步骤操作：
- en: Copy the `google-services.json` file, which you downloaded in the *Getting Ready*
    section, to your app folder (<project folder>\`GCM\app`).
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在“准备就绪”部分下载的`google-services.json`文件复制到您的应用程序文件夹中（`<项目文件夹>\`GCM\app`）。
- en: 'Open the project Gradle build file: `build.gradle (Project: GCM)`, and add
    the following to the `buildscript dependencies` sections:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开项目 Gradle 构建文件：`build.gradle (Project: GCM)`，并将以下内容添加到 `buildscript dependencies`
    部分：'
- en: '[PRE37]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Open the app module Gradle build file: `build.gradle (Module: app)`, and add
    the following statement to the beginning of the file (above the `android` section):'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开应用程序模块 Gradle 构建文件：`build.gradle (Module: app)`，并将以下语句添加到文件的开头（在 `android`
    部分之上）：'
- en: '[PRE38]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the same module build file as step 3, add the following statement to the
    dependencies section:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与步骤 3 相同的模块构建文件中，将以下语句添加到依赖项部分：
- en: '[PRE39]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Open the Android Manifest and add the following permissions:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 AndroidManifest.xml 文件并添加以下权限：
- en: '[PRE40]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Within the `<application>` element, add the following `<receiver>` and `<service>`
    declarations (these should be at the same level as the `<activity>`):'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `<application>` 元素内，添加以下 `<receiver>` 和 `<service>` 声明（这些应该与 `<activity>`
    处于同一级别）：
- en: '[PRE41]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Create a new Java class called `GCMRegistrationService` that extends `IntentService`,
    as follows:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GCMRegistrationService` 的新 Java 类，它扩展了 `IntentService`，如下所示：
- en: '[PRE42]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Create a new Java class called `GCMInstanceService` that extends `InstanceIDListenerService`,
    as follows:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GCMInstanceService` 的新 Java 类，它扩展了 `InstanceIDListenerService`，如下所示：
- en: '[PRE43]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Create a new Java class called `GCMService` that extends `GcmListenerService,`
    as follows:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `GCMService` 的新 Java 类，它扩展了 `GcmListenerService`，如下所示：
- en: '[PRE44]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Add the following code to the existing `onCreate()` callback:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的 `onCreate()` 回调中：
- en: '[PRE45]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以开始在设备或模拟器上运行应用程序了。
- en: How it works...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Most of the actual GCM code is encapsulated within the Google APIs, simplifying
    the implementation. We just have to set up the project to include Google Services,
    and give our app the required permissions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分实际的 GCM 代码都被封装在 Google API 中，简化了实现。我们只需设置项目以包含 Google 服务，并授予我们的应用程序所需的权限。
- en: Note
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Important**! When adding the permissions in Steps 5 and 6, replace the `<packageName>`
    placeholder with your application''s package name.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**重要**！在步骤 5 和 6 中添加权限时，将 `<packageName>` 占位符替换为你的应用程序包名。'
- en: 'The most complicated aspect of GCM is probably the multiple services required.
    Even though the code in each service is minimal, each service has a specific task.
    There are two main aspects of GCM:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: GCM 最复杂的部分可能是所需的多个服务。尽管每个服务中的代码量很少，但每个服务都有特定的任务。GCM 有两个主要方面：
- en: Registering the app with the GCM server
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序注册到 GCM 服务器
- en: Receiving messages
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收消息
- en: 'This is the code to register with the GCM server:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 这是向 GCM 服务器注册的代码：
- en: '[PRE46]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: We don't call `getToken()` in the Activity, because it could block the UI thread.
    Instead, we call the `GCMRegistrationService`, which handles the call in a background
    thread. After you receive the device token, you need to send it to your server,
    as it is needed when initiating a message.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不在 Activity 中调用 `getToken()`，因为它可能会阻塞 UI 线程。相反，我们调用 `GCMRegistrationService`，它在后台线程中处理调用。在收到设备令牌后，你需要将其发送到你的服务器，因为初始化消息时需要它。
- en: The process of receiving a GCM message is handled in `GCMService`, which extends
    `GcmListenerService`. Since the Google API already handles most of the work, all
    we have to do is respond to the `onMessageReceived()` callback.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 接收 GCM 消息的过程由 `GCMService` 处理，它扩展了 `GcmListenerService`。由于 Google API 已经处理了大部分工作，我们只需响应
    `onMessageReceived()` 回调。
- en: There's more...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'To make it easier to type, we left out an important Google Services API verification
    that should be included in any production application. Instead of calling `GCMRegistrationService`
    directly, as we did in `onCreate()` in the preceding section, first check whether
    the Google API Service is available. Here''s an example showing how to call the
    `isGooglePlayServicesAvailable()` method:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了便于输入，我们省略了一个重要的 Google 服务 API 验证，该验证应包含在任何生产应用程序中。我们不是直接调用 `GCMRegistrationService`，就像在前一节的
    `onCreate()` 中所做的那样，而是首先检查 Google API 服务是否可用。以下是一个展示如何调用 `isGooglePlayServicesAvailable()`
    方法的示例：
- en: '[PRE47]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Then, change the `onCreate()` code to call this method first:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，将 `onCreate()` 代码更改为首先调用此方法：
- en: '[PRE48]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Simple testing option
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 简单测试选项
- en: To help to verify that your code is working correctly, a testing application
    was created and posted on Google Play. This app will run on both a physical device
    and an emulator. The Google Play listing also includes a link to download the
    source code and run the project directly, making it easier to enter the required
    fields.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助验证您的代码是否正确工作，已创建并发布了一个测试应用程序到 Google Play。此应用程序将在物理设备和模拟器上运行。Google Play
    列表中还包括一个下载源代码并直接运行项目的链接，这使得输入所需字段变得更加容易。
- en: Tip
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**GCM (Push Notification) Tester**: Refer to the following link for more information:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '**GCM (Push Notification) Tester**: 请参考以下链接获取更多信息：'
- en: '[https://play.google.com/store/apps/details?id=com.eboyer.gcmtester](https://play.google.com/store/apps/details?id=com.eboyer.gcmtester)'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://play.google.com/store/apps/details?id=com.eboyer.gcmtester](https://play.google.com/store/apps/details?id=com.eboyer.gcmtester)'
- en: See also
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the Google Cloud Messaging web page at [https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging](https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging)
  id: totrans-307
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考谷歌云消息传递网页 [https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging](https://developers.google.com/android/reference/com/google/android/gms/gcm/GoogleCloudMessaging)
- en: Refer to the About the GCM Connection server web page at [https://developers.google.com/cloud-messaging/server](https://developers.google.com/cloud-messaging/server)
  id: totrans-308
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考关于 GCM 连接服务器网页 [https://developers.google.com/cloud-messaging/server](https://developers.google.com/cloud-messaging/server)
- en: How to add Google sign-in to your app
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何将 Google 登录添加到您的应用
- en: 'A Google sign-in allows your users to sign in to your application using their
    Google credentials. This recipe will walk you through the process of adding a
    Google sign-in to your application. Here''s a screenshot showing the Google sign-in
    button in the application that we''ll create in the recipe:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Google 登录允许您的用户使用他们的 Google 凭据登录您的应用程序。本指南将指导您将 Google 登录添加到您的应用程序中。以下是应用程序中
    Google 登录按钮的截图，我们将按照本指南创建它：
- en: '![How to add Google sign-in to your app](img/B05057_14_1.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![如何将 Google 登录添加到您的应用](img/B05057_14_1.jpg)'
- en: Getting ready
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备就绪
- en: Create a new project in Android Studio and call it `GoogleSignIn`. Use the default
    **Phone & Tablet** option and select **Empty Activity** when prompted for **Activity
    Type**.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android Studio 中创建一个新的项目，并将其命名为 `GoogleSignIn`。使用默认的 **Phone & Tablet** 选项，并在提示
    **Activity Type** 时选择 **Empty Activity**。
- en: 'The Google sign-in uses the Google Services plugin, which requires a Google
    Services Configuration file, which is available from the Google Developer Console.
    To create the configuration file, you will need the following information:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Google 登录使用 Google 服务插件，这需要一个 Google 服务配置文件，该文件可以从 Google 开发者控制台获取。要创建配置文件，您需要以下信息：
- en: Your application package name
  id: totrans-315
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您的应用程序包名
- en: Your signing certificate's SHA-1 hash code (see the *Authenticating Your Client*
    link at the end of the recipe for more information)
  id: totrans-316
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您签名证书的 SHA-1 哈希码（有关更多信息，请参阅本指南末尾的 *验证您的客户端* 链接）
- en: 'When you have the information, log in to this Google link and follow the wizard
    to enable sign-in:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 当您有了信息后，登录此 Google 链接并按照向导启用登录：
- en: '[https://developers.google.com/mobile/add](https://developers.google.com/mobile/add)'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://developers.google.com/mobile/add](https://developers.google.com/mobile/add)'
- en: Note
  id: totrans-319
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are downloading the source files, you will need to create a new package
    name when following the preceding steps, as the existing package name has already
    been registered.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您正在下载源文件，在遵循前面的步骤时需要创建一个新的包名，因为现有的包名已经被注册。
- en: How to do it...
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'After completing the preceding *Getting Ready* section, follow these steps:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成前面的 *准备就绪* 部分后，按照以下步骤操作：
- en: Copy the `google-services.json` file you downloaded in the *Getting Ready* section
    to your app folder (`<project folder>\GoogleSignIn\app`)
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将在 *准备就绪* 部分下载的 `google-services.json` 文件复制到您的应用文件夹中 (`<project folder>\GoogleSignIn\app`)
- en: 'Open the project Gradle build file: `build.gradle (Project: GoogleSignIn)`,
    and add the following to the `buildscript dependencies` section:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开项目 Gradle 构建文件：`build.gradle (Project: GoogleSignIn)`，并在 `buildscript dependencies`
    部分添加以下内容：'
- en: '[PRE49]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Open the app module Gradle build file: `build.gradle (Module: app)`, and add
    the following statement to the beginning of the file (above the `android` section):'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '打开应用模块 Gradle 构建文件：`build.gradle (Module: app)`，并在文件开头（在 `android` 部分之上）添加以下语句：'
- en: '[PRE50]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'In the same module build file as Step 3, add the following statement to the
    dependencies section:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与第 3 步相同的模块构建文件中，在依赖项部分添加以下语句：
- en: '[PRE51]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Open `activity_main.xml` and replace the existing `TextView` with the following
    XML:'
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`activity_main.xml`并用以下XML替换现有的`TextView`：
- en: '[PRE52]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Open `MainActivity.java` and add the following global declarations:'
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainActivity.java`并添加以下全局声明：
- en: '[PRE53]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Add the following `OnConnectionFailedListener`:'
  id: totrans-334
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下`OnConnectionFailedListener`：
- en: '[PRE54]'
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the following code to the existing `onCreate()`:'
  id: totrans-336
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到现有的`onCreate()`中：
- en: '[PRE55]'
  id: totrans-337
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Create an override for the `onActivityResult()` callback as follows:'
  id: totrans-338
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如下创建`onActivityResult()`回调的覆盖：
- en: '[PRE56]'
  id: totrans-339
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: You're ready to run the application on a device or emulator.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以运行应用程序在设备或模拟器上了。
- en: How it works...
  id: totrans-341
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Google has made it relatively simple to add a Google sign-in with their `GoogleApiClient`
    and `GoogleSignInOptions` APIs. First, we create a `GoogleSignInOptions` object
    with the builder. This is where we specify the sign-in options we want, such as
    requesting e-mail ID. Then, we pass it to the `GoogleApiClient` builder.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Google通过他们的`GoogleApiClient`和`GoogleSignInOptions` API使添加Google登录变得相对简单。首先，我们使用构建器创建一个`GoogleSignInOptions`对象。这是我们指定我们想要的登录选项的地方，例如请求电子邮件ID。然后，我们将其传递给`GoogleApiClient`构建器。
- en: 'When the user clicks on the Google sign-in button (created with the `com.google.android.gms.common.SignInButton`
    class), we send an Intent for `GoogleSignInApi` to the handle. We process the
    result in `onActivityResult()`. If the sign-in was successful, we can get the
    account details. In our example, we just get the e-mail, but additional information
    is available such as the following:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击Google登录按钮（使用`com.google.android.gms.common.SignInButton`类创建）时，我们向处理程序发送一个`GoogleSignInApi`的Intent。我们在`onActivityResult()`中处理结果。如果登录成功，我们可以获取账户详情。在我们的例子中，我们只获取电子邮件，但还有其他附加信息，如下所示：
- en: '`getDisplayName()`: This is the display name'
  id: totrans-344
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getDisplayName()`: 这是显示名称'
- en: '`getEmail(``)`: The e-mail address'
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getEmail(``)`: 电子邮件地址'
- en: '`getId()`: The unique ID for the Google account'
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getId()`: Google账户的唯一ID'
- en: '`getPhotoUrl()`: The display photo'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getPhotoUrl()`: 显示照片'
- en: '`getIdToken()`: This is for the backend authentication'
  id: totrans-348
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`getIdToken()`: 这用于后端认证'
- en: See the *GoogleSignInAccount* link in the *See also* section for a complete
    list.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 在“另请参阅”部分查看*GoogleSignInAccount*链接，以获取完整列表。
- en: There's more...
  id: totrans-350
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: If you want your application to be available to a wider audience, you'll want
    to think about localization.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想让你的应用程序面向更广泛的受众，你需要考虑本地化。
- en: Localization resources
  id: totrans-352
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 本地化资源
- en: 'Google provides many localized strings in the SDK, located at this link: `<SDK
    install folder>/sdk/extras/google/google_play_services/libproject/google-play-services_lib/res/`.'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: Google在SDK中提供了许多本地化字符串，位于此链接：`<SDK安装文件夹>/sdk/extras/google/google_play_services/libproject/google-play-services_lib/res/`。
- en: See also
  id: totrans-354
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 另请参阅
- en: Refer to the web page talking about authenticating your client at [https://developers.google.com/android/guides/client-auth](https://developers.google.com/android/guides/client-auth)
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考关于在[https://developers.google.com/android/guides/client-auth](https://developers.google.com/android/guides/client-auth)认证客户端的网页
- en: Visit GoogleSignInAccount at [https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount](https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount)
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问[https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount](https://developers.google.com/android/reference/com/google/android/gms/auth/api/signin/GoogleSignInAccount)
