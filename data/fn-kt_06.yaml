- en: Delegates in Kotlin
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin中的委托
- en: In the last two chapters, we learned about functions and function types in functional
    programming. We also learned about the various types of function Kotlin has to
    offer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在前两章中，我们学习了函数和函数类型在函数式编程中的应用。我们还学习了Kotlin提供的各种函数类型。
- en: This chapter is based on delegates in Kotlin. Delegates are awesome features
    of Kotlin in favour of functional programming. If you are coming from a non-FP
    background such as Java, you are probably hearing about delegates for the first
    time. So in this chapter, we will try to untangle things for you.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章基于Kotlin中的委托。委托是Kotlin在函数式编程方面的优秀特性。如果你来自非FP背景，如Java，你可能第一次听说委托。因此，在本章中，我们将尽力为你解开这些谜团。
- en: We will start by learning the basics of delegation and then gradually move into
    implementations of delegates in Kotlin.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先学习委托的基础知识，然后逐步过渡到Kotlin中委托的实现。
- en: 'The following list contains the topics that will be covered in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 以下列表包含本章将涉及的主题：
- en: Introduction to delegation
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托简介
- en: Delegates in Kotlin
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Kotlin中的委托
- en: Delegated properties
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托属性
- en: Standard delegates
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标准委托
- en: Custom delegates
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义委托
- en: Delegated map
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托映射
- en: Local delegation
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本地委托
- en: Class delegation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类委托
- en: So, let's get started with delegates.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始学习委托。
- en: Introduction to delegation
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托简介
- en: The origin of delegation in programming is from object composition. Object composition
    is a way to combine simple objects to derive a complex one. Object compositions
    are a critical building block of many basic data structures, including the tagged
    union, the linked list, and the binary tree.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中委托的起源来自对象组合。对象组合是将简单对象组合成复杂对象的一种方式。对象组合是许多基本数据结构的关键构建块，包括标签联合、链表和二叉树。
- en: To make object composition more reusable (as reusable as inheritance), a new
    pattern is incorporated—the **delegation pattern**.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使对象组合更可重用（尽可能像继承一样可重用），引入了一种新的模式——**委托模式**。
- en: This pattern allows an object to have a helper object, and that helper object
    is called a **delegate**. This pattern allows the original object to handle requests
    by delegating to the delegate helper object.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许一个对象拥有一个辅助对象，而这个辅助对象被称为**委托**。这种模式允许原始对象通过委托给委托辅助对象来处理请求。
- en: Though delegation is an object-oriented design pattern, not all languages have
    implicit support for delegation (such as Java, which doesn't support delegation
    implicitly). In those cases, you can still use *delegation* by explicitly passing
    the original object to the delegate to a method, as an argument/parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然委托是一种面向对象的设计模式，但并非所有语言都隐式支持委托（例如Java，它不隐式支持委托）。在这些情况下，您仍然可以通过显式地将原始对象传递给委托方法作为参数/参数来使用*委托*。
- en: But with the language support (such as in Kotlin), delegation becomes easier
    and often seems like using the original variable itself.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，有了语言支持（例如在Kotlin中），委托变得更容易，通常感觉就像使用原始变量本身一样。
- en: Understanding delegation
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解委托
- en: Over time, the delegation pattern has proven to be a better alternative of inheritance.
    Inheritance is a powerful tool for code reuse, especially in the context of the *Liskov
    Substitution* model. Moreover, the direct support of OOP languages makes it even
    stronger.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 随着时间的推移，委托模式已被证明是继承的更好替代方案。继承是代码重用的强大工具，尤其是在*Liskov替换*模型中。此外，面向对象语言对它的直接支持使其更加强大。
- en: However, inheritance still has some limitations, such as a class can't change
    its superclass dynamically during program execution; also, if you perform a small
    modification to the super class, it'll be directly propagated to the child class,
    and that is not what we want every time.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，继承仍然有一些局限性，例如，一个类在程序执行期间不能动态地更改其超类；此外，如果你对超类进行小的修改，它将直接传播到子类，而这并不是我们每次都想要的。
- en: Delegation, on the other hand, is flexible. You can think of delegation as a
    composition of multiple objects, where one object passes its method calls to another
    one and calls it a delegate. As I mentioned earlier, delegation is flexible; you
    can change the delegate at runtime.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，委托是灵活的。你可以把委托看作是多个对象的组合，其中一个对象将其方法调用传递给另一个对象，并称之为委托。如我之前提到的，委托是灵活的；你可以在运行时更改委托。
- en: For an example, think of the `Electronics` class and `Refrigerator` class. With
    inheritance, `Refrigerator` should implement/override the `Electronics` method
    calls and properties. With delegation however, the `Refrigerator` object would
    keep a reference of the `Electronics` object and would pass the method calls with
    it.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑 `Electronics` 类和 `Refrigerator` 类。使用继承时，`Refrigerator` 应该实现/覆盖 `Electronics`
    的方法调用和属性。然而，使用委托时，`Refrigerator` 对象将保持对 `Electronics` 对象的引用，并将方法调用与其一起传递。
- en: Now, since we know that Kotlin provides support for delegation, let's get started
    with delegation in Kotlin.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们知道 Kotlin 提供了对委托的支持，那么让我们开始学习 Kotlin 中的委托。
- en: Delegates in Kotlin
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Kotlin 中的委托
- en: Kotlin has out-of-the-box support for delegation. Kotlin provides you with some
    standard delegates for properties for most common programming needs. Most of the
    time, you'll find yourself using those standard delegates, instead of creating
    your own one; however, Kotlin also allows you to create your own delegate, as
    per your requirements.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了开箱即用的委托支持。Kotlin 为大多数常见的编程需求提供了某些标准委托。大多数时候，你会发现自己在使用这些标准委托，而不是创建自己的；然而，Kotlin
    也允许你根据需求创建自己的委托。
- en: Not only delegation for properties, Kotlin also allows you to have delegated
    classes.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 不仅允许对属性进行委托，还允许有委托类。
- en: 'So basically, there are two types of delegation in Kotlin, which are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基本上，Kotlin 中有两种类型的委托，如下所示：
- en: Property delegation
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性委托
- en: Class delegation
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类委托
- en: So, let's have a look at the property delegation first, and then we will move
    ahead with class delegation.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们先来看一下属性委托，然后我们将继续讨论类委托。
- en: Property delegation (standard delegates)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 属性委托（标准委托）
- en: In the previous section, where we discussed delegation, we learned that delegation
    is a technique of method passing/forwarding.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论委托时，我们了解到委托是一种方法传递/转发的技术。
- en: For property delegates, it almost does the same. A property can pass its getter
    and setter calls to the delegate and the delegate can handle those calls on behalf
    of the property itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于属性委托，它几乎做了同样的事情。一个属性可以将它的获取器和设置器调用传递给委托，委托可以代表属性本身处理这些调用。
- en: 'You''re probably thinking, what is the benefit of passing getter and setter
    calls to the delegate? Only the delegate you''re using can answer this question.
    Kotlin has multiple predefined standard delegations for most common use cases.
    Let''s have a look at the following list, containing available standard delegates:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能正在想，将获取器和设置器调用传递给委托有什么好处？只有你使用的委托才能回答这个问题。Kotlin 为大多数常见用例提供了多个预定义的标准委托。让我们看一下以下列表，其中包含可用的标准委托：
- en: The `Delegates.notNull` function and `lateinit`
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delegates.notNull` 函数和 `lateinit`'
- en: The `lazy` function
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`lazy` 函数'
- en: The `Delegates.Observable` function
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delegates.Observable` 函数'
- en: The `Delegates.vetoble` function
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Delegates.vetoble` 函数'
- en: The Delegates.notNull function and lateinit
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '`Delegates.notNull` 函数和 `lateinit`'
- en: Think of a situation where you need to declare a property at the class level,
    but you don't have the initial value for the variable there. You'll get the value
    at some later point, but before the property is actually used, and you're confident
    that the property will get initialised before using and it'll not be null. But,
    as per Kotlin syntax, you must initialize a property at the time of initializing.
    The quick fix is to declare it as a `nullable var` property, and assign a default
    null value. But as we mentioned earlier, since you are confident that the variable
    will not be null while using it, you are not willing to declare it as nullable.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个场景，你需要在一个类级别上声明一个属性，但你没有那里变量的初始值。你将在稍后某个时刻得到这个值，但在属性实际使用之前，你确信属性将在使用之前初始化，并且它不会是
    null。但是，根据 Kotlin 语法，你必须初始化属性。快速修复方法是将其声明为 `nullable var` 属性，并分配一个默认的 null 值。但是，如我们之前提到的，由于你确信变量在使用时不会是
    null，你不愿意将其声明为可空。
- en: '`Delegates.notNull` is here to save you in this scenario. Have a look at the
    following program:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delegates.notNull` 函数就是为了在这种情况下帮助你。看看以下程序：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Focus on the first line—`var notNullStr:String by Delegates.notNull<String>()`,
    we declared a non-null `String var` property, but we didn't initialize it. Instead,
    we wrote `by Delegates.notNull<String>()`, but what does it mean? Let us inspect.
    The `by` operator is a reserved keyword in Kotlin, to be used with delegates.
    The `by` operator works with two operands, on the left-hand side of `by` will
    be the property/class that needs to be delegated, and on the right-hand side will
    be the delegate.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 关注第一行——`var notNullStr:String by Delegates.notNull<String>()`，我们声明了一个非空的 `String
    var` 属性，但没有初始化它。相反，我们写了 `by Delegates.notNull<String>()`，但这是什么意思？让我们检查一下。`by`
    操作符是 Kotlin 中的一个保留关键字，用于与委托一起使用。`by` 操作符与两个操作数一起工作，`by` 的左侧将是需要委托的属性/类，而右侧将是委托。
- en: The delegate—`Delegates.notNull` allows you to temporarily go without initializing
    the property. It must be initialized before it is used (as we did on the very
    first line of the `main` method), otherwise it'll throw an exception.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 委托——`Delegates.notNull` 允许你在不初始化属性的情况下暂时使用。它必须在使用之前初始化（就像我们在 `main` 方法的第一行所做的那样），否则它将抛出异常。
- en: 'So, let''s modify the program by adding another property, which we will not
    initialize before using it, and see what happens:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过添加另一个属性来修改程序，我们将在使用之前不初始化它，看看会发生什么：
- en: '[PRE1]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The output looks like the following:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 输出看起来如下：
- en: '![](img/562500f7-04ce-47e2-97b1-5eca2ded726f.png)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/562500f7-04ce-47e2-97b1-5eca2ded726f.png)'
- en: So, the `notInit` property caused the exception—`Property notInit should be
    initialized before get`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`notInit` 属性导致了异常——`属性 notInit 应在使用前初始化`。
- en: But doesn't the variable declaration—`by Delegates.notNull()` sound awkward?
    The Kotlin team also thought the same way. That's why from Kotlin 1.1 they added
    a simple keyword—`lateinit`, to achieve the same objective. As it simply states
    about late initialization, it should be simply `lateinit`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，变量声明——`by Delegates.notNull()`听起来不是很顺耳吗？Kotlin 团队也这样认为。这就是为什么从 Kotlin 1.1
    开始，他们添加了一个简单的关键字——`lateinit`，以实现相同的目标。正如它简单说明了延迟初始化，它应该简单地是 `lateinit`。
- en: 'So, let''s modify the last program by replacing `by Delegates.notNull()` with
    `lateinit`. The following is the modified program:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过将 `by Delegates.notNull()` 替换为 `lateinit` 来修改最后一个程序。以下是修改后的程序：
- en: '[PRE2]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this program, we had to rename the variables, as you can't have two top-level
    (package-level variable, without any class/function) variables of the same name.
    Except variable names, the only thing that changed is we added `lateinit`, instead
    of `by Delegates.notNull()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们必须重命名变量，因为你不能有两个同名的顶级（包级变量，没有任何类/函数）。除了变量名外，唯一改变的是我们添加了 `lateinit`，而不是
    `by Delegates.notNull()`。
- en: 'So, now let''s have a look at the following output to identify if there''s
    any change:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在让我们看一下以下输出，以确定是否有任何变化：
- en: '![](img/0bb69276-a4e0-4be2-8f3a-4bed42942b3a.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0bb69276-a4e0-4be2-8f3a-4bed42942b3a.png)'
- en: The output is also identical, except it slightly changes the error message.
    It now says, `lateinit property notInit1 has not been initialized`.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 输出也是相同的，除了它稍微改变了错误信息。现在它说，`lateinit 属性 notInit1 尚未初始化`。
- en: The lazy function
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 懒加载函数
- en: The `lateinit` keyword works only on the `var` properties. The `Delegates.notNull()` 
    function works properly only with `var` properties, too.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`lateinit` 关键字仅适用于 `var` 属性。`Delegates.notNull()` 函数也仅与 `var` 属性配合使用。'
- en: So, what should we do when using `val` properties? Kotlin provides you with
    another delegation—`lazy`, that's meant for `val` properties only. But it works
    in a slightly different way.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，当使用 `val` 属性时，我们应该怎么做呢？Kotlin 为你提供了另一个委托——`lazy`，它仅适用于 `val` 属性。但它的工作方式略有不同。
- en: Unlike `lateinit` and `Delegates.notNull()`, you must specify how you want to
    initialize the variable at the time of declaration. So, what's the benefit? The
    initialization will not be called until the variable is actually used. That's
    why this delegate is called `lazy`; it enables lazy initialization of properties.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `lateinit` 和 `Delegates.notNull()` 不同，你必须在声明变量时指定你想要如何初始化变量。那么，有什么好处呢？初始化将不会在变量实际使用之前调用。这就是为什么这个委托被称为
    `lazy`；它允许属性的延迟初始化。
- en: 'The following is a code example:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个代码示例：
- en: '[PRE3]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So in this program, we declared a `String val` property—`myLazyVal` with a `lazy`
    delegate. We used (printed) that property in the second line of the `main` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这个程序中，我们声明了一个 `String val` 属性——`myLazyVal`，并使用（打印）了该属性在 `main` 函数的第二行。
- en: Now, let's focus on the variable declaration. The `lazy` delegate accepts a
    lambda that's expected to return the value of the property.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于变量声明。`lazy` 委托接受一个 lambda，该 lambda 预期返回属性的值。
- en: 'So, let''s have a look at the output:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们看看输出结果：
- en: '![](img/e9487a37-2d5f-4e9d-bd10-d85cb1c96271.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![](img/e9487a37-2d5f-4e9d-bd10-d85cb1c96271.png)'
- en: Notice that the output clearly shows that the property got initialized after
    the first line of the `main` method executed, that is, when the property was actually
    used. This `lazy` initialization of properties can save your memory by a significant
    measure. It also comes as a handy tool in some situations, for example, think
    of a situation where you want to initialize the property with some other property/context,
    which would be available only after a certain point (but you have the property
    name); in that situation, you can simply keep the property as `lazy`, and then
    you can use it when it's confirmed that the initialization will be successful.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，输出清楚地显示，属性是在 `main` 方法的第一行执行后初始化的，即当属性实际上被使用时。这种属性的 `lazy` 初始化可以显著节省内存。在某些情况下，它也是一个方便的工具，例如，想象一下你想要使用其他属性/上下文来初始化属性，而这些属性/上下文只有在某个特定点之后才可用（但你已经有了属性名）；在这种情况下，你可以简单地保持属性为
    `lazy`，然后当确认初始化将成功时再使用它。
- en: Observing property value change with Delegates.Observable
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 `Delegates.observable` 观察属性值变化
- en: Delegates are not only for initializing properties lately/lazily. As we learned,
    delegation enables the forwarding of getter and setter calls of a property to
    the delegate. This enables delegates to offer more cool features than just lately/lazily
    initialization.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 委托不仅用于最近/延迟初始化属性。正如我们所学的，委托允许将属性的获取器和设置器调用转发到委托。这使得委托能够提供比最近/延迟初始化更多的酷炫功能。
- en: One such cool feature comes with `Delegates.observable`. Think of a situation
    where you need to look out for the value change of a property, and perform some
    action as soon as this occurs. The immediate solution that comes to our mind is
    to override the setter, but this would look nasty and make codes complex, whereas
    delegates are there to save our life.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样一个酷炫的功能来自于 `Delegates.observable`。想象一下，你需要监视一个属性值的改变，并在这种改变发生时立即执行某些操作。我们首先想到的解决方案是重写设置器，但这会使代码显得很糟糕，并且使代码变得复杂，而委托正是为了拯救我们。
- en: 'Have a look at the following example:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的例子：
- en: '[PRE4]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: It's a simple example, we declared a `String` property—`myStr`, with the help
    of `Delegates.observable` (we will describe that initialization soon after having
    a look at the output), then, inside the `main` function, we changed the value
    of `myStr` twice.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的例子，我们使用 `Delegates.observable` 声明了一个 `String` 属性——`myStr`（我们将在查看输出后不久描述这种初始化），然后，在
    `main` 函数内部，我们两次改变了 `myStr` 的值。
- en: 'Have a look at the following output:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的输出：
- en: '![](img/29f2b91e-fc1f-4b14-bc94-732c2397b7ef.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![](img/29f2b91e-fc1f-4b14-bc94-732c2397b7ef.png)'
- en: 'In the output, we can see, that for both times we changed the value, a log
    got printed with the old and new value of the property. The `Delegates.observable`
    block in this program is responsible for that log in the output. So now, let''s
    have a close look at the `Delegates.observable` block and understand how it works:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在输出中，我们可以看到，每次我们更改值时，都会打印出属性的旧值和新值。这个程序中的 `Delegates.observable` 块负责输出中的日志。所以现在，让我们仔细看看
    `Delegates.observable` 块，并了解它是如何工作的：
- en: '[PRE5]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `Delegates.observable` function takes two parameters to create the delegate.
    The first argument is the initial value of the property, and the second argument
    is the lambda that should be executed whenever the value change is noticed.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delegates.observable` 函数接受两个参数来创建委托。第一个参数是属性的初始值，第二个参数是每当检测到值变化时应执行的 lambda。'
- en: 'The lambda for `Delegates.observable` expects three parameters:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delegates.observable` 的 lambda 预期有三个参数：'
- en: The first one is an instance of `KProperty<out R>`
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个是一个 `KProperty<out R>` 的实例
- en: '`KProperty` is an interface in the Kotlin `stdlib`, `kotlin.reflect` package,
    it is a property; such as a named `val` or `var` declaration. Instances of this
    class are obtainable by the `::` operator. For more information, visit: [https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/.](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/)'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`KProperty` 是 Kotlin `stdlib` 和 `kotlin.reflect` 包中的一个接口，它是一个属性；例如一个命名的 `val`
    或 `var` 声明。这个类的实例可以通过 `::` 操作符获取。更多信息，请访问：[https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.reflect/-k-property/)'
- en: The second parameter contains the old value of the property (the last value
    just before the assignment)
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二个参数包含属性的旧值（分配前的最后一个值）
- en: The third parameter is the newest value assigned to the property (the new value
    used in the assignment)
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第三个参数是分配给属性的最新值（在分配中使用的新值）
- en: So, as we've got the concept of `Delegates.observable`, let's move ahead with
    a new delegate, `Delegates.vetoable`.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了`Delegates.observable`的概念，那么让我们继续使用一个新的委托，`Delegates.vetoable`。
- en: The power of veto – Delegates.vetoable
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 否决权 - Delegates.vetoable
- en: '`Delegates.vetoable` is another standard delegate that allows us to veto a
    value change.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delegates.vetoable`是另一个标准委托，它允许我们否决值的变化。'
- en: 'A **veto**, Latin for *I forbid,* is the power (for example, used by an officer
    of the state) to unilaterally stop an official action. There is more information
    here: [https://en.wikipedia.org/wiki/Veto](https://en.wikipedia.org/wiki/Veto).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**否决权**，拉丁语为“我禁止”，是指单方面停止官方行动的权力（例如，由国家官员使用）。更多信息请参阅：[https://en.wikipedia.org/wiki/Veto](https://en.wikipedia.org/wiki/Veto)。'
- en: This right to veto allows us to have a logic check on each assignment of the
    property, where we can decide to continue with the assignment or not.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这种否决权允许我们对属性的每一项分配进行逻辑检查，我们可以决定是否继续分配。
- en: 'The following is an example:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个示例：
- en: '[PRE6]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this program, we created an `Int` property—`myIntEven`; this property should
    only accept even numbers as an assignment. The `Delegates.vetoable` delegate works
    almost the same as the `Delegates.observable` function, just there's a small change
    in the lambda. Here, the lambda is expected to return a Boolean; the assignment
    would be passed if that returned Boolean is `true`, else the assignment would
    be dismissed.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了一个`Int`属性—`myIntEven`；这个属性应该只接受偶数作为分配。`Delegates.vetoable`委托的工作方式几乎与`Delegates.observable`函数相同，只是在lambda中有细微的变化。在这里，lambda预期返回一个布尔值；如果返回的布尔值为`true`，则分配会被传递，否则分配会被拒绝。
- en: Have a look back at the program. While declaring the variable with the delegate
    `Delegates.vetoable`, we passed `0` as the initial value, then, in the lambda,
    we logged an assignment call, then we will return `true` if the new value is even
    and `false` if odd.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾一下程序。当我们使用`Delegates.vetoable`委托声明变量时，我们传递了`0`作为初始值，然后在lambda中记录了一个分配调用，然后如果新值是偶数，我们将返回`true`，如果是奇数则返回`false`。
- en: 'Here is the output:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出：
- en: '![](img/132e0642-60b1-4e3f-afb3-49aa4632b57d.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/132e0642-60b1-4e3f-afb3-49aa4632b57d.png)'
- en: So, in the output, we can see two logs of assignment, but when we printed the `myIntEven`
    property after the last assignment, we can see the last assignment wasn't successful.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在输出中，我们可以看到两个分配日志，但当我们打印最后分配后的`myIntEven`属性时，我们可以看到最后的分配并没有成功。
- en: 'Interesting, isn''t it? Let us see another example of `Delegates.vetoable`.
    Have a look at the following code:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣，不是吗？让我们看看`Delegates.vetoable`的另一个示例。看看以下代码：
- en: '[PRE7]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This program has a property—`myCounter`, which is expected to increase with
    each assignment.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这个程序有一个属性—`myCounter`，它预期在每次分配时增加。
- en: 'In the lambda, we checked if the `newValue` value is greater than the `oldValue` value.
    Here is the output:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在lambda中，我们检查`newValue`值是否大于`oldValue`值。以下是输出：
- en: '![](img/a5ef800e-3e61-4f75-8dbe-9efbb6620ca0.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a5ef800e-3e61-4f75-8dbe-9efbb6620ca0.png)'
- en: The output which shows those assignments where the value was increased was successful,
    but those where the value decreased got dismissed.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 显示那些值增加的分配的输出是成功的，但那些值减少的分配被拒绝了。
- en: Even when we used the increment and decrement operators, the increment operator
    was successful, but the decrement operator wasn't. This feature wouldn't be that
    easy to implement without delegates.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 即使当我们使用了递增和递减运算符时，递增运算符是成功的，但递减运算符却没有。没有委托，这个特性不会那么容易实现。
- en: Delegated map
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托映射
- en: 'So, we learned how to use standard delegates, but Kotlin has to offer more
    with delegation. The map delegation is among those awesome features that comes
    with delegation. So, what is it? It is the freedom of passing a map as a single
    parameter instead of numbers of parameters in a function/class constructor. Let''s
    have a look. The following is a program applying *map delegation*:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们学习了如何使用标准委托，但Kotlin必须提供更多关于委托的功能。映射委托是委托带来的那些令人惊叹的功能之一。那么，它是什么呢？它是在函数/类构造函数中传递一个映射作为单个参数，而不是传递多个参数的自由。让我们看看。以下是一个应用*映射委托*的程序：
- en: '[PRE8]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The program is simple enough; we defined a `Book` data class, and in the constructor,
    instead of taking all member values one by one, we took a map and then delegated
    all to the map delegate.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 程序足够简单；我们定义了一个 `Book` 数据类，并在构造函数中，我们不是逐个取成员值，而是取一个映射，然后将所有值委托给映射代理。
- en: One thing to be cautious here is to mention all member variables in the map,
    and the key name should exactly match the property name.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的一点是，在映射中提到所有成员变量，并且键名应与属性名完全匹配。
- en: 'Here is the output:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/01d55125-05ae-49c3-a258-dbc919e5606d.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/01d55125-05ae-49c3-a258-dbc919e5606d.png)'
- en: Simple enough, isn't it? Yes, delegations are that much powerful. But are you
    curious about what will happen if we skip mentioning any of the properties in
    the map? It will simply avoid the properties you skipped, and if you explicitly
    try to access them, then it'll throw an exception—`java.util.NoSuchElementException`.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 简单吧？是的，代理就是这样强大。但你有没有好奇如果我们省略了映射中提到的任何属性会发生什么？它将简单地跳过你省略的属性，如果你明确尝试访问它们，那么它将抛出一个异常—`java.util.NoSuchElementException`。
- en: Custom delegation
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义代理
- en: So far in this chapter, we have seen the standard delegations available with
    Kotlin. However, Kotlin does allow us to write our own custom delegates, to suit
    our custom needs.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在本章中，我们已经看到了 Kotlin 中可用的标准代理。然而，Kotlin 允许我们编写自己的自定义代理，以满足我们的特定需求。
- en: For example, in the program, where we checked for the `Even` with `Delegates.vetoable`,
    we could only discard the value assignment, but there's no way to automatically
    assign the next even number to the variable.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在程序中，当我们使用 `Delegates.vetoable` 检查 `Even` 时，我们只能丢弃值赋值，但无法自动将下一个偶数赋值给变量。
- en: In the following program, we used `makeEven`, a custom delegate which would
    automatically assign the next even number if an odd number is passed to the assignment,
    otherwise if an even number is passed to the assignment, it would pass that.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的程序中，我们使用了 `makeEven`，一个自定义代理，如果传递给赋值的数字是奇数，它会自动分配下一个偶数，否则如果传递给赋值的数字是偶数，它会传递那个数字。
- en: 'Have a look at the following program:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的程序：
- en: '[PRE9]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here is the output:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是输出结果：
- en: '![](img/59858d6f-3f44-44e2-9a36-1fbbd54cfd42.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/59858d6f-3f44-44e2-9a36-1fbbd54cfd42.png)'
- en: The output clearly shows that whenever we assigned an even number to `myEven`,
    it got assigned, but when we assigned an odd number, the next even number (`+1`)
    got assigned.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 输出清楚地显示，每次我们将偶数分配给 `myEven` 时，它都会被分配，但当我们分配奇数时，下一个偶数（`+1`）会被分配。
- en: For this delegate, we used almost the same lambda as the `Delegates.observable` we
    just added one more parameter—`wasEven:Boolean`, which will contain `true` if
    the assigned number was even, or `false` otherwise.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个代理，我们使用了与 `Delegates.observable` 几乎相同的 lambda 表达式，只是增加了一个额外的参数—`wasEven:Boolean`，如果分配的数字是偶数，则包含
    `true`，否则包含 `false`。
- en: 'Eager to know how we created the delegate? Here is the code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 想知道我们是如何创建代理的吗？以下是代码：
- en: '[PRE10]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: For creating a delegate on `var` properties, you need to implement the `ReadWriteProperty`
    interface.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `var` 属性上创建代理，你需要实现 `ReadWriteProperty` 接口。
- en: That interface has two functions to be overridden—`getValue` and `setValue`.
    These functions are actually delegated functions of the getters and setters of
    the property. You can return your desired value from the `getValue` function,
    which will then be forwarded as the return value of the property. Every time the
    property is accessed, the `getValue` function will be called. Similarly, every
    time the property is assigned a value, the `setValue` function will get called,
    and whatever we return from the `setValue` function will actually be the value
    the property is finally assigned. For example, assume a property `a` is assigned `X`,
    but from the `setValue` function, we returned `Y`, so after the assignment statement,
    the property `a` will actually hold `Y` instead of `X`.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 该接口有两个需要重写的方法—`getValue` 和 `setValue`。这些函数实际上是属性的获取器和设置器的委托函数。你可以从 `getValue`
    函数返回你想要的价值，然后它将被转发为属性的返回值。每次访问属性时，都会调用 `getValue` 函数。同样，每次属性被分配值时，`setValue` 函数都会被调用，我们从
    `setValue` 函数返回的任何内容实际上就是属性最终分配的值。例如，假设属性 `a` 被分配了 `X`，但从 `setValue` 函数返回了 `Y`，那么在赋值语句之后，属性
    `a` 实际上会持有 `Y` 而不是 `X`。
- en: So, if you want to return the property's value from your delegate's `getValue`
    function, you must keep the value of the property stored somewhere (yes, you would
    not be able to pull the value from the original property, maybe because the original
    property will not even store the value, as the property knows that it would be
    delegated). In this program, we used a mutable `var` property—`value`, to store
    the value of the property. We are returning `value` from the `getValue` function.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想从委托的 `getValue` 函数返回属性的值，你必须将属性的值存储在某个地方（是的，你将无法从原始属性中获取值，可能是因为原始属性甚至不会存储值，因为属性知道它将被委托）。在这个程序中，我们使用了一个可变的
    `var` 属性——`value`，来存储属性的值。我们从 `getValue` 函数返回 `value`。
- en: Inside the `setValue` function, we checked whether the assigned `newValue` is
    even or not. If even, we assigned that `newValue` to the value property (which
    will be returned from the `getValue` function), and if the `newValue` is odd,
    we assigned `newValue+1` to the `value` property.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `setValue` 函数内部，我们检查分配的 `newValue` 是否为偶数。如果是偶数，我们将 `newValue` 分配给 `value`
    属性（它将来自 `getValue` 函数），如果 `newValue` 是奇数，我们将 `newValue+1` 分配给 `value` 属性。
- en: In the `MakeEven` class, we have an abstract function—`afterAssignmentCall`.
    We called this function during the end of the `setValue` function. This function
    is meant for logging purposes.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MakeEven` 类中，我们有一个抽象方法——`afterAssignmentCall`。我们在 `setValue` 函数的末尾调用了这个方法。这个方法是为了日志记录目的。
- en: 'So, the delegate is almost ready, but what about the abstract function? We
    need to extend this class to apply the delegate, right? But remember the code
    where we used it like `by makeEven(0) {...}`, so there must be a function there,
    mustn''t there? Yes, there''s a function, the following is the definition:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，委托几乎已经准备好了，但抽象方法怎么办？我们需要扩展这个类来应用委托，对吧？但记住我们使用它的代码，像 `by makeEven(0) {...}`，所以那里必须有一个函数，不是吗？是的，有一个函数，以下是其定义：
- en: '[PRE11]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We created an anonymous object of `MakeEven` and passed it as a delegate, and
    we passed the argument lambda—`onAssignment`, as the abstract function—`afterAssignmentCall`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个 `MakeEven` 的匿名对象，并将其作为委托传递，并将参数 lambda——`onAssignment`，作为抽象函数——`afterAssignmentCall`
    传递。
- en: So, we've got to grip with delegates, let's move ahead and try our hands on
    some more interesting aspects of delegates.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，我们必须掌握委托，让我们继续前进，尝试一些关于委托的更有趣的方面。
- en: Local delegates
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 局部委托
- en: 'Delegation is powerful, we''ve already seen that, but think of a common situation
    where inside a method we declare and initialize a property, then we apply a logic
    which will either use the property or will continue without it. For example, the
    following is such a program:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 委托很强大，我们已经看到了这一点，但想想一个常见的情况，在方法内部我们声明并初始化一个属性，然后应用一个逻辑，这个逻辑要么使用属性，要么不使用它继续执行。例如，以下是这样的程序：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In this program, we will use the `localDelegate` property, only if the `shouldPrint` value
    is `true`, else we won't use it. But it would always take space in memory since
    it is declared and initialized. An option to avoid this memory blockage is to
    have the property inside the `if` block, but it's a simple dummy program, and
    here we can easily afford to move the variable declaration inside the `if` block,
    whereas in many real-life scenarios, moving the variable declaration inside the `if`
    block is not possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们将使用 `localDelegate` 属性，只有当 `shouldPrint` 的值为 `true` 时，否则我们不会使用它。但因为它被声明并初始化，所以它总是会占用内存空间。避免这种内存阻塞的一个选项是将属性放在
    `if` 块内部，但这是一个简单的示例程序，在这里我们可以轻松地将变量声明移动到 `if` 块内部，而在许多现实场景中，将变量声明移动到 `if` 块内部是不可能的。
- en: So, what's the solution? Yes, using `lazy` delegation can save our life here.
    But it wasn't possible in Kotlin before the arrival of Kotlin 1.1.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，解决方案是什么？是的，使用 `lazy` 委托可以拯救我们的生命。但在 Kotlin 1.1 之前，这是不可能的。
- en: 'So, the following is the updated program:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，以下是一个更新的程序：
- en: '[PRE13]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Though we only used `lazy` for this example, from Kotlin 1.1, we can have any
    delegation applied in local properties.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们在这个例子中只使用了 `lazy`，但从 Kotlin 1.1 开始，我们可以在局部属性中应用任何委托。
- en: Class delegation
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类委托
- en: Class delegation is another interesting feature of Kotlin. How? Just think of
    the following situation.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 类委托是 Kotlin 的另一个有趣特性。如何？只需想想以下情况。
- en: You have an interface, *I*, and two classes, *A* and *B*. Both *A* and *B* implement *I*.
    In your code, you've an instance of *A* and you want to create an instance of
    *B* from that *A*.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个接口，`I`，以及两个类，`A` 和 `B`。`A` 和 `B` 都实现了 `I` 接口。在你的代码中，你有一个 `A` 的实例，并且想要从这个
    `A` 实例创建一个 `B` 的实例。
- en: In traditional inheritance, it is not directly possible; you have to write a
    bunch of nasty codes to achieve that, but class delegation is there to save you.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在传统的继承中，这是不可能直接实现的；你必须编写一大堆糟糕的代码才能达到这个目的，但类委托（class delegation）就是为了解决这个问题而存在的。
- en: 'Go through the following code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是相应的代码：
- en: '[PRE14]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this program, we created the instance of `User`, with its member property—`person`,
    which is an instance of the `Person` interface. In the main function, we passed
    an instance of `PersonImpl` to the user to create the instance of `User`.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们创建了 `User` 的实例，其中包含其成员属性——`person`，它是一个 `Person` 接口的实例。在主函数中，我们将 `PersonImpl`
    的实例传递给 `user` 以创建 `User` 的实例。
- en: Now, have a look at the declaration of `User`. After color (`:`), the phrase
    `Person by person` indicates that the class `User` extends `Person` and is expected
    to copy `Person` behaviors from the provided `person` instance.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `User` 的声明。在颜色（`:`）之后，短语 `Person by person` 表示类 `User` 继承自 `Person`
    类，并且期望从提供的 `person` 实例复制 `Person` 的行为。
- en: 'Here is the output:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是输出结果：
- en: '![](img/47465d12-c4c5-46c2-aeab-eb0f50f470a0.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![](img/47465d12-c4c5-46c2-aeab-eb0f50f470a0.png)'
- en: The output shows the overriding works as expected, and we can also access properties
    and functions of the `person`, just like a normal property.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示了覆盖（overriding）工作如预期进行，我们还可以访问 `person` 的属性和函数，就像访问一个普通属性一样。
- en: A really awesome feature, isn't it?
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 真的是一个很棒的功能，不是吗？
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about delegates and we saw how to use delegates
    in various ways to make our code efficient and clean. We learned about different
    features and parts of delegates, and how to use them.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了代理（delegates），并看到了如何以各种方式使用代理来使我们的代码高效且整洁。我们学习了代理的不同特性和组成部分，以及如何使用它们。
- en: The next chapter is about coroutines, a path-breaking feature of Kotlin, to
    enable seamless asynchronous processing while keeping the developer's life easy
    and straightforward.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍协程，这是 Kotlin 的一个开创性特性，它能够在保持开发者生活简单直接的同时，实现无缝的异步处理。
- en: So, don't wait long, start with the next chapter now.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，不要等待太久，现在就开始下一章吧。
