- en: 'Chapter 3. User Interface: View Controllers'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。用户界面：视图控制器
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Loading a view with a view controller
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用视图控制器加载视图
- en: Navigating through different view controllers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的视图控制器之间导航
- en: Providing controllers in tabs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在标签页中提供控制器
- en: Creating a table controller
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建表格控制器
- en: Modal view controllers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模态视图控制器
- en: Creating a custom view controller
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义视图控制器
- en: Using view controllers efficiently
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高效使用视图控制器
- en: Combining different view controllers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组合不同的视图控制器
- en: iPad view controllers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iPad 视图控制器
- en: Creating a user interface for different devices
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为不同设备创建用户界面
- en: Introduction
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: So far, we have discussed views and how to use them. In most cases of real-world
    application scenarios, views alone are not enough. Apple provides another base
    class, the `UIViewController`, which is responsible for managing views. A view
    controller can respond to device notifications, such as when the device rotates,
    or can provide different ways for displaying and dismissing multiple views or
    even other view controllers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经讨论了视图及其使用方法。在大多数现实世界应用场景中，仅使用视图是不够的。Apple 提供了另一个基类，即 `UIViewController`，它负责管理视图。视图控制器可以响应设备通知，例如当设备旋转时，或者可以提供不同的方式来显示和关闭多个视图，甚至其他视图控制器。
- en: We will also see how to use the most common view controllers to create applications
    that manage multiple views.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将了解如何使用最常用的视图控制器来创建管理多个视图的应用程序。
- en: 'These view controllers are:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这些视图控制器是：
- en: '`UIViewController:` This is the base class of all view controllers'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UIViewController:` 这是所有视图控制器的基类'
- en: '`UINavigationController:` This is the view controller that provides various
    ways of navigating through different view controllers'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UINavigationController:` 这是一个提供多种在不同视图控制器之间导航方式的视图控制器'
- en: '`UITabBarController:` This is a view controller that displays multiple view
    controllers in a tab-like interface'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITabBarController:` 这是一个以标签界面显示多个视图控制器的视图控制器'
- en: '`UITableViewController:` This is a view controller that is used to display
    data in a list form'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`UITableViewController:` 这是一个用于以列表形式显示数据的视图控制器'
- en: '**iPad-specific view controllers:** These are view controllers that only apply
    to the iPad device'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**针对 iPad 的视图控制器:** 这些是仅适用于 iPad 设备的视图控制器'
- en: Furthermore, we will discuss combining different controllers, how to create
    custom controllers and use them, and we will create an application that can be
    deployed in both the iPhone and iPad.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将讨论组合不同的控制器，如何创建自定义控制器并使用它们，以及我们将创建一个可以在 iPhone 和 iPad 上部署的应用程序。
- en: Loading a view with a view controller
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用视图控制器加载视图
- en: In this recipe, we will learn how to use the `UIViewController` class to manage
    views.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 `UIViewController` 类来管理视图。
- en: Getting ready
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPhone empty project in MonoDevelop, and name it `ViewControllerApp`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的 iPhone 空项目，并将其命名为 `ViewControllerApp`。
- en: How to do it...
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add a new file to the project.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新文件。
- en: Right-click on the project in the **Solution** pad and select **Add | New File**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击 **Solution** 面板中的项目，并选择 **Add | New File**。
- en: In the dialog box that will appear, select **iPhone View** with **Controller**
    from the **MonoTouch** section. Name it `MainViewController`, and click on the
    **New** button. MonoDevelop will create a new `XIB` file and will automatically
    open the `MainViewController.cs` source file. This file contains a class that
    overrides the `UIViewController`, and we can implement any code related to our
    view controller in it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在出现的对话框中，从 **MonoTouch** 部分选择 **iPhone View** 并带有 **Controller**，将其命名为 `MainViewController`，然后点击
    **New** 按钮。MonoDevelop 将创建一个新的 `XIB` 文件，并自动打开 `MainViewController.cs` 源文件。此文件包含一个覆盖
    `UIViewController` 的类，我们可以在其中实现与我们的视图控制器相关的任何代码。
- en: Open the `MainViewController.xib` file in Interface Builder.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `MainViewController.xib` 文件。
- en: Add a `UILabel` on the view.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在视图中添加一个 `UILabel`。
- en: Create and connect an outlet for it inside the `MainViewController` class, and
    name it `myLabel`.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewController` 类中创建并连接一个出口，并将其命名为 `myLabel`。
- en: Enter the text `View in controller!` in the label.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签中输入文本 `View in controller!`。
- en: Save the `XIB` document.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存 `XIB` 文档。
- en: 'Back in MonoDevelop, enter the following code in the `FinishedLaunching()`
    method:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中返回，并在 `FinishedLaunching()` 方法中输入以下代码：
- en: '[PRE0]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Compile and run the application on the simulator.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: How it works...
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'When we add a new **iPhone View with Controller** file in a project, in this
    case `MainViewController`, MonoDevelop basically creates and adds three files:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在项目中添加一个新的**iPhone View with Controller**文件时，在这种情况下是`MainViewController`，MonoDevelop基本上创建并添加了三个文件：
- en: '`MainViewController.xib:` This is the XIB file that contains the controller.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainViewController.xib`：这是包含控制器的XIB文件。'
- en: '`MainViewController.cs:` This is the C# source file that implements the class
    of our controller.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainViewController.cs`：这是实现我们控制器类的C#源文件。'
- en: '`MainViewController.designer.cs:` This is the auto-generated source file that
    reflects the changes we make to the controller in Interface Builder.'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MainViewController.designer.cs`：这是自动生成的源文件，反映了我们在Interface Builder中对控制器所做的更改。'
- en: 'Notice that we do not need to add an outlet for the view, since this is taken
    care of by MonoDevelop. We initialize the controller through its class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不需要为视图添加一个出口，因为这是由MonoDevelop处理的。我们通过其类初始化控制器：
- en: '[PRE1]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, we display its view through the controller''s `View` by setting it as
    the `RootViewController` of our application''s window:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们通过控制器中的`View`显示其视图，将其设置为应用程序窗口的`RootViewController`：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: There's more...
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The project we have just created only shows how we can add a controller with
    a view. Notice that we created the outlet for the label inside the `MainViewController`
    class, which acts as the file''s owner object in the `XIB` file. To provide some
    functionality for the `MainViewController`, add the following method in the `MainViewController`
    class in the `MainViewController.cs` file:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建的项目仅展示了我们如何添加一个带有视图的控制器。注意，我们在`MainViewController`类内部创建了标签的出口，该类在`XIB`文件中充当文件的所有者对象。为了为`MainViewController`提供一些功能，在`MainViewController.cs`文件中的`MainViewController`类中添加以下方法：
- en: '[PRE3]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This method overrides the `UIViewController.ViewDidLoad()` method, which is
    executed when the controller loads its view.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法覆盖了`UIViewController.ViewDidLoad()`方法，该方法在控制器加载其视图时执行。
- en: UIViewController methods to override
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 要覆盖的`UIViewController`方法
- en: 'The methods that the `UIViewController` class contains are the ones that we
    override to use its features. Some of these methods are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`UIViewController`类包含的方法是我们覆盖以使用其功能的方法。其中一些方法包括：'
- en: '`ViewDidUnload():` It is called when the view is unloaded'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidUnload()`：当视图被卸载时调用'
- en: '`ViewWillAppear():` It is called when the view is about to appear on the screen'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillAppear()`：当视图即将在屏幕上显示时调用'
- en: '`ViewDidAppear():` It is called when the view has been displayed'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewDidAppear()`：当视图已显示时调用'
- en: '`ViewWillDisappear():` It is called when the view is about to disappear, for
    example, when another controller is about to be displayed `ViewDidDisappear():`
    It is called when the view has disappeared'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewWillDisappear()`：当视图即将消失时调用，例如，当另一个控制器即将显示时`ViewDidDisappear()`：当视图消失时调用'
- en: See also
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Navigating through different view controllers*'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同的视图控制器之间导航*'
- en: 'In this book:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '[第1章](ch01.html "第1章。开发工具"),开发工具：'
- en: '*Creating an iPhone project with MonoDevelop*'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用MonoDevelop创建iPhone项目*'
- en: '*Accessing the UI with outlets*'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过出口访问UI*'
- en: Navigating through different view controllers
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同的视图控制器之间导航
- en: In this recipe, we will learn how to use the `UINavigationController` class
    to navigate among multiple view controllers.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用`UINavigationController`类在多个视图控制器之间导航。
- en: Getting ready
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UINavigationController` is a controller that provides a hierarchical navigation
    functionality with multiple view controllers. Create a new iPhone empty project
    in MonoDevelop, and name it `NavigationControllerApp`.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController`是一个提供具有多个视图控制器的分层导航功能的控制器。在MonoDevelop中创建一个新的iPhone空项目，并将其命名为`NavigationControllerApp`。'
- en: How to do it...
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add three new **iPhone View with Controller** files in the project, and name
    them `RootViewController, ViewController1`, and `ViewController2`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加三个新的**iPhone View with Controller**文件，并分别命名为`RootViewController, ViewController1`和`ViewController2`。
- en: 'Add the following field in the `AppDelegate` class:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类中添加以下字段：
- en: '[PRE4]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the same class, add the following code in the `FinishedLaunching` method,
    above the `window.MakeKeyAndVisible()`; line:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，在`FinishedLaunching`方法中，在`window.MakeKeyAndVisible()`行之上添加以下代码：
- en: '[PRE5]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Open the `RootViewController.xib` file in Interface Builder, and add two buttons
    with their corresponding outlets. Set their titles to `First View` and `Second
    View` respectively.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`RootViewController.xib`文件，并添加两个按钮及其相应的出口。分别设置它们的标题为`第一个视图`和`第二个视图`。
- en: Save the document.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: Open both the `ViewController1.xib` and `ViewController2.xib`, and add a button
    in each one with the title `Pop to root`. Do not forget to connect the buttons
    with outlets and save the documents.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewController1.xib`和`ViewController2.xib`，并在每个视图中添加一个标题为`返回根视图`的按钮。不要忘记连接按钮与出口并保存文档。
- en: 'Enter the following code in the `RootViewController` class:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RootViewController`类中输入以下代码：
- en: '[PRE6]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In both `ViewController1` and `ViewController2` classes, enter the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ViewController1`和`ViewController2`类中输入以下内容：
- en: '[PRE7]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Compile and run the application on the simulator. Tap on each of the buttons
    to see and navigate through the available views.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。点击每个按钮以查看和导航到可用的视图。
- en: How it works...
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UINavigationController` preserves a stack of controllers. The `UIViewController`
    class has a property named `NavigationController`. In normal situations, this
    property returns null. But, if the controller is pushed into a navigation controller''s
    stack, it returns the instance of the navigation controller it is being pushed
    in. So this way, at any point in the hierarchy of controllers, access to the navigation
    controller is provided. To display a controller, we call the `UINavigationController.PushViewController(UIViewController,
    bool)` method:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`UINavigationController`保留了一个控制器堆栈。`UIViewController`类有一个名为`NavigationController`的属性。在正常情况下，这个属性返回null。但是，如果控制器被推入导航控制器的堆栈中，它将返回正在推入的导航控制器的实例。因此，这样在任何控制器层次结构中的任何一点，都可以提供对导航控制器的访问。要显示一个控制器，我们调用`UINavigationController.PushViewController(UIViewController,
    bool)`方法：'
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Notice that the `RootViewController` is the topmost or root controller in the
    navigation stack. A navigation controller must have at least one view controller
    that will act as its root controller. We set it when we create the instance of
    the UINavigationController class:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`RootViewController`是导航堆栈中最顶层或根控制器。导航控制器必须至少有一个将充当其根控制器的视图控制器。我们在创建`UINavigationController`类的实例时设置它：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'To return to the root controller, we call the `PopToRootViewController(bool)`
    method inside the current controller:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 要返回根控制器，我们在当前控制器中调用`PopToRootViewController(bool)`方法：
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `bool` parameters in both the methods are used for transitioning between
    controllers with animation.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 两个方法中的`bool`参数用于在控制器之间进行带有动画的转换。
- en: There's more...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this simple example, we provided backward navigation to the root controller
    with buttons. Notice that there is an arrow-shaped button at the top bar. That
    bar is called the **navigation** bar, and is of the type `UINavigationBar`. The
    arrow-shaped button is called the **back** button and is of the type `UIBarButtonItem`.
    The back button, when it exists, always navigates to the previous controller in
    the navigation stack.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，我们通过按钮提供了返回根控制器的导航。注意顶部栏中有一个箭头形状的按钮。那个栏被称为**导航栏**，其类型为`UINavigationBar`。箭头形状的按钮被称为**返回**按钮，其类型为`UIBarButtonItem`。当返回按钮存在时，它总是导航到导航堆栈中的上一个控制器。
- en: Managing navigation bar buttons
  id: totrans-92
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 管理导航栏按钮
- en: 'To change, add, and hide the buttons of the navigation bar, we can use the
    following methods of our currently displayed view controller''s `NavigationItem`
    property:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改、添加和隐藏导航栏的按钮，我们可以使用当前显示的视图控制器的`NavigationItem`属性的以下方法：
- en: '`SetLeftBarButtonItem:` It adds a custom button on the left of the navigation
    bar, replacing the default **Back** button'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetLeftBarButtonItem:` 它在导航栏的左侧添加一个自定义按钮，替换默认的**返回**按钮'
- en: '`SetRightBarButtonItem:` It adds a custom button on the right side of the navigation
    bar'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetRightBarButtonItem:` 它在导航栏的右侧添加一个自定义按钮'
- en: '`SetHidesBackButton:` It sets the visibility of the default **Back** button'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetHidesBackButton:` 它设置默认**返回**按钮的可见性'
- en: To remove or hide the custom left or right buttons on the navigation bar, call
    the appropriate methods, passing `null` instead of a `UIBarButtonItem` object.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要移除或隐藏导航栏上的自定义左侧或右侧按钮，请调用适当的方法，传递`null`而不是`UIBarButtonItem`对象。
- en: See also
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Modal view controllers*'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模态视图控制器*'
- en: '*Using view controllers efficiently*'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效使用视图控制器*'
- en: '*Combining different view controllers*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*结合不同的视图控制器*'
- en: 'In this book:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 11](ch11.html "Chapter 11. Graphics and Animation"),Graphics and Animation:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[第11章](ch11.html "第11章。图形和动画"),图形和动画：'
- en: '*Pushing view controllers with animation*'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用动画推送视图控制器*'
- en: Providing controllers in tabs
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在标签中提供控制器
- en: In this recipe, we will learn how to display multiple view controllers in a
    tabbed interface.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将学习如何在标签界面中显示多个视图控制器。
- en: Getting ready
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UITabBarController` provides a way of displaying different view controllers
    on the same hierarchy level divided into a tab-like interface. Create a new iPhone
    empty project in MonoDevelop, and name it `TabControllerApp`.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController` 提供了一种在相同层次结构级别上显示不同视图控制器的方法，这些控制器被划分为类似标签的界面。在 MonoDevelop
    中创建一个新的 iPhone 空项目，并将其命名为 `TabControllerApp`。'
- en: How to do it...
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: Add two **iPhone View with Controller** files to the project. Name them `MainController`
    and `SettingsController`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 向项目中添加两个 **iPhone View with Controller** 文件。将它们命名为 `MainController` 和 `SettingsController`。
- en: Open both controllers in Interface Builder, and set different background colors
    for their views and save the documents.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开两个控制器，并设置它们视图的不同背景颜色，然后保存文档。
- en: 'Add the following field in the `AppDelegate` class:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中添加以下字段：
- en: '[PRE11]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Enter the following code in the `FinishedLaunching()` method, above the `window.MakeKeyAndVisible()`;
    line:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FinishedLaunching()` 方法中输入以下代码，在 `window.MakeKeyAndVisible()` 行之上：
- en: '[PRE12]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Compile and run the application on the simulator.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: 'Tap on each of the tabs at the bottom of the screen, and see their respective
    views shown. The console output is displayed in the **Application Output** pad
    in MonoDevelop. The following screenshot shows the screen of the simulator, with
    the **Settings** tab selected:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击屏幕底部的每个标签，并查看它们各自显示的视图。控制台输出显示在 MonoDevelop 的 **应用程序输出** 窗格中。以下截图显示了模拟器的屏幕，其中
    **设置** 标签被选中：
- en: '![How to do it...](img/1468EXP_03_01 .jpg)'
  id: totrans-119
  prefs: []
  type: TYPE_IMG
  zh: '![如何做...](img/1468EXP_03_01 .jpg)'
- en: How it works...
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The `UITabBarController` displays one tab for each of the controllers it manages.
    That tab is of the type `UITabBarItem,` and it can accept both text and images.
    The `UITabBarController` class holds information about the controllers it contains.
    We can determine which controller was selected by the user through the `ViewControllerSelected`
    event:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController` 显示它管理的每个控制器的一个标签页。该标签页的类型为 `UITabBarItem`，它可以接受文本和图像。`UITabBarController`
    类包含有关其包含的控制器的信息。我们可以通过 `ViewControllerSelected` 事件确定用户选择了哪个控制器：'
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `UITabBarSelectionEventArgs` object holds an instance of the selected controller
    in the property `ViewController`. By accessing the `UIViewController.TabBarItem`
    property, we can determine which controller was selected:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarSelectionEventArgs` 对象在其 `ViewController` 属性中持有所选控制器的实例。通过访问 `UIViewController.TabBarItem`
    属性，我们可以确定哪个控制器被选中：'
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, we output its `Title` property.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们输出其 `Title` 属性。
- en: Note
  id: totrans-126
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Just like the `UIViewController` class' `NavigationController` property, where
    it returns the instance of the `UINavigationController` it is part of, the `TabBarItem`
    property will hold an instance only when the controller is part of a `UITabBarController`.
    In other cases it will return `null`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 `UIViewController` 类的 `NavigationController` 属性，其中它返回它所属的 `UINavigationController`
    实例一样，`TabBarItem` 属性只有在控制器是 `UITabBarController` 的部分时才会持有实例。在其他情况下，它将返回 `null`。
- en: 'When we initialize the tab controller, we set the controllers it will contain
    through the `SetViewControllers` method, passing an array of view controller objects:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们初始化标签控制器时，我们通过 `SetViewControllers` 方法设置它将包含的控制器，传递一个视图控制器对象的数组：
- en: '[PRE15]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: There's more...
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The controller can accept as many controllers as we want, but if we add six
    or more, four will be displayed with their tabs, while a fifth predefined **More**
    tab will represent all the remaining controllers. That is to keep the interface
    easily accessible by the user, by keeping the tabs to a specific size suitable
    for human fingers. When we add more than six controllers in a tab bar controller
    interface, by default the object provides an **Edit** button on top in the **More**
    tab, which allows the user to rearrange the order of controllers. If we want to
    exclude some controllers from this functionality, we have to remove it from the
    `CustomizableViewControllers` array.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器可以接受我们想要的任意数量的控制器，但如果添加六个或更多，则四个将带有标签显示，而第五个预定义的**更多**标签将代表所有剩余的控制器。这是为了保持界面易于用户访问，通过保持标签到适合人类手指的特定大小。当我们在一个标签栏控制器界面中添加超过六个控制器时，默认情况下，对象在**更多**标签的顶部提供一个**编辑**按钮，允许用户重新排列控制器的顺序。如果我们想排除某些控制器从这个功能中，我们必须从
    `CustomizableViewControllers` 数组中移除它。
- en: Useful UITabBarController properties
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 有用的 UITabBarController 属性
- en: 'Some more useful properties of the `UITabBarController` class are as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITabBarController` 类的一些其他有用属性如下：'
- en: '`ViewControllers:` It returns an array containing all the controllers that
    the tab controller holds'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewControllers:` 返回一个包含所有由标签控制器持有的控制器的数组'
- en: '`SelectedIndex:` It returns the zero-based index of the selected tab'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedIndex:` 返回选中标签的零基索引'
- en: '`SelectedViewController:` It returns the currently selected controller'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SelectedViewController:` 返回当前选中的控制器'
- en: Important note on tab bar interfaces
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于标签栏界面的重要说明
- en: Although we can add whatever type of controllers we want in a `UITabBarController`,
    we must not add a `UITabBarController` in another controller, such as a `UINavigationController`.
    We can, however, add a `UINavigationController` in a `UITabBarController`. This
    is because the tab bar interface is provided for implementing different controllers
    as different application modes and not hierarchical screens.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以在 `UITabBarController` 中添加任何类型的控制器，但我们不能在另一个控制器中添加 `UITabBarController`，例如
    `UINavigationController`。然而，我们可以在 `UITabBarController` 中添加 `UINavigationController`。这是因为标签栏界面是为了实现不同的控制器作为不同的应用程序模式，而不是层次屏幕。
- en: See also
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Using view controllers efficiently*'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效使用视图控制器*'
- en: '*Combining different view controllers*'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*组合不同的视图控制器*'
- en: Creating a table controller
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建表格控制器
- en: In this recipe, we will learn how to create and add a `UITableViewController`
    to a project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建并将 `UITableViewController` 添加到项目中。
- en: Getting ready
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The `UITableViewController` is used to display a `UITableView`. A `UITableView`
    provides an interface for displaying data in a list form. Create a new iPhone
    empty project in MonoDevelop, and name it `TableControllerApp`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `UITableViewController` 来显示 `UITableView`。`UITableView` 提供了一个以列表形式显示数据的界面。在
    MonoDevelop 中创建一个新的 iPhone 空项目，并将其命名为 `TableControllerApp`。
- en: How to do it...
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add an **iPhone View Controller** to the project, and name it `TableController`.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目添加一个**iPhone 视图控制器**，并将其命名为 `TableController`。
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类的 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE16]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Change the inheritance of the `TableController` class from `UIViewController`
    to `UITableViewController:`
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `TableController` 类的继承从 `UIViewController` 改为 `UITableViewController:`
- en: '[PRE17]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Open the `TableController.xib` in Interface Builder, and delete its view by
    selecting it and pressing backspace.
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `TableController.xib`，选择并按退格键删除其视图。
- en: Drag-and-drop a `UITableView` in its place.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `UITableView` 拖放到其位置。
- en: Right-click on the `UITableView` to show the outlet panel.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `UITableView` 以显示输出口面板。
- en: Click-and-drag from the **New Referencing Outlet** to the **File's Owner** object,
    as shown in the following screenshot:![How to do it...](img/1468EXP_03_02.jpg)
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图所示，从**新引用输出口**拖动到**文件所有者**对象：![如何操作...](img/1468EXP_03_02.jpg)
- en: Select view from the small panel that will appear on the **File's Owner** object
    when you release the button. This connects the `UITableView` we have just added
    to the `view` outlet of the **File's Owner** object.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你释放按钮时，从出现的**文件所有者**对象的小面板中选择视图。这连接了我们刚刚添加的 `UITableView` 到**文件所有者**对象的 `view`
    输出口。
- en: Save the document.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档。
- en: How it works...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we add a `UITableView` in an Interface Builder document, its view is displayed
    with some predefined data. The data only appears at design time and not at runtime.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在 Interface Builder 文档中添加一个 `UITableView` 时，其视图会显示一些预定义的数据。这些数据仅在设计时出现，而不是在运行时。
- en: The `UITableViewController` contains a view of the type `UITableView`. This
    view is responsible for displaying the data and can be customized in many ways.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableViewController` 包含一个 `UITableView` 类型的视图。这个视图负责显示数据，并且可以通过多种方式自定义。'
- en: There's more...
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Apart from the `View` property, we can access the view of the `UITableViewController`
    through its `TableView` property. Both properties return the same object.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `View` 属性外，我们还可以通过 `TableView` 属性访问 `UITableViewController` 的视图。这两个属性返回相同的对象。
- en: UITableViewController-specific property
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: '`UITableViewController` 特定属性'
- en: 'The `UITableViewController` has one more property: `ClearsSelectionOnViewWillAppear`.
    When it is set to `true`, the controller will clear the selected row automatically
    whenever the view appears.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`UITableViewController` 有一个额外的属性：`ClearsSelectionOnViewWillAppear`。当它设置为 `true`
    时，控制器将在视图出现时自动清除所选行。'
- en: How to populate data with a `UITableView` is discussed thoroughly in [Chapter
    5](ch05.html "Chapter 5. Displaying Data"),Displaying Data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 如何使用 `UITableView` 填充数据将在 [第 5 章](ch05.html "第 5 章。显示数据") 中详细讨论，显示数据。
- en: See also
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Modal view controllers*'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*模态视图控制器*'
- en: 'In this book:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中：
- en: '[Chapter 5](ch05.html "Chapter 5. Displaying Data"),Displaying Data:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 5 章](ch05.html "第 5 章。显示数据")，显示数据：'
- en: '*Displaying data in a table*'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在表格中显示数据*'
- en: Modal view controllers
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模态视图控制器
- en: In this recipe, we will discuss how to display view controllers modally.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将讨论如何以模态方式显示视图控制器。
- en: Getting ready
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: A **Modal view controller** is any controller that is presented above other
    views or controllers. The concept is similar to displaying a **WinForm** as a
    dialog, which takes control of the interface and does not allow access to other
    windows of the application, unless it is dismissed. Create a new iPhone empty
    project in MonoDevelop, and name it `ModalControllerApp`.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '**模态视图控制器** 是任何显示在其他视图或控制器之上的控制器。这个概念类似于将 **WinForm** 作为对话框显示，它控制界面并阻止访问应用程序的其他窗口，除非它被关闭。在
    MonoDevelop 中创建一个新的 iPhone 空项目，并将其命名为 `ModalControllerApp`。'
- en: How to do it...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Add two views with controllers to the project, and name them `MainController`
    and `ModalController`.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个带有控制器的视图添加到项目中，并分别命名为 `MainController` 和 `ModalController`。
- en: Open the `MainController.xib` file in Interface Builder, and add a button on
    its view with the title `Present`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中打开 `MainController.xib` 文件，并在其视图中添加一个标题为 `Present` 的按钮。
- en: Create and connect the appropriate outlet for the button. Save the document
    and open the `ModalController.xib` file.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建并连接按钮的适当出口。保存文档并打开 `ModalController.xib` 文件。
- en: Add a button on its view with the title `Dismiss`, and create the appropriate
    outlet for it. Set its view's background color to something other than white.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其视图中添加一个标题为 `Dismiss` 的按钮，并为它创建适当的出口。将其视图的背景颜色设置为非白色。
- en: 'Save the document and enter the following code in the `MainController` class:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文档并在 `MainController` 类中输入以下代码：
- en: '[PRE18]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Similarly, override the `ViewDidLoad()` method in the `ModalController` class,
    and enter the following code in it:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，覆盖 `ModalController` 类中的 `ViewDidLoad()` 方法，并在其中输入以下代码：
- en: '[PRE19]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, add code to display the main controller in the `FinishedLaunching()`
    method:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `FinishedLaunching()` 方法中添加代码以显示主控制器：
- en: '[PRE20]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Compile and run the application on the simulator.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the **Present** button and watch the modal controller present itself
    on top of the main controller.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Present** 按钮并观察模态控制器在主控制器之上显示。
- en: Tap on the **Dismiss** button to hide it.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **Dismiss** 按钮以隐藏它。
- en: How it works...
  id: totrans-191
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Each controller object has two methods that handle presenting and dismissing
    controllers modally. In our example, we call the `PresentModalViewController (UIViewController,
    bool)` method to present a controller:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器对象都有两个处理模态显示和关闭控制器的方法。在我们的示例中，我们调用 `PresentModalViewController (UIViewController,
    bool)` 方法来显示控制器：
- en: '[PRE21]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Its first parameter represents the controller we want to display modally, and
    the second parameter determines if we want the presentation to be animated. To
    dismiss the controller, we call its `DismissModalViewControllerAnimated(bool)`
    method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 其第一个参数表示我们想要以模态方式显示的控制器，第二个参数确定我们是否想要动画化显示。要关闭控制器，我们调用其 `DismissModalViewControllerAnimated(bool)`
    方法：
- en: '[PRE22]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It accepts only one parameter that toggles the animation for the dismissal.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 它只接受一个参数，用于切换消失动画。
- en: There's more...
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can define the type of animation for a modal view controller presentation
    with the controller''s `ModalTransitionStyle` property. Enter the following line
    of code before presenting the modal controller:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用控制器的 `ModalTransitionStyle` 属性定义模态视图控制器呈现的动画类型。在呈现模态控制器之前输入以下代码行：
- en: '[PRE23]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The main controller will flip to present the modal controller, giving the impression
    it is attached behind it.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 主控制器将翻转以显示模态控制器，给人一种它附着在其后面的印象。
- en: Accessing a modal controller
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 访问模态控制器
- en: Each controller that presents another controller modally provides access to
    its "child" controller through the `ModalController` property. If you need to
    access this property, make sure to do it before the `DismissModalViewControllerAnimated()`
    method is called.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 每个以模态方式呈现另一个控制器的控制器都通过 `ModalController` 属性提供对其“子”控制器的访问。如果您需要访问此属性，请确保在调用 `DismissModalViewControllerAnimated()`
    方法之前进行操作。
- en: How many modal controllers?
  id: totrans-203
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 有多少模态控制器？
- en: 'In theory, we can present an unlimited number of modal controllers. Of course,
    there are two restrictions on this:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以呈现无限数量的模态控制器。当然，对此有两个限制：
- en: '**Memory is not unlimited:** View controllers consume memory, so the more view
    controllers we present, the worse performance we get.'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**内存不是无限的**：视图控制器会消耗内存，因此我们呈现的视图控制器越多，性能越差。'
- en: '**Bad user experience:** Presenting many controllers modally discomforts the
    user with repetition.'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**糟糕的用户体验**：以模态方式呈现许多控制器会让用户感到不适。'
- en: See also
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Navigating through different view controllers*'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同视图控制器之间导航*'
- en: '*Providing controllers in tabs*'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在标签页中提供控制器*'
- en: 'In this book:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 11](ch11.html "Chapter 11. Graphics and Animation"),Graphics and Animation:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 11 章](ch11.html "第 11 章。图形和动画")，图形和动画：'
- en: '*Pushing view controllers with animation*'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用动画推送视图控制器*'
- en: Creating a custom view controller
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自定义视图控制器
- en: In this recipe, we will learn how to create a subclass of `UIViewController`
    and use it to derive view controllers contained in an `XIB` file.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何创建 `UIViewController` 的子类，并使用它来从 `XIB` 文件中派生视图控制器。
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this task, we will see how to create a custom view controller that will act
    as a base controller, providing common functionality among its inheritors. The
    functionality we will add to our base controller to share with its inheritor classes
    will be to output the current touch position in the **Application Output** pad
    in MonoDevelop. Create a new iPhone empty project in MonoDevelop, and name it
    `CustomControllerApp`.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在本任务中，我们将看到如何创建一个自定义视图控制器，它将充当基控制器，为其继承者提供共同的功能。我们将添加到我们的基控制器以与继承类共享的功能是，在 MonoDevelop
    的 **应用程序输出** 面板上输出当前的触摸位置。在 MonoDevelop 中创建一个新的 iPhone 空项目，并将其命名为 `CustomControllerApp`。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Add a new empty C# class in the project, and name it BaseController.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个新的空 C# 类，并将其命名为 BaseController。
- en: 'Enter the following code in the BaseController.cs file:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 BaseController.cs 文件中输入以下代码：
- en: '[PRE24]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Now, add an **iPhone View with Controller** file to the project, and name it
    `DerivedController`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将一个 **带有控制器的 iPhone 视图** 文件添加到项目中，并将其命名为 `DerivedController`。
- en: 'Change the class it inherits from `UIViewController` to `BaseController` in
    its class definition: `public partial class DerivedController : BaseController`.'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在其类定义中将继承自 `UIViewController` 的类更改为 `BaseController`：`public partial class
    DerivedController : BaseController`。'
- en: 'Finally, add the derived controller''s view to the main window:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将派生控制器的视图添加到主窗口：
- en: '[PRE25]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Compile and run the application on the simulator.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Click-and-drag the mouse pointer on the white surface, and watch MonoDevelop's
    **Application Output** pad displaying the current position of the pointer on the
    simulator's screen.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在白色表面上点击并拖动鼠标指针，观察 MonoDevelop 的 **应用程序输出** 面板显示指针在模拟器屏幕上的当前位置。
- en: How it works...
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'What we have done here is create a base controller class that can be used in
    multiple MonoTouch projects. The functionality we have added to this controller
    is to respond to user touches. Any controller that inherits it will inherit the
    same functionality. The code we have added to create the `BaseController` class
    is fairly simple. The constructor we implemented is merely a copy of the constructors
    that MonoDevelop creates in the class implementations when we add new view controllers
    in a project. There is only one slight modification:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是创建一个可以用于多个MonoTouch项目的基控制器类。我们添加到这个控制器中的功能是响应用户触摸。任何继承它的控制器都将继承相同的功能。我们添加到创建`BaseController`类的代码相当简单。我们实现的构造函数仅仅是MonoDevelop在项目中添加新视图控制器时在类实现中创建的构造函数的副本。这里只有一处细微的修改：
- en: '[PRE26]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This is the base constructor that will get called when we initialize the `DerivedController`
    class with the `new` keyword through our derived object's `DerivedController()`
    constructor.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这是当通过派生对象的`DerivedController()`构造函数使用`new`关键字初始化`DerivedController`类时将被调用的基构造函数。
- en: '[PRE27]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: There's more...
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The derived controller can also be added to another `XIB` file and used directly
    in code through outlets.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 派生控制器也可以添加到另一个`XIB`文件中，并通过出口直接在代码中使用。
- en: Subclassing view controllers from XIBs
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从XIB继承视图控制器
- en: If we would like to create a base controller that derives from a controller
    contained in an `XIB` file, the process is similar.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要创建一个从包含在`XIB`文件中的控制器派生的基控制器，过程是类似的。
- en: See also
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Loading a view with a controller*'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用控制器加载视图*'
- en: '*Using view controllers efficiently*'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效使用视图控制器*'
- en: 'In this book:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 2](ch02.html "Chapter 2. User Interface: Views"),User Interface: Views:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '[第二章](ch02.html "第二章. 用户界面：视图"),用户界面：视图：'
- en: '*Adding and customizing views*'
  id: totrans-243
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*添加和自定义视图*'
- en: Using view controllers efficiently
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高效使用视图控制器
- en: In this recipe, we will learn about the basic guidelines on efficient view controller
    usage.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将学习关于高效使用视图控制器的基本指南。
- en: Getting ready
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Open the project `TabControllerApp` we created in the recipe *Providing controllers
    in tabs* earlier in this chapter.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 打开我们在本章前面“在标签中提供控制器”食谱中创建的项目`TabControllerApp`。
- en: How to do it...
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: Open the `MainController.xib` file in Interface Builder, and add a `UIButton`
    and a `UILabel`. Connect them with outlets.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开`MainController.xib`文件，并添加一个`UIButton`和一个`UILabel`。通过出口将它们连接起来。
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`类中输入以下代码：
- en: '[PRE28]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Compile and run the application on the simulator.
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Tap on the button in the **Main** tab to display the contents of our list.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**主**标签页上轻触按钮以显示我们列表的内容。
- en: Switch to the **Settings** tab.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到**设置**标签。
- en: Click **Hardware | Simulate Memory Warning** in the menu bar of the simulator.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器的菜单栏中点击**硬件 | 模拟内存警告**。
- en: Watch the output in the **Application Output** of MainDevelop, and switch back
    to the **Main** tab.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在MainDevelop的**应用程序输出**中查看输出，并切换回**主**标签。
- en: How it works...
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This project does not provide any useful functionality. Its main purpose is
    to show how to use view controllers properly.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 此项目不提供任何有用的功能。其主要目的是展示如何正确使用视图控制器。
- en: When iOS needs more memory to perform various operations, it issues memory warnings.
    When a memory warning occurs, all UI objects that are handled by a controller
    and are not in use are purged from memory to free up more memory.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当iOS需要更多内存来执行各种操作时，它会发出内存警告。当发生内存警告时，所有由控制器处理且未使用的UI对象都会从内存中清除，以释放更多内存。
- en: The simulator provides a way for developers to recreate such a scenario, with
    the **Hardware | Simulate Memory Warning** action we selected from the menu bar.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟器提供了一个方法，让开发者可以通过从菜单栏中选择我们之前选择的**硬件 | 模拟内存警告**操作来重新创建这样的场景。
- en: 'Since we were in the **Settings** tab, the contents of the `MainController`
    were purged from memory. Inside the `DidReceiveMemoryWarning` method, we clean
    up any non-UI objects, which otherwise would remain in memory:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处于**设置**标签，`MainController`的内容已被从内存中清除。在`DidReceiveMemoryWarning`方法中，我们清理任何非UI对象，否则这些对象将保留在内存中：
- en: '[PRE29]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Next, in the `ViewDidUnload` method, we only need to release any UI objects
    that are retained by outlets. Note that this is where we unhook any handlers from
    events these objects might hold:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`ViewDidUnload`方法中，我们只需要释放任何由出口保留的UI对象。请注意，这就是我们从这些对象可能持有的事件中取消连接处理程序的地方：
- en: '[PRE30]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: When we select the **Main** tab again, the `ViewDidLoad` method will be called
    once more, after the view of the controller and all views and outlets it contains
    are loaded.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们再次选择 **主** 标签时，`ViewDidLoad` 方法将被再次调用，在控制器视图及其包含的所有视图和输出加载完毕之后。
- en: There's more...
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: When a memory warning occurs, instances of objects not related directly with
    the UI will remain in memory. In rare cases when there is not enough memory for
    specific tasks, the operating system might terminate our application if it occupies
    much of the available memory. To prevent such situations, we need to be careful
    to clean up all the objects and resources that are not needed, freeing up more
    memory for iOS.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当发生内存警告时，与 UI 无直接关系的对象实例将保留在内存中。在极少数情况下，如果没有足够的内存来完成特定任务，操作系统可能会终止我们的应用程序，如果它占用了大部分可用内存。为了防止这种情况，我们需要小心清理所有不需要的对象和资源，为
    iOS 释放更多内存。
- en: Note
  id: totrans-268
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Never access a controller''s view inside the `ViewDidUnload` method:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在 `ViewDidUnload` 方法中访问控制器的视图：
- en: '[PRE31]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: That is because even when we request the return value of a view controller's
    `View` property, it causes the view to be loaded again, which in most cases will
    mean that no memory will be released.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为即使我们请求视图控制器的 `View` 属性的返回值，也会导致视图重新加载，这在大多数情况下意味着不会释放内存。
- en: See also
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'In this chapter:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Providing controllers in tabs*'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在标签页中提供控制器*'
- en: 'In this book:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools"),Development Tools:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具"),开发工具：'
- en: '*Interface builder*'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*界面构建器*'
- en: '[Chapter 4](ch04.html "Chapter 4. Data Management"),'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 4 章](ch04.html "第 4 章。数据管理"),'
- en: '*Creating files*'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建文件*'
- en: '*Creating an SQLite database*'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*创建 SQLite 数据库*'
- en: Combining different view controllers
  id: totrans-281
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结合不同的视图控制器
- en: In this recipe, we will learn how to display a `UINavigationController` within
    a `UITabBarController`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何在 `UITabBarController` 中显示 `UINavigationController`。
- en: Getting ready
  id: totrans-283
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPhone empty project in MonoDevelop, and name it `CombinedControllerApp`.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在 MonoDevelop 中创建一个新的 iPhone 空项目，并将其命名为 `CombinedControllerApp`。
- en: How to do it...
  id: totrans-285
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: 'These are the steps to create this project:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 创建此项目的步骤如下：
- en: Add three iPhone View Controller files to the project, and name them `MainController,
    SettingsController`, and `AfterMainController`.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将三个 iPhone 视图控制器文件添加到项目中，并分别命名为 `MainController, SettingsController` 和 `AfterMainController`。
- en: Add a `UIButton` on the view of `MainController` in Interface Builder, and save
    the document.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Interface Builder 中 `MainController` 视图中添加一个 `UIButton`，并保存文档。
- en: 'Enter the following code in the `MainController` class:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainController` 类中输入以下代码：
- en: '[PRE32]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Add the following fields in the `AppDelegate` class:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中添加以下字段：
- en: '[PRE33]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Add the following code in the `FinishedLaunching` method of the `AppDelegate`
    class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类的 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE34]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the application on the simulator. Tap the button in the `MainController`
    to push the `AfterMainController` in the navigation stack, and then switch between
    the **Main** and **Settings** tabs.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。在 `MainController` 中轻触按钮，将 `AfterMainController` 推送到导航堆栈中，然后切换到
    **主** 和 **设置** 标签。
- en: How it works...
  id: totrans-296
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The complete solution can be found in the `CombinedControllerApp` folder. What
    we have managed to do with this project is to provide a user interface with three
    different screens, which is not confusing for the user.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的解决方案可以在 `CombinedControllerApp` 文件夹中找到。我们通过这个项目实现了提供三个不同屏幕的用户界面，这对用户来说不会造成困惑。
- en: The tab bar contains two system-defined items, each representing a different
    view controller. We implemented the first item in the tab bar controller with
    a navigation controller. This way, we can provide more screens that are related
    with a specific part of our application (**Main** plus **AfterMain)**, leaving
    another part of our application directly accessible at any time **(Settings)**.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 标签栏包含两个系统定义的项目，每个项目代表一个不同的视图控制器。我们在标签栏控制器中实现了第一个项目，使用导航控制器。这样，我们可以提供更多与特定部分的应用程序相关的屏幕（**主**
    加 **AfterMain**），同时让应用程序的另一部分在任何时候都可以直接访问 **（设置）**。
- en: There's more...
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The way this project combines three different controllers (a `UITabBarController`,
    a `UINavigationController`, and a `UIViewController)` is perfectly acceptable.
    We could even replace the second tab item with another navigation controller to
    provide even more screens for another section of the application, or even add
    another tab item.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目结合了三个不同的控制器（一个 `UITabBarController`、一个 `UINavigationController` 和一个 `UIViewController`）的方式是完全可接受的。我们甚至可以用另一个导航控制器替换第二个标签项，为应用程序的另一个部分提供更多的屏幕，或者甚至添加另一个标签项。
- en: However, as stated in the *Providing controllers in tabs* recipe in this chapter,
    it would not be acceptable if we added a `UITabBarController` inside a `UINavigationController`.
    If we want to provide tab-like behavior inside a navigation controller, we should
    use its `UIToolbar` to do so.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如本章中 *在标签中提供控制器* 的配方所述，如果我们在一个 `UINavigationController` 内添加一个 `UITabBarController`，这是不可接受的。如果我们想在导航控制器内提供类似标签的行为，我们应该使用它的
    `UIToolbar` 来实现。
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Navigating through different view controllers*'
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在不同视图控制器之间导航*'
- en: '*Providing controllers in tabs*'
  id: totrans-305
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在标签中提供控制器*'
- en: '*Creating a user interface for different devices*'
  id: totrans-306
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为不同设备创建用户界面*'
- en: iPad view controllers
  id: totrans-307
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: iPad 视图控制器
- en: In this recipe, we will discuss the controllers that are only available to the
    iPad.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在本配方中，我们将讨论仅适用于 iPad 的控制器。
- en: Getting ready
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new iPad empty project, and name it `iPadControllerApp`.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 iPad 空项目，并将其命名为 `iPadControllerApp`。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: Add two iPad views with controllers to the project, and name them `FirstController`
    and `SecondController`. Set different colors for their background views. In `SecondController`,
    also add a `UIToolbar` on the top of its view, and connect it to an outlet.
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个带有控制器的 iPad 视图添加到项目中，并分别命名为 `FirstController` 和 `SecondController`。为它们的背景视图设置不同的颜色。在
    `SecondController` 中，在其视图顶部添加一个 `UIToolbar`，并将其连接到一个出口。
- en: 'Add the following fields in the `AppDelegate` class:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 类中添加以下字段：
- en: '[PRE35]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note
  id: totrans-315
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `UISplitViewController` class is available only to the iPad.
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`UISplitViewController` 类仅适用于 iPad。'
- en: 'Add the following code in the `FinishedLaunching` method:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `FinishedLaunching` 方法中添加以下代码：
- en: '[PRE36]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Add the following nested class in `AppDelegate:`
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppDelegate` 中添加以下嵌套类：
- en: '[PRE37]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Add a property in the `SecondController` class, which returns the toolbar outlet
    that we created in *step 1:*
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `SecondController` 类中添加一个属性，它返回我们在 *步骤 1* 中创建的工具栏出口：
- en: '[PRE38]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Finally, compile and run the application in the simulator. Tap on the button
    in the toolbar to make the `FirstController` appear. The result should be similar
    to the following screenshot:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在模拟器中编译并运行应用程序。点击工具栏中的按钮，使 `FirstController` 出现。结果应该类似于以下截图：
- en: '![How to do it...](img/1468EXP_03_03.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现...](img/1468EXP_03_03.jpg)'
- en: How it works...
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'The complete solution can be found in the `iPadControllerApp` folder. There
    are two iPad-specific controllers: `UISplitViewController` and `UIPopoverController`.
    Both of them are being used here, although the `UIPopoverController` is not used
    directly.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 完整解决方案可以在 `iPadControllerApp` 文件夹中找到。有两个特定于 iPad 的控制器：`UISplitViewController`
    和 `UIPopoverController`。它们都被使用在这里，尽管 `UIPopoverController` 没有直接使用。
- en: The `UISplitViewController` helps to take full advantage of the iPad's larger
    screen. It provides a way of displaying two different views simultaneously on
    the same screen area. It does this by displaying one controller in full-screen
    in portrait orientation and the other controller smaller, in a popover. A **popover**
    is basically a view, which is displayed on top of other controllers (and their
    views), much like a modal view controller.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`UISplitViewController` 有助于充分利用 iPad 的更大屏幕。它提供了一种在相同屏幕区域内同时显示两个不同视图的方法。它是通过在纵向全屏显示一个控制器，而在弹出视图中显示另一个较小的控制器来实现的。**弹出视图**基本上是一个视图，它显示在其他控制器（及其视图）的顶部，就像一个模态视图控制器一样。'
- en: 'To provide access to both controllers in our project to the user, we have implemented
    a class that inherits from `UISpliViewControllerDelegate` and assigned it to our
    split controller inside the `FinishedLaunching()` method. The `Delegate` object
    we created overrides two methods. In the first method, we assign a button to the
    toolbar:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让用户能够访问我们项目中的两个控制器，我们实现了一个继承自 `UISplitViewControllerDelegate` 的类，并在 `FinishedLaunching()`
    方法中将它分配给我们的分割控制器。我们创建的 `Delegate` 对象覆盖了两个方法。在第一个方法中，我们将一个按钮分配给工具栏：
- en: '[PRE39]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `WillHideViewController()` method is executed whenever the `UISplitViewController`
    changes orientation from landscape to portrait, and its smaller controller is
    about to be hidden. So, to display it, we provide a button on the full-screen
    controller''s toolbar. When we tap on that button, the other controller will appear
    in a popover. When the orientation changes from portrait to landscape, the smaller
    controller appears besides the larger controller, without the need for a popover.
    So, we no longer need the button on the toolbar, hence we override the `WillShowViewController`
    to remove the button from the toolbar. We do this by assigning an empty `UIBarButtonItem[]`
    array:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 当`UISplitViewController`从横屏变为竖屏，并且其较小的控制器即将被隐藏时，`WillHideViewController()`方法会被执行。因此，为了显示它，我们在全屏控制器的工具栏上提供了一个按钮。当我们点击该按钮时，另一个控制器将以弹出窗口的形式出现。当方向从竖屏变为横屏时，较小的控制器出现在较大的控制器旁边，无需弹出窗口。因此，我们不再需要在工具栏上按钮，因此我们重写`WillShowViewController`以从工具栏中移除按钮。我们通过分配一个空的`UIBarButtonItem[]`数组来完成此操作：
- en: '[PRE40]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: There's more...
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: When the device rotates, the interface does not respond automatically. To instruct
    the view controller to rotate its views, we override the `ShouldAutorotateToInterface
    Orientation(UIInterfaceOrientation)` method **in both the controllers of the split
    view controller:**
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 当设备旋转时，界面不会自动响应。为了指示视图控制器旋转其视图，我们在分割视图控制器的两个控制器中重写`ShouldAutorotateToInterfaceOrientation(UIInterfaceOrientation)`方法：
- en: '[PRE41]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: iPad-specific controller usage
  id: totrans-335
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iPad特定控制器使用
- en: Although all other controllers are available to both the iPhone and the iPad,
    these two controllers cannot be used on the iPhone. An exception will occur in
    this case.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管所有其他控制器都可用于iPhone和iPad，但这两个控制器不能在iPhone上使用。在这种情况下将发生异常。
- en: See also
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'In this chapter:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中：
- en: '*Creating a user interface for different devices*'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*为不同设备创建用户界面*'
- en: 'In this book:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 9](ch09.html "Chapter 9. Interacting with Device Hardware"), Interacting
    with Device Hardware:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](ch09.html "第9章。与设备硬件交互"), 与设备硬件交互：'
- en: '*Rotating the device*'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*旋转设备*'
- en: Creating a user interface for different devices
  id: totrans-343
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为不同设备创建用户界面
- en: In this recipe, we will learn how to create an application that will support
    both the iPhone and the iPad.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何创建一个同时支持iPhone和iPad的应用程序。
- en: Getting ready
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new Universal empty project in MonoDevelop, and name it `UniversalApp`.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在MonoDevelop中创建一个新的通用空项目，并将其命名为`UniversalApp`。
- en: How to do it...
  id: totrans-347
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Add a new **iPhone View Controller** to the project, and name it `MainController`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的**iPhone视图控制器**，并将其命名为`MainController`。
- en: Open it in Interface Builder, and add a label and an outlet for it on the view.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Interface Builder中打开它，并在视图中为其添加一个标签和一个出口。
- en: Enter the text `Running on an iPhone!` in the label.
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在标签中输入文本`在iPhone上运行！`
- en: Change the background of the view to a color other than white. Do the same for
    the label, and save the document.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将视图的背景颜色改为白色以外的颜色。同样对标签进行操作，并保存文档。
- en: 'Add the following code in the `MainViewController` class:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainViewController`类中添加以下代码：
- en: '[PRE42]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Add the following code in the `FinishedLaunching()` in the `AppDelegate` class:'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AppDelegate`类的`FinishedLaunching()`中添加以下代码：
- en: '[PRE43]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Compile and run the application on the simulator.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用程序。
- en: Read the message of the label, stating that it is running on an iPhone. Terminate
    the execution in MonoDevelop, and click on **Run | Run With | iPad Simulator x.x**
    (where **x.x** is the corresponding iOS version installed on the system, here
    **5.0)** on the menu bar.![How to do it...](img/1468EXP_03_04.jpg)
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取标签的消息，表明它正在iPhone上运行。在MonoDevelop中终止执行，并在菜单栏上点击**运行 | 运行方式 | iPad模拟器 x.x**（其中**x.x**是系统上安装的相应iOS版本，这里**5.0**）。![如何操作...](img/1468EXP_03_04.jpg)
- en: Read the message stating that the application is running on an iPad!
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取表明应用程序正在iPad上运行的消息！
- en: How it works...
  id: totrans-359
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When we create a universal project in MonoDevelop, the basic difference lies
    in the application settings file `(Info.plist)` , where the application is declared
    to support both the iPhone and the iPad.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在MonoDevelop中创建通用项目时，基本区别在于应用程序设置文件`(Info.plist)`，其中声明应用程序支持iPhone和iPad。
- en: The fact that we have added an **iPhone View with Controller** does not prevent
    us from using the same controller for both devices. Remember, all controllers
    are available for all devices, except for the ones discussed in the previous recipe.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，我们添加了一个 **带有控制器的 iPhone 视图** 并不会阻止我们为两种设备使用相同的控制器。记住，所有控制器都适用于所有设备，除了之前菜谱中讨论的那些。
- en: Inside the `ViewDidLoad` method, we check which device the application is running
    on, by checking the `UserInterfaceIdiom` property of the `UIDevice.CurrentDevice`
    static property, and provide a frame for the view that is sized to the iPad screen's
    dimensions {768, 1024}.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法内部，我们通过检查 `UIDevice.CurrentDevice` 静态属性的 `UserInterfaceIdiom`
    属性来确定应用程序正在运行在哪种设备上，并为视图提供一个大小与 iPad 屏幕尺寸 {768, 1024} 相匹配的框架。
- en: '[PRE44]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: There's more...
  id: totrans-364
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: This takes care of sizing the views contained in a project according to which
    device the application is running on. But, it does not guarantee that all the
    controls will be sized and positioned correctly. To avoid cluttered user interfaces,
    we have to make sure to adjust the `Autosizing` property of our controls and views
    so that they will be resized and positioned correctly on different screens.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 这将确保根据应用程序运行在哪种设备上，对项目中包含的视图进行尺寸调整。但是，这并不能保证所有控件都将被正确地调整大小和定位。为了避免用户界面杂乱，我们必须确保调整我们控件和视图的
    `Autosizing` 属性，以便它们可以在不同的屏幕上正确地调整大小和定位。
- en: See also
  id: totrans-366
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'In this chapter:'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 本章内容：
- en: '*Using view controllers efficiently*'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*高效使用视图控制器*'
- en: '*iPad view controllers*'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*iPad 视图控制器*'
- en: 'In this book:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中：
- en: '[Chapter 1](ch01.html "Chapter 1. Development Tools") , Development Tools:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 1 章](ch01.html "第 1 章。开发工具")，开发工具：'
- en: '*Creating an iPhone project with MonoDevelop*'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 MonoDevelop 创建 iPhone 项目*'
- en: '*Interface builder*'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*界面构建器*'
