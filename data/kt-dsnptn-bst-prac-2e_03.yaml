- en: '*Chapter 2*: Working with Creational Patterns'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第二章*：使用创建型模式'
- en: In this chapter, we'll cover how classic **creational patterns** are implemented
    using **Kotlin**. These patterns deal with *how* and *when* you *create* your
    objects. For each design pattern, we will discuss what it aims to achieve and
    how Kotlin accommodates those needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何使用**Kotlin**实现经典**创建型模式**。这些模式处理**如何**和**何时**创建你的对象。对于每个设计模式，我们将讨论它旨在实现的目标以及Kotlin如何满足这些需求。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中将涵盖以下主题：
- en: Singleton
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例
- en: Factory Method
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂方法
- en: Abstract Factory
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: Builder
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建者
- en: Prototype
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Mastering these design patterns will allow you to manage your objects better,
    adapt well to changes, and write code that is easy to maintain.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 精通这些设计模式将使你能够更好地管理你的对象，更好地适应变化，并编写易于维护的代码。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'For this chapter, you will need to install the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你需要安装以下内容：
- en: '**IntelliJ IDEA** **Community Edition** ([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IntelliJ IDEA** **社区版**([https://www.jetbrains.com/idea/download/](https://www.jetbrains.com/idea/download/))'
- en: '**OpenJDK** **11** (or higher) ([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenJDK** **11**（或更高版本）([https://openjdk.java.net/install/](https://openjdk.java.net/install/))'
- en: You can find the code files for this chapter on **GitHub** at [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02).
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**GitHub**上找到本章的代码文件，地址为[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter02)。
- en: Singleton
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例
- en: '**Singleton** – the most popular bachelor in town. Everybody knows him, everybody
    talks about him, and everybody knows where to look for him.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**单例**——镇上最受欢迎的单身汉。每个人都认识他，每个人都谈论他，每个人都知道在哪里找到他。'
- en: Even people who don't like using design patterns will know Singleton by name.
    At one point, it was even proclaimed an **anti-pattern**, but only because of
    its wide popularity.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 即使不喜欢使用设计模式的人也会知道单例模式。在某个时候，它甚至被宣称为**反模式**，但这仅仅是因为它的广泛流行。
- en: '*So, for those who are encountering it for the first time, what is this design
    pattern all about?*'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，对于那些第一次遇到它的人来说，这种设计模式到底是什么呢？*'
- en: 'Usually, if you have a class, you can create as many instances of it as you
    want. For example, let''s say that we both are asked to list all of our favorite
    movies:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果你有一个类，你可以创建尽可能多的实例。例如，假设我们都要求列出我们最喜欢的电影：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note that we can create as many instances of `List` as we want, and there's
    no problem with that. Most classes can have multiple instances.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们可以创建尽可能多的`List`实例，而且这没有问题。大多数类都可以有多个实例。
- en: '*Next, what if we both want to list the best movies in the Quick and Angry
    series?*'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*接下来，如果我们俩都想列出《快速而愤怒》系列中的最佳电影呢？*'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that these two lists are exactly the same because they are empty. And they
    will stay empty because they are immutable and because the *Quick and Angry* series
    is simply horrendous. I hope you would agree with that.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这两个列表完全相同，因为它们都是空的。而且它们会保持空的状态，因为它们是不可变的，而且《快速而愤怒》系列电影真的很糟糕。我希望你会同意这一点。
- en: Since these two instances of a class are exactly the same, according to the
    **equals method**, it doesn't make much sense to keep them in memory multiple
    times. It would be great if all references to an empty list pointed to the same
    instance of an object. And in fact, that's what happens with null, if you think
    about it. All nulls are the same.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个类的实例完全相同，根据**equals方法**，将它们多次保存在内存中并没有太多意义。如果所有对空列表的引用都指向同一个对象实例，那就太好了。实际上，如果你这么想的话，所有null都是相同的。
- en: That's the main idea behind the Singleton design pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是单例设计模式背后的主要思想。
- en: 'There are a couple of requirements for the Singleton design pattern:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 单例设计模式有几个要求：
- en: We should have exactly one instance in our system.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们系统中应该只有一个实例。
- en: This instance should be accessible from any part of our system.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个实例应该可以从我们系统的任何部分访问。
- en: 'In `private` class. Then, you also need to make sure that instantiation is
    preferably lazy, thread-safe, and performant, with the following requirements:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在`private`类中。然后，你还需要确保实例化最好是懒加载的、线程安全的，并且性能良好，以下是一些要求：
- en: '**Lazy**: We might not want to instantiate a singleton object when our program
    starts, as this may be an expensive operation. We would like to instantiate it
    only when it''s needed for the first time.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟加载**：我们可能不想在程序启动时实例化单例对象，因为这可能是一个昂贵的操作。我们希望只在第一次需要时才实例化它。'
- en: '**Thread-safe**: If two threads are trying to instantiate a singleton object
    at the same time, they both should receive the same instance and not two different
    instances. If you''re not familiar with this concept, we''ll cover it in [*Chapter
    5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional Programming*.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线程安全**：如果有两个线程试图同时实例化一个单例对象，它们都应该接收到相同的实例，而不是两个不同的实例。如果您不熟悉这个概念，我们将在 [*第五章*](B17816_05_ePub.xhtml#_idTextAnchor144)
    *介绍函数式编程* 中介绍它。'
- en: '**Performant**: If many threads are trying to instantiate a singleton object
    at the same time, we shouldn''t block them for a long period of time, as this
    will be halting their execution.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**高效性**：如果有许多线程试图同时实例化一个单例对象，我们不应该长时间阻塞它们，因为这会阻止它们的执行。'
- en: Meeting all of these requirements in Java or **C++** is quite difficult, or
    at least very verbose.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Java 或 **C++** 中满足所有这些要求相当困难，或者至少非常冗长。
- en: Kotlin makes creating singletons easy by introducing a keyword called `object`.
    You may recognize this keyword from **Scala**. By using this keyword, we'll get
    an implementation of a singleton object, which accommodates all of our requirements.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 通过引入一个名为 `object` 的关键字使创建单例变得简单。您可能从 **Scala** 中认识这个关键字。通过使用这个关键字，我们将得到一个单例对象的实现，它满足我们所有的要求。
- en: 'Important Note:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: The `object` keyword is used for more than just creating singletons. We'll discuss
    this in depth later in this chapter.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`object` 关键字不仅用于创建单例，我们将在本章后面深入讨论这一点。'
- en: 'We declare objects just like a regular class but with no constructor, as a
    singleton object cannot be instantiated by us:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声明对象就像一个普通类一样，但没有构造函数，因为单例对象不能由我们实例化：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'From now on, we can access `NoMoviesList` from anywhere in our code, and there
    will be exactly one instance of it:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在起，我们可以在代码的任何地方访问 `NoMoviesList`，并且它将只有一个实例：
- en: '[PRE5]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Take note of the referential equality sign that checks that two variables point
    to the same object in memory. *Is this really a list though?*
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到参照性等号检查两个变量是否指向内存中的同一个对象。*这真的是一个列表吗？*
- en: 'Let''s create a function that prints the list of our movies:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个打印我们电影列表的函数：
- en: '[PRE9]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'When we pass an initial list of movies, the code compiles just fine:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递一个初始电影列表时，代码可以正常编译：
- en: '[PRE14]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'But if we pass it our empty movie list, the code won''t compile:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们传递一个空的电影列表给它，代码将无法编译：
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The reason for this is that our function only accepts arguments of the *list
    of strings* type, while there's nothing to tell the function that `NoMoviesList`
    is of this type (even though its name suggests it).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 原因在于我们的函数只接受 *字符串列表* 类型的参数，而没有任何东西告诉函数 `NoMoviesList` 是这种类型（尽管它的名字暗示了这一点）。
- en: 'Luckily, in Kotlin, singleton objects can implement interfaces, and a generic
    `List` interface is available:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Kotlin 中，单例对象可以实现接口，并且有一个通用的 `List` 接口可用：
- en: '[PRE18]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, our compiler will prompt us to implement the required functions. We''ll
    do that by adding a body to `object`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的编译器将提示我们实现所需的函数。我们将通过为 `object` 添加一个主体来实现这一点：
- en: '[PRE19]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We''ll leave it to you to implement the other functions if you wish. This should
    be a good exercise of everything you''ve learned about Kotlin until now. However,
    you don''t have to do this. Kotlin already provides a function to create empty
    lists of any type:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您愿意，我们可以将其他函数的实现留给您。这将是对您至今为止所学的 Kotlin 知识的良好练习。然而，您不必这样做。Kotlin 已经提供了一个创建任何类型空列表的函数：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: If you're curious, this function returns a singleton object that implements
    a `List`. You can see the complete implementation in the Kotlin source code using
    your IntelliJ IDEA or on GitHub ([https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt)).
    This is an excellent example of how design patterns are still actively applied
    in modern software.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您好奇，这个函数返回一个实现 `List` 的单例对象。您可以使用 IntelliJ IDEA 或在 GitHub 上查看其完整实现（[https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/src/kotlin/collections/Collections.kt)）。这是一个设计模式在现代软件中仍然积极应用的优秀例子。
- en: 'A Kotlin `object` has one major difference from a class – it can''t have constructors.
    If you need to implement initialization for your Singleton, such as loading data
    from a configuration file for the first time, you can use the `init` block instead:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin的`object`与类有一个主要区别——它不能有构造函数。如果你需要为你的Singleton实现初始化，例如第一次从配置文件加载数据，你可以使用`init`块代替：
- en: '[PRE25]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Note that if a Singleton is never invoked, it won't run its initialization logic
    at all, thereby saving resources. This is called **lazy initialization**.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，如果Singleton从未被调用，它根本不会运行其初始化逻辑，从而节省资源。这被称为**延迟初始化**。
- en: Now that we have learned how to limit object creation, let's discuss how to
    create objects without using a constructor directly.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经学会了如何限制对象的创建，让我们讨论如何在不直接使用构造函数的情况下创建对象。
- en: Factory Method
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂方法
- en: The **Factory Method** design pattern is all about creating objects.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**工厂方法**设计模式完全是关于创建对象。'
- en: '*But why do we need a method to create objects? Isn''t that what constructors
    are for?*'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '*但为什么我们需要一个创建对象的方法？构造函数不是用来这个的吗？*'
- en: Well, constructors have limitations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，构造函数有其局限性。
- en: As an example, imagine we're building a game of chess. We would like to allow
    our players to save the state of the game into a text file and then restore the
    game from that position.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设我们正在构建一个棋盘游戏。我们希望允许我们的玩家将游戏状态保存到文本文件中，然后从该位置恢复游戏。
- en: Since the size of the board is predetermined, we only need to record the position
    and type of each piece. We'll use algebraic notation for this – for example, the
    Queen piece at C3 will be stored in our file as `qc3`, the pawn piece at A8 will
    be stored as `pa8`, and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 由于棋盘的大小是预先确定的，我们只需要记录每个棋子的位置和类型。我们将使用代数符号来表示这一点——例如，位于C3的皇后棋子将被存储在我们的文件中为`qc3`，位于A8的兵棋子将被存储为`pa8`，以此类推。
- en: Let's assume that we already read this file into a list of strings (which, by
    the way, would be an excellent application of the Singleton design pattern we
    discussed earlier).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们已将此文件读入一个字符串列表（顺便说一句，这将是一个很好的Singleton设计模式的早期讨论的应用）。
- en: 'Given the list of notations, we would like to populate our board with them:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 给定符号列表，我们希望用它们填充我们的棋盘：
- en: '[PRE32]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before we can implement our `createPiece` function, we need to decide what''s
    common to all chess pieces. We''ll create an interface for that:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以实现我们的`createPiece`函数之前，我们需要决定所有棋子共有的东西。我们将为此创建一个接口：
- en: '[PRE39]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note that interfaces in Kotlin can declare properties, which is a very powerful
    feature.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Kotlin中的接口可以声明属性，这是一个非常强大的功能。
- en: 'Each chess piece will be a `data class` that implements our interface:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 每个棋子都将是一个实现我们接口的`data class`：
- en: '[PRE43]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The implementation of the other chess pieces is left as an exercise for you
    to do.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 其他棋子的实现留给你作为练习来完成。
- en: 'Now, what''s left is to implement our `createPiece` function:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，剩下的就是实现我们的`createPiece`函数：
- en: '[PRE51]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Before we can discuss what this function achieves, let's cover three new syntax
    elements we haven't seen before.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以讨论这个函数实现了什么之前，让我们先介绍三个我们之前没有见过的新的语法元素。
- en: First, the `toCharArray` function splits a string into an array of characters.
    Since we assume that all of our notations are three characters long, the element
    at the `0` position will represent the *type* of the chess piece, the element
    at the `1` position will represent its vertical column – also known as `file`
    – and the last element will represent its horizontal column – also known as `rank`.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，`toCharArray`函数将字符串分割成一个字符数组。由于我们假设所有的符号都是三个字符长，`0`位置的元素将代表棋子的*类型*，`1`位置的元素将代表其垂直列——也称为`file`，最后一个元素将代表其水平列——也称为`rank`。
- en: 'Next, we can see three values: `type`, `file`, and `rank`, surrounded by parentheses.
    This is called a `data class` can be destructured.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们可以看到三个值：`type`、`file`和`rank`，它们被括号包围。这被称为`data class`可以解构。
- en: 'The previous code example is similar to the following, much more verbose code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码示例类似于以下更冗长的代码：
- en: '[PRE60]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Now, let's focus on the `when` expression. Based on the letter representing
    the type, it instantiates one of the implementations of the `ChessPiece` interface.
    Remember, this is what the Factory Method design pattern is all about.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们专注于`when`表达式。根据表示类型的字母，它实例化`ChessPiece`接口的一个实现。记住，这正是工厂方法设计模式的核心。
- en: To make sure you grasp this design pattern well, feel free to implement the
    classes and logic for other chess pieces as an exercise.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你很好地掌握这个设计模式，请随意将其他棋子的类和逻辑实现作为练习。
- en: Finally, let's look at the bottom of our function, where we see the first use
    of a `throw` expression.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们看看函数的底部，在那里我们看到第一个`throw`表达式的使用。
- en: This expression, as the name suggests, *throws* an exception, which will stop
    the normal execution of our simple program. We'll discuss how to handle exceptions
    in [*Chapter 5*](B17816_05_ePub.xhtml#_idTextAnchor144), *Introducing Functional
    Programming*.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个表达式，正如其名所示，*抛出*一个异常，这将停止我们简单程序的正常执行。我们将在[*第五章*](B17816_05_ePub.xhtml#_idTextAnchor144)，“介绍函数式编程”中讨论如何处理异常。
- en: In the real world, the Factory Method design pattern is often used by libraries
    that need to parse configuration files – be they of the XML, JSON, or YAML format
    – into runtime objects.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在现实世界中，工厂方法设计模式通常被需要将配置文件（无论是XML、JSON还是YAML格式）解析为运行时对象的库所使用。
- en: Static Factory Method
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态工厂方法
- en: There is a similarly named design pattern (which has a slightly different implementation)
    that is often confused with the Factory Method design pattern, and it is described
    in the *Gang of Four* book – the **Static Factory Method** design pattern.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个类似命名的模式（实现略有不同），它经常与工厂方法设计模式混淆，并在*四人帮*的书中描述——这是**静态工厂方法**设计模式。
- en: 'The Static Factory Method design pattern was popularized by Joshua Bloch in
    his book, *Effective Java*. To understand this better, let''s look at some examples
    from the Java standard library: the `valueOf()` methods. There are at least two
    ways to construct a `Long` (that is, a 64-bit integer) from a string:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法设计模式是由Joshua Bloch在他的书《*Effective Java*》中推广的。为了更好地理解这一点，让我们看看Java标准库中的几个例子：`valueOf()`方法。从字符串构建`Long`（即64位整数）至少有两种方式：
- en: '[PRE63]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Both the constructor and the `valueOf()` method receive string as input and
    produce `Long` as output.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数和`valueOf()`方法都接收字符串作为输入，并产生`Long`作为输出。
- en: '*So, why should we prefer the Static Factory Method design pattern to a simple
    constructor?*'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，为什么我们应该更喜欢静态工厂方法设计模式而不是简单的构造函数呢？*'
- en: 'Here are some of the advantages of using the Static Factory Method compared
    to constructors:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 与构造函数相比，使用静态工厂方法的一些优点如下：
- en: It provides an opportunity to explicitly name different object constructors.
    This is especially useful when your class has multiple constructors.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它提供了显式命名不同对象构造函数的机会。当你的类有多个构造函数时，这特别有用。
- en: We usually don't expect exceptions from a constructor. That doesn't mean that
    the instantiation of a class can't fail. Exceptions from a regular method, on
    the other hand, are much more accepted.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通常不期望构造函数抛出异常。这并不意味着类的实例化不能失败。另一方面，常规方法的异常则更被接受。
- en: Speaking of expectations, we expect the constructor to be fast. But construction
    of some objects is inherently slow. Consider using the Static Factory Method instead.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说到期望，我们期望构造函数运行得快。但某些对象的构建本质上可能很慢。考虑使用静态工厂方法。
- en: These are mostly style advantages; however, there are also technological advantages
    to this approach.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这些主要是风格上的优势；然而，这种方法也有技术上的优势。
- en: Caching
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓存
- en: The Static Factory Method design pattern may provide `Long` actually does. Instead
    of always returning a new instance for any value, `valueOf()` checks in the cache
    whether this value was already parsed. If it was, it returns a cached instance.
    Repeatedly calling the Static Factory Method with the same values may produce
    less garbage for collection than using constructors all the time.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 静态工厂方法设计模式可能提供的`Long`实际上确实如此。而不是总是为任何值返回一个新实例，`valueOf()`会在缓存中检查此值是否已经被解析。如果是，它将返回缓存的实例。重复使用相同的值调用静态工厂方法可能产生的垃圾回收比始终使用构造函数要少。
- en: Subclassing
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 子类化
- en: When calling the constructor, we always instantiate the class we specify. On
    the other hand, calling a Static Factory Method is less restrictive and may produce
    either an instance of the class itself or one of its subclasses. We'll come to
    this after discussing the implementation of this design pattern in Kotlin.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用构造函数时，我们总是实例化我们指定的类。另一方面，调用静态工厂方法限制较少，可能产生类的实例或其子类之一。在讨论了在Kotlin中实现此设计模式之后，我们将讨论这一点。
- en: Static Factory Method in Kotlin
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Kotlin中的静态工厂方法
- en: We discussed the `object` keyword earlier in this chapter in the *Singleton*
    section. Now, we'll see another use of it as a **companion object**.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章的*单例*部分之前讨论了`object`关键字。现在，我们将看到它作为**伴随对象**的另一种用途。
- en: 'In Java, Static Factory Methods are declared `static`. But in Kotlin, there''s
    no such keyword. Instead, methods that don''t belong to an instance of a class
    can be declared inside `companion object`:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，静态工厂方法被声明为`static`。但在Kotlin中，没有这样的关键字。相反，不属于类实例的方法可以声明在`companion object`内部：
- en: '[PRE65]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Important Note:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Companion objects may have a name – for example, `companion object` parser.
    But this is only to provide clarity about what the goal of the object is.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 伴随对象可以有名称——例如，`companion object`解析器。但这只是为了提供关于对象目标的清晰度。
- en: As you can see, this time, we have declared an object that is prefixed by the
    `companion` keyword. Also, it's located inside a class, and not at the package
    level in the way we saw in the Singleton design pattern.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次，我们声明了一个以`companion`关键字为前缀的对象。它位于类内部，而不是像我们在单例设计模式中看到的那样位于包级别。
- en: 'This object has its own methods, and you may wonder what the benefit of this
    is. Just like a Java static method, calling a `companion` `object` will lazily
    instantiate it when the containing class is accessed for the first time:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个对象有自己的方法，您可能会想知道这有什么好处。就像Java静态方法一样，当第一次访问包含的类时，会惰性实例化`companion` `object`：
- en: '[PRE73]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Moreover, calling it on an instance of a class simply won''t work, unlike in
    Java:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在类的实例上调用它根本不起作用，与Java不同：
- en: '[PRE74]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Important Note:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: A class may have only one `companion object`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类可能只有一个`companion object`。
- en: 'Sometimes, we also want the Static Factory Method to be the only way to instantiate
    our object. In order to do that, we can declare the default constructor of our
    object as `private`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们也希望静态工厂方法是实例化我们的对象的唯一方式。为了做到这一点，我们可以将对象的默认构造函数声明为`private`：
- en: '[PRE75]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'This means that now there''s only one way of constructing an instance of our
    class – through our Static Factory Method:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在构建我们类实例的唯一方式是通过我们的静态工厂方法：
- en: '[PRE78]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: Let's now discuss another design pattern that is often confused with the Factory
    Method – Abstract Factory.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来讨论另一个经常与工厂方法混淆的设计模式——抽象工厂。
- en: Abstract Factory
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: '**Abstract Factory** is a greatly misunderstood design pattern. It has a notorious
    reputation for being very complex and bizarre. Actually, it''s quite simple. If
    you understood the Factory Method design pattern, you''ll understand this one
    in no time. This is because the Abstract Factory design pattern is a factory of
    factories. That''s all there is to it. The *factory* is a function or class that''s
    able to create other classes. In other words, an abstract factory is a class that
    wraps multiple factory methods.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象工厂**是一个被广泛误解的设计模式。它因非常复杂和奇特而臭名昭著。实际上，它相当简单。如果您理解了工厂方法设计模式，您会立刻理解这个。这是因为抽象工厂设计模式是工厂的工厂。仅此而已。*工厂*是一个能够创建其他类的函数或类。换句话说，抽象工厂是一个封装多个工厂方法的类。'
- en: You may understand this and still wonder what the use of such a design pattern
    may be. In the real world, the Abstract Factory design pattern is often used in
    frameworks and libraries that get their configuration from files. The **Spring
    Framework** is just one example of these.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经理解了这一点，但仍会想知道这种设计模式有什么用途。在现实世界中，抽象工厂设计模式通常用于从文件中获取配置的框架和库。**Spring框架**就是这些中的一个例子。
- en: 'To better understand how the design pattern works, let''s assume we have a
    configuration for our server written in a YAML file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解设计模式的工作原理，让我们假设我们有一个用YAML文件编写的服务器配置：
- en: '[PRE80]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: Our task is to construct objects from this configuration.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的任务是从这个配置中构建对象。
- en: In the previous section, we discussed how to use Factory Method to construct
    objects from the same family. But here, we have two families of objects that are
    related to each other but are not *siblings*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们讨论了如何使用工厂方法从同一系列中构建对象。但在这里，我们有两个相互关联但不是*兄弟姐妹*的对象系列。
- en: 'First, let''s describe them as interfaces:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们将它们描述为接口：
- en: '[PRE83]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Instead of a `data class`, we''ll return an interface. You''ll see how this
    helps us later in this section:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将返回一个接口而不是`data class`。您将在本节后面看到这如何帮助我们：
- en: '[PRE87]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Then, we can provide basic implementations to be used later:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以提供基本实现供以后使用：
- en: '[PRE90]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: The server configuration simply contains the list of properties – and a *property*
    is a pair comprising a `name` object and a `value` object.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器配置仅包含属性列表——而*属性*是由一个`name`对象和一个`value`对象组成的对。
- en: 'This is the first time we have seen the `Any` type being used. The `Any` type
    is Kotlin''s version of Java''s `object`, but with one important distinction:
    it cannot be null.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们第一次看到 `Any` 类型被使用。`Any` 类型是 Kotlin 对 Java 的 `object` 的版本，但有一个重要的区别：它不能为
    null。
- en: 'Now, let''s write our first Factory Method, which will create `Property` given
    as a string:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编写我们的第一个工厂方法，它将根据给定的字符串创建 `Property`：
- en: '[PRE97]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: '[PRE103]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'As in many other languages, `trim()` is a function that is declared on strings
    that removes any spaces in the string. Now, let''s create two properties to represent
    the port (`port`) and environment (`environment`) of our service:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言一样，`trim()` 是一个在字符串上声明的函数，用于删除字符串中的任何空格。现在，让我们创建两个属性来表示我们的服务的端口 (`port`)
    和环境 (`environment`)：
- en: '[PRE105]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'There is a slight issue with this code. To understand what it is, let''s try
    to store the value of the `port` property into another variable:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码有一个小问题。为了理解它是什么，让我们尝试将 `port` 属性的值存储到另一个变量中：
- en: '[PRE107]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: We already ensured that `port` is parsed to an `Int` in our Factory Method.
    But now, this information is lost because the type of the value is declared as
    `Any`. It can be `String`, `Int`, or any other type, for that matter. We need
    a new tool to solve this issue, so let's take a short detour and discuss casts
    in Kotlin.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在工厂方法中确保 `port` 被解析为 `Int`。但现在，由于值的类型被声明为 `Any`，这个信息丢失了。它可以是一个 `String`、`Int`
    或任何其他类型。我们需要一个新的工具来解决这个问题，所以让我们短暂地偏离一下，讨论 Kotlin 中的转换。
- en: Casts
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 转换
- en: '**Casts** in typed languages are a way to try and force the compiler to use
    the type we specify, instead of the type it has inferred. If we are sure what
    type the value is, we can use an *unsafe* cast on it:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在类型语言中，**转换**是一种尝试强制编译器使用我们指定的类型，而不是它推断出的类型。如果我们确定值的类型，我们可以在它上面使用一个 *不安全的* 转换：
- en: '[PRE109]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: The reason it is called *unsafe* is that if the value is not of the type we
    expect, our program will crash without the compiler being able to warn us.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 它被称为 *不安全的*，是因为如果值不是我们预期的类型，我们的程序将崩溃，而编译器无法警告我们。
- en: 'Alternatively, we could use a *safe* cast:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以使用 *安全的* 转换：
- en: '[PRE110]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '*Safe* casts won''t crash our program, but if the type of the object is not
    what we expect, it will return null. Notice that our `port` variable now is declared
    as the nullable `Int`, so we have to explicitly deal with the possibility of not
    getting what we want during compilation time.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '*安全的*转换不会使我们的程序崩溃，但如果对象的类型不是我们预期的，它将返回 null。注意，我们的 `port` 变量现在被声明为可空的 `Int`
    类型，因此在编译时我们必须显式处理可能得不到我们想要的结果的情况。'
- en: Subclassing
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: 'Instead of resorting to casts, let''s try another approach. Instead of using
    a single implementation with a value of the `Any` type, we''ll use two separate
    implementations:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是求助于转换，让我们尝试另一种方法。我们不会使用一个具有 `Any` 类型值的单个实现，而是使用两个独立的实现：
- en: '[PRE111]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-235
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Our Factory Method will have to change a little to be able to return one of
    the two classes:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的工厂方法需要稍作修改才能返回这两个类中的一个：
- en: '[PRE119]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'This looks fine, but if we try to compile our code again, it still won''t work:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来不错，但如果我们再次尝试编译我们的代码，它仍然不会工作：
- en: '[PRE127]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: 'Although we now have two concrete classes, the compiler doesn''t know if the
    parsed property is `IntProperty` or `StringProperty`. All it knows is that it''s
    `Property`, and the type of the value is still `Any`:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们现在有两个具体的类，但编译器不知道解析的属性是 `IntProperty` 还是 `StringProperty`。它只知道它是 `Property`，并且值的类型仍然是
    `Any`：
- en: '[PRE129]'
  id: totrans-252
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: We need another trick, and that trick is called **smart casts**.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要另一个技巧，这个技巧被称为 **智能转换**。
- en: Smart casts
  id: totrans-254
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 智能转换
- en: 'We can check if an object is of a given type by using the `is` keyword:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `is` 关键字来检查一个对象是否为给定的类型：
- en: '[PRE130]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: However, the Kotlin compiler is very smart. *If we performed a type check on
    an* `if` *expression, it would mean that* `portProperty` *was indeed* `IntProperty`*,
    right?* So, it could be safely cast.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，Kotlin 编译器非常智能。*如果我们在一个* `if` *表达式中执行类型检查，这意味着* `portProperty` *确实是* `IntProperty`*，对吧？*
    因此，它可以安全地进行转换。
- en: 'The Kotlin compiler will do just that for us:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 编译器会为我们做这件事：
- en: '[PRE131]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: There is no compilation error anymore, and we also do not have to deal with
    nullable values.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在不再有编译错误，我们也不必处理可空值。
- en: 'Smart casts also work on nulls. In Kotlin''s type hierarchy, the non-nullable
    `Int` type is a subclass of a nullable type, `Int?`, and this is true for all
    types. Previously, we mentioned that a *safe* cast will return `null` if it fails:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 智能转换也适用于 null。在 Kotlin 的类型层次结构中，不可为 null 的 `Int` 类型是可空类型 `Int?` 的子类，这对于所有类型都是真的。之前，我们提到，如果
    *安全的* 转换失败，它将返回 `null`：
- en: '[PRE134]'
  id: totrans-264
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'We could check if `port` is null, and if it isn''t, it will be smartly cast
    to a non-nullable type:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以检查 `port` 是否为 null，如果不是，它将智能地转换为非可空类型：
- en: '[PRE135]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '*Nice!* *But wait, what''s going on in this code?*'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '*太好了！* *但是等等，这段代码中发生了什么？*'
- en: In the previous chapter, we said that values cannot be reassigned. But here,
    we defined the `port` value twice. *How is this possible?* This is not a bug,
    but another Kotlin feature, and it is called **variable shadowing**.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们提到值不能被重新赋值。但在这里，我们定义了两次 `port` 值。*这是怎么可能的？* 这不是一个错误，而是 Kotlin 的另一个特性，称为
    **变量遮蔽**。
- en: Variable shadowing
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 变量遮蔽
- en: 'First, let''s consider how our code would look if there was no shadowing. We
    would have to declare two variables with different names:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑如果没有遮蔽，我们的代码会是什么样子。我们必须声明两个不同名称的变量：
- en: '[PRE138]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: However, this is a waste, for two reasons. First, the variable names become
    quite verbose. Second, the `portOrNull` variable would most probably never be
    used past this point because null is not a very useful value to begin with. Instead,
    we can declare values with the same names in different scopes, denoted by curly
    brackets (`{}`).
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这造成了浪费，原因有两个。首先，变量名变得相当冗长。其次，`portOrNull` 变量很可能在此之后就不会再被使用了，因为null 本身并不是一个非常有用的值。相反，我们可以在不同的作用域中声明具有相同名称的值，这些作用域由花括号（`{}`）表示。
- en: Please note that variable shadowing may confuse you, and it is error-prone by
    nature. However, it is important to be aware that it exists, but the recommendation
    is to name your variables explicitly whenever possible.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，变量遮蔽可能会让你感到困惑，并且它本质上是有缺陷的。然而，重要的是要意识到它的存在，但建议尽可能明确地命名你的变量。
- en: Collection of Factory Methods
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工厂方法集合
- en: 'Now that we''ve had our detour into casts and variable shadowing, let''s go
    back to the previous code example and implement a second Factory Method, that
    will create a `server` configuration object:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经对类型转换和变量遮蔽有了了解，让我们回到之前的代码示例，并实现第二个工厂方法，该方法将创建一个 `server` 配置对象：
- en: '[PRE142]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: This method takes the lines from our configuration file and converts them into
    `Property` objects using the `property()` Factory Method that we've already implemented.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将配置文件中的行转换为 `Property` 对象，使用的是我们之前已经实现的 `property()` 工厂方法。
- en: 'We can test that our second Factory Method works as well:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以测试我们的第二个工厂方法是否正常工作：
- en: '[PRE150]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: Since these two methods are related, it would be good to put them together under
    the same class. Let's call this class `Parser`. Although we didn't parse any actual
    file and agreed that we get its contents line by line already, by the end of this
    book, you would probably agree that implementing the actual reading logic is quite
    trivial.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个方法相关联，将它们放在同一个类下会更好。让我们称这个类为 `Parser`。尽管我们还没有解析任何实际的文件，并且已经同意我们可以逐行获取其内容，但到这本书的结尾，你可能会同意实现实际的读取逻辑相当简单。
- en: We can also use Static Factory Method and the `companion object` syntax we learned
    about in the previous section.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用静态工厂方法和我们在上一节中学到的 `companion object` 语法。
- en: 'The resulting implementation will look like this:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 结果实现将看起来像这样：
- en: '[PRE153]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: This pattern allows us to create *families* of objects – in this case, `ServerConfig`
    is the *parent* of a property.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式允许我们创建 *家族* 的对象——在这种情况下，`ServerConfig` 是属性的一个 *父类*。
- en: 'The previous code is just one way to implement an Abstract Factory. You may
    find some implementations that rely on implementing an interface instead:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码只是实现抽象工厂的一种方式。你可能会发现一些实现依赖于实现接口：
- en: '[PRE163]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: This approach may be better if your Factory Methods grow to contain lots of
    code.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的工厂方法变得很长，这种方法可能更好。
- en: One last question you may have is where we can see Abstract Factory used in
    real code. One example is the `java.util.Collections` class. It has methods such
    as `emptyMap`, `emptyList`, and `emptySet`, which each generate a different class.
    However, what is common to all of them is that they are all collections.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能还有一个问题，那就是在哪里可以看到实际代码中使用的抽象工厂。一个例子是 `java.util.Collections` 类。它有 `emptyMap`、`emptyList`
    和 `emptySet` 等方法，每个方法都生成一个不同的类。然而，它们共同的特点是它们都是集合。
- en: Builder
  id: totrans-321
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建器
- en: Sometimes, our objects are very simple and have only one constructor, be it
    an empty or non-empty one. But sometimes, their creation is very complex and based
    on a lot of parameters. We've seen one pattern already that provides *a better
    constructor* – the Static Factory Method design pattern. Now, we'll discuss the
    **Builder** design pattern, which will help us create complex objects.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们的对象非常简单，只有一个构造函数，无论是空的还是非空的。但有时，它们的创建非常复杂，基于很多参数。我们已经看到了一个提供**更好的构造函数**的模式——静态工厂方法设计模式。现在，我们将讨论**Builder**设计模式，它将帮助我们创建复杂对象。
- en: As an example of such an object, imagine we need to design a system that sends
    emails. We won't implement the actual mechanism of sending them, we will just
    design a class that represents it.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这样一个对象的例子，想象我们需要设计一个发送电子邮件的系统。我们不会实现发送它们的实际机制，我们只是设计一个代表它的类。
- en: 'An email may have the following properties:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 一封电子邮件可能具有以下属性：
- en: An address (at least one is mandatory)
  id: totrans-325
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地址（至少一个必填）
- en: CC (optional)
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CC（可选）
- en: Title (optional)
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 标题（可选）
- en: Body (optional)
  id: totrans-328
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 正文（可选）
- en: Important flag (optional)
  id: totrans-329
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重要标志（可选）
- en: 'We can describe an email in our system as a `data class`:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在我们的系统中将电子邮件描述为一个`data class`：
- en: '[PRE173]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: 'Important Note:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Look at the definition of the last argument in the preceding code. This comma
    is not a typo. It is called a **trailing comma**, and these were introduced in
    **Kotlin 1.4**. This is done so you can easily change the order of the arguments.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下前面代码中最后一个参数的定义。这个逗号不是打字错误。它被称为**尾随逗号**，这些是在**Kotlin 1.4**中引入的。这样做是为了你可以轻松地改变参数的顺序。
- en: 'Next, let''s attempt to create an email addressed to our manager:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们尝试创建一封致我们经理的电子邮件：
- en: '[PRE180]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: Note that we have defined *carbon copy* (that's what `CC` stands for) as nullable
    so that it can receive either a list of emails or null. Another option would be
    to define it as `List<String>` and force our code to pass `listOf()`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已将*carbon copy*（这就是`CC`所代表的意思）定义为可空的，这样它就可以接收电子邮件列表或null。另一个选项是将它定义为`List<String>`并强制我们的代码传递`listOf()`。
- en: Since our constructor receives a lot of arguments, we had to put in some comments
    in order not to get confused.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的构造函数接收了大量的参数，我们不得不添加一些注释以避免混淆。
- en: '*But what happens if we need to change this class now?*'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，如果我们现在需要更改这个类会怎样呢？*'
- en: First, our code will stop compiling. Second, we need to keep track of the comments.
    In short, constructors with a long list of arguments quickly become a mess.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的代码将停止编译。其次，我们需要跟踪注释。简而言之，具有长参数列表的构造函数很快就会变得混乱。
- en: This is the problem the Builder design pattern sets out to solve. It decouples
    the assigning of arguments from the creation of objects and allows the creation
    of complex objects one step at a time. In this section, we'll see a number of
    approaches to this problem.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是Builder设计模式试图解决的问题。它将参数的分配与对象的创建解耦，并允许逐步创建复杂对象。在本节中，我们将看到解决这个问题的多种方法。
- en: 'Let''s start by creating a new class, `MailBuilder`, which will wrap our `Mail`
    class:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的类，`MailBuilder`，它将包装我们的`Mail`类：
- en: '[PRE186]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: Our builder has exactly the same properties as our resulting class. But these
    properties are all mutable.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构建器具有与我们的结果类完全相同的属性。但这些属性都是可变的。
- en: Note that the constructor is marked using the `internal` visibility modifier.
    This means that our `Mail` class will be accessible to any code inside our module.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，构造函数使用`internal`可见性修饰符标记。这意味着我们的`Mail`类将对我们模块内的任何代码都是可访问的。
- en: 'To finalize the creation of our class, we''ll introduce the `build()` function:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了最终创建我们的类，我们将引入`build()`函数：
- en: '[PRE201]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: '[PRE203]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: 'And for each property, we''ll have another function to be able to set it:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个属性，我们还需要另一个函数来设置它：
- en: '[PRE207]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: 'Now, we can use our builder to create an email in the following way:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的构建器以以下方式创建一个电子邮件：
- en: '[PRE212]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: After setting a new value, we return a reference to our object by using `this`,
    which provides us with access to the next setter to allow us to perform chaining
    (please refer to the *Fluent setters* section in this chapter for an explanation
    of this).
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置新值后，我们通过使用`this`返回对对象的引用，这为我们提供了访问下一个setter的权限，以便我们可以执行链式操作（请参阅本章的*流畅设置器*部分以了解解释）。
- en: 'This is a working approach. But it has a couple of downsides:'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个有效的方法。但它有几个缺点：
- en: The properties of our resulting class must be repeated insider the builder.
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们结果类的属性必须在构建器内部重复。
- en: For every property, we need to declare a function to set its value.
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个属性，我们需要声明一个函数来设置其值。
- en: Kotlin provides two other ways that you may find even more useful.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 提供了两种其他方法，你可能觉得它们更有用。
- en: Fluent setters
  id: totrans-390
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 流畅设置器
- en: 'The approach using `data class` constructor will contain only the mandatory
    fields. All other fields will become `private`, and we''ll provide setters for
    these fields:'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `data class` 构造函数的方法将仅包含必填字段。所有其他字段将变为 `private`，我们将为这些字段提供设置器：
- en: '[PRE213]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-398
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: 'Important Note:'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示：
- en: Using underscores for `private` variables is a common convention in Kotlin.
    It allows us to avoid repeating `this.message = message` and mistakes such as
    `message = message`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，使用下划线为 `private` 变量是常见的约定。这允许我们避免重复 `this.message = message` 和像 `message
    = message` 这样的错误。
- en: 'In this code example, we used the `apply` function. This is part of the family
    of scoping functions that can be invoked on every Kotlin object, and we''ll cover
    them in detail in [*Chapter 9*](B17816_09_ePub.xhtml#_idTextAnchor216), *Idioms
    and Anti-Patterns*. The `apply` function returns the reference to an object after
    executing the block. So, it''s a shorter version of the setter function from the
    previous example:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个代码示例中，我们使用了 `apply` 函数。这是可以调用在每个 Kotlin 对象上的作用域函数系列的一部分，我们将在 [*第 9 章*](B17816_09_ePub.xhtml#_idTextAnchor216)，*惯用和反模式*
    中详细讨论它们。`apply` 函数在执行代码块后返回对象的引用。因此，它是上一个示例中设置器函数的简短版本：
- en: '[PRE226]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: 'This provides us with the same API as the previous example:'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 这为我们提供了与上一个示例相同的 API：
- en: '[PRE230]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: However, we may not need setters at all. Instead, we can use the `apply()` function
    we previously discussed on the object itself. This is one of the extension functions
    that every object in Kotlin has. This approach will work only if all of the optional
    fields are *variables* instead of *values*.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们可能根本不需要设置器。相反，我们可以使用之前讨论过的 `apply()` 函数在对象本身上。这是 Kotlin 中每个对象都有的扩展函数之一。这种方法仅当所有可选字段都是
    `*变量*` 而不是 `*值*` 时才有效。
- en: 'Then, we can create our email like this:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以这样创建我们的电子邮件：
- en: '[PRE231]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: 'This is a nice approach, and it requires less code to implement. However, there
    are a few downsides to this approach too:'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的方法，它需要更少的代码来实现。然而，这种方法也有一些缺点：
- en: We had to make all of the optional arguments mutable. Immutable fields should
    always be preferred to mutable ones, as they are thread-safe and easier to reason
    about.
  id: totrans-421
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们不得不将所有可选参数变为可变的。应始终优先考虑不可变字段，因为它们是线程安全的，并且更容易推理。
- en: All of our optional arguments are also nullable. Kotlin is a null-safe language,
    so every time we access them, we first have to check that their value was set.
  id: totrans-422
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们的所有可选参数也都是可空的。Kotlin 是一个空安全语言，所以每次我们访问它们时，我们首先必须检查它们的值是否已设置。
- en: This syntax is very verbose. For each field, we need to repeat the same pattern
    over and over again.
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种语法非常冗长。对于每个字段，我们需要一次又一次地重复相同的模式。
- en: Now, let's discuss the last approach to this problem.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们讨论这个问题的最后一种方法。
- en: Default arguments
  id: totrans-425
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 默认参数
- en: 'In Kotlin, we can specify default values for constructor and function parameters:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Kotlin 中，我们可以为构造函数和函数参数指定默认值：
- en: '[PRE235]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-429
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: Default arguments are set using the `=` operator after the type. This means
    that although our constructor still has all the arguments, we don't need to provide
    them any.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 默认参数使用类型后面的 `=` 运算符设置。这意味着尽管我们的构造函数仍然有所有参数，但我们不需要提供它们。
- en: 'So, if you would like to create an email without a body, you can do it like
    this:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，如果你想创建一个没有正文的电子邮件，你可以这样做：
- en: '[PRE242]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: However, note that we had to specify that we don't want anyone in the CC field
    by providing an empty list, which is a bit inconvenient.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，我们必须通过提供一个空列表来指定我们不想在 CC 字段中包含任何人，这有点不方便。
- en: '*What if we wanted to send an email that is only flagged as important?*'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '*如果我们只想发送一个标记为重要的电子邮件怎么办？*'
- en: 'Not having to specify order with fluent setters was very handy. Kotlin has
    *named arguments* for that:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 不需要使用流畅设置器指定顺序非常方便。Kotlin 有 `*命名参数*` 来实现这一点：
- en: '[PRE243]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: Combining default parameters with named arguments makes creating complex objects
    in Kotlin rather easy. For that reason, you will rarely need the Builder design
    pattern at all in Kotlin.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 将默认参数与命名参数结合使用使得在 Kotlin 中创建复杂对象变得相当容易。因此，在 Kotlin 中，你几乎根本不需要 Builder 设计模式。
- en: In real applications, you'll often see the Builder design pattern used to construct
    instances of servers. A server would accept an optional host and an optional port
    and so on, and then when all of the arguments were set, you'd invoke a listen
    method to start it.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 在实际应用中，你经常会看到使用 Builder 设计模式来构建服务器的实例。服务器将接受可选的主机、可选的端口等，然后在所有参数都设置好之后，你会调用一个监听方法来启动它。
- en: Prototype
  id: totrans-443
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: The **Prototype** design pattern is all about customization and creating objects
    that are similar but slightly different. To understand it better, Let's look at
    an example.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '**原型**设计模式全部关于定制和创建相似但略有不同的对象。为了更好地理解它，让我们来看一个例子。'
- en: 'Imagine we have a system that manages users and their permissions. A `data
    class` representing a user might look like this:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 想象我们有一个管理系统，用于管理用户及其权限。表示用户的 `data class` 可能看起来像这样：
- en: '[PRE244]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Each user must have a role, and each role has a set of permissions.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 每个用户都必须有一个角色，每个角色都有一组权限。
- en: 'We''ll describe a role as an `enum` class:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把角色描述为一个 `enum` 类：
- en: '[PRE251]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-457
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: The `enum` classes are a way to represent a collection of constants. This is
    more convenient than representing a role as a string, for example, as we check
    at compile time that such an object exists.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 类是一种表示常量集合的方式。这比将角色表示为字符串更方便，例如，我们在编译时检查此类对象是否存在。'
- en: 'When we create a new *user*, we assign them permissions that are similar to
    another user with the same *role*:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建一个新的 *用户* 时，我们将为他们分配与具有相同 *角色* 的另一个用户相似的权限：
- en: '[PRE256]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-471
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-472
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Let''s imagine that we now need to add a new field to the `User` class, which
    we will name `tasks`:'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设现在我们需要向 `User` 类添加一个新字段，我们将它命名为 `tasks`：
- en: '[PRE267]'
  id: totrans-474
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-477
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-478
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-479
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: 'Our `createUser` function will stop compiling. We''ll have to change it by
    copying the value of this newly added field to the new instance of our class:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 `createUser` 函数将停止编译。我们将不得不通过将新添加字段的值复制到我们类的新的实例中来更改它：
- en: '[PRE275]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: This work will have to be repeated every time the `User` class is changed.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 每次更改 `User` 类时，都必须重复这项工作。
- en: 'However, there''s a bigger problem still: *What if a new requirement is introduced,
    making the* `permissions` *property, for example,* `private`*?*'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一个更大的问题：*如果引入了新的需求，使得* `permissions` *属性，例如，*变为 `private`*，会发生什么？*
- en: '[PRE276]'
  id: totrans-486
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-487
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-489
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-491
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: Our code will stop compiling again, and we'll have to change it again. The constant
    requirement of changes to the code is a clear indication that we need another
    approach to solve this problem.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码将再次停止编译，我们又将不得不再次更改它。代码更改的这种持续需求是我们需要另一种方法来解决这个问题的一个明显迹象。
- en: Starting from a prototype
  id: totrans-495
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从原型开始
- en: 'The whole idea of a *prototype* is to be able to clone an object easily. There
    are at least two reasons you may want to do this:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 原型的整个想法是能够轻松地克隆一个对象。至少有两个原因你可能想要这样做：
- en: It helps in instances where creating your object is very expensive – for example,
    if you need to fetch it from the database.
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当创建对象非常昂贵时，例如需要从数据库中获取它时，这很有帮助。
- en: It helps if you need to create objects that are similar but vary slightly and
    you don't want to repeat similar parts over and over again.
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你需要创建相似但略有不同的对象，并且不想反复重复相似的部分，这会很有帮助。
- en: 'Important Note:'
  id: totrans-499
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 重要提示：
- en: There are also more advanced reasons to use the Prototype design pattern. JavaScript,
    for example, uses prototypes to implement inheritance-like behavior without having
    classes.
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用原型设计模式还有更多高级的理由。例如，JavaScript 使用原型来实现类似于类的继承行为，而不需要类。
- en: 'Luckily, Kotlin fixes the somewhat broken Java `clone()` method. Data classes
    have a `copy()` method, which takes an existing `data class`, and creates a new
    copy of it, optionally changing some of its attributes in the process:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，Kotlin 修复了 Java `clone()` 方法的某些缺陷。数据类有一个 `copy()` 方法，它接受一个现有的 `data class`，并创建它的一个新副本，在此过程中可以选择更改一些属性：
- en: '[PRE284]'
  id: totrans-502
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-503
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-504
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-506
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-507
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-509
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-510
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-511
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-512
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: In a similar way to what we saw with the Builder design pattern, named arguments
    allow us to specify attributes that we can change in any order. And we need to
    specify only the attributes we want to change. All of the other data will be copied
    for us, even the `private` properties.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们之前看到的 Builder 设计模式，命名参数允许我们以任何顺序指定可以更改的属性。我们只需要指定我们想要更改的属性。所有其他数据都将为我们复制，即使是
    `private` 属性。
- en: The `data class` is yet another example of a design pattern that is so common
    that it became part of a language syntax. They are an extremely useful feature,
    and we will see them being used many more times in this book.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '`data class` 是一种非常常见的设计模式，它已经成为语言语法的一部分。这是一个极其有用的特性，我们将在本书中多次看到它的应用。'
- en: Summary
  id: totrans-515
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have learned when and how to use creational design patterns.
    We started by discussing how to use the `object` keyword to construct a singleton
    class, and then we discussed the use of `companion object` if you need a Static
    Factory Method. We also covered how to assign multiple variables at once using
    destructuring declarations.
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了何时以及如何使用创建型设计模式。我们首先讨论了如何使用`object`关键字来构造单例类，然后讨论了如果需要静态工厂方法时如何使用`companion
    object`。我们还介绍了如何使用解构声明一次性分配多个变量。
- en: Then, we discussed smart casts, and how they can be applied in the Abstract
    Factory design pattern to create families of objects. We then moved to the Builder
    design pattern and learned that functions can have default parameter values. We
    then learned that we can refer to their arguments using not only positions but
    also names.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们讨论了智能转换，以及它们如何在抽象工厂设计模式中应用以创建对象系列。接着，我们转向建造者设计模式，并了解到函数可以有默认参数值。然后我们学习了我们可以不仅通过位置，还可以通过名称来引用它们的参数。
- en: Finally, we covered the `copy()` function of the data classes, and how it helps
    us when implementing the Prototype design pattern to produce similar objects with
    slight changes. You should now understand how to use creational design patterns
    to better manage your objects.
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们介绍了数据类的`copy()`函数，以及它在实现原型设计模式时如何帮助我们产生略有不同的相似对象。你现在应该理解了如何使用创建型设计模式来更好地管理你的对象。
- en: 'In the next chapter, we''ll cover the second family of design patterns: **structural
    patterns**. These design patterns will help us create extensible and maintainable
    object hierarchies.'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将介绍设计模式的第二组：**结构型模式**。这些设计模式将帮助我们创建可扩展和维护的对象层次结构。
- en: Questions
  id: totrans-520
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Name two uses for the `object` keyword we learned about in this chapter.
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出我们在本章中学到的`object`关键字的两个用途。
- en: What is the `apply()` function used for?
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`apply()`函数是用来做什么的？'
- en: Provide one example of a Static Factory Method.
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个静态工厂方法的示例。
