- en: Chapter 4. The Basics of Our Game
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章.我们游戏的基础
- en: '*In the previous chapter, we learned about assets and how to implement our
    own asset management system which loads the assets from the application bundle
    and caches them. We used the asset management setup to load our first image. We
    covered how to group display objects into scenes and wrote a scene director that
    manages our scenes. In this chapter, we will begin setting up our game. We will
    learn about what to consider when targeting different devices, and we will take
    the first step in setting up our game. This includes creating the scenes we need
    and displaying static images on the screen.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*在上一章中，我们学习了资源以及如何实现自己的资源管理系统，该系统从应用程序包中加载资源并对其进行缓存。我们使用资源管理系统来加载我们的第一张图像。我们介绍了如何将显示对象分组到场景中，并编写了一个场景导演来管理我们的场景。在本章中，我们将开始设置我们的游戏。我们将了解针对不同设备时应考虑的因素，并开始设置我们的游戏的第一步。这包括创建我们需要的场景和在屏幕上显示静态图像。*'
- en: Taking care of cross-device compatibility
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注意跨设备兼容性
- en: 'When developing an iOS game, we need to know which device to target. Besides
    the obvious technical differences between all of the iOS devices, there are two
    factors we need to actively take care of: screen size and texture size limit.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发iOS游戏时，我们需要知道要针对哪个设备。除了所有iOS设备之间明显的技术差异之外，还有两个因素我们需要积极关注：屏幕尺寸和纹理尺寸限制。
- en: Note
  id: totrans-4
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a quick reference on the differences between iOS devices, take a look at
    the comparison table at [http://www.iosres.com/](http://www.iosres.com/).
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 要快速了解iOS设备之间的差异，请查看[http://www.iosres.com/](http://www.iosres.com/)上的比较表。
- en: Let's take a closer look at how to deal with the texture size limit and screen
    sizes.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看如何处理纹理尺寸限制和屏幕尺寸。
- en: Understanding the texture size limit
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解纹理尺寸限制
- en: Every graphics card has a limit for the maximum size texture it can display.
    If a texture is bigger than the texture size limit, it can't be loaded and will
    appear black on the screen. A texture size limit has **power-of-two** dimensions
    and is a square such as 1024 pixels in width and in height or 2048 x 2048 pixels.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 每个图形卡都有一个最大纹理尺寸的限制，它可以显示。如果一个纹理的大小超过了纹理尺寸限制，它将无法加载，并在屏幕上显示为黑色。纹理尺寸限制具有**2的幂**维度，是一个正方形，如宽度为1024像素，高度也为1024像素，或者2048
    x 2048像素。
- en: When loading a texture, they don't need to have power-of-two dimensions. In
    fact, the texture does not have to be a square. However, it is a best practice
    for a texture to have power-of-two dimensions.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当加载纹理时，它们不需要有2的幂维度。实际上，纹理不需要是正方形。然而，纹理具有2的幂维度是一个最佳实践。
- en: 'This limit holds for big images as well as a bunch of small images packed into
    a big image. The latter is commonly referred to as a sprite sheet. Take a look
    at the following sample sprite sheet to see how it''s structured:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制适用于大图像以及打包在一个大图像中的许多小图像。后者通常被称为精灵表。看看以下示例精灵表，了解其结构：
- en: '![Understanding the texture size limit](img/1509OS_04_01.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![理解纹理尺寸限制](img/1509OS_04_01.jpg)'
- en: How to deal with different screen sizes
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何处理不同的屏幕尺寸
- en: While the screen size is always measured in pixels, the iOS coordinate system
    is measured in points.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然屏幕尺寸始终以像素为单位进行测量，但iOS坐标系是以点为单位进行测量的。
- en: 'The screen size of an iPhone 3GS is 320 x 480 pixels and also 320 x 480 points.
    On an iPhone 4, the screen size is 640 x 960 pixels, but is still 320 by 480 points.
    So, in this case, each point represents four pixels: two in width and two in height.
    A 100-point wide rectangle will be 200 pixels wide on an iPhone 4 and 100 pixels
    on an iPhone 3GS.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: iPhone 3GS的屏幕尺寸为320 x 480像素，也是320 x 480点。在iPhone 4上，屏幕尺寸为640 x 960像素，但仍然是320
    x 480点。因此，在这种情况下，每个点代表四个像素：宽度和高度各两个。一个100点宽的矩形在iPhone 4上将是200像素宽，而在iPhone 3GS上则是100像素。
- en: It works similarly for the devices with large display screens, such as the iPhone
    5\. Instead of 480 points, it's 568 points.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有大显示屏的设备，如iPhone 5，它的工作方式类似。而不是480点，它是568点。
- en: '![How to deal with different screen sizes](img/1509OS_04_02.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![如何处理不同的屏幕尺寸](img/1509OS_04_02.jpg)'
- en: Scaling the viewport
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缩放视口
- en: 'Let''s explain the term viewport first: the viewport is the visible portion
    of the complete screen area.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先解释一下视口这个术语：视口是整个屏幕区域中可见的部分。
- en: We need to be clear about which devices we want our game to run on. We take
    the biggest resolution that we want to support and scale it down to a smaller
    resolution. This is the easiest option, but it might not lead to the best results;
    touch areas and the user interface scale down as well. Apple recommends for touch
    areas to be at least a 40-point square; so, depending on the user interface, some
    elements might get scaled down so much that they get harder to touch.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要明确我们希望我们的游戏在哪些设备上运行。我们选择我们想要支持的最大的分辨率，并将其缩放到较小的分辨率。这是一个最简单的选项，但它可能不会产生最佳结果；触摸区域和用户界面也会缩放。苹果建议触摸区域至少为
    40 点的平方；因此，根据用户界面，某些元素可能会缩放得太多，以至于难以触摸。
- en: 'Take a look at the following screenshot, where we choose the iPad Retina resolution
    (2048 x 1536 pixels) as our biggest resolution and scale down all display objects
    on the screen for the iPad resolution (1024 x 768 pixels):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看看下面的截图，我们选择了 iPad Retina 分辨率（2048 x 1536 像素）作为我们的最大分辨率，并将屏幕上的所有显示对象缩放到 iPad
    分辨率（1024 x 768 像素）：
- en: '![Scaling the viewport](img/1509OS_04_03.jpg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![缩放视口](img/1509OS_04_03.jpg)'
- en: Scaling is a popular option for non-iOS environments, especially for PC and
    Mac games that support resolutions from 1024 x 600 pixels to full HD.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放是非 iOS 环境中的一种流行选项，尤其是对于支持从 1024 x 600 像素到全高清分辨率的 PC 和 Mac 游戏。
- en: As we will learn later in this chapter, Sparrow and the iOS SDK provide some
    mechanisms that will facilitate handling Retina and non-Retina iPad devices without
    the need to scale the whole viewport.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在本章后面学到的那样，Sparrow 和 iOS SDK 提供了一些机制，可以简化处理 Retina 和非 Retina iPad 设备，而无需对整个视口进行缩放。
- en: Black borders
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 黑色边框
- en: Some games in the past have been designed for a 4:3 resolution display but then
    made to run on a widescreen device that had more screen space.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 过去有些游戏是为 4:3 分辨率显示器设计的，但后来被修改为在具有更多屏幕空间的宽屏设备上运行。
- en: So, the option was to either scale a 4:3 resolution to widescreen, which will
    distort the whole screen, or put some black borders on either side of the screen
    to maintain the original scale factor.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择是将 4:3 分辨率缩放到宽屏，这将扭曲整个屏幕，或者将黑色边框放在屏幕的两侧以保持原始的缩放因子。
- en: '![Black borders](img/1509OS_04_04.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![黑色边框](img/1509OS_04_04.jpg)'
- en: Showing black borders is something that is now considered as bad practice, especially
    when there are so many games out there which scale quite well across different
    screen sizes and platforms.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 显示黑色边框现在被认为是一种不良做法，尤其是在有那么多游戏能够很好地适应不同屏幕尺寸和平台的情况下。
- en: Showing non-interactive screen space
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显示非交互式屏幕空间
- en: If our pirate game is a multiplayer, we may have a player on an iPad and another
    on an iPhone 5\. So, the player with the iPad has a bigger screen and more screen
    space to maneuver their ship. The worst case will be if the player with the iPad
    is able to move their ship outside the visual range for the iPhone player to see,
    which will result in a serious advantage for the iPad player.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的海盗游戏是多人游戏，我们可能会有一个玩家在使用 iPad，另一个玩家在使用 iPhone 5。因此，使用 iPad 的玩家有更大的屏幕和更多的屏幕空间来操控他们的船只。最坏的情况是，如果使用
    iPad 的玩家能够将他们的船只移动到 iPhone 玩家看不到的视觉范围之外，这将给 iPad 玩家带来严重优势。
- en: Luckily for us, we don't require competitive multiplayer functionality. Still,
    we need to keep a consistent screen space for players to move their ship in for
    game balance purposes. We wouldn't want to tie the difficulty level to the device
    someone is playing on.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们不需要竞争性多人游戏功能。然而，为了游戏平衡的目的，我们需要保持一致的屏幕空间，让玩家可以在其中移动他们的船只。我们不想将难度级别与玩家所使用的设备绑定。
- en: '![Showing non-interactive screen space](img/1509OS_04_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![显示非交互式屏幕空间](img/1509OS_04_05.jpg)'
- en: Let's compare the previous screenshot to the black border example. Instead of
    the ugly black borders, we just show more of the background.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较之前的截图和黑色边框示例。我们不是展示难看的黑色边框，而是展示更多的背景。
- en: In some cases, it's also possible to move some user interface elements to the
    areas which are not visible on other devices. However, we will need to consider
    whether we want to keep the same user experience across devices and whether moving
    these elements will result in a disadvantage for users who don't have this extra
    screen space on their devices.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，还可以将一些用户界面元素移动到其他设备上不可见的区域。然而，我们需要考虑我们是否希望在不同设备上保持相同的用户体验，以及移动这些元素是否会给那些没有这种额外屏幕空间的用户带来不利。
- en: Rearranging screen elements
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新排列屏幕元素
- en: Rearranging screen elements is probably the most time-intensive and sophisticated
    way of solving this issue. In this example, we have a big user interface at the
    top of the screen in the portrait mode. Now, if we were to leave it like this
    in the landscape mode, the top of the screen will be just the user interface,
    leaving very little room for the game itself.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重新排列屏幕元素可能是解决这个问题的最耗时和最复杂的方法。在这个例子中，我们在纵向模式下屏幕顶部有一个大的用户界面。现在，如果我们保持这种状态在横向模式下，屏幕顶部将只是用户界面，留给游戏本身的空间非常有限。
- en: '![Rearranging screen elements](img/1509OS_04_06.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![重新排列屏幕元素](img/1509OS_04_06.jpg)'
- en: In this case, we have to be deliberate about what kind of elements we need to
    see on the screen and which elements are using up too much screen estate. **Screen
    real estate** (or screen estate) is the amount of space available on a display
    for an application or a game to provide output. We will then have to reposition
    them, cut them up in to smaller pieces, or both.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们必须明确我们希望在屏幕上看到哪些元素，以及哪些元素占用了过多的屏幕空间。"屏幕空间"（或屏幕空间）是指应用程序或游戏在显示上可用的空间量。然后我们必须重新定位它们，将它们切割成更小的部分，或者两者都要做。
- en: The most prominent example of this technique is *Candy Crush* (a popular trending
    game) by King. While this concept applies particularly to device rotation, this
    does not mean that it can't be used for universal applications.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这种技术的最突出例子是King的"Candy Crush"（一款流行的热门游戏）。虽然这个概念特别适用于设备旋转，但这并不意味着它不能用于通用应用程序。
- en: Choosing the best option
  id: totrans-40
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 选择最佳选项
- en: None of these options are mutually exclusive. For our purposes, we are going
    to show non-interactive screen space, and if things get complicated, we might
    also resort to rearranging screen elements depending on our needs.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些选项之间并不相互排斥。就我们的目的而言，我们将显示非交互式屏幕空间，如果事情变得复杂，我们可能还需要根据我们的需求重新排列屏幕元素。
- en: Differences between various devices
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 不同设备之间的差异
- en: 'Let''s take a look at the differences in the screen size and the texture size
    limit between the different iOS devices:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看不同iOS设备之间屏幕尺寸和纹理尺寸限制的差异：
- en: '| Device | Screen size (in pixels) | Texture size limit (in pixels) |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | 屏幕尺寸（以像素为单位） | 纹理尺寸限制（以像素为单位） |'
- en: '| --- | --- | --- |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| iPhone 3GS | 480 x 360 | 2048 x 2048 |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 3GS | 480 x 360 | 2048 x 2048 |'
- en: '| iPhone 4 (including iPhone 4S) and iPod Touch 4^(th) generation | 960 x 640
    | 2048 x 2048 |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 4（包括iPhone 4S）和iPod Touch第4代 | 960 x 640 | 2048 x 2048 |'
- en: '| iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch 5^(th) generation
    | 1136 x 640 | 2048 x 2048 |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 5（包括iPhone 5C和iPhone 5S）和iPod Touch第5代 | 1136 x 640 | 2048 x 2048
    |'
- en: '| iPad 2 | 1024 x 768 | 2048 x 2048 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| iPad 2 | 1024 x 768 | 2048 x 2048 |'
- en: '| iPad (3^(rd) and 4^(th) generations) and iPad Air | 2048 x 1536 | 4096 x
    4096 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| iPad（第3代和第4代）和iPad Air | 2048 x 1536 | 4096 x 4096 |'
- en: '| iPad Mini | 1024 x 768 | 4096 x 4096 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| iPad Mini | 1024 x 768 | 4096 x 4096 |'
- en: Utilizing the iOS SDK
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用iOS SDK
- en: Both the iOS SDK and Sparrow can aid us in creating a universal application.
    Universal application is the term for apps that target more than one device, especially
    for an app that targets the iPhone and iPad device family.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK和Sparrow都可以帮助我们创建通用应用程序。通用应用程序是指针对多个设备的应用程序，特别是针对iPhone和iPad设备系列的应用程序。
- en: The iOS SDK provides a handy mechanism for loading files for specific devices.
    Let's say we are developing an iPhone application and we have an image that's
    called `my_amazing_image.png`. If we load this image on our devices, it will get
    loaded—no questions asked. However, if it's not a universal application, we can
    only scale the application using the regular scale button on iPad and iPhone Retina
    devices. This button appears on the bottom-right of the screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: iOS SDK提供了一个方便的机制来加载特定设备的文件。假设我们正在开发iPhone应用程序，并且我们有一个名为`my_amazing_image.png`的图像。如果我们将此图像加载到我们的设备上，它将被加载——无需质疑。然而，如果它不是通用应用程序，我们只能使用iPad和iPhone
    Retina设备上的常规缩放按钮来缩放应用程序。此按钮位于屏幕的右下角。
- en: 'If we want to target iPad, we have two options:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要针对iPad进行开发，我们有两个选择：
- en: The first option is to load the image as is. The device will scale the image.
    Depending on the image quality, the scaled image may look bad. In this case, we
    also need to consider that the device's CPU will do all the scaling work, which
    might result in some slowdown depending on the app's complexity.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个选项是将图像按原样加载。设备将缩放图像。根据图像质量，缩放后的图像可能看起来很糟糕。在这种情况下，我们还需要考虑设备的CPU将执行所有的缩放工作，这可能会根据应用程序的复杂度导致一些减速。
- en: The second option is to add an extra image for iPad devices. This one will use
    the `~ipad` suffix, for example, `my_amazing_image~ipad.png`. When loading the
    required image, we will still use the filename `my_amazing_image.png`. The iOS
    SDK will automatically detect the different sizes of the image supplied and use
    the correct size for the device.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择是为iPad设备添加一个额外的图片。这个图片将使用`~ipad`后缀，例如，`my_amazing_image~ipad.png`。在加载所需的图片时，我们仍然使用文件名`my_amazing_image.png`。iOS
    SDK将自动检测提供的图片的不同尺寸，并使用适合设备的正确尺寸。
- en: Beginning with Xcode 5 and iOS 7, it is possible to use asset catalogs. Asset
    catalogs can contain a variety of images grouped into image sets. Image sets contain
    all the images for the targeted devices. These asset catalogs don't require files
    with suffixes any more. These can only be used for splash images and application
    icons. We can't use asset catalogs for textures we load with Sparrow though.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 从Xcode 5和iOS 7开始，可以使用资源包。资源包可以包含各种图片，这些图片被分组到图片集中。图片集包含针对目标设备的所有图片。这些资源包不再需要带有后缀的文件。这些资源包只能用于启动图片和应用程序图标。但我们不能使用资源包来加载Sparrow中使用的纹理。
- en: 'The following table shows which suffix is needed for which device:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格显示了为哪种设备需要哪种后缀：
- en: '| Device | Retina | File suffix |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | Retina | 文件后缀 |'
- en: '| --- | --- | --- |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| iPhone 3GS | No | None |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 3GS | 否 | 无 |'
- en: '| iPhone 4 (including iPhone 4S) and iPod Touch (4^(th) generation) | Yes |
    `@2x``@2x~iphone` |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 4（包括iPhone 4S）和iPod Touch（第4代） | 是 | `@2x` `@2x~iphone` |'
- en: '| iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch (5^(th) generation)
    | Yes | `-568h@2x` |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 5（包括iPhone 5C和iPhone 5S）和iPod Touch（第5代） | 是 | `-568h@2x` |'
- en: '| iPad 2 | No | `~ipad` |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| iPad 2 | 否 | `~ipad` |'
- en: '| iPad (3^(rd) and 4^(th) generations) and iPad Air | Yes | `@2x~ipad` |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '| iPad（第3代和第4代）和iPad Air | 是 | `@2x~ipad` |'
- en: '| iPad Mini | No | `~ipad` |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '| iPad Mini | 否 | `~ipad` |'
- en: How does this affect the graphics we wish to display? The non-Retina image will
    be 128 pixels in width and 128 pixels in height. The Retina image, the one with
    the `@2x` suffix, will be exactly double the size of the non-Retina image, that
    is, 256 pixels in width and 256 pixels in height.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这如何影响我们希望显示的图形？非Retina图片的宽度将是128像素，高度是128像素。Retina图片，即带有`@2x`后缀的图片，将是非Retina图片的两倍大小，即256像素宽和256像素高。
- en: '![Utilizing the iOS SDK](img/1509OS_04_07.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![利用iOS SDK](img/1509OS_04_07.jpg)'
- en: Retina and iPad support in Sparrow
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sparrow中的Retina和iPad支持
- en: Sparrow supports all the filename suffixes shown in the previous table, and
    there is a special case for iPad devices, which we will take a closer look at
    now.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Sparrow支持之前表格中显示的所有文件名后缀，并且对于iPad设备有一个特殊情况，我们现在将更详细地探讨。
- en: 'When we take a look at `AppDelegate.m` in our game''s source, note the following
    line:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们查看我们游戏源代码中的`AppDelegate.m`时，注意以下行：
- en: '[PRE0]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first parameter, `supportHighResolutions`, tells the application to load
    Retina images (with the `@2x` suffix) if they are available.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数`supportHighResolutions`告诉应用程序如果可用，则加载Retina图片（带有`@2x`后缀）。
- en: The `doubleOnPad` parameter is the interesting one. If this is set to `true`,
    Sparrow will use the `@2x` images for iPad devices. So, we don't need to create
    a separate set of images for iPad, but we can use the Retina iPhone images for
    the iPad application.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`doubleOnPad`参数是其中一个有趣的参数。如果将其设置为`true`，Sparrow将为iPad设备使用`@2x`图片。因此，我们不需要为iPad创建一组单独的图片，而是可以使用Retina
    iPhone图片为iPad应用程序使用。'
- en: In this case, the width and height are 512 and 384 points respectively. If we
    are targeting iPad Retina devices, Sparrow introduces the `@4x` suffix, which
    requires larger images and leaves the coordinate system at 512 x 384 points.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，宽度和高度分别是512点和384点。如果我们针对的是iPad Retina设备，Sparrow引入了`@4x`后缀，这需要更大的图片，并将坐标系保持在512
    x 384点。
- en: App icons and splash images
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序图标和启动图片
- en: If we are talking about images of different sizes for the actual game content,
    app icons and splash images are also required to be in different sizes.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们谈论的是实际游戏内容的不同尺寸的图片，应用程序图标和启动图片也必须以不同的尺寸存在。
- en: '**Splash images** (also referred to as launch images) are the images that show
    up while the application loads. The iOS naming scheme applies for these images
    as well, so for Retina iPhone devices such as iPhone 4, we will name an image
    as `Default@2x.png,` and for iPhone 5 devices, we will name an image as `Default-568h@2x.png`.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**启动图片**（也称为启动图像）是在应用程序加载时显示的图片。这些图片也遵循iOS的命名方案，因此对于像iPhone 4这样的Retina iPhone设备，我们将图片命名为`Default@2x.png`，而对于iPhone
    5设备，我们将图片命名为`Default-568h@2x.png`。'
- en: 'For the correct size of app icons, take a look at the following table:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确的大小应用图标，请查看以下表格：
- en: '| Device | Retina | App icon size |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 设备 | Retina | 应用图标大小 |'
- en: '| --- | --- | --- |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| iPhone 3GS | No | 57 x 57 pixels |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 3GS | 否 | 57 x 57 像素 |'
- en: '| iPhone 4 (including iPhone 4S) and iPod Touch 4^(th) generation | Yes | 120
    x 120 pixels |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 4（包括iPhone 4S）和iPod Touch第4代 | 是 | 120 x 120 像素 |'
- en: '| iPhone 5 (including iPhone 5C and iPhone 5S) and iPod Touch 5^(th) generation
    | Yes | 120 x 120 pixels |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| iPhone 5（包括iPhone 5C和iPhone 5S）和iPod Touch第5代 | 是 | 120 x 120 像素 |'
- en: '| iPad 2 | No | 76 x 76 pixels |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| iPad 2 | 否 | 76 x 76 像素 |'
- en: '| iPad (3^(rd) and 4^(th) generation) and iPad Air | Yes | 152 x 152 pixels
    |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| iPad（第3代和第4代）和iPad Air | 是 | 152 x 152 像素 |'
- en: '| iPad Mini | No | 76 x 76 pixels |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| iPad Mini | 否 | 76 x 76 像素 |'
- en: The bottom line
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 核心内容
- en: The more devices we want to support, the more graphics we need, which directly
    increases the application file size, of course. Adding iPad support to our application
    is not a simple task, but Sparrow does some groundwork.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要支持的设备越多，需要的图形就越多，这直接增加了应用程序的文件大小。当然，将iPad支持添加到我们的应用程序不是一项简单的任务，但Sparrow做了一些基础工作。
- en: 'One thing we should keep in mind though: if we are only targeting iOS 7.0 and
    higher, we don''t need to include non-Retina iPhone images any more. Using `@2x`
    and `@4x` will be enough in this case, as support for non-Retina devices will
    soon end.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们需要记住一件事：如果我们只针对iOS 7.0及以上版本，我们不再需要包含非Retina iPhone图像。在这种情况下，使用`@2x`和`@4x`就足够了，因为非Retina设备的支持将很快结束。
- en: Starting with the development of our game
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从我们游戏开发开始
- en: Now that we have enough theory and experience with the Sparrow framework, let's
    put all that knowledge to use and turn theory into practice by creating our pirate
    game.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经足够了解Sparrow框架的理论和实践经验，让我们将所有这些知识应用到实际中，通过创建我们的海盗游戏来将理论转化为实践。
- en: Note
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you miss any of the development of our game, the source code of the game
    is also available on GitHub at [https://github.com/freezedev/pirategame](https://github.com/freezedev/pirategame).
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你错过了我们游戏的任何开发阶段，游戏的源代码也已在GitHub上提供，网址为[https://github.com/freezedev/pirategame](https://github.com/freezedev/pirategame)。
- en: 'Our game consists of two main gameplay parts:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏由两个主要游戏玩法部分组成：
- en: '**Battlefield/arena**: This is the scene where our pirate ship battles against
    other ships'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**战场/竞技场**：这是我们海盗船与其他船只战斗的场景'
- en: '**Pirate cove**: The pirate cove is the hub for activities after battling other
    ships such as hiring new crew members and upgrading the ship'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**海盗湾**：海盗湾是与其他船只战斗后的活动中心，如雇佣新船员和升级船只'
- en: In this chapter, we will set up the required scenes and load the textures, display
    them as images, and arrange the entities on the screen.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将设置所需的场景并加载纹理，将它们显示为图像，并在屏幕上排列实体。
- en: Note
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The graphics for the game are on GitHub as well: [https://github.com/freezedev/pirategame-assets](https://github.com/freezedev/pirategame-assets).
    The graphics are made with the open-source 3D modeling software, Blender ([http://www.blender.org](http://www.blender.org));
    Version 2.69 is required to open and edit these files. Don''t worry, we don''t
    need to update these files for the purposes of this book, but if you want to in
    order to look for inspiration, you are definitely encouraged to do so.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏的图形也在GitHub上：[https://github.com/freezedev/pirategame-assets](https://github.com/freezedev/pirategame-assets)。这些图形是用开源3D建模软件Blender制作的([http://www.blender.org](http://www.blender.org))；需要2.69版本才能打开和编辑这些文件。不用担心，我们不需要更新这些文件来完成本书的目的，但如果你想要寻找灵感，你绝对被鼓励这样做。
- en: 'Let''s download the required images for this chapter by navigating to [https://github.com/freezedev/pirategame-assets/releases](https://github.com/freezedev/pirategame-assets/releases).
    This will show all the available releases for this particular repository, as shown
    in the following screenshot:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过导航到[https://github.com/freezedev/pirategame-assets/releases](https://github.com/freezedev/pirategame-assets/releases)下载本章所需的图像。这将显示此特定存储库的所有可用版本，如下面的截图所示：
- en: '![Starting with the development of our game](img/1509OS_04_08.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![从我们游戏开发开始](img/1509OS_04_08.jpg)'
- en: 'Go ahead and download the `Graphics.zip` package and unzip the contents somewhere
    on your computer. This package contains the following images:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 请继续下载`Graphics.zip`包，并将其内容解压缩到你的电脑上的某个位置。此包包含以下图像：
- en: '| Filename | Description |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 文件名 | 描述 |'
- en: '| --- | --- |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `water.png` | This is the background for the battlefield scene. |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `water.png` | 这是战场场景的背景。 |'
- en: '| `island.png` | This is the background for the pirate base. Technically, it''s
    more of an island than a cove, which is why this image is called island, but it''s
    referred to as the pirate cove everywhere else. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `island.png` | 这是海盗基地的背景。技术上，它更像是一个岛屿而不是海湾，这就是为什么这个图像被称为岛屿，但其他地方都称之为海盗湾。
    |'
- en: '| `house.png` | This is a shelter for our pirates. |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `house.png` | 这是我们的海盗的避难所。 |'
- en: '| `tavern.png` | This is the building where we get to hire new pirates. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `tavern.png` | 这是我们可以雇佣新海盗的建筑。 |'
- en: '| `weaponsmith.png` | This will be the place where we upgrade our ship with
    additional cannons or ammunition. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `weaponsmith.png` | 这将是我们在船上升级额外大炮或弹药的地方。 |'
- en: '| `ship.png` | This is our basic enemy. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `ship.png` | 这是我们基本的敌人。 |'
- en: '| `ship_pirate.png` | This is the ship we are going to control. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `ship_pirate.png` | 这是我们将要控制的船只。 |'
- en: All of the assets are in a non-Retina resolution, Retina for iPad 2, iPad Mini,
    and iPhone/iPod Touch using the `@2x` filename suffix and `@4x` for iPad Retina
    devices.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 所有资源都在非Retina分辨率下，iPad 2、iPad Mini和iPhone/iPod Touch使用`@2x`文件后缀，iPad Retina设备使用`@4x`。
- en: Drag and drop the files into the `Resources` folder of our Xcode project. When
    a dialog pops up, we need to check **Copy items into destination group's folder
    (if needed)**, so we don't have to worry about references to the original files.
    Click on **Finish** to start the process.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件拖放到Xcode项目的`Resources`文件夹中。当弹出对话框时，我们需要勾选**Copy items into destination group's
    folder (if needed)**，这样我们就不必担心对原始文件的引用。点击**Finish**开始过程。
- en: So far, the images have been optimized for the landscape mode, so we need to
    deactivate the portrait mode for now. We need to select the **PirateGame** project
    and uncheck **Portrait** and **Upside Down** in the **Deployment Info** section,
    as shown in the following screenshot. Make sure to uncheck them for both iPhone
    and iPad.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，图像已经针对横幅模式进行了优化，因此我们现在需要暂时禁用纵向模式。我们需要选择**PirateGame**项目，并在**Deployment
    Info**部分取消勾选**Portrait**和**Upside Down**，如下面的截图所示。确保为iPhone和iPad都取消勾选。
- en: '![Starting with the development of our game](img/1509OS_04_09.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![从我们游戏开发开始](img/1509OS_04_09.jpg)'
- en: We can also safely delete the cardboard puppet doll code that is still in our
    `Game.m` file.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以安全地删除仍然存在于我们的`Game.m`文件中的纸板木偶代码。
- en: Creating our scene manager setup
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建我们的场景管理器设置
- en: In the previous chapter, we created a scene manager which we will now use for
    our scenes. In our first step, we will need two dummy scenes that we will later
    fill with gameplay mechanics. We will also need to add these scenes to our scene
    director and display one of the two scenes.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们创建了一个场景管理器，我们现在将使用它来处理场景。在我们的第一步中，我们需要两个占位符场景，稍后我们将填充它们以包含游戏机制。我们还需要将这些场景添加到场景导演中，并显示这两个场景之一。
- en: Time for action – creating our scene manager setup
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 创建我们的场景管理器设置
- en: 'To create our scene manager setup, we need to follow these steps:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 创建我们的场景管理器设置，我们需要遵循以下步骤：
- en: Open your Xcode game template if it's not already open.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果尚未打开，请打开您的Xcode游戏模板。
- en: Right-click on the **Classes** folder and select **New Group**.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**Classes**文件夹并选择**New Group**。
- en: Rename the group to **GameScenes**.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将组重命名为**GameScenes**。
- en: Create a new Objective-C class called `PirateCove` which is sub-classed from
    `Scene`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为`PirateCove`的Objective-C类，它是`Scene`类的子类。
- en: 'Add an initializer with the following content:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化器，内容如下：
- en: '[PRE1]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Create another Objective-C class which is sub-classed from `Scene`. Call this
    `Battlefield`.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个从`Scene`类派生的Objective-C类。将其命名为`Battlefield`。
- en: 'Add an initializer with the following content:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个初始化器，内容如下：
- en: '[PRE2]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Switch to the `Game.m` file.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Game.m`文件。
- en: 'Add the `PirateCove.h`, `Battlefield.h`, and `SceneDirector.h` files to the
    `import` section, as shown in the following code:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PirateCove.h`、`Battlefield.h`和`SceneDirector.h`文件添加到`import`部分，如下面的代码所示：
- en: '[PRE3]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `init` method, create an instance of the `PirateCove` and `Battlefield`
    classes and call the `initWithName` method using `@"piratecove"` and `@"battlefield"`
    respectively for its parameter:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`init`方法中，创建`PirateCove`和`Battlefield`类的实例，并使用`@"piratecove"`和`@"battlefield"`分别作为参数调用`initWithName`方法：
- en: '[PRE4]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Create an instance of the scene director and add it to the `Game` class, as
    shown in the following code:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建场景导演的实例并将其添加到`Game`类中，如下面的代码所示：
- en: '[PRE5]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add both scenes to the scene director and show the pirate cove scene:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个场景添加到场景导演中，并显示海盗湾场景：
- en: '[PRE6]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Run the example and you will get the following output:![Time for action – creating
    our scene manager setup](img/1509OS_04_10.jpg)
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![实战时间 – 创建我们的场景管理设置](img/1509OS_04_10.jpg)
- en: '*What just happened?*'
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened our Xcode template from where we left off in the previous
    chapter. In step 2, we created a new group where everything that is related to
    our game scenes will be put. In step 3, we renamed the newly created group.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们从上一章结束的地方打开了我们的 Xcode 模板。在步骤 2 中，我们创建了一个新组，所有与我们的游戏场景相关的文件都将放入这个组中。在步骤
    3 中，我们重命名了新创建的组。
- en: In step 4, we created a new Objective-C class, which is derived from the `Scene`
    class. In the next step, we added the initializer method where we added a log
    message to see whether the scene has been created.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 4 中，我们创建了一个新的 Objective-C 类，它继承自 `Scene` 类。在下一个步骤中，我们添加了初始化方法，其中添加了一个日志消息以查看场景是否已创建。
- en: In steps 6 and 7, we did the same for the battlefield scene.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 6 和 7 中，我们对战场场景做了同样的操作。
- en: After we switched to the `Game.m` file in step 8, we imported all the source
    files we need, which is the header from the scene director and both scenes we
    just created.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 8 中，我们切换到 `Game.m` 文件后，导入了所有需要的源文件，即场景导演的头文件以及我们刚刚创建的两个场景。
- en: We created instances of our scenes and our scene director in step 11\. The scene
    director is a sprite itself, so we need to add it to the `Game` class, which also
    derives from `SPSprite`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 11 中，我们创建了场景和场景导演的实例。场景导演本身就是一个精灵，因此我们需要将其添加到 `Game` 类中，该类也继承自 `SPSprite`。
- en: In step 12, we added our scene instances to the scene director, which means
    that the scenes are now in the display tree. We then called the method in the
    `SceneDirector` instance to show the battlefield scene.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 12 中，我们将场景实例添加到场景导演中，这意味着场景现在已经在显示树中。然后我们调用 `SceneDirector` 实例中的方法来显示战场场景。
- en: When we ran the example, we didn't see anything worthwhile on the screen as
    the scenes didn't have anything in them, but if we take a look at the console,
    we see that our two scenes have been successfully created.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们运行示例时，屏幕上没有看到任何有价值的内容，因为场景中没有内容，但如果我们查看控制台，我们会看到我们的两个场景已经成功创建。
- en: 'Here is the full source code from this example:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是本例的完整源代码：
- en: '| Pirate cove scene | Battlefield scene |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 海盗湾场景 | 战场场景 |'
- en: '| --- | --- |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `PirateCove.h`'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '| `PirateCove.h`'
- en: '[PRE7]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '`PirateCove.m`'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`PirateCove.m`'
- en: '[PRE8]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '| `Battlefield.h`'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '| `Battlefield.h`'
- en: '[PRE9]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '`Battlefield.m`'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`Battlefield.m`'
- en: '[PRE10]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '|'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'The `Game.m` file contains the following code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`Game.m` 文件包含以下代码：'
- en: '[PRE11]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Adding images to the battlefield scene
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向战场场景添加图像
- en: Now that the scenes are ready to use, let's add some ships to the battlefield
    scene.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在场景已经准备好使用，让我们向战场场景添加一些船只。
- en: Time for action – adding images to the battlefield scene
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实战时间 – 向战场场景添加图像
- en: 'Let''s take a look at the following steps in order to add images to the battlefield
    scene:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们查看以下步骤，以向战场场景添加图像：
- en: 'Open the `Battlefield.m` file and import the `Assets` header file:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Battlefield.m` 文件并导入 `Assets` 头文件：
- en: '[PRE12]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Remove the log message and add the background image, as shown in the following
    code:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除日志消息并添加背景图像，如下代码所示：
- en: '[PRE13]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add the pirate ship, as shown in the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加海盗船，如下代码所示：
- en: '[PRE14]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add an enemy ship using the following code:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码添加敌方船只：
- en: '[PRE15]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add all children to the display tree, as shown in the following code:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有子节点添加到显示树中，如下代码所示：
- en: '[PRE16]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run the example and you will get the following output:![Time for action – adding
    images to the battlefield scene](img/1509OS_04_11.jpg)
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![实战时间 – 向战场场景添加图像](img/1509OS_04_11.jpg)
- en: '*What just happened?*'
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: In step 1, we opened the `Battlefield.m` file as this is the file we need if
    we want to change anything in the battlefield scene and we imported the `Assets.h`
    file in order to use our asset management system.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们打开了 `Battlefield.m` 文件，因为如果我们想更改战场场景中的任何内容，就需要这个文件，并且我们导入了 `Assets.h`
    文件以便使用我们的资产管理系统。
- en: In step 2, we prepared the background, which should be in the center of the
    screen. We used our asset management system to get a texture from a specified
    file which returns either the cached or newly loaded texture, and the texture
    will then be used to draw `SPImage` on the screen.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 2 中，我们准备了背景，它应该位于屏幕中央。我们使用我们的资产管理系统从指定的文件中获取纹理，该纹理返回缓存的或新加载的纹理，然后该纹理将用于在屏幕上绘制
    `SPImage`。
- en: In step 3, we added the pirate ship, which should be in the center of the screen
    as well. In the next step, we added an enemy ship, which should not be too far
    away from our ship.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们添加了海盗船，它应该在屏幕中央。在下一个步骤中，我们添加了一艘敌舰，它不应该离我们的船太远。
- en: In step 5, we added all our display objects to the display tree, and when we
    ran the example, we saw two ships on the screen.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 5 中，我们将所有显示对象添加到显示树中，当我们运行示例时，我们在屏幕上看到了两艘船。
- en: 'The `Battlefield.m` file will contain the following code:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Battlefield.m` 文件将包含以下代码：'
- en: '[PRE17]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Arranging images in the pirate cove scene
  id: totrans-186
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在海盗湾场景中排列图像
- en: Let's move on to the pirate cove scene to give our pirates a nice little home.
    What we will be doing in this example is adding a house, a tavern, and a weaponsmith
    to the scene. These will serve as places where we can update our ship later on.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到海盗湾场景，为我们的海盗提供一个舒适的小家。在这个示例中，我们将添加一个房子、一个酒馆和一个铁匠到场景中。这些将作为我们可以稍后更新我们的船的地方。
- en: Time for action – arranging images in the pirate cove scene
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时间行动 – 在海盗湾场景中排列图像
- en: 'To add images to the pirate cove scene, follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要将图片添加到海盗湾场景中，请按照以下步骤操作：
- en: Open `PirateCove.m`.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `PirateCove.m`。
- en: 'Import the `Assets` header file using the following line of code:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码行导入 `Assets` 头文件：
- en: '[PRE18]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Remove the log message and add the background image, as shown in the following
    code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除日志消息并添加背景图片，如下面的代码所示：
- en: '[PRE19]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add our pirate ship, as shown in the following code:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们的海盗船，如下面的代码所示：
- en: '[PRE20]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Add a house, as shown in the following code:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个房子，如下面的代码所示：
- en: '[PRE21]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add a tavern, as shown in the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个酒馆，如下面的代码所示：
- en: '[PRE22]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Add a weaponsmith, as shown in the following code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个铁匠，如下面的代码所示：
- en: '[PRE23]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Register all images to the display tree:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将所有图片注册到显示树中：
- en: '[PRE24]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Go to the `Game.m` file and change the default scene to the pirate cove, as
    shown in the following code:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `Game.m` 文件，将默认场景更改为海盗湾，如下面的代码所示：
- en: '[PRE25]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the example and you will get the following output:![Time for action – arranging
    images in the pirate cove scene](img/1509OS_04_12.jpg)
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行示例，你将得到以下输出：![时间行动 – 在海盗湾场景中排列图像](img/1509OS_04_12.jpg)
- en: '*What just happened?*'
  id: totrans-208
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: Most of the steps are quite similar to the battlefield scene, so we don't need
    to explain every step in detail.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数步骤与战场场景非常相似，所以我们不需要详细解释每个步骤。
- en: In step 1, we opened the `PirateCove.m` file where everything with regard to
    the pirate cove should be. We needed the asset management system here as well,
    so we imported it in step 2.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 1 中，我们打开了 `PirateCove.m` 文件，其中应该包含关于海盗湾的所有内容。在这里我们还需要资产管理系统，所以在步骤 2 中我们导入了它。
- en: In step 3, we loaded the fitting image, which should be in the center of the
    screen. In steps 4 to 7, we loaded different entities we wanted to display on
    the screen, such as the pirate ship and the house. We positioned them more or
    less randomly on the screen, but left enough space between them so that it won't
    leave a cluttered impression.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 3 中，我们加载了合适的图片，它应该在屏幕中央。在步骤 4 到 7 中，我们加载了我们在屏幕上想要显示的不同实体，例如海盗船和房子。我们在屏幕上随机地定位它们，但留出足够的空间，以免显得杂乱。
- en: In step 8, we added all of our display objects to the screen. Remember that
    the order matters. If we were to add the background image last, we will only see
    the background and nothing else.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在步骤 8 中，我们将所有显示对象添加到屏幕上。请记住，顺序很重要。如果我们最后添加背景图片，我们只能看到背景，什么也看不到。
- en: We set the scene director to load the pirate cove scene instead of the battlefield
    scene, and when we ran the example, we saw the pirate cove on the screen.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将场景导演设置为加载海盗湾场景而不是战场场景，当我们运行示例时，我们在屏幕上看到了海盗湾。
- en: Pop quiz
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 快速问答
- en: Q1\. What do we need to actively take care of when developing a universal application?
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: Q1. 在开发通用应用程序时，我们需要积极注意哪些方面？
- en: Battery power
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 电池电量
- en: Screen size and texture size limit
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 屏幕尺寸和纹理尺寸限制
- en: GPU memory
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: GPU 内存
- en: Q2\. If we want to display an image with the suffix `~ipad`, on which device(s)
    will it load?
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: Q2. 如果我们想显示后缀为 `~ipad` 的图片，它将在哪些设备上加载？
- en: Non-Retina iPad
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Non-Retina iPad
- en: Retina iPhone
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Retina iPhone
- en: Retina iPad
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Retina iPad
- en: Q3\. What will the dimensions be of an image of 256 x 256 pixels on, Retina
    iPhone in the iOS point coordinate system?
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: Q3. 在 iOS 点坐标系统中，256 x 256 像素的图片在 Retina iPhone 上的尺寸是多少？
- en: 128 x 128 pt
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 128 x 128 pt
- en: 256 x 256 pt
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 256 x 256 pt
- en: 512 x 512 pt
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 512 x 512 pt
- en: Q4\. Which suffix is required to load images on, Retina iPad if the `doubleOnPad`
    parameter is set to `YES`?
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: Q4. 如果将 `doubleOnPad` 参数设置为 `YES`，加载 Retina iPad 上的图片需要哪个后缀？
- en: '@2x'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@2x'
- en: '@3x'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@3x'
- en: '@4x'
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '@4x'
- en: Summary
  id: totrans-231
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about cross-platform device compatibility between
    iPad and iPhone devices.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了iPad和iPhone设备之间的跨平台设备兼容性。
- en: Specifically, we covered which filename suffix we need to identify, which file
    to load for which device, how the coordinate system in points works, and texture
    size limits when loading images.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们涵盖了需要识别的文件名后缀，为哪种设备加载哪个文件，如何在点坐标系统中工作，以及加载图片时的纹理大小限制。
- en: We also set up the bare bone, of our game where we loaded the images for different
    kinds of devices utilizing our asset and scene managers.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还设置了游戏的骨架，其中我们利用我们的资源和场景管理器为不同类型的设备加载了图片。
- en: Now that the scenes of our game are available and we have put some images on
    the screen, we're ready to beautify our game—which is the topic of the next chapter.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们游戏的场景已经可用，并且我们在屏幕上放置了一些图片，我们准备美化我们的游戏——这是下一章的主题。
