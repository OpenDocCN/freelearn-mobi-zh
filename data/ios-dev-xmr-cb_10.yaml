- en: Chapter 10. Location Services and Maps
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第10章：位置服务和地图
- en: 'In this chapter, we will cover the following:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: Determining location
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定位置
- en: Determining heading
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定航向
- en: Using region monitoring
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用区域监控
- en: Using a significant-change location service
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用显著变化位置服务
- en: Location services in the background
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 背景位置服务
- en: Displaying maps
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示地图
- en: Geocoding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 地理编码
- en: Adding map annotations
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加地图标注
- en: Adding map overlays
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加地图覆盖
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Today's smartphones and hand-held devices are equipped with high-accuracy Global
    Positioning System (GPS) hardware. The GPS hardware receives location information
    from a constellation of satellites. Apart from the satellites, iOS devices take
    advantage of the cellular and Wi-Fi networks to provide location information to
    the user.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当今的智能手机和手持设备都配备了高精度的全球定位系统（GPS）硬件。GPS硬件从卫星星座接收位置信息。除了卫星之外，iOS设备还利用蜂窝和Wi-Fi网络向用户提供位置信息。
- en: 'In this chapter, we will discuss how to use the appropriate frameworks to take
    advantage of the location services of the device. Furthermore, we will learn how
    to display maps and annotate them. Specifically, we will focus on the following
    subjects:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论如何使用适当的框架来利用设备的位置服务。此外，我们还将学习如何显示地图并对其进行标注。具体来说，我们将重点关注以下主题：
- en: '**Location services**: Here, the services available on a device for providing
    location information will be discussed. These services are as follows:'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置服务**：在此，我们将讨论设备上提供位置信息的服务。这些服务如下：'
- en: '**Standard location service**: This location service depends fully on the device''s
    GPS module and provides location data of the highest accuracy'
  id: totrans-15
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**标准位置服务**：此位置服务完全依赖于设备的GPS模块，并提供最高精度的位置数据'
- en: '**Region monitoring service**: This location service monitors boundary crossings'
  id: totrans-16
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**区域监控服务**：此位置服务监控边界穿越'
- en: '**Significant-change location service**: This service monitors significant
    changes in the location of the device'
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**显著变化位置服务**：此服务监控设备位置的显著变化'
- en: '`CLLocationManager`: This class allows us to use the location services'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLLocationManager`：此类允许我们使用位置服务'
- en: '`Compass`: This class shows how to use the built-in compass'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Compass`：此类展示了如何使用内置罗盘'
- en: '`MKMapView`: This view is used to display maps'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKMapView`：此视图用于显示地图'
- en: '`CLGeocoder`: This class provides geocoding features'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CLGeocoder`：此类提供地理编码功能'
- en: '`MKAnnotation`: This class allows us to add annotations on maps'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKAnnotation`：此类允许我们在地图上添加标注'
- en: '`MKOverlay`: This class allows us to add overlays on maps'
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKOverlay`：此类允许我们在地图上添加覆盖'
- en: Determining location
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定位置
- en: We will now learn how to receive the location information from the built-in
    GPS hardware.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将学习如何从内置的GPS硬件接收位置信息。
- en: Getting ready
  id: totrans-26
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `LocationApp`.
    Add two buttons and a label on the view of the controller.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`LocationApp`。在控制器的视图中添加两个按钮和一个标签。
- en: How to do it...
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to receive the location of the device:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以接收设备的位置：
- en: 'To retrieve location information from the built-in GPS hardware, we need to
    use the Core Location framework. It is exposed through the `MonoTouch.CoreLocation`
    namespace as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要从内置的GPS硬件检索位置信息，我们需要使用Core Location框架。它通过以下`MonoTouch.CoreLocation`命名空间公开：
- en: '[PRE0]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Add the following code in the `LocationAppViewController` class:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LocationAppViewController`类中添加以下代码：
- en: '[PRE1]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Compile and run the app on the device. Tap the start button to view your location
    coordinates on the screen.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击开始按钮以在屏幕上查看您的位置坐标。
- en: Note
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Projects using the Core Location framework to determine the current position
    of a device can work on the simulator. By navigating to the **Debug** | **Location**
    menu of the simulator, we can customize the location that the device will be using.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Core Location框架确定设备当前位置的项目可以在模拟器上运行。通过导航到模拟器的**调试** | **位置**菜单，我们可以自定义设备将使用的位置。
- en: How it works...
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: 'The location data that the GPS module provides can be accessed through the
    `CLLocationManager` class. After initializing an instance of the class, we need
    to subscribe to its `LocationsUpdated` event as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通过`CLLocationManager`类可以访问GPS模块提供的位置数据。初始化该类的实例后，我们需要订阅其`LocationsUpdated`事件，如下所示：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Location data will become available, as they are issued through this event.
    It is also a good practice to subscribe to the `Failed` event as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 位置数据将通过此事件变得可用。同时，订阅`Failed`事件也是一个好的实践，如下所示：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When the location manager first requests for location updates, the user is
    informed through a system-specific alert, which is similar to the one shown in
    the following screenshot:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当位置管理器首次请求位置更新时，用户将通过系统特定的警报得到通知，这与以下截图所示类似：
- en: '![How it works...](img/8924OT_10_01.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/8924OT_10_01.jpg)'
- en: This alert basically asks for user permission to allow the app to retrieve location
    data. If the user denies this request, the `Failed` event will be triggered with
    the appropriate message. Future location requests will not trigger the permission
    alert, and the user will have to enable location services for the app through
    the device's settings, so we need to handle this scenario accordingly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 此警报基本上是请求用户权限，允许应用程序检索位置数据。如果用户拒绝此请求，将触发带有适当信息的`Failed`事件。未来的位置请求将不会触发权限警报，用户必须通过设备的设置启用应用程序的位置服务，因此我们需要相应地处理这种情况。
- en: 'After subscribing to the appropriate events, we request the delivery of location
    updates through the `StartUpdatingLocation` method as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在订阅适当的事件后，我们通过`StartUpdatingLocation`方法请求位置更新，如下所示：
- en: '[PRE4]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To stop receiving location updates, we call the `StopUpdatingLocation` method
    as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止接收位置更新，我们按照以下方式调用`StopUpdatingLocation`方法：
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: The `LocationsUpdated` event accepts the delegates of the `EventHandler<CLLocationsUpdatedEventArgs>`
    type. The `CLLocationsUpdatedEventArgs` parameter contains one property that returns
    an array of `CLLocation` objects. The last item in the array contains the most
    recent location data that were retrieved from location services. The array will
    always contain at least one `CLLocation` item.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`LocationsUpdated`事件接受`EventHandler<CLLocationsUpdatedEventArgs>`类型的委托。`CLLocationsUpdatedEventArgs`参数包含一个属性，该属性返回一个`CLLocation`对象的数组。数组中的最后一个项目包含从位置服务检索到的最新位置数据。数组将始终包含至少一个`CLLocation`项目。'
- en: 'The coordinates are returned as values of the `double` type and represent the
    coordinates of the position in degrees as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 坐标以`double`类型返回，并代表位置坐标的度数，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Negative latitude values indicate south coordinates and positive values indicate
    north coordinates. Negative longitude values indicate west coordinates, while
    positive longitude values indicate east coordinates.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 负纬度值表示南坐标，正值表示北坐标。负经度值表示西坐标，而正值表示东坐标。
- en: The `HorizontalAccuracy` property returns the accuracy of the GPS fix in meters.
    For example, a value of 17 m indicates that the location is determined within
    a circle of a diameter 17 m. Lower values indicate better accuracy.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`HorizontalAccuracy`属性返回GPS定位的精度（以米为单位）。例如，17米的值表示位置被确定在一个直径为17米的圆内。较低的值表示更好的精度。'
- en: GPS accuracy
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: GPS精度
- en: There is always a margin of error in location data, which is independent of
    GPS hardware, and there are variable factors that define it, such as the surrounding
    buildings and various obstacles. You will notice that the `HorizontalAccuracy`
    property will return lower values when the device is outdoors, while higher values
    will be returned when we use the GPS indoors or on a city street with tall buildings.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 位置数据始终存在一定的误差范围，这与GPS硬件无关，并且存在一些变量因素定义它，例如周围建筑和各种障碍物。您会注意到，当设备在户外时，`HorizontalAccuracy`属性将返回较低的值，而当我们在室内使用GPS或在有高楼的城市街道上时，将返回较高的值。
- en: Location services availability
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置服务可用性
- en: Not all devices are equipped with location services hardware. Furthermore, even
    if a device is equipped with the appropriate hardware, location services could
    be disabled by the user.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有设备都配备了位置服务硬件。此外，即使设备配备了适当的硬件，用户也可能已禁用位置服务。
- en: 'To determine if the location services are available or enabled on the device,
    we read the return value of the `CLLocationManager.LocationServicesEnabled` static
    property before initializing the location manager object as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定设备上是否可用或启用了位置服务，我们在初始化位置管理器对象之前，读取`CLLocationManager.LocationServicesEnabled`静态属性的返回值，如下所示：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Furthermore, we can check for the authorization status of location services
    through the `CLLocationManager.Status` property as follows:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还可以通过`CLLocationManager.Status`属性检查位置服务的授权状态，如下所示：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Location services usage indicator
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 位置服务使用指示器
- en: 'When any type of location service is used, the location services icon appears
    on the right-hand side of the status bar next to the battery indicator, as shown
    in the following screenshot:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用任何类型的定位服务时，位置服务图标会出现在状态栏的右侧，紧挨着电池指示器，如下面的截图所示：
- en: '![Location services usage indicator](img/8924OT_10_02.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![位置服务使用指示器](img/8924OT_10_02.jpg)'
- en: See also
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Determining heading* and *Location services in the background* recipes
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定航向*和*后台位置服务*菜谱'
- en: Determining heading
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确定航向
- en: In this recipe, we will learn how to use the built-in compass to determine the
    heading of the device.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何使用内置的指南针来确定设备的航向。
- en: Getting ready
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `HeadingApp`.
    Just as you did in the previous recipe, add two buttons and a label on the view
    of the controller.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`HeadingApp`。就像你在上一个菜谱中所做的那样，在控制器的视图中添加两个按钮和一个标签。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The project in this recipe cannot be tested on the simulator. A device with
    compass hardware (magnetometer) is required.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中的项目不能在模拟器上测试。需要一个带有指南针硬件（磁力计）的设备。
- en: How to do it...
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to determine the heading of the device:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定设备的航向，请执行以下步骤：
- en: 'Add the following code in the `HeadingAppViewController` class:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`HeadingAppViewController`类中添加以下代码：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Compile and run the app on the device. Tap the start button and rotate the device
    to view the different heading values.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在设备上编译并运行应用程序。点击开始按钮并旋转设备以查看不同的航向值。
- en: How it works...
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'To retrieve the heading information, we first need to subscribe to the location
    manager''s `UpdatedHeading` event as follows:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索航向信息，我们首先需要订阅位置管理器的`UpdatedHeading`事件，如下所示：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'To initiate the delivery of heading information, we call the `StartUpdatingHeading`
    method as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始发送航向信息，我们调用`StartUpdatingHeading`方法，如下所示：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Inside the `UpdatedHeading` event handler, we retrieve the heading information
    through the `MagneticHeading` property of the `CLHeading` object exposed through
    the event arguments'' `NewHeading` property as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdatedHeading`事件处理程序中，我们通过事件参数的`NewHeading`属性，通过以下方式检索`CLHeading`对象的`MagneticHeading`属性来获取航向信息：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To stop retrieving heading updates, we call the `StopUpdatingHeading` method
    with the help of the following code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止检索航向更新，我们调用`StopUpdatingHeading`方法，如下所示：
- en: '[PRE13]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: There's more...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'The heading is measured in degrees. The values for the four points of the horizon
    that can be viewed on a simple compass are the following:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 航向是以度数来测量的。在简单指南针上可以看到地平线的四个方向的值如下：
- en: '**0 or 360 degrees**: The magnetometer will return values of up to 359.99 degrees
    and then return 0 when the device is heading North.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**0或360度**：当设备朝北时，磁力计将返回最多359.99度的值，然后返回0。'
- en: '**90 degrees**: The device is heading East'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**90度**：设备朝东'
- en: '**180 degrees**: The device is heading South'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**180度**：设备朝南'
- en: '**270 degrees**: The device is heading West'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**270度**：设备朝西'
- en: Magnetic vs true heading
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 磁航向与真航向
- en: Magnetic heading is the heading that is based on what a normal compass will
    show as North. True heading is the true direction of North based on the actual
    position of the earth's North Pole. There is a slight difference between the two,
    which varies according to the earth's magnetic-field fluctuations, and it is usually
    about 2 degrees.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 磁航向是基于普通指南针显示的北方。真航向是基于地球北极实际位置的北方方向。两者之间有一个微小的差异，这个差异根据地球磁场的变化而变化，通常约为2度。
- en: The `CLHeading` class provides both readings through the `MagneticHeading` and
    `TrueHeading` properties. This provides a significant help to developers, as calculating
    the difference between the two readings requires either expensive equipment or
    very difficult calculations based on the time of year and other factors.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLHeading`类通过`MagneticHeading`和`TrueHeading`属性提供两种读数。这对开发者来说非常有帮助，因为计算两种读数之间的差异可能需要昂贵的设备或基于年份和其他因素的非常复杂的计算。'
- en: Compass availability
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 指南针可用性
- en: 'The magnetometer, a module that can determine the heading in degrees and provides
    compass functionality to devices, is not available on all devices. To check if
    a device can provide heading information, retrieve the value from the `CLLocationManager.HeadingAvailable`
    static property as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 磁力计，一个可以确定方向（以度为单位）并为设备提供指南针功能的功能模块，并非所有设备都可用。要检查设备是否可以提供方向信息，请从 `CLLocationManager.HeadingAvailable`
    静态属性中检索值，如下所示：
- en: '[PRE14]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: See also
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Determining location* and *Location services in the background* recipes
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定位置* 和 *后台位置服务* 的食谱'
- en: Using region monitoring
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用区域监控
- en: In this recipe, we will learn how to use GPS to respond to region-specific position
    changes.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何使用 GPS 来响应特定区域的位置变化。
- en: Getting ready
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `RegionApp`.
    Add two buttons and a label on the view of the controller.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用** 并命名为 `RegionApp`。在控制器的视图中添加两个按钮和一个标签。
- en: How to do it...
  id: totrans-106
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Create two fields in the `RegionAppViewController` class as follows:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `RegionAppViewController` 类中创建两个字段，如下所示：
- en: '[PRE15]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the `ViewDidLoad` method, initialize the `RegionAppViewController` class,
    and subscribe to the `LocationsUpdated`, `RegionEntered`, and `RegionLeft` events
    as follows:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中，初始化 `RegionAppViewController` 类，并按以下方式订阅 `LocationsUpdated`、`RegionEntered`
    和 `RegionLeft` 事件：
- en: '[PRE16]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Enter the following event handlers in the class:'
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中输入以下事件处理程序：
- en: '[PRE17]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the start button''s `TouchUpInside` handler, call the `StartUpdatingLocation`
    method using the following code:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在启动按钮的 `TouchUpInside` 处理程序中，使用以下代码调用 `StartUpdatingLocation` 方法：
- en: '[PRE18]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the stop button''s `TouchUpInside` handler, call the `StopMonitoring` method
    using the following code:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在停止按钮的 `TouchUpInside` 处理程序中，使用以下代码调用 `StopMonitoring` 方法：
- en: '[PRE19]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Compile and run the app on the simulator. Navigate to **Debug** | **Location**
    | **Freeway drive** on the simulator's menu and tap the **Start region monitoring**
    button.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。在模拟器的菜单中导航到 **调试** | **位置** | **高速公路驾驶**，然后点击 **开始区域监控** 按钮。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Region monitoring is a feature that monitors boundary crossings. When a boundary
    of a specific region is crossed, the `CLLocationManager` object issues the appropriate
    events as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 区域监控是一个监控边界穿越的功能。当特定区域边界被穿越时，`CLLocationManager` 对象将发出适当的事件，如下所示：
- en: '[PRE20]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In this example, we define the region based on the current location; hence,
    we also subscribe to the `LocationsUpdated` event.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们根据当前位置定义区域；因此，我们也订阅了 `LocationsUpdated` 事件。
- en: 'When the app starts receiving location updates, it first checks for location
    accuracy using the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用开始接收位置更新时，它首先使用以下代码检查位置精度：
- en: '[PRE21]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'If the desired accuracy is achieved (<100 m, modify at your discretion), we
    initialize the `CLCircularRegion` object using the following line of code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如果达到所需的精度（<100 m，可自行修改），我们使用以下代码行初始化 `CLCircularRegion` 对象：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `CLCircularRegion` class is used to define circular regions and inherits
    the `CLRegion` class. Here, in the first parameter, we create the region to be
    monitored based on our current location. The second parameter declares the radius
    around the coordinate, in meters, defining the region's boundary. The third parameter
    is a string identifier we want to assign to the region.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLCircularRegion` 类用于定义圆形区域，并继承自 `CLRegion` 类。在此，我们根据当前位置创建要监控的区域。第二个参数声明了围绕坐标的半径（以米为单位），定义了区域的边界。第三个参数是我们想要分配给区域的字符串标识符。'
- en: 'To start monitoring the region, we call the `StartMonitoring` method using
    the following line of code:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始监控区域，我们使用以下代码行调用 `StartMonitoring` 方法：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: When region monitoring has started, the appropriate events will be triggered
    when the device enters or leaves the region.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当区域监控开始时，当设备进入或离开区域时，将触发适当的事件。
- en: There's more...
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Region monitoring is a very useful feature. For example, an app could provide
    specific information to users based on their proximity to various areas. Furthermore,
    it can notify of boundary crossings while the app is in the background.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 区域监控是一个非常实用的功能。例如，一个应用可以根据用户接近的不同区域提供特定的信息。此外，它还可以在应用处于后台时通知边界穿越。
- en: Region monitoring availability
  id: totrans-133
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 区域监控可用性
- en: 'To check if a device supports region monitoring, call the `CLLocationManager.IsMonitoringAvailable`
    static method passing the type of the `CLRegion` object we want to use as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查设备是否支持区域监控，调用`CLLocationManager.IsMonitoringAvailable`静态方法，并传递我们想要使用的`CLRegion`对象的类型，如下所示：
- en: '[PRE24]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: See also
  id: totrans-136
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using a significant-change location service* and *Location services in
    the background* recipes
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用显著变化位置服务*和*后台位置服务*菜谱'
- en: Using a significant-change location service
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用显著变化位置服务
- en: In this chapter, we will learn how to use the significant location change monitoring
    feature.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用显著位置变化监控功能。
- en: Getting ready
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `SLCApp`.
    Add a label and two buttons on the view of the controller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`SLCApp`。在控制器的视图中添加一个标签和两个按钮。
- en: How to do it...
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: 'Add the following `ViewDidLoad` method in the `SLCAppViewController` class:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SLCAppViewController`类中添加以下`ViewDidLoad`方法：
- en: '[PRE25]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following method:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下方法：
- en: '[PRE26]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In iOS Simulator, navigate to **Debug** | **Location** | **Freeway drive** on
    the menu.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在iOS模拟器中，通过菜单导航到**调试** | **位置** | **高速公路驾驶**。
- en: Compile and run the app on the simulator. Tap the **Start monitoring** button
    to start monitoring for significant location changes.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。点击**开始监控**按钮以开始监控显著位置变化。
- en: How it works...
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The significant-change location service monitors significant location changes
    and provides location information when these changes occur. In terms of power
    consumption, it is the less-demanding location service. It uses the device's cellular
    radio transceiver to determine the user's location. Only devices equipped with
    a cellular radio transceiver can use this service.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 显著变化位置服务监控显著位置变化，并在这些变化发生时提供位置信息。在功耗方面，它是要求较低的位置服务。它使用设备的蜂窝无线电收发器来确定用户的位置。只有配备了蜂窝无线电收发器的设备才能使用此服务。
- en: 'The code for using the significant-change location service is similar to the
    code of the standard location services. The only differences are the methods of
    starting and stopping the service. To start the service, we call the `StartMonitoringSignificantLocationChanges`
    method using the following line of code:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 使用显著变化位置服务的代码与标准位置服务的代码类似。唯一的不同之处在于启动和停止服务的方法。要启动服务，我们使用以下代码行调用`StartMonitoringSignificantLocationChanges`方法：
- en: '[PRE27]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Location updates are issued through the `LocationsUpdated` event handler, which
    is the same event we use for the standard location service as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 位置更新通过`LocationsUpdated`事件处理器发布，这与我们用于标准位置服务的相同事件，如下所示：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: There's more...
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The significant-change location service can report location changes while in
    the background, waking up the app. It is very useful for apps that need to make
    use of location services, with a lower accuracy than that of the standard location
    services.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 显著变化位置服务可以在后台报告位置变化，唤醒应用。对于需要使用位置服务但精度低于标准位置服务的应用来说，它非常有用。
- en: Significant-change location service availability
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显著变化位置服务可用性
- en: 'To determine if a device is capable of using the significant-change location
    service, retrieve the value of the `SignificantLocationChangeMonitoringAvailable`
    static property as follows:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定设备是否能够使用显著变化位置服务，按照以下方式检索`SignificantLocationChangeMonitoringAvailable`静态属性的值：
- en: '[PRE29]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: See also
  id: totrans-161
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Using region monitoring* and *Location services in the background* recipes
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用区域监控*和*后台位置服务*菜谱'
- en: Location services in the background
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 后台位置服务
- en: In this recipe, we will discuss how to use location services while the app is
    in the background.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本菜谱中，我们将讨论如何在应用处于后台时使用位置服务。
- en: Getting ready
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `BackgroundLocationApp`.
    Just like we did in the previous recipes, add a label and two buttons on the view
    of the controller.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`BackgroundLocationApp`。就像我们在前面的菜谱中所做的那样，在控制器的视图中添加一个标签和两个按钮。
- en: How to do it...
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to use the location services when the app is in
    the background:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用处于后台时使用位置服务，请执行以下步骤：
- en: In the **Solution** pane, double-click on the `Info.plist` file to open it.
    Under the **Source** tab, add a new key by clicking on the plus (**+**) sign or
    by right-clicking and selecting **New Key** from the context menu.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Solution** 面板中，双击 `Info.plist` 文件以打开它。在 **Source** 选项卡下，通过单击加号（**+**）或通过右键单击并从上下文菜单中选择
    **New Key** 来添加一个新键。
- en: Select **Required background modes** from the drop-down list or just type `UIBackgroundModes`
    in the field.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉列表中选择 **Required background modes**，或者直接在字段中输入 `UIBackgroundModes`。
- en: Expand the key and right-click on the empty item below it. Click on **New Key**
    in the context menu. In its **Value** field, select **App registers for location
    updates**, or type the word `location`. Save the document. When done, you should
    have something similar to the following screenshot:![How to do it...](img/8924OT_10_03.jpg)
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开键并右键单击其下方的空白项。在上下文菜单中单击 **New Key**。在其 **Value** 字段中，选择 **App registers for
    location updates**，或者输入单词 `location`。保存文档。完成后，你应该会有以下类似的截图：![如何操作...](img/8924OT_10_03.jpg)
- en: In the `BackgroundLocationAppViewController` class, enter the same code as the
    one used in the *Determining location* recipe of this chapter.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `BackgroundLocationAppViewController` 类中，输入与本章中 *Determining location* 菜单中使用的相同代码。
- en: 'At the bottom of the `LocationManager_LocationsUpdated` method, add the following
    line:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `LocationManager_LocationsUpdated` 方法的底部添加以下行：
- en: '[PRE30]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Compile and run the app on the simulator. Tap the **Start** button to start
    receiving location updates.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器上编译并运行应用。轻触 **Start** 按钮以开始接收位置更新。
- en: With the simulator window active, press *Cmd* + *Shift* + *H*. This key combination
    simulates pressing the home button on a device and will move the app to the background.
    Watch Xamarin Studio's **Application Output** pad continuing the display of location
    updates.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模拟器窗口处于活动状态时，按 *Cmd* + *Shift* + *H*。这个键组合模拟在设备上按主页按钮，并将应用移动到后台。观察 Xamarin
    Studio 的 **Application Output** 面板继续显示位置更新。
- en: How it works...
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: To receive location updates while the app is in the background, we need to set
    the `location` value to the `UIBackgroundModes` key in the `Info.plist` file.
    This basically makes sure that the app has the appropriate permission to receive
    location updates while it is in the background and that it will not get suspended.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 要在应用后台运行时接收位置更新，我们需要在 `Info.plist` 文件中将 `location` 值设置为 `UIBackgroundModes`
    键。这基本上确保了应用在后台运行时具有接收位置更新的适当权限，并且它不会进入挂起状态。
- en: 'If you open the `Info.plist` file in a text editor, this is what has been added:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个文本编辑器中打开 `Info.plist` 文件，这是添加的内容：
- en: '[PRE31]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: To make sure that the app is receiving location updates, check the status bar.
    The location services icon should be displayed even if the app is in the background.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保应用正在接收位置更新，检查状态栏。即使应用在后台运行，位置服务图标也应显示。
- en: There's more...
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Setting the `UIBackgroundModes` key for location services is only needed for
    the standard location service. Both the region monitoring and significant-change
    location services support delivery of location updates while the app is in the
    background, by default. While one of these location services has started updating
    location data, the app can even be terminated. When a location update is received,
    the app is started or woken up from the suspended state and is given a limited
    amount of time to execute code.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为位置服务设置 `UIBackgroundModes` 键仅适用于标准位置服务。区域监控和重大变更位置服务默认支持在应用后台运行时提供位置更新。当其中一个位置服务开始更新位置数据时，应用甚至可以被终止。当接收到位置更新时，应用将被启动或从挂起状态唤醒，并给予有限的时间来执行代码。
- en: 'To determine if an app has been started by one of these two location services,
    check the `options` parameter of the `FinishedLaunching` method in the `AppDelegate`
    class as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定应用是否是由这两个位置服务之一启动的，请检查 `AppDelegate` 类中 `FinishedLaunching` 方法的 `options`
    参数，如下所示：
- en: '[PRE32]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `options` parameter is of the `NSDictionary` type. If this dictionary contains
    `UIApplication.LaunchOptionsLocationKey`, then the app has been started or woken
    up from the suspended state due to a location service. When this is the case,
    we need to call the `StartMonitoringSignificantLocationChanges` method on a `CLLocationManager`
    instance again, to retrieve location data.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`options` 参数的类型是 `NSDictionary`。如果这个字典包含 `UIApplication.LaunchOptionsLocationKey`，则应用是因为位置服务而被启动或从挂起状态唤醒的。在这种情况下，我们需要再次在
    `CLLocationManager` 实例上调用 `StartMonitoringSignificantLocationChanges` 方法，以检索位置数据。'
- en: The same applies to region-monitoring location service. Note that if we use
    either of these two location services, but our app does not support the background
    delivery of a location's events, we have to make sure that we stop monitoring
    location updates when they are no longer needed. If we do not, the location services
    will continue to run, causing significant battery drain.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 同样适用于区域监控位置服务。请注意，如果我们使用这两种位置服务之一，但我们的应用不支持位置事件的背景交付，我们必须确保在不再需要时停止监控位置更新。如果不这样做，位置服务将继续运行，导致电池消耗显著增加。
- en: Restricting to supported hardware
  id: totrans-188
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 限制到支持的硬件
- en: If our app's features are fully dependent on location services and cannot operate
    correctly on devices that do not support them, we have to add the `UIRequiredDeviceCapabilities`
    key in the `Info.plist` file with the `location-services` value.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们的应用功能完全依赖于位置服务，并且无法在不支持这些服务的设备上正确运行，我们必须在 `Info.plist` 文件中添加 `UIRequiredDeviceCapabilities`
    键，并使用 `location-services` 值。
- en: Furthermore, when the app requires the use of the standard location service,
    which uses the GPS hardware, we need to add the `gps` value to the `UIRequiredDeviceCapabilities`
    key. This way, we make sure that the app will not be available through the App
    Store to the devices that are not equipped with the appropriate hardware.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当应用需要使用使用 GPS 硬件的常规位置服务时，我们需要将 `gps` 值添加到 `UIRequiredDeviceCapabilities`
    键。这样，我们确保应用不会通过 App Store 供没有配备适当硬件的设备使用。
- en: UI updates while in the background
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在后台进行 UI 更新
- en: In this recipe, we deliberately set a value to the label's **Text** property
    while the app is in the background. However, updating the UI while the app is
    in the background should be avoided, because the iOS might terminate our app if
    there are too many updates. Furthermore, UI updates that occur in the background
    are basically being queued for when the app returns to the foreground and take
    place instantaneously when this happens. This may result in unexpected behavior
    in our app.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们故意在应用处于后台时设置标签的 **Text** 属性的值。然而，在应用处于后台时更新 UI 应该避免，因为 iOS 如果有太多的更新可能会终止我们的应用。此外，在后台发生的
    UI 更新基本上是在应用返回前台时排队，并在这种情况下立即发生。这可能会导致我们应用中出现意外的行为。
- en: See also
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Determining location* recipe
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*确定位置* 食谱'
- en: The *Creating an iOS project with Xamarin Studio* recipe in [Chapter 1](ch01.html
    "Chapter 1. Development Tools"), *Development Tools*
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第 1 章](ch01.html "第 1 章。开发工具") *开发工具* 的 *使用 Xamarin Studio 创建 iOS 项目* 食谱
- en: Displaying maps
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示地图
- en: In this recipe, we will learn how to display maps in our app.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在我们的应用中显示地图。
- en: Getting ready
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapDisplayApp`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序** 并将其命名为 `MapDisplayApp`。
- en: How to do it...
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to display maps in the app:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在应用中显示地图：
- en: Add `MKMapView` on the controller. The following screenshot shows the symbol
    for `MKMapView` in Xcode's object library:![How to do it...](img/8924OT_10_04.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器上添加 `MKMapView`。以下截图显示了 Xcode 对象库中 `MKMapView` 的符号：![如何操作...](img/8924OT_10_04.jpg)
- en: 'Add the following `using` directives in the `MapDisplayAppViewController.cs`
    file:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MapDisplayAppViewController.cs` 文件中添加以下 `using` 指令：
- en: '[PRE33]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Enter the following code in the `MapDisplayAppViewController` class:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MapDisplayAppViewController` 类中输入以下代码：
- en: '[PRE34]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Compile and run the app either on the simulator or on the device.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用。
- en: Zoom or pan the map by pinching on the screen (press *Option* and click-and-drag
    on the simulator) to output the current location in the **Application Output**
    pad.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在屏幕上捏合来缩放或平移地图（在模拟器上按 *Option* 并点击拖动）以在 **应用程序输出** 框中输出当前位置。（*注：原文中的 *Option*
    应为 *Option* 键，即键盘上的 Option 键*）
- en: How it works...
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `MonoTouch.MapKit` namespace wraps all the objects contained in the MapKit
    framework. The MapKit framework uses Apple maps to display maps.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`MonoTouch.MapKit` 命名空间包装了 MapKit 框架中包含的所有对象。MapKit 框架使用 Apple 地图来显示地图。'
- en: '`MKMapView` is the default iOS view that displays maps. It is especially designed
    for this purpose, and it should not be subclassed.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`MKMapView` 是默认的 iOS 视图，用于显示地图。它专门为此目的而设计，不应被子类化。'
- en: 'To display the user''s location on the map, we set its `ShowsUserLocation`
    property to `true` using the following line of code:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 要在地图上显示用户的当前位置，我们使用以下代码行将其 `ShowsUserLocation` 属性设置为 `true`：
- en: '[PRE35]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This activates the standard location service to start receiving location updates
    and handing them over to the `MKMapView` object internally.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这将激活标准位置服务以开始接收位置更新并将它们内部传递给`MKMapView`对象。
- en: Note
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When `MKMapView` is first shown in an app, the system will prompt the user for
    the permission to use location services, just as if we were trying to use location
    services directly.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 当`MKMapView`首次在应用中显示时，系统将提示用户请求使用位置服务的权限，就像我们直接尝试使用位置服务一样。
- en: 'To determine when the user zooms or pans the map, we subscribe to the `RegionChanged`
    event using the following code:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定用户何时缩放或平移地图，我们使用以下代码订阅`RegionChanged`事件：
- en: '[PRE36]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Inside the event handler, we retrieve the current location through the `UserLocation`
    property as follows:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在事件处理程序内部，我们通过`UserLocation`属性如下检索当前位置：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: If the `ShowsUserLocation` property is set to `false`, the location services
    will not be activated, and the `UserLocation.Location` property will return `null`.
    It will also return `null` when the app runs for the first time, as it will ask
    the user for permission to use location services. However, a map will be displayed
    as long as the device or simulator has an active Internet connection.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ShowsUserLocation`属性设置为`false`，则位置服务将不会激活，并且`UserLocation.Location`属性将返回`null`。当应用第一次运行时，它也会返回`null`，因为它将要求用户授权使用位置服务。然而，只要设备或模拟器有活动的互联网连接，就会显示地图。
- en: There's more...
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'We can set the center coordinate of the map to be displayed with the `SetCenterCoordinate`
    method as follows:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过`SetCenterCoordinate`方法如下设置要显示的地图的中心坐标：
- en: '[PRE38]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The first parameter is the map coordinates where we want the map to be centered
    at, represented by an object of the `CLLocationCoordinate2D` type. The second
    parameter declares if we want the centering of the map to be animated or not.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是我们希望地图中心对齐的地图坐标，由`CLLocationCoordinate2D`类型的对象表示。第二个参数声明我们是否希望地图中心对齐是动画的。
- en: 'Apart from centering the map, we can also set its zoom level. We do this through
    the `SetRegion` method as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定位地图外，我们还可以设置其缩放级别。我们通过`SetRegion`方法如下进行设置：
- en: '[PRE39]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first parameter is of the `MKCoordinateRegion` type. Here, its `FromDistance`
    static method is used to create an instance. Its first parameter is the coordinate
    of the region's center, while the next two parameters represent the horizontal
    and vertical span of the map to display, in meters. It basically means that the
    region represented by this `MKCoordinateRegion` instance will have `mapCoordinates`
    at the center, and the horizontal and vertical part of the map will each represent
    1000 meters on the map.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数是`MKCoordinateRegion`类型。在这里，使用其`FromDistance`静态方法来创建一个实例。它的第一个参数是区域中心的坐标，接下来的两个参数代表要显示的地图的水平跨度，单位为米。这基本上意味着由这个`MKCoordinateRegion`实例表示的区域将具有`mapCoordinates`为中心，地图的水平部分和垂直部分将分别代表地图上的1000米。
- en: Note that `MKMapView` will set the actual region to an approximation of the
    values of `MKCoordinateRegion`. This is because the dimensions of `MKMapView`
    cannot always match the horizontal and vertical span values provided. For example,
    here, we set a square region of 1000 x 1000 meters, but our `MKMapView` layout
    is not an absolute square, as it basically takes over the entire screen. We can
    retrieve the actual region of the map that the `MKMapView` is displaying through
    its `Region` property.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`MKMapView`将实际区域设置为`MKCoordinateRegion`值的近似值。这是因为`MKMapView`的尺寸不一定总是与提供的水平和垂直跨度值匹配。例如，在这里，我们设置了一个1000
    x 1000米的正方形区域，但我们的`MKMapView`布局并不是一个绝对的正方形，因为它基本上占据了整个屏幕。我们可以通过其`Region`属性检索`MKMapView`显示的实际地图区域。
- en: See also
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Geocoding*, *Adding map annotations*, and *Adding map overlays* recipes
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*地理编码*、*添加地图标注*和*添加地图覆盖*菜谱'
- en: Geocoding
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 地理编码
- en: In this recipe, we will learn how to provide information about an address, city,
    or country based on location coordinates.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将学习如何根据位置坐标提供关于地址、城市或国家的信息。
- en: Getting ready
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: Create a new **Single View Application** in Xamarin Studio and name it `GeocodingApp`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，并将其命名为`GeocodingApp`。
- en: How to do it...
  id: totrans-236
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Perform the following steps:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤：
- en: Add an `MKMapView` on the top half of the view of `MainController`, a label,
    and a button on the bottom half.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainController`视图的上半部分添加一个`MKMapView`，一个标签，以及下半部分的一个按钮。
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `GeocodingAppViewController.cs`
    file.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GeocodingAppViewController.cs` 文件中添加 `MonoTouch.MapKit` 和 `MonoTouch.CoreLocation`
    命名空间。
- en: 'Enter the following `ViewDidLoad` method in the class:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中输入以下 `ViewDidLoad` 方法：
- en: '[PRE40]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Make sure that the simulator's location is set to a stationary position. Navigate
    to **Debug** | **Location** | **Custom** (or **Apple**).
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模拟器的位置设置为固定位置。导航到 **调试** | **位置** | **自定义**（或 **Apple**）。
- en: Compile and run the app either on the simulator or on the device. The result
    should be similar to the following screenshot:![How to do it...](img/8924OT_10_05.jpg)
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译和运行应用程序。结果应类似于以下截图：![如何操作...](img/8924OT_10_05.jpg)
- en: How it works...
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Geocoding is the process of matching address information to geographic coordinates.
    Reverse geocoding is the opposite, matching geographic coordinates to address
    information. In this recipe, we are using reverse geocoding through the `CLGeocoder`
    class as follows:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 地理编码是将地址信息与地理坐标匹配的过程。反向地理编码是相反的过程，即将地理坐标与地址信息匹配。在本食谱中，我们通过 `CLGeocoder` 类使用以下方式进行反向地理编码：
- en: '[PRE41]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'After initializing the geocoder object, we call the `ReverseGeocodeAsync` method
    as follows:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化地理编码器对象后，我们按照以下方式调用 `ReverseGeocodeAsync` 方法：
- en: '[PRE42]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The method accepts a `CLLocation` parameter, which represents the location
    for which we want to retrieve geocoding data. The `return` value is an array of
    the CLPlacemark objects. The `CLPlacemark` class contains the reverse-geocoded
    information, such as the country, city, and address of the coordinates as shown
    in the following code:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法接受一个 `CLLocation` 参数，它表示我们想要检索地理编码数据的地理位置。`return` 值是一个包含 CLPlacemark 对象的数组。`CLPlacemark`
    类包含反向地理编码信息，例如国家、城市和坐标的地址，如下面的代码所示：
- en: '[PRE43]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When reverse-geocoding a location, the array will always contain one item. If
    the return value is null, then an error has occurred.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 当反向地理编码位置时，数组将始终包含一个项目。如果返回值为 null，则表示发生了错误。
- en: There's more...
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'We can also use the `CLGeocoder` class for forward geocoding. For example,
    to get the coordinates of Apple''s central offices, we use the `GeocodeAddressAsync`
    method as follows:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用 `CLGeocoder` 类进行正向地理编码。例如，要获取 Apple 中央办公室的坐标，我们使用以下 `GeocodeAddressAsync`
    方法：
- en: '[PRE44]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The method will give more accurate results when we pass as all the information
    that we have to it.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向该方法传递所有拥有的信息时，该方法将给出更准确的结果。
- en: Note
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Forward geocoding with the `GeocodeAddressAsync` method might return more than
    one item in the resulting `CLPlacemark[]` object. This is because the geocoder
    might not be able to determine the exact location through the passed information,
    so a set of possible results will be returned.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `GeocodeAddressAsync` 方法进行正向地理编码可能会在结果 `CLPlacemark[]` 对象中返回多个项目。这是因为地理编码器可能无法通过传递的信息确定确切的位置，因此会返回一组可能的结果。
- en: Things to have in mind for CLGeocoder
  id: totrans-258
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对于 CLGeocoder 需要注意的事项
- en: Apple provides the geocoding feature with a rate limit. Although the exact limit
    is not documented, it is recommended that you do not make more than one geocoding
    request per minute. If the rate limit is exceeded, the geocoder will fail with
    an error.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Apple 提供了地理编码功能，并设置了速率限制。尽管确切的限制没有记录，但建议您每分钟不要进行超过一次地理编码请求。如果超过速率限制，地理编码器将失败并返回错误。
- en: Obsolete API
  id: totrans-260
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 已废弃的 API
- en: The `CLGeocoder` class basically replaces `MKReverseGeocoder`, which only offered
    reverse geocoding until iOS 5.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`CLGeocoder` 类基本上取代了 `MKReverseGeocoder`，后者在 iOS 5 之前仅提供反向地理编码功能。'
- en: See also
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying maps*, *Adding map annotations*, and *Adding map overlays* recipes
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示地图*、*添加地图注释*和*添加地图覆盖*食谱'
- en: Adding map annotations
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地图注释
- en: In this recipe, we will discuss annotating a map to provide a variety of information
    to the user.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将讨论如何注释地图以向用户提供各种信息。
- en: Getting ready
  id: totrans-266
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapAnnotateApp`.
    Add `MKMapView` and a button on the view of the controller.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Xamarin Studio 中创建一个新的 **单视图应用程序**，并将其命名为 `MapAnnotateApp`。在控制器的视图中添加 `MKMapView`
    和一个按钮。
- en: How to do it...
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to add annotations to a map:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以向地图添加注释：
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `MapAnnotateAppViewController.cs`
    file.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MapAnnotateAppViewController.cs` 文件中添加 `MonoTouch.MapKit` 和 `MonoTouch.CoreLocation`
    命名空间。
- en: 'Add the `IMKMapViewDelegate` interface to the `MapAnnotateAppViewController`
    class declaration using the following code:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将 `IMKMapViewDelegate` 接口添加到 `MapAnnotateAppViewController` 类声明中：
- en: '[PRE45]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE46]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add the following method in the `MapAnnotateAppViewController` class:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MapAnnotateAppViewController` 类中添加以下方法：
- en: '[PRE47]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Compile and run the app either on the simulator or on the device. Tap the button
    to add a pin on the map. The result should be similar to the following screenshot:![How
    to do it...](img/8924OT_10_06.jpg)
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译并运行应用程序，无论是在模拟器上还是在设备上。点击按钮在地图上添加一个图钉。结果应该类似于以下截图：![如何操作...](img/8924OT_10_06.jpg)
- en: Tapping on the pin displays the callout bubble with the annotation title and
    subtitle.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 点击图钉会显示带有注释标题和副标题的呼出气泡。
- en: How it works...
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Annotating maps is very useful for providing a variety of information along
    with the map data. We can use the `MKPointAnnotation` class to create a simple
    annotation as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在地图上注释非常有用，可以提供与地图数据一起的各种信息。我们可以使用 `MKPointAnnotation` 类创建一个简单的注释，如下所示：
- en: '[PRE48]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We assign the annotation that will appear on the map coordinates, and optionally,
    a title and subtitle might also appear. We then add the annotation to the map
    view with the `AddAnnotation` method.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要在地图坐标上出现的注释分配给，并且可选地，标题和副标题也可能出现。然后我们使用 `AddAnnotation` 方法将注释添加到地图视图中。
- en: 'Just adding an annotation object to a map view is not enough. The annotation
    needs a view that will display its information. To provide a view for the annotation,
    we need to assign a delegate object to our map view. In this recipe, we are using
    our controller class as a delegate object for the map view as follows:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 只在地图视图中添加注释对象是不够的。注释需要一个将显示其信息的视图。为了为注释提供视图，我们需要将代理对象分配给我们的地图视图。在这个菜谱中，我们使用我们的控制器类作为地图视图的代理对象，如下所示：
- en: '[PRE49]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'We can assign any object that derives from `NSObject` to the `WeakDelegate`
    property. All we need to make it work properly is to make sure that we provide
    the necessary methods. Here is where the `GetViewForAnnotation` method comes in
    as follows:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何从 `NSObject` 派生的对象分配给 `WeakDelegate` 属性。我们只需要确保我们提供必要的方法。这就是 `GetViewForAnnotation`
    方法出现的地方，如下所示：
- en: '[PRE50]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This method is found in the `MKMapViewDelegate` class and is called by the system
    when it needs to get a view for an annotation. The main difference in our implementation
    here is that instead of subclassing `MKMapViewDelegate`, we just use our controller
    as a delegate for our map view.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法在 `MKMapViewDelegate` 类中，当系统需要为注释获取视图时被调用。我们实现中的主要区别是，我们不是子类化 `MKMapViewDelegate`，而是仅仅将我们的控制器作为地图视图的代理。
- en: 'Inside the `GetViewForAnnotation` method, we need to make sure that we create
    and return a view for our annotation. As the map displays the user''s location,
    there are two annotations on the map. We first need to check if the annotation
    object is `MKUserLocation` using the following code:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetViewForAnnotation` 方法内部，我们需要确保我们为我们的注释创建并返回一个视图。由于地图显示用户的位置，地图上有两个注释。我们首先需要使用以下代码检查注释对象是否为
    `MKUserLocation`：
- en: '[PRE51]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'In this case, we just return null. If the annotation parameter is of the `MKPointAnnotation`
    type, we first try to retrieve the view for it in a fashion similar to `UITableView`
    that creates the cells it contains, as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们只需返回 `null`。如果注释参数是 `MKPointAnnotation` 类型，我们首先尝试以类似于 `UITableView`
    创建其包含的单元格的方式检索其视图，如下所示：
- en: '[PRE52]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'If the result of the `DequeueReusableAnnotation` method is `null`, we initialize
    a new instance for our annotation view using the following code:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `DequeueReusableAnnotation` 方法的返回结果是 `null`，我们使用以下代码初始化我们的注释视图的新实例：
- en: '[PRE53]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The view we create for the annotation here is of the `MKPinAnnotationView` type.
    This is the standard view that is represented by a pin on the map. The properties
    we set are pretty straightforward and define its appearance and behavior. The
    `PinColor` property defines the color of the pin, the `AnimatesDrop` property
    defines if the pin will be displayed on the map with an animation, and the `CanShowCallout`
    property defines if the annotation view will display the information of its underlying
    annotation in a callout bubble.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里为注释创建的视图类型是 `MKPinAnnotationView`。这是由地图上的图钉表示的标准视图。我们设置的属性相当直接，定义了其外观和行为。`PinColor`
    属性定义了图钉的颜色，`AnimatesDrop` 属性定义了图钉是否将以动画形式显示在地图上，而 `CanShowCallout` 属性定义了注释视图是否将在呼出气泡中显示其底层注释的信息。
- en: 'After we have created the view for the annotation, we just return it from the
    method using the following line of code:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们为注释创建了视图之后，我们只需使用以下代码行从方法中返回它：
- en: '[PRE54]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: There's more...
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: We can also create custom annotations and annotation views. For annotations,
    we have to override the `MKAnnotation` class, while for annotation views, we can
    override the `MKAnnotationView` class.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以创建自定义注释和注释视图。对于注释，我们必须重写 `MKAnnotation` 类，而对于注释视图，我们可以重写 `MKAnnotationView`
    类。
- en: An annotation's performance
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注释的性能
- en: 'Theoretically, we can add as many annotations as we want to a map view. Although
    `MKMapView` can manage a large amount of annotations efficiently, it is strongly
    advised to take performance degradation into account. A way to overcome this is
    to display only the required annotations, instead of all of them. To do this,
    we can call the `ShowAnnotations` method, passing the specific annotation objects
    as an array using the following code:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们可以向地图视图中添加任意数量的注释。虽然 `MKMapView` 可以有效地管理大量注释，但强烈建议考虑性能下降。一种克服此问题的方法是只显示所需的注释，而不是所有注释。为此，我们可以调用
    `ShowAnnotations` 方法，使用以下代码将特定的注释对象作为数组传递：
- en: '[PRE55]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: See also
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying maps* and *Adding map overlays* recipes
  id: totrans-303
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示地图* 和 *添加地图覆盖层* 的食谱'
- en: The *Displaying data in a table* recipe in [Chapter 5](ch05.html "Chapter 5. Displaying
    Data"), *Displaying Data*
  id: totrans-304
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [第5章](ch05.html "第5章。显示数据") 的 *在表中显示数据* 食谱中，*显示数据*
- en: Adding map overlays
  id: totrans-305
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加地图覆盖层
- en: In this recipe, we will learn how to add a red circle overlay over a point on
    the map.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将学习如何在地图上的一个点上添加红色圆覆盖层。
- en: Getting ready
  id: totrans-307
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Create a new **Single View Application** in Xamarin Studio and name it `MapOverlayApp`.
    Add `MKMapView` and a button on the controller.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin Studio中创建一个新的**单视图应用程序**，命名为 `MapOverlayApp`。在控制器中添加 `MKMapView` 和一个按钮。
- en: How to do it...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Perform the following steps to add overlays on the map:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以在地图上添加覆盖层：
- en: Add the `MonoTouch.MapKit` and `MonoTouch.CoreLocation` namespaces in the `MapOverlayAppViewController.cs`
    file.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MapOverlayAppViewController.cs` 文件中添加 `MonoTouch.MapKit` 和 `MonoTouch.CoreLocation`
    命名空间。
- en: 'Add the `IMKMapViewDelegate` interface to the class declaration using the following
    code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码将 `IMKMapViewDelegate` 接口添加到类声明中：
- en: '[PRE56]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Add the following code in the `ViewDidLoad` method:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewDidLoad` 方法中添加以下代码：
- en: '[PRE57]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Add the following method to the class:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到类中：
- en: '[PRE58]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Compile and run the app either on the simulator or on the device. When you tap
    the button, the result should be similar to the following screenshot:![How to
    do it...](img/8924OT_10_07.jpg)
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模拟器或设备上编译并运行应用程序。当你点击按钮时，结果应该类似于以下截图：![如何操作...](img/8924OT_10_07.jpg)
- en: How it works...
  id: totrans-319
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: While an `MK` `MKAnnotation` represents a point on a map, an `MKOverlay` object
    can represent an area on a map. In this example, we use the `MKCircle` class,
    which inherits from `MKOverlay`, to display a circle over an area on the map.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `MK` `MKAnnotation` 代表地图上的一个点，但 `MKOverlay` 对象可以代表地图上的一个区域。在这个例子中，我们使用继承自
    `MKOverlay` 的 `MKCircle` 类来在地图上显示一个圆。
- en: 'We initialize an `MKCircle` instance with its `Circle` static method using
    the following code:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用以下代码使用 `Circle` 静态方法初始化 `MKCircle` 实例：
- en: '[PRE59]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'The first parameter represents the coordinates of the center of the circle,
    while the second parameter represents the radius of the circle, in meters. After
    initialization, we add the overlay to the map view with the `AddOverlay` method
    as follows:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个参数表示圆心的坐标，第二个参数表示圆的半径，单位为米。初始化后，我们使用以下 `AddOverlay` 方法将覆盖层添加到地图视图中：
- en: '[PRE60]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'The second parameter of the `AddOverlay` method determines how the overlay
    should be rendered in relation to the map''s information. There are two possible
    values, which are explained with the following accompanying screenshots:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddOverlay` 方法的第二个参数确定覆盖层相对于地图信息应该如何渲染。有两种可能的值，以下附图进行了说明：'
- en: '`MKOverlayLevel.AboveRoads`: This overlay will be displayed above the roads
    of the map, but below the map labels, as shown in the following screenshot:![How
    it works...](img/8924OT_10_08.jpg)'
  id: totrans-326
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKOverlayLevel.AboveRoads`: 此覆盖层将在地图的道路之上显示，但在地图标签之下，如下面的截图所示：![如何工作...](img/8924OT_10_08.jpg)'
- en: '`MKOverlayLevel.AboveLabels`: This overlay will be displayed above both roads
    and labels on the map, but below annotations and 3D projections of the buildings,
    as shown in the following screenshot:![How it works...](img/8924OT_10_09.jpg)'
  id: totrans-327
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MKOverlayLevel.AboveLabels`: 此覆盖层将在地图上显示在道路和标签之上，但在注释和建筑物的3D投影之下，如下面的截图所示：![如何工作...](img/8924OT_10_09.jpg)'
- en: Unlike annotations, overlays require `MKOverlayRenderer` to display their information.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 与注释不同，覆盖层需要 `MKOverlayRenderer` 来显示其信息。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Prior to iOS 7, overlays were shown with a view of the `MKOverlayView` type.
    This class is now deprecated.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 7 之前，叠加是以 `MKOverlayView` 类型的视图显示的。这个类现在已弃用。
- en: 'To provide a renderer for our overlay, we use the `OverlayRenderer` method
    as follows:'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为我们的叠加提供渲染器，我们使用 `OverlayRenderer` 方法如下：
- en: '[PRE61]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Inside this method, we first check if the `overlay` parameter is of the type
    we want (in this case, an `MKCircle`) using the following code:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们首先使用以下代码检查 `overlay` 参数是否为我们想要的类型（在这种情况下，一个 `MKCircle`）：
- en: '[PRE62]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Then, we create an instance of the `MKCircleView` class and return it as follows:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个 `MKCircleView` 类的实例，并如下返回它：
- en: '[PRE63]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: We set the appropriate properties that will define the appearance of our overlay.
    In this case, we set the `FillColor`, `StrokeColor`, and `LineWidth` properties.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 我们设置适当的属性，这些属性将定义我们的叠加外观。在这种情况下，我们设置了 `FillColor`、`StrokeColor` 和 `LineWidth`
    属性。
- en: There's more...
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Overlays are handled efficiently by the map view. One important thing that the
    map view takes care of for us is that when we scale the map, the overlay is automatically
    scaled to match each zoom level. This way, we do not need to scale the overlay
    manually in code.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 地图视图高效地处理叠加。地图视图为我们处理的一个重要事情是，当我们缩放地图时，叠加会自动缩放到匹配每个缩放级别。这样，我们就不需要在代码中手动缩放叠加。
- en: Creating custom overlays
  id: totrans-340
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义叠加
- en: We can create our own custom overlays. To do this, we need to override the `MKOverlay`
    class for the overlay and the `MKOverlayRenderer` class for the renderer.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建自己的自定义叠加。为此，我们需要为叠加覆盖 `MKOverlay` 类，并为渲染器覆盖 `MKOverlayRenderer` 类。
- en: Standard overlay objects
  id: totrans-342
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 标准叠加对象
- en: Apart from `MKCircle`, the other standard overlay objects are `MKPolygon` for
    creating polygon shapes and `MKPolyline` for creating polylines, like in a track-recording
    application.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `MKCircle` 之外，其他标准叠加对象是 `MKPolygon`，用于创建多边形形状，以及 `MKPolyline`，用于创建折线，如在轨迹记录应用程序中。
- en: See also
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Displaying maps* and *Adding map annotations* recipes
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*显示地图* 和 *添加地图标注* 的食谱'
