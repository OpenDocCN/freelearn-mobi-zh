- en: Chapter 9. Performance Enhancement and Extras
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章. 性能提升与附加功能
- en: In the previous chapter, we discussed about adding multiple levels in our game;
    adding multiple levels in a game is a normal functionality in most games. We also
    added the functionality to show the current level of the game by using a level
    label. Apart from this, we added a pause button and the button to access the node
    menu scene from the main menu.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们讨论了在我们的游戏中添加多个级别；在大多数游戏中，添加多个级别是一个正常的功能。我们还添加了使用级别标签显示游戏当前级别的功能。除此之外，我们还添加了暂停按钮和从主菜单访问节点菜单场景的按钮。
- en: 'This chapter is one of the most essential chapters in this book; here we are
    going to discuss about performance enhancement tips and tricks. Apart from this,
    we are going to add some really important features in our game. These features
    are:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是本书中最重要的章节之一；在这里，我们将讨论性能提升的技巧和窍门。除此之外，我们还将为我们的游戏添加一些非常重要的功能。这些功能包括：
- en: The scoring system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 评分系统
- en: The sound
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音
- en: The running animation of the player
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家的运行动画
- en: Sound is an essential part of a game; it greatly enhances the overall gameplay
    experience for the player. The scoring system helps the player to measure his
    or her performance over time. Running texture produces a good animation effect
    in the game, which increases the gameplay experience a lot. We are going to add
    all of these features in this current chapter, along with discussing about some
    of the important performance enhancement techniques for a Sprite Kit game.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 声音是游戏的一个基本组成部分；它极大地增强了玩家的整体游戏体验。评分系统帮助玩家衡量其随时间的变化表现。运行纹理在游戏中产生良好的动画效果，大大增加了游戏体验。我们将在这章中添加所有这些功能，并讨论一些Sprite
    Kit游戏的重要性能提升技术。
- en: Performance enhancement
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能提升
- en: 'Running a game requires extensive usage of memory and other resources of the
    device. This leads to accelerated drainage of the battery. We need to optimize
    the usage of the device resources for games. A game requires higher frames per
    second, hence more battery drainage occurs due to the excessive usage of the device
    resources. An optimized game will lead to efficient use of the device resources,
    hence less battery drainage. Following are listed some of the best practices to
    optimize the efficiency of a game:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏需要大量使用设备的内存和其他资源。这导致电池加速耗尽。我们需要优化游戏对设备资源的利用。游戏需要更高的帧率，因此由于对设备资源的过度使用，电池耗尽会更多。一个优化的游戏将导致设备资源的有效使用，从而减少电池耗尽。以下是优化游戏效率的一些最佳实践：
- en: Systemizing a game's content in the scene
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在场景中系统化游戏内容
- en: Improving the drawing performance
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高绘图性能
- en: Improving performance with `SKAction` and constraints
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SKAction`和约束提高性能
- en: Improving the physics performance
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高物理性能
- en: Improving the shapes performance
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高形状的性能
- en: Improving the effects performance
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高效果性能
- en: Improving the lighting
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高光照
- en: Now we are going to discuss each of the previously listed methods in detail.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将详细讨论之前列出的每种方法。
- en: Systemizing a game's content in the scene
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在场景中系统化游戏内容
- en: As we know, scenes are the elementary building blocks in a Sprite Kit game.
    A game can contain multiple scenes according to the requirements. A scene can
    contain multiple nodes, where the nodes can perform particular actions. We have
    a clear idea of how to create scenes, nodes, and actions for nodes. The challenging
    task is designing the game's scene and transition in such a way that it should
    not lower the game's performance.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所知，场景是Sprite Kit游戏中基本的构建块。根据需求，一个游戏可以包含多个场景。一个场景可以包含多个节点，节点可以执行特定的动作。我们清楚地了解如何创建场景、节点以及节点的动作。具有挑战性的任务是设计游戏场景和转换，以便不会降低游戏性能。
- en: 'One thing that should be kept in mind is that the scenes do not have a default
    behavior, as the storyboards do in traditional iOS app. Instead, we define and
    implement the behaviors for respective scenes, which may include the following:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 应当记住的一件事是，场景在传统iOS应用中与故事板不同，它们没有默认的行为。相反，我们为各自的场景定义和实现行为，这可能包括以下内容：
- en: When to create new scenes
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 何时创建新的场景
- en: Defining the content of the scene
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义场景的内容
- en: Defining when the transitions between the scenes should occur
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义场景间转换应何时发生
- en: Defining the visual effect for transition
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义转换的视觉效果
- en: Defining how the data is transferred from one scene to another
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义数据如何从一个场景传输到另一个场景
- en: Performance enhancement by preloading textures
  id: totrans-25
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过预加载纹理来提高性能
- en: 'This is one of the most powerful ways of increasing the performance of a game.
    Sprite Kit provides two methods for the same:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这是提高游戏性能最强大的方法之一。Sprite Kit提供了两种相同的方法：
- en: '`func preloadWithCompletionHandler(completionHandler: () -> Void)`: This method
    uses a function that is responsible for loading the atlas textures into memory,
    which requires the parameter, `completionHandler`, which is called after the task
    is completed.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func preloadWithCompletionHandler(completionHandler: () -> Void)`: 此方法使用一个负责将图集纹理加载到内存中的函数，该函数需要参数`completionHandler`，在任务完成后调用。'
- en: '`func preloadTextureAtlases(textureAtlases: [AnyObject]!,`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`func preloadTextureAtlases(textureAtlases: [AnyObject]!,`'
- en: '`withCompletionHandler completionHandler: (() -> Void)!)`: This method loads
    the textures of multiple atlases into memory and calls a completion handler after
    the task is completed. The completion handler expects two parameters: one is `textureAtlases`,
    which is an array of the `SKTextureAtlas` objects, and the second parameter is
    `completionHandler`, which is a block called after the texture atlases are loaded.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`withCompletionHandler completionHandler: (() -> Void)!)`: 此方法将多个图集的纹理加载到内存中，并在任务完成后调用完成处理程序。完成处理程序期望两个参数：一个是`textureAtlases`，它是一个`SKTextureAtlas`对象的数组，另一个参数是`completionHandler`，在图集纹理加载后调用。'
- en: Using texture atlases will reduce draw call, subsequently reducing the usage
    of the device resources. As of now, we have discussed some of the important techniques
    of performance enhancement in a game. Now, it is time to discuss about some essential
    elements of the game, such as scoring system, sounds, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 使用纹理图集可以减少绘制调用，从而减少对设备资源的使用。到目前为止，我们已经讨论了一些游戏性能提升的重要技术。现在，是时候讨论一些游戏的基本元素了，例如得分系统、声音等。
- en: Improving the drawing performance
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高绘制性能
- en: 'The biggest part of building a node tree is organizing the graphical content
    that needs to be drawn. We should take care of what needs to drawn first and what
    should be drawn in the end. There are two factors which influence the drawing
    performance:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 构建节点树的最大部分是组织需要绘制的图形内容。我们应该注意先绘制什么，最后绘制什么。有两个因素会影响绘制性能：
- en: Drawing order, by which the graphics are submitted to the engine
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绘制顺序，即图形提交给引擎的顺序
- en: Sharing of resources to accomplish the drawing
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过资源共享来完成绘制
- en: 'With respect to drawing order, you can set the sibling order of the node tree
    to reduce the number of drawings submitted by ignoring the sibling order:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关于绘制顺序，你可以设置节点树的兄弟顺序以减少通过忽略兄弟顺序提交的绘制次数：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You can use depth order as the rule to batch them together, and texture maps
    to optimize the batching further.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用深度顺序作为规则将它们一起批处理，并使用纹理图集进一步优化批处理。
- en: 'Make sure to turn on the performance metrics, such as **frames per second**
    (**FPS**), node count, draw count, and quad count. These metrics will help you
    determine the performance of a game. Following are the codes that we can use to
    view the performance metrics:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 确保开启性能指标，如**每秒帧数**（**FPS**）、节点计数、绘制计数和四边形计数。这些指标将帮助你确定游戏的性能。以下是我们可以使用来查看性能指标的代码：
- en: '[PRE1]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In reference to the preceding code block, let''s discuss each of the metrics:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的代码块，让我们讨论每个指标：
- en: In code `#1`, we are displaying the number of frames per second in the game
    scene. The optimum FPS for a game is `60`. By displaying the FPS in the game,
    it becomes easy to measure the FPS.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码`#1`中，我们显示游戏场景中每秒的帧数。游戏的最佳帧率是`60`。在游戏中显示帧率，可以轻松测量帧率。
- en: In code `#2`, we are displaying the number of `SKNodes` in a scene. The lesser
    nodes we have in a scene, the better it performs. A game needs to have nodes in
    order to have elements in the game, but we can measure the FPS and nodes together
    to make sure how many nodes are producing the optimum FPS.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码`#2`中，我们显示场景中`SKNodes`的数量。场景中的节点越少，性能越好。一个游戏需要节点来拥有游戏中的元素，但我们可以一起测量帧率和节点，以确保有多少节点产生了最佳的帧率。
- en: In code `#3`, we are displaying the number of batches for the scene count, that
    is, how many batches the scene is going to draw. The lesser draws your game has,
    the better it performs.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码`#3`中，我们显示场景计数的批次数，即场景将要绘制的批次数。你的游戏绘制的次数越少，性能越好。
- en: In code `#4`, we are displaying the quad count. Sprite Kit converts the node
    tree into rendered passes. Each of these rendering passes is rendered using quads.
    The lower the number of quads we have, the better the game performance.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在代码`#4`中，我们显示了四边形数量。Sprite Kit将节点树转换为渲染传递。每个渲染传递都使用四边形进行渲染。我们拥有的四边形数量越少，游戏性能越好。
- en: Improving performance with SKActions and constraints
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用SKActions和约束提高性能
- en: The main solution factor to increase the performance is by building the action
    once and using it for the maximum number of times possible. Try to avoid the custom
    animation code from the `update()` method. By using the `SKAction` and `SKConstraint`
    classes, you can optimize the animation effects in a game.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 提高性能的主要解决方案是构建一次动作并尽可能多地使用它。尽量避免在`update()`方法中使用自定义动画代码。通过使用`SKAction`和`SKConstraint`类，你可以优化游戏中的动画效果。
- en: Improving the physics performance
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高物理性能
- en: Whenever `SKScene` computes a new frame of animation, it simulates the effects
    of forces and collisions on physics bodies connected to the node tree. It computes
    a final position, orientation, and velocity for each physics body.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 每当`SKScene`计算动画的新帧时，它会模拟节点树连接的物理体上的力和碰撞效果。它为每个物理体计算最终的位置、方向和速度。
- en: With respect to improving the performance of the game, the dynamic objects cost
    more than static objects, so if possible, we can set the following property, so
    that the performance will be increased gradually.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 关于提高游戏性能，动态对象比静态对象成本更高，因此如果可能的话，我们可以设置以下属性，以便性能逐渐提高。
- en: 'Some guidelines for this are:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一些指导原则如下：
- en: You should use collision masks to group objects for performance
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你应该使用碰撞掩码来分组对象以提高性能
- en: You can use force fields to replace game logic
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以使用力场来代替游戏逻辑
- en: You should turn on field debug drawing, if needed
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果需要，你应该打开场调试绘制
- en: Before assigning a specified boundary to a physics body, you must consider the
    most efficient shape for your object. The shape of the boundary defines the number
    of calculations/operations required to be performed by the device, costing efficiency.
    The **Circle** is the cheapest, followed by the **Rectangle**, **Polygon**, **Compound**,
    and **Alpha Mask** bodies in the order of increasing cost of computation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在将指定的边界分配给物理体之前，你必须考虑你对象的最有效形状。边界的形状定义了设备需要执行的计算/操作的数量，这影响了效率。**圆形**是最便宜的，其次是**矩形**、**多边形**、**复合体**和**Alpha掩码**，计算成本按顺序增加。
- en: '![Improving the physics performance](img/4201_09_06.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![提高物理性能](img/4201_09_06.jpg)'
- en: The computation cost scale for different shapes of boundaries
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 不同形状边界的计算成本比例
- en: Improving shape's performance
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高形状的性能
- en: The shape of an object node plays an important role with respect to game performance.
    Where the performance will be increased if the node requires a lesser number of
    computations.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 对象节点的形状在游戏性能方面起着重要作用。如果节点需要较少的计算，性能将会提高。
- en: In the same way as described in the physics performance topic, you can improve
    the efficiency cost of shape nodes. The polygon is the cheapest in terms of performance
    cost, followed by curves, linear stroke, stroked curve, and filled curve in the
    order of increasing costs of computation.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 与物理性能主题中描述的相同，你可以提高形状节点的效率成本。在性能成本方面，多边形是最便宜的，其次是曲线、线性描边、描边曲线和填充曲线，计算成本按顺序增加。
- en: '![Improving shape''s performance](img/4201_09_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![改进形状的性能](img/4201_09_07.jpg)'
- en: The performance cost scale for shape nodes
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 形状节点的性能成本比例
- en: Improving effect's performance
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高效果的性能
- en: With respect to effects in Sprite Kit, `SKEffectNodes` are expensive, hence,
    use it sparingly. It does its rendering off-screen and transfers to framebuffer,
    reducing efficiency. It is better to use `SKShaders` when no off-screen pass is
    needed.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Sprite Kit中的效果，`SKEffectNodes`成本较高，因此请尽量少用。它在其屏幕外进行渲染并将结果传输到帧缓冲区，这降低了效率。当不需要屏幕外传递时，最好使用`SKShaders`。
- en: If the effects do not change much, it is better to rasterize such effects by
    using the `shouldRasterize` property. If the `shouldRastertize` property is `true`,
    the effect node caches the image for use in future frames.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 如果效果变化不大，最好通过使用`shouldRasterize`属性来光栅化这些效果。如果`shouldRasterize`属性为`true`，效果节点将缓存图像以供未来帧使用。
- en: Improving lighting performance
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提高光照性能
- en: Lighting is computed on a per pixel basis, hence the computation cost is proportional
    to the amount of pixels lit. Ambient light does not cost in terms of computation
    power. Computation cost of shadows is proportional to the number of lights, hence
    it is advised to keep the number of shadows low.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 照明是按像素计算的，因此计算成本与被照亮的像素数量成正比。环境光不会消耗计算能力。阴影的计算成本与灯光的数量成正比，因此建议保持阴影数量较低。
- en: Measuring performance with instruments
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用仪器测量性能
- en: Instruments is a performance measuring and testing tool provided by Apple in
    Xcode for the tracing and profiling of code. Instruments help in analyzing the
    performance of code. There are lot of instruments that can be used for checking
    performance issues, memory leaks, or other problems.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments是苹果在Xcode中提供的性能测量和测试工具，用于代码的跟踪和剖析。Instruments有助于分析代码的性能。有许多仪器可用于检查性能问题、内存泄漏或其他问题。
- en: Once any issue gets identified, it becomes easy to rectify the issue. You can
    also see how much our game caches, and based on that, make a decision about the
    assets in the game.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦识别出任何问题，就很容易纠正。您还可以查看我们的游戏缓存了多少，并根据这一点对游戏中的资产做出决定。
- en: You can access the instruments by navigating to **Xcode** | **Open Developer
    Tool** | **Instruments**. Then, you can choose the appropriate instrument to move
    with. It is better to have a look at the analysis in the initial phase of the
    development process, by this, you can easily understand which inclusion in the
    code was responsible for the error.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过导航到**Xcode** | **打开开发者工具** | **Instruments**来访问仪器。然后，您可以选择合适的仪器进行操作。在开发过程的初期阶段查看分析会更好，这样您可以轻松地了解代码中的哪些包含导致了错误。
- en: 'Instruments provide you with a list of trace templates. Trace templates are
    groups of preconfigured instruments. Let''s discuss each of the trace templates
    in detail:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: Instruments为您提供一个跟踪模板列表。跟踪模板是一组预配置的仪器。让我们详细讨论每个跟踪模板：
- en: '![Measuring performance with instruments](img/4201_09_01.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![使用仪器测量性能](img/4201_09_01.jpg)'
- en: '**Activity Monitor**: The **Activity Monitor** is used to monitor the CPU,
    memory, disk, and network usage statistics processes.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**活动监视器**：**活动监视器**用于监控CPU、内存、磁盘和网络使用统计的进程。'
- en: '**Allocations**: The allocation tool is used to track a process''s anonymous
    virtual memory and heap.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分配**：分配工具用于跟踪进程的匿名虚拟内存和堆。'
- en: This tool also provides the class names and optionally retained/released histories
    for objects.
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此工具还提供了对象的类名以及可选的保留/释放历史记录。
- en: '**Automation**: The automation template executes a script that simulates the
    UI interaction for an iOS application, which is launched from the instruments.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动化**：自动化模板执行一个脚本，该脚本模拟iOS应用程序的UI交互，该应用程序从仪器启动。'
- en: '**Cocoa Layout**: The **Cocoa Layout** observes the changes to the `NSLayoutConstraint`
    objects to help in determining when and where a layout constraint went away.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Cocoa布局**：**Cocoa布局**观察`NSLayoutConstraint`对象的变化，以帮助确定何时以及在哪里布局约束消失了。'
- en: '**Core Animation**: The **Core Animation** instrument measures application
    graphics performance as well as CPU usage of a process, via time profiling.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心动画**：**核心动画**仪器通过时间剖析测量应用程序的图形性能以及进程的CPU使用情况。'
- en: '**Core Data**: This instrument template traces the **Core Data** filesystem
    activity, including fetches, cache misses, and saved caches too. This was discussed
    in [Chapter 8](ch08.html "Chapter 8. Handling Multiple Scenes and Levels"), *Handling
    Multiple Scenes and Levels*.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**核心数据**：此仪器模板跟踪**核心数据**文件系统活动，包括检索、缓存未命中和保存的缓存。这在[第8章](ch08.html "第8章. 处理多个场景和级别")
    *处理多个场景和级别*中已有讨论。'
- en: '**Counters**: The **Counters** will collect the **performance monitor counter**
    (**PMC**) events, using time or event-based sampling methods.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**计数器**：**计数器**将收集**性能监视器计数器**（**PMC**）事件，使用基于时间或事件采样的方法。'
- en: '**Dispatch**: This template will monitor the dispatch queue activity, and record
    block invocations and their durations.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调度**：此模板将监控调度队列的活动，并记录块调用及其持续时间。'
- en: '**Energy Diagnostics**: This template will provide the diagnostics regarding
    energy usage as well as the basic ON/OFF state of major device components.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**能源诊断**：此模板将提供有关能源使用以及主要设备组件的基本开/关状态的诊断信息。'
- en: '**File Activity**: This will monitor the file and directory activity, including
    the file OPEN/CLOSE calls, file permission modifications, directory creation,
    file moves, and so on.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文件活动**：这将监控文件和目录活动，包括文件打开/关闭调用、文件权限修改、目录创建、文件移动等。'
- en: '**GPU Driver**: This template is used to measure the GPU driver statistics
    and it also samples active CPU usage.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GPU驱动程序**：此模板用于测量GPU驱动程序统计信息，并且它还采样活动CPU使用情况。'
- en: '**Leaks**: The **Leaks** will measure the general memory usage; it periodically
    scans if an object is created and not accessed and detects the resulting memory
    loss.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**泄漏**：**泄漏**将测量一般内存使用情况；它定期扫描是否有对象被创建但没有被访问，并检测由此产生的内存损失。'
- en: '**Network**: The **Network** analyses, how your applications are using the
    TCP/IP and UDP/IP connections, using the connections instrument.'
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网络**：**网络**分析使用连接工具分析应用程序如何使用TCP/IP和UDP/IP连接。'
- en: '**OpenGL ES Analysis**: This template measures and analyses openGL ES activity
    to detect openGL ES precision and performance problems. It also offers recommendations
    for addressing these problems.'
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OpenGL ES分析**：此模板测量和分析OpenGL ES活动，以检测OpenGL ES精度和性能问题。它还提供了解决这些问题的建议。'
- en: '**Sudden Termination**: The **Sudden Termination** is used to analyze the sudden
    termination support of a target process, reporting back traces of file system
    accesses and sudden termination enabled/disabled calls.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**突然终止**：**突然终止**用于分析目标进程的突然终止支持，报告文件系统访问和突然终止启用/禁用调用的跟踪。'
- en: '**System Trace**: This instrument provides system information such as process
    name, number of threads generated, CPU usage by each thread, and so on.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统跟踪**：此工具提供系统信息，例如进程名称、生成的线程数、每个线程的CPU使用情况等。'
- en: '**System Usage**: This template is used to record the I/O system activity related
    to files, sockets, and shared memory for a single process launched via instruments.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**系统使用**：此模板用于记录通过工具启动的单个进程与文件、套接字和共享内存相关的I/O系统活动。'
- en: '**Time Profiler**: The **Time Profiler** is used to perform the low-overhead
    time-based sampling, where we can check the status of the processes that are running
    on the system CPUs. Profiling is a means of measuring, by which the output of
    a profiling session gives you an insight on what parts of your code are used most
    often, and tells you which part of the code can be improved.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**时间分析器**：**时间分析器**用于执行低开销的时间采样，我们可以检查系统CPU上运行的过程的状态。分析是一种测量方法，通过分析会话的输出，你可以了解代码中哪些部分被使用得最多，并告诉你哪些代码部分可以改进。'
- en: '**Zombies**: If a game has removed an object, but at a later stage tries to
    access that object, it will crash the game. The Zombies instrument keeps removed
    objects as dead, and later on releases it whenever called by the game, hence,
    avoiding a crash. This way, the Zombies instrument points out where the game may
    crash. A debugger cannot pin-point this anomaly.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**僵尸**：如果一个游戏删除了一个对象，但在稍后阶段试图访问该对象，它将使游戏崩溃。僵尸工具将删除的对象保持为已死亡状态，并在游戏调用时释放它，从而避免崩溃。这样，僵尸工具就指出了游戏可能崩溃的地方。调试器无法定位这种异常。'
- en: A scoring system in a game
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的评分系统
- en: Adding a scoring or points system in a game makes it more interesting and fun
    to play. Having a scoring system in the game makes it easier for the players to
    measure their performance, making the objective clear for the user.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中添加评分或得分系统可以使游戏更有趣，更有趣。在游戏中拥有评分系统使玩家更容易衡量他们的表现，使用户的目标更加明确。
- en: It always makes sense to display the score somewhere on the main screen, so
    that the player can have a look at the score while playing the game.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在主屏幕的某个位置显示分数是有意义的，这样玩家在玩游戏时可以查看分数。
- en: Adding a scoring system in our Platformer game
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在我们的平台游戏添加评分系统
- en: In the first step of adding a scoring system in our game, we create a label
    node to display the score to the player. The initial variable will be zero.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们游戏添加评分系统的第一步，我们创建一个标签节点来向玩家显示分数。初始变量将为零。
- en: Creating the Score label
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建分数标签
- en: 'Let''s add the following code snippet in the beginning of the `GameScene` class:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`GameScene`类的开头添加以下代码片段：
- en: '[PRE2]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In the preceding code, you are creating an `SKLabelNode` and assigning it to
    the font, `Chalkduster`. Along with this, you are also initializing a variable
    `score` with the value as zero.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，你正在创建一个`SKLabelNode`并将其分配给字体`Chalkduster`。与此相关，你还在初始化一个变量`score`，其值为零。
- en: 'Now, let''s set the `ScoreText` label created above zero. Also, we can set
    the size and position of the font in an `addScoreLabel()` method and we can call
    this from `didMoveToView()` of `GameScene`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将上面创建的`ScoreText`标签设置为0。我们还可以在`addScoreLabel()`方法中设置字体的大小和位置，并从`GameScene`的`didMoveToView()`中调用此方法：
- en: '[PRE3]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The preceding code will define the score text to **Score: 0** and the font
    size to `30`. Along with this, we have also defined the position of the `scoreText`.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码将定义分数文本为**分数：0**和字体大小为`30`。此外，我们还定义了`scoreText`的位置。
- en: 'Following is how the game screen will look after implementing the **Score**
    label:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是实现**分数**标签后的游戏屏幕将看起来如何：
- en: '![Creating the Score label](img/4201_09_02.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![创建分数标签](img/4201_09_02.jpg)'
- en: Incrementing the score when required
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在需要时增加分数
- en: It is important to define when we have to increment the score in our game. The
    same should also be displayed in the `scoreText` label we have created.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中定义何时增加分数非常重要。同样，这也应该在创建的`scoreText`标签中显示。
- en: As our *Platformer* game deals with blocks, which act as an obstacle, it is
    better to reward points to the player when he jumps over a block.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的*平台游戏*处理作为障碍物的方块，当玩家跳过一个方块时，最好奖励玩家分数。
- en: 'Add the following lines of code in the `blockrunner()` method with the condition
    that the blocks should successfully cross the player''s *X* position without colliding
    with him (the first `else` condition):'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在`blockrunner()`方法中添加以下代码行，条件是方块应该成功跨越玩家的**X**位置而不与他碰撞（第一个`else`条件）：
- en: '[PRE4]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now, to save the highest score and the user''s name, we will use a special
    facility provided by iOS to save frequently required data via `NSUserDefaults`,
    in the following way:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了保存最高分和用户的名字，我们将使用iOS提供的特殊功能，通过`NSUserDefaults`保存频繁需要的数据，如下所示：
- en: '[PRE5]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code is to be added just before the end of the `if` statement,
    `blockStatus.isRunning`. The code will successfully increment score. Now, it is
    time to save the high score.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码需要在`if`语句`blockStatus.isRunning`的末尾之前添加。这段代码将成功增加分数。现在，是时候保存高分了。
- en: Saving the high score
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保存高分
- en: We will add a popup screen to save the high score when the user scores a high
    score. To make this happen, firstly, we have to create a new scene, `ScoreList.swift`,
    and call this scene when the player is out, that is, when the game is over.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户得分高时，我们将添加一个弹出屏幕来保存高分。为了实现这一点，首先，我们必须创建一个新的场景，`ScoreList.swift`，并在玩家出局时调用此场景，即游戏结束时。
- en: 'In our `didBeginContact()` method, we have the following code line:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`didBeginContact()`方法中，我们有以下代码行：
- en: '[PRE6]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Replace the preceding lines with the following ones:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 将前面的行替换为以下行：
- en: '[PRE7]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The new lines add the `ScoreList` scene when the player dies.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 新增的行在玩家死亡时添加了`ScoreList`场景。
- en: 'Now, we will create a new method called `gotoSavePlayerScreen()`, to check
    if the current score is greater than the saved score. Then, the `ScoreList` scene
    should be called, or else the main screen, that is, the `MainMenu` scene. The
    code for the same is as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个名为`gotoSavePlayerScreen()`的新方法，以检查当前分数是否大于保存的分数。然后，应该调用`ScoreList`场景，否则调用主屏幕，即`MainMenu`场景。相应的代码如下：
- en: '[PRE8]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We have implemented the method to select the scene to open after game completion.
    Now, let's construct the `ScoreList` scene.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经实现了在游戏完成后打开场景的方法。现在，让我们构建`ScoreList`场景。
- en: Creating the scene to save the high score
  id: totrans-125
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建保存高分的场景
- en: Let's create the `ScoreList` scene to display a popup for saving the highest
    score.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个`ScoreList`场景来显示保存最高分的弹出窗口。
- en: 'Also, add a label to congratulate the user. Following is the code for same:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还需要添加一个标签来恭喜用户。以下是为同一目的的代码：
- en: '[PRE9]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We also need to add a **CANCEL** button if the user doesn''t want to save the
    score with a name. Add the following code from the `didMoveToView()` method of
    `ScoreList.swift`, where the **CANCEL** button will take you to `MenuScene`:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果用户不想用名字保存分数，我们需要添加一个**取消**按钮。请从`ScoreList.swift`的`didMoveToView()`方法中添加以下代码，其中**取消**按钮将带您进入`MenuScene`：
- en: '[PRE10]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The preceding code adds a cancel button in blue color, and tapping on this
    button takes the player to the `MenuScene`. Now, to handle the tapping on the
    **CANCEL** button, add the following code within touches loop, inside the `touchesBegan()`
    method of `ScoreList.swift`:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码在蓝色中添加了一个取消按钮，点击此按钮将玩家带到`MenuScene`。现在，为了处理**取消**按钮的点击，请在`ScoreList.swift`的`touchesBegan()`方法中的触摸循环内添加以下代码：
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The score list will have been successfully created. We have also added a cancel
    button for the convenience of the user. Now, it is time to add a textbox in which
    the player will add his/her name.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 成绩列表已经成功创建。我们也为用户添加了一个取消按钮。现在，是时候添加一个文本框，玩家将在其中添加他的/她的名称。
- en: Adding a textbox to save player name
  id: totrans-134
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加文本框以保存玩家名称
- en: 'We need to display a textbox for the user to enter the player name that is
    to be saved. Add the following code line to insert a textfield inside a frame:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要显示一个文本框供用户输入要保存的玩家名称。添加以下代码行以在框架内插入一个文本字段：
- en: '[PRE12]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following method will make the textbox that is to be used:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法将创建要使用的文本框：
- en: '[PRE13]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Now, let''s add a `textFieldShouldReturn` method of `UITextFieldDelegate`,
    to make the keypad disappear after tapping the return key while entering the player
    name in the textbox:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个`UITextFieldDelegate`的`textFieldShouldReturn`方法，以便在文本框中输入玩家名称并点击回车键时使键盘消失：
- en: '[PRE14]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Now, add the `UITextFieldDelegate` delegate to the `Scorelist` class at the
    beginning. This delegate enables the keyboard to appear.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Scorelist`类开始时添加`UITextFieldDelegate`代理。这个代理使键盘出现。
- en: The preceding snippet will successfully make the keyboard disappear once the
    return key is pressed. Now, the next task will be to save the added name.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将在按下回车键后成功使键盘消失。现在，下一个任务是将添加的名称保存。
- en: '![Adding a textbox to save player name](img/4201_09_08.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![添加文本框以保存玩家名称](img/4201_09_08.jpg)'
- en: This is how the screen will look when the keyboard is opened
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这是键盘打开时的屏幕外观
- en: Saving the player name with high score
  id: totrans-145
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 保存高分玩家的玩家名称
- en: 'We will name the button **ADD PLAYER**. This button will make the name entered
    by the user to get saved with the high score made. Firstly, create the following
    node, named `add-player`, with the image:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将命名按钮为**添加玩家**。这个按钮将使用户输入的名称与高分一起保存。首先，创建以下节点，命名为`add-player`，并带有图像：
- en: '[PRE15]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Add the following code method to set the properties of the **ADD PLAYER** button.
    Also, make sure to call the same from the `didmoveToView()` method:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 添加以下代码方法来设置**添加玩家**按钮的属性。同时，确保从`didmoveToView()`方法中调用相同的代码：
- en: '[PRE16]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Add the following lines of code in the `touchesBegan()` method of `ScoreList.swift`,
    as in the previous code, to handle the tap of the **ADD PLAYER** button within
    touches loop:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ScoreList.swift`的`touchesBegan()`方法中添加以下代码行，如前所述，在触摸循环中处理**添加玩家**按钮的点击：
- en: '[PRE17]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We are also adding `gotoMenuScene()` to return to the main menu as we know.
    Following is the code for it:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了`gotoMenuScene()`来返回主菜单，正如我们所知。以下是它的代码：
- en: '[PRE18]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, the work on `SceneList.swift` is complete. Time to work on the high score
    board. The following screenshot shows how the screen will look:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`SceneList.swift`的工作已经完成。是时候开始处理高分榜了。以下截图显示了屏幕将如何显示：
- en: '![Saving the player name with high score](img/4201_09_03.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![保存高分玩家的玩家名称](img/4201_09_03.jpg)'
- en: Creating the high score board
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建高分榜
- en: So far, we have saved the name of the player who makes a high score, but we
    have not made a score board to show the high score to the player. It is better
    to have access to the score board right from the main menu, as it makes it convenient.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经保存了获得高分玩家的名称，但我们还没有创建一个分数榜来向玩家显示高分。最好直接从主菜单访问分数榜，因为它使操作更方便。
- en: In our game, we are going to create a high score menu scene with a button on
    the main menu to reach this screen.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将创建一个高分菜单场景，在主菜单中有一个按钮可以访问此屏幕。
- en: Firstly, create a scene with the name, `AddScoreScene.swift`, to show the high
    score.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个名为`AddScoreScene.swift`的场景，以显示高分。
- en: 'Now, create the method, `showHeightestScorerName()`,to display the name of
    the player who scored the highest score, and also call the same from the `didMoveToView()`
    method in the `AddScoreScene.swift` file:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`showHeightestScorerName()`的方法来显示得分最高玩家的名称，并从`AddScoreScene.swift`文件中的`didMoveToView()`方法中调用相同的方法：
- en: '[PRE19]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'We have displayed the name of the player with the highest score, now it is
    time to show the highest score made by the player. For this, create the method,
    `showHeighestScores()`, and also call the same from the `didMoveToView()` method
    in the `AddScoreScene.swift` file. Following is the code to be added in the `showHeighestScores()`
    method:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经显示了得分最高的玩家的名称，现在该显示玩家创下的最高分了。为此，创建`showHeighestScores()`方法，并从`AddScoreScene.swift`文件中的`didMoveToView()`方法中调用相同的方法。以下是在`showHeighestScores()`方法中要添加的代码：
- en: '[PRE20]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now, it is time to add a back button, which will return the player to the main
    menu. Add the following code to implement the back button functionality:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加一个返回按钮了，它将玩家返回主菜单。将以下代码添加以实现返回按钮的功能：
- en: '[PRE21]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The preceding code has added the back button functionality; now we have to
    handle the touch/tap on the button in the `touchesBegan()` method of `AddScore.swift`,
    as we did earlier. Add the following code in the `touchesBegan()` method:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码已添加返回按钮功能；现在我们必须在`AddScore.swift`中的`touchesBegan()`方法中处理按钮的触摸/点击，就像我们之前做的那样。在`touchesBegan()`方法中添加以下代码：
- en: '[PRE22]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Following is how the high score board will look:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是高分榜将呈现的样子：
- en: '![Creating the high score board](img/4201_09_04.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![创建高分榜](img/4201_09_04.jpg)'
- en: Finally, the high score screen is also complete. This concludes the integration
    of a scoring system in our *Platformer* game.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，高分屏幕也完成了。这标志着我们在*平台游戏（Platformer）*中集成计分系统的完成。
- en: Adding sound into a game
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将声音添加到游戏中
- en: A game can only be complete with different music and sound effects. There can
    be background music in the game along with sound effects at each action, such
    as, when the user taps, we can play a sound, and later, we can play a sound when
    a player hits an obstacle or some other element in the main game. We can also
    have different music at different levels. Sound effects play a vital role in enhancing
    the overall gaming experience, as they indulge the user in a holistic gaming experience.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一款游戏只有配上不同的音乐和声音效果才能完整。游戏中可以有背景音乐，以及在每个动作中的声音效果，例如，当用户点击时，我们可以播放一个声音，稍后，当玩家击中障碍物或主游戏中的其他元素时，我们可以播放另一个声音。我们还可以在不同的关卡中使用不同的音乐。声音效果在增强整体游戏体验中起着至关重要的作用，因为它们让用户沉浸在全面的游戏体验中。
- en: Adding sounds into a Sprite Kit game
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将声音添加到Sprite Kit游戏中
- en: 'There are two ways to add sound effects in a Sprite Kit game:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在Sprite Kit游戏中添加声音效果有两种方式：
- en: Using `SKActions`
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`SKActions`
- en: Using the `AVFoundation` framework
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`AVFoundation`框架
- en: Adding sound effects using `SKActions` is not efficient, as compared to the
    `AVFoundation` framework. `SKActions` has a lot of limitations, such as that one
    cannot pause or play the sound in the middle of gameplay, and so on. Hence, it
    is advisable to use `AVFoundation`.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`AVFoundation`框架相比，使用`SKActions`添加声音效果效率不高。`SKActions`有很多限制，例如，在游戏过程中无法暂停或播放声音等。因此，建议使用`AVFoundation`。
- en: Adding sound into our Platformer game
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将声音添加到我们的平台游戏（Platformer）中
- en: Let's add sound effects in our *Platformer* game. We will be using the `AVFoundation`
    framework to add sounds.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在我们的*平台游戏（Platformer）*中添加声音效果。我们将使用`AVFoundation`框架来添加声音。
- en: Firstly, add the framework by clicking on your project, and then, under the
    **General** category, go to the **Linked frameworks and Libraries** section and
    add the `AVFoundation` framework.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过点击你的项目添加框架，然后，在**通用**类别下，转到**链接的框架和库**部分，并添加`AVFoundation`框架。
- en: 'Now, add the following code to import the `AVFoundation` framework into our
    `GameScene.swift` file:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码添加到将`AVFoundation`框架导入到我们的`GameScene.swift`文件中：
- en: '[PRE23]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Add the `AVAudioPlayerDelegate` delegate to use specified properties and methods
    of `AVAudioPlayer` in the `GameScene` class.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AVAudioPlayerDelegate`代理添加到`GameScene`类中，以使用`AVAudioPlayer`的特定属性和方法。
- en: 'Now, create an instance of `AVAudioPlayer` for our `GameScene` file:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为我们的`GameScene`文件创建一个`AVAudioPlayer`实例：
- en: '[PRE24]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'We are adding two sound files named `game_music.mp3` and `Strong_Punch-Mike_Koenig-574430706.wav`
    into our project (the WAV file format is suitable for short sounds, and MP3 format
    is suitable for longer durational sounds) and assign their names with two string
    variable as shown as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将两个声音文件`game_music.mp3`和`Strong_Punch-Mike_Koenig-574430706.wav`添加到我们的项目中（WAV文件格式适合短声音，而MP3格式适合较长时间的声音），并使用两个字符串变量指定它们的名称，如下所示：
- en: '[PRE25]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Add the following method of code to make `AVAudioPlayer` get the specified
    audio file and play the same:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码方法添加到使`AVAudioPlayer`获取指定的音频文件并播放相同的代码中：
- en: '[PRE26]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In the preceding code, we are passing the sound name and the file format as
    two parameters. The method will then play the sound file. If the user, while playing
    sound on the device, starts the game, this code will stop the earlier playing
    sound and then start the game sound.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们传递了声音名称和文件格式作为两个参数。然后该方法将播放声音文件。如果用户在设备上播放声音时开始游戏，此代码将停止之前播放的声音，然后开始游戏声音。
- en: 'As we want the background sound to be always running, we will call the `readFileIntoAVPlayer()`
    method and pass `backgroundSound` and `mp3` as parameters. Add the method in the
    beginning of the `didMoveToView()` method of `GameScene.swift`. Following is the
    line to be added:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们希望背景音乐始终播放，我们将调用 `readFileIntoAVPlayer()` 方法并传递 `backgroundSound` 和 `mp3`
    作为参数。在 `GameScene.swift` 的 `didMoveToView()` 方法开头添加此方法。以下是要添加的行：
- en: '[PRE27]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The preceding line will play the background sound as the game starts.
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 上述行将在游戏开始时播放背景音乐。
- en: 'We have also added another sound file for when the player dies. Now it is time
    to add the code that will play the sound effect when the player dies. Add the
    following lines of code in the beginning of the `didBeginContact()` method of
    `GameScene.swift`:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还为玩家死亡时添加了另一个声音文件。现在，是时候添加当玩家死亡时播放声音效果的代码了。在 `GameScene.swift` 的 `didBeginContact()`
    方法开头添加以下代码行：
- en: '[PRE28]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In the preceding code, we are stopping the background sound in the player and
    playing a new sound effect for the player's death by calling the same method as
    before, but with different parameters.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们通过调用与之前相同的方法但使用不同的参数来停止玩家中的背景音乐，并通过调用相同的方法为玩家的死亡播放新的声音效果。
- en: Animation frames using SKTexture
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 SKTexture 的动画帧
- en: So far, we have used static images in our game, but if you will see, most of
    the games have animated effects, such as player running effect, car running effect,
    or any other effect that enhances the gameplay and creates a much better experience
    for all.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们在游戏中使用了静态图像，但如果你看的话，大多数游戏都有动画效果，如玩家跑步效果、汽车跑步效果或任何其他增强游戏玩法并创造更好体验的效果。
- en: Adding the Run action texture to the player in the Platformer game
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在平台游戏玩家中添加运行动作纹理
- en: We had earlier added an image atlas of the name, `idle.atlas`, which contained
    similar images of the player standing position.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前添加了一个名为 `idle.atlas` 的图像图集，其中包含玩家站立位置的相似图像。
- en: Now, we are going to add running texture images for the player, which will make
    it look as though the player is running in the `GameScene`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将为玩家添加跑步纹理图像，这将使玩家看起来像在 `GameScene` 中跑步。
- en: Firstly, add a texture image set called `bro5_run.atlas`, which we have provided.
    The image atlas contains sets of seven images, which are sometimes also referred
    to as a sprite sheet. In our case, it will be known as the player running sprite
    sheet. These sets of images will be running one after the other at a fast rate
    of time inside texture atlas.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，添加一个名为 `bro5_run.atlas` 的纹理图像集，这是我们提供的。图像图集包含七组图像，有时也被称为精灵表。在我们的案例中，它将被称为玩家跑步精灵表。这些图像组将按照快速的时间速率在纹理图集中依次运行。
- en: 'Now, let''s assign the texture image for the player. Add the following line
    of code in the beginning of the `didMoveToView()` method:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们为玩家分配纹理图像。在 `didMoveToView()` 方法的开头添加以下代码行：
- en: '[PRE29]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the next step, we will add a method to create an `SKAction` for adding an
    animated texture for the different textures of `atlasForPlayerRun.atlas`. Add
    the following line of code by creating a `runForwardTexture()` method and call
    it from `didMoveToView()`. Make sure to do this after you have added the texture
    image for the player:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一步中，我们将添加一个方法来为 `atlasForPlayerRun.atlas` 的不同纹理创建一个 `SKAction`。通过创建一个 `runForwardTexture()`
    方法并在 `didMoveToView()` 中调用它来实现这一点。确保在添加玩家纹理图像后执行此操作：
- en: '[PRE30]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The preceding code will have successfully implemented the running animation
    for the player. The following screenshot shows how a sprite sheet looks:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码已成功实现了玩家的跑步动画。以下截图显示了精灵表的外观：
- en: '![Adding the Run action texture to the player in the Platformer game](img/4201_09_05.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![在平台游戏玩家中添加运行动作纹理](img/4201_09_05.jpg)'
- en: The texture atlas for a running animation of the player
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家跑步动画的纹理图集
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have covered some important aspects of the game, along with
    reading about performance improvements. Further, you can enhance the performance
    of your game using performance measuring instruments provided by Xcode. We also
    integrated the scoring system, sounds, and player running animation in our platformer
    game.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些游戏的重要方面，包括阅读关于性能改进的内容。此外，您可以使用Xcode提供的性能测量工具来提高您游戏的表现。我们还集成了得分系统、音效和玩家跑步动画到我们的平台游戏中。
- en: In the next and final chapter of this book, we will discuss each element of
    our *Platformer* game, take an in-depth look at the Game Center provided by Apple,
    and discuss the newest additions in iOS 9 brought to us by Apple.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的下一章和最后一章中，我们将讨论我们*平台游戏*的每个元素，深入探讨苹果提供的游戏中心，并讨论苹果带来的iOS 9的最新增补。
