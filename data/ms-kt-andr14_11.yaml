- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Runtime Permissions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时权限
- en: As we build our Android apps, there are some functionalities that require permissions
    to be granted for them to function properly. Due to privacy and data security
    policies, we as developers can not automatically grant permissions to the apps
    that we develop. We need to inform the users of the permissions that the apps
    need and why they need them.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们构建 Android 应用，有一些功能需要授予相应的权限才能正常工作。由于隐私和数据安全政策，我们作为开发者不能自动为我们开发的应用程序授予权限。我们需要通知用户应用程序需要的权限以及为什么需要它们。
- en: In this chapter, we will understand runtime permissions and how to request them
    in our app.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解运行时权限以及如何在我们的应用程序中请求它们。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要内容：
- en: Understanding runtime permissions
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解运行时权限
- en: Requesting permissions at runtime
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行时请求权限
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To follow the instructions in this chapter, you will need to have Android Studio
    Hedgehog or later ([https://developer.android.com/studio](https://developer.android.com/studio))
    downloaded.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要遵循本章的说明，您需要下载 Android Studio Hedgehog 或更高版本（[https://developer.android.com/studio](https://developer.android.com/studio)）。
- en: You can use the previous chapter’s code to follow the instructions in this chapter.
    You can find the code for this chapter at [https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine).
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用上一章的代码来遵循本章的说明。您可以在[https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine](https://github.com/PacktPublishing/Mastering-Kotlin-for-Android/tree/main/chapternine)找到本章的代码。
- en: Understanding runtime permissions
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解运行时权限
- en: '`requestPermissions()` and `checkSelfPermission()`. The user only needs to
    grant permission once during the lifetime of the app.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '`requestPermissions()` 和 `checkSelfPermission()`。用户在整个应用生命周期中只需要授予一次权限。'
- en: Some of the features that need permission to be granted to work are camera,
    location, microphone and storage. Before using them, ensure that a user has permission
    to use them. If the user has not granted permission, you must request it from
    them. If the user has denied the permission, you must show a dialog explaining
    why you need it and ask the user to grant it from the settings. If the user has
    granted permission, you can use the feature. Failing to do these checks often
    results in an app crashing or a feature not working. If your app targets Android
    6.0 and above, you must request these permissions at runtime, and the user must
    grant the permission for the app to work.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 需要授予权限才能工作的功能中，有些是相机、位置、麦克风和存储。在使用它们之前，请确保用户有权使用它们。如果用户尚未授予权限，您必须向他们请求。如果用户拒绝了权限，您必须显示一个对话框解释为什么需要它，并要求用户从设置中授权。如果用户已经授权了权限，您就可以使用该功能。未能进行这些检查通常会导致应用程序崩溃或功能无法正常工作。如果您的应用程序针对
    Android 6.0 及以上版本，您必须在运行时请求这些权限，并且用户必须授权才能使应用程序工作。
- en: 'The flow for requesting permissions is shown in the following chart:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请求权限的流程如下所示：
- en: '![Figure 9.1 – The runtime permissions flow](img/B19779_09_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 运行时权限流程](img/B19779_09_01.jpg)'
- en: Figure 9.1 – The runtime permissions flow
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 运行时权限流程
- en: 'As shown in the preceding diagram, this is the flow:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，这是流程：
- en: The initial step is to *declare* the permission in the manifest file. This is
    done by adding the permission to the manifest file.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 初始步骤是在清单文件中*声明*权限。这是通过将权限添加到清单文件来完成的。
- en: After adding the permission to the manifest file, we must *design the UX* for
    the feature that needs the permission to be granted.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将权限添加到清单文件后，我们必须*设计 UX*，以便需要授予权限的功能。
- en: The next step is *waiting for the user to use* the feature that needs permission
    to be granted. At this point, we check whether the user has granted permission.
    If the user has granted permission, we proceed to use the feature.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是*等待用户使用*需要授予权限的功能。在这个阶段，我们检查用户是否已经授予了权限。如果用户已经授予了权限，我们就继续使用该功能。
- en: If the user *has not granted permission*, we first check whether we need to
    *show a rationale* that explains why we need permission. If we need to show the
    rationale, we show it with explanations and then request permission from the user.
    If we do not need to show the rationale, we just request permission from the user.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户*尚未授予权限*，我们首先检查是否需要*显示一个理由*来解释为什么我们需要权限。如果需要显示理由，我们将用解释来展示它，然后请求用户授权。如果不需要显示理由，我们只需请求用户授权。
- en: Once the permission is requested, we wait for the *user to grant or deny* permission.
    If the user grants permission, we proceed to use the feature. If the user denies
    permission, we allow the app to work, but the user cannot use the feature that
    needs permission to work.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦请求了权限，我们等待 *用户授予或拒绝* 权限。如果用户授予了权限，我们继续使用该功能。如果用户拒绝了权限，我们允许应用工作，但用户无法使用需要权限才能工作的功能。
- en: With this flow in mind, let us look at how to implement it in code. We are going
    to request permission to access a location.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 带着这种流程在心中的想法，让我们看看如何在代码中实现它。我们将请求权限以访问位置。
- en: Requesting permissions at runtime
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时请求权限
- en: 'We will follow the steps covered in *Figure 9**.1* to request runtime permissions
    for our app:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将遵循 *图9**.1 中涵盖的步骤来请求我们应用的运行时权限：
- en: 'Let us start by adding the permission to the manifest file. We will request
    permission to access the user’s location. To do this, we add the following permission
    to the manifest file:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从将权限添加到清单文件开始。我们将请求访问用户位置的权限。为此，我们在清单文件中添加以下权限：
- en: '[PRE0]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This specifies that our app will be using the `ACCESS_COARSE_LOCATION` permission.
    Declaring permissions in the manifests is crucial for enhancing security, user
    awareness, and overall app compatibility. By explicitly specifying the actions
    or resources apps require access to permissions informs users during installations,
    allowing them to make informed decisions about granting or denying access. This
    declaration ensures compatibility across different Android versions and devices,
    facilitates inter-app communication, and supports intent filtering to control
    component access. Permissions also play a role in runtime permission requests
    for dangerous permissions and help maintain platform compatibility. Additionally,
    Play Store reviews declare permissions as part of the submission process, contributing
    to adherence to policies and guidelines. In essence, manifest-based permission
    declarations are fundamental for creating secure, transparent, and user-controlled
    environments in our apps.
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这指定了我们的应用将使用 `ACCESS_COARSE_LOCATION` 权限。在清单文件中声明权限对于增强安全性、用户意识和整体应用兼容性至关重要。通过明确指定应用需要访问的动作或资源，允许用户在安装期间了解情况，从而让他们做出明智的授予或拒绝访问的决定。这种声明确保了不同
    Android 版本和设备之间的兼容性，促进了应用间的通信，并支持意图过滤以控制组件访问。权限在运行时请求危险权限中也发挥作用，有助于保持平台兼容性。此外，Play
    商店审查将权限作为提交过程的一部分，有助于遵守政策和指南。本质上，基于清单的权限声明对于创建安全、透明和用户控制的环境至关重要。
- en: The next thing is to create the UX for the feature that needs permission. We
    will create a dialog to request permissions from the user. It will also have the
    logic that shows the rationale to the user if permission was previously denied.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，我们需要为需要权限的功能创建用户界面。我们将创建一个对话框来请求用户的权限。它还将包含逻辑，如果之前拒绝了权限，则会向用户展示理由。
- en: 'Let’s create a new file in the **view** package named **PermissionDialog.kt**
    and add the utility functions to the file:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 **view** 包中创建一个名为 **PermissionDialog.kt** 的新文件，并将实用函数添加到该文件中：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first function checks whether the permission has been granted using the
    `ContextCompat.checkSelfPermission()` function. The second function checks whether
    we need to show the rationale to the user. This is done using the `ActivityCompat.shouldShowRequestPermissionRationale()`
    function. This function returns `true` if the app has requested this permission
    previously and the user denied the request. If the user turned down the permission
    request in the past and chose the `false`.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个函数使用 `ContextCompat.checkSelfPermission()` 函数检查权限是否已被授予。第二个函数检查是否需要向用户展示理由。这是通过使用
    `ActivityCompat.shouldShowRequestPermissionRationale()` 函数来完成的。如果该应用之前请求过此权限并且用户拒绝了请求，则该函数返回
    `true`。如果用户之前拒绝了权限请求并选择了 `false`。
- en: Next, let us create a sealed class that will be used to represent the state
    of the permission request.
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个密封类，用于表示权限请求的状态。
- en: 'Create a new file named **PermissionAction.kt** in the **data** package, and
    add the following code to the file:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **data** 包中创建一个名为 **PermissionAction.kt** 的新文件，并将以下代码添加到该文件中：
- en: '[PRE2]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The class has two states, `PermissionGranted` and `PermissionDenied`. A user
    can either grant or deny permission.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该类有两个状态，`PermissionGranted` 和 `PermissionDenied`。用户可以授予或拒绝权限。
- en: 'Next, let us create the dialog that will be used to request permission from
    the user. Head back to the **PermissionDialog.kt** file and add the following
    code to the file:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个用于请求用户权限的对话框。回到 **PermissionDialog.kt** 文件，并向文件中添加以下代码：
- en: '[PRE3]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let’s break down the preceding code:'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 让我们分析前面的代码：
- en: We have created a composable, `PetsScreen` composable.
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们创建了一个可组合的 `PetsScreen` 可组合组件。
- en: 'Let’s head to the **PetsScreen.kt** file and modify it to the following:'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 让我们转到 **PetsScreen.kt** 文件，并将其修改如下：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We have only made a few changes to this file:'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只对此文件做了一些修改：
- en: First, we have added a **showContent** mutable state that is used to check whether
    we should show the content of the screen. We have also set the initial value of
    the state to **false**. We will use this state to show the content of the screen
    if the user grants permission. We also have the **context** variable used to get
    the screen’s context.
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个名为 **showContent** 的可变状态，用于检查我们是否应该显示屏幕的内容。我们还设置了状态的初始值为 **false**。如果用户授予权限，我们将使用此状态来显示屏幕的内容。我们还有一个
    **context** 变量，用于获取屏幕的上下文。
- en: We have also added the **PermissionDialog** composable to the **PetsScreen**
    composable. We have passed the context and the permission – in this case, the
    **ACCESS_COARSE_LOCATION** permission – to the composable. We have also passed
    a callback to the composable that is used to get the state of the permission request.
    If the user grants the permission, we set the **showContent** state to **true**
    and show a toast with the **Location permission granted** message. If the user
    denies the permission, we set the **showContent** state to **false**.
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还向 **PetsScreen** 可组合组件添加了 **PermissionDialog** 可组合组件。我们将上下文和权限（在这种情况下，为 **ACCESS_COARSE_LOCATION**
    权限）传递给可组合组件。我们还传递了一个回调给可组合组件，用于获取权限请求的状态。如果用户授予权限，我们将 **showContent** 状态设置为 **true**
    并显示一个包含 **位置权限已授予** 消息的吐司。如果用户拒绝权限，我们将 **showContent** 状态设置为 **false**。
- en: Lastly, we have added a check to see whether the **showContent** state is **true**.
    If the state is **true**, we show the content of the screen. If the state is **false**,
    we do not show the content of the screen.
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，我们添加了一个检查，以查看 **showContent** 状态是否为 **true**。如果状态为 **true**，我们显示屏幕的内容。如果状态为
    **false**，我们不显示屏幕的内容。
- en: 'Build and run the app. At first, we will see the permission dialog, as shown
    in the following screenshot:'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建并运行应用。一开始，我们将看到授权对话框，如下面的截图所示：
- en: "![Figure 9.2 – The permission dial\uFEFFog](img/B19779_09_02.jpg)"
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – 授权对话框](img/B19779_09_02.jpg)'
- en: Figure 9.2 – The permission dialog
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – 授权对话框
- en: Tap the **Don’t allow** option, which will show an empty white screen, since
    we don’t show any content when the user has not granted the app permission.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **不允许** 选项，将显示一个空白的白色屏幕，因为我们没有在用户未授予应用权限时显示任何内容。
- en: '![Figure 9.3 – The no permission screen](img/B19779_09_03.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3 – 无权限屏幕](img/B19779_09_03.jpg)'
- en: Figure 9.3 – The no permission screen
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3 – 无权限屏幕
- en: The next time we run the app, we will see the rationale dialog showing why the
    app needs permission.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 下次我们运行应用时，我们将看到显示应用为何需要权限的授权理由对话框。
- en: '![Figure 9.4 – The permission rationale](img/B19779_09_04.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.4 – 授权理由](img/B19779_09_04.jpg)'
- en: Figure 9.4 – The permission rationale
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.4 – 授权理由
- en: On this rationale dialog, we can either cancel the request or grant access.
    Tapping the **Grant Access** option should bring up the permission dialog shown
    in *Figure 9**.2*, and by tapping the **While using the app** option, we grant
    the app the location permission, and now, we should be able to see the list of
    cute cats once again. Running the app again does not show the dialogs, since we
    have already granted the app the location permission.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个授权理由对话框中，我们可以取消请求或授权访问。点击 **授权访问** 选项应显示如图 *9.2* 所示的授权对话框，并通过点击 **使用应用时**
    选项，我们授予应用位置权限，现在，我们应该能够再次看到可爱猫咪的列表。再次运行应用不会显示对话框，因为我们已经授予了应用位置权限。
- en: '![Figure 9.5 – Cute cats](img/B19779_09_05.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.5 – 可爱的猫咪](img/B19779_09_05.jpg)'
- en: Figure 9.5 – Cute cats
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.5 – 可爱的猫咪
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored what runtime permissions are and why we should
    declare and request permissions in our apps. Step by step, we learned how to request
    runtime permissions in our app and how to show permission rationale dialogs, explaining
    to users why we need access to runtime permissions in cases where they have denied
    apps access to permissions.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了运行时权限是什么以及为什么我们应该在我们的应用中声明和请求权限。一步一步地，我们学习了如何在我们的应用中请求运行时权限以及如何显示权限理由对话框，向用户解释为什么在用户拒绝应用访问权限的情况下，我们需要访问运行时权限。
- en: In the next chapter, we will learn debugging tips and tricks, how to detect
    leaks using LeakCanary, how to inspect HTTPS requests/responses fired by our app
    using Chucker, and how to inspect the Room database.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习调试技巧和窍门，如何使用LeakCanary检测泄漏，如何使用Chucker检查我们应用发出的HTTPS请求/响应，以及如何检查Room数据库。
