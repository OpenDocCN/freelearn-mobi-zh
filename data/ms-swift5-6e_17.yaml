- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Custom Value Types
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义值类型
- en: In most traditional object-oriented programming languages, we create classes
    (which are reference types) as blueprints for our objects. In Swift, unlike other
    object-oriented languages, structures have much of the same functionality as classes,
    however, they are value types. Apple has said that we should prefer value types,
    such as structures, to reference types, but what are the differences between a
    reference type and a value type?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数传统的面向对象编程语言中，我们创建类（引用类型）作为我们对象的蓝图。在 Swift 中，与其它面向对象语言不同，结构体具有与类相似的大部分功能，然而，它们是值类型。苹果公司表示，我们应该优先选择值类型，如结构体，而不是引用类型，但引用类型和值类型之间有什么区别呢？
- en: 'In this chapter, you will explore the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将探索以下主题：
- en: The differences between value types and reference types
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值类型和引用类型之间的区别
- en: Why recursive data types cannot be created as a value type
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么递归数据类型不能作为值类型创建
- en: How to implement copy-on-write in your custom type
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何在你的自定义类型中实现写时复制
- en: How to conform to the `Equatable` protocol
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何遵守 `Equatable` 协议
- en: As we saw in *Chapter 8*, *Classes, Structures, and Protocols*, we have the
    ability to create our custom types as either a reference type (or class) or a
    value type (or structure). Let's review the differences between these two types
    because it is important to understand these differences when determining what
    type to use for our custom types.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在第 8 章 *类、结构体和协议* 中所看到的，我们有能力将我们的自定义类型创建为引用类型（或类）或值类型（或结构体）。让我们回顾一下这两种类型之间的区别，因为在确定我们自定义类型使用哪种类型时，理解这些区别非常重要。
- en: Value types and reference types
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 值类型和引用类型
- en: Structures are value types; when we pass instances of a structure in our application,
    we pass a copy of the structure and not the original structure. Classes are reference
    types; therefore, when we pass an instance of a class within our application,
    a reference to the original instance is passed. It is very important to understand
    this difference. We will discuss a very high-level view here but will provide
    additional details in *Chapter 18*, *Memory Management*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体是值类型；当我们在我们应用程序中传递结构体的实例时，我们传递的是结构体的副本，而不是原始结构体。类是引用类型；因此，当我们在我们应用程序中传递类的实例时，传递的是原始实例的引用。理解这种区别非常重要。我们在这里将提供一个非常高级的概述，但在第
    18 章 *内存管理* 中将提供更多详细信息。
- en: When we pass structures within our application, we are passing copies of the
    structures and not the original structures. This means that the function gets
    its own copy of the structure, which it can change as needed without affecting
    the original instance of the structure.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中传递结构体时，我们传递的是结构体的副本，而不是原始结构体。这意味着函数会得到结构体自己的副本，它可以按需更改，而不会影响结构体的原始实例。
- en: When we pass an instance of a class within our application, we are passing a
    reference to the original instance of the class, therefore, any changes made to
    the instance of the class will persist.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在应用程序中传递类的实例时，我们传递的是类的原始实例的引用，因此，对类的实例所做的任何更改都会持续存在。
- en: 'To illustrate the difference between value types and reference types, let''s
    examine a real-world object: a book. If we have a friend who wants to read *Mastering
    Swift 5.3, Sixth Edition*, we could either buy them their own copy or share ours.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明值类型和引用类型之间的区别，让我们考察一个现实世界的对象：一本书。如果我们有一个朋友想阅读 *Mastering Swift 5.3, Sixth
    Edition*，我们可以为他们购买自己的副本，或者分享我们的。
- en: If we bought our friend their own copy of the book, then any notes they made
    in the book would remain in their copy of the book and would not be reflected
    in our copy. This is how passing by value works with structures and variables.
    Any changes that are made to the structure or variable within the function are
    not reflected back to the original instance of the structure or variable.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们为我们朋友购买了他们自己的书，那么他们在书中做的任何笔记都会保留在他们自己的书中，而不会反映在我们的书中。这就是结构体和变量按值传递的工作方式。在函数内部对结构体或变量所做的任何更改都不会反映到结构体或变量的原始实例上。
- en: If we share our copy of the book, then any notes that were made in the book
    will stay in the book when it is returned to us. This is how passing by reference
    works. Any changes that are made to the instance of the class remain when the
    function exits.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们分享我们的书，那么当书归还给我们时，书中所做的任何笔记都会保留在书中。这就是按引用传递的工作方式。对类的实例所做的任何更改在函数退出时都会保留。
- en: When we pass an instance of a value type, we are actually passing a copy of
    the instance. You may be wondering about the performance of large value types
    when they are passed from one part of our code to another. For structures that
    have the possibility of becoming very large, we can use copy-on-write.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们传递一个值类型的实例时，我们实际上是在传递该实例的一个副本。你可能想知道当大值类型从一个代码部分传递到另一个代码部分时，其性能如何。对于可能变得非常大的结构，我们可以使用写时复制（copy-on-write）。
- en: The explanation in the previous paragraphs is pretty straightforward; however,
    it is a very important concept that we must understand. In this section, we are
    going to examine the differences between value types and reference types so that
    we know when to use each type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 前一段落的解释相当直接；然而，这是一个我们必须理解的重要概念。在本节中，我们将检查值类型和引用类型之间的差异，以便我们知道何时使用每种类型。
- en: 'Let''s begin by creating two types; one is going to be a structure (or value
    type) and the other is going to be a class (or reference type). We will be using
    these types in this section to demonstrate the differences between value types
    and reference types. The first type that we will examine is named `MyValueType`.
    We will implement `MyValueType` using a structure, which means that it is a value
    type, as its name suggests:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建两个类型开始；一个是结构（或值类型），另一个是类（或引用类型）。我们将在这部分使用这些类型来演示值类型和引用类型之间的差异。我们将要检查的第一个类型名为`MyValueType`。我们将使用结构来实现`MyValueType`，这意味着它是一个值类型，正如其名称所暗示的：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `MyValueType`, we define three properties. Two of the properties are of
    the `String` type (`name` and `assignment`) and one is of the `Integer` type (`grade`).
    Now, let''s take a look at how we can implement this as a class:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MyValueType`中，我们定义了三个属性。其中两个属性是`String`类型（`name`和`assignment`），另一个是`Integer`类型（`grade`）。现在，让我们看看我们如何将这个实现为一个类：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `MyReferenceType` type defines the same three properties as in the `MyValueType`
    type, however, we need to define an initializer in the `MyReferenceType` type
    that we did not need to define in the `MyValueType` type. The reason for this
    is that structures provide us with a default initializer that will initialize
    all the properties that need to be initialized if we do not provide a default
    initializer.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`MyReferenceType`类型定义了与`MyValueType`类型相同的三个属性，然而，我们需要在`MyReferenceType`类型中定义一个初始化器，而在`MyValueType`类型中我们不需要定义。这是因为结构为我们提供了一个默认初始化器，如果未提供默认初始化器，它将初始化所有需要初始化的属性。'
- en: 'Let''s take a look at how we can use each of these types. The following code
    shows how we can create instances of each of these types:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何使用这些类型。以下代码显示了如何创建这些类型的实例：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'As you can see in this code, instances of structures are created in exactly
    the same way as the instances of classes. Being able to use the same format to
    create instances of structures and classes is good because it makes our lives
    easier; however, we do need to bear in mind that value types behave in a different
    manner to reference types. Let''s explore this; the first thing we need to do
    is create two functions that will change the grades for the instances of the two
    types:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 如此代码所示，结构的实例与类的实例的创建方式完全相同。能够使用相同的格式来创建结构和类的实例是有好处的，因为它使我们的生活更简单；然而，我们确实需要记住，值类型的操作方式与引用类型不同。让我们来探讨这个问题；我们需要做的第一件事是创建两个函数，这两个函数将改变两种类型实例的成绩：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Each of these functions takes an instance of one of our types and an extra credit
    amount. Within the function, we will add the extra credit amount to the grade.
    If we try to use this code we will receive an error in the `extraCreditValueType()`
    function telling us that the left side of the mutable operation is not mutable.
    The reason for this is that a value type parameter, by default, is immutable because
    the function is receiving an immutable copy of the parameter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数中的每一个都接受我们类型的一个实例和一个额外的学分。在函数内部，我们将额外的学分添加到成绩中。如果我们尝试使用此代码，我们将在`extraCreditValueType()`函数中收到一个错误，告诉我们可变操作的左侧不可变。这是因为值类型参数默认是不可变的，因为函数接收的是参数的不可变副本。
- en: Using a value type like this protects us from making accidental changes to the
    instances; this is because the instances are scoped to the function or type in
    which they are created. Value types also protect us from having multiple references
    to the same instance. Therefore, they are, by default, thread (concurrency) safe
    because each thread will have its own version of the value type. If we absolutely
    need to change an instance of a value type outside of its scope, we could use
    an `inout` parameter.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这样的值类型可以保护我们免受意外更改实例的影响；这是因为实例的范围限定在创建它们的函数或类型中。值类型还可以保护我们免受对同一实例的多个引用。因此，它们默认是线程（并发）安全的，因为每个线程都将有自己的值类型版本。如果我们绝对需要在范围之外更改值类型的实例，我们可以使用一个`inout`参数。
- en: We define an `inout` parameter by placing the `inout` keyword at the start of
    the parameter's definition. An `inout` parameter has a value that is passed into
    the function. This value is then modified by the function and is passed back out
    of the function to replace the original value.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过在参数定义的开始处放置`inout`关键字来定义一个`inout`参数。一个`inout`参数有一个值被传递到函数中。然后这个值被函数修改，并从函数中传回以替换原始值。
- en: Let's explore how we can use an `inout` parameter. We will begin by creating
    a function that is designed to retrieve the grade for an assignment from a data
    store. However, to simplify our example, we will simply generate a random score.
    The following code demonstrates how we can write this function.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索如何使用`inout`参数。我们将首先创建一个函数，该函数旨在从一个数据存储中检索一个作业的成绩。然而，为了简化示例，我们将简单地生成一个随机分数。以下代码演示了我们可以如何编写这个函数。
- en: 'Let''s take a look at how we can use value types with the `inout` keyword to
    create a version of the previous example that will work correctly. The first thing
    we need to do is modify the `getGradesForAssignment()` function to use an instance
    of `MyValueType` that it can modify:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用带有`inout`关键字的值类型来创建一个正确工作的前一个示例版本。我们需要做的第一件事是修改`getGradesForAssignment()`函数，使其能够使用它可以修改的`MyValueType`实例：
- en: '[PRE4]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This function is designed to retrieve the grade for the assignment that is
    defined in the `MyValueType` instance and is then passed into the function. Once
    the grade is retrieved, we will use it to set the grade property of the `MyValueType`
    instance. We will also print the grade out to the console so that we can see what
    grade it is. Now let''s explore how to use this function:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数旨在检索在`MyValueType`实例中定义的作业成绩，并将其传递到函数中。一旦检索到成绩，我们将使用它来设置`MyValueType`实例的grade属性。我们还将打印成绩到控制台，以便我们可以看到它是多少。现在让我们探索如何使用此函数：
- en: '[PRE5]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the previous code, we created a `mathGrades` array that will store the grades
    for our assignment and a `students` array that will contain the names of the students
    that we wish to retrieve the grades for. We then created an instance of the `MyValueType`
    structure that contains the name for the assignment. We will use this instance
    to request the grades from the `getGradeForAssignment()` function. Notice that
    when we pass in the `mathAssignment` instance, we prefix the name of the instance
    with the `&` symbol. This lets us know that we are passing the reference to the
    original instance and not a copy. Now that everything is defined, we will loop
    through the list of students to retrieve the grades. The output of this code will
    look similar to the following snippet:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们创建了一个`mathGrades`数组，用于存储我们的作业成绩，以及一个`students`数组，包含我们希望检索成绩的学生姓名。然后我们创建了一个包含作业名称的`MyValueType`结构实例。我们将使用此实例从`getGradeForAssignment()`函数请求成绩。注意，当我们传递`mathAssignment`实例时，我们在实例名称前加上了`&`符号。这让我们知道我们传递的是原始实例的引用，而不是副本。现在一切都已经定义好了，我们将遍历学生列表以检索成绩。此代码的输出将类似于以下片段：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The output from this code is what we expected to see, where each instance in
    the `mathGrades` array represents the correct grade. The reason this code works
    correctly is that we are passing a reference from the `mathAssignment` instance
    to the `getGradeForAssignment()` function, and not a copy.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码的输出是我们预期的结果，其中`mathGrades`数组中的每个实例都代表正确的成绩。此代码正确工作的原因是我们在从`mathAssignment`实例传递到`getGradeForAssignment()`函数时传递了一个引用，而不是一个副本。
- en: There are some things we cannot do with value types that we can do with reference
    (or class) types. The first thing that we will look at is the recursive data type.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 有些事情我们不能用值类型做，但可以用引用（或类）类型做。我们将首先查看递归数据类型。
- en: Recursive data types for reference types
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用于引用类型的递归数据类型
- en: A recursive data type is a type that contains values of the same type as a property
    for the type. Recursive data types are used when we want to define dynamic data
    structures, such as lists and trees. The size of these dynamic data structures
    can grow or shrink depending on our runtime requirements.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 递归数据类型是一种包含与类型相同的值的类型的类型的类型。当我们想要定义动态数据结构，如列表和树时，会使用递归数据类型。这些动态数据结构的大小可以根据我们的运行时需求增长或缩小。
- en: 'Linked lists are perfect examples of a dynamic data structure that we can implement
    using a recursive data type. A linked list is a group of nodes that are linked
    together and where, in its simplest form, each node maintains a link to the next
    node in the list. *Figure 17.1* shows how a very basic linked list works:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 链表是我们可以使用递归数据类型实现的动态数据结构的完美示例。链表是一组相互链接的节点，在其最简单的形式中，每个节点都维护对列表中下一个节点的链接。*图17.1*展示了一个非常基本的链表是如何工作的：
- en: '![A screenshot of a cell phone  Description automatically generated](img/B16683_17_01.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![手机屏幕截图  描述自动生成](img/B16683_17_01.png)'
- en: 'Figure 17.1: A basic linked list'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：基本链表
- en: Each node in the list contains a value or data, and it also contains the link
    to the next node in the list. If one of the nodes in the list loses the reference
    to the next node, then the remainder of the list will be lost because each node
    is only aware of the next node. Some linked lists maintain a link to both the
    previous nodes and the following nodes to allow us to move both forward and backward
    through the list.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的每个节点都包含一个值或数据，同时也包含指向列表中下一个节点的链接。如果列表中的某个节点失去了对下一个节点的引用，那么列表的其余部分将会丢失，因为每个节点只知道下一个节点。一些链表维护对前一个节点和后一个节点的链接，这样我们就可以在列表中前后移动。
- en: 'The following code shows how we can create a linked list using a reference
    type:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了我们如何使用引用类型创建链表：
- en: '[PRE7]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `LinkedListReferenceType` class, we have two properties. The first property
    is named `value` and it contains the data for this instance. The second property
    is named `next`, which points to the next item in the linked list. If the `next`
    property is `nil`, then this instance will be the last node in the list. If we
    try to implement this linked list as a value type, the code will be similar to
    the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在`LinkedListReferenceType`类中，我们有两个属性。第一个属性名为`value`，它包含此实例的数据。第二个属性名为`next`，它指向链表中的下一个项目。如果`next`属性为`nil`，则此实例将是列表中的最后一个节点。如果我们尝试将此链表实现为值类型，代码将类似于以下内容：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we add this code to a playground, we receive the following error: `Recursive`
    `value type LinkedListValueType is not allowed`. This tells us that Swift does
    not allow recursive value types. However, we can implement them as a reference
    type, which we discussed earlier.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将此代码添加到游乐场时，我们收到以下错误：`Recursive` `value type LinkedListValueType is not allowed`。这告诉我们Swift不允许递归值类型。然而，我们可以将它们实现为引用类型，这是我们之前讨论过的。
- en: If you think about it, recursive value types are a really bad idea because of
    how value types function. Let's examine this for a minute, because it will really
    stress the difference between value types and reference types. It will also help
    you to understand *why* we need reference types.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细想想，递归值类型因为值类型的功能而是一个非常糟糕的想法。让我们花点时间来探讨这一点，因为这会真正强调值类型和引用类型之间的差异。这也有助于你理解*为什么*我们需要引用类型。
- en: 'Let''s say that we are able to create the `LinkedListValueType` structure without
    any errors. Now let''s create three nodes for our list, as shown in the following
    code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们能够无错误地创建`LinkedListValueType`结构。现在让我们为我们的列表创建三个节点，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now we will link these nodes together using the following code:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用以下代码将这些节点链接在一起：
- en: '[PRE10]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Do you see the problem with this code? If not, think about how a value type
    is passed. In the first line, `one.next = two`, we are not actually setting the
    `next` property to the original `two` instance; in fact, we are actually setting
    it to a copy of the `two` instance, because by implementing the `LinkedListValueType`
    as a value type, we are passing the value and not the actual instance. This means
    that in the next line, `two.next = three`, we are setting the next property of
    the original `two` instance to the `three` instance.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你看到这个问题了吗？如果没有，想想值类型是如何传递的。在第一行`one.next = two`中，我们实际上并没有将`next`属性设置为原始的`two`实例；实际上，我们将其设置为`two`实例的一个副本，因为我们通过将`LinkedListValueType`实现为值类型，我们传递的是值而不是实际的实例。这意味着在下一行`two.next
    = three`中，我们将原始的`two`实例的下一个属性设置为`three`实例。
- en: 'However, this change is not reflected back in the copy that was made for the
    next property of the `one` instance. Sounds a little confusing? Let''s clear it
    up a little by looking at a diagram that shows the state of our three `LinkedListValueType`
    instances if we were able to run this code:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这种变化并没有反映到为`one`实例的下一个属性所制作的副本中。听起来有点令人困惑？让我们通过查看一个图表来稍微澄清一下，如果能够运行这段代码，图表将显示我们三个`LinkedListValueType`实例的状态：
- en: '![Diagram  Description automatically generated](img/B16683_17_02.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.2：链表结构示例](img/B16683_17_02.png)'
- en: 'Figure 17.2: A linked list structure example'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.2：链表结构示例
- en: As you can see from the diagram, the next property of the `one` instance is
    pointing to a copy of the `two` instance whose next property is still `nil`. The
    next property of the original `two` instance, however, is pointing to the `three`
    instance. This means that, if we try to go through the list by starting at the
    `one` instance, we will not reach the `three` instance because the copy of the
    `two` instance will still have a `next` property that is `nil`.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如从图中所示，`one`实例的下一个属性指向一个`two`实例的副本，其下一个属性仍然是`nil`。然而，原始的`two`实例的下一个属性指向`three`实例。这意味着，如果我们从`one`实例开始遍历列表，我们将无法到达`three`实例，因为`two`实例的副本仍然有一个`next`属性是`nil`。
- en: Another thing that we can only do with reference (or class) types is class inheritance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只能使用引用（或类）类型做的另一件事是类继承。
- en: Inheritance for reference types
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型的继承
- en: In object-oriented programming, inheritance refers to one class (known as a
    **sub** or **child** **class**) being derived from another class (known as a **super**
    or **parent** **class**). The subclass will inherit methods, properties, and other
    characteristics from the superclass. With inheritance, we can also create a class
    hierarchy where we can have multiple layers of inheritance.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程中，继承指的是一个类（称为**子**或**子类**）从另一个类（称为**超**或**父类**）派生而来。子类将继承方法、属性和其他特征。通过继承，我们还可以创建一个类层次结构，其中可以有多个继承层。
- en: 'Let''s take a look at how we can create a class hierarchy with classes in Swift.
    We will start off by creating a base class named `Animal`:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用Swift中的类来创建一个类层次结构。我们将从创建一个名为`Animal`的基本类开始：
- en: '[PRE11]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the `Animal` class, we defined one property (`numberOfLegs`) and three methods
    (`sleeps()`, `walking()`, and `speaking()`). Now, any class that is a subclass
    of the `Animal` class will also have these properties and methods. Let''s examine
    how this works by creating two classes that are subclasses of the `Animal` class.
    These two classes will be named `Biped` (an animal with two legs) and `Quadruped`
    (an animal with four legs):'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Animal`类中，我们定义了一个属性（`numberOfLegs`）和三个方法（`sleeps()`、`walking()`和`speaking()`）。现在，任何是`Animal`类子类的类也将拥有这些属性和方法。让我们通过创建两个是`Animal`类子类的类来检查这是如何工作的。这两个类将被命名为`Biped`（两足动物）和`Quadruped`（四足动物）：
- en: '[PRE12]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Since these two classes inherit all the properties and methods from the `Animal`
    class, all we need to do is create an initializer that sets the `numberOfLegs`
    property to the correct number of legs. Now, let''s add another layer of inheritance
    by creating a `Dog` class that will be a subclass of the `Quadruped` class:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这两个类继承自`Animal`类中的所有属性和方法，我们只需要创建一个初始化器，将`numberOfLegs`属性设置为正确的腿数。现在，让我们通过创建一个`Dog`类来添加另一层继承，这个类将是`Quadruped`类的子类：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In the `Dog` class, we inherit from the `Quadruped` class, which, in turn, inherits
    from the `Animal` class. Therefore, the `Dog` class will have all the properties,
    methods, and characteristics of both the `Animal` and `Quadruped` classes. If
    the `Quadruped` class overrides anything from the `Animal` class, then the `Dog`
    class will inherit the version from the `Quadruped` class.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Dog`类中，我们继承自`Quadruped`类，而`Quadruped`类又继承自`Animal`类。因此，`Dog`类将具有`Animal`和`Quadruped`类中所有属性、方法和特征。如果`Quadruped`类覆盖了`Animal`类中的任何内容，那么`Dog`类将继承来自`Quadruped`类的版本。
- en: 'We can create very complex class hierarchies in this manner; for example, *Figure
    17.3* expands on the class hierarchy that we just created to add several other
    animal classes:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用这种方式创建非常复杂的类层次结构；例如，*图17.3*扩展了我们刚刚创建的类层次结构，添加了几个其他动物类：
- en: '![A close up of a piece of paper  Description automatically generated](img/B16683_17_03.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![一张纸的特写  自动生成的描述](img/B16683_17_03.png)'
- en: 'Figure 17.3: Animal class hierarchy'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：动物类层次结构
- en: Class hierarchies can get very complex. However, as you just saw, they can eliminate
    a lot of duplicate code because our subclasses inherit methods, properties, and
    other characteristics from their superclasses. Therefore, we do not need to recreate
    them in all of the subclasses.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构可能会变得非常复杂。然而，正如你所看到的，它们可以消除大量的重复代码，因为我们的子类从它们的超类中继承了方法、属性和其他特征。因此，我们不需要在所有子类中重新创建它们。
- en: The biggest drawback of a class hierarchy is the complexity. When we have a
    complex hierarchy (as shown in the preceding diagram), it is easy to make a change
    and not realize how it is going to affect all of the subclasses. If you consider
    the `Dog` and `Cat` classes, for example, we may want to add a `furColor` property
    to our `Quadruped` class so that we can set the color of the animal's fur. However,
    horses do not have fur; they have hair. So, before we can make any changes to
    a class in our hierarchy, we need to understand how it will affect all the subclasses
    in the hierarchy.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 类层次结构的一个主要缺点是复杂性。当我们有一个复杂的层次结构（如前图所示）时，很容易做出改变而不知道它将如何影响所有子类。例如，如果我们考虑`Dog`和`Cat`类，我们可能想在`Quadruped`类中添加一个`furColor`属性，以便我们可以设置动物的毛色。然而，马没有毛，它们有鬃毛。因此，在我们对层次结构中的任何类做出任何更改之前，我们需要了解它将如何影响层次结构中的所有子类。
- en: In Swift, it is best to avoid using complex class hierarchies (as shown in this
    example), and instead use a protocol-oriented design, unless, of course, there
    are specific reasons to use them. Now that we have a good understanding of reference
    and value types, let's explore dynamic dispatch.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 在Swift中，最好避免使用复杂的类层次结构（如本例所示），而应使用面向协议的设计，除非当然有特定的理由使用它们。现在我们已经很好地理解了引用类型和值类型，让我们来探索动态分派。
- en: Dynamic dispatch
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态分派
- en: In the previous section, we learned how to use inheritance with classes in order
    to inherit and override the functionality defined in a superclass. You may be
    wondering how and when the appropriate implementation is chosen. The process of
    choosing which implementation to call is performed at runtime and is known as
    **dynamic dispatch**.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们学习了如何使用类继承来继承和覆盖超类中定义的功能。你可能想知道何时以及如何选择合适的实现。选择调用哪个实现的过程是在运行时进行的，这被称为**动态分派**。
- en: One of the key points to understand from the last paragraph is that the implementation
    is chosen at runtime. What this means is that a certain amount of runtime overhead
    is associated with using class inheritance, as shown in the *Inheritance for reference
    types* section. For most applications, this overhead is not a concern; however,
    for performance-sensitive applications such as games, this overhead can be costly.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 从上一段中理解的一个关键点是，实现的选择是在运行时进行的。这意味着使用类继承会带来一定量的运行时开销，正如在*引用类型继承*部分所示。对于大多数应用程序来说，这个开销不是问题；然而，对于性能敏感的应用程序，如游戏，这个开销可能是昂贵的。
- en: One of the ways that we can reduce the overhead associated with dynamic dispatch
    is to use the `final` keyword. The `final` keyword puts a restriction on the class,
    method, or function to indicate that it cannot be overridden, in the case of a
    method or function, or subclasses, in the case of a class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以减少与动态分派相关的开销的一种方法是在类、方法或函数上使用`final`关键字。`final`关键字对类、方法或函数施加限制，表明它不能被覆盖，在方法或函数的情况下，或者在类的情况下，子类。
- en: 'To use the `final` keyword, you put it prior to the class, method, or function
    declaration, as shown in the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用`final`关键字，您将其放在类、方法或函数声明之前，如下面的代码所示：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'In the *Inheritance for reference types* section, we defined a `class` hierarchy
    that started with the `Animal` superclass. If we want to restrict subclasses from
    overriding the `walking()` method and the `numberOfLegs` property, we can change
    the `Animal` implementation, as shown in the next example:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在*引用类型的继承*部分，我们定义了一个以`Animal`超类开始的`class`层次结构。如果我们想限制子类覆盖`walking()`方法和`numberOfLegs`属性，我们可以修改`Animal`的实现，如下一个示例所示：
- en: '[PRE15]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This change allows the application, at runtime, to make a direct call to the
    `walking()` method rather than an indirect call that gives the application a slight
    performance increase. If you must use a class hierarchy, it is good practice to
    use the `final` keyword wherever possible; however, it is better to use a protocol-oriented
    design, with value types, to avoid this.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这个更改允许应用程序在运行时直接调用`walking()`方法，而不是间接调用，这会给应用程序带来轻微的性能提升。如果您必须使用类层次结构，尽可能使用`final`关键字是一种好的做法；然而，使用以协议为导向的设计，结合值类型，以避免这种情况会更好。
- en: 'Now, let''s take a look at something that can help with the performance of
    our custom value types: copy-on-write.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看可以帮助我们自定义值类型性能的东西：写时复制。
- en: Copy-on-write
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 写时复制
- en: Normally, when we pass an instance of a value type, such as a structure, a new
    copy of the instance is created. This means that if we have a large data structure
    that contains 100,000 elements, then every time we pass that instance, we will
    have to copy all 100,000 elements. This can have a detrimental impact on the performance
    of our applications, especially if we pass the instance to numerous functions.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当我们传递一个值类型的实例，例如一个结构体时，会创建该实例的新副本。这意味着如果我们有一个包含100,000个元素的大的数据结构，那么每次我们传递该实例时，我们都必须复制所有100,000个元素。这可能会对我们的应用程序的性能产生不利影响，尤其是如果我们将实例传递给许多函数时。
- en: To solve this issue, Apple has implemented the copy-on-write feature for all
    the data structures (such as `Array`, `Dictionary`, and `Set`) in the Swift standard
    library. With copy-on-write, Swift does not make a second copy of the data structure
    until a change is made to that data structure. Therefore, if we pass an array
    of 50,000 elements to another part of our code, and that code does not make any
    changes to the array, we will avoid the runtime overhead of copying all the elements.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，Apple在Swift标准库中为所有数据结构（如`Array`、`Dictionary`和`Set`）实现了写时复制功能。使用写时复制，Swift不会在修改数据结构之前再次复制该数据结构。因此，如果我们将包含50,000个元素的数组传递到代码的另一个部分，并且该代码不对数组进行任何修改，我们将避免复制所有元素的运行时开销。
- en: This is a very useful feature and can greatly increase the performance of our
    applications. However, our custom value types do not automatically get this feature
    by default. In this section, we will explore how we can use reference types and
    value types together to implement the copy-on-write feature for our custom value
    types. To do this, we will create a very basic queue type that will demonstrate
    how you can add copy-on-write functionality to your custom value types.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常有用的功能，可以大大提高我们应用程序的性能。然而，我们的自定义值类型默认情况下并不会自动获得这个功能。在本节中，我们将探讨如何使用引用类型和值类型一起实现我们自定义值类型的写时复制功能。为此，我们将创建一个非常基本的队列类型，以展示您如何将写时复制功能添加到您的自定义值类型中。
- en: 'We will start off by creating a backend storage type called `BackendQueue`
    and will implement it as a reference type. The following code gives our `BackendQueue`
    type the basic functionality of a queue type:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个名为`BackendQueue`的后端存储类型，并将其实现为一个引用类型。以下代码为我们的`BackendQueue`类型提供了队列类型的基本功能：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The `BackendQueue` type is a generic type that uses an array to store the data.
    This type contains three methods, which enables us to add items to the queue,
    retrieve an item from the queue, and return the number of items in the queue.
    We use the `fileprivate` access level to prevent the use of this type outside
    of the defining source file, because it should only be used to implement the copy-on-write
    feature for our main queue type.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`BackendQueue`类型是一个泛型类型，它使用数组来存储数据。此类型包含三个方法，使我们能够向队列中添加项目、从队列中检索项目以及返回队列中的项目数量。我们使用`fileprivate`访问级别来防止在定义源文件之外使用此类型，因为它应该只用于实现我们主要队列类型的写时复制功能。'
- en: 'We now need to add a couple of extra items to the `BackendQueue` type so that
    we can use it to implement the copy-on-write feature for the main queue type.
    The first thing that we will add is a public default initializer and a private
    initializer that can be used to create a new instance of the `BackendQueue` type;
    the following code shows the two initializers:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在需要向 `BackendQueue` 类型添加一些额外的项目，以便我们可以使用它来实现主队列类型的写时复制特性。我们将添加的第一件事是公共默认初始化器和私有初始化器，后者可以用来创建
    `BackendQueue` 类型的新的实例；以下代码展示了这两个初始化器：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The public initializer will be used to create an instance of the `BackendQueue`
    type without any items in the queue. The private initializer will be used internally
    to create a copy of itself that contains any items that are currently in the queue.
    Now we will need to create a method that will use the private initializer to create
    a copy of itself when required:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 公共初始化器将用于创建一个不包含任何项目的 `BackendQueue` 类型实例。私有初始化器将用于内部创建一个包含当前队列中任何项目的自身副本。现在我们需要创建一个方法，当需要时将使用私有初始化器来创建自身的副本：
- en: '[PRE18]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It could be very easy to make the private initializer public and then let the
    main queue type call that initializer to create the copy; however, it is good
    practice to keep the logic needed to create the new copy within the type itself.
    The reason why you should do this is that if you need to make changes to the type,
    that may affect how the type is copied. Instead, the logic that you need to change
    the type is embedded within the type itself and is easy to find. Additionally,
    if you use the `BackendQueue` type as the backend storage for multiple types,
    you will only need to make the changes to the copy logic in one place if it changes.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易将私有初始化器公开，然后让主队列类型调用该初始化器来创建副本；然而，将创建新副本所需的逻辑保持在类型本身中是一种良好的实践。这样做的原因是，如果您需要更改类型，可能会影响类型的复制方式。相反，您需要更改类型的逻辑被嵌入在类型本身中，并且易于查找。此外，如果您将
    `BackendQueue` 类型用作多个类型的后端存储，那么如果需要更改，您只需在一个地方更改复制逻辑即可。
- en: 'Here is the final code for the `BackendQueue` type:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 `BackendQueue` 类型的最终代码：
- en: '[PRE19]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now let''s create our `Queue` type, which will use the `BackendQueue` type
    to implement the copy-on-write feature. The following code adds the basic queue
    functionality to our `Queue` type:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建我们的 `Queue` 类型，它将使用 `BackendQueue` 类型来实现写时复制的特性。以下代码为我们的 `Queue` 类型添加了基本队列功能：
- en: '[PRE20]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `Queue` type is implemented as a value type. This type has one private property
    of the `BackendQueue` type, which will be used to store the data. This type contains
    three methods to add items to the queue, retrieve an item from the queue, and
    return the number of items in the queue. Now let's explore how we can add the
    copy-on-write feature to the `Queue` type.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue` 类型被实现为一个值类型。该类型有一个 `BackendQueue` 类型的私有属性，用于存储数据。该类型包含三个方法，用于向队列中添加项目、从队列中检索项目以及返回队列中的项目数量。现在让我们探讨如何将写时复制特性添加到
    `Queue` 类型中。'
- en: Swift has a global function named `isKnownUniquelyReferenced()`. This function
    will return `true` if there is only one reference to an instance of a reference
    type, or `false` if there is more than one reference.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: Swift 有一个名为 `isKnownUniquelyReferenced()` 的全局函数。如果只有一个引用指向引用类型的实例，该函数将返回 `true`；如果有多个引用，则返回
    `false`。
- en: 'We will begin by adding a function to check whether there is a unique reference
    to the `internalQueue` instance. This will be a private function named `checkUniquelyReferencedInternalQueue`.
    The following code shows how we can implement this method:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个函数来检查是否对 `internalQueue` 实例有唯一的引用。这将是一个名为 `checkUniquelyReferencedInternalQueue`
    的私有函数。以下代码展示了我们如何实现这个方法：
- en: '[PRE21]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this method, we check to see whether there are multiple references to the
    `internalQueue` instances. If there are multiple references, then we know that
    we have multiple copies of the `Queue` instance and, therefore, we can create
    a new copy.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们检查是否存在对 `internalQueue` 实例的多个引用。如果有多个引用，那么我们知道我们有多份 `Queue` 实例的副本，因此我们可以创建一个新的副本。
- en: 'The `Queue` type itself is a value type; therefore, when we pass an instance
    of the `Queue` type within our code, the code that we pass the instance to receives
    a new copy of that instance. The `BackendQueue` type, which the `Queue` type is
    using, is a reference type. Therefore, when a copy is made of a `Queue` instance,
    then that new copy receives a reference to the original `Queue`''s `BackendQueue`
    instance and not a new copy. This means that each instance of the `Queue` type
    has a reference to the same `internalQueue` instance. Consider the following code
    as an example; both `queue1` and `queue2` have references to the same `internalQueue`
    instance:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '`Queue`类型本身是一个值类型；因此，当我们将`Queue`类型的实例传递到我们的代码中时，接收该实例的代码将接收该实例的新副本。《BackendQueue》类型，`Queue`类型正在使用，是一个引用类型。因此，当创建`Queue`实例的副本时，新副本将接收对原始`Queue`的`BackendQueue`实例的引用，而不是一个新副本。这意味着`Queue`类型的每个实例都引用相同的`internalQueue`实例。以下代码作为示例；`queue1`和`queue2`都引用相同的`internalQueue`实例：'
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `Queue` type, we know that both the `addItem()` and `getItem()` methods
    change the `internalQueue` instance. Therefore, before we make these changes,
    we will want to call the `checkUniquelyReferencedInternalQueue()` method to create
    a new copy of the `internalQueue` instance. These two methods will now have the
    following code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Queue`类型中，我们知道`addItem()`和`getItem()`方法都会改变`internalQueue`实例。因此，在我们进行这些更改之前，我们将想要调用`checkUniquelyReferencedInternalQueue()`方法来创建`internalQueue`实例的新副本。这两个方法现在将具有以下代码：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With this code, when either the `addItem()` or `getItem()` methods are called
    – which will change the data in the `internalQueue instance` – we use the `checkUniquelyReferencedInternalQueue()`
    method to create a new instance of the data structure.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此代码，当调用`addItem()`或`getItem()`方法（这将更改`internalQueue`实例中的数据）时，我们使用`checkUniquelyReferencedInternalQueue()`方法来创建数据结构的新实例。
- en: 'Let''s add one additional method to the `Queue` type, which will allow us to
    see whether there is a unique reference to the `internalQueue` instance or not.
    Here is the code for this method:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`Queue`类型中添加一个额外的方法，这样我们就可以看到是否有对`internalQueue`实例的唯一引用。以下是该方法的代码：
- en: '[PRE24]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Here is the full code listing for the `Queue` type:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Queue`类型的完整代码列表：
- en: '[PRE25]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now let''s examine how the copy-on-write functionality works with the `Queue`
    type. We will start off by creating a new instance of the `Queue` type, adding
    an item to the queue, and then checking whether we have a unique reference to
    the `internalQueue` instance. The following code demonstrates how to do this:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查`Queue`类型的复制写入功能是如何工作的。我们将从创建`Queue`类型的新实例开始，向队列中添加一个项目，然后检查我们是否对`internalQueue`实例有唯一的引用。以下代码演示了如何做到这一点：
- en: '[PRE26]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'When we add the item to the queue, the following message will be printed to
    the console. This tells us that within the `checkUniquelyReferencedInternalQueue()`
    method, it was determined that there was only one reference to the `internalQueue`
    instance:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将项目添加到队列中时，以下消息将被打印到控制台。这告诉我们，在`checkUniquelyReferencedInternalQueue()`方法中，确定只有一个引用指向`internalQueue`实例：
- en: '[PRE27]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We can verify this by printing the results of the `uniquelyReference()` method
    to the console. Now let''s make a copy of the `queue3` instance by passing it
    to a new variable, as follows:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过将`uniquelyReference()`方法的结果打印到控制台来验证这一点。现在让我们通过将其传递给一个新变量来创建`queue3`实例的一个副本，如下所示：
- en: '[PRE28]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s check whether we have a unique reference to the `internalQueue`
    instances of either the `queue3` or `queue4` instance. The following code will
    do this:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来检查我们是否对`queue3`或`queue4`实例的`internalQueue`实例有唯一的引用。以下代码将执行此操作：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This code will print two `false` messages to the console, letting us know that
    neither instance has a unique reference to their `internalQueue` instances. Now
    let''s add an item to either one of the queues. The following code will add another
    item to the `queue3` instance:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将在控制台打印出两条`false`消息，告诉我们这两个实例都没有对它们的`internalQueue`实例具有唯一的引用。现在让我们向这两个队列中的任何一个添加一个项目。以下代码将向`queue3`实例添加另一个项目：
- en: '[PRE30]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'When we add the item to the queue, we will see the following message printed
    to the console:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将项目添加到队列中时，我们将看到以下消息打印到控制台：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This message tells us that when we add the new item to the queue, a new copy
    of the `internalQueue` instance is created. In order to verify this, we can print
    the results of the `uniquelyReferenced()` methods to the console again. If you
    do check this, you will see two `true` messages printed to the console this time
    rather than two `false` methods. We can now add additional items to the queues
    and we will see that we are not creating new instances of the `internalQueue`
    instance because each instance of the `Queue` type now has its own copy.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这条消息告诉我们，当我们向队列中添加新项目时，会创建`internalQueue`实例的新副本。为了验证这一点，我们可以再次将`uniquelyReferenced()`方法的结果打印到控制台。如果你进行检查，这次你将看到控制台打印出两个`true`消息，而不是两个`false`方法。现在我们可以向队列中添加额外的项目，我们会看到我们没有创建`internalQueue`实例的新副本，因为`Queue`类型的每个实例现在都有自己的副本。
- en: If you are planning on creating your own data structure that may contain a large
    number of items, it is recommended that you implement it with the copy-on-write
    feature as described here.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你计划创建可能包含大量项目的自定义数据结构，建议你使用此处描述的写时复制（copy-on-write）功能来实现它。
- en: If you are comparing your custom types, it is also recommended that you implement
    the `Equatable` protocol within these custom types. This will enable you to compare
    two instances of the type using the equal-to (`==`) and not-equal-to (`!=`) operators.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在比较自定义类型，也建议你在这些自定义类型中实现`Equatable`协议。这将使你能够使用等于（`==`）和不等（`!=`）运算符来比较类型的两个实例。
- en: Implementing the Equatable protocol
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Equatable协议
- en: In this section, we will demonstrate how we can conform to the `Equatable` protocol
    using extensions. When a type conforms to the `Equatable` protocol, we can use
    the equal-to (`==`) operator to compare for equality and the not-equal-to (`!=`)
    operator to compare for inequality.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将演示如何使用扩展来符合`Equatable`协议。当一个类型符合`Equatable`协议时，我们可以使用等于（`==`）运算符来比较相等性，以及不等（`!=`）运算符来比较不等性。
- en: If you will be comparing instances of a custom type, then it is a good idea
    to have that type conform to the `Equatable` protocol because it makes comparing
    instances very easy.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将比较自定义类型的实例，那么让该类型符合`Equatable`协议是一个好主意，因为它使得比较实例变得非常容易。
- en: 'Let''s start off by creating the type that we will compare. We will name this
    type `Place`:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先创建我们将要比较的类型。我们将把这个类型命名为`Place`：
- en: '[PRE32]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In the `Place` type, we have three properties that represent the ID of the place
    and the latitude and longitude coordinates for its location. If there are two
    instances of the `Place` type that have the same ID and coordinates, then they
    will be considered the same place.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Place`类型中，我们有三个属性，它们代表地点的ID以及其位置的纬度和经度坐标。如果有两个`Place`类型的实例具有相同的ID和坐标，那么它们将被视为同一个地点。
- en: 'To implement the `Equatable` protocol, we can create a global function; however,
    that is not the recommended solution for protocol-oriented programming. We could
    also add a static function to the `Place` type itself, but sometimes it is better
    to pull the functionality needed to conform to a protocol out of the implementation
    itself. The following code will make the `Place` type conform to the `Equatable`
    protocol:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现`Equatable`协议，我们可以创建一个全局函数；然而，这并不是面向协议编程的推荐解决方案。我们也可以将静态函数添加到`Place`类型本身，但有时将符合协议所需的功能从实现中提取出来会更好。以下代码将使`Place`类型符合`Equatable`协议：
- en: '[PRE33]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'We can now compare the instances of the `Place` type as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以如下比较`Place`类型的实例：
- en: '[PRE34]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This will print `false` because `Fenway Park` and `Wrigley Field` are two different
    baseball stadiums.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`false`，因为`芬威公园`和`惠利球场`是两个不同的棒球场。
- en: You may be wondering why we said that it may be better to pull the functionality
    needed to conform to a protocol out of the implementation itself. Well, think
    about some of the larger types that you have created in the past. Personally speaking,
    I have seen types that had several hundred lines of code and conformed to numerous
    protocols. By pulling the code that is needed to conform to a protocol out of
    the type's implementation and putting it in its own extension, we are making our
    code much easier to read and maintain in the future because the implementation
    code is isolated in its own extension.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道为什么我们说将符合协议所需的功能从实现本身中提取出来可能更好。好吧，想想你过去创建的一些大型类型。就我个人而言，我见过有几百行代码的类型，并且符合了许多协议。通过将符合协议所需的代码从类型的实现中提取出来，并将其放入它自己的扩展中，我们使代码在未来的可读性和可维护性方面变得更加容易，因为实现代码被隔离在其自己的扩展中。
- en: 'Starting with Swift 5.2, if all of the properties conform to the `Equatable`
    protocol and you want to compare all of the properties, as shown in the previous
    examples, we actually do not need to implement the `==` function. All we really
    need to do is to implement the code as shown in the following example:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Swift 5.2 开始，如果所有属性都符合 `Equatable` 协议，并且你想比较所有属性，就像之前的例子中那样，实际上我们不需要实现 `==`
    函数。我们真正需要做的只是按照以下示例实现代码：
- en: '[PRE35]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: In the previous code, Swift will add all of the boilerplate code to make the
    `Place` structure conform to the `Equatable` protocol for us; however, it is good
    to know how to implement this ourselves if all of the properties do not conform
    to the `Equatable` protocol or we do not want to compare all of the properties.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的代码中，Swift 会自动添加所有必要的代码，使 `Place` 结构体符合 `Equatable` 协议；然而，了解如何自己实现这一点是有好处的，尤其是当所有属性都不符合
    `Equatable` 协议，或者我们不想比较所有属性时。
- en: Summary
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the differences between value types and reference
    types. We also looked at how to implement copy-on-write and the `Equatable` protocol
    with our custom types. We can implement the copy-on-write feature with value types
    that become very large. We can implement the `Equatable` protocol for any custom
    type, including reference types, when we need to compare two instances.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了值类型和引用类型之间的区别。我们还探讨了如何使用自定义类型实现 copy-on-write 和 `Equatable` 协议。我们可以为变得非常大的值类型实现
    copy-on-write 功能。当我们需要比较两个实例时，我们可以为任何自定义类型实现 `Equatable` 协议，包括引用类型。
- en: While Swift takes care of managing the memory for us, it is still a good idea
    to understand how this memory management works so that we can avoid the pitfalls
    that may cause it to fail. In the next chapter, we will look at how memory management
    in Swift works and demonstrate how it can fail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Swift 会帮我们管理内存，但了解这种内存管理的工作原理仍然是一个好主意，这样我们可以避免可能导致其失败的陷阱。在下一章中，我们将探讨 Swift
    中内存管理的工作方式，并演示它可能失败的情况。
