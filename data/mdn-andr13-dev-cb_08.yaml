- en: '8'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '8'
- en: Getting Started with Paging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用Paging
- en: In Android development, the Paging library helps developers load and display
    data pages from a larger dataset from local storage or over a network. This can
    be a common case if your application loads considerable amounts of data for people
    to read. For instance, a good example is Twitter; you might notice the data refreshes
    due to the many tweets that people send daily.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在Android开发中，Paging库帮助开发者从本地存储或通过网络从更大的数据集中加载数据页面。如果您的应用程序需要加载大量数据供人们阅读，这可能会很常见。例如，一个好的例子是Twitter；您可能会注意到由于人们每天发送的许多推文，数据会刷新。
- en: Hence, in **Modern Android Development** (**MAD**), Android developers might
    want to implement the Paging library in their applications to help them with such
    instances when loading data. In this chapter, you will learn how to utilize the
    Paging library in your projects.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在**现代Android开发**（**MAD**）中，Android开发者可能希望在他们的应用程序中实现Paging库来帮助他们处理加载数据的此类情况。在本章中，您将学习如何在项目中利用Paging库。
- en: 'In this chapter, we’ll cover the following recipes:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下菜谱：
- en: Implementing the Jetpack Paging library
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现Jetpack Paging库
- en: Managing present and loading states
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理当前和加载状态
- en: Implementing your custom pagination in Jetpack Compose
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在Jetpack Compose中实现自定义分页
- en: Loading and displaying paged data
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载和显示分页数据
- en: Understanding how to transform data streams
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何转换数据流
- en: Migrating to Paging 3 and understanding the benefits
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 迁移到Paging 3并了解其优势
- en: Writing tests for your Paging Source
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为您的Paging Source编写测试
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The complete source code for this chapter can be found at [https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight).
    You will also need to get an API key for [https://newsapi.org/](https://newsapi.org/).
    `NewsApi` is a worldwide API for news.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的完整源代码可以在[https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight](https://github.com/PacktPublishing/Modern-Android-13-Development-Cookbook/tree/main/chapter_eight)找到。您还需要为[https://newsapi.org/](https://newsapi.org/)获取一个API密钥。"NewsApi"是一个全球性的新闻API。
- en: Implementing the Jetpack Paging library
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现Jetpack Paging库
- en: The Paging library comes with incredible features for developers. If your codebase
    is established and extensive, there are other custom ways that developers have
    created to help them load data efficiently. One notable advantage of Paging is
    its in-memory caching for your page’s data, which ensures your application uses
    the system resources efficiently while working with the already paged data.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: Paging库为开发者提供了令人难以置信的功能。如果您的代码库已经建立且规模庞大，开发者们已经创建了其他自定义方法来帮助他们高效地加载数据。Paging的一个显著优势是其页面数据的内存缓存，这确保了您的应用程序在处理已分页数据时高效地使用系统资源。
- en: In addition, it offers support for Kotlin coroutine flows and LiveData and has
    built-in deduplication, which ensures your application uses network bandwidth
    and resources efficiently, which can help save battery. Finally, the Paging library
    offers support for error handling, including when refreshing and retrying your
    data.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还支持Kotlin协程流和LiveData，并具有内置的去重功能，这确保了您的应用程序在处理已分页数据时高效地使用系统资源，这有助于节省电池。最后，Paging库提供了错误处理支持，包括在刷新和重试数据时。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will need to create a new project; if you need to reference
    a previous recipe for creating a new project, you can visit [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android* *Development Skills*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们需要创建一个新的项目；如果您需要参考创建新项目的先前菜谱，您可以访问[*第1章*](B18827_01.xhtml#_idTextAnchor014)，*现代Android开发技能入门*。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Let’s go ahead and create a new empty Compose project and call it `PagingJetpackExample`.
    In our example project, we will use the free `NewsApi` to display the news to
    our users. To get started, check out this link at [https://newsapi.org/docs/get-started](https://newsapi.org/docs/get-started).
    Also, ensure you get your API for the project, as it is a requirement for this
    recipe. Follow these steps to get started:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的空Compose项目，并将其命名为`PagingJetpackExample`。在我们的示例项目中，我们将使用免费的`NewsApi`向用户展示新闻。要开始，请查看这个链接[https://newsapi.org/docs/get-started](https://newsapi.org/docs/get-started)。同时，确保您为项目获取API，因为这是本菜谱的要求。按照以下步骤开始：
- en: 'Let’s go ahead and add the following required dependencies. In addition, since
    we will be doing a network call, we need to add a library to handle this. As for
    the correct versioning, check out the *Technical requirements* section for the
    code and the correct version. We will provide `2.x.x` so you can check compatibility
    if you are upgrading or already have `Retrofit` in your project and Coil which
    is a fast, lightweight, and flexible image loading library. It is designed to
    simplify the process of loading images from various sources (such as network,
    local storage, or content providers) and displaying them in ImageView or other
    image-related UI components:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续添加以下必需的依赖项。此外，由于我们将进行网络调用，我们需要添加一个库来处理这个问题。关于正确的版本控制，请查看*技术要求*部分以获取代码和正确的版本。我们将提供`2.x.x`，这样你可以在升级或已经在你的项目中使用`Retrofit`和Coil时检查兼容性。Coil是一个快速、轻量级且灵活的图像加载库。它旨在简化从各种来源（如网络、本地存储或内容提供者）加载图像并在ImageView或其他图像相关UI组件中显示图像的过程：
- en: '[PRE0]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: After the project syncs and is ready, go ahead and remove the `Greeting` composable
    function that comes with the project. You should have just your theme, and your
    surface should be empty. In addition, for the **user interface** (**UI**) portion
    of this recipe, you can get the entire code from the *Technical* *requirements*
    section.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目同步并准备就绪后，继续删除项目附带来的`Greeting`可组合函数。你应该只有你的主题，你的界面应该是空的。此外，对于这个食谱的**用户界面**（**UI**）部分，你可以从*技术要求*部分获取整个代码。
- en: 'Also, when using an API, developers tend to forget to add the `Android.permission.INTERNET`
    permission on the manifest, so let’s do that now before we forget it:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当使用API时，开发者往往会忘记在清单中添加`Android.permission.INTERNET`权限，所以现在让我们先做这件事，以免忘记：
- en: '[PRE7]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, create a package and call it `data`; we will add our model and service
    files to this package. In addition, ensure you go through the News API **Documentation**
    section to understand how the API works:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个名为`data`的包；我们将把我们的模型和服务文件添加到这个包中。此外，确保你阅读了新闻API的**文档**部分，以了解API的工作原理：
- en: '[PRE8]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let us now create our `NewsArticleResponse` data class, which we will implement
    in our `NewsApiService` interface. Our API call type is `@GET()`, which means
    exactly “to get.” A more detailed explanation of `GET` is provided in the *How
    it works* section. Our call seeks to return a call object containing the data
    in the form of the `NewsArticleResponse` data class:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来创建我们的`NewsArticleResponse`数据类，我们将在`NewsApiService`接口中实现它。我们的API调用类型是`@GET()`，这意味着“获取”。关于`GET`的更详细解释可以在*如何工作*部分找到。我们的调用旨在返回一个包含`NewsArticleResponse`数据类形式的调用对象：
- en: '[PRE11]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Create another class called `NewsArticlePagingSource()`; our class will use
    `NewsApiService` as the input parameter. When exposing any large datasets through
    APIs, we need to provide a mechanism to paginate the list of resources. To implement
    it, we need to pass the type of the Paging key and the type of data to load, which
    in our case is `NewsArticle`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个名为`NewsArticlePagingSource()`的类；我们的类将使用`NewsApiService`作为输入参数。当通过API公开任何大型数据集时，我们需要提供一个机制来分页资源列表。为了实现它，我们需要传递分页键的类型和要加载数据的类型，在我们的例子中是`NewsArticle`：
- en: '[PRE22]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, let us go ahead and override `getRefreshKey()` provided by the `PagingSource`
    and `load()` suspend functions. We will discuss the `load()` and `PagingSource`
    suspend functions in detail in the *Loading and displaying paged* *data* recipe:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们继续并重写由`PagingSource`和`load()`挂起函数提供的`getRefreshKey()`。我们将在*加载数据和显示分页数据*食谱中详细讨论`load()`和`PagingSource`挂起函数：
- en: '[PRE27]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, let’s create our repository; a repository is a class that isolates the
    data sources, such as a web service or a Room database, from the rest of the app.
    Since we do not have a Room database, we will work with the web service data:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的仓库；仓库是一个将数据源（如网络服务或Room数据库）与应用程序的其他部分隔离的类。由于我们没有Room数据库，我们将使用网络服务数据：
- en: '[PRE59]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We will use Hilt for Dependency Injection in our project and build the required
    modules that will be supplied. For this section, you can reference the steps in[*Chapter
    3*](B18827_03.xhtml#_idTextAnchor137), *Handling the UI State in Jetpack Compose
    and Using Hilt*, on how to add Hilt to your project and also how to create the
    required modules. In addition, you can access the entire code through the *Technical
    requirements* section if you get stuck:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们将使用 Hilt 进行依赖注入并构建所需模块。对于本节，你可以参考[*第 3 章*](B18827_03.xhtml#_idTextAnchor137)中的步骤，*在
    Jetpack Compose 中处理 UI 状态和使用 Hilt*，了解如何将 Hilt 添加到你的项目中以及如何创建所需的模块。此外，如果你遇到困难，可以通过
    *技术要求* 部分访问整个代码：
- en: '[PRE71]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Finally, after we have implemented our `PagingSource`, we can go ahead and create
    a `Pager` which typically refers to a `ViewPager` in our ViewModel and specify
    our page size. This can range based on the project’s needs or preferences. Furthermore,
    when using Paging 3.0, we don’t need to individually handle or convert any data
    to survive the screen configuration changes because this is done for us automatically.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们实现了我们的 `PagingSource` 之后，我们可以继续创建一个 `Pager`，这通常指的是我们的 ViewModel 中的 `ViewPager`，并指定我们的页面大小。这可以根据项目的需求或偏好进行选择。此外，当使用
    Paging 3.0 时，我们不需要单独处理或转换任何数据以应对屏幕配置更改，因为这会自动为我们完成。
- en: 'We can simply cache our API result using `cachedIn(viewModelScope)`. In addition,
    to notify of any change to the `PagingData`, you can handle the loading state
    using a `CombinedLoadState` callback:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `cachedIn(viewModelScope)` 简单地缓存我们的 API 结果。此外，为了通知 `PagingData` 的任何更改，你可以使用
    `CombinedLoadState` 回调来处理加载状态：
- en: '[PRE84]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Finally, when you run the application, you should see a display like *Figure
    8**.1*, showing the author’s name, image, and content. We also wrap the content
    since this example is just for learning purposes; you can take it as a challenge
    to improve the UI and display more details:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你运行应用程序时，你应该看到一个类似于 *图 8**.1* 的显示，显示作者的名字、图像和内容。我们还将内容包装起来，因为此示例只是为了学习目的；你可以将其作为一个挑战来改进
    UI 并显示更多细节：
- en: "![Figure 8.1 – The news article being loaded using the Paging 3 \uFEFFlibrary](img/Figure_8.1.jpg)"
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1 – 使用 Paging 3 库加载的新闻文章](img/Figure_8.1.jpg)'
- en: Figure 8.1 – The news article being loaded using the Paging 3 library
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1 – 使用 Paging 3 库加载的新闻文章
- en: How it works…
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In Android development, a retrofit request typically refers to a network request
    made using the Retrofit library, a popular HTTP client library for Android.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 开发中，Retrofit 请求通常指的是使用 Retrofit 库进行的网络请求，Retrofit 是一个流行的 Android HTTP
    客户端库。
- en: 'Here are some common types of Retrofit requests and their usage:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一些常见的 Retrofit 请求类型及其用法：
- en: '`GET`: This request is used to retrieve data from a server. It is the most
    common type of request used in Android apps and is often used to retrieve data
    to populate a UI element such as a list or a grid.'
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：此请求用于从服务器检索数据。它是 Android 应用中最常见的请求类型，通常用于检索数据以填充 UI 元素，如列表或网格。'
- en: '`POST`: This request is used to submit data to a server. It is commonly used
    to create new resources on the server, such as a new user account or a new post.'
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：此请求用于向服务器提交数据。它通常用于在服务器上创建新的资源，如新的用户账户或新的帖子。'
- en: '`PUT`: This request is used to update an existing resource on the server. It
    is commonly used to update a user’s account information or to modify an existing
    post.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：此请求用于更新服务器上的现有资源。它通常用于更新用户的账户信息或修改现有的帖子。'
- en: '`DELETE`: This request is used to delete a resource on the server. It is commonly
    used to delete a user account or to remove a post.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：此请求用于在服务器上删除资源。它通常用于删除用户账户或删除帖子。'
- en: '`PATCH`: This request partially updates an existing resource on the server.
    It is commonly used when only a small portion of the resource needs to be updated
    rather than updating the entire resource with a `PUT` request.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：此请求部分更新服务器上的现有资源。当只需要更新资源的一小部分而不是使用 `PUT` 请求更新整个资源时，通常使用它。'
- en: When making Retrofit requests, developers typically define an interface that
    describes the endpoint and the request parameters. Retrofit then generates a client
    implementation for that interface, which can be used to make the actual network
    calls.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Retrofit 请求时，开发者通常会定义一个接口来描述端点和请求参数。Retrofit 然后为该接口生成客户端实现，可用于进行实际的网络调用。
- en: By using Retrofit, developers can abstract away many of the low-level details
    of network requests, making it easier and more efficient to communicate with a
    server from an Android app. For examples about Retrofit, check out the following
    link [https://square.github.io/retrofit/](https://square.github.io/retrofit/).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Retrofit，开发者可以抽象出网络请求的许多底层细节，这使得从Android应用中与服务器通信变得更加容易和高效。有关Retrofit的示例，请查看以下链接
    [https://square.github.io/retrofit/](https://square.github.io/retrofit/)。
- en: 'The Paging library ensures it adheres to the recommended Android architecture
    patterns. Furthermore, its components are the `Repository`, `ViewModel`, and `UI`
    layers. The following diagram shows how Paging components operate at each layer
    and how they work together in unison to load and display your paged data:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 分页库确保它遵循推荐的Android架构模式。此外，其组件包括`Repository`、`ViewModel`和`UI`层。以下图表显示了分页组件在每个层中的操作方式以及它们如何协同工作以加载和显示你的分页数据：
- en: '![Figure 8.2 – The Paging library architecture](img/Figure_8.2.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2 – 分页库架构](img/Figure_8.2.jpg)'
- en: Figure 8.2 – The Paging library architecture
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 分页库架构
- en: 'The `Paging Source` component is the main component in the `Repository` layer,
    as seen in *Figure 8**.2*. The object usually declares a source for each piece
    of data and also handles how to retry data from that source. If you noticed, that
    is precisely what we did in our example:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '`Paging Source`组件是`Repository`层中的主要组件，如*图8**.2所示。该对象通常为每份数据声明一个源，并处理如何从该源重试数据。如果你注意到，这正是我们在示例中做的：'
- en: '[PRE85]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: We create our Retrofit `builder()` object that contains our base URL of the
    API, which we defined in the `Constant` class, `const val BASE_URL = "https://newsapi.org/v2/"`,
    and we use the `Gson` converter to convert our JSON API response. We then declare
    the `apiService` variable that we will use to connect the Retrofit `builder()`
    object with our interface and complete our retrofit module.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个包含API基本URL的Retrofit `builder()`对象，该URL我们在`Constant`类中定义，`const val BASE_URL
    = "https://newsapi.org/v2/"`，我们使用`Gson`转换器来转换我们的JSON API响应。然后我们声明了`apiService`变量，我们将使用它将Retrofit
    `builder()`对象与我们的接口连接并完成我们的Retrofit模块。
- en: Important note
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: It is recommended for anyone using the Paging Library to migrate to Paging 3
    due to its improvements and because some functionalities are hard to handle using
    Paging 2.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 由于其改进以及一些功能难以使用Paging 2处理，建议所有使用分页库的人迁移到Paging 3。
- en: Managing present and loading states
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理当前和加载状态
- en: The Paging library offers the loading state information to users through its
    load state object, which can have different forms based on its current loading
    state. For example, if you have an active load, then the state will be `LoadState.Loading`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 分页库通过其加载状态对象向用户提供加载状态信息，该对象可以根据其当前的加载状态呈现不同的形式。例如，如果你有一个正在进行的加载操作，那么状态将是`LoadState.Loading`。
- en: 'If you have an error state, then the state will be a `LoadState.Error`; and
    finally, there might be no active load operation, and this state is called the
    `LoadState.NotLoading.` In this recipe, we will explore the different states and
    get to understand them; the example demonstrated here can also be found at the
    following link: [https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state).
    In this example, we assume your project uses legacy code, which utilizes XML for
    the view system.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你有一个错误状态，那么状态将是`LoadState.Error`；最后，可能没有正在进行的加载操作，这种状态被称为`LoadState.NotLoading`。在本食谱中，我们将探讨不同的状态并了解它们；这里展示的示例也可以在以下链接中找到：[https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state)。在这个例子中，我们假设你的项目使用的是遗留代码，该代码利用XML作为视图系统。
- en: Getting ready
  id: totrans-141
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along with this recipe, you need to have completed the code in the
    previous recipe. You can also skip this if it is not required in your project.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟随本食谱，你需要完成上一个食谱中的代码。你也可以跳过这一步，如果它在你项目中不是必需的。
- en: How to do it…
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'We will not create a new project in this recipe but rather a step-by-step look
    at how we can access the loading state with a listener or present the loading
    state with an adapter. Follow along with these steps to get started:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们不会创建一个新的项目，而是逐步查看我们如何使用监听器访问加载状态或使用适配器呈现加载状态。按照以下步骤操作以开始：
- en: 'When you want to access the state, pass this information to your UI. You can
    easily use the `loadedStateFlow` stream of the `addLoadStateListener` function
    provided by `PagingDataAdapter`:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您想要访问状态时，将此信息传递给您的 UI。您可以使用 `PagingDataAdapter` 提供的 `addLoadStateListener`
    函数的 `loadedStateFlow` 流轻松地做到这一点：
- en: '[PRE86]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: For our example, we will not look into the `addLoadStateListener` function since
    this is used with an adapter class, and with the new Jetpack Compose, this is
    barely performed since there is more of a push to use the Jetpack Compose UI-based
    applications.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的示例，我们不会查看 `addLoadStateListener` 函数，因为这与适配器类一起使用，并且由于新的 Jetpack Compose，这几乎不再执行，因为有更多的推动力去使用基于
    Jetpack Compose 的 UI 应用程序。
- en: 'Filtering the load state steam might make sense based on your application’s
    specific event. This ensures that your app UI is updated at the correct time to
    avoid issues. Hence, using coroutines, we wait until our refresh load state is
    updated:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据您应用程序的具体事件，过滤加载状态流可能是有意义的。这确保了您的应用程序 UI 在正确的时间更新，以避免问题。因此，使用协程，我们等待刷新加载状态更新：
- en: '[PRE97]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: '[PRE101]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: How it works…
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When getting updates from `loadStateFlow` and `addLoadStateListener()`, these
    are guaranteed to be synchronous, and they update the UI as needed. This simply
    means in the Paging 3 library for Android, `LoadState.Error` is a state that indicates
    an error has occurred while loading data from a `PagingSource`.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 `loadStateFlow` 和 `addLoadStateListener()` 获取更新时，这些更新保证是同步的，并且根据需要更新 UI。这仅仅意味着在
    Android 的 Paging 3 库中，`LoadState.Error` 是一个表示在从 `PagingSource` 加载数据时发生错误的状态。
- en: In Paging 3 library for Android, `LoadState.NotLoading` is a state that indicates
    that the `PagingDataAdapter` is not currently loading any data and that all available
    data has been loaded.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Android 的 Paging 3 库中，`LoadState.NotLoading` 是一个表示 `PagingDataAdapter` 当前没有加载数据，并且所有可用数据都已加载的状态。
- en: When a `PagingDataAdapter` is first created, it starts in the `LoadState.NotLoading`
    state. This means that no data has been loaded yet, and the adapter is waiting
    for the first load to occur.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `PagingDataAdapter` 首次创建时，它处于 `LoadState.NotLoading` 状态。这意味着尚未加载数据，适配器正在等待第一次加载发生。
- en: After the first load, the adapter may transition to a different load state depending
    on the current state of the data loading process. However, once all available
    data has been loaded, the adapter will transition back to the `LoadState.NotLoading`
    state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一次加载之后，适配器可能会根据数据加载过程的当前状态转换到不同的加载状态。然而，一旦所有可用数据都已加载，适配器将转换回 `LoadState.NotLoading`
    状态。
- en: '`LoadState.NotLoading` can be used to inform the UI that the data-loading process
    is complete and that no further data will be loaded unless the user initiates
    a refresh or other action.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadState.NotLoading` 可以用来通知 UI 数据加载过程已完成，并且除非用户启动刷新或其他操作，否则不会加载更多数据。'
- en: To handle this state, you can register a listener for changes to the `LoadState`
    in the `PagingDataAdapter` and update the UI accordingly. For example, you could
    display a message to the user indicating that all data has been loaded or disable
    any “load more” buttons or gestures.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 要处理此状态，您可以在 `PagingDataAdapter` 中注册对 `LoadState` 变化的监听器，并相应地更新 UI。例如，您可以向用户显示一条消息，表明所有数据已加载，或禁用任何“加载更多”按钮或手势。
- en: There’s more…
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'You can learn more about the state and how to better handle Paging by following
    this link: [https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state).'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过以下链接了解状态以及如何更好地处理分页：[https://developer.android.com/topic/libraries/architecture/paging/load-state](https://developer.android.com/topic/libraries/architecture/paging/load-state)。
- en: Implementing your custom pagination in Jetpack Compose
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Jetpack Compose 中实现自定义分页
- en: The Paging library has incredible features for developers, but sometimes you
    encounter challenges and are forced to create custom pagination. At the beginning
    of the chapter, we talked about complex code bases having or creating pagination.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Paging 库为开发者提供了令人难以置信的功能，但有时您会遇到挑战，不得不创建自定义分页。在章节的开头，我们讨论了复杂代码库中或创建分页的情况。
- en: In this recipe, we will look into how we can achieve this with a simple list
    example and how you can use this example to create custom pagination in your application.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将探讨如何通过一个简单的列表示例来实现这一点，以及您如何使用此示例在您的应用程序中创建自定义分页。
- en: Getting ready
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: In this recipe, we will need to create a new project and call it `CustomPagingExample`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们需要创建一个新的项目，并将其命名为 `CustomPagingExample`。
- en: How to do it…
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In our example project, we will try to create a student profile card and use
    custom pagination to load the profiles in Jetpack Compose.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例项目中，我们将尝试创建一个学生配置文件卡片，并使用自定义分页在 Jetpack Compose 中加载配置文件。
- en: 'For this recipe, let us go ahead and add the `lifecycle-ViewModel` dependency
    since we will need it:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这个菜谱，让我们继续添加 `lifecycle-ViewModel` 依赖项，因为我们将会用到它：
- en: '[PRE103]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Let’s go ahead and create a new package and call it `data`. In our `data` package,
    we will add the items we will display on our card. For now, we will just display
    the student’s `name, school,` `and major`:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的包并称其为 `data`。在我们的 `data` 包中，我们将添加我们将在卡片上显示的项目。目前，我们只将显示学生的 `姓名、学校`
    和 `专业`：
- en: '[PRE104]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: '[PRE107]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Now that we have our `data` class, we will go ahead and build our repository,
    and since, in our example, we are not using an API, we will use our remote data
    source, and we can try to load, say, 50 to 100 profiles. Then, inside `data`,
    add another class and call it `StudentRepository`:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有了我们的 `data` 类，我们将继续构建我们的仓库，由于在我们的示例中我们没有使用 API，我们将使用我们的远程数据源，我们可以尝试加载，比如说，50
    到 100 个配置文件。然后，在 `data` 中添加另一个类并称其为 `StudentRepository`：
- en: '[PRE109]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: '[PRE110]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: '[PRE114]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: '[PRE115]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE118]'
- en: '[PRE119]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-209
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Now that we have created our repository let us go ahead and create our custom
    pagination. We will do this by creating a new interface and calling it `StudentPaginator`:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 既然我们已经创建了我们的仓库，让我们继续创建我们的自定义分页。我们将通过创建一个新的接口并称其为 `StudentPaginator` 来完成此操作：
- en: '[PRE131]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: '[PRE134]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Since `StudentPaginator` is an interface, we must create a class to implement
    the two functions we just created. Now, let us go ahead and create `StudentPaginatorImpl`
    and implement our interface:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `StudentPaginator` 是一个接口，我们必须创建一个类来实现我们刚刚创建的两个函数。现在，让我们继续创建 `StudentPaginatorImpl`
    并实现我们的接口：
- en: '[PRE135]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: '[PRE138]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '[PRE141]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: 'Next, you will need to work on what you need to handle in the `StudentPaginator`
    implementation class. For instance, in our constructor, we will need to create
    a key to listen to the `load`, `request`, `error`, `success`, and `next key`,
    and then finally, on the `reset()` function, be able to reset our pagination.
    You can view the complete code in the *Technical requirements* section. You might
    also notice it looks similar to the Paging Source in the first recipe of this
    chapter:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要处理 `StudentPaginator` 实现类中需要处理的内容。例如，在我们的构造函数中，我们需要创建一个键来监听 `load`、`request`、`error`、`success`
    和 `next key`，然后在 `reset()` 函数中能够重置我们的分页。你可以在 *技术要求* 部分查看完整的代码。你可能也会注意到它看起来与本章第一个菜谱中的分页源很相似：
- en: '[PRE144]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE146]'
- en: '[PRE147]'
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE153]'
- en: '[PRE154]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE159]'
- en: '[PRE160]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE160]'
- en: '[PRE161]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'Let’s go ahead and create a new package and call it `uistate`. Inside `uistate`,
    we will create a new data class and call it `UIState` to help us handle the UI
    state:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们继续创建一个新的包并称其为 `uistate`。在 `uistate` 中，我们将创建一个新的数据类并称其为 `UIState` 以帮助我们处理
    UI 状态：
- en: '[PRE163]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE165]'
- en: '[PRE166]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE170]'
- en: 'Now let’s go ahead and finalize our `ViewModel` `init` in Kotlin is the block
    that we use for our initialization. We also create `val ourPaginator` that we
    declare to the `StudentPaginatorImpl` class and handle the inputs with the data
    we need for our UI:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们继续并最终确定我们的 Kotlin 中的 `ViewModel` `init` 块，这是我们用于初始化的块。我们还创建了 `val ourPaginator`，并将其声明给
    `StudentPaginatorImpl` 类，并使用我们用于 UI 的数据来处理输入：
- en: '[PRE171]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE176]'
- en: '[PRE177]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: '[PRE191]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: '[PRE192]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: '[PRE197]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE201]'
- en: 'Finally, in our `MainActivity` class, we now load the student profile on our
    card and display it on the screen, as shown in *Figure 8**.3*. A tremendous additional
    exercise to try out is to use Dependency Injection on the sample project to enhance
    your Android skills. You can utilize [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137),
    *Handling the UI State in Jetpack Compose and Using Hilt*, for adding Dependency
    Injection and also to try writing tests for the `ViewModel` class:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在我们的 `MainActivity` 类中，我们现在在我们的卡片上加载学生配置文件并在屏幕上显示它，如图 *图 8**.3* 所示。一个额外的巨大练习是尝试在示例项目中使用依赖注入来提高你的
    Android 技能。你可以利用 [*第 3 章*](B18827_03.xhtml#_idTextAnchor137)，*在 Jetpack Compose
    中处理 UI 状态和使用 Hilt*，来添加依赖注入，并尝试为 `ViewModel` 类编写测试：
- en: '![Figure 8.3 – The data loaded on a lazy column](img/Figure_8.3.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3 – 懒加载列上加载的数据](img/Figure_8.3.jpg)'
- en: Figure 8.3 – The data loaded on a lazy column
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 懒加载列上加载的数据
- en: 'In *Figure 8**.4* you will see a progress loading symbol when you scroll down
    to **Student 4** and so on, which can be great when you have huge loads of data:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 8**.4* 中，当你向下滚动到 **学生 4** 等等时，你会看到一个进度加载符号，这在处理大量数据时可以非常出色：
- en: '![Figure 8.4 – Our data being loaded](img/Figure_8.4.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4 – 加载数据](img/Figure_8.4.jpg)'
- en: Figure 8.4 – Our data being loaded
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 加载数据
- en: How it works…
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You might experience issues once you get a list, and it might be tough to notify
    single items. However, you can easily make your pagination; in our project, we
    simulate a remote data source but remember that you can use any API for this example.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你得到一个列表，可能会遇到问题，并且通知单个项目可能很困难。然而，你可以轻松地实现分页；在我们的项目中，我们模拟了一个远程数据源，但请记住，你可以使用任何API来演示这个例子。
- en: 'Our primary focus is the `StudentPaginatorImpl` class – you will notice we
    pass in a key, a `loadUpdated` value, and a request which is a suspend function
    that returns a result from our `Student` type; we also pass the `nextkey`, which
    tells us where we are. Then, in case of an error, we have the throwable error
    and a `suspend` value, `success`, which gives us the `success` result:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的主要关注点是`StudentPaginatorImpl`类——你会注意到我们传递了一个键、一个`loadUpdated`值和一个请求，这是一个返回我们的`Student`类型结果的挂起函数；我们还传递了`nextkey`，它告诉我们我们的位置。然后，在出现错误的情况下，我们有可抛出的错误和一个`suspend`值`success`，它提供了`success`结果：
- en: '[PRE202]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: So when we override our function from the `loadNextStudent()` interface, we
    first check our current state request and return our initial value as `false`,
    but we update it after our status check. We also ensure that we reset the key
    by setting the `currentKey` to the `nextKey`.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们从`loadNextStudent()`接口重写我们的函数时，我们首先检查当前状态请求，并将初始值作为`false`返回，但在状态检查之后更新它。我们还确保通过将`currentKey`设置为`nextKey`来重置键。
- en: '[PRE203]'
  id: totrans-299
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: This makes it easy if you ever need to customize an item in your `LazyColumn`,
    ensuring you have great lists.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要自定义`LazyColumn`中的项目，这将变得很容易，确保你拥有优秀的列表。
- en: The `loadStudentProfile()` function has a `viewModelScope.launch {...}`. A ViewModel
    scope is defined for each ViewModel in our application. In addition, any coroutine
    launched in this scope is auto-canceled if the ViewModel is cleared.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadStudentProfile()`函数包含一个`viewModelScope.launch {...}`。在我们的应用程序中，为每个ViewModel定义了一个ViewModel作用域。此外，在这个作用域中启动的任何协程，如果ViewModel被清除，将会自动取消。'
- en: You might be wondering what a ViewModel is. To help refresh your knowledge,
    you can look into [*Chapter 3*](B18827_03.xhtml#_idTextAnchor137), *Handling the
    UI State in Jetpack Compose and* *Using Hilt*.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道ViewModel是什么。为了帮助你刷新知识，你可以查看[*第3章*](B18827_03.xhtml#_idTextAnchor137)，*在Jetpack
    Compose中处理UI状态以及使用Hilt*。
- en: Loading and displaying paged data
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和显示分页数据
- en: There are essential steps to consider when loading and displaying paged data.
    In addition, the Paging library provides tremendous advantages for loading and
    displaying large, paged datasets. A few steps you must have in mind is ensuring
    you first define a data source, your Paging Source set up streams if needed, and
    more.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在加载和显示分页数据时，有一些基本步骤需要考虑。此外，Paging库为加载和显示大型、分页数据集提供了巨大的优势。你必须记住的一些步骤是确保首先定义数据源，如果需要，设置Paging
    Source流，等等。
- en: In this recipe, we will look at how loading and displaying paged data works.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何加载和显示分页数据。
- en: How to do it…
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'You need to have completed the *Implementing the Jetpack Paging library* recipe
    to be able to follow along with the explanation of this recipe:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要完成*实现Jetpack Paging库*菜谱，才能跟随本菜谱的解释：
- en: 'You might have noticed in our first recipe that we override `load()`, a method
    that we use to indicate how we retrieve the paged data from our corresponding
    data source:'
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能已经注意到在我们的第一个菜谱中，我们重写了`load()`方法，这是我们用来指示如何从对应的数据源检索分页数据的方法：
- en: '[PRE204]'
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE219]'
- en: 'We start refreshing at page `1` if `val page = params.key ?: 1` is undefined
    when we override `getRefreshKey()`; we try to find the page key of the closest
    page to the anchor position from either our previous key or the next key. We also
    need to ensure we handle cases where we might have some `null` values:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '如果我们在重写`getRefreshKey()`时`val page = params.key ?: 1`未定义，我们则从页码`1`开始刷新；我们尝试从我们的上一个键或下一个键中找到锚定位置最近的页码。我们还需要确保我们处理可能存在的`null`值的情况：'
- en: '[PRE220]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE220]'
- en: '[PRE221]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-331
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-333
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE227]'
- en: '[PRE228]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE228]'
- en: How it works…
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: When using the Paging library, you can specify the position of the first item
    to be displayed on the screen using the `anchorPosition` parameter. In addition,
    `anchorPosition` is an optional parameter that you can pass to the `PagingItems`
    composable function, which is used to display paged data. The `anchorPosition`
    parameter is used to specify the position of the first item to be displayed on
    the screen when the composable is first rendered.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Paging库时，你可以使用`anchorPosition`参数指定屏幕上要显示的第一个项目的位置。此外，`anchorPosition`是一个可选参数，你可以将其传递给用于显示分页数据的`PagingItems`可组合函数。`anchorPosition`参数用于指定在可组合函数首次渲染时屏幕上要显示的第一个项目的位置。
- en: 'The `LoadParams` object carries the information about the load operation to
    be performed. In addition, it knows about the key to be loaded and the number
    of items to be displayed on the UI. Furthermore, to better understand how the
    `load()` function receives the key for each specific load and updates it, review
    the following diagram:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadParams` 对象携带有关要执行加载数据操作的信息。此外，它知道要加载的键和要在UI上显示的项目数量。此外，为了更好地理解`load()`函数如何接收每个特定加载的键并更新它，请查看以下图表：'
- en: '![Figure 8.5 – How load() uses and updates the key](img/Figure_8.5.jpg)'
  id: totrans-338
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5 – load()如何使用和更新键](img/Figure_8.5.jpg)'
- en: Figure 8.5 – How load() uses and updates the key
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – load()如何使用和更新键
- en: Understanding how to transform data streams
  id: totrans-340
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解如何转换数据流
- en: When writing any code dealing with Paging, you need to understand how you can
    transform the data stream as you load it to your users. For instance, you may
    need to filter a list of items or even convert the items to a different type before
    you can feed the UI with the data.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 当编写任何处理分页的代码时，你需要了解你如何在将数据加载到用户时转换数据流。例如，你可能需要在将数据提供给UI之前过滤项目列表或甚至将项目转换为不同的类型。
- en: Hence, ensuring you apply transformation directly to the stream data lets you
    keep your repository and UI logic separated cleanly. In this recipe, we will try
    to understand how we can transform data streams.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确保你直接将转换应用于流数据，可以使你的仓库和UI逻辑保持清晰分离。在本食谱中，我们将尝试了解我们如何转换数据流。
- en: Getting ready
  id: totrans-343
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow along, you must be familiar with the primary usage of the Paging library;
    hence make sure you have read the previous recipes in this chapter.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 要跟上进度，你必须熟悉分页库的主要用法；因此，请确保你已经阅读了本章之前的食谱。
- en: How to do it…
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In this recipe, we will perform the following steps:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将执行以下步骤：
- en: Look into how we can apply the essential transformation.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 探索我们如何应用基本转换。
- en: Convert and filter the data.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转换和过滤数据。
- en: Handle separators in the UI and convert the UI model.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在UI中处理分隔符并转换UI模型。
- en: The recipe is helpful to you if you are already using Paging in your application.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经在你的应用程序中使用分页，这个食谱对你有帮助。
- en: 'First, we need to place the transformation inside a `map{PagingData ->}`. A
    map in Kotlin applies the given lambda function to each element and returns a
    list of the lambda results:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要将转换放在一个 `map{PagingData ->}` 内部。在Kotlin中，一个映射将给定的lambda函数应用于每个元素，并返回一个lambda结果的列表：
- en: '[PRE229]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE233]'
- en: 'Second, when we want to convert the data or filter, once we have access to
    our `PagingData` object, we can use `map()` again on each item separately in the
    paged list. A typical use case is when you want to map a database or network layer
    object onto an object that might be used in the UI layer specifically:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 其次，当我们想要转换数据或过滤时，一旦我们访问到我们的 `PagingData` 对象，我们就可以在分页列表中的每个单独的项目上再次使用 `map()`。一个典型的用例是当你想要将数据库或网络层对象映射到可能在UI层特别使用的对象上：
- en: '[PRE234]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-360
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE238]'
- en: 'We will need to place the filter operation inside the map because the filter
    applies to the `PagingData` object. Then once the data is filtered out from our
    `PagingData`, the new instance is paged to the UI layer and displayed:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要将过滤操作放在 `map` 内部，因为过滤应用于 `PagingData` 对象。然后一旦从我们的 `PagingData` 中过滤出数据，新的实例将被分页到UI层并显示：
- en: '[PRE239]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE243]'
- en: 'Finally, when handling separators in the UI or converting the UI model, the
    most significant steps are ensuring that you do the following:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在处理UI中的分隔符或转换UI模型时，最重要的步骤是确保你做以下事情：
- en: Convert the UI models to accommodate your separator items.
  id: totrans-370
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将UI模型转换为适应你的分隔符项。
- en: Transform the data dynamically and add the separators between presenting and
    loading the data.
  id: totrans-371
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在展示和加载数据之间动态转换数据并添加分隔符。
- en: Update the UI to handle the separator items better.
  id: totrans-372
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新UI以更好地处理分隔符项。
- en: How it works…
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The `PagingData` is encapsulated in a reactive stream; what this means is that
    before loading the data and displaying it to the users, you can incrementally
    apply the transform to the data. Transforming data streams can be crucial when
    you have a complex application, and handling this situation in advance might help
    ensure your application scales better and help minimize the complexity of your
    data growth.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '`PagingData` 被封装在一个响应式流中；这意味着在加载数据并显示给用户之前，你可以逐步将转换应用于数据。在复杂的应用程序中，转换数据流可能至关重要，提前处理这种情况可能会帮助确保你的应用程序更好地扩展，并有助于最小化数据增长复杂性。'
- en: See also
  id: totrans-375
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'It is fair to acknowledge that this recipe cannot cover all the information
    you need to know about transforming the data stream. That said, if you encounter
    an issue and want to learn more, you can always reference the following link to
    learn more about how you can handle separators in the UI and more: [https://developer.android.com/topic/libraries/architecture/paging/v3-transform](https://developer.android.com/topic/libraries/architecture/paging/v3-transform).'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 公平地说，这个菜谱不能涵盖您需要了解的所有关于转换数据流的信息。话虽如此，如果您遇到问题并想了解更多，您始终可以参考以下链接来了解如何处理UI中的分隔符以及更多内容：[https://developer.android.com/topic/libraries/architecture/paging/v3-transform](https://developer.android.com/topic/libraries/architecture/paging/v3-transform)。
- en: Migrating to Paging 3 and understanding the benefits
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 迁移到分页3并了解其优势
- en: You might be using the old Paging version, in this case, Paging 2 or 1, and
    you might be required to migrate to utilize the benefits Paging 3 offers. Paging
    3 offers enhanced functionality and ensures it addresses the most common challenges
    people experience using Paging 2.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能正在使用旧的分页版本，在这种情况下，可能是分页2或1，并且您可能需要迁移以利用分页3提供的好处。分页3提供了增强的功能，并确保它解决了人们在使用分页2时遇到的最常见挑战。
- en: In this recipe, we will look into how you can migrate to the latest recommended
    Paging library.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何迁移到最新推荐的分页库。
- en: Getting ready
  id: totrans-380
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: If your application is already using Paging 3, then you can skip this recipe;
    this step-by-step migration guide is intended for users currently using the older
    versions of the Paging library.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您的应用程序已经使用分页3，那么您可以跳过这个菜谱；这个逐步迁移指南是为目前使用分页库旧版本的用户准备的。
- en: How to do it…
  id: totrans-382
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Migrating from old versions of the Paging library might seem complex due to
    the fact that each application is unique, and complexities might vary. In our
    example, however, we will touch on a low-level kind of migration since our example
    application does not need any migration.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 从旧版本的分页库迁移可能看起来很复杂，因为每个应用程序都是独特的，复杂性可能不同。然而，在我们的例子中，我们将讨论一种低级别的迁移，因为我们的示例应用程序不需要任何迁移。
- en: 'To perform migration from old Paging libraries, follow these steps:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行从旧分页库的迁移，请按照以下步骤操作：
- en: 'The first step is to replace the refresh keys, and this is because we need
    to define how refreshing resumes from the middle of loading data. We will do this
    by first implementing `getRefreshKey()`, which maps the correct initial key using
    `PagingState.anchorPosition` as the recent index:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 第一步是替换刷新键，这是因为我们需要定义如何从加载数据的中间部分恢复刷新。我们将通过首先实现`getRefreshKey()`来完成这项工作，它使用`PagingState.anchorPosition`作为最近索引来映射正确的初始键：
- en: '[PRE244]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE244]'
- en: '[PRE245]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE250]'
- en: 'Next, we need to ensure we replace the positional data source:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保我们替换位置数据源：
- en: '[PRE251]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE253]'
- en: If you are using the old Paging library, the paged data uses `DataSource.map()`,
    `mapByPage`, `Factory.map()`, and `Factory.mapByPage`. In Paging 3, however, all
    these are applied as operators to `PagingData`.
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您正在使用旧的分页库，分页数据使用`DataSource.map()`、`mapByPage`、`Factory.map()`和`Factory.mapByPage`。然而，在分页3中，所有这些都被应用为`PagingData`的操作符。
- en: 'Finally, to ensure you migrate from `PageList`, which is in Paging 2, you will
    need to migrate to `PagingData`. The most notable change is that `PagedList.Config`
    is not `PagingConfig`. In addition, the `Pager()` exposes an observable `Flow<PagingData>`
    with its flow:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，为了确保您从分页2的`PageList`迁移，您需要迁移到`PagingData`。最显著的变化是`PagedList.Config`不是`PagingConfig`。此外，`Pager()`暴露了一个带有其流的可观察的`Flow<PagingData>`：
- en: '[PRE254]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE256]'
- en: '[PRE257]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-404
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE259]'
- en: How it works…
  id: totrans-405
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: To ensure your migration is complete and successful, you must make sure you
    migrate all the significant components from Paging 2\. This includes the `DataSource`
    classes, `PagedList`, and `PagedListAdapter` if your application uses it. Furthermore,
    some Paging 3 components work well with other versions, which simply means it
    is backward compatible.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保您的迁移过程完整且成功，您必须确保从分页2迁移所有重要组件。这包括如果您的应用程序使用它，则必须迁移`DataSource`类、`PagedList`和`PagedListAdapter`。此外，一些分页3组件与其他版本兼容良好，这意味着它是向后兼容的。
- en: The most notable change to `PagingSource` in Paging 3 is that it combines all
    the loading functions into one, now called `load()` in `PagingSource`. This ensures
    there is no redundancy in the code because the loading logic is often identical
    to the old API. In addition, the loading function parameters in Paging 3 now use
    the `LoadParams` sealed class, which has subclasses for each load type.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在Paging 3中，对`PagingSource`最显著的变化是它将所有加载函数合并为一个，现在在`PagingSource`中称为`load()`。这确保了代码中没有冗余，因为加载逻辑通常与旧API相同。此外，Paging
    3中加载函数的参数现在使用`LoadParams`密封类，它为每种加载类型都有子类。
- en: In `PagedList`, which is used in Paging 2, when you migrate, you might use `PagingData`
    and `Pager`. When you start to use `PagingData` from Paging 3, you should ensure
    that the configuration is moved from the old `PagedList.Config` to `PagingConfig`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在Paging 2中使用的`PagedList`，当你迁移时，你可能会使用`PagingData`和`Pager`。当你开始从Paging 3使用`PagingData`时，你应该确保配置已从旧的`PagedList.Config`移动到`PagingConfig`。
- en: Writing tests for your Paging Source
  id: totrans-409
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为你的Paging Source编写测试
- en: Writing tests for your implementations is crucial. We will write unit tests
    for our `PagingSource` implementation in this recipe to test our logic. Some tests
    that might be worth writing are checking when news Paging load failure happens.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 为你的实现编写测试至关重要。在这个食谱中，我们将为我们的`PagingSource`实现编写单元测试来测试我们的逻辑。一些可能值得编写的测试是检查新闻Paging加载失败的情况。
- en: We can also test the success state and more. You can follow the pattern to write
    tests for your project or use case.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以测试成功状态等。你可以遵循这个模式为你的项目或用例编写测试。
- en: Getting ready
  id: totrans-412
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To follow this recipe step by step, you need to have followed the *Implementing
    the Jetpack Paging library* recipe, and you need to use the `PagingJetpackExample`
    project.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 要逐步遵循这个食谱，你需要已经遵循了*实现Jetpack Paging库*的食谱，并且你需要使用`PagingJetpackExample`项目。
- en: How to do it…
  id: totrans-414
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Open `PagingJetpackExample` and follow along with this project to add unit
    tests:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`PagingJetpackExample`，并跟随这个项目添加单元测试：
- en: 'Add the following testing libraries to your `build.gradle` app:'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下测试库添加到你的`build.gradle`应用中：
- en: '[PRE260]'
  id: totrans-417
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-419
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE263]'
- en: After adding the dependencies, create a new package and call it `data` in your
    `test` package in the project structure. You can reference the *Understanding
    the Android project structure* recipe in [*Chapter 1*](B18827_01.xhtml#_idTextAnchor014),
    *Getting Started with Modern Android Development Skills*, if you need help finding
    the folder.
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加依赖项后，在项目结构中`test`包中创建一个新的包，并将其命名为`data`。如果你需要帮助找到文件夹，可以参考[*第1章*](B18827_01.xhtml#_idTextAnchor014)，*现代Android开发技能入门*中的*理解Android项目结构*食谱。
- en: Create a test class and call it `NewsArticlePagingSourceTest`.
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个测试类，并将其命名为`NewsArticlePagingSourceTest`。
- en: 'Inside the class, let’s go ahead and add `Mock` to mock our `ApiService` interface
    and create a `lateinit var newsApiService` that we will initialize at our `@``Before`
    step:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类内部，让我们继续添加`Mock`来模拟我们的`ApiService`接口，并创建一个`lateinit var newsApiService`，我们将在`@Before`步骤中初始化它：
- en: '[PRE264]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-425
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE266]'
- en: 'Now let’s go ahead and create our `@Before` so we can run our `CoroutineDispatchers`,
    which is used by all standard builders such as async, and launch to our `@Before`
    step too:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们继续创建我们的`@Before`，这样我们就可以运行我们的`CoroutineDispatchers`，它被所有标准构建器（如async）和启动到我们的`@Before`步骤：
- en: '[PRE267]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE268]'
- en: '[PRE269]'
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-432
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE272]'
- en: 'The first test we will need to write is to check when a failure happens. Hence
    let’s go ahead and set up our test. A `403` response is a forbidden status code
    indicating the server understood your request but did not authorize it:'
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要编写的第一个测试是检查失败发生的情况。因此，让我们继续设置我们的测试。`403`响应是一个禁止状态码，表示服务器理解了你的请求但没有授权它：
- en: '[PRE273]'
  id: totrans-435
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-436
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-437
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-439
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-441
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-442
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE281]'
- en: 'To continue our test, we will need to use `Mockito.doThrow(error)`:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了继续我们的测试，我们需要使用`Mockito.doThrow(error)`：
- en: '[PRE282]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE282]'
- en: '[PRE283]'
  id: totrans-446
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-448
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-449
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE286]'
- en: 'Then, finally, we trigger `PagingSource.LoadResult.Error` and pass in the type,
    then assert:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，最后，我们触发`PagingSource.LoadResult.Error`并传入类型，然后断言：
- en: '[PRE287]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE288]'
- en: '[PRE289]'
  id: totrans-453
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-455
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE291]'
- en: '[PRE292]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-457
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-459
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE296]'
- en: 'You can add two more additional tests and then add `tearDown` to clean up the
    coroutines:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以添加两个额外的测试，然后添加`tearDown`来清理协程：
- en: '[PRE297]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE300]'
- en: How it works…
  id: totrans-466
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'We use `Mock` in unit tests, and the general idea is based on the notion that
    the objects under tests might have dependencies on other complex objects. Based
    on this, it is much easier to isolate the behavior of the object we want by mocking
    the object, which ensures it has the same behavior as our real object and makes
    testing easier:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在单元测试中使用`Mock`，其基本思想是基于测试对象可能依赖于其他复杂对象的观念。基于这一点，通过模拟对象，我们可以更容易地隔离我们想要的对象的行为，这确保了它具有与我们的真实对象相同的行为，从而使测试变得更容易：
- en: '[PRE301]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: 'Our `lateinit var newsPagingSource: NewsArticlePagingSource` is used for late
    initialization, and we initialize it on our `@``Before` function.'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '我们的`lateinit var newsPagingSource: NewsArticlePagingSource`用于延迟初始化，我们是在`@``Before`函数中对其进行初始化的。'
