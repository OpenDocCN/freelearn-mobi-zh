- en: '*Chapter 9*: Implementing an MVI Architecture'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第9章*：实现MVI架构'
- en: In this chapter, we will introduce the concept of **Model-View-Intent** (**MVI**)
    and the benefits it provides for managing the state of an application. We will
    begin by analyzing what MVI is and then move on to implementing it using Kotlin
    flows. In this chapter's exercise, we will build upon the previous chapter's exercises,
    and we will re-implement them using the MVI pattern to highlight how this pattern
    can be integrated into the presentation layer of an application with multiple
    modules.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**模型-视图-意图**（**MVI**）的概念以及它为管理应用程序状态提供的优势。我们将从分析MVI是什么开始，然后继续使用Kotlin流来实现它。在本章的练习中，我们将基于上一章的练习，并使用MVI模式重新实现它们，以突出这种模式如何集成到具有多个模块的应用程序的表现层。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing MVI
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍MVI
- en: Implementing MVI with Kotlin flows
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Kotlin流实现MVI
- en: By the end of the chapter, you will be able to implement the MVI architecture
    pattern inside a multimodule Android application, using Kotlin flows.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够使用Kotlin流在多模块Android应用程序中实现MVI架构模式。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The hardware and software requirements are as follows:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 硬件和软件要求如下：
- en: Android Studio Arctic Fox 2020.3.1 patch 3
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Android Studio Arctic Fox 2020.3.1补丁3
- en: 'The code files for this chapter can be found here: [https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在以下位置找到：[https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9](https://github.com/PacktPublishing/Clean-Android-Architecture/tree/main/Chapter9).
- en: 'Check out the following video to see the Code in Action: [https://bit.ly/3FYZKLn](https://bit.ly/3FYZKLn)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际应用：[https://bit.ly/3FYZKLn](https://bit.ly/3FYZKLn)
- en: Introducing MVI
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MVI
- en: In this section, we will look at what the MVI architecture pattern is, the problems
    it is trying to solve, and the solutions it presents for solving those problems.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨MVI架构模式是什么，它试图解决的问题，以及它为解决这些问题提供的解决方案。
- en: Let's imagine you need to develop a configuration screen for an application.
    It will load the existing configuration and it will need to toggle various switches
    and prepopulate input fields with the existing data. After that data is loaded,
    then the user can modify each of those fields. To achieve this, you would probably
    need to keep mutable references for the data represented in those fields so that
    when the user changes a value, the reference changes.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们假设你需要为应用程序开发一个配置屏幕。它将加载现有配置，并需要切换各种开关，以及使用现有数据预填充输入字段。在加载数据之后，用户可以修改这些字段中的每一个。为了实现这一点，你可能需要保留这些字段所表示数据的可变引用，以便当用户更改值时，引用会发生变化。
- en: This may pose a problem because of the mutability of those fields, especially
    when dealing with concurrent operations or their order. A solution to this problem
    is to make the data immutable and combine it into a state that the user interface
    can observe. Any changes the app or user will need to make on the user interfaces
    will be through a reactive data flow. The flow will then create a new state representing
    the change and update the user interface.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能由于这些字段的可变性而引发问题，尤其是在处理并发操作或它们的顺序时。解决这个问题的一种方法是将数据设置为不可变，并将其组合成一个用户界面可以观察的状态。应用或用户需要对用户界面进行的任何更改将通过响应式数据流来完成。然后，该流将创建一个新的状态来表示更改并更新用户界面。
- en: 'This is essentially how MVI operates. In MVI, the **View** plays the same role
    as in MVP or MVVM and the **Model** holds the state of the user interface, and
    it represents the single source of truth. The **Intent** is represented by any
    changes that should be made to the state, which will then be updated. In *Figure
    9.1*, we can see how the **View** will send an **Intent** to the **Model**, which
    will then trigger a change in state, which will update the **View**:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 这基本上是MVI的工作方式。在MVI中，**视图**扮演着与MVP或MVVM中相同的角色，而**模型**持有用户界面的状态，并且代表单一的真实来源。**意图**表示对状态的任何更改，这将随后被更新。在*图9.1*中，我们可以看到**视图**将向**模型**发送**意图**，然后**模型**将触发状态的变化，这将更新**视图**：
- en: Note
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The term Intent in the context of MVI is different from the Android `Intent`
    class used to interact with different Android components.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVI的上下文中，术语“意图”与用于与不同Android组件交互的Android `Intent`类不同。
- en: '![Figure 9.1 – MVI diagram'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.1 – MVI图'
- en: '](img/Figure_9.01_B18320.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.01_B18320.jpg)'
- en: Figure 9.1 – MVI diagram
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – MVI 图
- en: What is missing from this diagram is the equivalent of a **ViewModel** or a
    **Presenter**. This is because the MVI pattern isn't a replacement for those patterns
    but instead builds on top of them.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这个图中缺少的是 **ViewModel** 或 **Presenter** 的等效物。这是因为 MVI 模式不是这些模式的替代品，而是建立在它们之上的。
- en: 'To visualize how this might look, let''s look at an example of a `ViewModel`:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了可视化这可能是什么样子，让我们看看一个 `ViewModel` 的例子：
- en: '[PRE0]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the preceding example, we define a class named `MyViewModel` in which we
    have a use case to load data and a `text` variable that will be changed by the
    View when the user changes it. We can see that the `text` variable is a mutable
    variable accessible from the `StateFlow` variable holding the data to be loaded
    and we have a method to load the data. To transition the preceding code to MVI,
    we will need to first define a state that will hold the data to be loaded and
    the text. This will represent our source of truth. For the preceding example,
    this state will look as in the following example:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了一个名为 `MyViewModel` 的类，其中包含一个加载数据的使用案例和一个 `text` 变量，该变量将在用户更改它时由视图进行更改。我们可以看到，`text`
    变量是一个可变的变量，可以从持有要加载数据的 `StateFlow` 变量中访问，并且我们有一个加载数据的方法。要将前面的代码过渡到 MVI，我们首先需要定义一个将持有要加载数据和文本的状态。这将代表我们的真相来源。对于前面的例子，这个状态将如下所示：
- en: '[PRE1]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `MyState` class, we move the data to be loaded and the text to be changed.
    Now, we will need to identify the actions; in this case, we have two actions:
    loading the data and updating the value of the text with a new value introduced
    by the user:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MyState` 类中，我们将要加载数据和要更改的文本移动。现在，我们需要识别动作；在这种情况下，我们有两个动作：加载数据和用用户引入的新值更新文本的值：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In the preceding example, we have represented the action as a sealed class
    and defined two actions for loading and updating the text. Next, we will need
    to create the appropriate data flows for handling the actions and managing the
    state:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将动作表示为一个密封类，并定义了两个动作：加载数据和更新文本。接下来，我们需要创建适当的数据流来处理动作和管理状态：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the preceding example, we have changed the `StateFlow` variables to hold
    the state object defined previously and added a similar `SharedFlow` variable,
    which will be responsible for managing the actions inserted by the user. We will
    now need to subscribe and handle the actions:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将 `StateFlow` 变量更改为持有之前定义的状态对象，并添加了一个类似的 `SharedFlow` 变量，该变量将负责管理用户插入的动作。我们现在需要订阅并处理这些动作：
- en: '[PRE4]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the `init` block, we are collecting the actions and then, for each action,
    we perform the required operation. The View will invoke the `submitAction` method
    and pass the action it wants the ViewModel to perform. For this example, `MyAction`
    plays the role of the Intent within the MVI context and the ViewModel will sit
    between the View and Model and will be responsible for managing the flow of data
    between the Model and the View, as well as managing the state.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `init` 块中，我们正在收集动作，然后，对于每个动作，我们执行所需的操作。视图将调用 `submitAction` 方法，并传递它希望 ViewModel
    执行的动作。对于这个例子，`MyAction` 在 MVI 上下文中扮演 Intent 的角色，而 ViewModel 将位于视图和模型之间，并负责管理模型和视图之间的数据流，以及管理状态。
- en: When it comes to the implementation of the MVI pattern, there are many different
    variations for different technologies and different architecture patterns. From
    RxJava to `LiveData`, to flows and coroutines, to MVVM and MVP, there are different
    approaches to the pattern with different variations.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到 MVI 模式的实现时，针对不同的技术和不同的架构模式有许多不同的变体。从 RxJava 到 `LiveData`，再到流和协程，到 MVVM
    和 MVP，都有不同的方法来实现这个模式，并且有不同的变体。
- en: Some are built using concepts such as state machines, others use basic streams,
    and others use third-party open source libraries. From the preceding example,
    we can see that the pattern introduces a little bit of boilerplate code, so it
    is important to perform research and monitor the initial introduction of the pattern
    into any application. In the section that follows, we will look at how we can
    implement MVI using Kotlin flows.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 有些是使用诸如状态机等概念构建的，有些使用基本的流，还有些使用第三方开源库。从前面的例子中，我们可以看到这个模式引入了一些样板代码，因此在进行研究并监控任何应用程序中模式的初始引入时非常重要。在接下来的部分中，我们将探讨如何使用
    Kotlin 流实现 MVI。
- en: Implementing MVI with Kotlin flows
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Kotlin 流实现 MVI
- en: In this section, we will look at how we can implement the MVI architecture pattern
    using Kotlin flows and the benefits and pitfalls of this approach.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨如何使用Kotlin流实现MVI架构模式，以及这种方法的优势和劣势。
- en: 'In the previous section, we defined an MVI approach using `StateFlow` and `SharedFlow`,
    as in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的章节中，我们定义了一个使用`StateFlow`和`SharedFlow`的MVI方法，如下例所示：
- en: '[PRE5]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The different types of flows used here serve different purposes. `MutableStateFlow`
    will emit the last value held, which is good for the user interface because we
    want it to display the last data loaded, like how `LiveData` works. `SharedFlow`
    doesn''t have this feature, which is useful for actions because we do not want
    the last action to be emitted twice. Another aspect we will need to consider is
    one-shot events, which should be emitted using a channel flow. This will be useful
    when the View will need to respond to events in a channel to display a toast alert
    or handle navigation to a new screen. We can apply this using the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用的不同类型的流服务于不同的目的。`MutableStateFlow`会发出它持有的最后一个值，这对于用户界面来说很好，因为我们希望它显示最后加载数据，就像`LiveData`的工作方式一样。`SharedFlow`没有这个特性，这对于动作来说很有用，因为我们不希望最后一个动作被发射两次。我们还需要考虑的另一个方面是单次事件，这些事件应该使用通道流来发射。这将在视图需要响应通道中的事件以显示吐司警报或处理导航到新屏幕时很有用。我们可以使用以下方式来实现：
- en: '[PRE6]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the preceding example, we have integrated the `Channel` information with
    the rest of the `ViewModel`. Because an application will end up having multiple
    ViewModels, we can create a template that will be used across the application.
    We can start by defining abstractions for each of the state, action, and one-off
    events:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们将`Channel`信息与`ViewModel`的其余部分集成在一起。因为一个应用程序最终会有多个`ViewModel`，我们可以创建一个将在整个应用程序中使用的模板。我们可以从为每个状态、动作和一次性事件定义抽象开始：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Here, we have opted for a simple interface to represent each of the flows of
    data the `ViewModel` will use. We can next define a template for the `ViewModel`,
    which can be inherited by the ViewModels used in the application:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们选择了一个简单的接口来表示`ViewModel`将使用的数据流中的每一个。接下来，我们可以定义`ViewModel`的模板，该模板可以被应用程序中使用的`ViewModel`继承：
- en: '[PRE8]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the preceding example, we have used generics for each of the flows that
    the `ViewModel` will use. This creates a problem for `MutableStateFlow`, which
    requires an initial value. Because we don''t have any concrete value to initialize,
    we will need to create an abstract method that will provide the initial value:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们为`ViewModel`将使用的每个流使用了泛型。这为`MutableStateFlow`创建了一个问题，因为它需要一个初始值。因为我们没有具体的值来初始化，我们需要创建一个提供初始值的抽象方法：
- en: '[PRE9]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In addition to the `initState` abstraction, we have also added the `handleAction`
    abstraction. This will be called when new actions are submitted because of user
    actions or a screen load. Because the mutable variables are set to private, we
    will need to expose methods that emit events into these flows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`initState`抽象之外，我们还添加了`handleAction`抽象。当因为用户操作或屏幕加载提交新动作时，将调用此方法。由于可变变量被设置为私有，我们需要公开方法来将这些事件发射到这些流中：
- en: '[PRE10]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the preceding example, we have added the methods that emit, send, or change
    the value on each of the specific data flows. To implement the template for a
    specific scenario, we will need to create concretions for `UiState`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们添加了在每个特定数据流上发射、发送或更改值的方法。为了实现特定场景的模板，我们需要为`UiState`创建具体实现：
- en: '[PRE11]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the preceding example, we have defined different states that the screen
    might have. We can now create a concretion for `UiAction`:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们定义了屏幕可能具有的不同状态。现在，我们可以为`UiAction`创建具体实现：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we defined an action for when the data will need to be loaded and another
    for when something is clicked on the user interface:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个当需要加载数据时的动作，以及当用户界面上点击时的另一个动作：
- en: '[PRE13]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'For the single event fired, we have defined a show toast alert event. Finally,
    we can implement the concretion for the `ViewModel`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 对于单次触发的事件，我们定义了一个显示吐司警报的事件。最后，我们可以实现`ViewModel`的具体实现：
- en: '[PRE14]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In the preceding example, we have extended the `MviViewModel` class and passed
    `MyUiState`, `MyUiAction`, and `MyUiSingleEvent` for the generics. In the `initState`
    method, we return the `Loading` state, and in the `handleAction` method, we check
    the actions and then load the data or handle the click event, which will then
    submit the event to show a toast alert.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们扩展了 `MviViewModel` 类，并为泛型传递了 `MyUiState`、`MyUiAction` 和 `MyUiSingleEvent`。在
    `initState` 方法中，我们返回 `Loading` 状态，并在 `handleAction` 方法中检查操作，然后加载数据或处理点击事件，然后提交事件以显示
    toast 提醒。
- en: 'If we want to integrate the `ViewModel` with Jetpack Compose, we will have
    to use something like the following example:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要将 `ViewModel` 与 Jetpack Compose 集成，我们将不得不使用如下示例：
- en: '[PRE15]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can see that observing `UiState` will remain the same as for MVVM; however,
    if we wish to notify the `ViewModel` of any changes, we will need to use the `submitAction`
    method. For the `UiSingleEvents` object, we will need to use the `LaunchedEffect`
    function because we don''t want Jetpack Compose to keep recomposing and re-executing
    the same block; we only want it to be executed once, so we will need to use something
    such as the following:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到，观察 `UiState` 将与 MVVM 相同；然而，如果我们希望通知 `ViewModel` 任何更改，我们将需要使用 `submitAction`
    方法。对于 `UiSingleEvents` 对象，我们需要使用 `LaunchedEffect` 函数，因为我们不希望 Jetpack Compose 持续重新组合和重新执行相同的代码块；我们只想执行一次，因此我们需要使用如下所示的内容：
- en: '[PRE16]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In this example, we collect the data from `Channel` inside the `LaunchedEffect`
    method and then show a toast alert when the `ShowToast` event is received. `LaunchedEffect`
    can also be used to ensure that we do not trigger multiple data loads because
    of the Jetpack Compose recomposition mechanism:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们在 `LaunchedEffect` 方法内部从 `Channel` 收集数据，并在接收到 `ShowToast` 事件时显示一个 toast
    提醒。`LaunchedEffect` 还可以用来确保我们不会因为 Jetpack Compose 的重新组合机制而触发多次数据加载：
- en: '[PRE17]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In the preceding snippet, we have moved the call to `submitAction` inside `LaunchedEffect`,
    to avoid triggering the loading multiple times. More information about Jetpack
    Compose side effects can be found here: [https://developer.android.com/jetpack/compose/side-effects](https://developer.android.com/jetpack/compose/side-effects).'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将对 `submitAction` 的调用移动到了 `LaunchedEffect` 内部，以避免多次触发加载。有关 Jetpack
    Compose 侧效应的更多信息，请参阅此处：[https://developer.android.com/jetpack/compose/side-effects](https://developer.android.com/jetpack/compose/side-effects)。
- en: In this section, we have shown how we can integrate the MVI architecture pattern
    with flows and Jetpack Compose. We have seen how we have translated the interactions
    between the View and the `ViewModel` into intents using the `UiAction` interface
    and the implementations of this interface. We have also seen some of the downsides
    of the pattern because of the addition of boilerplate code and, in the case of
    Jetpack Compose, having to use methods such as `LaunchedEffect` and `Channel`
    for emitting one-off events. In the following section, we will create an application
    in which we will migrate a previous exercise to use MVI.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们展示了如何将 MVI 架构模式与流程和 Jetpack Compose 集成。我们看到了如何使用 `UiAction` 接口及其实现将视图和
    `ViewModel` 之间的交互转换为意图。我们还看到了由于添加了样板代码，以及在使用 Jetpack Compose 时需要使用 `LaunchedEffect`
    和 `Channel` 等方法来发出一次性事件，该模式的一些缺点。在下一节中，我们将创建一个应用程序，我们将迁移一个之前的练习以使用 MVI。
- en: Exercise 09.01 – Transitioning to MVI
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 09.01 – 转向 MVI
- en: Modify *Exercise 08.02 – Multi-module data presentation* from [*Chapter 8*](B18320_08_ePub.xhtml#_idTextAnchor090),
    *Implementing an MVVM Architecture*, so that the presentation layer uses the MVI
    architecture pattern. The `UiState` class will remain and represent the state
    of each screen. New interfaces will be added in the `presentation-common` module
    representing actions and one-off events. In the same module, an `MviViewModel`
    abstract class will be implemented, which will be the template for the other ViewModels
    used in the application. For `PostListViewModel`, we will create new user actions
    for loading the data, clicking on the post, and clicking on the author, and two
    new one-off events will be needed for opening each of those screens. For `PostViewModel`
    and `UserViewModel`, we will create only a single user action, which will be responsible
    for loading the data on each screen.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 *第 8 章 08.02 – 多模块数据展示*，从 [*第 8 章*](B18320_08_ePub.xhtml#_idTextAnchor090)，*实现
    MVVM 架构*，以便表示层使用 MVI 架构模式。`UiState` 类将保持不变，代表每个屏幕的状态。在 `presentation-common` 模块中，将添加新的接口来表示操作和一次性事件。在同一模块中，将实现
    `MviViewModel` 抽象类，它将是应用程序中其他 `ViewModel` 使用的模板。对于 `PostListViewModel`，我们将创建用于加载数据、点击帖子以及点击作者的新用户操作，并且需要两个新的一次性事件来打开这些屏幕。对于
    `PostViewModel` 和 `UserViewModel`，我们将创建单个用户操作，该操作将负责在屏幕上加载数据。
- en: 'To complete this exercise, you will need to do the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，你需要做以下事情：
- en: In `presentation-common`, create an interface called `UiAction` and an interface
    called `UiSingleEvent`, and then create the `MviViewModel` template.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-common` 中，创建一个名为 `UiAction` 的接口和一个名为 `UiSingleEvent` 的接口，然后创建
    `MviViewModel` 模板。
- en: In the `list` package of the `presentation-post` module, create a sealed class
    called `PostListUiAction`, which will contain three subclasses called `Load`,
    `UserClick`, and `PostClick`. Then, create a sealed class called `PostListUiSingleEvent`,
    which will have two subclasses named `OpenUserScreen` and `OpenPostScreen`. Then,
    modify `PostListViewModel` and `PostListScreen` to use the specified actions and
    events.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-post` 模块的 `list` 包中，创建一个名为 `PostListUiAction` 的密封类，它将包含三个子类，分别称为
    `Load`、`UserClick` 和 `PostClick`。然后，创建一个名为 `PostListUiSingleEvent` 的密封类，它将有两个子类，分别称为
    `OpenUserScreen` 和 `OpenPostScreen`。然后，修改 `PostListViewModel` 和 `PostListScreen`
    以使用指定的操作和事件。
- en: In the `single` package of the `presentation-post` module, create a sealed class
    called `PostUiAction`, which will have one subclass named `Load`, which will contain
    the ID of the post. Then, modify `PostViewModel` and `PostScreen` to instead use
    the specified action.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-post` 模块的 `single` 包中，创建一个名为 `PostUiAction` 的密封类，它将有一个名为 `Load`
    的子类，该子类将包含帖子的 ID。然后，修改 `PostViewModel` 和 `PostScreen` 以使用指定的操作。
- en: In the `single` package of the `presentation-user` module, create a sealed class
    called `UserUiAction`, which will have one subclass named `Load`, which will contain
    the ID of the user. Then, modify `UserViewModel` and `UserScreen` to instead use
    the specified action.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-user` 模块的 `single` 包中，创建一个名为 `UserUiAction` 的密封类，它将有一个名为 `Load`
    的子类，该子类将包含用户的 ID。然后，修改 `UserViewModel` 和 `UserScreen` 以使用指定的操作。
- en: 'Follow these steps to complete the exercise:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成练习：
- en: 'In the state package of the `presentation-common` module, create an interface
    called `UiAction`:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-common` 模块的 `状态` 包中，创建一个名为 `UiAction` 的接口：
- en: '[PRE18]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the same package, create an interface called `UiSingleEvent`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为 `UiSingleEvent` 的接口：
- en: '[PRE19]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'In the same package, create an abstract class called `MviViewModel`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，创建一个名为 `MviViewModel` 的抽象类：
- en: '[PRE20]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Because we are using the `UiState` class with generics, we will need to also
    supply that generic field in the generic specification of `MviViewModel`.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在使用泛型的 `UiState` 类，因此我们还需要在 `MviViewModel` 的泛型规范中提供该泛型字段。
- en: 'In the `MviViewModel` class, add the necessary flows and channels that will
    hold the states, actions, and events:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MviViewModel` 类中，添加必要的流程和通道，以保存状态、操作和事件：
- en: '[PRE21]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In this snippet, we have defined `StateFlow` variables to hold the last value
    that was emitted, which will be used to manage the state of the user interface,
    `SharedFlow`, which is used for handling user actions, and `Channel` for handling
    emitting one-off events. In the `MviViewModel` class, we are also defining generics
    so that we bind states, actions, and one-off events to their respective types.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了 `StateFlow` 变量来保存最后发出的值，这将用于管理用户界面的状态，`SharedFlow` 用于处理用户操作，以及
    `Channel` 用于处理一次性事件。在 `MviViewModel` 类中，我们还定义了泛型，以便将状态、操作和一次性事件绑定到它们各自的数据类型。
- en: 'In `MviViewModel`, add the abstract methods for initializing the state and
    handling the actions:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MviViewModel` 中添加初始化状态和处理操作的抽象方法：
- en: '[PRE22]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In this snippet, we are adding the abstraction required to provide an initial
    value for `StateFlow`, and then we handle the collection of the user actions,
    which will be handled in the `handleAction` method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们添加了提供 `StateFlow` 初始值的抽象，然后处理用户操作的收集，这些操作将在 `handleAction` 方法中处理。
- en: 'In `MviViewModel`, add the required methods to submit the state, events, and
    actions:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MviViewModel` 中添加提交状态、事件和操作的必需方法：
- en: '[PRE23]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In this snippet, we are defining a set of methods to emit data into the two
    `Flow` objects and the `Channel` object.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们定义了一组方法，用于将数据发射到两个 `Flow` 对象和一个 `Channel` 对象。
- en: 'In the `list` package of the `presentation-post` module, create the `PostListUiAction`
    class and its subclasses:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `presentation-post` 模块的 `list` 包中创建 `PostListUiAction` 类及其子类：
- en: '[PRE24]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Here, we define a sealed class for loading the data and clicking on the user
    and the post. Each of them will implement the `UiAction` interface.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个密封类，用于加载数据和点击用户和帖子。每个都将实现 `UiAction` 接口。
- en: 'In the same package, create the `PostListUiAction` class and its subclasses:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的包中创建 `PostListUiAction` 类及其子类：
- en: '[PRE25]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, we define a sealed class for the one-off events that will be emitted when
    we want the user and post screens to be opened, which is why we are implementing
    `UiSingleEvent`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个密封类，用于在需要打开用户和帖子屏幕时发出一次性事件，这就是为什么我们实现了 `UiSingleEvent`。
- en: 'In the same package, modify `PostListViewModel` to extend `MviViewModel`:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在相同的包中，修改 `PostListViewModel` 以扩展 `MviViewModel`：
- en: '[PRE26]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: In this snippet, we are extending `MviViewModel` and providing the types we
    defined previously as well as the existing `PostListModel` type to the generic
    fields. This is because we want this `ViewModel` to be bound to the data, actions,
    and one-off events that occur in `PostListScreen`.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们扩展了 `MviViewModel` 并将之前定义的类型以及现有的 `PostListModel` 类型提供给泛型字段。这是因为我们希望这个
    `ViewModel` 能够绑定到在 `PostListScreen` 中发生的数据、操作和一次性事件。
- en: 'Implement the `initState` method in the `PostListViewModel` class:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostListViewModel` 类中实现 `initState` 方法：
- en: '[PRE27]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: In this snippet, we are implementing the `initState` method and providing the
    `UiState.Loading` value, which will in turn make the `uiStateFlow` field from
    the parent class be initialized with the `Loading` value.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们实现了 `initState` 方法，并提供了 `UiState.Loading` 值，这将反过来使父类的 `uiStateFlow`
    字段初始化为 `Loading` 值。
- en: 'Implement the `handleAction` method in the `PostListViewModel` class:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostListViewModel` 类中实现 `handleAction` 方法：
- en: '[PRE28]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In this snippet, we are implementing the `handleAction` method, which will check
    what action we will need to handle and perform the necessary operation for each.
    For loading, we will invoke the `loadPosts` method, and for clicking on a user
    and a post, we will invoke the `updateInteraction` method and then submit a one-off
    event to open the user and post screens.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们实现了 `handleAction` 方法，它将检查我们需要处理哪些操作，并为每个操作执行必要的操作。对于加载，我们将调用 `loadPosts`
    方法；对于点击用户和帖子，我们将调用 `updateInteraction` 方法，然后提交一个一次性事件以打开用户和帖子屏幕。
- en: 'Implement the `loadPosts` method in the `PostListViewModel` class:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostListViewModel` 类中实现 `loadPosts` 方法：
- en: '[PRE29]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this snippet, we load the data from `GetPostsWithUsersWithInteractionUseCase`
    and collect it and update `uiStateFlow` through the `submitState` method inherited
    from the parent class.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们从 `GetPostsWithUsersWithInteractionUseCase` 加载数据，并通过从父类继承的 `submitState`
    方法收集并更新 `uiStateFlow`。
- en: 'Implement the `updateInteraction` method in the `PostListViewModel` class:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PostListViewModel` 类中实现 `updateInteraction` 方法：
- en: '[PRE30]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this method, we implement the `updateInteraction` method, which will submit
    a new value with an incremented click count using `UpdateInteractionUseCase`.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个方法中，我们实现了 `updateInteraction` 方法，它将使用 `UpdateInteractionUseCase` 提交一个带有递增点击次数的新值。
- en: 'Modify the `PostListScreen` method in the `PostListScreen` file in the `list`
    package in the `presentation-post` module so that it will instead use the `submitAction`
    method:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`presentation-post`模块中`list`包下的`PostListScreen`文件中的`PostListScreen`方法，使其改用`submitAction`方法：
- en: '[PRE31]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Here, we are changing how we interact with `PostListViewModel`. Instead of invoking
    each separate method for loading and updating the interaction, we instead use
    the `submitAction` method from `MviViewModel`. In order to load the data, we are
    using `LaunchedEffect` so that when Jetpack Compose triggers recomposition, the
    data load won't be retriggered. We are also subscribing to `uiStateFlow` instead
    of `postListFlow`, which no longer exists.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们正在改变与`PostListViewModel`的交互方式。我们不是为加载和更新交互调用每个单独的方法，而是使用`MviViewModel`中的`submitAction`方法。为了加载数据，我们使用`LaunchedEffect`，这样当Jetpack
    Compose触发重新组合时，数据加载不会被重新触发。我们还订阅了`uiStateFlow`而不是`postListFlow`，后者不再存在。
- en: 'In the same method, subscribe to `singleEventFlow` so that it opens `PostScreen`
    and `UserScreen` when the appropriate events are received:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一方法中，订阅`singleEventFlow`，以便在接收到适当的事件时打开`PostScreen`和`UserScreen`：
- en: '[PRE32]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: In this snippet, we will need to monitor the events from `singleEventFlow` and
    then check the events emitted and open the appropriate screen.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们需要监控`singleEventFlow`的事件，然后检查发出的事件并打开适当的屏幕。
- en: 'In the `single` package of the `presentation-post` module, create the `PostUiAction`
    class and its subclass:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-post`模块的`single`包中，创建`PostUiAction`类及其子类：
- en: '[PRE33]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'In the same package, modify `PostViewModel` so that it extends `MviViewModel`:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，修改`PostViewModel`使其扩展`MviViewModel`：
- en: '[PRE34]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, we are using the newly created `PostUiAction`, but because we have no
    one-off events to subscribe to, we will use the `UiSingleEvent` interface.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用新创建的`PostUiAction`，但由于我们没有一次性事件来订阅，我们将使用`UiSingleEvent`接口。
- en: 'In the same class, implement the `initState` and `handleAction` methods:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，实现`initState`和`handleAction`方法：
- en: '[PRE35]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, we are implementing the `initState` method and returning the `UiState.Loading`
    value and the `handleAction` method. For `handleAction`, we only have the action
    to load the data, which will use `GetPostUseCase` to retrieve the post data and
    then update `uiStateFlow` through the `submitState` method.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们实现`initState`方法并返回`UiState.Loading`值，以及`handleAction`方法。对于`handleAction`，我们只有加载数据的操作，这将使用`GetPostUseCase`检索帖子数据，然后通过`submitState`方法更新`uiStateFlow`。
- en: 'Modify the `PostScreen` method from the `PostScreen` file in the `single` package
    in the `presentation-post` module so that it instead uses the `Load` action:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`presentation-post`模块中`single`包下的`PostScreen`文件中的`PostScreen`方法，使其改用`Load`操作：
- en: '[PRE36]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this snippet, we are following the same principle as in `PostListScreen`
    where we replace the interaction with `PostViewModel` to use the `submitAction`
    method and use `LaunchedEffect` to isolate the data loading.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循与`PostListScreen`相同的原理，在那里我们将与`PostViewModel`的交互替换为使用`submitAction`方法，并使用`LaunchedEffect`来隔离数据加载。
- en: 'In the `single` package of the `presentation-user` module, create the `UserUiAction`
    class and its subclass:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`presentation-user`模块的`single`包中，创建`UserUiAction`类及其子类：
- en: '[PRE37]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In the same package, modify `UserViewModel` so that it extends the `MviViewModel`
    class:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一包中，修改`UserViewModel`使其扩展`MviViewModel`类：
- en: '[PRE38]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Here, we are using the newly created `UserUiAction`, but because we have no
    one-off events to subscribe to, we will use the `UiSingleEvent` interface.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用新创建的`UserUiAction`，但由于我们没有一次性事件来订阅，我们将使用`UiSingleEvent`接口。
- en: 'In the same class, implement the `initState` and `handleAction` methods:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一类中，实现`initState`和`handleAction`方法：
- en: '[PRE39]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Here, we are following the same principle as for `PostViewModel`, which is to
    implement the `initState` method to return `UiState.Loading`, then in `handleAction`,
    we check the type, and for the `Load` action, we load the user information.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们遵循与`PostViewModel`相同的原理，即实现`initState`方法以返回`UiState.Loading`，然后在`handleAction`中检查类型，对于`Load`操作，我们加载用户信息。
- en: 'Modify the `UserScreen` method from the `UserScreen` file in the `single` package
    in the `presentation-user` module so that it instead uses the `Load` action:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`presentation-user`模块中`single`包下的`UserScreen`文件中的`UserScreen`方法，使其改用`Load`操作：
- en: '[PRE40]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In this snippet, we are following the same principle as in `PostScreen` where
    we replace the interaction with `UserViewModel` to use the `submitAction` method
    and use `LaunchedEffect` to isolate the data loading.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个片段中，我们遵循与`PostScreen`相同的原理，将`UserViewModel`的交互替换为使用`submitAction`方法，并使用`LaunchedEffect`来隔离数据加载。
- en: 'If we run the application, we will see the same output as in *Exercise 08.02
    – Multi-module data presentation*:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行应用程序，我们将看到与*练习08.02 – 多模块数据表示*相同的输出：
- en: '![Figure 9.2 – Output of Exercise 09.01'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '![图9.2 – 练习09.01的输出'
- en: '](img/Figure_9.02_B18320_Merged.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_9.02_B18320_Merged.jpg)'
- en: Figure 9.2 – Output of Exercise 09.01
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2 – 练习09.01的输出
- en: After introducing MVI into the exercise, we can see that we already had the
    groundwork because of how Jetpack Compose requires states to manage the user interface.
    This represents one of the reasons we ended up creating the `UiState` class in
    previous chapters. We have also observed the downsides of the pattern through
    the addition of boilerplate code and the handling of one-off events, the latter
    not being limited to MVI. The use of `MviViewModel` shows how we can have the
    same template across different modules of the presentation layer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在将MVI引入练习后，我们可以看到由于Jetpack Compose要求状态来管理用户界面，我们已经有了一定的基础。这代表了我们在前几章中创建`UiState`类的原因之一。我们还通过添加样板代码和处理一次性事件观察到了该模式的缺点，后者不仅限于MVI。`MviViewModel`的使用展示了我们如何在表示层的不同模块中拥有相同的模板。
- en: From a Clean Architecture perspective, we can see that the changes we have done
    in our presentation layer haven't affected the rest of the layers of the application,
    which is a sign that we are going down the right path.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 从纯净架构的角度来看，我们可以看到我们在表示层所做的更改并没有影响到应用程序的其他层，这是一个表明我们正在走正确道路的迹象。
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we studied the MVI architecture pattern and the benefits it
    provides to applications using reactive streams of data, by centralizing user
    and application actions into a unidirectional flow of data.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们研究了MVI架构模式及其为使用反应式数据流的应用程序提供的优势，通过将用户和应用程序操作集中到数据的一个单向流中。
- en: We then looked at how we can implement this pattern using Kotlin flows and the
    role it plays when combined with other patterns, such as MVP and MVVM, with a
    focus on MVVM. We can observe the downsides of the pattern on simple presentations,
    but its benefits become more visible in applications with complicated user interfaces
    that take in multiple user inputs, which can change the states of other inputs.
    In the chapter's exercise, we looked at how we can transition an application with
    MVVM to MVI and how it fits into Clean Architecture.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们探讨了如何使用Kotlin流来实现这种模式，以及它与其他模式（如MVP和MVVM）结合时扮演的角色，重点是MVVM。我们可以在简单的表示中观察到该模式的缺点，但在具有复杂用户界面且接受多个用户输入的应用程序中，这些输入可以改变其他输入的状态，其优势变得更加明显。在章节的练习中，我们探讨了如何将具有MVVM的应用程序过渡到MVI，以及它如何适应纯净架构。
- en: In the next chapter, we will take a step back and look at what we have implemented
    and studied so far. We will see what we can improve and how we can take advantage
    of the different layers of the application, as well as how we can swap dependencies
    for the various configurations an application might have.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将退后一步，回顾到目前为止我们已经实现和研究的成果。我们将看看我们可以如何改进，以及我们如何可以利用应用程序的不同层，以及我们如何为应用程序可能具有的各种配置交换依赖项。
