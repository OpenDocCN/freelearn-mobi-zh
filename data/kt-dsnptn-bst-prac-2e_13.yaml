- en: '*Chapter 10*: Concurrent Microservices with Ktor'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 10 章*：使用 Ktor 的并发微服务'
- en: In the previous chapter, we explored how we should write idiomatic Kotlin code
    that will be readable and maintainable, as well as performant.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们探讨了如何编写符合 Kotlin 习惯的代码，这些代码将易于阅读和维护，同时性能良好。
- en: In this chapter, we'll put the skills we've learned so far to use by building
    a microservice using the **Ktor framework**. We also want this microservice to
    be reactive and to be as close to real life as possible. For that, we'll use the
    Ktor framework, the benefits of which we'll list in the first section of this
    chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将通过构建一个使用 **Ktor 框架**的微服务来运用我们迄今为止学到的技能。我们还想让这个微服务是反应式的，并且尽可能接近现实生活。为此，我们将使用
    Ktor 框架，其优点将在本章的第一节中列出。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: Getting started with Ktor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 Ktor
- en: Routing requests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 路由请求
- en: Testing the service
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试服务
- en: Modularizing the application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序模块化
- en: Connecting to a database
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: Creating new entities
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建新实体
- en: Making the test consistent
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使测试保持一致
- en: Fetching entities
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取实体
- en: Organizing routes in Ktor
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ktor 中组织路由
- en: Achieving concurrency in Ktor
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Ktor 中实现并发
- en: By the end of this chapter, you'll have a microservice written in Kotlin that
    is well tested and can read data from a PostgreSQL database and store data in
    it.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个用 Kotlin 编写的微服务，该服务经过良好测试，可以从 PostgreSQL 数据库中读取数据并将其存储在其中。
- en: Technical requirements
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'This is what you''ll need to get started:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这是您开始所需的：
- en: '**JDK 11** or later'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**JDK 11** 或更高版本'
- en: IntelliJ IDEA
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: '**Gradle 6.8** or later'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gradle 6.8** 或更高版本'
- en: '**PostgreSQL 14** or later'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PostgreSQL 14** 或更高版本'
- en: 'This chapter will assume that you have `PostgreSQL` already installed and that
    you have the basic knowledge for working with it. If you don''t, please refer
    to the official documentation: [https://www.postgresql.org/docs/14/tutorial-install.html](https://www.postgresql.org/docs/14/tutorial-install.html).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将假设您已经安装了 `PostgreSQL`，并且您具备使用它的基本知识。如果您没有，请参阅官方文档：[https://www.postgresql.org/docs/14/tutorial-install.html](https://www.postgresql.org/docs/14/tutorial-install.html)。
- en: 'You can find the source code for this chapter here: [https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10).'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处找到本章的源代码：[https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10](https://github.com/PacktPublishing/Kotlin-Design-Patterns-and-Best-Practices/tree/main/Chapter10)。
- en: Getting started with Ktor
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始使用 Ktor
- en: You're probably tired of creating to-do or shopping lists.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经厌倦了创建待办事项或购物清单。
- en: 'So, instead, in this chapter, the microservice will be for a `cat shelter`.
    The microservice should be able to do the following:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将微服务用于 `猫舍`。该微服务应该能够执行以下操作：
- en: Supply an endpoint we can ping to check whether the service is up and running
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一个端点，我们可以ping它来检查服务是否正在运行
- en: List the cats currently in the shelter
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列出目前在该庇护所中的猫
- en: Provide us with a means to add new cats
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提供一种添加新猫的方法
- en: The framework we'll be using for our microservice in this chapter is called
    **Ktor**. It's a concurrent framework that's developed and maintained by the creators
    of the Kotlin programming language.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们将使用的微服务框架称为 **Ktor**。它是由 Kotlin 编程语言的创建者开发和维护的并发框架。
- en: 'Let''s start by creating a new Kotlin Gradle project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一个新的 Kotlin Gradle 项目：
- en: From your IntelliJ IDEA, select **File** | **New** | **Project** and choose
    **Kotlin** from **New Project** and **Gradle Kotlin** as your **Build System**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的 IntelliJ IDEA 中选择 **文件** | **新建** | **项目**，然后在 **新建项目** 中选择 **Kotlin**，在
    **构建系统** 中选择 **Gradle Kotlin**。
- en: Give your project a descriptive name – `CatsHostel`, in my case – and choose
    **Project JDK** (in this case, we are using **JDK 15**):![Figure 10.1 – Selecting
    the Project JDK type
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的项目起一个描述性的名称 - 例如，我的项目名为 `CatsHostel` - 并选择 **项目 JDK**（在这种情况下，我们使用 **JDK 15**）:![图
    10.1 – 选择项目 JDK 类型
- en: '](img/Figure_10.1_B17816.jpg)'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.1_B17816.jpg)'
- en: Figure 10.1 – Selecting the Project JDK type
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.1 – 选择项目 JDK 类型
- en: On the next screen, select **JUnit 5** as your **Test framework** and set **Target
    JVM version** to **1.8**. Then, click **Finish**:![Figure 10.2 – Selecting Test
    framework and Target JVM version
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一屏上，选择 **JUnit 5** 作为您的 **测试框架**，并将 **目标 JVM 版本** 设置为 **1.8**。然后，点击 **完成**：![图
    10.2 – 选择测试框架和目标 JVM 版本
- en: '](img/Figure_10.2_B17816.jpg)'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_10.2_B17816.jpg)'
- en: Figure 10.2 – Selecting Test framework and Target JVM version
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 10.2 – 选择测试框架和目标 JVM 版本
- en: 'Now, you should see the following structure:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你应该看到以下结构：
- en: '![Figure 10.3 – Project structure'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 10.3 – 项目结构'
- en: '](img/Figure_10.3_B17816.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_10.3_B17816.jpg)'
- en: Figure 10.3 – Project structure
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.3 – 项目结构
- en: Next, let's open `build.gradle.kts`. This file controls how your project is
    built, its dependencies, and the libraries that the project is going to use. Depending
    on the version of your IntelliJ IDEA, the file's contents may differ a bit, but
    the general structure stays the same.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们打开 `build.gradle.kts` 文件。此文件控制项目的构建方式、其依赖项以及项目将要使用的库。根据 IntelliJ IDEA
    的版本，文件的内容可能略有不同，但总体结构保持不变。
- en: 'The `.kts` extension means that the configuration file for our Kotlin project
    is written in Kotlin, or to be precise, in `dependencies` block, which should
    look like this:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`.kts` 扩展名意味着我们的 Kotlin 项目的配置文件是用 Kotlin 编写的，或者更准确地说，是在 `dependencies` 块中，它应该看起来像这样：'
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The preceding code mentions all the libraries that your project will be using.
    The `implementation()` configuration means that the library will be used at all
    times. The `testImplementation()` configuration means that the library will only
    be used during tests.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码提到了项目中将要使用到的所有库。`implementation()` 配置意味着库将始终被使用。`testImplementation()`
    配置意味着库仅在测试期间被使用。
- en: 'Now, let''s take a look at how a library is defined in the following example:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看以下示例中是如何定义库的：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is a regular string that has been separated into three parts, as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个被分成三个部分的常规字符串，如下所示：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `group` and `name` strings identify the library; the `version` configuration
    should be self-explanatory.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`group` 和 `name` 字符串用于标识库；`version` 配置应该是自解释的。'
- en: 'Now, let''s modify the `dependencies` block, as follows:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们修改 `dependencies` 块，如下所示：
- en: '[PRE7]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Since the files with `.kts` extensions are Kotlin files, we can use regular
    Kotlin syntax in them. In this case, we are using values and string interpolation
    to extract the version of our library.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 由于具有 `.kts` 扩展名的文件是 Kotlin 文件，我们可以在其中使用常规的 Kotlin 语法。在这种情况下，我们正在使用值和字符串插值来提取库的版本。
- en: 'The latest version of Ktor to date is **1.6.4**, but when you read this book,
    it will be greater than this. You can find the latest version here: [https://ktor.io/](https://ktor.io/).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，Ktor 的最新版本是 **1.6.4**，但当你阅读这本书时，它将大于这个版本。你可以在以下位置找到最新版本：[https://ktor.io/](https://ktor.io/)。
- en: As a general rule, all Ktor libraries should be the same version and that's
    when the variable becomes useful.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一般规则，所有 Ktor 库应该使用相同的版本，这时变量就变得有用。
- en: 'Tip:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士：
- en: If you have followed the steps from the beginning of this section, you should
    have a file called `server.kt` in the `src/main/kotlin` folder in your project.
    If you don't, create one now.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经遵循了本节开头的步骤，你应该在你的项目中 `src/main/kotlin` 文件夹中有一个名为 `server.kt` 的文件。如果没有，现在就创建一个。
- en: 'Now, let''s add the following content to the `server.kt` file:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下内容添加到 `server.kt` 文件中：
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: That's all the code we need to write to start a web server that will respond
    with `OK` when you open `http://localhost:8080` in your browser.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们启动一个将响应 `OK` 的网络服务器所需编写的所有代码，当你打开浏览器中的 `http://localhost:8080` 时。
- en: 'Now, let''s understand what happens here:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们理解这里发生了什么：
- en: To interact with the request and return a response, we can use the `call` object,
    also known as the **context**. This object provides all the convenient methods
    for parsing requests and returning responses in different formats, and we'll see
    the different methods available for it throughout this chapter.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要与请求交互并返回响应，我们可以使用 `call` 对象，也称为 **上下文**。此对象提供了所有方便的方法来解析请求并以不同格式返回响应，我们将在本章中看到可用于它的不同方法。
- en: The `embeddedServer()` function is an implementation of the Builder pattern,
    which we discussed in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062), *Working
    with Creational Patterns*. It allows us to configure our server. Most of the arguments
    have the same defaults. We override `port` to `8080` just for convenience.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`embeddedServer()` 函数是 Builder 模式的一个实现，我们在 [*第 2 章*](B17816_02_ePub.xhtml#_idTextAnchor062)
    中讨论了这种模式，*使用创建型模式*。它允许我们配置服务器。大多数参数都有相同的默认值。我们仅为了方便将 `port` 覆盖为 `8080`。'
- en: We specify the `wait` argument to be `true` so that our server will wait for
    incoming requests.
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们指定 `wait` 参数为 `true`，这样我们的服务器将等待传入的请求。
- en: The only mandatory argument to the `embeddedServer` function is the server engine.
    In our example, we use `Netty`, which is a very well-known JVM library, but there
    are others as well. The most interesting of them is `CIO`, which was developed
    by JetBrains themselves.
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`embeddedServer` 函数的唯一必需参数是服务器引擎。在我们的例子中，我们使用 `Netty`，这是一个非常著名的 JVM 库，但还有其他库。其中最有趣的是
    `CIO`，它是 JetBrains 自己开发的。'
- en: Now, let's understand what `CIO` and `Netty` are. They are both **Factory**
    patterns that create the actual instance of our server when invoked. This is a
    really interesting combination of different design patterns in one place to create
    a very flexible and extensible architecture.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们了解什么是 `CIO` 和 `Netty`。它们都是 **工厂** 模式，在调用时创建我们服务器的实际实例。这是一个非常有趣的设计模式组合，在一个地方创建一个非常灵活和可扩展的架构。
- en: 'To switch to using `CIO`, all we need to do is add a new dependency:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 要切换到使用 `CIO`，我们只需要添加一个新的依赖项：
- en: '[PRE23]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, we need to pass another server engine, `CIO`, to our `embeddedServer`
    function:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将另一个服务器引擎 `CIO` 传递给 `embeddedServer` 函数：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Notice that we didn't have to change anything else in our code when we switched
    the server engine. That is because `embeddedServer()` uses the Bridge design pattern
    to make components interchangeable.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们切换服务器引擎时，我们不需要更改代码中的其他任何内容。这是因为 `embeddedServer()` 使用桥接设计模式使组件可互换。
- en: Now that our server has been started, let's investigate how we define different
    responses for each request to the server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的服务器已经启动，让我们调查我们如何为每个对服务器的请求定义不同的响应。
- en: Routing requests
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 路由请求
- en: 'Now, let''s take a look at the `routing` block:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看 `routing` 块：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This block describes all the URLs that will be handled by our server. In this
    case, we only handle the root URL. When that URL is requested, a text response,
    `OK`, will be returned to the user.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此块描述了我们的服务器将处理的所有 URL。在这种情况下，我们只处理根 URL。当请求该 URL 时，将向用户返回文本响应 `OK`。
- en: 'The following code returns a text response. Now, let''s see how we can return
    a JSON response instead:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码返回文本响应。现在，让我们看看我们如何返回 JSON 响应：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Instead of using the `respondText()` method, we'll use `respond()`, which receives
    an object instead of a string. In our example, we're passing a map of strings
    to the `respond()` function. If we run this code, though, we'll get an exception.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将不再使用 `respondText()` 方法，而是使用 `respond()`，它接收一个对象而不是字符串。在我们的例子中，我们向 `respond()`
    函数传递一个字符串映射。尽管如此，如果我们运行此代码，我们仍会得到一个异常。
- en: 'This is because, by default, objects are not serialized into JSON. Multiple
    libraries can do this for us. In this example, we''ll use the `kotlinx-serialization`
    library. Let''s start by adding it to our dependencies:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为默认情况下，对象不会被序列化为 JSON。多个库可以为我们完成这项工作。在这个例子中，我们将使用 `kotlinx-serialization`
    库。让我们首先将其添加到我们的依赖项中：
- en: '[PRE39]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Next, we need to add the following lines before our `routing` block:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的 `routing` 块之前添加以下行：
- en: '[PRE44]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, if we run our code again, it will output this on our browser:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们再次运行我们的代码，它将在我们的浏览器上输出以下内容：
- en: '[PRE47]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: We've just created our first route, which returns an object serialized as JSON.
    Now, we can check whether our application works by opening `http://localhost:8080/status`
    in our browser. But that is a bit cumbersome. In the next section, we'll learn
    how to write a test for the `/status` endpoint.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一条返回作为 JSON 序列化对象的第一个路由。现在，我们可以通过在浏览器中打开 `http://localhost:8080/status`
    来检查我们的应用程序是否工作。但这有点麻烦。在下一节中，我们将学习如何为 `/status` 端点编写测试。
- en: Testing the service
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试服务
- en: To write our first test, let's create a new file called `ServerTest.kt` under
    the `src/test/kotlin` directory.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 要编写我们的第一个测试，让我们在 `src/test/kotlin` 目录下创建一个名为 `ServerTest.kt` 的新文件。
- en: 'Now, let''s add a new dependency:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个新的依赖项：
- en: '[PRE48]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Next, let''s add the following contents to our `ServerTest.kt` file:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将以下内容添加到我们的 `ServerTest.kt` 文件中：
- en: '[PRE53]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Tests in Kotlin are grouped into classes, and each test is a method in the class,
    which is marked with the `@Test` annotation.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Kotlin 中的测试被分组到类中，每个测试都是类中的一个方法，该方法带有 `@Test` 注解。
- en: Inside the `test` method, we start a test server, issue a `GET` request to the
    `/status` endpoint, and check that the endpoint responds with a correct status
    code and JSON body.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `test` 方法内部，我们启动一个测试服务器，向 `/status` 端点发出 `GET` 请求，并检查该端点是否以正确的状态码和 JSON 主体响应。
- en: If you run this test now, though, it will fail, because we haven't started our
    server yet. To do so, we'll need to refactor it a bit, which we'll do in the next
    section.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个测试，它将会失败，因为我们还没有启动我们的服务器。为此，我们需要对其进行一些重构，我们将在下一节中这样做。
- en: Modularizing the application
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用程序模块化
- en: So far, our server has been started from the `main()` function. This was simple
    to set up, but this doesn't allow us to test our application.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们的服务器是从`main()`函数启动的。这很简单设置，但这不允许我们测试我们的应用程序。
- en: 'In Ktor, the code is usually organized into modules. Let''s rewrite our `main`
    function, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在Ktor中，代码通常组织成模块。让我们重写我们的`main`函数，如下所示：
- en: '[PRE63]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: '[PRE68]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: Here, instead of providing the logic of our server within a block, we specified
    a module that will contain all the configurations for our server.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们不是在块中提供我们服务器的逻辑，而是指定了一个将包含我们服务器所有配置的模块。
- en: 'This module is defined as an extension function on the `Application` object:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 此模块定义为`Application`对象上的扩展函数：
- en: '[PRE70]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: As you can see, the content of this function is the same as that of the block
    that we passed to our `embeddedService` function earlier.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，此函数的内容与之前传递给我们的`embeddedService`函数的块的内容相同。
- en: 'Now, all we need to do is go back to our test and specify which module we would
    like to test:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要回到我们的测试中，并指定我们想要测试哪个模块：
- en: '[PRE81]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: If you run this test now, it should pass, because our server has started properly
    in test mode.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行这个测试，它应该会通过，因为我们的服务器已经在测试模式下正确启动。
- en: 'So far, we''ve only dealt with the infrastructure of our service; we haven''t
    touched on its business logic: *managing cats*. To do so, we''ll need a database.
    In the next section, we''ll discuss how Ktor solves this problem using the Exposed
    library.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只处理了服务的基础设施；我们没有触及其业务逻辑：*管理猫*。为此，我们需要一个数据库。在下一节中，我们将讨论Ktor如何使用Exposed库解决这个问题。
- en: Connecting to a database
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接到数据库
- en: To store and retrieve cats, we'll need to connect to a database. We'll use PostgreSQL
    for that purpose, although using another SQL database won't be any different.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储和检索猫，我们需要连接到数据库。我们将为此目的使用PostgreSQL，尽管使用其他SQL数据库不会有任何不同。
- en: First, we'll need a new library to connect to the database. We'll use the Exposed
    library, which is also developed by JetBrains.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的库来连接到数据库。我们将使用由JetBrains开发的Exposed库。
- en: 'Let''s add the following dependency to our `build.gradle.kts` file:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在`build.gradle.kts`文件中添加以下依赖项：
- en: '[PRE87]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Once the libraries are in place, we need to connect to them. To do that, let''s
    create a new file called `DB.kt` under `/src/main/kotlin` with the following contents:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦库就位，我们需要连接到它们。为此，让我们在`/src/main/kotlin`下创建一个名为`DB.kt`的新文件，并包含以下内容：
- en: '[PRE92]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: '[PRE93]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: '[PRE94]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: '[PRE95]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE95]'
- en: '[PRE96]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE96]'
- en: '[PRE97]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: '[PRE98]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: '[PRE99]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: '[PRE100]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Since our application needs exactly one instance of a database, the `DB` object
    can use the Singleton pattern, which we discussed in [*Chapter 2*](B17816_02_ePub.xhtml#_idTextAnchor062),
    *Working with Creational Patterns*. For that, we will use the `object` keyword.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的应用程序需要一个数据库的确切实例，`DB`对象可以使用我们之前讨论的Singleton模式，即使用`object`关键字。
- en: Then, for each of the variables that we need to connect to the database, we
    will attempt to read them from our environment. If the `environment` variable
    is not set, we will use a default value using the **Elvis** operator.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，对于我们需要连接到数据库的每个变量，我们将尝试从我们的环境中读取它们。如果`环境`变量未设置，我们将使用**Elvis**运算符来使用默认值。
- en: 'Tip:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 提示：
- en: Creating a database and a user is beyond the scope of this book, but you can
    refer to the official documentation for this, at [https://www.postgresql.org/docs/14/app-createuser.html](https://www.postgresql.org/docs/14/app-createuser.html)
    and [https://www.postgresql.org/docs/14/app-createdb.html](https://www.postgresql.org/docs/14/app-createdb.html).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 创建数据库和用户超出了本书的范围，但你可以参考官方文档，在[https://www.postgresql.org/docs/14/app-createuser.html](https://www.postgresql.org/docs/14/app-createuser.html)和[https://www.postgresql.org/docs/14/app-createdb.html](https://www.postgresql.org/docs/14/app-createdb.html)。
- en: 'Alternatively, you can simply run the following two commands in your command
    line:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以在命令行中简单地运行以下两个命令：
- en: '[PRE101]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: '[PRE102]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The first command creates a database user called `cats_admin` and asks you to
    specify a password for this user. Our application will use this `cats_admin` user
    to interact with the database. The second command creates a database called `cats_db`
    that belongs to the `cats_admin` user. Now that our database has been created,
    all we need to do is create a table that will store our cats in it.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个命令创建了一个名为`cats_admin`的数据库用户，并要求你为该用户指定一个密码。我们的应用程序将使用这个`cats_admin`用户与数据库交互。第二个命令创建了一个名为`cats_db`的数据库，属于`cats_admin`用户。现在我们的数据库已经创建，我们只需要创建一个表来存储我们的猫。
- en: 'For that, let''s define another Singleton object in our `DB.kt` file that will
    represent a table:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，让我们在 `DB.kt` 文件中定义另一个 Singleton 对象，它将代表一个表：
- en: '[PRE103]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: '[PRE104]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: '[PRE105]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '[PRE106]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Let''s understand what the preceding definition means:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们理解一下前面的定义意味着什么：
- en: '`IntIdTable` means that we want to create a table with a primary key of the
    `Int` type.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IntIdTable` 表示我们想要创建一个以 `Int` 类型为主键的表。'
- en: In the body of our object, we define the columns. In addition to the `ID` column,
    we'll have a `name` column that is of the `varchar` type, or in other words, a
    string, and is `20` characters at the most.
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象的体中，我们定义列。除了 `ID` 列之外，我们还将有一个 `name` 列，它是 `varchar` 类型，换句话说，是一个字符串，最多 `20`
    个字符。
- en: The cat's `name` column is also unique, meaning that no two cats can have the
    same name.
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 猫的 `name` 列也是唯一的，这意味着没有两只猫可以拥有相同的名字。
- en: We also have a third column that is of the `integer` type, or `Int` in Kotlin
    terms, and is defaulted to `0`.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们还有一个第三列，它是 `integer` 类型，或者用 Kotlin 的话说，是 `Int` 类型，默认值为 `0`。
- en: 'We''ll also have a `data` class to represent a single cat:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将有一个 `data` 类来表示单个猫：
- en: '[PRE107]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: '[PRE108]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: '[PRE109]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'The only thing that is left for us to do is add the following lines of code
    to our `mainModule()` function:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们剩下要做的唯一一件事是将以下代码行添加到我们的 `mainModule()` 函数中：
- en: '[PRE110]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: '[PRE111]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: '[PRE112]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: '[PRE113]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Each time our application starts, the preceding code will connect to the database.
    Then, it will attempt to create a table that stores our entities. If a table already
    exists, nothing will happen.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们的应用程序启动时，前面的代码将连接到数据库。然后，它将尝试创建一个存储我们实体的表。如果表已经存在，则不会发生任何操作。
- en: Now that we have established a connection to our database, let's examine how
    we can use this connection to store a few cats in it.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经建立了与数据库的连接，让我们看看我们如何使用这个连接在数据库中存储几只猫。
- en: Creating new entities
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建新实体
- en: Our next task is adding the first cat to our virtual shelter.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来的任务是向我们的虚拟收容所添加第一只猫。
- en: 'Following the REST principles, it should be a `POST` request, where the body
    of the request may look something like this:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循 REST 原则，它应该是一个 `POST` 请求，其中请求的体可能看起来像这样：
- en: '[PRE114]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'We''ll start by writing a new test:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先编写一个新的测试：
- en: '[PRE115]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '[PRE116]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: '[PRE117]'
  id: totrans-233
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: '[PRE118]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Backticks are a useful Kotlin feature that allows us to have spaces in the names
    of our functions. This helps us create descriptive test names.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 反引号是 Kotlin 中的一个有用特性，它允许我们在函数的名称中包含空格。这有助于我们创建描述性的测试名称。
- en: 'Next, let''s look at the body of our test:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看我们的测试体：
- en: '[PRE119]'
  id: totrans-237
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: '[PRE120]'
  id: totrans-238
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '[PRE121]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: '[PRE122]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: '[PRE123]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: '[PRE124]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '[PRE125]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: '[PRE126]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: '[PRE127]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: '[PRE128]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '[PRE129]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: '[PRE130]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: '[PRE131]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: '[PRE132]'
  id: totrans-250
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: '[PRE133]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: We discussed the `withTestApplication` and `handleRequest` functions in the
    previous section. This time, we are using a `POST` request. These types of requests
    should have the correct header, so we must set those headers using the `addHeader()`
    function. We must also set the body to the contents discussed previously.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中讨论了 `withTestApplication` 和 `handleRequest` 函数。这次，我们使用了一个 `POST` 请求。这类请求应该有正确的头信息，因此我们必须使用
    `addHeader()` 函数设置这些头信息。我们还必须将体设置为之前讨论的内容。
- en: Finally, we must check whether the response header is set to the `Created` HTTP
    code.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须检查响应头是否设置为 `Created` HTTP 状态码。
- en: If we run this test now, it will fail with an HTTP code of `404` since we haven't
    implemented the `post` `/cats` endpoint yet.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在运行这个测试，它将因为还没有实现 `post` `/cats` 端点而以 `404` HTTP 状态码失败。
- en: 'Let''s go back to our `routing` block and add a new endpoint:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的 `routing` 块并添加一个新的端点：
- en: '[PRE134]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: '[PRE135]'
  id: totrans-257
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: '[PRE136]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: '[PRE137]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'To create a new cat, we''ll need to read the body of the `POST` request. We''ll
    use the `receiveParameters()` function for this:'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个新的猫，我们需要读取 `POST` 请求的体。我们将为此使用 `receiveParameters()` 函数：
- en: '[PRE138]'
  id: totrans-261
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '[PRE139]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '[PRE140]'
  id: totrans-263
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: The `receiveParameters` function returns a case-insensitive map. First, we will
    attempt to fetch the cat's `name` from this map, and if there's no name in the
    request, we will fail the call. This will be handled by Ktor.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '`receiveParameters` 函数返回一个不区分大小写的映射。首先，我们将尝试从这个映射中获取猫的 `name`，如果没有请求中的名字，我们将调用失败。这将由
    Ktor 处理。'
- en: Then, if we didn't receive `age`, we will default it to `0` using the Elvis
    operator.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，如果我们没有收到 `age`，我们将使用 Elvis 操作符将其默认设置为 `0`。
- en: 'Now, we must insert those values into the database:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们必须将这些值插入到数据库中：
- en: '[PRE141]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '[PRE142]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '[PRE143]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: '[PRE144]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: '[PRE145]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: '[PRE146]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Here, we open a `transaction` block to make changes to the database. Then, we
    use the `insert()` method, which is available on every table. Inside the `insert`
    lambda, the `cat` variable refers to the new row we are going to populate. We
    set the name of that row to the value of the `name` parameter and do the same
    for `age`.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们打开一个 `transaction` 块来对数据库进行更改。然后，我们使用 `insert()` 方法，该方法在每个表上都是可用的。在 `insert`
    lambda 中，`cat` 变量指的是我们将要填充的新行。我们将该行的名称设置为 `name` 参数的值，并为 `age` 做同样的操作。
- en: If you run your test now, it should pass. But if you run it again, it will fail.
    That's because the name of a cat in the database is unique. Also, we don't clean
    the database between test runs. So, the first run creates a cat named `Meatloaf`,
    while the second run fails. This is because such a cat already exists.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行测试，它应该会通过。但如果你再次运行它，它将会失败。这是因为数据库中猫的名字是唯一的。此外，我们在测试运行之间没有清理数据库。所以，第一次运行创建了一个名为`Meatloaf`的猫，而第二次运行失败。这是因为这样的猫已经存在。
- en: To make our tests consistent, we need a way to clean our database between runs.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的测试保持一致，我们需要一种方法在运行之间清理我们的数据库。
- en: Making the tests consistent
  id: totrans-276
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使测试保持一致
- en: 'Let''s go back to our test and add the following piece of code:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回到我们的测试并添加以下代码片段：
- en: '[PRE147]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: '[PRE148]'
  id: totrans-279
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: '[PRE149]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: '[PRE150]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: '[PRE151]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: '[PRE152]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: '[PRE153]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: Here, we are using the `@BeforeEach` annotation on a function. As its name suggests,
    this code will run before each test. The function will establish a connection
    to the database and drop the table completely. Then, our application will recreate
    the table.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在一个函数上使用了`@BeforeEach`注解。正如其名所示，这段代码将在每个测试之前运行。该函数将建立与数据库的连接并完全删除表。然后，我们的应用程序将重新创建该表。
- en: Now, our tests should pass consistently. In the next section, we'll learn how
    to fetch a cat from the database using the Exposed library.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的测试应该能够一致地通过。在下一节中，我们将学习如何使用Exposed库从数据库中获取猫。
- en: Fetching entities
  id: totrans-287
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取实体
- en: Following the REST practices, the URL for fetching all cats should be `/cats`,
    while for fetching a single cat, it should be `/cats/123`, where `123` is the
    ID of the cat we are trying to fetch.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 遵循REST实践，获取所有猫的URL应该是`/cats`，而对于获取单个猫，应该是`/cats/123`，其中`123`是我们试图获取的猫的ID。
- en: 'Let''s add two new routes for that:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加两个新的路由来实现这一点：
- en: '[PRE154]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: '[PRE155]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: '[PRE156]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: '[PRE157]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: '[PRE158]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: '[PRE159]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The first route is very similar to the `/status` route we introduced earlier
    in this chapter. But the second round is slightly different: it uses a query parameter
    in the URL. You can recognize query parameters by the curly brackets around their
    name.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个路由与我们在本章早期引入的`/status`路由非常相似。但第二个路由略有不同：它使用URL中的查询参数。你可以通过它们名字周围的括号来识别查询参数。
- en: 'To read a query parameter, we can access the `parameters` map:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 为了读取查询参数，我们可以访问`parameters`映射：
- en: '[PRE160]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'If there is an ID on the URL, we need to try and fetch a cat from the database:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果URL上有ID，我们需要尝试从数据库中获取一只猫：
- en: '[PRE161]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: '[PRE162]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: '[PRE163]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: '[PRE164]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: '[PRE165]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: Here, we open a transaction and use the `select` statement to get a cat with
    an ID equal to what we were provided previously.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们开启一个事务并使用`select`语句获取一个ID等于我们之前提供的ID的猫。
- en: 'If an object was returned, we would convert it into JSON. Otherwise, we would
    return an HTTP code of `404`, `Not Found`:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 如果返回了一个对象，我们会将其转换为JSON。否则，我们会返回HTTP代码`404`，即`Not Found`：
- en: '[PRE166]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: '[PRE167]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: '[PRE168]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: '[PRE169]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: '[PRE170]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: '[PRE171]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: '[PRE172]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: '[PRE173]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: '[PRE174]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: '[PRE175]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: '[PRE176]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'Now, let''s add a test for fetching a single cat as well:'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个用于获取单个猫的测试：
- en: '[PRE177]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: '[PRE178]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: '[PRE179]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '[PRE180]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: '[PRE181]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: '[PRE182]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: '[PRE183]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: '[PRE184]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: '[PRE185]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE185]'
- en: '[PRE186]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE186]'
- en: '[PRE187]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE187]'
- en: '[PRE188]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE188]'
- en: '[PRE189]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE189]'
- en: '[PRE190]'
  id: totrans-332
  prefs: []
  type: TYPE_PRE
  zh: '[PRE190]'
- en: In this test, we create a cat using Exposed. Here, we're using a new method
    called `insertAndGetId`. As its name suggests, it will return the ID of a newly
    created row. Then, we try to fetch that cat using our newly created endpoint.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个测试中，我们使用Exposed创建了一只猫。在这里，我们使用了一个新方法`insertAndGetId`。正如其名所示，它将返回新创建行的ID。然后，我们尝试使用我们新创建的端点获取那只猫。
- en: 'If we try to run this test, though, it will fail with the following exception:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试运行这个测试，它将会因为以下异常而失败：
- en: '[PRE191]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE191]'
- en: 'By default, Ktor doesn''t know how to turn our custom data class into JSON.
    To fix that, we''ll need to add a new plugin to our `build.gradle.kts` file:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Ktor不知道如何将我们的自定义数据类转换为JSON。为了解决这个问题，我们需要在我们的`build.gradle.kts`文件中添加一个新的插件：
- en: '[PRE192]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE192]'
- en: '[PRE193]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE193]'
- en: '[PRE194]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE194]'
- en: '[PRE195]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE195]'
- en: '[PRE196]'
  id: totrans-341
  prefs: []
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'This plugin will create serializers at compile time for any class marked with
    the `@Serializable` annotation. All we need to do now for the test to pass is
    add that annotation to our `Cat` class:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 此插件将为任何带有`@Serializable`注解的类在编译时创建序列化器。为了使测试通过，我们现在需要将此注解添加到我们的`Cat`类中：
- en: '[PRE197]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE197]'
- en: '[PRE198]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE198]'
- en: '[PRE199]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '[PRE200]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: '[PRE202]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE202]'
- en: That's it; now, our test for fetching a cat by its ID should pass.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样；现在，我们通过ID获取猫的测试应该会通过。
- en: 'Finally, we would like to be able to fetch all the cats from the database.
    To do that, we must change our test setup a little:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们希望能够从数据库中获取所有猫。为了做到这一点，我们必须稍微改变我们的测试设置：
- en: '[PRE203]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE203]'
- en: '[PRE204]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE204]'
- en: '[PRE205]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE205]'
- en: '[PRE206]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE206]'
- en: '[PRE207]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE207]'
- en: '[PRE208]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE208]'
- en: '[PRE209]'
  id: totrans-357
  prefs: []
  type: TYPE_PRE
  zh: '[PRE209]'
- en: '[PRE210]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE210]'
- en: '[PRE211]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE211]'
- en: '[PRE212]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE212]'
- en: '[PRE213]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE213]'
- en: '[PRE214]'
  id: totrans-362
  prefs: []
  type: TYPE_PRE
  zh: '[PRE214]'
- en: '[PRE215]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE215]'
- en: '[PRE216]'
  id: totrans-364
  prefs: []
  type: TYPE_PRE
  zh: '[PRE216]'
- en: '[PRE217]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE217]'
- en: '[PRE218]'
  id: totrans-366
  prefs: []
  type: TYPE_PRE
  zh: '[PRE218]'
- en: '[PRE219]'
  id: totrans-367
  prefs: []
  type: TYPE_PRE
  zh: '[PRE219]'
- en: '[PRE220]'
  id: totrans-368
  prefs: []
  type: TYPE_PRE
  zh: '[PRE220]'
- en: Here, we changed the setup of our test to drop the table once all the tests
    have been executed. So, instead of the `@BeforeEach` annotation, which executes
    the function before each test, we use the `@AfterAll` annotation, which executes
    the function after all tests have been executed.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们改变了测试的设置，以便在所有测试执行完毕后删除表。因此，我们使用`@AfterAll`注解，它在所有测试执行完毕后执行函数，而不是在每次测试之前执行的`@BeforeEach`注解。
- en: For this annotation to work, we also need to add the `@TestInstance` annotation
    to our class. The default for that is `PER_METHOD`, but since we want to execute
    multiple tests at once, and then clean up after, we need to set the life cycle
    of our test class to `PER_CLASS`.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这个注释生效，我们还需要在我们的类中添加`@TestInstance`注解。它的默认值是`PER_METHOD`，但由于我们希望一次性执行多个测试并在之后进行清理，我们需要将测试类的生命周期设置为`PER_CLASS`。
- en: 'Next, let''s wrap our test into a nested class, like this:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将我们的测试封装到一个嵌套类中，如下所示：
- en: '[PRE221]'
  id: totrans-372
  prefs: []
  type: TYPE_PRE
  zh: '[PRE221]'
- en: '[PRE222]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE222]'
- en: '[PRE223]'
  id: totrans-374
  prefs: []
  type: TYPE_PRE
  zh: '[PRE223]'
- en: '[PRE224]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE224]'
- en: '[PRE225]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE225]'
- en: '[PRE226]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE226]'
- en: '[PRE227]'
  id: totrans-378
  prefs: []
  type: TYPE_PRE
  zh: '[PRE227]'
- en: Nested test classes are a great way to encapsulate specific test situations.
    In our case, we would like to run two tests when there is a cat in our database
    already.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套测试类是封装特定测试情况的好方法。在我们的例子中，我们希望在数据库中已经存在猫的情况下运行两个测试。
- en: 'Now, let''s add the following setup code to our nested test:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将以下设置代码添加到我们的嵌套测试中：
- en: '[PRE228]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE228]'
- en: '[PRE229]'
  id: totrans-382
  prefs: []
  type: TYPE_PRE
  zh: '[PRE229]'
- en: '[PRE230]'
  id: totrans-383
  prefs: []
  type: TYPE_PRE
  zh: '[PRE230]'
- en: '[PRE231]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE231]'
- en: '[PRE232]'
  id: totrans-385
  prefs: []
  type: TYPE_PRE
  zh: '[PRE232]'
- en: '[PRE233]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE233]'
- en: '[PRE234]'
  id: totrans-387
  prefs: []
  type: TYPE_PRE
  zh: '[PRE234]'
- en: '[PRE235]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE235]'
- en: '[PRE236]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE236]'
- en: '[PRE237]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE237]'
- en: '[PRE238]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE238]'
- en: '[PRE239]'
  id: totrans-392
  prefs: []
  type: TYPE_PRE
  zh: '[PRE239]'
- en: '[PRE240]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE240]'
- en: '[PRE241]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE241]'
- en: '[PRE242]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE242]'
- en: '[PRE243]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE243]'
- en: '[PRE244]'
  id: totrans-397
  prefs: []
  type: TYPE_PRE
  zh: '[PRE244]'
- en: Before we execute each test in this nested class, we will create a cat in the
    database and after each test, we will delete all the cats from our database. Since
    we would like to keep track of the ID of the cat that we create, we will store
    it in a variable.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们执行这个嵌套类中的每个测试之前，我们将在数据库中创建一只猫，并在每个测试之后，我们将从我们的数据库中删除所有猫。由于我们希望跟踪我们创建的猫的 ID，我们将它存储在一个变量中。
- en: 'Now, our test class for fetching a single entity looks like this:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的用于检索单个实体的测试类看起来像这样：
- en: '[PRE245]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE245]'
- en: '[PRE246]'
  id: totrans-401
  prefs: []
  type: TYPE_PRE
  zh: '[PRE246]'
- en: '[PRE247]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE247]'
- en: '[PRE248]'
  id: totrans-403
  prefs: []
  type: TYPE_PRE
  zh: '[PRE248]'
- en: '[PRE249]'
  id: totrans-404
  prefs: []
  type: TYPE_PRE
  zh: '[PRE249]'
- en: '[PRE250]'
  id: totrans-405
  prefs: []
  type: TYPE_PRE
  zh: '[PRE250]'
- en: Notice that we interpolate the cat's ID into our expected response since it
    will change with each test execution.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们如何将猫的 ID 插入到我们期望的响应中，因为每次测试执行时它都会变化。
- en: 'The test for fetching all the cats from the database will look almost the same:'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 从数据库中检索所有猫的测试看起来几乎一样：
- en: '[PRE251]'
  id: totrans-408
  prefs: []
  type: TYPE_PRE
  zh: '[PRE251]'
- en: '[PRE252]'
  id: totrans-409
  prefs: []
  type: TYPE_PRE
  zh: '[PRE252]'
- en: '[PRE253]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE253]'
- en: '[PRE254]'
  id: totrans-411
  prefs: []
  type: TYPE_PRE
  zh: '[PRE254]'
- en: '[PRE255]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE255]'
- en: '[PRE256]'
  id: totrans-413
  prefs: []
  type: TYPE_PRE
  zh: '[PRE256]'
- en: We just don't specify the ID, and the response is wrapped into a JSON array,
    as you can see by the square brackets around it.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是没有指定 ID，并且响应被包装成一个 JSON 数组，正如你通过方括号看到的。
- en: 'Now, all we need to do is implement this new route:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们只需要实现这个新路由：
- en: '[PRE257]'
  id: totrans-416
  prefs: []
  type: TYPE_PRE
  zh: '[PRE257]'
- en: '[PRE258]'
  id: totrans-417
  prefs: []
  type: TYPE_PRE
  zh: '[PRE258]'
- en: '[PRE259]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE259]'
- en: '[PRE260]'
  id: totrans-419
  prefs: []
  type: TYPE_PRE
  zh: '[PRE260]'
- en: '[PRE261]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE261]'
- en: '[PRE262]'
  id: totrans-421
  prefs: []
  type: TYPE_PRE
  zh: '[PRE262]'
- en: '[PRE263]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE263]'
- en: '[PRE264]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE264]'
- en: '[PRE265]'
  id: totrans-424
  prefs: []
  type: TYPE_PRE
  zh: '[PRE265]'
- en: '[PRE266]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE266]'
- en: '[PRE267]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE267]'
- en: '[PRE268]'
  id: totrans-427
  prefs: []
  type: TYPE_PRE
  zh: '[PRE268]'
- en: If you followed the example for fetching a single entity from the database (from
    the beginning of this section), then this example won't be very different for
    you. We use the `selectAll()` function to fetch all the rows from the table. Then,
    we map each row to our `data` class. The only problem that is left for us to solve
    is that our code is quite messy and resides in a single file. It would be better
    if we split all the cat routes into a separate file. We'll do that in the next
    section.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循了从数据库中检索单个实体（从本节开头）的示例，那么这个示例对你来说不会有很大不同。我们使用`selectAll()`函数从表中检索所有行。然后，我们将每一行映射到我们的`data`类。我们剩下要解决的问题是我们代码相当杂乱，并且位于一个单独的文件中。如果我们能将所有猫的路由拆分到一个单独的文件中会更好。我们将在下一节中这样做。
- en: Organizing routes in Ktor
  id: totrans-429
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ktor 中组织路由
- en: In this section, we'll see what the idiomatic approach in Ktor is for structuring
    multiple routes that belong to the same domain.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将看到 Ktor 中结构属于同一域的多个路由的惯用方法。
- en: 'Our current `routing` block looks like this:'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的`routing`块看起来像这样：
- en: '[PRE269]'
  id: totrans-432
  prefs: []
  type: TYPE_PRE
  zh: '[PRE269]'
- en: '[PRE270]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE270]'
- en: '[PRE271]'
  id: totrans-434
  prefs: []
  type: TYPE_PRE
  zh: '[PRE271]'
- en: '[PRE272]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE272]'
- en: '[PRE273]'
  id: totrans-436
  prefs: []
  type: TYPE_PRE
  zh: '[PRE273]'
- en: '[PRE274]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE274]'
- en: '[PRE275]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE275]'
- en: '[PRE276]'
  id: totrans-439
  prefs: []
  type: TYPE_PRE
  zh: '[PRE276]'
- en: '[PRE277]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE277]'
- en: '[PRE278]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE278]'
- en: '[PRE279]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE279]'
- en: '[PRE280]'
  id: totrans-443
  prefs: []
  type: TYPE_PRE
  zh: '[PRE280]'
- en: '[PRE281]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE281]'
- en: '[PRE282]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE282]'
- en: 'It would be good if we could extract all the routes that are related to cats
    into a separate file. Let''s start by replacing all the cat routes with a function:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们能将所有与猫相关的路由提取到一个单独的文件中会更好。让我们首先用函数替换所有猫的路由：
- en: '[PRE283]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE283]'
- en: '[PRE284]'
  id: totrans-448
  prefs: []
  type: TYPE_PRE
  zh: '[PRE284]'
- en: '[PRE285]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE285]'
- en: '[PRE286]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE286]'
- en: '[PRE287]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE287]'
- en: '[PRE288]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE288]'
- en: 'If you are using IntelliJ IDEA, it will even suggest that you generate an extension
    function on the `Routing` class:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用 IntelliJ IDEA，它甚至会建议你在`Routing`类上生成一个扩展函数：
- en: '[PRE289]'
  id: totrans-454
  prefs: []
  type: TYPE_PRE
  zh: '[PRE289]'
- en: '[PRE290]'
  id: totrans-455
  prefs: []
  type: TYPE_PRE
  zh: '[PRE290]'
- en: '[PRE291]'
  id: totrans-456
  prefs: []
  type: TYPE_PRE
  zh: '[PRE291]'
- en: 'Now, we can move all our cat routes to this function:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将所有我们的猫路由移动到这个函数中：
- en: '[PRE292]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE292]'
- en: '[PRE293]'
  id: totrans-459
  prefs: []
  type: TYPE_PRE
  zh: '[PRE293]'
- en: '[PRE294]'
  id: totrans-460
  prefs: []
  type: TYPE_PRE
  zh: '[PRE294]'
- en: '[PRE295]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE295]'
- en: '[PRE296]'
  id: totrans-462
  prefs: []
  type: TYPE_PRE
  zh: '[PRE296]'
- en: '[PRE297]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE297]'
- en: '[PRE298]'
  id: totrans-464
  prefs: []
  type: TYPE_PRE
  zh: '[PRE298]'
- en: '[PRE299]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE299]'
- en: '[PRE300]'
  id: totrans-466
  prefs: []
  type: TYPE_PRE
  zh: '[PRE300]'
- en: '[PRE301]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE301]'
- en: '[PRE302]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE302]'
- en: 'Now, you can see that the `/cats` URL is repeated many times. We can lift it
    using the `route()` block:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以看到 `/cats` URL 被重复多次。我们可以使用`route()`块来提升它：
- en: '![Table 10.1 - Cleaner code after using the route() block'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '![表 10.1 - 使用 route() 块后的更简洁代码'
- en: '](img/Table.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Table.jpg)'
- en: Table 10.1 - Cleaner code after using the route() block
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 表 10.1 - 使用 route() 块后的更简洁代码
- en: Notice how much cleaner our code has become now.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到我们的代码现在变得多么简洁。
- en: Now, there's one last important topic for us to cover. At the beginning of this
    chapter, we mentioned that Ktor is a highly concurrent framework. And in [*Chapter
    6*](B17816_06_ePub.xhtml#_idTextAnchor164), *Threads and Coroutines*, we said
    that concurrency in Kotlin is mainly achieved by using coroutines. But we have
    started a single coroutine in this chapter. We'll look at this in the next section.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们还有一个最后的重要主题需要讨论。在本章的开头，我们提到 Ktor 是一个高度并发的框架。在[*第 6 章*](B17816_06_ePub.xhtml#_idTextAnchor164)“线程和协程”中，我们提到
    Kotlin 中的并发主要通过使用协程来实现。但我们在本章中只启动了一个协程。我们将在下一节中探讨这个问题。
- en: Achieving concurrency in Ktor
  id: totrans-475
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ktor 中实现并发
- en: Looking back at the code we've written in this chapter, you may be under the
    impression that the Ktor code is not concurrent at all. However, this couldn't
    be further from the truth.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾本章中我们编写的代码，你可能会有一种印象，认为 Ktor 的代码根本不是并发的。然而，这离事实相差甚远。
- en: All the Ktor functions we've used in this chapter are based on coroutines and
    the concept of **suspending functions**.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用的所有 Ktor 函数都是基于协程和**挂起函数**的概念。
- en: For every incoming request, Ktor will start a new coroutine that will handle
    it, thanks to the CIO server engine, which is based on coroutines at its core.
    Having a concurrency model that is performant but not obtrusive is a very important
    principle in Ktor.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一个进入的请求，Ktor 将启动一个新的协程来处理它，这得益于其核心基于协程的 CIO 服务器引擎。在 Ktor 中，拥有一个既高效又不会干扰的并发模型是一个非常重要的原则。
- en: In addition, the `routing` blocks we used to specify all our endpoints have
    access to `CoroutineScope`, meaning that we can invoke suspending functions within
    those blocks.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们用来指定所有端点的 `routing` 块可以访问 `CoroutineScope`，这意味着我们可以在这些块中调用挂起函数。
- en: One of the examples for such a suspending function is `call.respond()`, which
    we were using throughout this chapter. Suspending functions provide our application
    with opportunities to context switch, and to execute other code concurrently.
    This means that the same number of resources can serve far more requests than
    they would be able to otherwise. We'll stop here and summarize what we've learned
    about developing applications using Ktor.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 挂起函数的一个例子是 `call.respond()`，我们在这章中一直在使用。挂起函数为我们提供了进行上下文切换和执行其他代码并发的机会。这意味着相同数量的资源可以服务比其他情况下多得多的请求。我们在这里停下来，总结一下我们关于使用
    Ktor 开发应用程序所学到的东西。
- en: Summary
  id: totrans-481
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have built a well-tested service using Kotlin that uses
    the Ktor framework to store entities in the database. We've also discussed how
    the multiple design patterns that we encountered at the beginning of this book,
    such as Factory, Singleton, and Bridge, are used in the Ktor framework to provide
    a flexible structure for our code.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用 Kotlin 构建了一个经过良好测试的服务，该服务使用 Ktor 框架将实体存储在数据库中。我们还讨论了我们在本书开头遇到的多个设计模式，如工厂、单例和桥接模式，如何在
    Ktor 框架中用于为我们提供灵活的代码结构。
- en: Now, you should be able to interact with the database using the Exposed framework.
    We've learned how we can declare, create, and drop tables, how to insert new entities,
    and how to fetch and delete them.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该能够使用 Exposed 框架与数据库进行交互。我们学习了如何声明、创建和删除表，如何插入新实体，以及如何检索和删除它们。
- en: In the next chapter, we'll look at an alternative approach to developing web
    applications, but this time using a Reactive framework called **Vert.x**. This
    will allow us to compare the concurrent and Reactive approaches for developing
    web applications and discuss the tradeoffs of each of the approaches.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨开发 Web 应用的另一种方法，但这次使用的是名为 **Vert.x** 的响应式框架。这将使我们能够比较开发 Web 应用时的并发和响应式方法，并讨论每种方法的权衡。
- en: Questions
  id: totrans-485
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: How are the Ktor applications structured and what are their benefits?
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ktor 应用是如何构建的，它们有哪些好处？
- en: What are plugins in Ktor and what are they used for?
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Ktor 中的插件是什么，它们有什么用途？
- en: What is the main problem that the Exposed library solves?
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Exposed 库解决的主要问题是什么？
